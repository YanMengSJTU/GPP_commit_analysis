diff --git a/compiler/src/it/functional-tests/src/test/java/test/cycle/LongCycleTest.java b/compiler/src/it/functional-tests/src/test/java/test/cycle/LongCycleTest.java
index e50eaee69..b205e9d43 100644
--- a/compiler/src/it/functional-tests/src/test/java/test/cycle/LongCycleTest.java
+++ b/compiler/src/it/functional-tests/src/test/java/test/cycle/LongCycleTest.java
@@ -42,6 +42,6 @@ public void longCycle() {
   @Test
   public void longCycleHasMoreThanOneInitializeMethod() throws NoSuchMethodException {
     DaggerLongCycle_LongCycleComponent.class
-        .getDeclaredMethod("initialize1", DaggerLongCycle_LongCycleComponent.Builder.class);
+        .getDeclaredMethod("initialize2", DaggerLongCycle_LongCycleComponent.Builder.class);
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
index 8d55abccc..f31431bd9 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -27,39 +27,25 @@
 import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
 import com.google.common.collect.Sets;
-import com.google.common.util.concurrent.ListenableFuture;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.FieldSpec;
+import com.squareup.javapoet.MethodSpec;
+import com.squareup.javapoet.TypeName;
+import com.squareup.javapoet.TypeSpec;
 import dagger.internal.DelegateFactory;
-import dagger.internal.Factory;
-import dagger.internal.InstanceFactory;
 import dagger.internal.MapFactory;
 import dagger.internal.MapProviderFactory;
-import dagger.internal.MembersInjectors;
-import dagger.internal.ScopedProvider;
 import dagger.internal.SetFactory;
 import dagger.internal.codegen.ComponentDescriptor.BuilderSpec;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
-import dagger.internal.codegen.writer.ClassName;
-import dagger.internal.codegen.writer.ClassWriter;
-import dagger.internal.codegen.writer.ConstructorWriter;
-import dagger.internal.codegen.writer.FieldWriter;
-import dagger.internal.codegen.writer.JavaWriter;
-import dagger.internal.codegen.writer.MethodWriter;
-import dagger.internal.codegen.writer.ParameterizedTypeName;
-import dagger.internal.codegen.writer.Snippet;
-import dagger.internal.codegen.writer.StringLiteral;
-import dagger.internal.codegen.writer.TypeName;
-import dagger.internal.codegen.writer.TypeNames;
-import dagger.internal.codegen.writer.VoidName;
 import dagger.producers.Produced;
 import dagger.producers.Producer;
-import dagger.producers.internal.MapOfProducedProducer;
 import dagger.producers.internal.MapOfProducerProducer;
 import dagger.producers.internal.MapProducer;
-import dagger.producers.internal.Producers;
 import dagger.producers.internal.SetOfProducedProducer;
 import dagger.producers.internal.SetProducer;
 import java.util.HashMap;
-import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
@@ -81,14 +67,19 @@
 import static com.google.common.base.CaseFormat.UPPER_CAMEL;
 import static com.google.common.base.Preconditions.checkState;
 import static com.google.common.collect.Iterables.getOnlyElement;
+import static com.squareup.javapoet.MethodSpec.constructorBuilder;
+import static com.squareup.javapoet.MethodSpec.methodBuilder;
 import static dagger.internal.codegen.AbstractComponentWriter.InitializationState.DELEGATED;
 import static dagger.internal.codegen.AbstractComponentWriter.InitializationState.INITIALIZED;
 import static dagger.internal.codegen.AbstractComponentWriter.InitializationState.UNINITIALIZED;
+import static dagger.internal.codegen.AnnotationSpecs.SUPPRESS_WARNINGS_UNCHECKED;
+import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
+import static dagger.internal.codegen.CodeBlocks.nullCheck;
 import static dagger.internal.codegen.ContributionBinding.FactoryCreationStrategy.ENUM_INSTANCE;
 import static dagger.internal.codegen.ContributionBinding.Kind.PROVISION;
 import static dagger.internal.codegen.ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD;
+import static dagger.internal.codegen.MapKeys.getMapKeyExpression;
 import static dagger.internal.codegen.FrameworkDependency.frameworkDependenciesForBinding;
-import static dagger.internal.codegen.MapKeys.getMapKeySnippet;
 import static dagger.internal.codegen.MemberSelect.emptyFrameworkMapFactory;
 import static dagger.internal.codegen.MemberSelect.emptySetProvider;
 import static dagger.internal.codegen.MemberSelect.localField;
@@ -96,11 +87,30 @@
 import static dagger.internal.codegen.MemberSelect.staticMethod;
 import static dagger.internal.codegen.MembersInjectionBinding.Strategy.NO_OP;
 import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
-import static dagger.internal.codegen.SourceFiles.generatedClassNameForBinding;
-import static dagger.internal.codegen.SourceFiles.membersInjectorNameForType;
+import static dagger.internal.codegen.SourceFiles.javapoetGeneratedClassNameForBinding;
+import static dagger.internal.codegen.SourceFiles.javapoetMembersInjectorNameForType;
+import static dagger.internal.codegen.TypeNames.DELEGATE_FACTORY;
+import static dagger.internal.codegen.TypeNames.FACTORY;
+import static dagger.internal.codegen.TypeNames.ILLEGAL_STATE_EXCEPTION;
+import static dagger.internal.codegen.TypeNames.INSTANCE_FACTORY;
+import static dagger.internal.codegen.TypeNames.LISTENABLE_FUTURE;
+import static dagger.internal.codegen.TypeNames.MAP_FACTORY;
+import static dagger.internal.codegen.TypeNames.MAP_OF_PRODUCED_PRODUCER;
+import static dagger.internal.codegen.TypeNames.MAP_OF_PRODUCER_PRODUCER;
+import static dagger.internal.codegen.TypeNames.MAP_PRODUCER;
+import static dagger.internal.codegen.TypeNames.MAP_PROVIDER_FACTORY;
+import static dagger.internal.codegen.TypeNames.MEMBERS_INJECTORS;
+import static dagger.internal.codegen.TypeNames.PRODUCER;
+import static dagger.internal.codegen.TypeNames.PRODUCERS;
+import static dagger.internal.codegen.TypeNames.SCOPED_PROVIDER;
+import static dagger.internal.codegen.TypeNames.SET_FACTORY;
+import static dagger.internal.codegen.TypeNames.SET_OF_PRODUCED_PRODUCER;
+import static dagger.internal.codegen.TypeNames.SET_PRODUCER;
+import static dagger.internal.codegen.TypeNames.STRING;
+import static dagger.internal.codegen.TypeNames.UNSUPPORTED_OPERATION_EXCEPTION;
+import static dagger.internal.codegen.TypeNames.providerOf;
+import static dagger.internal.codegen.TypeSpecs.addSupertype;
 import static dagger.internal.codegen.Util.componentCanMakeNewInstances;
-import static dagger.internal.codegen.writer.Snippet.makeParametersSnippet;
-import static dagger.internal.codegen.writer.Snippet.nullCheck;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
@@ -118,24 +128,24 @@
   protected final Types types;
   protected final Key.Factory keyFactory;
   protected final Kind nullableValidationType;
-  protected final Set<JavaWriter> javaWriters = new LinkedHashSet<>();
   protected final ClassName name;
   protected final BindingGraph graph;
   protected final ImmutableMap<ComponentDescriptor, String> subcomponentImplNames;
   private final Map<BindingKey, InitializationState> initializationStates = new HashMap<>();
-  protected ClassWriter componentWriter;
-  private final Map<BindingKey, MemberSelect> memberSelectSnippets = new HashMap<>();
-  protected ConstructorWriter constructorWriter;
+  protected TypeSpec.Builder component;
+  private final UniqueNameSet componentFieldNames = new UniqueNameSet();
+  private final Map<BindingKey, MemberSelect> memberSelects = new HashMap<>();
+  protected final MethodSpec.Builder constructor = constructorBuilder().addModifiers(PRIVATE);
   protected Optional<ClassName> builderName = Optional.absent();
 
   /**
    * For each component requirement, the builder field. This map is empty for subcomponents that do
    * not use a builder.
    */
-  private ImmutableMap<TypeElement, FieldWriter> builderFields = ImmutableMap.of();
+  private ImmutableMap<TypeElement, FieldSpec> builderFields = ImmutableMap.of();
 
   /**
-   * For each component requirement, the snippet for the component field that holds it.
+   * For each component requirement, the member select for the component field that holds it.
    *
    * <p>Fields are written for all requirements for subcomponents that do not use a builder, and for
    * any requirement that is reused from a subcomponent of this component.
@@ -164,55 +174,61 @@ protected final TypeElement componentDefinitionType() {
   }
 
   protected final ClassName componentDefinitionTypeName() {
-    return ClassName.fromTypeElement(componentDefinitionType());
+    return ClassName.get(componentDefinitionType());
   }
 
   /**
-   * Returns an expression snippet that evaluates to an instance of the contribution, looking for
-   * either a builder field or a component field.
+   * Returns an expression that evaluates to an instance of the contribution, looking for either a
+   * builder field or a component field.
    */
-  private Snippet getComponentContributionSnippet(TypeElement contributionType) {
+  private CodeBlock getComponentContributionExpression(TypeElement contributionType) {
     if (builderFields.containsKey(contributionType)) {
-      return Snippet.format("builder.%s", builderFields.get(contributionType).name());
+      return CodeBlocks.format("builder.$N", builderFields.get(contributionType));
     } else {
-      Optional<Snippet> snippet = getOrCreateComponentContributionFieldSnippet(contributionType);
-      checkState(snippet.isPresent(), "no builder or component field for %s", contributionType);
-      return snippet.get();
+      Optional<CodeBlock> codeBlock =
+          getOrCreateComponentContributionFieldExpression(contributionType);
+      checkState(codeBlock.isPresent(), "no builder or component field for %s", contributionType);
+      return codeBlock.get();
     }
   }
 
   /**
-   * Returns a snippet for a component contribution field. Adds a field the first time one is
+   * Returns an expression for a component contribution field. Adds a field the first time one is
    * requested for a contribution type if this component's builder has a field for it.
    */
-  protected Optional<Snippet> getOrCreateComponentContributionFieldSnippet(
+  protected Optional<CodeBlock> getOrCreateComponentContributionFieldExpression(
       TypeElement contributionType) {
     MemberSelect fieldSelect = componentContributionFields.get(contributionType);
     if (fieldSelect == null) {
       if (!builderFields.containsKey(contributionType)) {
         return Optional.absent();
       }
-      FieldWriter componentField =
-          componentWriter.addField(contributionType, simpleVariableName(contributionType));
-      componentField.addModifiers(PRIVATE, FINAL);
-      constructorWriter
-          .body()
-          .addSnippet(
-              "this.%s = builder.%s;",
-              componentField.name(),
-              builderFields.get(contributionType).name());
-      fieldSelect = localField(name, componentField.name());
+      FieldSpec componentField =
+          componentField(ClassName.get(contributionType), simpleVariableName(contributionType))
+              .addModifiers(PRIVATE, FINAL)
+              .build();
+      component.addField(componentField);
+      constructor.addCode(
+          "this.$N = builder.$N;", componentField, builderFields.get(contributionType));
+      fieldSelect = localField(name, componentField.name);
       componentContributionFields.put(contributionType, fieldSelect);
     }
-    return Optional.of(fieldSelect.getSnippetFor(name));
+    return Optional.of(fieldSelect.getExpressionFor(name));
   }
 
-  private Snippet getMemberSelectSnippet(BindingKey key) {
-    return getMemberSelect(key).getSnippetFor(name);
+  /**
+   * Creates a {@link FieldSpec.Builder} with a unique name based off of {@code name}.
+   */
+  protected final FieldSpec.Builder componentField(TypeName type, String name) {
+    return FieldSpec.builder(type, componentFieldNames.getUniqueName(name));
+  }
+
+  private CodeBlock getMemberSelectExpression(BindingKey key) {
+    return getMemberSelect(key).getExpressionFor(name);
   }
 
   protected MemberSelect getMemberSelect(BindingKey key) {
-    return memberSelectSnippets.get(key);
+    return memberSelects.get(key);
   }
 
   /**
@@ -228,109 +244,112 @@ private void setInitializationState(BindingKey bindingKey, InitializationState s
     initializationStates.put(bindingKey, state);
   }
 
-  ImmutableSet<JavaWriter> write() {
-    if (javaWriters.isEmpty()) {
-      writeComponent();
-    }
-    return ImmutableSet.copyOf(javaWriters);
-  }
-
-  private void writeComponent() {
-    componentWriter = createComponentClass();
-    addConstructor();
+  /**
+   * Constructs a {@link TypeSpec.Builder} that models the {@link BindingGraph} for this component.
+   * This is only intended to be called once (and will throw on successive invocations). If the
+   * component must be regenerated, use a new instance.
+   */
+  final TypeSpec.Builder write() {
+    checkState(component == null, "ComponentWriter has already been generated.");
+    component = createComponentClass();
     addBuilder();
     addFactoryMethods();
     addFields();
     initializeFrameworkTypes();
     implementInterfaceMethods();
     addSubcomponents();
+    component.addMethod(constructor.build());
+    return component;
   }
 
   /**
    * Creates the component implementation class.
    */
-  protected abstract ClassWriter createComponentClass();
-
-  private void addConstructor() {
-    constructorWriter = componentWriter.addConstructor();
-    constructorWriter.addModifiers(PRIVATE);
-  }
+  protected abstract TypeSpec.Builder createComponentClass();
 
   /**
    * Adds a builder type.
    */
   protected void addBuilder() {
-    ClassWriter builderWriter = createBuilder();
-    builderWriter.addModifiers(FINAL);
-    builderWriter.addConstructor().addModifiers(PRIVATE);
-    builderName = Optional.of(builderWriter.name());
+    builderName = Optional.of(builderName());
+    TypeSpec.Builder componentBuilder =
+        createBuilder(builderName.get().simpleName()).addModifiers(FINAL);
 
     Optional<BuilderSpec> builderSpec = graph.componentDescriptor().builderSpec();
     if (builderSpec.isPresent()) {
-      builderWriter.addModifiers(PRIVATE);
-      builderWriter.setSupertype(builderSpec.get().builderDefinitionType());
+      componentBuilder.addModifiers(PRIVATE);
+      addSupertype(componentBuilder, builderSpec.get().builderDefinitionType());
     } else {
-      builderWriter.addModifiers(PUBLIC);
+      componentBuilder
+          .addModifiers(PUBLIC)
+          .addMethod(constructorBuilder().addModifiers(PRIVATE).build());
     }
 
-    builderFields = addBuilderFields(builderWriter);
-    addBuildMethod(builderWriter, builderSpec);
-    addBuilderMethods(builderWriter, builderSpec);
+    builderFields = addBuilderFields(componentBuilder);
+    addBuildMethod(componentBuilder, builderSpec);
+    addBuilderMethods(componentBuilder, builderSpec);
+    addBuilderClass(componentBuilder.build());
 
-    constructorWriter.addParameter(builderWriter, "builder");
-    constructorWriter.body().addSnippet("assert builder != null;");
+    constructor.addParameter(builderName.get(), "builder");
+    constructor.addStatement("assert builder != null");
   }
 
+  /**
+   * Adds {@code builder} as a nested builder class. Root components and subcomponents will nest
+   * this in different classes.
+   */
+  protected abstract void addBuilderClass(TypeSpec builder);
+
   /**
    * Adds fields for each of the {@linkplain BindingGraph#componentRequirements component
    * requirements}. Regardless of builder spec, there is always one field per requirement.
    */
-  private ImmutableMap<TypeElement, FieldWriter> addBuilderFields(ClassWriter builderWriter) {
-    ImmutableMap.Builder<TypeElement, FieldWriter> builderFieldsBuilder = ImmutableMap.builder();
+  private ImmutableMap<TypeElement, FieldSpec> addBuilderFields(TypeSpec.Builder componentBuilder) {
+    UniqueNameSet builderFieldNames = new UniqueNameSet();
+    ImmutableMap.Builder<TypeElement, FieldSpec> builderFields = ImmutableMap.builder();
     for (TypeElement contributionElement : graph.componentRequirements()) {
-      String contributionName = simpleVariableName(contributionElement);
-      FieldWriter builderField = builderWriter.addField(contributionElement, contributionName);
-      builderField.addModifiers(PRIVATE);
-      builderFieldsBuilder.put(contributionElement, builderField);
+      String contributionName =
+          builderFieldNames.getUniqueName(simpleVariableName(contributionElement));
+      FieldSpec builderField =
+          FieldSpec.builder(ClassName.get(contributionElement), contributionName, PRIVATE).build();
+      componentBuilder.addField(builderField);
+      builderFields.put(contributionElement, builderField);
     }
-    return builderFieldsBuilder.build();
+    return builderFields.build();
   }
 
   /** Adds the build method to the builder. */
-  private void addBuildMethod(ClassWriter builderWriter, Optional<BuilderSpec> builderSpec) {
-    MethodWriter buildMethod;
+  private void addBuildMethod(
+      TypeSpec.Builder componentBuilder, Optional<BuilderSpec> builderSpec) {
+    MethodSpec.Builder buildMethod;
     if (builderSpec.isPresent()) {
       ExecutableElement specBuildMethod = builderSpec.get().buildMethod();
       // Note: we don't use the specBuildMethod.getReturnType() as the return type
       // because it might be a type variable.  We make use of covariant returns to allow
       // us to return the component type, which will always be valid.
       buildMethod =
-          builderWriter.addMethod(
-              componentDefinitionTypeName(), specBuildMethod.getSimpleName().toString());
-      buildMethod.annotate(Override.class);
+          methodBuilder(specBuildMethod.getSimpleName().toString()).addAnnotation(Override.class);
     } else {
-      buildMethod = builderWriter.addMethod(componentDefinitionTypeName(), "build");
+      buildMethod = methodBuilder("build");
     }
-    buildMethod.addModifiers(PUBLIC);
+    buildMethod.returns(componentDefinitionTypeName()).addModifiers(PUBLIC);
 
-    for (Map.Entry<TypeElement, FieldWriter> builderFieldEntry : builderFields.entrySet()) {
-      FieldWriter builderField = builderFieldEntry.getValue();
+    for (Map.Entry<TypeElement, FieldSpec> builderFieldEntry : builderFields.entrySet()) {
+      FieldSpec builderField = builderFieldEntry.getValue();
       if (componentCanMakeNewInstances(builderFieldEntry.getKey())) {
-        buildMethod.body()
-            .addSnippet("if (%1$s == null) { this.%1$s = new %2$s(); }",
-                builderField.name(),
-                builderField.type());
+        buildMethod.addCode(
+            "if ($1N == null) { this.$1N = new $2T(); }", builderField, builderField.type);
       } else {
-        buildMethod.body()
-            .addSnippet(
-                "if (%s == null) { throw new %s(%s.class.getCanonicalName() + \" must be set\"); }",
-                builderField.name(),
-                ClassName.fromClass(IllegalStateException.class),
-                builderField.type());
+        buildMethod.addCode(
+            "if ($N == null) { throw new $T($T.class.getCanonicalName() + $S); }",
+            builderField,
+            ILLEGAL_STATE_EXCEPTION,
+            builderField.type,
+            " must be set");
       }
     }
-
-    buildMethod.body().addSnippet("return new %s(this);", name);
+    buildMethod.addStatement("return new $T(this)", name);
+    componentBuilder.addMethod(buildMethod.build());
   }
 
   /**
@@ -338,92 +357,90 @@ private void addBuildMethod(ClassWriter builderWriter, Optional<BuilderSpec> bui
    * present, it will tailor the methods to match the spec.
    */
   private void addBuilderMethods(
-      ClassWriter builderWriter,
-      Optional<BuilderSpec> builderSpec) {
+      TypeSpec.Builder componentBuilder, Optional<BuilderSpec> builderSpec) {
     if (builderSpec.isPresent()) {
+      UniqueNameSet parameterNames = new UniqueNameSet();
       for (Map.Entry<TypeElement, ExecutableElement> builderMethodEntry :
           builderSpec.get().methodMap().entrySet()) {
         TypeElement builderMethodType = builderMethodEntry.getKey();
         ExecutableElement specMethod = builderMethodEntry.getValue();
-        MethodWriter builderMethod = addBuilderMethodFromSpec(builderWriter, specMethod);
+        MethodSpec.Builder builderMethod = addBuilderMethodFromSpec(specMethod);
         String parameterName =
-            Iterables.getOnlyElement(specMethod.getParameters()).getSimpleName().toString();
-        builderMethod.addParameter(builderMethodType, parameterName);
-        builderMethod.body().addSnippet(nullCheck(parameterName));
+            parameterNames.getUniqueName(
+                Iterables.getOnlyElement(specMethod.getParameters()).getSimpleName());
+        builderMethod.addParameter(ClassName.get(builderMethodType), parameterName);
+        builderMethod.addCode(nullCheck(parameterName));
         if (graph.componentRequirements().contains(builderMethodType)) {
           // required type
-          builderMethod.body().addSnippet("this.%s = %s;",
-              builderFields.get(builderMethodType).name(),
-              parameterName);
+          builderMethod.addStatement(
+              "this.$N = $L", builderFields.get(builderMethodType), parameterName);
           addBuilderMethodReturnStatementForSpec(specMethod, builderMethod);
         } else if (graph.ownedModuleTypes().contains(builderMethodType)) {
           // owned, but not required
-          builderMethod.body()
-              .addSnippet("// This module is declared, but not used in the component. "
-                  + "This method is a no-op");
+          builderMethod.addCode(
+              "// This module is declared, but not used in the component. This method is a "
+                  + "no-op\n");
           addBuilderMethodReturnStatementForSpec(specMethod, builderMethod);
         } else {
           // neither owned nor required, so it must be an inherited module
-          builderMethod
-              .body()
-              .addSnippet(
-                  "throw new %s(%s.format(%s, %s.class.getCanonicalName()));",
-                  ClassName.fromClass(UnsupportedOperationException.class),
-                  ClassName.fromClass(String.class),
-                  StringLiteral.forValue(
-                      "%s cannot be set because it is inherited from the enclosing component"),
-                  ClassName.fromTypeElement(builderMethodType));
+          builderMethod.addStatement(
+              "throw new $T($T.format($S, $T.class.getCanonicalName()))",
+              UNSUPPORTED_OPERATION_EXCEPTION,
+              STRING,
+              "%s cannot be set because it is inherited from the enclosing component",
+              ClassName.get(builderMethodType));
         }
+        componentBuilder.addMethod(builderMethod.build());
       }
     } else {
       for (TypeElement componentRequirement : graph.availableDependencies()) {
         String componentRequirementName = simpleVariableName(componentRequirement);
-        MethodWriter builderMethod = builderWriter.addMethod(
-            builderWriter.name(),
-            componentRequirementName);
-        builderMethod.addModifiers(PUBLIC);
-        builderMethod.addParameter(componentRequirement, componentRequirementName);
-        builderMethod.body().addSnippet(nullCheck(componentRequirementName));
+        MethodSpec.Builder builderMethod =
+            methodBuilder(componentRequirementName)
+                .returns(builderName.get())
+                .addModifiers(PUBLIC)
+                .addParameter(ClassName.get(componentRequirement), componentRequirementName)
+                .addCode(nullCheck(componentRequirementName));
         if (graph.componentRequirements().contains(componentRequirement)) {
-          builderMethod.body()
-              .addSnippet("this.%s = %s;",
-                  builderFields.get(componentRequirement).name(),
-                  componentRequirementName);
+          builderMethod.addStatement(
+              "this.$N = $L", builderFields.get(componentRequirement), componentRequirementName);
         } else {
-          builderMethod.annotate(Deprecated.class);
+          builderMethod.addAnnotation(Deprecated.class);
         }
-        builderMethod.body().addSnippet("return this;");
+        builderMethod.addStatement("return this");
+        componentBuilder.addMethod(builderMethod.build());
       }
     }
   }
 
   private void addBuilderMethodReturnStatementForSpec(
-      ExecutableElement specMethod, MethodWriter builderMethod) {
+      ExecutableElement specMethod, MethodSpec.Builder builderMethod) {
     if (!specMethod.getReturnType().getKind().equals(VOID)) {
-      builderMethod.body().addSnippet("return this;");
+      builderMethod.addStatement("return this");
     }
   }
 
-  private MethodWriter addBuilderMethodFromSpec(
-      ClassWriter builderWriter, ExecutableElement method) {
-    String methodName = method.getSimpleName().toString();
+  private MethodSpec.Builder addBuilderMethodFromSpec(ExecutableElement method) {
     TypeMirror returnType = method.getReturnType();
+    MethodSpec.Builder builderMethod =
+        methodBuilder(method.getSimpleName().toString())
+            .addAnnotation(Override.class)
+            .addModifiers(Sets.difference(method.getModifiers(), ImmutableSet.of(ABSTRACT)));
     // If the return type is void, we add a method with the void return type.
-    // Otherwise we use the builderWriter and take advantage of covariant returns
+    // Otherwise we use the generated builder name and take advantage of covariant returns
     // (so that we don't have to worry about setter methods that return type variables).
-    MethodWriter builderMethod =
-        returnType.getKind().equals(TypeKind.VOID)
-            ? builderWriter.addMethod(returnType, methodName)
-            : builderWriter.addMethod(builderWriter, methodName);
-    builderMethod.annotate(Override.class);
-    builderMethod.addModifiers(Sets.difference(method.getModifiers(), ImmutableSet.of(ABSTRACT)));
+    if (!returnType.getKind().equals(TypeKind.VOID)) {
+      builderMethod.returns(builderName.get());
+    }
     return builderMethod;
   }
 
   /**
    * Creates the builder class.
    */
-  protected abstract ClassWriter createBuilder();
+  protected abstract TypeSpec.Builder createBuilder(String builderName);
+
+  protected abstract ClassName builderName();
 
   /**
    * Adds component factory methods.
@@ -443,7 +460,7 @@ private void addField(ResolvedBindings resolvedBindings) {
     // no field is necessary.
     Optional<MemberSelect> staticMemberSelect = staticMemberSelect(resolvedBindings);
     if (staticMemberSelect.isPresent()) {
-      memberSelectSnippets.put(bindingKey, staticMemberSelect.get());
+      memberSelects.put(bindingKey, staticMemberSelect.get());
       return;
     }
 
@@ -452,29 +469,31 @@ private void addField(ResolvedBindings resolvedBindings) {
       return;
     }
 
-    FieldWriter frameworkField = addFrameworkField(resolvedBindings);
-
-    memberSelectSnippets.put(
+    FieldSpec frameworkField = addFrameworkField(resolvedBindings);
+    memberSelects.put(
         bindingKey,
-        localField(name, frameworkField.name()));
+        localField(name, frameworkField.name));
   }
 
-  private FieldWriter addFrameworkField(ResolvedBindings resolvedBindings) {
+  private FieldSpec addFrameworkField(ResolvedBindings resolvedBindings) {
     boolean useRawType = useRawType(resolvedBindings);
 
     FrameworkField contributionBindingField =
         FrameworkField.createForResolvedBindings(resolvedBindings);
-    FieldWriter contributionField =
-        componentWriter.addField(
+    FieldSpec.Builder contributionField =
+        componentField(
             useRawType
-                ? contributionBindingField.frameworkType().type()
+                ? contributionBindingField.frameworkType().rawType
                 : contributionBindingField.frameworkType(),
             contributionBindingField.name());
     contributionField.addModifiers(PRIVATE);
     if (useRawType) {
-      contributionField.annotate(SuppressWarnings.class).setValue("rawtypes");
+      contributionField.addAnnotation(AnnotationSpecs.SUPPRESS_WARNINGS_RAWTYPES);
     }
-    return contributionField;
+
+    FieldSpec field = contributionField.build();
+    component.addField(field);
+    return field;
   }
 
   private boolean useRawType(ResolvedBindings resolvedBindings) {
@@ -485,7 +504,7 @@ private boolean useRawType(ResolvedBindings resolvedBindings) {
   /**
    * If {@code resolvedBindings} is an unscoped provision binding with no factory arguments or a
    * no-op members injection binding, then we don't need a field to hold its factory. In that case,
-   * this method returns the static member select snippet that returns the factory or no-op members
+   * this method returns the static member select that returns the factory or no-op members
    * injector.
    */
   private Optional<MemberSelect> staticMemberSelect(ResolvedBindings resolvedBindings) {
@@ -512,8 +531,8 @@ private boolean useRawType(ResolvedBindings resolvedBindings) {
             default:
               return Optional.of(
                   staticMethod(
-                      generatedClassNameForBinding(contributionBinding),
-                      Snippet.format("create()")));
+                      javapoetGeneratedClassNameForBinding(contributionBinding),
+                      CodeBlocks.format("create()")));
           }
         }
         break;
@@ -555,13 +574,10 @@ private static MemberSelect emptySetFactoryStaticMemberSelect(BindingType bindin
    */
   private static ClassName setFactoryClassName(BindingType bindingType, Key key) {
     if (bindingType.equals(BindingType.PROVISION)) {
-      return ClassName.fromClass(SetFactory.class);
+      return SET_FACTORY;
     } else {
       SetType setType = SetType.from(key.type());
-      return ClassName.fromClass(
-          setType.elementsAreTypeOf(Produced.class)
-              ? SetOfProducedProducer.class
-              : SetProducer.class);
+      return setType.elementsAreTypeOf(Produced.class) ? SET_OF_PRODUCED_PRODUCER : SET_PRODUCER;
     }
   }
 
@@ -576,14 +592,12 @@ private static ClassName setFactoryClassName(BindingType bindingType, Key key) {
   private static ClassName mapFactoryClassName(ContributionBinding binding) {
     switch (binding.bindingType()) {
       case PRODUCTION:
-        return ClassName.fromClass(
-            MapType.from(binding.key().type()).valuesAreTypeOf(Produced.class)
-                ? MapOfProducedProducer.class
-                : MapProducer.class);
+        return MapType.from(binding.key().type()).valuesAreTypeOf(Produced.class)
+            ? MAP_OF_PRODUCED_PRODUCER : MAP_PRODUCER;
 
       case PROVISION:
       case MEMBERS_INJECTION:
-        return ClassName.fromClass(MapFactory.class);
+        return MAP_FACTORY;
 
       default:
         throw new AssertionError(binding.toString());
@@ -599,10 +613,8 @@ private static ClassName mapFactoryClassName(ContributionBinding binding) {
    * </ul>
    */
   private static ClassName frameworkMapFactoryClassName(BindingType bindingType) {
-    return ClassName.fromClass(
-        bindingType.equals(BindingType.PRODUCTION)
-            ? MapOfProducerProducer.class
-            : MapProviderFactory.class);
+    return bindingType.equals(BindingType.PRODUCTION)
+        ? MAP_OF_PRODUCER_PRODUCER : MAP_PROVIDER_FACTORY;
   }
 
   private void implementInterfaceMethods() {
@@ -619,38 +631,29 @@ private void implementInterfaceMethods() {
             requestElement.getSimpleName().toString(), requestType);
         if (!interfaceMethods.contains(signature)) {
           interfaceMethods.add(signature);
-          MethodWriter interfaceMethod =
-              requestType.getReturnType().getKind().equals(VOID)
-                  ? componentWriter.addMethod(
-                      VoidName.VOID, requestElement.getSimpleName().toString())
-                  : componentWriter.addMethod(
-                      requestType.getReturnType(), requestElement.getSimpleName().toString());
-          interfaceMethod.annotate(Override.class);
-          interfaceMethod.addModifiers(PUBLIC);
+          MethodSpec.Builder interfaceMethod =
+              methodBuilder(requestElement.getSimpleName().toString())
+                  .addAnnotation(Override.class)
+                  .addModifiers(PUBLIC)
+                  .returns(TypeName.get(requestType.getReturnType()));
           BindingKey bindingKey = interfaceRequest.bindingKey();
           MemberSelect memberSelect = getMemberSelect(bindingKey);
-          Snippet memberSelectSnippet = memberSelect.getSnippetFor(name);
+          CodeBlock memberSelectCodeBlock = memberSelect.getExpressionFor(name);
           switch (interfaceRequest.kind()) {
             case MEMBERS_INJECTOR:
               List<? extends VariableElement> parameters = requestElement.getParameters();
               if (parameters.isEmpty()) {
                 // we're returning the framework type
-                interfaceMethod.body().addSnippet("return %s;", memberSelectSnippet);
+                interfaceMethod.addStatement("return $L", memberSelectCodeBlock);
               } else {
-                VariableElement parameter = Iterables.getOnlyElement(parameters);
-                Name parameterName = parameter.getSimpleName();
+                Name parameterName = Iterables.getOnlyElement(parameters).getSimpleName();
                 interfaceMethod.addParameter(
-                    TypeNames.forTypeMirror(
-                        Iterables.getOnlyElement(requestType.getParameterTypes())),
+                    TypeName.get(Iterables.getOnlyElement(requestType.getParameterTypes())),
                     parameterName.toString());
-                interfaceMethod
-                    .body()
-                    .addSnippet(
-                        "%s.injectMembers(%s);",
-                        memberSelectSnippet,
-                        parameterName);
+                interfaceMethod.addStatement(
+                    "$L.injectMembers($L)", memberSelectCodeBlock, parameterName);
                 if (!requestType.getReturnType().getKind().equals(VOID)) {
-                  interfaceMethod.body().addSnippet("return %s;", parameterName);
+                  interfaceMethod.addStatement("return $L", parameterName);
                 }
               }
               break;
@@ -661,14 +664,10 @@ private void implementInterfaceMethods() {
                 // If using a parameterized enum type, then we need to store the factory
                 // in a temporary variable, in order to help javac be able to infer
                 // the generics of the Factory.create methods.
-                TypeName factoryType =
-                    ParameterizedTypeName.create(
-                        Provider.class, TypeNames.forTypeMirror(requestType.getReturnType()));
+                TypeName factoryType = providerOf(TypeName.get(requestType.getReturnType()));
                 interfaceMethod
-                    .body()
-                    .addSnippet(
-                        "%s factory = %s;", factoryType, memberSelectSnippet);
-                interfaceMethod.body().addSnippet("return factory.get();");
+                    .addStatement("$T factory = $L", factoryType, memberSelectCodeBlock)
+                    .addStatement("return factory.get()");
                 break;
               }
               // fall through in the else case.
@@ -677,16 +676,14 @@ private void implementInterfaceMethods() {
             case PRODUCER:
             case PROVIDER:
             case FUTURE:
-              interfaceMethod
-                  .body()
-                  .addSnippet(
-                      "return %s;",
-                      frameworkTypeUsageStatement(
-                          memberSelectSnippet, interfaceRequest.kind()));
+              interfaceMethod.addStatement(
+                  "return $L",
+                  frameworkTypeUsageStatement(memberSelectCodeBlock, interfaceRequest.kind()));
               break;
             default:
               throw new AssertionError();
           }
+          component.addMethod(interfaceMethod.build());
         }
       }
     }
@@ -696,49 +693,51 @@ private void addSubcomponents() {
     for (Map.Entry<ExecutableElement, BindingGraph> subgraphEntry : graph.subgraphs().entrySet()) {
       SubcomponentWriter subcomponent =
           new SubcomponentWriter(this, subgraphEntry.getKey(), subgraphEntry.getValue());
-      javaWriters.addAll(subcomponent.write());
+      component.addType(subcomponent.write().build());
     }
   }
 
-  private static final int SNIPPETS_PER_INITIALIZATION_METHOD = 100;
+  private static final int INITIALIZATIONS_PER_INITIALIZE_METHOD = 100;
 
   private void initializeFrameworkTypes() {
-    ImmutableList.Builder<Snippet> snippetsBuilder = ImmutableList.builder();
+    ImmutableList.Builder<CodeBlock> codeBlocks = ImmutableList.builder();
     for (BindingKey bindingKey : graph.resolvedBindings().keySet()) {
-      snippetsBuilder.addAll(initializeFrameworkType(bindingKey).asSet());
+      codeBlocks.addAll(initializeFrameworkType(bindingKey).asSet());
     }
-    ImmutableList<Snippet> snippets = snippetsBuilder.build();
-
-    List<List<Snippet>> partitions = Lists.partition(snippets, SNIPPETS_PER_INITIALIZATION_METHOD);
-    for (int i = 0; i < partitions.size(); i++) {
-      MethodWriter initializeMethod =
-          componentWriter.addMethod(VoidName.VOID, "initialize" + ((i == 0) ? "" : i));
-      /* TODO(gak): Strictly speaking, we only need the suppression here if we are also initializing
-       * a raw field in this method, but the structure of this code makes it awkward to pass that
-       * bit through.  This will be cleaned up when we no longer separate fields and initilization
-       * as we do now. */
-      initializeMethod.annotate(SuppressWarnings.class).setValue("unchecked");
-      for (Snippet snippet : partitions.get(i)) {
-        initializeMethod.body().addSnippet(snippet);
-      }
-      initializeMethod.addModifiers(PRIVATE);
+    List<List<CodeBlock>> partitions =
+        Lists.partition(codeBlocks.build(), INITIALIZATIONS_PER_INITIALIZE_METHOD);
+
+    UniqueNameSet methodNames = new UniqueNameSet();
+    for (List<CodeBlock> partition : partitions) {
+      String methodName = methodNames.getUniqueName("initialize");
+      MethodSpec.Builder initializeMethod =
+          methodBuilder(methodName)
+              .addModifiers(PRIVATE)
+              /* TODO(gak): Strictly speaking, we only need the suppression here if we are also
+               * initializing a raw field in this method, but the structure of this code makes it
+               * awkward to pass that bit through.  This will be cleaned up when we no longer
+               * separate fields and initilization as we do now. */
+              .addAnnotation(SUPPRESS_WARNINGS_UNCHECKED)
+              .addCode(CodeBlocks.concat(partition));
       if (builderName.isPresent()) {
-        initializeMethod.addParameter(builderName.get(), "builder").addModifiers(FINAL);
-        constructorWriter.body().addSnippet("%s(builder);", initializeMethod.name());
+        initializeMethod.addParameter(builderName.get(), "builder", FINAL);
+        constructor.addStatement("$L(builder)", methodName);
       } else {
-        constructorWriter.body().addSnippet("%s();", initializeMethod.name());
+        constructor.addStatement("$L()", methodName);
       }
+      component.addMethod(initializeMethod.build());
     }
   }
 
   /**
-   * Returns a single snippet representing the initialization of the framework type.
+   * Returns a single code block representing the initialization of the framework type.
    *
-   * <p>Note that this must be a single snippet because initialization snippets can be invoked from
-   * any place in any order.  By requiring a single snippet (often of concatenated snippets) we
-   * ensure that things like local variables always behave as expected by the initialization logic.
+   * <p>Note that this must be a single code block because initialization code blocks can be invoked
+   * from any place in any order.  By requiring a single code block (often of concatenated code
+   * blocks) we ensure that things like local variables always behave as expected by the
+   * initialization logic.
    */
-  private Optional<Snippet> initializeFrameworkType(BindingKey bindingKey) {
+  private Optional<CodeBlock> initializeFrameworkType(BindingKey bindingKey) {
     // If the field is inherited or the member select is static, don't initialize.
     MemberSelect memberSelect = getMemberSelect(bindingKey);
     if (memberSelect.staticMember() || !memberSelect.owningClass().equals(name)) {
@@ -757,20 +756,20 @@ private void initializeFrameworkTypes() {
     }
   }
 
-  private Optional<Snippet> initializeContributionBinding(BindingKey bindingKey) {
+  private Optional<CodeBlock> initializeContributionBinding(BindingKey bindingKey) {
     ContributionBinding binding = graph.resolvedBindings().get(bindingKey).contributionBinding();
     if (binding.factoryCreationStrategy().equals(ENUM_INSTANCE) && !binding.scope().isPresent()) {
       return Optional.absent();
     }
 
     return Optional.of(
-        Snippet.concat(
+        CodeBlocks.concat(
             ImmutableList.of(
                 initializeDelegateFactoriesForUninitializedDependencies(binding),
                 initializeMember(bindingKey, initializeFactoryForContributionBinding(binding)))));
   }
 
-  private Optional<Snippet> initializeMembersInjectionBinding(BindingKey bindingKey) {
+  private Optional<CodeBlock> initializeMembersInjectionBinding(BindingKey bindingKey) {
     MembersInjectionBinding binding =
         graph.resolvedBindings().get(bindingKey).membersInjectionBinding().get();
 
@@ -779,7 +778,7 @@ private void initializeFrameworkTypes() {
     }
 
     return Optional.of(
-        Snippet.concat(
+        CodeBlocks.concat(
             ImmutableList.of(
                 initializeDelegateFactoriesForUninitializedDependencies(binding),
                 initializeMember(bindingKey, initializeMembersInjectorForBinding(binding)))));
@@ -789,8 +788,8 @@ private void initializeFrameworkTypes() {
    * Initializes delegate factories for any dependencies of {@code binding} that are uninitialized
    * because of a dependency cycle.
    */
-  private Snippet initializeDelegateFactoriesForUninitializedDependencies(Binding binding) {
-    ImmutableList.Builder<Snippet> initializationSnippets = ImmutableList.builder();
+  private CodeBlock initializeDelegateFactoriesForUninitializedDependencies(Binding binding) {
+    ImmutableList.Builder<CodeBlock> initializations = ImmutableList.builder();
 
     for (BindingKey dependencyKey :
         FluentIterable.from(binding.implicitDependencies())
@@ -798,66 +797,63 @@ private Snippet initializeDelegateFactoriesForUninitializedDependencies(Binding
             .toSet()) {
       if (!getMemberSelect(dependencyKey).staticMember()
           && getInitializationState(dependencyKey).equals(UNINITIALIZED)) {
-        initializationSnippets.add(
-            Snippet.format(
-                "this.%s = new %s();",
-                getMemberSelectSnippet(dependencyKey),
-                ClassName.fromClass(DelegateFactory.class)));
+        initializations.add(
+            CodeBlocks.format(
+                "this.$L = new $T();", getMemberSelectExpression(dependencyKey), DELEGATE_FACTORY));
         setInitializationState(dependencyKey, DELEGATED);
       }
     }
 
-    return Snippet.concat(initializationSnippets.build());
+    return CodeBlocks.concat(initializations.build());
   }
 
-  private Snippet initializeMember(BindingKey bindingKey, Snippet initializationSnippet) {
-    ImmutableList.Builder<Snippet> initializationSnippets = ImmutableList.builder();
+  private CodeBlock initializeMember(BindingKey bindingKey, CodeBlock initializationCodeBlock) {
+    ImmutableList.Builder<CodeBlock> initializations = ImmutableList.builder();
 
-    Snippet memberSelect = getMemberSelectSnippet(bindingKey);
-    Snippet delegateFactoryVariable = delegateFactoryVariableSnippet(bindingKey);
+    CodeBlock memberSelect = getMemberSelectExpression(bindingKey);
+    CodeBlock delegateFactoryVariable = delegateFactoryVariableExpression(bindingKey);
     if (getInitializationState(bindingKey).equals(DELEGATED)) {
-      initializationSnippets.add(
-          Snippet.format(
-              "%1$s %2$s = (%1$s) %3$s;",
-              ClassName.fromClass(DelegateFactory.class),
-              delegateFactoryVariable,
-              memberSelect));
+      initializations.add(
+          CodeBlocks.format(
+              "$1T $2L = ($1T) $3L;", DELEGATE_FACTORY, delegateFactoryVariable, memberSelect));
     }
-    initializationSnippets.add(
-        Snippet.format("this.%s = %s;", memberSelect, initializationSnippet));
+    initializations.add(
+        CodeBlocks.format("this.$L = $L;", memberSelect, initializationCodeBlock));
     if (getInitializationState(bindingKey).equals(DELEGATED)) {
-      initializationSnippets.add(
-          Snippet.format("%s.setDelegatedProvider(%s);", delegateFactoryVariable, memberSelect));
+      initializations.add(
+          CodeBlocks.format("$L.setDelegatedProvider($L);", delegateFactoryVariable, memberSelect));
     }
     setInitializationState(bindingKey, INITIALIZED);
 
-    return Snippet.concat(initializationSnippets.build());
+    return CodeBlocks.concat(initializations.build());
   }
 
-  private Snippet delegateFactoryVariableSnippet(BindingKey key) {
-    return Snippet.format("%sDelegate", getMemberSelectSnippet(key).toString().replace('.', '_'));
+  private CodeBlock delegateFactoryVariableExpression(BindingKey key) {
+    return CodeBlocks.format(
+        "$LDelegate", getMemberSelectExpression(key).toString().replace('.', '_'));
   }
 
-  private Snippet initializeFactoryForContributionBinding(ContributionBinding binding) {
-    TypeName bindingKeyTypeName = TypeNames.forTypeMirror(binding.key().type());
+  private CodeBlock initializeFactoryForContributionBinding(ContributionBinding binding) {
+    TypeName bindingKeyTypeName = TypeName.get(binding.key().type());
     switch (binding.bindingKind()) {
       case COMPONENT:
-        return Snippet.format(
-            "%s.<%s>create(%s)",
-            ClassName.fromClass(InstanceFactory.class),
+        return CodeBlocks.format(
+            "$T.<$T>create($L)",
+            INSTANCE_FACTORY,
             bindingKeyTypeName,
             bindingKeyTypeName.equals(componentDefinitionTypeName())
                 ? "this"
-                : getComponentContributionSnippet(MoreTypes.asTypeElement(binding.key().type())));
+                : getComponentContributionExpression(
+                    MoreTypes.asTypeElement(binding.key().type())));
 
       case COMPONENT_PROVISION:
         {
           TypeElement bindingTypeElement =
               graph.componentDescriptor().dependencyMethodIndex().get(binding.bindingElement());
           String localFactoryVariable = simpleVariableName(bindingTypeElement);
-          Snippet callFactoryMethodSnippet =
-              Snippet.format(
-                  "%s.%s()",
+          CodeBlock callFactoryMethod =
+              CodeBlocks.format(
+                  "$L.$L()",
                   localFactoryVariable,
                   binding.bindingElement().getSimpleName().toString());
           // TODO(sameb): This throws a very vague NPE right now.  The stack trace doesn't
@@ -866,122 +862,119 @@ private Snippet initializeFactoryForContributionBinding(ContributionBinding bind
           // We can easily include the raw type (no generics) + annotation type (no values),
           // using .class & String.format -- but that wouldn't be the whole story.
           // What should we do?
-          StringLiteral failMsg =
-              StringLiteral.forValue(CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD);
-          Snippet getMethodBody =
+          CodeBlock getMethodBody =
               binding.nullableType().isPresent()
                       || nullableValidationType.equals(Diagnostic.Kind.WARNING)
-                  ? Snippet.format("return %s;", callFactoryMethodSnippet)
-                  : Snippet.format(
+                  ? CodeBlocks.format("return $L;", callFactoryMethod)
+                  : CodeBlocks.format(
                       Joiner.on('\n')
                           .join(
-                              "%s provided = %s;",
+                              "$T provided = $L;",
                               "if (provided == null) {",
-                              "  throw new NullPointerException(%s);",
+                              "  throw new NullPointerException($S);",
                               "}",
                               "return provided;"),
                       bindingKeyTypeName,
-                      callFactoryMethodSnippet,
-                      failMsg);
-          return Snippet.format(
+                      callFactoryMethod,
+                      CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD);
+          return CodeBlocks.format(
               Joiner.on('\n')
                   .join(
-                      "new %1$s<%2$s>() {",
-                      "  private final %5$s %6$s = %3$s;",
-                      "  %4$s@Override public %2$s get() {",
-                      "    %7$s",
+                      "new $1T<$2T>() {",
+                      "  private final $5T $6L = $3L;",
+                      "  $4L@Override public $2T get() {",
+                      "    $7L",
                       "  }",
                       "}"),
-              /* 1 */ ClassName.fromClass(Factory.class),
+              /* 1 */ FACTORY,
               /* 2 */ bindingKeyTypeName,
-              /* 3 */ getComponentContributionSnippet(bindingTypeElement),
-              /* 4 */ nullableSnippet(binding.nullableType()),
-              /* 5 */ TypeNames.forTypeMirror(bindingTypeElement.asType()),
+              /* 3 */ getComponentContributionExpression(bindingTypeElement),
+              /* 4 */ nullableAnnotation(binding.nullableType()),
+              /* 5 */ TypeName.get(bindingTypeElement.asType()),
               /* 6 */ localFactoryVariable,
               /* 7 */ getMethodBody);
         }
 
       case SUBCOMPONENT_BUILDER:
-        return Snippet.format(
+        return CodeBlocks.format(
             Joiner.on('\n')
                 .join(
-                    "new %1$s<%2$s>() {",
-                    "  @Override public %2$s get() {",
-                    "    return %3$s();",
+                    "new $1T<$2T>() {",
+                    "  @Override public $2T get() {",
+                    "    return $3L();",
                     "  }",
                     "}"),
-            /* 1 */ ClassName.fromClass(Factory.class),
+            /* 1 */ FACTORY,
             /* 2 */ bindingKeyTypeName,
             /* 3 */ binding.bindingElement().getSimpleName().toString());
 
       case INJECTION:
       case PROVISION:
         {
-          List<Snippet> parameters =
+          List<CodeBlock> arguments =
               Lists.newArrayListWithCapacity(binding.dependencies().size() + 1);
           if (binding.bindingKind().equals(PROVISION)
               && !binding.bindingElement().getModifiers().contains(STATIC)) {
-            parameters.add(getComponentContributionSnippet(binding.contributedBy().get()));
+            arguments.add(getComponentContributionExpression(binding.contributedBy().get()));
           }
-          parameters.addAll(getDependencyParameterSnippets(binding));
+          arguments.addAll(getDependencyArguments(binding));
 
-          Snippet factorySnippet =
-              Snippet.format(
-                  "%s.create(%s)",
-                  generatedClassNameForBinding(binding),
-                  Snippet.makeParametersSnippet(parameters));
+          CodeBlock factoryCreate =
+              CodeBlocks.format(
+                  "$T.create($L)",
+                  javapoetGeneratedClassNameForBinding(binding),
+                  makeParametersCodeBlock(arguments));
           return binding.scope().isPresent()
-              ? Snippet.format(
-                  "%s.create(%s)", ClassName.fromClass(ScopedProvider.class), factorySnippet)
-              : factorySnippet;
+              ? CodeBlocks.format("$T.create($L)", SCOPED_PROVIDER, factoryCreate)
+              : factoryCreate;
         }
 
       case COMPONENT_PRODUCTION:
         {
           TypeElement bindingTypeElement =
               graph.componentDescriptor().dependencyMethodIndex().get(binding.bindingElement());
-          return Snippet.format(
+          return CodeBlocks.format(
               Joiner.on('\n')
                   .join(
-                      "new %1$s<%2$s>() {",
-                      "  private final %6$s %7$s = %4$s;",
-                      "  @Override public %3$s<%2$s> get() {",
-                      "    return %7$s.%5$s();",
+                      "new $1T<$2T>() {",
+                      "  private final $6T $7L = $4L;",
+                      "  @Override public $3T<$2T> get() {",
+                      "    return $7L.$5L();",
                       "  }",
                       "}"),
-              /* 1 */ ClassName.fromClass(Producer.class),
-              /* 2 */ TypeNames.forTypeMirror(binding.key().type()),
-              /* 3 */ ClassName.fromClass(ListenableFuture.class),
-              /* 4 */ getComponentContributionSnippet(bindingTypeElement),
+              /* 1 */ PRODUCER,
+              /* 2 */ TypeName.get(binding.key().type()),
+              /* 3 */ LISTENABLE_FUTURE,
+              /* 4 */ getComponentContributionExpression(bindingTypeElement),
               /* 5 */ binding.bindingElement().getSimpleName().toString(),
-              /* 6 */ TypeNames.forTypeMirror(bindingTypeElement.asType()),
+              /* 6 */ TypeName.get(bindingTypeElement.asType()),
               /* 7 */ simpleVariableName(bindingTypeElement));
         }
 
       case IMMEDIATE:
       case FUTURE_PRODUCTION:
         {
-          List<Snippet> parameters =
+          List<CodeBlock> arguments =
               Lists.newArrayListWithCapacity(binding.implicitDependencies().size() + 2);
           if (!binding.bindingElement().getModifiers().contains(STATIC)) {
-            parameters.add(getComponentContributionSnippet(binding.bindingTypeElement()));
+            arguments.add(getComponentContributionExpression(binding.bindingTypeElement()));
           }
-          parameters.add(
-              getComponentContributionSnippet(
+          arguments.add(
+              getComponentContributionExpression(
                   graph.componentDescriptor().executorDependency().get()));
-          parameters.addAll(getDependencyParameterSnippets(binding));
+          arguments.addAll(getDependencyArguments(binding));
 
-          return Snippet.format(
-              "new %s(%s)",
-              generatedClassNameForBinding(binding),
-              Snippet.makeParametersSnippet(parameters));
+          return CodeBlocks.format(
+              "new $T($L)",
+              javapoetGeneratedClassNameForBinding(binding),
+              makeParametersCodeBlock(arguments));
         }
 
       case SYNTHETIC_MAP:
-        return Snippet.format(
-            "%s.create(%s)",
+        return CodeBlocks.format(
+            "$T.create($L)",
             mapFactoryClassName(binding),
-            getMemberSelectSnippet(getOnlyElement(binding.dependencies()).bindingKey()));
+            getMemberSelectExpression(getOnlyElement(binding.dependencies()).bindingKey()));
 
       case SYNTHETIC_MULTIBOUND_SET:
         return initializeFactoryForSetMultibinding(binding);
@@ -994,72 +987,72 @@ private Snippet initializeFactoryForContributionBinding(ContributionBinding bind
     }
   }
 
-  private Snippet nullableSnippet(Optional<DeclaredType> nullableType) {
+  private CodeBlock nullableAnnotation(Optional<DeclaredType> nullableType) {
     return nullableType.isPresent()
-        ? Snippet.format("@%s ", TypeNames.forTypeMirror(nullableType.get()))
-        : Snippet.format("");
+        ? CodeBlocks.format("@$T ", TypeName.get(nullableType.get()))
+        : CodeBlocks.format("");
   }
 
-  private Snippet initializeMembersInjectorForBinding(MembersInjectionBinding binding) {
+  private CodeBlock initializeMembersInjectorForBinding(MembersInjectionBinding binding) {
     switch (binding.injectionStrategy()) {
       case NO_OP:
-        return Snippet.format("%s.noOp()", ClassName.fromClass(MembersInjectors.class));
+        return CodeBlocks.format("$T.noOp()", MEMBERS_INJECTORS);
       case INJECT_MEMBERS:
-        return Snippet.format(
-            "%s.create(%s)",
-            membersInjectorNameForType(binding.bindingElement()),
-            makeParametersSnippet(getDependencyParameterSnippets(binding)));
+        return CodeBlocks.format(
+            "$T.create($L)",
+            javapoetMembersInjectorNameForType(binding.bindingElement()),
+            makeParametersCodeBlock(getDependencyArguments(binding)));
       default:
         throw new AssertionError();
     }
   }
 
   /**
-   * The snippets that represent factory arguments for the dependencies of a binding.
+   * The expressions that represent factory arguments for the dependencies of a binding.
    */
-  private ImmutableList<Snippet> getDependencyParameterSnippets(Binding binding) {
-    ImmutableList.Builder<Snippet> parameters = ImmutableList.builder();
+  private ImmutableList<CodeBlock> getDependencyArguments(
+      Binding binding) {
+    ImmutableList.Builder<CodeBlock> parameters = ImmutableList.builder();
     for (FrameworkDependency frameworkDependency : frameworkDependenciesForBinding(binding)) {
-      parameters.add(getDependencySnippet(frameworkDependency));
+      parameters.add(getDependencyArgument(frameworkDependency));
     }
     return parameters.build();
   }
 
   /**
-   * The snippet for a dependency.
+   * The expression to use as an argument for a dependency.
    */
-  private Snippet getDependencySnippet(FrameworkDependency frameworkDependency) {
+  private CodeBlock getDependencyArgument(FrameworkDependency frameworkDependency) {
     BindingKey requestedKey = frameworkDependency.bindingKey();
-    Snippet frameworkSnippet = getMemberSelectSnippet(requestedKey);
+    CodeBlock frameworkExpression = getMemberSelectExpression(requestedKey);
     ResolvedBindings resolvedBindings = graph.resolvedBindings().get(requestedKey);
     if (resolvedBindings.frameworkClass().equals(Provider.class)
         && frameworkDependency.frameworkClass().equals(Producer.class)) {
-      return Snippet.format(
-          "%s.producerFromProvider(%s)", ClassName.fromClass(Producers.class), frameworkSnippet);
+      return CodeBlocks.format("$T.producerFromProvider($L)", PRODUCERS, frameworkExpression);
     } else {
-      return frameworkSnippet;
+      return frameworkExpression;
     }
   }
 
-  private Snippet initializeFactoryForSetMultibinding(ContributionBinding binding) {
-    return Snippet.format(
-        "%s.create(%s)",
+  private CodeBlock initializeFactoryForSetMultibinding(ContributionBinding binding) {
+    return CodeBlocks.format(
+        "$T.create($L)",
         setFactoryClassName(binding.bindingType(), binding.key()),
-        makeParametersSnippet(getDependencyParameterSnippets(binding)));
+        makeParametersCodeBlock(getDependencyArguments(binding)));
   }
 
-  private Snippet initializeFactoryForMapMultibinding(ContributionBinding binding) {
+  private CodeBlock initializeFactoryForMapMultibinding(ContributionBinding binding) {
     ImmutableSet<FrameworkDependency> frameworkDependencies =
         FrameworkDependency.frameworkDependenciesForBinding(binding);
 
-    ImmutableList.Builder<Snippet> snippets = ImmutableList.builder();
+    ImmutableList.Builder<CodeBlock> codeBlocks = ImmutableList.builder();
     MapType mapType = MapType.from(binding.key().type());
-    snippets.add(
-        Snippet.format(
-            "%s.<%s, %s>builder(%d)",
+    codeBlocks.add(
+        CodeBlocks.format(
+            "$T.<$T, $T>builder($L)",
             frameworkMapFactoryClassName(binding.bindingType()),
-            TypeNames.forTypeMirror(mapType.keyType()),
-            TypeNames.forTypeMirror(
+            TypeName.get(mapType.keyType()),
+            TypeName.get(
                 mapType.unwrappedValueType(binding.bindingType().frameworkClass())),
             frameworkDependencies.size()));
 
@@ -1067,16 +1060,15 @@ private Snippet initializeFactoryForMapMultibinding(ContributionBinding binding)
       BindingKey bindingKey = frameworkDependency.bindingKey();
       ContributionBinding contributionBinding =
           graph.resolvedBindings().get(bindingKey).contributionBinding();
-      snippets.add(
-          Snippet.format(
-              ".put(%s, %s)",
-              getMapKeySnippet(contributionBinding.bindingElement()),
-              getDependencySnippet(frameworkDependency)));
+      codeBlocks.add(
+          CodeBlocks.format(
+              ".put($L, $L)",
+              getMapKeyExpression(contributionBinding.bindingElement()),
+              getDependencyArgument(frameworkDependency)));
     }
+    codeBlocks.add(CodeBlocks.format(".build()"));
 
-    snippets.add(Snippet.format(".build()"));
-
-    return Snippet.concat(snippets.build());
+    return CodeBlocks.concat(codeBlocks.build());
   }
 
   private static String simpleVariableName(TypeElement typeElement) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/CodeBlocks.java b/compiler/src/main/java/dagger/internal/codegen/CodeBlocks.java
index 0bb43f65a..e08b12b96 100644
--- a/compiler/src/main/java/dagger/internal/codegen/CodeBlocks.java
+++ b/compiler/src/main/java/dagger/internal/codegen/CodeBlocks.java
@@ -16,6 +16,8 @@
 package dagger.internal.codegen;
 
 import com.google.common.base.Function;
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableList;
 import com.squareup.javapoet.CodeBlock;
 import com.squareup.javapoet.ParameterSpec;
 import java.util.Iterator;
@@ -28,10 +30,21 @@ static CodeBlock format(String format, Object... args) {
     return CodeBlock.builder().add(format, args).build();
   }
 
+  /**
+   * Returns a comma-separated version of {@code codeBlocks} as one unified {@link CodeBlock}.
+   */
   static CodeBlock makeParametersCodeBlock(Iterable<CodeBlock> codeBlocks) {
     return join(codeBlocks, ", ");
   }
 
+  /**
+   * Returns one unified {@link CodeBlock} which joins each item in {@code codeBlocks} with a
+   * newline.
+   */
+  static CodeBlock concat(Iterable<CodeBlock> codeBlocks) {
+    return join(codeBlocks, "\n");
+  }
+
   static CodeBlock join(Iterable<CodeBlock> codeBlocks, String delimiter) {
     CodeBlock.Builder builder = CodeBlock.builder();
     Iterator<CodeBlock> iterator = codeBlocks.iterator();
@@ -44,7 +57,15 @@ static CodeBlock join(Iterable<CodeBlock> codeBlocks, String delimiter) {
     return builder.build();
   }
 
-  static final Function<TypeMirror, CodeBlock> TYPE_MIRROR_TO_CODE_BLOCK =
+  static CodeBlock nullCheck(String thingToCheck) {
+    return format("if ($L == null) { throw new NullPointerException(); } ", thingToCheck);
+  }
+
+  static FluentIterable<CodeBlock> toCodeBlocks(Iterable<? extends TypeMirror> typeMirrors) {
+    return FluentIterable.from(typeMirrors).transform(TYPE_MIRROR_TO_CODE_BLOCK);
+  }
+
+  private static final Function<TypeMirror, CodeBlock> TYPE_MIRROR_TO_CODE_BLOCK =
       new Function<TypeMirror, CodeBlock>() {
         @Override
         public CodeBlock apply(TypeMirror typeMirror) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
index 379a60236..2b47e3baa 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
@@ -15,11 +15,11 @@
  */
 package dagger.internal.codegen;
 
+import com.google.common.base.Joiner;
 import com.google.common.base.Optional;
-import com.google.common.collect.ImmutableSet;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.TypeSpec;
 import dagger.Component;
-import dagger.internal.codegen.writer.ClassName;
-import dagger.internal.codegen.writer.JavaWriter;
 import javax.annotation.processing.Filer;
 import javax.lang.model.element.Element;
 import javax.lang.model.util.Elements;
@@ -32,7 +32,7 @@
  * @author Gregory Kick
  * @since 2.0
  */
-final class ComponentGenerator extends JavaWriterSourceFileGenerator<BindingGraph> {
+final class ComponentGenerator extends JavaPoetSourceFileGenerator<BindingGraph> {
   private final Types types;
   private final Elements elements;
   private final Key.Factory keyFactory;
@@ -54,14 +54,10 @@
   @Override
   ClassName nameGeneratedType(BindingGraph input) {
     ClassName componentDefinitionClassName =
-        ClassName.fromTypeElement(input.componentDescriptor().componentDefinitionType());
-    String componentName = "Dagger" + componentDefinitionClassName.classFileName('_');
-    return componentDefinitionClassName.topLevelClassName().peerNamed(componentName);
-  }
-
-  @Override
-  Iterable<? extends Element> getOriginatingElements(BindingGraph input) {
-    return ImmutableSet.of(input.componentDescriptor().componentDefinitionType());
+        ClassName.get(input.componentDescriptor().componentDefinitionType());
+    String componentName =
+        "Dagger" + Joiner.on('_').join(componentDefinitionClassName.simpleNames());
+    return componentDefinitionClassName.topLevelClassName().peerClass(componentName);
   }
 
   @Override
@@ -70,9 +66,10 @@ ClassName nameGeneratedType(BindingGraph input) {
   }
 
   @Override
-  ImmutableSet<JavaWriter> write(ClassName componentName, BindingGraph input) {
-    return new ComponentWriter(
-            types, elements, keyFactory, nullableValidationType, componentName, input)
-        .write();
+  Optional<TypeSpec.Builder> write(ClassName componentName, BindingGraph input) {
+    return Optional.of(
+        new ComponentWriter(
+                types, elements, keyFactory, nullableValidationType, componentName, input)
+            .write());
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java
index aeab5a746..6a7750fa2 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java
@@ -23,22 +23,23 @@
 import com.google.common.collect.ImmutableListMultimap;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Multimaps;
-import dagger.internal.codegen.writer.ClassName;
-import dagger.internal.codegen.writer.ClassWriter;
-import dagger.internal.codegen.writer.JavaWriter;
-import dagger.internal.codegen.writer.MethodWriter;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.MethodSpec;
+import com.squareup.javapoet.TypeSpec;
 import java.util.Collection;
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.Map.Entry;
-import javax.annotation.Generated;
 import javax.lang.model.element.Name;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 import javax.tools.Diagnostic.Kind;
 
+import static com.squareup.javapoet.MethodSpec.methodBuilder;
+import static com.squareup.javapoet.TypeSpec.classBuilder;
+import static dagger.internal.codegen.TypeSpecs.addSupertype;
 import static dagger.internal.codegen.Util.componentCanMakeNewInstances;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PUBLIC;
@@ -142,58 +143,55 @@ public String apply(ComponentDescriptor componentDescriptor) {
   }
 
   @Override
-  protected ClassWriter createComponentClass() {
-    JavaWriter javaWriter = JavaWriter.inPackage(name.packageName());
-    javaWriters.add(javaWriter);
-
-    ClassWriter componentWriter = javaWriter.addClass(name.simpleName());
-    componentWriter.addModifiers(PUBLIC, FINAL);
-    componentWriter.setSupertype(componentDefinitionType());
-    return componentWriter;
+  protected TypeSpec.Builder createComponentClass() {
+    TypeSpec.Builder component = classBuilder(name.simpleName()).addModifiers(PUBLIC, FINAL);
+    addSupertype(component, componentDefinitionType());
+    return component;
   }
 
   @Override
-  protected ClassWriter createBuilder() {
-    ClassWriter builderWriter = componentWriter.addNestedClass("Builder");
-    builderWriter.addModifiers(STATIC);
+  protected ClassName builderName() {
+    return name.nestedClass("Builder");
+  }
+
+  @Override
+  protected TypeSpec.Builder createBuilder(String builderSimpleName) {
+    TypeSpec.Builder builder = classBuilder(builderSimpleName).addModifiers(STATIC);
 
     // Only top-level components have the factory builder() method.
     // Mirror the user's builder API type if they had one.
-    MethodWriter builderFactoryMethod =
-        graph.componentDescriptor().builderSpec().isPresent()
-            ? componentWriter.addMethod(
-                graph
-                    .componentDescriptor()
-                    .builderSpec()
-                    .get()
-                    .builderDefinitionType()
-                    .asType(),
-                "builder")
-            : componentWriter.addMethod(builderWriter, "builder");
-    builderFactoryMethod.addModifiers(PUBLIC, STATIC);
-    builderFactoryMethod.body().addSnippet("return new %s();", builderWriter.name());
-    return builderWriter;
+    MethodSpec builderFactoryMethod =
+        methodBuilder("builder")
+            .addModifiers(PUBLIC, STATIC)
+            .returns(
+                graph.componentDescriptor().builderSpec().isPresent()
+                    ? ClassName.get(
+                        graph.componentDescriptor().builderSpec().get().builderDefinitionType())
+                    : builderName.get())
+            .addStatement("return new $T()", builderName.get())
+            .build();
+    component.addMethod(builderFactoryMethod);
+    return builder;
+  }
+
+  @Override
+  protected void addBuilderClass(TypeSpec builder) {
+    component.addType(builder);
   }
 
   @Override
   protected void addFactoryMethods() {
     if (canInstantiateAllRequirements()) {
-      MethodWriter factoryMethod =
-          componentWriter.addMethod(componentDefinitionTypeName(), "create");
-      factoryMethod.addModifiers(PUBLIC, STATIC);
-      // TODO(gak): replace this with something that doesn't allocate a builder
-      factoryMethod
-          .body()
-          .addSnippet(
-              "return builder().%s();",
-              graph.componentDescriptor().builderSpec().isPresent()
-                  ? graph
-                      .componentDescriptor()
-                      .builderSpec()
-                      .get()
-                      .buildMethod()
-                      .getSimpleName()
-                  : "build");
+      CharSequence buildMethodName =
+          graph.componentDescriptor().builderSpec().isPresent()
+              ? graph.componentDescriptor().builderSpec().get().buildMethod().getSimpleName()
+              : "build";
+      component.addMethod(
+          methodBuilder("create")
+              .returns(componentDefinitionTypeName())
+              .addModifiers(PUBLIC, STATIC)
+              .addStatement("return builder().$L()", buildMethodName)
+              .build());
     }
   }
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
index 993946571..b38c66908 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
@@ -141,7 +141,7 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
         }
         for (FrameworkField bindingField : fields.values()) {
           addConstructorParameterAndTypeField(
-              bindingField.javapoetFrameworkType(),
+              bindingField.frameworkType(),
               bindingField.name(),
               factoryBuilder,
               constructorBuilder.get());
diff --git a/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java b/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java
index 1cf914e5d..d8d2e37d8 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java
@@ -18,9 +18,9 @@
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
 import com.google.common.base.CaseFormat;
-import dagger.internal.codegen.writer.ClassName;
-import dagger.internal.codegen.writer.ParameterizedTypeName;
-import dagger.internal.codegen.writer.TypeNames;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.ParameterizedTypeName;
+import com.squareup.javapoet.TypeName;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ElementVisitor;
 import javax.lang.model.element.ExecutableElement;
@@ -40,22 +40,16 @@
   static FrameworkField createWithTypeFromKey(Class<?> frameworkClass, Key key, String name) {
     String suffix = frameworkClass.getSimpleName();
     ParameterizedTypeName frameworkType =
-        ParameterizedTypeName.create(
-            ClassName.fromClass(frameworkClass), TypeNames.forTypeMirror(key.type()));
-    com.squareup.javapoet.ParameterizedTypeName javapoetFrameworkType =
-        com.squareup.javapoet.ParameterizedTypeName.get(
-            com.squareup.javapoet.ClassName.get(frameworkClass),
-            com.squareup.javapoet.TypeName.get(key.type()));
+        ParameterizedTypeName.get(ClassName.get(frameworkClass), TypeName.get(key.type()));
     return new AutoValue_FrameworkField(
-        javapoetFrameworkType, frameworkType, name.endsWith(suffix) ? name : name + suffix);
+        frameworkType, name.endsWith(suffix) ? name : name + suffix);
   }
 
   private static FrameworkField createForMapBindingContribution(Key key, String name) {
     TypeMirror type = MapType.from(key.type()).valueType();
     String suffix = MoreTypes.asDeclared(type).asElement().getSimpleName().toString();
     return new AutoValue_FrameworkField(
-        (com.squareup.javapoet.ParameterizedTypeName) com.squareup.javapoet.TypeName.get(type),
-        (ParameterizedTypeName) TypeNames.forTypeMirror(type),
+        (ParameterizedTypeName) TypeName.get(type),
         name.endsWith(suffix) ? name : name + suffix);
   }
 
@@ -106,7 +100,6 @@ public String visitType(TypeElement e, Binding p) {
         }
       };
 
-  abstract com.squareup.javapoet.ParameterizedTypeName javapoetFrameworkType();
   abstract ParameterizedTypeName frameworkType();
   abstract String name();
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java b/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
index ee92a0db3..e7c273047 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
@@ -72,7 +72,8 @@
     private final Deque<B> bindingsRequiringGeneration = new ArrayDeque<>();
     private final Set<Key> materializedBindingKeys = Sets.newLinkedHashSet();
 
-    void generateBindings(SourceFileGenerator<B> generator) throws SourceFileGenerationException {
+    void generateBindings(JavaPoetSourceFileGenerator<B> generator)
+        throws SourceFileGenerationException {
       for (B binding = bindingsRequiringGeneration.poll();
           binding != null;
           binding = bindingsRequiringGeneration.poll()) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/JavaPoetSourceFileGenerator.java b/compiler/src/main/java/dagger/internal/codegen/JavaPoetSourceFileGenerator.java
index 745fe7b79..0c7da456c 100644
--- a/compiler/src/main/java/dagger/internal/codegen/JavaPoetSourceFileGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/JavaPoetSourceFileGenerator.java
@@ -41,12 +41,9 @@
  * from an annotation processor.  Particularly, it makes a best effort to ensure that files that
  * fail to write successfully are deleted.
  *
- * <p>This differs from {@link JavaWriterSourceFileGenerator} only in that it uses JavaPoet for
- * constructing the source code model. It is intended for this to take on all usages of JavaWriter.
- *
  * @param <T> The input type from which source is to be generated.
  */
-abstract class JavaPoetSourceFileGenerator<T> implements SourceFileGenerator<T> {
+abstract class JavaPoetSourceFileGenerator<T> {
   private static final String GENERATED_COMMENTS = "https://google.github.io/dagger";
 
   private static final AnnotationSpec GENERATED =
@@ -63,8 +60,8 @@
     generatedAnnotationAvailable = elements.getTypeElement("javax.annotation.Generated") != null;
   }
 
-  @Override
-  public final void generate(T input) throws SourceFileGenerationException {
+  /** Generates a source file to be compiled for {@code T}. */
+  void generate(T input) throws SourceFileGenerationException {
     ClassName generatedTypeName = nameGeneratedType(input);
     try {
       Optional<TypeSpec.Builder> type = write(generatedTypeName, input);
diff --git a/compiler/src/main/java/dagger/internal/codegen/JavaWriterSourceFileGenerator.java b/compiler/src/main/java/dagger/internal/codegen/JavaWriterSourceFileGenerator.java
deleted file mode 100644
index e43b1a5c5..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/JavaWriterSourceFileGenerator.java
+++ /dev/null
@@ -1,106 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen;
-
-import com.google.common.base.Function;
-import com.google.common.base.Optional;
-import com.google.common.base.Throwables;
-import com.google.common.collect.ImmutableList;
-import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.Iterables;
-import dagger.internal.codegen.writer.ClassName;
-import dagger.internal.codegen.writer.JavaWriter;
-import dagger.internal.codegen.writer.TypeWriter;
-import java.io.IOException;
-import javax.annotation.processing.Filer;
-import javax.lang.model.element.Element;
-import javax.lang.model.util.Elements;
-
-import static com.google.common.base.Preconditions.checkNotNull;
-
-/**
- * A template class that provides a framework for properly handling IO while generating source files
- * from an annotation processor.  Particularly, it makes a best effort to ensure that files that
- * fail to write successfully are deleted.
- *
- * @param <T> The input type from which source is to be generated.
- * @author Gregory Kick
- * @since 2.0
- */
-abstract class JavaWriterSourceFileGenerator<T> implements SourceFileGenerator<T> {
-  private final Filer filer;
-  private final boolean generatedAnnotationAvailable;
-
-  JavaWriterSourceFileGenerator(Filer filer, Elements elements) {
-    this.filer = checkNotNull(filer);
-    generatedAnnotationAvailable = elements.getTypeElement("javax.annotation.Generated") != null;
-  }
-
-  @Override
-  public final void generate(T input) throws SourceFileGenerationException {
-    ClassName generatedTypeName = nameGeneratedType(input);
-    ImmutableSet<Element> originatingElements =
-        ImmutableSet.<Element>copyOf(getOriginatingElements(input));
-    try {
-      ImmutableSet<JavaWriter> writers = write(generatedTypeName, input);
-      for (JavaWriter javaWriter : writers) {
-        javaWriter.markGenerated(generatedAnnotationAvailable);
-        try {
-          javaWriter.file(filer, originatingElements);
-        } catch (IOException e) {
-          throw new SourceFileGenerationException(getNamesForWriters(javaWriter.getTypeWriters()),
-              e, getElementForErrorReporting(input));
-        }
-      }
-    } catch (Exception e) {
-      // if the code above threw a SFGE, use that
-      Throwables.propagateIfPossible(e, SourceFileGenerationException.class);
-      // otherwise, throw a new one
-      throw new SourceFileGenerationException(ImmutableList.<ClassName>of(), e,
-          getElementForErrorReporting(input));
-    }
-  }
-
-  private static Iterable<ClassName> getNamesForWriters(Iterable<TypeWriter> typeWriters) {
-    return Iterables.transform(typeWriters, new Function<TypeWriter, ClassName>() {
-      @Override public ClassName apply(TypeWriter input) {
-        return input.name();
-      }
-    });
-  }
-
-  /**
-   * Implementations should return the {@link ClassName} for the top-level type to be generated.
-   */
-  abstract ClassName nameGeneratedType(T input);
-
-  /**
-   * Implementations should return {@link Element} instances from which the source is to be
-   * generated.
-   */
-  abstract Iterable<? extends Element> getOriginatingElements(T input);
-
-  /**
-   * Returns an optional element to be used for reporting errors. This returns a single element
-   * rather than a collection to reduce output noise.
-   */
-  abstract Optional<? extends Element> getElementForErrorReporting(T input);
-
-  /**
-   * Returns a set of writers to be generated for {@code T} input.
-   */
-  abstract ImmutableSet<JavaWriter> write(ClassName generatedTypeName, T input);
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/MapKeys.java b/compiler/src/main/java/dagger/internal/codegen/MapKeys.java
index 3bfd46916..875d4ef3d 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MapKeys.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MapKeys.java
@@ -20,11 +20,10 @@
 import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
+import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.TypeName;
 import dagger.MapKey;
-import dagger.internal.codegen.writer.ClassName;
-import dagger.internal.codegen.writer.Snippet;
-import dagger.internal.codegen.writer.TypeName;
-import dagger.internal.codegen.writer.TypeNames;
 import java.util.List;
 import java.util.Map;
 import java.util.NoSuchElementException;
@@ -48,12 +47,12 @@
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static com.google.common.collect.Iterables.transform;
+import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
 import static dagger.internal.codegen.SourceFiles.classFileName;
-import static dagger.internal.codegen.writer.Snippet.makeParametersSnippet;
 import static javax.lang.model.util.ElementFilter.methodsIn;
 
 /**
- * Methods for extracting {@link MapKey} annotations and key snippets from binding elements.
+ * Methods for extracting {@link MapKey} annotations and key code blocks from binding elements.
  */
 final class MapKeys {
 
@@ -145,16 +144,7 @@ public DeclaredType visitDeclared(DeclaredType t, Void p) {
   }
 
   /**
-   * Returns the name of the generated class that contains the static {@code create} methods for a
-   * {@link MapKey} annotation type.
-   */
-  public static ClassName getMapKeyCreatorClassName(TypeElement mapKeyType) {
-    ClassName mapKeyTypeName = ClassName.fromTypeElement(mapKeyType);
-    return mapKeyTypeName.topLevelClassName().peerNamed(mapKeyTypeName.classFileName() + "Creator");
-  }
-
-  /**
-   * Returns a snippet for the map key specified by the {@link MapKey} annotation on
+   * Returns a code block for the map key specified by the {@link MapKey} annotation on
    * {@code bindingElement}.
    *
    * @throws IllegalArgumentException if the element is annotated with more than one {@code MapKey}
@@ -162,22 +152,22 @@ public static ClassName getMapKeyCreatorClassName(TypeElement mapKeyType) {
    * @throws IllegalStateException if {@code bindingElement} is not annotated with a {@code MapKey}
    *     annotation
    */
-  static Snippet getMapKeySnippet(Element bindingElement) {
+  static CodeBlock getMapKeyExpression(Element bindingElement) {
     AnnotationMirror mapKey = getMapKey(bindingElement).get();
     ClassName mapKeyCreator =
-        getMapKeyCreatorClassName(MoreTypes.asTypeElement(mapKey.getAnnotationType()));
+        getJavapoetMapKeyCreatorClassName(MoreTypes.asTypeElement(mapKey.getAnnotationType()));
     Optional<? extends AnnotationValue> unwrappedValue = unwrapValue(mapKey);
     if (unwrappedValue.isPresent()) {
-      return new MapKeySnippetExceptArrays(mapKeyCreator)
+      return new MapKeyExpressionExceptArrays(mapKeyCreator)
           .visit(unwrappedValue.get(), unwrappedValue.get());
     } else {
-      return annotationSnippet(mapKey, new MapKeySnippet(mapKeyCreator));
+      return annotationExpression(mapKey, new MapKeyExpression(mapKeyCreator));
     }
   }
 
   /**
-   * Returns a snippet to create the visited value in code. Expects its parameter to be a class with
-   * static creation methods for all nested annotation types.
+   * Returns a code block to create the visited value in code. Expects its parameter to be a class
+   * with static creation methods for all nested annotation types.
    *
    * <p>Note that {@link AnnotationValue#toString()} is the source-code representation of the value
    * <em>when used in an annotation</em>, which is not always the same as the representation needed
@@ -186,141 +176,141 @@ static Snippet getMapKeySnippet(Element bindingElement) {
    * <p>For example, inside an annotation, a nested array of {@code int}s is simply
    * <code>{1, 2, 3}</code>, but in code it would have to be <code> new int[] {1, 2, 3}</code>.
    */
-  private static class MapKeySnippet
-      extends SimpleAnnotationValueVisitor6<Snippet, AnnotationValue> {
+  private static class MapKeyExpression
+      extends SimpleAnnotationValueVisitor6<CodeBlock, AnnotationValue> {
 
     final ClassName mapKeyCreator;
 
-    MapKeySnippet(ClassName mapKeyCreator) {
+    MapKeyExpression(ClassName mapKeyCreator) {
       this.mapKeyCreator = mapKeyCreator;
     }
 
     @Override
-    public Snippet visitEnumConstant(VariableElement c, AnnotationValue p) {
-      return Snippet.format(
-          "%s.%s", TypeNames.forTypeMirror(c.getEnclosingElement().asType()), c.getSimpleName());
+    public CodeBlock visitEnumConstant(VariableElement c, AnnotationValue p) {
+      return CodeBlocks.format(
+          "$T.$L", TypeName.get(c.getEnclosingElement().asType()), c.getSimpleName());
     }
 
     @Override
-    public Snippet visitAnnotation(AnnotationMirror a, AnnotationValue p) {
-      return annotationSnippet(a, this);
+    public CodeBlock visitAnnotation(AnnotationMirror a, AnnotationValue p) {
+      return annotationExpression(a, this);
     }
 
     @Override
-    public Snippet visitType(TypeMirror t, AnnotationValue p) {
-      return Snippet.format("%s.class", TypeNames.forTypeMirror(t));
+    public CodeBlock visitType(TypeMirror t, AnnotationValue p) {
+      return CodeBlocks.format("$T.class", TypeName.get(t));
     }
 
     @Override
-    public Snippet visitString(String s, AnnotationValue p) {
-      return Snippet.format("%s", p);
+    public CodeBlock visitString(String s, AnnotationValue p) {
+      return CodeBlocks.format("$S", s);
     }
 
     @Override
-    public Snippet visitByte(byte b, AnnotationValue p) {
-      return Snippet.format("(byte) %s", b);
+    public CodeBlock visitByte(byte b, AnnotationValue p) {
+      return CodeBlocks.format("(byte) $L", b);
     }
 
     @Override
-    public Snippet visitChar(char c, AnnotationValue p) {
-      return Snippet.format("%s", p);
+    public CodeBlock visitChar(char c, AnnotationValue p) {
+      return CodeBlocks.format("$L", p);
     }
 
     @Override
-    public Snippet visitDouble(double d, AnnotationValue p) {
-      return Snippet.format("%sD", d);
+    public CodeBlock visitDouble(double d, AnnotationValue p) {
+      return CodeBlocks.format("$LD", d);
     }
 
     @Override
-    public Snippet visitFloat(float f, AnnotationValue p) {
-      return Snippet.format("%sF", f);
+    public CodeBlock visitFloat(float f, AnnotationValue p) {
+      return CodeBlocks.format("$LF", f);
     }
 
     @Override
-    public Snippet visitInt(int i, AnnotationValue p) {
-      return Snippet.format("(int) %s", i);
+    public CodeBlock visitInt(int i, AnnotationValue p) {
+      return CodeBlocks.format("(int) $L", i);
     }
 
     @Override
-    public Snippet visitLong(long i, AnnotationValue p) {
-      return Snippet.format("%sL", i);
+    public CodeBlock visitLong(long i, AnnotationValue p) {
+      return CodeBlocks.format("$LL", i);
     }
 
     @Override
-    public Snippet visitShort(short s, AnnotationValue p) {
-      return Snippet.format("(short) %s", s);
+    public CodeBlock visitShort(short s, AnnotationValue p) {
+      return CodeBlocks.format("(short) $L", s);
     }
 
     @Override
-    protected Snippet defaultAction(Object o, AnnotationValue p) {
-      return Snippet.format("%s", o);
+    protected CodeBlock defaultAction(Object o, AnnotationValue p) {
+      return CodeBlocks.format("$L", o);
     }
 
     @Override
-    public Snippet visitArray(List<? extends AnnotationValue> values, AnnotationValue p) {
-      ImmutableList.Builder<Snippet> snippets = ImmutableList.builder();
+    public CodeBlock visitArray(List<? extends AnnotationValue> values, AnnotationValue p) {
+      ImmutableList.Builder<CodeBlock> codeBlocks = ImmutableList.builder();
       for (int i = 0; i < values.size(); i++) {
-        snippets.add(this.visit(values.get(i), p));
+        codeBlocks.add(this.visit(values.get(i), p));
       }
-      return Snippet.format("{%s}", makeParametersSnippet(snippets.build()));
+      return CodeBlocks.format("{$L}", makeParametersCodeBlock(codeBlocks.build()));
     }
   }
 
   /**
-   * Returns a snippet for the visited value. Expects its parameter to be a class with static
+   * Returns a code block for the visited value. Expects its parameter to be a class with static
    * creation methods for all nested annotation types.
    *
    * <p>Throws {@link IllegalArgumentException} if the visited value is an array.
    */
-  private static class MapKeySnippetExceptArrays extends MapKeySnippet {
+  private static class MapKeyExpressionExceptArrays extends MapKeyExpression {
 
-    MapKeySnippetExceptArrays(ClassName mapKeyCreator) {
+    MapKeyExpressionExceptArrays(ClassName mapKeyCreator) {
       super(mapKeyCreator);
     }
 
     @Override
-    public Snippet visitArray(List<? extends AnnotationValue> values, AnnotationValue p) {
+    public CodeBlock visitArray(List<? extends AnnotationValue> values, AnnotationValue p) {
       throw new IllegalArgumentException("Cannot unwrap arrays");
     }
   }
 
   /**
-   * Returns a snippet that calls a static method on {@code mapKeySnippet.mapKeyCreator} to create
-   * an annotation from {@code mapKeyAnnotation}.
+   * Returns a code block that calls a static method on {@code mapKeyCodeBlock.mapKeyCreator} to
+   * create an annotation from {@code mapKeyAnnotation}.
    */
-  private static Snippet annotationSnippet(
-      AnnotationMirror mapKeyAnnotation, final MapKeySnippet mapKeySnippet) {
-    return Snippet.format(
-        "%s.create%s(%s)",
-        mapKeySnippet.mapKeyCreator,
+  private static CodeBlock annotationExpression(
+      AnnotationMirror mapKeyAnnotation, final MapKeyExpression mapKeyExpression) {
+    return CodeBlocks.format(
+        "$T.create$L($L)",
+        mapKeyExpression.mapKeyCreator,
         mapKeyAnnotation.getAnnotationType().asElement().getSimpleName(),
-        makeParametersSnippet(
+        makeParametersCodeBlock(
             transform(
                 getAnnotationValuesWithDefaults(mapKeyAnnotation).entrySet(),
-                new Function<Map.Entry<ExecutableElement, AnnotationValue>, Snippet>() {
+                new Function<Map.Entry<ExecutableElement, AnnotationValue>, CodeBlock>() {
                   @Override
-                  public Snippet apply(Map.Entry<ExecutableElement, AnnotationValue> entry) {
+                  public CodeBlock apply(Map.Entry<ExecutableElement, AnnotationValue> entry) {
                     return ARRAY_LITERAL_PREFIX.visit(
                         entry.getKey().getReturnType(),
-                        mapKeySnippet.visit(entry.getValue(), entry.getValue()));
+                        mapKeyExpression.visit(entry.getValue(), entry.getValue()));
                   }
                 })));
   }
 
   /**
-   * If the visited type is an array, prefixes the parameter snippet with {@code new T[]}, where
+   * If the visited type is an array, prefixes the parameter code block with {@code new T[]}, where
    * {@code T} is the raw array component type.
    */
-  private static final SimpleTypeVisitor6<Snippet, Snippet> ARRAY_LITERAL_PREFIX =
-      new SimpleTypeVisitor6<Snippet, Snippet>() {
+  private static final SimpleTypeVisitor6<CodeBlock, CodeBlock> ARRAY_LITERAL_PREFIX =
+      new SimpleTypeVisitor6<CodeBlock, CodeBlock>() {
 
         @Override
-        public Snippet visitArray(ArrayType t, Snippet p) {
-          return Snippet.format("new %s[] %s", RAW_TYPE_NAME.visit(t.getComponentType()), p);
+        public CodeBlock visitArray(ArrayType t, CodeBlock p) {
+          return CodeBlocks.format("new $T[] $L", RAW_TYPE_NAME.visit(t.getComponentType()), p);
         }
 
         @Override
-        protected Snippet defaultAction(TypeMirror e, Snippet p) {
+        protected CodeBlock defaultAction(TypeMirror e, CodeBlock p) {
           return p;
         }
       };
@@ -333,12 +323,12 @@ protected Snippet defaultAction(TypeMirror e, Snippet p) {
       new SimpleTypeVisitor6<TypeName, Void>() {
         @Override
         public TypeName visitDeclared(DeclaredType t, Void p) {
-          return ClassName.fromTypeElement(MoreTypes.asTypeElement(t));
+          return ClassName.get(MoreTypes.asTypeElement(t));
         }
 
         @Override
         protected TypeName defaultAction(TypeMirror e, Void p) {
-          return TypeNames.forTypeMirror(e);
+          return TypeName.get(e);
         }
       };
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/MemberSelect.java b/compiler/src/main/java/dagger/internal/codegen/MemberSelect.java
index 89312acb7..0639dbf3f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MemberSelect.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MemberSelect.java
@@ -15,15 +15,11 @@
  */
 package dagger.internal.codegen;
 
-import com.google.common.base.Function;
-import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
 import dagger.MembersInjector;
 import dagger.internal.MapProviderFactory;
-import dagger.internal.MembersInjectors;
-import dagger.internal.codegen.writer.ClassName;
-import dagger.internal.codegen.writer.Snippet;
-import dagger.internal.codegen.writer.TypeNames;
 import dagger.producers.internal.MapOfProducerProducer;
 import java.util.Set;
 import javax.lang.model.type.TypeMirror;
@@ -31,15 +27,22 @@
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static dagger.internal.codegen.Accessibility.isTypeAccessibleFrom;
+import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
+import static dagger.internal.codegen.CodeBlocks.toCodeBlocks;
+import static dagger.internal.codegen.TypeNames.MAP_OF_PRODUCER_PRODUCER;
+import static dagger.internal.codegen.TypeNames.MAP_PROVIDER_FACTORY;
+import static dagger.internal.codegen.TypeNames.MEMBERS_INJECTOR;
+import static dagger.internal.codegen.TypeNames.MEMBERS_INJECTORS;
+import static dagger.internal.codegen.TypeNames.SET;
 
 /**
- * Represents a {@link com.sun.source.tree.MemberSelectTree} as a {@link Snippet}.
+ * Represents a {@link com.sun.source.tree.MemberSelectTree} as a {@link CodeBlock}.
  */
 abstract class MemberSelect {
   /**
    * Returns a {@link MemberSelect} that accesses the field given by {@code fieldName} owned by
    * {@code owningClass}.  In this context "local" refers to the fact that the field is owned by the
-   * type (or an enclosing type) from which the snippet will be used.  The returned
+   * type (or an enclosing type) from which the code block will be used.  The returned
    * {@link MemberSelect} will not be valid for accessing the field from a different class
    * (regardless of accessibility).
    */
@@ -56,34 +59,34 @@ static MemberSelect localField(ClassName owningClass, String fieldName) {
     }
 
     @Override
-    Snippet getSnippetFor(ClassName usingClass) {
+    CodeBlock getExpressionFor(ClassName usingClass) {
       return owningClass().equals(usingClass)
-          ? Snippet.format("%s", fieldName)
-          : Snippet.format("%s.this.%s", owningClass(), fieldName);
+          ? CodeBlocks.format("$L", fieldName)
+          : CodeBlocks.format("$T.this.$L", owningClass(), fieldName);
     }
   }
 
   /**
    * Returns a {@link MemberSelect} for the invocation of a static method (given by
-   * {@code methodInvocationSnippet}) on the {@code owningClass}.
+   * {@code methodInvocationCodeBlock}) on the {@code owningClass}.
    */
-  static MemberSelect staticMethod(ClassName owningClass, Snippet methodInvocationSnippet) {
-    return new StaticMethod(owningClass, methodInvocationSnippet);
+  static MemberSelect staticMethod(ClassName owningClass, CodeBlock methodInvocationCodeBlock) {
+    return new StaticMethod(owningClass, methodInvocationCodeBlock);
   }
 
   private static final class StaticMethod extends MemberSelect {
-    final Snippet methodSnippet;
+    final CodeBlock methodCodeBlock;
 
-    StaticMethod(ClassName owningClass, Snippet methodSnippet) {
+    StaticMethod(ClassName owningClass, CodeBlock methodCodeBlock) {
       super(owningClass, true);
-      this.methodSnippet = checkNotNull(methodSnippet);
+      this.methodCodeBlock = checkNotNull(methodCodeBlock);
     }
 
     @Override
-    Snippet getSnippetFor(ClassName usingClass) {
+    CodeBlock getExpressionFor(ClassName usingClass) {
       return owningClass().equals(usingClass)
-          ? methodSnippet
-          : Snippet.format("%s.%s", owningClass(), methodSnippet);
+          ? methodCodeBlock
+          : CodeBlocks.format("$T.$L", owningClass(), methodCodeBlock);
     }
   }
 
@@ -92,10 +95,10 @@ Snippet getSnippetFor(ClassName usingClass) {
    */
   static MemberSelect noOpMembersInjector(TypeMirror type) {
     return new ParameterizedStaticMethod(
-        ClassName.fromClass(MembersInjectors.class),
+        MEMBERS_INJECTORS,
         ImmutableList.of(type),
-        Snippet.format("noOp()"),
-        ClassName.fromClass(MembersInjector.class));
+        CodeBlocks.format("noOp()"),
+        MEMBERS_INJECTOR);
   }
 
   /**
@@ -107,14 +110,14 @@ static MemberSelect noOpMembersInjector(TypeMirror type) {
   static MemberSelect emptyFrameworkMapFactory(
       ClassName frameworkMapFactoryClass, TypeMirror keyType, TypeMirror unwrappedValueType) {
     checkArgument(
-        frameworkMapFactoryClass.equals(ClassName.fromClass(MapProviderFactory.class))
-            || frameworkMapFactoryClass.equals(ClassName.fromClass(MapOfProducerProducer.class)),
+        frameworkMapFactoryClass.equals(MAP_PROVIDER_FACTORY)
+            || frameworkMapFactoryClass.equals(MAP_OF_PRODUCER_PRODUCER),
         "frameworkMapFactoryClass must be MapProviderFactory or MapOfProducerProducer: %s",
         frameworkMapFactoryClass);
     return new ParameterizedStaticMethod(
         frameworkMapFactoryClass,
         ImmutableList.of(keyType, unwrappedValueType),
-        Snippet.format("empty()"),
+        CodeBlocks.format("empty()"),
         frameworkMapFactoryClass);
   }
 
@@ -127,53 +130,41 @@ static MemberSelect emptySetProvider(ClassName setFactoryType, SetType setType)
     return new ParameterizedStaticMethod(
         setFactoryType,
         ImmutableList.of(setType.elementType()),
-        Snippet.format("create()"),
-        ClassName.fromClass(Set.class));
+        CodeBlocks.format("create()"),
+        SET);
   }
 
-  static final class ParameterizedStaticMethod extends MemberSelect {
+  private static final class ParameterizedStaticMethod extends MemberSelect {
     final ImmutableList<TypeMirror> typeParameters;
-    final Snippet methodSnippet;
+    final CodeBlock methodCodeBlock;
     final ClassName rawReturnType;
 
     ParameterizedStaticMethod(
         ClassName owningClass,
         ImmutableList<TypeMirror> typeParameters,
-        Snippet methodSnippet,
+        CodeBlock methodCodeBlock,
         ClassName rawReturnType) {
       super(owningClass, true);
       this.typeParameters = typeParameters;
-      this.methodSnippet = methodSnippet;
+      this.methodCodeBlock = methodCodeBlock;
       this.rawReturnType = rawReturnType;
     }
 
     @Override
-    Snippet getSnippetFor(ClassName usingClass) {
+    CodeBlock getExpressionFor(ClassName usingClass) {
       boolean accessible = true;
       for (TypeMirror typeParameter : typeParameters) {
         accessible &= isTypeAccessibleFrom(typeParameter, usingClass.packageName());
       }
 
       if (accessible) {
-        Snippet typeParametersSnippet = Snippet.makeParametersSnippet(
-            FluentIterable.from(typeParameters)
-                .transform(new Function<TypeMirror, Snippet>() {
-                  @Override
-                  public Snippet apply(TypeMirror input) {
-                    return Snippet.format("%s", TypeNames.forTypeMirror(input));
-                  }
-                }));
-        return Snippet.format(
-            "%s.<%s>%s",
+        return CodeBlocks.format(
+            "$T.<$L>$L",
             owningClass(),
-            typeParametersSnippet,
-            methodSnippet);
+            makeParametersCodeBlock(toCodeBlocks(typeParameters)),
+            methodCodeBlock);
       } else {
-        return Snippet.format(
-            "((%s) %s.%s)",
-            rawReturnType,
-            owningClass(),
-            methodSnippet);
+        return CodeBlocks.format("(($T) $T.$L)", rawReturnType, owningClass(), methodCodeBlock);
       }
     }
   }
@@ -200,7 +191,8 @@ boolean staticMember() {
   }
 
   /**
-   * Returns a {@link Snippet} suitable for accessing the member from the given {@code usingClass}.
+   * Returns a {@link CodeBlock} suitable for accessing the member from the given {@code
+   * usingClass}.
    */
-  abstract Snippet getSnippetFor(ClassName usingClass);
+  abstract CodeBlock getExpressionFor(ClassName usingClass);
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
index c672a9521..14988e1ea 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
@@ -142,7 +142,7 @@ ClassName nameGeneratedType(MembersInjectionBinding binding) {
     ImmutableList.Builder<CodeBlock> constructorInvocationParameters = ImmutableList.builder();
 
     boolean usesRawFrameworkTypes = false;
-    UniqueNames fieldNames = new UniqueNames();
+    UniqueNameSet fieldNames = new UniqueNameSet();
     for (Entry<BindingKey, FrameworkField> fieldEntry : fields.entrySet()) {
       BindingKey bindingKey = fieldEntry.getKey();
       FrameworkField bindingField = fieldEntry.getValue();
@@ -155,8 +155,8 @@ ClassName nameGeneratedType(MembersInjectionBinding binding) {
       String fieldName = fieldNames.getUniqueName(bindingField.name());
       TypeName fieldType =
           useRawFrameworkType
-              ? bindingField.javapoetFrameworkType().rawType
-              : bindingField.javapoetFrameworkType();
+              ? bindingField.frameworkType().rawType
+              : bindingField.frameworkType();
       FieldSpec.Builder fieldBuilder = FieldSpec.builder(fieldType, fieldName, PRIVATE, FINAL);
       ParameterSpec.Builder parameterBuilder = ParameterSpec.builder(fieldType, fieldName);
 
@@ -385,17 +385,4 @@ public Boolean visitDeclared(DeclaredType t, MembersInjectionBinding p) {
           return visibleToMembersInjector(p, t.asElement());
         }
       };
-
-  private static final class UniqueNames {
-    private final Set<String> uniqueNames = new HashSet<>();
-
-    String getUniqueName(String base) {
-      String name = base;
-      for (int differentiator = 2; !uniqueNames.add(name); differentiator++) {
-        name = base + differentiator;
-      }
-      uniqueNames.add(name);
-      return name;
-    }
-  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
index ea8e3d308..103e0858f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
@@ -44,6 +44,7 @@
 import static com.squareup.javapoet.TypeSpec.classBuilder;
 import static dagger.internal.codegen.AnnotationSpecs.SUPPRESS_WARNINGS_UNCHECKED;
 import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
+import static dagger.internal.codegen.CodeBlocks.toCodeBlocks;
 import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
 import static dagger.internal.codegen.SourceFiles.javapoetGeneratedClassNameForBinding;
 import static dagger.internal.codegen.TypeNames.ASYNC_FUNCTION;
@@ -120,7 +121,7 @@ ClassName nameGeneratedType(ProductionBinding binding) {
     addFieldAndConstructorParameter(factoryBuilder, constructorBuilder, "executor", EXECUTOR);
 
     for (FrameworkField bindingField : fields.values()) {
-      TypeName fieldType = bindingField.javapoetFrameworkType();
+      TypeName fieldType = bindingField.frameworkType();
       addFieldAndConstructorParameter(
           factoryBuilder, constructorBuilder, bindingField.name(), fieldType);
     }
@@ -493,10 +494,6 @@ private CodeBlock getThrowsClause(List<? extends TypeMirror> thrownTypes) {
     if (thrownTypes.isEmpty()) {
       return CodeBlocks.format("");
     }
-    return CodeBlocks.format(
-        "throws $L",
-        CodeBlocks.join(
-            FluentIterable.from(thrownTypes)
-                .transform(CodeBlocks.TYPE_MIRROR_TO_CODE_BLOCK), ", "));
+    return CodeBlocks.format("throws $L", makeParametersCodeBlock(toCodeBlocks(thrownTypes)));
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerator.java b/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerator.java
deleted file mode 100644
index ddb889f34..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerator.java
+++ /dev/null
@@ -1,28 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen;
-
-/**
- * A template for types that generate source files from an annotation processor.
- *
- * @param <T> The input type from which source is to be generated.
- * @author Gregory Kick
- * @since 2.0
- */
-interface SourceFileGenerator<T> {
-  /** Generates a source file to be compiled for {@code T}. */
-  void generate(T input) throws SourceFileGenerationException;
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/SubcomponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/SubcomponentWriter.java
index 9fe1fb7a1..118713147 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SubcomponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SubcomponentWriter.java
@@ -19,14 +19,13 @@
 import com.google.common.base.CaseFormat;
 import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableList;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.FieldSpec;
+import com.squareup.javapoet.MethodSpec;
+import com.squareup.javapoet.TypeName;
+import com.squareup.javapoet.TypeSpec;
 import dagger.internal.codegen.ComponentDescriptor.BuilderSpec;
-import dagger.internal.codegen.writer.ClassName;
-import dagger.internal.codegen.writer.ClassWriter;
-import dagger.internal.codegen.writer.FieldWriter;
-import dagger.internal.codegen.writer.MethodWriter;
-import dagger.internal.codegen.writer.Snippet;
-import dagger.internal.codegen.writer.TypeName;
-import dagger.internal.codegen.writer.TypeNames;
 import java.util.List;
 import java.util.Set;
 import javax.lang.model.element.ExecutableElement;
@@ -38,8 +37,13 @@
 import static com.google.common.base.CaseFormat.LOWER_CAMEL;
 import static com.google.common.base.Verify.verify;
 import static com.google.common.collect.Sets.difference;
+import static com.squareup.javapoet.MethodSpec.methodBuilder;
+import static com.squareup.javapoet.TypeSpec.classBuilder;
 import static dagger.internal.codegen.AbstractComponentWriter.InitializationState.UNINITIALIZED;
+import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
+import static dagger.internal.codegen.CodeBlocks.nullCheck;
 import static dagger.internal.codegen.MemberSelect.localField;
+import static dagger.internal.codegen.TypeSpecs.addSupertype;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.PUBLIC;
@@ -69,7 +73,7 @@ public SubcomponentWriter(
   }
 
   private static ClassName subcomponentName(AbstractComponentWriter parent, BindingGraph subgraph) {
-    return parent.name.nestedClassNamed(
+    return parent.name.nestedClass(
         parent.subcomponentImplNames.get(subgraph.componentDescriptor()));
   }
 
@@ -82,10 +86,10 @@ protected InitializationState getInitializationState(BindingKey bindingKey) {
   }
 
   @Override
-  protected Optional<Snippet> getOrCreateComponentContributionFieldSnippet(
+  protected Optional<CodeBlock> getOrCreateComponentContributionFieldExpression(
       TypeElement contributionType) {
-    return super.getOrCreateComponentContributionFieldSnippet(contributionType)
-        .or(parent.getOrCreateComponentContributionFieldSnippet(contributionType));
+    return super.getOrCreateComponentContributionFieldExpression(contributionType)
+        .or(parent.getOrCreateComponentContributionFieldExpression(contributionType));
   }
 
   @Override
@@ -102,19 +106,16 @@ private ExecutableType resolvedSubcomponentFactoryMethod() {
   }
 
   @Override
-  protected ClassWriter createComponentClass() {
-    ClassWriter componentWriter = parent.componentWriter.addNestedClass(name.simpleName());
-    componentWriter.addModifiers(PRIVATE, FINAL);
-    componentWriter.setSupertype(
+  protected TypeSpec.Builder createComponentClass() {
+    TypeSpec.Builder subcomponent = classBuilder(name.simpleName()).addModifiers(PRIVATE, FINAL);
+
+    addSupertype(
+        subcomponent,
         MoreTypes.asTypeElement(
             graph.componentDescriptor().builderSpec().isPresent()
-                ? graph
-                    .componentDescriptor()
-                    .builderSpec()
-                    .get()
-                    .componentType()
+                ? graph.componentDescriptor().builderSpec().get().componentType()
                 : resolvedSubcomponentFactoryMethod().getReturnType()));
-    return componentWriter;
+    return subcomponent;
   }
 
   @Override
@@ -126,60 +127,70 @@ protected void addBuilder() {
   }
 
   @Override
-  protected ClassWriter createBuilder() {
+  protected ClassName builderName() {
+    return name.peerClass(componentDefinitionTypeName().simpleName() + "Builder");
+  }
+
+  @Override
+  protected TypeSpec.Builder createBuilder(String builderSimpleName) {
     // Only write subcomponent builders if there is a spec.
     verify(graph.componentDescriptor().builderSpec().isPresent());
-    return parent.componentWriter.addNestedClass(
-        componentDefinitionTypeName().simpleName() + "Builder");
+    return classBuilder(builderSimpleName);
+  }
+
+  @Override
+  protected void addBuilderClass(TypeSpec builder) {
+    parent.component.addType(builder);
   }
 
   @Override
   protected void addFactoryMethods() {
-    MethodWriter componentMethod;
+    MethodSpec.Builder componentMethod =
+        methodBuilder(subcomponentFactoryMethod.getSimpleName().toString())
+            .addModifiers(PUBLIC)
+            .addAnnotation(Override.class);
     if (graph.componentDescriptor().builderSpec().isPresent()) {
       BuilderSpec spec = graph.componentDescriptor().builderSpec().get();
-      componentMethod =
-          parent.componentWriter.addMethod(
-              spec.builderDefinitionType().asType(),
-              subcomponentFactoryMethod.getSimpleName().toString());
-      componentMethod.body().addSnippet("return new %s();", builderName.get());
+      componentMethod
+          .returns(ClassName.get(spec.builderDefinitionType()))
+          .addStatement("return new $T()", builderName.get());
     } else {
       ExecutableType resolvedMethod = resolvedSubcomponentFactoryMethod();
-      componentMethod =
-          parent.componentWriter.addMethod(
-              resolvedMethod.getReturnType(), subcomponentFactoryMethod.getSimpleName().toString());
+      componentMethod.returns(ClassName.get(resolvedMethod.getReturnType()));
       writeSubcomponentWithoutBuilder(componentMethod, resolvedMethod);
     }
-    componentMethod.addModifiers(PUBLIC);
-    componentMethod.annotate(Override.class);
+    parent.component.addMethod(componentMethod.build());
   }
 
   private void writeSubcomponentWithoutBuilder(
-      MethodWriter componentMethod, ExecutableType resolvedMethod) {
-    ImmutableList.Builder<Snippet> subcomponentConstructorParameters = ImmutableList.builder();
+      MethodSpec.Builder componentMethod, ExecutableType resolvedMethod) {
+    ImmutableList.Builder<CodeBlock> subcomponentConstructorParameters = ImmutableList.builder();
     List<? extends VariableElement> params = subcomponentFactoryMethod.getParameters();
     List<? extends TypeMirror> paramTypes = resolvedMethod.getParameterTypes();
     for (int i = 0; i < params.size(); i++) {
       VariableElement moduleVariable = params.get(i);
       TypeElement moduleTypeElement = MoreTypes.asTypeElement(paramTypes.get(i));
-      TypeName moduleType = TypeNames.forTypeMirror(paramTypes.get(i));
+      TypeName moduleType = TypeName.get(paramTypes.get(i));
       componentMethod.addParameter(moduleType, moduleVariable.getSimpleName().toString());
       if (!componentContributionFields.containsKey(moduleTypeElement)) {
         String preferredModuleName =
             CaseFormat.UPPER_CAMEL.to(LOWER_CAMEL, moduleTypeElement.getSimpleName().toString());
-        FieldWriter contributionField =
-            componentWriter.addField(moduleTypeElement, preferredModuleName);
-        contributionField.addModifiers(PRIVATE, FINAL);
-        String actualModuleName = contributionField.name();
-        constructorWriter.addParameter(moduleType, actualModuleName);
-        constructorWriter.body()
-            .addSnippet("if (%s == null) {", actualModuleName)
-            .addSnippet("  throw new NullPointerException();")
-            .addSnippet("}");
-        constructorWriter.body().addSnippet("this.%1$s = %1$s;", actualModuleName);
+        FieldSpec contributionField =
+            componentField(ClassName.get(moduleTypeElement), preferredModuleName)
+                .addModifiers(PRIVATE, FINAL)
+                .build();
+        component.addField(contributionField);
+
+        String actualModuleName = contributionField.name;
+        constructor
+            .addParameter(moduleType, actualModuleName)
+            .addCode(nullCheck(actualModuleName))
+            .addStatement("this.$1L = $1L", actualModuleName);
+
         MemberSelect moduleSelect = localField(name, actualModuleName);
         componentContributionFields.put(moduleTypeElement, moduleSelect);
-        subcomponentConstructorParameters.add(Snippet.format("%s", moduleVariable.getSimpleName()));
+        subcomponentConstructorParameters.add(
+            CodeBlocks.format("$L", moduleVariable.getSimpleName()));
       }
     }
 
@@ -189,16 +200,19 @@ private void writeSubcomponentWithoutBuilder(
     for (TypeElement moduleType : uninitializedModules) {
       String preferredModuleName =
           CaseFormat.UPPER_CAMEL.to(LOWER_CAMEL, moduleType.getSimpleName().toString());
-      FieldWriter contributionField = componentWriter.addField(moduleType, preferredModuleName);
-      contributionField.addModifiers(PRIVATE, FINAL);
-      String actualModuleName = contributionField.name();
-      constructorWriter.body().addSnippet("this.%s = new %s();",
-          actualModuleName, ClassName.fromTypeElement(moduleType));
+      FieldSpec contributionField =
+          componentField(ClassName.get(moduleType), preferredModuleName)
+              .addModifiers(PRIVATE, FINAL)
+              .build();
+      component.addField(contributionField);
+      String actualModuleName = contributionField.name;
+      constructor.addStatement(
+          "this.$L = new $T()", actualModuleName, ClassName.get(moduleType));
       MemberSelect moduleSelect = localField(name, actualModuleName);
       componentContributionFields.put(moduleType, moduleSelect);
     }
 
-    componentMethod.body().addSnippet("return new %s(%s);",
-        name, Snippet.makeParametersSnippet(subcomponentConstructorParameters.build()));
+    componentMethod.addStatement("return new $T($L)",
+        name, makeParametersCodeBlock(subcomponentConstructorParameters.build()));
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/TypeNames.java b/compiler/src/main/java/dagger/internal/codegen/TypeNames.java
index 80d83efba..e005761d7 100644
--- a/compiler/src/main/java/dagger/internal/codegen/TypeNames.java
+++ b/compiler/src/main/java/dagger/internal/codegen/TypeNames.java
@@ -23,11 +23,24 @@
 import com.squareup.javapoet.ParameterizedTypeName;
 import com.squareup.javapoet.TypeName;
 import dagger.MembersInjector;
+import dagger.internal.DelegateFactory;
 import dagger.internal.DoubleCheckLazy;
 import dagger.internal.Factory;
+import dagger.internal.InstanceFactory;
+import dagger.internal.MapFactory;
+import dagger.internal.MapProviderFactory;
+import dagger.internal.MembersInjectors;
+import dagger.internal.ScopedProvider;
+import dagger.internal.SetFactory;
 import dagger.producers.Produced;
+import dagger.producers.Producer;
 import dagger.producers.internal.AbstractProducer;
+import dagger.producers.internal.MapOfProducedProducer;
+import dagger.producers.internal.MapOfProducerProducer;
+import dagger.producers.internal.MapProducer;
 import dagger.producers.internal.Producers;
+import dagger.producers.internal.SetOfProducedProducer;
+import dagger.producers.internal.SetProducer;
 import dagger.producers.monitoring.ProducerToken;
 import dagger.producers.monitoring.ProductionComponentMonitor;
 import java.util.List;
@@ -43,17 +56,35 @@
   static final ClassName ABSTRACT_PRODUCER = ClassName.get(AbstractProducer.class);
   static final ClassName ASYNC_FUNCTION = ClassName.get(AsyncFunction.class);
   static final ClassName DOUBLE_CHECK_LAZY = ClassName.get(DoubleCheckLazy.class);
+  static final ClassName DELEGATE_FACTORY = ClassName.get(DelegateFactory.class);
   static final ClassName EXECUTOR = ClassName.get(Executor.class);
   static final ClassName FACTORY = ClassName.get(Factory.class);
   static final ClassName FUTURES = ClassName.get(Futures.class);
+  static final ClassName ILLEGAL_STATE_EXCEPTION = ClassName.get(IllegalStateException.class);
   static final ClassName IMMUTABLE_SET = ClassName.get(ImmutableSet.class);
+  static final ClassName INSTANCE_FACTORY = ClassName.get(InstanceFactory.class);
   static final ClassName LIST = ClassName.get(List.class);
   static final ClassName LISTENABLE_FUTURE = ClassName.get(ListenableFuture.class);
+  static final ClassName MAP_FACTORY = ClassName.get(MapFactory.class);
+  static final ClassName MAP_OF_PRODUCED_PRODUCER = ClassName.get(MapOfProducedProducer.class);
+  static final ClassName MAP_OF_PRODUCER_PRODUCER = ClassName.get(MapOfProducerProducer.class);
+  static final ClassName MAP_PRODUCER = ClassName.get(MapProducer.class);
+  static final ClassName MAP_PROVIDER_FACTORY = ClassName.get(MapProviderFactory.class);
   static final ClassName MEMBERS_INJECTOR = ClassName.get(MembersInjector.class);
+  static final ClassName MEMBERS_INJECTORS = ClassName.get(MembersInjectors.class);
   static final ClassName PRODUCER_TOKEN = ClassName.get(ProducerToken.class);
   static final ClassName PRODUCED = ClassName.get(Produced.class);
+  static final ClassName PRODUCER = ClassName.get(Producer.class);
   static final ClassName PRODUCERS = ClassName.get(Producers.class);
   static final ClassName PROVIDER = ClassName.get(Provider.class);
+  static final ClassName SCOPED_PROVIDER = ClassName.get(ScopedProvider.class);
+  static final ClassName SET = ClassName.get(Set.class);
+  static final ClassName SET_FACTORY = ClassName.get(SetFactory.class);
+  static final ClassName SET_OF_PRODUCED_PRODUCER = ClassName.get(SetOfProducedProducer.class);
+  static final ClassName SET_PRODUCER = ClassName.get(SetProducer.class);
+  static final ClassName STRING = ClassName.get(String.class);
+  static final ClassName UNSUPPORTED_OPERATION_EXCEPTION =
+      ClassName.get(UnsupportedOperationException.class);
 
   /**
    * {@link TypeName#VOID} is lowercase-v {@code void} whereas this represents the class, {@link
diff --git a/compiler/src/main/java/dagger/internal/codegen/TypeSpecs.java b/compiler/src/main/java/dagger/internal/codegen/TypeSpecs.java
new file mode 100644
index 000000000..325436140
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/TypeSpecs.java
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.TypeSpec;
+import javax.lang.model.element.TypeElement;
+
+/**
+ * Convenience methods for use with JavaPoet's {@link TypeSpec}.
+ */
+final class TypeSpecs {
+
+  /**
+   * If {@code supertype} is a class, adds it as a superclass for {@code typeBuilder}; if it is an
+   * interface, adds it as a superinterface.
+   */
+  static void addSupertype(TypeSpec.Builder typeBuilder, TypeElement supertype) {
+    switch (supertype.getKind()) {
+      case CLASS:
+        typeBuilder.superclass(ClassName.get(supertype));
+        break;
+      case INTERFACE:
+        typeBuilder.addSuperinterface(ClassName.get(supertype));
+        break;
+      default:
+        throw new AssertionError(supertype + " is neither a class nor an interface.");
+    }
+  }
+
+  private TypeSpecs() {}
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/UniqueNameSet.java b/compiler/src/main/java/dagger/internal/codegen/UniqueNameSet.java
new file mode 100644
index 000000000..b63b203e7
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/UniqueNameSet.java
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import java.util.HashSet;
+import java.util.Set;
+
+/**
+ * A collector for names to be used in the same namespace that should not conflict.
+ */
+final class UniqueNameSet {
+  private final Set<String> uniqueNames = new HashSet<>();
+
+  /**
+   * Generates a unique name using {@code base}. If {@code base} has not yet been added, it will be
+   * returned as-is. If your {@code base} is healthy, this will always return {@code base}.
+   */
+  String getUniqueName(CharSequence base) {
+    String name = base.toString();
+    for (int differentiator = 2; !uniqueNames.add(name); differentiator++) {
+      name = base.toString() + differentiator;
+    }
+    return name;
+  }
+}
diff --git a/compiler/src/test/java/dagger/internal/codegen/BindingFieldTest.java b/compiler/src/test/java/dagger/internal/codegen/BindingFieldTest.java
index b8349156d..607b5cbc0 100644
--- a/compiler/src/test/java/dagger/internal/codegen/BindingFieldTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/BindingFieldTest.java
@@ -17,11 +17,10 @@
 
 import com.google.common.collect.Iterables;
 import com.google.testing.compile.CompilationRule;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.ParameterizedTypeName;
+import com.squareup.javapoet.TypeName;
 import dagger.MembersInjector;
-import dagger.internal.codegen.writer.ClassName;
-import dagger.internal.codegen.writer.ParameterizedTypeName;
-import dagger.internal.codegen.writer.TypeName;
-import dagger.internal.codegen.writer.TypeNames;
 import javax.inject.Inject;
 import javax.inject.Provider;
 import javax.lang.model.element.ExecutableElement;
@@ -63,14 +62,13 @@ private ExecutableElement getXConstructor() {
   @Test public void frameworkType() {
     Key key = keyFactory.forInjectConstructorWithResolvedType(
         getXConstructor().getEnclosingElement().asType());
-    TypeName xClass = TypeNames.forTypeMirror(key.type());
+    TypeName xClass = TypeName.get(key.type());
     assertThat(FrameworkField.createWithTypeFromKey(Provider.class, key, "test").frameworkType())
-        .isEqualTo(ParameterizedTypeName.create(ClassName.fromClass(Provider.class), xClass));
+        .isEqualTo(ParameterizedTypeName.get(ClassName.get(Provider.class), xClass));
     assertThat(
             FrameworkField.createWithTypeFromKey(MembersInjector.class, key, "test")
                 .frameworkType())
-        .isEqualTo(
-            ParameterizedTypeName.create(ClassName.fromClass(MembersInjector.class), xClass));
+        .isEqualTo(ParameterizedTypeName.get(ClassName.get(MembersInjector.class), xClass));
   }
 
   @Test public void nameSuffix() {
diff --git a/compiler/src/test/java/dagger/internal/codegen/ComponentBuilderTest.java b/compiler/src/test/java/dagger/internal/codegen/ComponentBuilderTest.java
index d318cd37c..05f510121 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ComponentBuilderTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ComponentBuilderTest.java
@@ -65,7 +65,6 @@ public void testEmptyBuilder() {
         "package test;",
         "",
         "import javax.annotation.Generated;",
-        "import test.SimpleComponent",
         "",
         GENERATED_ANNOTATION,
         "public final class DaggerSimpleComponent implements SimpleComponent {",
@@ -133,7 +132,6 @@ public void testUsesBuildAndSetterNames() {
         "",
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
-        "import test.TestComponent;",
         "",
         GENERATED_ANNOTATION,
         "public final class DaggerTestComponent implements TestComponent {",
@@ -235,7 +233,6 @@ public void testIgnoresModulesNotInApi() {
         "",
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
-        "import test.TestComponent;",
         "",
         GENERATED_ANNOTATION,
         "public final class DaggerTestComponent implements TestComponent {",
diff --git a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
index b6dbd268a..164d21d9a 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
@@ -387,13 +387,10 @@ private void checkCannotReferToModuleOfType(String moduleType) {
         "",
         "import dagger.MembersInjector;",
         "import javax.annotation.Generated;",
-        "import test.OuterType.A;",
-        "import test.OuterType.B;",
-        "import test.OuterType.SimpleComponent;",
         "",
         GENERATED_ANNOTATION,
-        "public final class DaggerOuterType_SimpleComponent implements SimpleComponent {",
-        "  private MembersInjector<B> bMembersInjector;",
+        "public final class DaggerOuterType_SimpleComponent implements OuterType.SimpleComponent {",
+        "  private MembersInjector<OuterType.B> bMembersInjector;",
         "",
         "  private DaggerOuterType_SimpleComponent(Builder builder) {",
         "    assert builder != null;",
@@ -404,7 +401,7 @@ private void checkCannotReferToModuleOfType(String moduleType) {
         "    return new Builder();",
         "  }",
         "",
-        "  public static SimpleComponent create() {",
+        "  public static OuterType.SimpleComponent create() {",
         "    return builder().build();",
         "  }",
         "",
@@ -415,12 +412,12 @@ private void checkCannotReferToModuleOfType(String moduleType) {
         "  }",
         "",
         "  @Override",
-        "  public A a() {",
+        "  public OuterType.A a() {",
         "    return OuterType$A_Factory.create().get();",
         "  }",
         "",
         "  @Override",
-        "  public void inject(B b) {",
+        "  public void inject(OuterType.B b) {",
         "    bMembersInjector.injectMembers(b);",
         "  }",
         "",
@@ -428,7 +425,7 @@ private void checkCannotReferToModuleOfType(String moduleType) {
         "    private Builder() {",
         "    }",
         "",
-        "    public SimpleComponent build() {",
+        "    public OuterType.SimpleComponent build() {",
         "      return new DaggerOuterType_SimpleComponent(this);",
         "    }",
         "  }",
@@ -1575,14 +1572,11 @@ public void subcomponentOmitsInheritedBindings() {
         "",
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
-        "import other.test.A;",
-        "import other.test.TestModule;",
-        "import other.test.TestModule_AFactory;",
         "",
         GENERATED_ANNOTATION,
         "public final class DaggerTestComponent implements TestComponent {",
-        "  private Provider<test.A> aProvider;",
-        "  private Provider<A> aProvider1;",
+        "  private Provider<A> aProvider;",
+        "  private Provider<other.test.A> aProvider2;",
         "",
         "  private DaggerTestComponent(Builder builder) {",
         "    assert builder != null;",
@@ -1599,38 +1593,38 @@ public void subcomponentOmitsInheritedBindings() {
         "",
         "  @SuppressWarnings(\"unchecked\")",
         "  private void initialize(final Builder builder) {",
-        "    this.aProvider = test.TestModule_AFactory.create(builder.testModule);",
-        "    this.aProvider1 = TestModule_AFactory.create(builder.testModule1);",
+        "    this.aProvider = TestModule_AFactory.create(builder.testModule);",
+        "    this.aProvider2 = other.test.TestModule_AFactory.create(builder.testModule2);",
         "  }",
         "",
         "  @Override",
-        "  public test.A a() {",
+        "  public A a() {",
         "    return aProvider.get();",
         "  }",
         "",
         "  @Override",
-        "  public A otherA() {",
-        "    return aProvider1.get();",
+        "  public other.test.A otherA() {",
+        "    return aProvider2.get();",
         "  }",
         "",
         "  public static final class Builder {",
-        "    private test.TestModule testModule;",
-        "    private TestModule testModule1;",
+        "    private TestModule testModule;",
+        "    private other.test.TestModule testModule2;",
         "",
         "    private Builder() {",
         "    }",
         "",
         "    public TestComponent build() {",
         "      if (testModule == null) {",
-        "        this.testModule = new test.TestModule();",
+        "        this.testModule = new TestModule();",
         "      }",
-        "      if (testModule1 == null) {",
-        "        this.testModule1 = new TestModule();",
+        "      if (testModule2 == null) {",
+        "        this.testModule2 = new other.test.TestModule();",
         "      }",
         "      return new DaggerTestComponent(this);",
         "    }",
         "",
-        "    public Builder testModule(test.TestModule testModule) {",
+        "    public Builder testModule(TestModule testModule) {",
         "      if (testModule == null) {",
         "        throw new NullPointerException();",
         "      }",
@@ -1638,11 +1632,11 @@ public void subcomponentOmitsInheritedBindings() {
         "      return this;",
         "    }",
         "",
-        "    public Builder testModule(TestModule testModule) {",
+        "    public Builder testModule(other.test.TestModule testModule) {",
         "      if (testModule == null) {",
         "        throw new NullPointerException();",
         "      }",
-        "      this.testModule1 = testModule;",
+        "      this.testModule2 = testModule;",
         "      return this;",
         "    }",
         "  }",
diff --git a/compiler/src/test/java/dagger/internal/codegen/GeneratedLines.java b/compiler/src/test/java/dagger/internal/codegen/GeneratedLines.java
index 0a37c2294..487830801 100644
--- a/compiler/src/test/java/dagger/internal/codegen/GeneratedLines.java
+++ b/compiler/src/test/java/dagger/internal/codegen/GeneratedLines.java
@@ -20,11 +20,6 @@
  */
 public final class GeneratedLines {
   public static final String GENERATED_ANNOTATION =
-      "@Generated("
-          + "comments = \"https://google.github.io/dagger\", "
-          + "value = \"dagger.internal.codegen.ComponentProcessor\")";
-
-  public static final String GENERATED_ANNOTATION_JAVAPOET =
       "@Generated("
           + "value = \"dagger.internal.codegen.ComponentProcessor\", "
           + "comments = \"https://google.github.io/dagger\")";
diff --git a/compiler/src/test/java/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java b/compiler/src/test/java/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java
index a4429453e..de998be5f 100644
--- a/compiler/src/test/java/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java
@@ -39,7 +39,7 @@
 import static dagger.internal.codegen.ErrorMessages.QUALIFIER_ON_INJECT_CONSTRUCTOR;
 import static dagger.internal.codegen.ErrorMessages.STATIC_INJECT_FIELD;
 import static dagger.internal.codegen.ErrorMessages.STATIC_INJECT_METHOD;
-import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION_JAVAPOET;
+import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
 
 @RunWith(JUnit4.class)
 // TODO(gak): add tests for generation in the default package.
@@ -136,7 +136,7 @@
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        GENERATED_ANNOTATION_JAVAPOET,
+        GENERATED_ANNOTATION,
         "public final class GenericClass_Factory<T> implements Factory<GenericClass<T>> {",
         "  private final Provider<T> tProvider;",
         "",
@@ -182,7 +182,7 @@
             "import dagger.internal.Factory;",
             "import javax.annotation.Generated;",
             "",
-            GENERATED_ANNOTATION_JAVAPOET,
+            GENERATED_ANNOTATION,
             "public final class GenericClass_Factory<A, B> implements Factory<GenericClass<A, B>> {",
             "  private final MembersInjector<GenericClass<A, B>> genericClassMembersInjector;",
             "",
@@ -226,7 +226,7 @@
         "import javax.annotation.Generated;",
         "",
         "@SuppressWarnings(\"rawtypes\")",
-        GENERATED_ANNOTATION_JAVAPOET,
+        GENERATED_ANNOTATION,
         "public enum GenericClass_Factory implements Factory<GenericClass> {",
         "  INSTANCE;",
         "",
@@ -263,7 +263,7 @@
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        GENERATED_ANNOTATION_JAVAPOET,
+        GENERATED_ANNOTATION,
         "public final class GenericClass_Factory<A, B> implements Factory<GenericClass<A, B>> {",
         "  private final Provider<A> aProvider;",
         "  private final Provider<B> bProvider;",
@@ -311,7 +311,7 @@
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        GENERATED_ANNOTATION_JAVAPOET,
+        GENERATED_ANNOTATION,
         "public final class GenericClass_Factory<A extends Number & Comparable<A>,",
         "        B extends List<? extends String>,",
         "        C extends List<? super String>>",
@@ -371,7 +371,7 @@
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        GENERATED_ANNOTATION_JAVAPOET,
+        GENERATED_ANNOTATION,
         "public final class GenericClass_Factory<A, B> implements Factory<GenericClass<A, B>> {",
         "  private final Provider<A> aAndA2AndPaAndLaProvider;",
         "  private final Provider<A> qaProvider;",
@@ -817,7 +817,7 @@
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        GENERATED_ANNOTATION_JAVAPOET,
+        GENERATED_ANNOTATION,
         "public final class InjectConstructor_Factory ",
         "    implements Factory<InjectConstructor> {",
         "",
@@ -862,7 +862,7 @@
             "import javax.annotation.Generated;",
             "import javax.inject.Provider;",
             "",
-            GENERATED_ANNOTATION_JAVAPOET,
+            GENERATED_ANNOTATION,
             "public final class AllInjections_Factory ",
             "    implements Factory<AllInjections> {",
             "",
@@ -918,7 +918,7 @@
             "import dagger.internal.Factory;",
             "import javax.annotation.Generated;",
             "",
-            GENERATED_ANNOTATION_JAVAPOET,
+            GENERATED_ANNOTATION,
             "public final class B_Factory implements Factory<B> {",
             "",
             "  private final MembersInjector<B> bMembersInjector;",
@@ -964,7 +964,7 @@ public void wildcardDependency() {
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        GENERATED_ANNOTATION_JAVAPOET,
+        GENERATED_ANNOTATION,
         "public final class InjectConstructor_Factory ",
         "    implements Factory<InjectConstructor> {",
         "",
@@ -1012,7 +1012,7 @@ public void basicNameCollision() {
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        GENERATED_ANNOTATION_JAVAPOET,
+        GENERATED_ANNOTATION,
         "public final class InjectConstructor_Factory ",
         "    implements Factory<InjectConstructor> {",
         "",
@@ -1064,7 +1064,7 @@ public void nestedNameCollision() {
         "import javax.inject.Provider;",
         "import other.pkg.Outer;",
         "",
-        GENERATED_ANNOTATION_JAVAPOET,
+        GENERATED_ANNOTATION,
         "public final class InjectConstructor_Factory ",
         "    implements Factory<InjectConstructor> {",
         "",
@@ -1117,7 +1117,7 @@ public void samePackageNameCollision() {
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        GENERATED_ANNOTATION_JAVAPOET,
+        GENERATED_ANNOTATION,
         "public final class InjectConstructor_Factory ",
         "    implements Factory<InjectConstructor> {",
         "",
@@ -1165,7 +1165,7 @@ public void noDeps() {
         "import dagger.internal.Factory;",
         "import javax.annotation.Generated;",
         "",
-        GENERATED_ANNOTATION_JAVAPOET,
+        GENERATED_ANNOTATION,
         "public enum SimpleType_Factory implements Factory<SimpleType> {",
         "  INSTANCE;",
         "",
@@ -1210,7 +1210,7 @@ public void noDeps() {
         "import dagger.internal.Factory;",
         "import javax.annotation.Generated;",
         "",
-        GENERATED_ANNOTATION_JAVAPOET,
+        GENERATED_ANNOTATION,
         "public enum OuterType$A_Factory implements Factory<OuterType.A> {",
         "  INSTANCE;",
         "",
diff --git a/compiler/src/test/java/dagger/internal/codegen/MapKeyProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/MapKeyProcessorTest.java
index 88cc79b0d..b70f0479c 100644
--- a/compiler/src/test/java/dagger/internal/codegen/MapKeyProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/MapKeyProcessorTest.java
@@ -26,7 +26,6 @@
 import static com.google.common.truth.Truth.assertAbout;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
 import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
-import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION_JAVAPOET;
 
 @RunWith(JUnit4.class)
 public class MapKeyProcessorTest {
@@ -59,7 +58,7 @@ public void mapKeyCreatorFile() {
             "import com.google.auto.value.AutoAnnotation;",
             "import javax.annotation.Generated;",
             "",
-            GENERATED_ANNOTATION_JAVAPOET,
+            GENERATED_ANNOTATION,
             "public final class PathKeyCreator {",
             "  @AutoAnnotation",
             "  public static PathKey createPathKey(PathEnum value, String relativePath) {",
@@ -105,7 +104,7 @@ public void nestedMapKeyCreatorFile() {
             "import com.google.auto.value.AutoAnnotation;",
             "import javax.annotation.Generated;",
             "",
-            GENERATED_ANNOTATION_JAVAPOET,
+            GENERATED_ANNOTATION,
             "public final class Container$PathKeyCreator {",
             "  @AutoAnnotation",
             "  public static Container.PathKey createPathKey("
diff --git a/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java b/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java
index ccc2f97bb..1b585f603 100644
--- a/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java
@@ -34,7 +34,6 @@
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
 import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
-import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION_JAVAPOET;
 import static javax.tools.StandardLocation.CLASS_OUTPUT;
 
 @RunWith(JUnit4.class)
@@ -227,7 +226,7 @@ public void parentClass_injectedMembersInSupertype() {
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        GENERATED_ANNOTATION_JAVAPOET,
+        GENERATED_ANNOTATION,
         "public final class GenericClass_MembersInjector<A, B>",
         "    implements MembersInjector<GenericClass<A, B>> {",
         "  private final Provider<A> aProvider;",
@@ -320,7 +319,7 @@ public void parentClass_injectedMembersInSupertype() {
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        GENERATED_ANNOTATION_JAVAPOET,
+        GENERATED_ANNOTATION,
         "public final class Child_MembersInjector<T>",
         "    implements MembersInjector<Child<T>> {",
         "  private final Provider<T> tAndXProvider;",
@@ -392,7 +391,7 @@ public void parentClass_injectedMembersInSupertype() {
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        GENERATED_ANNOTATION_JAVAPOET,
+        GENERATED_ANNOTATION,
         "public final class FieldInjection_MembersInjector",
         "    implements MembersInjector<FieldInjection> {",
         "  private final Provider<String> stringProvider;",
@@ -462,7 +461,7 @@ public void parentClass_injectedMembersInSupertype() {
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        GENERATED_ANNOTATION_JAVAPOET,
+        GENERATED_ANNOTATION,
         "public final class MethodInjection_MembersInjector",
         "     implements MembersInjector<MethodInjection> {",
         "",
@@ -541,7 +540,7 @@ public void mixedMemberInjection() {
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        GENERATED_ANNOTATION_JAVAPOET,
+        GENERATED_ANNOTATION,
         "public final class MixedMemberInjection_MembersInjector",
         "    implements MembersInjector<MixedMemberInjection> {",
         "",
@@ -622,7 +621,7 @@ public void mixedMemberInjection() {
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        GENERATED_ANNOTATION_JAVAPOET,
+        GENERATED_ANNOTATION,
         "public final class AllInjections_MembersInjector ",
         "    implements MembersInjector<AllInjections> {",
         "",
@@ -679,7 +678,7 @@ public void mixedMemberInjection() {
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        GENERATED_ANNOTATION_JAVAPOET,
+        GENERATED_ANNOTATION,
         "public final class B_MembersInjector implements MembersInjector<B> {",
         "  private final Provider<String> sProvider;",
         "",
@@ -741,7 +740,7 @@ public void simpleComponentWithNesting() {
           "import javax.annotation.Generated;",
           "import javax.inject.Provider;",
           "",
-          GENERATED_ANNOTATION_JAVAPOET,
+          GENERATED_ANNOTATION,
           "public final class OuterType$B_MembersInjector implements MembersInjector<OuterType.B> {",
           "  private final Provider<OuterType.A> aProvider;",
           "",
@@ -806,7 +805,7 @@ public void componentWithNestingAndGeneratedType() {
             "import javax.annotation.Generated;",
             "import javax.inject.Provider;",
             "",
-            GENERATED_ANNOTATION_JAVAPOET,
+            GENERATED_ANNOTATION,
             "public final class OuterType$B_MembersInjector implements MembersInjector<OuterType.B> {",
             "  private final Provider<OuterType.A> aProvider;",
             "",
@@ -981,7 +980,7 @@ public void fieldInjectionForShadowedMember() {
             "import javax.annotation.Generated;",
             "import javax.inject.Provider;",
             "",
-            GENERATED_ANNOTATION_JAVAPOET,
+            GENERATED_ANNOTATION,
             "public final class Child_MembersInjector implements MembersInjector<Child> {",
             "  private final Provider<Foo> objectProvider;",
             "  private final Provider<Bar> objectProvider2;",
diff --git a/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java b/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
index cd44b97e5..f79cdbb8d 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
@@ -39,7 +39,7 @@
 import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_SET_VALUES_RETURN_SET;
 import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_THROWS;
 import static dagger.internal.codegen.ErrorMessages.PROVIDES_OR_PRODUCES_METHOD_MULTIPLE_QUALIFIERS;
-import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION_JAVAPOET;
+import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
 
 @RunWith(JUnit4.class)
 public class ModuleFactoryGeneratorTest {
@@ -375,7 +375,7 @@ private String formatModuleErrorMessage(String msg) {
         "import dagger.internal.Factory;",
         "import javax.annotation.Generated;",
         "",
-        GENERATED_ANNOTATION_JAVAPOET,
+        GENERATED_ANNOTATION,
         "public final class TestModule_ProvideStringFactory implements Factory<String> {",
         "  private final TestModule module;",
         "",
@@ -421,7 +421,7 @@ private String formatModuleErrorMessage(String msg) {
         "import dagger.internal.Factory;",
         "import javax.annotation.Generated;",
         "",
-        GENERATED_ANNOTATION_JAVAPOET,
+        GENERATED_ANNOTATION,
         "public final class TestModule_ProvideStringFactory implements Factory<String> {",
         "  private final TestModule module;",
         "",
@@ -462,7 +462,7 @@ private String formatModuleErrorMessage(String msg) {
         "import dagger.internal.Factory;",
         "import javax.annotation.Generated;",
         "",
-        GENERATED_ANNOTATION_JAVAPOET,
+        GENERATED_ANNOTATION,
         "public final class TestModule_ProvideStringFactory implements Factory<String> {",
         "  private final TestModule module;",
         "",
@@ -546,7 +546,7 @@ private String formatModuleErrorMessage(String msg) {
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
-        GENERATED_ANNOTATION_JAVAPOET,
+        GENERATED_ANNOTATION,
         "public final class TestModule_ProvideObjectsFactory implements Factory<List<Object>> {",
         "  private final TestModule module;",
         "  private final Provider<Object> aProvider;",
@@ -617,7 +617,7 @@ private String formatModuleErrorMessage(String msg) {
         "import java.util.Set;",
         "import javax.annotation.Generated;",
         "",
-        GENERATED_ANNOTATION_JAVAPOET,
+        GENERATED_ANNOTATION,
         "public final class TestModule_ProvideStringFactory implements Factory<Set<String>> {",
         "  private final TestModule module;",
         "",
@@ -668,7 +668,7 @@ private String formatModuleErrorMessage(String msg) {
         "import java.util.Set;",
         "import javax.annotation.Generated;",
         "",
-        GENERATED_ANNOTATION_JAVAPOET,
+        GENERATED_ANNOTATION,
         "public final class TestModule_ProvideWildcardListFactory implements "
             + "Factory<Set<List<List<?>>>> {",
         "  private final TestModule module;",
@@ -715,7 +715,7 @@ private String formatModuleErrorMessage(String msg) {
         "import java.util.Set;",
         "import javax.annotation.Generated;",
         "",
-        GENERATED_ANNOTATION_JAVAPOET,
+        GENERATED_ANNOTATION,
         "public final class TestModule_ProvideStringsFactory implements Factory<Set<String>> {",
         "  private final TestModule module;",
         "",
@@ -1004,7 +1004,7 @@ public void genericSubclassedModule() {
             "import javax.annotation.Generated;",
             "import javax.inject.Provider;",
             "",
-            GENERATED_ANNOTATION_JAVAPOET,
+            GENERATED_ANNOTATION,
             "public final class ParentModule_ProvideListBFactory<A extends CharSequence,",
             "    B, C extends Number & Comparable<C>> implements Factory<List<B>> {",
             "  private final ParentModule<A, B, C> module;",
@@ -1043,7 +1043,7 @@ public void genericSubclassedModule() {
             "import javax.annotation.Generated;",
             "import javax.inject.Provider;",
             "",
-            GENERATED_ANNOTATION_JAVAPOET,
+            GENERATED_ANNOTATION,
             "public final class ParentModule_ProvideBElementFactory<A extends CharSequence,",
             "    B, C extends Number & Comparable<C>> implements Factory<Set<B>> {",
             "  private final ParentModule<A, B, C> module;",
@@ -1076,7 +1076,7 @@ public void genericSubclassedModule() {
             "import javax.annotation.Generated;",
             "import javax.inject.Provider;",
             "",
-            GENERATED_ANNOTATION_JAVAPOET,
+            GENERATED_ANNOTATION,
             "public final class ParentModule_ProvideBEntryFactory<A extends CharSequence,",
             "    B, C extends Number & Comparable<C>> implements Factory<B>> {",
             "  private final ParentModule<A, B, C> module;",
@@ -1111,7 +1111,7 @@ public void genericSubclassedModule() {
         "import dagger.internal.Factory;",
         "import javax.annotation.Generated;",
         "",
-        GENERATED_ANNOTATION_JAVAPOET,
+        GENERATED_ANNOTATION,
         "public final class ChildNumberModule_ProvideNumberFactory implements Factory<Number> {",
         "  private final ChildNumberModule module;",
         "",
@@ -1140,7 +1140,7 @@ public void genericSubclassedModule() {
         "import dagger.internal.Factory;",
         "import javax.annotation.Generated;",
         "",
-        GENERATED_ANNOTATION_JAVAPOET,
+        GENERATED_ANNOTATION,
         "public final class ChildIntegerModule_ProvideIntegerFactory",
         "    implements Factory<Integer> {",
         "  private final ChildIntegerModule module;",
@@ -1208,7 +1208,7 @@ public void genericSubclassedModule() {
             "import java.util.Map;",
             "import javax.annotation.Generated;",
             "",
-            GENERATED_ANNOTATION_JAVAPOET,
+            GENERATED_ANNOTATION,
             "public enum ParameterizedModule_ProvideMapStringNumberFactory",
             "    implements Factory<Map<String, Number>> {",
             "  INSTANCE;",
@@ -1235,7 +1235,7 @@ public void genericSubclassedModule() {
             "import dagger.internal.Factory;",
             "import javax.annotation.Generated;",
             "",
-            GENERATED_ANNOTATION_JAVAPOET,
+            GENERATED_ANNOTATION,
             "public enum ParameterizedModule_ProvideNonGenericTypeFactory",
             "    implements Factory<Object> {",
             "  INSTANCE;",
diff --git a/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java b/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
index 41fae8ad1..41a40a88c 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
@@ -38,7 +38,7 @@
 import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_SET_VALUES_RETURN_SET;
 import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_THROWS;
 import static dagger.internal.codegen.ErrorMessages.PROVIDES_OR_PRODUCES_METHOD_MULTIPLE_QUALIFIERS;
-import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION_JAVAPOET;
+import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
 
 @RunWith(JUnit4.class)
 public class ProducerModuleFactoryGeneratorTest {
@@ -510,7 +510,7 @@ public void publicModuleNonPublicIncludes() {
             "import javax.annotation.Generated;",
             "import javax.inject.Provider;",
             "",
-            GENERATED_ANNOTATION_JAVAPOET,
+            GENERATED_ANNOTATION,
             "public final class TestModule_ProduceStringFactory extends AbstractProducer<String> {",
             "  private final TestModule module;",
             "  private final Executor executor;",
diff --git a/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java
index ade310cbf..c645056a5 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java
@@ -136,24 +136,19 @@
             "import dagger.producers.Producer;",
             "import dagger.producers.internal.Producers;",
             "import dagger.producers.monitoring.ProductionComponentMonitor;",
-            "import dagger.producers.monitoring.ProductionComponentMonitor.Factory;",
             "import java.util.Set;",
             "import java.util.concurrent.Executor;",
             "import javax.annotation.Generated;",
             "import javax.inject.Provider;",
-            "import test.TestClass.A;",
-            "import test.TestClass.AModule;",
-            "import test.TestClass.B;",
-            "import test.TestClass.BModule;",
-            "import test.TestClass.SimpleComponent;",
             "",
             GENERATED_ANNOTATION,
-            "public final class DaggerTestClass_SimpleComponent implements SimpleComponent {",
-            "  private Provider<SimpleComponent> simpleComponentProvider;",
-            "  private Provider<Set<Factory>> setOfFactoryProvider;",
+            "public final class DaggerTestClass_SimpleComponent",
+            "    implements TestClass.SimpleComponent {",
+            "  private Provider<TestClass.SimpleComponent> simpleComponentProvider;",
+            "  private Provider<Set<ProductionComponentMonitor.Factory>> setOfFactoryProvider;",
             "  private Provider<ProductionComponentMonitor> monitorProvider;",
-            "  private Provider<B> bProvider;",
-            "  private Producer<A> aProducer;",
+            "  private Provider<TestClass.B> bProvider;",
+            "  private Producer<TestClass.A> aProducer;",
             "",
             "  private DaggerTestClass_SimpleComponent(Builder builder) {",
             "    assert builder != null;",
@@ -166,7 +161,8 @@
             "",
             "  @SuppressWarnings(\"unchecked\")",
             "  private void initialize(final Builder builder) {",
-            "    this.simpleComponentProvider = InstanceFactory.<SimpleComponent>create(this);",
+            "    this.simpleComponentProvider = ",
+            "        InstanceFactory.<TestClass.SimpleComponent>create(this);",
             "    this.setOfFactoryProvider = SetFactory.create(",
             "        TestClass$SimpleComponent_MonitoringModule_DefaultSetOfFactoriesFactory",
             "            .create());",
@@ -185,30 +181,30 @@
             "  }",
             "",
             "  @Override",
-            "  public ListenableFuture<A> a() {",
+            "  public ListenableFuture<TestClass.A> a() {",
             "    return aProducer.get();",
             "  }",
             "",
             "  public static final class Builder {",
             "    private TestClass$SimpleComponent_MonitoringModule",
             "        testClass$SimpleComponent_MonitoringModule;",
-            "    private BModule bModule;",
-            "    private AModule aModule;",
+            "    private TestClass.BModule bModule;",
+            "    private TestClass.AModule aModule;",
             "    private Executor executor;",
             "",
             "    private Builder() {",
             "    }",
             "",
-            "    public SimpleComponent build() {",
+            "    public TestClass.SimpleComponent build() {",
             "      if (testClass$SimpleComponent_MonitoringModule == null) {",
             "        this.testClass$SimpleComponent_MonitoringModule =",
             "            new TestClass$SimpleComponent_MonitoringModule();",
             "      }",
             "      if (bModule == null) {",
-            "        this.bModule = new BModule();",
+            "        this.bModule = new TestClass.BModule();",
             "      }",
             "      if (aModule == null) {",
-            "        this.aModule = new AModule();",
+            "        this.aModule = new TestClass.AModule();",
             "      }",
             "      if (executor == null) {",
             "        throw new IllegalStateException(Executor.class.getCanonicalName()",
@@ -217,7 +213,7 @@
             "      return new DaggerTestClass_SimpleComponent(this);",
             "    }",
             "",
-            "    public Builder aModule(AModule aModule) {",
+            "    public Builder aModule(TestClass.AModule aModule) {",
             "      if (aModule == null) {",
             "        throw new NullPointerException();",
             "      }",
@@ -225,7 +221,7 @@
             "      return this;",
             "    }",
             "",
-            "    public Builder bModule(BModule bModule) {",
+            "    public Builder bModule(TestClass.BModule bModule) {",
             "      if (bModule == null) {",
             "        throw new NullPointerException();",
             "      }",
diff --git a/compiler/src/test/java/dagger/internal/codegen/SubcomponentValidationTest.java b/compiler/src/test/java/dagger/internal/codegen/SubcomponentValidationTest.java
index 76287e946..a0ec1be51 100644
--- a/compiler/src/test/java/dagger/internal/codegen/SubcomponentValidationTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/SubcomponentValidationTest.java
@@ -509,8 +509,7 @@ public void multipleSubcomponentsWithSameSimpleNamesCanExistInSameComponent() {
             "package test;",
             "",
             "import javax.annotation.Generated;",
-            "import test.Bar.Sub;",
-            "import test.Foo;",
+            "import test.subpackage.Sub;",
             "",
             GENERATED_ANNOTATION,
             "public final class DaggerParentComponent implements ParentComponent {",
@@ -546,22 +545,30 @@ public void multipleSubcomponentsWithSameSimpleNamesCanExistInSameComponent() {
             "",
             "  private final class Foo_SubImpl implements Foo.Sub {",
             "",
+            "    private Foo_SubImpl() {}",
+            "",
             "    @Override",
-            "    public Sub newBarSubcomponent() {",
+            "    public Bar.Sub newBarSubcomponent() {",
             "      return new Bar_SubImpl();",
             "    }",
             "",
-            "    private final class Bar_SubImpl implements Sub {",
+            "    private final class Bar_SubImpl implements Bar.Sub {",
+            "",
+            "      private Bar_SubImpl() {}",
             "",
             "      @Override",
-            "      public test.subpackage.Sub newSubcomponentInSubpackage() {",
+            "      public Sub newSubcomponentInSubpackage() {",
             "        return new subpackage_SubImpl();",
             "      }",
             "",
-            "      private final class subpackage_SubImpl implements test.subpackage.Sub {}",
+            "      private final class subpackage_SubImpl implements Sub {",
+            "        private subpackage_SubImpl() {}",
+            "      }",
             "    }",
             "  }",
-            "  private final class NoConflictImpl implements NoConflict {}",
+            "  private final class NoConflictImpl implements NoConflict {",
+            "    private NoConflictImpl() {}",
+            "  }",
             "}");
 
     assertAbout(javaSources())
@@ -610,7 +617,6 @@ public void subcomponentSimpleNamesDisambiguated() {
             "package test;",
             "",
             "import javax.annotation.Generated;",
-            "import test.deep.many.levels.that.match.test.Sub;",
             "",
             GENERATED_ANNOTATION,
             "public final class DaggerParentComponent implements ParentComponent {",
@@ -627,7 +633,7 @@ public void subcomponentSimpleNamesDisambiguated() {
             "  }",
             "",
             "  @Override",
-            "  public test.Sub newSubcomponent() {",
+            "  public Sub newSubcomponent() {",
             "    return new test_SubImpl();",
             "  }",
             "",
@@ -639,14 +645,19 @@ public void subcomponentSimpleNamesDisambiguated() {
             "    }",
             "  }",
             "",
-            "  private final class test_SubImpl implements test.Sub {",
+            "  private final class test_SubImpl implements Sub {",
+            "",
+            "    private test_SubImpl() {}",
             "",
             "    @Override",
-            "    public Sub newDeepSubcomponent() {",
+            "    public test.deep.many.levels.that.match.test.Sub newDeepSubcomponent() {",
             "      return new match_test_SubImpl();",
             "    }",
             "",
-            "    private final class match_test_SubImpl implements Sub {}",
+            "    private final class match_test_SubImpl implements ",
+            "        test.deep.many.levels.that.match.test.Sub {",
+            "      private match_test_SubImpl() {}",
+            "    }",
             "  }",
             "}");
 
@@ -703,8 +714,7 @@ public void subcomponentImplNameUsesFullyQualifiedClassNameIfNecessary() {
             "package test;",
             "",
             "import javax.annotation.Generated;",
-            "import top1.a.b.c.d.E.F.Sub;",
-            "import top2.a.b.c.d.E.F;",
+            "import top1.a.b.c.d.E;",
             "",
             GENERATED_ANNOTATION,
             "public final class DaggerParentComponent implements ParentComponent {",
@@ -721,12 +731,12 @@ public void subcomponentImplNameUsesFullyQualifiedClassNameIfNecessary() {
             "  }",
             "",
             "  @Override",
-            "  public Sub top1() {",
+            "  public E.F.Sub top1() {",
             "    return new top1_a_b_c_d_E_F_SubImpl();",
             "  }",
             "",
             "  @Override",
-            "  public F.Sub top2() {",
+            "  public top2.a.b.c.d.E.F.Sub top2() {",
             "    return new top2_a_b_c_d_E_F_SubImpl();",
             "  }",
             "",
@@ -738,8 +748,12 @@ public void subcomponentImplNameUsesFullyQualifiedClassNameIfNecessary() {
             "    }",
             "  }",
             "",
-            "  private final class top1_a_b_c_d_E_F_SubImpl implements Sub {}",
-            "  private final class top2_a_b_c_d_E_F_SubImpl implements F.Sub {}",
+            "  private final class top1_a_b_c_d_E_F_SubImpl implements E.F.Sub {",
+            "    private top1_a_b_c_d_E_F_SubImpl() {}",
+            "  }",
+            "  private final class top2_a_b_c_d_E_F_SubImpl implements top2.a.b.c.d.E.F.Sub {",
+            "    private top2_a_b_c_d_E_F_SubImpl() {}",
+            "  }",
             "}");
 
     assertAbout(javaSources())
@@ -780,10 +794,9 @@ public void parentComponentNameShouldNotBeDisambiguatedWhenItConflictsWithASubco
             "package test;",
             "",
             "import javax.annotation.Generated;",
-            "import test.Foo.C;",
             "",
             GENERATED_ANNOTATION,
-            "public final class DaggerC implements test.C {",
+            "public final class DaggerC implements C {",
             "  private DaggerC(Builder builder) {",
             "    assert builder != null;",
             "  }",
@@ -792,24 +805,26 @@ public void parentComponentNameShouldNotBeDisambiguatedWhenItConflictsWithASubco
             "    return new Builder();",
             "  }",
             "",
-            "  public static test.C create() {",
+            "  public static C create() {",
             "    return builder().build();",
             "  }",
             "",
             "  @Override",
-            "  public C newFooC() {",
+            "  public Foo.C newFooC() {",
             "    return new Foo_CImpl();",
             "  }",
             "",
             "  public static final class Builder {",
             "    private Builder() {}",
             "",
-            "    public test.C build() {",
+            "    public C build() {",
             "      return new DaggerC(this);",
             "    }",
             "  }",
             "",
-            "  private final class Foo_CImpl implements C {}",
+            "  private final class Foo_CImpl implements Foo.C {",
+            "    private Foo_CImpl() {}",
+            "  }",
             "}");
 
     assertAbout(javaSources())
