diff --git a/checkstyle.xml b/checkstyle.xml
index 9f114c6e0..016f64f47 100644
--- a/checkstyle.xml
+++ b/checkstyle.xml
@@ -67,7 +67,6 @@
         <module name="MethodLength">
             <property name="max" value="200"/>
         </module>
-
         <!--module name="ParameterNumber"/-->
 
 
diff --git a/compiler/pom.xml b/compiler/pom.xml
index 42bce62b3..f9cf29f31 100644
--- a/compiler/pom.xml
+++ b/compiler/pom.xml
@@ -67,6 +67,11 @@
       <artifactId>compile-testing</artifactId>
       <scope>test</scope>
     </dependency>
+    <dependency>
+      <groupId>com.google.guava</groupId>
+      <artifactId>guava-testlib</artifactId>
+      <scope>test</scope>
+    </dependency>
     <dependency>
       <groupId>org.truth0</groupId>
       <artifactId>truth</artifactId>
diff --git a/compiler/src/main/java/dagger/internal/codegen/Key.java b/compiler/src/main/java/dagger/internal/codegen/Key.java
new file mode 100644
index 000000000..51ba7ab7a
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/Key.java
@@ -0,0 +1,121 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.base.Preconditions.checkState;
+import static javax.lang.model.element.ElementKind.CONSTRUCTOR;
+import static javax.lang.model.element.ElementKind.METHOD;
+
+import com.google.auto.value.AutoValue;
+import com.google.common.base.Equivalence;
+import com.google.common.base.Objects;
+import com.google.common.base.Optional;
+import com.google.common.base.Predicate;
+import com.google.common.collect.FluentIterable;
+
+import dagger.Provides;
+
+import java.util.Iterator;
+import java.util.List;
+
+import javax.inject.Qualifier;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.type.TypeMirror;
+
+/**
+ * Represents a unique combination of {@linkplain TypeMirror type} and
+ * {@linkplain Qualifier qualifier} to which binding can occur.
+ *
+ * @author Gregory Kick
+ */
+@AutoValue
+abstract class Key {
+  abstract Optional<AnnotationMirror> qualifier();
+
+  /**
+   * As documented in {@link TypeMirror}, equals and hashCode aren't implemented to represent
+   * logical equality, so we use {@link Mirrors#equivalence()} for this object.
+   */
+  abstract Equivalence.Wrapper<TypeMirror> wrappedType();
+
+  TypeMirror type() {
+    return wrappedType().get();
+  }
+
+  @Override
+  public String toString() {
+    return Objects.toStringHelper(this)
+        .omitNullValues()
+        .add("qualifier", qualifier().orNull())
+        .add("type", type())
+        .toString();
+  }
+
+  static Key create(TypeMirror type) {
+    return new AutoValue_Key(Optional.<AnnotationMirror>absent(), Mirrors.equivalence().wrap(type));
+  }
+
+  static Key create(AnnotationMirror qualifier, TypeMirror type) {
+    return new AutoValue_Key(Optional.of(qualifier), Mirrors.equivalence().wrap(type));
+  }
+
+  // TODO(gak): decide whether to address set bindings here or someplace else
+  static Key forProvidesMethod(ExecutableElement e) {
+    checkNotNull(e);
+    checkArgument(e.getKind().equals(METHOD));
+    checkArgument(e.getAnnotation(Provides.class) != null);
+    return new AutoValue_Key(getQualifier(e), Mirrors.equivalence().wrap(e.getReturnType()));
+  }
+
+  static Key forComponentMethod(ExecutableElement e) {
+    checkNotNull(e);
+    checkArgument(e.getKind().equals(METHOD));
+    checkArgument(e.getParameters().isEmpty());
+    return new AutoValue_Key(getQualifier(e), Mirrors.equivalence().wrap(e.getReturnType()));
+  }
+
+  static Key forInjectConstructor(ExecutableElement e) {
+    checkNotNull(e);
+    checkArgument(e.getKind().equals(CONSTRUCTOR));
+    checkArgument(!getQualifier(e).isPresent());
+    // Must use the enclosing element.  The return type is void for constructors(?!)
+    TypeMirror type = e.getEnclosingElement().asType();
+    return new AutoValue_Key(Optional.<AnnotationMirror>absent(), Mirrors.equivalence().wrap(type));
+  }
+
+  private static Optional<AnnotationMirror> getQualifier(Element e) {
+    List<? extends AnnotationMirror> annotations = e.getAnnotationMirrors();
+    Iterator<? extends AnnotationMirror> qualifiers = FluentIterable.from(annotations)
+        .filter(new Predicate<AnnotationMirror>() {
+          @Override
+          public boolean apply(AnnotationMirror input) {
+            return input.getAnnotationType().asElement().getAnnotation(Qualifier.class) != null;
+          }
+        })
+        .iterator();
+    if (qualifiers.hasNext()) {
+      AnnotationMirror qualifier = qualifiers.next();
+      checkState(!qualifiers.hasNext(), "More than one qualifier was present.");
+      return Optional.of(qualifier);
+    } else {
+      return Optional.absent();
+    }
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/KeyRequest.java b/compiler/src/main/java/dagger/internal/codegen/KeyRequest.java
new file mode 100644
index 000000000..71186804d
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/KeyRequest.java
@@ -0,0 +1,54 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.value.AutoValue;
+
+import dagger.Provides;
+
+import javax.inject.Inject;
+
+
+/**
+ * Represents a request for a key at an injection point. Parameters to {@link Inject} constructors
+ * or {@link Provides} methods are examples of key requests.
+ *
+ * @author Gregory Kick
+ */
+// TODO(gak): Set bindings and the permutations thereof need to be addressed
+@AutoValue
+abstract class KeyRequest {
+  enum Kind {
+    INSTANCE,
+    PROVIDER,
+    LAZY,
+  }
+
+  abstract Kind type();
+  abstract Key key();
+
+  static KeyRequest instanceRequest(Key key) {
+    return new AutoValue_KeyRequest(Kind.INSTANCE, key);
+  }
+
+  static KeyRequest providerRequest(Key key) {
+    return new AutoValue_KeyRequest(Kind.PROVIDER, key);
+  }
+
+  static KeyRequest lazyRequest(Key key) {
+    return new AutoValue_KeyRequest(Kind.LAZY, key);
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/Mirrors.java b/compiler/src/main/java/dagger/internal/codegen/Mirrors.java
new file mode 100644
index 000000000..10c5d2dc4
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/Mirrors.java
@@ -0,0 +1,247 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import static javax.lang.model.type.TypeKind.ARRAY;
+import static javax.lang.model.type.TypeKind.DECLARED;
+import static javax.lang.model.type.TypeKind.EXECUTABLE;
+import static javax.lang.model.type.TypeKind.TYPEVAR;
+import static javax.lang.model.type.TypeKind.WILDCARD;
+
+import com.google.common.base.Equivalence;
+
+import java.util.Iterator;
+import java.util.List;
+
+import javax.lang.model.type.ArrayType;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.ErrorType;
+import javax.lang.model.type.ExecutableType;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.type.TypeVariable;
+import javax.lang.model.type.TypeVisitor;
+import javax.lang.model.type.WildcardType;
+import javax.lang.model.util.SimpleTypeVisitor6;
+
+/**
+ * Utilities related to {@link TypeMirror} instances.
+ *
+ * @author Gregory Kick
+ */
+final class Mirrors {
+  private static final Equivalence<TypeMirror> TYPE_EQUIVALENCE = new Equivalence<TypeMirror>() {
+    @Override
+    protected boolean doEquivalent(TypeMirror a, TypeMirror b) {
+      return Mirrors.equal(a, b);
+    }
+
+    @Override
+    protected int doHash(TypeMirror t) {
+      return Mirrors.hash(t);
+    }
+  };
+
+  static Equivalence<TypeMirror> equivalence() {
+    return TYPE_EQUIVALENCE;
+  }
+
+  private static final TypeVisitor<Boolean, TypeMirror> EQUAL_VISITOR =
+      new SimpleTypeVisitor6<Boolean, TypeMirror>() {
+        @Override
+        protected Boolean defaultAction(TypeMirror a, TypeMirror b) {
+          return a.getKind().equals(b.getKind());
+        }
+
+        @Override
+        public Boolean visitArray(ArrayType a, TypeMirror m) {
+          if (m.getKind().equals(ARRAY)) {
+            ArrayType b = (ArrayType) m;
+            return equal(a.getComponentType(), b.getComponentType());
+          }
+          return false;
+        }
+
+        @Override
+        public Boolean visitDeclared(DeclaredType a, TypeMirror m) {
+          if (m.getKind().equals(DECLARED)) {
+            DeclaredType b = (DeclaredType) m;
+            return a.asElement().equals(b.asElement())
+                && equal(a.getEnclosingType(), a.getEnclosingType())
+                && equalLists(a.getTypeArguments(), b.getTypeArguments());
+
+          }
+          return false;
+        }
+
+        @Override
+        public Boolean visitError(ErrorType a, TypeMirror m) {
+          return a.equals(m);
+        }
+
+        @Override
+        public Boolean visitExecutable(ExecutableType a, TypeMirror m) {
+          if (m.getKind().equals(EXECUTABLE)) {
+            ExecutableType b = (ExecutableType) m;
+            return equalLists(a.getParameterTypes(), b.getParameterTypes())
+                && equal(a.getReturnType(), b.getReturnType())
+                && equalLists(a.getThrownTypes(), b.getThrownTypes())
+                && equalLists(a.getTypeVariables(), b.getTypeVariables());
+          }
+          return false;
+        }
+
+        @Override
+        public Boolean visitTypeVariable(TypeVariable a, TypeMirror m) {
+          if (m.getKind().equals(TYPEVAR)) {
+            TypeVariable b = (TypeVariable) m;
+            return equal(a.getUpperBound(), b.getUpperBound())
+                && equal(a.getLowerBound(), b.getLowerBound());
+          }
+          return false;
+        }
+
+        @Override
+        public Boolean visitWildcard(WildcardType a, TypeMirror m) {
+          if (m.getKind().equals(WILDCARD)) {
+            WildcardType b = (WildcardType) m;
+            return equal(a.getExtendsBound(), b.getExtendsBound())
+                && equal(a.getSuperBound(), b.getSuperBound());
+          }
+          return false;
+        }
+
+        @Override
+        public Boolean visitUnknown(TypeMirror a, TypeMirror p) {
+          throw new UnsupportedOperationException();
+        }
+      };
+
+  static boolean equal(TypeMirror a, TypeMirror b) {
+    return (a == b) || (a != null && b != null && a.accept(EQUAL_VISITOR, b));
+  }
+
+  private static boolean equalLists(List<? extends TypeMirror> a, List<? extends TypeMirror> b) {
+    int size = a.size();
+    if (size != b.size()) {
+      return false;
+    }
+    // Use iterators in case the Lists aren't RandomAccess
+    Iterator<? extends TypeMirror> aIterator = a.iterator();
+    Iterator<? extends TypeMirror> bIterator = b.iterator();
+    while (aIterator.hasNext()) {
+      if (!bIterator.hasNext()) {
+        return false;
+      }
+      TypeMirror nextMirrorA = aIterator.next();
+      TypeMirror nextMirrorB = bIterator.next();
+      if (!equal(nextMirrorA, nextMirrorB)) {
+        return false;
+      }
+    }
+    return !aIterator.hasNext();
+  }
+
+  private static final int HASH_SEED = 17;
+  private static final int HASH_MULTIPLIER = 31;
+
+  private static final TypeVisitor<Integer, Void> HASH_VISITOR =
+      new SimpleTypeVisitor6<Integer, Void>() {
+          int hashKind(int seed, TypeMirror t) {
+            int result = seed * HASH_MULTIPLIER;
+            result += t.getKind().hashCode();
+            return result;
+          }
+
+          @Override
+          protected Integer defaultAction(TypeMirror e, Void p) {
+            return hashKind(HASH_SEED, e);
+          }
+
+          @Override
+          public Integer visitArray(ArrayType t, Void v) {
+            int result = hashKind(HASH_SEED, t);
+            result *= HASH_MULTIPLIER;
+            result += t.getComponentType().accept(this, null);
+            return result;
+          }
+
+          @Override
+          public Integer visitDeclared(DeclaredType t, Void v) {
+            int result = hashKind(HASH_SEED, t);
+            result *= HASH_MULTIPLIER;
+            result += t.asElement().hashCode();
+            result *= HASH_MULTIPLIER;
+            result += t.getEnclosingType().accept(this, null);
+            result *= HASH_MULTIPLIER;
+            result += hashList(t.getTypeArguments());
+            return result;
+          }
+
+          @Override
+          public Integer visitExecutable(ExecutableType t, Void p) {
+            int result = hashKind(HASH_SEED, t);
+            result *= HASH_MULTIPLIER;
+            result += hashList(t.getParameterTypes());
+            result *= HASH_MULTIPLIER;
+            result += t.getReturnType().accept(this, null);
+            result *= HASH_MULTIPLIER;
+            result += hashList(t.getThrownTypes());
+            result *= HASH_MULTIPLIER;
+            result += hashList(t.getTypeVariables());
+            return result;
+          }
+
+          @Override
+          public Integer visitTypeVariable(TypeVariable t, Void p) {
+            int result = hashKind(HASH_SEED, t);
+            result *= HASH_MULTIPLIER;
+            result += t.getLowerBound().accept(this, null);
+            result *= HASH_MULTIPLIER;
+            result += t.getUpperBound().accept(this, null);
+            return result;
+          }
+
+          @Override
+          public Integer visitWildcard(WildcardType t, Void p) {
+            int result = hashKind(HASH_SEED, t);
+            result *= HASH_MULTIPLIER;
+            result += (t.getExtendsBound() == null) ? 0 : t.getExtendsBound().accept(this, null);
+            result *= HASH_MULTIPLIER;
+            result += (t.getSuperBound() == null) ? 0 : t.getSuperBound().accept(this, null);
+            return result;
+          }
+
+          @Override
+          public Integer visitUnknown(TypeMirror t, Void p) {
+            throw new UnsupportedOperationException();
+          }
+      };
+
+  static int hashList(List<? extends TypeMirror> mirrors) {
+    int result = HASH_SEED;
+    for (TypeMirror mirror : mirrors) {
+      result *= HASH_MULTIPLIER;
+      result += hash(mirror);
+    }
+    return result;
+  }
+
+  static int hash(TypeMirror mirror) {
+    return mirror == null ? 0 : mirror.accept(HASH_VISITOR, null);
+  }
+
+  private Mirrors() {}
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java
index e2d74f2e5..f10efa31d 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java
@@ -95,7 +95,11 @@
   }
 
   @Override public boolean process(Set<? extends TypeElement> types, RoundEnvironment env) {
-    remainingTypes.putAll(providerMethodsByClass(env));
+    try {
+      remainingTypes.putAll(providerMethodsByClass(env));
+    } catch (ClassCastException e) {
+      return false; // upstream compiler issues - bail cleanly.
+    }
     for (Iterator<String> i = remainingTypes.keySet().iterator(); i.hasNext();) {
       String typeName = i.next();
       TypeElement type = processingEnv.getElementUtils().getTypeElement(typeName);
diff --git a/compiler/src/test/java/dagger/internal/codegen/KeyTest.java b/compiler/src/test/java/dagger/internal/codegen/KeyTest.java
new file mode 100644
index 000000000..040b6bf32
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/KeyTest.java
@@ -0,0 +1,100 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import static org.truth0.Truth.ASSERT;
+
+import com.google.common.collect.Iterables;
+import com.google.testing.compile.CompilationRule;
+
+import dagger.Module;
+import dagger.Provides;
+
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import javax.inject.Inject;
+import javax.inject.Qualifier;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.ElementFilter;
+import javax.lang.model.util.Elements;
+
+/**
+ * Tests {@link Key}.
+ */
+@RunWith(JUnit4.class)
+public class KeyTest {
+  @Rule public CompilationRule compilationRule = new CompilationRule();
+
+  @Test public void forInjectConstructor() {
+    TypeElement typeElement =
+        compilationRule.getElements().getTypeElement(InjectedClass.class.getCanonicalName());
+    ExecutableElement constructor =
+        Iterables.getOnlyElement(ElementFilter.constructorsIn(typeElement.getEnclosedElements()));
+    ASSERT.that(Key.forInjectConstructor(constructor)).isEqualTo(Key.create(typeElement.asType()));
+  }
+
+  static final class InjectedClass {
+    @SuppressWarnings("unused")
+    @Inject InjectedClass(String s, int i) {}
+  }
+
+  @Test public void forProvidesMethod() {
+    Elements elements = compilationRule.getElements();
+    TypeMirror stringType = elements.getTypeElement(String.class.getCanonicalName()).asType();
+    TypeElement moduleElement =
+        elements.getTypeElement(ProvidesMethodModule.class.getCanonicalName());
+    ExecutableElement providesMethod =
+        Iterables.getOnlyElement(ElementFilter.methodsIn(moduleElement.getEnclosedElements()));
+    ASSERT.that(Key.forProvidesMethod(providesMethod)).isEqualTo(Key.create(stringType));
+  }
+
+  @Module(library = true)
+  static final class ProvidesMethodModule {
+    @Provides String provideString() {
+      return null;
+    }
+  }
+
+  @Test public void forProvidesMethod_qualified() {
+    Elements elements = compilationRule.getElements();
+    TypeMirror stringType = elements.getTypeElement(String.class.getCanonicalName()).asType();
+    TypeElement qualifierElement =
+        elements.getTypeElement(TestQualifier.class.getCanonicalName());
+    TypeElement moduleElement =
+        elements.getTypeElement(QualifiedProvidesMethodModule.class.getCanonicalName());
+    ExecutableElement providesMethod =
+        Iterables.getOnlyElement(ElementFilter.methodsIn(moduleElement.getEnclosedElements()));
+    Key key = Key.forProvidesMethod(providesMethod);
+    ASSERT.that(Mirrors.equivalence().wrap(key.qualifier().get().getAnnotationType()))
+        .isEqualTo(Mirrors.equivalence().wrap(qualifierElement.asType()));
+    ASSERT.that(key.wrappedType()).isEqualTo(Mirrors.equivalence().wrap(stringType));
+  }
+
+  @Module(library = true)
+  static final class QualifiedProvidesMethodModule {
+    @Provides @TestQualifier String provideQualifiedString() {
+      return null;
+    }
+  }
+
+  @Qualifier
+  @interface TestQualifier {}
+}
diff --git a/compiler/src/test/java/dagger/internal/codegen/MirrorsTest.java b/compiler/src/test/java/dagger/internal/codegen/MirrorsTest.java
new file mode 100644
index 000000000..5eb86ef5c
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/MirrorsTest.java
@@ -0,0 +1,207 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import static javax.lang.model.type.TypeKind.NONE;
+import static javax.lang.model.type.TypeKind.VOID;
+
+import com.google.common.base.Function;
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.testing.EquivalenceTester;
+import com.google.testing.compile.CompilationRule;
+
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import java.lang.annotation.Annotation;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.ErrorType;
+import javax.lang.model.type.PrimitiveType;
+import javax.lang.model.type.TypeKind;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.type.TypeVisitor;
+import javax.lang.model.type.WildcardType;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
+
+/**
+ * Tests {@link Mirrors}.
+ */
+@RunWith(JUnit4.class)
+public class MirrorsTest {
+  @Rule public CompilationRule compilationRule = new CompilationRule();
+
+  @Test
+  public void equivalence() {
+    Types types = compilationRule.getTypes();
+    Elements elements = compilationRule.getElements();
+    TypeMirror objectType = elements.getTypeElement(Object.class.getCanonicalName()).asType();
+    TypeMirror stringType = elements.getTypeElement(String.class.getCanonicalName()).asType();
+    TypeElement mapElement = elements.getTypeElement(Map.class.getCanonicalName());
+    TypeElement setElement = elements.getTypeElement(Set.class.getCanonicalName());
+    DeclaredType mapOfObjectToObjectType =
+        types.getDeclaredType(mapElement, objectType, objectType);
+    TypeMirror mapType = mapElement.asType();
+    WildcardType wildcard = types.getWildcardType(null, null);
+    EquivalenceTester<TypeMirror> tester = EquivalenceTester.of(Mirrors.equivalence())
+        .addEquivalenceGroup(types.getNullType())
+        .addEquivalenceGroup(types.getNoType(NONE))
+        .addEquivalenceGroup(types.getNoType(VOID))
+        .addEquivalenceGroup(objectType)
+        .addEquivalenceGroup(stringType)
+        // Map<K, V>
+        .addEquivalenceGroup(mapType)
+        .addEquivalenceGroup(mapOfObjectToObjectType)
+        // Map<?, ?>
+        .addEquivalenceGroup(types.getDeclaredType(mapElement, wildcard, wildcard))
+        // Map
+        .addEquivalenceGroup(types.erasure(mapType), types.erasure(mapOfObjectToObjectType))
+        .addEquivalenceGroup(types.getDeclaredType(mapElement, objectType, stringType))
+        .addEquivalenceGroup(types.getDeclaredType(mapElement, stringType, objectType))
+        .addEquivalenceGroup(types.getDeclaredType(mapElement, stringType, stringType))
+        .addEquivalenceGroup(wildcard)
+        // ? extends Object
+        .addEquivalenceGroup(types.getWildcardType(objectType, null))
+        // ? extends String
+        .addEquivalenceGroup(types.getWildcardType(stringType, null))
+        // ? super String
+        .addEquivalenceGroup(types.getWildcardType(null, stringType))
+        // Map<String, Map<String, Set<Object>>>
+        .addEquivalenceGroup(types.getDeclaredType(mapElement, stringType,
+            types.getDeclaredType(mapElement, stringType,
+                types.getDeclaredType(setElement, objectType))))
+        .addEquivalenceGroup(FAKE_ERROR_TYPE)
+        ;
+
+    for (TypeKind kind : TypeKind.values()) {
+      if (kind.isPrimitive()) {
+        PrimitiveType primitiveType = types.getPrimitiveType(kind);
+        TypeMirror boxedPrimitiveType = types.boxedClass(primitiveType).asType();
+        tester.addEquivalenceGroup(primitiveType, types.unboxedType(boxedPrimitiveType));
+        tester.addEquivalenceGroup(boxedPrimitiveType);
+        tester.addEquivalenceGroup(types.getArrayType(primitiveType));
+        tester.addEquivalenceGroup(types.getArrayType(boxedPrimitiveType));
+      }
+    }
+
+    ImmutableSet<Class<?>> testClasses = ImmutableSet.of(
+        ExecutableElementsGroupA.class,
+        ExecutableElementsGroupB.class,
+        ExecutableElementsGroupC.class,
+        ExecutableElementsGroupD.class,
+        ExecutableElementsGroupE.class);
+    for (Class<?> testClass : testClasses) {
+      ImmutableList<TypeMirror> equivalenceGroup = FluentIterable.from(
+          elements.getTypeElement(testClass.getCanonicalName()).getEnclosedElements())
+              .transform(new Function<Element, TypeMirror>() {
+                @Override public TypeMirror apply(Element input) {
+                  return input.asType();
+                }
+              })
+              .toList();
+      tester.addEquivalenceGroup(equivalenceGroup);
+    }
+
+    tester.test();
+  }
+
+  @SuppressWarnings("unused")
+  private static final class ExecutableElementsGroupA {
+    ExecutableElementsGroupA() {}
+    void a() {}
+    public static void b() {}
+  }
+
+  @SuppressWarnings("unused")
+  private static final class ExecutableElementsGroupB {
+    ExecutableElementsGroupB(String s) {}
+    void a(String s) {}
+    public static void b(String s) {}
+  }
+
+  @SuppressWarnings("unused")
+  private static final class ExecutableElementsGroupC {
+    ExecutableElementsGroupC() throws Exception {}
+    void a() throws Exception {}
+    public static void b() throws Exception {}
+  }
+
+  @SuppressWarnings("unused")
+  private static final class ExecutableElementsGroupD {
+    ExecutableElementsGroupD() throws RuntimeException {}
+    void a() throws RuntimeException {}
+    public static void b() throws RuntimeException {}
+  }
+
+  @SuppressWarnings("unused")
+  private static final class ExecutableElementsGroupE {
+    <T> ExecutableElementsGroupE() {}
+    <T> void a() {}
+    public static <T> void b() {}
+  }
+
+  private static final ErrorType FAKE_ERROR_TYPE = new ErrorType() {
+    @Override
+    public TypeKind getKind() {
+      return TypeKind.ERROR;
+    }
+
+    @Override
+    public <R, P> R accept(TypeVisitor<R, P> v, P p) {
+      return v.visitError(this, p);
+    }
+
+    @Override
+    public List<? extends TypeMirror> getTypeArguments() {
+      return ImmutableList.of();
+    }
+
+    @Override
+    public TypeMirror getEnclosingType() {
+      return null;
+    }
+
+    @Override
+    public Element asElement() {
+      return null;
+    }
+
+    // JDK8 Compatibility:
+
+    public <A extends Annotation> A[] getAnnotationsByType(Class<A> annotationType) {
+      return null;
+    }
+
+    public <A extends Annotation> A getAnnotation(Class<A> annotationType) {
+      return null;
+    }
+
+    public List<? extends AnnotationMirror> getAnnotationMirrors() {
+      return null;
+    }
+  };
+}
diff --git a/core/pom.xml b/core/pom.xml
index 96f85a134..c9780ea86 100644
--- a/core/pom.xml
+++ b/core/pom.xml
@@ -42,6 +42,11 @@
       <artifactId>fest-assert</artifactId>
       <scope>test</scope>
     </dependency>
+    <dependency>
+      <groupId>org.truth0</groupId>
+      <artifactId>truth</artifactId>
+      <scope>test</scope>
+    </dependency>
   </dependencies>
 
   <build>
diff --git a/core/src/main/java/dagger/Factory.java b/core/src/main/java/dagger/Factory.java
new file mode 100644
index 000000000..74e2d0d12
--- /dev/null
+++ b/core/src/main/java/dagger/Factory.java
@@ -0,0 +1,37 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger;
+
+import javax.inject.Inject;
+import javax.inject.Provider;
+import javax.inject.Scope;
+
+/**
+ * An {@linkplain Scope unscoped} {@link Provider}. While a {@link Provider} <i>may<i> apply
+ * scoping semantics while providing an instance, a factory implementation is guaranteed to exercise
+ * the binding logic ({@link Inject} constructors, {@link Provides} methods) upon each call to
+ * {@link #get}.
+ *
+ * <p>Note that while subsequent calls to {@link #get} will create new instances for bindings such
+ * as those created by {@link Inject} constructors, a new instance is not guaranteed by all
+ * bindings. For example, {@link Provides} methods may be implemented in ways that return the same
+ * instance for each call.
+ *
+ * @author Gregory Kick
+ * @since 2.0
+ */
+public interface Factory<T> extends Provider<T> {
+}
diff --git a/core/src/main/java/dagger/internal/Keys.java b/core/src/main/java/dagger/internal/Keys.java
index fb65cc67b..2a5fe120f 100644
--- a/core/src/main/java/dagger/internal/Keys.java
+++ b/core/src/main/java/dagger/internal/Keys.java
@@ -189,7 +189,7 @@ static String getBuiltInBindingsKey(String key) {
   }
 
   /**
-   * Returns a key for the underlying binding of a Lazy<T> value. For example,
+   * Returns a key for the underlying binding of a {@code Lazy<T>} value. For example,
    * if this is a key for a {@code Lazy<Foo>}, this returns the key for
    * {@code Foo}. This retains annotations.
    */
@@ -211,7 +211,7 @@ private static int startOfType(String key) {
   }
 
   /**
-   * Returns an unwrapped key (the key for T from a Provider<T> for example),
+   * Returns an unwrapped key (the key for {@code T} from a {@code Provider<T>} for example),
    * removing all wrapping key information, but preserving annotations or known
    * prefixes.
    *
diff --git a/core/src/main/java/dagger/internal/ProvidesBinding.java b/core/src/main/java/dagger/internal/ProvidesBinding.java
index 2e6f98922..43b3ac2c6 100644
--- a/core/src/main/java/dagger/internal/ProvidesBinding.java
+++ b/core/src/main/java/dagger/internal/ProvidesBinding.java
@@ -30,7 +30,10 @@
    */
   public ProvidesBinding(String key, boolean singleton, String moduleClass, String methodName) {
     // Set requiredBy as fullMethodName to preserve older debugging meaning.
-    super(key, null, singleton, moduleClass + "." + methodName + "()");
+    // Use an explicitly sized StringBuilder as this code is invoked often
+    super(key, null, singleton,
+        new StringBuilder(moduleClass.length() + methodName.length() + 3)
+            .append(moduleClass).append('.').append(methodName).append("()").toString());
     this.moduleClass = moduleClass;
     this.methodName = methodName;
   }
diff --git a/core/src/main/java/dagger/internal/ScopedProvider.java b/core/src/main/java/dagger/internal/ScopedProvider.java
new file mode 100644
index 000000000..eaaa78d76
--- /dev/null
+++ b/core/src/main/java/dagger/internal/ScopedProvider.java
@@ -0,0 +1,62 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal;
+
+import dagger.Factory;
+
+import javax.inject.Provider;
+
+/**
+ * A {@link Provider} implementation that memoizes the result of a {@link Factory} instance.
+ *
+ * @author Gregory Kick
+ * @since 2.0
+ */
+public final class ScopedProvider<T> implements Provider<T> {
+  private final Factory<T> factory;
+  private volatile T instance = null;
+
+  private ScopedProvider(Factory<T> factory) {
+    assert factory != null;
+    this.factory = factory;
+  }
+
+  @Override
+  public T get() {
+    // double-check idiom from EJ2: Item 71
+    T result = instance;
+    if (result == null) {
+      synchronized (this) {
+        result = instance;
+        if (result == null) {
+          instance = result = factory.get();
+          if (result == null) {
+            throw new NullPointerException(factory + " returned null");
+          }
+        }
+      }
+    }
+    return result;
+  }
+
+  /** Returns a new scoped provider for the given factory. */
+  public static <T> Provider<T> create(Factory<T> factory) {
+    if (factory == null) {
+      throw new NullPointerException();
+    }
+    return new ScopedProvider<T>(factory);
+  }
+}
diff --git a/core/src/test/java/dagger/internal/ScopedProviderTest.java b/core/src/test/java/dagger/internal/ScopedProviderTest.java
new file mode 100644
index 000000000..5544d1858
--- /dev/null
+++ b/core/src/test/java/dagger/internal/ScopedProviderTest.java
@@ -0,0 +1,66 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal;
+
+import static org.junit.Assert.fail;
+import static org.truth0.Truth.ASSERT;
+
+import dagger.Factory;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import javax.inject.Provider;
+
+/**
+ * Tests {@link ScopedProvider}.
+ */
+@RunWith(JUnit4.class)
+public class ScopedProviderTest {
+  @Test public void create_nullPointerException() {
+    try {
+      ScopedProvider.create(null);
+      fail();
+    } catch (NullPointerException expected) { }
+  }
+
+  @Test public void get_nullPointerException() {
+    Provider<Object> scopedProvider = ScopedProvider.create(new Factory<Object>() {
+      @Override public Object get() {
+        return null;
+      }
+    });
+    try {
+      scopedProvider.get();
+      fail();
+    } catch (NullPointerException expected) {
+    }
+  }
+
+  @Test public void get() {
+    Provider<Integer> scopedProvider = ScopedProvider.create(new Factory<Integer>() {
+      int i = 0;
+
+      @Override public Integer get() {
+        return i++;
+      }
+    });
+    ASSERT.that(scopedProvider.get()).is(0);
+    ASSERT.that(scopedProvider.get()).is(0);
+    ASSERT.that(scopedProvider.get()).is(0);
+  }
+}
diff --git a/deploy_website.sh b/deploy_website.sh
old mode 100755
new mode 100644
diff --git a/examples/android-activity-graphs/res/values/strings.xml b/examples/android-activity-graphs/res/values/strings.xml
deleted file mode 100644
index 4247e0349..000000000
--- a/examples/android-activity-graphs/res/values/strings.xml
+++ /dev/null
@@ -1,4 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<resources>
-  <string name="app_name">Dagger Activity Graph</string>
-</resources>
diff --git a/examples/android-simple/res/values/strings.xml b/examples/android-simple/res/values/strings.xml
deleted file mode 100644
index 7c398f540..000000000
--- a/examples/android-simple/res/values/strings.xml
+++ /dev/null
@@ -1,4 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<resources>
-  <string name="app_name">Dagger Simple</string>
-</resources>
diff --git a/pom.xml b/pom.xml
index 78c4f5d18..2305f863e 100644
--- a/pom.xml
+++ b/pom.xml
@@ -44,7 +44,7 @@
     <java.version>1.6</java.version>
     <javax.inject.version>1</javax.inject.version>
     <javawriter.version>2.3.0</javawriter.version>
-    <guava.version>15.0</guava.version>
+    <guava.version>16.0.1</guava.version>
 
     <!-- Test Dependencies -->
     <junit.version>4.10</junit.version>
@@ -94,6 +94,11 @@
         <artifactId>guava</artifactId>
         <version>${guava.version}</version>
       </dependency>
+      <dependency>
+        <groupId>com.google.guava</groupId>
+        <artifactId>guava-testlib</artifactId>
+        <version>${guava.version}</version>
+      </dependency>
       <dependency>
         <groupId>junit</groupId>
         <artifactId>junit</artifactId>
