diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
index 56dac91de..f80d2f93d 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -150,6 +150,7 @@
     void validateSubgraph() {
       validateComponentScope();
       validateDependencyScopes();
+      validateComponentHierarchy();
       validateBuilders();
 
       for (ComponentMethodDescriptor componentMethod :
@@ -479,6 +480,51 @@ public Boolean visitPrimitive(PrimitiveType t, Void p) {
               null);
     }
 
+    /**
+     * Validates that component dependencies do not form a cycle.
+     */
+    private void validateComponentHierarchy() {
+      ComponentDescriptor descriptor = subject.componentDescriptor();
+      TypeElement componentType = descriptor.componentDefinitionType();
+      validateComponentHierarchy(componentType, componentType, new ArrayDeque<TypeElement>());
+    }
+
+    /**
+     * Recursive method to validate that component dependencies do not form a cycle.
+     */
+    private void validateComponentHierarchy(
+        TypeElement rootComponent,
+        TypeElement componentType,
+        Deque<TypeElement> componentStack) {
+
+      if (componentStack.contains(componentType)) {
+        // Current component has already appeared in the component chain.
+        StringBuilder message = new StringBuilder();
+        message.append(rootComponent.getQualifiedName());
+        message.append(" contains a cycle in its component dependencies:\n");
+        componentStack.push(componentType);
+        appendIndentedComponentsList(message, componentStack);
+        componentStack.pop();
+        reportBuilder.addItem(message.toString(),
+            scopeCycleValidationType.diagnosticKind().get(),
+            rootComponent, getAnnotationMirror(rootComponent, Component.class).get());
+      } else {
+        Optional<AnnotationMirror> componentAnnotation =
+            getAnnotationMirror(componentType, Component.class);
+        if (componentAnnotation.isPresent()) {
+          componentStack.push(componentType);
+
+          ImmutableSet<TypeElement> dependencies =
+              MoreTypes.asTypeElements(getComponentDependencies(componentAnnotation.get()));
+          for (TypeElement dependency : dependencies) {
+            validateComponentHierarchy(rootComponent, dependency, componentStack);
+          }
+
+          componentStack.pop();
+        }
+      }
+    }
+
     /**
      * Validates that among the dependencies are at most one scoped dependency,
      * that there are no cycles within the scoping chain, and that singleton
@@ -587,7 +633,8 @@ public boolean apply(TypeElement input) {
      *
      * <p>As a side-effect, this means scoped components cannot have a dependency cycle between
      * themselves, since a component's presence within its own dependency path implies a cyclical
-     * relationship between scopes.
+     * relationship between scopes. However, cycles in component dependencies are explicitly
+     * checked in {@link #validateComponentHierarchy()}.
      */
     private void validateScopeHierarchy(TypeElement rootComponent,
         TypeElement componentType,
diff --git a/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java b/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
index 5356c2722..36303f1e9 100644
--- a/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
@@ -29,6 +29,7 @@
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
 import static dagger.internal.codegen.ErrorMessages.NULLABLE_TO_NON_NULLABLE;
+import static java.util.Arrays.asList;
 
 @RunWith(JUnit4.class)
 public class GraphValidationTest {
@@ -1048,4 +1049,75 @@ public void falsePositiveCyclicDependencyIndirectionDetected() {
         .processedWith(new ComponentProcessor())
         .compilesWithoutError();
   }
+
+  @Test public void componentDependencyMustNotCycle_Direct() {
+    JavaFileObject shortLifetime = JavaFileObjects.forSourceLines("test.ComponentShort",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component(dependencies = ComponentShort.class)",
+        "interface ComponentShort {",
+        "}");
+    String errorMessage =
+        "test.ComponentShort contains a cycle in its component dependencies:\n"
+            + "      test.ComponentShort";
+    assertAbout(javaSource())
+        .that(shortLifetime)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(errorMessage);
+  }
+
+  @Test public void componentDependencyMustNotCycle_Indirect() {
+    JavaFileObject longLifetime = JavaFileObjects.forSourceLines("test.ComponentLong",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component(dependencies = ComponentMedium.class)",
+        "interface ComponentLong {",
+        "}");
+    JavaFileObject mediumLifetime = JavaFileObjects.forSourceLines("test.ComponentMedium",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component(dependencies = ComponentLong.class)",
+        "interface ComponentMedium {",
+        "}");
+    JavaFileObject shortLifetime = JavaFileObjects.forSourceLines("test.ComponentShort",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component(dependencies = ComponentMedium.class)",
+        "interface ComponentShort {",
+        "}");
+    String longErrorMessage =
+        "test.ComponentLong contains a cycle in its component dependencies:\n"
+            + "      test.ComponentLong\n"
+            + "      test.ComponentMedium\n"
+            + "      test.ComponentLong";
+    String mediumErrorMessage =
+        "test.ComponentMedium contains a cycle in its component dependencies:\n"
+            + "      test.ComponentMedium\n"
+            + "      test.ComponentLong\n"
+            + "      test.ComponentMedium";
+    String shortErrorMessage =
+        "test.ComponentShort contains a cycle in its component dependencies:\n"
+            + "      test.ComponentMedium\n"
+            + "      test.ComponentLong\n"
+            + "      test.ComponentMedium\n"
+            + "      test.ComponentShort";
+    assertAbout(javaSources())
+        .that(ImmutableList.of(longLifetime, mediumLifetime, shortLifetime))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(longErrorMessage).in(longLifetime)
+        .and()
+        .withErrorContaining(mediumErrorMessage).in(mediumLifetime)
+        .and()
+        .withErrorContaining(shortErrorMessage).in(shortLifetime);
+  }
 }
