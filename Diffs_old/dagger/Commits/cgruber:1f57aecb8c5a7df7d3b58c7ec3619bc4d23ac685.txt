diff --git a/compiler/src/it/producers-functional-tests/src/main/java/test/badexecutor/ComponentDependency.java b/compiler/src/it/producers-functional-tests/src/main/java/test/badexecutor/ComponentDependency.java
new file mode 100644
index 000000000..eac62db2a
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/test/badexecutor/ComponentDependency.java
@@ -0,0 +1,22 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.badexecutor;
+
+import com.google.common.util.concurrent.ListenableFuture;
+
+interface ComponentDependency {
+  ListenableFuture<Double> doubleDep();
+}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/test/badexecutor/SimpleComponent.java b/compiler/src/it/producers-functional-tests/src/main/java/test/badexecutor/SimpleComponent.java
new file mode 100644
index 000000000..adc5675f3
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/test/badexecutor/SimpleComponent.java
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.badexecutor;
+
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.producers.ProductionComponent;
+
+/**
+ * A component that contains entry points that exercise different execution paths, for verifying the
+ * behavior when the executor throws a {@link java.util.concurrent.RejectedExecutionException}.
+ */
+@ProductionComponent(dependencies = ComponentDependency.class, modules = SimpleProducerModule.class)
+interface SimpleComponent {
+  /** An entry point exposing a producer method with no args. */
+  ListenableFuture<String> noArgStr();
+
+  /** An entry point exposing a producer method that depends on another producer method. */
+  ListenableFuture<Integer> singleArgInt();
+
+  /** An entry point exposing a producer method that depends on a component dependency method. */
+  ListenableFuture<Boolean> singleArgBool();
+
+  /** An entry point exposing a component dependency method. */
+  ListenableFuture<Double> doubleDep();
+}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/test/badexecutor/SimpleProducerModule.java b/compiler/src/it/producers-functional-tests/src/main/java/test/badexecutor/SimpleProducerModule.java
new file mode 100644
index 000000000..0c9d9e31d
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/test/badexecutor/SimpleProducerModule.java
@@ -0,0 +1,37 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.badexecutor;
+
+import dagger.producers.ProducerModule;
+import dagger.producers.Produces;
+
+@ProducerModule
+final class SimpleProducerModule {
+  @Produces
+  static String noArgStr() {
+    return "no arg string";
+  }
+
+  @Produces
+  static int singleArgInt(String arg) {
+    return arg.length();
+  }
+
+  @Produces
+  static boolean singleArgBool(double arg) {
+    return arg > 0.0;
+  }
+}
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/test/badexecutor/BadExecutorTest.java b/compiler/src/it/producers-functional-tests/src/test/java/test/badexecutor/BadExecutorTest.java
new file mode 100644
index 000000000..8e6de25e5
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/test/java/test/badexecutor/BadExecutorTest.java
@@ -0,0 +1,74 @@
+package test.badexecutor;
+
+import com.google.common.util.concurrent.Futures;
+import com.google.common.util.concurrent.ListenableFuture;
+import com.google.common.util.concurrent.ListeningExecutorService;
+import com.google.common.util.concurrent.MoreExecutors;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.RejectedExecutionException;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+
+/** This test verifies behavior when the executor throws {@link RejectedExecutionException}. */
+@RunWith(JUnit4.class)
+public final class BadExecutorTest {
+  private SimpleComponent component;
+
+  @Before
+  public void setUpComponent() {
+    ComponentDependency dependency =
+        new ComponentDependency() {
+          @Override
+          public ListenableFuture<Double> doubleDep() {
+            return Futures.immediateFuture(42.0);
+          }
+        };
+    ListeningExecutorService executorService = MoreExecutors.newDirectExecutorService();
+    component =
+        DaggerSimpleComponent.builder()
+            .executor(executorService)
+            .componentDependency(dependency)
+            .build();
+    executorService.shutdown();
+  }
+
+  @Test
+  public void rejectNoArgMethod() throws Exception {
+    try {
+      component.noArgStr().get();
+      fail();
+    } catch (ExecutionException e) {
+      assertThat(e.getCause()).isInstanceOf(RejectedExecutionException.class);
+    }
+  }
+
+  @Test
+  public void rejectSingleArgMethod() throws Exception {
+    try {
+      component.singleArgInt().get();
+      fail();
+    } catch (ExecutionException e) {
+      assertThat(e.getCause()).isInstanceOf(RejectedExecutionException.class);
+    }
+  }
+
+  @Test
+  public void rejectSingleArgFromComponentDepMethod() throws Exception {
+    try {
+      component.singleArgBool().get();
+      fail();
+    } catch (ExecutionException e) {
+      assertThat(e.getCause()).isInstanceOf(RejectedExecutionException.class);
+    }
+  }
+
+  @Test
+  public void doNotRejectComponentDepMethod() throws Exception {
+    assertThat(component.doubleDep().get()).isEqualTo(42.0);
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
index 9ae154886..5712a1e55 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
@@ -47,7 +47,6 @@
 import dagger.producers.monitoring.ProducerToken;
 import dagger.producers.monitoring.ProductionComponentMonitor;
 import java.util.List;
-import java.util.concurrent.Callable;
 import java.util.concurrent.Executor;
 import javax.annotation.Generated;
 import javax.annotation.Nullable;
@@ -144,7 +143,7 @@ ClassName nameGeneratedType(ProductionBinding binding) {
     getMethodWriter.annotate(Override.class);
     getMethodWriter.addModifiers(PROTECTED);
 
-    final ImmutableMap<BindingKey, FrameworkField> fields =
+    ImmutableMap<BindingKey, FrameworkField> fields =
         SourceFiles.generateBindingFieldsForDependencies(
             dependencyRequestMapper, binding.dependencies());
 
@@ -183,134 +182,215 @@ ClassName nameGeneratedType(ProductionBinding binding) {
               : futureAccess);
     }
 
-    if (asyncDependencies.isEmpty()) {
+    FutureTransform futureTransform = FutureTransform.create(fields, binding, asyncDependencies);
+    Snippet transformSnippet =
+        Snippet.format(
+            Joiner.on('\n')
+                .join(
+                    "new %1$s<%2$s, %3$s>() {",
+                    "  %4$s",
+                    "  @Override public %5$s apply(%2$s %6$s) %7$s {",
+                    "    %8$s",
+                    "  }",
+                    "}"),
+            ClassName.fromClass(AsyncFunction.class),
+            futureTransform.applyArgType(),
+            providedTypeName,
+            futureTransform.hasUncheckedCast()
+                ? "@SuppressWarnings(\"unchecked\")  // safe by specification"
+                : "",
+            futureTypeName,
+            futureTransform.applyArgName(),
+            getThrowsClause(binding.thrownTypes()),
+            getInvocationSnippet(!returnsFuture, binding, futureTransform.parameterSnippets()));
+    getMethodWriter
+        .body()
+        .addSnippet(
+            "return %s.transform(%s, %s, executor);",
+            ClassName.fromClass(Futures.class),
+            futureTransform.futureSnippet(),
+            transformSnippet);
+
+    // TODO(gak): write a sensible toString
+    return ImmutableSet.of(writer);
+  }
+
+  /** Represents the transformation of an input future by a producer method. */
+  abstract static class FutureTransform {
+    protected final ImmutableMap<BindingKey, FrameworkField> fields;
+    protected final ProductionBinding binding;
+
+    FutureTransform(ImmutableMap<BindingKey, FrameworkField> fields, ProductionBinding binding) {
+      this.fields = fields;
+      this.binding = binding;
+    }
+
+    /** The snippet representing the future that should be transformed. */
+    abstract Snippet futureSnippet();
+
+    /** The type of the argument to the apply method. */
+    abstract TypeName applyArgType();
+
+    /** The name of the argument to the apply method */
+    abstract String applyArgName();
+
+    /** The snippets to be passed to the produces method itself. */
+    abstract ImmutableList<Snippet> parameterSnippets();
+
+    /** Whether the transform method has an unchecked cast. */
+    boolean hasUncheckedCast() {
+      return false;
+    }
+
+    static FutureTransform create(
+        ImmutableMap<BindingKey, FrameworkField> fields,
+        ProductionBinding binding,
+        ImmutableList<DependencyRequest> asyncDependencies) {
+      if (asyncDependencies.isEmpty()) {
+        return new NoArgFutureTransform(fields, binding);
+      } else if (asyncDependencies.size() == 1) {
+        return new SingleArgFutureTransform(
+            fields, binding, Iterables.getOnlyElement(asyncDependencies));
+      } else {
+        return new MultiArgFutureTransform(fields, binding, asyncDependencies);
+      }
+    }
+  }
+
+  static final class NoArgFutureTransform extends FutureTransform {
+    NoArgFutureTransform(
+        ImmutableMap<BindingKey, FrameworkField> fields, ProductionBinding binding) {
+      super(fields, binding);
+    }
+
+    @Override
+    Snippet futureSnippet() {
+      return Snippet.format(
+          "%s.<%s>immediateFuture(null)",
+          ClassName.fromClass(Futures.class),
+          ClassName.fromClass(Void.class));
+    }
+
+    @Override
+    TypeName applyArgType() {
+      return ClassName.fromClass(Void.class);
+    }
+
+    @Override
+    String applyArgName() {
+      return "ignoredVoidArg";
+    }
+
+    @Override
+    ImmutableList<Snippet> parameterSnippets() {
       ImmutableList.Builder<Snippet> parameterSnippets = ImmutableList.builder();
       for (DependencyRequest dependency : binding.dependencies()) {
-        parameterSnippets.add(frameworkTypeUsageStatement(
-            Snippet.format(fields.get(dependency.bindingKey()).name()), dependency.kind()));
+        parameterSnippets.add(
+            frameworkTypeUsageStatement(
+                Snippet.format(
+                    "%s", fields.get(dependency.bindingKey()).name()), dependency.kind()));
       }
-      final boolean wrapWithFuture = false;  // since submitToExecutor will create the future
-      Snippet invocationSnippet =
-          getInvocationSnippet(wrapWithFuture, binding, parameterSnippets.build());
-      TypeName callableReturnType = returnsFuture ? futureTypeName : providedTypeName;
-      Snippet throwsClause = getThrowsClause(binding.thrownTypes());
-      Snippet callableSnippet =
-          Snippet.format(
-              Joiner.on('\n')
-                  .join(
-                      "new %1$s<%2$s>() {",
-                      "  @Override public %2$s call() %3$s{",
-                      "    %4$s",
-                      "  }",
-                      "}"),
-              ClassName.fromClass(Callable.class),
-              callableReturnType,
-              throwsClause,
-              invocationSnippet);
-      getMethodWriter
-          .body()
-          .addSnippet(
-              "%s future = %s.submitToExecutor(%s, executor);",
-              ParameterizedTypeName.create(
-                  ClassName.fromClass(ListenableFuture.class), callableReturnType),
-              ClassName.fromClass(Producers.class),
-              callableSnippet);
-      getMethodWriter
-          .body()
-          .addSnippet(
-              "return %s;",
-              returnsFuture
-                  ? Snippet.format("%s.dereference(future)", ClassName.fromClass(Futures.class))
-                  : "future");
-    } else {
-      final Snippet futureSnippet;
-      final Snippet transformSnippet;
-      if (asyncDependencies.size() == 1) {
-        DependencyRequest asyncDependency = Iterables.getOnlyElement(asyncDependencies);
-        futureSnippet = Snippet.format("%s",
-            fields.get(asyncDependency.bindingKey()).name() + "Future");
-        String argName = asyncDependency.requestElement().getSimpleName().toString();
-        ImmutableList.Builder<Snippet> parameterSnippets = ImmutableList.builder();
-        for (DependencyRequest dependency : binding.dependencies()) {
-          // We really want to compare instances here, because asyncDependency is an element in the
-          // set binding.dependencies().
-          if (dependency == asyncDependency) {
-            parameterSnippets.add(Snippet.format("%s", argName));
-          } else {
-            parameterSnippets.add(frameworkTypeUsageStatement(
-                Snippet.format(fields.get(dependency.bindingKey()).name()),
-                dependency.kind()));
-          }
+      return parameterSnippets.build();
+    }
+  }
+
+  static final class SingleArgFutureTransform extends FutureTransform {
+    private final DependencyRequest asyncDependency;
+
+    SingleArgFutureTransform(
+        ImmutableMap<BindingKey, FrameworkField> fields,
+        ProductionBinding binding,
+        DependencyRequest asyncDependency) {
+      super(fields, binding);
+      this.asyncDependency = asyncDependency;
+    }
+
+    @Override
+    Snippet futureSnippet() {
+      return Snippet.format("%s", fields.get(asyncDependency.bindingKey()).name() + "Future");
+    }
+
+    @Override
+    TypeName applyArgType() {
+      return asyncDependencyType(asyncDependency);
+    }
+
+    @Override
+    String applyArgName() {
+      return asyncDependency.requestElement().getSimpleName().toString();
+    }
+
+    @Override
+    ImmutableList<Snippet> parameterSnippets() {
+      ImmutableList.Builder<Snippet> parameterSnippets = ImmutableList.builder();
+      for (DependencyRequest dependency : binding.dependencies()) {
+        // We really want to compare instances here, because asyncDependency is an element in the
+        // set binding.dependencies().
+        if (dependency == asyncDependency) {
+          parameterSnippets.add(Snippet.format("%s", applyArgName()));
+        } else {
+          parameterSnippets.add(
+              frameworkTypeUsageStatement(
+                  Snippet.format(
+                      "%s", fields.get(dependency.bindingKey()).name()), dependency.kind()));
         }
-        boolean wrapWithFuture = !returnsFuture;  // only wrap if we don't already have a future
-        Snippet invocationSnippet =
-            getInvocationSnippet(wrapWithFuture, binding, parameterSnippets.build());
-        Snippet throwsClause = getThrowsClause(binding.thrownTypes());
-        transformSnippet =
-            Snippet.format(
-                Joiner.on('\n')
-                    .join(
-                        "new %1$s<%2$s, %3$s>() {",
-                        "  @Override public %4$s apply(%2$s %5$s) %6$s{",
-                        "    %7$s",
-                        "  }",
-                        "}"),
-                ClassName.fromClass(AsyncFunction.class),
-                asyncDependencyType(asyncDependency),
-                providedTypeName,
-                futureTypeName,
-                argName,
-                throwsClause,
-                invocationSnippet);
-      } else {
-        futureSnippet = Snippet.format("%s.<%s>allAsList(%s)",
-            ClassName.fromClass(Futures.class),
-            ClassName.fromClass(Object.class),
-            Joiner.on(",").join(FluentIterable
-                .from(asyncDependencies)
-                .transform(DependencyRequest.BINDING_KEY_FUNCTION)
-                .transform(new Function<BindingKey, String>() {
-                  @Override public String apply(BindingKey dependencyBindingKey) {
-                    return fields.get(dependencyBindingKey).name() + "Future";
-                  }
-                })));
-        ImmutableList<Snippet> parameterSnippets = getParameterSnippets(binding, fields, "args");
-        boolean wrapWithFuture = !returnsFuture;  // only wrap if we don't already have a future
-        Snippet invocationSnippet =
-            getInvocationSnippet(wrapWithFuture, binding, parameterSnippets);
-        ParameterizedTypeName listOfObject =
-            ParameterizedTypeName.create(
-                ClassName.fromClass(List.class), ClassName.fromClass(Object.class));
-        Snippet throwsClause = getThrowsClause(binding.thrownTypes());
-        transformSnippet =
-            Snippet.format(
-                Joiner.on('\n')
-                    .join(
-                        "new %1$s<%2$s, %3$s>() {",
-                        "  @SuppressWarnings(\"unchecked\")  // safe by specification",
-                        "  @Override public %4$s apply(%2$s args) %5$s{",
-                        "    %6$s",
-                        "  }",
-                        "}"),
-                ClassName.fromClass(AsyncFunction.class),
-                listOfObject,
-                providedTypeName,
-                futureTypeName,
-                throwsClause,
-                invocationSnippet);
       }
-      getMethodWriter.body().addSnippet("return %s.%s(%s, %s, executor);",
+      return parameterSnippets.build();
+    }
+  }
+
+  static final class MultiArgFutureTransform extends FutureTransform {
+    private final ImmutableList<DependencyRequest> asyncDependencies;
+
+    MultiArgFutureTransform(
+        ImmutableMap<BindingKey, FrameworkField> fields,
+        ProductionBinding binding,
+        ImmutableList<DependencyRequest> asyncDependencies) {
+      super(fields, binding);
+      this.asyncDependencies = asyncDependencies;
+    }
+
+    @Override
+    Snippet futureSnippet() {
+      return Snippet.format(
+          "%s.<%s>allAsList(%s)",
           ClassName.fromClass(Futures.class),
-          "transform",
-          futureSnippet,
-          transformSnippet);
+          ClassName.fromClass(Object.class),
+          makeParametersSnippet(
+              FluentIterable.from(asyncDependencies)
+                  .transform(DependencyRequest.BINDING_KEY_FUNCTION)
+                  .transform(
+                      new Function<BindingKey, Snippet>() {
+                        @Override
+                        public Snippet apply(BindingKey bindingKey) {
+                          return Snippet.format("%s", fields.get(bindingKey).name() + "Future");
+                        }
+                      })));
     }
 
-    // TODO(gak): write a sensible toString
-    return ImmutableSet.of(writer);
+    @Override
+    TypeName applyArgType() {
+      return ParameterizedTypeName.create(
+          ClassName.fromClass(List.class), ClassName.fromClass(Object.class));
+    }
+
+    @Override
+    String applyArgName() {
+      return "args";
+    }
+
+    @Override
+    ImmutableList<Snippet> parameterSnippets() {
+      return getParameterSnippets(binding, fields, applyArgName());
+    }
+
+    @Override
+    boolean hasUncheckedCast() {
+      return true;
+    }
   }
 
-  private boolean isAsyncDependency(DependencyRequest dependency) {
+  private static boolean isAsyncDependency(DependencyRequest dependency) {
     switch (dependency.kind()) {
       case INSTANCE:
       case PRODUCED:
@@ -320,7 +400,7 @@ private boolean isAsyncDependency(DependencyRequest dependency) {
     }
   }
 
-  private TypeName asyncDependencyType(DependencyRequest dependency) {
+  private static TypeName asyncDependencyType(DependencyRequest dependency) {
     TypeName keyName = TypeNames.forTypeMirror(dependency.key().type());
     switch (dependency.kind()) {
       case INSTANCE:
@@ -332,7 +412,8 @@ private TypeName asyncDependencyType(DependencyRequest dependency) {
     }
   }
 
-  private ImmutableList<Snippet> getParameterSnippets(ProductionBinding binding,
+  private static ImmutableList<Snippet> getParameterSnippets(
+      ProductionBinding binding,
       ImmutableMap<BindingKey, FrameworkField> fields,
       String listArgName) {
     int argIndex = 0;
@@ -347,7 +428,7 @@ private TypeName asyncDependencyType(DependencyRequest dependency) {
         argIndex++;
       } else {
         snippets.add(frameworkTypeUsageStatement(
-            Snippet.format(fields.get(dependency.bindingKey()).name()), dependency.kind()));
+            Snippet.format("%s", fields.get(dependency.bindingKey()).name()), dependency.kind()));
       }
     }
     return snippets.build();
diff --git a/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java b/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
index 0041f5d89..c27423028 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
@@ -471,13 +471,13 @@ public void publicModuleNonPublicIncludes() {
             "TestModule_ProduceStringFactory",
             "package test;",
             "",
+            "import com.google.common.util.concurrent.AsyncFunction;",
             "import com.google.common.util.concurrent.Futures;",
             "import com.google.common.util.concurrent.ListenableFuture;",
             "import dagger.producers.internal.AbstractProducer;",
             "import dagger.producers.internal.Producers;",
             "import dagger.producers.monitoring.ProducerToken;",
             "import dagger.producers.monitoring.ProductionComponentMonitor;",
-            "import java.util.concurrent.Callable;",
             "import java.util.concurrent.Executor;",
             "import javax.annotation.Generated;",
             "import javax.annotation.Nullable;",
@@ -502,9 +502,10 @@ public void publicModuleNonPublicIncludes() {
             "  }",
             "",
             "  @Override protected ListenableFuture<String> compute() {",
-            "    ListenableFuture<ListenableFuture<String>> future = Producers.submitToExecutor(",
-            "      new Callable<ListenableFuture<String>>() {",
-            "        @Override public ListenableFuture<String> call() {",
+            "    return Futures.transform(",
+            "      Futures.<Void>immediateFuture(null),",
+            "      new AsyncFunction<Void, String>() {",
+            "        @Override public ListenableFuture<String> apply(Void ignoredVoidArg) {",
             "          if (monitor != null) {",
             "            monitor.methodStarting();",
             "          }",
@@ -517,7 +518,6 @@ public void publicModuleNonPublicIncludes() {
             "          }",
             "        }",
             "      }, executor);",
-            "    return Futures.dereference(future);",
             "  }",
             "}");
     assertAbout(javaSource())
diff --git a/producers/src/main/java/dagger/producers/internal/Producers.java b/producers/src/main/java/dagger/producers/internal/Producers.java
index 6cd06d40e..ea32c7829 100644
--- a/producers/src/main/java/dagger/producers/internal/Producers.java
+++ b/producers/src/main/java/dagger/producers/internal/Producers.java
@@ -20,16 +20,12 @@
 import com.google.common.util.concurrent.FutureFallback;
 import com.google.common.util.concurrent.Futures;
 import com.google.common.util.concurrent.ListenableFuture;
-import com.google.common.util.concurrent.ListenableFutureTask;
 import dagger.producers.Produced;
 import dagger.producers.Producer;
 import dagger.producers.monitoring.ProducerMonitor;
 import dagger.producers.monitoring.ProducerToken;
 import dagger.producers.monitoring.ProductionComponentMonitor;
 import java.util.Set;
-import java.util.concurrent.Callable;
-import java.util.concurrent.Executor;
-import java.util.concurrent.RejectedExecutionException;
 import javax.annotation.Nullable;
 import javax.inject.Provider;
 
@@ -89,19 +85,6 @@
     });
   }
 
-  /**
-   * Submits a callable to an executor, returning the future representing the task. This mirrors
-   * {@link com.google.common.util.concurrent.ListeningExecutorService#submit}, but only requires an
-   * {@link Executor}.
-   *
-   * @throws RejectedExecutionException if this task cannot be accepted for execution.
-   */
-  public static <T> ListenableFuture<T> submitToExecutor(Callable<T> callable, Executor executor) {
-    ListenableFutureTask<T> future = ListenableFutureTask.create(callable);
-    executor.execute(future);
-    return future;
-  }
-
   /**
    * Returns a producer that immediately executes the binding logic for the given provider every
    * time it is called.
diff --git a/producers/src/test/java/dagger/producers/internal/ProducersTest.java b/producers/src/test/java/dagger/producers/internal/ProducersTest.java
index 43564089f..e2707b342 100644
--- a/producers/src/test/java/dagger/producers/internal/ProducersTest.java
+++ b/producers/src/test/java/dagger/producers/internal/ProducersTest.java
@@ -17,12 +17,10 @@
 
 import com.google.common.util.concurrent.Futures;
 import com.google.common.util.concurrent.ListenableFuture;
-import com.google.common.util.concurrent.MoreExecutors;
 import com.google.common.util.concurrent.SettableFuture;
 import dagger.producers.Produced;
 import dagger.producers.Producer;
 import java.util.Set;
-import java.util.concurrent.Callable;
 import java.util.concurrent.CancellationException;
 import java.util.concurrent.ExecutionException;
 import javax.inject.Provider;
@@ -98,16 +96,6 @@
     }
   }
 
-  @Test public void submitToExecutor() throws Exception {
-    ListenableFuture<Integer> future = Producers.submitToExecutor(new Callable<Integer>() {
-      @Override public Integer call() {
-        return 42;
-      }
-    }, MoreExecutors.directExecutor());
-    assertThat(future.isDone()).isTrue();
-    assertThat(future.get()).isEqualTo(42);
-  }
-
   @Test public void producerFromProvider() throws Exception {
     Producer<Integer> producer = Producers.producerFromProvider(new Provider<Integer>() {
       int i = 0;
