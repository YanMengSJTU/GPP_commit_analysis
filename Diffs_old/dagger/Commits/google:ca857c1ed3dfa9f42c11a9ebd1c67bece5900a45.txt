diff --git a/compiler/pom.xml b/compiler/pom.xml
index 03b96b106..5ac25dd7d 100644
--- a/compiler/pom.xml
+++ b/compiler/pom.xml
@@ -105,32 +105,30 @@
   <build>
     <plugins>
       <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-compiler-plugin</artifactId>
-        <executions>
-          <execution>
-            <id>default-compile</id>
-            <goals><goal>compile</goal></goals>
-            <configuration>
-              <annotationProcessors>
-                <annotationProcessor>com.google.auto.value.processor.AutoValueProcessor</annotationProcessor>
-                <annotationProcessor>com.google.auto.service.processor.AutoServiceProcessor</annotationProcessor>
-              </annotationProcessors>
-            </configuration>
-          </execution>
-          <execution>
-            <id>default-test-compile</id>
-            <goals><goal>testCompile</goal></goals>
-            <configuration>
-              <annotationProcessors>
-                <annotationProcessor>dagger.internal.codegen.ComponentProcessor</annotationProcessor>
-              </annotationProcessors>
-            </configuration>
-          </execution>
-        </executions>
+         <executions>
+           <execution>
+             <id>default-compile</id>
+             <goals><goal>compile</goal></goals>
+             <configuration>
+               <annotationProcessors>
+                 <annotationProcessor>com.google.auto.value.processor.AutoValueProcessor</annotationProcessor>
+                 <annotationProcessor>com.google.auto.service.processor.AutoServiceProcessor</annotationProcessor>
+               </annotationProcessors>
+             </configuration>
+           </execution>
+           <execution>
+             <id>default-test-compile</id>
+             <goals><goal>testCompile</goal></goals>
+             <configuration>
+               <annotationProcessors>
+                 <annotationProcessor>dagger.internal.codegen.ComponentProcessor</annotationProcessor>
+               </annotationProcessors>
+             </configuration>
+           </execution>
+         </executions>
       </plugin>
       <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-invoker-plugin</artifactId>
         <configuration>
           <addTestClassPath>true</addTestClassPath>
@@ -157,7 +155,6 @@
         </executions>
       </plugin>
       <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-shade-plugin</artifactId>
         <version>2.3</version>
         <executions>
diff --git a/compiler/src/it/functional-tests/src/main/java/test/BasicAbstractClassComponent.java b/compiler/src/it/functional-tests/src/main/java/test/BasicAbstractClassComponent.java
new file mode 100644
index 000000000..78f77dfb8
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/BasicAbstractClassComponent.java
@@ -0,0 +1,29 @@
+/*
+* Copyright (C) 2015 Google, Inc.
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package test;
+
+import dagger.Component;
+
+/**
+ * This component tests behavior equivalent to {@link BasicComponent}, but as an abstract class
+ * rather than an interface.
+ */
+@Component(modules = PrimitivesModule.class)
+abstract class BasicAbstractClassComponent implements BasicComponent {
+  void throwAParty() {
+    throw new RuntimeException("Paaarrrrrtaaaaaaaay!");
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/BasicComponent.java b/compiler/src/it/functional-tests/src/main/java/test/BasicComponent.java
index 2a0eab6ba..a04607dd4 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/BasicComponent.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/BasicComponent.java
@@ -16,10 +16,12 @@
 package test;
 
 import dagger.Component;
+import dagger.Lazy;
+import dagger.MembersInjector;
 import javax.inject.Provider;
 
 @Component(modules = PrimitivesModule.class)
-interface BasicComponent {
+interface BasicComponent extends Injector<Thing> {
   byte getByte();
   char getChar();
   short getShort();
@@ -68,5 +70,12 @@
   Object noOpMembersInjection(Object obviouslyDoesNotHaveMembersToInject);
 
   Thing thing();
+  InjectedThing injectedThing();
+  Provider<InjectedThing> injectedThingProvider();
+  Lazy<InjectedThing> lazyInjectedThing();
+  MembersInjector<InjectedThing> injectedThingMembersInjector();
+
   TypeWithInheritedMembersInjection typeWithInheritedMembersInjection();
+  MembersInjector<TypeWithInheritedMembersInjection>
+      typeWithInheritedMembersInjectionMembersInjector();
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/InjectedThing.java b/compiler/src/it/functional-tests/src/main/java/test/InjectedThing.java
new file mode 100644
index 000000000..73a46e8aa
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/InjectedThing.java
@@ -0,0 +1,229 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import dagger.Lazy;
+import dagger.MembersInjector;
+import javax.inject.Inject;
+import javax.inject.Provider;
+
+@SuppressWarnings("unused")
+final class InjectedThing {
+  @Inject byte primitiveByte;
+  @Inject char primitiveChar;
+  @Inject short primitiveShort;
+  @Inject int primitiveInt;
+  @Inject long primitiveLong;
+  @Inject boolean primitiveBoolean;
+  @Inject float primitiveFloat;
+  @Inject double primitiveDouble;
+
+  @Inject Provider<Byte> byteProvider;
+  @Inject Provider<Character> charProvider;
+  @Inject Provider<Short> shortProvider;
+  @Inject Provider<Integer> intProvider;
+  @Inject Provider<Long> longProvider;
+  @Inject Provider<Boolean> booleanProvider;
+  @Inject Provider<Float> floatProvider;
+  @Inject Provider<Double> doubleProvider;
+
+  @Inject Lazy<Byte> lazyByte;
+  @Inject Lazy<Character> lazyChar;
+  @Inject Lazy<Short> lazyShort;
+  @Inject Lazy<Integer> lazyInt;
+  @Inject Lazy<Long> lazyLong;
+  @Inject Lazy<Boolean> lazyBoolean;
+  @Inject Lazy<Float> lazyFloat;
+  @Inject Lazy<Double> lazyDouble;
+
+  @Inject Byte boxedBype;
+  @Inject Character boxedChar;
+  @Inject Short boxedShort;
+  @Inject Integer boxedInt;
+  @Inject Long boxedLong;
+  @Inject Boolean boxedBoolean;
+  @Inject Float boxedFloat;
+  @Inject Double boxedDouble;
+
+  @Inject byte[] byteArray;
+  @Inject char[] charArray;
+  @Inject short[] shortArray;
+  @Inject int[] intArray;
+  @Inject long[] longArray;
+  @Inject boolean[] booleanArray;
+  @Inject float[] floatArray;
+  @Inject double[] doubleArray;
+
+  @Inject Provider<byte[]> byteArrayProvider;
+  @Inject Provider<char[]> charArrayProvider;
+  @Inject Provider<short[]> shortArrayProvider;
+  @Inject Provider<int[]> intArrayProvider;
+  @Inject Provider<long[]> longArrayProvider;
+  @Inject Provider<boolean[]> booleanArrayProvider;
+  @Inject Provider<float[]> floatArrayProvider;
+  @Inject Provider<double[]> doubleArrayProvider;
+
+  @Inject Lazy<byte[]> lazyByteArray;
+  @Inject Lazy<char[]> lazyCharArray;
+  @Inject Lazy<short[]> lazyShortArray;
+  @Inject Lazy<int[]> lazyIntArray;
+  @Inject Lazy<long[]> lazyLongArray;
+  @Inject Lazy<boolean[]> lazyBooleanArray;
+  @Inject Lazy<float[]> lazy;
+  @Inject Lazy<double[]> lazyDoubleArray;
+
+  @Inject Thing thing;
+  @Inject Provider<Thing> thingProvider;
+  @Inject Lazy<Thing> lazyThing;
+  @Inject MembersInjector<Thing> thingMembersInjector;
+
+  @Inject InjectedThing(
+      byte primitiveByte,
+      char primitiveChar,
+      short primitiveShort,
+      int primitiveInt,
+      long primitiveLong,
+      boolean primitiveBoolean,
+      float primitiveFloat,
+      double primitiveDouble,
+
+      Provider<Byte> byteProvider,
+      Provider<Character> charProvider,
+      Provider<Short> shortProvider,
+      Provider<Integer> intProvider,
+      Provider<Long> longProvider,
+      Provider<Boolean> booleanProvider,
+      Provider<Float> floatProvider,
+      Provider<Double> doubleProvider,
+
+      Lazy<Byte> lazyByte,
+      Lazy<Character> lazyChar,
+      Lazy<Short> lazyShort,
+      Lazy<Integer> lazyInt,
+      Lazy<Long> lazyLong,
+      Lazy<Boolean> lazyBoolean,
+      Lazy<Float> lazyFloat,
+      Lazy<Double> lazyDouble,
+
+      Byte boxedBype,
+      Character boxedChar,
+      Short boxedShort,
+      Integer boxedInt,
+      Long boxedLong,
+      Boolean boxedBoolean,
+      Float boxedFloat,
+      Double boxedDouble,
+
+      byte[] byteArray,
+      char[] charArray,
+      short[] shortArray,
+      int[] intArray,
+      long[] longArray,
+      boolean[] booleanArray,
+      float[] floatArray,
+      double[] doubleArray,
+
+      Provider<byte[]> byteArrayProvider,
+      Provider<char[]> charArrayProvider,
+      Provider<short[]> shortArrayProvider,
+      Provider<int[]> intArrayProvider,
+      Provider<long[]> longArrayProvider,
+      Provider<boolean[]> booleanArrayProvider,
+      Provider<float[]> floatArrayProvider,
+      Provider<double[]> doubleArrayProvider,
+
+      Lazy<byte[]> lazyByteArray,
+      Lazy<char[]> lazyCharArray,
+      Lazy<short[]> lazyShortArray,
+      Lazy<int[]> lazyIntArray,
+      Lazy<long[]> lazyLongArray,
+      Lazy<boolean[]> lazyBooleanArray,
+      Lazy<float[]> lazy,
+      Lazy<double[]> lazyDoubleArray,
+
+      Thing thing,
+      Provider<Thing> thingProvider,
+      Lazy<Thing> lazyThing,
+      MembersInjector<Thing> thingMembersInjector) {}
+
+  @Inject void primitiveByte(byte primitiveByte) {}
+  @Inject void primitiveChar(char primitiveChar) {}
+  @Inject void primitiveShort(short primitiveShort) {}
+  @Inject void primitiveInt(int primitiveInt) {}
+  @Inject void primitiveLong(long primitiveLong) {}
+  @Inject void primitiveBoolean(boolean primitiveBoolean) {}
+  @Inject void primitiveFloat(float primitiveFloat) {}
+  @Inject void primitiveDouble(double primitiveDouble) {}
+
+  @Inject void byteProvider(Provider<Byte> byteProvider) {}
+  @Inject void charProvider(Provider<Character> charProvider) {}
+  @Inject void shortProvider(Provider<Short> shortProvider) {}
+  @Inject void intProvider(Provider<Integer> intProvider) {}
+  @Inject void longProvider(Provider<Long> longProvider) {}
+  @Inject void booleanProvider(Provider<Boolean> booleanProvider) {}
+  @Inject void floatProvider(Provider<Float> floatProvider) {}
+  @Inject void doubleProvider(Provider<Double> doubleProvider) {}
+
+  @Inject void lazyByte(Lazy<Byte> lazyByte) {}
+  @Inject void lazyChar(Lazy<Character> lazyChar) {}
+  @Inject void lazyShort(Lazy<Short> lazyShort) {}
+  @Inject void lazyInt(Lazy<Integer> lazyInt) {}
+  @Inject void lazyLong(Lazy<Long> lazyLong) {}
+  @Inject void lazyBoolean(Lazy<Boolean> lazyBoolean) {}
+  @Inject void lazyFloat(Lazy<Float> lazyFloat) {}
+  @Inject void lazyDouble(Lazy<Double> lazyDouble) {}
+
+  @Inject void boxedBype(Byte boxedBype) {}
+  @Inject void boxedChar(Character boxedChar) {}
+  @Inject void boxedShort(Short boxedShort) {}
+  @Inject void boxedInt(Integer boxedInt) {}
+  @Inject void boxedLong(Long boxedLong) {}
+  @Inject void boxedBoolean(Boolean boxedBoolean) {}
+  @Inject void boxedFloat(Float boxedFloat) {}
+  @Inject void boxedDouble(Double boxedDouble) {}
+
+  @Inject void byteArray(byte[] byteArray) {}
+  @Inject void charArray(char[] charArray) {}
+  @Inject void shortArray(short[] shortArray) {}
+  @Inject void intArray(int[] intArray) {}
+  @Inject void longArray(long[] longArray) {}
+  @Inject void booleanArray(boolean[] booleanArray) {}
+  @Inject void floatArray(float[] floatArray) {}
+  @Inject void doubleArray(double[] doubleArray) {}
+
+  @Inject void byteArrayProvider(Provider<byte[]> byteArrayProvider) {}
+  @Inject void charArrayProvider(Provider<char[]> charArrayProvider) {}
+  @Inject void shortArrayProvider(Provider<short[]> shortArrayProvider) {}
+  @Inject void intArrayProvider(Provider<int[]> intArrayProvider) {}
+  @Inject void longArrayProvider(Provider<long[]> longArrayProvider) {}
+  @Inject void booleanArrayProvider(Provider<boolean[]> booleanArrayProvider) {}
+  @Inject void floatArrayProvider(Provider<float[]> floatArrayProvider) {}
+  @Inject void doubleArrayProvider(Provider<double[]> doubleArrayProvider) {}
+
+  @Inject void lazyByteArray(Lazy<byte[]> lazyByteArray) {}
+  @Inject void lazyCharArray(Lazy<char[]> lazyCharArray) {}
+  @Inject void lazyShortArray(Lazy<short[]> lazyShortArray) {}
+  @Inject void lazyIntArray(Lazy<int[]> lazyIntArray) {}
+  @Inject void lazyLongArray(Lazy<long[]> lazyLongArray) {}
+  @Inject void lazyBooleanArray(Lazy<boolean[]> lazyBooleanArray) {}
+  @Inject void lazy(Lazy<float[]> lazy) {}
+  @Inject void lazyDoubleArray(Lazy<double[]> lazyDoubleArray) {}
+
+  @Inject void thing(Thing thing) {}
+  @Inject void thingProvider(Provider<Thing> thingProvider) {}
+  @Inject void lazyThing(Lazy<Thing> lazyThing) {}
+  @Inject void thingMembersInjector(MembersInjector<Thing> thingMembersInjector) {}
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/Injector.java b/compiler/src/it/functional-tests/src/main/java/test/Injector.java
new file mode 100644
index 000000000..2a5798a03
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/Injector.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import dagger.Lazy;
+import dagger.MembersInjector;
+import javax.inject.Provider;
+
+/**
+ * A simple interface that exercises all forms of injection for a given type.
+ */
+interface Injector<T> {
+  T instance();
+  Provider<T> provider();
+  Lazy<T> lazy();
+  MembersInjector<T> membersInjector();
+  void injectMembers(T t);
+  T injectMembersAndReturn(T t);
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/NonComponentDependencyComponent.java b/compiler/src/it/functional-tests/src/main/java/test/NonComponentDependencyComponent.java
index 5521dd7dd..3f1b80069 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/NonComponentDependencyComponent.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/NonComponentDependencyComponent.java
@@ -24,7 +24,7 @@
 
   static class ThingTwo {
     @Inject
-    ThingTwo(Thing thing) {}
+    ThingTwo(@SuppressWarnings("unused") Thing thing) {}
   }
 
   // A non-component interface which this interface depends upon.
diff --git a/compiler/src/it/functional-tests/src/main/java/test/membersinject/ChildOfArrayOfParentOfStringArray.java b/compiler/src/it/functional-tests/src/main/java/test/membersinject/ChildOfArrayOfParentOfStringArray.java
new file mode 100644
index 000000000..22efcf12e
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/membersinject/ChildOfArrayOfParentOfStringArray.java
@@ -0,0 +1,20 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.membersinject;
+
+class ChildOfArrayOfParentOfStringArray extends
+    MembersInjectGenericParent<MembersInjectGenericParent<String[]>[]> {
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/membersinject/ChildOfPrimitiveIntArray.java b/compiler/src/it/functional-tests/src/main/java/test/membersinject/ChildOfPrimitiveIntArray.java
new file mode 100644
index 000000000..e01c1c266
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/membersinject/ChildOfPrimitiveIntArray.java
@@ -0,0 +1,20 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.membersinject;
+
+class ChildOfPrimitiveIntArray extends MembersInjectGenericParent<int[]> {
+
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/membersinject/ChildOfStringArray.java b/compiler/src/it/functional-tests/src/main/java/test/membersinject/ChildOfStringArray.java
new file mode 100644
index 000000000..8ec943b96
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/membersinject/ChildOfStringArray.java
@@ -0,0 +1,20 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.membersinject;
+
+class ChildOfStringArray extends MembersInjectGenericParent<String[]> {
+
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/membersinject/MembersInjectComponent.java b/compiler/src/it/functional-tests/src/main/java/test/membersinject/MembersInjectComponent.java
new file mode 100644
index 000000000..9ab8c1928
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/membersinject/MembersInjectComponent.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.membersinject;
+
+import dagger.Component;
+
+@Component(modules = {MembersInjectModule.class})
+interface MembersInjectComponent {
+  
+  void inject(ChildOfStringArray subfoo);
+  void inject(ChildOfArrayOfParentOfStringArray subfoo);
+  void inject(ChildOfPrimitiveIntArray subfoo);
+
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/membersinject/MembersInjectGenericParent.java b/compiler/src/it/functional-tests/src/main/java/test/membersinject/MembersInjectGenericParent.java
new file mode 100644
index 000000000..064b88642
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/membersinject/MembersInjectGenericParent.java
@@ -0,0 +1,24 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.membersinject;
+
+import javax.inject.Inject;
+
+class MembersInjectGenericParent<T> {
+  
+  @Inject T t; 
+
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/membersinject/MembersInjectModule.java b/compiler/src/it/functional-tests/src/main/java/test/membersinject/MembersInjectModule.java
new file mode 100644
index 000000000..a6c1fadb9
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/membersinject/MembersInjectModule.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.membersinject;
+
+import dagger.Module;
+import dagger.Provides;
+
+@Module
+class MembersInjectModule {
+  
+  @Provides String[] provideStringArray() { return new String[10]; }
+  
+  @Provides int[] provideIntArray() { return new int[10]; }
+  
+  @SuppressWarnings("unchecked")
+  @Provides MembersInjectGenericParent<String[]>[] provideFooArrayOfStringArray() { return new MembersInjectGenericParent[10]; }
+
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildComponentRequiringModules.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildComponentRequiringModules.java
new file mode 100644
index 000000000..905c68990
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildComponentRequiringModules.java
@@ -0,0 +1,26 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.subcomponent;
+
+import dagger.Subcomponent;
+
+@Subcomponent(modules = {
+    ChildModule.class,
+    ChildModuleWithParameters.class,
+    ChildModuleWithState.class})
+interface ChildComponentRequiringModules {
+  int getInt();
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildModuleWithParameters.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildModuleWithParameters.java
new file mode 100644
index 000000000..e18b4a6da
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildModuleWithParameters.java
@@ -0,0 +1,26 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.subcomponent;
+
+import dagger.Module;
+
+/**
+ * This is a module that can't be constructed with a default constructor.
+ */
+@Module
+final class ChildModuleWithParameters {
+  public ChildModuleWithParameters(@SuppressWarnings("unused") Object whatever) {}
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildModuleWithState.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildModuleWithState.java
new file mode 100644
index 000000000..5908a005b
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildModuleWithState.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.subcomponent;
+
+import dagger.Module;
+import dagger.Provides;
+
+/**
+ * This is a module that can be constructed with a default constructor, but has state, so callers
+ * might want to pass a reference anyway.
+ */
+@Module
+final class ChildModuleWithState {
+  private int i = 0;
+
+  @Provides int provideInt() {
+    return i++;
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentComponent.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentComponent.java
index ed4e6f0e8..babf3ea34 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentComponent.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentComponent.java
@@ -28,4 +28,8 @@
   Set<Object> objectSet();
 
   ChildComponent newChildComponent();
+
+  ChildComponentRequiringModules newChildComponentRequiringModules(
+      ChildModuleWithParameters cmwp,
+      ChildModuleWithState childModuleWithState);
 }
diff --git a/compiler/src/it/functional-tests/src/test/java/test/BasicTest.java b/compiler/src/it/functional-tests/src/test/java/test/BasicTest.java
index c3bfa98fa..fe9c6afe9 100644
--- a/compiler/src/it/functional-tests/src/test/java/test/BasicTest.java
+++ b/compiler/src/it/functional-tests/src/test/java/test/BasicTest.java
@@ -15,9 +15,10 @@
 */
 package test;
 
-import org.junit.Test;
+import org.junit.experimental.theories.DataPoint;
+import org.junit.experimental.theories.Theories;
+import org.junit.experimental.theories.Theory;
 import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
 
 import static com.google.common.truth.Truth.assertThat;
 import static test.PrimitivesModule.BOUND_BOOLEAN;
@@ -37,10 +38,15 @@
 import static test.PrimitivesModule.BOUND_SHORT;
 import static test.PrimitivesModule.BOUND_SHORT_ARRAY;
 
-@RunWith(JUnit4.class)
+@RunWith(Theories.class)
 public class BasicTest {
-  @Test public void primitives() {
-    BasicComponent basicComponent = Dagger_BasicComponent.create();
+  @DataPoint
+  public static final BasicComponent basicComponent = DaggerBasicComponent.create();
+  @DataPoint
+  public static final BasicComponent abstractClassBasicComponent =
+      DaggerBasicAbstractClassComponent.create();
+
+  @Theory public void primitives(BasicComponent basicComponent) {
     assertThat(basicComponent.getByte()).isEqualTo(BOUND_BYTE);
     assertThat(basicComponent.getChar()).isEqualTo(BOUND_CHAR);
     assertThat(basicComponent.getShort()).isEqualTo(BOUND_SHORT);
@@ -51,8 +57,7 @@
     assertThat(basicComponent.getDouble()).isEqualTo(BOUND_DOUBLE);
   }
 
-  @Test public void boxedPrimitives() {
-    BasicComponent basicComponent = Dagger_BasicComponent.create();
+  @Theory public void boxedPrimitives(BasicComponent basicComponent) {
     assertThat(basicComponent.getBoxedByte()).isEqualTo(new Byte(BOUND_BYTE));
     assertThat(basicComponent.getBoxedChar()).isEqualTo(new Character(BOUND_CHAR));
     assertThat(basicComponent.getBoxedShort()).isEqualTo(new Short(BOUND_SHORT));
@@ -63,8 +68,7 @@
     assertThat(basicComponent.getBoxedDouble()).isEqualTo(new Double(BOUND_DOUBLE));
   }
 
-  @Test public void boxedPrimitiveProviders() {
-    BasicComponent basicComponent = Dagger_BasicComponent.create();
+  @Theory public void boxedPrimitiveProviders(BasicComponent basicComponent) {
     assertThat(basicComponent.getByteProvider().get()).isEqualTo(new Byte(BOUND_BYTE));
     assertThat(basicComponent.getCharProvider().get()).isEqualTo(new Character(BOUND_CHAR));
     assertThat(basicComponent.getShortProvider().get()).isEqualTo(new Short(BOUND_SHORT));
@@ -75,8 +79,7 @@
     assertThat(basicComponent.getDoubleProvider().get()).isEqualTo(new Double(BOUND_DOUBLE));
   }
 
-  @Test public void primitiveArrays() {
-    BasicComponent basicComponent = Dagger_BasicComponent.create();
+  @Theory public void primitiveArrays(BasicComponent basicComponent) {
     assertThat(basicComponent.getByteArray()).isSameAs(BOUND_BYTE_ARRAY);
     assertThat(basicComponent.getCharArray()).isSameAs(BOUND_CHAR_ARRAY);
     assertThat(basicComponent.getShortArray()).isSameAs(BOUND_SHORT_ARRAY);
@@ -87,8 +90,7 @@
     assertThat(basicComponent.getDoubleArray()).isSameAs(BOUND_DOUBLE_ARRAY);
   }
 
-  @Test public void primitiveArrayProviders() {
-    BasicComponent basicComponent = Dagger_BasicComponent.create();
+  @Theory public void primitiveArrayProviders(BasicComponent basicComponent) {
     assertThat(basicComponent.getByteArrayProvider().get()).isSameAs(BOUND_BYTE_ARRAY);
     assertThat(basicComponent.getCharArrayProvider().get()).isSameAs(BOUND_CHAR_ARRAY);
     assertThat(basicComponent.getShortArrayProvider().get()).isSameAs(BOUND_SHORT_ARRAY);
@@ -99,19 +101,16 @@
     assertThat(basicComponent.getDoubleArrayProvider().get()).isSameAs(BOUND_DOUBLE_ARRAY);
   }
 
-  @Test public void noOpMembersInjection() {
-    BasicComponent basicComponent = Dagger_BasicComponent.create();
+  @Theory public void noOpMembersInjection(BasicComponent basicComponent) {
     Object object = new Object();
     assertThat(basicComponent.noOpMembersInjection(object)).isSameAs(object);
   }
 
-  @Test public void basicObject_noDeps() {
-    BasicComponent basicComponent = Dagger_BasicComponent.create();
+  @Theory public void basicObject_noDeps(BasicComponent basicComponent) {
     assertThat(basicComponent.thing()).isNotNull();
   }
 
-  @Test public void inheritedMembersInjection() {
-    BasicComponent basicComponent = Dagger_BasicComponent.create();
+  @Theory public void inheritedMembersInjection(BasicComponent basicComponent) {
     assertThat(basicComponent.typeWithInheritedMembersInjection().thing).isNotNull();
   }
 }
diff --git a/compiler/src/it/functional-tests/src/test/java/test/GenericTest.java b/compiler/src/it/functional-tests/src/test/java/test/GenericTest.java
index 88be63f0e..f1c981f25 100644
--- a/compiler/src/it/functional-tests/src/test/java/test/GenericTest.java
+++ b/compiler/src/it/functional-tests/src/test/java/test/GenericTest.java
@@ -32,17 +32,17 @@
 public class GenericTest {
 
   @Test public void testGenericComponentCreate() {
-    GenericComponent component = Dagger_GenericComponent.create();
+    GenericComponent component = DaggerGenericComponent.create();
     assertThat(component).isNotNull();
   }
   
   @Test public void testGenericSimpleReferences() {
-    GenericComponent component = Dagger_GenericComponent.create();
+    GenericComponent component = DaggerGenericComponent.create();
     assertThat(component.referencesGeneric().genericA.t).isNotNull();    
   }
   
   @Test public void testGenericDoubleReferences() {
-    GenericComponent component = Dagger_GenericComponent.create();
+    GenericComponent component = DaggerGenericComponent.create();
     GenericDoubleReferences<A> doubleA = component.doubleGenericA();
     assertThat(doubleA.a).isNotNull();
     assertThat(doubleA.a2).isNotNull();
@@ -57,13 +57,13 @@
   }
   
   @Test public void complexGenerics() {
-    GenericComponent component = Dagger_GenericComponent.create();
+    GenericComponent component = DaggerGenericComponent.create();
     // validate these can be called w/o exceptions.
     component.complexGenerics();
   }
   
   @Test public void noDepsGenerics() {
-    GenericComponent component = Dagger_GenericComponent.create();
+    GenericComponent component = DaggerGenericComponent.create();
     // validate these can be called w/o exceptions.
     component.noDepsA();
     component.noDepsB();
@@ -71,7 +71,7 @@
   
   @Test public void boundedGenerics() {
     BoundedGenericModule expected = new BoundedGenericModule();
-    BoundedGenericComponent component = Dagger_BoundedGenericComponent.create();
+    BoundedGenericComponent component = DaggerBoundedGenericComponent.create();
     BoundedGenerics<Integer, ArrayList<String>, LinkedList<CharSequence>, Integer, List<Integer>>
         b1 = component.bounds1();
     assertEquals(expected.provideInteger(), b1.a);
@@ -90,7 +90,7 @@
   }
   
   @Test public void membersInjections() {
-    GenericComponent component = Dagger_GenericComponent.create();
+    GenericComponent component = DaggerGenericComponent.create();
     GenericChild<A> childA = new GenericChild<A>();
     component.injectA(childA);
     assertThat(childA.a).isNotNull();
@@ -113,7 +113,7 @@
   }
   
   @Test public void packagePrivateTypeParameterDependencies() {
-    GenericComponent component = Dagger_GenericComponent.create();
+    GenericComponent component = DaggerGenericComponent.create();
     Exposed exposed = component.exposed();
     assertThat(exposed.gpp.t).isNotNull();
     assertThat(exposed.gpp2).isNotNull();
@@ -121,13 +121,13 @@
   
   @SuppressWarnings("rawtypes")
   @Test public void publicSubclassWithPackagePrivateTypeParameterOfSuperclass() {
-    GenericComponent component = Dagger_GenericComponent.create();
+    GenericComponent component = DaggerGenericComponent.create();
     PublicSubclass publicSubclass = component.publicSubclass();
     assertThat(((Generic)publicSubclass).t).isNotNull();
   }
   
   @Test public void singletonScopesAppliesToEachResolvedType() {
-    SingletonGenericComponent component = Dagger_SingletonGenericComponent.create();
+    SingletonGenericComponent component = DaggerSingletonGenericComponent.create();
     ScopedGeneric<A> a = component.scopedGenericA();
     assertThat(a).isSameAs(component.scopedGenericA());
     assertThat(a.t).isNotNull();
@@ -140,7 +140,7 @@
   }
   
   @Test public void genericModules() {
-    GenericComponent component = Dagger_GenericComponent.create();
+    GenericComponent component = DaggerGenericComponent.create();
     assertThat(component.iterableInt()).containsExactly(1, 2).inOrder();
     assertThat(component.iterableDouble()).containsExactly(3d, 4d).inOrder();
     
diff --git a/compiler/src/it/functional-tests/src/test/java/test/MultibindingTest.java b/compiler/src/it/functional-tests/src/test/java/test/MultibindingTest.java
index 23fb61bb7..04235b68b 100644
--- a/compiler/src/it/functional-tests/src/test/java/test/MultibindingTest.java
+++ b/compiler/src/it/functional-tests/src/test/java/test/MultibindingTest.java
@@ -26,7 +26,7 @@
 @RunWith(JUnit4.class)
 public class MultibindingTest {
   @Test public void testMultibindings() {
-    MultibindingComponent multibindingComponent = Dagger_MultibindingComponent.create();
+    MultibindingComponent multibindingComponent = DaggerMultibindingComponent.create();
     Map<String, String> map = multibindingComponent.map();
     assertThat(map).hasSize(2);
     assertThat(map).containsEntry("foo", "foo value");
diff --git a/compiler/src/it/functional-tests/src/test/java/test/NonComponentDependencyTest.java b/compiler/src/it/functional-tests/src/test/java/test/NonComponentDependencyTest.java
index 157acf999..37d3f7aec 100644
--- a/compiler/src/it/functional-tests/src/test/java/test/NonComponentDependencyTest.java
+++ b/compiler/src/it/functional-tests/src/test/java/test/NonComponentDependencyTest.java
@@ -25,7 +25,7 @@
 public class NonComponentDependencyTest {
   @Test public void testThing() {
     NonComponentDependencyComponent component =
-        Dagger_NonComponentDependencyComponent.builder()
+        DaggerNonComponentDependencyComponent.builder()
             .thingComponent(new NonComponentDependencyComponent.ThingComponentImpl())
             .build();
     assertThat(component).isNotNull();
diff --git a/compiler/src/it/functional-tests/src/test/java/test/membersinject/MembersInjectTest.java b/compiler/src/it/functional-tests/src/test/java/test/membersinject/MembersInjectTest.java
new file mode 100644
index 000000000..1b382d8f7
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/test/java/test/membersinject/MembersInjectTest.java
@@ -0,0 +1,45 @@
+/*
+* Copyright (C) 2015 Google, Inc.
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package test.membersinject;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public class MembersInjectTest {
+  @Test public void testMembersInject_arrays() {
+    MembersInjectComponent component = DaggerMembersInjectComponent.builder().build();
+    
+    ChildOfStringArray childOfStringArray = new ChildOfStringArray();
+    component.inject(childOfStringArray);
+  }
+
+  @Test public void testMembersInject_nestedArrays() {
+    MembersInjectComponent component = DaggerMembersInjectComponent.builder().build();
+    
+    ChildOfArrayOfParentOfStringArray childOfArrayOfParentOfStringArray =
+        new ChildOfArrayOfParentOfStringArray();
+    component.inject(childOfArrayOfParentOfStringArray);
+  }
+
+  @Test public void testMembersInject_primitives() {
+    MembersInjectComponent component = DaggerMembersInjectComponent.builder().build();
+    
+    ChildOfPrimitiveIntArray childOfPrimitiveIntArray = new ChildOfPrimitiveIntArray();
+    component.inject(childOfPrimitiveIntArray);
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/test/java/test/nullables/NullabilityTest.java b/compiler/src/it/functional-tests/src/test/java/test/nullables/NullabilityTest.java
index 5ad9efb7c..a0e1e22f5 100644
--- a/compiler/src/it/functional-tests/src/test/java/test/nullables/NullabilityTest.java
+++ b/compiler/src/it/functional-tests/src/test/java/test/nullables/NullabilityTest.java
@@ -26,7 +26,7 @@
 public class NullabilityTest {
   @Test public void testNullability_provides() {
     NullModule module = new NullModule();
-    NullComponent component = Dagger_NullComponent.builder().nullModule(module).build();
+    NullComponent component = DaggerNullComponent.builder().nullModule(module).build();
 
     // Can't construct NullFoo because it depends on Number, and Number was null.
     try {
@@ -80,7 +80,7 @@
       }
     };
     NullComponentWithDependency component =
-        Dagger_NullComponentWithDependency.builder().nullComponent(nullComponent).build();
+        DaggerNullComponentWithDependency.builder().nullComponent(nullComponent).build();
     validate(false, component.string(), component.stringProvider(), component.numberProvider());
     
     // Also validate that the component's number() method fails
diff --git a/compiler/src/it/functional-tests/src/test/java/test/subcomponent/SubcomponentScopeTest.java b/compiler/src/it/functional-tests/src/test/java/test/subcomponent/SubcomponentTest.java
similarity index 74%
rename from compiler/src/it/functional-tests/src/test/java/test/subcomponent/SubcomponentScopeTest.java
rename to compiler/src/it/functional-tests/src/test/java/test/subcomponent/SubcomponentTest.java
index 4e897ff72..c0d01b19a 100644
--- a/compiler/src/it/functional-tests/src/test/java/test/subcomponent/SubcomponentScopeTest.java
+++ b/compiler/src/it/functional-tests/src/test/java/test/subcomponent/SubcomponentTest.java
@@ -24,10 +24,10 @@
 import static com.google.common.truth.Truth.assertThat;
 
 @RunWith(JUnit4.class)
-public class SubcomponentScopeTest {
+public class SubcomponentTest {
   @Test
   public void scopePropagatesUpward_class() {
-    ParentComponent parentComponent = Dagger_ParentComponent.create();
+    ParentComponent parentComponent = DaggerParentComponent.create();
     assertThat(parentComponent.newChildComponent().requiresSingleton().singletonType())
         .isSameAs(parentComponent.newChildComponent().requiresSingleton().singletonType());
     assertThat(parentComponent.newChildComponent().requiresSingleton().singletonType())
@@ -37,7 +37,7 @@ public void scopePropagatesUpward_class() {
 
   @Test
   public void scopePropagatesUpward_provides() {
-    ParentComponent parentComponent = Dagger_ParentComponent.create();
+    ParentComponent parentComponent = DaggerParentComponent.create();
     assertThat(parentComponent.newChildComponent()
         .requiresSingleton().unscopedTypeBoundAsSingleton())
             .isSameAs(parentComponent.newChildComponent()
@@ -50,7 +50,7 @@ public void scopePropagatesUpward_provides() {
 
   @Test
   public void multibindingContributions() {
-    ParentComponent parentComponent = Dagger_ParentComponent.create();
+    ParentComponent parentComponent = DaggerParentComponent.create();
     Set<Object> parentObjectSet = parentComponent.objectSet();
     assertThat(parentObjectSet).hasSize(2);
     Set<Object> childObjectSet = parentComponent.newChildComponent().objectSet();
@@ -65,7 +65,7 @@ public void multibindingContributions() {
 
   @Test
   public void unscopedProviders() {
-    ParentComponent parentComponent = Dagger_ParentComponent.create();
+    ParentComponent parentComponent = DaggerParentComponent.create();
     assertThat(parentComponent.getUnscopedTypeProvider())
         .isSameAs(parentComponent.newChildComponent().getUnscopedTypeProvider());
     assertThat(parentComponent.getUnscopedTypeProvider())
@@ -73,4 +73,20 @@ public void unscopedProviders() {
             .newGrandchildComponent()
             .getUnscopedTypeProvider());
   }
+
+  @Test
+  public void passedModules() {
+    ParentComponent parentComponent = DaggerParentComponent.create();
+    ChildModuleWithState childModuleWithState = new ChildModuleWithState();
+    ChildComponentRequiringModules childComponent1 =
+        parentComponent.newChildComponentRequiringModules(
+            new ChildModuleWithParameters(new Object()),
+            childModuleWithState);
+    ChildComponentRequiringModules childComponent2 =
+        parentComponent.newChildComponentRequiringModules(
+            new ChildModuleWithParameters(new Object()),
+            childModuleWithState);
+    assertThat(childComponent1.getInt()).isEqualTo(0);
+    assertThat(childComponent2.getInt()).isEqualTo(1);
+  }
 }
diff --git a/compiler/src/it/functional-tests/src/test/java/test/subcomponent/hiding/SubcomponentHidingTest.java b/compiler/src/it/functional-tests/src/test/java/test/subcomponent/hiding/SubcomponentHidingTest.java
index 76e916d3e..27dcbb690 100644
--- a/compiler/src/it/functional-tests/src/test/java/test/subcomponent/hiding/SubcomponentHidingTest.java
+++ b/compiler/src/it/functional-tests/src/test/java/test/subcomponent/hiding/SubcomponentHidingTest.java
@@ -24,7 +24,7 @@
 @RunWith(JUnit4.class)
 public class SubcomponentHidingTest {
   @Test public void moduleNameHiding() {
-    ParentComponent parent = Dagger_ParentComponent.create();
+    ParentComponent parent = DaggerParentComponent.create();
     assertThat(parent.aCommonName().toString()).isEqualTo("a");
     assertThat(parent.newChildComponent().aCommonName().toString()).isEqualTo("a");
     assertThat(parent.newChildComponent().bCommonName().toString()).isEqualTo("1");
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/test/DependentTest.java b/compiler/src/it/producers-functional-tests/src/test/java/test/DependentTest.java
index 70413ae94..75c07c7a3 100644
--- a/compiler/src/it/producers-functional-tests/src/test/java/test/DependentTest.java
+++ b/compiler/src/it/producers-functional-tests/src/test/java/test/DependentTest.java
@@ -25,12 +25,12 @@
 @RunWith(JUnit4.class)
 public class DependentTest {
   @Test public void testDependentComponent() throws Exception {
-    DependentComponent dependentComponent = Dagger_DependentComponent
+    DependentComponent dependentComponent = DaggerDependentComponent
         .builder()
-        .dependedProductionComponent(Dagger_DependedProductionComponent.builder()
+        .dependedProductionComponent(DaggerDependedProductionComponent.builder()
             .executor(MoreExecutors.directExecutor())
             .build())
-        .dependedComponent(Dagger_DependedComponent.create())
+        .dependedComponent(DaggerDependedComponent.create())
         .executor(MoreExecutors.directExecutor())
         .build();
     assertThat(dependentComponent).isNotNull();
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/test/MultibindingTest.java b/compiler/src/it/producers-functional-tests/src/test/java/test/MultibindingTest.java
index d20de2384..20c86dc52 100644
--- a/compiler/src/it/producers-functional-tests/src/test/java/test/MultibindingTest.java
+++ b/compiler/src/it/producers-functional-tests/src/test/java/test/MultibindingTest.java
@@ -25,7 +25,7 @@
 @RunWith(JUnit4.class)
 public class MultibindingTest {
   @Test public void multibinding() throws Exception {
-    MultibindingComponent multibindingComponent = Dagger_MultibindingComponent.builder()
+    MultibindingComponent multibindingComponent = DaggerMultibindingComponent.builder()
         .executor(MoreExecutors.directExecutor())
         .build();
     assertThat(multibindingComponent.strs().get())
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/test/SimpleTest.java b/compiler/src/it/producers-functional-tests/src/test/java/test/SimpleTest.java
index de0ea89bd..f2b910e3c 100644
--- a/compiler/src/it/producers-functional-tests/src/test/java/test/SimpleTest.java
+++ b/compiler/src/it/producers-functional-tests/src/test/java/test/SimpleTest.java
@@ -25,7 +25,7 @@
 @RunWith(JUnit4.class)
 public class SimpleTest {
   @Test public void testSimpleComponent() throws Exception {
-    SimpleComponent simpleComponent = Dagger_SimpleComponent
+    SimpleComponent simpleComponent = DaggerSimpleComponent
         .builder()
         .executor(MoreExecutors.directExecutor())
         .build();
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
index c2f8adf06..69c9b3d74 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
@@ -29,7 +29,7 @@
 import com.google.common.collect.Sets;
 import dagger.Component;
 import dagger.Provides;
-import dagger.internal.codegen.ComponentDescriptor.ComponentMethodType;
+import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
 import dagger.producers.Produces;
 import dagger.producers.ProductionComponent;
 import java.util.Deque;
@@ -55,6 +55,7 @@
 import static dagger.internal.codegen.ConfigurationAnnotations.getTransitiveModules;
 import static dagger.internal.codegen.MembersInjectionBinding.Strategy.DELEGATE;
 import static dagger.internal.codegen.MembersInjectionBinding.Strategy.NO_OP;
+import static dagger.internal.codegen.Util.componentCanMakeNewInstances;
 import static javax.lang.model.util.ElementFilter.methodsIn;
 
 /**
@@ -64,9 +65,13 @@
  */
 @AutoValue
 abstract class BindingGraph {
+  enum ModuleStrategy {
+    PASSED,
+    CONSTRUCTED,
+  }
+
   abstract ComponentDescriptor componentDescriptor();
-  abstract ImmutableSet<DependencyRequest> entryPoints();
-  abstract ImmutableMap<TypeElement, ImmutableSet<TypeElement>> transitiveModules();
+  abstract ImmutableMap<TypeElement, ModuleStrategy> transitiveModules();
   abstract ImmutableMap<BindingKey, ResolvedBindings> resolvedBindings();
   abstract ImmutableMap<ExecutableElement, BindingGraph> subgraphs();
 
@@ -191,9 +196,13 @@ private BindingGraph create(Optional<RequestResolver> parentResolver,
       ImmutableSet<TypeElement> moduleTypes =
           MoreTypes.asTypeElements(getComponentModules(componentAnnotation));
 
-      ImmutableMap<TypeElement, ImmutableSet<TypeElement>> transitiveModules =
-          getTransitiveModules(types, elements, moduleTypes);
-      for (TypeElement module : transitiveModules.keySet()) {
+      ImmutableMap.Builder<TypeElement, ModuleStrategy> transitiveModules = ImmutableMap.builder();
+      for (TypeElement module : getTransitiveModules(types, elements, moduleTypes)) {
+        transitiveModules.put(module,
+            (componentCanMakeNewInstances(module) && module.getTypeParameters().isEmpty())
+                ? ModuleStrategy.CONSTRUCTED
+                : ModuleStrategy.PASSED);
+
         // traverse the modules, collect the bindings
         List<ExecutableElement> moduleMethods = methodsIn(elements.getAllMembers(module));
         for (ExecutableElement moduleMethod : moduleMethods) {
@@ -213,13 +222,11 @@ private BindingGraph create(Optional<RequestResolver> parentResolver,
           componentDescriptor.wrappedScope(),
           explicitBindingsByKey(explicitProvisionBindingsBuilder.build()),
           explicitBindingsByKey(explicitProductionBindingsBuilder.build()));
-      ImmutableSetMultimap<ComponentMethodType, ExecutableElement> componentMethods =
-          componentDescriptor.componentMethods();
-
-      ImmutableSet<DependencyRequest> componentMethodRequests =
-          componentMethodRequests(componentMethods);
-      for (DependencyRequest componentMethodRequest : componentMethodRequests) {
-        requestResolver.resolve(componentMethodRequest);
+      for (ComponentMethodDescriptor componentMethod : componentDescriptor.componentMethods()) {
+        Optional<DependencyRequest> componentMethodRequest = componentMethod.dependencyRequest();
+        if (componentMethodRequest.isPresent()) {
+          requestResolver.resolve(componentMethodRequest.get());
+        }
       }
 
       ImmutableMap.Builder<ExecutableElement, BindingGraph> subgraphsBuilder =
@@ -232,9 +239,8 @@ private BindingGraph create(Optional<RequestResolver> parentResolver,
 
       return new AutoValue_BindingGraph(
           componentDescriptor,
-          componentMethodRequests,
-          transitiveModules,
-          ImmutableMap.copyOf(requestResolver.resolvedBindings),
+          transitiveModules.build(),
+          requestResolver.getResolvedBindings(),
           subgraphsBuilder.build());
     }
 
@@ -248,26 +254,6 @@ private BindingGraph create(Optional<RequestResolver> parentResolver,
       return builder.build();
     }
 
-    private ImmutableSet<DependencyRequest> componentMethodRequests(
-        ImmutableSetMultimap<ComponentMethodType, ExecutableElement> componentMethods) {
-      ImmutableSet.Builder<DependencyRequest> interfaceRequestsBuilder = ImmutableSet.builder();
-      for (ExecutableElement provisionMethod : componentMethods.get(ComponentMethodType.PROVISON)) {
-        interfaceRequestsBuilder.add(
-            dependencyRequestFactory.forComponentProvisionMethod(provisionMethod));
-      }
-      for (ExecutableElement productionMethod :
-          componentMethods.get(ComponentMethodType.PRODUCTION)) {
-        interfaceRequestsBuilder.add(
-            dependencyRequestFactory.forComponentProductionMethod(productionMethod));
-      }
-      for (ExecutableElement membersInjectionMethod :
-          componentMethods.get(ComponentMethodType.MEMBERS_INJECTION)) {
-        interfaceRequestsBuilder.add(
-            dependencyRequestFactory.forComponentMembersInjectionMethod(membersInjectionMethod));
-      }
-      return interfaceRequestsBuilder.build();
-    }
-
     private final class RequestResolver {
       final Optional<RequestResolver> parentResolver;
       final Optional<Equivalence.Wrapper<AnnotationMirror>> targetScope;
@@ -483,6 +469,29 @@ void resolve(DependencyRequest request) {
           cycleStack.pop();
         }
       }
+
+      ImmutableMap<BindingKey, ResolvedBindings> getResolvedBindings() {
+        ImmutableMap.Builder<BindingKey, ResolvedBindings> resolvedBindingsBuilder =
+            ImmutableMap.builder();
+        resolvedBindingsBuilder.putAll(resolvedBindings);
+        if (parentResolver.isPresent()) {
+          for (ResolvedBindings resolvedInParent :
+            parentResolver.get().getResolvedBindings().values()) {
+            BindingKey bindingKey = resolvedInParent.bindingKey();
+            if (!resolvedBindings.containsKey(bindingKey)) {
+              if (resolvedInParent.ownedBindings().isEmpty()) {
+                // reuse the instance if we can get away with it
+                resolvedBindingsBuilder.put(bindingKey, resolvedInParent);
+              } else {
+                resolvedBindingsBuilder.put(bindingKey,
+                    ResolvedBindings.create(
+                        bindingKey, ImmutableSet.<Binding>of(), resolvedInParent.bindings()));
+              }
+            }
+          }
+        }
+        return resolvedBindingsBuilder.build();
+      }
     }
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
index 6d1827a11..47d51015f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -35,21 +35,23 @@
 import com.google.common.collect.Sets;
 import dagger.Component;
 import dagger.internal.codegen.BindingGraph.ResolvedBindings;
+import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
 import dagger.internal.codegen.ContributionBinding.BindingType;
 import dagger.internal.codegen.ValidationReport.Builder;
 import dagger.internal.codegen.writer.TypeNames;
 import java.util.ArrayDeque;
 import java.util.Deque;
 import java.util.Formatter;
-import java.util.HashSet;
 import java.util.Iterator;
+import java.util.Map.Entry;
 import java.util.Set;
 import javax.inject.Singleton;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.ArrayType;
 import javax.lang.model.type.DeclaredType;
-import javax.lang.model.type.TypeKind;
+import javax.lang.model.type.PrimitiveType;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.SimpleTypeVisitor6;
 import javax.lang.model.util.Types;
@@ -106,37 +108,60 @@
   public ValidationReport<BindingGraph> validate(final BindingGraph subject) {
     final ValidationReport.Builder<BindingGraph> reportBuilder =
         ValidationReport.Builder.about(subject);
+    return validate(subject, reportBuilder);
+  }
+
+  private ValidationReport<BindingGraph> validate(final BindingGraph subject,
+      final ValidationReport.Builder<BindingGraph> reportBuilder) {
     ImmutableMap<BindingKey, ResolvedBindings> resolvedBindings = subject.resolvedBindings();
 
     validateComponentScope(subject, reportBuilder, resolvedBindings);
     validateDependencyScopes(subject, reportBuilder);
 
-    for (DependencyRequest entryPoint : subject.entryPoints()) {
-      Deque<ResolvedRequest> path = new ArrayDeque<>();
-      path.push(ResolvedRequest.create(entryPoint, subject));
-      traversalHelper(subject, path, new Traverser() {
-        final Set<BindingKey> visitedBindings = new HashSet<>();
-
-        @Override
-        boolean visitResolvedRequest(Deque<ResolvedRequest> path) {
-          ResolvedBindings binding = path.peek().binding();
-          for (ResolvedRequest resolvedRequest : Iterables.skip(path, 1)) {
-            if (resolvedRequest.request().bindingKey().equals(binding.bindingKey())) {
-              reportCycle(path, reportBuilder);
-              return false;
-            }
-          }
+    for (ComponentMethodDescriptor componentMethod :
+        subject.componentDescriptor().componentMethods()) {
+      Optional<DependencyRequest> entryPoint = componentMethod.dependencyRequest();
+      if (entryPoint.isPresent()) {
+        traverseRequest(entryPoint.get(), new ArrayDeque<ResolvedRequest>(), subject,
+            reportBuilder);
+      }
+    }
 
-          if (!visitedBindings.add(binding.bindingKey())) {
-            return false;
-          }
+    validateSubcomponents(subject, reportBuilder);
 
-          return validateResolvedBinding(path, binding, reportBuilder);
-        }
-      });
+    return reportBuilder.build();
+  }
+
+  private void traverseRequest(
+      DependencyRequest request,
+      Deque<ResolvedRequest> bindingPath,
+      BindingGraph graph,
+      ValidationReport.Builder<BindingGraph> reportBuilder) {
+    BindingKey requestKey = request.bindingKey();
+    for (ResolvedRequest pathElement : bindingPath) {
+      if (pathElement.request().bindingKey().equals(requestKey)) {
+        reportCycle(request, bindingPath, reportBuilder);
+        return;
+      }
     }
 
-    return reportBuilder.build();
+    ResolvedRequest resolvedRequest = ResolvedRequest.create(request, graph);
+    bindingPath.push(resolvedRequest);
+    validateResolvedBinding(bindingPath, resolvedRequest.binding(), reportBuilder);
+
+    for (Binding binding : resolvedRequest.binding().bindings()) {
+      for (DependencyRequest nextRequest : binding.implicitDependencies()) {
+        traverseRequest(nextRequest, bindingPath, graph, reportBuilder);
+      }
+    }
+    bindingPath.poll();
+  }
+
+  private void validateSubcomponents(BindingGraph graph,
+      ValidationReport.Builder<BindingGraph> reportBuilder) {
+    for (Entry<ExecutableElement, BindingGraph> subgraphEntry : graph.subgraphs().entrySet()) {
+      validate(subgraphEntry.getValue(), reportBuilder);
+    }
   }
 
   /**
@@ -181,7 +206,7 @@ private boolean validateResolvedBinding(
               "contribution binding keys should never have members injection bindings");
         }
         Set<ContributionBinding> combined = Sets.union(provisionBindings, productionBindings);
-        if (!validateNullability(path, combined, reportBuilder)) {
+        if (!validateNullability(path.peek().request(), combined, reportBuilder)) {
           return false;
         }
         if (!productionBindings.isEmpty() && doesPathRequireProvisionOnly(path)) {
@@ -225,10 +250,9 @@ private boolean validateResolvedBinding(
   }
 
   /** Ensures that if the request isn't nullable, then each contribution is also not nullable. */
-  private boolean validateNullability(Deque<ResolvedRequest> requestPath,
+  private boolean validateNullability(DependencyRequest request,
       Set<ContributionBinding> bindings, Builder<BindingGraph> reportBuilder) {
     boolean valid = true;
-    DependencyRequest request = requestPath.peek().request();
     String typeName = TypeNames.forTypeMirror(request.key().type()).toString();
     if (!request.isNullable()) {
       for (ContributionBinding binding : bindings) {
@@ -274,11 +298,55 @@ private boolean validateMembersInjectionBinding(MembersInjectionBinding binding,
       @Override public Boolean visitDeclared(DeclaredType type, Void ignored) {
         // If the key has type arguments, validate that each type argument is declared.
         // Otherwise the type argument may be a wildcard (or other type), and we can't
-        // resolve that to actual types.
+        // resolve that to actual types.  If the arg was an array, validate the type
+        // of the array.
         for (TypeMirror arg : type.getTypeArguments()) {
-          if (arg.getKind() != TypeKind.DECLARED) {
-            reportBuilder.addItem(MEMBERS_INJECTION_WITH_UNBOUNDED_TYPE,
-                path.peek().request().requestElement());
+          boolean declared;
+          switch (arg.getKind()) {
+            case ARRAY:
+              declared = MoreTypes.asArray(arg).getComponentType().accept(
+                  new SimpleTypeVisitor6<Boolean, Void>() {
+                    @Override protected Boolean defaultAction(TypeMirror e, Void p) {
+                      return false;
+                    }
+
+                    @Override public Boolean visitDeclared(DeclaredType t, Void p) {
+                      for (TypeMirror arg : t.getTypeArguments()) {
+                        if (!arg.accept(this, null)) {
+                          return false;
+                        }
+                      }
+                      return true;
+                    }
+
+                    @Override public Boolean visitArray(ArrayType t, Void p) {
+                      return t.getComponentType().accept(this, null);
+                    }
+
+                    @Override public Boolean visitPrimitive(PrimitiveType t, Void p) {
+                      return true;
+                    }
+                  }, null);
+              break;
+            case DECLARED:
+              declared = true;
+              break;
+            default:
+              declared = false;
+          }
+          if (!declared) {
+            ImmutableList<String> printableDependencyPath = FluentIterable.from(path)
+                .transform(REQUEST_FROM_RESOLVED_REQUEST)
+                .transform(dependencyRequestFormatter)
+                .filter(Predicates.not(Predicates.equalTo("")))
+                .toList()
+                .reverse();
+            reportBuilder.addItem(
+                String.format(MEMBERS_INJECTION_WITH_UNBOUNDED_TYPE,
+                    arg.toString(),
+                    type.toString(),
+                    Joiner.on('\n').join(printableDependencyPath)),
+                    path.peek().request().requestElement());
             return false;
           }
         }
@@ -290,8 +358,16 @@ private boolean validateMembersInjectionBinding(MembersInjectionBinding binding,
         // allow it and instantiate the type bounds... but we don't.)
         if (!MoreTypes.asDeclared(element.asType()).getTypeArguments().isEmpty()
             && types.isSameType(types.erasure(element.asType()), type)) {
+            ImmutableList<String> printableDependencyPath = FluentIterable.from(path)
+                .transform(REQUEST_FROM_RESOLVED_REQUEST)
+                .transform(dependencyRequestFormatter)
+                .filter(Predicates.not(Predicates.equalTo("")))
+                .toList()
+                .reverse();
           reportBuilder.addItem(
-              String.format(ErrorMessages.MEMBERS_INJECTION_WITH_RAW_TYPE, type.toString()),
+              String.format(ErrorMessages.MEMBERS_INJECTION_WITH_RAW_TYPE,
+                  type.toString(),
+                  Joiner.on('\n').join(printableDependencyPath)),
               path.peek().request().requestElement());
           return false;
         }
@@ -449,7 +525,7 @@ void validateComponentScope(final BindingGraph subject,
     ImmutableSet.Builder<String> incompatiblyScopedMethodsBuilder = ImmutableSet.builder();
     for (ResolvedBindings bindings : resolvedBindings.values()) {
       if (bindings.bindingKey().kind().equals(BindingKey.Kind.CONTRIBUTION)) {
-        for (ContributionBinding contributionBinding : bindings.contributionBindings()) {
+        for (ContributionBinding contributionBinding : bindings.ownedContributionBindings()) {
           if (contributionBinding instanceof ProvisionBinding) {
             ProvisionBinding provisionBinding = (ProvisionBinding) contributionBinding;
             if (provisionBinding.scope().isPresent()
@@ -523,16 +599,13 @@ private void reportMissingBinding(
     boolean requiresContributionMethod = !key.isValidImplicitProvisionKey(types);
     boolean requiresProvision = doesPathRequireProvisionOnly(path);
     StringBuilder errorMessage = new StringBuilder();
-    final String requiresErrorMessageFormat;
-    if (requiresContributionMethod) {
-      requiresErrorMessageFormat = requiresProvision
-          ? REQUIRES_PROVIDER_FORMAT
-          : REQUIRES_PROVIDER_OR_PRODUCER_FORMAT;
-    } else {
-      requiresErrorMessageFormat = requiresProvision
-          ? REQUIRES_AT_INJECT_CONSTRUCTOR_OR_PROVIDER_FORMAT
-          : REQUIRES_AT_INJECT_CONSTRUCTOR_OR_PROVIDER_OR_PRODUCER_FORMAT;
-    }
+    String requiresErrorMessageFormat = requiresContributionMethod
+        ? requiresProvision
+            ? REQUIRES_PROVIDER_FORMAT
+            : REQUIRES_PROVIDER_OR_PRODUCER_FORMAT
+        : requiresProvision
+            ? REQUIRES_AT_INJECT_CONSTRUCTOR_OR_PROVIDER_FORMAT
+            : REQUIRES_AT_INJECT_CONSTRUCTOR_OR_PROVIDER_OR_PRODUCER_FORMAT;
     errorMessage.append(String.format(requiresErrorMessageFormat, typeName));
     if (key.isValidMembersInjectionKey()
         && !injectBindingRegistry.getOrFindMembersInjectionBinding(key).injectionSites()
@@ -670,10 +743,13 @@ private String formatBindingType(BindingType type) {
     }
   }
 
-  private void reportCycle(Deque<ResolvedRequest> path,
+  private void reportCycle(DependencyRequest request, Deque<ResolvedRequest> path,
       final ValidationReport.Builder<BindingGraph> reportBuilder) {
-    ImmutableList<String> printableDependencyPath = FluentIterable.from(path)
-        .transform(REQUEST_FROM_RESOLVED_REQUEST)
+    ImmutableList<DependencyRequest> pathElements = ImmutableList.<DependencyRequest>builder()
+        .add(request)
+        .addAll(Iterables.transform(path, REQUEST_FROM_RESOLVED_REQUEST))
+        .build();
+    ImmutableList<String> printableDependencyPath = FluentIterable.from(pathElements)
         .transform(dependencyRequestFormatter)
         .filter(Predicates.not(Predicates.equalTo("")))
         .toList()
@@ -687,7 +763,7 @@ private void reportCycle(Deque<ResolvedRequest> path,
             componentType.getQualifiedName(),
             rootRequest.requestElement().getSimpleName(),
             Joiner.on("\n")
-            .join(printableDependencyPath.subList(1, printableDependencyPath.size()))),
+                .join(printableDependencyPath.subList(1, printableDependencyPath.size()))),
         rootRequest.requestElement());
   }
 
@@ -697,8 +773,13 @@ private void reportCycle(Deque<ResolvedRequest> path,
     abstract ResolvedBindings binding();
 
     static ResolvedRequest create(DependencyRequest request, BindingGraph graph) {
-      return new AutoValue_BindingGraphValidator_ResolvedRequest(
-          request, graph.resolvedBindings().get(request.bindingKey()));
+      BindingKey bindingKey = request.bindingKey();
+      ResolvedBindings resolvedBindings = graph.resolvedBindings().get(bindingKey);
+      return new AutoValue_BindingGraphValidator_ResolvedRequest(request,
+          resolvedBindings == null
+              ? ResolvedBindings.create(bindingKey,
+                  ImmutableSet.<Binding>of(), ImmutableSet.<Binding>of())
+              : resolvedBindings);
     }
   }
 
@@ -709,28 +790,6 @@ static ResolvedRequest create(DependencyRequest request, BindingGraph graph) {
         }
       };
 
-  private void traversalHelper(BindingGraph graph, Deque<ResolvedRequest> path,
-      Traverser traverser) {
-    ImmutableSet<DependencyRequest> allDeps =
-        FluentIterable.from(path.peek().binding().bindings())
-            .transformAndConcat(
-                new Function<Binding, Set<DependencyRequest>>() {
-                  @Override
-                  public Set<DependencyRequest> apply(Binding input) {
-                    return input.implicitDependencies();
-                  }
-                })
-            .toSet();
-    boolean descend = traverser.visitResolvedRequest(path);
-    if (descend) {
-      for (DependencyRequest dependency : allDeps) {
-        path.push(ResolvedRequest.create(dependency, graph));
-        traversalHelper(graph, path, traverser);
-        path.pop();
-      }
-    }
-  }
-
   abstract static class Traverser {
     abstract boolean visitResolvedRequest(Deque<ResolvedRequest> path);
   }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
index e2a2eb605..03f759a2e 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
@@ -23,25 +23,28 @@
 import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.ImmutableSetMultimap;
 import com.google.common.collect.Lists;
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.Component;
+import dagger.Lazy;
+import dagger.MembersInjector;
 import dagger.Subcomponent;
 import dagger.producers.ProductionComponent;
 import java.lang.annotation.Annotation;
 import java.util.Iterator;
 import java.util.List;
 import java.util.concurrent.Executor;
+import javax.inject.Provider;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.TypeElement;
-import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.ExecutableType;
 import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.ElementFilter;
 import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
 
 import static com.google.auto.common.MoreElements.getAnnotationMirror;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
@@ -120,9 +123,16 @@
 
   abstract ImmutableMap<ExecutableElement, ComponentDescriptor> subcomponents();
 
-  abstract ImmutableSetMultimap<ComponentMethodType, ExecutableElement> componentMethods();
+  abstract ImmutableSet<ComponentMethodDescriptor> componentMethods();
 
-  enum ComponentMethodType {
+  @AutoValue
+  static abstract class ComponentMethodDescriptor {
+    abstract ComponentMethodKind kind();
+    abstract Optional<DependencyRequest> dependencyRequest();
+    abstract ExecutableElement methodElement();
+  }
+
+  enum ComponentMethodKind {
     PROVISON,
     PRODUCTION,
     MEMBERS_INJECTION,
@@ -131,9 +141,13 @@
 
   static final class Factory {
     private final Elements elements;
+    private final Types types;
+    private final DependencyRequest.Factory dependencyRequestFactory;
 
-    Factory(Elements elements) {
+    Factory(Elements elements, Types types, DependencyRequest.Factory dependencyRequestFactory) {
       this.elements = elements;
+      this.types = types;
+      this.dependencyRequestFactory = dependencyRequestFactory;
     }
 
     ComponentDescriptor forComponent(TypeElement componentDefinitionType) {
@@ -175,16 +189,16 @@ private ComponentDescriptor create(TypeElement componentDefinitionType, Kind kin
       ImmutableSet<ExecutableElement> unimplementedMethods =
           getUnimplementedMethods(elements, componentDefinitionType);
 
-      ImmutableSetMultimap.Builder<ComponentMethodType, ExecutableElement> componentMethodsBuilder =
-          ImmutableSetMultimap.builder();
+      ImmutableSet.Builder<ComponentMethodDescriptor> componentMethodsBuilder =
+          ImmutableSet.builder();
 
       ImmutableMap.Builder<ExecutableElement, ComponentDescriptor> subcomponentDescriptors =
           ImmutableMap.builder();
       for (ExecutableElement componentMethod : unimplementedMethods) {
-        ComponentMethodType componentMethodType =
-            getComponentMethodType(kind, componentMethod);
-        componentMethodsBuilder.put(componentMethodType, componentMethod);
-        if (componentMethodType.equals(ComponentMethodType.SUBCOMPONENT)) {
+        ComponentMethodDescriptor componentMethodDescriptor =
+            getDescriptorForComponentMethod(componentDefinitionType, kind, componentMethod);
+        componentMethodsBuilder.add(componentMethodDescriptor);
+        if (componentMethodDescriptor.kind().equals(ComponentMethodKind.SUBCOMPONENT)) {
           subcomponentDescriptors.put(componentMethod,
               create(MoreElements.asType(MoreTypes.asElement(componentMethod.getReturnType())),
                   Kind.COMPONENT));
@@ -203,36 +217,72 @@ private ComponentDescriptor create(TypeElement componentDefinitionType, Kind kin
           subcomponentDescriptors.build(),
           componentMethodsBuilder.build());
     }
-  }
 
-  private static ComponentMethodType getComponentMethodType(Kind componentKind,
-      ExecutableElement method) {
-    TypeMirror returnType = method.getReturnType();
-    if (returnType.getKind().equals(DECLARED) &&
-        getAnnotationMirror(MoreTypes.asElement(returnType), Subcomponent.class).isPresent()) {
-      return ComponentMethodType.SUBCOMPONENT;
-    }
+    private ComponentMethodDescriptor getDescriptorForComponentMethod(TypeElement componentElement,
+        Kind componentKind,
+        ExecutableElement componentMethod) {
+      ExecutableType resolvedComponentMethod = MoreTypes.asExecutable(types.asMemberOf(
+          MoreTypes.asDeclared(componentElement.asType()), componentMethod));
+      TypeMirror returnType = resolvedComponentMethod.getReturnType();
+      if (returnType.getKind().equals(DECLARED)) {
+        if (MoreTypes.isTypeOf(Provider.class, returnType)
+            || MoreTypes.isTypeOf(Lazy.class, returnType)) {
+          return new AutoValue_ComponentDescriptor_ComponentMethodDescriptor(
+              ComponentMethodKind.PROVISON,
+              Optional.of(dependencyRequestFactory.forComponentProvisionMethod(componentMethod,
+                  resolvedComponentMethod)),
+              componentMethod);
+        } else if (MoreTypes.isTypeOf(MembersInjector.class, returnType)) {
+          return new AutoValue_ComponentDescriptor_ComponentMethodDescriptor(
+              ComponentMethodKind.MEMBERS_INJECTION,
+              Optional.of(dependencyRequestFactory.forComponentMembersInjectionMethod(
+                  componentMethod,
+                  resolvedComponentMethod)),
+              componentMethod);
+        } else if (getAnnotationMirror(MoreTypes.asElement(returnType), Subcomponent.class)
+            .isPresent()) {
+          return new AutoValue_ComponentDescriptor_ComponentMethodDescriptor(
+              ComponentMethodKind.SUBCOMPONENT,
+              Optional.<DependencyRequest>absent(),
+              componentMethod);
+        }
+      }
 
-    if (method.getParameters().isEmpty()
-        && !method.getReturnType().getKind().equals(VOID)) {
-      switch (componentKind) {
-        case COMPONENT:
-          return ComponentMethodType.PROVISON;
-        case PRODUCTION_COMPONENT:
-          return ComponentMethodType.PRODUCTION;
-        default:
-          throw new AssertionError();
+      // a typical provision method
+      if (componentMethod.getParameters().isEmpty()
+          && !componentMethod.getReturnType().getKind().equals(VOID)) {
+        switch (componentKind) {
+          case COMPONENT:
+            return new AutoValue_ComponentDescriptor_ComponentMethodDescriptor(
+                ComponentMethodKind.PROVISON,
+                Optional.of(dependencyRequestFactory.forComponentProvisionMethod(componentMethod,
+                    resolvedComponentMethod)),
+                componentMethod);
+          case PRODUCTION_COMPONENT:
+            return new AutoValue_ComponentDescriptor_ComponentMethodDescriptor(
+                ComponentMethodKind.PRODUCTION,
+                Optional.of(dependencyRequestFactory.forComponentProductionMethod(componentMethod,
+                    resolvedComponentMethod)),
+                componentMethod);
+          default:
+            throw new AssertionError();
+        }
       }
-    }
 
-    List<? extends VariableElement> parameters = method.getParameters();
-    if (parameters.size() == 1
-        && (returnType.getKind().equals(VOID)
-            || MoreTypes.equivalence().equivalent(returnType, parameters.get(0).asType()))) {
-      return ComponentMethodType.MEMBERS_INJECTION;
-    }
+      List<? extends TypeMirror> parameterTypes = resolvedComponentMethod.getParameterTypes();
+      if (parameterTypes.size() == 1
+          && (returnType.getKind().equals(VOID)
+              || MoreTypes.equivalence().equivalent(returnType, parameterTypes.get(0)))) {
+        return new AutoValue_ComponentDescriptor_ComponentMethodDescriptor(
+            ComponentMethodKind.MEMBERS_INJECTION,
+            Optional.of(dependencyRequestFactory.forComponentMembersInjectionMethod(
+                componentMethod,
+                resolvedComponentMethod)),
+            componentMethod);
+      }
 
-    throw new IllegalArgumentException();
+      throw new IllegalArgumentException("not a valid component method: " + componentMethod);
+    }
   }
 
   static boolean isComponentContributionMethod(Elements elements, ExecutableElement method) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
index 678b72c93..2a9f434a7 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
@@ -33,6 +33,7 @@
 import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
 import com.google.common.collect.Sets;
+import com.google.common.collect.Sets.SetView;
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.Component;
 import dagger.MapKey;
@@ -45,6 +46,7 @@
 import dagger.internal.ScopedProvider;
 import dagger.internal.SetFactory;
 import dagger.internal.codegen.BindingGraph.ResolvedBindings;
+import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
 import dagger.internal.codegen.ContributionBinding.BindingType;
 import dagger.internal.codegen.writer.ClassName;
 import dagger.internal.codegen.writer.ClassWriter;
@@ -82,13 +84,17 @@
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.ExecutableType;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.ElementKindVisitor6;
 import javax.lang.model.util.SimpleAnnotationValueVisitor6;
+import javax.lang.model.util.Types;
 import javax.tools.Diagnostic;
 
 import static com.google.auto.common.MoreTypes.asDeclared;
 import static com.google.common.base.CaseFormat.LOWER_CAMEL;
+import static com.google.common.base.Preconditions.checkState;
+import static com.google.common.base.Verify.verify;
 import static dagger.internal.codegen.Binding.bindingPackageFor;
 import static dagger.internal.codegen.ConfigurationAnnotations.getMapKeys;
 import static dagger.internal.codegen.ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD;
@@ -99,13 +105,12 @@
 import static dagger.internal.codegen.SourceFiles.factoryNameForProvisionBinding;
 import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
 import static dagger.internal.codegen.SourceFiles.membersInjectorNameForMembersInjectionBinding;
-import static javax.lang.model.element.ElementKind.CONSTRUCTOR;
+import static dagger.internal.codegen.Util.componentCanMakeNewInstances;
+import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.PUBLIC;
 import static javax.lang.model.element.Modifier.STATIC;
-import static javax.lang.model.element.NestingKind.MEMBER;
-import static javax.lang.model.element.NestingKind.TOP_LEVEL;
 import static javax.lang.model.type.TypeKind.VOID;
 
 /**
@@ -115,10 +120,12 @@
  * @since 2.0
  */
 final class ComponentGenerator extends SourceFileGenerator<BindingGraph> {
+  private final Types types;
   private final Diagnostic.Kind nullableValidationType;
 
-  ComponentGenerator(Filer filer, Diagnostic.Kind nullableValidationType) {
+  ComponentGenerator(Filer filer, Types types, Diagnostic.Kind nullableValidationType) {
     super(filer);
+    this.types = types;
     this.nullableValidationType = nullableValidationType;
   }
 
@@ -127,7 +134,7 @@ ClassName nameGeneratedType(BindingGraph input) {
     ClassName componentDefinitionClassName =
         ClassName.fromTypeElement(input.componentDescriptor().componentDefinitionType());
     String componentName =
-        "Dagger_" + componentDefinitionClassName.classFileName().replace('$', '_');
+        "Dagger" + componentDefinitionClassName.classFileName().replace('$', '_');
     return componentDefinitionClassName.topLevelClassName().peerNamed(componentName);
   }
 
@@ -199,15 +206,26 @@ Snippet getSnippetFor(ClassName usingClass) {
 
   @Override
   ImmutableSet<JavaWriter> write(ClassName componentName, BindingGraph input) {
+    TypeElement componentDefinitionType = input.componentDescriptor().componentDefinitionType();
     ClassName componentDefinitionTypeName =
-        ClassName.fromTypeElement(input.componentDescriptor().componentDefinitionType());
+        ClassName.fromTypeElement(componentDefinitionType);
 
     JavaWriter writer = JavaWriter.inPackage(componentName.packageName());
 
     ClassWriter componentWriter = writer.addClass(componentName.simpleName());
     componentWriter.annotate(Generated.class).setValue(ComponentProcessor.class.getCanonicalName());
     componentWriter.addModifiers(PUBLIC, FINAL);
-    componentWriter.addImplementedType(componentDefinitionTypeName);
+    switch (componentDefinitionType.getKind()) {
+      case CLASS:
+        checkState(componentDefinitionType.getModifiers().contains(ABSTRACT));
+        componentWriter.setSuperType(componentDefinitionTypeName);
+        break;
+      case INTERFACE:
+        componentWriter.addImplementedType(componentDefinitionTypeName);
+        break;
+      default:
+        throw new IllegalStateException();
+    }
 
     Set<JavaWriter> javaWriters = Sets.newHashSet();
     javaWriters.add(writer);
@@ -272,7 +290,7 @@ Snippet getSnippetFor(ClassName usingClass) {
           .addSnippet("}")
           .addSnippet("this.%s = %s;", builderField.name(), contributionName)
           .addSnippet("return this;");
-      if (hasNoArgsConstructor(contributionElement)) {
+      if (componentCanMakeNewInstances(contributionElement)) {
         buildMethod.body()
             .addSnippet("if (%s == null) {", builderField.name())
             .addSnippet("  this.%s = new %s();",
@@ -329,88 +347,99 @@ Snippet getSnippetFor(ClassName usingClass) {
 
     writeInterfaceMethods(input, componentWriter, memberSelectSnippets, enumBindingKeys);
 
-    writeSubcomponents(input,
-        componentWriter,
-        proxyWriters,
-        componentContributionFields,
-        memberSelectSnippets,
-        multibindingContributionSnippets);
+    for (Entry<ExecutableElement, BindingGraph> subgraphEntry : input.subgraphs().entrySet()) {
+      writeSubcomponent(componentWriter,
+          proxyWriters,
+          componentContributionFields,
+          memberSelectSnippets,
+          multibindingContributionSnippets,
+          subgraphEntry.getKey(),
+          subgraphEntry.getValue());
+    }
 
     return memberSelectSnippets;
   }
 
-  private void writeSubcomponents(BindingGraph input,
-      ClassWriter componentWriter,
+  private void writeSubcomponent(ClassWriter componentWriter,
       Set<JavaWriter> proxyWriters,
-      Map<TypeElement, MemberSelect> componentContributionFields,
+      Map<TypeElement, MemberSelect> parentContributionFields,
       ImmutableMap<BindingKey, MemberSelect> parentMemberSelectSnippets,
-      ImmutableMap<ContributionBinding, Snippet> multibindingContributionSnippets) {
-    for (Entry<ExecutableElement, BindingGraph> subgraphEntry : input.subgraphs().entrySet()) {
-      TypeName componentType =
-          TypeNames.forTypeMirror(subgraphEntry.getKey().getReturnType());
+      ImmutableMap<ContributionBinding, Snippet> parentMultibindingContributionSnippets,
+      ExecutableElement subcomponentFactoryMethod,
+      BindingGraph subgraph) {
+    TypeName subcomponentType =
+        TypeNames.forTypeMirror(subcomponentFactoryMethod.getReturnType());
 
-      ClassWriter subcomponentWriter = componentWriter.addNestedClass(
-          subgraphEntry.getValue().componentDescriptor().componentDefinitionType().getSimpleName()
-              + "Impl");
+    ClassWriter subcomponentWriter = componentWriter.addNestedClass(
+        subgraph.componentDescriptor().componentDefinitionType().getSimpleName()
+            + "Impl");
 
-      subcomponentWriter.addModifiers(PRIVATE, FINAL);
-      subcomponentWriter.addImplementedType(componentType);
+    subcomponentWriter.addModifiers(PRIVATE, FINAL);
+    subcomponentWriter.addImplementedType(subcomponentType);
 
-      writeSubcomponent(subgraphEntry.getValue(),
-          subcomponentWriter,
-          proxyWriters,
-          ImmutableMap.copyOf(componentContributionFields),
-          multibindingContributionSnippets,
-          parentMemberSelectSnippets);
-
-      MethodWriter componentMethod = componentWriter.addMethod(componentType,
-          subgraphEntry.getKey().getSimpleName().toString());
-      componentMethod.addModifiers(PUBLIC);
-      componentMethod.annotate(Override.class);
-      // TODO(gak): need to pipe through the method params
-      componentMethod.body().addSnippet("return new %s();",
-          subcomponentWriter.name());
-    }
-  }
+    MethodWriter componentMethod = componentWriter.addMethod(subcomponentType,
+        subcomponentFactoryMethod.getSimpleName().toString());
+    componentMethod.addModifiers(PUBLIC);
+    componentMethod.annotate(Override.class);
 
-  private ImmutableMap<BindingKey, MemberSelect> writeSubcomponent(
-      BindingGraph input, ClassWriter componentWriter,
-      Set<JavaWriter> proxyWriters,
-      ImmutableMap<TypeElement, MemberSelect> parentContributionFields,
-      ImmutableMap<ContributionBinding, Snippet> parentMultibindingContributionSnippets,
-      ImmutableMap<BindingKey, MemberSelect> parentMemberSelectSnippets) {
-    // the full set of types that calling code uses to construct a component instance
-    ImmutableMap<TypeElement, String> componentContributionNames =
-        ImmutableMap.copyOf(Maps.asMap(
-            Sets.union(
-                input.transitiveModules().keySet(),
-                input.componentDescriptor().dependencies()),
-            new Function<TypeElement, String>() {
-              @Override public String apply(TypeElement input) {
-                return CaseFormat.UPPER_CAMEL.to(LOWER_CAMEL, input.getSimpleName().toString());
-              }
-            }));
-
-    ConstructorWriter constructorWriter = componentWriter.addConstructor();
+    ConstructorWriter constructorWriter = subcomponentWriter.addConstructor();
     constructorWriter.addModifiers(PRIVATE);
+    constructorWriter.body();
 
     Map<TypeElement, MemberSelect> componentContributionFields =
         Maps.newHashMap(parentContributionFields);
+    ImmutableList.Builder<Snippet> subcomponentConstructorParameters = ImmutableList.builder();
+
+    for (VariableElement moduleVariable : subcomponentFactoryMethod.getParameters()) {
+      // safe because this passed validation
+      TypeElement moduleType = MoreTypes.asTypeElement(moduleVariable.asType());
+      verify(subgraph.transitiveModules().containsKey(moduleType));
+      componentMethod.addParameter(
+          TypeNames.forTypeMirror(moduleVariable.asType()),
+          moduleVariable.getSimpleName().toString());
+      if (!componentContributionFields.containsKey(moduleType)) {
+        String preferredModuleName = CaseFormat.UPPER_CAMEL.to(LOWER_CAMEL,
+            moduleType.getSimpleName().toString());
+        FieldWriter contributionField =
+            subcomponentWriter.addField(moduleType, preferredModuleName);
+        contributionField.addModifiers(PRIVATE, FINAL);
+        String actualModuleName = contributionField.name();
+        constructorWriter.addParameter(
+            TypeNames.forTypeMirror(moduleVariable.asType()), actualModuleName);
+        constructorWriter.body().addSnippet(Snippet.format(Joiner.on('\n').join(
+            "if (%s == null) {",
+            "  throw new NullPointerException();",
+            "}"), actualModuleName));
+        constructorWriter.body().addSnippet(
+            Snippet.format("this.%1$s = %1$s;", actualModuleName));
+        MemberSelect moduleSelect = MemberSelect.instanceSelect(
+            subcomponentWriter.name(), Snippet.format(actualModuleName));
+        componentContributionFields.put(moduleType, moduleSelect);
+        subcomponentConstructorParameters.add(Snippet.format("%s", moduleVariable.getSimpleName()));
+      }
+    }
 
-    for (Entry<TypeElement, String> entry : componentContributionNames.entrySet()) {
-      TypeElement contributionElement = entry.getKey();
-      String contributionName = entry.getValue();
+    SetView<TypeElement> uninitializedModules = Sets.difference(
+        subgraph.transitiveModules().keySet(), componentContributionFields.keySet());
+    for (TypeElement moduleType : uninitializedModules) {
+      String preferredModuleName = CaseFormat.UPPER_CAMEL.to(LOWER_CAMEL,
+          moduleType.getSimpleName().toString());
       FieldWriter contributionField =
-          componentWriter.addField(contributionElement, contributionName);
-      if (hasNoArgsConstructor(entry.getKey())) {
-        contributionField.setInitializer(Snippet.format("new %s()",
-            ClassName.fromTypeElement(entry.getKey())));
-      }
+          subcomponentWriter.addField(moduleType, preferredModuleName);
       contributionField.addModifiers(PRIVATE, FINAL);
-      componentContributionFields.put(contributionElement, MemberSelect.instanceSelect(
-          componentWriter.name(), Snippet.format(contributionField.name())));
+      String actualModuleName = contributionField.name();
+      constructorWriter.body().addSnippet(
+          Snippet.format("this.%s = new %s();", actualModuleName,
+              ClassName.fromTypeElement(moduleType)));
+      MemberSelect moduleSelect = MemberSelect.instanceSelect(
+          subcomponentWriter.name(), Snippet.format(actualModuleName));
+      componentContributionFields.put(moduleType, moduleSelect);
     }
 
+    componentMethod.body().addSnippet("return new %s(%s);",
+        subcomponentWriter.name(),
+        Snippet.makeParametersSnippet(subcomponentConstructorParameters.build()));
+
     Map<BindingKey, MemberSelect> memberSelectSnippetsBuilder = Maps.newHashMap();
 
     Map<ContributionBinding, Snippet> multibindingContributionSnippetsBuilder = Maps.newHashMap();
@@ -418,8 +447,8 @@ private void writeSubcomponents(BindingGraph input,
 
     Map<String, ProxyClassAndField> packageProxies = Maps.newHashMap();
 
-    writeFields(input,
-        componentWriter,
+    writeFields(subgraph,
+        subcomponentWriter,
         proxyWriters,
         memberSelectSnippetsBuilder,
         parentMultibindingContributionSnippets,
@@ -440,8 +469,8 @@ private void writeSubcomponents(BindingGraph input,
         ImmutableMap.copyOf(multibindingContributionSnippetsBuilder);
     ImmutableSet<BindingKey> enumBindingKeys = enumBindingKeysBuilder.build();
 
-    initializeFrameworkTypes(input,
-        componentWriter,
+    initializeFrameworkTypes(subgraph,
+        subcomponentWriter,
         constructorWriter,
         Optional.<ClassName>absent(),
         componentContributionFields,
@@ -449,19 +478,20 @@ private void writeSubcomponents(BindingGraph input,
         parentMultibindingContributionSnippets,
         multibindingContributionSnippets);
 
-    writeInterfaceMethods(input, componentWriter, memberSelectSnippets, enumBindingKeys);
-
-    writeSubcomponents(input,
-        componentWriter,
-        proxyWriters,
-        componentContributionFields,
-        memberSelectSnippets,
-        new ImmutableMap.Builder<ContributionBinding, Snippet>()
-            .putAll(parentMultibindingContributionSnippets)
-            .putAll(multibindingContributionSnippets)
-            .build());
+    writeInterfaceMethods(subgraph, subcomponentWriter, memberSelectSnippets, enumBindingKeys);
 
-    return memberSelectSnippets;
+    for (Entry<ExecutableElement, BindingGraph> subgraphEntry : subgraph.subgraphs().entrySet()) {
+      writeSubcomponent(subcomponentWriter,
+          proxyWriters,
+          componentContributionFields,
+          memberSelectSnippets,
+          new ImmutableMap.Builder<ContributionBinding, Snippet>()
+              .putAll(parentMultibindingContributionSnippets)
+              .putAll(multibindingContributionSnippets)
+              .build(),
+          subgraphEntry.getKey(),
+          subgraphEntry.getValue());
+    }
   }
 
   private void writeFields(BindingGraph input,
@@ -627,63 +657,80 @@ private void writeInterfaceMethods(BindingGraph input, ClassWriter componentWrit
       ImmutableSet<BindingKey> enumBindingKeys) throws AssertionError {
     Set<MethodSignature> interfaceMethods = Sets.newHashSet();
 
-    for (DependencyRequest interfaceRequest : input.entryPoints()) {
-      ExecutableElement requestElement =
-          MoreElements.asExecutable(interfaceRequest.requestElement());
-      MethodSignature signature = MethodSignature.fromExecutableElement(requestElement);
-      if (!interfaceMethods.contains(signature)) {
-        interfaceMethods.add(signature);
-        MethodWriter interfaceMethod = requestElement.getReturnType().getKind().equals(VOID)
-            ? componentWriter.addMethod(VoidName.VOID, requestElement.getSimpleName().toString())
-                : componentWriter.addMethod(requestElement.getReturnType(),
-                    requestElement.getSimpleName().toString());
-        interfaceMethod.annotate(Override.class);
-        interfaceMethod.addModifiers(PUBLIC);
-        BindingKey bindingKey = interfaceRequest.bindingKey();
-        switch(interfaceRequest.kind()) {
-          case MEMBERS_INJECTOR:
-            MemberSelect membersInjectorSelect = memberSelectSnippets.get(bindingKey);
-            VariableElement parameter = Iterables.getOnlyElement(requestElement.getParameters());
-            Name parameterName = parameter.getSimpleName();
-            interfaceMethod.addParameter(
-                TypeNames.forTypeMirror(parameter.asType()), parameterName.toString());
-            interfaceMethod.body()
-                .addSnippet("%s.injectMembers(%s);",
+    for (ComponentMethodDescriptor componentMethod :
+        input.componentDescriptor().componentMethods()) {
+      if (componentMethod.dependencyRequest().isPresent()) {
+        DependencyRequest interfaceRequest = componentMethod.dependencyRequest().get();
+        ExecutableElement requestElement =
+            MoreElements.asExecutable(interfaceRequest.requestElement());
+        ExecutableType requestType = MoreTypes.asExecutable(types.asMemberOf(
+            MoreTypes.asDeclared(input.componentDescriptor().componentDefinitionType().asType()),
+            requestElement));
+        MethodSignature signature = MethodSignature.fromExecutableType(
+            requestElement.getSimpleName().toString(),
+            requestType);
+        if (!interfaceMethods.contains(signature)) {
+          interfaceMethods.add(signature);
+          MethodWriter interfaceMethod = requestType.getReturnType().getKind().equals(VOID)
+              ? componentWriter.addMethod(VoidName.VOID, requestElement.getSimpleName().toString())
+                  : componentWriter.addMethod(requestType.getReturnType(),
+                      requestElement.getSimpleName().toString());
+          interfaceMethod.annotate(Override.class);
+          interfaceMethod.addModifiers(PUBLIC);
+          BindingKey bindingKey = interfaceRequest.bindingKey();
+          switch(interfaceRequest.kind()) {
+            case MEMBERS_INJECTOR:
+              MemberSelect membersInjectorSelect = memberSelectSnippets.get(bindingKey);
+              List<? extends VariableElement> parameters = requestElement.getParameters();
+              if (parameters.isEmpty()) {
+                // we're returning the framework type
+                interfaceMethod.body().addSnippet("return %s;",
+                    membersInjectorSelect.getSnippetFor(componentWriter.name()));
+              } else {
+                VariableElement parameter = Iterables.getOnlyElement(parameters);
+                Name parameterName = parameter.getSimpleName();
+                interfaceMethod.addParameter(
+                    TypeNames.forTypeMirror(
+                        Iterables.getOnlyElement(requestType.getParameterTypes())),
+                    parameterName.toString());
+                interfaceMethod.body().addSnippet("%s.injectMembers(%s);",
                     // in this case we know we won't need the cast because we're never going to pass
                     // the reference to anything
                     membersInjectorSelect.getSnippetFor(componentWriter.name()),
                     parameterName);
-            if (!requestElement.getReturnType().getKind().equals(VOID)) {
-              interfaceMethod.body().addSnippet("return %s;", parameterName);
-            }
-            break;
-          case INSTANCE:
-            if (enumBindingKeys.contains(bindingKey)
-                && !MoreTypes.asDeclared(bindingKey.key().type())
-                        .getTypeArguments().isEmpty()) {
-              // If using a parameterized enum type, then we need to store the factory
-              // in a temporary variable, in order to help javac be able to infer
-              // the generics of the Factory.create methods.
-              TypeName factoryType = ParameterizedTypeName.create(Provider.class,
-                  TypeNames.forTypeMirror(requestElement.getReturnType()));
-              interfaceMethod.body().addSnippet("%s factory = %s;", factoryType,
-                  memberSelectSnippets.get(bindingKey).getSnippetFor(componentWriter.name()));
-              interfaceMethod.body().addSnippet("return factory.get();");
+                if (!requestType.getReturnType().getKind().equals(VOID)) {
+                  interfaceMethod.body().addSnippet("return %s;", parameterName);
+                }
+              }
               break;
-            }
-            // fall through in the else case.
-          case LAZY:
-          case PRODUCED:
-          case PRODUCER:
-          case PROVIDER:
-          case FUTURE:
-            interfaceMethod.body().addSnippet("return %s;",
-                frameworkTypeUsageStatement(
-                    memberSelectSnippets.get(bindingKey).getSnippetFor(componentWriter.name()),
-                    interfaceRequest.kind()));
-            break;
-          default:
-            throw new AssertionError();
+            case INSTANCE:
+              if (enumBindingKeys.contains(bindingKey)
+                  && !MoreTypes.asDeclared(bindingKey.key().type())
+                          .getTypeArguments().isEmpty()) {
+                // If using a parameterized enum type, then we need to store the factory
+                // in a temporary variable, in order to help javac be able to infer
+                // the generics of the Factory.create methods.
+                TypeName factoryType = ParameterizedTypeName.create(Provider.class,
+                    TypeNames.forTypeMirror(requestType.getReturnType()));
+                interfaceMethod.body().addSnippet("%s factory = %s;", factoryType,
+                    memberSelectSnippets.get(bindingKey).getSnippetFor(componentWriter.name()));
+                interfaceMethod.body().addSnippet("return factory.get();");
+                break;
+              }
+              // fall through in the else case.
+            case LAZY:
+            case PRODUCED:
+            case PRODUCER:
+            case PROVIDER:
+            case FUTURE:
+              interfaceMethod.body().addSnippet("return %s;",
+                  frameworkTypeUsageStatement(
+                      memberSelectSnippets.get(bindingKey).getSnippetFor(componentWriter.name()),
+                      interfaceRequest.kind()));
+              break;
+            default:
+              throw new AssertionError();
+          }
         }
       }
     }
@@ -758,9 +805,11 @@ private void initializeFrameworkTypes(BindingGraph input,
                   ImmutableSet<ProvisionBinding> provisionBindings =
                       (ImmutableSet<ProvisionBinding>) bindings;
                   for (ProvisionBinding provisionBinding : provisionBindings) {
-                    if (!isNonProviderMap(provisionBinding)) {
+                    if (!isNonProviderMap(provisionBinding)
+                        && multibindingContributionSnippets.containsKey(provisionBinding)) {
+                      Snippet snippet = multibindingContributionSnippets.get(provisionBinding);
                       initializeMethod.body().addSnippet("this.%s = %s;",
-                        multibindingContributionSnippets.get(provisionBinding),
+                          snippet,
                           initializeFactoryForProvisionBinding(provisionBinding,
                               componentWriter.name(),
                               input.componentDescriptor().dependencyMethodIndex(),
@@ -771,7 +820,11 @@ private void initializeFrameworkTypes(BindingGraph input,
                   if (!provisionBindings.isEmpty()) {
                     Snippet initializeMapSnippet = initializeMapBinding(
                         componentWriter.name(), memberSelectSnippets,
-                        multibindingContributionSnippets, provisionBindings);
+                        new ImmutableMap.Builder<ContributionBinding, Snippet>()
+                            .putAll(parentMultibindingContributionSnippets)
+                            .putAll(multibindingContributionSnippets)
+                            .build(),
+                        provisionBindings);
                     initializeMethod.body().addSnippet("this.%s = %s;",
                         memberSelectSnippet, initializeMapSnippet);
                   }
@@ -1065,7 +1118,7 @@ private Snippet initializeFactoryForProductionBinding(ProductionBinding binding,
     }
   }
 
-  private static Snippet initializeMembersInjectorForBinding(
+  private Snippet initializeMembersInjectorForBinding(
       ClassName componentName,
       MembersInjectionBinding binding,
       ImmutableMap<BindingKey, MemberSelect> memberSelectSnippets) {
@@ -1092,13 +1145,13 @@ private static Snippet initializeMembersInjectorForBinding(
     }
   }
 
-  private static List<Snippet> getDependencyParameters(
+  private List<Snippet> getDependencyParameters(
       ClassName componentName,
       Iterable<DependencyRequest> dependencies,
       ImmutableMap<BindingKey, MemberSelect> memberSelectSnippets) {
     ImmutableList.Builder<Snippet> parameters = ImmutableList.builder();
     for (Collection<DependencyRequest> requestsForKey :
-         SourceFiles.indexDependenciesByUnresolvedKey(dependencies).asMap().values()) {
+         SourceFiles.indexDependenciesByUnresolvedKey(types, dependencies).asMap().values()) {
       BindingKey key = Iterables.getOnlyElement(FluentIterable.from(requestsForKey)
           .transform(new Function<DependencyRequest, BindingKey>() {
             @Override public BindingKey apply(DependencyRequest request) {
@@ -1111,14 +1164,14 @@ private static Snippet initializeMembersInjectorForBinding(
     return parameters.build();
   }
 
-  private static List<Snippet> getProducerDependencyParameters(
+  private List<Snippet> getProducerDependencyParameters(
       BindingGraph bindingGraph,
       ClassName componentName,
       Iterable<DependencyRequest> dependencies,
       ImmutableMap<BindingKey, MemberSelect> memberSelectSnippets) {
     ImmutableList.Builder<Snippet> parameters = ImmutableList.builder();
     for (Collection<DependencyRequest> requestsForKey :
-         SourceFiles.indexDependenciesByUnresolvedKey(dependencies).asMap().values()) {
+         SourceFiles.indexDependenciesByUnresolvedKey(types, dependencies).asMap().values()) {
       BindingKey key = Iterables.getOnlyElement(FluentIterable.from(requestsForKey)
           .transform(new Function<DependencyRequest, BindingKey>() {
             @Override public BindingKey apply(DependencyRequest request) {
@@ -1278,18 +1331,4 @@ private boolean isNonProviderMap(Binding binding) {
     return MoreTypes.isTypeOf(Map.class, bindingType) // Implicitly guarantees a declared type.
         && !MoreTypes.isTypeOf(Provider.class, asDeclared(bindingType).getTypeArguments().get(1));
   }
-
-  private boolean hasNoArgsConstructor(TypeElement type) {
-    if (type.getNestingKind().equals(TOP_LEVEL)
-        || type.getNestingKind().equals(MEMBER) && type.getModifiers().contains(STATIC)) {
-      for (Element enclosed : type.getEnclosedElements()) {
-        if (enclosed.getKind().equals(CONSTRUCTOR)) {
-          if (((ExecutableElement) enclosed).getParameters().isEmpty()) {
-            return true;
-          }
-        }
-      }
-    }
-    return false;
-  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
index a298e8aff..401681c72 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -15,10 +15,6 @@
  */
 package dagger.internal.codegen;
 
-import java.util.EnumSet;
-
-import javax.tools.Diagnostic;
-import java.util.Arrays;
 import com.google.auto.common.BasicAnnotationProcessor;
 import com.google.auto.service.AutoService;
 import com.google.common.collect.ImmutableList;
@@ -27,6 +23,7 @@
 import dagger.Provides;
 import dagger.producers.ProducerModule;
 import dagger.producers.Produces;
+import java.util.EnumSet;
 import java.util.Map;
 import java.util.Set;
 import javax.annotation.processing.Filer;
@@ -36,6 +33,8 @@
 import javax.lang.model.SourceVersion;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
+import javax.tools.Diagnostic;
+
 import static javax.tools.Diagnostic.Kind.ERROR;
 
 /**
@@ -85,7 +84,8 @@ public SourceVersion getSupportedSourceVersion() {
     ModuleValidator moduleValidator = new ModuleValidator(types, elements, methodSignatureFormatter,
         Module.class, Provides.class);
     ProvidesMethodValidator providesMethodValidator = new ProvidesMethodValidator(elements);
-    ComponentValidator componentValidator = new ComponentValidator(moduleValidator);
+    ComponentValidator componentValidator =
+        new ComponentValidator(elements, types, moduleValidator);
     MapKeyValidator mapKeyValidator = new MapKeyValidator();
     ModuleValidator producerModuleValidator = new ModuleValidator(types, elements,
         methodSignatureFormatter, ProducerModule.class, Produces.class);
@@ -98,7 +98,8 @@ public SourceVersion getSupportedSourceVersion() {
         new FactoryGenerator(filer, DependencyRequestMapper.FOR_PROVIDER, nullableDiagnosticType);
     MembersInjectorGenerator membersInjectorGenerator =
         new MembersInjectorGenerator(filer, elements, types, DependencyRequestMapper.FOR_PROVIDER);
-    ComponentGenerator componentGenerator = new ComponentGenerator(filer, nullableDiagnosticType);
+    ComponentGenerator componentGenerator =
+        new ComponentGenerator(filer, types, nullableDiagnosticType);
     ProducerFactoryGenerator producerFactoryGenerator =
         new ProducerFactoryGenerator(filer, DependencyRequestMapper.FOR_PRODUCER);
 
@@ -116,7 +117,7 @@ public SourceVersion getSupportedSourceVersion() {
         membersInjectionBindingFactory, membersInjectorGenerator);
 
     ComponentDescriptor.Factory componentDescriptorFactory =
-        new ComponentDescriptor.Factory(elements);
+        new ComponentDescriptor.Factory(elements, types, dependencyRequestFactory);
 
     BindingGraph.Factory bindingGraphFactory = new BindingGraph.Factory(
         elements, types, injectBindingRegistry, keyFactory,
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
index ed99925e9..022275750 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
@@ -15,17 +15,42 @@
  */
 package dagger.internal.codegen;
 
+import com.google.auto.common.MoreElements;
+import com.google.auto.common.MoreTypes;
+import com.google.common.base.Joiner;
+import com.google.common.base.Optional;
+import com.google.common.base.Predicate;
+import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Iterables;
+import com.google.common.collect.Sets;
+import com.google.common.collect.Sets.SetView;
 import dagger.Component;
+import dagger.Module;
+import dagger.Subcomponent;
+import java.util.List;
+import java.util.Set;
 import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.ElementFilter;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.SimpleTypeVisitor6;
+import javax.lang.model.util.Types;
 
 import static com.google.auto.common.MoreElements.getAnnotationMirror;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentModules;
+import static dagger.internal.codegen.ConfigurationAnnotations.getTransitiveModules;
+import static dagger.internal.codegen.Util.componentCanMakeNewInstances;
 import static javax.lang.model.element.ElementKind.CLASS;
 import static javax.lang.model.element.ElementKind.INTERFACE;
 import static javax.lang.model.element.Modifier.ABSTRACT;
+import static javax.lang.model.type.TypeKind.VOID;
 
 /**
  * Performs superficial validation of the contract of the {@link Component} annotation.
@@ -33,12 +58,16 @@
  * @author Gregory Kick
  */
 final class ComponentValidator implements Validator<TypeElement> {
+  private final Elements elements;
+  private final Types types;
   private final ModuleValidator moduleValidator;
-  
-  ComponentValidator(ModuleValidator moduleValidator) {
+
+  ComponentValidator(Elements elements, Types types, ModuleValidator moduleValidator) {
+    this.elements = elements;
+    this.types = types;
     this.moduleValidator = moduleValidator;
   }
-  
+
   @Override public ValidationReport<TypeElement> validate(final TypeElement subject) {
     final ValidationReport.Builder<TypeElement> builder = ValidationReport.Builder.about(subject);
 
@@ -47,9 +76,131 @@
       builder.addItem("@Component may only be applied to an interface or abstract class", subject);
     }
 
+    List<? extends Element> members = elements.getAllMembers(subject);
+    for (ExecutableElement method : ElementFilter.methodsIn(members)) {
+      if (method.getModifiers().contains(ABSTRACT)) {
+        List<? extends VariableElement> parameters = method.getParameters();
+        TypeMirror returnType = method.getReturnType();
+
+        // abstract methods are ones we have to implement, so they each need to be validated
+        // first, check the return type.  if it's a subcomponent, validate that method as such.
+        Optional<AnnotationMirror> subcomponentAnnotation  = returnType.accept(
+            new SimpleTypeVisitor6<Optional<AnnotationMirror>, Void>() {
+              @Override protected Optional<AnnotationMirror> defaultAction(TypeMirror e, Void p) {
+                return Optional.absent();
+              }
+
+              @Override public Optional<AnnotationMirror> visitDeclared(DeclaredType t, Void p) {
+                return MoreElements.getAnnotationMirror(t.asElement(), Subcomponent.class);
+              }
+            }, null);
+        if (subcomponentAnnotation.isPresent()) {
+          validateSubcomponentMethod(
+              builder, method, parameters, returnType, subcomponentAnnotation);
+        } else {
+          // if it's not a subcomponent...
+          switch (parameters.size()) {
+            case 0:
+              // no parameters means that it is a provision method
+              // basically, there are no restrictions here.  \o/
+              break;
+            case 1:
+              // one parameter means that it's a members injection method
+              VariableElement onlyParameter = Iterables.getOnlyElement(parameters);
+              if (!(returnType.getKind().equals(VOID)
+                  || types.isSameType(returnType, onlyParameter.asType()))) {
+                builder.addItem(
+                    "Members injection methods may only return the injected type or void.",
+                    method);
+              }
+              break;
+            default:
+              // this isn't any method that we know how to implement...
+              builder.addItem(
+                  "This method isn't a valid provision method, members injection method or "
+                      + "subcomponent factory method. Dagger cannot implement this method", method);
+              break;
+          }
+        }
+      }
+    }
+
     AnnotationMirror componentMirror = getAnnotationMirror(subject, Component.class).get();
     ImmutableList<TypeMirror> moduleTypes = getComponentModules(componentMirror);
     moduleValidator.validateReferencedModules(subject, builder, moduleTypes);
     return builder.build();
   }
+
+  private void validateSubcomponentMethod(final ValidationReport.Builder<TypeElement> builder,
+      ExecutableElement method, List<? extends VariableElement> parameters, TypeMirror returnType,
+      Optional<AnnotationMirror> subcomponentAnnotation) {
+    ImmutableSet<TypeElement> moduleTypes =
+        MoreTypes.asTypeElements(getComponentModules(subcomponentAnnotation.get()));
+
+    ImmutableSet<TypeElement> transitiveModules =
+        getTransitiveModules(types, elements, moduleTypes);
+
+    ImmutableSet<TypeElement> requiredModules =
+        FluentIterable.from(transitiveModules)
+            .filter(new Predicate<TypeElement>() {
+              @Override public boolean apply(TypeElement input) {
+                return !componentCanMakeNewInstances(input);
+              }
+            })
+            .toSet();
+
+    Set<TypeElement> variableTypes = Sets.newHashSet();
+
+    for (VariableElement parameter : parameters) {
+      Optional<TypeElement> moduleType = parameter.asType().accept(
+          new SimpleTypeVisitor6<Optional<TypeElement>, Void>() {
+            @Override protected Optional<TypeElement> defaultAction(TypeMirror e, Void p) {
+              return Optional.absent();
+            }
+
+            @Override public Optional<TypeElement> visitDeclared(DeclaredType t, Void p) {
+              return MoreElements.isAnnotationPresent(t.asElement(), Module.class)
+                  ? Optional.of(MoreTypes.asTypeElement(t))
+                  : Optional.<TypeElement>absent();
+            }
+          }, null);
+      if (moduleType.isPresent()) {
+        if (variableTypes.contains(moduleType.get())) {
+          builder.addItem(
+              String.format(
+                  "A module may only occur once an an argument in a Subcomponent factory "
+                      + "method, but %s was already passed.",
+                  moduleType.get().getQualifiedName()), parameter);
+        }
+        if (!transitiveModules.contains(moduleType.get())) {
+          builder.addItem(
+              String.format(
+                  "%s is present as an argument to the %s factory method, but is not one of the"
+                      + " modules used to implement the subcomponent.",
+                  moduleType.get().getQualifiedName(),
+                  MoreTypes.asTypeElement(returnType).getQualifiedName()),
+              method);
+        }
+        variableTypes.add(moduleType.get());
+      } else {
+        builder.addItem(
+            String.format(
+                "Subcomponent factory methods may only accept modules, but %s is not.",
+                parameter.asType()),
+            parameter);
+      }
+    }
+
+    SetView<TypeElement> missingModules =
+        Sets.difference(requiredModules, ImmutableSet.copyOf(variableTypes));
+    if (!missingModules.isEmpty()) {
+      builder.addItem(
+          String.format(
+              "%s requires modules which have no visible default constructors. "
+                  + "Add the following modules as parameters to this method: %s",
+              MoreTypes.asTypeElement(returnType).getQualifiedName(),
+              Joiner.on(", ").join(missingModules)),
+          method);
+    }
+  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java b/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
index 3a91a1e34..de60f4285 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
@@ -15,8 +15,6 @@
  */
 package dagger.internal.codegen;
 
-import javax.lang.model.type.DeclaredType;
-
 import com.google.auto.common.AnnotationMirrors;
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
@@ -24,10 +22,9 @@
 import com.google.common.base.Optional;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
-import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.Maps;
 import com.google.common.collect.Queues;
+import com.google.common.collect.Sets;
 import dagger.Component;
 import dagger.MapKey;
 import dagger.Module;
@@ -35,8 +32,8 @@
 import dagger.producers.ProducerModule;
 import dagger.producers.ProductionComponent;
 import java.util.List;
-import java.util.Map;
 import java.util.Queue;
+import java.util.Set;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.AnnotationValue;
 import javax.lang.model.element.Element;
@@ -47,6 +44,7 @@
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.SimpleTypeVisitor6;
 import javax.lang.model.util.Types;
+
 import static com.google.auto.common.AnnotationMirrors.getAnnotationValue;
 import static com.google.auto.common.MoreElements.getAnnotationMirror;
 import static com.google.common.base.Preconditions.checkNotNull;
@@ -95,7 +93,7 @@ static boolean isComponent(TypeElement componentDefinitionType) {
   static ImmutableSet<? extends AnnotationMirror> getMapKeys(Element element) {
     return AnnotationMirrors.getAnnotatedAnnotations(element, MapKey.class);
   }
-  
+
   /** Returns the first type that specifies this' nullability, or absent if none. */
   static Optional<DeclaredType> getNullableType(Element element) {
     List<? extends AnnotationMirror> mirrors = element.getAnnotationMirrors();
@@ -124,11 +122,11 @@ static boolean isComponent(TypeElement componentDefinitionType) {
    * given seed modules.  If a module is malformed and a type listed in {@link Module#includes}
    * is not annotated with {@link Module}, it is ignored.
    */
-  static ImmutableMap<TypeElement, ImmutableSet<TypeElement>> getTransitiveModules(
-      Types types, Elements elements, ImmutableSet<TypeElement> seedModules) {
+  static ImmutableSet<TypeElement> getTransitiveModules(
+      Types types, Elements elements, Iterable<TypeElement> seedModules) {
     TypeMirror objectType = elements.getTypeElement(Object.class.getCanonicalName()).asType();
     Queue<TypeElement> moduleQueue = Queues.newArrayDeque(seedModules);
-    Map<TypeElement, ImmutableSet<TypeElement>> moduleElements = Maps.newLinkedHashMap();
+    Set<TypeElement> moduleElements = Sets.newLinkedHashSet();
     for (TypeElement moduleElement = moduleQueue.poll();
         moduleElement != null;
         moduleElement = moduleQueue.poll()) {
@@ -143,15 +141,15 @@ static boolean isComponent(TypeElement componentDefinitionType) {
         // against this element, not the parent.)
         addIncludesFromSuperclasses(types, moduleElement, moduleDependenciesBuilder, objectType);
         ImmutableSet<TypeElement> moduleDependencies = moduleDependenciesBuilder.build();
-        moduleElements.put(moduleElement, moduleDependencies);
+        moduleElements.add(moduleElement);
         for (TypeElement dependencyType : moduleDependencies) {
-          if (!moduleElements.containsKey(dependencyType)) {
+          if (!moduleElements.contains(dependencyType)) {
             moduleQueue.add(dependencyType);
           }
         }
       }
     }
-    return ImmutableMap.copyOf(moduleElements);
+    return ImmutableSet.copyOf(moduleElements);
   }
 
   static boolean isSubcomponentType(TypeMirror type) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
index 9e36418fd..2fbb507c2 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
@@ -37,6 +37,7 @@
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.ExecutableType;
 import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
 
@@ -44,6 +45,7 @@
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
+import static javax.lang.model.type.TypeKind.DECLARED;
 
 /**
  * Represents a request for a key at an injection point. Parameters to {@link Inject} constructors
@@ -163,21 +165,24 @@ DependencyRequest forRequiredResolvedVariable(DeclaredType container,
       return newDependencyRequest(variableElement, resolvedType, qualifier, container);
     }
 
-    DependencyRequest forComponentProvisionMethod(ExecutableElement provisionMethod) {
+    DependencyRequest forComponentProvisionMethod(ExecutableElement provisionMethod,
+        ExecutableType provisionMethodType) {
       checkNotNull(provisionMethod);
+      checkNotNull(provisionMethodType);
       checkArgument(provisionMethod.getParameters().isEmpty(),
           "Component provision methods must be empty: " + provisionMethod);
-      TypeMirror type = provisionMethod.getReturnType();
       Optional<AnnotationMirror> qualifier = InjectionAnnotations.getQualifier(provisionMethod);
-      return newDependencyRequest(provisionMethod, type, qualifier,
+      return newDependencyRequest(provisionMethod, provisionMethodType.getReturnType(), qualifier,
           getEnclosingType(provisionMethod));
     }
 
-    DependencyRequest forComponentProductionMethod(ExecutableElement productionMethod) {
+    DependencyRequest forComponentProductionMethod(ExecutableElement productionMethod,
+        ExecutableType productionMethodType) {
       checkNotNull(productionMethod);
+      checkNotNull(productionMethodType);
       checkArgument(productionMethod.getParameters().isEmpty(),
           "Component production methods must be empty: %s", productionMethod);
-      TypeMirror type = productionMethod.getReturnType();
+      TypeMirror type = productionMethodType.getReturnType();
       Optional<AnnotationMirror> qualifier = InjectionAnnotations.getQualifier(productionMethod);
       DeclaredType container = getEnclosingType(productionMethod);
       // Only a component production method can be a request for a ListenableFuture, so we
@@ -195,17 +200,30 @@ DependencyRequest forComponentProductionMethod(ExecutableElement productionMetho
       }
     }
 
-    DependencyRequest forComponentMembersInjectionMethod(ExecutableElement membersInjectionMethod) {
+    DependencyRequest forComponentMembersInjectionMethod(ExecutableElement membersInjectionMethod,
+        ExecutableType membersInjectionMethodType) {
       checkNotNull(membersInjectionMethod);
+      checkNotNull(membersInjectionMethodType);
       Optional<AnnotationMirror> qualifier =
           InjectionAnnotations.getQualifier(membersInjectionMethod);
       checkArgument(!qualifier.isPresent());
-      return new AutoValue_DependencyRequest(Kind.MEMBERS_INJECTOR,
-          keyFactory.forMembersInjectedType(
-              Iterables.getOnlyElement(membersInjectionMethod.getParameters()).asType()),
-          membersInjectionMethod,
-          getEnclosingType(membersInjectionMethod),
-          false /* doesn't allow null */);
+      TypeMirror returnType = membersInjectionMethodType.getReturnType();
+      if (returnType.getKind().equals(DECLARED)
+          && MoreTypes.isTypeOf(MembersInjector.class, returnType)) {
+        return new AutoValue_DependencyRequest(Kind.MEMBERS_INJECTOR,
+            keyFactory.forMembersInjectedType(
+                Iterables.getOnlyElement(((DeclaredType) returnType).getTypeArguments())),
+                membersInjectionMethod,
+                getEnclosingType(membersInjectionMethod),
+                false /* doesn't allow null */);
+      } else {
+        return new AutoValue_DependencyRequest(Kind.MEMBERS_INJECTOR,
+            keyFactory.forMembersInjectedType(
+                Iterables.getOnlyElement(membersInjectionMethodType.getParameterTypes())),
+                membersInjectionMethod,
+                getEnclosingType(membersInjectionMethod),
+                false /* doesn't allow null */);
+      }
     }
 
     DependencyRequest forMembersInjectedType(DeclaredType type) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
index e5b657bee..53b5d2232 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
@@ -161,7 +161,7 @@
   static final String PROVIDES_OR_PRODUCES_METHOD_MULTIPLE_QUALIFIERS =
       "Cannot use more than one @Qualifier on a @Provides or @Produces method";
 
-  /*mapKey errors*/
+  /* mapKey errors*/
   static final String MAPKEY_WITHOUT_FIELDS =
       "Map key annotation does not have fields";
 
@@ -195,10 +195,10 @@
       "This type supports members injection but cannot be implicitly provided.";
 
   static final String MEMBERS_INJECTION_WITH_RAW_TYPE =
-      "%s has type parameters, cannot members inject the raw type.";
+      "%s has type parameters, cannot members inject the raw type. via:\n%s";
 
   static final String MEMBERS_INJECTION_WITH_UNBOUNDED_TYPE =
-      "Type parameters must be bounded for members injection.";
+      "Type parameters must be bounded for members injection. (%s required by %s, via:\n%s";
 
   static final String CONTAINS_DEPENDENCY_CYCLE_FORMAT = "%s.%s() contains a dependency cycle:\n%s";
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/Key.java b/compiler/src/main/java/dagger/internal/codegen/Key.java
index 9f48deaa1..ca01668b7 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Key.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Key.java
@@ -89,8 +89,14 @@ TypeMirror type() {
     return wrappedType().get();
   }
 
-  Key withType(TypeMirror newType) {
-    return new AutoValue_Key(wrappedQualifier(), MoreTypes.equivalence().wrap(newType));
+  private static TypeMirror normalize(Types types, TypeMirror type) {
+    TypeKind kind = type.getKind();
+    return kind.isPrimitive() ? types.boxedClass((PrimitiveType) type).asType() : type;
+  }
+
+  Key withType(Types types, TypeMirror newType) {
+    return new AutoValue_Key(wrappedQualifier(),
+        MoreTypes.equivalence().wrap(normalize(types, newType)));
   }
 
   boolean isValidMembersInjectionKey() {
@@ -157,11 +163,6 @@ public String toString() {
       this.elements = checkNotNull(elements);
     }
 
-    private TypeMirror normalize(TypeMirror type) {
-      TypeKind kind = type.getKind();
-      return kind.isPrimitive() ? types.boxedClass((PrimitiveType) type).asType() : type;
-    }
-
     private TypeElement getSetElement() {
       return elements.getTypeElement(Set.class.getCanonicalName());
     }
@@ -185,7 +186,7 @@ private TypeElement getClassElement(Class<?> cls) {
     Key forComponentMethod(ExecutableElement componentMethod) {
       checkNotNull(componentMethod);
       checkArgument(componentMethod.getKind().equals(METHOD));
-      TypeMirror returnType = normalize(componentMethod.getReturnType());
+      TypeMirror returnType = normalize(types, componentMethod.getReturnType());
       return new AutoValue_Key(
           wrapOptionalInEquivalence(AnnotationMirrors.equivalence(), getQualifier(componentMethod)),
           MoreTypes.equivalence().wrap(returnType));
@@ -194,7 +195,7 @@ Key forComponentMethod(ExecutableElement componentMethod) {
     Key forProductionComponentMethod(ExecutableElement componentMethod) {
       checkNotNull(componentMethod);
       checkArgument(componentMethod.getKind().equals(METHOD));
-      TypeMirror returnType = normalize(componentMethod.getReturnType());
+      TypeMirror returnType = normalize(types, componentMethod.getReturnType());
       TypeMirror keyType = returnType;
       if (MoreTypes.isTypeOf(ListenableFuture.class, returnType)) {
         keyType = Iterables.getOnlyElement(MoreTypes.asDeclared(returnType).getTypeArguments());
@@ -209,7 +210,7 @@ Key forProvidesMethod(ExecutableType executableType, ExecutableElement e) {
       checkArgument(e.getKind().equals(METHOD));
       Provides providesAnnotation = e.getAnnotation(Provides.class);
       checkArgument(providesAnnotation != null);
-      TypeMirror returnType = normalize(executableType.getReturnType());
+      TypeMirror returnType = normalize(types, executableType.getReturnType());
       switch (providesAnnotation.type()) {
         case UNIQUE:
           return new AutoValue_Key(
@@ -252,7 +253,7 @@ Key forProducesMethod(ExecutableType executableType, ExecutableElement e) {
       checkArgument(e.getKind().equals(METHOD));
       Produces producesAnnotation = e.getAnnotation(Produces.class);
       checkArgument(producesAnnotation != null);
-      TypeMirror returnType = normalize(executableType.getReturnType());
+      TypeMirror returnType = normalize(types, executableType.getReturnType());
       TypeMirror keyType = returnType;
       if (MoreTypes.isTypeOf(ListenableFuture.class, returnType)) {
         keyType = Iterables.getOnlyElement(MoreTypes.asDeclared(returnType).getTypeArguments());
@@ -301,19 +302,19 @@ Key forInjectConstructorWithResolvedType(TypeMirror type) {
     Key forComponent(TypeMirror type) {
       return new AutoValue_Key(
           Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
-          MoreTypes.equivalence().wrap(normalize(type)));
+          MoreTypes.equivalence().wrap(normalize(types, type)));
     }
 
     Key forMembersInjectedType(TypeMirror type) {
       return new AutoValue_Key(
           Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
-          MoreTypes.equivalence().wrap(normalize(type)));
+          MoreTypes.equivalence().wrap(normalize(types, type)));
     }
 
     Key forQualifiedType(Optional<AnnotationMirror> qualifier, TypeMirror type) {
       return new AutoValue_Key(
           wrapOptionalInEquivalence(AnnotationMirrors.equivalence(), qualifier),
-          MoreTypes.equivalence().wrap(normalize(type)));
+          MoreTypes.equivalence().wrap(normalize(types, type)));
     }
 
     /**
diff --git a/compiler/src/main/java/dagger/internal/codegen/MethodSignature.java b/compiler/src/main/java/dagger/internal/codegen/MethodSignature.java
index d45fd8758..447ed24ef 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MethodSignature.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MethodSignature.java
@@ -4,8 +4,7 @@
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Equivalence;
 import com.google.common.collect.ImmutableList;
-import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.ExecutableType;
 import javax.lang.model.type.TypeMirror;
 
 import static com.google.common.base.Preconditions.checkNotNull;
@@ -16,18 +15,18 @@
   abstract ImmutableList<Equivalence.Wrapper<TypeMirror>> parameterTypes();
   abstract ImmutableList<Equivalence.Wrapper<TypeMirror>> thrownTypes();
 
-  static MethodSignature fromExecutableElement(ExecutableElement method) {
-    checkNotNull(method);
+  static MethodSignature fromExecutableType(String methodName, ExecutableType methodType) {
+    checkNotNull(methodType);
     ImmutableList.Builder<Equivalence.Wrapper<TypeMirror>> parameters = ImmutableList.builder();
     ImmutableList.Builder<Equivalence.Wrapper<TypeMirror>> thrownTypes = ImmutableList.builder();
-    for (VariableElement parameter : method.getParameters()) {
-      parameters.add(MoreTypes.equivalence().wrap(parameter.asType()));
+    for (TypeMirror parameter : methodType.getParameterTypes()) {
+      parameters.add(MoreTypes.equivalence().wrap(parameter));
     }
-    for (TypeMirror thrownType : method.getThrownTypes()) {
+    for (TypeMirror thrownType : methodType.getThrownTypes()) {
       thrownTypes.add(MoreTypes.equivalence().wrap(thrownType));
     }
     return new AutoValue_MethodSignature(
-        method.getSimpleName().toString(),
+        methodName,
         parameters.build(),
         thrownTypes.build());
   }
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
index bf208a63c..b18362230 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
@@ -37,6 +37,7 @@
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Types;
 
 import static com.google.common.base.CaseFormat.UPPER_CAMEL;
 
@@ -79,10 +80,10 @@ public int compare(DependencyRequest left, DependencyRequest right) {
   // TODO(user): Refactor these indexing methods so that the binding itself knows what sort of
   // binding keys and framework classes that it needs.
   static ImmutableSetMultimap<BindingKey, DependencyRequest> indexDependenciesByUnresolvedKey(
-      Iterable<? extends DependencyRequest> dependencies) {
+      Types types, Iterable<? extends DependencyRequest> dependencies) {
     ImmutableSetMultimap.Builder<BindingKey, DependencyRequest> dependenciesByKeyBuilder =
-        new ImmutableSetMultimap.Builder<BindingKey, DependencyRequest>().orderValuesBy(
-            DEPENDENCY_ORDERING);
+        new ImmutableSetMultimap.Builder<BindingKey, DependencyRequest>()
+            .orderValuesBy(DEPENDENCY_ORDERING);
     for (DependencyRequest dependency : dependencies) {
       BindingKey resolved = dependency.bindingKey();
       // To get the proper unresolved type, we have to extract the proper type from the
@@ -90,7 +91,7 @@ public int compare(DependencyRequest left, DependencyRequest right) {
       TypeMirror unresolvedType =
           DependencyRequest.Factory.extractKindAndType(dependency.requestElement().asType()).type();
       BindingKey unresolved =
-          BindingKey.create(resolved.kind(), resolved.key().withType(unresolvedType));
+          BindingKey.create(resolved.kind(), resolved.key().withType(types, unresolvedType));
       dependenciesByKeyBuilder.put(unresolved, dependency);
     }
     return dependenciesByKeyBuilder.build();
@@ -106,8 +107,8 @@ public int compare(DependencyRequest left, DependencyRequest right) {
   static ImmutableSetMultimap<BindingKey, DependencyRequest> indexDependenciesByKey(
       Iterable<? extends DependencyRequest> dependencies) {
     ImmutableSetMultimap.Builder<BindingKey, DependencyRequest> dependenciesByKeyBuilder =
-        new ImmutableSetMultimap.Builder<BindingKey, DependencyRequest>().orderValuesBy(
-            DEPENDENCY_ORDERING);
+        new ImmutableSetMultimap.Builder<BindingKey, DependencyRequest>()
+            .orderValuesBy(DEPENDENCY_ORDERING);
     for (DependencyRequest dependency : dependencies) {
       dependenciesByKeyBuilder.put(dependency.bindingKey(), dependency);
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/Util.java b/compiler/src/main/java/dagger/internal/codegen/Util.java
index 2b633b33b..58ad95c36 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Util.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Util.java
@@ -27,6 +27,7 @@
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.AnnotationValue;
 import javax.lang.model.element.AnnotationValueVisitor;
+import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
@@ -36,6 +37,9 @@
 import javax.lang.model.util.SimpleAnnotationValueVisitor6;
 
 import static com.google.common.base.Preconditions.checkState;
+import static javax.lang.model.element.ElementKind.CONSTRUCTOR;
+import static javax.lang.model.element.Modifier.ABSTRACT;
+import static javax.lang.model.element.Modifier.STATIC;
 
 /**
  * Utilities for handling types in annotation processors
@@ -120,5 +124,56 @@ protected TypeElement defaultAction(Object o, Void v) {
         : Optional.<T>absent();
   }
 
+  private static boolean requiresEnclosingInstance(TypeElement typeElement) {
+    switch (typeElement.getNestingKind()) {
+      case TOP_LEVEL:
+        return false;
+      case MEMBER:
+        return !typeElement.getModifiers().contains(STATIC);
+      case ANONYMOUS:
+      case LOCAL:
+        return true;
+      default:
+        throw new AssertionError("TypeElement cannot have nesting kind: "
+            + typeElement.getNestingKind());
+    }
+  }
+
+  /**
+   * Returns true if and only if a component can instantiate new instances (typically of a module)
+   * rather than requiring that they be passed.
+   */
+  static boolean componentCanMakeNewInstances(TypeElement typeElement) {
+    switch (typeElement.getKind()) {
+      case CLASS:
+        break;
+      case ENUM:
+      case ANNOTATION_TYPE:
+      case INTERFACE:
+        return false;
+      default:
+        throw new AssertionError("TypeElement cannot have kind: " + typeElement.getKind());
+    }
+
+    if (typeElement.getModifiers().contains(ABSTRACT)) {
+      return false;
+    }
+
+    if (requiresEnclosingInstance(typeElement)) {
+      return false;
+    }
+
+    for (Element enclosed : typeElement.getEnclosedElements()) {
+      if (enclosed.getKind().equals(CONSTRUCTOR)
+          && ((ExecutableElement) enclosed).getParameters().isEmpty()) {
+        return true;
+      }
+    }
+
+    // TODO(gak): still need checks for visibility
+
+    return false;
+  }
+
   private Util() {}
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
index af704ea2f..1faed549a 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
@@ -191,7 +191,7 @@
         "  Provider<SomeInjectableType> someInjectableTypeProvider();",
         "}");
     JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
-        "test.Dagger_SimpleComponent",
+        "test.DaggerSimpleComponent",
         "package test;",
         "",
         "import dagger.Lazy;",
@@ -200,8 +200,8 @@
         "import javax.inject.Provider;",
         "",
         "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class Dagger_SimpleComponent implements SimpleComponent {",
-        "  private Dagger_SimpleComponent(Builder builder) {",
+        "public final class DaggerSimpleComponent implements SimpleComponent {",
+        "  private DaggerSimpleComponent(Builder builder) {",
         "    assert builder != null;",
         "    initialize(builder);",
         "  }",
@@ -237,7 +237,7 @@
         "    }",
         "",
         "    public SimpleComponent build() {",
-        "      return new Dagger_SimpleComponent(this);",
+        "      return new DaggerSimpleComponent(this);",
         "    }",
         "  }",
         "}");
@@ -274,7 +274,7 @@
         "  Provider<SomeInjectableType> someInjectableTypeProvider();",
         "}");
     JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
-        "test.Dagger_SimpleComponent",
+        "test.DaggerSimpleComponent",
         "package test;",
         "",
         "import dagger.Lazy;",
@@ -284,10 +284,10 @@
         "import javax.inject.Provider;",
         "",
         "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class Dagger_SimpleComponent implements SimpleComponent {",
+        "public final class DaggerSimpleComponent implements SimpleComponent {",
         "  private Provider<SomeInjectableType> someInjectableTypeProvider;",
         "",
-        "  private Dagger_SimpleComponent(Builder builder) {",
+        "  private DaggerSimpleComponent(Builder builder) {",
         "    assert builder != null;",
         "    initialize(builder);",
         "  }",
@@ -325,7 +325,7 @@
         "    }",
         "",
         "    public SimpleComponent build() {",
-        "      return new Dagger_SimpleComponent(this);",
+        "      return new DaggerSimpleComponent(this);",
         "    }",
         "  }",
         "}");
@@ -356,7 +356,7 @@
         "}");
 
     JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
-        "test.Dagger_OuterType_SimpleComponent",
+        "test.DaggerOuterType_SimpleComponent",
         "package test;",
         "",
         "import dagger.MembersInjector;",
@@ -366,10 +366,10 @@
         "import test.OuterType.SimpleComponent;",
         "",
         "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class Dagger_OuterType_SimpleComponent implements SimpleComponent {",
+        "public final class DaggerOuterType_SimpleComponent implements SimpleComponent {",
         "  private MembersInjector<B> bMembersInjector;",
         "",
-        "  private Dagger_OuterType_SimpleComponent(Builder builder) {",
+        "  private DaggerOuterType_SimpleComponent(Builder builder) {",
         "    assert builder != null;",
         "    initialize(builder);",
         "  }",
@@ -402,7 +402,7 @@
         "    }",
         "",
         "    public SimpleComponent build() {",
-        "      return new Dagger_OuterType_SimpleComponent(this);",
+        "      return new DaggerOuterType_SimpleComponent(this);",
         "    }",
         "  }",
         "}");
@@ -457,18 +457,18 @@
         "  A a();",
         "}");
     JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
-        "test.Dagger_TestComponent",
+        "test.DaggerTestComponent",
         "package test;",
         "",
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
         "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class Dagger_TestComponent implements TestComponent {",
+        "public final class DaggerTestComponent implements TestComponent {",
         "  private Provider<B> bProvider;",
         "  private Provider<A> aProvider;",
         "",
-        "  private Dagger_TestComponent(Builder builder) {",
+        "  private DaggerTestComponent(Builder builder) {",
         "    assert builder != null;",
         "    initialize(builder);",
         "  }",
@@ -502,7 +502,7 @@
         "      if (testModule == null) {",
         "        this.testModule = new TestModule();",
         "      }",
-        "      return new Dagger_TestComponent(this);",
+        "      return new DaggerTestComponent(this);",
         "    }",
         "",
         "    public Builder testModule(TestModule testModule) {",
@@ -592,15 +592,15 @@
     // Generated code includes all includes, but excludes the parent modules.
     // The "always" module should only be listed once.
     JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
-        "test.Dagger_TestComponent",
+        "test.DaggerTestComponent",
         "package test;",
         "",
         "import javax.annotation.Generated;",
         "",
         "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class Dagger_TestComponent implements TestComponent {",
+        "public final class DaggerTestComponent implements TestComponent {",
         "",
-        "  private Dagger_TestComponent(Builder builder) {",
+        "  private DaggerTestComponent(Builder builder) {",
         "    assert builder != null;",
         "  }",
         "",
@@ -642,7 +642,7 @@
         "      if (parentDepIncluded == null) {",
         "        this.parentDepIncluded = new ParentDepIncluded();",
         "      }",
-        "      return new Dagger_TestComponent(this);",
+        "      return new DaggerTestComponent(this);",
         "    }",
         "",
         "    public Builder testModule(TestModule testModule) {",
@@ -779,7 +779,7 @@
         "  Set<String> strings();",
         "}");
     JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
-        "test.Dagger_TestComponent",
+        "test.DaggerTestComponent",
         "package test;",
         "",
         "import dagger.internal.SetFactory;",
@@ -788,12 +788,12 @@
         "import javax.inject.Provider;",
         "",
         "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class Dagger_TestComponent implements TestComponent {",
+        "public final class DaggerTestComponent implements TestComponent {",
         "  private Provider<Set<String>> setOfStringContribution1Provider;",
         "  private Provider<Set<String>> setOfStringContribution2Provider;",
         "  private Provider<Set<String>> setOfStringProvider;",
         "",
-        "  private Dagger_TestComponent(Builder builder) {",
+        "  private DaggerTestComponent(Builder builder) {",
         "    assert builder != null;",
         "    initialize(builder);",
         "  }",
@@ -834,7 +834,7 @@
         "      if (setModule == null) {",
         "        this.setModule = new SetModule();",
         "      }",
-        "      return new Dagger_TestComponent(this);",
+        "      return new DaggerTestComponent(this);",
         "    }",
         "",
         "    public Builder emptySetModule(EmptySetModule emptySetModule) {",
@@ -893,17 +893,17 @@
         "  SomeInjectedType injectAndReturn(SomeInjectedType instance);",
         "}");
     JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
-        "test.Dagger_SimpleComponent",
+        "test.DaggerSimpleComponent",
         "package test;",
         "",
         "import dagger.MembersInjector;",
         "import javax.annotation.Generated;",
         "",
         "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class Dagger_SimpleComponent implements SimpleComponent {",
+        "public final class DaggerSimpleComponent implements SimpleComponent {",
         "  private MembersInjector<SomeInjectedType> someInjectedTypeMembersInjector;",
         "",
-        "  private Dagger_SimpleComponent(Builder builder) {",
+        "  private DaggerSimpleComponent(Builder builder) {",
         "    assert builder != null;",
         "    initialize(builder);",
         "  }",
@@ -937,7 +937,7 @@
         "    }",
         "",
         "    public SimpleComponent build() {",
-        "      return new Dagger_SimpleComponent(this);",
+        "      return new DaggerSimpleComponent(this);",
         "    }",
         "  }",
         "}");
@@ -970,7 +970,7 @@
         "  SomeInjectableType someInjectableType();",
         "}");
     JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
-        "test.Dagger_SimpleComponent",
+        "test.DaggerSimpleComponent",
         "package test;",
         "",
         "import dagger.internal.InstanceFactory;",
@@ -978,11 +978,11 @@
         "import javax.inject.Provider;",
         "",
         "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class Dagger_SimpleComponent implements SimpleComponent {",
+        "public final class DaggerSimpleComponent implements SimpleComponent {",
         "  private Provider<SimpleComponent> simpleComponentProvider;",
         "  private Provider<SomeInjectableType> someInjectableTypeProvider;",
         "",
-        "  private Dagger_SimpleComponent(Builder builder) {",
+        "  private DaggerSimpleComponent(Builder builder) {",
         "    assert builder != null;",
         "    initialize(builder);",
         "  }",
@@ -1011,7 +1011,7 @@
         "    }",
         "",
         "    public SimpleComponent build() {",
-        "      return new Dagger_SimpleComponent(this);",
+        "      return new DaggerSimpleComponent(this);",
         "    }",
         "  }",
         "}");
@@ -1049,7 +1049,7 @@
         "  SomeInjectedType createAndInject();",
         "}");
     JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
-        "test.Dagger_SimpleComponent",
+        "test.DaggerSimpleComponent",
         "package test;",
         "",
         "import dagger.MembersInjector;",
@@ -1057,11 +1057,11 @@
         "import javax.inject.Provider;",
         "",
         "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class Dagger_SimpleComponent implements SimpleComponent {",
+        "public final class DaggerSimpleComponent implements SimpleComponent {",
         "  private MembersInjector<SomeInjectedType> someInjectedTypeMembersInjector;",
         "  private Provider<SomeInjectedType> someInjectedTypeProvider;",
         "",
-        "  private Dagger_SimpleComponent(Builder builder) {",
+        "  private DaggerSimpleComponent(Builder builder) {",
         "    assert builder != null;",
         "    initialize(builder);",
         "  }",
@@ -1091,7 +1091,7 @@
         "    }",
         "",
         "    public SimpleComponent build() {",
-        "      return new Dagger_SimpleComponent(this);",
+        "      return new DaggerSimpleComponent(this);",
         "    }",
         "  }",
         "}");
@@ -1126,7 +1126,7 @@
         "  SomeInjectableType someInjectableType();",
         "}");
     JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
-        "test.Dagger_SimpleComponent",
+        "test.DaggerSimpleComponent",
         "package test;",
         "",
         "import dagger.MembersInjector;",
@@ -1135,10 +1135,10 @@
         "import javax.inject.Provider;",
         "",
         "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class Dagger_SimpleComponent implements SimpleComponent {",
+        "public final class DaggerSimpleComponent implements SimpleComponent {",
         "  private Provider<SomeInjectableType> someInjectableTypeProvider;",
         "",
-        "  private Dagger_SimpleComponent(Builder builder) {",
+        "  private DaggerSimpleComponent(Builder builder) {",
         "    assert builder != null;",
         "    initialize(builder);",
         "  }",
@@ -1166,7 +1166,7 @@
         "    }",
         "",
         "    public SimpleComponent build() {",
-        "      return new Dagger_SimpleComponent(this);",
+        "      return new DaggerSimpleComponent(this);",
         "    }",
         "  }",
         "}");
@@ -1219,7 +1219,7 @@
         "  B b();",
         "}");
     JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
-        "test.Dagger_BComponent",
+        "test.DaggerBComponent",
         "package test;",
         "",
         "import dagger.internal.Factory;",
@@ -1227,11 +1227,11 @@
         "import javax.inject.Provider;",
         "",
         "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class Dagger_BComponent implements BComponent {",
+        "public final class DaggerBComponent implements BComponent {",
         "  private Provider<A> aProvider;",
         "  private Provider<B> bProvider;",
         "",
-        "  private Dagger_BComponent(Builder builder) {",
+        "  private DaggerBComponent(Builder builder) {",
         "    assert builder != null;",
         "    initialize(builder);",
         "  }",
@@ -1268,7 +1268,7 @@
         "      if (aComponent == null) {",
         "        throw new IllegalStateException(\"aComponent must be set\");",
         "      }",
-        "      return new Dagger_BComponent(this);",
+        "      return new DaggerBComponent(this);",
         "    }",
         "",
         "    public Builder aComponent(AComponent aComponent) {",
@@ -1331,7 +1331,7 @@
         "  other.test.A otherA();",
         "}");
     JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
-        "test.Dagger_TestComponent",
+        "test.DaggerTestComponent",
         "package test;",
         "",
         "import javax.annotation.Generated;",
@@ -1341,11 +1341,11 @@
         "import other.test.TestModule$$AFactory;",
         "",
         "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class Dagger_TestComponent implements TestComponent {",
+        "public final class DaggerTestComponent implements TestComponent {",
         "  private Provider<test.A> aProvider;",
         "  private Provider<A> aProvider1;",
         "",
-        "  private Dagger_TestComponent(Builder builder) {",
+        "  private DaggerTestComponent(Builder builder) {",
         "    assert builder != null;",
         "    initialize(builder);",
         "  }",
@@ -1387,7 +1387,7 @@
         "      if (testModule1 == null) {",
         "        this.testModule1 = new TestModule();",
         "      }",
-        "      return new Dagger_TestComponent(this);",
+        "      return new DaggerTestComponent(this);",
         "    }",
         "",
         "    public Builder testModule(test.TestModule testModule) {",
@@ -1462,19 +1462,19 @@
         "  X x();",
         "}");
     JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
-        "test.Dagger_TestComponent",
+        "test.DaggerTestComponent",
         "package test;",
         "",
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
         "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class Dagger_TestComponent implements TestComponent {",
+        "public final class DaggerTestComponent implements TestComponent {",
         "  private Provider<B> bProvider;",
         "  private Provider<A> aProvider;",
         "  private Provider<X> xProvider;",
         "",
-        "  private Dagger_TestComponent(Builder builder) {",
+        "  private DaggerTestComponent(Builder builder) {",
         "    assert builder != null;",
         "    initialize(builder);",
         "  }",
@@ -1513,7 +1513,7 @@
         "    }",
         "",
         "    public TestComponent build() {",
-        "      return new Dagger_TestComponent(this);",
+        "      return new DaggerTestComponent(this);",
         "    }",
         "  }",
         "}");
@@ -1569,14 +1569,14 @@
         "interface SimpleComponent extends SupertypeA, SupertypeB {",
         "}");
     JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
-        "test.Dagger_SimpleComponent",
+        "test.DaggerSimpleComponent",
         "package test;",
         "",
         "import javax.annotation.Generated;",
         "",
         "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class Dagger_SimpleComponent implements SimpleComponent {",
-        "  private Dagger_SimpleComponent(Builder builder) {",
+        "public final class DaggerSimpleComponent implements SimpleComponent {",
+        "  private DaggerSimpleComponent(Builder builder) {",
         "    assert builder != null;",
         "    initialize(builder);",
         "  }",
@@ -1601,7 +1601,7 @@
         "    }",
         "",
         "    public SimpleComponent build() {",
-        "      return new Dagger_SimpleComponent(this);",
+        "      return new DaggerSimpleComponent(this);",
         "    }",
         "  }",
         "}");
@@ -1657,14 +1657,14 @@
         "  SomeInjectableType someInjectableType();",
         "}");
     JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
-        "test.Dagger_SimpleComponent",
+        "test.DaggerSimpleComponent",
         "package test;",
         "",
         "import javax.annotation.Generated;",
         "",
         "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class Dagger_SimpleComponent implements SimpleComponent {",
-        "  private Dagger_SimpleComponent(Builder builder) {",
+        "public final class DaggerSimpleComponent implements SimpleComponent {",
+        "  private DaggerSimpleComponent(Builder builder) {",
         "    assert builder != null;",
         "    initialize(builder);",
         "  }",
@@ -1689,7 +1689,7 @@
         "    }",
         "",
         "    public SimpleComponent build() {",
-        "      return new Dagger_SimpleComponent(this);",
+        "      return new DaggerSimpleComponent(this);",
         "    }",
         "  }",
         "}");
@@ -1791,17 +1791,17 @@ public void genericTestToLetMeDebugInEclipse() {
          "  Provider<B<A>> d2();",
          "}");
      JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
-         "test.Dagger_SimpleComponent",
+         "test.DaggerSimpleComponent",
          "package test;",
          "",
          "import javax.annotation.Generated;",
          "import javax.inject.Provider;",
          "",
          "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-         "public final class Dagger_SimpleComponent implements SimpleComponent {",
+         "public final class DaggerSimpleComponent implements SimpleComponent {",
          "  private Provider<D> dProvider;",
          "",
-         "  private Dagger_SimpleComponent(Builder builder) {",
+         "  private DaggerSimpleComponent(Builder builder) {",
          "    assert builder != null;",
          "    initialize();",
          "  }",
@@ -1828,7 +1828,7 @@ public void genericTestToLetMeDebugInEclipse() {
          "    }",
          "",
          "    public SimpleComponent build() {",
-         "      return new Dagger_SimpleComponent(this);",
+         "      return new DaggerSimpleComponent(this);",
          "    }",
          "  }",
          "}");
diff --git a/compiler/src/test/java/dagger/internal/codegen/DependencyRequestMapperTest.java b/compiler/src/test/java/dagger/internal/codegen/DependencyRequestMapperTest.java
index 0232d1c38..76b28e461 100644
--- a/compiler/src/test/java/dagger/internal/codegen/DependencyRequestMapperTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/DependencyRequestMapperTest.java
@@ -128,7 +128,7 @@ private DependencyRequest dependencyRequestForProduced() {
         .isEqualTo(Producer.class);
   }
 
-  @Module(library = true)
+  @Module
   static final class ProvidesMethodModule {
     @Provides String provideString(
         Integer a, Lazy<Integer> b, Provider<Integer> c, MembersInjector<Integer> d) {
diff --git a/compiler/src/test/java/dagger/internal/codegen/KeyTest.java b/compiler/src/test/java/dagger/internal/codegen/KeyTest.java
index dde52f754..c1d622dfd 100644
--- a/compiler/src/test/java/dagger/internal/codegen/KeyTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/KeyTest.java
@@ -94,7 +94,7 @@
             MoreTypes.equivalence().wrap(stringType)));
   }
 
-  @Module(library = true)
+  @Module
   static final class ProvidesMethodModule {
     @Provides String provideString() {
       return null;
@@ -135,7 +135,7 @@
     assertThat(provisionKey).isEqualTo(injectionKey);
   }
 
-  @Module(library = true)
+  @Module
   static final class QualifiedProvidesMethodModule {
     @Provides
     @TestQualifier(@InnerAnnotation)
@@ -171,7 +171,7 @@ String provideQualifiedString() {
     }
   }
 
-  @Module(library = true)
+  @Module
   static final class SetProvidesMethodsModule {
     @Provides(type = SET) String provideString() {
       return null;
@@ -182,14 +182,14 @@ String provideQualifiedString() {
     }
   }
 
-  @Module(library = true)
+  @Module
   static final class PrimitiveTypes {
     @Provides int foo() {
       return 0;
     }
   }
 
-  @Module(library = true)
+  @Module
   static final class BoxedPrimitiveTypes {
     @Provides Integer foo() {
       return 0;
diff --git a/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java
index fccfb3334..7593af507 100644
--- a/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java
@@ -108,7 +108,7 @@ public void mapBindingsWithEnumKey() {
         "interface TestComponent {",
         "  Map<PathEnum, Provider<Handler>> dispatcher();",
         "}");
-    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines("test.Dagger_TestComponent",
+    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines("test.DaggerTestComponent",
         "package test;",
         "",
         "import dagger.internal.MapProviderFactory;",
@@ -117,13 +117,13 @@ public void mapBindingsWithEnumKey() {
         "import javax.inject.Provider;",
         "",
         "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class Dagger_TestComponent implements TestComponent {",
+        "public final class DaggerTestComponent implements TestComponent {",
         "  private Provider<Handler> mapOfPathEnumAndProviderOfHandlerContribution1;",
         "  private Provider<Handler> mapOfPathEnumAndProviderOfHandlerContribution2;",
         "  private Provider<Map<PathEnum, Provider<Handler>>>",
         "      mapOfPathEnumAndProviderOfHandlerProvider;",
         "",
-        "  private Dagger_TestComponent(Builder builder) {",
+        "  private DaggerTestComponent(Builder builder) {",
         "    assert builder != null;",
         "    initialize(builder);",
         "  }",
@@ -169,7 +169,7 @@ public void mapBindingsWithEnumKey() {
         "      if (mapModuleTwo == null) {",
         "        this.mapModuleTwo = new MapModuleTwo();",
         "      }",
-        "      return new Dagger_TestComponent(this);",
+        "      return new DaggerTestComponent(this);",
         "    }",
         "",
         "    public Builder mapModuleOne(MapModuleOne mapModuleOne) {",
@@ -276,7 +276,7 @@ public void mapBindingsWithStringKey() {
         "interface TestComponent {",
         "  Map<String, Provider<Handler>> dispatcher();",
         "}");
-    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines("test.Dagger_TestComponent",
+    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines("test.DaggerTestComponent",
         "package test;",
         "",
         "import dagger.internal.MapProviderFactory;",
@@ -285,13 +285,13 @@ public void mapBindingsWithStringKey() {
         "import javax.inject.Provider;",
         "",
         "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class Dagger_TestComponent implements TestComponent {",
+        "public final class DaggerTestComponent implements TestComponent {",
         "  private Provider<Handler> mapOfStringAndProviderOfHandlerContribution1;",
         "  private Provider<Handler> mapOfStringAndProviderOfHandlerContribution2;",
         "  private Provider<Map<String, Provider<Handler>>>",
         "      mapOfStringAndProviderOfHandlerProvider;",
         "",
-        "  private Dagger_TestComponent(Builder builder) {",
+        "  private DaggerTestComponent(Builder builder) {",
         "    assert builder != null;",
         "    initialize(builder);",
         "  }",
@@ -335,7 +335,7 @@ public void mapBindingsWithStringKey() {
         "      if (mapModuleTwo == null) {",
         "        this.mapModuleTwo = new MapModuleTwo();",
         "      }",
-        "      return new Dagger_TestComponent(this);",
+        "      return new DaggerTestComponent(this);",
         "    }",
         "",
         "    public Builder mapModuleOne(MapModuleOne mapModuleOne) {",
@@ -444,7 +444,7 @@ public void mapBindingsWithNonProviderValue() {
         "interface TestComponent {",
         "  Map<PathEnum, Handler> dispatcher();",
         "}");
-    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines("test.Dagger_TestComponent",
+    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines("test.DaggerTestComponent",
         "package test;",
         "",
         "import dagger.internal.MapFactory;",
@@ -454,14 +454,14 @@ public void mapBindingsWithNonProviderValue() {
         "import javax.inject.Provider;",
         "",
         "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class Dagger_TestComponent implements TestComponent {",
+        "public final class DaggerTestComponent implements TestComponent {",
         "  private Provider<Handler> mapOfPathEnumAndProviderOfHandlerContribution1;",
         "  private Provider<Handler> mapOfPathEnumAndProviderOfHandlerContribution2;",
         "  private Provider<Map<PathEnum, Provider<Handler>>>",
         "      mapOfPathEnumAndProviderOfHandlerProvider;",
         "  private Provider<Map<PathEnum, Handler>> mapOfPathEnumAndHandlerProvider;",
         "",
-        "  private Dagger_TestComponent(Builder builder) {",
+        "  private DaggerTestComponent(Builder builder) {",
         "    assert builder != null;",
         "    initialize(builder);",
         "  }",
@@ -509,7 +509,7 @@ public void mapBindingsWithNonProviderValue() {
         "      if (mapModuleTwo == null) {",
         "        this.mapModuleTwo = new MapModuleTwo();",
         "      }",
-        "      return new Dagger_TestComponent(this);",
+        "      return new DaggerTestComponent(this);",
         "    }",
         "",
         "    public Builder mapModuleOne(MapModuleOne mapModuleOne) {",
@@ -573,7 +573,7 @@ public void injectMapWithoutMapBinding() {
         "interface TestComponent {",
         "  Map<String, String> dispatcher();",
         "}");
-    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines("test.Dagger_TestComponent",
+    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines("test.DaggerTestComponent",
         "package test;",
         "",
         "import java.util.Map;",
@@ -581,10 +581,10 @@ public void injectMapWithoutMapBinding() {
         "import javax.inject.Provider;",
         "",
         "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class Dagger_TestComponent implements TestComponent {",
+        "public final class DaggerTestComponent implements TestComponent {",
         "  private Provider<Map<String, String>> provideAMapProvider;",
         "",
-        "  private Dagger_TestComponent(Builder builder) {",
+        "  private DaggerTestComponent(Builder builder) {",
         "    assert builder != null;",
         "    initialize(builder);",
         "  }",
@@ -616,7 +616,7 @@ public void injectMapWithoutMapBinding() {
         "      if (mapModule == null) {",
         "        this.mapModule = new MapModule();",
         "      }",
-        "      return new Dagger_TestComponent(this);",
+        "      return new DaggerTestComponent(this);",
         "    }",
         "",
         "    public Builder mapModule(MapModule mapModule) {",
diff --git a/compiler/src/test/java/dagger/internal/codegen/MapKeyProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/MapKeyProcessorTest.java
index 7f0178c85..1732b7d58 100644
--- a/compiler/src/test/java/dagger/internal/codegen/MapKeyProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/MapKeyProcessorTest.java
@@ -149,7 +149,7 @@ public void mapKeyComponentFileWithDisorderedKeyField() {
         "interface TestComponent {",
         "  Map<PathKey, Provider<Handler>> dispatcher();",
         "}");
-    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines("test.Dagger_TestComponent",
+    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines("test.DaggerTestComponent",
         "package test;",
         "",
         "import dagger.internal.MapProviderFactory;",
@@ -158,13 +158,13 @@ public void mapKeyComponentFileWithDisorderedKeyField() {
         "import javax.inject.Provider;",
         "",
         "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class Dagger_TestComponent implements TestComponent {",
+        "public final class DaggerTestComponent implements TestComponent {",
         "  private Provider<Handler> mapOfPathKeyAndProviderOfHandlerContribution1;",
         "  private Provider<Handler> mapOfPathKeyAndProviderOfHandlerContribution2;",
         "  private Provider<Map<PathKey, Provider<Handler>>>",
         "      mapOfPathKeyAndProviderOfHandlerProvider;",
         "",
-        "  private Dagger_TestComponent(Builder builder) {",
+        "  private DaggerTestComponent(Builder builder) {",
         "    assert builder != null;",
         "    initialize(builder);",
         "  }",
@@ -210,7 +210,7 @@ public void mapKeyComponentFileWithDisorderedKeyField() {
         "      if (mapModuleTwo == null) {",
         "        this.mapModuleTwo = new MapModuleTwo();",
         "      }",
-        "      return new Dagger_TestComponent(this);",
+        "      return new DaggerTestComponent(this);",
         "    }",
         "",
         "    public Builder mapModuleOne(MapModuleOne mapModuleOne) {",
@@ -323,7 +323,7 @@ public void mapKeyComponentFileWithDefaultField() {
         "interface TestComponent {",
         "  Map<PathKey, Provider<Handler>> dispatcher();",
         "}");
-    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines("test.Dagger_TestComponent",
+    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines("test.DaggerTestComponent",
         "package test;",
         "",
         "import dagger.internal.MapProviderFactory;",
@@ -332,13 +332,13 @@ public void mapKeyComponentFileWithDefaultField() {
         "import javax.inject.Provider;",
         "",
         "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class Dagger_TestComponent implements TestComponent {",
+        "public final class DaggerTestComponent implements TestComponent {",
         "  private Provider<Handler> mapOfPathKeyAndProviderOfHandlerContribution1;",
         "  private Provider<Handler> mapOfPathKeyAndProviderOfHandlerContribution2;",
         "  private Provider<Map<PathKey, Provider<Handler>>>",
         "      mapOfPathKeyAndProviderOfHandlerProvider;",
         "",
-        "  private Dagger_TestComponent(Builder builder) {",
+        "  private DaggerTestComponent(Builder builder) {",
         "    assert builder != null;",
         "    initialize(builder);",
         "  }",
@@ -384,7 +384,7 @@ public void mapKeyComponentFileWithDefaultField() {
         "      if (mapModuleTwo == null) {",
         "        this.mapModuleTwo = new MapModuleTwo();",
         "      }",
-        "      return new Dagger_TestComponent(this);",
+        "      return new DaggerTestComponent(this);",
         "    }",
         "",
         "    public Builder mapModuleOne(MapModuleOne mapModuleOne) {",
diff --git a/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java b/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java
index f02a9fc1f..0135e58e8 100644
--- a/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java
@@ -54,7 +54,7 @@ public void parentClass_noInjectedMembers() {
         "  Child child();",
         "}");
     JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
-        "test.Dagger_TestComponent",
+        "test.DaggerTestComponent",
         "package test;",
         "",
         "import dagger.MembersInjector;",
@@ -63,10 +63,10 @@ public void parentClass_noInjectedMembers() {
         "import javax.inject.Provider;",
         "",
         "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class Dagger_TestComponent implements TestComponent {",
+        "public final class DaggerTestComponent implements TestComponent {",
         "  private Provider<Child> childProvider;",
         "",
-        "  private Dagger_TestComponent(Builder builder) {",
+        "  private DaggerTestComponent(Builder builder) {",
         "    assert builder != null;",
         "    initialize(builder);",
         "  }",
@@ -94,7 +94,7 @@ public void parentClass_noInjectedMembers() {
         "    }",
         "",
         "    public TestComponent build() {",
-        "      return new Dagger_TestComponent(this);",
+        "      return new DaggerTestComponent(this);",
         "    }",
         "  }",
         "}");
@@ -142,7 +142,7 @@ public void parentClass_injectedMembersInSupertype() {
         "  Child child();",
         "}");
     JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
-        "test.Dagger_TestComponent",
+        "test.DaggerTestComponent",
         "package test;",
         "",
         "import dagger.MembersInjector;",
@@ -151,12 +151,12 @@ public void parentClass_injectedMembersInSupertype() {
         "import javax.inject.Provider;",
         "",
         "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class Dagger_TestComponent implements TestComponent {",
+        "public final class DaggerTestComponent implements TestComponent {",
         "  private MembersInjector<Parent> parentMembersInjector;",
         "  private MembersInjector<Child> childMembersInjector;",
         "  private Provider<Child> childProvider;",
         "",
-        "  private Dagger_TestComponent(Builder builder) {",
+        "  private DaggerTestComponent(Builder builder) {",
         "    assert builder != null;",
         "    initialize(builder);",
         "  }",
@@ -185,7 +185,7 @@ public void parentClass_injectedMembersInSupertype() {
         "    }",
         "",
         "    public TestComponent build() {",
-        "      return new Dagger_TestComponent(this);",
+        "      return new DaggerTestComponent(this);",
         "    }",
         "  }",
         "}");
diff --git a/compiler/src/test/java/dagger/internal/codegen/PackageProxyTest.java b/compiler/src/test/java/dagger/internal/codegen/PackageProxyTest.java
index a387f4221..956ff6cbe 100644
--- a/compiler/src/test/java/dagger/internal/codegen/PackageProxyTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/PackageProxyTest.java
@@ -59,10 +59,10 @@
         "  PublicClass publicClass();",
         "}");
     JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
-        "test.Dagger_TestComponent",
+        "test.DaggerTestComponent",
         "package test;",
         "",
-        "import foreign.Dagger_TestComponent__PackageProxy;",
+        "import foreign.DaggerTestComponent__PackageProxy;",
         "import foreign.NoDepClass$$Factory;",
         "import foreign.NonPublicClass1$$Factory;",
         "import foreign.NonPublicClass2$$Factory;",
@@ -72,12 +72,12 @@
         "import javax.inject.Provider;",
         "",
         "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class Dagger_TestComponent implements TestComponent {",
-        "  private final Dagger_TestComponent__PackageProxy foreign_Proxy =",
-        "      new Dagger_TestComponent__PackageProxy();",
+        "public final class DaggerTestComponent implements TestComponent {",
+        "  private final DaggerTestComponent__PackageProxy foreign_Proxy =",
+        "      new DaggerTestComponent__PackageProxy();",
         "  private Provider<PublicClass> publicClassProvider;",
         "",
-        "  private Dagger_TestComponent(Builder builder) {",
+        "  private DaggerTestComponent(Builder builder) {",
         "    assert builder != null;",
         "    initialize(builder);",
         "  }",
@@ -111,7 +111,7 @@
         "    }",
         "",
         "    public TestComponent build() {",
-        "      return new Dagger_TestComponent(this);",
+        "      return new DaggerTestComponent(this);",
         "    }",
         "  }",
         "}");
@@ -185,25 +185,25 @@
         "  void injectA(A a);",
         "}");
     JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
-        "test.Dagger_TestComponent",
+        "test.DaggerTestComponent",
         "package test;",
         "",
         "import dagger.MembersInjector;",
         "import foreign.B;",
         "import foreign.B$$MembersInjector;",
         "import foreign.C$$MembersInjector;",
-        "import foreign.Dagger_TestComponent__PackageProxy;",
+        "import foreign.DaggerTestComponent__PackageProxy;",
         "import javax.annotation.Generated;",
         "",
         "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class Dagger_TestComponent implements TestComponent {",
+        "public final class DaggerTestComponent implements TestComponent {",
         "  private MembersInjector<D> dMembersInjector;",
-        "  private final Dagger_TestComponent__PackageProxy foreign_Proxy =",
-        "      new Dagger_TestComponent__PackageProxy();",
+        "  private final DaggerTestComponent__PackageProxy foreign_Proxy =",
+        "      new DaggerTestComponent__PackageProxy();",
         "  private MembersInjector<B> bMembersInjector;",
         "  private MembersInjector<A> aMembersInjector;",
         "",
-        "  private Dagger_TestComponent(Builder builder) {",
+        "  private DaggerTestComponent(Builder builder) {",
         "    assert builder != null;",
         "    initialize(builder);",
         "  }",
@@ -236,7 +236,7 @@
         "    }",
         "",
         "    public TestComponent build() {",
-        "      return new Dagger_TestComponent(this);",
+        "      return new DaggerTestComponent(this);",
         "    }",
         "  }",
         "}");
diff --git a/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java
index 381251de3..d30800df4 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java
@@ -124,7 +124,7 @@
         "  }",
         "}");
     JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
-        "test.Dagger_TestClass_SimpleComponent",
+        "test.DaggerTestClass_SimpleComponent",
         "package test;",
         "",
         "import com.google.common.util.concurrent.ListenableFuture;",
@@ -140,11 +140,11 @@
         "import test.TestClass.SimpleComponent;",
         "",
         "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class Dagger_TestClass_SimpleComponent implements SimpleComponent {",
+        "public final class DaggerTestClass_SimpleComponent implements SimpleComponent {",
         "  private Provider<B> bProvider;",
         "  private Producer<A> aProducer;",
         "",
-        "  private Dagger_TestClass_SimpleComponent(Builder builder) {",
+        "  private DaggerTestClass_SimpleComponent(Builder builder) {",
         "    assert builder != null;",
         "    initialize(builder);",
         "  }",
@@ -183,7 +183,7 @@
         "      if (executor == null) {",
         "        throw new IllegalStateException(\"executor must be set\");",
         "      }",
-        "      return new Dagger_TestClass_SimpleComponent(this);",
+        "      return new DaggerTestClass_SimpleComponent(this);",
         "    }",
         "",
         "    public Builder aModule(AModule aModule) {",
diff --git a/compiler/src/test/java/dagger/internal/codegen/SubcomponentValidationTest.java b/compiler/src/test/java/dagger/internal/codegen/SubcomponentValidationTest.java
new file mode 100644
index 000000000..cf15210ee
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/SubcomponentValidationTest.java
@@ -0,0 +1,195 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.common.collect.ImmutableList;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assertAbout;
+import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+
+@RunWith(JUnit4.class)
+public final class SubcomponentValidationTest {
+  @Test public void factoryMethod_missingModulesWithParameters() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component",
+        "interface TestComponent {",
+        "  ChildComponent newChildComponent();",
+        "}");
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent(modules = ModuleWithParameters.class)",
+        "interface ChildComponent {}");
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.ModuleWithParameters",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "",
+        "@Module",
+        "final class ModuleWithParameters {",
+        "  ModuleWithParameters(Object whatever) {}",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(componentFile, childComponentFile, moduleFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            "test.ChildComponent requires modules which have no visible default constructors. "
+                + "Add the following modules as parameters to this method: "
+                + "test.ModuleWithParameters")
+        .in(componentFile).onLine(7);
+  }
+
+  @Test public void factoryMethod_nonModuleParameter() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component",
+        "interface TestComponent {",
+        "  ChildComponent newChildComponent(String someRandomString);",
+        "}");
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "interface ChildComponent {}");
+    assertAbout(javaSources()).that(ImmutableList.of(componentFile, childComponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            "Subcomponent factory methods may only accept modules, but java.lang.String is not.")
+        .in(componentFile).onLine(7).atColumn(43);
+  }
+
+  @Test public void factoryMethod_duplicateParameter() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "",
+        "@Module",
+        "final class TestModule {}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component",
+        "interface TestComponent {",
+        "  ChildComponent newChildComponent(TestModule testModule1, TestModule testModule2);",
+        "}");
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent(modules = TestModule.class)",
+        "interface ChildComponent {}");
+    assertAbout(javaSources()).that(ImmutableList.of(moduleFile, componentFile, childComponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            "A module may only occur once an an argument in a Subcomponent factory method, "
+                + "but test.TestModule was already passed.")
+        .in(componentFile).onLine(7).atColumn(71);
+  }
+
+  @Test public void factoryMethod_superflouousModule() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "",
+        "@Module",
+        "final class TestModule {}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component",
+        "interface TestComponent {",
+        "  ChildComponent newChildComponent(TestModule testModule);",
+        "}");
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "interface ChildComponent {}");
+    assertAbout(javaSources()).that(ImmutableList.of(moduleFile, componentFile, childComponentFile))
+    .processedWith(new ComponentProcessor())
+    .failsToCompile()
+    .withErrorContaining(
+        "test.TestModule is present as an argument to the test.ChildComponent factory method, but "
+            + "is not one of the modules used to implement the subcomponent.")
+                .in(componentFile).onLine(7);
+  }
+
+  @Test public void missingBinding() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "final class TestModule {",
+        "  @Provides String provideString(int i) {",
+        "    return Integer.toString(i);",
+        "  }",
+        "}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component",
+        "interface TestComponent {",
+        "  ChildComponent newChildComponent();",
+        "}");
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent(modules = TestModule.class)",
+        "interface ChildComponent {",
+        "  String getString();",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(moduleFile, componentFile, childComponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            "java.lang.Integer cannot be provided without an @Inject constructor or from an "
+                + "@Provides-annotated method");
+  }
+}
diff --git a/compiler/src/test/java/dagger/tests/integration/operation/PrimitiveInjectionTest.java b/compiler/src/test/java/dagger/tests/integration/operation/PrimitiveInjectionTest.java
index 4def47a1e..26c8e4e8c 100644
--- a/compiler/src/test/java/dagger/tests/integration/operation/PrimitiveInjectionTest.java
+++ b/compiler/src/test/java/dagger/tests/integration/operation/PrimitiveInjectionTest.java
@@ -68,18 +68,18 @@
       "}");
 
   JavaFileObject expectedComponent = JavaFileObjects.forSourceLines(
-      "test.Dagger_PrimitiveComponent",
+      "test.DaggerPrimitiveComponent",
       "package test;",
       "",
       "import javax.annotation.Generated;",
       "import javax.inject.Provider;",
       "",
       "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-      "public final class Dagger_PrimitiveComponent implements PrimitiveComponent {",
+      "public final class DaggerPrimitiveComponent implements PrimitiveComponent {",
       "  private Provider<Integer> primitiveIntProvider;",
       "  private Provider<PrimitiveInjectable> primitiveInjectableProvider;",
       "",
-      "  private Dagger_PrimitiveComponent(Builder builder) {",
+      "  private DaggerPrimitiveComponent(Builder builder) {",
       "    assert builder != null;",
       "    initialize(builder);",
       "  }",
@@ -119,7 +119,7 @@
       "      if (primitiveModule == null) {",
       "        this.primitiveModule = new PrimitiveModule();",
       "      }",
-      "      return new Dagger_PrimitiveComponent(this);",
+      "      return new DaggerPrimitiveComponent(this);",
       "    }",
       "",
       "    public Builder primitiveModule(PrimitiveModule primitiveModule) {",
diff --git a/core/src/main/java/dagger/Component.java b/core/src/main/java/dagger/Component.java
index eb0344749..69903b5b9 100644
--- a/core/src/main/java/dagger/Component.java
+++ b/core/src/main/java/dagger/Component.java
@@ -21,6 +21,7 @@
 import javax.inject.Inject;
 import javax.inject.Provider;
 import javax.inject.Qualifier;
+import javax.inject.Scope;
 
 import static java.lang.annotation.ElementType.TYPE;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
@@ -28,47 +29,192 @@
 /**
  * Annotates an interface or abstract class for which a fully-formed, dependency-injected
  * implementation is to be generated from a set of {@linkplain #modules}. The generated class will
- * have the name of the type annotated with {@code @Component} prepended with
- * {@code Dagger_}.  For example, {@code @Component interface MyComponent {...}} will
- * produce an implementation named {@code Dagger_MyComponent}.
+ * have the name of the type annotated with {@code @Component} prepended with {@code Dagger}. For
+ * example, {@code @Component interface MyComponent {...}} will produce an implementation named
+ * {@code DaggerMyComponent}.
  *
+ * <a name="component-methods">
  * <h2>Component methods</h2>
+ * </a>
  *
  * <p>Every type annotated with {@code @Component} must contain at least one abstract component
- * method. Component methods must either represent {@linkplain Provider provision} or
- * {@linkplain MembersInjector member injection}.
+ * method. Component methods may have any name, but must have signatures that conform to either
+ * {@linkplain Provider provision} or {@linkplain MembersInjector members-injection} contracts.
  *
- * Provision methods have no arguments and return an {@link Inject injected} or
- * {@link Provides provided} type.  Each may have a {@link Qualifier} annotation as well. The
+ * <a name="provision-methods">
+ * <h3>Provision methods</h3>
+ * </a>
+ *
+ * <p>Provision methods have no parameters and return an {@link Inject injected} or
+ * {@link Provides provided} type. Each method may have a {@link Qualifier} annotation as well. The
  * following are all valid provision method declarations: <pre><code>
  *   SomeType getSomeType();
  *   {@literal Set<SomeType>} getSomeTypes();
  *   {@literal @PortNumber} int getPortNumber();
  * </code></pre>
  *
- * Member injection methods take a single parameter and optionally return that same type. The
- * following are all valid member injection method declarations: <pre><code>
+ * <p>Provision methods, like typical {@link Inject injection} sites, may use {@link Provider} or
+ * {@link Lazy} to more explicitly control provision requests. A {@link Provider} allows the user
+ * of the component to request provision any number of times by calling {@link Provider#get}. A
+ * {@link Lazy} will only ever request a single provision, but will defer it until the first call to
+ * {@link Lazy#get}. The following provision methods all request provision of the same type, but
+ * each implies different semantics: <pre><code>
+ *   SomeType getSomeType();
+ *   {@literal Provider<SomeType>} getSomeTypeProvider();
+ *   {@literal Lazy<SomeType>} getLazySomeType();
+ * </code></pre>
+ *
+ * <a name="members-injection-methods">
+ * <h3>Members-injection methods</h3>
+ * </a>
+ *
+ * <p>Members-injection methods have a single parameter and inject dependencies into each of the
+ * {@link Inject}-annotated fields and methods of the passed instance. A members-injection method
+ * may be void or return its single parameter as a convenience for chaining. The following are all
+ * valid members-injection method declarations: <pre><code>
  *   void injectSomeType(SomeType someType);
  *   SomeType injectAndReturnSomeType(SomeType someType);
  * </code></pre>
  *
+ * <p>A method with no parameters that returns a {@link MembersInjector} is equivalent to a members
+ * injection method. Calling {@link MembersInjector#injectMembers} on the returned object will
+ * perform the same work as a members injection method. For example: <pre><code>
+ *   {@literal MembersInjector<SomeType>} getSomeTypeMembersInjector();
+ * </code></pre>
+ *
+ * <h4>A note about covariance</h4>
+ *
+ * <p>While a members-injection method for a type will accept instances of its subtypes, only
+ * {@link Inject}-annotated members of the parameter type and its supertypes will be injected;
+ * members of subtypes will not. For example, given the following types, only {@code a} and
+ * {@code b} will be injected into an instance of {@code Child} when it is passed to the
+ * members-injection method {@code injectSelf(Self instance)}: <pre><code>
+ *   class Parent {
+ *     @Inject A a;
+ *   }
+ *
+ *   class Self extends Parent {
+ *     @Inject B b;
+ *   }
+ *
+ *   class Child extends Self {
+ *     @Inject C c;
+ *   }
+ * </code></pre>
+ *
+ * <a name="instantiation">
+ * <h2>Instantiation</h2>
+ * </a>
+ *
+ * <p>Component implementations are primarily instantiated via a generated
+ * <a href="http://en.wikipedia.org/wiki/Builder_pattern">builder</a>. An instance of the builder
+ * is obtained using the {@code builder()} method on the component implementation. The returned
+ * builder has a method to set each of the {@linkplain #modules} and component
+ * {@linkplain #dependencies} named with the <a href="http://en.wikipedia.org/wiki/CamelCase">lower
+ * camel case</a> version of the module or dependency type. Each component dependency and module
+ * without a visible default constructor must be set explicitly, but any module with a default or
+ * no-args constructor accessible to the component implementation may be elided. This is an example
+ * usage of a component builder: <pre><code>
+ *   public static void main(String[] args) {
+ *     OtherComponent otherComponent = ...;
+ *     MyComponent component = DaggerMyComponent.builder()
+ *         // required because component dependencies must be set
+ *         .otherComponent(otherComponent)
+ *         // required because FlagsModule has constructor parameters
+ *         .flagsModule(new FlagsModule(args))
+ *         // may be elided because a no-args constructor is visible
+ *         .myApplicationModule(new MyApplicationModule())
+ *         .build();
+ *   }
+ * </code></pre>
+ *
+ * <p>In the case that a component has no component dependencies and only no-arg modules, the
+ * generated component will also have a factory method {@code create()}.
+ * {@code SomeComponent.create()} and {@code SomeComponent.builder().build()} are both valid and
+ * equivalent.
+ *
+ * <a name="scope">
+ * <h2>Scope</h2>
+ * </a>
+ *
+ * <p>Each Dagger component can be associated with a scope by annotating it with the
+ * {@linkplain Scope scope annotation}. The component implementation ensures that there is only one
+ * provision of each scoped binding per instance of the component. If the component declares a
+ * scope, it may only contain unscoped bindings or bindings of that scope anywhere in the graph. For
+ * example: <pre><code>
+ *   @Singleton @Component
+ *   interface MyApplicationComponent {
+ *     // this component can only inject types using unscoped or @Singleton bindings
+ *   }
+ * </code></pre>
+ *
+ * <p>In order to get the proper behavior associated with a scope annotation, it is the caller's
+ * responsibility to instaniate new component instances when appropriate. A {@link Singleton}
+ * component, for instance, should only be instantiated once per application, while a
+ * {@code RequestScoped} component should be instantiated once per request. Because components are
+ * self-contained implementations, exiting a scope is as simple as dropping all references to the
+ * component instance.
+ *
+ * <a name="component-relationships">
+ * <h2>Component relationships</h2>
+ * </a>
+ *
+ * <p>While there is much utility in isolated components with purely unscoped bindings, many
+ * applications will call for multiple components with multiple scopes to interact. Dagger provides
+ * two mechanisms for relating components.
+ *
+ * <a name="subcomponents">
+ * <h3>Subcomponents</h3>
+ * </a>
+ *
+ * <p>The simplest way to relate two components is by declaring a {@link Subcomponent}. A
+ * subcomponent behaves exactly like a component, but has its implementation generated within
+ * a parent component or subcomponent. That relationship allows the subcomponent implementation to
+ * inherit the <em>entire</em> binding graph from its parent when it is declared. For that reason,
+ * a subcomponent isn't evaluated for completeness until it is associated with a parent.
+ *
+ * <p>Subcomponents are delared via a factory method on a parent component or subcomponent. The
+ * method may have any name, but must return the subcomponent. The factory method's parameters may
+ * be any number of the subcomponents's modules, but must at least include those without visible
+ * no-arg constructors. The follwing is an example of a factory method that creates a request-scoped
+ * subcomponent from a singleton-scoped parent: <pre><code>
+ *   @Singleton @Component
+ *   interface ApplicationComponent {
+ *     // component methods...
+ *
+ *     RequestComponent newRequestComponent(RequestModule requestModule);
+ *   }
+ * </code></pre>
+ *
+ * <a name="component-dependencies">
+ * <h3>Component dependencies</h3>
+ * </a>
+ *
+ * <p>While subcomponents are the simplest way to compose subgraphs of bindings, subcomponents are
+ * tightly coupled with the parents; they may use any binding defined by their ancestor component
+ * and subcomponents. As an alternative, components can use bindings only from another
+ * <em>component interface</em> by declaring a {@linkplain #dependencies component dependency}. When
+ * a type is used as a component dependency, each <a href="#provision-methods">provision method</a>
+ * on the dependency is bound as a provider. Note that <em>only</em> the bindings exposed as
+ * provision methods are available through component dependencies.
+ *
  * @author Gregory Kick
  * @since 2.0
  */
-// TODO(gak): add missing spec for @Scope
-// TODO(gak): add missing spec for component dependencies
 @Retention(RUNTIME) // Allows runtimes to have specialized behavior interoperating with Dagger.
 @Target(TYPE)
 @Documented
 public @interface Component {
   /**
    * A list of classes annotated with {@link Module} whose bindings are used to generate the
-   * component implementation.
+   * component implementation. Note that through the use of {@link Module#includes} the full set of
+   * modules used to implement the component may include more modules that just those listed here.
    */
   Class<?>[] modules() default {};
 
   /**
-   * A list of types that are to be used as component dependencies.
+   * A list of types that are to be used as <a href="#component-dependencies">component
+   * dependencies</a>.
    */
   Class<?>[] dependencies() default {};
 }
diff --git a/core/src/main/java/dagger/MapKey.java b/core/src/main/java/dagger/MapKey.java
index ca88661c9..8699c42a0 100644
--- a/core/src/main/java/dagger/MapKey.java
+++ b/core/src/main/java/dagger/MapKey.java
@@ -15,6 +15,7 @@
  */
 package dagger;
 
+import dagger.internal.Beta;
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
@@ -47,6 +48,7 @@
 @Documented
 @Target(ANNOTATION_TYPE)
 @Retention(RUNTIME)
+@Beta
 public @interface MapKey {
   /**
    * if {@code unwrapValue} is false, then the whole annotation will be the type and annotation
@@ -54,5 +56,5 @@
    * annotation will be the key type for injected map and the value instances will be the keys.
    * Currently only support {@code unwrapValue} to be true.
    */
-  boolean unwrapValue();
+  boolean unwrapValue() default true;
 }
diff --git a/core/src/main/java/dagger/Module.java b/core/src/main/java/dagger/Module.java
index d566c5876..05f0f3a6a 100644
--- a/core/src/main/java/dagger/Module.java
+++ b/core/src/main/java/dagger/Module.java
@@ -26,73 +26,11 @@
 @Retention(RetentionPolicy.RUNTIME)
 @Target(ElementType.TYPE)
 public @interface Module {
-  /**
-   * Returns classes that object graphs created with this module must be able to
-   * inject. This includes both classes passed to {@link ObjectGraph#get} and
-   * the types of instances passed {@link ObjectGraph#inject}.
-   *
-   * <p>It is an error to call {@link ObjectGraph#get} or {@link
-   * ObjectGraph#inject} with a type that isn't listed in the {@code injects}
-   * set for any of the object graph's modules. Making such a call will trigger
-   * an {@code IllegalArgumentException} at runtime.
-   *
-   * <p>Maintaining this set is onerous, but doing so provides benefits to the
-   * application. This set enables dagger to perform more aggressive static
-   * analysis than would be otherwise possible:
-   * <ul>
-   *   <li><strong>Detect missing bindings.</strong> Dagger can check that all
-   *       injected dependencies can be satisfied. Set {@code complete=false} to
-   *       disable this check for the current module.
-   *   <li><strong>Detect unused bindings.</strong> Dagger can check that all
-   *       provides methods are used to satisfy injected dependencies. Set
-   *       {@code library=true} to disable this check for the current module.
-   * </ul>
-   */
-  Class<?>[] injects() default { };
-  Class<?>[] staticInjections() default { };
-
-  /**
-   * True if {@code @Provides} methods from this module are permitted to
-   * override those of other modules. This is a dangerous feature as it permits
-   * binding conflicts to go unnoticed. It should only be used in test and
-   * development modules.
-   */
-  boolean overrides() default false;
-
   /**
    * Additional {@code @Module}-annotated classes from which this module is
    * composed. The de-duplicated contributions of the modules in
    * {@code includes}, and of their inclusions recursively, are all contributed
    * to the object graph.
    */
-  Class<?>[] includes() default { };
-
-  /**
-   * An optional {@code @Module}-annotated class upon which this module can be
-   * {@link ObjectGraph#plus added} to form a complete graph.
-   */
-  Class<?> addsTo() default Void.class;
-
-  /**
-   * True if all of the bindings required by this module can also be satisfied
-   * by this module, its {@link #includes} and its {@link #addsTo}. If a module
-   * is complete it is eligible for additional static checking: tools can detect
-   * if required bindings are not available. Modules that have external
-   * dependencies must use {@code complete = false}.
-   */
-  boolean complete() default true;
-
-  /**
-   * False if all the included bindings in this module are necessary to satisfy
-   * all of its {@link #injects injectable types}. If a module is not a library
-   * module, it is eligible for additional static checking: tools can detect if
-   * included bindings are not necessary. If you provide bindings that are not
-   * used by this module's graph, then you must declare {@code library = true}.
-   *
-   * <p>This is intended to help you detect dead code.  As of 2.0 Dagger ignores
-   * this property and it is present for compatibility with Dagger 1.x during
-   * migrations.
-   */
-  // TODO(cgruber): Deprecate this property.
-  boolean library() default true;
+  Class<?>[] includes() default {};
 }
diff --git a/core/src/main/java/dagger/Provides.java b/core/src/main/java/dagger/Provides.java
index df4ad904d..b0524b4ef 100644
--- a/core/src/main/java/dagger/Provides.java
+++ b/core/src/main/java/dagger/Provides.java
@@ -16,6 +16,7 @@
  */
 package dagger;
 
+import dagger.internal.Beta;
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
@@ -61,6 +62,7 @@
      * is contributed to the map as a key/value pair. The {@code Map<K, Provider<V>>} produced from
      * the accumulation of values will be immutable.
      */
+    @Beta
     MAP;
   }
 
diff --git a/core/src/main/java/dagger/Subcomponent.java b/core/src/main/java/dagger/Subcomponent.java
index 1775050c5..1c8799515 100644
--- a/core/src/main/java/dagger/Subcomponent.java
+++ b/core/src/main/java/dagger/Subcomponent.java
@@ -21,24 +21,21 @@
 import static java.lang.annotation.ElementType.TYPE;
 
 /**
- * A component that inherits the bindings from a parent {@link Component} or {@link Subcomponent}.
- *
- * <p>Subcomponent implementations only exist in the context of a parent and are associated with
- * parents using factory methods on the component.  Simply add a method that returns the
- * subcomponent on the parent.
+ * A subcomponent that inherits the bindings from a parent {@link Component} or
+ * {@link Subcomponent}. The details of how to associate a subcomponent with a parent are described
+ * in the documentation for {@link Component}.
  *
  * @author Gregory Kick
  * @since 2.0
  */
-// TODO(gak): add missing spec for @Scope, validation, etc.
 @Target(TYPE)
 @Documented
 public @interface Subcomponent {
   /**
    * A list of classes annotated with {@link Module} whose bindings are used to generate the
-   * component implementation.
-   *
-   * <p>At the moment, only modules without arguments are supported.
+   * subcomponent implementation.  Note that through the use of {@link Module#includes} the full set
+   * of modules used to implement the subcomponent may include more modules that just those listed
+   * here.
    */
   Class<?>[] modules() default {};
 }
diff --git a/core/src/main/java/dagger/internal/Beta.java b/core/src/main/java/dagger/internal/Beta.java
new file mode 100644
index 000000000..a0a82c659
--- /dev/null
+++ b/core/src/main/java/dagger/internal/Beta.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+
+import static java.lang.annotation.RetentionPolicy.SOURCE;
+
+/**
+ * Signifies that a public API (public class, method or field) is subject to
+ * incompatible changes, or even removal, in a future release. An API bearing
+ * this annotation is exempt from any compatibility guarantees made by its
+ * containing library. Note that the presence of this annotation implies nothing
+ * about the quality or performance of the API in question, only the fact that
+ * it is not "API-frozen."
+ */
+@Documented
+@Retention(SOURCE)
+public @interface Beta {}
diff --git a/core/src/main/java/dagger/package-info.java b/core/src/main/java/dagger/package-info.java
new file mode 100644
index 000000000..e5cc67f39
--- /dev/null
+++ b/core/src/main/java/dagger/package-info.java
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * This package contains the public API for the <a href="http://google.github.io/dagger/">Dagger
+ * 2</a> dependency injection framework.  By building upon
+ * <a href="https://jcp.org/en/jsr/detail?id=330">JSR 330</a>, Dagger 2 provides an
+ * annotation-driven API for dependency injection whose implementation is entirely generated at
+ * compile time by <a href="http://en.wikipedia.org/wiki/Java_annotation#Processing">annotation
+ * processors</a>.
+ *
+ * <p>The entry point into the API is the {@link Component}, which annotates abstract types for
+ * Dagger 2 to implement.  The dependency graph is configured using using annotations such as
+ * {@link Module}, {@link Provides} and {@link javax.inject.Inject}.
+ *
+ * <p>{@code dagger.internal.codegen.ComponentProcessor} is the processor responsible for generating
+ * the implementation.  Dagger uses the annotation procesor
+ * {@linkplain java.util.ServiceLoader service loader} to automatically configure the processor, so
+ * explict build configuration shouldn't be necessary.
+ */
+package dagger;
diff --git a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/DemoApplication.java b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/DemoApplication.java
index 23ac08fd8..72057332c 100644
--- a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/DemoApplication.java
+++ b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/DemoApplication.java
@@ -28,7 +28,7 @@
 
   @Override public void onCreate() {
     super.onCreate();
-    applicationComponent = Dagger_ApplicationComponent.builder()
+    applicationComponent = DaggerApplicationComponent.builder()
         .demoApplicationModule(new DemoApplicationModule(this))
         .build();
   }
diff --git a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ui/HomeActivity.java b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ui/HomeActivity.java
index f0bd87815..1f3bb7002 100644
--- a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ui/HomeActivity.java
+++ b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ui/HomeActivity.java
@@ -28,7 +28,7 @@
 
   HomeComponent component() {
     if (component == null) {
-      component = Dagger_HomeComponent.builder()
+      component = DaggerHomeComponent.builder()
           .applicationComponent(((DemoApplication) getApplication()).component())
           .activityModule(new ActivityModule(this))
           .build();
diff --git a/examples/android-simple/src/main/java/com/example/dagger/simple/DemoApplication.java b/examples/android-simple/src/main/java/com/example/dagger/simple/DemoApplication.java
index 0a08d987b..55402c654 100644
--- a/examples/android-simple/src/main/java/com/example/dagger/simple/DemoApplication.java
+++ b/examples/android-simple/src/main/java/com/example/dagger/simple/DemoApplication.java
@@ -40,7 +40,7 @@
 
   @Override public void onCreate() {
     super.onCreate();
-    component = Dagger_DemoApplication_ApplicationComponent.builder()
+    component = DaggerDemoApplication_ApplicationComponent.builder()
         .androidModule(new AndroidModule(this))
         .build();
     component().inject(this); // As of now, LocationManager should be injected into this.
diff --git a/examples/simple/src/main/java/coffee/CoffeeApp.java b/examples/simple/src/main/java/coffee/CoffeeApp.java
index 0789a86f1..b0a93ec3c 100644
--- a/examples/simple/src/main/java/coffee/CoffeeApp.java
+++ b/examples/simple/src/main/java/coffee/CoffeeApp.java
@@ -11,7 +11,7 @@
   }
 
   public static void main(String[] args) {
-    Coffee coffee = Dagger_CoffeeApp_Coffee.builder().build();
+    Coffee coffee = DaggerCoffeeApp_Coffee.builder().build();
     coffee.maker().brew();
   }
 }
diff --git a/examples/simple/src/main/java/coffee/PumpModule.java b/examples/simple/src/main/java/coffee/PumpModule.java
index b064cea65..338ad33c2 100644
--- a/examples/simple/src/main/java/coffee/PumpModule.java
+++ b/examples/simple/src/main/java/coffee/PumpModule.java
@@ -3,7 +3,7 @@
 import dagger.Module;
 import dagger.Provides;
 
-@Module(complete = false, library = true)
+@Module
 class PumpModule {
   @Provides Pump providePump(Thermosiphon pump) {
     return pump;
diff --git a/pom.xml b/pom.xml
index df36e3670..e00847987 100644
--- a/pom.xml
+++ b/pom.xml
@@ -46,7 +46,7 @@
     <javax.inject.version>1</javax.inject.version>
     <javawriter.version>2.5.0</javawriter.version>
     <auto.common.version>1.0-SNAPSHOT</auto.common.version>
-    <auto.service.version>1.0-rc1</auto.service.version>
+    <auto.service.version>1.0-rc2</auto.service.version>
     <auto.value.version>1.0</auto.value.version>
     <guava.version>18.0</guava.version>
 
@@ -161,7 +161,6 @@
 
     <plugins>
       <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-compiler-plugin</artifactId>
         <configuration>
           <source>${java.version}</source>
@@ -173,7 +172,6 @@
       </plugin>
 
       <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-release-plugin</artifactId>
         <version>2.3.2</version><!--$NO-MVN-MAN-VER$-->
         <configuration>
@@ -189,7 +187,6 @@
       </plugin>
 
       <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-checkstyle-plugin</artifactId>
         <version>2.10</version>
         <configuration>
diff --git a/producers/src/main/java/dagger/producers/Produced.java b/producers/src/main/java/dagger/producers/Produced.java
index 137244bad..9019aa657 100644
--- a/producers/src/main/java/dagger/producers/Produced.java
+++ b/producers/src/main/java/dagger/producers/Produced.java
@@ -15,6 +15,7 @@
  */
 package dagger.producers;
 
+import dagger.internal.Beta;
 import java.util.concurrent.ExecutionException;
 
 /**
@@ -36,6 +37,7 @@
  *
  * @author Jesse Beder
  */
+@Beta
 public interface Produced<T> {
   /**
    * Returns the result of a production.
diff --git a/producers/src/main/java/dagger/producers/Producer.java b/producers/src/main/java/dagger/producers/Producer.java
index cccf78376..5aeb4a03d 100644
--- a/producers/src/main/java/dagger/producers/Producer.java
+++ b/producers/src/main/java/dagger/producers/Producer.java
@@ -15,6 +15,7 @@
  */
 package dagger.producers;
 
+import dagger.internal.Beta;
 import com.google.common.util.concurrent.ListenableFuture;
 
 /**
@@ -65,7 +66,7 @@
  * Suppose we instantiate the generated implementation of this component and call
  * {@code delayedC()}: <pre>   {@code
  *
- *   MyComponent component = Dagger_MyComponent
+ *   MyComponent component = DaggerMyComponent
  *       .builder()
  *       .executor(MoreExecutors.directExecutor())
  *       .build();
@@ -86,6 +87,7 @@
  *
  * @author Jesse Beder
  */
+@Beta
 public interface Producer<T> {
   /**
    * Returns a future representing a running task that produces a value. Calling this method will
diff --git a/producers/src/main/java/dagger/producers/ProducerModule.java b/producers/src/main/java/dagger/producers/ProducerModule.java
index f86cf12a3..714e3fa3e 100644
--- a/producers/src/main/java/dagger/producers/ProducerModule.java
+++ b/producers/src/main/java/dagger/producers/ProducerModule.java
@@ -16,6 +16,7 @@
 package dagger.producers;
 
 import dagger.Module;
+import dagger.internal.Beta;
 import java.lang.annotation.Documented;
 import java.lang.annotation.Target;
 
@@ -26,7 +27,9 @@
  *
  * @author Jesse Beder
  */
-@Documented @Target(TYPE)
+@Documented
+@Target(TYPE)
+@Beta
 public @interface ProducerModule {
   /**
    * Additional {@code @ProducerModule}- or {@link Module}-annotated classes from which this module
diff --git a/producers/src/main/java/dagger/producers/Produces.java b/producers/src/main/java/dagger/producers/Produces.java
index 6f77c3c2d..1b57bc39d 100644
--- a/producers/src/main/java/dagger/producers/Produces.java
+++ b/producers/src/main/java/dagger/producers/Produces.java
@@ -15,6 +15,7 @@
  */
 package dagger.producers;
 
+import dagger.internal.Beta;
 import com.google.common.util.concurrent.ListenableFuture;
 import java.lang.annotation.Documented;
 import java.lang.annotation.Target;
@@ -29,7 +30,9 @@
  *
  * @author Jesse Beder
  */
-@Documented @Target(METHOD)
+@Documented
+@Target(METHOD)
+@Beta
 public @interface Produces {
   /** The type of binding into which the return type of the annotated method contributes. */
   enum Type {
diff --git a/producers/src/main/java/dagger/producers/ProductionComponent.java b/producers/src/main/java/dagger/producers/ProductionComponent.java
index b6376b0b0..e4fe125ba 100644
--- a/producers/src/main/java/dagger/producers/ProductionComponent.java
+++ b/producers/src/main/java/dagger/producers/ProductionComponent.java
@@ -18,6 +18,7 @@
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.Module;
 import dagger.Provides;
+import dagger.internal.Beta;
 import java.lang.annotation.Documented;
 import java.lang.annotation.Target;
 import javax.inject.Inject;
@@ -29,8 +30,8 @@
  * Annotates an interface or abstract class for which a fully-formed, dependency-injected
  * implementation is to be generated from a set of {@linkplain #modules}. The generated class will
  * have the name of the type annotated with {@code @ProductionComponent} prepended with
- * {@code Dagger_}.  For example, {@code @ProductionComponent interface MyComponent {...}} will
- * produce an implementation named {@code Dagger_MyComponent}.
+ * {@code Dagger}.  For example, {@code @ProductionComponent interface MyComponent {...}} will
+ * produce an implementation named {@code DaggerMyComponent}.
  *
  * <p>Each {@link Produces} method that contributes to the component will be called at most once per
  * component instance, no matter how many times that binding is used as a dependency.
@@ -61,11 +62,13 @@
  * <p>If a non-execution exception is thrown (e.g., an {@code InterruptedException} or
  * {@code CancellationException}), then exception is handled as in
  * {@link com.google.common.util.concurrent.Futures#transform}.
- * TODO(user): Explain this more thoroughly, and possibly update the javadocs of those utilities.
+ * <!-- TODO(user): Explain this more thoroughly, and update the javadocs of those utilities. -->
  *
  * @author Jesse Beder
  */
-@Documented @Target(TYPE)
+@Documented
+@Target(TYPE)
+@Beta
 public @interface ProductionComponent {
   /**
    * A list of classes annotated with {@link Module} or {@link ProducerModule} whose bindings are
