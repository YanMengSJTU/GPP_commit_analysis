diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
index f1434e0df..a974d3c8a 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -183,6 +183,19 @@ ResolvedBindings previousResolvedBindings() {
       return Iterators.get(path.descendingIterator(), 1).resolvedBindings();
     }
 
+    /**
+     * Returns the contribution bindings resolved for the second-most-recent request in the given
+     * path; that is, returns those bindings that depend on the latest request in the path.
+     */
+    FluentIterable<ContributionBinding> contributionsDependingOnLatestRequest() {
+      if (size() <= 1) {
+        return FluentIterable.from(ImmutableList.<ContributionBinding>of());
+      }
+      return FluentIterable.from(previousResolvedBindings().bindings())
+          .filter(binding -> binding.implicitDependencies().contains(currentDependencyRequest()))
+          .filter(ContributionBinding.class);
+    }
+
     /**
      * {@code true} if there is a dependency cycle, which means that the
      * {@linkplain #currentDependencyRequest() current request}'s binding key occurs earlier in the
@@ -418,9 +431,10 @@ private void validateResolvedBindings(DependencyPath path) {
           }
           if (contributionBinding.bindingType().equals(PRODUCTION)
               && doesPathRequireProvisionOnly(path)) {
-            reportProviderMayNotDependOnProducer(path);
+            reportProviderMayNotDependOnProducer(path, contributionBinding);
             return;
           }
+          // TODO(dpb,beder): Validate this during @Inject/@Provides/@Produces validation.
           if (compilerOptions.usesProducers()) {
             Key productionImplementationExecutorKey =
                 keyFactory.forProductionImplementationExecutor();
@@ -553,12 +567,13 @@ private void validateNullability(DependencyPath path, Set<ContributionBinding> b
 
       for (ContributionBinding binding : bindings) {
         if (binding.nullableType().isPresent()) {
-          reportBuilder.addItem(
-              nullableToNonNullable(typeName, bindingDeclarationFormatter.format(binding))
-                  + "\n at: "
-                  + dependencyRequestFormatter.toDependencyTrace(path),
-              compilerOptions.nullableValidationKind(),
-              path.entryPointElement());
+          owningReportBuilder(path.contributionsDependingOnLatestRequest().append(binding))
+              .addItem(
+                  nullableToNonNullable(typeName, bindingDeclarationFormatter.format(binding))
+                      + "\n at: "
+                      + dependencyRequestFormatter.toDependencyTrace(path),
+                  compilerOptions.nullableValidationKind(),
+                  path.entryPointElement());
         }
       }
     }
@@ -605,6 +620,7 @@ private void validateMapKeyAnnotationTypes(
     }
 
     /** Reports errors if a members injection binding is invalid. */
+    // TODO(dpb): Can this be done while validating @Inject?
     private void validateMembersInjectionBinding(
         final MembersInjectionBinding binding, final DependencyPath path) {
       binding
@@ -967,24 +983,26 @@ void validateComponentScope() {
 
     @SuppressWarnings("resource") // Appendable is a StringBuilder.
     // TODO(b/29509141): Clarify the error.
-    private void reportProviderMayNotDependOnProducer(DependencyPath path) {
-      StringBuilder errorMessage = new StringBuilder();
+    private void reportProviderMayNotDependOnProducer(
+        DependencyPath path, ContributionBinding productionBinding) {
       if (path.size() == 1) {
-        new Formatter(errorMessage)
-            .format(
+        reportBuilder.addError(
+            String.format(
                 PROVIDER_ENTRY_POINT_MAY_NOT_DEPEND_ON_PRODUCER_FORMAT,
-                formatCurrentDependencyRequestKey(path));
+                formatCurrentDependencyRequestKey(path)),
+            path.entryPointElement());
       } else {
         FluentIterable<ContributionBinding> dependentProvisions =
             provisionsDependingOnLatestRequest(path);
         // TODO(beder): Consider displaying all dependent provisions in the error message. If we
         // do that, should we display all productions that depend on them also?
-        new Formatter(errorMessage)
-            .format(
-                PROVIDER_MAY_NOT_DEPEND_ON_PRODUCER_FORMAT,
-                dependentProvisions.iterator().next().key());
+        owningReportBuilder(dependentProvisions.append(productionBinding))
+            .addError(
+                String.format(
+                    PROVIDER_MAY_NOT_DEPEND_ON_PRODUCER_FORMAT,
+                    dependentProvisions.iterator().next().key()),
+                path.entryPointElement());
       }
-      reportBuilder.addError(errorMessage.toString(), path.entryPointElement());
     }
 
     /**
@@ -1033,7 +1051,7 @@ private void reportMissingBinding(DependencyPath path) {
               topLevelGraph(), path.currentDependencyRequest().bindingKey())) {
         errorMessage.append('\n').append(suggestion);
       }
-      reportBuilder.addError(errorMessage.toString(), path.entryPointElement());
+      topLevelReport().addError(errorMessage.toString(), path.entryPointElement());
     }
 
     @SuppressWarnings("resource") // Appendable is a StringBuilder.
@@ -1070,13 +1088,13 @@ private void reportDuplicateBindings(DependencyPath path) {
     }
 
     /**
-     * Returns the report builder for the rootmost component that contains any of the duplicate
-     * bindings.
+     * Returns the report builder for the rootmost component that contains any of the {@code
+     * bindings}.
      */
     private ValidationReport.Builder<TypeElement> owningReportBuilder(
-        Iterable<ContributionBinding> duplicateBindings) {
+        Iterable<ContributionBinding> bindings) {
       ImmutableSet.Builder<ComponentDescriptor> owningComponentsBuilder = ImmutableSet.builder();
-      for (ContributionBinding binding : duplicateBindings) {
+      for (ContributionBinding binding : bindings) {
         ResolvedBindings resolvedBindings =
             subject.resolvedBindings().get(BindingKey.contribution(binding.key()));
         owningComponentsBuilder.addAll(
@@ -1088,8 +1106,7 @@ private void reportDuplicateBindings(DependencyPath path) {
           return validation.reportBuilder;
         }
       }
-      throw new AssertionError(
-          "cannot find owning component for duplicate bindings: " + duplicateBindings);
+      throw new AssertionError("cannot find owning component for bindings: " + bindings);
     }
 
     /**
@@ -1128,7 +1145,8 @@ private void reportMultipleContributionTypes(DependencyPath path) {
             builder, declarationsByType.get(contributionType), 2, DUPLICATE_SIZE_LIMIT);
         builder.append('\n');
       }
-      reportBuilder.addError(builder.toString(), path.entryPointElement());
+      owningReportBuilder(resolvedBindings.contributionBindings())
+          .addError(builder.toString(), path.entryPointElement());
     }
 
     private void reportDuplicateMapKeys(
@@ -1136,7 +1154,7 @@ private void reportDuplicateMapKeys(
       StringBuilder builder = new StringBuilder();
       builder.append(duplicateMapKeysError(formatCurrentDependencyRequestKey(path)));
       bindingDeclarationFormatter.formatIndentedList(builder, mapBindings, 1, DUPLICATE_SIZE_LIMIT);
-      reportBuilder.addError(builder.toString(), path.entryPointElement());
+      owningReportBuilder(mapBindings).addError(builder.toString(), path.entryPointElement());
     }
 
     private void reportInconsistentMapKeyAnnotations(
@@ -1159,7 +1177,8 @@ private void reportInconsistentMapKeyAnnotations(
 
         bindingDeclarationFormatter.formatIndentedList(builder, bindings, 2, DUPLICATE_SIZE_LIMIT);
       }
-      reportBuilder.addError(builder.toString(), path.entryPointElement());
+      owningReportBuilder(mapBindingsByAnnotationType.values())
+          .addError(builder.toString(), path.entryPointElement());
     }
 
     private void reportCycle(DependencyPath path) {
@@ -1167,16 +1186,16 @@ private void reportCycle(DependencyPath path) {
         return;
       }
       // TODO(cgruber): Provide a hint for the start and end of the cycle.
-      TypeElement componentType =
-          MoreElements.asType(path.entryPointElement().getEnclosingElement());
-      reportBuilder.addItem(
-          String.format(
-              CONTAINS_DEPENDENCY_CYCLE_FORMAT,
-              componentType.getQualifiedName(),
-              path.entryPointElement().getSimpleName(),
-              dependencyRequestFormatter.toDependencyTrace(path)),
-          ERROR,
-          path.entryPointElement());
+      owningReportBuilder(
+              path.cycle()
+                  .transform(ResolvedRequest::resolvedBindings)
+                  .transformAndConcat(ResolvedBindings::contributionBindings))
+          .addItem(
+              String.format(
+                  CONTAINS_DEPENDENCY_CYCLE_FORMAT,
+                  dependencyRequestFormatter.toDependencyTrace(path)),
+              ERROR,
+              path.entryPointElement());
     }
 
     /**
@@ -1299,11 +1318,8 @@ private boolean doesPathRequireProvisionOnly(DependencyPath path) {
    * that is, returns those provision bindings that depend on the latest request in the path.
    */
   private FluentIterable<ContributionBinding> provisionsDependingOnLatestRequest(
-      final DependencyPath path) {
-    return FluentIterable.from(path.previousResolvedBindings().bindings())
-        .filter(PROVISION::isOfType)
-        .filter(binding -> binding.implicitDependencies().contains(path.currentDependencyRequest()))
-        .filter(ContributionBinding.class);
+      DependencyPath path) {
+    return path.contributionsDependingOnLatestRequest().filter(PROVISION::isOfType);
   }
 
   private String formatContributionType(ContributionType type) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
index bf709f292..efdf5f761 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
@@ -288,7 +288,7 @@ static String provisionMayNotDependOnProducerType(TypeMirror type) {
   static final String MEMBERS_INJECTION_WITH_UNBOUNDED_TYPE =
       "Type parameters must be bounded for members injection. %s required by %s, via:\n%s";
 
-  static final String CONTAINS_DEPENDENCY_CYCLE_FORMAT = "%s.%s() contains a dependency cycle:\n%s";
+  static final String CONTAINS_DEPENDENCY_CYCLE_FORMAT = "Found a dependency cycle:\n%s";
 
   static String nullableToNonNullable(String typeName, String bindingString) {
     return String.format(
diff --git a/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java b/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
index 69704da09..c5856ce8b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
@@ -55,18 +55,18 @@
   abstract ComponentDescriptor owningComponent();
 
   /**
-   * The contribution bindings for {@link #bindingKey()} that were resolved in
-   * {@link #owningComponent()} or its ancestor components, keyed by the component in which the
-   * binding was resolved. If {@link #bindingKey()}'s kind is not
-   * {@link BindingKey.Kind#CONTRIBUTION}, this is empty.
+   * The contribution bindings for {@link #bindingKey()} that were resolved in {@link
+   * #owningComponent()} or its ancestor components, indexed by the component in which the binding
+   * was resolved. If {@link #bindingKey()}'s kind is not {@link BindingKey.Kind#CONTRIBUTION}, this
+   * is empty.
    */
   abstract ImmutableSetMultimap<ComponentDescriptor, ContributionBinding> allContributionBindings();
 
   /**
-   * The members-injection bindings for {@link #bindingKey()} that were resolved in
-   * {@link #owningComponent()} or its ancestor components, keyed by the component in which the
-   * binding was resolved. If {@link #bindingKey()}'s kind is not
-   * {@link BindingKey.Kind#MEMBERS_INJECTION}, this is empty.
+   * The members-injection bindings for {@link #bindingKey()} that were resolved in {@link
+   * #owningComponent()} or its ancestor components, indexed by the component in which the binding
+   * was resolved. If {@link #bindingKey()}'s kind is not {@link BindingKey.Kind#MEMBERS_INJECTION},
+   * this is empty.
    */
   abstract ImmutableMap<ComponentDescriptor, MembersInjectionBinding> allMembersInjectionBindings();
 
@@ -94,20 +94,28 @@ public Key key() {
   abstract ImmutableSet<OptionalBindingDeclaration> optionalBindingDeclarations();
 
   /**
-   * All bindings for {@link #bindingKey()}, regardless of in which component they were resolved.
+   * All bindings for {@link #bindingKey()}, indexed by the component in which the binding was
+   * resolved.
    */
-  ImmutableSet<? extends Binding> bindings() {
+  ImmutableSetMultimap<ComponentDescriptor, ? extends Binding> allBindings() {
     switch (bindingKey().kind()) {
       case CONTRIBUTION:
-        return contributionBindings();
+        return allContributionBindings();
 
       case MEMBERS_INJECTION:
-        return ImmutableSet.copyOf(membersInjectionBinding().asSet());
+        return allMembersInjectionBindings().asMultimap();
 
       default:
         throw new AssertionError(bindingKey());
     }
   }
+  
+  /**
+   * All bindings for {@link #bindingKey()}, regardless of in which component they were resolved.
+   */
+  ImmutableSet<? extends Binding> bindings() {
+    return ImmutableSet.copyOf(allBindings().values());
+  }
 
   /**
    * Returns the single binding.
diff --git a/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java b/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
index 9f04042c3..d67855df5 100644
--- a/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
@@ -238,7 +238,7 @@ public void membersInjectDependsOnUnboundedType() {
     String expectedError =
         Joiner.on('\n')
             .join(
-                "test.Outer.CComponent.getC() contains a dependency cycle:",
+                "Found a dependency cycle:",
                 "      test.Outer.C is injected at",
                 "          test.Outer.A.<init>(cParam)",
                 "      test.Outer.A is injected at",
@@ -291,7 +291,7 @@ public void membersInjectDependsOnUnboundedType() {
     String expectedError =
         Joiner.on('\n')
             .join(
-                "test.Outer.DComponent.getD() contains a dependency cycle:",
+                "Found a dependency cycle:",
                 "      test.Outer.C is injected at",
                 "          test.Outer.A.<init>(cParam)",
                 "      test.Outer.A is injected at",
@@ -363,7 +363,7 @@ public void cyclicDependencyNotBrokenByMapBinding() {
     String expectedError =
         Joiner.on('\n')
             .join(
-                "test.Outer.CComponent.getC() contains a dependency cycle:",
+                "Found a dependency cycle:",
                 "      test.Outer.C is injected at",
                 "          test.Outer.CModule.c(c)",
                 "      java.util.Map<java.lang.String,test.Outer.C> is injected at",
@@ -428,7 +428,7 @@ public void cyclicDependencyWithSetBinding() {
     String expectedError =
         Joiner.on('\n')
             .join(
-                "test.Outer.CComponent.getC() contains a dependency cycle:",
+                "Found a dependency cycle:",
                 "      test.Outer.C is injected at",
                 "          test.Outer.CModule.c(c)",
                 "      java.util.Set<test.Outer.C> is injected at",
@@ -488,7 +488,7 @@ public void falsePositiveCyclicDependencyIndirectionDetected() {
     String expectedError =
         Joiner.on('\n')
             .join(
-                "test.Outer.DComponent.getD() contains a dependency cycle:",
+                "Found a dependency cycle:",
                 "      test.Outer.C is injected at",
                 "          test.Outer.A.<init>(cParam)",
                 "      test.Outer.A is injected at",
@@ -509,6 +509,90 @@ public void falsePositiveCyclicDependencyIndirectionDetected() {
         .onLine(28);
   }
 
+  @Test
+  public void cyclicDependencyInSubcomponents() {
+    JavaFileObject parent =
+        JavaFileObjects.forSourceLines(
+            "test.Parent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface Parent {",
+            "  Child child();",
+            "}");
+    JavaFileObject child =
+        JavaFileObjects.forSourceLines(
+            "test.Child",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = ChildModule.class)",
+            "interface Child {",
+            "  Grandchild grandchild();",
+            "}");
+    JavaFileObject grandchild =
+        JavaFileObjects.forSourceLines(
+            "test.Grandchild",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = GrandchildModule.class)",
+            "interface Grandchild {",
+            "  String entry();",
+            "}");
+    JavaFileObject childModule =
+        JavaFileObjects.forSourceLines(
+            "test.ChildModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "abstract class ChildModule {",
+            "  @Provides static Object object(String string) {",
+            "    return string;",
+            "  }",
+            "}");
+    JavaFileObject grandchildModule =
+        JavaFileObjects.forSourceLines(
+            "test.GrandchildModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "abstract class GrandchildModule {",
+            "  @Provides static String string(Object object) {",
+            "    return object.toString();",
+            "  }",
+            "}");
+
+    String expectedError =
+        Joiner.on('\n')
+            .join(
+                "[test.Grandchild.entry()] Found a dependency cycle:",
+                "      java.lang.String is injected at",
+                "          test.ChildModule.object(string)",
+                "      java.lang.Object is injected at",
+                "          test.GrandchildModule.string(object)",
+                "      java.lang.String is provided at",
+                "          test.Grandchild.entry()");
+
+    assertAbout(javaSources())
+        .that(ImmutableList.of(parent, child, grandchild, childModule, grandchildModule))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(expectedError)
+        .in(child)
+        .onLine(6);
+  }
+
   @Test
   public void circularBindsMethods() {
     JavaFileObject qualifier =
@@ -549,7 +633,7 @@ public void circularBindsMethods() {
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(
-            "test.TestComponent.unqualified() contains a dependency cycle:\n"
+            "Found a dependency cycle:\n"
                 + "      java.lang.Object is injected at\n"
                 + "          test.TestModule.bindQualified(unqualified)\n"
                 + "      @test.SomeQualifier java.lang.Object is injected at\n"
@@ -560,7 +644,7 @@ public void circularBindsMethods() {
         .onLine(7)
         .and()
         .withErrorContaining(
-            "test.TestComponent.qualified() contains a dependency cycle:\n"
+            "Found a dependency cycle:\n"
                 + "      @test.SomeQualifier java.lang.Object is injected at\n"
                 + "          test.TestModule.bindUnqualified(qualified)\n"
                 + "      java.lang.Object is injected at\n"
@@ -603,7 +687,7 @@ public void selfReferentialBinds() {
         .withErrorContaining(
             // TODO(gak): cl/126230644 produces a better error message in this case. Here it isn't
             // unclear what is going wrong.
-            "test.TestComponent.selfReferential() contains a dependency cycle:\n"
+            "Found a dependency cycle:\n"
                 + "      java.lang.Object is injected at\n"
                 + "          test.TestModule.bindToSelf(sameKey)\n"
                 + "      java.lang.Object is provided at\n"
diff --git a/compiler/src/test/java/dagger/internal/codegen/SubcomponentValidationTest.java b/compiler/src/test/java/dagger/internal/codegen/SubcomponentValidationTest.java
index c1ed888f4..fb3a38873 100644
--- a/compiler/src/test/java/dagger/internal/codegen/SubcomponentValidationTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/SubcomponentValidationTest.java
@@ -199,12 +199,16 @@
         "interface ChildComponent {",
         "  String getString();",
         "}");
-    assertAbout(javaSources()).that(ImmutableList.of(moduleFile, componentFile, childComponentFile))
+    assertAbout(javaSources())
+        .that(ImmutableList.of(moduleFile, componentFile, childComponentFile))
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(
-            "java.lang.Integer cannot be provided without an @Inject constructor or from an "
-                + "@Provides-annotated method");
+            "[test.ChildComponent.getString()] "
+                + "java.lang.Integer cannot be provided without an @Inject constructor or from an "
+                + "@Provides-annotated method")
+        .in(componentFile)
+        .onLine(6);
   }
 
   @Test public void subcomponentOnConcreteType() {
