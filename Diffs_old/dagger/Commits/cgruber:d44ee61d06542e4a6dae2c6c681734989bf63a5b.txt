diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/subcomponent/Subcomponents.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/subcomponent/Subcomponents.java
new file mode 100644
index 000000000..3ebd6078d
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/subcomponent/Subcomponents.java
@@ -0,0 +1,131 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package producerstest.subcomponent;
+
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.Component;
+import dagger.Module;
+import dagger.Provides;
+import dagger.producers.ProducerModule;
+import dagger.producers.Produces;
+import dagger.producers.ProductionComponent;
+import dagger.producers.ProductionSubcomponent;
+import java.util.concurrent.Executor;
+import javax.inject.Inject;
+import javax.inject.Provider;
+import javax.inject.Qualifier;
+
+final class Subcomponents {
+  @Qualifier
+  @interface FromParent {}
+
+  @Qualifier
+  @interface FromChild {}
+
+  @Qualifier
+  @interface FromGrandchild {}
+
+  @Module
+  static final class ParentModule {
+    @Provides
+    @FromParent
+    static String fromParent() {
+      return "parent";
+    }
+  }
+
+  @Component(modules = ParentModule.class)
+  interface ParentComponent {
+    InjectsChildBuilder injectsChildBuilder();
+
+    ChildComponent.Builder newChildComponentBuilder();
+  }
+
+  @ProducerModule
+  static final class ParentProducerModule {
+    @Produces
+    @FromParent
+    static String fromParent() {
+      return "parentproduction";
+    }
+  }
+
+  @ProductionComponent(modules = ParentProducerModule.class)
+  interface ParentProductionComponent {
+    ChildComponent.Builder newChildComponentBuilder();
+  }
+
+  @ProducerModule
+  static final class ChildProducerModule {
+    @Produces
+    @FromChild
+    static String fromChild(@FromParent String fromParent) {
+      return "child:" + fromParent;
+    }
+  }
+
+  @ProductionSubcomponent(modules = ChildProducerModule.class)
+  interface ChildComponent {
+    @FromChild
+    ListenableFuture<String> fromChild();
+
+    GrandchildComponent.Builder newGrandchildComponentBuilder();
+
+    @ProductionSubcomponent.Builder
+    interface Builder {
+      Builder executor(Executor executor);
+
+      ChildComponent build();
+    }
+  }
+
+  static final class InjectsChildBuilder {
+    private final Provider<ChildComponent.Builder> childBuilder;
+
+    @Inject
+    InjectsChildBuilder(Provider<ChildComponent.Builder> childBuilder) {
+      this.childBuilder = childBuilder;
+    }
+
+    ChildComponent.Builder childBuilder() {
+      return childBuilder.get();
+    }
+  }
+
+  @ProducerModule
+  static final class GrandchildProducerModule {
+    @Produces
+    @FromGrandchild
+    static String fromGranchild(@FromChild String fromChild) {
+      return "grandchild:" + fromChild;
+    }
+  }
+
+  @ProductionSubcomponent(modules = GrandchildProducerModule.class)
+  interface GrandchildComponent {
+    @FromGrandchild
+    ListenableFuture<String> fromGrandchild();
+
+    @ProductionSubcomponent.Builder
+    interface Builder {
+      Builder executor(Executor executor);
+
+      GrandchildComponent build();
+    }
+  }
+
+  private Subcomponents() {}
+}
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/subcomponent/SubcomponentTest.java b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/subcomponent/SubcomponentTest.java
new file mode 100644
index 000000000..ef15bdd23
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/subcomponent/SubcomponentTest.java
@@ -0,0 +1,77 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package producerstest.subcomponent;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import com.google.common.util.concurrent.MoreExecutors;
+import java.util.concurrent.Executor;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import producerstest.subcomponent.Subcomponents.ChildComponent;
+import producerstest.subcomponent.Subcomponents.GrandchildComponent;
+import producerstest.subcomponent.Subcomponents.ParentComponent;
+import producerstest.subcomponent.Subcomponents.ParentProductionComponent;
+
+@RunWith(JUnit4.class)
+public final class SubcomponentTest {
+  @Test
+  public void topLevelComponent_child() throws Exception {
+    Executor executor = MoreExecutors.directExecutor();
+    ParentComponent parent = DaggerSubcomponents_ParentComponent.create();
+    ChildComponent child = parent.newChildComponentBuilder().executor(executor).build();
+    assertThat(child.fromChild().get()).isEqualTo("child:parent");
+  }
+
+  @Test
+  public void topLevelComponent_injectsChildBuilder() throws Exception {
+    Executor executor = MoreExecutors.directExecutor();
+    ParentComponent parent = DaggerSubcomponents_ParentComponent.create();
+    ChildComponent child = parent.injectsChildBuilder().childBuilder().executor(executor).build();
+    assertThat(child.fromChild().get()).isEqualTo("child:parent");
+  }
+
+  @Test
+  public void topLevelComponent_grandchild() throws Exception {
+    Executor executor = MoreExecutors.directExecutor();
+    ParentComponent parent = DaggerSubcomponents_ParentComponent.create();
+    ChildComponent child = parent.newChildComponentBuilder().executor(executor).build();
+    GrandchildComponent grandchild =
+        child.newGrandchildComponentBuilder().executor(executor).build();
+    assertThat(grandchild.fromGrandchild().get()).isEqualTo("grandchild:child:parent");
+  }
+
+  @Test
+  public void topLevelProductionComponent_child() throws Exception {
+    Executor executor = MoreExecutors.directExecutor();
+    ParentProductionComponent parent =
+        DaggerSubcomponents_ParentProductionComponent.builder().executor(executor).build();
+    ChildComponent child = parent.newChildComponentBuilder().executor(executor).build();
+    assertThat(child.fromChild().get()).isEqualTo("child:parentproduction");
+  }
+
+  @Test
+  public void topLevelProductionComponent_grandchild() throws Exception {
+    Executor executor = MoreExecutors.directExecutor();
+    ParentProductionComponent parent =
+        DaggerSubcomponents_ParentProductionComponent.builder().executor(executor).build();
+    ChildComponent child = parent.newChildComponentBuilder().executor(executor).build();
+    GrandchildComponent grandchild =
+        child.newGrandchildComponentBuilder().executor(executor).build();
+    assertThat(grandchild.fromGrandchild().get()).isEqualTo("grandchild:child:parentproduction");
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
index 02b2d2c34..f7ed3ac77 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
@@ -61,6 +61,7 @@
 import static dagger.internal.codegen.ComponentDescriptor.isComponentContributionMethod;
 import static dagger.internal.codegen.ComponentDescriptor.isComponentProductionMethod;
 import static dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor.isOfKind;
+import static dagger.internal.codegen.ComponentDescriptor.ComponentMethodKind.PRODUCTION_SUBCOMPONENT_BUILDER;
 import static dagger.internal.codegen.ComponentDescriptor.ComponentMethodKind.SUBCOMPONENT_BUILDER;
 import static dagger.internal.codegen.ComponentDescriptor.Kind.PRODUCTION_COMPONENT;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
@@ -220,7 +221,8 @@ private BindingGraph create(
       // Bindings for subcomponent builders.
       for (ComponentMethodDescriptor subcomponentMethodDescriptor :
           Iterables.filter(
-              componentDescriptor.subcomponents().keySet(), isOfKind(SUBCOMPONENT_BUILDER))) {
+              componentDescriptor.subcomponents().keySet(),
+              isOfKind(SUBCOMPONENT_BUILDER, PRODUCTION_SUBCOMPONENT_BUILDER))) {
         explicitBindingsBuilder.add(
             provisionBindingFactory.forSubcomponentBuilderMethod(
                 subcomponentMethodDescriptor.methodElement(),
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
index f467069e8..413896c38 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -80,6 +80,7 @@
 import static com.google.common.collect.Iterables.skip;
 import static com.google.common.collect.Maps.filterKeys;
 import static dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor.isOfKind;
+import static dagger.internal.codegen.ComponentDescriptor.ComponentMethodKind.PRODUCTION_SUBCOMPONENT;
 import static dagger.internal.codegen.ComponentDescriptor.ComponentMethodKind.SUBCOMPONENT;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
 import static dagger.internal.codegen.ContributionBinding.indexMapBindingsByAnnotationType;
@@ -174,7 +175,9 @@ void validateSubgraph() {
       }
       
       for (Map.Entry<ComponentMethodDescriptor, ComponentDescriptor> entry :
-          filterKeys(subject.componentDescriptor().subcomponents(), isOfKind(SUBCOMPONENT))
+          filterKeys(
+                  subject.componentDescriptor().subcomponents(),
+                  isOfKind(SUBCOMPONENT, PRODUCTION_SUBCOMPONENT))
               .entrySet()) {
         validateSubcomponentFactoryMethod(
             entry.getKey().methodElement(), entry.getValue().componentDefinitionType());
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
index 608a8dd56..000abf14e 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
@@ -33,6 +33,7 @@
 import dagger.Module;
 import dagger.Subcomponent;
 import dagger.producers.ProductionComponent;
+import dagger.producers.ProductionSubcomponent;
 import java.lang.annotation.Annotation;
 import java.util.EnumSet;
 import java.util.LinkedHashSet;
@@ -59,7 +60,6 @@
 import static dagger.internal.codegen.ConfigurationAnnotations.enclosedBuilders;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentModules;
-import static dagger.internal.codegen.ConfigurationAnnotations.isComponent;
 import static javax.lang.model.type.TypeKind.DECLARED;
 import static javax.lang.model.type.TypeKind.VOID;
 
@@ -76,7 +76,9 @@
   enum Kind {
     COMPONENT(Component.class, Component.Builder.class, true),
     SUBCOMPONENT(Subcomponent.class, Subcomponent.Builder.class, false),
-    PRODUCTION_COMPONENT(ProductionComponent.class, ProductionComponent.Builder.class, true);
+    PRODUCTION_COMPONENT(ProductionComponent.class, ProductionComponent.Builder.class, true),
+    PRODUCTION_SUBCOMPONENT(
+        ProductionSubcomponent.class, ProductionSubcomponent.Builder.class, false);
 
     private final Class<? extends Annotation> annotationType;
     private final Class<? extends Annotation> builderType;
@@ -143,6 +145,7 @@
         case SUBCOMPONENT:
           return Sets.immutableEnumSet(ModuleDescriptor.Kind.MODULE);
         case PRODUCTION_COMPONENT:
+        case PRODUCTION_SUBCOMPONENT:
           return Sets.immutableEnumSet(
               ModuleDescriptor.Kind.MODULE, ModuleDescriptor.Kind.PRODUCER_MODULE);
         default:
@@ -154,9 +157,10 @@
       switch (this) {
         case COMPONENT:
         case SUBCOMPONENT:
-          return ImmutableSet.of(SUBCOMPONENT);
+          return ImmutableSet.of(SUBCOMPONENT, PRODUCTION_SUBCOMPONENT);
         case PRODUCTION_COMPONENT:
-          return ImmutableSet.of();
+        case PRODUCTION_SUBCOMPONENT:
+          return ImmutableSet.of(PRODUCTION_SUBCOMPONENT);
         default:
           throw new AssertionError();
       }
@@ -274,28 +278,72 @@ boolean isTopLevel() {
     abstract ComponentMethodKind kind();
     abstract Optional<DependencyRequest> dependencyRequest();
     abstract ExecutableElement methodElement();
-    
+
     /**
-     * A predicate that passes for {@link ComponentMethodDescriptor}s of a given kind.
+     * A predicate that passes for {@link ComponentMethodDescriptor}s of one of the given kinds.
      */
-    static Predicate<ComponentMethodDescriptor> isOfKind(final ComponentMethodKind kind) {
+    static Predicate<ComponentMethodDescriptor> isOfKind(ComponentMethodKind... kinds) {
+      final ImmutableSet<ComponentMethodKind> kindSet = ImmutableSet.copyOf(kinds);
       return new Predicate<ComponentMethodDescriptor>() {
         @Override
         public boolean apply(ComponentMethodDescriptor descriptor) {
-          return kind.equals(descriptor.kind());
+          return kindSet.contains(descriptor.kind());
         }
       };
     }
+
+    static ComponentMethodDescriptor create(
+        ComponentMethodKind kind,
+        Optional<DependencyRequest> dependencyRequest,
+        ExecutableElement methodElement) {
+      return new AutoValue_ComponentDescriptor_ComponentMethodDescriptor(
+          kind, dependencyRequest, methodElement);
+    }
+
+    static ComponentMethodDescriptor forProvision(
+        ExecutableElement methodElement, DependencyRequest dependencyRequest) {
+      return create(ComponentMethodKind.PROVISION, Optional.of(dependencyRequest), methodElement);
+    }
+
+    static ComponentMethodDescriptor forMembersInjection(
+        ExecutableElement methodElement, DependencyRequest dependencyRequest) {
+      return create(
+          ComponentMethodKind.MEMBERS_INJECTION, Optional.of(dependencyRequest), methodElement);
+    }
+
+    static ComponentMethodDescriptor forSubcomponent(
+        ComponentMethodKind kind, ExecutableElement methodElement) {
+      return create(kind, Optional.<DependencyRequest>absent(), methodElement);
+    }
   }
 
   enum ComponentMethodKind {
-    PROVISON,
+    PROVISION,
     PRODUCTION,
     MEMBERS_INJECTION,
     SUBCOMPONENT,
     SUBCOMPONENT_BUILDER,
+    PRODUCTION_SUBCOMPONENT,
+    PRODUCTION_SUBCOMPONENT_BUILDER;
+
+    /**
+     * Returns the component kind associated with this component method, if it exists. Otherwise,
+     * throws.
+     */
+    Kind componentKind() {
+      switch (this) {
+        case SUBCOMPONENT:
+        case SUBCOMPONENT_BUILDER:
+          return Kind.SUBCOMPONENT;
+        case PRODUCTION_SUBCOMPONENT:
+        case PRODUCTION_SUBCOMPONENT_BUILDER:
+          return Kind.PRODUCTION_SUBCOMPONENT;
+        default:
+          throw new IllegalStateException("no component associated with method " + this);
+      }
+    }
   }
-  
+
   @AutoValue
   static abstract class BuilderSpec {
     abstract TypeElement builderDefinitionType();
@@ -331,17 +379,16 @@ ComponentDescriptor forComponent(TypeElement componentDefinitionType) {
           kind.isPresent() && kind.get().isTopLevel(),
           "%s must be annotated with @Component or @ProductionComponent",
           componentDefinitionType);
-      return create(componentDefinitionType, kind.get());
+      return create(componentDefinitionType, kind.get(), Optional.<Kind>absent());
     }
 
-    private ComponentDescriptor create(TypeElement componentDefinitionType, Kind kind) {
+    private ComponentDescriptor create(
+        TypeElement componentDefinitionType, Kind kind, Optional<Kind> parentKind) {
       DeclaredType declaredComponentType = MoreTypes.asDeclared(componentDefinitionType.asType());
       AnnotationMirror componentMirror =
-          getAnnotationMirror(componentDefinitionType, kind.annotationType())
-              .or(getAnnotationMirror(componentDefinitionType, Subcomponent.class))
-              .get();
+          getAnnotationMirror(componentDefinitionType, kind.annotationType()).get();
       ImmutableSet<TypeElement> componentDependencyTypes =
-          isComponent(componentDefinitionType)
+          kind.isTopLevel()
               ? MoreTypes.asTypeElements(getComponentDependencies(componentMirror))
               : ImmutableSet.<TypeElement>of();
 
@@ -359,7 +406,7 @@ private ComponentDescriptor create(TypeElement componentDefinitionType, Kind kin
       }
 
       Optional<TypeElement> executorDependency =
-          kind.equals(Kind.PRODUCTION_COMPONENT)
+          kind.equals(Kind.PRODUCTION_COMPONENT) || kind.equals(Kind.PRODUCTION_SUBCOMPONENT)
               ? Optional.of(elements.getTypeElement(Executor.class.getCanonicalName()))
               : Optional.<TypeElement>absent();
 
@@ -367,7 +414,11 @@ private ComponentDescriptor create(TypeElement componentDefinitionType, Kind kin
       for (TypeMirror moduleIncludesType : getComponentModules(componentMirror)) {
         modules.add(moduleDescriptorFactory.create(MoreTypes.asTypeElement(moduleIncludesType)));
       }
-      if (kind.equals(Kind.PRODUCTION_COMPONENT)) {
+      if (kind.equals(Kind.PRODUCTION_COMPONENT)
+          || (kind.equals(Kind.PRODUCTION_SUBCOMPONENT)
+              && parentKind.isPresent()
+              && (parentKind.get().equals(Kind.COMPONENT)
+                  || parentKind.get().equals(Kind.SUBCOMPONENT)))) {
         modules.add(descriptorForMonitoringModule(componentDefinitionType));
       }
 
@@ -387,19 +438,23 @@ private ComponentDescriptor create(TypeElement componentDefinitionType, Kind kin
         componentMethodsBuilder.add(componentMethodDescriptor);
         switch (componentMethodDescriptor.kind()) {
           case SUBCOMPONENT:
+          case PRODUCTION_SUBCOMPONENT:
             subcomponentDescriptors.put(
                 componentMethodDescriptor,
                 create(
                     MoreElements.asType(MoreTypes.asElement(resolvedMethod.getReturnType())),
-                    Kind.SUBCOMPONENT));
+                    componentMethodDescriptor.kind().componentKind(),
+                    Optional.of(kind)));
             break;
           case SUBCOMPONENT_BUILDER:
+          case PRODUCTION_SUBCOMPONENT_BUILDER:
             subcomponentDescriptors.put(
                 componentMethodDescriptor,
                 create(
                     MoreElements.asType(
                         MoreTypes.asElement(resolvedMethod.getReturnType()).getEnclosingElement()),
-                    Kind.SUBCOMPONENT));
+                    componentMethodDescriptor.kind().componentKind(),
+                    Optional.of(kind)));
             break;
           default: // nothing special to do for other methods.
         }
@@ -427,38 +482,39 @@ private ComponentDescriptor create(TypeElement componentDefinitionType, Kind kin
           createBuilderSpec(builderType));
     }
 
-    private ComponentMethodDescriptor getDescriptorForComponentMethod(TypeElement componentElement,
-        Kind componentKind,
-        ExecutableElement componentMethod) {
-      ExecutableType resolvedComponentMethod = MoreTypes.asExecutable(types.asMemberOf(
-          MoreTypes.asDeclared(componentElement.asType()), componentMethod));
+    private ComponentMethodDescriptor getDescriptorForComponentMethod(
+        TypeElement componentElement, Kind componentKind, ExecutableElement componentMethod) {
+      ExecutableType resolvedComponentMethod =
+          MoreTypes.asExecutable(
+              types.asMemberOf(MoreTypes.asDeclared(componentElement.asType()), componentMethod));
       TypeMirror returnType = resolvedComponentMethod.getReturnType();
       if (returnType.getKind().equals(DECLARED)) {
         if (MoreTypes.isTypeOf(Provider.class, returnType)
             || MoreTypes.isTypeOf(Lazy.class, returnType)) {
-          return new AutoValue_ComponentDescriptor_ComponentMethodDescriptor(
-              ComponentMethodKind.PROVISON,
-              Optional.of(dependencyRequestFactory.forComponentProvisionMethod(componentMethod,
-                  resolvedComponentMethod)),
-              componentMethod);
+          return ComponentMethodDescriptor.forProvision(
+              componentMethod,
+              dependencyRequestFactory.forComponentProvisionMethod(
+                  componentMethod, resolvedComponentMethod));
         } else if (MoreTypes.isTypeOf(MembersInjector.class, returnType)) {
-          return new AutoValue_ComponentDescriptor_ComponentMethodDescriptor(
-              ComponentMethodKind.MEMBERS_INJECTION,
-              Optional.of(dependencyRequestFactory.forComponentMembersInjectionMethod(
-                  componentMethod,
-                  resolvedComponentMethod)),
-              componentMethod);
+          return ComponentMethodDescriptor.forMembersInjection(
+              componentMethod,
+              dependencyRequestFactory.forComponentMembersInjectionMethod(
+                  componentMethod, resolvedComponentMethod));
         } else if (isAnnotationPresent(MoreTypes.asElement(returnType), Subcomponent.class)) {
-          return new AutoValue_ComponentDescriptor_ComponentMethodDescriptor(
-              ComponentMethodKind.SUBCOMPONENT,
-              Optional.<DependencyRequest>absent(),
-              componentMethod);
-        } else if (isAnnotationPresent(MoreTypes.asElement(returnType),
-            Subcomponent.Builder.class)) {
-          return new AutoValue_ComponentDescriptor_ComponentMethodDescriptor(
-              ComponentMethodKind.SUBCOMPONENT_BUILDER,
-              Optional.<DependencyRequest>absent(),
-              componentMethod);
+          return ComponentMethodDescriptor.forSubcomponent(
+              ComponentMethodKind.SUBCOMPONENT, componentMethod);
+        } else if (isAnnotationPresent(
+            MoreTypes.asElement(returnType), ProductionSubcomponent.class)) {
+          return ComponentMethodDescriptor.forSubcomponent(
+              ComponentMethodKind.PRODUCTION_SUBCOMPONENT, componentMethod);
+        } else if (isAnnotationPresent(
+            MoreTypes.asElement(returnType), Subcomponent.Builder.class)) {
+          return ComponentMethodDescriptor.forSubcomponent(
+              ComponentMethodKind.SUBCOMPONENT_BUILDER, componentMethod);
+        } else if (isAnnotationPresent(
+            MoreTypes.asElement(returnType), ProductionSubcomponent.Builder.class)) {
+          return ComponentMethodDescriptor.forSubcomponent(
+              ComponentMethodKind.PRODUCTION_SUBCOMPONENT_BUILDER, componentMethod);
         }
       }
 
@@ -468,17 +524,16 @@ private ComponentMethodDescriptor getDescriptorForComponentMethod(TypeElement co
         switch (componentKind) {
           case COMPONENT:
           case SUBCOMPONENT:
-            return new AutoValue_ComponentDescriptor_ComponentMethodDescriptor(
-                ComponentMethodKind.PROVISON,
-                Optional.of(dependencyRequestFactory.forComponentProvisionMethod(componentMethod,
-                    resolvedComponentMethod)),
-                componentMethod);
+            return ComponentMethodDescriptor.forProvision(
+                componentMethod,
+                dependencyRequestFactory.forComponentProvisionMethod(
+                    componentMethod, resolvedComponentMethod));
           case PRODUCTION_COMPONENT:
-            return new AutoValue_ComponentDescriptor_ComponentMethodDescriptor(
-                ComponentMethodKind.PRODUCTION,
-                Optional.of(dependencyRequestFactory.forComponentProductionMethod(componentMethod,
-                    resolvedComponentMethod)),
-                componentMethod);
+          case PRODUCTION_SUBCOMPONENT:
+            return ComponentMethodDescriptor.forProvision(
+                componentMethod,
+                dependencyRequestFactory.forComponentProductionMethod(
+                    componentMethod, resolvedComponentMethod));
           default:
             throw new AssertionError();
         }
@@ -488,12 +543,10 @@ private ComponentMethodDescriptor getDescriptorForComponentMethod(TypeElement co
       if (parameterTypes.size() == 1
           && (returnType.getKind().equals(VOID)
               || MoreTypes.equivalence().equivalent(returnType, parameterTypes.get(0)))) {
-        return new AutoValue_ComponentDescriptor_ComponentMethodDescriptor(
-            ComponentMethodKind.MEMBERS_INJECTION,
-            Optional.of(dependencyRequestFactory.forComponentMembersInjectionMethod(
-                componentMethod,
-                resolvedComponentMethod)),
-            componentMethod);
+        return ComponentMethodDescriptor.forMembersInjection(
+            componentMethod,
+            dependencyRequestFactory.forComponentMembersInjectionMethod(
+                componentMethod, resolvedComponentMethod));
       }
 
       throw new IllegalArgumentException("not a valid component method: " + componentMethod);
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentHierarchyValidator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentHierarchyValidator.java
index 8fb4191a5..3a09e8cba 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentHierarchyValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentHierarchyValidator.java
@@ -52,6 +52,7 @@
       // validate the way that we create subcomponents
       switch (subcomponentMethodDescriptor.kind()) {
         case SUBCOMPONENT:
+        case PRODUCTION_SUBCOMPONENT:
           for (VariableElement factoryMethodParameter :
               subcomponentMethodDescriptor.methodElement().getParameters()) {
             TypeElement origininatingComponent =
@@ -70,6 +71,7 @@
           }
           break;
         case SUBCOMPONENT_BUILDER:
+        case PRODUCTION_SUBCOMPONENT_BUILDER:
           BuilderSpec subcomponentBuilderSpec = subcomponentDescriptor.builderSpec().get();
           for (Map.Entry<TypeElement, ExecutableElement> builderMethodEntry :
               subcomponentBuilderSpec.methodMap().entrySet()) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java
index fdc53d569..8a4feddac 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java
@@ -28,6 +28,7 @@
 import dagger.internal.codegen.ComponentDescriptor.Factory;
 import dagger.internal.codegen.ComponentValidator.ComponentValidationReport;
 import dagger.producers.ProductionComponent;
+import dagger.producers.ProductionSubcomponent;
 import java.lang.annotation.Annotation;
 import java.util.Map;
 import java.util.Set;
@@ -85,7 +86,9 @@
         ProductionComponent.class,
         ProductionComponent.Builder.class,
         Subcomponent.class,
-        Subcomponent.Builder.class);
+        Subcomponent.Builder.class,
+        ProductionSubcomponent.class,
+        ProductionSubcomponent.Builder.class);
   }
 
   @Override
diff --git a/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java b/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
index 50e343543..a9f1ffa35 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
@@ -26,9 +26,7 @@
 import com.google.common.collect.Sets;
 import dagger.Component;
 import dagger.Module;
-import dagger.Subcomponent;
 import dagger.producers.ProducerModule;
-import dagger.producers.ProductionComponent;
 import java.lang.annotation.Annotation;
 import java.util.ArrayDeque;
 import java.util.List;
@@ -45,7 +43,6 @@
 import javax.lang.model.util.ElementFilter;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.SimpleAnnotationValueVisitor6;
-import javax.lang.model.util.SimpleTypeVisitor6;
 import javax.lang.model.util.Types;
 
 import static com.google.auto.common.AnnotationMirrors.getAnnotationValue;
@@ -60,11 +57,6 @@
  */
 final class ConfigurationAnnotations {
 
-  static boolean isComponent(TypeElement componentDefinitionType) {
-    return MoreElements.isAnnotationPresent(componentDefinitionType, Component.class)
-        || MoreElements.isAnnotationPresent(componentDefinitionType, ProductionComponent.class);
-  }
-
   private static final String MODULES_ATTRIBUTE = "modules";
 
   static ImmutableList<TypeMirror> getComponentModules(AnnotationMirror componentAnnotation) {
@@ -203,23 +195,6 @@ protected TypeMirror defaultAction(Object o, Void p) {
     return builders.build();
   }
 
-  static boolean isSubcomponentType(TypeMirror type) {
-    return type.accept(new SubcomponentDetector(), null).isPresent();
-  }
-
-  private static final class SubcomponentDetector
-      extends SimpleTypeVisitor6<Optional<AnnotationMirror>, Void> {
-    @Override
-    protected Optional<AnnotationMirror> defaultAction(TypeMirror e, Void p) {
-      return Optional.absent();
-    }
-
-    @Override
-    public Optional<AnnotationMirror> visitDeclared(DeclaredType t, Void p) {
-      return MoreElements.getAnnotationMirror(t.asElement(), Subcomponent.class);
-    }
-  }
-
   /** Traverses includes from superclasses and adds them into the builder. */
   private static void addIncludesFromSuperclasses(Types types, TypeElement element,
       ImmutableSet.Builder<TypeElement> builder, TypeMirror objectType) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
index 4c9a9af3f..41406f80c 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
@@ -264,6 +264,8 @@ static ComponentBuilderMessages builderMsgsFor(ComponentDescriptor.Kind kind) {
         return SubcomponentBuilderMessages.INSTANCE;
       case PRODUCTION_COMPONENT:
         return ProductionComponentBuilderMessages.INSTANCE;
+      case PRODUCTION_SUBCOMPONENT:
+        return ProductionSubcomponentBuilderMessages.INSTANCE;
       default:
         throw new IllegalStateException(kind.toString());
     }
@@ -406,6 +408,26 @@ String moreThanOneRefToSubcomponent() {
     }
   }
 
+  static final class ProductionSubcomponentBuilderMessages extends ComponentBuilderMessages {
+    @SuppressWarnings("hiding")
+    static final ProductionSubcomponentBuilderMessages INSTANCE =
+        new ProductionSubcomponentBuilderMessages();
+
+    @Override
+    protected String process(String s) {
+      return s.replaceAll("component", "production subcomponent")
+          .replaceAll("Component", "ProductionSubcomponent");
+    }
+
+    String builderMethodRequiresNoArgs() {
+      return "Methods returning a @ProductionSubcomponent.Builder must have no arguments";
+    }
+
+    String moreThanOneRefToSubcomponent() {
+      return "Only one method can create a given production subcomponent. %s is created by: %s";
+    }
+  }
+
   /** Error messages related to {@link Multibindings @Multibindings}. */
   static final class MultibindingsMessages {
     static final String MUST_BE_INTERFACE = "@Multibindings can be applied only to interfaces";
diff --git a/compiler/src/main/java/dagger/internal/codegen/MonitoringModuleProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/MonitoringModuleProcessingStep.java
index 91b10e7ef..45e5e835c 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MonitoringModuleProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MonitoringModuleProcessingStep.java
@@ -16,20 +16,19 @@
 package dagger.internal.codegen;
 
 import com.google.auto.common.BasicAnnotationProcessor.ProcessingStep;
+import com.google.auto.common.MoreElements;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.SetMultimap;
 import dagger.producers.ProductionComponent;
+import dagger.producers.ProductionSubcomponent;
 import java.lang.annotation.Annotation;
 import java.util.Set;
 import javax.annotation.processing.Messager;
 import javax.lang.model.element.Element;
-import javax.lang.model.element.TypeElement;
-
-import static javax.lang.model.util.ElementFilter.typesIn;
 
 /**
  * A processing step that is responsible for generating a special module for a
- * {@link ProductionComponent}.
+ * {@link ProductionComponent} or {@link ProductionSubcomponent}.
  */
 final class MonitoringModuleProcessingStep implements ProcessingStep {
   private final Messager messager;
@@ -43,15 +42,15 @@
 
   @Override
   public Set<? extends Class<? extends Annotation>> annotations() {
-    return ImmutableSet.of(ProductionComponent.class);
+    return ImmutableSet.of(ProductionComponent.class, ProductionSubcomponent.class);
   }
 
   @Override
   public Set<Element> process(
       SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
-    for (TypeElement element : typesIn(elementsByAnnotation.get(ProductionComponent.class))) {
+    for (Element element : elementsByAnnotation.values()) {
       try {
-        monitoringModuleGenerator.generate(element);
+        monitoringModuleGenerator.generate(MoreElements.asType(element));
       } catch (SourceFileGenerationException e) {
         e.printMessageTo(messager);
       }
diff --git a/producers/src/main/java/dagger/producers/ProductionSubcomponent.java b/producers/src/main/java/dagger/producers/ProductionSubcomponent.java
new file mode 100644
index 000000000..2832fcf65
--- /dev/null
+++ b/producers/src/main/java/dagger/producers/ProductionSubcomponent.java
@@ -0,0 +1,57 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.producers;
+
+import dagger.Component;
+import dagger.Module;
+import dagger.Subcomponent;
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+
+import static java.lang.annotation.ElementType.TYPE;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+/**
+ * A subcomponent that inherits the bindings from a parent {@link Component}, {@link Subcomponent},
+ * {@link ProductionComponent}, or {@link ProductionSubcomponent}. The details of how to associate a
+ * subcomponent with a parent are described in the documentation for {@link Component}.
+ *
+ * @author Jesse Beder
+ */
+@Retention(RUNTIME) // Allows runtimes to have specialized behavior interoperating with Dagger.
+@Target(TYPE)
+@Documented
+public @interface ProductionSubcomponent {
+  /**
+   * A list of classes annotated with {@link Module} or {@link ProducerModule} whose bindings are
+   * used to generate the subcomponent implementation.  Note that through the use of
+   * {@link Module#includes} or {@link ProducerModule#includes} the full set of modules used to
+   * implement the subcomponent may include more modules that just those listed here.
+   */
+  Class<?>[] modules() default {};
+
+  /**
+   * A builder for a subcomponent.  This follows all the rules of
+   * {@link ProductionComponent.Builder}, except it must appear in classes annotated with
+   * {@link ProductionSubcomponent} instead of {@code ProductionComponent}. Components can have
+   * methods that return a {@link ProductionSubcomponent.Builder}-annotated type, allowing the user
+   * to set modules on the subcomponent using their defined API.
+   */
+  @Target(TYPE)
+  @Documented
+  @interface Builder {}
+}
