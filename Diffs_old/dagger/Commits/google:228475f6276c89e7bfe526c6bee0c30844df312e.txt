diff --git a/compiler/src/it/functional-tests/src/main/java/test/MultibindingComponent.java b/compiler/src/it/functional-tests/src/main/java/test/MultibindingComponent.java
index ca99abaa3..8be16eb25 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/MultibindingComponent.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/MultibindingComponent.java
@@ -25,10 +25,7 @@
 import test.sub.ContributionsModule;
 
 @Component(
-  modules = {
-    MultibindingModule.class,
-    ContributionsModule.class
-  },
+  modules = {MultibindingModule.class, MultibindsModule.class, ContributionsModule.class},
   dependencies = MultibindingDependency.class
 )
 interface MultibindingComponent {
diff --git a/compiler/src/it/functional-tests/src/main/java/test/MultibindingComponentWithMultibindingsInterface.java b/compiler/src/it/functional-tests/src/main/java/test/MultibindingComponentWithMultibindingsInterface.java
new file mode 100644
index 000000000..37f59b10b
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/MultibindingComponentWithMultibindingsInterface.java
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import dagger.Component;
+import dagger.Multibindings;
+import test.sub.ContributionsModule;
+
+/**
+ * A component used to test multibindings that use {@link Multibindings @Multibindings}-annotated
+ * nested interfaces to declare multibindings.
+ */
+@Component(
+  modules = {
+    MultibindingModule.class,
+    MultibindingsInterfaceModule.class,
+    ContributionsModule.class
+  },
+  dependencies = MultibindingDependency.class
+)
+interface MultibindingComponentWithMultibindingsInterface extends MultibindingComponent {}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/MultibindingModule.java b/compiler/src/it/functional-tests/src/main/java/test/MultibindingModule.java
index d4f2a1c46..8562983a0 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/MultibindingModule.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/MultibindingModule.java
@@ -16,7 +16,6 @@
 package test;
 
 import dagger.Module;
-import dagger.Multibindings;
 import dagger.Provides;
 import dagger.multibindings.ClassKey;
 import dagger.multibindings.ElementsIntoSet;
@@ -25,14 +24,12 @@
 import dagger.multibindings.IntoSet;
 import dagger.multibindings.LongKey;
 import dagger.multibindings.StringKey;
-
 import java.math.BigDecimal;
 import java.math.BigInteger;
 import java.util.Collection;
 import java.util.HashSet;
 import java.util.Map;
 import java.util.Set;
-
 import javax.inject.Named;
 import javax.inject.Provider;
 
@@ -254,29 +251,4 @@ static CharSequence mapContribution() {
   static CharSequence qualifiedMapContribution() {
     return "qualified foo value";
   }
-
-  interface EmptiesSupertype {
-    Set<Object> emptySet();
-
-    Map<String, Object> emptyMap();
-
-    Set<CharSequence> maybeEmptySet();
-
-    Map<String, CharSequence> maybeEmptyMap();
-  }
-
-  @Multibindings
-  interface Empties extends EmptiesSupertype {
-    @Named("complexQualifier")
-    Set<Object> emptyQualifiedSet();
-
-    @Named("complexQualifier")
-    Map<String, Object> emptyQualifiedMap();
-
-    @Named("complexQualifier")
-    Set<CharSequence> maybeEmptyQualifiedSet();
-
-    @Named("complexQualifier")
-    Map<String, CharSequence> maybeEmptyQualifiedMap();
-  }
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/MultibindingsInterfaceModule.java b/compiler/src/it/functional-tests/src/main/java/test/MultibindingsInterfaceModule.java
new file mode 100644
index 000000000..b9219ff1f
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/MultibindingsInterfaceModule.java
@@ -0,0 +1,55 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import dagger.Module;
+import dagger.Multibindings;
+import java.util.Map;
+import java.util.Set;
+import javax.inject.Named;
+
+/**
+ * A module that uses a {@link Multibindings @Multibindings}-annotated nested interface to declare
+ * multibindings.
+ */
+@Module
+final class MultibindingsInterfaceModule {
+
+  interface EmptiesSupertype {
+    Set<Object> emptySet();
+
+    Map<String, Object> emptyMap();
+
+    Set<CharSequence> set();
+
+    Map<String, CharSequence> map();
+  }
+
+  @Multibindings
+  interface Empties extends EmptiesSupertype {
+    @Named("complexQualifier")
+    Set<Object> emptyQualifiedSet();
+
+    @Named("complexQualifier")
+    Map<String, Object> emptyQualifiedMap();
+
+    @Named("complexQualifier")
+    Set<CharSequence> qualifiedSet();
+
+    @Named("complexQualifier")
+    Map<String, CharSequence> qualifiedMap();
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/MultibindsModule.java b/compiler/src/it/functional-tests/src/main/java/test/MultibindsModule.java
new file mode 100644
index 000000000..8b193c96d
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/MultibindsModule.java
@@ -0,0 +1,58 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import dagger.Module;
+import dagger.multibindings.Multibinds;
+import java.util.Map;
+import java.util.Set;
+import javax.inject.Named;
+
+/**
+ * A module that uses {@link Multibinds @Multibinds}-annotated abstract methods to declare
+ * multibindings.
+ */
+@Module
+abstract class MultibindsModule {
+
+  @Multibinds
+  abstract Set<Object> emptySet();
+
+  @Multibinds
+  abstract Map<String, Object> emptyMap();
+
+  @Multibinds
+  abstract Set<CharSequence> set();
+
+  @Multibinds
+  abstract Map<String, CharSequence> map();
+
+  @Multibinds
+  @Named("complexQualifier")
+  abstract Set<Object> emptyQualifiedSet();
+
+  @Multibinds
+  @Named("complexQualifier")
+  abstract Map<String, Object> emptyQualifiedMap();
+
+  @Multibinds
+  @Named("complexQualifier")
+  abstract Set<CharSequence> qualifiedSet();
+
+  @Multibinds
+  @Named("complexQualifier")
+  abstract Map<String, CharSequence> qualifiedMap();
+}
diff --git a/compiler/src/it/functional-tests/src/test/java/test/MultibindingTest.java b/compiler/src/it/functional-tests/src/test/java/test/MultibindingTest.java
index 33b9aed38..c17260ad9 100644
--- a/compiler/src/it/functional-tests/src/test/java/test/MultibindingTest.java
+++ b/compiler/src/it/functional-tests/src/test/java/test/MultibindingTest.java
@@ -14,6 +14,7 @@
 package test;
 
 import com.google.auto.value.AutoAnnotation;
+import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import dagger.multibindings.ClassKey;
 import dagger.multibindings.StringKey;
@@ -21,25 +22,45 @@
 import java.math.BigInteger;
 import java.util.Map;
 import javax.inject.Provider;
-import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
+import org.junit.runners.Parameterized;
+import org.junit.runners.Parameterized.Parameters;
 
 import static com.google.common.truth.Truth.assertThat;
 
-@RunWith(JUnit4.class)
+@RunWith(Parameterized.class)
 public class MultibindingTest {
-  private MultibindingComponent multibindingComponent;
 
-  @Before public void setUp() {
-    multibindingComponent = DaggerMultibindingComponent.builder()
-        .multibindingDependency(new MultibindingDependency() {
-          @Override public double doubleDependency() {
-            return 0.0;
+  private static final MultibindingDependency MULTIBINDING_DEPENDENCY =
+      new MultibindingDependency() {
+        @Override
+        public double doubleDependency() {
+          return 0.0;
+        }
+      };
+
+  @Parameters(name = "{0}")
+  public static Iterable<Object[]> parameters() {
+    return ImmutableList.copyOf(
+        new Object[][] {
+          {
+            DaggerMultibindingComponent.builder()
+                .multibindingDependency(MULTIBINDING_DEPENDENCY)
+                .build()
+          },
+          {
+            DaggerMultibindingComponentWithMultibindingsInterface.builder()
+                .multibindingDependency(MULTIBINDING_DEPENDENCY)
+                .build()
           }
-        })
-        .build();
+        });
+  }
+
+  private final MultibindingComponent multibindingComponent;
+
+  public MultibindingTest(MultibindingComponent multibindingComponent) {
+    this.multibindingComponent = multibindingComponent;
   }
 
   @Test public void map() {
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingMethodValidator.java
index f719273d9..3d4837705 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingMethodValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingMethodValidator.java
@@ -21,7 +21,6 @@
 import com.google.common.cache.CacheLoader;
 import com.google.common.cache.LoadingCache;
 import com.google.common.collect.FluentIterable;
-import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Lists;
 import dagger.MapKey;
@@ -30,6 +29,7 @@
 import dagger.multibindings.IntoMap;
 import dagger.producers.Produces;
 import java.lang.annotation.Annotation;
+import javax.annotation.OverridingMethodsMustInvokeSuper;
 import javax.annotation.processing.Messager;
 import javax.inject.Qualifier;
 import javax.lang.model.element.AnnotationMirror;
@@ -75,7 +75,7 @@
   private final Elements elements;
   private final Types types;
   private final Class<? extends Annotation> methodAnnotation;
-  private final ImmutableList<Class<? extends Annotation>> enclosingElementAnnotations;
+  private final ImmutableSet<Class<? extends Annotation>> enclosingElementAnnotations;
   private final Abstractness abstractness;
   private final ExceptionSuperclass exceptionSuperclass;
   private final LoadingCache<ExecutableElement, ValidationReport<ExecutableElement>> cache =
@@ -109,7 +109,7 @@ protected BindingMethodValidator(
         elements,
         types,
         methodAnnotation,
-        ImmutableList.of(enclosingElementAnnotation),
+        ImmutableSet.of(enclosingElementAnnotation),
         abstractness,
         exceptionSuperclass);
   }
@@ -132,7 +132,7 @@ protected BindingMethodValidator(
     this.types = types;
     this.methodAnnotation = methodAnnotation;
     this.enclosingElementAnnotations =
-        ImmutableList.<Class<? extends Annotation>>copyOf(enclosingElementAnnotations);
+        ImmutableSet.<Class<? extends Annotation>>copyOf(enclosingElementAnnotations);
     this.abstractness = abstractness;
     this.exceptionSuperclass = exceptionSuperclass;
   }
@@ -162,6 +162,7 @@ protected BindingMethodValidator(
   }
 
   /** Checks the method for validity. Adds errors to {@code builder}. */
+  @OverridingMethodsMustInvokeSuper
   protected void checkMethod(ValidationReport.Builder<ExecutableElement> builder) {
     checkEnclosingElement(builder);
     checkTypeParameters(builder);
@@ -178,7 +179,8 @@ protected void checkMethod(ValidationReport.Builder<ExecutableElement> builder)
    * Adds an error if the method is not declared in a class or interface annotated with one of the
    * {@link #enclosingElementAnnotations}.
    */
-  private void checkEnclosingElement(ValidationReport.Builder<ExecutableElement> builder) {
+  // TODO(b/28861722): Make private once @Multibindings is deleted.
+  protected void checkEnclosingElement(ValidationReport.Builder<ExecutableElement> builder) {
     if (!isAnyAnnotationPresent(
         builder.getSubject().getEnclosingElement(), enclosingElementAnnotations)) {
       builder.addError(
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindsMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindsMethodValidator.java
index 4af09accf..369f424eb 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindsMethodValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindsMethodValidator.java
@@ -15,7 +15,7 @@
  */
 package dagger.internal.codegen;
 
-import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
 import dagger.Binds;
 import dagger.Module;
 import dagger.producers.ProducerModule;
@@ -42,7 +42,7 @@
         elements,
         types,
         Binds.class,
-        ImmutableList.of(Module.class, ProducerModule.class),
+        ImmutableSet.of(Module.class, ProducerModule.class),
         MUST_BE_ABSTRACT,
         RUNTIME_EXCEPTION);
     this.types = checkNotNull(types);
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
index 70a12928f..5fae068e6 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -85,11 +85,13 @@ public SourceVersion getSupportedSourceVersion() {
     ProvidesMethodValidator providesMethodValidator = new ProvidesMethodValidator(elements, types);
     ProducesMethodValidator producesMethodValidator = new ProducesMethodValidator(elements, types);
     BindsMethodValidator bindsMethodValidator = new BindsMethodValidator(elements, types);
+    MultibindsMethodValidator multibindsMethodValidator =
+        new MultibindsMethodValidator(elements, types);
+    MultibindingsMethodValidator multibindingsMethodValidator =
+        new MultibindingsMethodValidator(elements, types);
 
     Key.Factory keyFactory = new Key.Factory(types, elements);
 
-    MultibindingsMethodValidator multibindingsMethodValidator =
-        new MultibindingsMethodValidator(elements, types);
     MultibindingsValidator multibindingsValidator =
         new MultibindingsValidator(
             elements,
@@ -183,7 +185,8 @@ public SourceVersion getSupportedSourceVersion() {
             provisionBindingFactory,
             factoryGenerator,
             providesMethodValidator,
-            bindsMethodValidator),
+            bindsMethodValidator,
+            multibindsMethodValidator),
         new ComponentProcessingStep(
             ComponentDescriptor.Kind.COMPONENT,
             messager,
@@ -201,7 +204,8 @@ public SourceVersion getSupportedSourceVersion() {
             productionBindingFactory,
             producerFactoryGenerator,
             producesMethodValidator,
-            bindsMethodValidator),
+            bindsMethodValidator,
+            multibindsMethodValidator),
         new ComponentProcessingStep(
             ComponentDescriptor.Kind.PRODUCTION_COMPONENT,
             messager,
diff --git a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
index 1732afe1a..8b07e58c9 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
@@ -18,6 +18,7 @@
 import com.google.auto.common.MoreTypes;
 import dagger.Multibindings;
 import dagger.Provides;
+import dagger.multibindings.Multibinds;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 import javax.lang.model.element.AnnotationMirror;
@@ -189,8 +190,8 @@ static String inconsistentMapKeyAnnotationsError(String key) {
       "Cannot have more than one @%s method with the same name in a single module";
 
   static final String INCOMPATIBLE_MODULE_METHODS =
-      "A @%1$s may contain non-static @%2$s methods or @Binds methods,"
-          + " but not both at the same time.  (Static @%2$s may be used with either.)";
+      "A @%1$s may not contain both non-static @%2$s methods and abstract @Binds or @Multibinds "
+          + "declarations";
 
   static final String MODULES_WITH_TYPE_PARAMS_MUST_BE_ABSTRACT =
       "Modules with type parameters must be abstract";
@@ -481,12 +482,6 @@ String moreThanOneRefToSubcomponent() {
     static final String MUST_BE_IN_MODULE =
         "@Multibindings types must be nested within a @Module or @ProducerModule";
 
-    static final String METHOD_MUST_RETURN_MAP_OR_SET =
-        "@Multibindings methods must return Map<K, V> or Set<T>";
-
-    static final String TOO_MANY_QUALIFIERS =
-        "Cannot use more than one @Qualifier on a method in an @Multibindings type";
-
     static String tooManyMethodsForKey(String formattedKey) {
       return String.format(
           "Too many @Multibindings methods for %s", stripCommonTypePrefixes(formattedKey));
@@ -494,6 +489,21 @@ static String tooManyMethodsForKey(String formattedKey) {
 
     private MultibindingsMessages() {}
   }
+  
+  /**
+   * Error messages related to {@link Multibinds @Multibinds} methods and methods in
+   * {@link Multibindings} interfaces.
+   */
+  static final class MultibindsMessages {
+    static final String METHOD_MUST_RETURN_MAP_OR_SET =
+        "@%s methods must return Map<K, V> or Set<T>";
+
+    static final String NO_MAP_KEY = "@%s methods must not have a @MapKey annotation";
+
+    static final String PARAMETERS = "@%s methods cannot have parameters";
+
+    private MultibindsMessages() {}
+  }
 
   /**
    * A regular expression to match a small list of specific packages deemed to
diff --git a/compiler/src/main/java/dagger/internal/codegen/Key.java b/compiler/src/main/java/dagger/internal/codegen/Key.java
index 37d92a371..c67d374d8 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Key.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Key.java
@@ -29,6 +29,7 @@
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.Binds;
 import dagger.Multibindings;
+import dagger.multibindings.Multibinds;
 import dagger.producers.Produced;
 import dagger.producers.Producer;
 import dagger.producers.Production;
@@ -330,12 +331,13 @@ private Key forProvidesOrProducesMethod(
     }
 
     /**
-     * Returns the key for a method in a {@link Multibindings @Multibindings} interface.
+     * Returns the key for a {@link Multibinds @Multibinds} method or a method in a
+     * {@link Multibindings @Multibindings} interface.
      *
      * The key's type is either {@code Set<T>} or {@code Map<K, F<V>>}, where {@code F} is either
      * {@link Provider} or {@link Producer}, depending on {@code bindingType}.
      */
-    Key forMultibindingsMethod(
+    Key forMultibindsMethod(
         BindingType bindingType, ExecutableType executableType, ExecutableElement method) {
       checkArgument(method.getKind().equals(METHOD), "%s must be a method", method);
       TypeElement factoryType =
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java
index a4e645ec3..c875d23c7 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java
@@ -27,6 +27,7 @@
 import dagger.Module;
 import dagger.Multibindings;
 import dagger.Provides;
+import dagger.multibindings.Multibinds;
 import dagger.producers.ProducerModule;
 import dagger.producers.Produces;
 import java.lang.annotation.Annotation;
@@ -168,6 +169,8 @@ ModuleDescriptor create(TypeElement moduleElement) {
 
       ImmutableSet.Builder<ContributionBinding> bindings = ImmutableSet.builder();
       ImmutableSet.Builder<DelegateDeclaration> delegates = ImmutableSet.builder();
+      ImmutableSet.Builder<MultibindingDeclaration> multibindingDeclarations =
+          ImmutableSet.builder();
       for (ExecutableElement moduleMethod : methodsIn(elements.getAllMembers(moduleElement))) {
         if (isAnnotationPresent(moduleMethod, Provides.class)) {
           bindings.add(provisionBindingFactory.forProvidesMethod(moduleMethod, moduleElement));
@@ -178,14 +181,16 @@ ModuleDescriptor create(TypeElement moduleElement) {
         if (isAnnotationPresent(moduleMethod, Binds.class)) {
           delegates.add(bindingDelegateDeclarationFactory.create(moduleMethod, moduleElement));
         }
+        if (isAnnotationPresent(moduleMethod, Multibinds.class)) {
+          multibindingDeclarations.add(
+              multibindingDeclarationFactory.forMultibindsMethod(moduleMethod, moduleElement));
+        }
       }
 
-      ImmutableSet.Builder<MultibindingDeclaration> multibindingDeclarations =
-          ImmutableSet.builder();
       for (TypeElement memberType : typesIn(elements.getAllMembers(moduleElement))) {
         if (isAnnotationPresent(memberType, Multibindings.class)) {
           multibindingDeclarations.addAll(
-              multibindingDeclarationFactory.forDeclaredInterface(memberType));
+              multibindingDeclarationFactory.forMultibindingsInterface(memberType));
         }
       }
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/ModuleProcessingStep.java
index 44712190b..33fd0b82b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleProcessingStep.java
@@ -54,7 +54,8 @@
       final ProvisionBinding.Factory provisionBindingFactory,
       FactoryGenerator factoryGenerator,
       ProvidesMethodValidator providesMethodValidator,
-      BindsMethodValidator bindsMethodValidator) {
+      BindsMethodValidator bindsMethodValidator,
+      MultibindsMethodValidator multibindsMethodValidator) {
     return new ModuleProcessingStep<>(
         messager,
         Module.class,
@@ -68,7 +69,7 @@ public ProvisionBinding bindingForModuleMethod(
           }
         },
         factoryGenerator,
-        ImmutableSet.of(providesMethodValidator, bindsMethodValidator));
+        ImmutableSet.of(providesMethodValidator, bindsMethodValidator, multibindsMethodValidator));
   }
 
   /**
@@ -81,7 +82,8 @@ public ProvisionBinding bindingForModuleMethod(
       final ProductionBinding.Factory productionBindingFactory,
       ProducerFactoryGenerator producerFactoryGenerator,
       ProducesMethodValidator producesMethodValidator,
-      BindsMethodValidator bindsMethodValidator) {
+      BindsMethodValidator bindsMethodValidator,
+      MultibindsMethodValidator multibindsMethodValidator) {
     return new ModuleProcessingStep<>(
         messager,
         ProducerModule.class,
@@ -95,7 +97,7 @@ public ProductionBinding bindingForModuleMethod(
           }
         },
         producerFactoryGenerator,
-        ImmutableSet.of(producesMethodValidator, bindsMethodValidator));
+        ImmutableSet.of(producesMethodValidator, bindsMethodValidator, multibindsMethodValidator));
   }
 
   private final Messager messager;
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java b/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java
index 4d56bbe7d..b11da4c46 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java
@@ -28,6 +28,7 @@
 import com.google.common.collect.Sets;
 import dagger.Binds;
 import dagger.Module;
+import dagger.multibindings.Multibinds;
 import dagger.producers.ProducerModule;
 import java.lang.annotation.Annotation;
 import java.util.Collection;
@@ -61,6 +62,7 @@
 import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_OVERRIDES_ANOTHER;
 import static dagger.internal.codegen.ErrorMessages.REFERENCED_MODULE_MUST_NOT_HAVE_TYPE_PARAMS;
 import static dagger.internal.codegen.ErrorMessages.REFERENCED_MODULE_NOT_ANNOTATED;
+import static dagger.internal.codegen.Util.isAnyAnnotationPresent;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.element.Modifier.STATIC;
 
@@ -92,14 +94,11 @@
 
     Set<ModuleMethodKind> methodKinds = EnumSet.noneOf(ModuleMethodKind.class);
     for (ExecutableElement moduleMethod : moduleMethods) {
-      if (isAnnotationPresent(moduleMethod, moduleKind.methodAnnotation())) {
+      if (isAnyAnnotationPresent(
+          moduleMethod,
+          ImmutableSet.of(moduleKind.methodAnnotation(), Binds.class, Multibinds.class))) {
         bindingMethodsByName.put(moduleMethod.getSimpleName().toString(), moduleMethod);
-        methodKinds.add(
-            moduleMethod.getModifiers().contains(STATIC)
-                ? ModuleMethodKind.STATIC_BINDING
-                : ModuleMethodKind.INSTANCE_BINDING);
-      } else if (isAnnotationPresent(moduleMethod, Binds.class)) {
-        methodKinds.add(ModuleMethodKind.ABSTRACT_DECLARATION);
+        methodKinds.add(ModuleMethodKind.ofMethod(moduleMethod));
       }
       allMethodsByName.put(moduleMethod.getSimpleName().toString(), moduleMethod);
     }
@@ -130,6 +129,17 @@
     ABSTRACT_DECLARATION,
     INSTANCE_BINDING,
     STATIC_BINDING,
+    ;
+
+    static ModuleMethodKind ofMethod(ExecutableElement moduleMethod) {
+      if (moduleMethod.getModifiers().contains(STATIC)) {
+        return STATIC_BINDING;
+      } else if (moduleMethod.getModifiers().contains(ABSTRACT)) {
+        return ABSTRACT_DECLARATION;
+      } else {
+        return INSTANCE_BINDING;
+      }
+    }
   }
 
   private void validateModifiers(
diff --git a/compiler/src/main/java/dagger/internal/codegen/MultibindingDeclaration.java b/compiler/src/main/java/dagger/internal/codegen/MultibindingDeclaration.java
index c682d6497..d41b71663 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MultibindingDeclaration.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MultibindingDeclaration.java
@@ -23,11 +23,13 @@
 import dagger.Multibindings;
 import dagger.internal.codegen.BindingType.HasBindingType;
 import dagger.internal.codegen.ContributionType.HasContributionType;
+import dagger.multibindings.Multibinds;
 import dagger.producers.Producer;
 import dagger.producers.ProducerModule;
 import java.util.Map;
 import java.util.Set;
 import javax.inject.Provider;
+import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.DeclaredType;
@@ -93,10 +95,10 @@
      * Creates multibinding declarations for each method in a
      * {@link Multibindings @Multibindings}-annotated interface.
      */
-    ImmutableSet<MultibindingDeclaration> forDeclaredInterface(TypeElement interfaceElement) {
+    ImmutableSet<MultibindingDeclaration> forMultibindingsInterface(TypeElement interfaceElement) {
       checkArgument(interfaceElement.getKind().equals(INTERFACE));
       checkArgument(isAnnotationPresent(interfaceElement, Multibindings.class));
-      BindingType bindingType = bindingType(interfaceElement);
+      BindingType bindingType = bindingType(interfaceElement.getEnclosingElement());
       DeclaredType interfaceType = MoreTypes.asDeclared(interfaceElement.asType());
 
       ImmutableSet.Builder<MultibindingDeclaration> declarations = ImmutableSet.builder();
@@ -110,15 +112,26 @@
       return declarations.build();
     }
 
-    private BindingType bindingType(TypeElement interfaceElement) {
-      if (isAnnotationPresent(interfaceElement.getEnclosingElement(), Module.class)) {
+    /** A multibinding declaration for a {@link Multibinds @Multibinds} method. */
+    MultibindingDeclaration forMultibindsMethod(
+        ExecutableElement moduleMethod, TypeElement moduleElement) {
+      checkArgument(isAnnotationPresent(moduleMethod, Multibinds.class));
+      return forDeclaredMethod(
+          bindingType(moduleElement),
+          moduleMethod,
+          MoreTypes.asExecutable(
+              types.asMemberOf(MoreTypes.asDeclared(moduleElement.asType()), moduleMethod)),
+          moduleElement);
+    }
+
+    private BindingType bindingType(Element moduleElement) {
+      if (isAnnotationPresent(moduleElement, Module.class)) {
         return BindingType.PROVISION;
-      } else if (isAnnotationPresent(
-          interfaceElement.getEnclosingElement(), ProducerModule.class)) {
+      } else if (isAnnotationPresent(moduleElement, ProducerModule.class)) {
         return BindingType.PRODUCTION;
       } else {
         throw new IllegalArgumentException(
-            "Expected " + interfaceElement + " to be nested in a @Module or @ProducerModule");
+            "Expected " + moduleElement + " to be a @Module or @ProducerModule");
       }
     }
 
@@ -126,7 +139,7 @@ private MultibindingDeclaration forDeclaredMethod(
         BindingType bindingType,
         ExecutableElement method,
         ExecutableType methodType,
-        TypeElement interfaceElement) {
+        TypeElement contributingType) {
       TypeMirror returnType = methodType.getReturnType();
       checkArgument(
           SetType.isSet(returnType) || MapType.isMap(returnType),
@@ -134,8 +147,8 @@ private MultibindingDeclaration forDeclaredMethod(
           method);
       return new AutoValue_MultibindingDeclaration(
           method,
-          Optional.of(interfaceElement),
-          keyFactory.forMultibindingsMethod(bindingType, methodType, method),
+          Optional.of(contributingType),
+          keyFactory.forMultibindsMethod(bindingType, methodType, method),
           contributionType(returnType),
           bindingType);
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/MultibindingsMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/MultibindingsMethodValidator.java
index ab8edc773..4b7252cf6 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MultibindingsMethodValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MultibindingsMethodValidator.java
@@ -15,62 +15,22 @@
  */
 package dagger.internal.codegen;
 
-import com.google.auto.common.MoreTypes;
+import com.google.common.collect.ImmutableSet;
 import dagger.Multibindings;
 import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 
-import static dagger.internal.codegen.BindingMethodValidator.Abstractness.MUST_BE_ABSTRACT;
-import static dagger.internal.codegen.ErrorMessages.MultibindingsMessages.METHOD_MUST_RETURN_MAP_OR_SET;
-import static dagger.internal.codegen.FrameworkTypes.isFrameworkType;
-
 /** A {@link Validator} for methods in {@link Multibindings @Multibindings} interfaces. */
-final class MultibindingsMethodValidator extends BindingMethodValidator {
+final class MultibindingsMethodValidator extends MultibindsMethodValidator {
 
   MultibindingsMethodValidator(Elements elements, Types types) {
-    super(
-        elements,
-        types,
-        Multibindings.class,
-        Multibindings.class,
-        MUST_BE_ABSTRACT,
-        ExceptionSuperclass.NONE);
+    super(elements, types, Multibindings.class, ImmutableSet.of(Multibindings.class));
   }
 
   @Override
-  protected void checkMethod(ValidationReport.Builder<ExecutableElement> builder) {
-    // TODO(dpb): Why not do the rest of the checks?
-    checkReturnType(builder);
-    checkQualifiers(builder);
-  }
-
-  @Override
-  protected void checkReturnType(ValidationReport.Builder<ExecutableElement> builder) {
-    if (!isPlainMap(builder.getSubject().getReturnType())
-        && !isPlainSet(builder.getSubject().getReturnType())) {
-      builder.addError(METHOD_MUST_RETURN_MAP_OR_SET);
-    }
-  }
-
-  private boolean isPlainMap(TypeMirror returnType) {
-    if (!MapType.isMap(returnType)) {
-      return false;
-    }
-    MapType mapType = MapType.from(returnType);
-    return !mapType.isRawType()
-        && MoreTypes.isType(mapType.valueType()) // No wildcards.
-        && !isFrameworkType(mapType.valueType());
-  }
-
-  private boolean isPlainSet(TypeMirror returnType) {
-    if (!SetType.isSet(returnType)) {
-      return false;
-    }
-    SetType setType = SetType.from(returnType);
-    return !setType.isRawType()
-        && MoreTypes.isType(setType.elementType()) // No wildcards.
-        && !isFrameworkType(setType.elementType());
+  protected void checkEnclosingElement(ValidationReport.Builder<ExecutableElement> builder) {
+    // no-op, since @Multibindings interfaces can inherit methods from unannotated supertypes.
   }
 }
+
diff --git a/compiler/src/main/java/dagger/internal/codegen/MultibindingsValidator.java b/compiler/src/main/java/dagger/internal/codegen/MultibindingsValidator.java
index 5834c983a..664029937 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MultibindingsValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MultibindingsValidator.java
@@ -93,7 +93,7 @@
 
       if (methodReport.isClean() && bindingType.isPresent()) {
         methodsByKey.put(
-            keyFactory.forMultibindingsMethod(
+            keyFactory.forMultibindsMethod(
                 bindingType.get(), asExecutable(method.asType()), method),
             method);
       }
diff --git a/compiler/src/main/java/dagger/internal/codegen/MultibindsMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/MultibindsMethodValidator.java
new file mode 100644
index 000000000..3b07faad7
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/MultibindsMethodValidator.java
@@ -0,0 +1,127 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.common.MoreTypes;
+import com.google.common.collect.ImmutableSet;
+import dagger.MapKey;
+import dagger.Module;
+import dagger.Multibindings;
+import dagger.multibindings.ElementsIntoSet;
+import dagger.multibindings.IntoMap;
+import dagger.multibindings.IntoSet;
+import dagger.multibindings.Multibinds;
+import dagger.producers.ProducerModule;
+import java.lang.annotation.Annotation;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
+
+import static dagger.internal.codegen.BindingMethodValidator.Abstractness.MUST_BE_ABSTRACT;
+import static dagger.internal.codegen.ErrorMessages.MultibindsMessages.METHOD_MUST_RETURN_MAP_OR_SET;
+import static dagger.internal.codegen.ErrorMessages.MultibindsMessages.NO_MAP_KEY;
+import static dagger.internal.codegen.ErrorMessages.MultibindsMessages.PARAMETERS;
+import static dagger.internal.codegen.FrameworkTypes.isFrameworkType;
+import static dagger.internal.codegen.MapKeys.getMapKeys;
+
+/**
+ * A {@link Validator} for {@link Multibinds @Multibinds} methods or methods in
+ * {@link Multibindings @Multibindings} interfaces.
+ */
+class MultibindsMethodValidator extends BindingMethodValidator {
+
+  /** Creates a {@link Validator} for {@link Multibinds @Multibinds} methods. */
+  MultibindsMethodValidator(Elements elements, Types types) {
+    this(elements, types, Multibinds.class, ImmutableSet.of(Module.class, ProducerModule.class));
+  }
+
+  protected MultibindsMethodValidator(
+      Elements elements,
+      Types types,
+      Class<? extends Annotation> methodAnnotation,
+      Iterable<? extends Class<? extends Annotation>> enclosingElementAnnotations) {
+    super(
+        elements,
+        types,
+        methodAnnotation,
+        enclosingElementAnnotations,
+        MUST_BE_ABSTRACT,
+        ExceptionSuperclass.NONE);
+  }
+  
+  @Override
+  protected void checkMethod(ValidationReport.Builder<ExecutableElement> builder) {
+    super.checkMethod(builder);
+
+    checkParameters(builder);
+  }
+
+  private void checkParameters(ValidationReport.Builder<ExecutableElement> builder) {
+    if (!builder.getSubject().getParameters().isEmpty()) {
+      builder.addError(formatErrorMessage(PARAMETERS));
+    }
+  }
+
+  /** Adds an error unless the method returns a {@code Map<K, V>} or {@code Set<T>}. */
+  @Override
+  protected void checkReturnType(ValidationReport.Builder<ExecutableElement> builder) {
+    if (!isPlainMap(builder.getSubject().getReturnType())
+        && !isPlainSet(builder.getSubject().getReturnType())) {
+      builder.addError(formatErrorMessage(METHOD_MUST_RETURN_MAP_OR_SET));
+    }
+  }
+
+  /** Adds an error if the method has any {@link MapKey @MapKey} annotations. */
+  @Override
+  protected void checkMapKeys(ValidationReport.Builder<ExecutableElement> builder) {
+    ImmutableSet<? extends AnnotationMirror> mapKeys = getMapKeys(builder.getSubject());
+    if (!mapKeys.isEmpty()) {
+      builder.addError(formatErrorMessage(NO_MAP_KEY));
+    }
+  }
+
+  /**
+   * {@link MultibindingAnnotationsProcessingStep} reports an error if {@link IntoMap @IntoMap},
+   * {@link IntoSet @IntoSet}, or {@link ElementsIntoSet @ElementsIntoSet} are applied to the method
+   * at all, so no need to check again.
+   */
+  @Override
+  protected void checkMultibindings(ValidationReport.Builder<ExecutableElement> builder) {
+    // no-op
+  }
+
+  private boolean isPlainMap(TypeMirror returnType) {
+    if (!MapType.isMap(returnType)) {
+      return false;
+    }
+    MapType mapType = MapType.from(returnType);
+    return !mapType.isRawType()
+        && MoreTypes.isType(mapType.valueType()) // No wildcards.
+        && !isFrameworkType(mapType.valueType());
+  }
+
+  private boolean isPlainSet(TypeMirror returnType) {
+    if (!SetType.isSet(returnType)) {
+      return false;
+    }
+    SetType setType = SetType.from(returnType);
+    return !setType.isRawType()
+        && MoreTypes.isType(setType.elementType()) // No wildcards.
+        && !isFrameworkType(setType.elementType());
+  }
+}
diff --git a/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java b/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
index 52ce9d51d..2253201af 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
@@ -1174,6 +1174,7 @@ public void genericSubclassedModule() {
   }
 
   private static final String BINDS_METHOD = "@Binds abstract Foo bindFoo(FooImpl impl);";
+  private static final String MULTIBINDS_METHOD = "@Multibinds abstract Set<Foo> foos();";
   private static final String STATIC_PROVIDES_METHOD =
       "@Provides static Bar provideBar() { return new Bar(); }";
   private static final String INSTANCE_PROVIDES_METHOD =
@@ -1184,8 +1185,17 @@ public void genericSubclassedModule() {
   public void moduleMethodPermutations() {
     assertThatMethodCombination(BINDS_METHOD, INSTANCE_PROVIDES_METHOD)
         .failsToCompile()
-        .withErrorContaining("not both at the same time");
+        .withErrorContaining(
+            "A @Module may not contain both non-static @Provides methods and "
+                + "abstract @Binds or @Multibinds declarations");
+    assertThatMethodCombination(MULTIBINDS_METHOD, INSTANCE_PROVIDES_METHOD)
+        .failsToCompile()
+        .withErrorContaining(
+            "A @Module may not contain both non-static @Provides methods and "
+                + "abstract @Binds or @Multibinds declarations");
     assertThatMethodCombination(BINDS_METHOD, STATIC_PROVIDES_METHOD).compilesWithoutError();
+    assertThatMethodCombination(BINDS_METHOD, MULTIBINDS_METHOD).compilesWithoutError();
+    assertThatMethodCombination(MULTIBINDS_METHOD, STATIC_PROVIDES_METHOD).compilesWithoutError();
     assertThatMethodCombination(INSTANCE_PROVIDES_METHOD, SOME_ABSTRACT_METHOD)
         .compilesWithoutError();
   }
@@ -1228,6 +1238,8 @@ private CompileTester assertThatMethodCombination(String... methodLines) {
                 "import dagger.Binds;",
                 "import dagger.Module;",
                 "import dagger.Provides;",
+                "import dagger.multibindings.Multibinds;",
+                "import java.util.Set;",
                 "",
                 "@Module abstract class TestModule {")
             .add(methodLines)
diff --git a/compiler/src/test/java/dagger/internal/codegen/MultibindingsValidatorTest.java b/compiler/src/test/java/dagger/internal/codegen/MultibindingsValidatorTest.java
index 74a49472c..5741aa6f1 100644
--- a/compiler/src/test/java/dagger/internal/codegen/MultibindingsValidatorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/MultibindingsValidatorTest.java
@@ -289,6 +289,12 @@ public void overqualifiedMap() {
         .hasError("Cannot use more than one @Qualifier");
   }
 
+  @Test
+  public void hasParameters() {
+    assertThatMultibindingsMethod("Set<String> parameters(Object param);")
+        .hasError("@Multibindings methods cannot have parameters");
+  }
+
   @Test
   public void badMethodsOnSupertype() {
     JavaFileObject testModule =
diff --git a/compiler/src/test/java/dagger/internal/codegen/MultibindsValidatorTest.java b/compiler/src/test/java/dagger/internal/codegen/MultibindsValidatorTest.java
new file mode 100644
index 000000000..e36006550
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/MultibindsValidatorTest.java
@@ -0,0 +1,167 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.common.collect.ImmutableList;
+import dagger.Module;
+import dagger.producers.ProducerModule;
+import java.lang.annotation.Annotation;
+import java.util.Collection;
+import javax.inject.Qualifier;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+import org.junit.runners.Parameterized.Parameters;
+
+import static dagger.internal.codegen.DaggerModuleMethodSubject.Factory.assertThatMethodInUnannotatedClass;
+import static dagger.internal.codegen.DaggerModuleMethodSubject.Factory.assertThatModuleMethod;
+
+@RunWith(Parameterized.class)
+public class MultibindsValidatorTest {
+
+  @Parameters(name = "{0}")
+  public static Collection<Object[]> parameters() {
+    return ImmutableList.copyOf(new Object[][] {{Module.class}, {ProducerModule.class}});
+  }
+
+  private final String moduleDeclaration;
+
+  public MultibindsValidatorTest(Class<? extends Annotation> moduleAnnotation) {
+    moduleDeclaration = "@" + moduleAnnotation.getCanonicalName() + " abstract class %s { %s }";
+  }
+
+  @Test
+  public void notWithinModule() {
+    assertThatMethodInUnannotatedClass("@Multibinds abstract Set<Object> emptySet();")
+        .hasError("@Multibinds methods can only be present within a @Module or @ProducerModule");
+  }
+
+  @Test
+  public void voidMethod() {
+    assertThatModuleMethod("@Multibinds abstract void voidMethod();")
+        .withDeclaration(moduleDeclaration)
+        .hasError("@Multibinds methods must return Map<K, V> or Set<T>");
+  }
+
+  @Test
+  public void primitiveMethod() {
+    assertThatModuleMethod("@Multibinds abstract int primitive();")
+        .withDeclaration(moduleDeclaration)
+        .hasError("@Multibinds methods must return Map<K, V> or Set<T>");
+  }
+
+  @Test
+  public void rawMap() {
+    assertThatModuleMethod("@Multibinds abstract Map rawMap();")
+        .withDeclaration(moduleDeclaration)
+        .hasError("@Multibinds methods must return Map<K, V> or Set<T>");
+  }
+
+  @Test
+  public void wildcardMap() {
+    assertThatModuleMethod("@Multibinds abstract Map<?, ?> wildcardMap();")
+        .withDeclaration(moduleDeclaration)
+        .hasError("@Multibinds methods must return Map<K, V> or Set<T>");
+  }
+
+  @Test
+  public void providerMap() {
+    assertThatModuleMethod("@Multibinds abstract Map<String, Provider<Object>> providerMap();")
+        .withDeclaration(moduleDeclaration)
+        .hasError("@Multibinds methods must return Map<K, V> or Set<T>");
+  }
+
+  @Test
+  public void producerMap() {
+    assertThatModuleMethod("@Multibinds abstract Map<String, Producer<Object>> producerMap();")
+        .withDeclaration(moduleDeclaration)
+        .hasError("@Multibinds methods must return Map<K, V> or Set<T>");
+  }
+
+  @Test
+  public void producedMap() {
+    assertThatModuleMethod("@Multibinds abstract Map<String, Produced<Object>> producedMap();")
+        .withDeclaration(moduleDeclaration)
+        .hasError("@Multibinds methods must return Map<K, V> or Set<T>");
+  }
+
+  @Test
+  public void rawSet() {
+    assertThatModuleMethod("@Multibinds abstract Set rawSet();")
+        .withDeclaration(moduleDeclaration)
+        .hasError("@Multibinds methods must return Map<K, V> or Set<T>");
+  }
+
+  @Test
+  public void wildcardSet() {
+    assertThatModuleMethod("@Multibinds abstract Set<?> wildcardSet();")
+        .withDeclaration(moduleDeclaration)
+        .hasError("@Multibinds methods must return Map<K, V> or Set<T>");
+  }
+
+  @Test
+  public void providerSet() {
+    assertThatModuleMethod("@Multibinds abstract Set<Provider<Object>> providerSet();")
+        .withDeclaration(moduleDeclaration)
+        .hasError("@Multibinds methods must return Map<K, V> or Set<T>");
+  }
+
+  @Test
+  public void producerSet() {
+    assertThatModuleMethod("@Multibinds abstract Set<Producer<Object>> producerSet();")
+        .withDeclaration(moduleDeclaration)
+        .hasError("@Multibinds methods must return Map<K, V> or Set<T>");
+  }
+
+  @Test
+  public void producedSet() {
+    assertThatModuleMethod("@Multibinds abstract Set<Produced<Object>> producedSet();")
+        .withDeclaration(moduleDeclaration)
+        .hasError("@Multibinds methods must return Map<K, V> or Set<T>");
+  }
+
+  @Test
+  public void overqualifiedSet() {
+    assertThatModuleMethod(
+            "@Multibinds @SomeQualifier @OtherQualifier "
+                + "abstract Set<Object> tooManyQualifiersSet();")
+        .withDeclaration(moduleDeclaration)
+        .importing(SomeQualifier.class, OtherQualifier.class)
+        .hasError("Cannot use more than one @Qualifier");
+  }
+
+  @Test
+  public void overqualifiedMap() {
+    assertThatModuleMethod(
+            "@Multibinds @SomeQualifier @OtherQualifier "
+                + "abstract Map<String, Object> tooManyQualifiersMap();")
+        .withDeclaration(moduleDeclaration)
+        .importing(SomeQualifier.class, OtherQualifier.class)
+        .hasError("Cannot use more than one @Qualifier");
+  }
+
+  @Test
+  public void hasParameters() {
+    assertThatModuleMethod("@Multibinds abstract Set<String> parameters(Object param);")
+        .hasError("@Multibinds methods cannot have parameters");
+  }
+
+  @Qualifier
+  public @interface SomeQualifier {}
+
+  @Qualifier
+  public @interface OtherQualifier {}
+}
diff --git a/core/src/main/java/dagger/multibindings/Multibinds.java b/core/src/main/java/dagger/multibindings/Multibinds.java
new file mode 100644
index 000000000..d41a4dc92
--- /dev/null
+++ b/core/src/main/java/dagger/multibindings/Multibinds.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.multibindings;
+
+import dagger.internal.Beta;
+import java.lang.annotation.Documented;
+import java.lang.annotation.Target;
+
+import static java.lang.annotation.ElementType.METHOD;
+
+@Documented
+@Target(METHOD)
+@Beta
+public @interface Multibinds {}
