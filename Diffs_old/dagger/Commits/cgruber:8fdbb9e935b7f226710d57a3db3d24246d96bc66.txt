diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
index c75acbeac..e3258e575 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -96,7 +96,7 @@ public synchronized void init(ProcessingEnvironment processingEnv) {
     ComponentGenerator componentGenerator = new ComponentGenerator(filer);
 
     DependencyRequest.Factory dependencyRequestFactory =
-        new DependencyRequest.Factory(elements, types, keyFactory);
+        new DependencyRequest.Factory(types, keyFactory);
     ProvisionBinding.Factory provisionBindingFactory =
         new ProvisionBinding.Factory(elements, types, keyFactory, dependencyRequestFactory);
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
index 6274a783c..0cf61d8f9 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
@@ -26,6 +26,8 @@
 import dagger.Lazy;
 import dagger.MembersInjector;
 import dagger.Provides;
+import dagger.producers.Produced;
+import dagger.producers.Producer;
 import java.util.List;
 import javax.inject.Inject;
 import javax.inject.Provider;
@@ -36,7 +38,6 @@
 import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeMirror;
-import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 
 import static com.google.common.base.Preconditions.checkArgument;
@@ -61,6 +62,10 @@
     LAZY,
     /** A request for a {@link MembersInjector}.  E.g.: {@code MembersInjector<Blah>} */
     MEMBERS_INJECTOR,
+    /** A request for a {@link Producer}.  E.g.: {@code Producer<Blah>} */
+    PRODUCER,
+    /** A request for a {@link Produced}.  E.g.: {@code Produced<Blah>} */
+    PRODUCED,
   }
 
   abstract Kind kind();
@@ -68,12 +73,10 @@
   abstract Element requestElement();
 
   static final class Factory {
-    private final Elements elements;
     private final Types types;
     private final Key.Factory keyFactory;
 
-    Factory(Elements elements, Types types, Key.Factory keyFactory) {
-      this.elements = elements;
+    Factory(Types types, Key.Factory keyFactory) {
       this.types = types;
       this.keyFactory = keyFactory;
     }
@@ -149,6 +152,14 @@ private DependencyRequest newDependencyRequest(Element requestElement, TypeMirro
         return new AutoValue_DependencyRequest(Kind.MEMBERS_INJECTOR,
             qualifiedTypeForParameter(qualifier, (DeclaredType) type),
             requestElement);
+      } else if (isTypeOf(Producer.class, type)) {
+        return new AutoValue_DependencyRequest(Kind.PRODUCER,
+            qualifiedTypeForParameter(qualifier, (DeclaredType) type),
+            requestElement);
+      } else if (isTypeOf(Produced.class, type)) {
+        return new AutoValue_DependencyRequest(Kind.PRODUCED,
+            qualifiedTypeForParameter(qualifier, (DeclaredType) type),
+            requestElement);
       } else {
         return new AutoValue_DependencyRequest(Kind.INSTANCE,
             keyFactory.forQualifiedType(qualifier, type),
diff --git a/compiler/src/main/java/dagger/internal/codegen/Key.java b/compiler/src/main/java/dagger/internal/codegen/Key.java
index 04576095b..d8b6ea5dc 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Key.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Key.java
@@ -21,8 +21,10 @@
 import com.google.common.base.MoreObjects;
 import com.google.common.base.Optional;
 import com.google.common.collect.Iterables;
+import com.google.common.util.concurrent.ListenableFuture;
 import dagger.MapKey;
 import dagger.Provides;
+import dagger.producers.Produces;
 import java.util.Map;
 import java.util.Set;
 import javax.inject.Provider;
@@ -177,6 +179,53 @@ Key forProvidesMethod(ExecutableElement e) {
       }
     }
 
+    // TODO(user): Reconcile this method with forProvidesMethod when Provides.Type and
+    // Produces.Type are no longer different.
+    Key forProducesMethod(ExecutableElement e) {
+      checkNotNull(e);
+      checkArgument(e.getKind().equals(METHOD));
+      Produces producesAnnotation = e.getAnnotation(Produces.class);
+      checkArgument(producesAnnotation != null);
+      TypeMirror returnType = normalize(e.getReturnType());
+      TypeMirror keyType = returnType;
+      if (MoreTypes.isTypeOf(ListenableFuture.class, returnType)) {
+        keyType = Iterables.getOnlyElement(MoreTypes.asDeclared(returnType).getTypeArguments());
+      }
+      switch (producesAnnotation.type()) {
+        case UNIQUE:
+          return new AutoValue_Key(
+              wrapOptionalInEquivalence(AnnotationMirrors.equivalence(), getQualifier(e)),
+              MoreTypes.equivalence().wrap(keyType));
+        case SET:
+          TypeMirror setType = types.getDeclaredType(getSetElement(), keyType);
+          return new AutoValue_Key(
+              wrapOptionalInEquivalence(AnnotationMirrors.equivalence(), getQualifier(e)),
+              MoreTypes.equivalence().wrap(setType));
+        case MAP:
+          AnnotationMirror mapKeyAnnotation = Iterables.getOnlyElement(getMapKeys(e));
+          MapKey mapKey =
+              mapKeyAnnotation.getAnnotationType().asElement().getAnnotation(MapKey.class);
+          TypeElement keyTypeElement =
+              mapKey.unwrapValue() ? Util.getKeyTypeElement(mapKeyAnnotation, elements)
+                  : (TypeElement) mapKeyAnnotation.getAnnotationType().asElement();
+          TypeMirror valueType = types.getDeclaredType(getProviderElement(), keyType);
+          TypeMirror mapType =
+              types.getDeclaredType(getMapElement(), keyTypeElement.asType(), valueType);
+          return new AutoValue_Key(
+              wrapOptionalInEquivalence(AnnotationMirrors.equivalence(), getQualifier(e)),
+              MoreTypes.equivalence().wrap(mapType));
+        case SET_VALUES:
+          // TODO(gak): do we want to allow people to use "covariant return" here?
+          checkArgument(keyType.getKind().equals(DECLARED));
+          checkArgument(((DeclaredType) keyType).asElement().equals(getSetElement()));
+          return new AutoValue_Key(
+              wrapOptionalInEquivalence(AnnotationMirrors.equivalence(), getQualifier(e)),
+              MoreTypes.equivalence().wrap(keyType));
+        default:
+          throw new AssertionError();
+      }
+    }
+
     Key forInjectConstructor(ExecutableElement e) {
       checkNotNull(e);
       checkArgument(e.getKind().equals(CONSTRUCTOR));
diff --git a/compiler/src/test/java/dagger/internal/codegen/FrameworkKeyTest.java b/compiler/src/test/java/dagger/internal/codegen/FrameworkKeyTest.java
index 472cdf0a2..c8fefcbb6 100644
--- a/compiler/src/test/java/dagger/internal/codegen/FrameworkKeyTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/FrameworkKeyTest.java
@@ -56,11 +56,10 @@
     this.types = compilationRule.getTypes();
     this.elements = compilationRule.getElements();
     this.keyFactory = new Key.Factory(types, elements);
-    this.dependencyRequestFactory = new DependencyRequest.Factory(elements, types, keyFactory);
+    this.dependencyRequestFactory = new DependencyRequest.Factory(types, keyFactory);
   }
 
   private List<? extends VariableElement> sampleProviderParameters() {
-    TypeMirror stringType = elements.getTypeElement(String.class.getCanonicalName()).asType();
     TypeElement moduleElement =
         elements.getTypeElement(ProvidesMethodModule.class.getCanonicalName());
     ExecutableElement providesMethod =
diff --git a/compiler/src/test/java/dagger/internal/codegen/KeyTest.java b/compiler/src/test/java/dagger/internal/codegen/KeyTest.java
index 41c3c60d1..02a85e3a4 100644
--- a/compiler/src/test/java/dagger/internal/codegen/KeyTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/KeyTest.java
@@ -19,9 +19,12 @@
 import com.google.common.base.Equivalence;
 import com.google.common.base.Optional;
 import com.google.common.collect.Iterables;
+import com.google.common.util.concurrent.ListenableFuture;
 import com.google.testing.compile.CompilationRule;
 import dagger.Module;
 import dagger.Provides;
+import dagger.producers.ProducerModule;
+import dagger.producers.Produces;
 import java.util.Set;
 import javax.inject.Inject;
 import javax.inject.Qualifier;
@@ -39,7 +42,7 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import static com.google.common.truth.Truth.assert_;
+import static com.google.common.truth.Truth.assertThat;
 import static dagger.Provides.Type.SET;
 import static dagger.Provides.Type.SET_VALUES;
 
@@ -65,7 +68,7 @@
         compilationRule.getElements().getTypeElement(InjectedClass.class.getCanonicalName());
     ExecutableElement constructor =
         Iterables.getOnlyElement(ElementFilter.constructorsIn(typeElement.getEnclosedElements()));
-    assert_().that(keyFactory.forInjectConstructor(constructor))
+    assertThat(keyFactory.forInjectConstructor(constructor))
         .isEqualTo(new AutoValue_Key(
             Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
             MoreTypes.equivalence().wrap(typeElement.asType())));
@@ -82,7 +85,7 @@
         elements.getTypeElement(ProvidesMethodModule.class.getCanonicalName());
     ExecutableElement providesMethod =
         Iterables.getOnlyElement(ElementFilter.methodsIn(moduleElement.getEnclosedElements()));
-    assert_().that(keyFactory.forProvidesMethod(providesMethod))
+    assertThat(keyFactory.forProvidesMethod(providesMethod))
         .isEqualTo(new AutoValue_Key(
             Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
             MoreTypes.equivalence().wrap(stringType)));
@@ -104,9 +107,9 @@
     ExecutableElement providesMethod =
         Iterables.getOnlyElement(ElementFilter.methodsIn(moduleElement.getEnclosedElements()));
     Key key = keyFactory.forProvidesMethod(providesMethod);
-    assert_().that(MoreTypes.equivalence().wrap(key.qualifier().get().getAnnotationType()))
+    assertThat(MoreTypes.equivalence().wrap(key.qualifier().get().getAnnotationType()))
         .isEqualTo(MoreTypes.equivalence().wrap(qualifierElement.asType()));
-    assert_().that(key.wrappedType()).isEqualTo(MoreTypes.equivalence().wrap(stringType));
+    assertThat(key.wrappedType()).isEqualTo(MoreTypes.equivalence().wrap(stringType));
   }
 
   @Test public void qualifiedKeyEquivalents() {
@@ -124,7 +127,7 @@
     AnnotationMirror qualifier = Iterables.getOnlyElement(injectionField.getAnnotationMirrors());
     Key injectionKey = keyFactory.forQualifiedType(Optional.<AnnotationMirror>of(qualifier), type);
 
-    assert_().that(provisionKey).isEqualTo(injectionKey);
+    assertThat(provisionKey).isEqualTo(injectionKey);
   }
 
   @Module(library = true)
@@ -155,7 +158,7 @@ String provideQualifiedString() {
         elements.getTypeElement(SetProvidesMethodsModule.class.getCanonicalName());
     for (ExecutableElement providesMethod
         : ElementFilter.methodsIn(moduleElement.getEnclosedElements())) {
-      assert_().that(keyFactory.forProvidesMethod(providesMethod))
+      assertThat(keyFactory.forProvidesMethod(providesMethod))
           .isEqualTo(new AutoValue_Key(
               Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
               MoreTypes.equivalence().wrap(setOfStringsType)));
@@ -198,13 +201,72 @@ String provideQualifiedString() {
 
     // TODO(user): Truth subject for TypeMirror and TypeElement
     TypeMirror intType = intMethod.getReturnType();
-    assert_().that(intType.getKind().isPrimitive()).isTrue();
+    assertThat(intType.getKind().isPrimitive()).isTrue();
     TypeMirror integerType = integerMethod.getReturnType();
-    assert_().that(integerType.getKind().isPrimitive()).isFalse();
-    assert_().that(types.isSameType(intType, integerType)).named("type equality").isFalse();
+    assertThat(integerType.getKind().isPrimitive()).isFalse();
+    assertThat(types.isSameType(intType, integerType)).named("type equality").isFalse();
 
     Key intKey = keyFactory.forProvidesMethod(intMethod);
     Key integerKey = keyFactory.forProvidesMethod(integerMethod);
-    assert_().that(intKey).isEqualTo(integerKey);
+    assertThat(intKey).isEqualTo(integerKey);
+  }
+
+  @Test public void forProducesMethod() {
+    TypeMirror stringType = elements.getTypeElement(String.class.getCanonicalName()).asType();
+    TypeElement moduleElement =
+        elements.getTypeElement(ProducesMethodsModule.class.getCanonicalName());
+    for (ExecutableElement producesMethod
+        : ElementFilter.methodsIn(moduleElement.getEnclosedElements())) {
+      assertThat(keyFactory.forProducesMethod(producesMethod))
+          .isEqualTo(new AutoValue_Key(
+                  Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
+                  MoreTypes.equivalence().wrap(stringType)));
+    }
+  }
+
+  @ProducerModule
+  static final class ProducesMethodsModule {
+    @Produces String produceString() {
+      return null;
+    }
+
+    @Produces ListenableFuture<String> produceFutureString() {
+      return null;
+    }
+  }
+
+  @Test public void forProducesMethod_sets() {
+    TypeElement setElement = elements.getTypeElement(Set.class.getCanonicalName());
+    TypeMirror stringType = elements.getTypeElement(String.class.getCanonicalName()).asType();
+    TypeMirror setOfStringsType = types.getDeclaredType(setElement, stringType);
+    TypeElement moduleElement =
+        elements.getTypeElement(SetProducesMethodsModule.class.getCanonicalName());
+    for (ExecutableElement producesMethod
+        : ElementFilter.methodsIn(moduleElement.getEnclosedElements())) {
+      assertThat(keyFactory.forProducesMethod(producesMethod))
+          .isEqualTo(new AutoValue_Key(
+                  Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
+                  MoreTypes.equivalence().wrap(setOfStringsType)));
+    }
+  }
+
+  @ProducerModule
+  static final class SetProducesMethodsModule {
+    @Produces(type = Produces.Type.SET) String produceString() {
+      return null;
+    }
+
+    @Produces(type = Produces.Type.SET) ListenableFuture<String> produceFutureString() {
+      return null;
+    }
+
+    @Produces(type = Produces.Type.SET_VALUES) Set<String> produceStrings() {
+      return null;
+    }
+
+    @Produces(type = Produces.Type.SET_VALUES)
+    ListenableFuture<Set<String>> produceFutureStrings() {
+      return null;
+    }
   }
 }
