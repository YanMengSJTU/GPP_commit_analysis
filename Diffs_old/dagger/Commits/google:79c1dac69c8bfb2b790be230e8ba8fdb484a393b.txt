diff --git a/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
index e1cbc85d6..22613b440 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
@@ -26,11 +26,10 @@
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
 import com.squareup.javapoet.MethodSpec;
+import com.squareup.javapoet.ParameterizedTypeName;
 import com.squareup.javapoet.TypeName;
 import com.squareup.javapoet.TypeSpec;
 import dagger.producers.Producer;
-import dagger.producers.monitoring.ProducerMonitor;
-import java.util.List;
 import javax.annotation.processing.Filer;
 import javax.lang.model.element.Element;
 import javax.lang.model.type.TypeMirror;
@@ -42,7 +41,6 @@
 import static com.squareup.javapoet.TypeSpec.classBuilder;
 import static dagger.internal.codegen.AnnotationSpecs.SUPPRESS_WARNINGS_UNCHECKED;
 import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
-import static dagger.internal.codegen.CodeBlocks.toCodeBlocks;
 import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
 import static dagger.internal.codegen.SourceFiles.generatedClassNameForBinding;
 import static dagger.internal.codegen.TypeNames.ASYNC_FUNCTION;
@@ -119,8 +117,7 @@ ClassName nameGeneratedType(ProductionBinding binding) {
         methodBuilder("compute")
             .returns(futureTypeName)
             .addAnnotation(Override.class)
-            .addModifiers(PROTECTED)
-            .addParameter(ProducerMonitor.class, "monitor", FINAL);
+            .addModifiers(PROTECTED);
 
     ImmutableList<DependencyRequest> asyncDependencies = asyncDependencies(binding);
     for (DependencyRequest dependency : asyncDependencies) {
@@ -136,38 +133,42 @@ ClassName nameGeneratedType(ProductionBinding binding) {
               : futureAccess);
     }
     FutureTransform futureTransform = FutureTransform.create(fields, binding, asyncDependencies);
-    CodeBlock transformCodeBlock =
-        CodeBlock.of(
-            Joiner.on('\n')
-                .join(
-                    "new $1T<$2T, $3T>() {",
-                    "  $4L",
-                    "  @Override public $5T apply($2T $6L) $7L {",
-                    "    $8L",
-                    "  }",
-                    "}"),
-            ASYNC_FUNCTION,
-            futureTransform.applyArgType(),
-            providedTypeName,
-            futureTransform.hasUncheckedCast()
-                ? CodeBlock.of("$L // safe by specification", SUPPRESS_WARNINGS_UNCHECKED)
-                : "",
-            futureTypeName,
-            futureTransform.applyArgName(),
-            getThrowsClause(binding.thrownTypes()),
-            getInvocationCodeBlock(
-                generatedTypeName,
-                binding,
-                providedTypeName,
-                futureTransform.parameterCodeBlocks()));
+
     computeMethodBuilder.addStatement(
-        "return $T.transformAsync($L, $L, executorProvider.get())",
+        "return $T.transformAsync($L, this, executorProvider.get())",
         FUTURES,
-        futureTransform.futureCodeBlock(),
-        transformCodeBlock);
+        futureTransform.futureCodeBlock());
+
+    factoryBuilder.addSuperinterface(
+        ParameterizedTypeName.get(
+            ASYNC_FUNCTION, futureTransform.applyArgType(), providedTypeName));
+
+    MethodSpec.Builder applyMethodBuilder =
+        methodBuilder("apply")
+            .returns(futureTypeName)
+            .addJavadoc("@deprecated this may only be called from the internal {@link #compute()}")
+            .addAnnotation(Deprecated.class)
+            .addAnnotation(Override.class)
+            .addModifiers(PUBLIC)
+            .addParameter(futureTransform.applyArgType(), futureTransform.applyArgName())
+            .addExceptions(getThrownTypeNames(binding.thrownTypes()))
+            .addStatement(
+                "assert monitor != null : $S",
+                "apply() may only be called internally from compute(); "
+                    + "if it's called explicitly, the monitor might be null")
+            .addCode(
+                getInvocationCodeBlock(
+                    generatedTypeName,
+                    binding,
+                    providedTypeName,
+                    futureTransform.parameterCodeBlocks()));
+    if (futureTransform.hasUncheckedCast()) {
+      applyMethodBuilder.addAnnotation(SUPPRESS_WARNINGS_UNCHECKED);
+    }
 
     factoryBuilder.addMethod(constructorBuilder.build());
     factoryBuilder.addMethod(computeMethodBuilder.build());
+    factoryBuilder.addMethod(applyMethodBuilder.build());
 
     // TODO(gak): write a sensible toString
     return Optional.of(factoryBuilder);
@@ -486,14 +487,19 @@ private CodeBlock getInvocationCodeBlock(
   }
 
   /**
-   * Creates a CodeBlock for the throws clause.
+   * Converts the list of thrown types into type names.
    *
    * @param thrownTypes the list of thrown types.
    */
-  private CodeBlock getThrowsClause(List<? extends TypeMirror> thrownTypes) {
-    if (thrownTypes.isEmpty()) {
-      return CodeBlock.of("");
-    }
-    return CodeBlock.of("throws $L", makeParametersCodeBlock(toCodeBlocks(thrownTypes)));
+  private FluentIterable<? extends TypeName> getThrownTypeNames(
+      Iterable<? extends TypeMirror> thrownTypes) {
+    return FluentIterable.from(thrownTypes)
+        .transform(
+            new Function<TypeMirror, TypeName>() {
+              @Override
+              public TypeName apply(TypeMirror type) {
+                return TypeName.get(type);
+              }
+            });
   }
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java b/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
index 59e50536a..4b9f17869 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
@@ -358,7 +358,6 @@ public void publicModuleNonPublicIncludes() {
             "import com.google.common.util.concurrent.Futures;",
             "import com.google.common.util.concurrent.ListenableFuture;",
             "import dagger.producers.internal.AbstractProducer;",
-            "import dagger.producers.monitoring.ProducerMonitor;",
             "import dagger.producers.monitoring.ProducerToken;",
             "import dagger.producers.monitoring.ProductionComponentMonitor;",
             "import java.util.concurrent.Executor;",
@@ -366,7 +365,8 @@ public void publicModuleNonPublicIncludes() {
             "import javax.inject.Provider;",
             "",
             GENERATED_ANNOTATION,
-            "public final class TestModule_ProduceStringFactory extends AbstractProducer<String> {",
+            "public final class TestModule_ProduceStringFactory",
+            "    extends AbstractProducer<String> implements AsyncFunction<Void, String> {",
             "  private final TestModule module;",
             "  private final Provider<Executor> executorProvider;",
             "  private final Provider<ProductionComponentMonitor> monitorProvider;",
@@ -386,20 +386,22 @@ public void publicModuleNonPublicIncludes() {
             "    this.monitorProvider = monitorProvider;",
             "  }",
             "",
-            "  @Override protected ListenableFuture<String> compute(",
-            "      final ProducerMonitor monitor) {",
+            "  @Override protected ListenableFuture<String> compute() {",
             "    return Futures.transformAsync(",
-            "      Futures.<Void>immediateFuture(null),",
-            "      new AsyncFunction<Void, String>() {",
-            "        @Override public ListenableFuture<String> apply(Void ignoredVoidArg) {",
-            "          monitor.methodStarting();",
-            "          try {",
-            "            return TestModule_ProduceStringFactory.this.module.produceString();",
-            "          } finally {",
-            "            monitor.methodFinished();",
-            "          }",
-            "        }",
-            "      }, executorProvider.get());",
+            "        Futures.<Void>immediateFuture(null), this, executorProvider.get());",
+            "  }",
+            "",
+            "  @Deprecated",
+            "  @Override public ListenableFuture<String> apply(Void ignoredVoidArg) {",
+            "    assert monitor != null :",
+            "        \"apply() may only be called internally from compute(); \"",
+            "        + \"if it's called explicitly, the monitor might be null\";",
+            "    monitor.methodStarting();",
+            "    try {",
+            "      return TestModule_ProduceStringFactory.this.module.produceString();",
+            "    } finally {",
+            "      monitor.methodFinished();",
+            "    }",
             "  }",
             "}");
     assertAbout(javaSource())
@@ -437,7 +439,6 @@ public void singleProducesMethodNoArgsFutureWithProducerName() {
             "import com.google.common.util.concurrent.Futures;",
             "import com.google.common.util.concurrent.ListenableFuture;",
             "import dagger.producers.internal.AbstractProducer;",
-            "import dagger.producers.monitoring.ProducerMonitor;",
             "import dagger.producers.monitoring.ProducerToken;",
             "import dagger.producers.monitoring.ProductionComponentMonitor;",
             "import java.util.concurrent.Executor;",
@@ -445,7 +446,8 @@ public void singleProducesMethodNoArgsFutureWithProducerName() {
             "import javax.inject.Provider;",
             "",
             GENERATED_ANNOTATION,
-            "public final class TestModule_ProduceStringFactory extends AbstractProducer<String> {",
+            "public final class TestModule_ProduceStringFactory",
+            "    extends AbstractProducer<String> implements AsyncFunction<Void, String> {",
             "  private final TestModule module;",
             "  private final Provider<Executor> executorProvider;",
             "  private final Provider<ProductionComponentMonitor> monitorProvider;",
@@ -465,20 +467,22 @@ public void singleProducesMethodNoArgsFutureWithProducerName() {
             "    this.monitorProvider = monitorProvider;",
             "  }",
             "",
-            "  @Override protected ListenableFuture<String> compute(",
-            "      final ProducerMonitor monitor) {",
+            "  @Override protected ListenableFuture<String> compute() {",
             "    return Futures.transformAsync(",
-            "      Futures.<Void>immediateFuture(null),",
-            "      new AsyncFunction<Void, String>() {",
-            "        @Override public ListenableFuture<String> apply(Void ignoredVoidArg) {",
-            "          monitor.methodStarting();",
-            "          try {",
-            "            return TestModule_ProduceStringFactory.this.module.produceString();",
-            "          } finally {",
-            "            monitor.methodFinished();",
-            "          }",
-            "        }",
-            "      }, executorProvider.get());",
+            "      Futures.<Void>immediateFuture(null), this, executorProvider.get());",
+            "  }",
+            "",
+            "  @Deprecated",
+            "  @Override public ListenableFuture<String> apply(Void ignoredVoidArg) {",
+            "    assert monitor != null :",
+            "        \"apply() may only be called internally from compute(); \"",
+            "        + \"if it's called explicitly, the monitor might be null\";",
+            "    monitor.methodStarting();",
+            "    try {",
+            "      return TestModule_ProduceStringFactory.this.module.produceString();",
+            "    } finally {",
+            "      monitor.methodFinished();",
+            "    }",
             "  }",
             "}");
     assertAbout(javaSource())
diff --git a/producers/src/main/java/dagger/producers/internal/AbstractProducer.java b/producers/src/main/java/dagger/producers/internal/AbstractProducer.java
index 8c4fe0b40..85a973370 100644
--- a/producers/src/main/java/dagger/producers/internal/AbstractProducer.java
+++ b/producers/src/main/java/dagger/producers/internal/AbstractProducer.java
@@ -37,6 +37,7 @@
   private final Provider<ProductionComponentMonitor> monitorProvider;
   @Nullable private final ProducerToken token;
   private volatile ListenableFuture<T> instance = null;
+  protected volatile ProducerMonitor monitor = null;
 
   protected AbstractProducer() {
     this(Monitors.noOpProductionComponentMonitorProvider(), null);
@@ -48,8 +49,11 @@ protected AbstractProducer(
     this.token = token;
   }
 
-  /** Computes this producer's future, which is then cached in {@link #get}. */
-  protected abstract ListenableFuture<T> compute(ProducerMonitor monitor);
+  /**
+   * Computes this producer's future, which is then cached in {@link #get}. The {@link #monitor}
+   * will be non-null from the point of this call forward.
+   */
+  protected abstract ListenableFuture<T> compute();
 
   @Override
   public final ListenableFuture<T> get() {
@@ -59,9 +63,9 @@ protected AbstractProducer(
       synchronized (this) {
         result = instance;
         if (result == null) {
-          ProducerMonitor monitor = monitorProvider.get().producerMonitorFor(token);
+          monitor = monitorProvider.get().producerMonitorFor(token);
           monitor.requested();
-          instance = result = compute(monitor);
+          instance = result = compute();
           if (result == null) {
             throw new NullPointerException("compute returned null");
           }
diff --git a/producers/src/main/java/dagger/producers/internal/MapOfProducedProducer.java b/producers/src/main/java/dagger/producers/internal/MapOfProducedProducer.java
index a0ba0c51a..f55194fec 100644
--- a/producers/src/main/java/dagger/producers/internal/MapOfProducedProducer.java
+++ b/producers/src/main/java/dagger/producers/internal/MapOfProducedProducer.java
@@ -25,7 +25,6 @@
 import dagger.internal.Beta;
 import dagger.producers.Produced;
 import dagger.producers.Producer;
-import dagger.producers.monitoring.ProducerMonitor;
 import java.util.List;
 import java.util.Map;
 
@@ -62,7 +61,7 @@ private MapOfProducedProducer(Producer<Map<K, Producer<V>>> mapProducerProducer)
   }
 
   @Override
-  public ListenableFuture<Map<K, Produced<V>>> compute(ProducerMonitor unusedMonitor) {
+  public ListenableFuture<Map<K, Produced<V>>> compute() {
     return Futures.transformAsync(
         mapProducerProducer.get(),
         new AsyncFunction<Map<K, Producer<V>>, Map<K, Produced<V>>>() {
diff --git a/producers/src/main/java/dagger/producers/internal/MapOfProducerProducer.java b/producers/src/main/java/dagger/producers/internal/MapOfProducerProducer.java
index 013266f2d..0424a68d5 100644
--- a/producers/src/main/java/dagger/producers/internal/MapOfProducerProducer.java
+++ b/producers/src/main/java/dagger/producers/internal/MapOfProducerProducer.java
@@ -20,7 +20,6 @@
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.internal.Beta;
 import dagger.producers.Producer;
-import dagger.producers.monitoring.ProducerMonitor;
 import java.util.Map;
 
 import static com.google.common.base.Preconditions.checkNotNull;
@@ -55,7 +54,7 @@ private MapOfProducerProducer(ImmutableMap<K, Producer<V>> contributingMap) {
   }
 
   @Override
-  public ListenableFuture<Map<K, Producer<V>>> compute(ProducerMonitor unusedMonitor) {
+  public ListenableFuture<Map<K, Producer<V>>> compute() {
     return Futures.<Map<K, Producer<V>>>immediateFuture(contributingMap);
   }
 
diff --git a/producers/src/main/java/dagger/producers/internal/MapProducer.java b/producers/src/main/java/dagger/producers/internal/MapProducer.java
index 61b7cfdbd..6897959f7 100644
--- a/producers/src/main/java/dagger/producers/internal/MapProducer.java
+++ b/producers/src/main/java/dagger/producers/internal/MapProducer.java
@@ -24,7 +24,6 @@
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.internal.Beta;
 import dagger.producers.Producer;
-import dagger.producers.monitoring.ProducerMonitor;
 import java.util.List;
 import java.util.Map;
 
@@ -58,7 +57,7 @@ private MapProducer(Producer<Map<K, Producer<V>>> mapProducerProducer) {
   }
 
   @Override
-  public ListenableFuture<Map<K, V>> compute(ProducerMonitor unusedMonitor) {
+  public ListenableFuture<Map<K, V>> compute() {
     return Futures.transformAsync(
         mapProducerProducer.get(),
         new AsyncFunction<Map<K, Producer<V>>, Map<K, V>>() {
diff --git a/producers/src/main/java/dagger/producers/internal/Producers.java b/producers/src/main/java/dagger/producers/internal/Producers.java
index 499de2a50..17e5cb68a 100644
--- a/producers/src/main/java/dagger/producers/internal/Producers.java
+++ b/producers/src/main/java/dagger/producers/internal/Producers.java
@@ -22,7 +22,6 @@
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.producers.Produced;
 import dagger.producers.Producer;
-import dagger.producers.monitoring.ProducerMonitor;
 import java.util.Set;
 import javax.inject.Provider;
 
@@ -96,7 +95,7 @@
     checkNotNull(provider);
     return new AbstractProducer<T>() {
       @Override
-      protected ListenableFuture<T> compute(ProducerMonitor unusedMonitor) {
+      protected ListenableFuture<T> compute() {
         return Futures.immediateFuture(provider.get());
       }
     };
diff --git a/producers/src/main/java/dagger/producers/internal/SetOfProducedProducer.java b/producers/src/main/java/dagger/producers/internal/SetOfProducedProducer.java
index 39712fac6..ef3d763fa 100644
--- a/producers/src/main/java/dagger/producers/internal/SetOfProducedProducer.java
+++ b/producers/src/main/java/dagger/producers/internal/SetOfProducedProducer.java
@@ -21,7 +21,6 @@
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.producers.Produced;
 import dagger.producers.Producer;
-import dagger.producers.monitoring.ProducerMonitor;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Set;
@@ -111,7 +110,7 @@ private SetOfProducedProducer(
    * @throws NullPointerException if any of the delegate producers return null
    */
   @Override
-  public ListenableFuture<Set<Produced<T>>> compute(ProducerMonitor unusedMonitor) {
+  public ListenableFuture<Set<Produced<T>>> compute() {
     List<ListenableFuture<Produced<Set<T>>>> futureProducedSets =
         new ArrayList<ListenableFuture<Produced<Set<T>>>>(
             individualProducers.size() + setProducers.size());
diff --git a/producers/src/main/java/dagger/producers/internal/SetProducer.java b/producers/src/main/java/dagger/producers/internal/SetProducer.java
index b9189d29a..b2e8506f7 100644
--- a/producers/src/main/java/dagger/producers/internal/SetProducer.java
+++ b/producers/src/main/java/dagger/producers/internal/SetProducer.java
@@ -20,7 +20,6 @@
 import com.google.common.util.concurrent.Futures;
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.producers.Producer;
-import dagger.producers.monitoring.ProducerMonitor;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Set;
@@ -117,7 +116,7 @@ private SetProducer(
    * @throws NullPointerException if any of the delegate producers return null
    */
   @Override
-  public ListenableFuture<Set<T>> compute(ProducerMonitor unusedMonitor) {
+  public ListenableFuture<Set<T>> compute() {
     List<ListenableFuture<T>> individualFutures =
         new ArrayList<ListenableFuture<T>>(individualProducers.size());
     for (Producer<T> producer : individualProducers) {
diff --git a/producers/src/test/java/dagger/producers/internal/AbstractProducerTest.java b/producers/src/test/java/dagger/producers/internal/AbstractProducerTest.java
index 8bb8b7574..5169a1bc2 100644
--- a/producers/src/test/java/dagger/producers/internal/AbstractProducerTest.java
+++ b/producers/src/test/java/dagger/producers/internal/AbstractProducerTest.java
@@ -79,7 +79,7 @@ public void get_nullPointerException() {
           int i = 0;
 
           @Override
-          public ListenableFuture<Integer> compute(ProducerMonitor unusedMonitor) {
+          public ListenableFuture<Integer> compute() {
             return Futures.immediateFuture(i++);
           }
         };
@@ -144,7 +144,8 @@ public void monitor_null() throws Exception {
     }
 
     @Override
-    public ListenableFuture<T> compute(ProducerMonitor unusedMonitor) {
+    public ListenableFuture<T> compute() {
+      assertThat(monitor).isNotNull();
       return delegate;
     }
   }
