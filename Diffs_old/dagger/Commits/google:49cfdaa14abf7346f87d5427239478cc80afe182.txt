diff --git a/java/dagger/internal/codegen/BUILD b/java/dagger/internal/codegen/BUILD
index d71da3408..629a81cfd 100644
--- a/java/dagger/internal/codegen/BUILD
+++ b/java/dagger/internal/codegen/BUILD
@@ -203,6 +203,7 @@ java_library(
     srcs = [
         "BindingGraphValidationModule.java",
         "NonNullableRequestForNullableBindingValidation.java",
+        "ProviderDependsOnProducerValidation.java",
         "Validation.java",
     ],
     deps = CODEGEN_DEPS + [
diff --git a/java/dagger/internal/codegen/BindingGraphValidationModule.java b/java/dagger/internal/codegen/BindingGraphValidationModule.java
index 20364bf42..c2049da92 100644
--- a/java/dagger/internal/codegen/BindingGraphValidationModule.java
+++ b/java/dagger/internal/codegen/BindingGraphValidationModule.java
@@ -29,4 +29,9 @@
   @IntoSet
   @Validation
   BindingGraphPlugin nullable(NonNullableRequestForNullableBindingValidation validation);
+
+  @Binds
+  @IntoSet
+  @Validation
+  BindingGraphPlugin providerDependsOnProducer(ProviderDependsOnProducerValidation validation);
 }
diff --git a/java/dagger/internal/codegen/BindingGraphValidator.java b/java/dagger/internal/codegen/BindingGraphValidator.java
index 6328486c3..8d18df36d 100644
--- a/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -25,8 +25,9 @@
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Verify.verify;
 import static com.google.common.collect.Iterables.getOnlyElement;
-import static dagger.internal.codegen.BindingType.PRODUCTION;
+import static dagger.internal.codegen.BindingType.PROVISION;
 import static dagger.internal.codegen.ComponentRequirement.Kind.BOUND_INSTANCE;
+import static dagger.internal.codegen.ComponentRequirement.Kind.MODULE;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentAnnotation;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
 import static dagger.internal.codegen.ContributionBinding.indexMapBindingsByAnnotationType;
@@ -44,8 +45,6 @@
 import static dagger.internal.codegen.ErrorMessages.MEMBERS_INJECTION_WITH_RAW_TYPE;
 import static dagger.internal.codegen.ErrorMessages.MEMBERS_INJECTION_WITH_UNBOUNDED_TYPE;
 import static dagger.internal.codegen.ErrorMessages.MULTIPLE_CONTRIBUTION_TYPES_FOR_KEY_FORMAT;
-import static dagger.internal.codegen.ErrorMessages.PROVIDER_ENTRY_POINT_MAY_NOT_DEPEND_ON_PRODUCER_FORMAT;
-import static dagger.internal.codegen.ErrorMessages.PROVIDER_MAY_NOT_DEPEND_ON_PRODUCER_FORMAT;
 import static dagger.internal.codegen.ErrorMessages.REQUIRES_AT_INJECT_CONSTRUCTOR_OR_PROVIDER_FORMAT;
 import static dagger.internal.codegen.ErrorMessages.REQUIRES_AT_INJECT_CONSTRUCTOR_OR_PROVIDER_OR_PRODUCER_FORMAT;
 import static dagger.internal.codegen.ErrorMessages.REQUIRES_PROVIDER_FORMAT;
@@ -59,6 +58,7 @@
 import static dagger.internal.codegen.Keys.isValidImplicitProvisionKey;
 import static dagger.internal.codegen.Keys.isValidMembersInjectionKey;
 import static dagger.internal.codegen.MoreAnnotationMirrors.getTypeValue;
+import static dagger.internal.codegen.RequestKinds.entryPointCanUseProduction;
 import static dagger.internal.codegen.RequestKinds.extractKeyType;
 import static dagger.internal.codegen.RequestKinds.getRequestKind;
 import static dagger.internal.codegen.Scopes.getReadableSource;
@@ -69,6 +69,7 @@
 import static dagger.model.BindingKind.INJECTION;
 import static dagger.model.BindingKind.MEMBERS_INJECTOR;
 import static dagger.model.BindingKind.MULTIBOUND_MAP;
+import static java.util.function.Predicate.isEqual;
 import static java.util.stream.Collectors.groupingBy;
 import static java.util.stream.Collectors.joining;
 import static java.util.stream.Collectors.mapping;
@@ -78,7 +79,6 @@
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.common.base.Equivalence;
-import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableListMultimap;
 import com.google.common.collect.ImmutableSet;
@@ -98,6 +98,7 @@
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
 import dagger.internal.codegen.ComponentRequirement.NullPolicy;
 import dagger.internal.codegen.ContributionType.HasContributionType;
+import dagger.internal.codegen.ErrorMessages.ComponentBuilderMessages;
 import dagger.model.BindingKind;
 import dagger.model.DependencyRequest;
 import dagger.model.Key;
@@ -222,9 +223,7 @@ protected void visitSubcomponentFactoryMethod(
           graph
               .componentRequirements()
               .stream()
-              .filter(
-                  componentRequirement ->
-                      componentRequirement.kind().equals(ComponentRequirement.Kind.MODULE))
+              .filter(componentRequirement -> componentRequirement.kind().equals(MODULE))
               .map(ComponentRequirement::typeElement)
               .filter(
                   moduleType ->
@@ -399,7 +398,7 @@ private void validateBuilders(BindingGraph graph) {
               .map(BuilderRequirementMethod::requirement)
               .collect(toImmutableSet());
 
-      ErrorMessages.ComponentBuilderMessages msgs =
+      ComponentBuilderMessages msgs =
           ErrorMessages.builderMsgsFor(graph.componentDescriptor().kind());
       Set<ComponentRequirement> extraSetters =
           Sets.difference(declaredRequirements, availableDependencies);
@@ -634,9 +633,6 @@ protected void visitContributionBinding(
             report(currentGraph()).addSubreport(report);
           }
         }
-        if (binding.bindingType().equals(PRODUCTION) && doesPathRequireProvisionOnly()) {
-          reportProviderMayNotDependOnProducer(binding);
-        }
         if (compilerOptions.usesProducers()) {
           // TODO(dpb,beder): Validate this during @Inject/@Provides/@Produces validation.
           // Only the Dagger-specific binding may depend on the production executor.
@@ -848,22 +844,6 @@ public Boolean visitDeclared(DeclaredType t, Void p) {
             }
           };
 
-      // TODO(b/29509141): Clarify the error.
-      private void reportProviderMayNotDependOnProducer(ContributionBinding productionBinding) {
-        if (atEntryPoint()) {
-          reportErrorAtEntryPoint(
-              PROVIDER_ENTRY_POINT_MAY_NOT_DEPEND_ON_PRODUCER_FORMAT,
-              formatCurrentDependencyRequestKey());
-        } else {
-          // TODO(beder): Consider displaying all dependent provisions in the error message. If we
-          // do that, should we display all productions that depend on them also?
-          reportErrorAtEntryPoint(
-              owningGraph(provisionsDependingOnLatestRequest().append(productionBinding)),
-              PROVIDER_MAY_NOT_DEPEND_ON_PRODUCER_FORMAT,
-              provisionsDependingOnLatestRequest().iterator().next().key());
-        }
-      }
-
       /**
        * Descriptive portion of the error message for when the given request has no binding.
        * Currently, the only other portions of the message are the dependency path, line number and
@@ -876,15 +856,15 @@ private StringBuilder requiresErrorMessageBase() {
         if (key.type().getKind().equals(TypeKind.WILDCARD)) {
           requiresErrorMessageFormat = CANNOT_INJECT_WILDCARD_TYPE;
         } else {
-          boolean requiresProvision = doesPathRequireProvisionOnly();
+          boolean canUseProduction = dependencyRequestCanUseProduction();
           if (!isValidImplicitProvisionKey(key, types)) {
             requiresErrorMessageFormat =
-                requiresProvision ? REQUIRES_PROVIDER_FORMAT : REQUIRES_PROVIDER_OR_PRODUCER_FORMAT;
+                canUseProduction ? REQUIRES_PROVIDER_OR_PRODUCER_FORMAT : REQUIRES_PROVIDER_FORMAT;
           } else {
             requiresErrorMessageFormat =
-                requiresProvision
-                    ? REQUIRES_AT_INJECT_CONSTRUCTOR_OR_PROVIDER_FORMAT
-                    : REQUIRES_AT_INJECT_CONSTRUCTOR_OR_PROVIDER_OR_PRODUCER_FORMAT;
+                canUseProduction
+                    ? REQUIRES_AT_INJECT_CONSTRUCTOR_OR_PROVIDER_OR_PRODUCER_FORMAT
+                    : REQUIRES_AT_INJECT_CONSTRUCTOR_OR_PROVIDER_FORMAT;
           }
         }
         StringBuilder errorMessage =
@@ -1140,41 +1120,21 @@ private boolean breaksCycle(TypeMirror requestedType, RequestKind requestKind) {
       }
 
       /**
-       * Returns whether the given dependency path would require the most recent request to be
-       * resolved by only provision bindings.
+       * Returns true if the current dependency request can be satisfied by a production binding.
        */
-      private boolean doesPathRequireProvisionOnly() {
-        // The second-most-recent bindings determine whether the most recent one must be a
-        // provision.
-        if (!atEntryPoint()) {
-          return !provisionsDependingOnLatestRequest().isEmpty();
-        }
-
-        // Check the request kind for entry points.
-        switch (dependencyRequest().kind()) {
-          case INSTANCE:
-          case PROVIDER:
-          case LAZY:
-          case MEMBERS_INJECTION:
-            return true;
-          case PRODUCER:
-          case PRODUCED:
-          case FUTURE:
-            return false;
-          default:
-            throw new AssertionError();
+      private boolean dependencyRequestCanUseProduction() {
+        if (atEntryPoint()) {
+          return entryPointCanUseProduction(dependencyRequest().kind());
+        } else {
+          // The current request can be satisfied by a production binding if it's not from a
+          // provision binding
+          return !hasDependentProvisionBindings();
         }
       }
 
-      /**
-       * Returns any provision bindings resolved for the second-most-recent request in the given
-       * path; that is, returns those provision bindings that depend on the latest request in the
-       * path.
-       */
-      private FluentIterable<ContributionBinding> provisionsDependingOnLatestRequest() {
-        return FluentIterable.from(dependentBindings())
-            .filter(ContributionBinding.class)
-            .filter(binding -> binding.bindingType().equals(BindingType.PROVISION));
+      /** Returns {@code true} if any provision bindings contain the latest request in the path. */
+      private boolean hasDependentProvisionBindings() {
+        return dependentBindings().stream().map(Binding::bindingType).anyMatch(isEqual(PROVISION));
       }
 
       private String formatCurrentDependencyRequestKey() {
diff --git a/java/dagger/internal/codegen/ErrorMessages.java b/java/dagger/internal/codegen/ErrorMessages.java
index ef164712d..54604e34b 100644
--- a/java/dagger/internal/codegen/ErrorMessages.java
+++ b/java/dagger/internal/codegen/ErrorMessages.java
@@ -253,12 +253,6 @@ static String inconsistentMapKeyAnnotationsError(String key) {
   static final String MULTIPLE_CONTRIBUTION_TYPES_FOR_KEY_FORMAT =
       "%s has incompatible bindings or declarations:\n";
 
-  static final String PROVIDER_ENTRY_POINT_MAY_NOT_DEPEND_ON_PRODUCER_FORMAT =
-      "%s is a provision entry-point, which cannot depend on a production.";
-
-  static final String PROVIDER_MAY_NOT_DEPEND_ON_PRODUCER_FORMAT =
-      "%s is a provision, which cannot depend on a production.";
-
   static final String DEPENDS_ON_PRODUCTION_EXECUTOR_FORMAT =
       "%s may not depend on the production executor.";
 
diff --git a/java/dagger/internal/codegen/NonNullableRequestForNullableBindingValidation.java b/java/dagger/internal/codegen/NonNullableRequestForNullableBindingValidation.java
index 0ce10f2c3..6734824fd 100644
--- a/java/dagger/internal/codegen/NonNullableRequestForNullableBindingValidation.java
+++ b/java/dagger/internal/codegen/NonNullableRequestForNullableBindingValidation.java
@@ -16,6 +16,7 @@
 
 package dagger.internal.codegen;
 
+import static dagger.internal.codegen.DaggerStreams.instancesOf;
 import static dagger.internal.codegen.DaggerStreams.toImmutableList;
 
 import com.google.common.annotations.VisibleForTesting;
@@ -72,8 +73,7 @@ public String pluginName() {
     return bindingGraph
         .inEdges(bindingNode)
         .stream()
-        .filter(edge -> edge instanceof DependencyEdge)
-        .map(edge -> (DependencyEdge) edge)
+        .flatMap(instancesOf(DependencyEdge.class))
         .filter(edge -> !edge.dependencyRequest().isNullable())
         .collect(toImmutableList());
   }
diff --git a/java/dagger/internal/codegen/ProviderDependsOnProducerValidation.java b/java/dagger/internal/codegen/ProviderDependsOnProducerValidation.java
new file mode 100644
index 000000000..a2562afde
--- /dev/null
+++ b/java/dagger/internal/codegen/ProviderDependsOnProducerValidation.java
@@ -0,0 +1,116 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Verify.verify;
+import static dagger.internal.codegen.DaggerStreams.instancesOf;
+import static dagger.internal.codegen.RequestKinds.entryPointCanUseProduction;
+import static javax.tools.Diagnostic.Kind.ERROR;
+
+import dagger.model.BindingGraph;
+import dagger.model.BindingGraph.BindingNode;
+import dagger.model.BindingGraph.DependencyEdge;
+import dagger.model.BindingGraph.Node;
+import dagger.spi.BindingGraphPlugin;
+import dagger.spi.DiagnosticReporter;
+import java.util.stream.Stream;
+import javax.inject.Inject;
+
+/**
+ * Reports an error for each dependency of a provision binding that is satisfied by a production
+ * binding.
+ */
+// TODO(b/29509141): Clarify the error.
+final class ProviderDependsOnProducerValidation implements BindingGraphPlugin {
+
+  @Inject
+  ProviderDependsOnProducerValidation() {}
+
+  @Override
+  public String pluginName() {
+    return "Dagger/ProviderDependsOnProducer";
+  }
+
+  @Override
+  public void visitGraph(BindingGraph bindingGraph, DiagnosticReporter diagnosticReporter) {
+    provisionDependenciesOnProductionBindings(bindingGraph)
+        .forEach(
+            provisionDependent ->
+                diagnosticReporter.reportDependency(
+                    ERROR,
+                    provisionDependent,
+                    provisionDependent.isEntryPoint()
+                        ? entryPointErrorMessage(provisionDependent)
+                        : dependencyErrorMessage(provisionDependent, bindingGraph)));
+  }
+
+  private Stream<DependencyEdge> provisionDependenciesOnProductionBindings(
+      BindingGraph bindingGraph) {
+    return bindingGraph
+        .bindingNodes()
+        .stream()
+        .filter(bindingNode -> bindingNode.binding().isProduction())
+        .flatMap(binding -> incomingDependencies(binding, bindingGraph))
+        .filter(edge -> !dependencyCanUseProduction(edge, bindingGraph));
+  }
+
+  /** Returns the dependencies on {@code binding}. */
+  // TODO(dpb): Move to BindingGraph.
+  private Stream<DependencyEdge> incomingDependencies(
+      BindingNode binding, BindingGraph bindingGraph) {
+    return bindingGraph.inEdges(binding).stream().flatMap(instancesOf(DependencyEdge.class));
+  }
+
+  private boolean dependencyCanUseProduction(DependencyEdge edge, BindingGraph bindingGraph) {
+    return edge.isEntryPoint()
+        ? entryPointCanUseProduction(edge.dependencyRequest().kind())
+        : bindingRequestingDependency(edge, bindingGraph).binding().isProduction();
+  }
+
+  /**
+   * Returns the binding that requests a dependency.
+   *
+   * @throws IllegalArgumentException if {@code dependency} is an {@linkplain
+   *     DependencyEdge#isEntryPoint() entry point}.
+   */
+  // TODO(dpb): Move to BindingGraph.
+  private BindingNode bindingRequestingDependency(
+      DependencyEdge dependency, BindingGraph bindingGraph) {
+    checkArgument(!dependency.isEntryPoint());
+    Node source = bindingGraph.incidentNodes(dependency).source();
+    verify(
+        source instanceof BindingNode,
+        "expected source of %s to be a binding node, but was: %s",
+        dependency,
+        source);
+    return (BindingNode) source;
+  }
+
+  private String entryPointErrorMessage(DependencyEdge entryPoint) {
+    return String.format(
+        "%s is a provision entry-point, which cannot depend on a production.",
+        entryPoint.dependencyRequest().key());
+  }
+
+  private String dependencyErrorMessage(
+      DependencyEdge dependencyOnProduction, BindingGraph bindingGraph) {
+    return String.format(
+        "%s is a provision, which cannot depend on a production.",
+        bindingRequestingDependency(dependencyOnProduction, bindingGraph).binding().key());
+  }
+}
diff --git a/java/dagger/internal/codegen/RequestKinds.java b/java/dagger/internal/codegen/RequestKinds.java
index 5e2fcf2c0..b13c57b8e 100644
--- a/java/dagger/internal/codegen/RequestKinds.java
+++ b/java/dagger/internal/codegen/RequestKinds.java
@@ -165,5 +165,25 @@ static TypeMirror extractKeyType(RequestKind requestKind, TypeMirror type) {
     return Optional.ofNullable(FRAMEWORK_CLASSES.get(requestKind));
   }
 
+  /**
+   * Returns {@code true} if entry points with the given request kind may be satisfied with a
+   * production binding.
+   */
+  static boolean entryPointCanUseProduction(RequestKind requestKind) {
+    switch (requestKind) {
+      case INSTANCE:
+      case PROVIDER:
+      case LAZY:
+      case PROVIDER_OF_LAZY:
+      case MEMBERS_INJECTION:
+        return false;
+      case PRODUCER:
+      case PRODUCED:
+      case FUTURE:
+        return true;
+    }
+    throw new AssertionError();
+  }
+
   private RequestKinds() {}
 }
