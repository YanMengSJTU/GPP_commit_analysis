diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
index 0b939a327..869d3be59 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -32,7 +32,6 @@
 import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
 import static dagger.internal.codegen.ContributionBinding.FactoryCreationStrategy.ENUM_INSTANCE;
 import static dagger.internal.codegen.ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD;
-import static dagger.internal.codegen.FrameworkDependency.frameworkDependenciesForBinding;
 import static dagger.internal.codegen.MapKeys.getMapKeyExpression;
 import static dagger.internal.codegen.MemberSelect.emptyFrameworkMapFactory;
 import static dagger.internal.codegen.MemberSelect.emptySetProvider;
@@ -841,11 +840,12 @@ private void initializeFrameworkTypes() {
      * called before we get the code block that initializes the member. */
     switch (binding.factoryCreationStrategy()) {
       case DELEGATE:
-        CodeBlock delegatingCodeBlock = CodeBlock.of(
-            "($T) $L",
-            binding.bindingType().frameworkClass(),
-            getMemberSelect(
-                Iterables.getOnlyElement(binding.dependencies()).bindingKey())
+        CodeBlock delegatingCodeBlock =
+            CodeBlock.of(
+                "($T) $L",
+                binding.bindingType().frameworkClass(),
+                getMemberSelect(
+                        Iterables.getOnlyElement(binding.explicitDependencies()).bindingKey())
                     .getExpressionFor(name));
         return Optional.of(
             CodeBlocks.concat(
@@ -907,7 +907,7 @@ private CodeBlock initializeDelegateFactoriesForUninitializedDependencies(Bindin
     ImmutableList.Builder<CodeBlock> initializations = ImmutableList.builder();
 
     for (BindingKey dependencyKey :
-        FluentIterable.from(binding.implicitDependencies())
+        FluentIterable.from(binding.dependencies())
             .transform(DependencyRequest::bindingKey)
             .toSet()) {
       if (!getMemberSelect(dependencyKey).staticMember()
@@ -924,7 +924,7 @@ private CodeBlock initializeDelegateFactoriesForUninitializedDependencies(Bindin
 
   private CodeBlock initializeProducersFromProviderDependencies(Binding binding) {
     ImmutableList.Builder<CodeBlock> initializations = ImmutableList.builder();
-    for (FrameworkDependency frameworkDependency : frameworkDependenciesForBinding(binding)) {
+    for (FrameworkDependency frameworkDependency : binding.frameworkDependencies()) {
       ResolvedBindings resolvedBindings =
           graph.resolvedBindings().get(frameworkDependency.bindingKey());
       if (resolvedBindings.frameworkClass().equals(Provider.class)
@@ -1048,7 +1048,7 @@ private CodeBlock initializeFactoryForContributionBinding(ContributionBinding bi
       case PROVISION:
         {
           List<CodeBlock> arguments =
-              Lists.newArrayListWithCapacity(binding.dependencies().size() + 1);
+              Lists.newArrayListWithCapacity(binding.explicitDependencies().size() + 1);
           if (binding.requiresModuleInstance()) {
             arguments.add(getComponentContributionExpression(binding.contributingModule().get()));
           }
@@ -1088,7 +1088,7 @@ private CodeBlock initializeFactoryForContributionBinding(ContributionBinding bi
       case PRODUCTION:
         {
           List<CodeBlock> arguments =
-              Lists.newArrayListWithCapacity(binding.implicitDependencies().size() + 2);
+              Lists.newArrayListWithCapacity(binding.dependencies().size() + 2);
           if (binding.requiresModuleInstance()) {
             arguments.add(getComponentContributionExpression(binding.contributingModule().get()));
           }
@@ -1104,7 +1104,7 @@ private CodeBlock initializeFactoryForContributionBinding(ContributionBinding bi
         return CodeBlock.of(
             "$T.create($L)",
             mapFactoryClassName(binding),
-            getMemberSelectExpression(getOnlyElement(binding.dependencies()).bindingKey()));
+            getMemberSelectExpression(getOnlyElement(binding.explicitDependencies()).bindingKey()));
 
       case SYNTHETIC_MULTIBOUND_SET:
         return initializeFactoryForSetMultibinding(binding);
@@ -1156,7 +1156,7 @@ private CodeBlock initializeMembersInjectorForBinding(MembersInjectionBinding bi
    */
   private ImmutableList<CodeBlock> getDependencyArguments(Binding binding) {
     ImmutableList.Builder<CodeBlock> parameters = ImmutableList.builder();
-    for (FrameworkDependency frameworkDependency : frameworkDependenciesForBinding(binding)) {
+    for (FrameworkDependency frameworkDependency : binding.frameworkDependencies()) {
       parameters.add(getDependencyArgument(frameworkDependency).getExpressionFor(name));
     }
     return parameters.build();
@@ -1189,7 +1189,7 @@ private CodeBlock initializeFactoryForSetMultibinding(ContributionBinding bindin
     int individualProviders = 0;
     int setProviders = 0;
     CodeBlock.Builder builderMethodCalls = CodeBlock.builder();
-    for (FrameworkDependency frameworkDependency : frameworkDependenciesForBinding(binding)) {
+    for (FrameworkDependency frameworkDependency : binding.frameworkDependencies()) {
       ContributionType contributionType =
           graph.resolvedBindings().get(frameworkDependency.bindingKey()).contributionType();
       String methodName;
@@ -1221,8 +1221,7 @@ private CodeBlock initializeFactoryForSetMultibinding(ContributionBinding bindin
   }
 
   private CodeBlock initializeFactoryForMapMultibinding(ContributionBinding binding) {
-    ImmutableSet<FrameworkDependency> frameworkDependencies =
-        FrameworkDependency.frameworkDependenciesForBinding(binding);
+    ImmutableList<FrameworkDependency> frameworkDependencies = binding.frameworkDependencies();
 
     ImmutableList.Builder<CodeBlock> codeBlocks = ImmutableList.builder();
     MapType mapType = MapType.from(binding.key().type());
@@ -1266,7 +1265,7 @@ private CodeBlock potentiallyCast(boolean shouldCast, Class<?> classToCast, Code
    * binding.
    */
   private CodeBlock initializeFactoryForSyntheticOptionalBinding(ContributionBinding binding) {
-    if (binding.dependencies().isEmpty()) {
+    if (binding.explicitDependencies().isEmpty()) {
       verify(
           binding.bindingType().equals(BindingType.PROVISION),
           "Absent optional bindings should be provisions: %s",
diff --git a/compiler/src/main/java/dagger/internal/codegen/Binding.java b/compiler/src/main/java/dagger/internal/codegen/Binding.java
index 159745000..e70b5df8d 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Binding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Binding.java
@@ -16,16 +16,25 @@
 
 package dagger.internal.codegen;
 
+import static com.google.common.collect.Iterables.getOnlyElement;
+import static java.util.stream.Collectors.toList;
 import static javax.lang.model.element.Modifier.PUBLIC;
 
 import com.google.auto.common.MoreElements;
+import com.google.auto.value.AutoValue;
 import com.google.common.base.Optional;
+import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.ImmutableSetMultimap;
 import com.google.common.collect.Lists;
 import com.google.common.collect.Sets;
 import dagger.internal.codegen.BindingType.HasBindingType;
+import java.util.Collection;
+import java.util.Iterator;
 import java.util.List;
+import java.util.Map;
 import java.util.Set;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.Name;
@@ -58,27 +67,148 @@
    * The explicit set of {@link DependencyRequest dependencies} required to satisfy this binding as
    * defined by the user-defined injection sites.
    */
-  abstract ImmutableSet<DependencyRequest> dependencies();
+  abstract ImmutableSet<DependencyRequest> explicitDependencies();
 
   /**
    * The set of {@link DependencyRequest dependencies} that are added by the framework rather than a
    * user-defined injection site. This returns an unmodifiable set.
    */
-  // TODO(gak): this will eventually get migrated to FrameworkDependency
-  Set<DependencyRequest> frameworkDependencies() {
+  // TODO(gak): this will eventually get changed to return a set of FrameworkDependency
+  Set<DependencyRequest> implicitDependencies() {
     return ImmutableSet.of();
   }
 
   /**
    * The set of {@link DependencyRequest dependencies} required to satisfy this binding. This is the
-   * union of {@link #dependencies()} and {@link #frameworkDependencies()}. This returns an
+   * union of {@link #explicitDependencies()} and {@link #implicitDependencies()}. This returns an
    * unmodifiable set.
    */
-  final Set<DependencyRequest> implicitDependencies() {
-    Set<DependencyRequest> frameworkDependencies = frameworkDependencies();
-    return frameworkDependencies.isEmpty()
-        ? dependencies()
-        : Sets.union(frameworkDependencies, dependencies());
+  final Set<DependencyRequest> dependencies() {
+    Set<DependencyRequest> implicitDependencies = implicitDependencies();
+    return implicitDependencies.isEmpty()
+        ? explicitDependencies()
+        : Sets.union(implicitDependencies, explicitDependencies());
+  }
+
+  /**
+   * The framework dependencies of {@code binding}. There will be one element for each different
+   * binding key in the <em>{@linkplain Binding#unresolved() unresolved}</em> version of {@code
+   * binding}.
+   *
+   * <p>For example, given the following modules:
+   *
+   * <pre><code>
+   *   {@literal @Module} abstract class {@literal BaseModule<T>} {
+   *     {@literal @Provides} Foo provideFoo(T t, String string) {
+   *       return …;
+   *     }
+   *   }
+   *
+   *   {@literal @Module} class StringModule extends {@literal BaseModule<String>} {}
+   * </code></pre>
+   *
+   * Both dependencies of {@code StringModule.provideFoo} have the same binding key: {@code String}.
+   * But there are still two dependencies, because in the unresolved binding they have different
+   * binding keys:
+   *
+   * <dl>
+   * <dt>{@code T}
+   * <dd>{@code String t}
+   * <dt>{@code String}
+   * <dd>{@code String string}
+   * </dl>
+   *
+   * <p>Note that the sets returned by this method when called on the same binding will be equal,
+   * and their elements will be in the same order.
+   */
+  /* TODO(dpb): The stable-order postcondition is actually hard to verify in code for two equal
+   * instances of Binding, because it really depends on the order of the binding's dependencies,
+   * and two equal instances of Binding may have the same dependencies in a different order. */
+  ImmutableList<FrameworkDependency> frameworkDependencies() {
+    return ImmutableList.copyOf(
+        dependencyAssociations()
+            .stream()
+            .map(DependencyAssociation::frameworkDependency)
+            .collect(toList()));
+  }
+
+  /**
+   * Associates a {@link FrameworkDependency} with the set of {@link DependencyRequest} instances
+   * that correlate for a binding.
+   */
+  @AutoValue
+  abstract static class DependencyAssociation {
+    abstract FrameworkDependency frameworkDependency();
+
+    abstract ImmutableSet<DependencyRequest> dependencyRequests();
+
+    static DependencyAssociation create(
+        FrameworkDependency frameworkDependency, Iterable<DependencyRequest> dependencyRequests) {
+      return new AutoValue_Binding_DependencyAssociation(
+          frameworkDependency, ImmutableSet.copyOf(dependencyRequests));
+    }
+  }
+
+  /**
+   * Returns the same {@link FrameworkDependency} instances from {@link #frameworkDependencies}, but
+   * with the set of {@link DependencyRequest} instances with which each is associated.
+   *
+   * <p>Ths method returns a list of {@link Map.Entry entries} rather than a {@link Map} or {@link
+   * com.google.common.collect.Multimap} because any given {@link FrameworkDependency} may appear
+   * multiple times if the {@linkplain Binding#unresolved() unresolved} binding requires it. If that
+   * distinction is not important, the entries can be merged into a single mapping.
+   */
+  ImmutableList<DependencyAssociation> dependencyAssociations() {
+    BindingTypeMapper bindingTypeMapper = BindingTypeMapper.forBindingType(bindingType());
+    ImmutableList.Builder<DependencyAssociation> frameworkDependencies = ImmutableList.builder();
+    for (Collection<DependencyRequest> requests : groupByUnresolvedKey()) {
+      frameworkDependencies.add(
+          DependencyAssociation.create(
+              FrameworkDependency.create(
+                  getOnlyElement(
+                      FluentIterable.from(requests)
+                          .transform(DependencyRequest::bindingKey)
+                          .toSet()),
+                  bindingTypeMapper.getBindingType(requests)),
+              requests));
+    }
+    return frameworkDependencies.build();
+  }
+
+  /**
+   * Returns the mapping from each {@linkplain #dependencies dependency} to its associated {@link
+   * FrameworkDependency}.
+   */
+  ImmutableMap<DependencyRequest, FrameworkDependency> dependenciesToFrameworkDependenciesMap() {
+    ImmutableMap.Builder<DependencyRequest, FrameworkDependency> frameworkDependencyMap =
+        ImmutableMap.builder();
+    for (DependencyAssociation dependencyAssociation : dependencyAssociations()) {
+      for (DependencyRequest dependencyRequest : dependencyAssociation.dependencyRequests()) {
+        frameworkDependencyMap.put(dependencyRequest, dependencyAssociation.frameworkDependency());
+      }
+    }
+    return frameworkDependencyMap.build();
+  }
+
+  /**
+   * Groups {@code binding}'s implicit dependencies by their binding key, using the dependency keys
+   * from the {@link Binding#unresolved()} binding if it exists.
+   */
+  private ImmutableList<Collection<DependencyRequest>> groupByUnresolvedKey() {
+    ImmutableSetMultimap.Builder<BindingKey, DependencyRequest> dependenciesByKeyBuilder =
+        ImmutableSetMultimap.builder();
+    Iterator<DependencyRequest> dependencies = dependencies().iterator();
+    Binding unresolved = unresolved().isPresent() ? unresolved().get() : this;
+    Iterator<DependencyRequest> unresolvedDependencies = unresolved.dependencies().iterator();
+    while (dependencies.hasNext()) {
+      dependenciesByKeyBuilder.put(unresolvedDependencies.next().bindingKey(), dependencies.next());
+    }
+    return ImmutableList.copyOf(
+        dependenciesByKeyBuilder
+            .orderValuesBy(SourceFiles.DEPENDENCY_ORDERING)
+            .build()
+            .asMap()
+            .values());
   }
 
   /**
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
index 4c04a4977..a1305bb9c 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
@@ -876,7 +876,7 @@ void resolve(BindingKey bindingKey) {
         try {
           ResolvedBindings bindings = lookUpBindings(bindingKey);
           for (Binding binding : bindings.ownedBindings()) {
-            for (DependencyRequest dependency : binding.implicitDependencies()) {
+            for (DependencyRequest dependency : binding.dependencies()) {
               resolve(dependency.bindingKey());
             }
           }
@@ -988,7 +988,7 @@ boolean dependsOnLocalBindings(Binding binding) {
                           || binding.scope().get().equals(reusableScope(elements)))
                       // TODO(beder): Figure out what happens with production subcomponents.
                       && !binding.bindingType().equals(BindingType.PRODUCTION)) {
-                    for (DependencyRequest dependency : binding.implicitDependencies()) {
+                    for (DependencyRequest dependency : binding.dependencies()) {
                       if (dependsOnLocalBindings(dependency.bindingKey())) {
                         return true;
                       }
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
index 1c418528a..831fba7b0 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -335,7 +335,7 @@ private void traverseDependencyRequest(DependencyRequest request, DependencyPath
                   (component, bindings) -> {
                     Validation validation = validationForComponent(component);
                     for (Binding binding : bindings) {
-                      for (DependencyRequest nextRequest : binding.implicitDependencies()) {
+                      for (DependencyRequest nextRequest : binding.dependencies()) {
                         validation.traverseDependencyRequest(nextRequest, path);
                       }
                     }
@@ -414,7 +414,7 @@ private void validateResolvedBindings(DependencyPath path) {
             // binding to the implementation
             if (!contributionBinding.key().equals(productionImplementationExecutorKey)) {
               Key productionExecutorKey = keyFactory.forProductionExecutor();
-              for (DependencyRequest request : contributionBinding.dependencies()) {
+              for (DependencyRequest request : contributionBinding.explicitDependencies()) {
                 if (request.key().equals(productionExecutorKey)
                     || request.key().equals(productionImplementationExecutorKey)) {
                   reportDependsOnProductionExecutor(path);
@@ -495,7 +495,7 @@ private ResolvedBindings inlineContributionsWithoutBindingElements(
           if (binding.bindingElement().isPresent()) {
             contributions.put(bindingEntry);
           } else {
-            for (DependencyRequest dependency : binding.dependencies()) {
+            for (DependencyRequest dependency : binding.explicitDependencies()) {
               queue.add(owningGraph.resolvedBindings().get(dependency.bindingKey()));
             }
           }
@@ -561,7 +561,7 @@ private void validateMapKeys(
           binding);
       ImmutableSet.Builder<ContributionBinding> multibindingContributionsBuilder =
           ImmutableSet.builder();
-      for (DependencyRequest dependency : binding.dependencies()) {
+      for (DependencyRequest dependency : binding.explicitDependencies()) {
         multibindingContributionsBuilder.add(
             subject.resolvedBindings().get(dependency.bindingKey()).contributionBinding());
       }
@@ -1343,7 +1343,7 @@ private String formatCurrentDependencyRequestKey(DependencyPath path) {
     FluentIterable<? extends Binding> dependentBindings() {
       return FluentIterable.from(dependentResolvedBindings().asSet())
           .transformAndConcat(ResolvedBindings::bindings)
-          .filter(binding -> binding.implicitDependencies().contains(dependencyRequest()));
+          .filter(binding -> binding.dependencies().contains(dependencyRequest()));
     }
 
     private static ResolvedRequest create(
diff --git a/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
index da7398b3a..235b99a2e 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
@@ -197,13 +197,13 @@ FactoryCreationStrategy factoryCreationStrategy() {
       case SYNTHETIC_DELEGATE_BINDING:
         return DELEGATE;
       case PROVISION:
-        return implicitDependencies().isEmpty() && !requiresModuleInstance()
+        return dependencies().isEmpty() && !requiresModuleInstance()
             ? ENUM_INSTANCE
             : CLASS_CONSTRUCTOR;
       case INJECTION:
       case SYNTHETIC_MULTIBOUND_SET:
       case SYNTHETIC_MULTIBOUND_MAP:
-        return implicitDependencies().isEmpty() ? ENUM_INSTANCE : CLASS_CONSTRUCTOR;
+        return dependencies().isEmpty() ? ENUM_INSTANCE : CLASS_CONSTRUCTOR;
       default:
         return CLASS_CONSTRUCTOR;
     }
@@ -271,9 +271,9 @@ final TypeMirror factoryType() {
 
     abstract B key(Key key);
 
-    abstract B dependencies(Iterable<DependencyRequest> dependencies);
+    abstract B explicitDependencies(Iterable<DependencyRequest> dependencies);
 
-    abstract B dependencies(DependencyRequest... dependencies);
+    abstract B explicitDependencies(DependencyRequest... dependencies);
 
     abstract B nullableType(Optional<DeclaredType> nullableType);
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
index 653a0538a..332562b61 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
@@ -221,7 +221,7 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
     }
 
     List<CodeBlock> parameters = Lists.newArrayList();
-    for (DependencyRequest dependency : binding.dependencies()) {
+    for (DependencyRequest dependency : binding.explicitDependencies()) {
       parameters.add(
           frameworkTypeUsageStatement(
               CodeBlock.of("$N", fields.get(dependency.bindingKey())), dependency.kind()));
diff --git a/compiler/src/main/java/dagger/internal/codegen/FrameworkDependency.java b/compiler/src/main/java/dagger/internal/codegen/FrameworkDependency.java
index 1e0b02e5e..0cd593d6b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FrameworkDependency.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FrameworkDependency.java
@@ -16,16 +16,7 @@
 
 package dagger.internal.codegen;
 
-import static com.google.common.collect.Iterables.getOnlyElement;
-
 import com.google.auto.value.AutoValue;
-import com.google.common.collect.FluentIterable;
-import com.google.common.collect.ImmutableList;
-import com.google.common.collect.ImmutableMap;
-import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.ImmutableSetMultimap;
-import java.util.Collection;
-import java.util.Iterator;
 import javax.inject.Provider;
 
 /**
@@ -65,90 +56,8 @@
     return bindingType().frameworkClass();
   }
 
-  /**
-   * The dependency requests that are all satisfied by one framework instance.
-   */
-  abstract ImmutableSet<DependencyRequest> dependencyRequests();
-
-  /**
-   * The framework dependencies of {@code binding}. There will be one element for each
-   * different binding key in the <em>{@linkplain Binding#unresolved() unresolved}</em> version of
-   * {@code binding}.
-   *
-   * <p>For example, given the following modules:
-   * <pre><code>
-   *   {@literal @Module} abstract class {@literal BaseModule<T>} {
-   *     {@literal @Provides} Foo provideFoo(T t, String string) {
-   *       return …;
-   *     }
-   *   }
-   *
-   *   {@literal @Module} class StringModule extends {@literal BaseModule<String>} {}
-   * </code></pre>
-   *
-   * Both dependencies of {@code StringModule.provideFoo} have the same binding key:
-   * {@code String}. But there are still two dependencies, because in the unresolved binding they
-   * have different binding keys:
-   *
-   * <dl>
-   * <dt>{@code T} <dd>{@code String t}
-   * <dt>{@code String} <dd>{@code String string}
-   * </dl>
-   * 
-   * <p>Note that the sets returned by this method when called on the same binding will be equal,
-   * and their elements will be in the same order.
-   */
-  /* TODO(dpb): The stable-order postcondition is actually hard to verify in code for two equal
-   * instances of Binding, because it really depends on the order of the binding's dependencies,
-   * and two equal instances of Binding may have the same dependencies in a different order. */
-  static ImmutableSet<FrameworkDependency> frameworkDependenciesForBinding(Binding binding) {
-    BindingTypeMapper bindingTypeMapper =
-        BindingTypeMapper.forBindingType(binding.bindingType());
-    ImmutableSet.Builder<FrameworkDependency> frameworkDependencies = ImmutableSet.builder();
-    for (Collection<DependencyRequest> requests : groupByUnresolvedKey(binding)) {
-      frameworkDependencies.add(
-          new AutoValue_FrameworkDependency(
-              getOnlyElement(
-                  FluentIterable.from(requests).transform(DependencyRequest::bindingKey).toSet()),
-              bindingTypeMapper.getBindingType(requests),
-              ImmutableSet.copyOf(requests)));
-    }
-    return frameworkDependencies.build();
-  }
-
-  /** Indexes {@code dependencies} by their {@link #dependencyRequests()}. */
-  static ImmutableMap<DependencyRequest, FrameworkDependency> indexByDependencyRequest(
-      Iterable<FrameworkDependency> dependencies) {
-    ImmutableMap.Builder<DependencyRequest, FrameworkDependency> frameworkDependencyMap =
-        ImmutableMap.builder();
-    for (FrameworkDependency dependency : dependencies) {
-      for (DependencyRequest request : dependency.dependencyRequests()) {
-        frameworkDependencyMap.put(request, dependency);
-      }
-    }
-    return frameworkDependencyMap.build();
-  }
-
-  /**
-   * Groups {@code binding}'s implicit dependencies by their binding key, using the dependency keys
-   * from the {@link Binding#unresolved()} binding if it exists.
-   */
-  private static ImmutableList<Collection<DependencyRequest>> groupByUnresolvedKey(
-      Binding binding) {
-    ImmutableSetMultimap.Builder<BindingKey, DependencyRequest> dependenciesByKeyBuilder =
-        ImmutableSetMultimap.builder();
-    Iterator<DependencyRequest> dependencies = binding.implicitDependencies().iterator();
-    Binding unresolved = binding.unresolved().isPresent() ? binding.unresolved().get() : binding;
-    Iterator<DependencyRequest> unresolvedDependencies =
-        unresolved.implicitDependencies().iterator();
-    while (dependencies.hasNext()) {
-      dependenciesByKeyBuilder.put(unresolvedDependencies.next().bindingKey(), dependencies.next());
-    }
-    return ImmutableList.copyOf(
-        dependenciesByKeyBuilder
-            .orderValuesBy(SourceFiles.DEPENDENCY_ORDERING)
-            .build()
-            .asMap()
-            .values());
+  /** Returns a new instance with the given key and type. */
+  static FrameworkDependency create(BindingKey bindingKey, BindingType bindingType) {
+    return new AutoValue_FrameworkDependency(bindingKey, bindingType);
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
index c2a53148d..c759af798 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
@@ -220,9 +220,8 @@ private static void assignField(MethodSpec.Builder constructorBuilder, FieldSpec
   /** Returns a list of dependencies that are generated asynchronously. */
   private static ImmutableList<DependencyRequest> asyncDependencies(Binding binding) {
     final ImmutableMap<DependencyRequest, FrameworkDependency> frameworkDependencies =
-        FrameworkDependency.indexByDependencyRequest(
-            FrameworkDependency.frameworkDependenciesForBinding(binding));
-    return FluentIterable.from(binding.implicitDependencies())
+        binding.dependenciesToFrameworkDependenciesMap();
+    return FluentIterable.from(binding.dependencies())
         .filter(
             dependency ->
                 isAsyncDependency(dependency)
@@ -317,7 +316,7 @@ String applyArgName() {
     @Override
     ImmutableList<CodeBlock> parameterCodeBlocks() {
       ImmutableList.Builder<CodeBlock> parameterCodeBlocks = ImmutableList.builder();
-      for (DependencyRequest dependency : binding.dependencies()) {
+      for (DependencyRequest dependency : binding.explicitDependencies()) {
         parameterCodeBlocks.add(
             frameworkTypeUsageStatement(
                 CodeBlock.of("$N", fields.get(dependency.bindingKey())), dependency.kind()));
@@ -355,7 +354,7 @@ String applyArgName() {
     @Override
     ImmutableList<CodeBlock> parameterCodeBlocks() {
       ImmutableList.Builder<CodeBlock> parameterCodeBlocks = ImmutableList.builder();
-      for (DependencyRequest dependency : binding.dependencies()) {
+      for (DependencyRequest dependency : binding.explicitDependencies()) {
         // We really want to compare instances here, because asyncDependency is an element in the
         // set binding.dependencies().
         if (dependency == asyncDependency) {
@@ -441,7 +440,7 @@ private static TypeName asyncDependencyType(DependencyRequest dependency) {
       ProductionBinding binding, ImmutableMap<BindingKey, FieldSpec> fields, String listArgName) {
     int argIndex = 0;
     ImmutableList.Builder<CodeBlock> codeBlocks = ImmutableList.builder();
-    for (DependencyRequest dependency : binding.dependencies()) {
+    for (DependencyRequest dependency : binding.explicitDependencies()) {
       if (isAsyncDependency(dependency)) {
         codeBlocks.add(
             CodeBlock.of(
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
index a25d339a2..bbcabc679 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
@@ -59,7 +59,7 @@ public BindingType bindingType() {
   }
 
   @Override
-  Set<DependencyRequest> frameworkDependencies() {
+  Set<DependencyRequest> implicitDependencies() {
     return new ImmutableSet.Builder<DependencyRequest>()
         .addAll(executorRequest().asSet())
         .addAll(monitorRequest().asSet())
@@ -101,7 +101,7 @@ public BindingType bindingType() {
 
   private static Builder builder() {
     return new AutoValue_ProductionBinding.Builder()
-        .dependencies(ImmutableList.<DependencyRequest>of())
+        .explicitDependencies(ImmutableList.<DependencyRequest>of())
         .thrownTypes(ImmutableList.<TypeMirror>of());
   }
 
@@ -163,7 +163,7 @@ ProductionBinding forProducesMethod(
           .bindingElement(producesMethod)
           .contributingModule(contributedBy)
           .key(key)
-          .dependencies(dependencies)
+          .explicitDependencies(dependencies)
           .wrappedMapKey(wrapOptionalInEquivalence(getMapKey(producesMethod)))
           .bindingKind(Kind.PRODUCTION)
           .productionKind(productionKind)
@@ -190,7 +190,7 @@ ProductionBinding syntheticMapOfValuesOrProducedBinding(Key mapOfValuesOrProduce
       return ProductionBinding.builder()
           .contributionType(ContributionType.UNIQUE)
           .key(mapOfValuesOrProducedKey)
-          .dependencies(requestForMapOfProducers)
+          .explicitDependencies(requestForMapOfProducers)
           .bindingKind(Kind.SYNTHETIC_MAP)
           .build();
     }
@@ -206,7 +206,7 @@ ProductionBinding syntheticMultibinding(
       return ProductionBinding.builder()
           .contributionType(ContributionType.UNIQUE)
           .key(key)
-          .dependencies(
+          .explicitDependencies(
               dependencyRequestFactory.forMultibindingContributions(multibindingContributions))
           .bindingKind(Kind.forMultibindingKey(key))
           .build();
@@ -233,7 +233,7 @@ ProductionBinding delegate(
           .bindingElement(delegateDeclaration.bindingElement().get())
           .contributingModule(delegateDeclaration.contributingModule().get())
           .key(keyFactory.forDelegateBinding(delegateDeclaration, Producer.class))
-          .dependencies(delegateDeclaration.delegateRequest())
+          .explicitDependencies(delegateDeclaration.delegateRequest())
           .nullableType(delegateBinding.nullableType())
           .wrappedMapKey(delegateDeclaration.wrappedMapKey())
           .bindingKind(Kind.SYNTHETIC_DELEGATE_BINDING)
@@ -249,7 +249,7 @@ ProductionBinding syntheticPresentBinding(Key key) {
           .contributionType(ContributionType.UNIQUE)
           .key(key)
           .bindingKind(Kind.SYNTHETIC_OPTIONAL_BINDING)
-          .dependencies(
+          .explicitDependencies(
               dependencyRequestFactory.forSyntheticPresentOptionalBinding(
                   key, DependencyRequest.Kind.PRODUCER))
           .build();
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
index b6e459ab9..d913c4351 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
@@ -60,7 +60,7 @@
 abstract class ProvisionBinding extends ContributionBinding {
 
   @Override
-  Set<DependencyRequest> frameworkDependencies() {
+  Set<DependencyRequest> implicitDependencies() {
     return membersInjectionRequest().asSet();
   }
 
@@ -80,7 +80,7 @@ public BindingType bindingType() {
 
   private static Builder builder() {
     return new AutoValue_ProvisionBinding.Builder()
-        .dependencies(ImmutableSet.<DependencyRequest>of());
+        .explicitDependencies(ImmutableSet.<DependencyRequest>of());
   }
 
   abstract Builder toBuilder();
@@ -152,7 +152,7 @@ ProvisionBinding forInjectConstructor(ExecutableElement constructorElement,
               .contributionType(ContributionType.UNIQUE)
               .bindingElement(constructorElement)
               .key(key)
-              .dependencies(dependencies)
+              .explicitDependencies(dependencies)
               .membersInjectionRequest(membersInjectionRequest)
               .bindingKind(Kind.INJECTION)
               .scope(Scope.uniqueScopeOf(constructorElement.getEnclosingElement()));
@@ -199,7 +199,7 @@ ProvisionBinding forProvidesMethod(
           .bindingElement(providesMethod)
           .contributingModule(contributedBy)
           .key(key)
-          .dependencies(dependencies)
+          .explicitDependencies(dependencies)
           .nullableType(ConfigurationAnnotations.getNullableType(providesMethod))
           .wrappedMapKey(wrapOptionalInEquivalence(getMapKey(providesMethod)))
           .bindingKind(Kind.PROVISION)
@@ -217,7 +217,7 @@ ProvisionBinding syntheticMapOfValuesBinding(Key mapOfValuesKey) {
       return ProvisionBinding.builder()
           .contributionType(ContributionType.UNIQUE)
           .key(mapOfValuesKey)
-          .dependencies(requestForMapOfProviders)
+          .explicitDependencies(requestForMapOfProviders)
           .bindingKind(Kind.SYNTHETIC_MAP)
           .build();
     }
@@ -233,7 +233,7 @@ ProvisionBinding syntheticMultibinding(
       return ProvisionBinding.builder()
           .contributionType(ContributionType.UNIQUE)
           .key(key)
-          .dependencies(
+          .explicitDependencies(
               dependencyRequestFactory.forMultibindingContributions(multibindingContributions))
           .bindingKind(Kind.forMultibindingKey(key))
           .build();
@@ -307,7 +307,7 @@ ProvisionBinding missingDelegate(DelegateDeclaration delegateDeclaration) {
           .bindingElement(delegateDeclaration.bindingElement().get())
           .contributingModule(delegateDeclaration.contributingModule().get())
           .key(keyFactory.forDelegateBinding(delegateDeclaration, Provider.class))
-          .dependencies(delegateDeclaration.delegateRequest())
+          .explicitDependencies(delegateDeclaration.delegateRequest())
           .wrappedMapKey(delegateDeclaration.wrappedMapKey())
           .bindingKind(Kind.SYNTHETIC_DELEGATE_BINDING)
           .scope(Scope.uniqueScopeOf(delegateDeclaration.bindingElement().get()));
@@ -332,7 +332,7 @@ ProvisionBinding syntheticAbsentBinding(Key key) {
     ProvisionBinding syntheticPresentBinding(Key key) {
       return syntheticAbsentBinding(key)
           .toBuilder()
-          .dependencies(
+          .explicitDependencies(
               dependencyRequestFactory.forSyntheticPresentOptionalBinding(
                   key, DependencyRequest.Kind.PROVIDER))
           .build();
diff --git a/compiler/src/main/java/dagger/internal/codegen/RequestFulfillmentRegistry.java b/compiler/src/main/java/dagger/internal/codegen/RequestFulfillmentRegistry.java
index 943ac5e4a..941d314e6 100644
--- a/compiler/src/main/java/dagger/internal/codegen/RequestFulfillmentRegistry.java
+++ b/compiler/src/main/java/dagger/internal/codegen/RequestFulfillmentRegistry.java
@@ -64,7 +64,7 @@ private RequestFulfillment createRequestFulfillment(BindingKey bindingKey) {
 
         ProviderFieldRequestFulfillment providerFieldRequestFulfillment =
             new ProviderFieldRequestFulfillment(bindingKey, memberSelect);
-        if (provisionBinding.frameworkDependencies().isEmpty()
+        if (provisionBinding.implicitDependencies().isEmpty()
             && !provisionBinding.scope().isPresent()
             && !provisionBinding.requiresModuleInstance()
             && provisionBinding.bindingElement().isPresent()
diff --git a/compiler/src/main/java/dagger/internal/codegen/SimpleMethodRequestFulfillment.java b/compiler/src/main/java/dagger/internal/codegen/SimpleMethodRequestFulfillment.java
index 987320a6c..e6f040984 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SimpleMethodRequestFulfillment.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SimpleMethodRequestFulfillment.java
@@ -52,7 +52,7 @@
       RequestFulfillmentRegistry registry) {
     super(bindingKey);
     checkArgument(
-        provisionBinding.frameworkDependencies().isEmpty(),
+        provisionBinding.implicitDependencies().isEmpty(),
         "framework deps are not currently supported");
     checkArgument(!provisionBinding.scope().isPresent());
     checkArgument(!provisionBinding.requiresModuleInstance());
@@ -114,7 +114,7 @@ private CodeBlock invokeMethod(ClassName requestingClass) {
     CodeBlock parametersCodeBlock =
         CodeBlocks.makeParametersCodeBlock(
             provisionBinding
-                .dependencies()
+                .explicitDependencies()
                 .stream()
                 .map(
                     request -> {
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
index 62571bdb9..2b7aebda5 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
@@ -16,7 +16,6 @@
 
 import static com.google.common.base.CaseFormat.UPPER_CAMEL;
 import static com.google.common.base.Preconditions.checkArgument;
-import static dagger.internal.codegen.FrameworkDependency.frameworkDependenciesForBinding;
 import static dagger.internal.codegen.TypeNames.DOUBLE_CHECK;
 import static dagger.internal.codegen.TypeNames.PROVIDER_OF_LAZY;
 import static dagger.internal.codegen.Util.ELEMENT_SIMPLE_NAME;
@@ -85,23 +84,22 @@
     checkArgument(!binding.unresolved().isPresent(), "binding must be unresolved: %s", binding);
 
     ImmutableMap.Builder<BindingKey, FrameworkField> bindingFields = ImmutableMap.builder();
-    for (FrameworkDependency frameworkDependency : frameworkDependenciesForBinding(binding)) {
+    for (Binding.DependencyAssociation dependencyAssociation : binding.dependencyAssociations()) {
+      FrameworkDependency frameworkDependency = dependencyAssociation.frameworkDependency();
       bindingFields.put(
           frameworkDependency.bindingKey(),
           FrameworkField.create(
               ClassName.get(frameworkDependency.frameworkClass()),
               TypeName.get(frameworkDependency.bindingKey().key().type()),
-              fieldNameForDependency(frameworkDependency)));
+              fieldNameForDependency(dependencyAssociation.dependencyRequests())));
     }
     return bindingFields.build();
   }
 
-  private static String fieldNameForDependency(FrameworkDependency frameworkDependency) {
+  private static String fieldNameForDependency(ImmutableSet<DependencyRequest> dependencyRequests) {
     // collect together all of the names that we would want to call the provider
     ImmutableSet<String> dependencyNames =
-        FluentIterable.from(frameworkDependency.dependencyRequests())
-            .transform(new DependencyVariableNamer())
-            .toSet();
+        FluentIterable.from(dependencyRequests).transform(new DependencyVariableNamer()).toSet();
 
     if (dependencyNames.size() == 1) {
       // if there's only one name, great! use it!
