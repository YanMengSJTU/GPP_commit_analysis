diff --git a/compiler/src/main/java/dagger/internal/codegen/Accessibility.java b/compiler/src/main/java/dagger/internal/codegen/Accessibility.java
index bdc921d2b..a56222ff6 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Accessibility.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Accessibility.java
@@ -22,6 +22,7 @@
 import static javax.lang.model.element.Modifier.PUBLIC;
 
 import com.google.auto.common.MoreElements;
+import com.google.common.base.Optional;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ElementKind;
 import javax.lang.model.element.ExecutableElement;
@@ -36,9 +37,11 @@
 import javax.lang.model.type.PrimitiveType;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.type.TypeVariable;
+import javax.lang.model.type.TypeVisitor;
 import javax.lang.model.type.WildcardType;
 import javax.lang.model.util.SimpleElementVisitor6;
 import javax.lang.model.util.SimpleTypeVisitor6;
+import javax.lang.model.util.SimpleTypeVisitor8;
 
 /**
  * Utility methods for determining whether a {@linkplain TypeMirror type} or an {@linkplain Element
@@ -56,17 +59,35 @@
  * preferable for {@code javac}.
  */
 final class Accessibility {
+
   /**
    * Returns true if the given type can be referenced from code in the given package.
    */
   static boolean isTypeAccessibleFrom(TypeMirror type, String packageName) {
-    return type.accept(new TypeAccessiblityVisitor(packageName), null);
+    return type.accept(new TypeAccessibilityVisitor(packageName), null);
+  }
+
+  /** Returns true if the given type can be referenced from any package. */
+  static boolean isTypePubliclyAccessible(TypeMirror type) {
+    return type.accept(new TypeAccessibilityVisitor(), null);
   }
 
-  private static final class TypeAccessiblityVisitor extends SimpleTypeVisitor6<Boolean, Void> {
-    final String packageName;
+  private static boolean isTypeAccessibleFrom(TypeMirror type, Optional<String> packageName) {
+    return type.accept(new TypeAccessibilityVisitor(packageName), null);
+  }
+
+  private static final class TypeAccessibilityVisitor extends SimpleTypeVisitor6<Boolean, Void> {
+    final Optional<String> packageName;
+
+    TypeAccessibilityVisitor() {
+      this(Optional.absent());
+    }
+
+    TypeAccessibilityVisitor(String packageName) {
+      this(Optional.of(packageName));
+    }
 
-    TypeAccessiblityVisitor(String packageName) {
+    TypeAccessibilityVisitor(Optional<String> packageName) {
       this.packageName = packageName;
     }
 
@@ -135,11 +156,18 @@ protected Boolean defaultAction(TypeMirror type, Void p) {
     }
   }
 
-  /**
-   * Returns true if the given element can be referenced from code in the given package.
-   */
+  /** Returns true if the given element can be referenced from code in the given package. */
   //TODO(gak): account for protected
-  static boolean isElementAccessibleFrom(Element element, final String packageName) {
+  static boolean isElementAccessibleFrom(Element element, String packageName) {
+    return element.accept(new ElementAccessibilityVisitor(packageName), null);
+  }
+
+  /** Returns true if the given element can be referenced from any package. */
+  static boolean isElementPubliclyAccessible(Element element) {
+    return element.accept(new ElementAccessibilityVisitor(), null);
+  }
+
+  private static boolean isElementAccessibleFrom(Element element, Optional<String> packageName) {
     return element.accept(new ElementAccessibilityVisitor(packageName), null);
   }
 
@@ -151,9 +179,17 @@ static boolean isElementAccessibleFromOwnPackage(Element element) {
 
   private static final class ElementAccessibilityVisitor
       extends SimpleElementVisitor6<Boolean, Void> {
-    final String packageName;
+    final Optional<String> packageName;
+
+    ElementAccessibilityVisitor() {
+      this(Optional.absent());
+    }
 
     ElementAccessibilityVisitor(String packageName) {
+      this(Optional.of(packageName));
+    }
+
+    ElementAccessibilityVisitor(Optional<String> packageName) {
       this.packageName = packageName;
     }
 
@@ -189,7 +225,8 @@ boolean accessibleModifiers(Element element) {
         return true;
       } else if (element.getModifiers().contains(PRIVATE)) {
         return false;
-      } else if (getPackage(element).getQualifiedName().contentEquals(packageName)) {
+      } else if (packageName.isPresent()
+          && getPackage(element).getQualifiedName().contentEquals(packageName.get())) {
         return true;
       } else {
         return false;
@@ -215,6 +252,29 @@ public Boolean visitVariable(VariableElement element, Void p) {
     }
   }
 
+  private static final TypeVisitor<Boolean, Optional<String>> RAW_TYPE_ACCESSIBILITY_VISITOR =
+      new SimpleTypeVisitor8<Boolean, Optional<String>>() {
+        @Override
+        protected Boolean defaultAction(TypeMirror e, Optional<String> requestingPackage) {
+          return isTypeAccessibleFrom(e, requestingPackage);
+        }
+
+        @Override
+        public Boolean visitDeclared(DeclaredType t, Optional<String> requestingPackage) {
+          return isElementAccessibleFrom(t.asElement(), requestingPackage);
+        }
+      };
+
+  /** Returns true if the raw type of {@code type} is accessible from the given package. */
+  static boolean isRawTypeAccessible(TypeMirror type, String requestingPackage) {
+    return type.accept(RAW_TYPE_ACCESSIBILITY_VISITOR, Optional.of(requestingPackage));
+  }
+
+  /** Returns true if the raw type of {@code type} is accessible from any package. */
+  static boolean isRawTypePubliclyAccessible(TypeMirror type) {
+    return type.accept(RAW_TYPE_ACCESSIBILITY_VISITOR, Optional.absent());
+  }
+
   private Accessibility() {}
 }
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/CodeBlocks.java b/compiler/src/main/java/dagger/internal/codegen/CodeBlocks.java
index 7c8bf0eec..9a54dc238 100644
--- a/compiler/src/main/java/dagger/internal/codegen/CodeBlocks.java
+++ b/compiler/src/main/java/dagger/internal/codegen/CodeBlocks.java
@@ -18,14 +18,16 @@
 
 import com.google.common.collect.FluentIterable;
 import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.TypeName;
 import java.util.Iterator;
+import java.util.Spliterator;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.TypeMirror;
 
 final class CodeBlocks {
 
-  /**
-   * Returns a comma-separated version of {@code codeBlocks} as one unified {@link CodeBlock}.
-   */
+  /** Returns a comma-separated version of {@code codeBlocks} as one unified {@link CodeBlock}. */
   static CodeBlock makeParametersCodeBlock(Iterable<CodeBlock> codeBlocks) {
     return join(codeBlocks, ", ");
   }
@@ -62,5 +64,37 @@ static CodeBlock stringLiteral(String toWrap) {
     return CodeBlock.of("$S", toWrap);
   }
 
+  /** Returns a javadoc {@literal @link} tag that poins to the given {@link ExecutableElement}. */
+  static CodeBlock javadocLinkTo(ExecutableElement executableElement) {
+    CodeBlock.Builder builder =
+        CodeBlock.builder().add("{@link $T#", executableElement.getEnclosingElement());
+    switch (executableElement.getKind()) {
+      case METHOD:
+        builder.add("$L", executableElement.getSimpleName());
+        break;
+      case CONSTRUCTOR:
+        builder.add("$L", executableElement.getEnclosingElement().getSimpleName());
+        break;
+      case STATIC_INIT:
+      case INSTANCE_INIT:
+        throw new IllegalArgumentException(
+            "cannot create a javadoc link to an initializer: " + executableElement);
+      default:
+        throw new AssertionError(executableElement.toString());
+    }
+    builder.add("(");
+    Spliterator<TypeName> rawTypesSpliterator =
+        executableElement
+            .getParameters()
+            .stream()
+            .map(VariableElement::asType)
+            .map(TypeName::get)
+            .map(TypeNames::rawTypeName)
+            .spliterator();
+    rawTypesSpliterator.tryAdvance(first -> builder.add("$T", first));
+    rawTypesSpliterator.forEachRemaining(remaining -> builder.add(", $T", remaining));
+    return builder.add(")}").build();
+  }
+
   private CodeBlocks() {}
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
index 13504f3a2..5513ae77b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
@@ -27,6 +27,8 @@
 import static dagger.internal.codegen.ContributionBinding.Kind.INJECTION;
 import static dagger.internal.codegen.ContributionBinding.Kind.PROVISION;
 import static dagger.internal.codegen.ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_PROVIDES_METHOD;
+import static dagger.internal.codegen.Proxies.createProxy;
+import static dagger.internal.codegen.Proxies.shouldGenerateProxy;
 import static dagger.internal.codegen.SourceFiles.bindingTypeElementTypeVariableNames;
 import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
 import static dagger.internal.codegen.SourceFiles.generateBindingFieldsForDependencies;
@@ -38,6 +40,7 @@
 import static javax.lang.model.element.Modifier.PUBLIC;
 import static javax.lang.model.element.Modifier.STATIC;
 
+import com.google.auto.common.MoreElements;
 import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
@@ -60,6 +63,7 @@
 import javax.annotation.processing.Filer;
 import javax.inject.Inject;
 import javax.lang.model.element.Element;
+import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.util.Elements;
 import javax.tools.Diagnostic;
 
@@ -270,10 +274,26 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
       factoryBuilder.addMethod(createMethod.get());
     }
 
-    // TODO(gak): write a sensible toString
+    proxyMethodFor(binding).asSet().forEach(factoryBuilder::addMethod);
+
     return Optional.of(factoryBuilder);
   }
 
+  /**
+   * Returns a method to proxy access to the binding's {@link Binding#bindingElement()}, which
+   * behaves according to the description in {@link Proxies}. Use here is further restricted by
+   * whether or not members injection is required, since that is not yet implemented for proxy
+   * methods, but will be added.
+   */
+  // TODO(gak): support accessibility proxies for types with injected members as well
+  private static Optional<MethodSpec> proxyMethodFor(ProvisionBinding binding) {
+    ExecutableElement executableElement = MoreElements.asExecutable(binding.bindingElement().get());
+    if (binding.membersInjectionRequest().isPresent() || !shouldGenerateProxy(executableElement)) {
+      return Optional.absent();
+    }
+    return Optional.of(createProxy(executableElement));
+  }
+
   @CanIgnoreReturnValue
   private FieldSpec addConstructorParameterAndTypeField(
       TypeName typeName,
diff --git a/compiler/src/main/java/dagger/internal/codegen/Proxies.java b/compiler/src/main/java/dagger/internal/codegen/Proxies.java
new file mode 100644
index 000000000..800e3272d
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/Proxies.java
@@ -0,0 +1,252 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.base.CaseFormat.LOWER_CAMEL;
+import static com.google.common.base.CaseFormat.UPPER_CAMEL;
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.collect.Iterables.toArray;
+import static com.squareup.javapoet.MethodSpec.methodBuilder;
+import static dagger.internal.codegen.Accessibility.isElementAccessibleFrom;
+import static dagger.internal.codegen.Accessibility.isElementPubliclyAccessible;
+import static dagger.internal.codegen.Accessibility.isRawTypeAccessible;
+import static dagger.internal.codegen.Accessibility.isRawTypePubliclyAccessible;
+import static dagger.internal.codegen.Accessibility.isTypePubliclyAccessible;
+import static dagger.internal.codegen.CodeBlocks.javadocLinkTo;
+import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
+import static dagger.internal.codegen.TypeNames.rawTypeName;
+import static javax.lang.model.element.Modifier.PUBLIC;
+import static javax.lang.model.element.Modifier.STATIC;
+import static javax.lang.model.type.TypeKind.VOID;
+
+import com.google.auto.common.MoreElements;
+import com.google.common.collect.ImmutableList;
+import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.MethodSpec;
+import com.squareup.javapoet.ParameterSpec;
+import com.squareup.javapoet.TypeName;
+import com.squareup.javapoet.TypeVariableName;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.Parameterizable;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.TypeParameterElement;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.TypeMirror;
+
+/**
+ * Proxy methods ("proxies") are generated methods used to give component implementations access to
+ * {@link Element}s that are inaccessible as written in the source code. For example, a component
+ * cannot directly invoke a package-private {@code @Inject} constructor in a different package.
+ *
+ * <p>Since proxies are generated separately from their usages, they cannot make any assumptions
+ * about the types or packages from which methods will be invoked. Thus, any type or element that is
+ * not public is considered to be "inaccessible".
+ *
+ * <p>This class generates proxies for any {@link ExecutableElement}, but the form of the methods
+ * are somewhat tailored to how they are used within components.
+ *
+ * <p>Proxies have the following attributes:
+ *
+ * <ul>
+ *   <li>Proxies are always {@code public}, {@code static} methods.
+ *   <li>The return type of the proxy is always the return type of the method or the constructed
+ *       type regardless of its accessibility. For example, if a proxied method returns {@code
+ *       MyPackagePrivateClass}, the proxy method will also return {@code MyPackagePrivateClass}
+ *       because the accessibility of the return type does not impact callers.
+ *   <li>Proxies for constructors are named "{@code newTypeName}" (where "{@code TypeName}" is the
+ *       name of the type being constructed) and proxies for methods are named "{@code
+ *       proxyMethodName}" (where "{@code methodName}" is the name of the method being proxied).
+ *   <li>If the element being proxied is an instance method, the first parameter will be the
+ *       instance.
+ *   <li>The rest of the parameters of the proxy method are that of the proxied method unless the
+ *       raw type of a parameter is inaccessible, in which case it is {@link Object}. Passing an
+ *       object to this method that is not of the proxied parameter type will result in a {@link
+ *       ClassCastException}.
+ *       <p>While it is not required by the language that a method's parameter types be accessible
+ *       to invoke it, components often hold references to {@link javax.inject.Provider} as raw
+ *       types in order to dodge similar accessibility restrictions. This means that the {@code
+ *       {@link javax.inject.Provider#get()}} method will return {@link Object}. Since it cannot be
+ *       cast to the the more specific type on the calling side, we must accept {@link Object} in
+ *       the proxy method.
+ * </ul>
+ *
+ * <p>Proxies are not generated under the following conditions:
+ *
+ * <ul>
+ *   <li>If an {@link ExecutableElement} is publicly accessible and all of its {@linkplain
+ *       ExecutableElement#getParameters() parameters} are publicly accessible types, no proxy is
+ *       necessary. If the type of a parameter has a type argument that is is inaccessible, but the
+ *       raw type that is accessible, the type is considered to be accessible because callers can
+ *       always hold references to the raw type.
+ *   <li>If an {@link ExecutableElement} or any of its enclosing types are {@code private}, no proxy
+ *       is generated because it is impossible to write Java (without reflection) that accesses the
+ *       element.
+ * </ul>
+ */
+final class Proxies {
+
+  /**
+   * Returns {@code true} if the given method has limited access, thus requiring a proxy for some
+   * cases.
+   */
+  static boolean shouldGenerateProxy(ExecutableElement method) {
+    return !isElementPubliclyAccessible(method)
+        || method
+            .getParameters()
+            .stream()
+            .map(VariableElement::asType)
+            .anyMatch(type -> !isRawTypePubliclyAccessible(type));
+  }
+
+  /** Returns {@code true} if accessing the given method from the given package requires a proxy. */
+  static boolean requiresProxyAccess(ExecutableElement method, String callingPackage) {
+    return !isElementAccessibleFrom(method, callingPackage)
+        || method
+            .getParameters()
+            .stream()
+            .map(VariableElement::asType)
+            .anyMatch(type -> !isRawTypeAccessible(type, callingPackage));
+  }
+
+  /** Returns the name of the method that proxies access to the given method. */
+  static String proxyName(ExecutableElement method) {
+    switch (method.getKind()) {
+      case CONSTRUCTOR:
+        return "new" + method.getEnclosingElement().getSimpleName();
+      case METHOD:
+        return "proxy" + LOWER_CAMEL.to(UPPER_CAMEL, method.getSimpleName().toString());
+      case STATIC_INIT:
+      case INSTANCE_INIT:
+        throw new IllegalArgumentException(
+            "cannot proxy initializers because they cannot be invoked directly: " + method);
+      default:
+        throw new AssertionError(method);
+    }
+  }
+
+  /**
+   * Returns a proxy method implementation for the method.
+   *
+   * @throws IllegalArgumentException if the method is publicly accessible
+   */
+  // TODO(gak): expand support to proxy fields
+  static MethodSpec createProxy(ExecutableElement method) {
+    checkArgument(
+        shouldGenerateProxy(method),
+        "method and all of its arguments are accessible; proxy isn't necessary: %s",
+        method);
+    final MethodSpec.Builder builder;
+    switch (method.getKind()) {
+      case CONSTRUCTOR:
+        builder = forConstructor(method);
+        break;
+      case METHOD:
+        builder = forMethod(method);
+        break;
+      default:
+        throw new AssertionError();
+    }
+    builder.addJavadoc("Proxies $L.", javadocLinkTo(method));
+    builder.addModifiers(PUBLIC, STATIC);
+
+    copyTypeParameters(method, builder);
+    copyThrows(method, builder);
+
+    return builder.build();
+  }
+
+  private static MethodSpec.Builder forConstructor(ExecutableElement constructor) {
+    TypeElement enclosingType = MoreElements.asType(constructor.getEnclosingElement());
+    MethodSpec.Builder methodBuilder = methodBuilder(proxyName(constructor));
+
+    copyTypeParameters(enclosingType, methodBuilder);
+
+    methodBuilder.returns(TypeName.get(enclosingType.asType()));
+
+    CodeBlock arguments =
+        copyParameters(
+            constructor, methodBuilder, new UniqueNameSet(), new ImmutableList.Builder<>());
+
+    methodBuilder.addCode("return new $T($L);", enclosingType, arguments);
+
+    return methodBuilder;
+  }
+
+  private static MethodSpec.Builder forMethod(ExecutableElement method) {
+    TypeElement enclosingType = MoreElements.asType(method.getEnclosingElement());
+    MethodSpec.Builder methodBuilder = methodBuilder(proxyName(method));
+
+    UniqueNameSet nameSet = new UniqueNameSet();
+    ImmutableList.Builder<CodeBlock> argumentsBuilder = new ImmutableList.Builder<>();
+    if (!method.getModifiers().contains(STATIC)) {
+      methodBuilder.addParameter(
+          TypeName.get(enclosingType.asType()), nameSet.getUniqueName("instance"));
+    }
+    CodeBlock arguments = copyParameters(method, methodBuilder, nameSet, argumentsBuilder);
+    if (!method.getReturnType().getKind().equals(VOID)) {
+      methodBuilder.addCode("return ");
+    }
+    if (method.getModifiers().contains(STATIC)) {
+      methodBuilder.addCode("$T", rawTypeName(TypeName.get(enclosingType.asType())));
+    } else {
+      copyTypeParameters(enclosingType, methodBuilder);
+      // "instance" is guaranteed b/c it was the first name into the UniqueNameSet
+      methodBuilder.addCode("instance", method.getSimpleName());
+    }
+    methodBuilder.addCode(".$N($L);", method.getSimpleName(), arguments);
+    methodBuilder.returns(TypeName.get(method.getReturnType()));
+    return methodBuilder;
+  }
+
+  private static void copyThrows(ExecutableElement method, MethodSpec.Builder methodBuilder) {
+    for (TypeMirror thrownType : method.getThrownTypes()) {
+      methodBuilder.addException(TypeName.get(thrownType));
+    }
+  }
+
+  private static CodeBlock copyParameters(
+      ExecutableElement method,
+      MethodSpec.Builder methodBuilder,
+      UniqueNameSet nameSet,
+      ImmutableList.Builder<CodeBlock> argumentsBuilder) {
+    for (VariableElement parameter : method.getParameters()) {
+      TypeMirror parameterType = parameter.asType();
+      boolean useObject = !isTypePubliclyAccessible(parameterType);
+      TypeName typeName = useObject ? TypeName.OBJECT : TypeName.get(parameterType);
+      String name = nameSet.getUniqueName(parameter.getSimpleName().toString());
+      argumentsBuilder.add(
+          useObject ? CodeBlock.of("($T) $L", parameterType, name) : CodeBlock.of(name));
+      ParameterSpec.Builder parameterBuilder =
+          ParameterSpec.builder(typeName, name)
+              .addModifiers(toArray(parameter.getModifiers(), Modifier.class));
+      methodBuilder.addParameter(parameterBuilder.build());
+    }
+    methodBuilder.varargs(method.isVarArgs());
+    return makeParametersCodeBlock(argumentsBuilder.build());
+  }
+
+  private static void copyTypeParameters(
+      Parameterizable parameterizable, MethodSpec.Builder methodBuilder) {
+    for (TypeParameterElement typeParameterElement : parameterizable.getTypeParameters()) {
+      methodBuilder.addTypeVariable(TypeVariableName.get(typeParameterElement));
+    }
+  }
+
+  private Proxies() {}
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/SimpleMethodRequestFulfillment.java b/compiler/src/main/java/dagger/internal/codegen/SimpleMethodRequestFulfillment.java
index e6f040984..add65fd31 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SimpleMethodRequestFulfillment.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SimpleMethodRequestFulfillment.java
@@ -19,20 +19,22 @@
 import static com.google.auto.common.MoreElements.asExecutable;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkState;
-import static dagger.internal.codegen.Accessibility.isElementAccessibleFrom;
 import static dagger.internal.codegen.Accessibility.isTypeAccessibleFrom;
+import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
+import static dagger.internal.codegen.Proxies.proxyName;
+import static dagger.internal.codegen.Proxies.requiresProxyAccess;
+import static dagger.internal.codegen.SourceFiles.generatedClassNameForBinding;
+import static dagger.internal.codegen.TypeNames.rawTypeName;
+import static java.util.stream.Collectors.collectingAndThen;
 import static java.util.stream.Collectors.toList;
 import static javax.lang.model.element.Modifier.STATIC;
 
 import com.google.common.util.concurrent.Futures;
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
-import com.squareup.javapoet.ParameterizedTypeName;
 import com.squareup.javapoet.TypeName;
 import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeMirror;
-import javax.lang.model.util.SimpleTypeVisitor8;
 
 /**
  * A request fulfillment implementation that invokes methods or constructors directly to fulfill
@@ -64,69 +66,38 @@
 
   @Override
   CodeBlock getSnippetForDependencyRequest(DependencyRequest request, ClassName requestingClass) {
-    String requestingPackage = requestingClass.packageName();
-    /* This is where we do some checking to make sure we honor and/or dodge accessibility
-     * restrictions:
-     *
-     * 1. Check to make sure that the method/constructor that we're trying to invoke is accessible.
-     * 2. Check that the *raw type* of each parameter is accessible.  If something is only
-     *    inaccessible due to a type variable, we do a raw type cast just like we do for framework
-     *    types.
-     */
-    // TODO(gak): the accessibility limitation here needs to be addressed
-    if (!isElementAccessibleFrom(provisionBinding.bindingElement().get(), requestingPackage)
-        || provisionBinding
-            .dependencies()
-            .stream()
-            .anyMatch(
-                dependencyRequest ->
-                    !isRawTypeAccessible(dependencyRequest.key().type(), requestingPackage))) {
-      return providerDelegate.getSnippetForDependencyRequest(request, requestingClass);
-    }
     switch (request.kind()) {
       case INSTANCE:
-        return invokeMethod(requestingClass);
+        return invokeMethodOrProxy(requestingClass);
       case FUTURE:
-        return CodeBlock.of("$T.immediateFuture($L)", Futures.class, invokeMethod(requestingClass));
+        return CodeBlock.of(
+            "$T.immediateFuture($L)", Futures.class, invokeMethodOrProxy(requestingClass));
       default:
         return providerDelegate.getSnippetForDependencyRequest(request, requestingClass);
     }
   }
 
-  public static final SimpleTypeVisitor8<Boolean, String> RAW_TYPE_ACCESSIBILITY_VISITOR =
-      new SimpleTypeVisitor8<Boolean, String>() {
-        @Override
-        protected Boolean defaultAction(TypeMirror e, String requestingPackage) {
-          return isTypeAccessibleFrom(e, requestingPackage);
-        }
-
-        @Override
-        public Boolean visitDeclared(DeclaredType t, String requestingPackage) {
-          return isElementAccessibleFrom(t.asElement(), requestingPackage);
-        }
-      };
-
-  private static boolean isRawTypeAccessible(TypeMirror type, String requestingPackage) {
-    return type.accept(RAW_TYPE_ACCESSIBILITY_VISITOR, requestingPackage);
+  private CodeBlock invokeMethodOrProxy(ClassName requestingClass) {
+    ExecutableElement bindingElement = asExecutable(provisionBinding.bindingElement().get());
+    return requiresProxyAccess(bindingElement, requestingClass.packageName())
+        ? invokeProxyMethod(requestingClass)
+        : invokeMethod(requestingClass);
   }
 
   private CodeBlock invokeMethod(ClassName requestingClass) {
     CodeBlock parametersCodeBlock =
-        CodeBlocks.makeParametersCodeBlock(
+        makeParametersCodeBlock(
             provisionBinding
                 .explicitDependencies()
                 .stream()
                 .map(
                     request -> {
-                      CodeBlock snippet =
-                          registry
-                              .getRequestFulfillment(request.bindingKey())
-                              .getSnippetForDependencyRequest(request, requestingClass);
-                      return isTypeAccessibleFrom(
-                              request.key().type(), requestingClass.packageName())
+                      CodeBlock snippet = getDependencySnippet(requestingClass, request);
+                      TypeMirror requestElementType = request.requestElement().get().asType();
+                      return isTypeAccessibleFrom(requestElementType, requestingClass.packageName())
                           ? snippet
                           : CodeBlock.of(
-                              "($T) $L", rawTypeName(TypeName.get(request.key().type())), snippet);
+                              "($T) $L", rawTypeName(TypeName.get(requestElementType)), snippet);
                     })
                 .collect(toList()));
     // we use the type from the key to ensure we get the right generics
@@ -147,9 +118,21 @@ private CodeBlock invokeMethod(ClassName requestingClass) {
     }
   }
 
-  private static TypeName rawTypeName(TypeName typeName) {
-    return (typeName instanceof ParameterizedTypeName)
-        ? ((ParameterizedTypeName) typeName).rawType
-        : typeName;
+  private CodeBlock invokeProxyMethod(ClassName requestingClass) {
+    return CodeBlock.of(
+        "$T.$L($L)",
+        generatedClassNameForBinding(provisionBinding),
+        proxyName(asExecutable(provisionBinding.bindingElement().get())),
+        provisionBinding
+            .explicitDependencies()
+            .stream()
+            .map(request -> getDependencySnippet(requestingClass, request))
+            .collect(collectingAndThen(toList(), CodeBlocks::makeParametersCodeBlock)));
+  }
+
+  private CodeBlock getDependencySnippet(ClassName requestingClass, DependencyRequest request) {
+    return registry
+        .getRequestFulfillment(request.bindingKey())
+        .getSnippetForDependencyRequest(request, requestingClass);
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/TypeNames.java b/compiler/src/main/java/dagger/internal/codegen/TypeNames.java
index 6003cc128..3c427b0bb 100644
--- a/compiler/src/main/java/dagger/internal/codegen/TypeNames.java
+++ b/compiler/src/main/java/dagger/internal/codegen/TypeNames.java
@@ -156,6 +156,16 @@ static ParameterizedTypeName providerOf(TypeName typeName) {
   static ParameterizedTypeName setOf(TypeName elementType) {
     return ParameterizedTypeName.get(SET, elementType);
   }
-  
+
+  /**
+   * Returns the {@link TypeName} for the raw type of the given type name. If the argument isn't a
+   * parameterized type, it returns the argument unchanged.
+   */
+  static TypeName rawTypeName(TypeName typeName) {
+    return (typeName instanceof ParameterizedTypeName)
+        ? ((ParameterizedTypeName) typeName).rawType
+        : typeName;
+  }
+
   private TypeNames() {}
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/InaccessibleTypeTest.java b/compiler/src/test/java/dagger/internal/codegen/InaccessibleTypeTest.java
index df427c5a5..07ce587c5 100644
--- a/compiler/src/test/java/dagger/internal/codegen/InaccessibleTypeTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/InaccessibleTypeTest.java
@@ -74,65 +74,71 @@
         "interface TestComponent {",
         "  PublicClass publicClass();",
         "}");
-    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
-        "test.DaggerTestComponent",
-        "package test;",
-        "",
-        "import foreign.NoDepClass_Factory;",
-        "import foreign.NonPublicClass1_Factory;",
-        "import foreign.NonPublicClass2_Factory;",
-        "import foreign.PublicClass;",
-        "import foreign.PublicClass_Factory;",
-        "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
-        "",
-        GENERATED_ANNOTATION,
-        "public final class DaggerTestComponent implements TestComponent {",
-        "  @SuppressWarnings(\"rawtypes\")",
-        "  private Provider nonPublicClass1Provider;",
-        "  @SuppressWarnings(\"rawtypes\")",
-        "  private Provider nonPublicClass2Provider;",
-        "  private Provider<PublicClass> publicClassProvider;",
-        "",
-        "  private DaggerTestComponent(Builder builder) {",
-        "    assert builder != null;",
-        "    initialize(builder);",
-        "  }",
-        "",
-        "  public static Builder builder() {",
-        "    return new Builder();",
-        "  }",
-        "",
-        "  public static TestComponent create() {",
-        "    return builder().build();",
-        "  }",
-        "",
-        "  @SuppressWarnings(\"unchecked\")",
-        "  private void initialize(final Builder builder) {",
-        "    this.nonPublicClass1Provider =",
-        "        NonPublicClass1_Factory.create(NoDepClass_Factory.create());",
-        "    this.nonPublicClass2Provider =",
-        "        NonPublicClass2_Factory.create(NoDepClass_Factory.create());",
-        "    this.publicClassProvider = PublicClass_Factory.create(",
-        "        nonPublicClass1Provider,",
-        "        nonPublicClass2Provider,",
-        "        NoDepClass_Factory.create());",
-        "  }",
-        "",
-        "  @Override",
-        "  public PublicClass publicClass() {",
-        "    return publicClassProvider.get();",
-        "  }",
-        "",
-        "  public static final class Builder {",
-        "    private Builder() {",
-        "    }",
-        "",
-        "    public TestComponent build() {",
-        "      return new DaggerTestComponent(this);",
-        "    }",
-        "  }",
-        "}");
+    JavaFileObject generatedComponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerTestComponent",
+            "package test;",
+            "",
+            "import foreign.NoDepClass_Factory;",
+            "import foreign.NonPublicClass1_Factory;",
+            "import foreign.NonPublicClass2_Factory;",
+            "import foreign.PublicClass;",
+            "import foreign.PublicClass_Factory;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerTestComponent implements TestComponent {",
+            "  @SuppressWarnings(\"rawtypes\")",
+            "  private Provider nonPublicClass1Provider;",
+            "  @SuppressWarnings(\"rawtypes\")",
+            "  private Provider nonPublicClass2Provider;",
+            "  private Provider<PublicClass> publicClassProvider;",
+            "",
+            "  private DaggerTestComponent(Builder builder) {",
+            "    assert builder != null;",
+            "    initialize(builder);",
+            "  }",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static TestComponent create() {",
+            "    return builder().build();",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize(final Builder builder) {",
+            "    this.nonPublicClass1Provider =",
+            "        NonPublicClass1_Factory.create(NoDepClass_Factory.create());",
+            "    this.nonPublicClass2Provider =",
+            "        NonPublicClass2_Factory.create(NoDepClass_Factory.create());",
+            "    this.publicClassProvider = PublicClass_Factory.create(",
+            "        nonPublicClass1Provider,",
+            "        nonPublicClass2Provider,",
+            "        NoDepClass_Factory.create());",
+            "  }",
+            "",
+            "  @Override",
+            "  public PublicClass publicClass() {",
+            "    return PublicClass_Factory.newPublicClass(",
+            "        NonPublicClass1_Factory.newNonPublicClass1(",
+            "            NoDepClass_Factory.newNoDepClass()),",
+            "        NonPublicClass2_Factory.newNonPublicClass2(",
+            "            NoDepClass_Factory.newNoDepClass()),",
+            "        NoDepClass_Factory.newNoDepClass());",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private Builder() {",
+            "    }",
+            "",
+            "    public TestComponent build() {",
+            "      return new DaggerTestComponent(this);",
+            "    }",
+            "  }",
+            "}");
     assertAbout(javaSources())
         .that(ImmutableList.of(
             noDepClassFile,
diff --git a/compiler/src/test/java/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java b/compiler/src/test/java/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java
index a23a5008b..bf557bdc8 100644
--- a/compiler/src/test/java/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java
@@ -132,31 +132,37 @@
         "class GenericClass<T> {",
         "  @Inject GenericClass(T t) {}",
         "}");
-    JavaFileObject expected = JavaFileObjects.forSourceLines("test.GenericClass_Factory",
-        "package test;",
-        "",
-        "import dagger.internal.Factory;",
-        "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
-        "",
-        GENERATED_ANNOTATION,
-        "public final class GenericClass_Factory<T> implements Factory<GenericClass<T>> {",
-        "  private final Provider<T> tProvider;",
-        "",
-        "  public GenericClass_Factory(Provider<T> tProvider) {",
-        "    assert tProvider != null;",
-        "    this.tProvider = tProvider;",
-        "  }",
-        "",
-        "  @Override",
-        "  public GenericClass<T> get() {",
-        "    return new GenericClass<T>(tProvider.get());",
-        "  }",
-        "",
-        "  public static <T> Factory<GenericClass<T>> create(Provider<T> tProvider) {",
-        "    return new GenericClass_Factory<T>(tProvider);",
-        "  }",
-        "}");
+    JavaFileObject expected =
+        JavaFileObjects.forSourceLines(
+            "test.GenericClass_Factory",
+            "package test;",
+            "",
+            "import dagger.internal.Factory;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class GenericClass_Factory<T> implements Factory<GenericClass<T>> {",
+            "  private final Provider<T> tProvider;",
+            "",
+            "  public GenericClass_Factory(Provider<T> tProvider) {",
+            "    assert tProvider != null;",
+            "    this.tProvider = tProvider;",
+            "  }",
+            "",
+            "  @Override",
+            "  public GenericClass<T> get() {",
+            "    return new GenericClass<T>(tProvider.get());",
+            "  }",
+            "",
+            "  public static <T> Factory<GenericClass<T>> create(Provider<T> tProvider) {",
+            "    return new GenericClass_Factory<T>(tProvider);",
+            "  }",
+            "",
+            "  public static <T> GenericClass<T> newGenericClass(T t) {",
+            "    return new GenericClass<T>(t);",
+            "  }",
+            "}");
     assertAbout(javaSource()).that(file)
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
@@ -245,6 +251,9 @@
             "    return (Factory) INSTANCE;",
             "  }",
             "",
+            "  public static <T> GenericClass<T> newGenericClass() {",
+            "    return new GenericClass<T>();",
+            "  }",
             "}");
     assertAbout(javaSource()).that(file)
         .processedWith(new ComponentProcessor())
@@ -261,35 +270,41 @@
         "class GenericClass<A, B> {",
         "  @Inject GenericClass(A a, B b) {}",
         "}");
-    JavaFileObject expected = JavaFileObjects.forSourceLines("test.GenericClass_Factory",
-        "package test;",
-        "",
-        "import dagger.internal.Factory;",
-        "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
-        "",
-        GENERATED_ANNOTATION,
-        "public final class GenericClass_Factory<A, B> implements Factory<GenericClass<A, B>> {",
-        "  private final Provider<A> aProvider;",
-        "  private final Provider<B> bProvider;",
-        "",
-        "  public GenericClass_Factory(Provider<A> aProvider, Provider<B> bProvider) {",
-        "    assert aProvider != null;",
-        "    this.aProvider = aProvider;",
-        "    assert bProvider != null;",
-        "    this.bProvider = bProvider;",
-        "  }",
-        "",
-        "  @Override",
-        "  public GenericClass<A, B> get() {",
-        "    return new GenericClass<A, B>(aProvider.get(), bProvider.get());",
-        "  }",
-        "",
-        "  public static <A, B> Factory<GenericClass<A, B>> create(",
-        "      Provider<A> aProvider, Provider<B> bProvider) {",
-        "    return new GenericClass_Factory<A, B>(aProvider, bProvider);",
-        "  }",
-        "}");
+    JavaFileObject expected =
+        JavaFileObjects.forSourceLines(
+            "test.GenericClass_Factory",
+            "package test;",
+            "",
+            "import dagger.internal.Factory;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class GenericClass_Factory<A, B> implements Factory<GenericClass<A, B>> {",
+            "  private final Provider<A> aProvider;",
+            "  private final Provider<B> bProvider;",
+            "",
+            "  public GenericClass_Factory(Provider<A> aProvider, Provider<B> bProvider) {",
+            "    assert aProvider != null;",
+            "    this.aProvider = aProvider;",
+            "    assert bProvider != null;",
+            "    this.bProvider = bProvider;",
+            "  }",
+            "",
+            "  @Override",
+            "  public GenericClass<A, B> get() {",
+            "    return new GenericClass<A, B>(aProvider.get(), bProvider.get());",
+            "  }",
+            "",
+            "  public static <A, B> Factory<GenericClass<A, B>> create(",
+            "      Provider<A> aProvider, Provider<B> bProvider) {",
+            "    return new GenericClass_Factory<A, B>(aProvider, bProvider);",
+            "  }",
+            "",
+            "  public static <A, B> GenericClass<A, B> newGenericClass(A a, B b) {",
+            "    return new GenericClass<A, B>(a, b);",
+            "  }",
+            "}");
     assertAbout(javaSource()).that(file)
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
@@ -308,46 +323,57 @@
         "    C extends List<? super String>> {",
         "  @Inject GenericClass(A a, B b, C c) {}",
         "}");
-    JavaFileObject expected = JavaFileObjects.forSourceLines("test.GenericClass_Factory",
-        "package test;",
-        "",
-        "import dagger.internal.Factory;",
-        "import java.util.List;",
-        "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
-        "",
-        GENERATED_ANNOTATION,
-        "public final class GenericClass_Factory<A extends Number & Comparable<A>,",
-        "        B extends List<? extends String>,",
-        "        C extends List<? super String>>",
-        "    implements Factory<GenericClass<A, B, C>> {",
-        "  private final Provider<A> aProvider;",
-        "  private final Provider<B> bProvider;",
-        "  private final Provider<C> cProvider;",
-        "",
-        "  public GenericClass_Factory(Provider<A> aProvider,",
-        "      Provider<B> bProvider,",
-        "      Provider<C> cProvider) {",
-        "    assert aProvider != null;",
-        "    this.aProvider = aProvider;",
-        "    assert bProvider != null;",
-        "    this.bProvider = bProvider;",
-        "    assert cProvider != null;",
-        "    this.cProvider = cProvider;",
-        "  }",
-        "",
-        "  @Override",
-        "  public GenericClass<A, B, C> get() {",
-        "    return new GenericClass<A, B, C>(aProvider.get(), bProvider.get(), cProvider.get());",
-        "  }",
-        "",
-        "  public static <A extends Number & Comparable<A>,",
-        "      B extends List<? extends String>,",
-        "      C extends List<? super String>> Factory<GenericClass<A, B, C>> create(",
-        "          Provider<A> aProvider, Provider<B> bProvider, Provider<C> cProvider) {",
-        "    return new GenericClass_Factory<A, B, C>(aProvider, bProvider, cProvider);",
-        "  }",
-        "}");
+    JavaFileObject expected =
+        JavaFileObjects.forSourceLines(
+            "test.GenericClass_Factory",
+            "package test;",
+            "",
+            "import dagger.internal.Factory;",
+            "import java.util.List;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class GenericClass_Factory<A extends Number & Comparable<A>,",
+            "        B extends List<? extends String>,",
+            "        C extends List<? super String>>",
+            "    implements Factory<GenericClass<A, B, C>> {",
+            "  private final Provider<A> aProvider;",
+            "  private final Provider<B> bProvider;",
+            "  private final Provider<C> cProvider;",
+            "",
+            "  public GenericClass_Factory(Provider<A> aProvider,",
+            "      Provider<B> bProvider,",
+            "      Provider<C> cProvider) {",
+            "    assert aProvider != null;",
+            "    this.aProvider = aProvider;",
+            "    assert bProvider != null;",
+            "    this.bProvider = bProvider;",
+            "    assert cProvider != null;",
+            "    this.cProvider = cProvider;",
+            "  }",
+            "",
+            "  @Override",
+            "  public GenericClass<A, B, C> get() {",
+            "    return new GenericClass<A, B, C>(",
+            "        aProvider.get(), bProvider.get(), cProvider.get());",
+            "  }",
+            "",
+            "  public static <A extends Number & Comparable<A>,",
+            "      B extends List<? extends String>,",
+            "      C extends List<? super String>> Factory<GenericClass<A, B, C>> create(",
+            "          Provider<A> aProvider, Provider<B> bProvider, Provider<C> cProvider) {",
+            "    return new GenericClass_Factory<A, B, C>(aProvider, bProvider, cProvider);",
+            "  }",
+            "",
+            "  public static <",
+            "          A extends Number & Comparable<A>,",
+            "          B extends List<? extends String>,",
+            "          C extends List<? super String>>",
+            "      GenericClass<A, B, C> newGenericClass(A a, B b, C c) {",
+            "    return new GenericClass<A, B, C>(a, b, c);",
+            "  }",
+            "}");
     assertAbout(javaSource()).that(file)
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
@@ -373,13 +399,15 @@
             "test.GenericClass_Factory",
             "package test;",
             "",
+            "import dagger.Lazy;",
             "import dagger.internal.DoubleCheck;",
             "import dagger.internal.Factory;",
             "import javax.annotation.Generated;",
             "import javax.inject.Provider;",
             "",
             GENERATED_ANNOTATION,
-            "public final class GenericClass_Factory<A, B> implements Factory<GenericClass<A, B>> {",
+            "public final class GenericClass_Factory<A, B>",
+            "    implements Factory<GenericClass<A, B>> {",
             "  private final Provider<A> aAndA2AndPaAndLaProvider;",
             "  private final Provider<A> qaProvider;",
             "  private final Provider<String> sAndS2AndPsAndLsProvider;",
@@ -442,6 +470,26 @@
             "        bAndB2AndPbAndLbProvider,",
             "        qbProvider);",
             "  }",
+            "",
+            "  public static <A, B> GenericClass<A, B> newGenericClass(",
+            "      A a,",
+            "      A a2,",
+            "      Provider<A> pa,",
+            "      A qa,",
+            "      Lazy<A> la,",
+            "      String s,",
+            "      String s2,",
+            "      Provider<String> ps,",
+            "      String qs,",
+            "      Lazy<String> ls,",
+            "      B b,",
+            "      B b2,",
+            "      Provider<B> pb,",
+            "      B qb,",
+            "      Lazy<B> lb) {",
+            "    return new GenericClass<A, B>(",
+            "        a, a2, pa, qa, la, s, s2, ps, qs, ls, b, b2, pb, qb, lb);",
+            "  }",
             "}");
     assertAbout(javaSources()).that(ImmutableList.of(file, QUALIFIER_A))
         .processedWith(new ComponentProcessor())
@@ -924,33 +972,38 @@
         "class InjectConstructor {",
         "  @Inject InjectConstructor(String s) {}",
         "}");
-    JavaFileObject expected = JavaFileObjects.forSourceLines(
-        "test.InjectConstructor_Factory",
-        "package test;",
-        "",
-        "import dagger.internal.Factory;",
-        "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
-        "",
-        GENERATED_ANNOTATION,
-        "public final class InjectConstructor_Factory ",
-        "    implements Factory<InjectConstructor> {",
-        "",
-        "  private final Provider<String> sProvider;",
-        "",
-        "  public InjectConstructor_Factory(Provider<String> sProvider) {",
-        "    assert sProvider != null;",
-        "    this.sProvider = sProvider;",
-        "  }",
-        "",
-        "  @Override public InjectConstructor get() {",
-        "    return new InjectConstructor(sProvider.get());",
-        "  }",
-        "",
-        "  public static Factory<InjectConstructor> create(Provider<String> sProvider) {",
-        "    return new InjectConstructor_Factory(sProvider);",
-        "  }",
-        "}");
+    JavaFileObject expected =
+        JavaFileObjects.forSourceLines(
+            "test.InjectConstructor_Factory",
+            "package test;",
+            "",
+            "import dagger.internal.Factory;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class InjectConstructor_Factory ",
+            "    implements Factory<InjectConstructor> {",
+            "",
+            "  private final Provider<String> sProvider;",
+            "",
+            "  public InjectConstructor_Factory(Provider<String> sProvider) {",
+            "    assert sProvider != null;",
+            "    this.sProvider = sProvider;",
+            "  }",
+            "",
+            "  @Override public InjectConstructor get() {",
+            "    return new InjectConstructor(sProvider.get());",
+            "  }",
+            "",
+            "  public static Factory<InjectConstructor> create(Provider<String> sProvider) {",
+            "    return new InjectConstructor_Factory(sProvider);",
+            "  }",
+            "",
+            "  public static InjectConstructor newInjectConstructor(String s) {",
+            "    return new InjectConstructor(s);",
+            "  }",
+            "}");
     assertAbout(javaSource()).that(file).processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and().generatesSources(expected);
@@ -1069,35 +1122,40 @@ public void wildcardDependency() {
         "class InjectConstructor {",
         "  @Inject InjectConstructor(List<?> objects) {}",
         "}");
-    JavaFileObject expected = JavaFileObjects.forSourceLines(
-        "test.InjectConstructor_Factory",
-        "package test;",
-        "",
-        "import dagger.internal.Factory;",
-        "import java.util.List;",
-        "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
-        "",
-        GENERATED_ANNOTATION,
-        "public final class InjectConstructor_Factory ",
-        "    implements Factory<InjectConstructor> {",
-        "",
-        "  private final Provider<List<?>> objectsProvider;",
-        "",
-        "  public InjectConstructor_Factory(Provider<List<?>> objectsProvider) {",
-        "    assert objectsProvider != null;",
-        "    this.objectsProvider = objectsProvider;",
-        "  }",
-        "",
-        "  @Override public InjectConstructor get() {",
-        "    return new InjectConstructor(objectsProvider.get());",
-        "  }",
-        "",
-        "  public static Factory<InjectConstructor> create(",
-        "      Provider<List<?>> objectsProvider) {",
-        "    return new InjectConstructor_Factory(objectsProvider);",
-        "  }",
-        "}");
+    JavaFileObject expected =
+        JavaFileObjects.forSourceLines(
+            "test.InjectConstructor_Factory",
+            "package test;",
+            "",
+            "import dagger.internal.Factory;",
+            "import java.util.List;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class InjectConstructor_Factory ",
+            "    implements Factory<InjectConstructor> {",
+            "",
+            "  private final Provider<List<?>> objectsProvider;",
+            "",
+            "  public InjectConstructor_Factory(Provider<List<?>> objectsProvider) {",
+            "    assert objectsProvider != null;",
+            "    this.objectsProvider = objectsProvider;",
+            "  }",
+            "",
+            "  @Override public InjectConstructor get() {",
+            "    return new InjectConstructor(objectsProvider.get());",
+            "  }",
+            "",
+            "  public static Factory<InjectConstructor> create(",
+            "      Provider<List<?>> objectsProvider) {",
+            "    return new InjectConstructor_Factory(objectsProvider);",
+            "  }",
+            "",
+            "  public static InjectConstructor newInjectConstructor(List<?> objects) {",
+            "    return new InjectConstructor(objects);",
+            "  }",
+            "}");
     assertAbout(javaSource()).that(file).processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and().generatesSources(expected);
@@ -1118,34 +1176,39 @@ public void basicNameCollision() {
         "class InjectConstructor {",
         "  @Inject InjectConstructor(Factory factory) {}",
         "}");
-    JavaFileObject expected = JavaFileObjects.forSourceLines(
-        "test.InjectConstructor_Factory",
-        "package test;",
-        "",
-        "import dagger.internal.Factory;",
-        "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
-        "",
-        GENERATED_ANNOTATION,
-        "public final class InjectConstructor_Factory ",
-        "    implements Factory<InjectConstructor> {",
-        "",
-        "  private final Provider<other.pkg.Factory> factoryProvider;",
-        "",
-        "  public InjectConstructor_Factory(Provider<other.pkg.Factory> factoryProvider) {",
-        "    assert factoryProvider != null;",
-        "    this.factoryProvider = factoryProvider;",
-        "  }",
-        "",
-        "  @Override public InjectConstructor get() {",
-        "    return new InjectConstructor(factoryProvider.get());",
-        "  }",
-        "",
-        "  public static Factory<InjectConstructor> create(",
-        "      Provider<other.pkg.Factory> factoryProvider) {",
-        "    return new InjectConstructor_Factory(factoryProvider);",
-        "  }",
-        "}");
+    JavaFileObject expected =
+        JavaFileObjects.forSourceLines(
+            "test.InjectConstructor_Factory",
+            "package test;",
+            "",
+            "import dagger.internal.Factory;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class InjectConstructor_Factory ",
+            "    implements Factory<InjectConstructor> {",
+            "",
+            "  private final Provider<other.pkg.Factory> factoryProvider;",
+            "",
+            "  public InjectConstructor_Factory(Provider<other.pkg.Factory> factoryProvider) {",
+            "    assert factoryProvider != null;",
+            "    this.factoryProvider = factoryProvider;",
+            "  }",
+            "",
+            "  @Override public InjectConstructor get() {",
+            "    return new InjectConstructor(factoryProvider.get());",
+            "  }",
+            "",
+            "  public static Factory<InjectConstructor> create(",
+            "      Provider<other.pkg.Factory> factoryProvider) {",
+            "    return new InjectConstructor_Factory(factoryProvider);",
+            "  }",
+            "",
+            "  public static InjectConstructor newInjectConstructor(other.pkg.Factory factory) {",
+            "    return new InjectConstructor(factory);",
+            "  }",
+            "}");
     assertAbout(javaSources()).that(ImmutableList.of(factoryFile, file))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
@@ -1169,35 +1232,40 @@ public void nestedNameCollision() {
         "class InjectConstructor {",
         "  @Inject InjectConstructor(Outer.Factory factory) {}",
         "}");
-    JavaFileObject expected = JavaFileObjects.forSourceLines(
-        "test.InjectConstructor_Factory",
-        "package test;",
-        "",
-        "import dagger.internal.Factory;",
-        "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
-        "import other.pkg.Outer;",
-        "",
-        GENERATED_ANNOTATION,
-        "public final class InjectConstructor_Factory ",
-        "    implements Factory<InjectConstructor> {",
-        "",
-        "  private final Provider<Outer.Factory> factoryProvider;",
-        "",
-        "  public InjectConstructor_Factory(Provider<Outer.Factory> factoryProvider) {",
-        "    assert factoryProvider != null;",
-        "    this.factoryProvider = factoryProvider;",
-        "  }",
-        "",
-        "  @Override public InjectConstructor get() {",
-        "    return new InjectConstructor(factoryProvider.get());",
-        "  }",
-        "",
-        "  public static Factory<InjectConstructor> create(",
-        "      Provider<Outer.Factory> factoryProvider) {",
-        "    return new InjectConstructor_Factory(factoryProvider);",
-        "  }",
-        "}");
+    JavaFileObject expected =
+        JavaFileObjects.forSourceLines(
+            "test.InjectConstructor_Factory",
+            "package test;",
+            "",
+            "import dagger.internal.Factory;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "import other.pkg.Outer;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class InjectConstructor_Factory ",
+            "    implements Factory<InjectConstructor> {",
+            "",
+            "  private final Provider<Outer.Factory> factoryProvider;",
+            "",
+            "  public InjectConstructor_Factory(Provider<Outer.Factory> factoryProvider) {",
+            "    assert factoryProvider != null;",
+            "    this.factoryProvider = factoryProvider;",
+            "  }",
+            "",
+            "  @Override public InjectConstructor get() {",
+            "    return new InjectConstructor(factoryProvider.get());",
+            "  }",
+            "",
+            "  public static Factory<InjectConstructor> create(",
+            "      Provider<Outer.Factory> factoryProvider) {",
+            "    return new InjectConstructor_Factory(factoryProvider);",
+            "  }",
+            "",
+            "  public static InjectConstructor newInjectConstructor(Outer.Factory factory) {",
+            "    return new InjectConstructor(factory);",
+            "  }",
+            "}");
     assertAbout(javaSources()).that(ImmutableList.of(factoryFile, file))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
@@ -1223,39 +1291,47 @@ public void samePackageNameCollision() {
         "class InjectConstructor implements CommonName {",
         "  @Inject InjectConstructor(other.pkg.CommonName otherPackage, CommonName samePackage) {}",
         "}");
-    JavaFileObject expected = JavaFileObjects.forSourceLines(
-        "test.InjectConstructor_Factory",
-        "package test;",
-        "",
-        "import dagger.internal.Factory;",
-        "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
-        "",
-        GENERATED_ANNOTATION,
-        "public final class InjectConstructor_Factory ",
-        "    implements Factory<InjectConstructor> {",
-        "",
-        "  private final Provider<other.pkg.CommonName> otherPackageProvider;",
-        "  private final Provider<CommonName> samePackageProvider;",
-        "",
-        "  public InjectConstructor_Factory(Provider<other.pkg.CommonName> otherPackageProvider,",
-        "      Provider<CommonName> samePackageProvider) {",
-        "    assert otherPackageProvider != null;",
-        "    this.otherPackageProvider = otherPackageProvider;",
-        "    assert samePackageProvider != null;",
-        "    this.samePackageProvider = samePackageProvider;",
-        "  }",
-        "",
-        "  @Override public InjectConstructor get() {",
-        "    return new InjectConstructor(otherPackageProvider.get(), samePackageProvider.get());",
-        "  }",
-        "",
-        "  public static Factory<InjectConstructor> create(",
-        "      Provider<other.pkg.CommonName> otherPackageProvider,",
-        "      Provider<CommonName> samePackageProvider) {",
-        "    return new InjectConstructor_Factory(otherPackageProvider, samePackageProvider);",
-        "  }",
-        "}");
+    JavaFileObject expected =
+        JavaFileObjects.forSourceLines(
+            "test.InjectConstructor_Factory",
+            "package test;",
+            "",
+            "import dagger.internal.Factory;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class InjectConstructor_Factory ",
+            "    implements Factory<InjectConstructor> {",
+            "",
+            "  private final Provider<other.pkg.CommonName> otherPackageProvider;",
+            "  private final Provider<CommonName> samePackageProvider;",
+            "",
+            "  public InjectConstructor_Factory(",
+            "      Provider<other.pkg.CommonName> otherPackageProvider,",
+            "      Provider<CommonName> samePackageProvider) {",
+            "    assert otherPackageProvider != null;",
+            "    this.otherPackageProvider = otherPackageProvider;",
+            "    assert samePackageProvider != null;",
+            "    this.samePackageProvider = samePackageProvider;",
+            "  }",
+            "",
+            "  @Override public InjectConstructor get() {",
+            "    return new InjectConstructor(",
+            "        otherPackageProvider.get(), samePackageProvider.get());",
+            "  }",
+            "",
+            "  public static Factory<InjectConstructor> create(",
+            "      Provider<other.pkg.CommonName> otherPackageProvider,",
+            "      Provider<CommonName> samePackageProvider) {",
+            "    return new InjectConstructor_Factory(otherPackageProvider, samePackageProvider);",
+            "  }",
+            "",
+            "  public static InjectConstructor newInjectConstructor(",
+            "      other.pkg.CommonName otherPackage, CommonName samePackage) {",
+            "    return new InjectConstructor(otherPackage, samePackage);",
+            "  }",
+            "}");
     assertAbout(javaSources())
         .that(ImmutableList.of(samePackageInterface, differentPackageInterface, file))
         .processedWith(new ComponentProcessor())
@@ -1292,6 +1368,10 @@ public void noDeps() {
             "  public static Factory<SimpleType> create() {",
             "    return INSTANCE;",
             "  }",
+            "",
+            "  public static SimpleType newSimpleType() {",
+            "    return new SimpleType();",
+            "  }",
             "}");
     assertAbout(javaSource())
         .that(simpleType)
@@ -1338,6 +1418,10 @@ public void noDeps() {
             "  public static Factory<OuterType.A> create() {",
             "    return INSTANCE;",
             "  }",
+            "",
+            "  public static OuterType.A newA() {",
+            "    return new OuterType.A();",
+            "  }",
             "}");
     assertAbout(javaSources()).that(ImmutableList.of(nestedTypesFile))
         .processedWith(new ComponentProcessor())
diff --git a/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java b/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
index 202c8c485..8d02a499c 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
@@ -247,30 +247,36 @@ public void providesMethodReturnsProduced() {
         "    return \"\";",
         "  }",
         "}");
-    JavaFileObject factoryFile = JavaFileObjects.forSourceLines("TestModule_ProvideStringFactory",
-        "package test;",
-        "",
-        "import dagger.internal.Factory;",
-        "import dagger.internal.Preconditions;",
-        "import javax.annotation.Generated;",
-        "",
-        GENERATED_ANNOTATION,
-        "public final class TestModule_ProvideStringFactory implements Factory<String> {",
-        "  private final TestModule module;",
-        "",
-        "  public TestModule_ProvideStringFactory(TestModule module) {",
-        "    assert module != null;",
-        "    this.module = module;",
-        "  }",
-        "",
-        "  @Override public String get() {",
-        "    return Preconditions.checkNotNull(module.provideString(), " + NPE_LITERAL + ");",
-        "  }",
-        "",
-        "  public static Factory<String> create(TestModule module) {",
-        "    return new TestModule_ProvideStringFactory(module);",
-        "  }",
-        "}");
+    JavaFileObject factoryFile =
+        JavaFileObjects.forSourceLines(
+            "TestModule_ProvideStringFactory",
+            "package test;",
+            "",
+            "import dagger.internal.Factory;",
+            "import dagger.internal.Preconditions;",
+            "import javax.annotation.Generated;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class TestModule_ProvideStringFactory implements Factory<String> {",
+            "  private final TestModule module;",
+            "",
+            "  public TestModule_ProvideStringFactory(TestModule module) {",
+            "    assert module != null;",
+            "    this.module = module;",
+            "  }",
+            "",
+            "  @Override public String get() {",
+            "    return Preconditions.checkNotNull(module.provideString(), " + NPE_LITERAL + ");",
+            "  }",
+            "",
+            "  public static Factory<String> create(TestModule module) {",
+            "    return new TestModule_ProvideStringFactory(module);",
+            "  }",
+            "",
+            "  public static String proxyProvideString(TestModule instance) {",
+            "    return instance.provideString();",
+            "  }",
+            "}");
     assertAbout(javaSource()).that(moduleFile)
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
@@ -290,29 +296,35 @@ public void providesMethodReturnsProduced() {
         "    return \"\";",
         "  }",
         "}");
-    JavaFileObject factoryFile = JavaFileObjects.forSourceLines("TestModule_ProvideStringFactory",
-        "package test;",
-        "",
-        "import dagger.internal.Factory;",
-        "import javax.annotation.Generated;",
-        "",
-        GENERATED_ANNOTATION,
-        "public final class TestModule_ProvideStringFactory implements Factory<String> {",
-        "  private final TestModule module;",
-        "",
-        "  public TestModule_ProvideStringFactory(TestModule module) {",
-        "    assert module != null;",
-        "    this.module = module;",
-        "  }",
-        "",
-        "  @Override public String get() {",
-        "    return module.provideString();",
-        "  }",
-        "",
-        "  public static Factory<String> create(TestModule module) {",
-        "    return new TestModule_ProvideStringFactory(module);",
-        "  }",
-        "}");
+    JavaFileObject factoryFile =
+        JavaFileObjects.forSourceLines(
+            "TestModule_ProvideStringFactory",
+            "package test;",
+            "",
+            "import dagger.internal.Factory;",
+            "import javax.annotation.Generated;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class TestModule_ProvideStringFactory implements Factory<String> {",
+            "  private final TestModule module;",
+            "",
+            "  public TestModule_ProvideStringFactory(TestModule module) {",
+            "    assert module != null;",
+            "    this.module = module;",
+            "  }",
+            "",
+            "  @Override public String get() {",
+            "    return module.provideString();",
+            "  }",
+            "",
+            "  public static Factory<String> create(TestModule module) {",
+            "    return new TestModule_ProvideStringFactory(module);",
+            "  }",
+            "",
+            "  public static String proxyProvideString(TestModule instance) {",
+            "    return instance.provideString();",
+            "  }",
+            "}");
     assertAbout(javaSource()).that(moduleFile)
         .withCompilerOptions("-Adagger.nullableValidation=WARNING")
         .processedWith(new ComponentProcessor())
@@ -331,31 +343,37 @@ public void providesMethodReturnsProduced() {
         "final class TestModule {",
         "  @Provides @Nullable String provideString() { return null; }",
         "}");
-    JavaFileObject factoryFile = JavaFileObjects.forSourceLines("TestModule_ProvideStringFactory",
-        "package test;",
-        "",
-        "import dagger.internal.Factory;",
-        "import javax.annotation.Generated;",
-        "",
-        GENERATED_ANNOTATION,
-        "public final class TestModule_ProvideStringFactory implements Factory<String> {",
-        "  private final TestModule module;",
-        "",
-        "  public TestModule_ProvideStringFactory(TestModule module) {",
-        "    assert module != null;",
-        "    this.module = module;",
-        "  }",
-        "",
-        "  @Override",
-        "  @Nullable",
-        "  public String get() {",
-        "    return module.provideString();",
-        "  }",
-        "",
-        "  public static Factory<String> create(TestModule module) {",
-        "    return new TestModule_ProvideStringFactory(module);",
-        "  }",
-        "}");
+    JavaFileObject factoryFile =
+        JavaFileObjects.forSourceLines(
+            "TestModule_ProvideStringFactory",
+            "package test;",
+            "",
+            "import dagger.internal.Factory;",
+            "import javax.annotation.Generated;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class TestModule_ProvideStringFactory implements Factory<String> {",
+            "  private final TestModule module;",
+            "",
+            "  public TestModule_ProvideStringFactory(TestModule module) {",
+            "    assert module != null;",
+            "    this.module = module;",
+            "  }",
+            "",
+            "  @Override",
+            "  @Nullable",
+            "  public String get() {",
+            "    return module.provideString();",
+            "  }",
+            "",
+            "  public static Factory<String> create(TestModule module) {",
+            "    return new TestModule_ProvideStringFactory(module);",
+            "  }",
+            "",
+            "  public static String proxyProvideString(TestModule instance) {",
+            "    return instance.provideString();",
+            "  }",
+            "}");
     assertAbout(javaSources()).that(ImmutableList.of(moduleFile, NULLABLE))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
@@ -410,54 +428,61 @@ public void providesMethodReturnsProduced() {
         "    return new Object();",
         "  }",
         "}");
-    JavaFileObject listFactoryFile = JavaFileObjects.forSourceLines(
-        "TestModule_ProvideObjectsFactory",
-        "package test;",
-        "",
-        "import dagger.MembersInjector;",
-        "import dagger.internal.Factory;",
-        "import dagger.internal.Preconditions;",
-        "import java.util.List;",
-        "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
-        "",
-        GENERATED_ANNOTATION,
-        "public final class TestModule_ProvideObjectsFactory implements Factory<List<Object>> {",
-        "  private final TestModule module;",
-        "  private final Provider<Object> aProvider;",
-        "  private final Provider<Object> bProvider;",
-        "  private final MembersInjector<X> xMembersInjector;",
-        "",
-        "  public TestModule_ProvideObjectsFactory(",
-        "      TestModule module,",
-        "      Provider<Object> aProvider,",
-        "      Provider<Object> bProvider,",
-        "      MembersInjector<X> xMembersInjector) {",
-        "    assert module != null;",
-        "    this.module = module;",
-        "    assert aProvider != null;",
-        "    this.aProvider = aProvider;",
-        "    assert bProvider != null;",
-        "    this.bProvider = bProvider;",
-        "    assert xMembersInjector != null;",
-        "    this.xMembersInjector = xMembersInjector;",
-        "  }",
-        "",
-        "  @Override public List<Object> get() {",
-        "    return Preconditions.checkNotNull(",
-        "        module.provideObjects(aProvider.get(), bProvider.get(), xMembersInjector),",
-        "        " + NPE_LITERAL + ");",
-        "  }",
-        "",
-        "  public static Factory<List<Object>> create(",
-        "      TestModule module,",
-        "      Provider<Object> aProvider,",
-        "      Provider<Object> bProvider,",
-        "      MembersInjector<X> xMembersInjector) {",
-        "    return new TestModule_ProvideObjectsFactory(",
-        "        module, aProvider, bProvider, xMembersInjector);",
-        "  }",
-        "}");
+    JavaFileObject listFactoryFile =
+        JavaFileObjects.forSourceLines(
+            "TestModule_ProvideObjectsFactory",
+            "package test;",
+            "",
+            "import dagger.MembersInjector;",
+            "import dagger.internal.Factory;",
+            "import dagger.internal.Preconditions;",
+            "import java.util.List;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class TestModule_ProvideObjectsFactory",
+            "    implements Factory<List<Object>> {",
+            "  private final TestModule module;",
+            "  private final Provider<Object> aProvider;",
+            "  private final Provider<Object> bProvider;",
+            "  private final MembersInjector<X> xMembersInjector;",
+            "",
+            "  public TestModule_ProvideObjectsFactory(",
+            "      TestModule module,",
+            "      Provider<Object> aProvider,",
+            "      Provider<Object> bProvider,",
+            "      MembersInjector<X> xMembersInjector) {",
+            "    assert module != null;",
+            "    this.module = module;",
+            "    assert aProvider != null;",
+            "    this.aProvider = aProvider;",
+            "    assert bProvider != null;",
+            "    this.bProvider = bProvider;",
+            "    assert xMembersInjector != null;",
+            "    this.xMembersInjector = xMembersInjector;",
+            "  }",
+            "",
+            "  @Override public List<Object> get() {",
+            "    return Preconditions.checkNotNull(",
+            "        module.provideObjects(aProvider.get(), bProvider.get(), xMembersInjector),",
+            "        " + NPE_LITERAL + ");",
+            "  }",
+            "",
+            "  public static Factory<List<Object>> create(",
+            "      TestModule module,",
+            "      Provider<Object> aProvider,",
+            "      Provider<Object> bProvider,",
+            "      MembersInjector<X> xMembersInjector) {",
+            "    return new TestModule_ProvideObjectsFactory(",
+            "        module, aProvider, bProvider, xMembersInjector);",
+            "  }",
+            "",
+            "  public static List<Object> proxyProvideObjects(",
+            "      TestModule instance, Object a, Object b, Object x) {",
+            "    return instance.provideObjects(a, b, (MembersInjector<X>) x);",
+            "  }",
+            "}");
     assertAbout(javaSources()).that(
             ImmutableList.of(classXFile, moduleFile, QUALIFIER_A, QUALIFIER_B))
         .processedWith(new ComponentProcessor())
@@ -480,30 +505,36 @@ public void providesMethodReturnsProduced() {
         "    return \"\";",
         "  }",
         "}");
-    JavaFileObject factoryFile = JavaFileObjects.forSourceLines("TestModule_ProvideStringFactory",
-        "package test;",
-        "",
-        "import dagger.internal.Factory;",
-        "import dagger.internal.Preconditions;",
-        "import javax.annotation.Generated;",
-        "",
-        GENERATED_ANNOTATION,
-        "public final class TestModule_ProvideStringFactory implements Factory<String> {",
-        "  private final TestModule module;",
-        "",
-        "  public TestModule_ProvideStringFactory(TestModule module) {",
-        "    assert module != null;",
-        "    this.module = module;",
-        "  }",
-        "",
-        "  @Override public String get() {",
-        "    return Preconditions.checkNotNull(module.provideString(), " + NPE_LITERAL + ");",
-        "  }",
-        "",
-        "  public static Factory<String> create(TestModule module) {",
-        "    return new TestModule_ProvideStringFactory(module);",
-        "  }",
-        "}");
+    JavaFileObject factoryFile =
+        JavaFileObjects.forSourceLines(
+            "TestModule_ProvideStringFactory",
+            "package test;",
+            "",
+            "import dagger.internal.Factory;",
+            "import dagger.internal.Preconditions;",
+            "import javax.annotation.Generated;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class TestModule_ProvideStringFactory implements Factory<String> {",
+            "  private final TestModule module;",
+            "",
+            "  public TestModule_ProvideStringFactory(TestModule module) {",
+            "    assert module != null;",
+            "    this.module = module;",
+            "  }",
+            "",
+            "  @Override public String get() {",
+            "    return Preconditions.checkNotNull(module.provideString(), " + NPE_LITERAL + ");",
+            "  }",
+            "",
+            "  public static Factory<String> create(TestModule module) {",
+            "    return new TestModule_ProvideStringFactory(module);",
+            "  }",
+            "",
+            "  public static String proxyProvideString(TestModule instance) {",
+            "    return instance.provideString();",
+            "  }",
+            "}");
     assertAbout(javaSource()).that(moduleFile)
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
@@ -527,33 +558,40 @@ public void providesMethodReturnsProduced() {
         "    return new ArrayList<>();",
         "  }",
         "}");
-    JavaFileObject factoryFile = JavaFileObjects.forSourceLines(
-        "TestModule_ProvideWildcardListFactory",
-        "package test;",
-        "",
-        "import dagger.internal.Factory;",
-        "import dagger.internal.Preconditions;",
-        "import java.util.List;",
-        "import javax.annotation.Generated;",
-        "",
-        GENERATED_ANNOTATION,
-        "public final class TestModule_ProvideWildcardListFactory implements "
-            + "Factory<List<List<?>>> {",
-        "  private final TestModule module;",
-        "",
-        "  public TestModule_ProvideWildcardListFactory(TestModule module) {",
-        "    assert module != null;",
-        "    this.module = module;",
-        "  }",
-        "",
-        "  @Override public List<List<?>> get() {",
-        "    return Preconditions.checkNotNull(module.provideWildcardList(), " + NPE_LITERAL + ");",
-        "  }",
-        "",
-        "  public static Factory<List<List<?>>> create(TestModule module) {",
-        "    return new TestModule_ProvideWildcardListFactory(module);",
-        "  }",
-        "}");
+    JavaFileObject factoryFile =
+        JavaFileObjects.forSourceLines(
+            "TestModule_ProvideWildcardListFactory",
+            "package test;",
+            "",
+            "import dagger.internal.Factory;",
+            "import dagger.internal.Preconditions;",
+            "import java.util.List;",
+            "import javax.annotation.Generated;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class TestModule_ProvideWildcardListFactory implements "
+                + "Factory<List<List<?>>> {",
+            "  private final TestModule module;",
+            "",
+            "  public TestModule_ProvideWildcardListFactory(TestModule module) {",
+            "    assert module != null;",
+            "    this.module = module;",
+            "  }",
+            "",
+            "  @Override public List<List<?>> get() {",
+            "    return Preconditions.checkNotNull(module.provideWildcardList(), "
+                + NPE_LITERAL
+                + ");",
+            "  }",
+            "",
+            "  public static Factory<List<List<?>>> create(TestModule module) {",
+            "    return new TestModule_ProvideWildcardListFactory(module);",
+            "  }",
+            "",
+            "  public static List<List<?>> proxyProvideWildcardList(TestModule instance) {",
+            "    return instance.provideWildcardList();",
+            "  }",
+            "}");
     assertAbout(javaSource()).that(moduleFile)
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
@@ -575,31 +613,37 @@ public void providesMethodReturnsProduced() {
         "    return null;",
         "  }",
         "}");
-    JavaFileObject factoryFile = JavaFileObjects.forSourceLines("TestModule_ProvideStringsFactory",
-        "package test;",
-        "",
-        "import dagger.internal.Factory;",
-        "import dagger.internal.Preconditions;",
-        "import java.util.Set;",
-        "import javax.annotation.Generated;",
-        "",
-        GENERATED_ANNOTATION,
-        "public final class TestModule_ProvideStringsFactory implements Factory<Set<String>> {",
-        "  private final TestModule module;",
-        "",
-        "  public TestModule_ProvideStringsFactory(TestModule module) {",
-        "    assert module != null;",
-        "    this.module = module;",
-        "  }",
-        "",
-        "  @Override public Set<String> get() {",
-        "    return Preconditions.checkNotNull(module.provideStrings(), " + NPE_LITERAL + ");",
-        "  }",
-        "",
-        "  public static Factory<Set<String>> create(TestModule module) {",
-        "    return new TestModule_ProvideStringsFactory(module);",
-        "  }",
-        "}");
+    JavaFileObject factoryFile =
+        JavaFileObjects.forSourceLines(
+            "TestModule_ProvideStringsFactory",
+            "package test;",
+            "",
+            "import dagger.internal.Factory;",
+            "import dagger.internal.Preconditions;",
+            "import java.util.Set;",
+            "import javax.annotation.Generated;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class TestModule_ProvideStringsFactory implements Factory<Set<String>> {",
+            "  private final TestModule module;",
+            "",
+            "  public TestModule_ProvideStringsFactory(TestModule module) {",
+            "    assert module != null;",
+            "    this.module = module;",
+            "  }",
+            "",
+            "  @Override public Set<String> get() {",
+            "    return Preconditions.checkNotNull(module.provideStrings(), " + NPE_LITERAL + ");",
+            "  }",
+            "",
+            "  public static Factory<Set<String>> create(TestModule module) {",
+            "    return new TestModule_ProvideStringsFactory(module);",
+            "  }",
+            "",
+            "  public static Set<String> proxyProvideStrings(TestModule instance) {",
+            "    return instance.provideStrings();",
+            "  }",
+            "}");
     assertAbout(javaSource()).that(moduleFile)
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
@@ -892,6 +936,12 @@ public void genericSubclassedModule() {
             "      Factory<List<B>> create(ParentModule<A, B, C> module, Provider<B> bProvider) {",
             "    return new ParentModule_ProvideListBFactory<A, B, C>(module, bProvider);",
             "  }",
+            "",
+            "  public static <A extends CharSequence, B, C extends Number & Comparable<C>> List<B>",
+            "      proxyProvideListB(",
+            "          ParentModule<A, B, C> instance, B b) {",
+            "    return instance.provideListB(b);",
+            "  }",
             "}");
     JavaFileObject bElementFactory =
         JavaFileObjects.forSourceLines(
@@ -927,6 +977,12 @@ public void genericSubclassedModule() {
             "      Factory<B> create(ParentModule<A, B, C> module, Provider<B> bProvider) {",
             "    return new ParentModule_ProvideBElementFactory<A, B, C>(module, bProvider);",
             "  }",
+            "",
+            "  public static <A extends CharSequence, B, C extends Number & Comparable<C>>",
+            "      B proxyProvideBElement(",
+            "          ParentModule<A, B, C> instance, B b) {",
+            "        return instance.provideBElement(b);",
+            "  }",
             "}");
     JavaFileObject bEntryFactory =
         JavaFileObjects.forSourceLines(
@@ -962,60 +1018,77 @@ public void genericSubclassedModule() {
             "      Factory<B> create(ParentModule<A, B, C> module, Provider<B> bProvider) {",
             "    return new ParentModule_ProvideBEntryFactory<A, B, C>(module, bProvider);",
             "  }",
+            "",
+            "  public static <A extends CharSequence, B, C extends Number & Comparable<C>>",
+            "      B proxyProvideBEntry(",
+            "          ParentModule<A, B, C> instance, B b) {",
+            "        return instance.provideBEntry(b);",
+            "  }",
+            "}");
+    JavaFileObject numberFactory =
+        JavaFileObjects.forSourceLines(
+            "test.ChildNumberModule_ProvideNumberFactory",
+            "package test;",
+            "",
+            "import dagger.internal.Factory;",
+            "import dagger.internal.Preconditions;",
+            "import javax.annotation.Generated;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class ChildNumberModule_ProvideNumberFactory",
+            "    implements Factory<Number> {",
+            "  private final ChildNumberModule module;",
+            "",
+            "  public ChildNumberModule_ProvideNumberFactory(ChildNumberModule module) {",
+            "    assert module != null;",
+            "    this.module = module;",
+            "  }",
+            "",
+            "  @Override",
+            "  public Number get() {  ",
+            "    return Preconditions.checkNotNull(module.provideNumber(), " + NPE_LITERAL + ");",
+            "  }",
+            "",
+            "  public static Factory<Number> create(ChildNumberModule module) {",
+            "    return new ChildNumberModule_ProvideNumberFactory(module);",
+            "  }",
+            "",
+            "  public static Number proxyProvideNumber(ChildNumberModule instance) {",
+            "    return instance.provideNumber();",
+            "  }",
+            "}");
+    JavaFileObject integerFactory =
+        JavaFileObjects.forSourceLines(
+            "test.ChildIntegerModule_ProvideIntegerFactory",
+            "package test;",
+            "",
+            "import dagger.internal.Factory;",
+            "import dagger.internal.Preconditions;",
+            "import javax.annotation.Generated;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class ChildIntegerModule_ProvideIntegerFactory",
+            "    implements Factory<Integer> {",
+            "  private final ChildIntegerModule module;",
+            "",
+            "  public ChildIntegerModule_ProvideIntegerFactory(ChildIntegerModule module) {",
+            "    assert module != null;",
+            "    this.module = module;",
+            "  }",
+            "",
+            "  @Override",
+            "  public Integer get() {  ",
+            "    return Preconditions.checkNotNull(module.provideInteger(), " + NPE_LITERAL + ");",
+            "  }",
+            "",
+            "  public static Factory<Integer> create(ChildIntegerModule module) {",
+            "    return new ChildIntegerModule_ProvideIntegerFactory(module);",
+            "  }",
+            "",
+            "  public static Integer proxyProvideInteger(ChildIntegerModule instance) {",
+            "    return instance.provideInteger();",
+            "  }",
             "}");
-    JavaFileObject numberFactory = JavaFileObjects.forSourceLines(
-        "test.ChildNumberModule_ProvideNumberFactory",
-        "package test;",
-        "",
-        "import dagger.internal.Factory;",
-        "import dagger.internal.Preconditions;",
-        "import javax.annotation.Generated;",
-        "",
-        GENERATED_ANNOTATION,
-        "public final class ChildNumberModule_ProvideNumberFactory implements Factory<Number> {",
-        "  private final ChildNumberModule module;",
-        "",
-        "  public ChildNumberModule_ProvideNumberFactory(ChildNumberModule module) {",
-        "    assert module != null;",
-        "    this.module = module;",
-        "  }",
-        "",
-        "  @Override",
-        "  public Number get() {  ",
-        "    return Preconditions.checkNotNull(module.provideNumber(), " + NPE_LITERAL + ");",
-        "  }",
-        "",
-        "  public static Factory<Number> create(ChildNumberModule module) {",
-        "    return new ChildNumberModule_ProvideNumberFactory(module);",
-        "  }",
-        "}");
-    JavaFileObject integerFactory = JavaFileObjects.forSourceLines(
-        "test.ChildIntegerModule_ProvideIntegerFactory",
-        "package test;",
-        "",
-        "import dagger.internal.Factory;",
-        "import dagger.internal.Preconditions;",
-        "import javax.annotation.Generated;",
-        "",
-        GENERATED_ANNOTATION,
-        "public final class ChildIntegerModule_ProvideIntegerFactory",
-        "    implements Factory<Integer> {",
-        "  private final ChildIntegerModule module;",
-        "",
-        "  public ChildIntegerModule_ProvideIntegerFactory(ChildIntegerModule module) {",
-        "    assert module != null;",
-        "    this.module = module;",
-        "  }",
-        "",
-        "  @Override",
-        "  public Integer get() {  ",
-        "    return Preconditions.checkNotNull(module.provideInteger(), " + NPE_LITERAL + ");",
-        "  }",
-        "",
-        "  public static Factory<Integer> create(ChildIntegerModule module) {",
-        "    return new ChildIntegerModule_ProvideIntegerFactory(module);",
-        "  }",
-        "}");
     assertAbout(javaSources())
         .that(ImmutableList.of(parent, numberChild, integerChild, component))
         .processedWith(new ComponentProcessor())
@@ -1081,6 +1154,10 @@ public void genericSubclassedModule() {
             "  public static Factory<Map<String, Number>> create() {",
             "    return INSTANCE;",
             "  }",
+            "",
+            "  public static Map<String, Number> proxyProvideMapStringNumber() {",
+            "    return ParameterizedModule.provideMapStringNumber();",
+            "  }",
             "}");
 
     JavaFileObject provideNonGenericTypeFactory =
@@ -1107,6 +1184,10 @@ public void genericSubclassedModule() {
             "  public static Factory<Object> create() {",
             "    return INSTANCE;",
             "  }",
+            "",
+            "  public static Object proxyProvideNonGenericType() {",
+            "    return ParameterizedModule.provideNonGenericType();",
+            "  }",
             "}");
 
     JavaFileObject provideNonGenericTypeWithDepsFactory =
@@ -1140,6 +1221,10 @@ public void genericSubclassedModule() {
             "  public static Factory<String> create(Provider<Object> oProvider) {",
             "    return new ParameterizedModule_ProvideNonGenericTypeWithDepsFactory(oProvider);",
             "  }",
+            "",
+            "  public static String proxyProvideNonGenericTypeWithDeps(Object o) {",
+            "    return ParameterizedModule.provideNonGenericTypeWithDeps(o);",
+            "  }",
             "}");
 
     assertAbout(javaSource())
