diff --git a/compiler/src/it/functional-tests/src/main/java/test/builder/MiddleChild.java b/compiler/src/it/functional-tests/src/main/java/test/builder/MiddleChild.java
index 59c29ab34..690c91ad7 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/builder/MiddleChild.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/builder/MiddleChild.java
@@ -24,6 +24,8 @@
   
   Grandchild.Builder grandchildBuilder();
   
+  RequiresSubcomponentBuilder<Grandchild.Builder> requiresGrandchildBuilder();
+  
   @Subcomponent.Builder
   interface Builder {
     MiddleChild build();
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builder/ParentComponent.java b/compiler/src/it/functional-tests/src/main/java/test/builder/ParentComponent.java
index f901b8863..584eff6ef 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/builder/ParentComponent.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/builder/ParentComponent.java
@@ -26,4 +26,6 @@
   
   MiddleChild.Builder middleBuilder();
   OtherMiddleChild.Builder otherBuilder();
+  
+  RequiresSubcomponentBuilder<MiddleChild.Builder> requiresMiddleChildBuilder();
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builder/RequiresSubcomponentBuilder.java b/compiler/src/it/functional-tests/src/main/java/test/builder/RequiresSubcomponentBuilder.java
new file mode 100644
index 000000000..ee9963227
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/builder/RequiresSubcomponentBuilder.java
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.builder;
+
+import javax.inject.Inject;
+import javax.inject.Provider;
+
+class RequiresSubcomponentBuilder<B> {
+  private final Provider<B> subcomponentBuilderProvider;
+  private final B subcomponentBuilder;
+
+  @Inject
+  RequiresSubcomponentBuilder(Provider<B> subcomponentBuilderProvider, B subcomponentBuilder) {
+    this.subcomponentBuilderProvider = subcomponentBuilderProvider;
+    this.subcomponentBuilder = subcomponentBuilder;
+  }
+
+  Provider<B> subcomponentBuilderProvider() {
+    return subcomponentBuilderProvider;
+  }
+  
+  B subcomponentBuilder() {
+    return subcomponentBuilder;
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/test/java/test/builder/BuilderTest.java b/compiler/src/it/functional-tests/src/test/java/test/builder/BuilderTest.java
index ba590d2d9..46f5388ec 100644
--- a/compiler/src/it/functional-tests/src/test/java/test/builder/BuilderTest.java
+++ b/compiler/src/it/functional-tests/src/test/java/test/builder/BuilderTest.java
@@ -163,7 +163,7 @@
     assertThat(child2.l()).isEqualTo(6L);
     assertThat(child2.b()).isEqualTo((byte)70);
   }
-  
+    
   @Test
   public void grandchildren() {
     ParentComponent parent = DaggerParentComponent.create();
@@ -222,4 +222,45 @@ public void genericSubcomponentMethod() {
     assertThat(child.i()).isEqualTo(21);
   }
   
+  @Test
+  public void requireSubcomponentBuilderProviders() {
+    ParentComponent parent = DaggerParentComponent.create();
+    MiddleChild middle =
+        parent
+            .requiresMiddleChildBuilder()
+            .subcomponentBuilderProvider()
+            .get()
+            .set(new StringModule("sam"))
+            .build();
+    Grandchild grandchild =
+        middle
+            .requiresGrandchildBuilder()
+            .subcomponentBuilderProvider()
+            .get()
+            .set(new IntModuleIncludingDoubleAndFloat(12))
+            .build();
+    assertThat(middle.s()).isEqualTo("sam");
+    assertThat(grandchild.i()).isEqualTo(12);
+    assertThat(grandchild.s()).isEqualTo("sam");
+  }
+  
+  @Test
+  public void requireSubcomponentBuilders() {
+    ParentComponent parent = DaggerParentComponent.create();
+    MiddleChild middle =
+        parent
+            .requiresMiddleChildBuilder()
+            .subcomponentBuilder()
+            .set(new StringModule("sam"))
+            .build();
+    Grandchild grandchild =
+        middle
+            .requiresGrandchildBuilder()
+            .subcomponentBuilder()
+            .set(new IntModuleIncludingDoubleAndFloat(12))
+            .build();
+    assertThat(middle.s()).isEqualTo("sam");
+    assertThat(grandchild.i()).isEqualTo(12);
+    assertThat(grandchild.s()).isEqualTo("sam");
+  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
index a61b7b459..db890b246 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -810,7 +810,7 @@ private Snippet initializeUniqueContributionBinding(ResolvedBindings resolvedBin
 
     ContributionBinding binding = getOnlyElement(resolvedBindings.ownedContributionBindings());
     if (!binding.factoryCreationStrategy().equals(ENUM_INSTANCE) || binding.scope().isPresent()) {
-        initializationSnippets.add(initializeDelegateFactories(binding));
+      initializationSnippets.add(initializeDelegateFactories(binding));
       initializationSnippets.add(
           initializeMember(
               resolvedBindings.bindingKey(), initializeFactoryForContributionBinding(binding)));
@@ -948,6 +948,19 @@ private Snippet initializeFactoryForContributionBinding(ContributionBinding bind
               /* 7 */ getMethodBody);
         }
 
+      case SUBCOMPONENT_BUILDER:
+        return Snippet.format(
+            Joiner.on('\n')
+                .join(
+                    "new %1$s<%2$s>() {",
+                    "  @Override public %2$s get() {",
+                    "    return %3$s();",
+                    "  }",
+                    "}"),
+            /* 1 */ ClassName.fromClass(Factory.class),
+            /* 2 */ bindingKeyTypeName,
+            /* 3 */ binding.bindingElement().getSimpleName().toString());
+        
       case INJECTION:
       case PROVISION:
         {
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
index 5ee026fb4..b95143803 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
@@ -26,6 +26,7 @@
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ImmutableSetMultimap;
+import com.google.common.collect.Iterables;
 import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
 import com.google.common.collect.Sets;
@@ -62,6 +63,8 @@
 import static dagger.internal.codegen.BindingKey.Kind.CONTRIBUTION;
 import static dagger.internal.codegen.ComponentDescriptor.isComponentContributionMethod;
 import static dagger.internal.codegen.ComponentDescriptor.isComponentProductionMethod;
+import static dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor.isOfKind;
+import static dagger.internal.codegen.ComponentDescriptor.ComponentMethodKind.SUBCOMPONENT_BUILDER;
 import static dagger.internal.codegen.ComponentDescriptor.Kind.PRODUCTION_COMPONENT;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
 import static dagger.internal.codegen.MembersInjectionBinding.Strategy.INJECT_MEMBERS;
@@ -204,6 +207,16 @@ private BindingGraph create(
         }
       }
 
+      // Bindings for subcomponent builders.
+      for (ComponentMethodDescriptor subcomponentMethodDescriptor :
+          Iterables.filter(
+              componentDescriptor.subcomponents().keySet(), isOfKind(SUBCOMPONENT_BUILDER))) {
+        explicitBindingsBuilder.add(
+            provisionBindingFactory.forSubcomponentBuilderMethod(
+                subcomponentMethodDescriptor.methodElement(),
+                componentDescriptor.componentDefinitionType()));
+      }
+
       // Collect transitive module bindings.
       for (ModuleDescriptor moduleDescriptor : componentDescriptor.transitiveModules()) {
         for (ContributionBinding binding : moduleDescriptor.bindings()) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
index 543064dff..831943f2a 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
@@ -20,6 +20,7 @@
 import com.google.common.base.Equivalence.Wrapper;
 import com.google.common.base.Function;
 import com.google.common.base.Optional;
+import com.google.common.base.Predicate;
 import com.google.common.collect.ImmutableListMultimap;
 import com.google.common.collect.ImmutableSetMultimap;
 import com.google.common.collect.Iterables;
@@ -140,6 +141,11 @@ boolean isSyntheticBinding() {
     /** A provision method on a component's {@linkplain Component#dependencies() dependency}. */
     COMPONENT_PROVISION,
 
+    /**
+     * A subcomponent builder method on a component or subcomponent.
+     */
+    SUBCOMPONENT_BUILDER,
+
     // Production kinds
 
     /** A {@link Produces}-annotated method that doesn't return a {@link ListenableFuture}. */
@@ -161,6 +167,17 @@ boolean isSyntheticBinding() {
    * The kind of this contribution binding.
    */
   protected abstract Kind bindingKind();
+  
+  /**
+   * A predicate that passes for bindings of a given kind.
+   */
+  static Predicate<ContributionBinding> isOfKind(final Kind kind) {
+    return new Predicate<ContributionBinding>() {
+      @Override
+      public boolean apply(ContributionBinding binding) {
+        return binding.bindingKind().equals(kind);
+      }};
+  }
 
   /** The provision type that was used to bind the key. */
   abstract Provides.Type provisionType();
diff --git a/compiler/src/main/java/dagger/internal/codegen/ContributionBindingFormatter.java b/compiler/src/main/java/dagger/internal/codegen/ContributionBindingFormatter.java
index 4e94bc946..0d267619b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ContributionBindingFormatter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ContributionBindingFormatter.java
@@ -40,9 +40,11 @@
         return methodSignatureFormatter.format(asExecutable(binding.bindingElement()));
 
       case PROVISION:
+      case SUBCOMPONENT_BUILDER:
       case IMMEDIATE:
       case FUTURE_PRODUCTION:
-        return methodSignatureFormatter.format(asExecutable(binding.bindingElement()),
+        return methodSignatureFormatter.format(
+            asExecutable(binding.bindingElement()),
             Optional.of(asDeclared(binding.contributedBy().get().asType())));
 
       default:
diff --git a/compiler/src/main/java/dagger/internal/codegen/Key.java b/compiler/src/main/java/dagger/internal/codegen/Key.java
index d34225542..f0bd3a04f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Key.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Key.java
@@ -46,6 +46,7 @@
 import javax.lang.model.util.SimpleTypeVisitor6;
 import javax.lang.model.util.Types;
 
+import static com.google.auto.common.MoreTypes.asExecutable;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static dagger.internal.codegen.InjectionAnnotations.getQualifier;
@@ -201,6 +202,16 @@ Key forProductionComponentMethod(ExecutableElement componentMethod) {
       return forMethod(componentMethod, keyType);
     }
 
+    Key forSubcomponentBuilderMethod(
+        ExecutableElement subcomponentBuilderMethod, DeclaredType declaredContainer) {
+      checkNotNull(subcomponentBuilderMethod);
+      checkArgument(subcomponentBuilderMethod.getKind().equals(METHOD));
+      ExecutableType resolvedMethod =
+          asExecutable(types.asMemberOf(declaredContainer, subcomponentBuilderMethod));
+      TypeMirror returnType = normalize(types, resolvedMethod.getReturnType());
+      return forMethod(subcomponentBuilderMethod, returnType);
+    }
+
     Key forProvidesMethod(ExecutableType executableType, ExecutableElement method) {
       checkNotNull(method);
       checkArgument(method.getKind().equals(METHOD));
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
index 257628e4f..b2ac74fb3 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
@@ -35,6 +35,7 @@
 import javax.lang.model.util.Types;
 
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
+import static com.google.auto.common.MoreTypes.asDeclared;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
@@ -243,5 +244,25 @@ ProvisionBinding forComponentMethod(ExecutableElement componentMethod) {
           Provides.Type.UNIQUE,
           scope);
     }
+
+    ProvisionBinding forSubcomponentBuilderMethod(
+        ExecutableElement subcomponentBuilderMethod, TypeElement contributedBy) {
+      checkNotNull(subcomponentBuilderMethod);
+      checkArgument(subcomponentBuilderMethod.getKind().equals(METHOD));
+      checkArgument(subcomponentBuilderMethod.getParameters().isEmpty());
+      DeclaredType declaredContainer = asDeclared(contributedBy.asType());
+      return new AutoValue_ProvisionBinding(
+          keyFactory.forSubcomponentBuilderMethod(subcomponentBuilderMethod, declaredContainer),
+          subcomponentBuilderMethod,
+          ImmutableSet.<DependencyRequest>of(),
+          Optional.<String>absent(),
+          false /* no non-default parameter types */,
+          Optional.<DeclaredType>absent(),
+          Optional.of(contributedBy),
+          Optional.<DependencyRequest>absent(),
+          Kind.SUBCOMPONENT_BUILDER,
+          Provides.Type.UNIQUE,
+          Scope.unscoped());
+    }
   }
 }
