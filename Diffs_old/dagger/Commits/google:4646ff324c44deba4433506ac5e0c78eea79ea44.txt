diff --git a/compiler/src/main/java/dagger/internal/codegen/Binding.java b/compiler/src/main/java/dagger/internal/codegen/Binding.java
index 1a88f1c2c..88ed8b6e2 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Binding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Binding.java
@@ -18,9 +18,20 @@
 import com.google.auto.common.MoreElements;
 import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableSet;
+import java.util.Set;
 import javax.lang.model.element.Element;
+import javax.lang.model.element.Name;
+import javax.lang.model.element.PackageElement;
 import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.ArrayType;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.type.TypeVariable;
+import javax.lang.model.type.WildcardType;
 import javax.lang.model.util.SimpleElementVisitor6;
+import javax.lang.model.util.SimpleTypeVisitor6;
+
+import static javax.lang.model.element.Modifier.PUBLIC;
 
 /**
  * An abstract type for classes representing a Dagger binding.  Particularly, contains the
@@ -72,4 +83,53 @@ public TypeElement visitType(TypeElement e, Void p) {
    */
   abstract Optional<String> bindingPackage();
 
+  protected static Optional<String> findBindingPackage(Key bindingKey) {
+    Set<String> packages = nonPublicPackageUse(bindingKey.type());
+    switch (packages.size()) {
+      case 0:
+        return Optional.absent();
+      case 1:
+        return Optional.of(packages.iterator().next());
+      default:
+        throw new IllegalStateException();
+    }
+  }
+
+  private static Set<String> nonPublicPackageUse(TypeMirror typeMirror) {
+    ImmutableSet.Builder<String> packages = ImmutableSet.builder();
+    typeMirror.accept(new SimpleTypeVisitor6<Void, ImmutableSet.Builder<String>>() {
+      @Override
+      public Void visitArray(ArrayType t, ImmutableSet.Builder<String> p) {
+        return t.getComponentType().accept(this, p);
+      }
+
+      @Override
+      public Void visitDeclared(DeclaredType t, ImmutableSet.Builder<String> p) {
+        for (TypeMirror typeArgument : t.getTypeArguments()) {
+          typeArgument.accept(this, p);
+        }
+        // TODO(gak): address public nested types in non-public types
+        TypeElement typeElement = MoreElements.asType(t.asElement());
+        if (!typeElement.getModifiers().contains(PUBLIC)) {
+          PackageElement elementPackage = MoreElements.getPackage(typeElement);
+          Name qualifiedName = elementPackage.getQualifiedName();
+          p.add(qualifiedName.toString());
+        }
+        return null;
+      }
+
+      @Override
+      public Void visitWildcard(WildcardType t, ImmutableSet.Builder<String> p) {
+        if (t.getExtendsBound() != null) {
+          t.getExtendsBound().accept(this, p);
+        }
+        if (t.getSuperBound() != null) {
+          t.getSuperBound().accept(this, p);
+        }
+        return null;
+      }
+    }, packages);
+    return packages.build();
+  }
+
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
index e4b98fb35..c3e874175 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
@@ -17,6 +17,7 @@
 
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
+import com.google.auto.value.AutoValue;
 import com.google.common.base.CaseFormat;
 import com.google.common.base.Function;
 import com.google.common.base.Functions;
@@ -127,6 +128,16 @@ ClassName nameGeneratedType(BindingGraph input) {
     return Optional.of(input.componentDescriptor().componentDefinitionType());
   }
 
+  @AutoValue
+  static abstract class ProxyClassAndField {
+    abstract ClassWriter proxyWriter();
+    abstract FieldWriter proxyFieldWriter();
+
+    static ProxyClassAndField create(ClassWriter proxyWriter, FieldWriter proxyFieldWriter) {
+      return new AutoValue_ComponentGenerator_ProxyClassAndField(proxyWriter, proxyFieldWriter);
+    }
+  }
+
   @Override
   ImmutableSet<JavaWriter> write(ClassName componentName, BindingGraph input) {
     ClassName componentDefinitionTypeName =
@@ -216,7 +227,7 @@ ClassName nameGeneratedType(BindingGraph input) {
         ImmutableMap.builder();
 
     ImmutableSet.Builder<JavaWriter> proxyWriters = ImmutableSet.builder();
-    Map<String, ClassWriter> packageProxies = Maps.newHashMap();
+    Map<String, ProxyClassAndField> packageProxies = Maps.newHashMap();
 
     for (Entry<Key, ResolvedBindings> resolvedBindingsEntry : input.resolvedBindings().entrySet()) {
       Key key = resolvedBindingsEntry.getKey();
@@ -267,26 +278,28 @@ ClassName nameGeneratedType(BindingGraph input) {
         fieldModifiers = EnumSet.of(PRIVATE);
       } else {
         // get or create the proxy
-        ClassWriter proxyClassWriter = packageProxies.get(bindingPackage);
-        if (proxyClassWriter == null) {
-          JavaWriter proxyWriter = JavaWriter.inPackage(bindingPackage);
-          proxyWriters.add(proxyWriter);
-          proxyClassWriter = proxyWriter.addClass(componentName.simpleName() + "__PackageProxy");
-          proxyClassWriter.annotate(Generated.class)
+        ProxyClassAndField proxyClassAndField = packageProxies.get(bindingPackage);
+        if (proxyClassAndField == null) {
+          JavaWriter proxyJavaWriter = JavaWriter.inPackage(bindingPackage);
+          proxyWriters.add(proxyJavaWriter);
+          ClassWriter proxyWriter =
+              proxyJavaWriter.addClass(componentName.simpleName() + "__PackageProxy");
+          proxyWriter.annotate(Generated.class)
               .setValue(ComponentProcessor.class.getCanonicalName());
-          packageProxies.put(bindingPackage, proxyClassWriter);
+          proxyWriter.addModifiers(PUBLIC, FINAL);
+          // create the field for the proxy in the component
+          FieldWriter proxyFieldWriter =
+              componentWriter.addField(proxyWriter.name(), bindingPackage.replace('.', '_')
+                  + "_Proxy");
+          proxyFieldWriter.addModifiers(PRIVATE, FINAL);
+          proxyFieldWriter.setInitializer("new %s()", proxyWriter.name());
+          proxyClassAndField = ProxyClassAndField.create(proxyWriter, proxyFieldWriter);
+          packageProxies.put(bindingPackage, proxyClassAndField);
         }
-        proxyClassWriter.addModifiers(PUBLIC, FINAL);
-        // create the field for the proxy in the component
-        FieldWriter proxyField =
-            componentWriter.addField(proxyClassWriter.name(), bindingPackage.replace('.', '_')
-                + "_Proxy");
-        proxyField.addModifiers(PRIVATE, FINAL);
-        proxyField.setInitializer("new %s()", proxyClassWriter.name());
         // add the field for the member select
-        proxySelector = Optional.of(proxyField.name());
+        proxySelector = Optional.of(proxyClassAndField.proxyFieldWriter().name());
         // proxy gets the fields
-        classWithFields = proxyClassWriter;
+        classWithFields = proxyClassAndField.proxyWriter();
         // public fields in the proxy
         fieldModifiers = EnumSet.of(PUBLIC);
       }
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
index afa771b36..9fd1e7d4c 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
@@ -164,14 +164,15 @@ MembersInjectionBinding forInjectedType(TypeElement typeElement) {
             }
           });
 
+      Key key = keyFactory.forMembersInjectedType(typeElement.asType());
       return new AutoValue_MembersInjectionBinding(
-          keyFactory.forMembersInjectedType(typeElement.asType()),
+          key,
           dependencies,
           new ImmutableSet.Builder<DependencyRequest>()
               .addAll(dependencies)
               .addAll(parentInjectorRequest.asSet())
               .build(),
-          Optional.of(MoreElements.getPackage(typeElement).getQualifiedName().toString()),
+          findBindingPackage(key),
           typeElement,
           injectionSites,
           parentInjectorRequest);
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
index 46d83242a..25cd5879b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
@@ -32,16 +32,8 @@
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ElementKind;
 import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.Name;
-import javax.lang.model.element.PackageElement;
 import javax.lang.model.element.TypeElement;
-import javax.lang.model.type.ArrayType;
-import javax.lang.model.type.DeclaredType;
-import javax.lang.model.type.TypeMirror;
-import javax.lang.model.type.TypeVariable;
-import javax.lang.model.type.WildcardType;
 import javax.lang.model.util.Elements;
-import javax.lang.model.util.SimpleTypeVisitor6;
 import javax.lang.model.util.Types;
 
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
@@ -54,7 +46,6 @@
 import static javax.lang.model.element.ElementKind.CONSTRUCTOR;
 import static javax.lang.model.element.ElementKind.FIELD;
 import static javax.lang.model.element.ElementKind.METHOD;
-import static javax.lang.model.element.Modifier.PUBLIC;
 
 /**
  * A value object representing the mechanism by which a {@link Key} can be provided. New instances
@@ -193,62 +184,6 @@ FactoryCreationStrategy factoryCreationStrategy() {
       this.dependencyRequestFactory = dependencyRequestFactory;
     }
 
-    private static Optional<String> findBindingPackage(Key providedKey) {
-      Set<String> packages = nonPublicPackageUse(providedKey.type());
-      switch (packages.size()) {
-        case 0:
-          return Optional.absent();
-        case 1:
-          return Optional.of(packages.iterator().next());
-        default:
-          throw new IllegalStateException();
-      }
-    }
-
-    private static Set<String> nonPublicPackageUse(TypeMirror typeMirror) {
-      ImmutableSet.Builder<String> packages = ImmutableSet.builder();
-      typeMirror.accept(new SimpleTypeVisitor6<Void, ImmutableSet.Builder<String>>() {
-        @Override
-        public Void visitArray(ArrayType t, ImmutableSet.Builder<String> p) {
-          return t.getComponentType().accept(this, p);
-        }
-
-        @Override
-        public Void visitDeclared(DeclaredType t, ImmutableSet.Builder<String> p) {
-          for (TypeMirror typeArgument : t.getTypeArguments()) {
-            typeArgument.accept(this, p);
-          }
-          // TODO(gak): address public nested types in non-public types
-          TypeElement typeElement = MoreElements.asType(t.asElement());
-          if (!typeElement.getModifiers().contains(PUBLIC)) {
-            PackageElement elementPackage = MoreElements.getPackage(typeElement);
-            Name qualifiedName = elementPackage.getQualifiedName();
-            p.add(qualifiedName.toString());
-          }
-          return null;
-        }
-
-        @Override
-        public Void visitTypeVariable(TypeVariable t, ImmutableSet.Builder<String> p) {
-          t.getLowerBound().accept(this, p);
-          t.getUpperBound().accept(this, p);
-          return null;
-        }
-
-        @Override
-        public Void visitWildcard(WildcardType t, ImmutableSet.Builder<String> p) {
-          if (t.getExtendsBound() != null) {
-            t.getExtendsBound().accept(this, p);
-          }
-          if (t.getSuperBound() != null) {
-            t.getSuperBound().accept(this, p);
-          }
-          return null;
-        }
-      }, packages);
-      return packages.build();
-    }
-
     ProvisionBinding forInjectConstructor(ExecutableElement constructorElement) {
       checkNotNull(constructorElement);
       checkArgument(constructorElement.getKind().equals(CONSTRUCTOR));
diff --git a/compiler/src/test/java/dagger/internal/codegen/PackageProxyTest.java b/compiler/src/test/java/dagger/internal/codegen/PackageProxyTest.java
index 6f799ece3..2fb63b9cf 100644
--- a/compiler/src/test/java/dagger/internal/codegen/PackageProxyTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/PackageProxyTest.java
@@ -12,7 +12,7 @@
 
 @RunWith(JUnit4.class)
 public class PackageProxyTest {
-  @Test public void testPackageProxy() {
+  @Test public void basicPackageProxy() {
     JavaFileObject noDepClassFile = JavaFileObjects.forSourceLines("foreign.NoDepClass",
         "package foreign;",
         "",
@@ -27,15 +27,23 @@
         "import javax.inject.Inject;",
         "",
         "public final class PublicClass {",
-        "  @Inject PublicClass(NonPublicClass dep1, NoDepClass dep2) {}",
+        "  @Inject PublicClass(NonPublicClass1 dep1, NonPublicClass2 dep2, NoDepClass dep3) {}",
         "}");
-    JavaFileObject nonPublicClassFile = JavaFileObjects.forSourceLines("foreign.NonPublicClass",
+    JavaFileObject nonPublicClass1File = JavaFileObjects.forSourceLines("foreign.NonPublicClass1",
         "package foreign;",
         "",
         "import javax.inject.Inject;",
         "",
-        "final class NonPublicClass {",
-        "  @Inject NonPublicClass(NoDepClass dep) {}",
+        "final class NonPublicClass1 {",
+        "  @Inject NonPublicClass1(NoDepClass dep) {}",
+        "}");
+    JavaFileObject nonPublicClass2File = JavaFileObjects.forSourceLines("foreign.NonPublicClass2",
+        "package foreign;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class NonPublicClass2 {",
+        "  @Inject NonPublicClass2(NoDepClass dep) {}",
         "}");
 
     JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
@@ -56,7 +64,8 @@
         "",
         "import foreign.Dagger_TestComponent__PackageProxy;",
         "import foreign.NoDepClass$$Factory;",
-        "import foreign.NonPublicClass$$Factory;",
+        "import foreign.NonPublicClass1$$Factory;",
+        "import foreign.NonPublicClass2$$Factory;",
         "import foreign.PublicClass;",
         "import foreign.PublicClass$$Factory;",
         "import javax.annotation.Generated;",
@@ -82,10 +91,14 @@
         "  }",
         "",
         "  private void initialize() {",
-        "    this.foreign_Proxy.nonPublicClassProvider =",
-        "        new NonPublicClass$$Factory(NoDepClass$$Factory.INSTANCE);",
+        "    this.foreign_Proxy.nonPublicClass1Provider =",
+        "        new NonPublicClass1$$Factory(NoDepClass$$Factory.INSTANCE);",
+        "    this.foreign_Proxy.nonPublicClass2Provider =",
+        "        new NonPublicClass2$$Factory(NoDepClass$$Factory.INSTANCE);",
         "    this.publicClassProvider = new PublicClass$$Factory(",
-        "        foreign_Proxy.nonPublicClassProvider, NoDepClass$$Factory.INSTANCE);",
+        "        foreign_Proxy.nonPublicClass1Provider,",
+        "        foreign_Proxy.nonPublicClass2Provider,",
+        "        NoDepClass$$Factory.INSTANCE);",
         "  }",
         "",
         "  @Override",
@@ -103,7 +116,138 @@
         "  }",
         "}");
     assert_().about(javaSources())
-        .that(ImmutableList.of(noDepClassFile, publicClassFile, nonPublicClassFile, componentFile))
+        .that(ImmutableList.of(
+            noDepClassFile,
+            publicClassFile,
+            nonPublicClass1File,
+            nonPublicClass2File,
+            componentFile))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(generatedComponent);
+  }
+
+  @Test public void memberInjectionPackageProxy() {
+    JavaFileObject noDepClassFile = JavaFileObjects.forSourceLines("test.NoDepClass",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "public final class NoDepClass {",
+        "  @Inject NoDepClass() {}",
+        "}");
+    JavaFileObject aClassFile = JavaFileObjects.forSourceLines("test.A",
+        "package test;",
+        "",
+        "import foreign.B;",
+        "import javax.inject.Inject;",
+        "",
+        "final class A extends B {",
+        "  @Inject NoDepClass dep;",
+        "}");
+    JavaFileObject bClassFile = JavaFileObjects.forSourceLines("foreign.B",
+        "package foreign;",
+        "",
+        "import test.NoDepClass;",
+        "import javax.inject.Inject;",
+        "",
+        "public class B extends C {",
+        "  @Inject NoDepClass dep;",
+        "}");
+    JavaFileObject cClassFile = JavaFileObjects.forSourceLines("foreign.C",
+        "package foreign;",
+        "",
+        "import test.D;",
+        "import test.NoDepClass;",
+        "import javax.inject.Inject;",
+        "",
+        "class C extends D {",
+        "  @Inject NoDepClass dep;",
+        "}");
+    JavaFileObject dClassFile = JavaFileObjects.forSourceLines("test.D",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "public class D {",
+        "  @Inject NoDepClass dep;",
+        "}");
+
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "interface TestComponent {",
+        "  void injectA(A a);",
+        "}");
+    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
+        "test.Dagger_TestComponent",
+        "package test;",
+        "",
+        "import dagger.MembersInjector;",
+        "import foreign.B;",
+        "import foreign.B$$MembersInjector;",
+        "import foreign.C$$MembersInjector;",
+        "import foreign.Dagger_TestComponent__PackageProxy;",
+        "import javax.annotation.Generated;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class Dagger_TestComponent implements TestComponent {",
+        "  private MembersInjector<D> dMembersInjector;",
+        "  private final Dagger_TestComponent__PackageProxy foreign_Proxy =",
+        "      new Dagger_TestComponent__PackageProxy();",
+        "  private MembersInjector<B> bMembersInjector;",
+        "  private MembersInjector<A> aMembersInjector;",
+        "",
+        "  private Dagger_TestComponent(Builder builder) {",
+        "    assert builder != null;",
+        "    initialize();",
+        "  }",
+        "",
+        "  public static Builder builder() {",
+        "    return new Builder();",
+        "  }",
+        "",
+        "  public static TestComponent create() {",
+        "    return builder().build();",
+        "  }",
+        "",
+        "  private void initialize() {",
+        "    this.dMembersInjector = new D$$MembersInjector(NoDepClass$$Factory.INSTANCE);",
+        "    this.foreign_Proxy.cMembersInjector =",
+        "        new C$$MembersInjector(dMembersInjector, NoDepClass$$Factory.INSTANCE);",
+        "    this.bMembersInjector = new B$$MembersInjector(",
+        "        foreign_Proxy.cMembersInjector, NoDepClass$$Factory.INSTANCE);",
+        "    this.aMembersInjector = new A$$MembersInjector(",
+        "        bMembersInjector, NoDepClass$$Factory.INSTANCE);",
+        "  }",
+        "",
+        "  @Override",
+        "  public void injectA(A a) {",
+        "    aMembersInjector.injectMembers(a);",
+        "  }",
+        "",
+        "  public static final class Builder {",
+        "    private Builder() {",
+        "    }",
+        "",
+        "    public TestComponent build() {",
+        "      return new Dagger_TestComponent(this);",
+        "    }",
+        "  }",
+        "}");
+    assert_().about(javaSources())
+        .that(ImmutableList.of(
+            noDepClassFile,
+            aClassFile,
+            bClassFile,
+            cClassFile,
+            dClassFile,
+            componentFile))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and().generatesSources(generatedComponent);
