diff --git a/.travis.yml b/.travis.yml
index 3e1627c46..140fc1548 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -6,8 +6,8 @@ jdk:
 
 android:
   components:
-    - build-tools-20.0.0
-    - android-16
+    - build-tools-23.0.0
+    - android-23
   licenses:
     - android-sdk-license-5be876d5
 
diff --git a/CHANGELOG.md b/CHANGELOG.md
index 957840eca..3a38bfc00 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,8 +1,58 @@
 Change Log
 ==========
 
-Version 1.2.0 *(2013-12-13)*
-----------------------------
+Dagger 2 (Components)
+---------------------
+
+### Version 2.0.2 *(2015-11-03)*
+
+A patch release, most crucially including:
+
+  * A fix to the way processor validation of types is done that permits dagger to play
+    more nicely with other processors, avoiding over-validating aspects that it doesn't
+    need, which may yet not have been generated by other processors in a different round
+    of processing.
+  * Some improved error reporting for edge-cases
+  * Fix to prevent incompatible versions of Guava on the classpath from blowing up processing
+  * Support a more robust set of types for map keys in map bindings (primitive types, etc.)
+
+### Version 2.0.1 *(2015-05-28)*
+
+A maintenance release fixing immediate issues following the Dagger 2.0 release, including:
+
+  * Speed up Graph Validation (reduce build times by 10s of seconds on sampled large projects)
+  * Generate correct code for @MapKey annotation types (beta)
+  * Fix to properly emit code for class literal values in @MapKey annotations.
+  * Fix for injecting component dependencies
+  * Fixes to generated code to account for differences in generics handling in ecg vs. javac.
+  * Subcomponents can now be abstract classes.
+  * Subcomponents now properly build the object graph in some cases involving explicit bindings
+    and (sub)components without scope.
+  * Improve runtime performance of SetFactory (set multibindings)
+  * Other smaller fixes, refactorings, etc.
+
+### Version 2.0.0 *(2015-04-21)*
+
+The initial release of the 2.0 code-line, supporting:
+
+  * `@Component` interfaces representing a custom API to access a graph of objects
+  * JSR-330 injection automation using `@Inject` signals, `@Qualifiers`
+  * Simple bindings of implementations to interfaces, custom provision of objects, and set-bindings
+  * Compile-time validation of graph structure (cycles, missing bindings, duplicate bindings)
+  * Generation of 
+    - backing implementations for components
+    - factories for `@Inject` constructors and modules
+    - members-injectors for `@Inject` methods and fields
+  * Beta support for
+    - Map bindings
+    - [Producers](http://google.github.io/dagger/api/latest/dagger/producers/Producer.html)
+
+==============================================================
+
+Dagger 1 (ObjectGraph)
+----------------------
+
+### Version 1.2.0 *(2013-12-13)*
 
  * Numerous performance improvements in both the compiler and runtime.
    * Use more efficient `String` concatenation.
@@ -15,8 +65,7 @@ Version 1.2.0 *(2013-12-13)*
    module adapters.
 
 
-Version 1.1.0 *(2013-08-05)*
-----------------------------
+### Version 1.1.0 *(2013-08-05)*
 
  * Module loading now requires code generation via the 'dagger-compiler' artifact.
  * Allow multiple contributions to Set binding via `Provides.Type.SET_VALUES`.
@@ -27,14 +76,12 @@ Version 1.1.0 *(2013-08-05)*
  * Update JavaWriter to 2.1.1.
 
 
-Version 1.0.1 *(2013-06-03)*
-----------------------------
+### Version 1.0.1 *(2013-06-03)*
 
  * Explicitly forbid declaring `@Inject` on a class type (e.g., `@Inject class Foo {}`).
  * Update JavaWriter to 1.0.5.
 
 
-Version 1.0.0 *(2013-05-07)*
-----------------------------
+### Version 1.0.0 *(2013-05-07)*
 
 Initial release.
diff --git a/compiler/pom.xml b/compiler/pom.xml
index 40e0fa27d..72252f1dd 100644
--- a/compiler/pom.xml
+++ b/compiler/pom.xml
@@ -46,25 +46,27 @@
       <artifactId>auto-common</artifactId>
     </dependency>
     <dependency>
-      <groupId>com.google.auto.service</groupId>
-      <artifactId>auto-service</artifactId>
+      <groupId>com.google.guava</groupId>
+      <artifactId>guava</artifactId>
+    </dependency>
+    <dependency>
+      <groupId>com.google.code.findbugs</groupId>
+      <artifactId>jsr305</artifactId>
       <optional>true</optional>
     </dependency>
-    <!-- TODO(gak): Restore this presumably as javapoet when appropriate.
     <dependency>
-      <groupId>com.squareup</groupId>
-      <artifactId>javawriter</artifactId>
+      <groupId>com.google.googlejavaformat</groupId>
+      <artifactId>google-java-format</artifactId>
     </dependency>
-    -->
     <dependency>
-      <groupId>com.google.guava</groupId>
-      <artifactId>guava</artifactId>
+      <groupId>com.google.auto.service</groupId>
+      <artifactId>auto-service</artifactId>
+      <scope>provided</scope> <!-- to leave out of the all-deps jar -->
     </dependency>
-
     <dependency>
       <groupId>com.google.auto.value</groupId>
       <artifactId>auto-value</artifactId>
-      <optional>true</optional>
+      <scope>provided</scope> <!-- to leave out of the all-deps jar -->
       <version>1.0</version>
     </dependency>
 
@@ -187,6 +189,16 @@
                   <shadedPattern>dagger.shaded.auto.common</shadedPattern>
                 </relocation>
               </relocations>
+              <filters>
+                <filter>
+                  <artifact>*:*</artifact>
+                  <excludes>
+                    <exclude>META-INF/*.SF</exclude>
+                    <exclude>META-INF/*.DSA</exclude>
+                    <exclude>META-INF/*.RSA</exclude>
+                  </excludes>
+                </filter>
+              </filters>
             </configuration>
           </execution>
         </executions>
diff --git a/compiler/src/it/functional-tests/pom.xml b/compiler/src/it/functional-tests/pom.xml
index 1eca20c14..ce3dd4e62 100644
--- a/compiler/src/it/functional-tests/pom.xml
+++ b/compiler/src/it/functional-tests/pom.xml
@@ -28,6 +28,10 @@ limitations under the License.
   <artifactId>functional-tests</artifactId>
   <name>Functional Tests</name>
   <dependencies>
+    <dependency>
+      <groupId>com.google.guava</groupId>
+      <artifactId>guava</artifactId>
+    </dependency>
     <dependency>
       <groupId>com.google.dagger</groupId>
       <artifactId>dagger</artifactId>
@@ -39,19 +43,23 @@ limitations under the License.
       <version>${project.version}</version>
       <optional>true</optional>
     </dependency>
+    <dependency>
+      <groupId>javax.inject</groupId>
+      <artifactId>javax.inject-tck</artifactId>
+    </dependency>
     <dependency>
       <!-- For map-bindings -->
       <groupId>com.google.auto.value</groupId>
       <artifactId>auto-value</artifactId>
       <version>${auto.value.version}</version>
-      <optional>true</optional>
+      <scope>provided</scope> <!-- to leave out of the all-deps jar -->
     </dependency>
     <dependency>
       <!-- For map-bindings -->
       <groupId>com.google.auto.factory</groupId>
       <artifactId>auto-factory</artifactId>
       <version>${auto.factory.version}</version>
-      <optional>true</optional>
+      <scope>provided</scope> <!-- to leave out of the all-deps jar -->
     </dependency>
 
     <dependency>
diff --git a/compiler/src/it/functional-tests/src/main/java/test/TestBooleanKey.java b/compiler/src/it/functional-tests/src/main/java/test/BooleanKey.java
similarity index 95%
rename from compiler/src/it/functional-tests/src/main/java/test/TestBooleanKey.java
rename to compiler/src/it/functional-tests/src/main/java/test/BooleanKey.java
index a4883459a..4cef79e02 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/TestBooleanKey.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/BooleanKey.java
@@ -18,6 +18,6 @@
 import dagger.MapKey;
 
 @MapKey(unwrapValue = true)
-@interface TestBooleanKey {
+@interface BooleanKey {
   boolean value();
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/TestByteKey.java b/compiler/src/it/functional-tests/src/main/java/test/ByteKey.java
similarity index 96%
rename from compiler/src/it/functional-tests/src/main/java/test/TestByteKey.java
rename to compiler/src/it/functional-tests/src/main/java/test/ByteKey.java
index 7ad25c4a2..8e739bd4a 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/TestByteKey.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/ByteKey.java
@@ -18,6 +18,6 @@
 import dagger.MapKey;
 
 @MapKey(unwrapValue = true)
-@interface TestByteKey {
+@interface ByteKey {
   byte value();
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/TestCharKey.java b/compiler/src/it/functional-tests/src/main/java/test/CharKey.java
similarity index 96%
rename from compiler/src/it/functional-tests/src/main/java/test/TestCharKey.java
rename to compiler/src/it/functional-tests/src/main/java/test/CharKey.java
index a727551de..a4f4e29c8 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/TestCharKey.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/CharKey.java
@@ -18,6 +18,6 @@
 import dagger.MapKey;
 
 @MapKey(unwrapValue = true)
-@interface TestCharKey {
+@interface CharKey {
   char value();
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/ComponentSupertypeDependsOnGeneratedCode.java b/compiler/src/it/functional-tests/src/main/java/test/ComponentSupertypeDependsOnGeneratedCode.java
new file mode 100644
index 000000000..f7460c989
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/ComponentSupertypeDependsOnGeneratedCode.java
@@ -0,0 +1,22 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import dagger.Component;
+
+@Component
+interface ComponentSupertypeDependsOnGeneratedCode
+    extends ComponentSupertypeDependsOnGeneratedCodeInterface {}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/ComponentSupertypeDependsOnGeneratedCodeInterface.java b/compiler/src/it/functional-tests/src/main/java/test/ComponentSupertypeDependsOnGeneratedCodeInterface.java
new file mode 100644
index 000000000..fca90e0f3
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/ComponentSupertypeDependsOnGeneratedCodeInterface.java
@@ -0,0 +1,20 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+interface ComponentSupertypeDependsOnGeneratedCodeInterface {
+  NeedsFactory_SomethingFactory somethingFactory();
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/MultibindingComponent.java b/compiler/src/it/functional-tests/src/main/java/test/MultibindingComponent.java
index 05542a40d..ac0624f83 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/MultibindingComponent.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/MultibindingComponent.java
@@ -16,9 +16,11 @@
 package test;
 
 import dagger.Component;
+import dagger.mapkeys.StringKey;
 import java.util.Collection;
 import java.util.Map;
 import java.util.Set;
+import javax.inject.Named;
 import javax.inject.Provider;
 import test.sub.ContributionsModule;
 
@@ -31,11 +33,12 @@
 )
 interface MultibindingComponent {
   Map<String, String> map();
+  Map<String, String[]> mapOfArrays();
   Map<String, Provider<String>> mapOfProviders();
   Set<String> mapKeys();
   Collection<String> mapValues();
   Set<Integer> set();
-  Map<TestStringKey.NestedWrappedKey, String> nestedKeyMap();
+  Map<NestedAnnotationContainer.NestedWrappedKey, String> nestedKeyMap();
   Map<Class<? extends Number>, String> numberClassKeyMap();
   Map<Class<?>, String> classKeyMap();
   Map<Long, String> longKeyMap();
@@ -44,6 +47,7 @@
   Map<Byte, String> byteKeyMap();
   Map<Boolean, String> booleanKeyMap();
   Map<Character, String> characterKeyMap();
-  Map<TestStringKey, String> unwrappedAnnotationKeyMap();
-  Map<TestWrappedAnnotationKey, String> wrappedAnnotationKeyMap();
+  Map<StringKey, String> unwrappedAnnotationKeyMap();
+  Map<WrappedAnnotationKey, String> wrappedAnnotationKeyMap();
+  @Named("complexQualifier") Set<String> complexQualifierStringSet();
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/MultibindingModule.java b/compiler/src/it/functional-tests/src/main/java/test/MultibindingModule.java
index 73d53fef3..4a7577e76 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/MultibindingModule.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/MultibindingModule.java
@@ -17,11 +17,16 @@
 
 import dagger.Module;
 import dagger.Provides;
+import dagger.mapkeys.ClassKey;
+import dagger.mapkeys.IntKey;
+import dagger.mapkeys.LongKey;
+import dagger.mapkeys.StringKey;
 import java.math.BigDecimal;
 import java.math.BigInteger;
 import java.util.Collection;
 import java.util.Map;
 import java.util.Set;
+import javax.inject.Named;
 import javax.inject.Provider;
 
 import static dagger.Provides.Type.MAP;
@@ -30,125 +35,147 @@
 @Module
 class MultibindingModule {
   @Provides(type = MAP)
-  @TestStringKey("foo")
-  String provideFooKey(double doubleDependency) {
+  @StringKey("foo")
+  static String provideFooKey(double doubleDependency) {
     return "foo value";
   }
 
   @Provides(type = MAP)
-  @TestStringKey("bar")
-  String provideBarKey() {
+  @StringKey("bar")
+  static String provideBarKey() {
     return "bar value";
   }
 
-  @Provides(type = SET) int provideFiveToSet() {
+  @Provides(type = MAP)
+  @StringKey("foo")
+  static String[] provideFooArrayValue(double doubleDependency) {
+    return new String[] {"foo1", "foo2"};
+  }
+
+  @Provides(type = MAP)
+  @StringKey("bar")
+  static String[] provideBarArrayValue() {
+    return new String[] {"bar1", "bar2"};
+  }
+
+  @Provides(type = SET)
+  static int provideFiveToSet() {
     return 5;
   }
 
-  @Provides(type = SET) int provideSixToSet() {
+  @Provides(type = SET)
+  static int provideSixToSet() {
     return 6;
   }
 
-  @Provides Set<String> provideMapKeys(Map<String, Provider<String>> map) {
+  @Provides
+  static Set<String> provideMapKeys(Map<String, Provider<String>> map) {
     return map.keySet();
   }
 
-  @Provides Collection<String> provideMapValues(Map<String, String> map) {
+  @Provides
+  static Collection<String> provideMapValues(Map<String, String> map) {
     return map.values();
   }
 
   @Provides(type = MAP)
-  @TestStringKey.NestedWrappedKey(Integer.class)
-  String valueForInteger() {
+  @NestedAnnotationContainer.NestedWrappedKey(Integer.class)
+  static String valueForInteger() {
     return "integer";
   }
 
   @Provides(type = MAP)
-  @TestStringKey.NestedWrappedKey(Long.class)
-  String valueForLong() {
+  @NestedAnnotationContainer.NestedWrappedKey(Long.class)
+  static String valueForLong() {
     return "long";
   }
 
   @Provides(type = MAP)
-  @TestClassKey(Integer.class)
-  String valueForClassInteger() {
+  @ClassKey(Integer.class)
+  static String valueForClassInteger() {
     return "integer";
   }
 
   @Provides(type = MAP)
-  @TestClassKey(Long.class)
-  String valueForClassLong() {
+  @ClassKey(Long.class)
+  static String valueForClassLong() {
     return "long";
   }
 
   @Provides(type = MAP)
-  @TestNumberClassKey(BigDecimal.class)
-  String valueForNumberClassBigDecimal() {
+  @NumberClassKey(BigDecimal.class)
+  static String valueForNumberClassBigDecimal() {
     return "bigdecimal";
   }
 
   @Provides(type = MAP)
-  @TestNumberClassKey(BigInteger.class)
-  String valueForNumberClassBigInteger() {
+  @NumberClassKey(BigInteger.class)
+  static String valueForNumberClassBigInteger() {
     return "biginteger";
   }
 
   @Provides(type = MAP)
-  @TestLongKey(longValue = 100)
-  String valueFor100Long() {
+  @LongKey(100)
+  static String valueFor100Long() {
     return "100 long";
   }
 
   @Provides(type = MAP)
-  @TestIntKey(100)
-  String valueFor100Int() {
+  @IntKey(100)
+  static String valueFor100Int() {
     return "100 int";
   }
 
   @Provides(type = MAP)
-  @TestShortKey(100)
-  String valueFor100Short() {
+  @ShortKey(100)
+  static String valueFor100Short() {
     return "100 short";
   }
 
   @Provides(type = MAP)
-  @TestByteKey(100)
-  String valueFor100Byte() {
+  @ByteKey(100)
+  static String valueFor100Byte() {
     return "100 byte";
   }
 
   @Provides(type = MAP)
-  @TestBooleanKey(true)
-  String valueForTrue() {
+  @BooleanKey(true)
+  static String valueForTrue() {
     return "true";
   }
 
   @Provides(type = MAP)
-  @TestCharKey('a')
-  String valueForA() {
+  @CharKey('a')
+  static String valueForA() {
     return "a char";
   }
 
   @Provides(type = MAP)
-  @TestCharKey('\n')
-  String valueForNewline() {
+  @CharKey('\n')
+  static String valueForNewline() {
     return "newline char";
   }
 
   @Provides(type = MAP)
-  @TestUnwrappedAnnotationKey(@TestStringKey("foo\n"))
-  String valueForUnwrappedAnnotationKeyFoo() {
+  @UnwrappedAnnotationKey(@StringKey("foo\n"))
+  static String valueForUnwrappedAnnotationKeyFoo() {
     return "foo annotation";
   }
 
   @Provides(type = MAP)
-  @TestWrappedAnnotationKey(
-    value = @TestStringKey("foo"),
+  @WrappedAnnotationKey(
+    value = @StringKey("foo"),
     integers = {1, 2, 3},
     annotations = {},
     classes = {Long.class, Integer.class}
   )
-  String valueForWrappedAnnotationKeyFoo() {
+  static String valueForWrappedAnnotationKeyFoo() {
     return "wrapped foo annotation";
   }
+
+  @Provides(type = SET)
+  @Named("complexQualifier")
+  static String valueForComplexQualifierSet() {
+    return "foo";
+  }
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/TestStringKey.java b/compiler/src/it/functional-tests/src/main/java/test/NestedAnnotationContainer.java
similarity index 90%
rename from compiler/src/it/functional-tests/src/main/java/test/TestStringKey.java
rename to compiler/src/it/functional-tests/src/main/java/test/NestedAnnotationContainer.java
index a0e89ed71..c57b4ecf4 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/TestStringKey.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/NestedAnnotationContainer.java
@@ -17,9 +17,7 @@
 
 import dagger.MapKey;
 
-@MapKey(unwrapValue = true)
-@interface TestStringKey {
-  String value();
+public final class NestedAnnotationContainer {
 
   @MapKey(unwrapValue = false)
   @interface NestedWrappedKey {
diff --git a/compiler/src/it/functional-tests/src/main/java/test/TestNumberClassKey.java b/compiler/src/it/functional-tests/src/main/java/test/NumberClassKey.java
similarity index 95%
rename from compiler/src/it/functional-tests/src/main/java/test/TestNumberClassKey.java
rename to compiler/src/it/functional-tests/src/main/java/test/NumberClassKey.java
index 884c75e19..4164ae5cc 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/TestNumberClassKey.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/NumberClassKey.java
@@ -18,6 +18,6 @@
 import dagger.MapKey;
 
 @MapKey(unwrapValue = true)
-@interface TestNumberClassKey {
+@interface NumberClassKey {
   Class<? extends Number> value();
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/TestShortKey.java b/compiler/src/it/functional-tests/src/main/java/test/ShortKey.java
similarity index 96%
rename from compiler/src/it/functional-tests/src/main/java/test/TestShortKey.java
rename to compiler/src/it/functional-tests/src/main/java/test/ShortKey.java
index a74f21041..01b3aa99d 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/TestShortKey.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/ShortKey.java
@@ -18,6 +18,6 @@
 import dagger.MapKey;
 
 @MapKey(unwrapValue = true)
-@interface TestShortKey {
+@interface ShortKey {
   short value();
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/TestIntKey.java b/compiler/src/it/functional-tests/src/main/java/test/TestIntKey.java
deleted file mode 100644
index 14b25cf5d..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/TestIntKey.java
+++ /dev/null
@@ -1,23 +0,0 @@
-/*
-* Copyright (C) 2015 Google, Inc.
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
-*
-* http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS,
-* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-* See the License for the specific language governing permissions and
-* limitations under the License.
-*/
-package test;
-
-import dagger.MapKey;
-
-@MapKey(unwrapValue = true)
-@interface TestIntKey {
-  int value();
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/TestLongKey.java b/compiler/src/it/functional-tests/src/main/java/test/TestLongKey.java
deleted file mode 100644
index ba06ad0e1..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/TestLongKey.java
+++ /dev/null
@@ -1,23 +0,0 @@
-/*
-* Copyright (C) 2015 Google, Inc.
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
-*
-* http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS,
-* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-* See the License for the specific language governing permissions and
-* limitations under the License.
-*/
-package test;
-
-import dagger.MapKey;
-
-@MapKey(unwrapValue = true)
-@interface TestLongKey {
-  long longValue(); // Tests that the unwrapped member can have any name.
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/TestUnwrappedAnnotationKey.java b/compiler/src/it/functional-tests/src/main/java/test/TestUnwrappedAnnotationKey.java
deleted file mode 100644
index a00372890..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/TestUnwrappedAnnotationKey.java
+++ /dev/null
@@ -1,23 +0,0 @@
-/*
-* Copyright (C) 2015 Google, Inc.
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
-*
-* http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS,
-* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-* See the License for the specific language governing permissions and
-* limitations under the License.
-*/
-package test;
-
-import dagger.MapKey;
-
-@MapKey(unwrapValue = true)
-@interface TestUnwrappedAnnotationKey {
-  TestStringKey value();
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/TestClassKey.java b/compiler/src/it/functional-tests/src/main/java/test/UnwrappedAnnotationKey.java
similarity index 87%
rename from compiler/src/it/functional-tests/src/main/java/test/TestClassKey.java
rename to compiler/src/it/functional-tests/src/main/java/test/UnwrappedAnnotationKey.java
index 921259781..21ed95841 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/TestClassKey.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/UnwrappedAnnotationKey.java
@@ -16,8 +16,9 @@
 package test;
 
 import dagger.MapKey;
+import dagger.mapkeys.StringKey;
 
 @MapKey(unwrapValue = true)
-@interface TestClassKey {
-  Class<?> value();
+@interface UnwrappedAnnotationKey {
+  StringKey value();
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/TestWrappedAnnotationKey.java b/compiler/src/it/functional-tests/src/main/java/test/WrappedAnnotationKey.java
similarity index 82%
rename from compiler/src/it/functional-tests/src/main/java/test/TestWrappedAnnotationKey.java
rename to compiler/src/it/functional-tests/src/main/java/test/WrappedAnnotationKey.java
index 13c059058..5d6e86dc7 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/TestWrappedAnnotationKey.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/WrappedAnnotationKey.java
@@ -16,11 +16,13 @@
 package test;
 
 import dagger.MapKey;
+import dagger.mapkeys.ClassKey;
+import dagger.mapkeys.StringKey;
 
 @MapKey(unwrapValue = false)
-@interface TestWrappedAnnotationKey {
-  TestStringKey value();
+@interface WrappedAnnotationKey {
+  StringKey value();
   int[] integers();
-  TestClassKey[] annotations();
+  ClassKey[] annotations();
   Class<? extends Number>[] classes();
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builder/MiddleChild.java b/compiler/src/it/functional-tests/src/main/java/test/builder/MiddleChild.java
index 59c29ab34..690c91ad7 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/builder/MiddleChild.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/builder/MiddleChild.java
@@ -24,6 +24,8 @@
   
   Grandchild.Builder grandchildBuilder();
   
+  RequiresSubcomponentBuilder<Grandchild.Builder> requiresGrandchildBuilder();
+  
   @Subcomponent.Builder
   interface Builder {
     MiddleChild build();
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builder/ParentComponent.java b/compiler/src/it/functional-tests/src/main/java/test/builder/ParentComponent.java
index f901b8863..584eff6ef 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/builder/ParentComponent.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/builder/ParentComponent.java
@@ -26,4 +26,6 @@
   
   MiddleChild.Builder middleBuilder();
   OtherMiddleChild.Builder otherBuilder();
+  
+  RequiresSubcomponentBuilder<MiddleChild.Builder> requiresMiddleChildBuilder();
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builder/RequiresSubcomponentBuilder.java b/compiler/src/it/functional-tests/src/main/java/test/builder/RequiresSubcomponentBuilder.java
new file mode 100644
index 000000000..ee9963227
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/builder/RequiresSubcomponentBuilder.java
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.builder;
+
+import javax.inject.Inject;
+import javax.inject.Provider;
+
+class RequiresSubcomponentBuilder<B> {
+  private final Provider<B> subcomponentBuilderProvider;
+  private final B subcomponentBuilder;
+
+  @Inject
+  RequiresSubcomponentBuilder(Provider<B> subcomponentBuilderProvider, B subcomponentBuilder) {
+    this.subcomponentBuilderProvider = subcomponentBuilderProvider;
+    this.subcomponentBuilder = subcomponentBuilder;
+  }
+
+  Provider<B> subcomponentBuilderProvider() {
+    return subcomponentBuilderProvider;
+  }
+  
+  B subcomponentBuilder() {
+    return subcomponentBuilder;
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/cycle/Cycles.java b/compiler/src/it/functional-tests/src/main/java/test/cycle/Cycles.java
new file mode 100644
index 000000000..8d67d92eb
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/cycle/Cycles.java
@@ -0,0 +1,162 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.cycle;
+
+import dagger.Component;
+import dagger.Lazy;
+import dagger.Module;
+import dagger.Provides;
+import dagger.Subcomponent;
+import dagger.mapkeys.StringKey;
+import java.util.Map;
+import javax.inject.Inject;
+import javax.inject.Provider;
+
+import static dagger.Provides.Type.MAP;
+
+/**
+ * Cycle classes used for testing cyclic dependencies.
+ * A <- (E <- D <- B <- C <- Provider<A>, Lazy<A>), (B <- C <- Provider<A>, Lazy<A>)
+ * S <- Provider<S>, Lazy<S>
+ *
+ * @author Tony Bentancur
+ * @since 2.0
+ */
+
+final class Cycles {
+  private Cycles() {}
+
+  static class A {
+    public final B b;
+    public final E e;
+
+    @Inject
+    A(E e, B b) {
+      this.e = e;
+      this.b = b;
+    }
+  }
+
+  static class B {
+    public final C c;
+
+    @Inject
+    B(C c) {
+      this.c = c;
+    }
+  }
+
+  static class C {
+    public final Provider<A> aProvider;
+    @Inject public Lazy<A> aLazy;
+
+    @Inject
+    C(Provider<A> aProvider) {
+      this.aProvider = aProvider;
+    }
+  }
+
+  static class D {
+    public final B b;
+
+    @Inject
+    D(B b) {
+      this.b = b;
+    }
+  }
+
+  static class E {
+    public final D d;
+
+    @Inject
+    E(D d) {
+      this.d = d;
+    }
+  }
+
+  static class S {
+    public final Provider<S> sProvider;
+    @Inject public Lazy<S> sLazy;
+
+    @Inject
+    S(Provider<S> sProvider) {
+      this.sProvider = sProvider;
+    }
+  }
+
+  static class X {
+    public final Y y;
+
+    @Inject
+    X(Y y) {
+      this.y = y;
+    }
+  }
+
+  static class Y {
+    public final Map<String, Provider<X>> mapOfProvidersOfX;
+    public final Map<String, Provider<Y>> mapOfProvidersOfY;
+
+    @Inject
+    Y(Map<String, Provider<X>> mapOfProvidersOfX, Map<String, Provider<Y>> mapOfProvidersOfY) {
+      this.mapOfProvidersOfX = mapOfProvidersOfX;
+      this.mapOfProvidersOfY = mapOfProvidersOfY;
+    }
+  }
+
+  @Module
+  static class CycleMapModule {
+    @Provides(type = MAP)
+    @StringKey("X")
+    static X x(X x) {
+      return x;
+    }
+
+    @Provides(type = MAP)
+    @StringKey("Y")
+    static Y y(Y y) {
+      return y;
+    }
+  }
+
+  @SuppressWarnings("dependency-cycle")
+  @Component(modules = CycleMapModule.class)
+  interface CycleMapComponent {
+    Y y();
+  }
+
+  @SuppressWarnings("dependency-cycle")
+  @Component
+  interface CycleComponent {
+    A a();
+
+    C c();
+
+    ChildCycleComponent child();
+  }
+
+  @SuppressWarnings("dependency-cycle")
+  @Component
+  interface SelfCycleComponent {
+    S s();
+  }
+
+  @Subcomponent
+  interface ChildCycleComponent {
+    @SuppressWarnings("dependency-cycle")
+    A a();
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/cycle/LongCycle.java b/compiler/src/it/functional-tests/src/main/java/test/cycle/LongCycle.java
new file mode 100644
index 000000000..b4f61e096
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/cycle/LongCycle.java
@@ -0,0 +1,132 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.cycle;
+
+import dagger.Component;
+import javax.inject.Inject;
+import javax.inject.Provider;
+
+final class LongCycle {
+  static class Class1 { @Inject Class1(Class2 class2) {} }
+  static class Class2 { @Inject Class2(Class3 class3) {} }
+  static class Class3 { @Inject Class3(Class4 class4) {} }
+  static class Class4 { @Inject Class4(Class5 class5) {} }
+  static class Class5 { @Inject Class5(Class6 class6) {} }
+  static class Class6 { @Inject Class6(Class7 class7) {} }
+  static class Class7 { @Inject Class7(Class8 class8) {} }
+  static class Class8 { @Inject Class8(Class9 class9) {} }
+  static class Class9 { @Inject Class9(Class10 class10) {} }
+  static class Class10 { @Inject Class10(Class11 class11) {} }
+  static class Class11 { @Inject Class11(Class12 class12) {} }
+  static class Class12 { @Inject Class12(Class13 class13) {} }
+  static class Class13 { @Inject Class13(Class14 class14) {} }
+  static class Class14 { @Inject Class14(Class15 class15) {} }
+  static class Class15 { @Inject Class15(Class16 class16) {} }
+  static class Class16 { @Inject Class16(Class17 class17) {} }
+  static class Class17 { @Inject Class17(Class18 class18) {} }
+  static class Class18 { @Inject Class18(Class19 class19) {} }
+  static class Class19 { @Inject Class19(Class20 class20) {} }
+  static class Class20 { @Inject Class20(Class21 class21) {} }
+  static class Class21 { @Inject Class21(Class22 class22) {} }
+  static class Class22 { @Inject Class22(Class23 class23) {} }
+  static class Class23 { @Inject Class23(Class24 class24) {} }
+  static class Class24 { @Inject Class24(Class25 class25) {} }
+  static class Class25 { @Inject Class25(Class26 class26) {} }
+  static class Class26 { @Inject Class26(Class27 class27) {} }
+  static class Class27 { @Inject Class27(Class28 class28) {} }
+  static class Class28 { @Inject Class28(Class29 class29) {} }
+  static class Class29 { @Inject Class29(Class30 class30) {} }
+  static class Class30 { @Inject Class30(Class31 class31) {} }
+  static class Class31 { @Inject Class31(Class32 class32) {} }
+  static class Class32 { @Inject Class32(Class33 class33) {} }
+  static class Class33 { @Inject Class33(Class34 class34) {} }
+  static class Class34 { @Inject Class34(Class35 class35) {} }
+  static class Class35 { @Inject Class35(Class36 class36) {} }
+  static class Class36 { @Inject Class36(Class37 class37) {} }
+  static class Class37 { @Inject Class37(Class38 class38) {} }
+  static class Class38 { @Inject Class38(Class39 class39) {} }
+  static class Class39 { @Inject Class39(Class40 class40) {} }
+  static class Class40 { @Inject Class40(Class41 class41) {} }
+  static class Class41 { @Inject Class41(Class42 class42) {} }
+  static class Class42 { @Inject Class42(Class43 class43) {} }
+  static class Class43 { @Inject Class43(Class44 class44) {} }
+  static class Class44 { @Inject Class44(Class45 class45) {} }
+  static class Class45 { @Inject Class45(Class46 class46) {} }
+  static class Class46 { @Inject Class46(Class47 class47) {} }
+  static class Class47 { @Inject Class47(Class48 class48) {} }
+  static class Class48 { @Inject Class48(Class49 class49) {} }
+  static class Class49 { @Inject Class49(Class50 class50) {} }
+  static class Class50 { @Inject Class50(Class51 class51) {} }
+  static class Class51 { @Inject Class51(Class52 class52) {} }
+  static class Class52 { @Inject Class52(Class53 class53) {} }
+  static class Class53 { @Inject Class53(Class54 class54) {} }
+  static class Class54 { @Inject Class54(Class55 class55) {} }
+  static class Class55 { @Inject Class55(Class56 class56) {} }
+  static class Class56 { @Inject Class56(Class57 class57) {} }
+  static class Class57 { @Inject Class57(Class58 class58) {} }
+  static class Class58 { @Inject Class58(Class59 class59) {} }
+  static class Class59 { @Inject Class59(Class60 class60) {} }
+  static class Class60 { @Inject Class60(Class61 class61) {} }
+  static class Class61 { @Inject Class61(Class62 class62) {} }
+  static class Class62 { @Inject Class62(Class63 class63) {} }
+  static class Class63 { @Inject Class63(Class64 class64) {} }
+  static class Class64 { @Inject Class64(Class65 class65) {} }
+  static class Class65 { @Inject Class65(Class66 class66) {} }
+  static class Class66 { @Inject Class66(Class67 class67) {} }
+  static class Class67 { @Inject Class67(Class68 class68) {} }
+  static class Class68 { @Inject Class68(Class69 class69) {} }
+  static class Class69 { @Inject Class69(Class70 class70) {} }
+  static class Class70 { @Inject Class70(Class71 class71) {} }
+  static class Class71 { @Inject Class71(Class72 class72) {} }
+  static class Class72 { @Inject Class72(Class73 class73) {} }
+  static class Class73 { @Inject Class73(Class74 class74) {} }
+  static class Class74 { @Inject Class74(Class75 class75) {} }
+  static class Class75 { @Inject Class75(Class76 class76) {} }
+  static class Class76 { @Inject Class76(Class77 class77) {} }
+  static class Class77 { @Inject Class77(Class78 class78) {} }
+  static class Class78 { @Inject Class78(Class79 class79) {} }
+  static class Class79 { @Inject Class79(Class80 class80) {} }
+  static class Class80 { @Inject Class80(Class81 class81) {} }
+  static class Class81 { @Inject Class81(Class82 class82) {} }
+  static class Class82 { @Inject Class82(Class83 class83) {} }
+  static class Class83 { @Inject Class83(Class84 class84) {} }
+  static class Class84 { @Inject Class84(Class85 class85) {} }
+  static class Class85 { @Inject Class85(Class86 class86) {} }
+  static class Class86 { @Inject Class86(Class87 class87) {} }
+  static class Class87 { @Inject Class87(Class88 class88) {} }
+  static class Class88 { @Inject Class88(Class89 class89) {} }
+  static class Class89 { @Inject Class89(Class90 class90) {} }
+  static class Class90 { @Inject Class90(Class91 class91) {} }
+  static class Class91 { @Inject Class91(Class92 class92) {} }
+  static class Class92 { @Inject Class92(Class93 class93) {} }
+  static class Class93 { @Inject Class93(Class94 class94) {} }
+  static class Class94 { @Inject Class94(Class95 class95) {} }
+  static class Class95 { @Inject Class95(Class96 class96) {} }
+  static class Class96 { @Inject Class96(Class97 class97) {} }
+  static class Class97 { @Inject Class97(Class98 class98) {} }
+  static class Class98 { @Inject Class98(Class99 class99) {} }
+  static class Class99 { @Inject Class99(Class100 class100) {} }
+  static class Class100 { @Inject Class100(Class101 class101) {} }
+  static class Class101 { @Inject Class101(Provider<Class1> class1Provider) {} }
+
+  @SuppressWarnings("dependency-cycle")
+  @Component
+  interface LongCycleComponent {
+    Class1 class1();
+  }
+
+  private LongCycle() {}
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/membersinject/NonRequestedChild.java b/compiler/src/it/functional-tests/src/main/java/test/membersinject/NonRequestedChild.java
new file mode 100644
index 000000000..108a1b58f
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/membersinject/NonRequestedChild.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.membersinject;
+
+import javax.inject.Inject;
+
+/**
+ * A class that should not be requested by any component, to ensure that we still generate a members
+ * injector for it.
+ */
+class NonRequestedChild extends MembersInjectGenericParent<String> {
+  @Inject
+  NonRequestedChild() {}
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/multipackage/MembersInjectionVisibilityComponent.java b/compiler/src/it/functional-tests/src/main/java/test/multipackage/MembersInjectionVisibilityComponent.java
new file mode 100644
index 000000000..85ce40aac
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/multipackage/MembersInjectionVisibilityComponent.java
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.multipackage;
+
+import dagger.Component;
+import test.multipackage.a.AGrandchild;
+import test.multipackage.a.AModule;
+import test.multipackage.a.AParent;
+import test.multipackage.b.BChild;
+
+/**
+ * A component that tests members injection across packages and subclasses.
+ */
+@Component(modules = {AModule.class})
+public interface MembersInjectionVisibilityComponent {
+  void inject(AParent aParent);
+
+  void inject(BChild aChild);
+
+  void inject(AGrandchild aGrandchild);
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/AGrandchild.java b/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/AGrandchild.java
new file mode 100644
index 000000000..8f0f1f39c
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/AGrandchild.java
@@ -0,0 +1,50 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.multipackage.a;
+
+import javax.inject.Inject;
+import test.multipackage.b.BChild;
+
+public class AGrandchild extends BChild {
+
+  @Inject APackagePrivateObject aGrandchildField;
+
+  private APackagePrivateObject aGrandchildMethod;
+
+  @Inject
+  void aGrandchildMethod(APackagePrivateObject aGrandchildMethod) {
+    this.aGrandchildMethod = aGrandchildMethod;
+  }
+
+  @Override
+  @Inject
+  protected void aParentMethod(APublicObject aParentMethod) {
+    super.aParentMethod(aParentMethod);
+  }
+
+  @Override
+  protected void aChildMethod(APublicObject aChildMethod) {
+    super.aChildMethod(aChildMethod);
+  }
+
+  public APackagePrivateObject aGrandchildField() {
+    return aGrandchildField;
+  }
+
+  public APackagePrivateObject aGrandchildMethod() {
+    return aGrandchildMethod;
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/APackagePrivateObject.java b/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/APackagePrivateObject.java
new file mode 100644
index 000000000..d60413331
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/APackagePrivateObject.java
@@ -0,0 +1,24 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.multipackage.a;
+
+import javax.inject.Inject;
+
+class APackagePrivateObject {
+
+  @Inject
+  APackagePrivateObject() {}
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/AParent.java b/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/AParent.java
new file mode 100644
index 000000000..4c91a6f26
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/AParent.java
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.multipackage.a;
+
+import javax.inject.Inject;
+
+public class AParent {
+
+  @Inject APackagePrivateObject aParentField;
+
+  private APublicObject aParentMethod;
+
+  @Inject
+  protected void aParentMethod(APublicObject aParentMethod) {
+    this.aParentMethod = aParentMethod;
+  }
+
+  public APackagePrivateObject aParentField() {
+    return aParentField;
+  }
+
+  public APublicObject aParentMethod() {
+    return aParentMethod;
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/APublicObject.java b/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/APublicObject.java
new file mode 100644
index 000000000..90357f661
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/APublicObject.java
@@ -0,0 +1,24 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.multipackage.a;
+
+import javax.inject.Inject;
+
+public class APublicObject {
+
+  @Inject
+  APublicObject() {}
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/multipackage/b/BChild.java b/compiler/src/it/functional-tests/src/main/java/test/multipackage/b/BChild.java
new file mode 100644
index 000000000..188d1201f
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/multipackage/b/BChild.java
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.multipackage.b;
+
+import javax.inject.Inject;
+import test.multipackage.a.AParent;
+import test.multipackage.a.APublicObject;
+
+public class BChild extends AParent {
+
+  @Inject BPackagePrivateObject aChildField;
+
+  private APublicObject aChildMethod;
+
+  @Inject
+  protected void aChildMethod(APublicObject aChildMethod) {
+    this.aChildMethod = aChildMethod;
+  }
+
+  @Override
+  protected void aParentMethod(APublicObject aParentMethod) {
+    super.aParentMethod(aParentMethod);
+  }
+
+  public BPackagePrivateObject aChildField() {
+    return aChildField;
+  }
+
+  public APublicObject aChildMethod() {
+    return aChildMethod;
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/multipackage/b/BPackagePrivateObject.java b/compiler/src/it/functional-tests/src/main/java/test/multipackage/b/BPackagePrivateObject.java
new file mode 100644
index 000000000..c397a02c8
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/multipackage/b/BPackagePrivateObject.java
@@ -0,0 +1,24 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.multipackage.b;
+
+import javax.inject.Inject;
+
+class BPackagePrivateObject {
+
+  @Inject
+  BPackagePrivateObject() {}
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/staticprovides/StaticTestComponent.java b/compiler/src/it/functional-tests/src/main/java/test/staticprovides/StaticTestComponent.java
index 255f28c3a..4be51ed7b 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/staticprovides/StaticTestComponent.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/staticprovides/StaticTestComponent.java
@@ -19,7 +19,7 @@
 import java.util.Set;
 
 /**
- * A simple component that demonstrates both static an non-static provides methods.
+ * A simple component that demonstrates both static and non-static provides methods.
  */
 @Component(modules = {AllStaticModule.class, SomeStaticModule.class})
 interface StaticTestComponent {
diff --git a/compiler/src/it/functional-tests/src/main/java/test/staticprovides/StaticTestComponentWithBuilder.java b/compiler/src/it/functional-tests/src/main/java/test/staticprovides/StaticTestComponentWithBuilder.java
new file mode 100644
index 000000000..d778fc5c5
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/staticprovides/StaticTestComponentWithBuilder.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.staticprovides;
+
+import dagger.Component;
+
+/**
+ * A simple component that demonstrates both static and non-static provides methods with a builder.
+ */
+@Component(modules = {AllStaticModule.class, SomeStaticModule.class})
+interface StaticTestComponentWithBuilder extends StaticTestComponent {
+  @Component.Builder
+  interface Builder {
+    Builder allStaticModule(AllStaticModule allStaticModule);
+    Builder someStaticModule(SomeStaticModule someStaticModule);
+    StaticTestComponentWithBuilder build();
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildAbstractClassComponent.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildAbstractClassComponent.java
index 6c061bc5c..2529433ae 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildAbstractClassComponent.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildAbstractClassComponent.java
@@ -17,6 +17,6 @@
 
 import dagger.Subcomponent;
 
-@Subcomponent(modules = ChildModule.class)
+@Subcomponent(modules = {ChildModule.class, StaticChildModule.class})
 abstract class ChildAbstractClassComponent implements ChildComponent {
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildComponent.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildComponent.java
index 67d66cae9..d3c28f2b4 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildComponent.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildComponent.java
@@ -19,7 +19,7 @@
 import java.util.Set;
 import javax.inject.Provider;
 
-@Subcomponent(modules = ChildModule.class)
+@Subcomponent(modules = {ChildModule.class, StaticChildModule.class})
 interface ChildComponent {
   Provider<UnscopedType> getUnscopedTypeProvider();
 
@@ -28,4 +28,6 @@
   Set<Object> objectSet();
 
   GrandchildComponent newGrandchildComponent();
+  
+  Object object();
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildComponentWithMultibindings.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildComponentWithMultibindings.java
new file mode 100644
index 000000000..9ed266aec
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildComponentWithMultibindings.java
@@ -0,0 +1,23 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.subcomponent;
+
+import dagger.Subcomponent;
+
+@Subcomponent(modules = ChildMultibindingModule.class)
+interface ChildComponentWithMultibindings {
+  RequiresMultibindingsInChild requiresMultibindingsInChild();
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildMultibindingModule.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildMultibindingModule.java
new file mode 100644
index 000000000..ae02b9e6f
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildMultibindingModule.java
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.subcomponent;
+
+import dagger.Module;
+import dagger.Provides;
+import dagger.mapkeys.StringKey;
+
+import static dagger.Provides.Type.MAP;
+import static dagger.Provides.Type.SET;
+
+@Module
+class ChildMultibindingModule {
+
+  @Provides(type = SET)
+  static Object childObject() {
+    return "object provided by child";
+  }
+
+  @Provides(type = MAP)
+  @StringKey("child key")
+  static Object childKeyObject() {
+    return "object in child";
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentComponentWithMultibindings.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentComponentWithMultibindings.java
new file mode 100644
index 000000000..46fe8835c
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentComponentWithMultibindings.java
@@ -0,0 +1,23 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.subcomponent;
+
+import dagger.Component;
+
+@Component(modules = ParentMultibindingModule.class)
+interface ParentComponentWithMultibindings extends ParentComponentWithoutMultibindings {
+  RequiresMultibindingsInParent requiresMultibindingsInParent();
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentComponentWithoutMultibindings.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentComponentWithoutMultibindings.java
new file mode 100644
index 000000000..3d4431ca9
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentComponentWithoutMultibindings.java
@@ -0,0 +1,23 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.subcomponent;
+
+import dagger.Component;
+
+@Component(modules = ParentMultibindingModule.class)
+interface ParentComponentWithoutMultibindings {
+  ChildComponentWithMultibindings childComponent();
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentMultibindingModule.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentMultibindingModule.java
new file mode 100644
index 000000000..e4ec173de
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentMultibindingModule.java
@@ -0,0 +1,55 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.subcomponent;
+
+import dagger.Module;
+import dagger.Provides;
+import dagger.mapkeys.StringKey;
+
+import static dagger.Provides.Type.MAP;
+import static dagger.Provides.Type.SET;
+
+@Module
+class ParentMultibindingModule {
+
+  @Provides(type = SET)
+  static Object provideObject() {
+    return "object provided by parent";
+  }
+
+  @Provides(type = SET)
+  static String provideString() {
+    return "string provided by parent";
+  }
+
+  @Provides(type = SET)
+  static RequiresMultiboundObjects requiresMultiboundObjects(
+      RequiresMultiboundObjects requiresMultiboundObjects) {
+    return requiresMultiboundObjects;
+  }
+
+  @Provides(type = MAP)
+  @StringKey("parent key")
+  static String parentKeyString() {
+    return "string in parent";
+  }
+
+  @Provides(type = MAP)
+  @StringKey("parent key")
+  static Object parentKeyObject() {
+    return "object in parent";
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/RequiresMultibindingsInChild.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/RequiresMultibindingsInChild.java
new file mode 100644
index 000000000..4ec0469de
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/RequiresMultibindingsInChild.java
@@ -0,0 +1,30 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.subcomponent;
+
+import java.util.Set;
+import javax.inject.Inject;
+
+class RequiresMultibindingsInChild extends RequiresMultibindingsInParent {
+
+  @Inject
+  RequiresMultibindingsInChild(
+      RequiresMultiboundObjects requiresMultiboundObjects,
+      RequiresMultiboundStrings requiresMultiboundStrings,
+      Set<RequiresMultiboundObjects> setOfRequiresMultiboundObjects) {
+    super(requiresMultiboundObjects, requiresMultiboundStrings, setOfRequiresMultiboundObjects);
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/RequiresMultibindingsInParent.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/RequiresMultibindingsInParent.java
new file mode 100644
index 000000000..a48d38bfa
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/RequiresMultibindingsInParent.java
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.subcomponent;
+
+import java.util.Set;
+import javax.inject.Inject;
+
+class RequiresMultibindingsInParent {
+  private final RequiresMultiboundObjects requiresMultiboundObjects;
+  private final RequiresMultiboundStrings requiresMultiboundStrings;
+  private final Set<RequiresMultiboundObjects> setOfRequiresMultiboundObjects;
+
+  @Inject
+  RequiresMultibindingsInParent(
+      RequiresMultiboundObjects requiresMultiboundObjects,
+      RequiresMultiboundStrings requiresMultiboundStrings,
+      Set<RequiresMultiboundObjects> setOfRequiresMultiboundObjects) {
+    this.requiresMultiboundObjects = requiresMultiboundObjects;
+    this.requiresMultiboundStrings = requiresMultiboundStrings;
+    this.setOfRequiresMultiboundObjects = setOfRequiresMultiboundObjects;
+  }
+
+  RequiresMultiboundObjects requiresMultiboundObjects() {
+    return requiresMultiboundObjects;
+  }
+
+  RequiresMultiboundStrings requiresMultiboundStrings() {
+    return requiresMultiboundStrings;
+  }
+
+  Set<RequiresMultiboundObjects> setOfRequiresMultiboundObjects() {
+    return setOfRequiresMultiboundObjects;
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/RequiresMultiboundObjects.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/RequiresMultiboundObjects.java
new file mode 100644
index 000000000..d787153e3
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/RequiresMultiboundObjects.java
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.subcomponent;
+
+import java.util.Map;
+import java.util.Set;
+import javax.inject.Inject;
+
+class RequiresMultiboundObjects {
+  private final Set<Object> setOfObjects;
+  private final Map<String, Object> mapOfObjects;
+
+  @Inject
+  RequiresMultiboundObjects(Set<Object> setOfObjects, Map<String, Object> mapOfObjects) {
+    this.setOfObjects = setOfObjects;
+    this.mapOfObjects = mapOfObjects;
+  }
+
+  Set<Object> setOfObjects() {
+    return setOfObjects;
+  }
+
+  Map<String, Object> mapOfObjects() {
+    return mapOfObjects;
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/RequiresMultiboundStrings.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/RequiresMultiboundStrings.java
new file mode 100644
index 000000000..410bdf2c0
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/RequiresMultiboundStrings.java
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.subcomponent;
+
+import java.util.Map;
+import java.util.Set;
+import javax.inject.Inject;
+
+class RequiresMultiboundStrings {
+  private final Set<String> setOfStrings;
+  private final Map<String, String> mapOfStrings;
+
+  @Inject
+  RequiresMultiboundStrings(Set<String> setOfStrings, Map<String, String> mapOfStrings) {
+    this.setOfStrings = setOfStrings;
+    this.mapOfStrings = mapOfStrings;
+  }
+
+  Set<String> setOfStrings() {
+    return setOfStrings;
+  }
+
+  Map<String, String> mapOfStrings() {
+    return mapOfStrings;
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/StaticChildModule.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/StaticChildModule.java
new file mode 100644
index 000000000..f7fd49058
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/StaticChildModule.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.subcomponent;
+
+import dagger.Module;
+import dagger.Provides;
+
+@Module
+final class StaticChildModule {
+  private StaticChildModule() {}
+  
+  @Provides static Object provideStaticObject() {
+    return "static";
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/ChildComponent.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/ChildComponent.java
deleted file mode 100644
index badb7cac6..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/ChildComponent.java
+++ /dev/null
@@ -1,14 +0,0 @@
-
-
-package test.subcomponent.repeat;
-
-import dagger.Subcomponent;
-
-import java.util.Set;
-
-@Subcomponent(modules = RepeatedModule.class)
-interface ChildComponent {
-  String getString();
-  Set<String> getMultiboundStrings();
-  OnlyUsedInChild getOnlyUsedInChild();
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/ParentComponent.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/ParentComponent.java
index 91df02cc3..f0af00237 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/ParentComponent.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/ParentComponent.java
@@ -1,19 +1,39 @@
+/*
+ * Copyright (C) 2015 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package test.subcomponent.repeat;
 
 import dagger.Component;
-
 import java.util.Set;
 
 @Component(modules = RepeatedModule.class)
 interface ParentComponent {
+  Object state();
+
   String getString();
   Set<String> getMultiboundStrings();
   OnlyUsedInParent getOnlyUsedInParent();
 
-  ChildComponent newChildComponent();
+  SubcomponentWithRepeatedModule.Builder newChildComponentBuilder();
+
+  SubcomponentWithoutRepeatedModule newChildComponentWithoutRepeatedModule();
 
   @Component.Builder
   interface Builder {
+    Builder repeatedModule(RepeatedModule repeatedModule);
+
     ParentComponent build();
   }
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/RepeatedModule.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/RepeatedModule.java
index 508a41b56..d0997513d 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/RepeatedModule.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/RepeatedModule.java
@@ -1,25 +1,51 @@
+/*
+ * Copyright (C) 2015 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package test.subcomponent.repeat;
 
-import static dagger.Provides.Type.SET;
-
 import dagger.Module;
 import dagger.Provides;
 
+import static dagger.Provides.Type.SET;
+
 @Module
 final class RepeatedModule {
-  @Provides String provideString() {
+  private final Object state = new Object();
+
+  @Provides
+  Object state() {
+    return state;
+  }
+
+  @Provides
+  static String provideString() {
     return "a string";
   }
 
-  @Provides(type = SET) String contributeString() {
+  @Provides(type = SET)
+  static String contributeString() {
     return "a string in a set";
   }
 
-  @Provides OnlyUsedInParent provideOnlyUsedInParent() {
+  @Provides
+  static OnlyUsedInParent provideOnlyUsedInParent() {
     return new OnlyUsedInParent() {};
   }
 
-  @Provides OnlyUsedInChild provideOnlyUsedInChild() {
+  @Provides
+  static OnlyUsedInChild provideOnlyUsedInChild() {
     return new OnlyUsedInChild() {};
   }
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/SubcomponentWithRepeatedModule.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/SubcomponentWithRepeatedModule.java
new file mode 100644
index 000000000..279bc954c
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/SubcomponentWithRepeatedModule.java
@@ -0,0 +1,37 @@
+/*
+ * Copyright (C) 2015 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.subcomponent.repeat;
+
+import dagger.Subcomponent;
+import java.util.Set;
+
+@Subcomponent(modules = RepeatedModule.class)
+interface SubcomponentWithRepeatedModule {
+  Object state();
+
+  String getString();
+
+  Set<String> getMultiboundStrings();
+
+  OnlyUsedInChild getOnlyUsedInChild();
+
+  @Subcomponent.Builder
+  interface Builder {
+    Builder repeatedModule(RepeatedModule repeatedModule);
+
+    SubcomponentWithRepeatedModule build();
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/SubcomponentWithoutRepeatedModule.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/SubcomponentWithoutRepeatedModule.java
new file mode 100644
index 000000000..e63c9a0ae
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/SubcomponentWithoutRepeatedModule.java
@@ -0,0 +1,23 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.subcomponent.repeat;
+
+import dagger.Subcomponent;
+
+@Subcomponent
+interface SubcomponentWithoutRepeatedModule {
+  SubcomponentWithRepeatedModule.Builder newGrandchildBuilder();
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/tck/CarModule.java b/compiler/src/it/functional-tests/src/main/java/test/tck/CarModule.java
new file mode 100644
index 000000000..bc7851739
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/tck/CarModule.java
@@ -0,0 +1,29 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.tck;
+
+import dagger.Module;
+import dagger.Provides;
+import org.atinject.tck.auto.Car;
+import org.atinject.tck.auto.Convertible;
+
+@Module
+class CarModule {
+  @Provides
+  Car provideConvertible(Convertible convertible) {
+    return convertible;
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/tck/CarShop.java b/compiler/src/it/functional-tests/src/main/java/test/tck/CarShop.java
new file mode 100644
index 000000000..e42532e9d
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/tck/CarShop.java
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.tck;
+
+import dagger.Component;
+import org.atinject.tck.auto.Car;
+import javax.inject.Singleton;
+
+@Singleton
+@Component(
+  modules = {
+    CarModule.class,
+    TireModule.class,
+    SeatModule.class,
+    EngineModule.class,
+    FuelTankModule.class
+  }
+)
+public interface CarShop {
+  @SuppressWarnings("dependency-cycle")
+  Car make();
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/tck/EngineModule.java b/compiler/src/it/functional-tests/src/main/java/test/tck/EngineModule.java
new file mode 100644
index 000000000..577fb5b70
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/tck/EngineModule.java
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.tck;
+
+import dagger.MembersInjector;
+import dagger.Module;
+import dagger.Provides;
+import org.atinject.tck.auto.Engine;
+import org.atinject.tck.auto.V8Engine;
+
+@Module
+public class EngineModule {
+  @Provides
+  Engine provideEngine(MembersInjector<V8Engine> injector) {
+    // This is provided because V8Engine has no @Inject constructor and Dagger requires an @Inject
+    // constructor, however this is a TCK supplied class that we prefer to leave unmodified.
+    V8Engine engine = new V8Engine();
+    injector.injectMembers(engine);
+    return engine;
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/tck/FuelTankModule.java b/compiler/src/it/functional-tests/src/main/java/test/tck/FuelTankModule.java
new file mode 100644
index 000000000..931556cfe
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/tck/FuelTankModule.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.tck;
+
+import dagger.Module;
+import dagger.Provides;
+import org.atinject.tck.auto.FuelTank;
+
+@Module
+class FuelTankModule {
+  @Provides
+  FuelTank provideFuelTank() {
+    return new FuelTank();
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/tck/SeatModule.java b/compiler/src/it/functional-tests/src/main/java/test/tck/SeatModule.java
new file mode 100644
index 000000000..5c6b72988
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/tck/SeatModule.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.tck;
+
+import dagger.Module;
+import dagger.Provides;
+import org.atinject.tck.auto.Drivers;
+import org.atinject.tck.auto.DriversSeat;
+import org.atinject.tck.auto.Seat;
+
+@Module
+class SeatModule {
+  @Provides
+  @Drivers
+  Seat provideSeat(DriversSeat seat) {
+    return seat;
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/tck/TireModule.java b/compiler/src/it/functional-tests/src/main/java/test/tck/TireModule.java
new file mode 100644
index 000000000..914a6d6ec
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/tck/TireModule.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.tck;
+
+import dagger.Module;
+import dagger.Provides;
+import org.atinject.tck.auto.Tire;
+import org.atinject.tck.auto.accessories.SpareTire;
+import javax.inject.Named;
+
+@Module
+class TireModule {
+  @Provides
+  @Named("spare")
+  Tire provideTire(SpareTire sparetire) {
+    return sparetire;
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/test/java/test/MultibindingTest.java b/compiler/src/it/functional-tests/src/test/java/test/MultibindingTest.java
index 66a429be1..1b7e30233 100644
--- a/compiler/src/it/functional-tests/src/test/java/test/MultibindingTest.java
+++ b/compiler/src/it/functional-tests/src/test/java/test/MultibindingTest.java
@@ -15,6 +15,8 @@
 
 import com.google.auto.value.AutoAnnotation;
 import com.google.common.collect.ImmutableMap;
+import dagger.mapkeys.ClassKey;
+import dagger.mapkeys.StringKey;
 import java.math.BigDecimal;
 import java.math.BigInteger;
 import java.util.Map;
@@ -47,6 +49,15 @@
     assertThat(map).containsEntry("bar", "bar value");
   }
 
+  @Test public void mapOfArrays() {
+    Map<String, String[]> map = multibindingComponent.mapOfArrays();
+    assertThat(map).hasSize(2);
+    assertThat(map).containsKey("foo");
+    assertThat(map.get("foo")).asList().containsExactly("foo1", "foo2").inOrder();
+    assertThat(map).containsKey("bar");
+    assertThat(map.get("bar")).asList().containsExactly("bar1", "bar2").inOrder();
+  }
+
   @Test public void mapOfProviders() {
     Map<String, Provider<String>> mapOfProviders = multibindingComponent.mapOfProviders();
     assertThat(mapOfProviders).hasSize(2);
@@ -80,7 +91,7 @@ public void wrappedAnnotationKeyMap() {
         .isEqualTo(
             ImmutableMap.of(
                 testWrappedAnnotationKey(
-                    testStringKey("foo"), new int[] {1, 2, 3}, new TestClassKey[] {}, classes),
+                    testStringKey("foo"), new int[] {1, 2, 3}, new ClassKey[] {}, classes),
                 "wrapped foo annotation"));
   }
 
@@ -140,22 +151,23 @@ public void shortKeyMap() {
     assertThat(multibindingComponent.set()).containsExactly(-90, -17, -1, 5, 6, 832, 1742);
   }
 
+  @Test public void complexQualifierSet() {
+    assertThat(multibindingComponent.complexQualifierStringSet()).containsExactly("foo");
+  }
+
   @AutoAnnotation
-  static TestStringKey testStringKey(String value) {
+  static StringKey testStringKey(String value) {
     return new AutoAnnotation_MultibindingTest_testStringKey(value);
   }
 
   @AutoAnnotation
-  static TestStringKey.NestedWrappedKey nestedWrappedKey(Class<?> value) {
+  static NestedAnnotationContainer.NestedWrappedKey nestedWrappedKey(Class<?> value) {
     return new AutoAnnotation_MultibindingTest_nestedWrappedKey(value);
   }
 
   @AutoAnnotation
-  static TestWrappedAnnotationKey testWrappedAnnotationKey(
-      TestStringKey value,
-      int[] integers,
-      TestClassKey[] annotations,
-      Class<? extends Number>[] classes) {
+  static WrappedAnnotationKey testWrappedAnnotationKey(
+      StringKey value, int[] integers, ClassKey[] annotations, Class<? extends Number>[] classes) {
     return new AutoAnnotation_MultibindingTest_testWrappedAnnotationKey(
         value, integers, annotations, classes);
   }
diff --git a/compiler/src/it/functional-tests/src/test/java/test/builder/BuilderTest.java b/compiler/src/it/functional-tests/src/test/java/test/builder/BuilderTest.java
index ba590d2d9..46f5388ec 100644
--- a/compiler/src/it/functional-tests/src/test/java/test/builder/BuilderTest.java
+++ b/compiler/src/it/functional-tests/src/test/java/test/builder/BuilderTest.java
@@ -163,7 +163,7 @@
     assertThat(child2.l()).isEqualTo(6L);
     assertThat(child2.b()).isEqualTo((byte)70);
   }
-  
+    
   @Test
   public void grandchildren() {
     ParentComponent parent = DaggerParentComponent.create();
@@ -222,4 +222,45 @@ public void genericSubcomponentMethod() {
     assertThat(child.i()).isEqualTo(21);
   }
   
+  @Test
+  public void requireSubcomponentBuilderProviders() {
+    ParentComponent parent = DaggerParentComponent.create();
+    MiddleChild middle =
+        parent
+            .requiresMiddleChildBuilder()
+            .subcomponentBuilderProvider()
+            .get()
+            .set(new StringModule("sam"))
+            .build();
+    Grandchild grandchild =
+        middle
+            .requiresGrandchildBuilder()
+            .subcomponentBuilderProvider()
+            .get()
+            .set(new IntModuleIncludingDoubleAndFloat(12))
+            .build();
+    assertThat(middle.s()).isEqualTo("sam");
+    assertThat(grandchild.i()).isEqualTo(12);
+    assertThat(grandchild.s()).isEqualTo("sam");
+  }
+  
+  @Test
+  public void requireSubcomponentBuilders() {
+    ParentComponent parent = DaggerParentComponent.create();
+    MiddleChild middle =
+        parent
+            .requiresMiddleChildBuilder()
+            .subcomponentBuilder()
+            .set(new StringModule("sam"))
+            .build();
+    Grandchild grandchild =
+        middle
+            .requiresGrandchildBuilder()
+            .subcomponentBuilder()
+            .set(new IntModuleIncludingDoubleAndFloat(12))
+            .build();
+    assertThat(middle.s()).isEqualTo("sam");
+    assertThat(grandchild.i()).isEqualTo(12);
+    assertThat(grandchild.s()).isEqualTo("sam");
+  }
 }
diff --git a/compiler/src/it/functional-tests/src/test/java/test/cycle/CycleTest.java b/compiler/src/it/functional-tests/src/test/java/test/cycle/CycleTest.java
new file mode 100644
index 000000000..d3bc2cbad
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/test/java/test/cycle/CycleTest.java
@@ -0,0 +1,91 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.cycle;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import test.cycle.Cycles.A;
+import test.cycle.Cycles.C;
+import test.cycle.Cycles.ChildCycleComponent;
+import test.cycle.Cycles.CycleComponent;
+import test.cycle.Cycles.CycleMapComponent;
+import test.cycle.Cycles.S;
+import test.cycle.Cycles.SelfCycleComponent;
+
+import static com.google.common.truth.Truth.assertThat;
+
+@RunWith(JUnit4.class)
+public class CycleTest {
+  @Test
+  public void providerIndirectionSelfCycle() {
+    SelfCycleComponent selfCycleComponent = DaggerCycles_SelfCycleComponent.create();
+    S s = selfCycleComponent.s();
+    assertThat(s.sProvider.get()).isNotNull();
+  }
+
+  @Test
+  public void providerIndirectionCycle() {
+    CycleComponent cycleComponent = DaggerCycles_CycleComponent.create();
+    A a = cycleComponent.a();
+    C c = cycleComponent.c();
+    assertThat(c.aProvider.get()).isNotNull();
+    assertThat(a.b.c.aProvider.get()).isNotNull();
+    assertThat(a.e.d.b.c.aProvider.get()).isNotNull();
+  }
+
+  @Test
+  public void lazyIndirectionSelfCycle() {
+    SelfCycleComponent selfCycleComponent = DaggerCycles_SelfCycleComponent.create();
+    S s = selfCycleComponent.s();
+    assertThat(s.sLazy.get()).isNotNull();
+  }
+
+  @Test
+  public void lazyIndirectionCycle() {
+    CycleComponent cycleComponent = DaggerCycles_CycleComponent.create();
+    A a = cycleComponent.a();
+    C c = cycleComponent.c();
+    assertThat(c.aLazy.get()).isNotNull();
+    assertThat(a.b.c.aLazy.get()).isNotNull();
+    assertThat(a.e.d.b.c.aLazy.get()).isNotNull();
+  }
+  
+  @Test
+  public void subcomponentIndirectionCycle() {
+    ChildCycleComponent childCycleComponent = DaggerCycles_CycleComponent.create().child();
+    A a = childCycleComponent.a();
+    assertThat(a.b.c.aProvider.get()).isNotNull();
+    assertThat(a.e.d.b.c.aProvider.get()).isNotNull();
+  }
+  
+  @Test
+  public void providerMapIndirectionCycle() {
+    CycleMapComponent cycleMapComponent = DaggerCycles_CycleMapComponent.create();
+    assertThat(cycleMapComponent.y()).isNotNull();
+    assertThat(cycleMapComponent.y().mapOfProvidersOfX).containsKey("X");
+    assertThat(cycleMapComponent.y().mapOfProvidersOfX.get("X")).isNotNull();
+    assertThat(cycleMapComponent.y().mapOfProvidersOfX.get("X").get()).isNotNull();
+    assertThat(cycleMapComponent.y().mapOfProvidersOfX.get("X").get().y).isNotNull();
+    assertThat(cycleMapComponent.y().mapOfProvidersOfX).hasSize(1);
+    assertThat(cycleMapComponent.y().mapOfProvidersOfY).containsKey("Y");
+    assertThat(cycleMapComponent.y().mapOfProvidersOfY.get("Y")).isNotNull();
+    assertThat(cycleMapComponent.y().mapOfProvidersOfY.get("Y").get()).isNotNull();
+    assertThat(cycleMapComponent.y().mapOfProvidersOfY.get("Y").get().mapOfProvidersOfX).hasSize(1);
+    assertThat(cycleMapComponent.y().mapOfProvidersOfY.get("Y").get().mapOfProvidersOfY).hasSize(1);
+    assertThat(cycleMapComponent.y().mapOfProvidersOfY).hasSize(1);
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/test/java/test/cycle/LongCycleTest.java b/compiler/src/it/functional-tests/src/test/java/test/cycle/LongCycleTest.java
new file mode 100644
index 000000000..e50eaee69
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/test/java/test/cycle/LongCycleTest.java
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.cycle;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import test.cycle.LongCycle.LongCycleComponent;
+
+import static com.google.common.truth.Truth.assertThat;
+
+@RunWith(JUnit4.class)
+public class LongCycleTest {
+  
+  /**
+   * Tests a cycle long enough that the real factory is created in a separate initialize method from
+   * the delegate factory.
+   */
+  @Test
+  public void longCycle() {
+    LongCycleComponent longCycleComponent = DaggerLongCycle_LongCycleComponent.create();
+    assertThat(longCycleComponent.class1()).isNotNull();
+  }
+
+  /**
+   * Fails if {@link LongCycleComponent} doesn't have a long enough cycle to make sure the real
+   * factory is created in a separate method from the delegate factory.
+   */
+  @Test
+  public void longCycleHasMoreThanOneInitializeMethod() throws NoSuchMethodException {
+    DaggerLongCycle_LongCycleComponent.class
+        .getDeclaredMethod("initialize1", DaggerLongCycle_LongCycleComponent.Builder.class);
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/test/java/test/membersinject/MembersInjectTest.java b/compiler/src/it/functional-tests/src/test/java/test/membersinject/MembersInjectTest.java
index 1b382d8f7..411ecb177 100644
--- a/compiler/src/it/functional-tests/src/test/java/test/membersinject/MembersInjectTest.java
+++ b/compiler/src/it/functional-tests/src/test/java/test/membersinject/MembersInjectTest.java
@@ -1,36 +1,45 @@
 /*
-* Copyright (C) 2015 Google, Inc.
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
-*
-* http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS,
-* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-* See the License for the specific language governing permissions and
-* limitations under the License.
-*/
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package test.membersinject;
 
+import dagger.MembersInjector;
+import javax.inject.Provider;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
+import test.multipackage.DaggerMembersInjectionVisibilityComponent;
+import test.multipackage.MembersInjectionVisibilityComponent;
+import test.multipackage.a.AGrandchild;
+import test.multipackage.a.AParent;
+import test.multipackage.b.BChild;
+
+import static com.google.common.truth.Truth.assertThat;
 
 @RunWith(JUnit4.class)
 public class MembersInjectTest {
   @Test public void testMembersInject_arrays() {
     MembersInjectComponent component = DaggerMembersInjectComponent.builder().build();
-    
+
     ChildOfStringArray childOfStringArray = new ChildOfStringArray();
     component.inject(childOfStringArray);
   }
 
   @Test public void testMembersInject_nestedArrays() {
     MembersInjectComponent component = DaggerMembersInjectComponent.builder().build();
-    
+
     ChildOfArrayOfParentOfStringArray childOfArrayOfParentOfStringArray =
         new ChildOfArrayOfParentOfStringArray();
     component.inject(childOfArrayOfParentOfStringArray);
@@ -38,8 +47,49 @@
 
   @Test public void testMembersInject_primitives() {
     MembersInjectComponent component = DaggerMembersInjectComponent.builder().build();
-    
+
     ChildOfPrimitiveIntArray childOfPrimitiveIntArray = new ChildOfPrimitiveIntArray();
     component.inject(childOfPrimitiveIntArray);
   }
+
+  @Test
+  public void testMembersInject_overrides() {
+    MembersInjectionVisibilityComponent component =
+        DaggerMembersInjectionVisibilityComponent.create();
+    AParent aParent = new AParent();
+    component.inject(aParent);
+    assertThat(aParent.aParentField()).isNotNull();
+    assertThat(aParent.aParentMethod()).isNotNull();
+
+    BChild aChild = new BChild();
+    component.inject(aChild);
+    assertThat(aChild.aParentField()).isNotNull();
+    assertThat(aChild.aParentMethod()).isNull();
+    assertThat(aChild.aChildField()).isNotNull();
+    assertThat(aChild.aChildMethod()).isNotNull();
+
+    AGrandchild aGrandchild = new AGrandchild();
+    component.inject(aGrandchild);
+    assertThat(aGrandchild.aParentField()).isNotNull();
+    assertThat(aGrandchild.aParentMethod()).isNotNull();
+    assertThat(aGrandchild.aChildField()).isNotNull();
+    assertThat(aGrandchild.aChildMethod()).isNull();
+    assertThat(aGrandchild.aGrandchildField()).isNotNull();
+    assertThat(aGrandchild.aGrandchildMethod()).isNotNull();
+  }
+
+  @Test
+  public void testNonRequestedMembersInjector() {
+    NonRequestedChild child = new NonRequestedChild();
+    Provider<String> provider =
+        new Provider<String>() {
+          @Override
+          public String get() {
+            return "field!";
+          }
+        };
+    MembersInjector<NonRequestedChild> injector = new NonRequestedChild_MembersInjector(provider);
+    injector.injectMembers(child);
+    assertThat(child.t).isEqualTo("field!");
+  }
 }
diff --git a/compiler/src/it/functional-tests/src/test/java/test/staticprovides/StaticProvidesTest.java b/compiler/src/it/functional-tests/src/test/java/test/staticprovides/StaticProvidesTest.java
index 53185f8fc..397259403 100644
--- a/compiler/src/it/functional-tests/src/test/java/test/staticprovides/StaticProvidesTest.java
+++ b/compiler/src/it/functional-tests/src/test/java/test/staticprovides/StaticProvidesTest.java
@@ -15,17 +15,35 @@
  */
 package test.staticprovides;
 
-import static com.google.common.truth.Truth.assertThat;
-
 import com.google.common.collect.ImmutableSet;
-
+import java.lang.reflect.Field;
+import java.lang.reflect.Method;
+import java.util.Arrays;
+import java.util.Collection;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
+import org.junit.runners.Parameterized;
+import org.junit.runners.Parameterized.Parameter;
+import org.junit.runners.Parameterized.Parameters;
 
-@RunWith(JUnit4.class)
+import static com.google.common.truth.Truth.assertThat;
+import static com.google.common.truth.Truth.assertWithMessage;
+
+@RunWith(Parameterized.class)
 public class StaticProvidesTest {
-  private final StaticTestComponent component = DaggerStaticTestComponent.create();
+  @Parameters
+  public static Collection<Object[]> components() {
+    return Arrays.asList(new Object[][] {
+        {DaggerStaticTestComponent.create()},
+        {DaggerStaticTestComponentWithBuilder.builder().build()},
+        {DaggerStaticTestComponentWithBuilder.builder()
+          .allStaticModule(new AllStaticModule())
+          .someStaticModule(new SomeStaticModule())
+          .build()}});
+  }
+
+  @Parameter
+  public StaticTestComponent component;
 
   @Test public void setMultibinding() {
     assertThat(component.getMultiboundStrings()).isEqualTo(ImmutableSet.of(
@@ -33,4 +51,21 @@
         SomeStaticModule.class + ".contributeStringFromAStaticMethod",
         SomeStaticModule.class + ".contributeStringFromAnInstanceMethod"));
   }
+
+  @Test public void allStaticProvidesModules_noFieldInComponentBuilder() {
+    for (Field field : DaggerStaticTestComponent.Builder.class.getDeclaredFields()) {
+      assertWithMessage(field.getName())
+          .that(field.getType()).isNotEqualTo(AllStaticModule.class);
+    }
+  }
+
+  @Test public void allStaticProvidesModules_deprecatedMethodInComponentBuilder() {
+    for (Method method : DaggerStaticTestComponent.Builder.class.getDeclaredMethods()) {
+      if (Arrays.asList(method.getParameterTypes()).contains(AllStaticModule.class)) {
+        assertWithMessage(method.getName())
+            .that(method.isAnnotationPresent(Deprecated.class))
+            .isTrue();
+      }
+    }
+  }
 }
diff --git a/compiler/src/it/functional-tests/src/test/java/test/subcomponent/SubcomponentMultibindingsTest.java b/compiler/src/it/functional-tests/src/test/java/test/subcomponent/SubcomponentMultibindingsTest.java
new file mode 100644
index 000000000..f57a77831
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/test/java/test/subcomponent/SubcomponentMultibindingsTest.java
@@ -0,0 +1,89 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.subcomponent;
+
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableMap;
+import java.util.Collection;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+import org.junit.runners.Parameterized.Parameters;
+
+import static com.google.common.collect.Iterables.getOnlyElement;
+import static com.google.common.truth.Truth.assertWithMessage;
+
+@RunWith(Parameterized.class)
+public class SubcomponentMultibindingsTest {
+
+  @Parameters(name = "{0}")
+  public static Collection<Object[]> parameters() {
+    return ImmutableList.of(
+        new Object[] {DaggerParentComponentWithMultibindings.create()},
+        new Object[] {DaggerParentComponentWithoutMultibindings.create()});
+  }
+
+  private ParentComponentWithoutMultibindings parent;
+
+  public SubcomponentMultibindingsTest(ParentComponentWithoutMultibindings parentComponent) {
+    this.parent = parentComponent;
+  }
+
+  @Test
+  public void testMultibindingsInSubcomponents() {
+    RequiresMultibindingsInChild requiresMultibindingsInChild =
+        parent.childComponent().requiresMultibindingsInChild();
+
+    assertWithMessage("requiresMultiboundObjects.setOfObjects")
+        .that(requiresMultibindingsInChild.requiresMultiboundObjects().setOfObjects())
+        .containsExactly("object provided by parent", "object provided by child");
+
+    assertWithMessage("requiresMultiboundObjects.mapOfObjects")
+        .that(requiresMultibindingsInChild.requiresMultiboundObjects().mapOfObjects())
+        .isEqualTo(
+            ImmutableMap.of("parent key", "object in parent", "child key", "object in child"));
+
+    assertWithMessage("requiresMultiboundStrings")
+        .that(requiresMultibindingsInChild.requiresMultiboundStrings().setOfStrings())
+        .containsExactly("string provided by parent");
+
+    assertWithMessage("requiresMultiboundStrings.mapOfStrings")
+        .that(requiresMultibindingsInChild.requiresMultiboundStrings().mapOfStrings())
+        .isEqualTo(ImmutableMap.of("parent key", "string in parent"));
+  }
+
+  @Test
+  public void testOverriddenMultibindingsInSubcomponents() {
+    RequiresMultibindingsInChild requiresMultibindingsInChild =
+        parent.childComponent().requiresMultibindingsInChild();
+
+    assertWithMessage("setOfRequiresMultiboundObjects")
+        .that(requiresMultibindingsInChild.setOfRequiresMultiboundObjects())
+        .hasSize(1);
+
+    RequiresMultiboundObjects onlyElementInMultiboundRequiresMultiboundObjects =
+        getOnlyElement(requiresMultibindingsInChild.setOfRequiresMultiboundObjects());
+
+    assertWithMessage("setOfRequiresMultiboundObjects[only].setOfObjects")
+        .that(onlyElementInMultiboundRequiresMultiboundObjects.setOfObjects())
+        .containsExactly("object provided by parent", "object provided by child");
+
+    assertWithMessage("setOfRequiresMultiboundObjects[only].mapOfObjects")
+        .that(onlyElementInMultiboundRequiresMultiboundObjects.mapOfObjects())
+        .isEqualTo(
+            ImmutableMap.of("parent key", "object in parent", "child key", "object in child"));
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/test/java/test/subcomponent/repeat/RepeatedModuleTest.java b/compiler/src/it/functional-tests/src/test/java/test/subcomponent/repeat/RepeatedModuleTest.java
new file mode 100644
index 000000000..7e92371bf
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/test/java/test/subcomponent/repeat/RepeatedModuleTest.java
@@ -0,0 +1,82 @@
+/*
+ * Copyright (C) 2015 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.subcomponent.repeat;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+
+@RunWith(JUnit4.class)
+public final class RepeatedModuleTest {
+  private ParentComponent parentComponent;
+
+  @Before
+  public void initializeParentComponent() {
+    this.parentComponent = DaggerParentComponent.builder().build();
+  }
+
+  @Test
+  public void repeatedModuleHasSameStateInSubcomponent() {
+    SubcomponentWithRepeatedModule childComponent =
+        parentComponent.newChildComponentBuilder().build();
+    assertThat(parentComponent.state()).isSameAs(childComponent.state());
+  }
+
+  @Test
+  public void repeatedModuleHasSameStateInGrandchildSubcomponent() {
+    SubcomponentWithoutRepeatedModule childComponent =
+        parentComponent.newChildComponentWithoutRepeatedModule();
+    SubcomponentWithRepeatedModule grandchildComponent =
+        childComponent.newGrandchildBuilder().build();
+    assertThat(parentComponent.state()).isSameAs(grandchildComponent.state());
+  }
+
+  @Test
+  public void repeatedModuleBuilderThrowsInSubcomponent() {
+    SubcomponentWithRepeatedModule.Builder childComponentBuilder =
+        parentComponent.newChildComponentBuilder();
+    try {
+      childComponentBuilder.repeatedModule(new RepeatedModule());
+      fail();
+    } catch (UnsupportedOperationException expected) {
+      assertThat(expected)
+          .hasMessage(
+              "test.subcomponent.repeat.RepeatedModule cannot be set "
+                  + "because it is inherited from the enclosing component");
+    }
+  }
+
+  @Test
+  public void repeatedModuleBuilderThrowsInGrandchildSubcomponent() {
+    SubcomponentWithoutRepeatedModule childComponent =
+        parentComponent.newChildComponentWithoutRepeatedModule();
+    SubcomponentWithRepeatedModule.Builder grandchildComponentBuilder =
+        childComponent.newGrandchildBuilder();
+    try {
+      grandchildComponentBuilder.repeatedModule(new RepeatedModule());
+      fail();
+    } catch (UnsupportedOperationException expected) {
+      assertThat(expected)
+          .hasMessage(
+              "test.subcomponent.repeat.RepeatedModule cannot be set "
+                  + "because it is inherited from the enclosing component");
+    }
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/test/java/test/tck/TckTest.java b/compiler/src/it/functional-tests/src/test/java/test/tck/TckTest.java
new file mode 100644
index 000000000..d79b06b6a
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/test/java/test/tck/TckTest.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.tck;
+
+import junit.framework.Test;
+import org.atinject.tck.Tck;
+import org.atinject.tck.auto.Car;
+import org.atinject.tck.auto.Convertible;
+
+/** 
+ * Test suite to execute the JSR-330 TCK in JUnit.
+ */
+public class TckTest {
+  public static Test suite() {
+    CarShop carShopComponent = DaggerCarShop.create();
+    Car car = carShopComponent.make();
+    Convertible.localConvertible.set((Convertible) car);
+    return Tck.testsFor(car, false, false);
+  }
+}
diff --git a/compiler/src/it/producers-functional-tests/pom.xml b/compiler/src/it/producers-functional-tests/pom.xml
index 206a7e2d8..a0d16498a 100644
--- a/compiler/src/it/producers-functional-tests/pom.xml
+++ b/compiler/src/it/producers-functional-tests/pom.xml
@@ -28,6 +28,10 @@ limitations under the License.
   <artifactId>producers-functional-tests</artifactId>
   <name>Producers Functional Tests</name>
   <dependencies>
+    <dependency>
+      <groupId>com.google.guava</groupId>
+      <artifactId>guava</artifactId>
+    </dependency>
     <dependency>
       <groupId>com.google.dagger</groupId>
       <artifactId>dagger</artifactId>
@@ -56,8 +60,9 @@ limitations under the License.
       <scope>test</scope>
     </dependency>
     <dependency>
-      <groupId>com.google.guava</groupId>
-      <artifactId>guava</artifactId>
+      <groupId>org.mockito</groupId>
+      <artifactId>mockito-core</artifactId>
+      <scope>test</scope>
     </dependency>
   </dependencies>
   <build>
@@ -66,8 +71,8 @@ limitations under the License.
         <artifactId>maven-compiler-plugin</artifactId>
         <version>3.1</version>
         <configuration>
-          <source>1.6</source>
-          <target>1.6</target>
+          <source>1.7</source>
+          <target>1.7</target>
         </configuration>
       </plugin>
       <plugin>
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/test/DependedComponent.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/DependedComponent.java
similarity index 97%
rename from compiler/src/it/producers-functional-tests/src/main/java/test/DependedComponent.java
rename to compiler/src/it/producers-functional-tests/src/main/java/producerstest/DependedComponent.java
index fa392dd8e..a80ea4968 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/test/DependedComponent.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/DependedComponent.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package test;
+package producerstest;
 
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.Component;
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/test/DependedModule.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/DependedModule.java
similarity index 97%
rename from compiler/src/it/producers-functional-tests/src/main/java/test/DependedModule.java
rename to compiler/src/it/producers-functional-tests/src/main/java/producerstest/DependedModule.java
index 604107025..dc62612cd 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/test/DependedModule.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/DependedModule.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package test;
+package producerstest;
 
 import dagger.Module;
 import dagger.Provides;
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/test/DependedProducerModule.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/DependedProducerModule.java
similarity index 97%
rename from compiler/src/it/producers-functional-tests/src/main/java/test/DependedProducerModule.java
rename to compiler/src/it/producers-functional-tests/src/main/java/producerstest/DependedProducerModule.java
index ad0c792a9..fe47c9973 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/test/DependedProducerModule.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/DependedProducerModule.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package test;
+package producerstest;
 
 import com.google.common.base.Ascii;
 import com.google.common.collect.ImmutableList;
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/test/DependedProductionComponent.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/DependedProductionComponent.java
similarity index 97%
rename from compiler/src/it/producers-functional-tests/src/main/java/test/DependedProductionComponent.java
rename to compiler/src/it/producers-functional-tests/src/main/java/producerstest/DependedProductionComponent.java
index 57f175812..ba98e3698 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/test/DependedProductionComponent.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/DependedProductionComponent.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package test;
+package producerstest;
 
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.producers.ProductionComponent;
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/test/DependentComponent.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/DependentComponent.java
similarity index 97%
rename from compiler/src/it/producers-functional-tests/src/main/java/test/DependentComponent.java
rename to compiler/src/it/producers-functional-tests/src/main/java/producerstest/DependentComponent.java
index 4b14f99b5..85709f0f3 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/test/DependentComponent.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/DependentComponent.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package test;
+package producerstest;
 
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.producers.ProductionComponent;
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/test/DependentProducerModule.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/DependentProducerModule.java
similarity index 98%
rename from compiler/src/it/producers-functional-tests/src/main/java/test/DependentProducerModule.java
rename to compiler/src/it/producers-functional-tests/src/main/java/producerstest/DependentProducerModule.java
index 234c088d3..e16c82212 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/test/DependentProducerModule.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/DependentProducerModule.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package test;
+package producerstest;
 
 import com.google.common.base.Ascii;
 import com.google.common.collect.ImmutableList;
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/test/MultibindingComponent.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/MultibindingComponent.java
similarity index 76%
rename from compiler/src/it/producers-functional-tests/src/main/java/test/MultibindingComponent.java
rename to compiler/src/it/producers-functional-tests/src/main/java/producerstest/MultibindingComponent.java
index 561ad4a89..6277e621a 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/test/MultibindingComponent.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/MultibindingComponent.java
@@ -13,14 +13,21 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package test;
+package producerstest;
 
 import com.google.common.util.concurrent.ListenableFuture;
+import dagger.producers.Produced;
 import dagger.producers.ProductionComponent;
 import java.util.Set;
+import producerstest.MultibindingProducerModule.PossiblyThrowingSet;
 
 @ProductionComponent(modules = MultibindingProducerModule.class)
 interface MultibindingComponent {
   ListenableFuture<Set<String>> strs();
   ListenableFuture<Integer> strCount();
+
+  ListenableFuture<Set<Produced<String>>> successfulSet();
+
+  @PossiblyThrowingSet
+  ListenableFuture<Set<Produced<String>>> possiblyThrowingSet();
 }
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/test/MultibindingProducerModule.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/MultibindingProducerModule.java
similarity index 59%
rename from compiler/src/it/producers-functional-tests/src/main/java/test/MultibindingProducerModule.java
rename to compiler/src/it/producers-functional-tests/src/main/java/producerstest/MultibindingProducerModule.java
index 4651afcc6..09cd5bdbc 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/test/MultibindingProducerModule.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/MultibindingProducerModule.java
@@ -13,7 +13,7 @@
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
-package test;
+package producerstest;
 
 import com.google.common.collect.ImmutableSet;
 import com.google.common.util.concurrent.Futures;
@@ -21,29 +21,56 @@
 import dagger.producers.ProducerModule;
 import dagger.producers.Produces;
 import java.util.Set;
+import javax.inject.Qualifier;
 
 import static dagger.producers.Produces.Type.SET;
 import static dagger.producers.Produces.Type.SET_VALUES;
 
 @ProducerModule
 final class MultibindingProducerModule {
-  @Produces(type = SET) ListenableFuture<String> futureStr() {
+  @Qualifier
+  @interface PossiblyThrowingSet {}
+
+  @Produces(type = SET)
+  static ListenableFuture<String> futureStr() {
     return Futures.immediateFuture("foo");
   }
 
-  @Produces(type = SET) String str() {
+  @Produces(type = SET)
+  static String str() {
     return "bar";
   }
 
-  @Produces(type = SET_VALUES) ListenableFuture<Set<String>> futureStrs() {
+  @Produces(type = SET_VALUES)
+  static ListenableFuture<Set<String>> futureStrs() {
     return Futures.<Set<String>>immediateFuture(ImmutableSet.of("foo1", "foo2"));
   }
 
-  @Produces(type = SET_VALUES) Set<String> strs() {
+  @Produces(type = SET_VALUES)
+  static Set<String> strs() {
     return ImmutableSet.of("bar1", "bar2");
   }
 
-  @Produces int strCount(Set<String> strs) {
+  @Produces
+  static int strCount(Set<String> strs) {
     return strs.size();
   }
+
+  @Produces(type = SET)
+  @PossiblyThrowingSet
+  static String successfulStringForSet() {
+    return "singleton";
+  }
+
+  @Produces(type = SET_VALUES)
+  @PossiblyThrowingSet
+  static Set<String> successfulStringsForSet() {
+    return ImmutableSet.of("double", "ton");
+  }
+
+  @Produces(type = SET)
+  @PossiblyThrowingSet
+  static String throwingStringForSet() {
+    throw new RuntimeException("monkey");
+  }
 }
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/test/Request.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/Request.java
similarity index 97%
rename from compiler/src/it/producers-functional-tests/src/main/java/test/Request.java
rename to compiler/src/it/producers-functional-tests/src/main/java/producerstest/Request.java
index 039d0fe55..0227be6bd 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/test/Request.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/Request.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package test;
+package producerstest;
 
 import javax.inject.Inject;
 
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/test/Response.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/Response.java
similarity index 97%
rename from compiler/src/it/producers-functional-tests/src/main/java/test/Response.java
rename to compiler/src/it/producers-functional-tests/src/main/java/producerstest/Response.java
index 7a46e5b0e..8618ff5e1 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/test/Response.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/Response.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package test;
+package producerstest;
 
 final class Response {
   private final String data;
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/ResponseModule.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/ResponseModule.java
new file mode 100644
index 000000000..1edbe8aa6
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/ResponseModule.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package producerstest;
+
+import dagger.Module;
+import dagger.Provides;
+
+@Module
+final class ResponseModule {
+  @Provides
+  static int requestNumber() {
+    return 5;
+  }
+}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/test/ResponseProducerModule.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/ResponseProducerModule.java
similarity index 73%
rename from compiler/src/it/producers-functional-tests/src/main/java/test/ResponseProducerModule.java
rename to compiler/src/it/producers-functional-tests/src/main/java/producerstest/ResponseProducerModule.java
index bda53eb56..0ef2ae886 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/test/ResponseProducerModule.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/ResponseProducerModule.java
@@ -13,20 +13,22 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package test;
+package producerstest;
 
 import com.google.common.util.concurrent.Futures;
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.producers.ProducerModule;
 import dagger.producers.Produces;
 
-@ProducerModule
+@ProducerModule(includes = ResponseModule.class)
 final class ResponseProducerModule {
-  @Produces ListenableFuture<String> greeting() {
+  @Produces
+  static ListenableFuture<String> greeting() {
     return Futures.immediateFuture("Hello");
   }
 
-  @Produces Response response(String greeting, Request request) {
-    return new Response(greeting + ", " + request.name() + "!");
+  @Produces
+  static Response response(String greeting, Request request, int requestNumber) {
+    return new Response(String.format("%s, %s #%d!", greeting, request.name(), requestNumber));
   }
 }
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/test/SimpleComponent.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/SimpleComponent.java
similarity index 97%
rename from compiler/src/it/producers-functional-tests/src/main/java/test/SimpleComponent.java
rename to compiler/src/it/producers-functional-tests/src/main/java/producerstest/SimpleComponent.java
index 583cd50f0..1d1e49233 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/test/SimpleComponent.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/SimpleComponent.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package test;
+package producerstest;
 
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.producers.ProductionComponent;
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/SimpleProducerModule.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/SimpleProducerModule.java
new file mode 100644
index 000000000..2d831ed7f
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/SimpleProducerModule.java
@@ -0,0 +1,219 @@
+/*
+* Copyright (C) 2015 Google, Inc.
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package producerstest;
+
+import com.google.common.collect.ImmutableSet;
+import com.google.common.util.concurrent.Futures;
+import com.google.common.util.concurrent.ListenableFuture;
+import com.google.common.util.concurrent.SettableFuture;
+import dagger.producers.Produced;
+import dagger.producers.Producer;
+import dagger.producers.ProducerModule;
+import dagger.producers.Produces;
+import java.io.IOException;
+import java.util.Set;
+import javax.inject.Provider;
+import javax.inject.Qualifier;
+
+import static dagger.producers.Produces.Type.SET;
+import static dagger.producers.Produces.Type.SET_VALUES;
+
+/**
+ * A module that contains various signatures of produces methods. This is not used in any
+ * components.
+ */
+@ProducerModule
+final class SimpleProducerModule {
+  @Qualifier @interface Qual {
+    int value();
+  }
+
+  // Unique bindings.
+
+  @Produces
+  @Qual(-2)
+  static ListenableFuture<String> throwingProducer() {
+    throw new RuntimeException("monkey");
+  }
+
+  @Produces
+  @Qual(-1)
+  static ListenableFuture<String> settableFutureStr(SettableFuture<String> future) {
+    return future;
+  }
+
+  @Produces
+  @Qual(0)
+  static String str() {
+    return "str";
+  }
+
+  @Produces
+  @Qual(1)
+  static ListenableFuture<String> futureStr() {
+    return Futures.immediateFuture("future str");
+  }
+
+  @Produces
+  @Qual(2)
+  static String strWithArg(int i) {
+    return "str with arg";
+  }
+
+  @Produces
+  @Qual(3)
+  static ListenableFuture<String> futureStrWithArg(int i) {
+    return Futures.immediateFuture("future str with arg");
+  }
+
+  @Produces
+  @Qual(4)
+  static String strThrowingException() throws IOException {
+    return "str throwing exception";
+  }
+
+  @Produces
+  @Qual(5)
+  static ListenableFuture<String> futureStrThrowingException() throws IOException {
+    return Futures.immediateFuture("future str throwing exception");
+  }
+
+  @Produces
+  @Qual(6)
+  static String strWithArgThrowingException(int i) throws IOException {
+    return "str with arg throwing exception";
+  }
+
+  @Produces
+  @Qual(7)
+  static ListenableFuture<String> futureStrWithArgThrowingException(int i) throws IOException {
+    return Futures.immediateFuture("future str with arg throwing exception");
+  }
+
+  @Produces
+  @Qual(8)
+  static String strWithArgs(int i, Produced<Double> b, Producer<Object> c, Provider<Boolean> d) {
+    return "str with args";
+  }
+
+  @Produces
+  @Qual(9)
+  static String strWithArgsThrowingException(
+      int i, Produced<Double> b, Producer<Object> c, Provider<Boolean> d) throws IOException {
+    return "str with args throwing exception";
+  }
+
+  @Produces
+  @Qual(10)
+  static ListenableFuture<String> futureStrWithArgs(
+      int i, Produced<Double> b, Producer<Object> c, Provider<Boolean> d) {
+    return Futures.immediateFuture("future str with args");
+  }
+
+  @Produces
+  @Qual(11)
+  static ListenableFuture<String> futureStrWithArgsThrowingException(
+      int i, Produced<Double> b, Producer<Object> c, Provider<Boolean> d) throws IOException {
+    return Futures.immediateFuture("str with args throwing exception");
+  }
+
+  // Set bindings.
+
+  @Produces(type = SET)
+  static String setOfStrElement() {
+    return "set of str element";
+  }
+
+  @Produces(type = SET)
+  static String setOfStrElementThrowingException() throws IOException {
+    return "set of str element throwing exception";
+  }
+
+  @Produces(type = SET)
+  static ListenableFuture<String> setOfStrFutureElement() {
+    return Futures.immediateFuture("set of str element");
+  }
+
+  @Produces(type = SET)
+  static ListenableFuture<String> setOfStrFutureElementThrowingException() throws IOException {
+    return Futures.immediateFuture("set of str element throwing exception");
+  }
+
+  @Produces(type = SET)
+  static String setOfStrElementWithArg(int i) {
+    return "set of str element with arg";
+  }
+
+  @Produces(type = SET)
+  static String setOfStrElementWithArgThrowingException(int i) throws IOException {
+    return "set of str element with arg throwing exception";
+  }
+
+  @Produces(type = SET)
+  static ListenableFuture<String> setOfStrFutureElementWithArg(int i) {
+    return Futures.immediateFuture("set of str element with arg");
+  }
+
+  @Produces(type = SET)
+  static ListenableFuture<String> setOfStrFutureElementWithArgThrowingException(int i)
+      throws IOException {
+    return Futures.immediateFuture("set of str element with arg throwing exception");
+  }
+
+  @Produces(type = SET_VALUES)
+  static Set<String> setOfStrValues() {
+    return ImmutableSet.of("set of str 1", "set of str 2");
+  }
+
+  @Produces(type = SET_VALUES)
+  static Set<String> setOfStrValuesThrowingException() throws IOException {
+    return ImmutableSet.of("set of str 1", "set of str 2 throwing exception");
+  }
+
+  @Produces(type = SET_VALUES)
+  static ListenableFuture<Set<String>> setOfStrFutureValues() {
+    return Futures.<Set<String>>immediateFuture(ImmutableSet.of("set of str 1", "set of str 2"));
+  }
+
+  @Produces(type = SET_VALUES)
+  static ListenableFuture<Set<String>> setOfStrFutureValuesThrowingException() throws IOException {
+    return Futures.<Set<String>>immediateFuture(
+        ImmutableSet.of("set of str 1", "set of str 2 throwing exception"));
+  }
+
+  @Produces(type = SET_VALUES)
+  static Set<String> setOfStrValuesWithArg(int i) {
+    return ImmutableSet.of("set of str with arg 1", "set of str with arg 2");
+  }
+
+  @Produces(type = SET_VALUES)
+  static Set<String> setOfStrValuesWithArgThrowingException(int i) throws IOException {
+    return ImmutableSet.of("set of str with arg 1", "set of str with arg 2 throwing exception");
+  }
+
+  @Produces(type = SET_VALUES)
+  static ListenableFuture<Set<String>> setOfStrFutureValuesWithArg(int i) {
+    return Futures.<Set<String>>immediateFuture(
+        ImmutableSet.of("set of str with arg 1", "set of str with arg 2"));
+  }
+
+  @Produces(type = SET_VALUES)
+  static ListenableFuture<Set<String>> setOfStrFutureValuesWithArgThrowingException(int i)
+      throws IOException {
+    return Futures.<Set<String>>immediateFuture(
+        ImmutableSet.of("set of str with arg 1", "set of str with arg 2 throwing exception"));
+  }
+}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/badexecutor/ComponentDependency.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/badexecutor/ComponentDependency.java
new file mode 100644
index 000000000..7bba4ea4e
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/badexecutor/ComponentDependency.java
@@ -0,0 +1,22 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package producerstest.badexecutor;
+
+import com.google.common.util.concurrent.ListenableFuture;
+
+interface ComponentDependency {
+  ListenableFuture<Double> doubleDep();
+}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/badexecutor/SimpleComponent.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/badexecutor/SimpleComponent.java
new file mode 100644
index 000000000..6b3536eae
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/badexecutor/SimpleComponent.java
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package producerstest.badexecutor;
+
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.producers.ProductionComponent;
+
+/**
+ * A component that contains entry points that exercise different execution paths, for verifying the
+ * behavior when the executor throws a {@link java.util.concurrent.RejectedExecutionException}.
+ */
+@ProductionComponent(dependencies = ComponentDependency.class, modules = SimpleProducerModule.class)
+interface SimpleComponent {
+  /** An entry point exposing a producer method with no args. */
+  ListenableFuture<String> noArgStr();
+
+  /** An entry point exposing a producer method that depends on another producer method. */
+  ListenableFuture<Integer> singleArgInt();
+
+  /** An entry point exposing a producer method that depends on a component dependency method. */
+  ListenableFuture<Boolean> singleArgBool();
+
+  /** An entry point exposing a component dependency method. */
+  ListenableFuture<Double> doubleDep();
+}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/badexecutor/SimpleProducerModule.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/badexecutor/SimpleProducerModule.java
new file mode 100644
index 000000000..00ab037bd
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/badexecutor/SimpleProducerModule.java
@@ -0,0 +1,37 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package producerstest.badexecutor;
+
+import dagger.producers.ProducerModule;
+import dagger.producers.Produces;
+
+@ProducerModule
+final class SimpleProducerModule {
+  @Produces
+  static String noArgStr() {
+    return "no arg string";
+  }
+
+  @Produces
+  static int singleArgInt(String arg) {
+    return arg.length();
+  }
+
+  @Produces
+  static boolean singleArgBool(double arg) {
+    return arg > 0.0;
+  }
+}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/builder/DepComponent.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/builder/DepComponent.java
new file mode 100644
index 000000000..dadde7b05
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/builder/DepComponent.java
@@ -0,0 +1,22 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package producerstest.builder;
+
+import com.google.common.util.concurrent.ListenableFuture;
+
+interface DepComponent {
+  ListenableFuture<Double> d();
+}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/builder/IntModule.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/builder/IntModule.java
new file mode 100644
index 000000000..7f99836d3
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/builder/IntModule.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package producerstest.builder;
+
+import dagger.Module;
+import dagger.Provides;
+
+@Module
+final class IntModule {
+  @Provides
+  static int i() {
+    return 42;
+  }
+}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/builder/StringModule.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/builder/StringModule.java
new file mode 100644
index 000000000..cdf0793da
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/builder/StringModule.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package producerstest.builder;
+
+import dagger.producers.ProducerModule;
+import dagger.producers.Produces;
+
+@ProducerModule
+final class StringModule {
+  @Produces
+  static String str(int i) {
+    return "arg: " + i;
+  }
+}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/builder/TestComponentWithBuilder.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/builder/TestComponentWithBuilder.java
new file mode 100644
index 000000000..16dc9bad7
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/builder/TestComponentWithBuilder.java
@@ -0,0 +1,37 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package producerstest.builder;
+
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.producers.ProductionComponent;
+import java.util.concurrent.Executor;
+
+@ProductionComponent(
+  modules = {StringModule.class, IntModule.class},
+  dependencies = DepComponent.class
+)
+interface TestComponentWithBuilder {
+  ListenableFuture<String> s();
+  ListenableFuture<Double> d();
+
+  @ProductionComponent.Builder
+  interface Builder {
+    Builder depComponent(DepComponent depComponent);
+    Builder strModule(StringModule strModule);
+    Builder executor(Executor executor);
+    TestComponentWithBuilder build();
+  }
+}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/MonitoredComponent.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/MonitoredComponent.java
new file mode 100644
index 000000000..48acbabac
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/MonitoredComponent.java
@@ -0,0 +1,24 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package producerstest.monitoring;
+
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.producers.ProductionComponent;
+
+@ProductionComponent(modules = {MonitoringModule.class, StubModule.class, ServingModule.class})
+interface MonitoredComponent {
+  ListenableFuture<String> output();
+}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/MonitoringModule.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/MonitoringModule.java
new file mode 100644
index 000000000..0c4209076
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/MonitoringModule.java
@@ -0,0 +1,36 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package producerstest.monitoring;
+
+import dagger.Module;
+import dagger.Provides;
+import dagger.producers.monitoring.ProductionComponentMonitor;
+
+import static dagger.Provides.Type.SET;
+
+@Module
+final class MonitoringModule {
+  private final ProductionComponentMonitor.Factory monitorFactory;
+
+  MonitoringModule(ProductionComponentMonitor.Factory monitorFactory) {
+    this.monitorFactory = monitorFactory;
+  }
+
+  @Provides(type = SET)
+  ProductionComponentMonitor.Factory monitorFactory() {
+    return monitorFactory;
+  }
+}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/ServingModule.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/ServingModule.java
new file mode 100644
index 000000000..d5bec22ce
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/ServingModule.java
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package producerstest.monitoring;
+
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.producers.ProducerModule;
+import dagger.producers.Produces;
+import javax.inject.Qualifier;
+import producerstest.monitoring.StubModule.ForServer1;
+import producerstest.monitoring.StubModule.ForServer2;
+
+@ProducerModule
+final class ServingModule {
+  @Qualifier
+  @interface RequestData {}
+
+  @Qualifier
+  @interface IntermediateData {}
+
+  @Produces
+  @RequestData
+  static String requestData() {
+    return "Hello, World!";
+  }
+
+  @Produces
+  @IntermediateData
+  static ListenableFuture<String> callServer1(
+      @RequestData String data, @ForServer1 StringStub stub) {
+    return stub.run(data);
+  }
+
+  @Produces
+  static ListenableFuture<String> callServer2(
+      @IntermediateData String data, @ForServer2 StringStub stub) {
+    return stub.run(data);
+  }
+}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/StringStub.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/StringStub.java
new file mode 100644
index 000000000..195dd283d
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/StringStub.java
@@ -0,0 +1,22 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package producerstest.monitoring;
+
+import com.google.common.util.concurrent.ListenableFuture;
+
+interface StringStub {
+  ListenableFuture<String> run(String input);
+}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/StubModule.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/StubModule.java
new file mode 100644
index 000000000..dc8ab6260
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/StubModule.java
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package producerstest.monitoring;
+
+import dagger.Module;
+import dagger.Provides;
+import javax.inject.Qualifier;
+
+@Module
+final class StubModule {
+  @Qualifier
+  @interface ForServer1 {}
+
+  @Qualifier
+  @interface ForServer2 {}
+
+  private final StringStub server1;
+  private final StringStub server2;
+
+  StubModule(StringStub server1, StringStub server2) {
+    this.server1 = server1;
+    this.server2 = server2;
+  }
+
+  @Provides
+  @ForServer1
+  StringStub server1() {
+    return server1;
+  }
+
+  @Provides
+  @ForServer2
+  StringStub server2() {
+    return server2;
+  }
+}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/test/SimpleProducerModule.java b/compiler/src/it/producers-functional-tests/src/main/java/test/SimpleProducerModule.java
deleted file mode 100644
index fa63d4822..000000000
--- a/compiler/src/it/producers-functional-tests/src/main/java/test/SimpleProducerModule.java
+++ /dev/null
@@ -1,32 +0,0 @@
-/*
-* Copyright (C) 2015 Google, Inc.
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
-*
-* http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS,
-* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-* See the License for the specific language governing permissions and
-* limitations under the License.
-*/
-package test;
-
-import com.google.common.util.concurrent.Futures;
-import com.google.common.util.concurrent.ListenableFuture;
-import dagger.producers.ProducerModule;
-import dagger.producers.Produces;
-
-@ProducerModule
-final class SimpleProducerModule {
-  @Produces ListenableFuture<String> str() {
-    return Futures.immediateFuture("Hello, World!");
-  }
-
-  @Produces int len(String str) {
-    return str.length();
-  }
-}
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/test/DependentTest.java b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/DependentTest.java
similarity index 99%
rename from compiler/src/it/producers-functional-tests/src/test/java/test/DependentTest.java
rename to compiler/src/it/producers-functional-tests/src/test/java/producerstest/DependentTest.java
index 15aa48165..b2533d735 100644
--- a/compiler/src/it/producers-functional-tests/src/test/java/test/DependentTest.java
+++ b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/DependentTest.java
@@ -13,7 +13,7 @@
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
-package test;
+package producerstest;
 
 import com.google.common.util.concurrent.Futures;
 import com.google.common.util.concurrent.ListenableFuture;
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/MultibindingTest.java b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/MultibindingTest.java
new file mode 100644
index 000000000..4ddc7c6bc
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/MultibindingTest.java
@@ -0,0 +1,73 @@
+/*
+* Copyright (C) 2015 Google, Inc.
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package producerstest;
+
+import com.google.common.collect.Iterables;
+import com.google.common.util.concurrent.MoreExecutors;
+import dagger.producers.Produced;
+import java.util.HashSet;
+import java.util.Set;
+import java.util.concurrent.ExecutionException;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assertThat;
+
+@RunWith(JUnit4.class)
+public class MultibindingTest {
+  @Test
+  public void setBinding() throws Exception {
+    MultibindingComponent multibindingComponent =
+        DaggerMultibindingComponent.builder().executor(MoreExecutors.directExecutor()).build();
+    assertThat(multibindingComponent.strs().get())
+        .containsExactly("foo", "foo1", "foo2", "bar", "bar1", "bar2");
+    assertThat(multibindingComponent.strCount().get()).isEqualTo(6);
+  }
+
+  @Test
+  public void setBindingOfProduced() throws Exception {
+    MultibindingComponent multibindingComponent =
+        DaggerMultibindingComponent.builder().executor(MoreExecutors.directExecutor()).build();
+    assertThat(multibindingComponent.successfulSet().get())
+        .containsExactly(
+            Produced.successful("foo"),
+            Produced.successful("foo1"),
+            Produced.successful("foo2"),
+            Produced.successful("bar"),
+            Produced.successful("bar1"),
+            Produced.successful("bar2"));
+  }
+
+  @Test
+  public void setBindingOfProducedWithFailures() throws Exception {
+    MultibindingComponent multibindingComponent =
+        DaggerMultibindingComponent.builder().executor(MoreExecutors.directExecutor()).build();
+    Set<Produced<String>> possiblyThrowingSet = multibindingComponent.possiblyThrowingSet().get();
+    Set<String> successes = new HashSet<>();
+    Set<ExecutionException> failures = new HashSet<>();
+    for (Produced<String> str : possiblyThrowingSet) {
+      try {
+        successes.add(str.get());
+      } catch (ExecutionException e) {
+        failures.add(e);
+      }
+    }
+    assertThat(successes).containsExactly("singleton", "double", "ton");
+    assertThat(failures).hasSize(1);
+    assertThat(Iterables.getOnlyElement(failures).getCause()).hasMessage("monkey");
+  }
+}
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/ProducerFactoryTest.java b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/ProducerFactoryTest.java
new file mode 100644
index 000000000..9a5602990
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/ProducerFactoryTest.java
@@ -0,0 +1,185 @@
+/*
+* Copyright (C) 2015 Google, Inc.
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package producerstest;
+
+import com.google.common.util.concurrent.ListenableFuture;
+import com.google.common.util.concurrent.MoreExecutors;
+import com.google.common.util.concurrent.SettableFuture;
+import dagger.producers.Producer;
+import dagger.producers.monitoring.ProducerMonitor;
+import dagger.producers.monitoring.ProducerToken;
+import dagger.producers.monitoring.ProductionComponentMonitor;
+import java.util.concurrent.ExecutionException;
+import javax.inject.Provider;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import org.mockito.InOrder;
+import org.mockito.Mock;
+import org.mockito.Mockito;
+import org.mockito.MockitoAnnotations;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.inOrder;
+import static org.mockito.Mockito.when;
+
+@RunWith(JUnit4.class)
+public class ProducerFactoryTest {
+  @Mock private ProductionComponentMonitor componentMonitor;
+  private ProducerMonitor monitor;
+  private Provider<ProductionComponentMonitor> componentMonitorProvider;
+
+  @Before
+  public void setUpMocks() {
+    MockitoAnnotations.initMocks(this);
+    monitor = Mockito.mock(ProducerMonitor.class, Mockito.CALLS_REAL_METHODS);
+    when(componentMonitor.producerMonitorFor(any(ProducerToken.class))).thenReturn(monitor);
+    componentMonitorProvider =
+        new Provider<ProductionComponentMonitor>() {
+          @Override
+          public ProductionComponentMonitor get() {
+            return componentMonitor;
+          }
+        };
+  }
+
+  @Test
+  public void noArgMethod() throws Exception {
+    ProducerToken token = ProducerToken.create(SimpleProducerModule_StrFactory.class);
+    Producer<String> producer =
+        new SimpleProducerModule_StrFactory(
+            MoreExecutors.directExecutor(), componentMonitorProvider);
+    assertThat(producer.get().get()).isEqualTo("str");
+    InOrder order = inOrder(componentMonitor, monitor);
+    order.verify(componentMonitor).producerMonitorFor(token);
+    order.verify(monitor).methodStarting();
+    order.verify(monitor).methodFinished();
+    order.verify(monitor).succeeded("str");
+    order.verifyNoMoreInteractions();
+  }
+
+  @Test public void singleArgMethod() throws Exception {
+    SettableFuture<Integer> intFuture = SettableFuture.create();
+    Producer<Integer> intProducer = producerOfFuture(intFuture);
+    Producer<String> producer =
+        new SimpleProducerModule_StrWithArgFactory(
+            MoreExecutors.directExecutor(), componentMonitorProvider, intProducer);
+    assertThat(producer.get().isDone()).isFalse();
+    intFuture.set(42);
+    assertThat(producer.get().get()).isEqualTo("str with arg");
+  }
+
+  @Test
+  public void successMonitor() throws Exception {
+    ProducerToken token = ProducerToken.create(SimpleProducerModule_SettableFutureStrFactory.class);
+
+    SettableFuture<String> strFuture = SettableFuture.create();
+    SettableFuture<SettableFuture<String>> strFutureFuture = SettableFuture.create();
+    Producer<SettableFuture<String>> strFutureProducer = producerOfFuture(strFutureFuture);
+    Producer<String> producer =
+        new SimpleProducerModule_SettableFutureStrFactory(
+            MoreExecutors.directExecutor(), componentMonitorProvider, strFutureProducer);
+    assertThat(producer.get().isDone()).isFalse();
+
+    InOrder order = inOrder(componentMonitor, monitor);
+    order.verify(componentMonitor).producerMonitorFor(token);
+
+    strFutureFuture.set(strFuture);
+    order.verify(monitor).methodStarting();
+    order.verify(monitor).methodFinished();
+    assertThat(producer.get().isDone()).isFalse();
+
+    strFuture.set("monkey");
+    assertThat(producer.get().get()).isEqualTo("monkey");
+    order.verify(monitor).succeeded("monkey");
+
+    order.verifyNoMoreInteractions();
+  }
+
+  @Test
+  public void failureMonitor() throws Exception {
+    ProducerToken token = ProducerToken.create(SimpleProducerModule_SettableFutureStrFactory.class);
+
+    SettableFuture<String> strFuture = SettableFuture.create();
+    SettableFuture<SettableFuture<String>> strFutureFuture = SettableFuture.create();
+    Producer<SettableFuture<String>> strFutureProducer = producerOfFuture(strFutureFuture);
+    Producer<String> producer =
+        new SimpleProducerModule_SettableFutureStrFactory(
+            MoreExecutors.directExecutor(), componentMonitorProvider, strFutureProducer);
+    assertThat(producer.get().isDone()).isFalse();
+
+    InOrder order = inOrder(componentMonitor, monitor);
+    order.verify(componentMonitor).producerMonitorFor(token);
+
+    strFutureFuture.set(strFuture);
+    order.verify(monitor).methodStarting();
+    order.verify(monitor).methodFinished();
+    assertThat(producer.get().isDone()).isFalse();
+
+    Throwable t = new RuntimeException("monkey");
+    strFuture.setException(t);
+    try {
+      producer.get().get();
+      fail();
+    } catch (ExecutionException e) {
+      assertThat(e.getCause()).isSameAs(t);
+      order.verify(monitor).failed(t);
+    }
+
+    order.verifyNoMoreInteractions();
+  }
+
+  @Test
+  public void failureMonitorDueToThrowingProducer() throws Exception {
+    ProducerToken token = ProducerToken.create(SimpleProducerModule_ThrowingProducerFactory.class);
+
+    Producer<String> producer =
+        new SimpleProducerModule_ThrowingProducerFactory(
+            MoreExecutors.directExecutor(), componentMonitorProvider);
+    assertThat(producer.get().isDone()).isTrue();
+
+    InOrder order = inOrder(componentMonitor, monitor);
+    order.verify(componentMonitor).producerMonitorFor(token);
+
+    order.verify(monitor).methodStarting();
+    order.verify(monitor).methodFinished();
+
+    try {
+      producer.get().get();
+      fail();
+    } catch (ExecutionException e) {
+      order.verify(monitor).failed(e.getCause());
+    }
+
+    order.verifyNoMoreInteractions();
+  }
+
+  @Test(expected = NullPointerException.class)
+  public void nullComponentMonitorProvider() throws Exception {
+    new SimpleProducerModule_StrFactory(MoreExecutors.directExecutor(), null);
+  }
+
+  private static <T> Producer<T> producerOfFuture(final ListenableFuture<T> future) {
+    return new Producer<T>() {
+      @Override public ListenableFuture<T> get() {
+        return future;
+      }
+    };
+  }
+}
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/test/SimpleTest.java b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/SimpleTest.java
similarity index 96%
rename from compiler/src/it/producers-functional-tests/src/test/java/test/SimpleTest.java
rename to compiler/src/it/producers-functional-tests/src/test/java/producerstest/SimpleTest.java
index f2b910e3c..cacc0f11d 100644
--- a/compiler/src/it/producers-functional-tests/src/test/java/test/SimpleTest.java
+++ b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/SimpleTest.java
@@ -13,7 +13,7 @@
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
-package test;
+package producerstest;
 
 import com.google.common.util.concurrent.MoreExecutors;
 import org.junit.Test;
@@ -30,6 +30,6 @@
         .executor(MoreExecutors.directExecutor())
         .build();
     assertThat(simpleComponent).isNotNull();
-    assertThat(simpleComponent.response().get().data()).isEqualTo("Hello, Request!");
+    assertThat(simpleComponent.response().get().data()).isEqualTo("Hello, Request #5!");
   }
 }
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/badexecutor/BadExecutorTest.java b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/badexecutor/BadExecutorTest.java
new file mode 100644
index 000000000..8a49797f5
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/badexecutor/BadExecutorTest.java
@@ -0,0 +1,74 @@
+package producerstest.badexecutor;
+
+import com.google.common.util.concurrent.Futures;
+import com.google.common.util.concurrent.ListenableFuture;
+import com.google.common.util.concurrent.ListeningExecutorService;
+import com.google.common.util.concurrent.MoreExecutors;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.RejectedExecutionException;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+
+/** This test verifies behavior when the executor throws {@link RejectedExecutionException}. */
+@RunWith(JUnit4.class)
+public final class BadExecutorTest {
+  private SimpleComponent component;
+
+  @Before
+  public void setUpComponent() {
+    ComponentDependency dependency =
+        new ComponentDependency() {
+          @Override
+          public ListenableFuture<Double> doubleDep() {
+            return Futures.immediateFuture(42.0);
+          }
+        };
+    ListeningExecutorService executorService = MoreExecutors.newDirectExecutorService();
+    component =
+        DaggerSimpleComponent.builder()
+            .executor(executorService)
+            .componentDependency(dependency)
+            .build();
+    executorService.shutdown();
+  }
+
+  @Test
+  public void rejectNoArgMethod() throws Exception {
+    try {
+      component.noArgStr().get();
+      fail();
+    } catch (ExecutionException e) {
+      assertThat(e.getCause()).isInstanceOf(RejectedExecutionException.class);
+    }
+  }
+
+  @Test
+  public void rejectSingleArgMethod() throws Exception {
+    try {
+      component.singleArgInt().get();
+      fail();
+    } catch (ExecutionException e) {
+      assertThat(e.getCause()).isInstanceOf(RejectedExecutionException.class);
+    }
+  }
+
+  @Test
+  public void rejectSingleArgFromComponentDepMethod() throws Exception {
+    try {
+      component.singleArgBool().get();
+      fail();
+    } catch (ExecutionException e) {
+      assertThat(e.getCause()).isInstanceOf(RejectedExecutionException.class);
+    }
+  }
+
+  @Test
+  public void doNotRejectComponentDepMethod() throws Exception {
+    assertThat(component.doubleDep().get()).isEqualTo(42.0);
+  }
+}
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/builder/ProductionComponentBuilderTest.java b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/builder/ProductionComponentBuilderTest.java
new file mode 100644
index 000000000..715761df4
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/builder/ProductionComponentBuilderTest.java
@@ -0,0 +1,78 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package producerstest.builder;
+
+import com.google.common.util.concurrent.Futures;
+import com.google.common.util.concurrent.ListenableFuture;
+import com.google.common.util.concurrent.MoreExecutors;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assertThat;
+
+/** Tests for {@link dagger.producers.ProductionComponent.Builder}. */
+@RunWith(JUnit4.class)
+public final class ProductionComponentBuilderTest {
+
+  @Test
+  public void successfulBuild() throws Exception {
+    TestComponentWithBuilder component =
+        DaggerTestComponentWithBuilder.builder()
+            .executor(MoreExecutors.directExecutor())
+            .depComponent(depComponent(15.3))
+            .strModule(new StringModule())
+            .build();
+    assertThat(component.s().get()).isEqualTo("arg: 42");
+    assertThat(component.d().get()).isEqualTo(15.3);
+  }
+
+  @Test
+  public void successfulBuild_withMissingZeroArgModule() throws Exception {
+    TestComponentWithBuilder component =
+        DaggerTestComponentWithBuilder.builder()
+            .executor(MoreExecutors.directExecutor())
+            .depComponent(depComponent(15.3))
+            .build();
+    assertThat(component.s().get()).isEqualTo("arg: 42");
+    assertThat(component.d().get()).isEqualTo(15.3);
+  }
+
+  @Test(expected = IllegalStateException.class)
+  public void missingExecutor() {
+    DaggerTestComponentWithBuilder.builder()
+        .depComponent(depComponent(15.3))
+        .strModule(new StringModule())
+        .build();
+  }
+
+  @Test(expected = IllegalStateException.class)
+  public void missingDepComponent() {
+    DaggerTestComponentWithBuilder.builder()
+        .executor(MoreExecutors.directExecutor())
+        .strModule(new StringModule())
+        .build();
+  }
+
+  private static DepComponent depComponent(final double value) {
+    return new DepComponent() {
+      @Override
+      public ListenableFuture<Double> d() {
+        return Futures.immediateFuture(value);
+      }
+    };
+  }
+}
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/monitoring/MonitoringTest.java b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/monitoring/MonitoringTest.java
new file mode 100644
index 000000000..3efb2b5b1
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/monitoring/MonitoringTest.java
@@ -0,0 +1,157 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package producerstest.monitoring;
+
+import com.google.common.base.Throwables;
+import com.google.common.collect.ImmutableList;
+import com.google.common.util.concurrent.ListenableFuture;
+import com.google.common.util.concurrent.MoreExecutors;
+import com.google.common.util.concurrent.SettableFuture;
+import dagger.producers.monitoring.ProducerMonitor;
+import dagger.producers.monitoring.ProducerToken;
+import dagger.producers.monitoring.ProductionComponentMonitor;
+import java.util.LinkedHashMap;
+import java.util.Map;
+import java.util.concurrent.ExecutionException;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import org.mockito.InOrder;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+import static org.mockito.Mockito.any;
+import static org.mockito.Mockito.inOrder;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verifyNoMoreInteractions;
+import static org.mockito.Mockito.when;
+
+/** Tests for production components using monitoring. */
+@RunWith(JUnit4.class)
+public final class MonitoringTest {
+  @Mock private ProductionComponentMonitor.Factory componentMonitorFactory;
+  @Mock private StringStub server1;
+  @Mock private StringStub server2;
+  private SettableFuture<String> server1Future;
+  private SettableFuture<String> server2Future;
+  private FakeProductionComponentMonitor componentMonitor;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+    componentMonitor = new FakeProductionComponentMonitor();
+    when(componentMonitorFactory.create(any())).thenReturn(componentMonitor);
+    server1Future = SettableFuture.create();
+    server2Future = SettableFuture.create();
+    when(server1.run(any(String.class))).thenReturn(server1Future);
+    when(server2.run(any(String.class))).thenReturn(server2Future);
+  }
+
+  @Test
+  public void basicMonitoring() throws Exception {
+    MonitoredComponent component =
+        DaggerMonitoredComponent.builder()
+            .executor(MoreExecutors.directExecutor())
+            .monitoringModule(new MonitoringModule(componentMonitorFactory))
+            .stubModule(new StubModule(server1, server2))
+            .build();
+    ListenableFuture<String> output = component.output();
+    assertThat(componentMonitor.monitors).hasSize(3);
+    ImmutableList<Map.Entry<ProducerToken, ProducerMonitor>> entries =
+        ImmutableList.copyOf(componentMonitor.monitors.entrySet());
+    assertThat(entries.get(0).getKey().toString()).contains("CallServer2");
+    assertThat(entries.get(1).getKey().toString()).contains("CallServer1");
+    assertThat(entries.get(2).getKey().toString()).contains("RequestData");
+
+    ProducerMonitor callServer2Monitor = entries.get(0).getValue();
+    ProducerMonitor callServer1Monitor = entries.get(1).getValue();
+    ProducerMonitor requestDataMonitor = entries.get(2).getValue();
+
+    InOrder inOrder = inOrder(requestDataMonitor, callServer1Monitor, callServer2Monitor);
+    inOrder.verify(requestDataMonitor).methodStarting();
+    inOrder.verify(requestDataMonitor).methodFinished();
+    inOrder.verify(requestDataMonitor).succeeded("Hello, World!");
+    inOrder.verify(callServer1Monitor).methodStarting();
+    inOrder.verify(callServer1Monitor).methodFinished();
+    verifyNoMoreInteractions(requestDataMonitor, callServer1Monitor, callServer2Monitor);
+
+    server1Future.set("server 1 response");
+    inOrder.verify(callServer1Monitor).succeeded("server 1 response");
+    inOrder.verify(callServer2Monitor).methodStarting();
+    inOrder.verify(callServer2Monitor).methodFinished();
+    verifyNoMoreInteractions(requestDataMonitor, callServer1Monitor, callServer2Monitor);
+
+    server2Future.set("server 2 response");
+    inOrder.verify(callServer2Monitor).succeeded("server 2 response");
+    verifyNoMoreInteractions(requestDataMonitor, callServer1Monitor, callServer2Monitor);
+    assertThat(output.get()).isEqualTo("server 2 response");
+  }
+
+  @Test
+  public void basicMonitoringWithFailure() throws Exception {
+    MonitoredComponent component =
+        DaggerMonitoredComponent.builder()
+            .executor(MoreExecutors.directExecutor())
+            .monitoringModule(new MonitoringModule(componentMonitorFactory))
+            .stubModule(new StubModule(server1, server2))
+            .build();
+    ListenableFuture<String> output = component.output();
+    assertThat(componentMonitor.monitors).hasSize(3);
+    ImmutableList<Map.Entry<ProducerToken, ProducerMonitor>> entries =
+        ImmutableList.copyOf(componentMonitor.monitors.entrySet());
+    assertThat(entries.get(0).getKey().toString()).contains("CallServer2");
+    assertThat(entries.get(1).getKey().toString()).contains("CallServer1");
+    assertThat(entries.get(2).getKey().toString()).contains("RequestData");
+
+    ProducerMonitor callServer2Monitor = entries.get(0).getValue();
+    ProducerMonitor callServer1Monitor = entries.get(1).getValue();
+    ProducerMonitor requestDataMonitor = entries.get(2).getValue();
+
+    InOrder inOrder = inOrder(requestDataMonitor, callServer1Monitor, callServer2Monitor);
+    inOrder.verify(requestDataMonitor).methodStarting();
+    inOrder.verify(requestDataMonitor).methodFinished();
+    inOrder.verify(requestDataMonitor).succeeded("Hello, World!");
+    inOrder.verify(callServer1Monitor).methodStarting();
+    inOrder.verify(callServer1Monitor).methodFinished();
+    verifyNoMoreInteractions(requestDataMonitor, callServer1Monitor, callServer2Monitor);
+
+    RuntimeException cause = new RuntimeException("monkey");
+    server1Future.setException(cause);
+    inOrder.verify(callServer1Monitor).failed(cause);
+    inOrder.verify(callServer2Monitor).failed(any(Throwable.class));
+    verifyNoMoreInteractions(requestDataMonitor, callServer1Monitor, callServer2Monitor);
+    try {
+      output.get();
+      fail();
+    } catch (ExecutionException e) {
+      assertThat(Throwables.getRootCause(e)).isSameAs(cause);
+    }
+  }
+
+  private static final class FakeProductionComponentMonitor implements ProductionComponentMonitor {
+    final Map<ProducerToken, ProducerMonitor> monitors = new LinkedHashMap<>();
+
+    @Override
+    public ProducerMonitor producerMonitorFor(ProducerToken token) {
+      ProducerMonitor monitor = mock(ProducerMonitor.class);
+      monitors.put(token, monitor);
+      return monitor;
+    }
+  }
+}
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/test/MultibindingTest.java b/compiler/src/it/producers-functional-tests/src/test/java/test/MultibindingTest.java
deleted file mode 100644
index 20c86dc52..000000000
--- a/compiler/src/it/producers-functional-tests/src/test/java/test/MultibindingTest.java
+++ /dev/null
@@ -1,35 +0,0 @@
-/*
-* Copyright (C) 2015 Google, Inc.
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
-*
-* http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS,
-* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-* See the License for the specific language governing permissions and
-* limitations under the License.
-*/
-package test;
-
-import com.google.common.util.concurrent.MoreExecutors;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-import static com.google.common.truth.Truth.assertThat;
-
-@RunWith(JUnit4.class)
-public class MultibindingTest {
-  @Test public void multibinding() throws Exception {
-    MultibindingComponent multibindingComponent = DaggerMultibindingComponent.builder()
-        .executor(MoreExecutors.directExecutor())
-        .build();
-    assertThat(multibindingComponent.strs().get())
-        .containsExactly("foo", "foo1", "foo2", "bar", "bar1", "bar2");
-    assertThat(multibindingComponent.strCount().get()).isEqualTo(6);
-  }
-}
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/test/ProducerFactoryTest.java b/compiler/src/it/producers-functional-tests/src/test/java/test/ProducerFactoryTest.java
deleted file mode 100644
index 3826b6ed0..000000000
--- a/compiler/src/it/producers-functional-tests/src/test/java/test/ProducerFactoryTest.java
+++ /dev/null
@@ -1,55 +0,0 @@
-/*
-* Copyright (C) 2015 Google, Inc.
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
-*
-* http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS,
-* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-* See the License for the specific language governing permissions and
-* limitations under the License.
-*/
-package test;
-
-import com.google.common.util.concurrent.ListenableFuture;
-import com.google.common.util.concurrent.MoreExecutors;
-import com.google.common.util.concurrent.SettableFuture;
-import dagger.producers.Producer;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-import static com.google.common.truth.Truth.assertThat;
-
-@RunWith(JUnit4.class)
-public class ProducerFactoryTest {
-  @Test public void noArgMethod() throws Exception {
-    SimpleProducerModule module = new SimpleProducerModule();
-    Producer<String> producer =
-        new SimpleProducerModule_StrFactory(module, MoreExecutors.directExecutor());
-    assertThat(producer.get().get()).isEqualTo("Hello, World!");
-  }
-
-  @Test public void singleArgMethod() throws Exception {
-    SimpleProducerModule module = new SimpleProducerModule();
-    SettableFuture<String> strFuture = SettableFuture.create();
-    Producer<String> strProducer = producerOfFuture(strFuture);
-    Producer<Integer> producer =
-        new SimpleProducerModule_LenFactory(module, MoreExecutors.directExecutor(), strProducer);
-    assertThat(producer.get().isDone()).isFalse();
-    strFuture.set("abcdef");
-    assertThat(producer.get().get()).isEqualTo(6);
-  }
-
-  private static <T> Producer<T> producerOfFuture(final ListenableFuture<T> future) {
-    return new Producer<T>() {
-      @Override public ListenableFuture<T> get() {
-        return future;
-      }
-    };
-  }
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentProcessingStep.java
index fd670f266..578fb5ffa 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentProcessingStep.java
@@ -16,12 +16,13 @@
 package dagger.internal.codegen;
 
 import com.google.auto.common.BasicAnnotationProcessor.ProcessingStep;
+import com.google.auto.common.MoreElements;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.SetMultimap;
 import java.lang.annotation.Annotation;
-import java.util.Set;
 import javax.annotation.processing.Messager;
 import javax.lang.model.element.Element;
+import javax.lang.model.element.TypeElement;
 
 /**
  * A {@link ProcessingStep} that is responsible for dealing with a component or production component
@@ -29,18 +30,27 @@
  */
 abstract class AbstractComponentProcessingStep implements ProcessingStep {
 
+  private final Class<? extends Annotation> componentAnnotation;
   private final Messager messager;
+  private final ComponentHierarchyValidator componentHierarchyValidator;
   private final BindingGraphValidator bindingGraphValidator;
+  private final ComponentDescriptor.Factory componentDescriptorFactory;
   private final BindingGraph.Factory bindingGraphFactory;
   private final ComponentGenerator componentGenerator;
 
   AbstractComponentProcessingStep(
+      Class<? extends Annotation> componentAnnotation,
       Messager messager,
+      ComponentHierarchyValidator componentHierarchyValidator,
       BindingGraphValidator bindingGraphValidator,
+      ComponentDescriptor.Factory componentDescriptorFactory,
       BindingGraph.Factory bindingGraphFactory,
       ComponentGenerator componentGenerator) {
+    this.componentAnnotation = componentAnnotation;
     this.messager = messager;
+    this.componentHierarchyValidator = componentHierarchyValidator;
     this.bindingGraphValidator = bindingGraphValidator;
+    this.componentDescriptorFactory = componentDescriptorFactory;
     this.bindingGraphFactory = bindingGraphFactory;
     this.componentGenerator = componentGenerator;
   }
@@ -49,29 +59,59 @@
   public final ImmutableSet<Element> process(
       SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
     ImmutableSet.Builder<Element> rejectedElements = ImmutableSet.builder();
-    for (ComponentDescriptor componentDescriptor : componentDescriptors(elementsByAnnotation)) {
+    ComponentElementValidator componentElementValidator =
+        componentElementValidator(elementsByAnnotation);
+    for (Element element : elementsByAnnotation.get(componentAnnotation)) {
+      TypeElement componentTypeElement = MoreElements.asType(element);
       try {
-        BindingGraph bindingGraph = bindingGraphFactory.create(componentDescriptor);
-        ValidationReport<BindingGraph> graphReport = bindingGraphValidator.validate(bindingGraph);
-        graphReport.printMessagesTo(messager);
-        if (graphReport.isClean()) {
-          try {
-            componentGenerator.generate(bindingGraph);
-          } catch (SourceFileGenerationException e) {
-            e.printMessageTo(messager);
+        if (componentElementValidator.validateComponent(componentTypeElement, messager)) {
+          ComponentDescriptor componentDescriptor =
+              componentDescriptorFactory.forComponent(componentTypeElement);
+          ValidationReport<TypeElement> hierarchyReport =
+              componentHierarchyValidator.validate(componentDescriptor);
+          hierarchyReport.printMessagesTo(messager);
+          if (hierarchyReport.isClean()) {
+            BindingGraph bindingGraph = bindingGraphFactory.create(componentDescriptor);
+            ValidationReport<TypeElement> graphReport =
+                bindingGraphValidator.validate(bindingGraph);
+            graphReport.printMessagesTo(messager);
+            if (graphReport.isClean()) {
+              generateComponent(bindingGraph);
+            }
           }
         }
       } catch (TypeNotPresentException e) {
-        rejectedElements.add(componentDescriptor.componentDefinitionType());
+        rejectedElements.add(componentTypeElement);
       }
     }
     return rejectedElements.build();
   }
 
+  private void generateComponent(BindingGraph bindingGraph) {
+    try {
+      componentGenerator.generate(bindingGraph);
+    } catch (SourceFileGenerationException e) {
+      e.printMessageTo(messager);
+    }
+  }
+
   /**
-   * Returns a {@link ComponentDescriptor} for each valid component element for which an
-   * implementation class should be generated.
+   * Returns an object that can validate a type element annotated with the component type.
    */
-  protected abstract Set<ComponentDescriptor> componentDescriptors(
+  protected abstract ComponentElementValidator componentElementValidator(
       SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation);
+
+  /**
+   * Validates a component type element.
+   */
+  protected static abstract class ComponentElementValidator {
+    /**
+     * Validates a component type element. Prints any messages about the element to
+     * {@code messager}.
+     *
+     * @throws TypeNotPresentException if any type required to validate the component cannot be
+     *     found
+     */
+    abstract boolean validateComponent(TypeElement componentTypeElement, Messager messager);
+  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
new file mode 100644
index 000000000..db890b246
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -0,0 +1,1165 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.common.MoreElements;
+import com.google.auto.common.MoreTypes;
+import com.google.common.base.Joiner;
+import com.google.common.base.Optional;
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Iterables;
+import com.google.common.collect.Lists;
+import com.google.common.collect.Maps;
+import com.google.common.collect.Sets;
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.MembersInjector;
+import dagger.internal.DelegateFactory;
+import dagger.internal.Factory;
+import dagger.internal.InstanceFactory;
+import dagger.internal.MapFactory;
+import dagger.internal.MapProviderFactory;
+import dagger.internal.MembersInjectors;
+import dagger.internal.ScopedProvider;
+import dagger.internal.SetFactory;
+import dagger.internal.codegen.ComponentDescriptor.BuilderSpec;
+import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
+import dagger.internal.codegen.ComponentGenerator.MemberSelect;
+import dagger.internal.codegen.writer.ClassName;
+import dagger.internal.codegen.writer.ClassWriter;
+import dagger.internal.codegen.writer.ConstructorWriter;
+import dagger.internal.codegen.writer.FieldWriter;
+import dagger.internal.codegen.writer.JavaWriter;
+import dagger.internal.codegen.writer.MethodWriter;
+import dagger.internal.codegen.writer.ParameterizedTypeName;
+import dagger.internal.codegen.writer.Snippet;
+import dagger.internal.codegen.writer.StringLiteral;
+import dagger.internal.codegen.writer.TypeName;
+import dagger.internal.codegen.writer.TypeNames;
+import dagger.internal.codegen.writer.VoidName;
+import dagger.producers.Producer;
+import dagger.producers.internal.Producers;
+import dagger.producers.internal.SetOfProducedProducer;
+import dagger.producers.internal.SetProducer;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.LinkedHashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import javax.inject.Provider;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ElementKind;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.Name;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.ExecutableType;
+import javax.lang.model.type.TypeKind;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
+import javax.tools.Diagnostic;
+import javax.tools.Diagnostic.Kind;
+
+import static com.google.auto.common.MoreTypes.asDeclared;
+import static com.google.common.base.CaseFormat.LOWER_CAMEL;
+import static com.google.common.base.CaseFormat.UPPER_CAMEL;
+import static com.google.common.base.Preconditions.checkState;
+import static com.google.common.collect.Iterables.any;
+import static com.google.common.collect.Iterables.getOnlyElement;
+import static dagger.internal.codegen.AbstractComponentWriter.InitializationState.DELEGATED;
+import static dagger.internal.codegen.AbstractComponentWriter.InitializationState.INITIALIZED;
+import static dagger.internal.codegen.AbstractComponentWriter.InitializationState.UNINITIALIZED;
+import static dagger.internal.codegen.Binding.bindingPackageFor;
+import static dagger.internal.codegen.ComponentGenerator.MemberSelect.staticMethodInvocationWithCast;
+import static dagger.internal.codegen.ComponentGenerator.MemberSelect.staticSelect;
+import static dagger.internal.codegen.ContributionBinding.contributionTypeFor;
+import static dagger.internal.codegen.ContributionBinding.FactoryCreationStrategy.ENUM_INSTANCE;
+import static dagger.internal.codegen.ContributionBinding.Kind.PROVISION;
+import static dagger.internal.codegen.ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD;
+import static dagger.internal.codegen.MapKeys.getMapKeySnippet;
+import static dagger.internal.codegen.MembersInjectionBinding.Strategy.NO_OP;
+import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
+import static dagger.internal.codegen.SourceFiles.generatedClassNameForBinding;
+import static dagger.internal.codegen.SourceFiles.indexDependenciesByUnresolvedKey;
+import static dagger.internal.codegen.SourceFiles.membersInjectorNameForType;
+import static dagger.internal.codegen.Util.componentCanMakeNewInstances;
+import static dagger.internal.codegen.Util.getKeyTypeOfMap;
+import static dagger.internal.codegen.Util.getProvidedValueTypeOfMap;
+import static dagger.internal.codegen.Util.isMapWithNonProvidedValues;
+import static dagger.internal.codegen.writer.Snippet.makeParametersSnippet;
+import static dagger.internal.codegen.writer.Snippet.memberSelectSnippet;
+import static dagger.internal.codegen.writer.Snippet.nullCheck;
+import static javax.lang.model.element.Modifier.ABSTRACT;
+import static javax.lang.model.element.Modifier.FINAL;
+import static javax.lang.model.element.Modifier.PRIVATE;
+import static javax.lang.model.element.Modifier.PUBLIC;
+import static javax.lang.model.element.Modifier.STATIC;
+import static javax.lang.model.type.TypeKind.DECLARED;
+import static javax.lang.model.type.TypeKind.VOID;
+
+/**
+ * Creates the implementation class for a component or subcomponent.
+ */
+abstract class AbstractComponentWriter {
+  // TODO(dpb): Make all these fields private after refactoring is complete.
+  protected final Elements elements;
+  protected final Types types;
+  protected final Key.Factory keyFactory;
+  protected final Kind nullableValidationType;
+  protected final Set<JavaWriter> javaWriters = new LinkedHashSet<>();
+  protected final ClassName name;
+  protected final BindingGraph graph;
+  private final Map<BindingKey, InitializationState> initializationStates = new HashMap<>();
+  private final Map<Binding, InitializationState> contributionInitializationStates =
+      new HashMap<>();
+  protected ClassWriter componentWriter;
+  private final Map<BindingKey, MemberSelect> memberSelectSnippets = new HashMap<>();
+  private final Map<ContributionBinding, MemberSelect> multibindingContributionSnippets =
+      new HashMap<>();
+  protected ConstructorWriter constructorWriter;
+  protected Optional<ClassName> builderName = Optional.absent();
+
+  /**
+   * For each component requirement, the builder field. This map is empty for subcomponents that do
+   * not use a builder.
+   */
+  private ImmutableMap<TypeElement, FieldWriter> builderFields = ImmutableMap.of();
+
+  /**
+   * For each component requirement, the snippet for the component field that holds it.
+   *
+   * <p>Fields are written for all requirements for subcomponents that do not use a builder, and for
+   * any requirement that is reused from a subcomponent of this component.
+   */
+  protected final Map<TypeElement, MemberSelect> componentContributionFields = Maps.newHashMap();
+
+  AbstractComponentWriter(
+      Types types,
+      Elements elements,
+      Key.Factory keyFactory,
+      Diagnostic.Kind nullableValidationType,
+      ClassName name,
+      BindingGraph graph) {
+    this.types = types;
+    this.elements = elements;
+    this.keyFactory = keyFactory;
+    this.nullableValidationType = nullableValidationType;
+    this.name = name;
+    this.graph = graph;
+  }
+
+  protected final TypeElement componentDefinitionType() {
+    return graph.componentDescriptor().componentDefinitionType();
+  }
+
+  protected final ClassName componentDefinitionTypeName() {
+    return ClassName.fromTypeElement(componentDefinitionType());
+  }
+
+  /**
+   * Returns an expression snippet that evaluates to an instance of the contribution, looking for
+   * either a builder field or a component field.
+   */
+  private Snippet getComponentContributionSnippet(TypeElement contributionType) {
+    if (builderFields.containsKey(contributionType)) {
+      return Snippet.format("builder.%s", builderFields.get(contributionType).name());
+    } else {
+      Optional<Snippet> snippet = getOrCreateComponentContributionFieldSnippet(contributionType);
+      checkState(snippet.isPresent(), "no builder or component field for %s", contributionType);
+      return snippet.get();
+    }
+  }
+
+  /**
+   * Returns a snippet for a component contribution field. Adds a field the first time one is
+   * requested for a contribution type if this component's builder has a field for it.
+   */
+  protected Optional<Snippet> getOrCreateComponentContributionFieldSnippet(
+      TypeElement contributionType) {
+    MemberSelect fieldSelect = componentContributionFields.get(contributionType);
+    if (fieldSelect == null) {
+      if (!builderFields.containsKey(contributionType)) {
+        return Optional.absent();
+      }
+      FieldWriter componentField =
+          componentWriter.addField(contributionType, simpleVariableName(contributionType));
+      componentField.addModifiers(PRIVATE, FINAL);
+      constructorWriter
+          .body()
+          .addSnippet(
+              "this.%s = builder.%s;",
+              componentField.name(),
+              builderFields.get(contributionType).name());
+      fieldSelect = MemberSelect.instanceSelect(name, Snippet.format("%s", componentField.name()));
+      componentContributionFields.put(contributionType, fieldSelect);
+    }
+    return Optional.of(fieldSelect.getSnippetFor(name));
+  }
+
+  private Snippet getMemberSelectSnippet(BindingKey key) {
+    return getMemberSelect(key).getSnippetFor(name);
+  }
+
+  protected MemberSelect getMemberSelect(BindingKey key) {
+    return memberSelectSnippets.get(key);
+  }
+
+  protected Optional<MemberSelect> getMultibindingContributionSnippet(ContributionBinding binding) {
+    return Optional.fromNullable(multibindingContributionSnippets.get(binding));
+  }
+
+  /**
+   * Returns the initialization state of the factory field for a binding key in this component.
+   */
+  protected InitializationState getInitializationState(BindingKey bindingKey) {
+    return initializationStates.containsKey(bindingKey)
+        ? initializationStates.get(bindingKey)
+        : UNINITIALIZED;
+  }
+
+  private void setInitializationState(BindingKey bindingKey, InitializationState state) {
+    initializationStates.put(bindingKey, state);
+  }
+
+  private InitializationState getContributionInitializationState(Binding binding) {
+    return contributionInitializationStates.containsKey(binding)
+        ? contributionInitializationStates.get(binding)
+        : UNINITIALIZED;
+  }
+
+  private void setContributionInitializationState(Binding binding, InitializationState state) {
+    contributionInitializationStates.put(binding, state);
+  }
+
+  ImmutableSet<JavaWriter> write() {
+    if (javaWriters.isEmpty()) {
+      writeComponent();
+    }
+    return ImmutableSet.copyOf(javaWriters);
+  }
+
+  private void writeComponent() {
+    componentWriter = createComponentClass();
+    addConstructor();
+    addBuilder();
+    addFactoryMethods();
+    addFields();
+    initializeFrameworkTypes();
+    implementInterfaceMethods();
+    addSubcomponents();
+  }
+
+  /**
+   * Creates the component implementation class.
+   */
+  protected abstract ClassWriter createComponentClass();
+
+  private void addConstructor() {
+    constructorWriter = componentWriter.addConstructor();
+    constructorWriter.addModifiers(PRIVATE);
+  }
+
+  /**
+   * Adds a builder type.
+   */
+  protected void addBuilder() {
+    ClassWriter builderWriter = createBuilder();
+    builderWriter.addModifiers(FINAL);
+    builderWriter.addConstructor().addModifiers(PRIVATE);
+    builderName = Optional.of(builderWriter.name());
+
+    Optional<BuilderSpec> builderSpec = graph.componentDescriptor().builderSpec();
+    if (builderSpec.isPresent()) {
+      builderWriter.addModifiers(PRIVATE);
+      builderWriter.setSupertype(builderSpec.get().builderDefinitionType());
+    } else {
+      builderWriter.addModifiers(PUBLIC);
+    }
+
+    builderFields = addBuilderFields(builderWriter);
+    addBuildMethod(builderWriter, builderSpec);
+    addBuilderMethods(builderWriter, builderSpec);
+
+    constructorWriter.addParameter(builderWriter, "builder");
+    constructorWriter.body().addSnippet("assert builder != null;");
+  }
+
+  /**
+   * Adds fields for each of the {@linkplain BindingGraph#componentRequirements component
+   * requirements}. Regardless of builder spec, there is always one field per requirement.
+   */
+  private ImmutableMap<TypeElement, FieldWriter> addBuilderFields(ClassWriter builderWriter) {
+    ImmutableMap.Builder<TypeElement, FieldWriter> builderFieldsBuilder = ImmutableMap.builder();
+    for (TypeElement contributionElement : graph.componentRequirements()) {
+      String contributionName = simpleVariableName(contributionElement);
+      FieldWriter builderField = builderWriter.addField(contributionElement, contributionName);
+      builderField.addModifiers(PRIVATE);
+      builderFieldsBuilder.put(contributionElement, builderField);
+    }
+    return builderFieldsBuilder.build();
+  }
+
+  /** Adds the build method to the builder. */
+  private void addBuildMethod(ClassWriter builderWriter, Optional<BuilderSpec> builderSpec) {
+    MethodWriter buildMethod;
+    if (builderSpec.isPresent()) {
+      ExecutableElement specBuildMethod = builderSpec.get().buildMethod();
+      // Note: we don't use the specBuildMethod.getReturnType() as the return type
+      // because it might be a type variable.  We make use of covariant returns to allow
+      // us to return the component type, which will always be valid.
+      buildMethod =
+          builderWriter.addMethod(
+              componentDefinitionTypeName(), specBuildMethod.getSimpleName().toString());
+      buildMethod.annotate(Override.class);
+    } else {
+      buildMethod = builderWriter.addMethod(componentDefinitionTypeName(), "build");
+    }
+    buildMethod.addModifiers(PUBLIC);
+
+    for (Map.Entry<TypeElement, FieldWriter> builderFieldEntry : builderFields.entrySet()) {
+      FieldWriter builderField = builderFieldEntry.getValue();
+      if (componentCanMakeNewInstances(builderFieldEntry.getKey())) {
+        buildMethod.body()
+            .addSnippet("if (%1$s == null) { this.%1$s = new %2$s(); }",
+                builderField.name(),
+                builderField.type());
+      } else {
+        buildMethod.body()
+            .addSnippet(
+                "if (%s == null) { throw new %s(%s.class.getCanonicalName() + \" must be set\"); }",
+                builderField.name(),
+                ClassName.fromClass(IllegalStateException.class),
+                builderField.type());
+      }
+    }
+
+    buildMethod.body().addSnippet("return new %s(this);", name);
+  }
+
+  /**
+   * Adds the methods that set each of parameters on the builder. If the {@link BuilderSpec} is
+   * present, it will tailor the methods to match the spec.
+   */
+  private void addBuilderMethods(
+      ClassWriter builderWriter,
+      Optional<BuilderSpec> builderSpec) {
+    if (builderSpec.isPresent()) {
+      for (Map.Entry<TypeElement, ExecutableElement> builderMethodEntry :
+          builderSpec.get().methodMap().entrySet()) {
+        TypeElement builderMethodType = builderMethodEntry.getKey();
+        ExecutableElement specMethod = builderMethodEntry.getValue();
+        MethodWriter builderMethod = addBuilderMethodFromSpec(builderWriter, specMethod);
+        String parameterName =
+            Iterables.getOnlyElement(specMethod.getParameters()).getSimpleName().toString();
+        builderMethod.addParameter(builderMethodType, parameterName);
+        builderMethod.body().addSnippet(nullCheck(parameterName));
+        if (graph.componentRequirements().contains(builderMethodType)) {
+          // required type
+          builderMethod.body().addSnippet("this.%s = %s;",
+              builderFields.get(builderMethodType).name(),
+              parameterName);
+          addBuilderMethodReturnStatementForSpec(specMethod, builderMethod);
+        } else if (graph.ownedModuleTypes().contains(builderMethodType)) {
+          // owned, but not required
+          builderMethod.body()
+              .addSnippet("// This module is declared, but not used in the component. "
+                  + "This method is a no-op");
+          addBuilderMethodReturnStatementForSpec(specMethod, builderMethod);
+        } else {
+          // neither owned nor required, so it must be an inherited module
+          builderMethod
+              .body()
+              .addSnippet(
+                  "throw new %s(%s.format(%s, %s.class.getCanonicalName()));",
+                  ClassName.fromClass(UnsupportedOperationException.class),
+                  ClassName.fromClass(String.class),
+                  StringLiteral.forValue(
+                      "%s cannot be set because it is inherited from the enclosing component"),
+                  ClassName.fromTypeElement(builderMethodType));
+        }
+      }
+    } else {
+      for (TypeElement componentRequirement : graph.availableDependencies()) {
+        String componentRequirementName = simpleVariableName(componentRequirement);
+        MethodWriter builderMethod = builderWriter.addMethod(
+            builderWriter.name(),
+            componentRequirementName);
+        builderMethod.addModifiers(PUBLIC);
+        builderMethod.addParameter(componentRequirement, componentRequirementName);
+        builderMethod.body().addSnippet(nullCheck(componentRequirementName));
+        if (graph.componentRequirements().contains(componentRequirement)) {
+          builderMethod.body()
+              .addSnippet("this.%s = %s;",
+                  builderFields.get(componentRequirement).name(),
+                  componentRequirementName);
+        } else {
+          builderMethod.annotate(Deprecated.class);
+        }
+        builderMethod.body().addSnippet("return this;");
+      }
+    }
+  }
+
+  private void addBuilderMethodReturnStatementForSpec(
+      ExecutableElement specMethod, MethodWriter builderMethod) {
+    if (!specMethod.getReturnType().getKind().equals(VOID)) {
+      builderMethod.body().addSnippet("return this;");
+    }
+  }
+
+  private MethodWriter addBuilderMethodFromSpec(
+      ClassWriter builderWriter, ExecutableElement method) {
+    String methodName = method.getSimpleName().toString();
+    TypeMirror returnType = method.getReturnType();
+    // If the return type is void, we add a method with the void return type.
+    // Otherwise we use the builderWriter and take advantage of covariant returns
+    // (so that we don't have to worry about setter methods that return type variables).
+    MethodWriter builderMethod =
+        returnType.getKind().equals(TypeKind.VOID)
+            ? builderWriter.addMethod(returnType, methodName)
+            : builderWriter.addMethod(builderWriter, methodName);
+    builderMethod.annotate(Override.class);
+    builderMethod.addModifiers(Sets.difference(method.getModifiers(), ImmutableSet.of(ABSTRACT)));
+    return builderMethod;
+  }
+
+  /**
+   * Creates the builder class.
+   */
+  protected abstract ClassWriter createBuilder();
+
+  /**
+   * Adds component factory methods.
+   */
+  protected abstract void addFactoryMethods();
+
+  private void addFields() {
+    for (ResolvedBindings resolvedBindings : graph.resolvedBindings().values()) {
+      addField(resolvedBindings);
+    }
+  }
+
+  private void addField(ResolvedBindings resolvedBindings) {
+    BindingKey bindingKey = resolvedBindings.bindingKey();
+
+    // No field needed if there are no owned bindings.
+    if (resolvedBindings.ownedBindings().isEmpty()) {
+      return;
+    }
+    
+    // No field needed for bindings with no dependencies or state.
+    Optional<MemberSelect> staticMemberSelect = staticMemberSelect(resolvedBindings);
+    if (staticMemberSelect.isPresent()) {
+      memberSelectSnippets.put(bindingKey, staticMemberSelect.get());
+      return;
+    }
+
+    Optional<String> bindingPackage = bindingPackageFor(resolvedBindings.bindings());
+    boolean useRawType = bindingPackage.isPresent()
+        && !bindingPackage.get().equals(name.packageName());
+    if (bindingKey.kind().equals(BindingKey.Kind.CONTRIBUTION)) {
+      ImmutableSet<ContributionBinding> contributionBindings =
+          resolvedBindings.contributionBindings();
+      if (ContributionBinding.contributionTypeFor(contributionBindings).isMultibinding()) {
+        // note that here we rely on the order of the resolved bindings being from parent to child
+        // otherwise, the numbering wouldn't work
+        int contributionNumber = 0;
+        for (ContributionBinding contributionBinding : contributionBindings) {
+          if (!contributionBinding.isSyntheticBinding()) {
+            contributionNumber++;
+            if (resolvedBindings.ownedContributionBindings().contains(contributionBinding)) {
+              FrameworkField contributionBindingField =
+                  FrameworkField.createForSyntheticContributionBinding(
+                      contributionNumber, contributionBinding);
+              FieldWriter contributionField =
+                  addFrameworkField(useRawType, contributionBindingField);
+
+              ImmutableList<String> contributionSelectTokens =
+                  new ImmutableList.Builder<String>()
+                      .add(contributionField.name())
+                      .build();
+              multibindingContributionSnippets.put(
+                  contributionBinding,
+                  MemberSelect.instanceSelect(name, memberSelectSnippet(contributionSelectTokens)));
+            }
+          }
+        }
+      }
+    }
+
+    FrameworkField bindingField = FrameworkField.createForResolvedBindings(resolvedBindings);
+    FieldWriter frameworkField = addFrameworkField(useRawType, bindingField);
+
+    ImmutableList<String> memberSelectTokens =
+        new ImmutableList.Builder<String>()
+            .add(frameworkField.name())
+            .build();
+    memberSelectSnippets.put(
+        bindingKey,
+        MemberSelect.instanceSelect(name, Snippet.memberSelectSnippet(memberSelectTokens)));
+  }
+
+  private FieldWriter addFrameworkField(boolean useRawType,
+      FrameworkField contributionBindingField) {
+    FieldWriter contributionField =
+        componentWriter.addField(
+            useRawType
+                ? contributionBindingField.frameworkType().type()
+                : contributionBindingField.frameworkType(),
+            contributionBindingField.name());
+    contributionField.addModifiers(PRIVATE);
+    if (useRawType) {
+      contributionField.annotate(SuppressWarnings.class).setValue("rawtypes");
+    }
+    return contributionField;
+  }
+
+  /**
+   * If {@code resolvedBindings} is an unscoped provision binding with no factory arguments or a
+   * no-op members injection binding, then we don't need a field to hold its factory. In that case,
+   * this method returns the static member select snippet that returns the factory or no-op members
+   * injector.
+   */
+  private Optional<MemberSelect> staticMemberSelect(ResolvedBindings resolvedBindings) {
+    switch (resolvedBindings.bindingKey().kind()) {
+      case CONTRIBUTION:
+        if (resolvedBindings.contributionBindings().size() != 1) {
+          return Optional.absent();
+        }
+        ContributionBinding contributionBinding =
+            getOnlyElement(resolvedBindings.contributionBindings());
+        if (contributionBinding.contributionType().isMultibinding()
+            || !(contributionBinding.bindingType().equals(Binding.Type.PROVISION))) {
+          return Optional.absent();
+        }
+        if (contributionBinding.factoryCreationStrategy().equals(ENUM_INSTANCE)
+            && !contributionBinding.scope().isPresent()) {
+          return Optional.of(
+              staticSelect(
+                  generatedClassNameForBinding(contributionBinding), Snippet.format("create()")));
+        }
+        break;
+
+      case MEMBERS_INJECTION:
+        Optional<MembersInjectionBinding> membersInjectionBinding =
+            resolvedBindings.membersInjectionBinding();
+        if (membersInjectionBinding.isPresent()
+            && membersInjectionBinding.get().injectionStrategy().equals(NO_OP)) {
+          return Optional.of(
+              staticMethodInvocationWithCast(
+                  ClassName.fromClass(MembersInjectors.class),
+                  Snippet.format("noOp()"),
+                  ClassName.fromClass(MembersInjector.class)));
+        }
+        break;
+
+      default:
+        throw new AssertionError();
+    }
+    return Optional.absent();
+  }
+
+  private void implementInterfaceMethods() {
+    Set<MethodSignature> interfaceMethods = Sets.newHashSet();
+    for (ComponentMethodDescriptor componentMethod :
+        graph.componentDescriptor().componentMethods()) {
+      if (componentMethod.dependencyRequest().isPresent()) {
+        DependencyRequest interfaceRequest = componentMethod.dependencyRequest().get();
+        ExecutableElement requestElement =
+            MoreElements.asExecutable(interfaceRequest.requestElement());
+        ExecutableType requestType = MoreTypes.asExecutable(types.asMemberOf(
+            MoreTypes.asDeclared(componentDefinitionType().asType()), requestElement));
+        MethodSignature signature = MethodSignature.fromExecutableType(
+            requestElement.getSimpleName().toString(), requestType);
+        if (!interfaceMethods.contains(signature)) {
+          interfaceMethods.add(signature);
+          MethodWriter interfaceMethod =
+              requestType.getReturnType().getKind().equals(VOID)
+                  ? componentWriter.addMethod(
+                      VoidName.VOID, requestElement.getSimpleName().toString())
+                  : componentWriter.addMethod(
+                      requestType.getReturnType(), requestElement.getSimpleName().toString());
+          interfaceMethod.annotate(Override.class);
+          interfaceMethod.addModifiers(PUBLIC);
+          BindingKey bindingKey = interfaceRequest.bindingKey();
+          MemberSelect memberSelect = getMemberSelect(bindingKey);
+          Snippet memberSelectSnippet = memberSelect.getSnippetFor(name);
+          switch (interfaceRequest.kind()) {
+            case MEMBERS_INJECTOR:
+              List<? extends VariableElement> parameters = requestElement.getParameters();
+              if (parameters.isEmpty()) {
+                // we're returning the framework type
+                interfaceMethod.body().addSnippet("return %s;", memberSelectSnippet);
+              } else {
+                VariableElement parameter = Iterables.getOnlyElement(parameters);
+                Name parameterName = parameter.getSimpleName();
+                interfaceMethod.addParameter(
+                    TypeNames.forTypeMirror(
+                        Iterables.getOnlyElement(requestType.getParameterTypes())),
+                    parameterName.toString());
+                interfaceMethod
+                    .body()
+                    .addSnippet(
+                        "%s.injectMembers(%s);",
+                        memberSelectSnippet,
+                        parameterName);
+                if (!requestType.getReturnType().getKind().equals(VOID)) {
+                  interfaceMethod.body().addSnippet("return %s;", parameterName);
+                }
+              }
+              break;
+            case INSTANCE:
+              if (memberSelect.staticMember()
+                  && bindingKey.key().type().getKind().equals(DECLARED)
+                  && !((DeclaredType) bindingKey.key().type()).getTypeArguments().isEmpty()) {
+                // If using a parameterized enum type, then we need to store the factory
+                // in a temporary variable, in order to help javac be able to infer
+                // the generics of the Factory.create methods.
+                TypeName factoryType =
+                    ParameterizedTypeName.create(
+                        Provider.class, TypeNames.forTypeMirror(requestType.getReturnType()));
+                interfaceMethod
+                    .body()
+                    .addSnippet(
+                        "%s factory = %s;", factoryType, memberSelectSnippet);
+                interfaceMethod.body().addSnippet("return factory.get();");
+                break;
+              }
+              // fall through in the else case.
+            case LAZY:
+            case PRODUCED:
+            case PRODUCER:
+            case PROVIDER:
+            case FUTURE:
+              interfaceMethod
+                  .body()
+                  .addSnippet(
+                      "return %s;",
+                      frameworkTypeUsageStatement(
+                          memberSelectSnippet, interfaceRequest.kind()));
+              break;
+            default:
+              throw new AssertionError();
+          }
+        }
+      }
+    }
+  }
+
+  private void addSubcomponents() {
+    for (Map.Entry<ExecutableElement, BindingGraph> subgraphEntry : graph.subgraphs().entrySet()) {
+      SubcomponentWriter subcomponent =
+          new SubcomponentWriter(this, subgraphEntry.getKey(), subgraphEntry.getValue());
+      javaWriters.addAll(subcomponent.write());
+    }
+  }
+
+  private static final int SNIPPETS_PER_INITIALIZATION_METHOD = 100;
+
+  private void initializeFrameworkTypes() {
+    ImmutableList.Builder<Snippet> snippetsBuilder = ImmutableList.builder();
+    for (BindingKey bindingKey : graph.resolvedBindings().keySet()) {
+      snippetsBuilder.add(initializeFrameworkType(bindingKey));
+    }
+    ImmutableList<Snippet> snippets = snippetsBuilder.build();
+
+    List<List<Snippet>> partitions = Lists.partition(snippets, SNIPPETS_PER_INITIALIZATION_METHOD);
+    for (int i = 0; i < partitions.size(); i++) {
+      MethodWriter initializeMethod =
+          componentWriter.addMethod(VoidName.VOID, "initialize" + ((i == 0) ? "" : i));
+      /* TODO(gak): Strictly speaking, we only need the suppression here if we are also initializing
+       * a raw field in this method, but the structure of this code makes it awkward to pass that
+       * bit through.  This will be cleaned up when we no longer separate fields and initilization
+       * as we do now. */
+      initializeMethod.annotate(SuppressWarnings.class).setValue("unchecked");
+      for (Snippet snippet : partitions.get(i)) {
+        initializeMethod.body().addSnippet(snippet);
+      }
+      initializeMethod.addModifiers(PRIVATE);
+      if (builderName.isPresent()) {
+        initializeMethod.addParameter(builderName.get(), "builder").addModifiers(FINAL);
+        constructorWriter.body().addSnippet("%s(builder);", initializeMethod.name());
+      } else {
+        constructorWriter.body().addSnippet("%s();", initializeMethod.name());
+      }
+    }
+  }
+
+  /**
+   * Returns a single snippet representing the initialization of the framework type.
+   *
+   * <p>Note that this must be a single snippet because initialization snippets can be invoked from
+   * any place in any order.  By requiring a single snippet (often of concatenated snippets) we
+   * ensure that things like local variables always behave as expected by the initialization logic.
+   */
+  private Snippet initializeFrameworkType(BindingKey bindingKey) {
+    ResolvedBindings resolvedBindings = graph.resolvedBindings().get(bindingKey);
+    
+    // There's no field for inherited bindings.
+    if (resolvedBindings.ownedBindings().isEmpty()) {
+      return Snippet.format("");
+    }
+    
+    switch (bindingKey.kind()) {
+      case CONTRIBUTION:
+        switch (contributionTypeFor(resolvedBindings.contributionBindings())) {
+          case SET:
+            return initializeSetMultibindings(resolvedBindings);
+          case MAP:
+            return initializeMapMultibindings(resolvedBindings);
+          case UNIQUE:
+            return initializeUniqueContributionBinding(resolvedBindings);
+          default:
+            throw new AssertionError();
+        }
+
+      case MEMBERS_INJECTION:
+        return initializeMembersInjectionBinding(resolvedBindings);
+
+      default:
+        throw new AssertionError();
+    }
+  }
+
+  private Snippet initializeSetMultibindings(ResolvedBindings resolvedBindings) {
+    ImmutableList.Builder<Snippet> initializationSnippets = ImmutableList.builder();
+
+    ImmutableList.Builder<Snippet> parameterSnippets = ImmutableList.builder();
+    for (ContributionBinding binding : resolvedBindings.contributionBindings()) {
+      Optional<MemberSelect> multibindingContributionSnippet =
+          getMultibindingContributionSnippet(binding);
+      checkState(multibindingContributionSnippet.isPresent(), "%s was not found", binding);
+      Snippet snippet = multibindingContributionSnippet.get().getSnippetFor(name);
+      if (multibindingContributionSnippet.get().owningClass().equals(name)
+          // the binding might already be initialized by a different set binding that shares the
+          // same contributions (e.g., Set<T> and Set<Produced<T>>)
+          && getContributionInitializationState(binding)
+              .equals(InitializationState.UNINITIALIZED)) {
+        Snippet initializeSnippet = initializeFactoryForContributionBinding(binding);
+        initializationSnippets.add(Snippet.format("this.%s = %s;", snippet, initializeSnippet));
+        setContributionInitializationState(binding, InitializationState.INITIALIZED);
+      }
+      parameterSnippets.add(snippet);
+    }
+    Class<?> factoryClass =
+        Iterables.all(resolvedBindings.contributionBindings(), Binding.Type.PROVISION)
+            ? SetFactory.class
+            : Util.isSetOfProduced(resolvedBindings.bindingKey().key().type())
+                ? SetOfProducedProducer.class
+                : SetProducer.class;
+    Snippet initializeSetSnippet =
+        Snippet.format(
+            "%s.create(%s)",
+            ClassName.fromClass(factoryClass),
+            makeParametersSnippet(parameterSnippets.build()));
+    initializationSnippets.add(
+        initializeMember(resolvedBindings.bindingKey(), initializeSetSnippet));
+
+    return Snippet.concat(initializationSnippets.build());
+  }
+
+  private Snippet initializeMapMultibindings(ResolvedBindings resolvedBindings) {
+    ImmutableList.Builder<Snippet> initializationSnippets = ImmutableList.builder();
+
+    if (any(resolvedBindings.contributionBindings(), Binding.Type.PRODUCTION)) {
+      // TODO(beder): Implement producer map bindings.
+      throw new IllegalStateException("producer map bindings not implemented yet");
+    }
+    for (ContributionBinding binding : resolvedBindings.contributionBindings()) {
+      Optional<MemberSelect> multibindingContributionSnippet =
+          getMultibindingContributionSnippet(binding);
+      if (!isMapWithNonProvidedValues(binding.key().type())
+          && multibindingContributionSnippet.isPresent()
+          && multibindingContributionSnippet.get().owningClass().equals(name)) {
+        initializationSnippets.add(
+            Snippet.format(
+                "this.%s = %s;",
+                multibindingContributionSnippet.get().getSnippetFor(name),
+                initializeFactoryForContributionBinding(binding)));
+      }
+    }
+    initializationSnippets.add(
+        initializeMember(
+            resolvedBindings.bindingKey(),
+            initializeMapBinding(resolvedBindings.contributionBindings())));
+
+    return Snippet.concat(initializationSnippets.build());
+  }
+
+  private Snippet initializeUniqueContributionBinding(ResolvedBindings resolvedBindings) {
+    ImmutableList.Builder<Snippet> initializationSnippets = ImmutableList.builder();
+
+    ContributionBinding binding = getOnlyElement(resolvedBindings.ownedContributionBindings());
+    if (!binding.factoryCreationStrategy().equals(ENUM_INSTANCE) || binding.scope().isPresent()) {
+      initializationSnippets.add(initializeDelegateFactories(binding));
+      initializationSnippets.add(
+          initializeMember(
+              resolvedBindings.bindingKey(), initializeFactoryForContributionBinding(binding)));
+    }
+
+    return Snippet.concat(initializationSnippets.build());
+  }
+
+  private Snippet initializeMembersInjectionBinding(ResolvedBindings resolvedBindings) {
+    ImmutableList.Builder<Snippet> initializationSnippets = ImmutableList.builder();
+
+    MembersInjectionBinding binding = resolvedBindings.membersInjectionBinding().get();
+    if (!binding.injectionStrategy().equals(MembersInjectionBinding.Strategy.NO_OP)) {
+      initializationSnippets.add(initializeDelegateFactories(binding));
+      initializationSnippets.add(
+          initializeMember(
+              resolvedBindings.bindingKey(), initializeMembersInjectorForBinding(binding)));
+    }
+
+    return Snippet.concat(initializationSnippets.build());
+  }
+
+  private Snippet initializeDelegateFactories(Binding binding) {
+    ImmutableList.Builder<Snippet> initializationSnippets = ImmutableList.builder();
+
+    for (Collection<DependencyRequest> requestsForKey :
+        indexDependenciesByUnresolvedKey(types, binding.dependencies()).asMap().values()) {
+      BindingKey dependencyKey =
+          Iterables.getOnlyElement(
+              FluentIterable.from(requestsForKey)
+                  .transform(DependencyRequest.BINDING_KEY_FUNCTION)
+                  .toSet());
+      if (!getMemberSelect(dependencyKey).staticMember()
+          && getInitializationState(dependencyKey).equals(UNINITIALIZED)) {
+        initializationSnippets.add(
+            Snippet.format(
+                "this.%s = new %s();",
+                getMemberSelectSnippet(dependencyKey),
+                ClassName.fromClass(DelegateFactory.class)));
+        setInitializationState(dependencyKey, DELEGATED);
+      }
+    }
+
+    return Snippet.concat(initializationSnippets.build());
+  }
+
+  private Snippet initializeMember(BindingKey bindingKey, Snippet initializationSnippet) {
+    ImmutableList.Builder<Snippet> initializationSnippets = ImmutableList.builder();
+
+    Snippet memberSelect = getMemberSelectSnippet(bindingKey);
+    Snippet delegateFactoryVariable = delegateFactoryVariableSnippet(bindingKey);
+    if (getInitializationState(bindingKey).equals(DELEGATED)) {
+      initializationSnippets.add(
+          Snippet.format(
+              "%1$s %2$s = (%1$s) %3$s;",
+              ClassName.fromClass(DelegateFactory.class),
+              delegateFactoryVariable,
+              memberSelect));
+    }
+    initializationSnippets.add(
+        Snippet.format("this.%s = %s;", memberSelect, initializationSnippet));
+    if (getInitializationState(bindingKey).equals(DELEGATED)) {
+      initializationSnippets.add(
+          Snippet.format("%s.setDelegatedProvider(%s);", delegateFactoryVariable, memberSelect));
+    }
+    setInitializationState(bindingKey, INITIALIZED);
+
+    return Snippet.concat(initializationSnippets.build());
+  }
+
+  private Snippet delegateFactoryVariableSnippet(BindingKey key) {
+    return Snippet.format("%sDelegate", getMemberSelectSnippet(key).toString().replace('.', '_'));
+  }
+
+  private Snippet initializeFactoryForContributionBinding(ContributionBinding binding) {
+    TypeName bindingKeyTypeName = TypeNames.forTypeMirror(binding.key().type());
+    switch (binding.bindingKind()) {
+      case COMPONENT:
+        return Snippet.format(
+            "%s.<%s>create(%s)",
+            ClassName.fromClass(InstanceFactory.class),
+            bindingKeyTypeName,
+            bindingKeyTypeName.equals(componentDefinitionTypeName())
+                ? "this"
+                : getComponentContributionSnippet(MoreTypes.asTypeElement(binding.key().type())));
+
+      case COMPONENT_PROVISION:
+        {
+          TypeElement bindingTypeElement =
+              graph.componentDescriptor().dependencyMethodIndex().get(binding.bindingElement());
+          String localFactoryVariable = simpleVariableName(bindingTypeElement);
+          Snippet callFactoryMethodSnippet =
+              Snippet.format(
+                  "%s.%s()",
+                  localFactoryVariable,
+                  binding.bindingElement().getSimpleName().toString());
+          // TODO(sameb): This throws a very vague NPE right now.  The stack trace doesn't
+          // help to figure out what the method or return type is.  If we include a string
+          // of the return type or method name in the error message, that can defeat obfuscation.
+          // We can easily include the raw type (no generics) + annotation type (no values),
+          // using .class & String.format -- but that wouldn't be the whole story.
+          // What should we do?
+          StringLiteral failMsg =
+              StringLiteral.forValue(CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD);
+          Snippet getMethodBody =
+              binding.nullableType().isPresent()
+                      || nullableValidationType.equals(Diagnostic.Kind.WARNING)
+                  ? Snippet.format("return %s;", callFactoryMethodSnippet)
+                  : Snippet.format(
+                      Joiner.on('\n')
+                          .join(
+                              "%s provided = %s;",
+                              "if (provided == null) {",
+                              "  throw new NullPointerException(%s);",
+                              "}",
+                              "return provided;"),
+                      bindingKeyTypeName,
+                      callFactoryMethodSnippet,
+                      failMsg);
+          return Snippet.format(
+              Joiner.on('\n')
+                  .join(
+                      "new %1$s<%2$s>() {",
+                      "  private final %5$s %6$s = %3$s;",
+                      "  %4$s@Override public %2$s get() {",
+                      "    %7$s",
+                      "  }",
+                      "}"),
+              /* 1 */ ClassName.fromClass(Factory.class),
+              /* 2 */ bindingKeyTypeName,
+              /* 3 */ getComponentContributionSnippet(bindingTypeElement),
+              /* 4 */ nullableSnippet(binding.nullableType()),
+              /* 5 */ TypeNames.forTypeMirror(bindingTypeElement.asType()),
+              /* 6 */ localFactoryVariable,
+              /* 7 */ getMethodBody);
+        }
+
+      case SUBCOMPONENT_BUILDER:
+        return Snippet.format(
+            Joiner.on('\n')
+                .join(
+                    "new %1$s<%2$s>() {",
+                    "  @Override public %2$s get() {",
+                    "    return %3$s();",
+                    "  }",
+                    "}"),
+            /* 1 */ ClassName.fromClass(Factory.class),
+            /* 2 */ bindingKeyTypeName,
+            /* 3 */ binding.bindingElement().getSimpleName().toString());
+        
+      case INJECTION:
+      case PROVISION:
+        {
+          List<Snippet> parameters =
+              Lists.newArrayListWithCapacity(binding.dependencies().size() + 1);
+          if (binding.bindingKind().equals(PROVISION)
+              && !binding.bindingElement().getModifiers().contains(STATIC)) {
+            parameters.add(getComponentContributionSnippet(binding.contributedBy().get()));
+          }
+          parameters.addAll(getDependencyParameters(binding));
+
+          Snippet factorySnippet =
+              Snippet.format(
+                  "%s.create(%s)",
+                  generatedClassNameForBinding(binding),
+                  Snippet.makeParametersSnippet(parameters));
+          return binding.scope().isPresent()
+              ? Snippet.format(
+                  "%s.create(%s)", ClassName.fromClass(ScopedProvider.class), factorySnippet)
+              : factorySnippet;
+        }
+
+      case COMPONENT_PRODUCTION:
+        {
+          TypeElement bindingTypeElement =
+              graph.componentDescriptor().dependencyMethodIndex().get(binding.bindingElement());
+          return Snippet.format(
+              Joiner.on('\n')
+                  .join(
+                      "new %1$s<%2$s>() {",
+                      "  private final %6$s %7$s = %4$s;",
+                      "  @Override public %3$s<%2$s> get() {",
+                      "    return %7$s.%5$s();",
+                      "  }",
+                      "}"),
+              /* 1 */ ClassName.fromClass(Producer.class),
+              /* 2 */ TypeNames.forTypeMirror(binding.key().type()),
+              /* 3 */ ClassName.fromClass(ListenableFuture.class),
+              /* 4 */ getComponentContributionSnippet(bindingTypeElement),
+              /* 5 */ binding.bindingElement().getSimpleName().toString(),
+              /* 6 */ TypeNames.forTypeMirror(bindingTypeElement.asType()),
+              /* 7 */ simpleVariableName(bindingTypeElement));
+        }
+
+      case IMMEDIATE:
+      case FUTURE_PRODUCTION:
+        {
+          List<Snippet> parameters =
+              Lists.newArrayListWithCapacity(binding.implicitDependencies().size() + 2);
+          if (!binding.bindingElement().getModifiers().contains(STATIC)) {
+            parameters.add(getComponentContributionSnippet(binding.bindingTypeElement()));
+          }
+          parameters.add(
+              getComponentContributionSnippet(
+                  graph.componentDescriptor().executorDependency().get()));
+          parameters.addAll(getProducerDependencyParameters(binding));
+
+          return Snippet.format(
+              "new %s(%s)",
+              generatedClassNameForBinding(binding),
+              Snippet.makeParametersSnippet(parameters));
+        }
+
+      default:
+        throw new AssertionError();
+    }
+  }
+
+  private Snippet nullableSnippet(Optional<DeclaredType> nullableType) {
+    return nullableType.isPresent()
+        ? Snippet.format("@%s ", TypeNames.forTypeMirror(nullableType.get()))
+        : Snippet.format("");
+  }
+
+  private Snippet initializeMembersInjectorForBinding(MembersInjectionBinding binding) {
+    switch (binding.injectionStrategy()) {
+      case NO_OP:
+        return Snippet.format("%s.noOp()", ClassName.fromClass(MembersInjectors.class));
+      case INJECT_MEMBERS:
+        List<Snippet> parameters = getDependencyParameters(binding);
+        return Snippet.format(
+            "%s.create(%s)",
+            membersInjectorNameForType(binding.bindingElement()),
+            Snippet.makeParametersSnippet(parameters));
+      default:
+        throw new AssertionError();
+    }
+  }
+
+  private List<Snippet> getDependencyParameters(Binding binding) {
+    ImmutableList.Builder<Snippet> parameters = ImmutableList.builder();
+    Set<Key> keysSeen = new HashSet<>();
+    for (Collection<DependencyRequest> requestsForKey :
+        indexDependenciesByUnresolvedKey(types, binding.implicitDependencies()).asMap().values()) {
+      Set<BindingKey> requestedBindingKeys = new HashSet<>();
+      for (DependencyRequest dependencyRequest : requestsForKey) {
+        Element requestElement = dependencyRequest.requestElement();
+        TypeMirror typeMirror = typeMirrorAsMemberOf(binding.bindingTypeElement(), requestElement);
+        Key key = keyFactory.forQualifiedType(dependencyRequest.key().qualifier(), typeMirror);
+        if (keysSeen.add(key)) {
+          requestedBindingKeys.add(dependencyRequest.bindingKey());
+        }
+      }
+      if (!requestedBindingKeys.isEmpty()) {
+        BindingKey key = Iterables.getOnlyElement(requestedBindingKeys);
+        parameters.add(getMemberSelect(key).getSnippetWithRawTypeCastFor(name));
+      }
+    }
+    return parameters.build();
+  }
+
+  // TODO(dpb): Investigate use of asMemberOf here. Why aren't the dependency requests already
+  // resolved?
+  private TypeMirror typeMirrorAsMemberOf(TypeElement bindingTypeElement, Element requestElement) {
+    TypeMirror requestType = requestElement.asType();
+    if (requestType.getKind() == TypeKind.TYPEVAR) {
+      return types.asMemberOf(
+          MoreTypes.asDeclared(bindingTypeElement.asType()),
+          (requestElement.getKind() == ElementKind.PARAMETER)
+              ? MoreTypes.asElement(requestType)
+              : requestElement);
+    } else {
+      return requestType;
+    }
+  }
+
+  private List<Snippet> getProducerDependencyParameters(Binding binding) {
+    ImmutableList.Builder<Snippet> parameters = ImmutableList.builder();
+    for (Collection<DependencyRequest> requestsForKey :
+        SourceFiles.indexDependenciesByUnresolvedKey(types, binding.implicitDependencies())
+            .asMap()
+            .values()) {
+      BindingKey key = Iterables.getOnlyElement(FluentIterable.from(requestsForKey)
+          .transform(DependencyRequest.BINDING_KEY_FUNCTION));
+      ResolvedBindings resolvedBindings = graph.resolvedBindings().get(key);
+      Class<?> frameworkClass =
+          DependencyRequestMapper.FOR_PRODUCER.getFrameworkClass(requestsForKey);
+      if (FrameworkField.frameworkClassForResolvedBindings(resolvedBindings).equals(Provider.class)
+          && frameworkClass.equals(Producer.class)) {
+        parameters.add(
+            Snippet.format(
+                "%s.producerFromProvider(%s)",
+                ClassName.fromClass(Producers.class),
+                getMemberSelectSnippet(key)));
+      } else {
+        parameters.add(getMemberSelectSnippet(key));
+      }
+    }
+    return parameters.build();
+  }
+
+  private Snippet initializeMapBinding(Set<ContributionBinding> bindings) {
+    // Get type information from the first binding.
+    ContributionBinding firstBinding = bindings.iterator().next();
+    DeclaredType mapType = asDeclared(firstBinding.key().type());
+
+    if (isMapWithNonProvidedValues(mapType)) {
+      return Snippet.format(
+          "%s.create(%s)",
+          ClassName.fromClass(MapFactory.class),
+          getMemberSelectSnippet(getOnlyElement(firstBinding.dependencies()).bindingKey()));
+    }
+
+    ImmutableList.Builder<dagger.internal.codegen.writer.Snippet> snippets =
+        ImmutableList.builder();
+    snippets.add(Snippet.format("%s.<%s, %s>builder(%d)",
+        ClassName.fromClass(MapProviderFactory.class),
+        TypeNames.forTypeMirror(getKeyTypeOfMap(mapType)),
+        TypeNames.forTypeMirror(getProvidedValueTypeOfMap(mapType)), // V of Map<K, Provider<V>>
+        bindings.size()));
+
+    for (ContributionBinding binding : bindings) {
+      snippets.add(
+          Snippet.format(
+              "    .put(%s, %s)",
+              getMapKeySnippet(binding.bindingElement()),
+              getMultibindingContributionSnippet(binding).get().getSnippetFor(name)));
+    }
+
+    snippets.add(Snippet.format("    .build()"));
+
+    return Snippet.concat(snippets.build());
+  }
+
+  private static String simpleVariableName(TypeElement typeElement) {
+    return UPPER_CAMEL.to(LOWER_CAMEL, typeElement.getSimpleName().toString());
+  }
+
+  /**
+   * Initialization state for a factory field.
+   */
+  enum InitializationState {
+    /** The field is {@code null}. */
+    UNINITIALIZED,
+
+    /** The field is set to a {@link DelegateFactory}. */
+    DELEGATED,
+
+    /** The field is set to an undelegated factory. */
+    INITIALIZED;
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/Binding.java b/compiler/src/main/java/dagger/internal/codegen/Binding.java
index edb8ad6b3..0a6b84052 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Binding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Binding.java
@@ -17,12 +17,17 @@
 
 import com.google.auto.common.MoreElements;
 import com.google.common.base.Optional;
+import com.google.common.base.Predicate;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Lists;
+import dagger.MembersInjector;
+import dagger.producers.Producer;
 import java.util.List;
 import java.util.Set;
+import javax.inject.Provider;
 import javax.lang.model.element.Element;
+import javax.lang.model.element.ElementVisitor;
 import javax.lang.model.element.Name;
 import javax.lang.model.element.PackageElement;
 import javax.lang.model.element.TypeElement;
@@ -47,6 +52,59 @@
  * @since 2.0
  */
 abstract class Binding {
+  
+  /**
+   * The subtype of this binding.
+   */
+  enum Type implements Predicate<Binding> {
+    /** A binding with this type is a {@link ProvisionBinding}. */
+    PROVISION(Provider.class),
+    /** A binding with this type is a {@link MembersInjectionBinding}. */
+    MEMBERS_INJECTION(MembersInjector.class),
+    /** A binding with this type is a {@link ProductionBinding}. */
+    PRODUCTION(Producer.class),
+    ;
+    
+    private final Class<?> frameworkClass;
+    
+    private Type(Class<?> frameworkClass) {
+      this.frameworkClass = frameworkClass;
+    }
+    
+    /**
+     * Returns the framework class associated with bindings of this type.
+     */
+    Class<?> frameworkClass() {
+      return frameworkClass;
+    }
+
+    BindingKey.Kind bindingKeyKind() {
+      switch (this) {
+        case MEMBERS_INJECTION:
+          return BindingKey.Kind.MEMBERS_INJECTION;
+        case PROVISION:
+        case PRODUCTION:
+          return BindingKey.Kind.CONTRIBUTION;
+        default:
+          throw new AssertionError();
+      }
+    }
+
+    @Override
+    public boolean apply(Binding binding) {
+      return this.equals(binding.bindingType());
+    }
+  }
+
+  abstract Binding.Type bindingType();
+
+  /**
+   * Returns the framework class associated with this binding.
+   */
+  Class<?> frameworkClass() {
+    return bindingType().frameworkClass();
+  }
+
   static Optional<String> bindingPackageFor(Iterable<? extends Binding> bindings) {
     ImmutableSet.Builder<String> bindingPackagesBuilder = ImmutableSet.builder();
     for (Binding binding : bindings) {
@@ -66,24 +124,31 @@
   /** The {@link Key} that is provided by this binding. */
   protected abstract Key key();
 
+  BindingKey bindingKey() {
+    return BindingKey.create(bindingType().bindingKeyKind(), key());
+  }
+
   /** Returns the {@link Element} instance that is responsible for declaring the binding. */
   abstract Element bindingElement();
 
   /** The type enclosing the binding {@link #bindingElement()}. */
   TypeElement bindingTypeElement() {
-    return bindingElement().accept(new SimpleElementVisitor6<TypeElement, Void>() {
-      @Override
-      protected TypeElement defaultAction(Element e, Void p) {
-        return MoreElements.asType(bindingElement().getEnclosingElement());
-      }
-
-      @Override
-      public TypeElement visitType(TypeElement e, Void p) {
-        return e;
-      }
-    }, null);
+    return BINDING_TYPE_ELEMENT.visit(bindingElement());
   }
 
+  private static final ElementVisitor<TypeElement, Void> BINDING_TYPE_ELEMENT =
+      new SimpleElementVisitor6<TypeElement, Void>() {
+        @Override
+        protected TypeElement defaultAction(Element e, Void p) {
+          return visit(e.getEnclosingElement());
+        }
+
+        @Override
+        public TypeElement visitType(TypeElement e, Void p) {
+          return e;
+        }
+      };
+
   /**
    * The explicit set of {@link DependencyRequest dependencies} required to satisfy this binding.
    */
@@ -160,31 +225,40 @@ public Void visitWildcard(WildcardType t, ImmutableSet.Builder<String> p) {
    */
   abstract boolean hasNonDefaultTypeParameters();
 
+  /**
+   * The scope of this binding.
+   */
+  Scope scope() {
+    return Scope.unscoped();
+  }
+
   // TODO(sameb): Remove the TypeElement parameter and pull it from the TypeMirror.
   static boolean hasNonDefaultTypeParameters(TypeElement element, TypeMirror type, Types types) {
     // If the element has no type parameters, nothing can be wrong.
     if (element.getTypeParameters().isEmpty()) {
       return false;
     }
-    
+
     List<TypeMirror> defaultTypes = Lists.newArrayList();
     for (TypeParameterElement parameter : element.getTypeParameters()) {
       defaultTypes.add(parameter.asType());
     }
-    
+
     List<TypeMirror> actualTypes =
-        type.accept(new SimpleTypeVisitor6<List<TypeMirror>, Void>() {
-          @Override
-          protected List<TypeMirror> defaultAction(TypeMirror e, Void p) {
-            return ImmutableList.of();
-          }
-
-          @Override
-          public List<TypeMirror> visitDeclared(DeclaredType t, Void p) {
-            return ImmutableList.copyOf(t.getTypeArguments());
-          }
-        }, null);
-    
+        type.accept(
+            new SimpleTypeVisitor6<List<TypeMirror>, Void>() {
+              @Override
+              protected List<TypeMirror> defaultAction(TypeMirror e, Void p) {
+                return ImmutableList.of();
+              }
+
+              @Override
+              public List<TypeMirror> visitDeclared(DeclaredType t, Void p) {
+                return ImmutableList.<TypeMirror>copyOf(t.getTypeArguments());
+              }
+            },
+            null);
+
     // The actual type parameter size can be different if the user is using a raw type.
     if (defaultTypes.size() != actualTypes.size()) {
       return true;
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
index 68da53502..b95143803 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
@@ -17,26 +17,38 @@
 
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
-import com.google.common.base.Equivalence;
 import com.google.common.base.Function;
 import com.google.common.base.Optional;
+import com.google.common.cache.Cache;
+import com.google.common.cache.CacheBuilder;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ImmutableSetMultimap;
+import com.google.common.collect.Iterables;
 import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
 import com.google.common.collect.Sets;
+import com.google.common.collect.TreeTraverser;
 import dagger.Component;
+import dagger.Subcomponent;
+import dagger.internal.codegen.Binding.Type;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
+import dagger.producers.Producer;
 import dagger.producers.ProductionComponent;
 import java.util.ArrayDeque;
+import java.util.Collection;
 import java.util.Deque;
+import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Map.Entry;
+import java.util.Set;
+import java.util.concurrent.Callable;
+import java.util.concurrent.ExecutionException;
 import java.util.concurrent.Executor;
+import javax.inject.Inject;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
@@ -44,12 +56,20 @@
 import javax.lang.model.util.Elements;
 
 import static com.google.auto.common.MoreElements.getAnnotationMirror;
+import static com.google.common.base.Predicates.in;
+import static com.google.common.base.Verify.verify;
+import static com.google.common.collect.Iterables.any;
+import static com.google.common.collect.Sets.union;
+import static dagger.internal.codegen.BindingKey.Kind.CONTRIBUTION;
 import static dagger.internal.codegen.ComponentDescriptor.isComponentContributionMethod;
 import static dagger.internal.codegen.ComponentDescriptor.isComponentProductionMethod;
+import static dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor.isOfKind;
+import static dagger.internal.codegen.ComponentDescriptor.ComponentMethodKind.SUBCOMPONENT_BUILDER;
 import static dagger.internal.codegen.ComponentDescriptor.Kind.PRODUCTION_COMPONENT;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
-import static dagger.internal.codegen.MembersInjectionBinding.Strategy.DELEGATE;
+import static dagger.internal.codegen.MembersInjectionBinding.Strategy.INJECT_MEMBERS;
 import static dagger.internal.codegen.MembersInjectionBinding.Strategy.NO_OP;
+import static javax.lang.model.element.Modifier.STATIC;
 
 /**
  * The canonical representation of a full-resolved graph.
@@ -62,61 +82,107 @@
   abstract ImmutableMap<BindingKey, ResolvedBindings> resolvedBindings();
   abstract ImmutableMap<ExecutableElement, BindingGraph> subgraphs();
 
+  /**
+   * Returns the set of modules that are owned by this graph regardless of whether or not any of
+   * their bindings are used in this graph. For graphs representing top-level {@link Component
+   * components}, this set will be the same as
+   * {@linkplain ComponentDescriptor#transitiveModules the component's transitive modules}. For
+   * {@linkplain Subcomponent subcomponents}, this set will be the transitive modules that are not
+   * owned by any of their ancestors.
+   */
+  abstract ImmutableSet<ModuleDescriptor> ownedModules();
+
+  ImmutableSet<TypeElement> ownedModuleTypes() {
+    return FluentIterable.from(ownedModules())
+        .transform(ModuleDescriptor.getModuleElement())
+        .toSet();
+  }
+
+  private static final TreeTraverser<BindingGraph> SUBGRAPH_TRAVERSER =
+      new TreeTraverser<BindingGraph>() {
+        @Override
+        public Iterable<BindingGraph> children(BindingGraph node) {
+          return node.subgraphs().values();
+        }
+      };
+
   /**
    * Returns the set of types necessary to implement the component, but are not part of the injected
    * graph.  This includes modules, component dependencies and an {@link Executor} in the case of
    * {@link ProductionComponent}.
    */
   ImmutableSet<TypeElement> componentRequirements() {
-    return FluentIterable.from(componentDescriptor().transitiveModules())
-        .transform(new Function<ModuleDescriptor, TypeElement>() {
-          @Override public TypeElement apply(ModuleDescriptor input) {
-            return input.moduleElement();
-          }
-        })
+    return SUBGRAPH_TRAVERSER
+        .preOrderTraversal(this)
+        .transformAndConcat(
+            new Function<BindingGraph, Iterable<ResolvedBindings>>() {
+              @Override
+              public Iterable<ResolvedBindings> apply(BindingGraph input) {
+                return input.resolvedBindings().values();
+              }
+            })
+        .transformAndConcat(
+            new Function<ResolvedBindings, Set<ContributionBinding>>() {
+              @Override
+              public Set<ContributionBinding> apply(ResolvedBindings input) {
+                return (input.bindingKey().kind().equals(CONTRIBUTION))
+                    ? input.contributionBindings()
+                    : ImmutableSet.<ContributionBinding>of();
+              }
+            })
+        .transformAndConcat(
+            new Function<ContributionBinding, Set<TypeElement>>() {
+              @Override
+              public Set<TypeElement> apply(ContributionBinding input) {
+                return input.bindingElement().getModifiers().contains(STATIC)
+                    ? ImmutableSet.<TypeElement>of()
+                    : input.contributedBy().asSet();
+              }
+            })
+        .filter(in(ownedModuleTypes()))
         .append(componentDescriptor().dependencies())
         .append(componentDescriptor().executorDependency().asSet())
         .toSet();
   }
 
+  ImmutableSet<TypeElement> availableDependencies() {
+    return new ImmutableSet.Builder<TypeElement>()
+        .addAll(componentDescriptor().transitiveModuleTypes())
+        .addAll(componentDescriptor().dependencies())
+        .addAll(componentDescriptor().executorDependency().asSet())
+        .build();
+  }
+
   static final class Factory {
     private final Elements elements;
     private final InjectBindingRegistry injectBindingRegistry;
     private final Key.Factory keyFactory;
-    private final DependencyRequest.Factory dependencyRequestFactory;
     private final ProvisionBinding.Factory provisionBindingFactory;
     private final ProductionBinding.Factory productionBindingFactory;
 
     Factory(Elements elements,
         InjectBindingRegistry injectBindingRegistry,
         Key.Factory keyFactory,
-        DependencyRequest.Factory dependencyRequestFactory,
         ProvisionBinding.Factory provisionBindingFactory,
         ProductionBinding.Factory productionBindingFactory) {
       this.elements = elements;
       this.injectBindingRegistry = injectBindingRegistry;
       this.keyFactory = keyFactory;
-      this.dependencyRequestFactory = dependencyRequestFactory;
       this.provisionBindingFactory = provisionBindingFactory;
       this.productionBindingFactory = productionBindingFactory;
     }
 
     BindingGraph create(ComponentDescriptor componentDescriptor) {
-      return create(Optional.<RequestResolver>absent(), componentDescriptor);
+      return create(Optional.<Resolver>absent(), componentDescriptor);
     }
 
-    private BindingGraph create(Optional<RequestResolver> parentResolver,
-        ComponentDescriptor componentDescriptor) {
-      ImmutableSet.Builder<ProvisionBinding> explicitProvisionBindingsBuilder =
-          ImmutableSet.builder();
-      ImmutableSet.Builder<ProductionBinding> explicitProductionBindingsBuilder =
-          ImmutableSet.builder();
+    private BindingGraph create(
+        Optional<Resolver> parentResolver, ComponentDescriptor componentDescriptor) {
+      ImmutableSet.Builder<ContributionBinding> explicitBindingsBuilder = ImmutableSet.builder();
 
       // binding for the component itself
       TypeElement componentDefinitionType = componentDescriptor.componentDefinitionType();
-      ProvisionBinding componentBinding =
-          provisionBindingFactory.forComponent(componentDefinitionType);
-      explicitProvisionBindingsBuilder.add(componentBinding);
+      explicitBindingsBuilder.add(provisionBindingFactory.forComponent(componentDefinitionType));
 
       // Collect Component dependencies.
       Optional<AnnotationMirror> componentMirror =
@@ -126,42 +192,43 @@ private BindingGraph create(Optional<RequestResolver> parentResolver,
           ? MoreTypes.asTypeElements(getComponentDependencies(componentMirror.get()))
           : ImmutableSet.<TypeElement>of();
       for (TypeElement componentDependency : componentDependencyTypes) {
-        explicitProvisionBindingsBuilder.add(
-            provisionBindingFactory.forComponent(componentDependency));
+        explicitBindingsBuilder.add(provisionBindingFactory.forComponent(componentDependency));
         List<ExecutableElement> dependencyMethods =
             ElementFilter.methodsIn(elements.getAllMembers(componentDependency));
         for (ExecutableElement method : dependencyMethods) {
           // MembersInjection methods aren't "provided" explicitly, so ignore them.
           if (isComponentContributionMethod(elements, method)) {
-            if (componentDescriptor.kind().equals(PRODUCTION_COMPONENT)
-                && isComponentProductionMethod(elements, method)) {
-              explicitProductionBindingsBuilder.add(
-                  productionBindingFactory.forComponentMethod(method));
-            } else {
-              explicitProvisionBindingsBuilder.add(
-                  provisionBindingFactory.forComponentMethod(method));
-            }
+            explicitBindingsBuilder.add(
+                componentDescriptor.kind().equals(PRODUCTION_COMPONENT)
+                        && isComponentProductionMethod(elements, method)
+                    ? productionBindingFactory.forComponentMethod(method)
+                    : provisionBindingFactory.forComponentMethod(method));
           }
         }
       }
 
+      // Bindings for subcomponent builders.
+      for (ComponentMethodDescriptor subcomponentMethodDescriptor :
+          Iterables.filter(
+              componentDescriptor.subcomponents().keySet(), isOfKind(SUBCOMPONENT_BUILDER))) {
+        explicitBindingsBuilder.add(
+            provisionBindingFactory.forSubcomponentBuilderMethod(
+                subcomponentMethodDescriptor.methodElement(),
+                componentDescriptor.componentDefinitionType()));
+      }
+
       // Collect transitive module bindings.
       for (ModuleDescriptor moduleDescriptor : componentDescriptor.transitiveModules()) {
         for (ContributionBinding binding : moduleDescriptor.bindings()) {
-          if (binding instanceof ProvisionBinding) {
-            explicitProvisionBindingsBuilder.add((ProvisionBinding) binding);
-          }
-          if (binding instanceof ProductionBinding) {
-            explicitProductionBindingsBuilder.add((ProductionBinding) binding);
-          }
+          explicitBindingsBuilder.add(binding);
         }
       }
 
-      RequestResolver requestResolver = new RequestResolver(
-          parentResolver,
-          componentDescriptor.wrappedScope(),
-          explicitBindingsByKey(explicitProvisionBindingsBuilder.build()),
-          explicitBindingsByKey(explicitProductionBindingsBuilder.build()));
+      Resolver requestResolver =
+          new Resolver(
+              parentResolver,
+              componentDescriptor,
+              explicitBindingsByKey(explicitBindingsBuilder.build()));
       for (ComponentMethodDescriptor componentMethod : componentDescriptor.componentMethods()) {
         Optional<DependencyRequest> componentMethodRequest = componentMethod.dependencyRequest();
         if (componentMethodRequest.isPresent()) {
@@ -171,16 +238,26 @@ private BindingGraph create(Optional<RequestResolver> parentResolver,
 
       ImmutableMap.Builder<ExecutableElement, BindingGraph> subgraphsBuilder =
           ImmutableMap.builder();
-      for (Entry<ExecutableElement, ComponentDescriptor> subcomponentEntry :
+      for (Entry<ComponentMethodDescriptor, ComponentDescriptor> subcomponentEntry :
           componentDescriptor.subcomponents().entrySet()) {
-        subgraphsBuilder.put(subcomponentEntry.getKey(),
+        subgraphsBuilder.put(
+            subcomponentEntry.getKey().methodElement(),
             create(Optional.of(requestResolver), subcomponentEntry.getValue()));
       }
 
+      for (ResolvedBindings resolvedBindings : requestResolver.getResolvedBindings().values()) {
+        verify(
+            resolvedBindings.owningComponent().equals(componentDescriptor),
+            "%s is not owned by %s",
+            resolvedBindings,
+            componentDescriptor);
+      }
+
       return new AutoValue_BindingGraph(
           componentDescriptor,
           requestResolver.getResolvedBindings(),
-          subgraphsBuilder.build());
+          subgraphsBuilder.build(),
+          requestResolver.getOwnedModules());
     }
 
     private <B extends ContributionBinding> ImmutableSetMultimap<Key, B> explicitBindingsByKey(
@@ -193,129 +270,175 @@ private BindingGraph create(Optional<RequestResolver> parentResolver,
       return builder.build();
     }
 
-    private final class RequestResolver {
-      final Optional<RequestResolver> parentResolver;
-      final Optional<Equivalence.Wrapper<AnnotationMirror>> targetScope;
-      final ImmutableSetMultimap<Key, ProvisionBinding> explicitProvisionBindings;
-      final ImmutableSetMultimap<Key, ProductionBinding> explicitProductionBindings;
+    private final class Resolver {
+      final Optional<Resolver> parentResolver;
+      final ComponentDescriptor componentDescriptor;
+      final ImmutableSetMultimap<Key, ContributionBinding> explicitBindings;
+      final ImmutableSet<ContributionBinding> explicitBindingsSet;
       final Map<BindingKey, ResolvedBindings> resolvedBindings;
       final Deque<BindingKey> cycleStack = new ArrayDeque<>();
+      final Cache<BindingKey, Boolean> dependsOnLocalMultibindingsCache =
+          CacheBuilder.newBuilder().<BindingKey, Boolean>build();
 
-      RequestResolver(Optional<RequestResolver> parentResolver,
-          Optional<Equivalence.Wrapper<AnnotationMirror>> targetScope,
-          ImmutableSetMultimap<Key, ProvisionBinding> explicitProvisionBindings,
-          ImmutableSetMultimap<Key, ProductionBinding> explicitProductionBindings) {
+      Resolver(
+          Optional<Resolver> parentResolver,
+          ComponentDescriptor componentDescriptor,
+          ImmutableSetMultimap<Key, ContributionBinding> explicitBindings) {
         assert parentResolver != null;
         this.parentResolver = parentResolver;
-        assert targetScope != null;
-        this.targetScope = targetScope;
-        assert explicitProvisionBindings != null;
-        this.explicitProvisionBindings = explicitProvisionBindings;
-        assert explicitProductionBindings != null;
-        this.explicitProductionBindings = explicitProductionBindings;
+        assert componentDescriptor != null;
+        this.componentDescriptor = componentDescriptor;
+        assert explicitBindings != null;
+        this.explicitBindings = explicitBindings;
+        this.explicitBindingsSet = ImmutableSet.copyOf(explicitBindings.values());
         this.resolvedBindings = Maps.newLinkedHashMap();
       }
 
       /**
-       *  Looks up the bindings associated with a given dependency request and returns them.  In the
-       *  event that the binding is owned by a parent component it will trigger resolution in that
-       *  component's resolver but will return an {@link Optional#absent} value.
+       * Looks up the bindings associated with a given dependency request and returns them.
+       *
+       * <p>Requests for {@code Map<K, V>} for which there are only bindings for
+       * {@code Map<K, Provider<V>>} will resolve to a single implicit binding for the latter map
+       * (and similarly for {@link Producer}s).
+       *
+       * <p>If there are no explicit bindings for a contribution, looks for implicit
+       * {@link Inject @Inject}-annotated constructor types.
        */
       ResolvedBindings lookUpBindings(DependencyRequest request) {
         BindingKey bindingKey = request.bindingKey();
         switch (bindingKey.kind()) {
           case CONTRIBUTION:
             // First, check for explicit keys (those from modules and components)
-            ImmutableSet<ProvisionBinding> explicitProvisionBindingsForKey =
-                getExplicitProvisionBindings(bindingKey.key());
-            ImmutableSet<ProductionBinding> explicitProductionBindingsForKey =
-                getExplicitProductionBindings(bindingKey.key());
+            ImmutableSet<ContributionBinding> explicitBindingsForKey =
+                getExplicitBindings(bindingKey.key());
 
             // If the key is Map<K, V>, get its implicit binding keys, which are either
             // Map<K, Provider<V>> or Map<K, Producer<V>>, and grab their explicit bindings.
             Optional<Key> mapProviderKey = keyFactory.implicitMapProviderKeyFrom(bindingKey.key());
-            ImmutableSet<ProvisionBinding> explicitMapProvisionBindings = ImmutableSet.of();
+            ImmutableSet.Builder<ContributionBinding> explicitMapBindingsBuilder =
+                ImmutableSet.builder();
             if (mapProviderKey.isPresent()) {
-              explicitMapProvisionBindings = getExplicitProvisionBindings(mapProviderKey.get());
+              explicitMapBindingsBuilder.addAll(getExplicitBindings(mapProviderKey.get()));
             }
 
             Optional<Key> mapProducerKey = keyFactory.implicitMapProducerKeyFrom(bindingKey.key());
-            ImmutableSet<ProductionBinding> explicitMapProductionBindings = ImmutableSet.of();
             if (mapProducerKey.isPresent()) {
-              explicitMapProductionBindings = getExplicitProductionBindings(mapProducerKey.get());
+              explicitMapBindingsBuilder.addAll(getExplicitBindings(mapProducerKey.get()));
             }
-
-            if (!explicitProvisionBindingsForKey.isEmpty()
-                || !explicitProductionBindingsForKey.isEmpty()) {
-              // we have some explicit binding for this key, so we collect all explicit implicit map
-              // bindings that might conflict with this and let the validator sort it out
-              ImmutableSet.Builder<ContributionBinding> ownedBindings = ImmutableSet.builder();
-              ImmutableSet.Builder<ContributionBinding> inheritedBindings = ImmutableSet.builder();
-              for (ProvisionBinding provisionBinding :
-                  Sets.union(explicitProvisionBindingsForKey, explicitMapProvisionBindings)) {
-                Optional<RequestResolver> owningResolver = getOwningResolver(provisionBinding);
-                if (owningResolver.isPresent() && !owningResolver.get().equals(this)) {
-                  owningResolver.get().resolve(request);
-                  inheritedBindings.add(provisionBinding);
-                } else {
-                  ownedBindings.add(provisionBinding);
-                }
+            ImmutableSet<ContributionBinding> explicitMapBindings =
+                explicitMapBindingsBuilder.build();
+
+            // If the key is Set<Produced<T>>, then we look up bindings by the alternate key Set<T>.
+            Optional<Key> setKeyFromProduced =
+                keyFactory.implicitSetKeyFromProduced(bindingKey.key());
+            ImmutableSet<ContributionBinding> explicitSetBindings =
+                setKeyFromProduced.isPresent()
+                    ? getExplicitBindings(setKeyFromProduced.get())
+                    : ImmutableSet.<ContributionBinding>of();
+
+            if (!explicitBindingsForKey.isEmpty() || !explicitSetBindings.isEmpty()) {
+              /* If there are any explicit bindings for this key, then combine those with any
+               * conflicting Map<K, Provider<V>> bindings and let the validator fail. */
+              ImmutableSetMultimap.Builder<ComponentDescriptor, ContributionBinding> bindings =
+                  ImmutableSetMultimap.builder();
+              for (ContributionBinding binding :
+                  union(explicitBindingsForKey, union(explicitSetBindings, explicitMapBindings))) {
+                bindings.put(getOwningComponent(request, binding), binding);
               }
-              return ResolvedBindings.create(bindingKey,
-                  ownedBindings
-                      .addAll(explicitProductionBindingsForKey)
-                      .addAll(explicitMapProductionBindings)
-                      .build(),
-                  inheritedBindings.build());
+              return ResolvedBindings.forContributionBindings(
+                  bindingKey, componentDescriptor, bindings.build());
+            } else if (any(explicitMapBindings, Binding.Type.PRODUCTION)) {
+              /* If this binding is for Map<K, V> and there are no explicit Map<K, V> bindings but
+               * some explicit Map<K, Producer<V>> bindings, then this binding must have only the
+               * implicit dependency on Map<K, Producer<V>>. */
+              return ResolvedBindings.forContributionBindings(
+                  bindingKey,
+                  componentDescriptor,
+                  productionBindingFactory.implicitMapOfProducerBinding(request));
+            } else if (any(explicitMapBindings, Binding.Type.PROVISION)) {
+              /* If this binding is for Map<K, V> and there are no explicit Map<K, V> bindings but
+               * some explicit Map<K, Provider<V>> bindings, then this binding must have only the
+               * implicit dependency on Map<K, Provider<V>>. */
+              return ResolvedBindings.forContributionBindings(
+                  bindingKey,
+                  componentDescriptor,
+                  provisionBindingFactory.implicitMapOfProviderBinding(request));
             } else {
-              if (!explicitMapProductionBindings.isEmpty()) {
-                // if we have any explicit Map<K, Producer<V>> bindings, then this Map<K, V> binding
-                // must be considered an implicit ProductionBinding
-                DependencyRequest implicitRequest =
-                    dependencyRequestFactory.forImplicitMapBinding(request, mapProducerKey.get());
-                return ResolvedBindings.create(bindingKey,
-                    productionBindingFactory.forImplicitMapBinding(request, implicitRequest));
-              } else if (!explicitMapProvisionBindings.isEmpty()) {
-                // if there are Map<K, Provider<V>> bindings, then it'll be an implicit
-                // ProvisionBinding
-                DependencyRequest implicitRequest =
-                    dependencyRequestFactory.forImplicitMapBinding(request, mapProviderKey.get());
-                return ResolvedBindings.create(bindingKey,
-                    provisionBindingFactory.forImplicitMapBinding(request, implicitRequest));
-              } else {
-                // no explicit binding, look it up.
-                Optional<ProvisionBinding> provisionBinding =
-                    injectBindingRegistry.getOrFindProvisionBinding(bindingKey.key());
-                if (provisionBinding.isPresent()) {
-                  Optional<RequestResolver> owningResolver =
-                      getOwningResolver(provisionBinding.get());
-                  if (owningResolver.isPresent() && !owningResolver.get().equals(this)) {
-                    owningResolver.get().resolve(request);
-                    return ResolvedBindings.create(
-                        bindingKey, ImmutableSet.<Binding>of(),
-                        provisionBinding.asSet());
-                  }
-                }
-                return ResolvedBindings.create(
-                    bindingKey, provisionBinding.asSet(), ImmutableSet.<Binding>of());
-              }
+              /* If there are no explicit bindings at all, look for an implicit @Inject-constructed
+               * binding. */
+              Optional<ProvisionBinding> provisionBinding =
+                  injectBindingRegistry.getOrFindProvisionBinding(bindingKey.key());
+              ComponentDescriptor owningComponent =
+                  provisionBinding.isPresent()
+                          && isResolvedInParent(request, provisionBinding.get())
+                          && !shouldOwnParentBinding(request, provisionBinding.get())
+                      ? getOwningResolver(provisionBinding.get()).get().componentDescriptor
+                      : componentDescriptor;
+              return ResolvedBindings.forContributionBindings(
+                  bindingKey,
+                  componentDescriptor,
+                  ImmutableSetMultimap.<ComponentDescriptor, ContributionBinding>builder()
+                      .putAll(owningComponent, provisionBinding.asSet())
+                      .build());
             }
+
           case MEMBERS_INJECTION:
             // no explicit deps for members injection, so just look it up
-            return ResolvedBindings.create(
-                bindingKey, rollUpMembersInjectionBindings(bindingKey.key()));
+            return ResolvedBindings.forMembersInjectionBinding(
+                bindingKey, componentDescriptor, rollUpMembersInjectionBindings(bindingKey.key()));
           default:
             throw new AssertionError();
         }
       }
 
+      /**
+       * If {@code binding} should be owned by a parent component, resolves the binding in that
+       * component's resolver and returns that component. Otherwise returns the component for this
+       * resolver.
+       */
+      private ComponentDescriptor getOwningComponent(
+          DependencyRequest request, ContributionBinding binding) {
+        return isResolvedInParent(request, binding) && !shouldOwnParentBinding(request, binding)
+            ? getOwningResolver(binding).get().componentDescriptor
+            : componentDescriptor;
+      }
+
+      /**
+       * Returns {@code true} if {@code binding} is owned by a parent resolver. If so, calls
+       * {@link #resolve(DependencyRequest) resolve(request)} on that resolver.
+       */
+      private boolean isResolvedInParent(DependencyRequest request, ContributionBinding binding) {
+        Optional<Resolver> owningResolver = getOwningResolver(binding);
+        if (owningResolver.isPresent() && !owningResolver.get().equals(this)) {
+          owningResolver.get().resolve(request);
+          return true;
+        } else {
+          return false;
+        }
+      }
+
+      /**
+       * Returns {@code true} if {@code binding}, which was previously resolved by a parent
+       * resolver, should be moved into this resolver's bindings for {@code request} because it is
+       * unscoped and {@linkplain #dependsOnLocalMultibindings(ResolvedBindings) depends on local
+       * multibindings}, or {@code false} if it can satisfy {@code request} as an inherited binding.
+       */
+      private boolean shouldOwnParentBinding(
+          DependencyRequest request, ContributionBinding binding) {
+        return !binding.scope().isPresent()
+            && dependsOnLocalMultibindings(
+                getPreviouslyResolvedBindings(request.bindingKey()).get());
+      }
+
       private MembersInjectionBinding rollUpMembersInjectionBindings(Key key) {
         MembersInjectionBinding membersInjectionBinding =
             injectBindingRegistry.getOrFindMembersInjectionBinding(key);
 
-        if (membersInjectionBinding.injectionStrategy().equals(DELEGATE)) {
-          MembersInjectionBinding parentBinding = rollUpMembersInjectionBindings(
-              membersInjectionBinding.parentInjectorRequest().get().key());
+        if (membersInjectionBinding.parentInjectorRequest().isPresent()
+            && membersInjectionBinding.injectionStrategy().equals(INJECT_MEMBERS)) {
+          MembersInjectionBinding parentBinding =
+              rollUpMembersInjectionBindings(
+                  membersInjectionBinding.parentInjectorRequest().get().key());
           if (parentBinding.injectionStrategy().equals(NO_OP)) {
             return membersInjectionBinding.withoutParentInjectorRequest();
           }
@@ -324,28 +447,30 @@ private MembersInjectionBinding rollUpMembersInjectionBindings(Key key) {
         return membersInjectionBinding;
       }
 
-      private Optional<RequestResolver> getOwningResolver(ProvisionBinding provisionBinding) {
-        Optional<Equivalence.Wrapper<AnnotationMirror>> bindingScope =
-            provisionBinding.wrappedScope();
-        for (RequestResolver requestResolver : getResolverLineage().reverse()) {
-          if (requestResolver.explicitProvisionBindings.containsValue(provisionBinding)) {
-             return Optional.of(requestResolver);
+      private Optional<Resolver> getOwningResolver(ContributionBinding provisionBinding) {
+        for (Resolver requestResolver : getResolverLineage().reverse()) {
+          if (requestResolver.explicitBindingsSet.contains(provisionBinding)) {
+            return Optional.of(requestResolver);
           }
         }
+
         // look for scope separately.  we do this for the case where @Singleton can appear twice
         // in the † compatibility mode
-        for (RequestResolver requestResolver : getResolverLineage().reverse()) {
-          if (bindingScope.isPresent() && bindingScope.equals(requestResolver.targetScope)) {
-            return Optional.of(requestResolver);
+        Scope bindingScope = provisionBinding.scope();
+        if (bindingScope.isPresent()) {
+          for (Resolver requestResolver : getResolverLineage().reverse()) {
+            if (bindingScope.equals(requestResolver.componentDescriptor.scope())) {
+              return Optional.of(requestResolver);
+            }
           }
         }
         return Optional.absent();
       }
 
       /** Returns the resolver lineage from parent to child. */
-      private ImmutableList<RequestResolver> getResolverLineage() {
-        List<RequestResolver> resolverList = Lists.newArrayList();
-        for (Optional<RequestResolver> currentResolver = Optional.of(this);
+      private ImmutableList<Resolver> getResolverLineage() {
+        List<Resolver> resolverList = Lists.newArrayList();
+        for (Optional<Resolver> currentResolver = Optional.of(this);
             currentResolver.isPresent();
             currentResolver = currentResolver.get().parentResolver) {
           resolverList.add(currentResolver.get());
@@ -353,20 +478,10 @@ private MembersInjectionBinding rollUpMembersInjectionBindings(Key key) {
         return ImmutableList.copyOf(Lists.reverse(resolverList));
       }
 
-      private ImmutableSet<ProvisionBinding> getExplicitProvisionBindings(Key requestKey) {
-        ImmutableSet.Builder<ProvisionBinding> explicitBindingsForKey = ImmutableSet.builder();
-        for (RequestResolver resolver : getResolverLineage()) {
-          explicitBindingsForKey.addAll(
-              resolver.explicitProvisionBindings.get(requestKey));
-        }
-        return explicitBindingsForKey.build();
-      }
-
-      private ImmutableSet<ProductionBinding> getExplicitProductionBindings(Key requestKey) {
-        ImmutableSet.Builder<ProductionBinding> explicitBindingsForKey = ImmutableSet.builder();
-        for (RequestResolver resolver : getResolverLineage()) {
-          explicitBindingsForKey.addAll(
-              resolver.explicitProductionBindings.get(requestKey));
+      private ImmutableSet<ContributionBinding> getExplicitBindings(Key requestKey) {
+        ImmutableSet.Builder<ContributionBinding> explicitBindingsForKey = ImmutableSet.builder();
+        for (Resolver resolver : getResolverLineage()) {
+          explicitBindingsForKey.addAll(resolver.explicitBindings.get(requestKey));
         }
         return explicitBindingsForKey.build();
       }
@@ -386,19 +501,26 @@ private MembersInjectionBinding rollUpMembersInjectionBindings(Key key) {
       void resolve(DependencyRequest request) {
         BindingKey bindingKey = request.bindingKey();
 
-        Optional<ResolvedBindings> previouslyResolvedBinding =
-            getPreviouslyResolvedBindings(bindingKey);
-        if (previouslyResolvedBinding.isPresent()
-            && !(bindingKey.kind().equals(BindingKey.Kind.CONTRIBUTION)
-                && !previouslyResolvedBinding.get().contributionBindings().isEmpty()
-                && ContributionBinding.bindingTypeFor(
-                    previouslyResolvedBinding.get().contributionBindings()).isMultibinding())) {
+        // If we find a cycle, stop resolving. The original request will add it with all of the
+        // other resolved deps.
+        if (cycleStack.contains(bindingKey)) {
           return;
         }
 
-        if (cycleStack.contains(bindingKey)) {
-          // We found a cycle. Don't add a resolved binding, since the original request will add it
-          // with all of the other resolved deps
+        // If the binding was previously resolved in this (sub)component, don't resolve it again.
+        if (resolvedBindings.containsKey(bindingKey)) {
+          return;
+        }
+
+        // If the binding was previously resolved in a supercomponent, then test to see if it
+        // depends on multibindings with contributions from this subcomponent. If it does, then we
+        // have to resolve it in this subcomponent so that it sees the local contributions. If it
+        // does not, then we can stop resolving it in this subcomponent and rely on the
+        // supercomponent resolution.
+        Optional<ResolvedBindings> bindingsPreviouslyResolvedInParent =
+            getPreviouslyResolvedBindings(bindingKey);
+        if (bindingsPreviouslyResolvedInParent.isPresent()
+            && !dependsOnLocalMultibindings(bindingsPreviouslyResolvedInParent.get())) {
           return;
         }
 
@@ -416,28 +538,90 @@ void resolve(DependencyRequest request) {
         }
       }
 
+      /**
+       * Returns {@code true} if {@code previouslyResolvedBindings} is multibindings with
+       * contributions declared within this (sub)component's modules, or if any of its unscoped
+       * provision-dependencies depend on such local multibindings.
+       *
+       * <p>We don't care about scoped dependencies or production bindings because they will never
+       * depend on multibindings with contributions from subcomponents.
+       */
+      private boolean dependsOnLocalMultibindings(ResolvedBindings previouslyResolvedBindings) {
+        return dependsOnLocalMultibindings(previouslyResolvedBindings, new HashSet<BindingKey>());
+      }
+
+      private boolean dependsOnLocalMultibindings(
+          final ResolvedBindings previouslyResolvedBindings, final Set<BindingKey> cycleChecker) {
+        // Don't recur infinitely if there are valid cycles in the dependency graph.
+        if (!cycleChecker.add(previouslyResolvedBindings.bindingKey())) {
+          return false;
+        }
+        try {
+          return dependsOnLocalMultibindingsCache.get(
+              previouslyResolvedBindings.bindingKey(),
+              new Callable<Boolean>() {
+                @Override
+                public Boolean call() {
+                  if (previouslyResolvedBindings.isMultibindings()
+                      && hasLocalContributions(previouslyResolvedBindings)) {
+                    return true;
+                  }
+
+                  for (Binding binding : previouslyResolvedBindings.bindings()) {
+                    if (!binding.scope().isPresent()
+                        && !binding.bindingType().equals(Type.PRODUCTION)) {
+                      for (DependencyRequest dependency : binding.implicitDependencies()) {
+                        if (dependsOnLocalMultibindings(
+                            getPreviouslyResolvedBindings(dependency.bindingKey()).get(),
+                            cycleChecker)) {
+                          return true;
+                        }
+                      }
+                    }
+                  }
+                  return false;
+                }
+              });
+        } catch (ExecutionException e) {
+          throw new AssertionError(e);
+        }
+      }
+
+      private boolean hasLocalContributions(ResolvedBindings resolvedBindings) {
+        return !explicitBindings.get(resolvedBindings.bindingKey().key()).isEmpty();
+      }
+
       ImmutableMap<BindingKey, ResolvedBindings> getResolvedBindings() {
         ImmutableMap.Builder<BindingKey, ResolvedBindings> resolvedBindingsBuilder =
             ImmutableMap.builder();
         resolvedBindingsBuilder.putAll(resolvedBindings);
         if (parentResolver.isPresent()) {
-          for (ResolvedBindings resolvedInParent :
-              parentResolver.get().getResolvedBindings().values()) {
-            BindingKey bindingKey = resolvedInParent.bindingKey();
-            if (!resolvedBindings.containsKey(bindingKey)) {
-              if (resolvedInParent.ownedBindings().isEmpty()) {
-                // reuse the instance if we can get away with it
-                resolvedBindingsBuilder.put(bindingKey, resolvedInParent);
-              } else {
-                resolvedBindingsBuilder.put(bindingKey,
-                    ResolvedBindings.create(
-                        bindingKey, ImmutableSet.<Binding>of(), resolvedInParent.bindings()));
-              }
-            }
+          Collection<ResolvedBindings> bindingsResolvedInParent =
+              Maps.difference(parentResolver.get().getResolvedBindings(), resolvedBindings)
+                  .entriesOnlyOnLeft()
+                  .values();
+          for (ResolvedBindings resolvedInParent : bindingsResolvedInParent) {
+            resolvedBindingsBuilder.put(
+                resolvedInParent.bindingKey(),
+                resolvedInParent.asInheritedIn(componentDescriptor));
           }
         }
         return resolvedBindingsBuilder.build();
       }
+
+      ImmutableSet<ModuleDescriptor> getInheritedModules() {
+        return parentResolver.isPresent()
+            ? Sets.union(
+                    parentResolver.get().getInheritedModules(),
+                    parentResolver.get().componentDescriptor.transitiveModules())
+                .immutableCopy()
+            : ImmutableSet.<ModuleDescriptor>of();
+      }
+
+      ImmutableSet<ModuleDescriptor> getOwnedModules() {
+        return Sets.difference(componentDescriptor.transitiveModules(), getInheritedModules())
+            .immutableCopy();
+      }
     }
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
index 2b38b5ab6..f8010c301 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -15,7 +15,6 @@
  */
 package dagger.internal.codegen;
 
-import com.google.auto.common.AnnotationMirrors;
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
@@ -30,28 +29,37 @@
 import com.google.common.collect.ImmutableListMultimap;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.ImmutableSetMultimap;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Maps;
+import com.google.common.collect.Multimap;
 import com.google.common.collect.Ordering;
 import com.google.common.collect.Sets;
 import dagger.Component;
+import dagger.Lazy;
+import dagger.MapKey;
 import dagger.internal.codegen.ComponentDescriptor.BuilderSpec;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
-import dagger.internal.codegen.ContributionBinding.BindingType;
+import dagger.internal.codegen.ContributionBinding.ContributionType;
 import dagger.internal.codegen.writer.TypeNames;
 import java.util.ArrayDeque;
+import java.util.Arrays;
 import java.util.Collection;
 import java.util.Deque;
 import java.util.Formatter;
+import java.util.HashSet;
 import java.util.Iterator;
+import java.util.LinkedHashSet;
 import java.util.Map;
 import java.util.Set;
-import javax.inject.Singleton;
+import javax.inject.Provider;
 import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.ArrayType;
 import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.ExecutableType;
 import javax.lang.model.type.PrimitiveType;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.SimpleTypeVisitor6;
@@ -59,28 +67,51 @@
 import javax.tools.Diagnostic;
 
 import static com.google.auto.common.MoreElements.getAnnotationMirror;
-import static com.google.auto.common.MoreTypes.isTypeOf;
+import static com.google.auto.common.MoreTypes.asDeclared;
+import static com.google.auto.common.MoreTypes.asExecutable;
+import static com.google.auto.common.MoreTypes.asTypeElements;
+import static com.google.common.base.Predicates.equalTo;
+import static com.google.common.base.Predicates.in;
+import static com.google.common.base.Predicates.not;
 import static com.google.common.base.Verify.verify;
+import static com.google.common.collect.Iterables.all;
+import static com.google.common.collect.Iterables.any;
 import static com.google.common.collect.Iterables.getOnlyElement;
+import static com.google.common.collect.Iterables.indexOf;
+import static com.google.common.collect.Iterables.skip;
+import static com.google.common.collect.Maps.filterKeys;
+import static dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor.isOfKind;
+import static dagger.internal.codegen.ComponentDescriptor.ComponentMethodKind.SUBCOMPONENT;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
+import static dagger.internal.codegen.ContributionBinding.indexMapBindingsByAnnotationType;
+import static dagger.internal.codegen.ContributionBinding.indexMapBindingsByMapKey;
+import static dagger.internal.codegen.ErrorMessages.DUPLICATE_SIZE_LIMIT;
 import static dagger.internal.codegen.ErrorMessages.INDENT;
 import static dagger.internal.codegen.ErrorMessages.MEMBERS_INJECTION_WITH_UNBOUNDED_TYPE;
-import static dagger.internal.codegen.ErrorMessages.NULLABLE_TO_NON_NULLABLE;
 import static dagger.internal.codegen.ErrorMessages.REQUIRES_AT_INJECT_CONSTRUCTOR_OR_PROVIDER_FORMAT;
 import static dagger.internal.codegen.ErrorMessages.REQUIRES_AT_INJECT_CONSTRUCTOR_OR_PROVIDER_OR_PRODUCER_FORMAT;
 import static dagger.internal.codegen.ErrorMessages.REQUIRES_PROVIDER_FORMAT;
 import static dagger.internal.codegen.ErrorMessages.REQUIRES_PROVIDER_OR_PRODUCER_FORMAT;
+import static dagger.internal.codegen.ErrorMessages.duplicateMapKeysError;
+import static dagger.internal.codegen.ErrorMessages.inconsistentMapKeyAnnotationsError;
+import static dagger.internal.codegen.ErrorMessages.nullableToNonNullable;
 import static dagger.internal.codegen.ErrorMessages.stripCommonTypePrefixes;
-import static dagger.internal.codegen.InjectionAnnotations.getScopeAnnotation;
+import static dagger.internal.codegen.Util.componentCanMakeNewInstances;
+import static dagger.internal.codegen.Util.getKeyTypeOfMap;
+import static dagger.internal.codegen.Util.getProvidedValueTypeOfMap;
+import static dagger.internal.codegen.Util.getValueTypeOfMap;
+import static dagger.internal.codegen.Util.isMapWithNonProvidedValues;
+import static dagger.internal.codegen.Util.isMapWithProvidedValues;
+import static javax.tools.Diagnostic.Kind.ERROR;
+import static javax.tools.Diagnostic.Kind.WARNING;
 
-public class BindingGraphValidator implements Validator<BindingGraph> {
+public class BindingGraphValidator {
 
   private final Types types;
   private final InjectBindingRegistry injectBindingRegistry;
   private final ValidationType scopeCycleValidationType;
   private final Diagnostic.Kind nullableValidationType;
-  private final ProvisionBindingFormatter provisionBindingFormatter;
-  private final ProductionBindingFormatter productionBindingFormatter;
+  private final ContributionBindingFormatter contributionBindingFormatter;
   private final MethodSignatureFormatter methodSignatureFormatter;
   private final DependencyRequestFormatter dependencyRequestFormatter;
   private final KeyFormatter keyFormatter;
@@ -90,8 +121,7 @@
       InjectBindingRegistry injectBindingRegistry,
       ValidationType scopeCycleValidationType,
       Diagnostic.Kind nullableValidationType,
-      ProvisionBindingFormatter provisionBindingFormatter,
-      ProductionBindingFormatter productionBindingFormatter,
+      ContributionBindingFormatter contributionBindingFormatter,
       MethodSignatureFormatter methodSignatureFormatter,
       DependencyRequestFormatter dependencyRequestFormatter,
       KeyFormatter keyFormatter) {
@@ -99,8 +129,7 @@
     this.injectBindingRegistry = injectBindingRegistry;
     this.scopeCycleValidationType = scopeCycleValidationType;
     this.nullableValidationType = nullableValidationType;
-    this.provisionBindingFormatter = provisionBindingFormatter;
-    this.productionBindingFormatter = productionBindingFormatter;
+    this.contributionBindingFormatter = contributionBindingFormatter;
     this.methodSignatureFormatter = methodSignatureFormatter;
     this.dependencyRequestFormatter = dependencyRequestFormatter;
     this.keyFormatter = keyFormatter;
@@ -108,48 +137,120 @@
 
   private class Validation {
     final BindingGraph topLevelGraph;
-    final ValidationReport.Builder<BindingGraph> reportBuilder;
+    final BindingGraph subject;
+    final ValidationReport.Builder<TypeElement> reportBuilder;
 
-    Validation(BindingGraph topLevelGraph) {
+    Validation(BindingGraph topLevelGraph, BindingGraph subject) {
       this.topLevelGraph = topLevelGraph;
-      this.reportBuilder = ValidationReport.Builder.about(topLevelGraph);
+      this.subject = subject;
+      this.reportBuilder =
+          ValidationReport.about(subject.componentDescriptor().componentDefinitionType());
     }
 
-    ValidationReport<BindingGraph> buildReport() {
+    Validation(BindingGraph topLevelGraph) {
+      this(topLevelGraph, topLevelGraph);
+    }
+
+    ValidationReport<TypeElement> buildReport() {
       return reportBuilder.build();
     }
 
-    void validateSubgraph(BindingGraph subject) {
-      validateComponentScope(subject);
-      validateDependencyScopes(subject);
-      validateBuilders(subject);
+    void validateSubgraph() {
+      validateComponentScope();
+      validateDependencyScopes();
+      validateComponentHierarchy();
+      validateBuilders();
 
       for (ComponentMethodDescriptor componentMethod :
            subject.componentDescriptor().componentMethods()) {
         Optional<DependencyRequest> entryPoint = componentMethod.dependencyRequest();
         if (entryPoint.isPresent()) {
-          traverseRequest(entryPoint.get(), new ArrayDeque<ResolvedRequest>(),
-              Sets.<BindingKey>newHashSet(), subject,
-              Sets.<DependencyRequest>newHashSet());
+          traverseRequest(
+              entryPoint.get(),
+              new ArrayDeque<ResolvedRequest>(),
+              new LinkedHashSet<BindingKey>(),
+              subject,
+              new HashSet<DependencyRequest>());
         }
       }
+      
+      for (Map.Entry<ComponentMethodDescriptor, ComponentDescriptor> entry :
+          filterKeys(subject.componentDescriptor().subcomponents(), isOfKind(SUBCOMPONENT))
+              .entrySet()) {
+        validateSubcomponentFactoryMethod(
+            entry.getKey().methodElement(), entry.getValue().componentDefinitionType());
+      }
 
       for (BindingGraph subgraph : subject.subgraphs().values()) {
-        validateSubgraph(subgraph);
+        Validation subgraphValidation =
+            new Validation(topLevelGraph, subgraph);
+        subgraphValidation.validateSubgraph();
+        reportBuilder.addSubreport(subgraphValidation.buildReport());
       }
     }
 
+    private void validateSubcomponentFactoryMethod(
+        ExecutableElement factoryMethod, TypeElement subcomponentType) {
+      BindingGraph subgraph = subject.subgraphs().get(factoryMethod);
+      FluentIterable<TypeElement> missingModules =
+          FluentIterable.from(subgraph.componentRequirements())
+              .filter(not(in(subgraphFactoryMethodParameters(factoryMethod))))
+              .filter(
+                  new Predicate<TypeElement>() {
+                    @Override
+                    public boolean apply(TypeElement moduleType) {
+                      return !componentCanMakeNewInstances(moduleType);
+                    }
+                  });
+      if (!missingModules.isEmpty()) {
+        reportBuilder.addError(
+            String.format(
+                "%s requires modules which have no visible default constructors. "
+                    + "Add the following modules as parameters to this method: %s",
+                subcomponentType.getQualifiedName(),
+                Joiner.on(", ").join(missingModules.toSet())),
+            factoryMethod);
+      }
+    }
+
+    private ImmutableSet<TypeElement> subgraphFactoryMethodParameters(
+        ExecutableElement factoryMethod) {
+      DeclaredType componentType =
+          asDeclared(subject.componentDescriptor().componentDefinitionType().asType());
+      ExecutableType factoryMethodType =
+          asExecutable(types.asMemberOf(componentType, factoryMethod));
+      return asTypeElements(factoryMethodType.getParameterTypes());
+    }
+
+    /**
+     * Traverse the resolved dependency requests, validating resolved bindings, and reporting any
+     * cycles found.
+     *
+     * @param request the current dependency request
+     * @param bindingPath the dependency request path from the parent of {@code request} at the head
+     *     up to the root dependency request from the component method at the tail
+     * @param keysInPath the binding keys corresponding to the dependency requests in
+     *     {@code bindingPath}, but in reverse order: the first element is the binding key from the
+     *     component method
+     * @param resolvedRequests the requests that have already been resolved, so we can avoid
+     *     traversing that part of the graph again
+     */
+    // TODO(dpb): It might be simpler to invert bindingPath's order.
     private void traverseRequest(
         DependencyRequest request,
         Deque<ResolvedRequest> bindingPath,
-        Set<BindingKey> keysInPath,
+        LinkedHashSet<BindingKey> keysInPath,
         BindingGraph graph,
         Set<DependencyRequest> resolvedRequests) {
       verify(bindingPath.size() == keysInPath.size(),
           "mismatched path vs keys -- (%s vs %s)", bindingPath, keysInPath);
       BindingKey requestKey = request.bindingKey();
       if (keysInPath.contains(requestKey)) {
-        reportCycle(request, bindingPath);
+        reportCycle(
+            // Invert bindingPath to match keysInPath's order
+            ImmutableList.copyOf(bindingPath).reverse(),
+            request,
+            indexOf(keysInPath, equalTo(requestKey)));
         return;
       }
 
@@ -181,72 +282,56 @@ private boolean validateResolvedBinding(
         return false;
       }
 
-      ImmutableSet.Builder<ProvisionBinding> provisionBindingsBuilder =
-          ImmutableSet.builder();
-      ImmutableSet.Builder<ProductionBinding> productionBindingsBuilder =
-          ImmutableSet.builder();
-      ImmutableSet.Builder<MembersInjectionBinding> membersInjectionBindingsBuilder =
-          ImmutableSet.builder();
-      for (Binding binding : resolvedBinding.bindings()) {
-        if (binding instanceof ProvisionBinding) {
-          provisionBindingsBuilder.add((ProvisionBinding) binding);
-        }
-        if (binding instanceof ProductionBinding) {
-          productionBindingsBuilder.add((ProductionBinding) binding);
-        }
-        if (binding instanceof MembersInjectionBinding) {
-          membersInjectionBindingsBuilder.add((MembersInjectionBinding) binding);
-        }
-      }
-      ImmutableSet<ProvisionBinding> provisionBindings = provisionBindingsBuilder.build();
-      ImmutableSet<ProductionBinding> productionBindings = productionBindingsBuilder.build();
-      ImmutableSet<MembersInjectionBinding> membersInjectionBindings =
-          membersInjectionBindingsBuilder.build();
-
       switch (resolvedBinding.bindingKey().kind()) {
         case CONTRIBUTION:
-          if (!membersInjectionBindings.isEmpty()) {
+          ImmutableSet<ContributionBinding> contributionBindings =
+              resolvedBinding.contributionBindings();
+          if (any(contributionBindings, Binding.Type.MEMBERS_INJECTION)) {
             throw new IllegalArgumentException(
                 "contribution binding keys should never have members injection bindings");
           }
-          Set<ContributionBinding> combined = Sets.union(provisionBindings, productionBindings);
-          if (!validateNullability(path.peek().request(), combined)) {
+          if (!validateNullability(path.peek().request(), contributionBindings)) {
             return false;
           }
-          if (!productionBindings.isEmpty() && doesPathRequireProvisionOnly(path)) {
+          if (any(contributionBindings, Binding.Type.PRODUCTION)
+              && doesPathRequireProvisionOnly(path)) {
             reportProviderMayNotDependOnProducer(path);
             return false;
           }
-          if ((provisionBindings.size() + productionBindings.size()) <= 1) {
+          if (contributionBindings.size() <= 1) {
             return true;
           }
-          ImmutableListMultimap<BindingType, ContributionBinding> bindingsByType =
-              ContributionBinding.bindingTypesFor(
-                  Iterables.<ContributionBinding>concat(provisionBindings, productionBindings));
-          if (bindingsByType.keySet().size() > 1) {
+          ImmutableListMultimap<ContributionType, ContributionBinding> contributionsByType =
+              ContributionBinding.contributionTypesFor(contributionBindings);
+          if (contributionsByType.keySet().size() > 1) {
             reportMultipleBindingTypes(path);
             return false;
-          } else if (getOnlyElement(bindingsByType.keySet()).equals(BindingType.UNIQUE)) {
-            reportDuplicateBindings(path);
-            return false;
+          }
+          switch (getOnlyElement(contributionsByType.keySet())) {
+            case UNIQUE:
+              reportDuplicateBindings(path);
+              return false;
+            case MAP:
+              boolean duplicateMapKeys = hasDuplicateMapKeys(path, contributionBindings);
+              boolean inconsistentMapKeyAnnotationTypes =
+                  hasInconsistentMapKeyAnnotationTypes(path, contributionBindings);
+              return !duplicateMapKeys && !inconsistentMapKeyAnnotationTypes;
+            case SET:
+              break;
+            default:
+              throw new AssertionError();
           }
           break;
         case MEMBERS_INJECTION:
-          if (!provisionBindings.isEmpty() || !productionBindings.isEmpty()) {
+          if (!all(resolvedBinding.bindings(), Binding.Type.MEMBERS_INJECTION)) {
             throw new IllegalArgumentException(
                 "members injection binding keys should never have contribution bindings");
           }
-          if (membersInjectionBindings.size() > 1) {
+          if (resolvedBinding.bindings().size() > 1) {
             reportDuplicateBindings(path);
             return false;
           }
-          if (membersInjectionBindings.size() == 1) {
-            MembersInjectionBinding binding = getOnlyElement(membersInjectionBindings);
-            if (!validateMembersInjectionBinding(binding, path)) {
-              return false;
-            }
-          }
-          break;
+          return validateMembersInjectionBinding(getOnlyElement(resolvedBinding.bindings()), path);
         default:
           throw new AssertionError();
       }
@@ -256,132 +341,221 @@ private boolean validateResolvedBinding(
     /** Ensures that if the request isn't nullable, then each contribution is also not nullable. */
     private boolean validateNullability(
         DependencyRequest request, Set<ContributionBinding> bindings) {
+      if (request.isNullable()) {
+        return true;
+      }
+
+      // Note: the method signature will include the @Nullable in it!
+      /* TODO(sameb): Sometimes javac doesn't include the Element in its output.
+       * (Maybe this happens if the code was already compiled before this point?)
+       * ... we manually print out the request in that case, otherwise the error
+       * message is kind of useless. */
+      String typeName = TypeNames.forTypeMirror(request.key().type()).toString();
+
       boolean valid = true;
-      if (!request.isNullable()) {
-        String typeName = null;
-        for (ContributionBinding binding : bindings) {
-          if (binding.nullableType().isPresent()) {
-            String methodSignature;
-            if (binding instanceof ProvisionBinding) {
-              ProvisionBinding provisionBinding = (ProvisionBinding) binding;
-              methodSignature = provisionBindingFormatter.format(provisionBinding);
-            } else {
-              ProductionBinding productionBinding = (ProductionBinding) binding;
-              methodSignature = productionBindingFormatter.format(productionBinding);
-            }
-            // Note: the method signature will include the @Nullable in it!
-            // TODO(sameb): Sometimes javac doesn't include the Element in its output.
-            // (Maybe this happens if the code was already compiled before this point?)
-            // ... we manually print ouf the request in that case, otherwise the error
-            // message is kind of useless.
-            if (typeName == null) {
-              typeName = TypeNames.forTypeMirror(request.key().type()).toString();
-            }
-            reportBuilder.addItem(
-                String.format(NULLABLE_TO_NON_NULLABLE, typeName, methodSignature)
-                + "\n at: " + dependencyRequestFormatter.format(request),
-                nullableValidationType,
-                request.requestElement());
-            valid = false;
-          }
+      for (ContributionBinding binding : bindings) {
+        if (binding.nullableType().isPresent()) {
+          reportBuilder.addItem(
+              nullableToNonNullable(typeName, contributionBindingFormatter.format(binding))
+                  + "\n at: "
+                  + dependencyRequestFormatter.format(request),
+              nullableValidationType,
+              request.requestElement());
+          valid = false;
         }
       }
       return valid;
     }
 
+    /**
+     * Returns {@code true} (and reports errors) if {@code mapBindings} has more than one binding
+     * for the same map key.
+     */
+    private boolean hasDuplicateMapKeys(
+        Deque<ResolvedRequest> path, Set<ContributionBinding> mapBindings) {
+      boolean hasDuplicateMapKeys = false;
+      for (Collection<ContributionBinding> mapBindingsForMapKey :
+          indexMapBindingsByMapKey(mapBindings).asMap().values()) {
+        if (mapBindingsForMapKey.size() > 1) {
+          hasDuplicateMapKeys = true;
+          reportDuplicateMapKeys(path, mapBindingsForMapKey);
+        }
+      }
+      return hasDuplicateMapKeys;
+    }
+
+    /**
+     * Returns {@code true} (and reports errors) if {@code mapBindings} uses more than one
+     * {@link MapKey} annotation type.
+     */
+    private boolean hasInconsistentMapKeyAnnotationTypes(
+        Deque<ResolvedRequest> path, Set<ContributionBinding> contributionBindings) {
+      ImmutableSetMultimap<Equivalence.Wrapper<DeclaredType>, ContributionBinding>
+          mapBindingsByAnnotationType = indexMapBindingsByAnnotationType(contributionBindings);
+      if (mapBindingsByAnnotationType.keySet().size() > 1) {
+        reportInconsistentMapKeyAnnotations(path, mapBindingsByAnnotationType);
+        return true;
+      }
+      return false;
+    }
+
     /**
      * Validates a members injection binding, returning false (and reporting the error) if it wasn't
      * valid.
      */
     private boolean validateMembersInjectionBinding(
-        MembersInjectionBinding binding, final Deque<ResolvedRequest> path) {
-      return binding.key().type().accept(new SimpleTypeVisitor6<Boolean, Void>() {
-        @Override protected Boolean defaultAction(TypeMirror e, Void p) {
-          reportBuilder.addItem("Invalid members injection request.",
-              path.peek().request().requestElement());
-          return false;
-        }
+        Binding binding, final Deque<ResolvedRequest> path) {
+      return binding
+          .key()
+          .type()
+          .accept(
+              new SimpleTypeVisitor6<Boolean, Void>() {
+                @Override
+                protected Boolean defaultAction(TypeMirror e, Void p) {
+                  reportBuilder.addError(
+                      "Invalid members injection request.", path.peek().request().requestElement());
+                  return false;
+                }
 
-        @Override public Boolean visitDeclared(DeclaredType type, Void ignored) {
-          // If the key has type arguments, validate that each type argument is declared.
-          // Otherwise the type argument may be a wildcard (or other type), and we can't
-          // resolve that to actual types.  If the arg was an array, validate the type
-          // of the array.
-          for (TypeMirror arg : type.getTypeArguments()) {
-            boolean declared;
-            switch (arg.getKind()) {
-              case ARRAY:
-                declared = MoreTypes.asArray(arg).getComponentType().accept(
-                    new SimpleTypeVisitor6<Boolean, Void>() {
-                      @Override protected Boolean defaultAction(TypeMirror e, Void p) {
-                        return false;
-                      }
-
-                      @Override public Boolean visitDeclared(DeclaredType t, Void p) {
-                        for (TypeMirror arg : t.getTypeArguments()) {
-                          if (!arg.accept(this, null)) {
-                            return false;
-                          }
-                        }
-                        return true;
-                      }
-
-                      @Override public Boolean visitArray(ArrayType t, Void p) {
-                        return t.getComponentType().accept(this, null);
-                      }
-
-                      @Override public Boolean visitPrimitive(PrimitiveType t, Void p) {
-                        return true;
-                      }
-                    }, null);
-                break;
-              case DECLARED:
-                declared = true;
-                break;
-              default:
-                declared = false;
-            }
-            if (!declared) {
-              ImmutableList<String> printableDependencyPath = FluentIterable.from(path)
-                  .transform(REQUEST_FROM_RESOLVED_REQUEST)
-                  .transform(dependencyRequestFormatter)
-                  .filter(Predicates.not(Predicates.equalTo("")))
-                  .toList()
-                  .reverse();
-              reportBuilder.addItem(
-                  String.format(MEMBERS_INJECTION_WITH_UNBOUNDED_TYPE,
-                      arg.toString(),
-                      type.toString(),
-                      Joiner.on('\n').join(printableDependencyPath)),
-                      path.peek().request().requestElement());
-              return false;
-            }
-          }
+                @Override
+                public Boolean visitDeclared(DeclaredType type, Void ignored) {
+                  // If the key has type arguments, validate that each type argument is declared.
+                  // Otherwise the type argument may be a wildcard (or other type), and we can't
+                  // resolve that to actual types.  If the arg was an array, validate the type
+                  // of the array.
+                  for (TypeMirror arg : type.getTypeArguments()) {
+                    boolean declared;
+                    switch (arg.getKind()) {
+                      case ARRAY:
+                        declared =
+                            MoreTypes.asArray(arg)
+                                .getComponentType()
+                                .accept(
+                                    new SimpleTypeVisitor6<Boolean, Void>() {
+                                      @Override
+                                      protected Boolean defaultAction(TypeMirror e, Void p) {
+                                        return false;
+                                      }
 
-          TypeElement element = MoreElements.asType(type.asElement());
-          // Also validate that the key is not the erasure of a generic type.
-          // If it is, that means the user referred to Foo<T> as just 'Foo',
-          // which we don't allow.  (This is a judgement call -- we *could*
-          // allow it and instantiate the type bounds... but we don't.)
-          if (!MoreTypes.asDeclared(element.asType()).getTypeArguments().isEmpty()
-              && types.isSameType(types.erasure(element.asType()), type)) {
-              ImmutableList<String> printableDependencyPath = FluentIterable.from(path)
-                  .transform(REQUEST_FROM_RESOLVED_REQUEST)
-                  .transform(dependencyRequestFormatter)
-                  .filter(Predicates.not(Predicates.equalTo("")))
-                  .toList()
-                  .reverse();
-            reportBuilder.addItem(
-                String.format(ErrorMessages.MEMBERS_INJECTION_WITH_RAW_TYPE,
-                    type.toString(),
-                    Joiner.on('\n').join(printableDependencyPath)),
-                path.peek().request().requestElement());
-            return false;
+                                      @Override
+                                      public Boolean visitDeclared(DeclaredType t, Void p) {
+                                        for (TypeMirror arg : t.getTypeArguments()) {
+                                          if (!arg.accept(this, null)) {
+                                            return false;
+                                          }
+                                        }
+                                        return true;
+                                      }
+
+                                      @Override
+                                      public Boolean visitArray(ArrayType t, Void p) {
+                                        return t.getComponentType().accept(this, null);
+                                      }
+
+                                      @Override
+                                      public Boolean visitPrimitive(PrimitiveType t, Void p) {
+                                        return true;
+                                      }
+                                    },
+                                    null);
+                        break;
+                      case DECLARED:
+                        declared = true;
+                        break;
+                      default:
+                        declared = false;
+                    }
+                    if (!declared) {
+                      ImmutableList<String> printableDependencyPath =
+                          FluentIterable.from(path)
+                              .transform(REQUEST_FROM_RESOLVED_REQUEST)
+                              .transform(dependencyRequestFormatter)
+                              .filter(Predicates.not(Predicates.equalTo("")))
+                              .toList()
+                              .reverse();
+                      reportBuilder.addError(
+                          String.format(
+                              MEMBERS_INJECTION_WITH_UNBOUNDED_TYPE,
+                              arg.toString(),
+                              type.toString(),
+                              Joiner.on('\n').join(printableDependencyPath)),
+                          path.peek().request().requestElement());
+                      return false;
+                    }
+                  }
+
+                  TypeElement element = MoreElements.asType(type.asElement());
+                  // Also validate that the key is not the erasure of a generic type.
+                  // If it is, that means the user referred to Foo<T> as just 'Foo',
+                  // which we don't allow.  (This is a judgement call -- we *could*
+                  // allow it and instantiate the type bounds... but we don't.)
+                  if (!MoreTypes.asDeclared(element.asType()).getTypeArguments().isEmpty()
+                      && types.isSameType(types.erasure(element.asType()), type)) {
+                    ImmutableList<String> printableDependencyPath =
+                        FluentIterable.from(path)
+                            .transform(REQUEST_FROM_RESOLVED_REQUEST)
+                            .transform(dependencyRequestFormatter)
+                            .filter(Predicates.not(Predicates.equalTo("")))
+                            .toList()
+                            .reverse();
+                    reportBuilder.addError(
+                        String.format(
+                            ErrorMessages.MEMBERS_INJECTION_WITH_RAW_TYPE,
+                            type.toString(),
+                            Joiner.on('\n').join(printableDependencyPath)),
+                        path.peek().request().requestElement());
+                    return false;
+                  }
+
+                  return true; // valid
+                }
+              },
+              null);
+    }
+
+    /**
+     * Validates that component dependencies do not form a cycle.
+     */
+    private void validateComponentHierarchy() {
+      ComponentDescriptor descriptor = subject.componentDescriptor();
+      TypeElement componentType = descriptor.componentDefinitionType();
+      validateComponentHierarchy(componentType, componentType, new ArrayDeque<TypeElement>());
+    }
+
+    /**
+     * Recursive method to validate that component dependencies do not form a cycle.
+     */
+    private void validateComponentHierarchy(
+        TypeElement rootComponent,
+        TypeElement componentType,
+        Deque<TypeElement> componentStack) {
+
+      if (componentStack.contains(componentType)) {
+        // Current component has already appeared in the component chain.
+        StringBuilder message = new StringBuilder();
+        message.append(rootComponent.getQualifiedName());
+        message.append(" contains a cycle in its component dependencies:\n");
+        componentStack.push(componentType);
+        appendIndentedComponentsList(message, componentStack);
+        componentStack.pop();
+        reportBuilder.addItem(message.toString(),
+            scopeCycleValidationType.diagnosticKind().get(),
+            rootComponent, getAnnotationMirror(rootComponent, Component.class).get());
+      } else {
+        Optional<AnnotationMirror> componentAnnotation =
+            getAnnotationMirror(componentType, Component.class);
+        if (componentAnnotation.isPresent()) {
+          componentStack.push(componentType);
+
+          ImmutableSet<TypeElement> dependencies =
+              MoreTypes.asTypeElements(getComponentDependencies(componentAnnotation.get()));
+          for (TypeElement dependency : dependencies) {
+            validateComponentHierarchy(rootComponent, dependency, componentStack);
           }
 
-          return true; // valid
+          componentStack.pop();
         }
-      }, null);
+      }
     }
 
     /**
@@ -389,14 +563,14 @@ private boolean validateMembersInjectionBinding(
      * that there are no cycles within the scoping chain, and that singleton
      * components have no scoped dependencies.
      */
-    private void validateDependencyScopes(BindingGraph subject) {
+    private void validateDependencyScopes() {
       ComponentDescriptor descriptor = subject.componentDescriptor();
-      Optional<AnnotationMirror> scope = descriptor.scope();
+      Scope scope = descriptor.scope();
       ImmutableSet<TypeElement> scopedDependencies = scopedTypesIn(descriptor.dependencies());
       if (scope.isPresent()) {
         // Dagger 1.x scope compatibility requires this be suppress-able.
         if (scopeCycleValidationType.diagnosticKind().isPresent()
-            && isTypeOf(Singleton.class, scope.get().getAnnotationType())) {
+            && scope.isSingleton()) {
           // Singleton is a special-case representing the longest lifetime, and therefore
           // @Singleton components may not depend on scoped components
           if (!scopedDependencies.isEmpty()) {
@@ -410,12 +584,13 @@ private void validateDependencyScopes(BindingGraph subject) {
           }
         } else if (scopedDependencies.size() > 1) {
           // Scoped components may depend on at most one scoped component.
-          StringBuilder message = new StringBuilder(ErrorMessages.format(scope.get()))
+          StringBuilder message = new StringBuilder(scope.getReadableSource())
               .append(' ')
               .append(descriptor.componentDefinitionType().getQualifiedName())
               .append(" depends on more than one scoped component:\n");
           appendIndentedComponentsList(message, scopedDependencies);
-          reportBuilder.addItem(message.toString(),
+          reportBuilder.addError(
+              message.toString(),
               descriptor.componentDefinitionType(),
               descriptor.componentAnnotation());
         } else {
@@ -423,7 +598,7 @@ private void validateDependencyScopes(BindingGraph subject) {
           if (!scopeCycleValidationType.equals(ValidationType.NONE)) {
             validateScopeHierarchy(descriptor.componentDefinitionType(),
                 descriptor.componentDefinitionType(),
-                new ArrayDeque<Equivalence.Wrapper<AnnotationMirror>>(),
+                new ArrayDeque<Scope>(),
                 new ArrayDeque<TypeElement>());
           }
         }
@@ -434,33 +609,37 @@ private void validateDependencyScopes(BindingGraph subject) {
               new StringBuilder(descriptor.componentDefinitionType().getQualifiedName())
                   .append(" (unscoped) cannot depend on scoped components:\n");
           appendIndentedComponentsList(message, scopedDependencies);
-          reportBuilder.addItem(message.toString(),
+          reportBuilder.addError(
+              message.toString(),
               descriptor.componentDefinitionType(),
               descriptor.componentAnnotation());
         }
       }
     }
 
-    private void validateBuilders(BindingGraph subject) {
+    private void validateBuilders() {
       ComponentDescriptor componentDesc = subject.componentDescriptor();
       if (!componentDesc.builderSpec().isPresent()) {
         // If no builder, nothing to validate.
         return;
       }
 
-      Set<TypeElement> allDependents = subject.componentRequirements();
-      Set<TypeElement> requiredDependents =
-          Sets.filter(allDependents, new Predicate<TypeElement>() {
-            @Override public boolean apply(TypeElement input) {
-              return !Util.componentCanMakeNewInstances(input);
-            }
-          });
+      Set<TypeElement> availableDependencies = subject.availableDependencies();
+      Set<TypeElement> requiredDependencies =
+          Sets.filter(
+              availableDependencies,
+              new Predicate<TypeElement>() {
+                @Override
+                public boolean apply(TypeElement input) {
+                  return !Util.componentCanMakeNewInstances(input);
+                }
+              });
       final BuilderSpec spec = componentDesc.builderSpec().get();
       Map<TypeElement, ExecutableElement> allSetters = spec.methodMap();
 
       ErrorMessages.ComponentBuilderMessages msgs =
           ErrorMessages.builderMsgsFor(subject.componentDescriptor().kind());
-      Set<TypeElement> extraSetters = Sets.difference(allSetters.keySet(), allDependents);
+      Set<TypeElement> extraSetters = Sets.difference(allSetters.keySet(), availableDependencies);
       if (!extraSetters.isEmpty()) {
         Collection<ExecutableElement> excessMethods =
             Maps.filterKeys(allSetters, Predicates.in(extraSetters)).values();
@@ -470,14 +649,14 @@ private void validateBuilders(BindingGraph subject) {
                 return methodSignatureFormatter.format(input,
                     Optional.of(MoreTypes.asDeclared(spec.builderDefinitionType().asType())));
               }});
-        reportBuilder.addItem(String.format(msgs.extraSetters(), formatted),
-            spec.builderDefinitionType());
+        reportBuilder.addError(
+            String.format(msgs.extraSetters(), formatted), spec.builderDefinitionType());
       }
 
-      Set<TypeElement> missingSetters = Sets.difference(requiredDependents, allSetters.keySet());
+      Set<TypeElement> missingSetters = Sets.difference(requiredDependencies, allSetters.keySet());
       if (!missingSetters.isEmpty()) {
-        reportBuilder.addItem(String.format(msgs.missingSetters(), missingSetters),
-            spec.builderDefinitionType());
+        reportBuilder.addError(
+            String.format(msgs.missingSetters(), missingSetters), spec.builderDefinitionType());
       }
     }
 
@@ -487,17 +666,16 @@ private void validateBuilders(BindingGraph subject) {
      *
      * <p>As a side-effect, this means scoped components cannot have a dependency cycle between
      * themselves, since a component's presence within its own dependency path implies a cyclical
-     * relationship between scopes.
+     * relationship between scopes. However, cycles in component dependencies are explicitly
+     * checked in {@link #validateComponentHierarchy()}.
      */
     private void validateScopeHierarchy(TypeElement rootComponent,
         TypeElement componentType,
-        Deque<Equivalence.Wrapper<AnnotationMirror>> scopeStack,
+        Deque<Scope> scopeStack,
         Deque<TypeElement> scopedDependencyStack) {
-      Optional<AnnotationMirror> scope = getScopeAnnotation(componentType);
+      Scope scope = Scope.scopeOf(componentType);
       if (scope.isPresent()) {
-        Equivalence.Wrapper<AnnotationMirror> wrappedScope =
-            AnnotationMirrors.equivalence().wrap(scope.get());
-        if (scopeStack.contains(wrappedScope)) {
+        if (scopeStack.contains(scope)) {
           scopedDependencyStack.push(componentType);
           // Current scope has already appeared in the component chain.
           StringBuilder message = new StringBuilder();
@@ -518,7 +696,7 @@ private void validateScopeHierarchy(TypeElement rootComponent,
                 MoreTypes.asTypeElements(getComponentDependencies(componentAnnotation.get())));
             if (scopedDependencies.size() == 1) {
               // empty can be ignored (base-case), and > 1 is a different error reported separately.
-              scopeStack.push(wrappedScope);
+              scopeStack.push(scope);
               scopedDependencyStack.push(componentType);
               validateScopeHierarchy(rootComponent, getOnlyElement(scopedDependencies),
                   scopeStack, scopedDependencyStack);
@@ -534,37 +712,34 @@ private void validateScopeHierarchy(TypeElement rootComponent,
      * Validates that the scope (if any) of this component are compatible with the scopes of the
      * bindings available in this component
      */
-    void validateComponentScope(final BindingGraph subject) {
+    void validateComponentScope() {
       ImmutableMap<BindingKey, ResolvedBindings> resolvedBindings = subject.resolvedBindings();
-      Optional<Equivalence.Wrapper<AnnotationMirror>> componentScope =
-          subject.componentDescriptor().wrappedScope();
+      Scope componentScope = subject.componentDescriptor().scope();
       ImmutableSet.Builder<String> incompatiblyScopedMethodsBuilder = ImmutableSet.builder();
       for (ResolvedBindings bindings : resolvedBindings.values()) {
         if (bindings.bindingKey().kind().equals(BindingKey.Kind.CONTRIBUTION)) {
           for (ContributionBinding contributionBinding : bindings.ownedContributionBindings()) {
-            if (contributionBinding instanceof ProvisionBinding) {
-              ProvisionBinding provisionBinding = (ProvisionBinding) contributionBinding;
-              if (provisionBinding.scope().isPresent()
-                  && !componentScope.equals(provisionBinding.wrappedScope())) {
-                // Scoped components cannot reference bindings to @Provides methods or @Inject
-                // types decorated by a different scope annotation. Unscoped components cannot
-                // reference to scoped @Provides methods or @Inject types decorated by any
-                // scope annotation.
-                switch (provisionBinding.bindingKind()) {
-                  case PROVISION:
-                    ExecutableElement provisionMethod =
-                        MoreElements.asExecutable(provisionBinding.bindingElement());
-                    incompatiblyScopedMethodsBuilder.add(
-                        methodSignatureFormatter.format(provisionMethod));
-                    break;
-                  case INJECTION:
-                    incompatiblyScopedMethodsBuilder.add(stripCommonTypePrefixes(
-                        provisionBinding.scope().get().toString()) + " class "
-                            + provisionBinding.bindingTypeElement().getQualifiedName());
-                    break;
-                  default:
-                    throw new IllegalStateException();
-                }
+            Scope bindingScope = contributionBinding.scope();
+            if (bindingScope.isPresent() && !bindingScope.equals(componentScope)) {
+              // Scoped components cannot reference bindings to @Provides methods or @Inject
+              // types decorated by a different scope annotation. Unscoped components cannot
+              // reference to scoped @Provides methods or @Inject types decorated by any
+              // scope annotation.
+              switch (contributionBinding.bindingKind()) {
+                case PROVISION:
+                  ExecutableElement provisionMethod =
+                      MoreElements.asExecutable(contributionBinding.bindingElement());
+                  incompatiblyScopedMethodsBuilder.add(
+                      methodSignatureFormatter.format(provisionMethod));
+                  break;
+                case INJECTION:
+                  incompatiblyScopedMethodsBuilder.add(
+                      bindingScope.getReadableSource()
+                          + " class "
+                          + contributionBinding.bindingTypeElement().getQualifiedName());
+                  break;
+                default:
+                  throw new IllegalStateException();
               }
             }
           }
@@ -576,7 +751,7 @@ void validateComponentScope(final BindingGraph subject) {
         StringBuilder message = new StringBuilder(componentType.getQualifiedName());
         if (componentScope.isPresent()) {
           message.append(" scoped with ");
-          message.append(stripCommonTypePrefixes(ErrorMessages.format(componentScope.get().get())));
+          message.append(componentScope.getReadableSource());
           message.append(" may not reference bindings with different scopes:\n");
         } else {
           message.append(" (unscoped) may not reference scoped bindings:\n");
@@ -584,8 +759,8 @@ void validateComponentScope(final BindingGraph subject) {
         for (String method : incompatiblyScopedMethods) {
           message.append(ErrorMessages.INDENT).append(method).append("\n");
         }
-        reportBuilder.addItem(message.toString(), componentType,
-            subject.componentDescriptor().componentAnnotation());
+        reportBuilder.addError(
+            message.toString(), componentType, subject.componentDescriptor().componentAnnotation());
       }
     }
 
@@ -593,25 +768,24 @@ void validateComponentScope(final BindingGraph subject) {
     private void reportProviderMayNotDependOnProducer(Deque<ResolvedRequest> path) {
       StringBuilder errorMessage = new StringBuilder();
       if (path.size() == 1) {
-        new Formatter(errorMessage).format(
-            ErrorMessages.PROVIDER_ENTRY_POINT_MAY_NOT_DEPEND_ON_PRODUCER_FORMAT,
-            keyFormatter.format(path.peek().request().key()));
+        new Formatter(errorMessage)
+            .format(
+                ErrorMessages.PROVIDER_ENTRY_POINT_MAY_NOT_DEPEND_ON_PRODUCER_FORMAT,
+                formatRootRequestKey(path));
       } else {
-        ImmutableSet<ProvisionBinding> dependentProvisions =
+        ImmutableSet<? extends Binding> dependentProvisions =
             provisionsDependingOnLatestRequest(path);
         // TODO(beder): Consider displaying all dependent provisions in the error message. If we do
         // that, should we display all productions that depend on them also?
         new Formatter(errorMessage).format(ErrorMessages.PROVIDER_MAY_NOT_DEPEND_ON_PRODUCER_FORMAT,
             keyFormatter.format(dependentProvisions.iterator().next().key()));
       }
-      reportBuilder.addItem(errorMessage.toString(), path.getLast().request().requestElement());
+      reportBuilder.addError(errorMessage.toString(), path.getLast().request().requestElement());
     }
 
     private void reportMissingBinding(Deque<ResolvedRequest> path) {
       Key key = path.peek().request().key();
       BindingKey bindingKey = path.peek().request().bindingKey();
-      TypeMirror type = key.type();
-      String typeName = TypeNames.forTypeMirror(type).toString();
       boolean requiresContributionMethod = !key.isValidImplicitProvisionKey(types);
       boolean requiresProvision = doesPathRequireProvisionOnly(path);
       StringBuilder errorMessage = new StringBuilder();
@@ -622,7 +796,7 @@ private void reportMissingBinding(Deque<ResolvedRequest> path) {
           : requiresProvision
               ? REQUIRES_AT_INJECT_CONSTRUCTOR_OR_PROVIDER_FORMAT
               : REQUIRES_AT_INJECT_CONSTRUCTOR_OR_PROVIDER_OR_PRODUCER_FORMAT;
-      errorMessage.append(String.format(requiresErrorMessageFormat, typeName));
+      errorMessage.append(String.format(requiresErrorMessageFormat, keyFormatter.format(key)));
       if (key.isValidMembersInjectionKey()
           && !injectBindingRegistry.getOrFindMembersInjectionBinding(key).injectionSites()
               .isEmpty()) {
@@ -642,27 +816,21 @@ private void reportMissingBinding(Deque<ResolvedRequest> path) {
       for (String suggestion : MissingBindingSuggestions.forKey(topLevelGraph, bindingKey)) {
         errorMessage.append('\n').append(suggestion);
       }
-      reportBuilder.addItem(errorMessage.toString(), path.getLast().request().requestElement());
+      reportBuilder.addError(errorMessage.toString(), path.getLast().request().requestElement());
     }
 
-    private static final int DUPLICATE_SIZE_LIMIT = 10;
-
     @SuppressWarnings("resource") // Appendable is a StringBuilder.
     private void reportDuplicateBindings(Deque<ResolvedRequest> path) {
       ResolvedBindings resolvedBinding = path.peek().binding();
       StringBuilder builder = new StringBuilder();
-      new Formatter(builder).format(ErrorMessages.DUPLICATE_BINDINGS_FOR_KEY_FORMAT,
-          keyFormatter.format(path.peek().request().key()));
-      for (Binding binding : Iterables.limit(resolvedBinding.bindings(), DUPLICATE_SIZE_LIMIT)) {
-        builder.append('\n').append(INDENT);
-        // TODO(beder): Refactor the formatters so we don't need these instanceof checks.
-        if (binding instanceof ProvisionBinding) {
-          builder.append(provisionBindingFormatter.format((ProvisionBinding) binding));
-        } else if (binding instanceof ProductionBinding) {
-          builder.append(productionBindingFormatter.format((ProductionBinding) binding));
-        }
+      new Formatter(builder)
+          .format(ErrorMessages.DUPLICATE_BINDINGS_FOR_KEY_FORMAT, formatRootRequestKey(path));
+      for (ContributionBinding binding :
+          Iterables.limit(resolvedBinding.contributionBindings(), DUPLICATE_SIZE_LIMIT)) {
+        builder.append('\n').append(INDENT).append(contributionBindingFormatter.format(binding));
       }
-      int numberOfOtherBindings = resolvedBinding.bindings().size() - DUPLICATE_SIZE_LIMIT;
+      int numberOfOtherBindings =
+          resolvedBinding.contributionBindings().size() - DUPLICATE_SIZE_LIMIT;
       if (numberOfOtherBindings > 0) {
         builder.append('\n').append(INDENT)
             .append("and ").append(numberOfOtherBindings).append(" other");
@@ -670,63 +838,187 @@ private void reportDuplicateBindings(Deque<ResolvedRequest> path) {
       if (numberOfOtherBindings > 1) {
         builder.append('s');
       }
-      reportBuilder.addItem(builder.toString(), path.getLast().request().requestElement());
+      reportBuilder.addError(builder.toString(), path.getLast().request().requestElement());
     }
 
     @SuppressWarnings("resource") // Appendable is a StringBuilder.
     private void reportMultipleBindingTypes(Deque<ResolvedRequest> path) {
       ResolvedBindings resolvedBinding = path.peek().binding();
       StringBuilder builder = new StringBuilder();
-      new Formatter(builder).format(ErrorMessages.MULTIPLE_BINDING_TYPES_FOR_KEY_FORMAT,
-          keyFormatter.format(path.peek().request().key()));
-      ImmutableListMultimap<BindingType, ContributionBinding> bindingsByType =
-          ContributionBinding.bindingTypesFor(resolvedBinding.contributionBindings());
-      for (BindingType type :
+      new Formatter(builder)
+          .format(ErrorMessages.MULTIPLE_BINDING_TYPES_FOR_KEY_FORMAT, formatRootRequestKey(path));
+      ImmutableListMultimap<ContributionType, ContributionBinding> bindingsByType =
+          ContributionBinding.contributionTypesFor(resolvedBinding.contributionBindings());
+      for (ContributionType type :
           Ordering.natural().immutableSortedCopy(bindingsByType.keySet())) {
         builder.append(INDENT);
         builder.append(formatBindingType(type));
         builder.append(" bindings:\n");
         for (ContributionBinding binding : bindingsByType.get(type)) {
-          builder.append(INDENT).append(INDENT);
-          if (binding instanceof ProvisionBinding) {
-            builder.append(provisionBindingFormatter.format((ProvisionBinding) binding));
-          } else if (binding instanceof ProductionBinding) {
-            builder.append(productionBindingFormatter.format((ProductionBinding) binding));
-          }
-          builder.append('\n');
+          builder
+              .append(INDENT)
+              .append(INDENT)
+              .append(contributionBindingFormatter.format(binding))
+              .append('\n');
         }
       }
-      reportBuilder.addItem(builder.toString(), path.getLast().request().requestElement());
-    }
-
-    private void reportCycle(DependencyRequest request, Deque<ResolvedRequest> path) {
-      ImmutableList<DependencyRequest> pathElements = ImmutableList.<DependencyRequest>builder()
-          .add(request)
-          .addAll(Iterables.transform(path, REQUEST_FROM_RESOLVED_REQUEST))
-          .build();
-      ImmutableList<String> printableDependencyPath = FluentIterable.from(pathElements)
-          .transform(dependencyRequestFormatter)
-          .filter(Predicates.not(Predicates.equalTo("")))
-          .toList()
-          .reverse();
-      DependencyRequest rootRequest = path.getLast().request();
-      TypeElement componentType =
-          MoreElements.asType(rootRequest.requestElement().getEnclosingElement());
-      // TODO(cgruber): Restructure to provide a hint for the start and end of the cycle.
+      reportBuilder.addError(builder.toString(), path.getLast().request().requestElement());
+    }
+
+    private void reportDuplicateMapKeys(
+        Deque<ResolvedRequest> path, Collection<ContributionBinding> mapBindings) {
+      StringBuilder builder = new StringBuilder();
+      builder.append(duplicateMapKeysError(formatRootRequestKey(path)));
+      appendBindings(builder, mapBindings, 1);
+      reportBuilder.addError(builder.toString(), path.getLast().request().requestElement());
+    }
+
+    private void reportInconsistentMapKeyAnnotations(
+        Deque<ResolvedRequest> path,
+        Multimap<Equivalence.Wrapper<DeclaredType>, ContributionBinding>
+            mapBindingsByAnnotationType) {
+      StringBuilder builder =
+          new StringBuilder(inconsistentMapKeyAnnotationsError(formatRootRequestKey(path)));
+      for (Map.Entry<Equivalence.Wrapper<DeclaredType>, Collection<ContributionBinding>> entry :
+          mapBindingsByAnnotationType.asMap().entrySet()) {
+        DeclaredType annotationType = entry.getKey().get();
+        Collection<ContributionBinding> bindings = entry.getValue();
+
+        builder
+            .append('\n')
+            .append(INDENT)
+            .append(annotationType)
+            .append(':');
+
+        appendBindings(builder, bindings, 2);
+      }
+      reportBuilder.addError(builder.toString(), path.getLast().request().requestElement());
+    }
+
+    /**
+     * Reports a cycle in the binding path.
+     *
+     * @param bindingPath the binding path, starting with the component provision dependency, and
+     *     ending with the binding that depends on {@code request}
+     * @param request the request that would have been added to the binding path if its
+     *     {@linkplain DependencyRequest#bindingKey() binding key} wasn't already in it
+     * @param indexOfDuplicatedKey the index of the dependency request in {@code bindingPath} whose
+     *     {@linkplain DependencyRequest#bindingKey() binding key} matches {@code request}'s
+     */
+    private void reportCycle(
+        Iterable<ResolvedRequest> bindingPath,
+        DependencyRequest request,
+        int indexOfDuplicatedKey) {
+      ImmutableList<DependencyRequest> requestPath =
+          FluentIterable.from(bindingPath)
+              .transform(REQUEST_FROM_RESOLVED_REQUEST)
+              .append(request)
+              .toList();
+      Element rootRequestElement = requestPath.get(0).requestElement();
+      ImmutableList<DependencyRequest> cycle =
+          requestPath.subList(indexOfDuplicatedKey, requestPath.size());
+      Diagnostic.Kind kind = cycleHasProviderOrLazy(cycle) ? WARNING : ERROR;
+      if (kind == WARNING
+          && (suppressCycleWarnings(rootRequestElement)
+              || suppressCycleWarnings(rootRequestElement.getEnclosingElement())
+              || suppressCycleWarnings(cycle))) {
+        return;
+      }
+      // TODO(cgruber): Provide a hint for the start and end of the cycle.
+      TypeElement componentType = MoreElements.asType(rootRequestElement.getEnclosingElement());
       reportBuilder.addItem(
-          String.format(ErrorMessages.CONTAINS_DEPENDENCY_CYCLE_FORMAT,
+          String.format(
+              ErrorMessages.CONTAINS_DEPENDENCY_CYCLE_FORMAT,
               componentType.getQualifiedName(),
-              rootRequest.requestElement().getSimpleName(),
+              rootRequestElement.getSimpleName(),
               Joiner.on("\n")
-                  .join(printableDependencyPath.subList(1, printableDependencyPath.size()))),
-          rootRequest.requestElement());
+                  .join(
+                      FluentIterable.from(requestPath)
+                          .transform(dependencyRequestFormatter)
+                          .filter(not(equalTo("")))
+                          .skip(1))),
+          kind,
+          rootRequestElement);
+    }
+
+    /**
+     * Returns {@code true} if any step of a dependency cycle after the first is a {@link Provider}
+     * or {@link Lazy} or a {@code Map<K, Provider<V>>}.
+     *
+     * <p>If an implicit {@link Provider} dependency on {@code Map<K, Provider<V>>} is immediately
+     * preceded by a dependency on {@code Map<K, V>}, which means that the map's {@link Provider}s'
+     * {@link Provider#get() get()} methods are called during provision and so the cycle is not
+     * really broken.
+     */
+    private boolean cycleHasProviderOrLazy(ImmutableList<DependencyRequest> cycle) {
+      DependencyRequest lastDependencyRequest = cycle.get(0);
+      for (DependencyRequest dependencyRequest : skip(cycle, 1)) {
+        switch (dependencyRequest.kind()) {
+          case PROVIDER:
+            if (!isImplicitProviderMapForValueMap(dependencyRequest, lastDependencyRequest)) {
+              return true;
+            }
+            break;
+
+          case LAZY:
+            return true;
+
+          case INSTANCE:
+            if (isMapWithProvidedValues(dependencyRequest.key().type())) {
+              return true;
+            } else {
+              break;
+            }
+
+          default:
+            break;
+        }
+        lastDependencyRequest = dependencyRequest;
+      }
+      return false;
     }
+
+    /**
+     * Returns {@code true} if {@code maybeValueMapRequest}'s key type is {@code Map<K, V>} and
+     * {@code maybeProviderMapRequest}'s key type is {@code Map<K, Provider<V>>}, and both keys have
+     * the same qualifier.
+     */
+    private boolean isImplicitProviderMapForValueMap(
+        DependencyRequest maybeProviderMapRequest, DependencyRequest maybeValueMapRequest) {
+      TypeMirror maybeProviderMapRequestType = maybeProviderMapRequest.key().type();
+      TypeMirror maybeValueMapRequestType = maybeValueMapRequest.key().type();
+      return maybeProviderMapRequest
+              .key()
+              .wrappedQualifier()
+              .equals(maybeValueMapRequest.key().wrappedQualifier())
+          && isMapWithProvidedValues(maybeProviderMapRequestType)
+          && isMapWithNonProvidedValues(maybeValueMapRequestType)
+          && types.isSameType(
+              getKeyTypeOfMap(asDeclared(maybeProviderMapRequestType)),
+              getKeyTypeOfMap(asDeclared(maybeValueMapRequestType)))
+          && types.isSameType(
+              getProvidedValueTypeOfMap(asDeclared(maybeProviderMapRequestType)),
+              getValueTypeOfMap(asDeclared(maybeValueMapRequestType)));
+    }
+  }
+
+  private boolean suppressCycleWarnings(Element requestElement) {
+    SuppressWarnings suppressions = requestElement.getAnnotation(SuppressWarnings.class);
+    return suppressions != null && Arrays.asList(suppressions.value()).contains("dependency-cycle");
   }
 
-  @Override
-  public ValidationReport<BindingGraph> validate(final BindingGraph subject) {
+  private boolean suppressCycleWarnings(ImmutableList<DependencyRequest> pathElements) {
+    for (DependencyRequest dependencyRequest : pathElements) {
+      if (suppressCycleWarnings(dependencyRequest.requestElement())) {
+        return true;
+      }
+    }
+    return false;
+  }
+
+  ValidationReport<TypeElement> validate(BindingGraph subject) {
     Validation validation = new Validation(subject);
-    validation.validateSubgraph(subject);
+    validation.validateSubgraph();
     return validation.buildReport();
   }
 
@@ -736,9 +1028,9 @@ private void reportCycle(DependencyRequest request, Deque<ResolvedRequest> path)
   private void appendIndentedComponentsList(StringBuilder message, Iterable<TypeElement> types) {
     for (TypeElement scopedComponent : types) {
       message.append(INDENT);
-      Optional<AnnotationMirror> scope = getScopeAnnotation(scopedComponent);
+      Scope scope = Scope.scopeOf(scopedComponent);
       if (scope.isPresent()) {
-        message.append(ErrorMessages.format(scope.get())).append(' ');
+        message.append(scope.getReadableSource()).append(' ');
       }
       message.append(stripCommonTypePrefixes(scopedComponent.getQualifiedName().toString()))
           .append('\n');
@@ -752,7 +1044,7 @@ private void appendIndentedComponentsList(StringBuilder message, Iterable<TypeEl
   private ImmutableSet<TypeElement> scopedTypesIn(Set<TypeElement> types) {
     return FluentIterable.from(types).filter(new Predicate<TypeElement>() {
       @Override public boolean apply(TypeElement input) {
-        return getScopeAnnotation(input).isPresent();
+        return Scope.scopeOf(input).isPresent();
       }
     }).toSet();
   }
@@ -780,33 +1072,32 @@ private boolean doesPathRequireProvisionOnly(Deque<ResolvedRequest> path) {
     }
     // otherwise, the second-most-recent bindings determine whether the most recent one must be a
     // provision
-    ImmutableSet<ProvisionBinding> dependentProvisions = provisionsDependingOnLatestRequest(path);
-    return !dependentProvisions.isEmpty();
+    return !provisionsDependingOnLatestRequest(path).isEmpty();
   }
 
   /**
    * Returns any provision bindings resolved for the second-most-recent request in the given path;
    * that is, returns those provision bindings that depend on the latest request in the path.
    */
-  private ImmutableSet<ProvisionBinding> provisionsDependingOnLatestRequest(
+  private ImmutableSet<? extends Binding> provisionsDependingOnLatestRequest(
       Deque<ResolvedRequest> path) {
     Iterator<ResolvedRequest> iterator = path.iterator();
     final DependencyRequest request = iterator.next().request();
     ResolvedRequest previousResolvedRequest = iterator.next();
-    @SuppressWarnings("unchecked")  // validated by instanceof below
-    ImmutableSet<ProvisionBinding> bindings = (ImmutableSet<ProvisionBinding>) FluentIterable
-        .from(previousResolvedRequest.binding().bindings())
-        .filter(new Predicate<Binding>() {
-            @Override public boolean apply(Binding binding) {
-              return binding instanceof ProvisionBinding
-                  && binding.implicitDependencies().contains(request);
-            }
-        }).toSet();
-    return bindings;
+    return FluentIterable.from(previousResolvedRequest.binding().bindings())
+        .filter(Binding.Type.PROVISION)
+        .filter(
+            new Predicate<Binding>() {
+              @Override
+              public boolean apply(Binding binding) {
+                return binding.implicitDependencies().contains(request);
+              }
+            })
+        .toSet();
   }
 
-  private String formatBindingType(BindingType type) {
-    switch(type) {
+  private String formatBindingType(ContributionType type) {
+    switch (type) {
       case MAP:
         return "Map";
       case SET:
@@ -818,6 +1109,32 @@ private String formatBindingType(BindingType type) {
     }
   }
 
+  private String formatRootRequestKey(Deque<ResolvedRequest> path) {
+    return keyFormatter.format(path.peek().request().key());
+  }
+
+  private void appendBindings(
+      StringBuilder builder, Collection<ContributionBinding> bindings, int indentLevel) {
+    for (ContributionBinding binding : Iterables.limit(bindings, DUPLICATE_SIZE_LIMIT)) {
+      builder.append('\n');
+      for (int i = 0; i < indentLevel; i++) {
+        builder.append(INDENT);
+      }
+      builder.append(contributionBindingFormatter.format(binding));
+    }
+    int numberOfOtherBindings = bindings.size() - DUPLICATE_SIZE_LIMIT;
+    if (numberOfOtherBindings > 0) {
+      builder.append('\n');
+      for (int i = 0; i < indentLevel; i++) {
+        builder.append(INDENT);
+      }
+      builder.append("and ").append(numberOfOtherBindings).append(" other");
+    }
+    if (numberOfOtherBindings > 1) {
+      builder.append('s');
+    }
+  }
+
   @AutoValue
   abstract static class ResolvedRequest {
     abstract DependencyRequest request();
@@ -826,10 +1143,10 @@ private String formatBindingType(BindingType type) {
     static ResolvedRequest create(DependencyRequest request, BindingGraph graph) {
       BindingKey bindingKey = request.bindingKey();
       ResolvedBindings resolvedBindings = graph.resolvedBindings().get(bindingKey);
-      return new AutoValue_BindingGraphValidator_ResolvedRequest(request,
+      return new AutoValue_BindingGraphValidator_ResolvedRequest(
+          request,
           resolvedBindings == null
-              ? ResolvedBindings.create(bindingKey,
-                  ImmutableSet.<Binding>of(), ImmutableSet.<Binding>of())
+              ? ResolvedBindings.noBindings(bindingKey, graph.componentDescriptor())
               : resolvedBindings);
     }
   }
@@ -840,8 +1157,4 @@ static ResolvedRequest create(DependencyRequest request, BindingGraph graph) {
           return resolvedRequest.request();
         }
       };
-
-  abstract static class Traverser {
-    abstract boolean visitResolvedRequest(Deque<ResolvedRequest> path);
-  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/BuilderValidator.java b/compiler/src/main/java/dagger/internal/codegen/BuilderValidator.java
index 3bb85e3f9..ba96ebfd3 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BuilderValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BuilderValidator.java
@@ -43,33 +43,33 @@
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.STATIC;
 
-/** 
+/**
  * Validates {@link dagger.Component.Builder} annotations.
- * 
- * @author sameb@google.com (Sam Berlin)  
+ *
+ * @author sameb@google.com (Sam Berlin)
  */
-class BuilderValidator implements Validator<TypeElement> {
+class BuilderValidator {
   private final Elements elements;
   private final Types types;
   private final ComponentDescriptor.Kind componentType;
-  
+
   BuilderValidator(Elements elements, Types types, ComponentDescriptor.Kind componentType) {
     this.elements = elements;
     this.types = types;
     this.componentType = componentType;
   }
 
-  @Override public ValidationReport<TypeElement> validate(TypeElement subject) {
-    ValidationReport.Builder<TypeElement> builder = ValidationReport.Builder.about(subject);
+  public ValidationReport<TypeElement> validate(TypeElement subject) {
+    ValidationReport.Builder<TypeElement> builder = ValidationReport.about(subject);
 
     Element componentElement = subject.getEnclosingElement();
     ErrorMessages.ComponentBuilderMessages msgs = ErrorMessages.builderMsgsFor(componentType);
     Class<? extends Annotation> componentAnnotation = componentType.annotationType();
     Class<? extends Annotation> builderAnnotation = componentType.builderAnnotationType();
     checkArgument(subject.getAnnotation(builderAnnotation) != null);
-    
+
     if (!isAnnotationPresent(componentElement, componentAnnotation)) {
-      builder.addItem(msgs.mustBeInComponent(), subject);
+      builder.addError(msgs.mustBeInComponent(), subject);
     }
 
     switch (subject.getKind()) {
@@ -77,37 +77,36 @@
         List<? extends Element> allElements = subject.getEnclosedElements();
         List<ExecutableElement> cxtors = ElementFilter.constructorsIn(allElements);
         if (cxtors.size() != 1 || getOnlyElement(cxtors).getParameters().size() != 0) {
-          builder.addItem(msgs.cxtorOnlyOneAndNoArgs(), subject);
+          builder.addError(msgs.cxtorOnlyOneAndNoArgs(), subject);
         }
         break;
       case INTERFACE:
         break;
       default:
         // If not the correct type, exit early since the rest of the messages will be bogus.
-        builder.addItem(msgs.mustBeClassOrInterface(), subject);
-        return builder.build(); 
-    }    
+        builder.addError(msgs.mustBeClassOrInterface(), subject);
+        return builder.build();
+    }
 
-    
     if (!subject.getTypeParameters().isEmpty()) {
-      builder.addItem(msgs.generics(), subject);
+      builder.addError(msgs.generics(), subject);
     }
 
     Set<Modifier> modifiers = subject.getModifiers();
     if (modifiers.contains(PRIVATE)) {
-      builder.addItem(msgs.isPrivate(), subject);
+      builder.addError(msgs.isPrivate(), subject);
     }
     if (!modifiers.contains(STATIC)) {
-      builder.addItem(msgs.mustBeStatic(), subject);
+      builder.addError(msgs.mustBeStatic(), subject);
     }
     // Note: Must be abstract, so no need to check for final.
     if (!modifiers.contains(ABSTRACT)) {
-      builder.addItem(msgs.mustBeAbstract(), subject);
+      builder.addError(msgs.mustBeAbstract(), subject);
     }
-    
+
     ExecutableElement buildMethod = null;
     Multimap<Equivalence.Wrapper<TypeMirror>, ExecutableElement> methodsPerParam =
-        LinkedHashMultimap.create();    
+        LinkedHashMultimap.create();
     for (ExecutableElement method : Util.getUnimplementedMethods(elements, subject)) {
       ExecutableType resolvedMethodType =
           MoreTypes.asExecutable(types.asMemberOf(MoreTypes.asDeclared(subject.asType()), method));
@@ -141,33 +140,33 @@
                 Iterables.getOnlyElement(resolvedMethodType.getParameterTypes())),
             method);
       }
-      
+
       if (!method.getTypeParameters().isEmpty()) {
         error(builder, method, msgs.methodsMayNotHaveTypeParameters(),
             msgs.inheritedMethodsMayNotHaveTypeParameters());
       }
     }
-    
+
     if (buildMethod == null) {
-      builder.addItem(msgs.missingBuildMethod(), subject);
+      builder.addError(msgs.missingBuildMethod(), subject);
     }
-    
+
     // Go back through each recorded method per param type.  If we had more than one method
     // for a given param, fail.
     for (Map.Entry<Equivalence.Wrapper<TypeMirror>, Collection<ExecutableElement>> entry :
         methodsPerParam.asMap().entrySet()) {
       if (entry.getValue().size() > 1) {
         TypeMirror type = entry.getKey().get();
-        builder.addItem(String.format(msgs.manyMethodsForType(), type, entry.getValue()), subject);
+        builder.addError(String.format(msgs.manyMethodsForType(), type, entry.getValue()), subject);
       }
     }
-    
+
     // Note: there's more validation in BindingGraphValidator,
     // specifically to make sure the setter methods mirror the deps.
 
     return builder.build();
   }
-  
+
   /**
    * Generates one of two error messages. If the method is enclosed in the subject, we target the
    * error to the method itself. Otherwise we target the error to the subject and list the method as
@@ -182,19 +181,23 @@
    * of libfoo's SharedBuilder (which could have been compiled in a previous pass).
    * So we can't point to SharedBuilder#badSetter as the subject of the BarBuilder validation
    * failure.
-   * 
+   *
    * This check is a little more strict than necessary -- ideally we'd check if method's enclosing
    * class was included in this compile run.  But that's hard, and this is close enough.
    */
-  private void error(ValidationReport.Builder<TypeElement> builder, ExecutableElement method,
-      String enclosedError, String inheritedError, Object... extraArgs) {
+  private void error(
+      ValidationReport.Builder<TypeElement> builder,
+      ExecutableElement method,
+      String enclosedError,
+      String inheritedError,
+      Object... extraArgs) {
     if (method.getEnclosingElement().equals(builder.getSubject())) {
-      builder.addItem(String.format(enclosedError, extraArgs), method);
+      builder.addError(String.format(enclosedError, extraArgs), method);
     } else {
       Object[] newArgs = new Object[extraArgs.length + 1];
       newArgs[0] = method;
       System.arraycopy(extraArgs, 0, newArgs, 1, extraArgs.length);
-      builder.addItem(String.format(inheritedError, newArgs), builder.getSubject());
+      builder.addError(String.format(inheritedError, newArgs), builder.getSubject());
     }
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
index 906be8a57..650fb9dcc 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
@@ -15,12 +15,12 @@
  */
 package dagger.internal.codegen;
 
-import com.google.auto.common.AnnotationMirrors;
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
-import com.google.common.base.Equivalence;
 import com.google.common.base.Optional;
+import com.google.common.base.Predicate;
+import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
@@ -28,9 +28,11 @@
 import dagger.Component;
 import dagger.Lazy;
 import dagger.MembersInjector;
+import dagger.Module;
 import dagger.Subcomponent;
 import dagger.producers.ProductionComponent;
 import java.lang.annotation.Annotation;
+import java.util.EnumSet;
 import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Map;
@@ -49,15 +51,13 @@
 
 import static com.google.auto.common.MoreElements.getAnnotationMirror;
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
+import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Verify.verify;
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static dagger.internal.codegen.ConfigurationAnnotations.enclosedBuilders;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentModules;
 import static dagger.internal.codegen.ConfigurationAnnotations.isComponent;
-import static dagger.internal.codegen.InjectionAnnotations.getScopeAnnotation;
-import static dagger.internal.codegen.Util.unwrapOptionalEquivalence;
-import static dagger.internal.codegen.Util.wrapOptionalInEquivalence;
 import static javax.lang.model.type.TypeKind.DECLARED;
 import static javax.lang.model.type.TypeKind.VOID;
 
@@ -72,16 +72,40 @@
   ComponentDescriptor() {}
 
   enum Kind {
-    COMPONENT(Component.class, Component.Builder.class),
-    SUBCOMPONENT(Subcomponent.class, Subcomponent.Builder.class),
-    PRODUCTION_COMPONENT(ProductionComponent.class, null);
+    COMPONENT(Component.class, Component.Builder.class, true),
+    SUBCOMPONENT(Subcomponent.class, Subcomponent.Builder.class, false),
+    PRODUCTION_COMPONENT(ProductionComponent.class, ProductionComponent.Builder.class, true);
 
     private final Class<? extends Annotation> annotationType;
     private final Class<? extends Annotation> builderType;
+    private final boolean isTopLevel;
+
+    /**
+     * Returns the kind of an annotated element if it is annotated with one of the
+     * {@linkplain #annotationType() annotation types}.
+     *
+     * @throws IllegalArgumentException if the element is annotated with more than one of the
+     *     annotation types
+     */
+    static Optional<Kind> forAnnotatedElement(TypeElement element) {
+      Set<Kind> kinds = EnumSet.noneOf(Kind.class);
+      for (Kind kind : values()) {
+        if (MoreElements.isAnnotationPresent(element, kind.annotationType())) {
+          kinds.add(kind);
+        }
+      }
+      checkArgument(
+          kinds.size() <= 1, "%s cannot be annotated with more than one of %s", element, kinds);
+      return Optional.fromNullable(getOnlyElement(kinds, null));
+    }
 
-    Kind(Class<? extends Annotation> annotationType, Class<? extends Annotation> builderType) {
+    Kind(
+        Class<? extends Annotation> annotationType,
+        Class<? extends Annotation> builderType,
+        boolean isTopLevel) {
       this.annotationType = annotationType;
       this.builderType = builderType;
+      this.isTopLevel = isTopLevel;
     }
 
     Class<? extends Annotation> annotationType() {
@@ -91,6 +115,10 @@
     Class<? extends Annotation> builderAnnotationType() {
       return builderType;
     }
+
+    boolean isTopLevel() {
+      return isTopLevel;
+    }
   }
 
   abstract Kind kind();
@@ -108,8 +136,20 @@
    */
   abstract ImmutableSet<TypeElement> dependencies();
 
+  /**
+   * The set of {@link ModuleDescriptor modules} declared directly in {@link Component#modules}.
+   * Use {@link #transitiveModules} to get the full set of modules available upon traversing
+   * {@link Module#includes}.
+   */
   abstract ImmutableSet<ModuleDescriptor> modules();
 
+  /**
+   * Returns the set of {@link ModuleDescriptor modules} declared in {@link Component#modules} and
+   * those reachable by traversing {@link Module#includes}.
+   *
+   * <p>Note that for subcomponents this <em>will not</em> include descriptors for any modules that
+   * are declared in parent components.
+   */
   ImmutableSet<ModuleDescriptor> transitiveModules() {
     Set<ModuleDescriptor> transitiveModules = new LinkedHashSet<>();
     for (ModuleDescriptor module : modules()) {
@@ -118,6 +158,12 @@
     return ImmutableSet.copyOf(transitiveModules);
   }
 
+  ImmutableSet<TypeElement> transitiveModuleTypes() {
+    return FluentIterable.from(transitiveModules())
+        .transform(ModuleDescriptor.getModuleElement())
+        .toSet();
+  }
+
   private static Set<ModuleDescriptor> addTransitiveModules(
       Set<ModuleDescriptor> transitiveModules, ModuleDescriptor module) {
     if (transitiveModules.add(module)) {
@@ -141,20 +187,11 @@
   abstract Optional<TypeElement> executorDependency();
 
   /**
-   * An optional annotation constraining the scope of this component.
-   */
-  Optional<AnnotationMirror> scope() {
-    return unwrapOptionalEquivalence(wrappedScope());
-  }
-
-  /**
-   * An optional annotation constraining the scope of this component wrapped in an
-   * {@link com.google.common.base.Equivalence.Wrapper} to preserve comparison semantics of
-   * {@link AnnotationMirror}.
+   * The scope of the component.
    */
-  abstract Optional<Equivalence.Wrapper<AnnotationMirror>> wrappedScope();
+  abstract Scope scope();
 
-  abstract ImmutableMap<ExecutableElement, ComponentDescriptor> subcomponents();
+  abstract ImmutableMap<ComponentMethodDescriptor, ComponentDescriptor> subcomponents();
 
   abstract ImmutableSet<ComponentMethodDescriptor> componentMethods();
 
@@ -167,6 +204,18 @@
     abstract ComponentMethodKind kind();
     abstract Optional<DependencyRequest> dependencyRequest();
     abstract ExecutableElement methodElement();
+    
+    /**
+     * A predicate that passes for {@link ComponentMethodDescriptor}s of a given kind.
+     */
+    static Predicate<ComponentMethodDescriptor> isOfKind(final ComponentMethodKind kind) {
+      return new Predicate<ComponentMethodDescriptor>() {
+        @Override
+        public boolean apply(ComponentMethodDescriptor descriptor) {
+          return kind.equals(descriptor.kind());
+        }
+      };
+    }
   }
 
   enum ComponentMethodKind {
@@ -176,7 +225,7 @@
     SUBCOMPONENT,
     SUBCOMPONENT_BUILDER,
   }
-
+  
   @AutoValue
   static abstract class BuilderSpec {
     abstract TypeElement builderDefinitionType();
@@ -202,12 +251,17 @@
       this.moduleDescriptorFactory = moduleDescriptorFactory;
     }
 
+    /**
+     * Returns a component descriptor for a type annotated with either {@link Component @Component}
+     * or {@link ProductionComponent @ProductionComponent}.
+     */
     ComponentDescriptor forComponent(TypeElement componentDefinitionType) {
-      return create(componentDefinitionType, Kind.COMPONENT);
-    }
-
-    ComponentDescriptor forProductionComponent(TypeElement componentDefinitionType) {
-      return create(componentDefinitionType, Kind.PRODUCTION_COMPONENT);
+      Optional<Kind> kind = Kind.forAnnotatedElement(componentDefinitionType);
+      checkArgument(
+          kind.isPresent() && kind.get().isTopLevel(),
+          "%s must be annotated with @Component or @ProductionComponent",
+          componentDefinitionType);
+      return create(componentDefinitionType, kind.get());
     }
 
     private ComponentDescriptor create(TypeElement componentDefinitionType, Kind kind) {
@@ -243,6 +297,9 @@ private ComponentDescriptor create(TypeElement componentDefinitionType, Kind kin
       for (TypeMirror moduleIncludesType : getComponentModules(componentMirror)) {
         modules.add(moduleDescriptorFactory.create(MoreTypes.asTypeElement(moduleIncludesType)));
       }
+      if (kind.equals(Kind.PRODUCTION_COMPONENT)) {
+        modules.add(descriptorForMonitoringModule(componentDefinitionType));
+      }
 
       ImmutableSet<ExecutableElement> unimplementedMethods =
           Util.getUnimplementedMethods(elements, componentDefinitionType);
@@ -250,7 +307,7 @@ private ComponentDescriptor create(TypeElement componentDefinitionType, Kind kin
       ImmutableSet.Builder<ComponentMethodDescriptor> componentMethodsBuilder =
           ImmutableSet.builder();
 
-      ImmutableMap.Builder<ExecutableElement, ComponentDescriptor> subcomponentDescriptors =
+      ImmutableMap.Builder<ComponentMethodDescriptor, ComponentDescriptor> subcomponentDescriptors =
           ImmutableMap.builder();
       for (ExecutableElement componentMethod : unimplementedMethods) {
         ExecutableType resolvedMethod =
@@ -260,13 +317,18 @@ private ComponentDescriptor create(TypeElement componentDefinitionType, Kind kin
         componentMethodsBuilder.add(componentMethodDescriptor);
         switch (componentMethodDescriptor.kind()) {
           case SUBCOMPONENT:
-            subcomponentDescriptors.put(componentMethod,
-                create(MoreElements.asType(MoreTypes.asElement(resolvedMethod.getReturnType())),
+            subcomponentDescriptors.put(
+                componentMethodDescriptor,
+                create(
+                    MoreElements.asType(MoreTypes.asElement(resolvedMethod.getReturnType())),
                     Kind.SUBCOMPONENT));
             break;
           case SUBCOMPONENT_BUILDER:
-            subcomponentDescriptors.put(componentMethod, create(MoreElements.asType(
-                MoreTypes.asElement(resolvedMethod.getReturnType()).getEnclosingElement()),
+            subcomponentDescriptors.put(
+                componentMethodDescriptor,
+                create(
+                    MoreElements.asType(
+                        MoreTypes.asElement(resolvedMethod.getReturnType()).getEnclosingElement()),
                     Kind.SUBCOMPONENT));
             break;
           default: // nothing special to do for other methods.
@@ -280,7 +342,7 @@ private ComponentDescriptor create(TypeElement componentDefinitionType, Kind kin
       Optional<DeclaredType> builderType =
           Optional.fromNullable(getOnlyElement(enclosedBuilders, null));
 
-      Optional<AnnotationMirror> scope = getScopeAnnotation(componentDefinitionType);
+      Scope scope = Scope.scopeOf(componentDefinitionType);
       return new AutoValue_ComponentDescriptor(
           kind,
           componentMirror,
@@ -289,7 +351,7 @@ private ComponentDescriptor create(TypeElement componentDefinitionType, Kind kin
           modules.build(),
           dependencyMethodIndex.build(),
           executorDependency,
-          wrapOptionalInEquivalence(AnnotationMirrors.equivalence(), scope),
+          scope,
           subcomponentDescriptors.build(),
           componentMethodsBuilder.build(),
           createBuilderSpec(builderType));
@@ -388,6 +450,23 @@ private ComponentMethodDescriptor getDescriptorForComponentMethod(TypeElement co
       return Optional.<BuilderSpec>of(new AutoValue_ComponentDescriptor_BuilderSpec(element,
           map.build(), buildMethod, element.getEnclosingElement().asType()));
     }
+
+    /**
+     * Returns a descriptor for a generated module that handles monitoring for production
+     * components. This module is generated in the {@link MonitoringModuleProcessingStep}.
+     *
+     * @throws TypeNotPresentException if the module has not been generated yet. This will cause the
+     *     processor to retry in a later processing round.
+     */
+    private ModuleDescriptor descriptorForMonitoringModule(TypeElement componentDefinitionType) {
+      String generatedMonitorModuleName =
+          SourceFiles.generatedMonitoringModuleName(componentDefinitionType).canonicalName();
+      TypeElement monitoringModule = elements.getTypeElement(generatedMonitorModuleName);
+      if (monitoringModule == null) {
+        throw new TypeNotPresentException(generatedMonitorModuleName, null);
+      }
+      return moduleDescriptorFactory.create(monitoringModule);
+    }
   }
 
   static boolean isComponentContributionMethod(Elements elements, ExecutableElement method) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
index 1584945ae..72e761cbf 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
@@ -15,102 +15,22 @@
  */
 package dagger.internal.codegen;
 
-import com.google.auto.common.MoreElements;
-import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
-import com.google.common.base.CaseFormat;
-import com.google.common.base.Function;
-import com.google.common.base.Functions;
-import com.google.common.base.Joiner;
 import com.google.common.base.Optional;
-import com.google.common.base.Predicate;
-import com.google.common.base.Predicates;
-import com.google.common.collect.FluentIterable;
-import com.google.common.collect.ImmutableList;
-import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.Iterables;
-import com.google.common.collect.Lists;
-import com.google.common.collect.Maps;
-import com.google.common.collect.Sets;
-import com.google.common.util.concurrent.ListenableFuture;
 import dagger.Component;
-import dagger.MembersInjector;
-import dagger.internal.Factory;
-import dagger.internal.InstanceFactory;
-import dagger.internal.MapFactory;
-import dagger.internal.MapProviderFactory;
-import dagger.internal.MembersInjectors;
-import dagger.internal.ScopedProvider;
-import dagger.internal.SetFactory;
-import dagger.internal.codegen.ComponentDescriptor.BuilderSpec;
-import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
-import dagger.internal.codegen.ContributionBinding.BindingType;
 import dagger.internal.codegen.writer.ClassName;
 import dagger.internal.codegen.writer.ClassWriter;
-import dagger.internal.codegen.writer.ConstructorWriter;
 import dagger.internal.codegen.writer.FieldWriter;
 import dagger.internal.codegen.writer.JavaWriter;
-import dagger.internal.codegen.writer.MethodWriter;
-import dagger.internal.codegen.writer.ParameterizedTypeName;
 import dagger.internal.codegen.writer.Snippet;
-import dagger.internal.codegen.writer.StringLiteral;
 import dagger.internal.codegen.writer.TypeName;
-import dagger.internal.codegen.writer.TypeNames;
-import dagger.internal.codegen.writer.TypeWriter;
-import dagger.internal.codegen.writer.VoidName;
-import dagger.producers.Producer;
-import dagger.producers.internal.Producers;
-import dagger.producers.internal.SetProducer;
-import java.util.Collection;
-import java.util.EnumSet;
-import java.util.List;
-import java.util.Map;
-import java.util.Map.Entry;
-import java.util.Set;
-import javax.annotation.Generated;
 import javax.annotation.processing.Filer;
-import javax.inject.Provider;
 import javax.lang.model.element.Element;
-import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.Modifier;
-import javax.lang.model.element.Name;
-import javax.lang.model.element.TypeElement;
-import javax.lang.model.element.VariableElement;
-import javax.lang.model.type.DeclaredType;
-import javax.lang.model.type.ExecutableType;
-import javax.lang.model.type.TypeKind;
-import javax.lang.model.type.TypeMirror;
-import javax.lang.model.util.ElementKindVisitor6;
+import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 import javax.tools.Diagnostic;
 
-import static com.google.auto.common.MoreTypes.asDeclared;
-import static com.google.common.base.CaseFormat.LOWER_CAMEL;
-import static com.google.common.base.Preconditions.checkState;
-import static com.google.common.base.Verify.verify;
-import static com.google.common.collect.Iterables.getOnlyElement;
-import static dagger.internal.codegen.Binding.bindingPackageFor;
-import static dagger.internal.codegen.ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD;
-import static dagger.internal.codegen.MapKeys.getMapKeySnippet;
-import static dagger.internal.codegen.MembersInjectionBinding.Strategy.NO_OP;
-import static dagger.internal.codegen.ProvisionBinding.FactoryCreationStrategy.ENUM_INSTANCE;
-import static dagger.internal.codegen.ProvisionBinding.Kind.PROVISION;
-import static dagger.internal.codegen.SourceFiles.factoryNameForProductionBinding;
-import static dagger.internal.codegen.SourceFiles.factoryNameForProvisionBinding;
-import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
-import static dagger.internal.codegen.SourceFiles.membersInjectorNameForMembersInjectionBinding;
-import static dagger.internal.codegen.Util.componentCanMakeNewInstances;
-import static dagger.internal.codegen.Util.getKeyTypeOfMap;
-import static dagger.internal.codegen.Util.getProvidedValueTypeOfMap;
-import static javax.lang.model.element.Modifier.ABSTRACT;
-import static javax.lang.model.element.Modifier.FINAL;
-import static javax.lang.model.element.Modifier.PRIVATE;
-import static javax.lang.model.element.Modifier.PUBLIC;
-import static javax.lang.model.element.Modifier.STATIC;
-import static javax.lang.model.type.TypeKind.DECLARED;
-import static javax.lang.model.type.TypeKind.VOID;
-
 /**
  * Generates the implementation of the abstract types annotated with {@link Component}.
  *
@@ -119,11 +39,20 @@
  */
 final class ComponentGenerator extends SourceFileGenerator<BindingGraph> {
   private final Types types;
+  private final Elements elements;
+  private final Key.Factory keyFactory;
   private final Diagnostic.Kind nullableValidationType;
 
-  ComponentGenerator(Filer filer, Types types, Diagnostic.Kind nullableValidationType) {
+  ComponentGenerator(
+      Filer filer,
+      Elements elements,
+      Types types,
+      Key.Factory keyFactory,
+      Diagnostic.Kind nullableValidationType) {
     super(filer);
     this.types = types;
+    this.elements = elements;
+    this.keyFactory = keyFactory;
     this.nullableValidationType = nullableValidationType;
   }
 
@@ -131,8 +60,7 @@
   ClassName nameGeneratedType(BindingGraph input) {
     ClassName componentDefinitionClassName =
         ClassName.fromTypeElement(input.componentDescriptor().componentDefinitionType());
-    String componentName =
-        "Dagger" + componentDefinitionClassName.classFileName().replace('$', '_');
+    String componentName = "Dagger" + componentDefinitionClassName.classFileName('_');
     return componentDefinitionClassName.topLevelClassName().peerNamed(componentName);
   }
 
@@ -146,16 +74,6 @@ ClassName nameGeneratedType(BindingGraph input) {
     return Optional.of(input.componentDescriptor().componentDefinitionType());
   }
 
-  @AutoValue
-  static abstract class ProxyClassAndField {
-    abstract ClassWriter proxyWriter();
-    abstract FieldWriter proxyFieldWriter();
-
-    static ProxyClassAndField create(ClassWriter proxyWriter, FieldWriter proxyFieldWriter) {
-      return new AutoValue_ComponentGenerator_ProxyClassAndField(proxyWriter, proxyFieldWriter);
-    }
-  }
-
   @AutoValue static abstract class MemberSelect {
     static MemberSelect instanceSelect(ClassName owningClass, Snippet snippet) {
       return new AutoValue_ComponentGenerator_MemberSelect(
@@ -196,1172 +114,14 @@ Snippet getSnippetWithRawTypeCastFor(ClassName usingClass) {
     }
 
     Snippet getSnippetFor(ClassName usingClass) {
-      return owningClass().equals(usingClass)
-          ? snippet()
-          : qualifiedSelectSnippet();
+      return owningClass().equals(usingClass) ? snippet() : qualifiedSelectSnippet();
     }
   }
 
   @Override
   ImmutableSet<JavaWriter> write(ClassName componentName, BindingGraph input) {
-    TypeElement componentDefinitionType = input.componentDescriptor().componentDefinitionType();
-    ClassName componentDefinitionTypeName =
-        ClassName.fromTypeElement(componentDefinitionType);
-
-    JavaWriter writer = JavaWriter.inPackage(componentName.packageName());
-
-    ClassWriter componentWriter = writer.addClass(componentName.simpleName());
-    componentWriter.annotate(Generated.class).setValue(ComponentProcessor.class.getCanonicalName());
-    componentWriter.addModifiers(PUBLIC, FINAL);
-    checkState(componentDefinitionType.getModifiers().contains(ABSTRACT));
-    componentWriter.setSupertype(componentDefinitionType);
-
-    Set<JavaWriter> javaWriters = Sets.newHashSet();
-    javaWriters.add(writer);
-    writeComponent(input, componentDefinitionTypeName, componentWriter, javaWriters);
-
-    return ImmutableSet.copyOf(javaWriters);
-  }
-
-  /**
-   * Writes out a builder for a component or subcomponent.
-   *
-   * @param input the component or subcomponent
-   * @param componentApiName the API name of the component we're building (not our impl)
-   * @param componentImplName the implementation name of the component we're building
-   * @param componentWriter the class we're adding this builder to
-   * @param componentContributionFields a map of member selects so we can later use the fields
-   */
-  private ClassWriter writeBuilder(BindingGraph input, ClassName componentApiName,
-      ClassName componentImplName, ClassWriter componentWriter,
-      Map<TypeElement, MemberSelect> componentContributionFields) {
-    ClassWriter builderWriter;
-    Optional<BuilderSpec> builderSpec = input.componentDescriptor().builderSpec();
-    switch (input.componentDescriptor().kind()) {
-      case COMPONENT:
-      case PRODUCTION_COMPONENT:
-        builderWriter = componentWriter.addNestedClass("Builder");
-        builderWriter.addModifiers(STATIC);
-
-        // Only top-level components have the factory builder() method.
-        // Mirror the user's builder API type if they had one.
-        MethodWriter builderFactoryMethod = builderSpec.isPresent()
-            ? componentWriter.addMethod(
-                builderSpec.get().builderDefinitionType().asType(), "builder")
-            : componentWriter.addMethod(builderWriter, "builder");
-        builderFactoryMethod.addModifiers(PUBLIC, STATIC);
-        builderFactoryMethod.body().addSnippet("return new %s();", builderWriter.name());
-        break;
-      case SUBCOMPONENT:
-        verify(builderSpec.isPresent()); // we only write subcomponent builders if there was a spec
-        builderWriter =
-            componentWriter.addNestedClass(componentApiName.simpleName() + "Builder");
-        break;
-      default:
-        throw new IllegalStateException();
-    }
-    builderWriter.addModifiers(FINAL);
-    builderWriter.addConstructor().addModifiers(PRIVATE);
-    if (builderSpec.isPresent()) {
-      builderWriter.addModifiers(PRIVATE);
-      builderWriter.setSupertype(builderSpec.get().builderDefinitionType());
-    } else {
-      builderWriter.addModifiers(PUBLIC);
-    }
-
-    // the full set of types that calling code uses to construct a component instance
-    ImmutableMap<TypeElement, String> componentContributionNames =
-        ImmutableMap.copyOf(Maps.asMap(
-            input.componentRequirements(),
-            Functions.compose(
-                CaseFormat.UPPER_CAMEL.converterTo(LOWER_CAMEL),
-                new Function<TypeElement, String>() {
-                  @Override public String apply(TypeElement input) {
-                    return input.getSimpleName().toString();
-                  }
-                })));
-
-    MethodWriter buildMethod;
-    if (builderSpec.isPresent()) {
-      ExecutableElement specBuildMethod = builderSpec.get().buildMethod();
-      // Note: we don't use the specBuildMethod.getReturnType() as the return type
-      // because it might be a type variable.  We make use of covariant returns to allow
-      // us to return the component type, which will always be valid.
-      buildMethod = builderWriter.addMethod(componentApiName,
-          specBuildMethod.getSimpleName().toString());
-      buildMethod.annotate(Override.class);
-    } else {
-      buildMethod = builderWriter.addMethod(componentApiName, "build");
-    }
-    buildMethod.addModifiers(PUBLIC);
-
-    for (Entry<TypeElement, String> entry : componentContributionNames.entrySet()) {
-      TypeElement contributionElement = entry.getKey();
-      String contributionName = entry.getValue();
-      FieldWriter builderField = builderWriter.addField(contributionElement, contributionName);
-      builderField.addModifiers(PRIVATE);
-      componentContributionFields.put(contributionElement, MemberSelect.instanceSelect(
-          componentImplName, Snippet.format("builder.%s", builderField.name())));
-      if (componentCanMakeNewInstances(contributionElement)) {
-        buildMethod.body()
-            .addSnippet("if (%s == null) {", builderField.name())
-            .addSnippet("  this.%s = new %s();",
-                builderField.name(), ClassName.fromTypeElement(contributionElement))
-            .addSnippet("}");
-      } else {
-        buildMethod.body()
-            .addSnippet("if (%s == null) {", builderField.name())
-            .addSnippet("  throw new IllegalStateException(\"%s must be set\");",
-                builderField.name())
-            .addSnippet("}");
-      }
-      MethodWriter builderMethod;
-      boolean returnsVoid = false;
-      if (builderSpec.isPresent()) {
-        ExecutableElement method = builderSpec.get().methodMap().get(contributionElement);
-        if (method == null) { // no method in the API, nothing to write out.
-          continue;
-        }
-        // If the return type is void, we add a method with the void return type.
-        // Otherwise we use the builderWriter and take advantage of covariant returns
-        // (so that we don't have to worry about setter methods that return type variables).
-        if (method.getReturnType().getKind().equals(TypeKind.VOID)) {
-          returnsVoid = true;
-          builderMethod =
-              builderWriter.addMethod(method.getReturnType(), method.getSimpleName().toString());
-        } else {
-          builderMethod = builderWriter.addMethod(builderWriter, method.getSimpleName().toString());
-        }
-        builderMethod.annotate(Override.class);
-      } else {
-        builderMethod = builderWriter.addMethod(builderWriter, contributionName);
-      }
-      // TODO(gak): Mirror the API's visibility.
-      // (Makes no difference to the user since this class is private,
-      //  but makes generated code prettier.)
-      builderMethod.addModifiers(PUBLIC);
-      builderMethod.addParameter(contributionElement, contributionName);
-      builderMethod.body()
-          .addSnippet("if (%s == null) {", contributionName)
-          .addSnippet("  throw new NullPointerException(%s);",
-              StringLiteral.forValue(contributionName))
-          .addSnippet("}")
-          .addSnippet("this.%s = %s;", builderField.name(), contributionName);
-      if (!returnsVoid) {
-        builderMethod.body().addSnippet("return this;");
-      }
-    }
-    buildMethod.body().addSnippet("return new %s(this);", componentImplName);
-    return builderWriter;
-  }
-
-  /** Returns true if the graph has any dependents that can't be automatically constructed. */
-  private boolean requiresUserSuppliedDependents(BindingGraph input) {
-    Set<TypeElement> userRequiredDependents =
-        Sets.filter(input.componentRequirements(), new Predicate<TypeElement>() {
-          @Override public boolean apply(TypeElement input) {
-            return !Util.componentCanMakeNewInstances(input);
-          }
-        });
-    return !userRequiredDependents.isEmpty();
-  }
-
-  private ImmutableMap<BindingKey, MemberSelect> writeComponent(
-      BindingGraph input, ClassName componentDefinitionTypeName, ClassWriter componentWriter,
-      Set<JavaWriter> proxyWriters) {
-    Map<TypeElement, MemberSelect> componentContributionFields = Maps.newHashMap();
-    ClassWriter builderWriter = writeBuilder(input, componentDefinitionTypeName,
-        componentWriter.name(), componentWriter, componentContributionFields);
-    if (!requiresUserSuppliedDependents(input)) {
-      MethodWriter factoryMethod = componentWriter.addMethod(componentDefinitionTypeName, "create");
-      factoryMethod.addModifiers(PUBLIC, STATIC);
-      // TODO(gak): replace this with something that doesn't allocate a builder
-      factoryMethod.body().addSnippet("return builder().%s();",
-          input.componentDescriptor().builderSpec().isPresent()
-              ? input.componentDescriptor().builderSpec().get().buildMethod().getSimpleName()
-              : "build");
-    }
-
-    Map<BindingKey, MemberSelect> memberSelectSnippetsBuilder = Maps.newHashMap();
-    Map<ContributionBinding, Snippet> multibindingContributionSnippetsBuilder = Maps.newHashMap();
-    ImmutableSet.Builder<BindingKey> enumBindingKeysBuilder = ImmutableSet.builder();
-
-    Map<String, ProxyClassAndField> packageProxies = Maps.newHashMap();
-
-    writeFields(input,
-        componentWriter,
-        proxyWriters,
-        memberSelectSnippetsBuilder,
-        multibindingContributionSnippetsBuilder,
-        enumBindingKeysBuilder,
-        packageProxies);
-
-    ImmutableMap<BindingKey, MemberSelect> memberSelectSnippets =
-        ImmutableMap.copyOf(memberSelectSnippetsBuilder);
-    ImmutableMap<ContributionBinding, Snippet> multibindingContributionSnippets =
-        ImmutableMap.copyOf(multibindingContributionSnippetsBuilder);
-    ImmutableSet<BindingKey> enumBindingKeys = enumBindingKeysBuilder.build();
-
-    ConstructorWriter constructorWriter = componentWriter.addConstructor();
-    constructorWriter.addModifiers(PRIVATE);
-    constructorWriter.addParameter(builderWriter, "builder");
-    constructorWriter.body().addSnippet("assert builder != null;");
-    initializeFrameworkTypes(input,
-        componentWriter,
-        constructorWriter,
-        Optional.of(builderWriter.name()),
-        componentContributionFields,
-        memberSelectSnippets,
-        ImmutableMap.<ContributionBinding, Snippet>of(),
-        multibindingContributionSnippets);
-
-    writeInterfaceMethods(input, componentWriter, memberSelectSnippets, enumBindingKeys);
-
-    for (Entry<ExecutableElement, BindingGraph> subgraphEntry : input.subgraphs().entrySet()) {
-      writeSubcomponent(componentWriter,
-          MoreTypes.asDeclared(input.componentDescriptor().componentDefinitionType().asType()),
-          proxyWriters,
-          memberSelectSnippets,
-          multibindingContributionSnippets,
-          subgraphEntry.getKey(),
-          subgraphEntry.getValue());
-    }
-
-    return memberSelectSnippets;
-  }
-
-  private void writeSubcomponent(ClassWriter componentWriter,
-      DeclaredType containingComponent,
-      Set<JavaWriter> proxyWriters,
-      ImmutableMap<BindingKey, MemberSelect> parentMemberSelectSnippets,
-      ImmutableMap<ContributionBinding, Snippet> parentMultibindingContributionSnippets,
-      ExecutableElement subcomponentFactoryMethod,
-      BindingGraph subgraph) {
-    ClassName subcomponentApiName =
-        ClassName.fromTypeElement(subgraph.componentDescriptor().componentDefinitionType());
-    ClassWriter subcomponentWriter =
-        componentWriter.addNestedClass(subcomponentApiName.simpleName() + "Impl");
-    subcomponentWriter.addModifiers(PRIVATE, FINAL);
-
-    ConstructorWriter constructorWriter = subcomponentWriter.addConstructor();
-    constructorWriter.addModifiers(PRIVATE);
-    constructorWriter.body();
-
-    Map<TypeElement, MemberSelect> componentContributionFields = Maps.newHashMap();
-    ImmutableList.Builder<Snippet> subcomponentConstructorParameters = ImmutableList.builder();
-
-    TypeMirror subcomponentType;
-    MethodWriter componentMethod;
-    Optional<ClassName> builderName;
-    if (subgraph.componentDescriptor().builderSpec().isPresent()) {
-      BuilderSpec spec = subgraph.componentDescriptor().builderSpec().get();
-      subcomponentType = spec.componentType();
-      componentMethod = componentWriter.addMethod(
-          ClassName.fromTypeElement(spec.builderDefinitionType()),
-          subcomponentFactoryMethod.getSimpleName().toString());
-      ClassWriter builderWriter = writeBuilder(subgraph, subcomponentApiName,
-          subcomponentWriter.name(), componentWriter, componentContributionFields);
-      builderName = Optional.of(builderWriter.name());
-      constructorWriter.addParameter(builderWriter, "builder");
-      constructorWriter.body().addSnippet("assert builder != null;");
-      componentMethod.body().addSnippet("return new %s();", builderWriter.name());
-    } else {
-      builderName = Optional.absent();
-      ExecutableType resolvedMethod =
-          MoreTypes.asExecutable(types.asMemberOf(containingComponent, subcomponentFactoryMethod));
-      subcomponentType = resolvedMethod.getReturnType();
-      componentMethod = componentWriter.addMethod(subcomponentType,
-          subcomponentFactoryMethod.getSimpleName().toString());
-      writeSubcomponentWithoutBuilder(subcomponentFactoryMethod,
-          subgraph,
-          subcomponentWriter,
-          constructorWriter,
-          componentContributionFields,
-          subcomponentConstructorParameters,
-          componentMethod,
-          resolvedMethod);
-    }
-    componentMethod.addModifiers(PUBLIC);
-    componentMethod.annotate(Override.class);
-
-    TypeElement subcomponentElement = MoreTypes.asTypeElement(subcomponentType);
-    checkState(subcomponentElement.getModifiers().contains(ABSTRACT));
-    subcomponentWriter.setSupertype(subcomponentElement);
-
-    Map<BindingKey, MemberSelect> memberSelectSnippetsBuilder = Maps.newHashMap();
-
-    Map<ContributionBinding, Snippet> multibindingContributionSnippetsBuilder = Maps.newHashMap();
-    ImmutableSet.Builder<BindingKey> enumBindingKeysBuilder = ImmutableSet.builder();
-
-    Map<String, ProxyClassAndField> packageProxies = Maps.newHashMap();
-
-    writeFields(subgraph,
-        subcomponentWriter,
-        proxyWriters,
-        memberSelectSnippetsBuilder,
-        multibindingContributionSnippetsBuilder,
-        enumBindingKeysBuilder,
-        packageProxies);
-
-    for (Entry<BindingKey, MemberSelect> parentBindingEntry :
-        parentMemberSelectSnippets.entrySet()) {
-      if (!memberSelectSnippetsBuilder.containsKey(parentBindingEntry.getKey())) {
-        memberSelectSnippetsBuilder.put(parentBindingEntry.getKey(), parentBindingEntry.getValue());
-      }
-    }
-
-    ImmutableMap<BindingKey, MemberSelect> memberSelectSnippets =
-        ImmutableMap.copyOf(memberSelectSnippetsBuilder);
-    ImmutableMap<ContributionBinding, Snippet> multibindingContributionSnippets =
-        ImmutableMap.copyOf(multibindingContributionSnippetsBuilder);
-    ImmutableSet<BindingKey> enumBindingKeys = enumBindingKeysBuilder.build();
-
-    initializeFrameworkTypes(subgraph,
-        subcomponentWriter,
-        constructorWriter,
-        builderName,
-        componentContributionFields,
-        memberSelectSnippets,
-        parentMultibindingContributionSnippets,
-        multibindingContributionSnippets);
-
-    writeInterfaceMethods(subgraph, subcomponentWriter, memberSelectSnippets, enumBindingKeys);
-
-    for (Entry<ExecutableElement, BindingGraph> subgraphEntry : subgraph.subgraphs().entrySet()) {
-      writeSubcomponent(subcomponentWriter,
-          MoreTypes.asDeclared(subgraph.componentDescriptor().componentDefinitionType().asType()),
-          proxyWriters,
-          memberSelectSnippets,
-          new ImmutableMap.Builder<ContributionBinding, Snippet>()
-              .putAll(parentMultibindingContributionSnippets)
-              .putAll(multibindingContributionSnippets)
-              .build(),
-          subgraphEntry.getKey(),
-          subgraphEntry.getValue());
-    }
-  }
-
-  private void writeSubcomponentWithoutBuilder(ExecutableElement subcomponentFactoryMethod,
-      BindingGraph subgraph,
-      ClassWriter subcomponentWriter,
-      ConstructorWriter constructorWriter,
-      Map<TypeElement, MemberSelect> componentContributionFields,
-      ImmutableList.Builder<Snippet> subcomponentConstructorParameters,
-      MethodWriter componentMethod,
-      ExecutableType resolvedMethod) {
-    List<? extends VariableElement> params = subcomponentFactoryMethod.getParameters();
-    List<? extends TypeMirror> paramTypes = resolvedMethod.getParameterTypes();
-    for (int i = 0; i < params.size(); i++) {
-      VariableElement moduleVariable = params.get(i);
-      TypeElement moduleTypeElement = MoreTypes.asTypeElement(paramTypes.get(i));
-      TypeName moduleType = TypeNames.forTypeMirror(paramTypes.get(i));
-      componentMethod.addParameter(moduleType, moduleVariable.getSimpleName().toString());
-      if (!componentContributionFields.containsKey(moduleTypeElement)) {
-        String preferredModuleName = CaseFormat.UPPER_CAMEL.to(LOWER_CAMEL,
-            moduleTypeElement.getSimpleName().toString());
-        FieldWriter contributionField =
-            subcomponentWriter.addField(moduleTypeElement, preferredModuleName);
-        contributionField.addModifiers(PRIVATE, FINAL);
-        String actualModuleName = contributionField.name();
-        constructorWriter.addParameter(moduleType, actualModuleName);
-        constructorWriter.body().addSnippet(Snippet.format(Joiner.on('\n').join(
-            "if (%s == null) {",
-            "  throw new NullPointerException();",
-            "}"), actualModuleName));
-        constructorWriter.body().addSnippet(
-            Snippet.format("this.%1$s = %1$s;", actualModuleName));
-        MemberSelect moduleSelect = MemberSelect.instanceSelect(
-            subcomponentWriter.name(), Snippet.format(actualModuleName));
-        componentContributionFields.put(moduleTypeElement, moduleSelect);
-        subcomponentConstructorParameters.add(
-            Snippet.format("%s", moduleVariable.getSimpleName()));
-      }
-    }
-
-    ImmutableSet<TypeElement> uninitializedModules =
-        FluentIterable.from(subgraph.componentDescriptor().transitiveModules())
-            .transform(ModuleDescriptor.getModuleElement())
-            .filter(Predicates.not(Predicates.in(componentContributionFields.keySet())))
-            .toSet();
-
-    for (TypeElement moduleType : uninitializedModules) {
-      String preferredModuleName = CaseFormat.UPPER_CAMEL.to(LOWER_CAMEL,
-          moduleType.getSimpleName().toString());
-      FieldWriter contributionField =
-          subcomponentWriter.addField(moduleType, preferredModuleName);
-      contributionField.addModifiers(PRIVATE, FINAL);
-      String actualModuleName = contributionField.name();
-      constructorWriter.body().addSnippet(
-          Snippet.format("this.%s = new %s();", actualModuleName,
-              ClassName.fromTypeElement(moduleType)));
-      MemberSelect moduleSelect = MemberSelect.instanceSelect(
-          subcomponentWriter.name(), Snippet.format(actualModuleName));
-      componentContributionFields.put(moduleType, moduleSelect);
-    }
-
-    componentMethod.body().addSnippet("return new %s(%s);",
-        subcomponentWriter.name(),
-        Snippet.makeParametersSnippet(subcomponentConstructorParameters.build()));
-  }
-
-  private void writeFields(BindingGraph input,
-      ClassWriter componentWriter,
-      Set<JavaWriter> proxyWriters,
-      Map<BindingKey, MemberSelect> memberSelectSnippetsBuilder,
-      Map<ContributionBinding, Snippet> multibindingContributionSnippetsBuilder,
-      ImmutableSet.Builder<BindingKey> enumBindingKeysBuilder,
-      Map<String, ProxyClassAndField> packageProxies) {
-    for (ResolvedBindings resolvedBindings : input.resolvedBindings().values()) {
-      writeField(
-          componentWriter,
-          proxyWriters,
-          memberSelectSnippetsBuilder,
-          multibindingContributionSnippetsBuilder,
-          enumBindingKeysBuilder,
-          packageProxies,
-          resolvedBindings);
-    }
-  }
-
-  private void writeField(
-      ClassWriter componentWriter,
-      Set<JavaWriter> proxyWriters,
-      Map<BindingKey, MemberSelect> memberSelectSnippetsBuilder,
-      Map<ContributionBinding, Snippet> multibindingContributionSnippetsBuilder,
-      ImmutableSet.Builder<BindingKey> enumBindingKeysBuilder,
-      Map<String, ProxyClassAndField> packageProxies, ResolvedBindings resolvedBindings) {
-    BindingKey bindingKey = resolvedBindings.bindingKey();
-
-    if (bindingKey.kind().equals(BindingKey.Kind.CONTRIBUTION)
-        && resolvedBindings.ownedContributionBindings().isEmpty()
-        && !ContributionBinding.bindingTypeFor(resolvedBindings.contributionBindings())
-            .isMultibinding()) {
-      return;
-    }
-
-    if (resolvedBindings.bindings().size() == 1) {
-      if (bindingKey.kind().equals(BindingKey.Kind.CONTRIBUTION)) {
-        ContributionBinding contributionBinding =
-            Iterables.getOnlyElement(resolvedBindings.contributionBindings());
-        if (!contributionBinding.bindingType().isMultibinding()
-            && (contributionBinding instanceof ProvisionBinding)) {
-          ProvisionBinding provisionBinding = (ProvisionBinding) contributionBinding;
-          if (provisionBinding.factoryCreationStrategy().equals(ENUM_INSTANCE)
-              && !provisionBinding.scope().isPresent()) {
-            enumBindingKeysBuilder.add(bindingKey);
-            // skip keys whose factories are enum instances and aren't scoped
-            memberSelectSnippetsBuilder.put(bindingKey,
-                MemberSelect.staticSelect(
-                    factoryNameForProvisionBinding(provisionBinding),
-                    Snippet.format("create()")));
-            return;
-          }
-        }
-      } else if (bindingKey.kind().equals(BindingKey.Kind.MEMBERS_INJECTION)) {
-        MembersInjectionBinding membersInjectionBinding =
-            Iterables.getOnlyElement(resolvedBindings.membersInjectionBindings());
-        if (membersInjectionBinding.injectionStrategy().equals(NO_OP)) {
-          // TODO(gak): refactor to use enumBindingKeys throughout the generator
-          enumBindingKeysBuilder.add(bindingKey);
-          // TODO(gak): suppress the warnings in a reasonable place
-          memberSelectSnippetsBuilder.put(bindingKey,
-              MemberSelect.staticMethodInvocationWithCast(
-                  ClassName.fromClass(MembersInjectors.class),
-                  Snippet.format("noOp()"),
-                  ClassName.fromClass(MembersInjector.class)));
-          return;
-        }
-      }
-    }
-
-    String bindingPackage = bindingPackageFor(resolvedBindings.bindings())
-        .or(componentWriter.name().packageName());
-
-    final Optional<String> proxySelector;
-    final TypeWriter classWithFields;
-    final Set<Modifier> fieldModifiers;
-
-    if (bindingPackage.equals(componentWriter.name().packageName())) {
-      // no proxy
-      proxySelector = Optional.absent();
-      // component gets the fields
-      classWithFields = componentWriter;
-      // private fields
-      fieldModifiers = EnumSet.of(PRIVATE);
-    } else {
-      // get or create the proxy
-      ProxyClassAndField proxyClassAndField = packageProxies.get(bindingPackage);
-      if (proxyClassAndField == null) {
-        JavaWriter proxyJavaWriter = JavaWriter.inPackage(bindingPackage);
-        proxyWriters.add(proxyJavaWriter);
-        ClassWriter proxyWriter =
-            proxyJavaWriter.addClass(componentWriter.name().simpleName() + "_PackageProxy");
-        proxyWriter.annotate(Generated.class)
-            .setValue(ComponentProcessor.class.getCanonicalName());
-        proxyWriter.addModifiers(PUBLIC, FINAL);
-        // create the field for the proxy in the component
-        FieldWriter proxyFieldWriter =
-            componentWriter.addField(proxyWriter.name(),
-                bindingPackage.replace('.', '_') + "_Proxy");
-        proxyFieldWriter.addModifiers(PRIVATE, FINAL);
-        proxyFieldWriter.setInitializer("new %s()", proxyWriter.name());
-        proxyClassAndField = ProxyClassAndField.create(proxyWriter, proxyFieldWriter);
-        packageProxies.put(bindingPackage, proxyClassAndField);
-      }
-      // add the field for the member select
-      proxySelector = Optional.of(proxyClassAndField.proxyFieldWriter().name());
-      // proxy gets the fields
-      classWithFields = proxyClassAndField.proxyWriter();
-      // public fields in the proxy
-      fieldModifiers = EnumSet.of(PUBLIC);
-    }
-
-    if (bindingKey.kind().equals(BindingKey.Kind.CONTRIBUTION)) {
-      ImmutableSet<? extends ContributionBinding> contributionBindings =
-          resolvedBindings.contributionBindings();
-      if (ContributionBinding.bindingTypeFor(contributionBindings).isMultibinding()) {
-        // note that here we rely on the order of the resolved bindings being from parent to child
-        // otherwise, the numbering wouldn't work
-        int contributionNumber = 0;
-        for (ContributionBinding contributionBinding : contributionBindings) {
-          if (!contributionBinding.isSyntheticBinding()) {
-            contributionNumber++;
-            if (resolvedBindings.ownedBindings().contains(contributionBinding)) {
-              FrameworkField contributionBindingField =
-                  frameworkFieldForSyntheticContributionBinding(
-                        bindingKey, contributionNumber, contributionBinding);
-              FieldWriter contributionField = classWithFields.addField(
-                  contributionBindingField.frameworkType(), contributionBindingField.name());
-              contributionField.addModifiers(fieldModifiers);
-
-              ImmutableList<String> contributionSelectTokens = new ImmutableList.Builder<String>()
-                  .addAll(proxySelector.asSet())
-                  .add(contributionField.name())
-                  .build();
-              multibindingContributionSnippetsBuilder.put(contributionBinding,
-                  Snippet.memberSelectSnippet(contributionSelectTokens));
-            }
-          }
-        }
-      }
-    }
-
-    FrameworkField bindingField = frameworkFieldForResolvedBindings(resolvedBindings);
-    FieldWriter frameworkField =
-        classWithFields.addField(bindingField.frameworkType(), bindingField.name());
-    frameworkField.addModifiers(fieldModifiers);
-
-    ImmutableList<String> memberSelectTokens = new ImmutableList.Builder<String>()
-        .addAll(proxySelector.asSet())
-        .add(frameworkField.name())
-        .build();
-    memberSelectSnippetsBuilder.put(bindingKey, MemberSelect.instanceSelect(
-        componentWriter.name(),
-        Snippet.memberSelectSnippet(memberSelectTokens)));
-  }
-
-  private void writeInterfaceMethods(BindingGraph input, ClassWriter componentWriter,
-      ImmutableMap<BindingKey, MemberSelect> memberSelectSnippets,
-      ImmutableSet<BindingKey> enumBindingKeys) throws AssertionError {
-    Set<MethodSignature> interfaceMethods = Sets.newHashSet();
-
-    for (ComponentMethodDescriptor componentMethod :
-        input.componentDescriptor().componentMethods()) {
-      if (componentMethod.dependencyRequest().isPresent()) {
-        DependencyRequest interfaceRequest = componentMethod.dependencyRequest().get();
-        ExecutableElement requestElement =
-            MoreElements.asExecutable(interfaceRequest.requestElement());
-        ExecutableType requestType = MoreTypes.asExecutable(types.asMemberOf(
-            MoreTypes.asDeclared(input.componentDescriptor().componentDefinitionType().asType()),
-            requestElement));
-        MethodSignature signature = MethodSignature.fromExecutableType(
-            requestElement.getSimpleName().toString(),
-            requestType);
-        if (!interfaceMethods.contains(signature)) {
-          interfaceMethods.add(signature);
-          MethodWriter interfaceMethod = requestType.getReturnType().getKind().equals(VOID)
-              ? componentWriter.addMethod(VoidName.VOID, requestElement.getSimpleName().toString())
-                  : componentWriter.addMethod(requestType.getReturnType(),
-                      requestElement.getSimpleName().toString());
-          interfaceMethod.annotate(Override.class);
-          interfaceMethod.addModifiers(PUBLIC);
-          BindingKey bindingKey = interfaceRequest.bindingKey();
-          switch(interfaceRequest.kind()) {
-            case MEMBERS_INJECTOR:
-              MemberSelect membersInjectorSelect = memberSelectSnippets.get(bindingKey);
-              List<? extends VariableElement> parameters = requestElement.getParameters();
-              if (parameters.isEmpty()) {
-                // we're returning the framework type
-                interfaceMethod.body().addSnippet("return %s;",
-                    membersInjectorSelect.getSnippetFor(componentWriter.name()));
-              } else {
-                VariableElement parameter = Iterables.getOnlyElement(parameters);
-                Name parameterName = parameter.getSimpleName();
-                interfaceMethod.addParameter(
-                    TypeNames.forTypeMirror(
-                        Iterables.getOnlyElement(requestType.getParameterTypes())),
-                    parameterName.toString());
-                interfaceMethod.body().addSnippet("%s.injectMembers(%s);",
-                    // in this case we know we won't need the cast because we're never going to pass
-                    // the reference to anything
-                    membersInjectorSelect.getSnippetFor(componentWriter.name()),
-                    parameterName);
-                if (!requestType.getReturnType().getKind().equals(VOID)) {
-                  interfaceMethod.body().addSnippet("return %s;", parameterName);
-                }
-              }
-              break;
-            case INSTANCE:
-              if (enumBindingKeys.contains(bindingKey)
-                  && (bindingKey.key().type().getKind().equals(DECLARED)
-                      && !((DeclaredType) bindingKey.key().type()).getTypeArguments().isEmpty())) {
-                // If using a parameterized enum type, then we need to store the factory
-                // in a temporary variable, in order to help javac be able to infer
-                // the generics of the Factory.create methods.
-                TypeName factoryType = ParameterizedTypeName.create(Provider.class,
-                    TypeNames.forTypeMirror(requestType.getReturnType()));
-                interfaceMethod.body().addSnippet("%s factory = %s;", factoryType,
-                    memberSelectSnippets.get(bindingKey).getSnippetFor(componentWriter.name()));
-                interfaceMethod.body().addSnippet("return factory.get();");
-                break;
-              }
-              // fall through in the else case.
-            case LAZY:
-            case PRODUCED:
-            case PRODUCER:
-            case PROVIDER:
-            case FUTURE:
-              interfaceMethod.body().addSnippet("return %s;",
-                  frameworkTypeUsageStatement(
-                      memberSelectSnippets.get(bindingKey).getSnippetFor(componentWriter.name()),
-                      interfaceRequest.kind()));
-              break;
-            default:
-              throw new AssertionError();
-          }
-        }
-      }
-    }
-  }
-
-  private void initializeFrameworkTypes(BindingGraph input,
-      ClassWriter componentWriter,
-      ConstructorWriter constructorWriter,
-      Optional<ClassName> builderName,
-      Map<TypeElement, MemberSelect> componentContributionFields,
-      ImmutableMap<BindingKey, MemberSelect> memberSelectSnippets,
-      ImmutableMap<ContributionBinding, Snippet> parentMultibindingContributionSnippets,
-      ImmutableMap<ContributionBinding, Snippet> multibindingContributionSnippets)
-      throws AssertionError {
-    List<List<BindingKey>> partitions = Lists.partition(
-        input.resolvedBindings().keySet().asList(), 100);
-    for (int i = 0; i < partitions.size(); i++) {
-      MethodWriter initializeMethod =
-          componentWriter.addMethod(VoidName.VOID, "initialize" + ((i == 0) ? "" : i));
-      initializeMethod.body();
-      initializeMethod.addModifiers(PRIVATE);
-      if (builderName.isPresent()) {
-        initializeMethod.addParameter(builderName.get(), "builder").addModifiers(FINAL);
-        constructorWriter.body().addSnippet("%s(builder);", initializeMethod.name());
-      } else {
-        constructorWriter.body().addSnippet("%s();", initializeMethod.name());
-      }
-
-      for (BindingKey bindingKey : partitions.get(i)) {
-        Snippet memberSelectSnippet =
-            memberSelectSnippets.get(bindingKey).getSnippetFor(componentWriter.name());
-        ResolvedBindings resolvedBindings = input.resolvedBindings().get(bindingKey);
-        switch (bindingKey.kind()) {
-          case CONTRIBUTION:
-            ImmutableSet<? extends ContributionBinding> bindings =
-                resolvedBindings.contributionBindings();
-
-            switch (ContributionBinding.bindingTypeFor(bindings)) {
-              case SET:
-                boolean hasOnlyProvisions =
-                    Iterables.all(bindings, Predicates.instanceOf(ProvisionBinding.class));
-                ImmutableList.Builder<Snippet> parameterSnippets = ImmutableList.builder();
-                for (ContributionBinding binding : bindings) {
-                  if (multibindingContributionSnippets.containsKey(binding)) {
-                    Snippet initializeSnippet = initializeFactoryForContributionBinding(
-                        binding,
-                        input,
-                        componentWriter.name(),
-                        componentContributionFields,
-                        memberSelectSnippets);
-                    Snippet snippet = multibindingContributionSnippets.get(binding);
-                    initializeMethod.body().addSnippet("this.%s = %s;", snippet, initializeSnippet);
-                    parameterSnippets.add(snippet);
-                  } else if (parentMultibindingContributionSnippets.containsKey(binding)) {
-                    parameterSnippets.add(parentMultibindingContributionSnippets.get(binding));
-                  } else {
-                    throw new IllegalStateException(binding + " was not found in");
-                  }
-                }
-                Snippet initializeSetSnippet = Snippet.format("%s.create(%s)",
-                    hasOnlyProvisions
-                        ? ClassName.fromClass(SetFactory.class)
-                        : ClassName.fromClass(SetProducer.class),
-                    Snippet.makeParametersSnippet(parameterSnippets.build()));
-                initializeMethod.body().addSnippet("this.%s = %s;",
-                    memberSelectSnippet, initializeSetSnippet);
-                break;
-              case MAP:
-                if (Sets.filter(bindings, Predicates.instanceOf(ProductionBinding.class))
-                    .isEmpty()) {
-                  @SuppressWarnings("unchecked")  // checked by the instanceof filter above
-                  ImmutableSet<ProvisionBinding> provisionBindings =
-                      (ImmutableSet<ProvisionBinding>) bindings;
-                  for (ProvisionBinding provisionBinding : provisionBindings) {
-                    if (!isNonProviderMap(provisionBinding.key().type())
-                        && multibindingContributionSnippets.containsKey(provisionBinding)) {
-                      Snippet snippet = multibindingContributionSnippets.get(provisionBinding);
-                      initializeMethod.body().addSnippet("this.%s = %s;",
-                          snippet,
-                          initializeFactoryForProvisionBinding(provisionBinding,
-                              componentWriter.name(),
-                              input.componentDescriptor().dependencyMethodIndex(),
-                              componentContributionFields,
-                              memberSelectSnippets));
-                    }
-                  }
-                  if (!provisionBindings.isEmpty()) {
-                    Snippet initializeMapSnippet = initializeMapBinding(
-                        componentWriter.name(), memberSelectSnippets,
-                        new ImmutableMap.Builder<ContributionBinding, Snippet>()
-                            .putAll(parentMultibindingContributionSnippets)
-                            .putAll(multibindingContributionSnippets)
-                            .build(),
-                        provisionBindings);
-                    initializeMethod.body().addSnippet("this.%s = %s;",
-                        memberSelectSnippet, initializeMapSnippet);
-                  }
-                } else {
-                  // TODO(user): Implement producer map bindings.
-                  throw new IllegalStateException("producer map bindings not implemented yet");
-                }
-                break;
-              case UNIQUE:
-                if (!resolvedBindings.ownedContributionBindings().isEmpty()) {
-                  ContributionBinding binding = Iterables.getOnlyElement(bindings);
-                  if (binding instanceof ProvisionBinding) {
-                    ProvisionBinding provisionBinding = (ProvisionBinding) binding;
-                    if (!provisionBinding.factoryCreationStrategy().equals(ENUM_INSTANCE)
-                        || provisionBinding.scope().isPresent()) {
-                      initializeMethod.body().addSnippet("this.%s = %s;",
-                          memberSelectSnippet,
-                          initializeFactoryForProvisionBinding(provisionBinding,
-                              componentWriter.name(),
-                              input.componentDescriptor().dependencyMethodIndex(),
-                              componentContributionFields, memberSelectSnippets));
-                    }
-                  } else if (binding instanceof ProductionBinding) {
-                    ProductionBinding productionBinding = (ProductionBinding) binding;
-                    initializeMethod.body().addSnippet("this.%s = %s;",
-                        memberSelectSnippet,
-                        initializeFactoryForProductionBinding(productionBinding,
-                            input,
-                            componentWriter.name(),
-                            input.componentDescriptor().dependencyMethodIndex(),
-                            componentContributionFields, memberSelectSnippets));
-                  } else {
-                    throw new AssertionError();
-                  }
-                }
-                break;
-              default:
-                throw new IllegalStateException();
-            }
-            break;
-          case MEMBERS_INJECTION:
-            MembersInjectionBinding binding = Iterables.getOnlyElement(
-                resolvedBindings.membersInjectionBindings());
-            if (!binding.injectionStrategy().equals(MembersInjectionBinding.Strategy.NO_OP)) {
-              initializeMethod.body().addSnippet("this.%s = %s;",
-                  memberSelectSnippet,
-                  initializeMembersInjectorForBinding(
-                      componentWriter.name(), binding, memberSelectSnippets));
-            }
-            break;
-          default:
-            throw new AssertionError();
-        }
-      }
-    }
-  }
-
-  private static FrameworkField frameworkFieldForSyntheticContributionBinding(BindingKey bindingKey,
-      int contributionNumber, ContributionBinding contributionBinding) throws AssertionError {
-    switch (contributionBinding.bindingType()) {
-      case MAP:
-        return FrameworkField.createForMapBindingContribution(
-            contributionBinding.frameworkClass(),
-            BindingKey.create(bindingKey.kind(), contributionBinding.key()),
-            KeyVariableNamer.INSTANCE.apply(bindingKey.key())
-                + "Contribution" + contributionNumber);
-      case SET:
-        return FrameworkField.createWithTypeFromKey(
-            contributionBinding.frameworkClass(),
-            bindingKey,
-            KeyVariableNamer.INSTANCE.apply(bindingKey.key())
-                + "Contribution" + contributionNumber);
-      case UNIQUE:
-        return FrameworkField.createWithTypeFromKey(
-            contributionBinding.frameworkClass(),
-            bindingKey,
-            KeyVariableNamer.INSTANCE.apply(bindingKey.key())
-                + "Contribution" + contributionNumber);
-      default:
-        throw new AssertionError();
-    }
-  }
-
-  private static Class<?> frameworkClassForResolvedBindings(ResolvedBindings resolvedBindings) {
-    switch (resolvedBindings.bindingKey().kind()) {
-      case CONTRIBUTION:
-        for (ContributionBinding binding : resolvedBindings.contributionBindings()) {
-          if (binding instanceof ProductionBinding) {
-            return Producer.class;
-          }
-        }
-        return Provider.class;
-      case MEMBERS_INJECTION:
-        return MembersInjector.class;
-      default:
-        throw new AssertionError();
-    }
-  }
-
-  private FrameworkField frameworkFieldForResolvedBindings(ResolvedBindings resolvedBindings) {
-    BindingKey bindingKey = resolvedBindings.bindingKey();
-    switch (bindingKey.kind()) {
-      case CONTRIBUTION:
-        ImmutableSet<? extends ContributionBinding> contributionBindings =
-            resolvedBindings.contributionBindings();
-        BindingType bindingsType = ProvisionBinding.bindingTypeFor(contributionBindings);
-        switch (bindingsType) {
-          case SET:
-          case MAP:
-            return FrameworkField.createWithTypeFromKey(
-                frameworkClassForResolvedBindings(resolvedBindings),
-                bindingKey,
-                KeyVariableNamer.INSTANCE.apply(bindingKey.key()));
-          case UNIQUE:
-            ContributionBinding binding = Iterables.getOnlyElement(contributionBindings);
-            return FrameworkField.createWithTypeFromKey(
-                frameworkClassForResolvedBindings(resolvedBindings),
-                bindingKey,
-                binding.bindingElement().accept(new ElementKindVisitor6<String, Void>() {
-                  @Override
-                  public String visitExecutableAsConstructor(ExecutableElement e, Void p) {
-                    return e.getEnclosingElement().accept(this, null);
-                  }
-
-                  @Override
-                  public String visitExecutableAsMethod(ExecutableElement e, Void p) {
-                    return e.getSimpleName().toString();
-                  }
-
-                  @Override
-                  public String visitType(TypeElement e, Void p) {
-                    return CaseFormat.UPPER_CAMEL.to(CaseFormat.LOWER_CAMEL,
-                        e.getSimpleName().toString());
-                  }
-                }, null));
-          default:
-            throw new AssertionError();
-        }
-      case MEMBERS_INJECTION:
-        return FrameworkField.createWithTypeFromKey(
-            MembersInjector.class,
-            bindingKey,
-            CaseFormat.UPPER_CAMEL.to(CaseFormat.LOWER_CAMEL,
-                Iterables.getOnlyElement(resolvedBindings.bindings())
-                .bindingElement().getSimpleName().toString()));
-      default:
-        throw new AssertionError();
-    }
-  }
-
-  private Snippet initializeFactoryForContributionBinding(ContributionBinding binding,
-      BindingGraph input,
-      ClassName componentName,
-      Map<TypeElement, MemberSelect> componentContributionFields,
-      ImmutableMap<BindingKey, MemberSelect> memberSelectSnippets) {
-    if (binding instanceof ProvisionBinding) {
-      return initializeFactoryForProvisionBinding(
-          (ProvisionBinding) binding,
-          componentName,
-          input.componentDescriptor().dependencyMethodIndex(),
-          componentContributionFields,
-          memberSelectSnippets);
-    } else if (binding instanceof ProductionBinding) {
-      return initializeFactoryForProductionBinding(
-          (ProductionBinding) binding,
-          input,
-          componentName,
-          input.componentDescriptor().dependencyMethodIndex(),
-          componentContributionFields,
-          memberSelectSnippets);
-    } else {
-      throw new AssertionError();
-    }
-}
-
-  private Snippet initializeFactoryForProvisionBinding(ProvisionBinding binding,
-      ClassName componentName,
-      ImmutableMap<ExecutableElement, TypeElement> dependencyMethodIndex,
-      Map<TypeElement, MemberSelect> contributionFields,
-      ImmutableMap<BindingKey, MemberSelect> memberSelectSnippets) {
-    switch(binding.bindingKind()) {
-      case COMPONENT:
-        MemberSelect componentContributionSelect =
-            contributionFields.get(MoreTypes.asTypeElement(binding.key().type()));
-        return Snippet.format("%s.<%s>create(%s)",
-            ClassName.fromClass(InstanceFactory.class),
-            TypeNames.forTypeMirror(binding.key().type()),
-            componentContributionSelect != null
-                ? componentContributionSelect.getSnippetFor(componentName) : "this");
-      case COMPONENT_PROVISION:
-        TypeElement bindingTypeElement = dependencyMethodIndex.get(binding.bindingElement());
-        String sourceFieldName =
-            CaseFormat.UPPER_CAMEL.to(LOWER_CAMEL, bindingTypeElement.getSimpleName().toString());
-        if (binding.nullableType().isPresent()
-            || nullableValidationType.equals(Diagnostic.Kind.WARNING)) {
-          Snippet nullableSnippet = binding.nullableType().isPresent()
-              ? Snippet.format("@%s ", TypeNames.forTypeMirror(binding.nullableType().get()))
-              : Snippet.format("");
-          return Snippet.format(Joiner.on('\n').join(
-            "new %s<%2$s>() {",
-            "  private final %6$s %7$s = %3$s;",
-            "  %5$s@Override public %2$s get() {",
-            "    return %7$s.%4$s();",
-            "  }",
-            "}"),
-            ClassName.fromClass(Factory.class),
-            TypeNames.forTypeMirror(binding.key().type()),
-            contributionFields.get(bindingTypeElement).getSnippetFor(componentName),
-            binding.bindingElement().getSimpleName().toString(),
-            nullableSnippet,
-            TypeNames.forTypeMirror(bindingTypeElement.asType()),
-            sourceFieldName);
-        } else {
-          // TODO(sameb): This throws a very vague NPE right now.  The stack trace doesn't
-          // help to figure out what the method or return type is.  If we include a string
-          // of the return type or method name in the error message, that can defeat obfuscation.
-          // We can easily include the raw type (no generics) + annotation type (no values),
-          // using .class & String.format -- but that wouldn't be the whole story.
-          // What should we do?
-          StringLiteral failMsg =
-              StringLiteral.forValue(CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD);
-          return Snippet.format(Joiner.on('\n').join(
-            "new %s<%2$s>() {",
-            "  private final %6$s %7$s = %3$s;",
-            "  @Override public %2$s get() {",
-            "    %2$s provided = %7$s.%4$s();",
-            "    if (provided == null) {",
-            "      throw new NullPointerException(%5$s);",
-            "    }",
-            "    return provided;",
-            "  }",
-            "}"),
-            ClassName.fromClass(Factory.class),
-            TypeNames.forTypeMirror(binding.key().type()),
-            contributionFields.get(bindingTypeElement).getSnippetFor(componentName),
-            binding.bindingElement().getSimpleName().toString(),
-            failMsg,
-            TypeNames.forTypeMirror(bindingTypeElement.asType()),
-            sourceFieldName);
-        }
-      case INJECTION:
-      case PROVISION:
-        List<Snippet> parameters =
-            Lists.newArrayListWithCapacity(binding.dependencies().size() + 1);
-        if (binding.bindingKind().equals(PROVISION)
-            && !binding.bindingElement().getModifiers().contains(STATIC)) {
-          parameters.add(contributionFields.get(binding.contributedBy().get())
-              .getSnippetFor(componentName));
-        }
-        parameters.addAll(getDependencyParameters(componentName, binding.implicitDependencies(),
-            memberSelectSnippets));
-
-        Snippet factorySnippet = Snippet.format("%s.create(%s)",
-            factoryNameForProvisionBinding(binding),
-            Snippet.makeParametersSnippet(parameters));
-        return binding.scope().isPresent()
-            ? Snippet.format("%s.create(%s)",
-                ClassName.fromClass(ScopedProvider.class),
-                factorySnippet)
-            : factorySnippet;
-      default:
-        throw new AssertionError();
-    }
-  }
-
-  private Snippet initializeFactoryForProductionBinding(ProductionBinding binding,
-      BindingGraph bindingGraph,
-      ClassName componentName,
-      ImmutableMap<ExecutableElement, TypeElement> dependencyMethodIndex,
-      Map<TypeElement, MemberSelect> contributionFields,
-      ImmutableMap<BindingKey, MemberSelect> memberSelectSnippets) {
-    switch (binding.bindingKind()) {
-      case COMPONENT_PRODUCTION:
-        TypeElement bindingTypeElement = dependencyMethodIndex.get(binding.bindingElement());
-        String sourceFieldName =
-            CaseFormat.UPPER_CAMEL.to(LOWER_CAMEL, bindingTypeElement.getSimpleName().toString());
-        return Snippet.format(Joiner.on('\n').join(
-            "new %s<%2$s>() {",
-            "  private final %6$s %7$s = %4$s;",
-            "  @Override public %3$s<%2$s> get() {",
-            "    return %7$s.%5$s();",
-            "  }",
-            "}"),
-            ClassName.fromClass(Producer.class),
-            TypeNames.forTypeMirror(binding.key().type()),
-            ClassName.fromClass(ListenableFuture.class),
-            contributionFields.get(bindingTypeElement).getSnippetFor(componentName),
-            binding.bindingElement().getSimpleName().toString(),
-            TypeNames.forTypeMirror(bindingTypeElement.asType()),
-            sourceFieldName);
-      case IMMEDIATE:
-      case FUTURE_PRODUCTION:
-        List<Snippet> parameters =
-            Lists.newArrayListWithCapacity(binding.dependencies().size() + 2);
-        parameters.add(contributionFields.get(binding.bindingTypeElement())
-            .getSnippetFor(componentName));
-        parameters.add(contributionFields.get(
-            bindingGraph.componentDescriptor().executorDependency().get())
-                .getSnippetFor(componentName));
-        parameters.addAll(getProducerDependencyParameters(
-            bindingGraph, componentName, binding.dependencies(), memberSelectSnippets));
-
-        return Snippet.format("new %s(%s)",
-            factoryNameForProductionBinding(binding),
-            Snippet.makeParametersSnippet(parameters));
-      default:
-        throw new AssertionError();
-    }
-  }
-
-  private Snippet initializeMembersInjectorForBinding(
-      ClassName componentName,
-      MembersInjectionBinding binding,
-      ImmutableMap<BindingKey, MemberSelect> memberSelectSnippets) {
-    switch (binding.injectionStrategy()) {
-      case NO_OP:
-        return Snippet.format("%s.noOp()",
-            ClassName.fromClass(MembersInjectors.class));
-      case DELEGATE:
-        DependencyRequest parentInjectorRequest = binding.parentInjectorRequest().get();
-        return Snippet.format("%s.delegatingTo(%s)",
-            ClassName.fromClass(MembersInjectors.class),
-            memberSelectSnippets.get(parentInjectorRequest.bindingKey())
-                .getSnippetFor(componentName));
-      case INJECT_MEMBERS:
-        List<Snippet> parameters = getDependencyParameters(
-            componentName,
-            binding.implicitDependencies(),
-            memberSelectSnippets);
-        return Snippet.format("%s.create(%s)",
-            membersInjectorNameForMembersInjectionBinding(binding),
-            Snippet.makeParametersSnippet(parameters));
-      default:
-        throw new AssertionError();
-    }
-  }
-
-  private List<Snippet> getDependencyParameters(
-      ClassName componentName,
-      Iterable<DependencyRequest> dependencies,
-      ImmutableMap<BindingKey, MemberSelect> memberSelectSnippets) {
-    ImmutableList.Builder<Snippet> parameters = ImmutableList.builder();
-    for (Collection<DependencyRequest> requestsForKey :
-         SourceFiles.indexDependenciesByUnresolvedKey(types, dependencies).asMap().values()) {
-      BindingKey key = Iterables.getOnlyElement(FluentIterable.from(requestsForKey)
-          .transform(new Function<DependencyRequest, BindingKey>() {
-            @Override public BindingKey apply(DependencyRequest request) {
-              return request.bindingKey();
-            }
-          })
-          .toSet());
-      parameters.add(memberSelectSnippets.get(key).getSnippetWithRawTypeCastFor(componentName));
-    }
-    return parameters.build();
-  }
-
-  private List<Snippet> getProducerDependencyParameters(
-      BindingGraph bindingGraph,
-      ClassName componentName,
-      Iterable<DependencyRequest> dependencies,
-      ImmutableMap<BindingKey, MemberSelect> memberSelectSnippets) {
-    ImmutableList.Builder<Snippet> parameters = ImmutableList.builder();
-    for (Collection<DependencyRequest> requestsForKey :
-         SourceFiles.indexDependenciesByUnresolvedKey(types, dependencies).asMap().values()) {
-      BindingKey key = Iterables.getOnlyElement(FluentIterable.from(requestsForKey)
-          .transform(new Function<DependencyRequest, BindingKey>() {
-            @Override public BindingKey apply(DependencyRequest request) {
-              return request.bindingKey();
-            }
-          }));
-      ResolvedBindings resolvedBindings = bindingGraph.resolvedBindings().get(key);
-      Class<?> frameworkClass =
-          DependencyRequestMapper.FOR_PRODUCER.getFrameworkClass(requestsForKey);
-      if (frameworkClassForResolvedBindings(resolvedBindings).equals(Provider.class)
-          && frameworkClass.equals(Producer.class)) {
-        parameters.add(Snippet.format(
-            "%s.producerFromProvider(%s)",
-            ClassName.fromClass(Producers.class),
-            memberSelectSnippets.get(key).getSnippetFor(componentName)));
-      } else {
-        parameters.add(memberSelectSnippets.get(key).getSnippetFor(componentName));
-      }
-    }
-    return parameters.build();
-  }
-
-  private Snippet initializeMapBinding(
-      ClassName componentName,
-      ImmutableMap<BindingKey, MemberSelect> memberSelectSnippets,
-      ImmutableMap<ContributionBinding, Snippet> multibindingContributionSnippets,
-      Set<ProvisionBinding> bindings) {
-    // Get type information from the first binding.
-    ProvisionBinding firstBinding = bindings.iterator().next();
-    DeclaredType mapType = asDeclared(firstBinding.key().type());
-
-    if (isNonProviderMap(mapType)) {
-      return Snippet.format(
-          "%s.create(%s)",
-          ClassName.fromClass(MapFactory.class),
-          memberSelectSnippets
-              .get(getOnlyElement(firstBinding.dependencies()).bindingKey())
-              .getSnippetFor(componentName));
-    }
-
-    ImmutableList.Builder<dagger.internal.codegen.writer.Snippet> snippets =
-        ImmutableList.builder();
-    snippets.add(
-        Snippet.format(
-            "%s.<%s, %s>builder(%d)",
-            ClassName.fromClass(MapProviderFactory.class),
-            TypeNames.forTypeMirror(getKeyTypeOfMap(mapType)),
-            TypeNames.forTypeMirror(getProvidedValueTypeOfMap(mapType)), // V of Map<K, Provider<V>>
-            bindings.size()));
-
-    for (ProvisionBinding binding : bindings) {
-      snippets.add(
-          Snippet.format(
-              "    .put(%s, %s)",
-              getMapKeySnippet(binding.bindingElement()),
-              multibindingContributionSnippets.get(binding)));
-    }
-
-    snippets.add(Snippet.format("    .build()"));
-
-    return Snippet.join(Joiner.on('\n'), snippets.build());
-  }
-
-  private boolean isNonProviderMap(TypeMirror type) {
-    return MoreTypes.isTypeOf(Map.class, type) // Implicitly guarantees a declared type.
-        && !MoreTypes.isTypeOf(Provider.class, asDeclared(type).getTypeArguments().get(1));
+    return new ComponentWriter(
+            types, elements, keyFactory, nullableValidationType, componentName, input)
+        .write();
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentHierarchyValidator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentHierarchyValidator.java
new file mode 100644
index 000000000..8fb4191a5
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentHierarchyValidator.java
@@ -0,0 +1,115 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.common.MoreTypes;
+import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.Maps;
+import com.google.common.collect.Sets;
+import dagger.internal.codegen.ComponentDescriptor.BuilderSpec;
+import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
+import java.util.Map;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.VariableElement;
+
+import static com.google.common.base.Functions.constant;
+
+/**
+ * Validates the relationships between parent components and subcomponents.
+ */
+final class ComponentHierarchyValidator {
+  ValidationReport<TypeElement> validate(ComponentDescriptor componentDescriptor) {
+    return validateSubcomponentMethods(
+        componentDescriptor,
+        Maps.toMap(
+            componentDescriptor.transitiveModuleTypes(),
+            constant(componentDescriptor.componentDefinitionType())));
+  }
+
+  private ValidationReport<TypeElement> validateSubcomponentMethods(
+      ComponentDescriptor componentDescriptor,
+      Map<TypeElement, TypeElement> existingModuleToOwners) {
+    ValidationReport.Builder<TypeElement> reportBuilder =
+        ValidationReport.about(componentDescriptor.componentDefinitionType());
+    for (Map.Entry<ComponentMethodDescriptor, ComponentDescriptor> subcomponentEntry :
+        componentDescriptor.subcomponents().entrySet()) {
+      ComponentMethodDescriptor subcomponentMethodDescriptor = subcomponentEntry.getKey();
+      ComponentDescriptor subcomponentDescriptor = subcomponentEntry.getValue();
+      // validate the way that we create subcomponents
+      switch (subcomponentMethodDescriptor.kind()) {
+        case SUBCOMPONENT:
+          for (VariableElement factoryMethodParameter :
+              subcomponentMethodDescriptor.methodElement().getParameters()) {
+            TypeElement origininatingComponent =
+                existingModuleToOwners.get(
+                    MoreTypes.asTypeElement(factoryMethodParameter.asType()));
+            if (origininatingComponent != null) {
+              /* Factory method tries to pass a module that is already present in the parent.
+               * This is an error. */
+              reportBuilder.addError(
+                  String.format(
+                      "This module is present in %s. Subcomponents cannot use an instance of a "
+                          + "module that differs from its parent.",
+                      origininatingComponent.getQualifiedName()),
+                  factoryMethodParameter);
+            }
+          }
+          break;
+        case SUBCOMPONENT_BUILDER:
+          BuilderSpec subcomponentBuilderSpec = subcomponentDescriptor.builderSpec().get();
+          for (Map.Entry<TypeElement, ExecutableElement> builderMethodEntry :
+              subcomponentBuilderSpec.methodMap().entrySet()) {
+            TypeElement origininatingComponent =
+                existingModuleToOwners.get(builderMethodEntry.getKey());
+            if (origininatingComponent != null) {
+              /* A subcomponent builder allows you to pass a module that is already present in the
+               * parent.  This can't be an error because it might be valid in _other_ components, so
+               * we warn here. */
+              ExecutableElement builderMethodElement = builderMethodEntry.getValue();
+              /* TODO(gak): consider putting this on the builder method directly if it's in the
+               * component being compiled */
+              reportBuilder.addWarning(
+                  String.format(
+                      "This module is present in %s. Subcomponents cannot use an instance of a "
+                          + "module that differs from its parent. The implementation of %s "
+                          + "in this component will throw %s.",
+                      origininatingComponent.getQualifiedName(),
+                      builderMethodElement.getSimpleName(),
+                      UnsupportedOperationException.class.getSimpleName()),
+                  builderMethodElement);
+            }
+          }
+          break;
+        default:
+          throw new AssertionError();
+      }
+      reportBuilder.addSubreport(
+          validateSubcomponentMethods(
+              subcomponentDescriptor,
+              new ImmutableMap.Builder<TypeElement, TypeElement>()
+                  .putAll(existingModuleToOwners)
+                  .putAll(
+                      Maps.toMap(
+                          Sets.difference(
+                              subcomponentDescriptor.transitiveModuleTypes(),
+                              existingModuleToOwners.keySet()),
+                          constant(subcomponentDescriptor.componentDefinitionType())))
+                  .build()));
+    }
+    return reportBuilder.build();
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java
index 18636fe18..39b21ca32 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java
@@ -43,7 +43,6 @@
   private final ComponentValidator subcomponentValidator;
   private final BuilderValidator componentBuilderValidator;
   private final BuilderValidator subcomponentBuilderValidator;
-  private final ComponentDescriptor.Factory componentDescriptorFactory;
 
   ComponentProcessingStep(
       Messager messager,
@@ -51,13 +50,17 @@
       ComponentValidator subcomponentValidator,
       BuilderValidator componentBuilderValidator,
       BuilderValidator subcomponentBuilderValidator,
+      ComponentHierarchyValidator componentHierarchyValidator,
       BindingGraphValidator bindingGraphValidator,
       Factory componentDescriptorFactory,
       BindingGraph.Factory bindingGraphFactory,
       ComponentGenerator componentGenerator) {
     super(
+        Component.class,
         messager,
+        componentHierarchyValidator,
         bindingGraphValidator,
+        componentDescriptorFactory,
         bindingGraphFactory,
         componentGenerator);
     this.messager = messager;
@@ -65,7 +68,6 @@
     this.subcomponentValidator = subcomponentValidator;
     this.componentBuilderValidator = componentBuilderValidator;
     this.subcomponentBuilderValidator = subcomponentBuilderValidator;
-    this.componentDescriptorFactory = componentDescriptorFactory;
   }
 
   @Override
@@ -75,34 +77,31 @@
   }
 
   @Override
-  protected ImmutableSet<ComponentDescriptor> componentDescriptors(
+  protected ComponentElementValidator componentElementValidator(
       SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
-    Map<Element, ValidationReport<TypeElement>> builderReportsByComponent =
+    final Map<Element, ValidationReport<TypeElement>> builderReportsByComponent =
         processComponentBuilders(elementsByAnnotation.get(Component.Builder.class));
-    Set<Element> subcomponentBuilderElements = elementsByAnnotation.get(Subcomponent.Builder.class);
-    Map<Element, ValidationReport<TypeElement>> builderReportsBySubcomponent =
+    final Set<Element> subcomponentBuilderElements =
+        elementsByAnnotation.get(Subcomponent.Builder.class);
+    final Map<Element, ValidationReport<TypeElement>> builderReportsBySubcomponent =
         processSubcomponentBuilders(subcomponentBuilderElements);
-    Set<Element> subcomponentElements = elementsByAnnotation.get(Subcomponent.class);
-    Map<Element, ValidationReport<TypeElement>> reportsBySubcomponent =
+    final Set<Element> subcomponentElements = elementsByAnnotation.get(Subcomponent.class);
+    final Map<Element, ValidationReport<TypeElement>> reportsBySubcomponent =
         processSubcomponents(subcomponentElements, subcomponentBuilderElements);
-    Set<Element> componentElements = elementsByAnnotation.get(Component.class);
-
-    ImmutableSet.Builder<ComponentDescriptor> builder = ImmutableSet.builder();
-    for (Element element : componentElements) {
-      TypeElement componentTypeElement = MoreElements.asType(element);
-      ComponentValidationReport report = componentValidator.validate(
-          componentTypeElement, subcomponentElements, subcomponentBuilderElements);
-      report.report().printMessagesTo(messager);
-      if (isClean(
-          report, builderReportsByComponent, reportsBySubcomponent, builderReportsBySubcomponent)) {
-        try {
-          builder.add(componentDescriptorFactory.forComponent(componentTypeElement));
-        } catch (TypeNotPresentException e) {
-          // just skip it and get it later
-        }
+    return new ComponentElementValidator() {
+      @Override
+      boolean validateComponent(TypeElement componentTypeElement, Messager messager) {
+        ComponentValidationReport validationReport =
+            componentValidator.validate(
+                componentTypeElement, subcomponentElements, subcomponentBuilderElements);
+        validationReport.report().printMessagesTo(messager);
+        return isClean(
+            validationReport,
+            builderReportsByComponent,
+            reportsBySubcomponent,
+            builderReportsBySubcomponent);
       }
-    }
-    return builder.build();
+    };
   }
 
   private Map<Element, ValidationReport<TypeElement>> processComponentBuilders(
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
index 3152c3fd1..c35058ba3 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -17,12 +17,14 @@
 
 import com.google.auto.common.BasicAnnotationProcessor;
 import com.google.auto.service.AutoService;
+import com.google.common.base.Ascii;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import dagger.Module;
 import dagger.Provides;
 import dagger.producers.ProducerModule;
 import dagger.producers.Produces;
+import java.lang.annotation.Annotation;
 import java.util.EnumSet;
 import java.util.Map;
 import java.util.Set;
@@ -61,7 +63,9 @@ public SourceVersion getSupportedSourceVersion() {
   public Set<String> getSupportedOptions() {
     return ImmutableSet.of(
         DISABLE_INTER_COMPONENT_SCOPE_VALIDATION_KEY,
-        NULLABLE_VALIDATION_KEY
+        NULLABLE_VALIDATION_KEY,
+        PRIVATE_MEMBER_VALIDATION_TYPE_KEY,
+        STATIC_MEMBER_VALIDATION_TYPE_KEY
     );
   }
 
@@ -76,18 +80,26 @@ public SourceVersion getSupportedSourceVersion() {
         nullableValidationType(processingEnv).diagnosticKind().get();
 
     MethodSignatureFormatter methodSignatureFormatter = new MethodSignatureFormatter(types);
-    ProvisionBindingFormatter provisionBindingFormatter =
-        new ProvisionBindingFormatter(methodSignatureFormatter);
-    ProductionBindingFormatter productionBindingFormatter =
-        new ProductionBindingFormatter(methodSignatureFormatter);
+    ContributionBindingFormatter contributionBindingFormatter =
+        new ContributionBindingFormatter(methodSignatureFormatter);
     DependencyRequestFormatter dependencyRequestFormatter = new DependencyRequestFormatter(types);
     KeyFormatter keyFormatter = new KeyFormatter();
 
     InjectConstructorValidator injectConstructorValidator = new InjectConstructorValidator();
-    InjectFieldValidator injectFieldValidator = new InjectFieldValidator();
-    InjectMethodValidator injectMethodValidator = new InjectMethodValidator();
-    ModuleValidator moduleValidator = new ModuleValidator(types, elements, methodSignatureFormatter,
-        Module.class, Provides.class);
+    InjectFieldValidator injectFieldValidator = new InjectFieldValidator(
+        privateMemberValidationType(processingEnv).diagnosticKind().get(),
+        staticMemberValidationType(processingEnv).diagnosticKind().get());
+    InjectMethodValidator injectMethodValidator = new InjectMethodValidator(
+        privateMemberValidationType(processingEnv).diagnosticKind().get(),
+        staticMemberValidationType(processingEnv).diagnosticKind().get());
+    ModuleValidator moduleValidator =
+        new ModuleValidator(
+            types,
+            elements,
+            methodSignatureFormatter,
+            Module.class,
+            ImmutableList.<Class<? extends Annotation>>of(Module.class),
+            Provides.class);
     ProvidesMethodValidator providesMethodValidator = new ProvidesMethodValidator(elements);
     BuilderValidator componentBuilderValidator =
         new BuilderValidator(elements, types, ComponentDescriptor.Kind.COMPONENT);
@@ -98,23 +110,33 @@ public SourceVersion getSupportedSourceVersion() {
     ComponentValidator componentValidator = ComponentValidator.createForComponent(elements, types,
         moduleValidator, subcomponentValidator, subcomponentBuilderValidator);
     MapKeyValidator mapKeyValidator = new MapKeyValidator();
-    ModuleValidator producerModuleValidator = new ModuleValidator(types, elements,
-        methodSignatureFormatter, ProducerModule.class, Produces.class);
+    ModuleValidator producerModuleValidator =
+        new ModuleValidator(
+            types,
+            elements,
+            methodSignatureFormatter,
+            ProducerModule.class,
+            ImmutableList.of(Module.class, ProducerModule.class),
+            Produces.class);
     ProducesMethodValidator producesMethodValidator = new ProducesMethodValidator(elements);
     ProductionComponentValidator productionComponentValidator = new ProductionComponentValidator();
+    BuilderValidator productionComponentBuilderValidator =
+        new BuilderValidator(elements, types, ComponentDescriptor.Kind.PRODUCTION_COMPONENT);
 
     Key.Factory keyFactory = new Key.Factory(types, elements);
 
     this.factoryGenerator =
         new FactoryGenerator(filer, DependencyRequestMapper.FOR_PROVIDER, nullableDiagnosticType);
     this.membersInjectorGenerator =
-        new MembersInjectorGenerator(filer, elements, types, DependencyRequestMapper.FOR_PROVIDER);
+        new MembersInjectorGenerator(filer, DependencyRequestMapper.FOR_PROVIDER);
     ComponentGenerator componentGenerator =
-        new ComponentGenerator(filer, types, nullableDiagnosticType);
+        new ComponentGenerator(filer, elements, types, keyFactory, nullableDiagnosticType);
     ProducerFactoryGenerator producerFactoryGenerator =
         new ProducerFactoryGenerator(filer, DependencyRequestMapper.FOR_PRODUCER);
+    MonitoringModuleGenerator monitoringModuleGenerator = new MonitoringModuleGenerator(filer);
 
-    DependencyRequest.Factory dependencyRequestFactory = new DependencyRequest.Factory(keyFactory);
+    DependencyRequest.Factory dependencyRequestFactory =
+        new DependencyRequest.Factory(elements, keyFactory);
     ProvisionBinding.Factory provisionBindingFactory =
         new ProvisionBinding.Factory(elements, types, keyFactory, dependencyRequestFactory);
     ProductionBinding.Factory productionBindingFactory =
@@ -132,32 +154,29 @@ public SourceVersion getSupportedSourceVersion() {
     ComponentDescriptor.Factory componentDescriptorFactory = new ComponentDescriptor.Factory(
         elements, types, dependencyRequestFactory, moduleDescriptorFactory);
 
-    BindingGraph.Factory bindingGraphFactory = new BindingGraph.Factory(
-        elements,
-        injectBindingRegistry,
-        keyFactory,
-        dependencyRequestFactory,
-        provisionBindingFactory,
-        productionBindingFactory);
+    BindingGraph.Factory bindingGraphFactory =
+        new BindingGraph.Factory(
+            elements,
+            injectBindingRegistry,
+            keyFactory,
+            provisionBindingFactory,
+            productionBindingFactory);
 
     MapKeyGenerator mapKeyGenerator = new MapKeyGenerator(filer);
-    BindingGraphValidator bindingGraphValidator = new BindingGraphValidator(
-        types,
-        injectBindingRegistry,
-        scopeValidationType(processingEnv),
-        nullableDiagnosticType,
-        provisionBindingFormatter,
-        productionBindingFormatter,
-        methodSignatureFormatter,
-        dependencyRequestFormatter,
-        keyFormatter);
+    ComponentHierarchyValidator componentHierarchyValidator = new ComponentHierarchyValidator();
+    BindingGraphValidator bindingGraphValidator =
+        new BindingGraphValidator(
+            types,
+            injectBindingRegistry,
+            scopeValidationType(processingEnv),
+            nullableDiagnosticType,
+            contributionBindingFormatter,
+            methodSignatureFormatter,
+            dependencyRequestFormatter,
+            keyFormatter);
 
     return ImmutableList.<ProcessingStep>of(
-        new MapKeyProcessingStep(
-            messager,
-            types,
-            mapKeyValidator,
-            mapKeyGenerator),
+        new MapKeyProcessingStep(messager, types, mapKeyValidator, mapKeyGenerator),
         new InjectProcessingStep(
             messager,
             injectConstructorValidator,
@@ -166,6 +185,7 @@ public SourceVersion getSupportedSourceVersion() {
             provisionBindingFactory,
             membersInjectionBindingFactory,
             injectBindingRegistry),
+        new MonitoringModuleProcessingStep(messager, monitoringModuleGenerator),
         new ModuleProcessingStep(
             messager,
             moduleValidator,
@@ -178,6 +198,7 @@ public SourceVersion getSupportedSourceVersion() {
             subcomponentValidator,
             componentBuilderValidator,
             subcomponentBuilderValidator,
+            componentHierarchyValidator,
             bindingGraphValidator,
             componentDescriptorFactory,
             bindingGraphFactory,
@@ -191,6 +212,8 @@ public SourceVersion getSupportedSourceVersion() {
         new ProductionComponentProcessingStep(
             messager,
             productionComponentValidator,
+            productionComponentBuilderValidator,
+            componentHierarchyValidator,
             bindingGraphValidator,
             componentDescriptorFactory,
             bindingGraphFactory,
@@ -212,6 +235,12 @@ protected void postProcess() {
 
   private static final String NULLABLE_VALIDATION_KEY = "dagger.nullableValidation";
 
+  private static final String PRIVATE_MEMBER_VALIDATION_TYPE_KEY =
+      "dagger.privateMemberValidation";
+
+  private static final String STATIC_MEMBER_VALIDATION_TYPE_KEY =
+      "dagger.staticMemberValidation";
+
   private static ValidationType scopeValidationType(ProcessingEnvironment processingEnv) {
     return valueOf(processingEnv,
         DISABLE_INTER_COMPONENT_SCOPE_VALIDATION_KEY,
@@ -226,12 +255,28 @@ private static ValidationType nullableValidationType(ProcessingEnvironment proce
         EnumSet.of(ValidationType.ERROR, ValidationType.WARNING));
   }
 
+  private static ValidationType privateMemberValidationType(ProcessingEnvironment processingEnv) {
+    return valueOf(processingEnv,
+        PRIVATE_MEMBER_VALIDATION_TYPE_KEY,
+        ValidationType.ERROR,
+        EnumSet.of(ValidationType.ERROR, ValidationType.WARNING));
+  }
+
+  private static ValidationType staticMemberValidationType(ProcessingEnvironment processingEnv) {
+    return valueOf(processingEnv,
+        STATIC_MEMBER_VALIDATION_TYPE_KEY,
+        ValidationType.ERROR,
+        EnumSet.of(ValidationType.ERROR, ValidationType.WARNING));
+  }
+
   private static <T extends Enum<T>> T valueOf(ProcessingEnvironment processingEnv, String key,
       T defaultValue, Set<T> validValues) {
     Map<String, String> options = processingEnv.getOptions();
     if (options.containsKey(key)) {
       try {
-        T type = Enum.valueOf(defaultValue.getDeclaringClass(), options.get(key).toUpperCase());
+        T type = Enum.valueOf(
+            defaultValue.getDeclaringClass(),
+            Ascii.toUpperCase(options.get(key)));
         if (!validValues.contains(type)) {
           throw new IllegalArgumentException(); // let handler below print out good msg.
         }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
index a2a5eac22..a9e82a8cf 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
@@ -18,17 +18,13 @@
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
-import com.google.common.base.Joiner;
 import com.google.common.base.Optional;
-import com.google.common.base.Predicate;
-import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.LinkedHashMultimap;
 import com.google.common.collect.Multimap;
 import com.google.common.collect.Sets;
-import com.google.common.collect.Sets.SetView;
 import dagger.Component;
 import dagger.Module;
 import dagger.Subcomponent;
@@ -54,7 +50,6 @@
 import static dagger.internal.codegen.ConfigurationAnnotations.enclosedBuilders;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentModules;
 import static dagger.internal.codegen.ConfigurationAnnotations.getTransitiveModules;
-import static dagger.internal.codegen.Util.componentCanMakeNewInstances;
 import static javax.lang.model.element.ElementKind.CLASS;
 import static javax.lang.model.element.ElementKind.INTERFACE;
 import static javax.lang.model.element.Modifier.ABSTRACT;
@@ -133,18 +128,21 @@ static ComponentValidator createForSubcomponent(Elements elements,
   public ComponentValidationReport validate(final TypeElement subject,
       Set<? extends Element> validatedSubcomponents,
       Set<? extends Element> validatedSubcomponentBuilders) {
-    ValidationReport.Builder<TypeElement> builder = ValidationReport.Builder.about(subject);
+    ValidationReport.Builder<TypeElement> builder = ValidationReport.about(subject);
 
     if (!subject.getKind().equals(INTERFACE)
         && !(subject.getKind().equals(CLASS) && subject.getModifiers().contains(ABSTRACT))) {
-      builder.addItem(String.format("@%s may only be applied to an interface or abstract class",
-          componentType.annotationType().getSimpleName()), subject);
+      builder.addError(
+          String.format(
+              "@%s may only be applied to an interface or abstract class",
+              componentType.annotationType().getSimpleName()),
+          subject);
     }
 
     ImmutableList<DeclaredType> builders =
         enclosedBuilders(subject, componentType.builderAnnotationType());
     if (builders.size() > 1) {
-      builder.addItem(
+      builder.addError(
           String.format(ErrorMessages.builderMsgsFor(componentType).moreThanOne(), builders),
           subject);
     }
@@ -197,16 +195,16 @@ public ComponentValidationReport validate(final TypeElement subject,
               TypeMirror onlyParameter = Iterables.getOnlyElement(parameterTypes);
               if (!(returnType.getKind().equals(VOID)
                   || types.isSameType(returnType, onlyParameter))) {
-                builder.addItem(
-                    "Members injection methods may only return the injected type or void.",
-                    method);
+                builder.addError(
+                    "Members injection methods may only return the injected type or void.", method);
               }
               break;
             default:
               // this isn't any method that we know how to implement...
-              builder.addItem(
+              builder.addError(
                   "This method isn't a valid provision method, members injection method or "
-                      + "subcomponent factory method. Dagger cannot implement this method", method);
+                      + "subcomponent factory method. Dagger cannot implement this method",
+                  method);
               break;
           }
         }
@@ -216,10 +214,11 @@ public ComponentValidationReport validate(final TypeElement subject,
     for (Map.Entry<Element, Collection<ExecutableElement>> entry :
         referencedSubcomponents.asMap().entrySet()) {
       if (entry.getValue().size() > 1) {
-        builder.addItem(
+        builder.addError(
             String.format(
                 ErrorMessages.SubcomponentBuilderMessages.INSTANCE.moreThanOneRefToSubcomponent(),
-                entry.getKey(), entry.getValue()),
+                entry.getKey(),
+                entry.getValue()),
             subject);
       }
     }
@@ -260,18 +259,10 @@ private void validateSubcomponentMethod(final ValidationReport.Builder<TypeEleme
     // TODO(gak): This logic maybe/probably shouldn't live here as it requires us to traverse
     // subcomponents and their modules separately from how it is done in ComponentDescriptor and
     // ModuleDescriptor
+    @SuppressWarnings("deprecation")
     ImmutableSet<TypeElement> transitiveModules =
         getTransitiveModules(types, elements, moduleTypes);
 
-    ImmutableSet<TypeElement> requiredModules =
-        FluentIterable.from(transitiveModules)
-            .filter(new Predicate<TypeElement>() {
-              @Override public boolean apply(TypeElement input) {
-                return !componentCanMakeNewInstances(input);
-              }
-            })
-            .toSet();
-
     Set<TypeElement> variableTypes = Sets.newHashSet();
 
     for (int i = 0; i < parameterTypes.size(); i++) {
@@ -291,14 +282,15 @@ private void validateSubcomponentMethod(final ValidationReport.Builder<TypeEleme
           }, null);
       if (moduleType.isPresent()) {
         if (variableTypes.contains(moduleType.get())) {
-          builder.addItem(
+          builder.addError(
               String.format(
                   "A module may only occur once an an argument in a Subcomponent factory "
                       + "method, but %s was already passed.",
-                  moduleType.get().getQualifiedName()), parameter);
+                  moduleType.get().getQualifiedName()),
+              parameter);
         }
         if (!transitiveModules.contains(moduleType.get())) {
-          builder.addItem(
+          builder.addError(
               String.format(
                   "%s is present as an argument to the %s factory method, but is not one of the"
                       + " modules used to implement the subcomponent.",
@@ -308,25 +300,13 @@ private void validateSubcomponentMethod(final ValidationReport.Builder<TypeEleme
         }
         variableTypes.add(moduleType.get());
       } else {
-        builder.addItem(
+        builder.addError(
             String.format(
                 "Subcomponent factory methods may only accept modules, but %s is not.",
                 parameterType),
             parameter);
       }
     }
-
-    SetView<TypeElement> missingModules =
-        Sets.difference(requiredModules, ImmutableSet.copyOf(variableTypes));
-    if (!missingModules.isEmpty()) {
-      builder.addItem(
-          String.format(
-              "%s requires modules which have no visible default constructors. "
-                  + "Add the following modules as parameters to this method: %s",
-              MoreTypes.asTypeElement(returnType).getQualifiedName(),
-              Joiner.on(", ").join(missingModules)),
-          method);
-    }
   }
 
   private void validateSubcomponentBuilderMethod(ValidationReport.Builder<TypeElement> builder,
@@ -334,7 +314,7 @@ private void validateSubcomponentBuilderMethod(ValidationReport.Builder<TypeElem
       Set<? extends Element> validatedSubcomponentBuilders) {
 
     if (!parameters.isEmpty()) {
-      builder.addItem(
+      builder.addError(
           ErrorMessages.SubcomponentBuilderMessages.INSTANCE.builderMethodRequiresNoArgs(), method);
     }
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java
new file mode 100644
index 000000000..5221cf0a2
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java
@@ -0,0 +1,118 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.common.base.Predicate;
+import com.google.common.collect.Iterables;
+import dagger.internal.codegen.writer.ClassName;
+import dagger.internal.codegen.writer.ClassWriter;
+import dagger.internal.codegen.writer.JavaWriter;
+import dagger.internal.codegen.writer.MethodWriter;
+import javax.annotation.Generated;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
+import javax.tools.Diagnostic.Kind;
+
+import static dagger.internal.codegen.Util.componentCanMakeNewInstances;
+import static javax.lang.model.element.Modifier.FINAL;
+import static javax.lang.model.element.Modifier.PUBLIC;
+import static javax.lang.model.element.Modifier.STATIC;
+
+/**
+ * Creates the implementation class for a component.
+ */
+class ComponentWriter extends AbstractComponentWriter {
+
+  ComponentWriter(
+      Types types,
+      Elements elements,
+      Key.Factory keyFactory,
+      Kind nullableValidationType,
+      ClassName name,
+      BindingGraph graph) {
+    super(types, elements, keyFactory, nullableValidationType, name, graph);
+  }
+
+  @Override
+  protected ClassWriter createComponentClass() {
+    JavaWriter javaWriter = JavaWriter.inPackage(name.packageName());
+    javaWriters.add(javaWriter);
+
+    ClassWriter componentWriter = javaWriter.addClass(name.simpleName());
+    componentWriter.annotate(Generated.class).setValue(ComponentProcessor.class.getCanonicalName());
+    componentWriter.addModifiers(PUBLIC, FINAL);
+    componentWriter.setSupertype(componentDefinitionType());
+    return componentWriter;
+  }
+
+  @Override
+  protected ClassWriter createBuilder() {
+    ClassWriter builderWriter = componentWriter.addNestedClass("Builder");
+    builderWriter.addModifiers(STATIC);
+
+    // Only top-level components have the factory builder() method.
+    // Mirror the user's builder API type if they had one.
+    MethodWriter builderFactoryMethod =
+        graph.componentDescriptor().builderSpec().isPresent()
+            ? componentWriter.addMethod(
+                graph
+                    .componentDescriptor()
+                    .builderSpec()
+                    .get()
+                    .builderDefinitionType()
+                    .asType(),
+                "builder")
+            : componentWriter.addMethod(builderWriter, "builder");
+    builderFactoryMethod.addModifiers(PUBLIC, STATIC);
+    builderFactoryMethod.body().addSnippet("return new %s();", builderWriter.name());
+    return builderWriter;
+  }
+
+  @Override
+  protected void addFactoryMethods() {
+    if (canInstantiateAllRequirements()) {
+      MethodWriter factoryMethod =
+          componentWriter.addMethod(componentDefinitionTypeName(), "create");
+      factoryMethod.addModifiers(PUBLIC, STATIC);
+      // TODO(gak): replace this with something that doesn't allocate a builder
+      factoryMethod
+          .body()
+          .addSnippet(
+              "return builder().%s();",
+              graph.componentDescriptor().builderSpec().isPresent()
+                  ? graph
+                      .componentDescriptor()
+                      .builderSpec()
+                      .get()
+                      .buildMethod()
+                      .getSimpleName()
+                  : "build");
+    }
+  }
+
+  /** {@code true} if all of the graph's required dependencies can be automatically constructed. */
+  private boolean canInstantiateAllRequirements() {
+    return Iterables.all(
+        graph.componentRequirements(),
+        new Predicate<TypeElement>() {
+          @Override
+          public boolean apply(TypeElement dependency) {
+            return componentCanMakeNewInstances(dependency);
+          }
+        });
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
index 0630dfc7d..831943f2a 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
@@ -15,18 +15,37 @@
  */
 package dagger.internal.codegen;
 
+import com.google.auto.common.MoreTypes;
+import com.google.common.base.Equivalence;
+import com.google.common.base.Equivalence.Wrapper;
+import com.google.common.base.Function;
 import com.google.common.base.Optional;
+import com.google.common.base.Predicate;
 import com.google.common.collect.ImmutableListMultimap;
+import com.google.common.collect.ImmutableSetMultimap;
 import com.google.common.collect.Iterables;
+import com.google.common.collect.Multimaps;
 import com.google.common.collect.Ordering;
+import com.google.common.collect.Sets;
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.Component;
+import dagger.MapKey;
+import dagger.Provides;
+import dagger.producers.Produces;
+import dagger.producers.ProductionComponent;
 import java.util.EnumSet;
 import java.util.Set;
-import javax.inject.Provider;
+import javax.inject.Inject;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.AnnotationValue;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.DeclaredType;
 
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
+import static dagger.internal.codegen.MapKeys.getMapKey;
+import static dagger.internal.codegen.MapKeys.unwrapValue;
+import static javax.lang.model.element.Modifier.STATIC;
 
 /**
  * An abstract class for a value object representing the mechanism by which a {@link Key} can be
@@ -36,7 +55,19 @@
  * @since 2.0
  */
 abstract class ContributionBinding extends Binding {
-  static enum BindingType {
+  
+  @Override
+  Set<DependencyRequest> implicitDependencies() {
+    // Optimization: If we don't need the memberInjectionRequest, don't create more objects.
+    if (!membersInjectionRequest().isPresent()) {
+      return dependencies();
+    } else {
+      // Optimization: Avoid creating an ImmutableSet+Builder just to union two things together.
+      return Sets.union(membersInjectionRequest().asSet(), dependencies());
+    }
+  }
+
+  static enum ContributionType {
     /** Represents map bindings. */
     MAP,
     /** Represents set bindings. */
@@ -49,8 +80,20 @@ boolean isMultibinding() {
     }
   }
 
-  abstract BindingType bindingType();
-
+  ContributionType contributionType() {
+    switch (provisionType()) {
+      case SET:
+      case SET_VALUES:
+        return ContributionType.SET;
+      case MAP:
+        return ContributionType.MAP;
+      case UNIQUE:
+        return ContributionType.UNIQUE;
+      default:
+        throw new AssertionError("Unknown provision type: " + provisionType());
+    }
+  }
+  
   /** Returns the type that specifies this' nullability, absent if not nullable. */
   abstract Optional<DeclaredType> nullableType();
 
@@ -66,47 +109,180 @@ boolean isMultibinding() {
    * Returns whether this binding is synthetic, i.e., not explicitly tied to code, but generated
    * implicitly by the framework.
    */
-  // TODO(user): Remove the SYNTHETIC enums from ProvisionBinding and ProductionBinding and make
-  // this field the source of truth for synthetic bindings.
-  abstract boolean isSyntheticBinding();
+  boolean isSyntheticBinding() {
+    return bindingKind().equals(Kind.SYNTHETIC);
+  }
+
+  /** If this provision requires members injection, this will be the corresponding request. */
+  abstract Optional<DependencyRequest> membersInjectionRequest();
 
   /**
-   * Returns the framework class associated with this binding, e.g., {@link Provider} for a
-   * ProvisionBinding.
+   * The kind of contribution this binding represents. Defines which elements can specify this kind
+   * of contribution.
    */
-  abstract Class<?> frameworkClass();
+  enum Kind {
+    /**
+     * A binding that is not explicitly tied to an element, but generated implicitly by the
+     * framework.
+     */
+    SYNTHETIC,
+
+    // Provision kinds
+
+    /** An {@link Inject}-annotated constructor. */
+    INJECTION,
+
+    /** A {@link Provides}-annotated method. */
+    PROVISION,
+
+    /** An implicit binding to a {@link Component @Component}-annotated type. */
+    COMPONENT,
 
+    /** A provision method on a component's {@linkplain Component#dependencies() dependency}. */
+    COMPONENT_PROVISION,
+
+    /**
+     * A subcomponent builder method on a component or subcomponent.
+     */
+    SUBCOMPONENT_BUILDER,
+
+    // Production kinds
+
+    /** A {@link Produces}-annotated method that doesn't return a {@link ListenableFuture}. */
+    IMMEDIATE,
+
+    /** A {@link Produces}-annotated method that returns a {@link ListenableFuture}. */
+    FUTURE_PRODUCTION,
+
+    /**
+     * A production method on a production component's
+     * {@linkplain ProductionComponent#dependencies() dependency} that returns a
+     * {@link ListenableFuture}. Methods on production component dependencies that don't return a
+     * {@link ListenableFuture} are considered {@linkplain #PROVISION provision bindings}.
+     */
+    COMPONENT_PRODUCTION,
+  }
+
+  /**
+   * The kind of this contribution binding.
+   */
+  protected abstract Kind bindingKind();
+  
   /**
-   * Returns the set of {@link BindingType} enum values implied by a given
-   * {@link ContributionBinding} collection.
+   * A predicate that passes for bindings of a given kind.
    */
-  static <B extends ContributionBinding> ImmutableListMultimap<BindingType, B> bindingTypesFor(
-      Iterable<? extends B> bindings) {
-    ImmutableListMultimap.Builder<BindingType, B> builder =
-        ImmutableListMultimap.builder();
-    builder.orderKeysBy(Ordering.<BindingType>natural());
+  static Predicate<ContributionBinding> isOfKind(final Kind kind) {
+    return new Predicate<ContributionBinding>() {
+      @Override
+      public boolean apply(ContributionBinding binding) {
+        return binding.bindingKind().equals(kind);
+      }};
+  }
+
+  /** The provision type that was used to bind the key. */
+  abstract Provides.Type provisionType();
+
+  /**
+   * The strategy for getting an instance of a factory for a {@link ContributionBinding}.
+   */
+  enum FactoryCreationStrategy {
+    /** The factory class is an enum with one value named {@code INSTANCE}. */
+    ENUM_INSTANCE,
+    /** The factory must be created by calling the constructor. */
+    CLASS_CONSTRUCTOR,
+  }
+
+  /**
+   * Returns {@link FactoryCreationStrategy#ENUM_INSTANCE} if the binding has no dependencies and
+   * is a static provision binding or an {@link Inject @Inject} constructor binding. Otherwise
+   * returns {@link FactoryCreationStrategy#CLASS_CONSTRUCTOR}.
+   */
+  FactoryCreationStrategy factoryCreationStrategy() {
+    switch (bindingKind()) {
+      case PROVISION:
+        return implicitDependencies().isEmpty() && bindingElement().getModifiers().contains(STATIC)
+            ? FactoryCreationStrategy.ENUM_INSTANCE
+            : FactoryCreationStrategy.CLASS_CONSTRUCTOR;
+
+      case INJECTION:
+        return implicitDependencies().isEmpty()
+            ? FactoryCreationStrategy.ENUM_INSTANCE
+            : FactoryCreationStrategy.CLASS_CONSTRUCTOR;
+
+      default:
+        return FactoryCreationStrategy.CLASS_CONSTRUCTOR;
+    }
+  }
+
+  /**
+   * Returns the {@link ContributionType}s represented by a given {@link ContributionBinding}
+   * collection.
+   */
+  static <B extends ContributionBinding>
+      ImmutableListMultimap<ContributionType, B> contributionTypesFor(
+          Iterable<? extends B> bindings) {
+    ImmutableListMultimap.Builder<ContributionType, B> builder = ImmutableListMultimap.builder();
+    builder.orderKeysBy(Ordering.<ContributionType>natural());
     for (B binding : bindings) {
-      builder.put(binding.bindingType(), binding);
+      builder.put(binding.contributionType(), binding);
     }
     return builder.build();
   }
 
   /**
-   * Returns a single {@code BindingsType} represented by a given collection of
-   * {@code ContributionBindings} or throws an IllegalArgumentException if the given bindings
-   * are not all of one type.
+   * Returns a single {@link ContributionType} represented by a given collection of
+   * {@link ContributionBinding}s.
+   *
+   * @throws IllegalArgumentException if the given bindings are not all of one type
    */
-  static BindingType bindingTypeFor(Iterable<? extends ContributionBinding> bindings) {
+  static ContributionType contributionTypeFor(Iterable<ContributionBinding> bindings) {
     checkNotNull(bindings);
     checkArgument(!Iterables.isEmpty(bindings), "no bindings");
-    Set<BindingType> types = EnumSet.noneOf(BindingType.class);
+    Set<ContributionType> types = EnumSet.noneOf(ContributionType.class);
     for (ContributionBinding binding : bindings) {
-      types.add(binding.bindingType());
+      types.add(binding.contributionType());
     }
     if (types.size() > 1) {
       throw new IllegalArgumentException(
-          String.format(ErrorMessages.MULTIPLE_BINDING_TYPES_FORMAT, types));
+          String.format(ErrorMessages.MULTIPLE_CONTRIBUTION_TYPES_FORMAT, types));
     }
     return Iterables.getOnlyElement(types);
   }
+
+  /**
+   * Indexes map-multibindings by map key (the result of calling
+   * {@link AnnotationValue#getValue()} on a single member or the whole {@link AnnotationMirror}
+   * itself, depending on {@link MapKey#unwrapValue()}).
+   */
+  static ImmutableSetMultimap<Object, ContributionBinding> indexMapBindingsByMapKey(
+      Set<ContributionBinding> mapBindings) {
+    return ImmutableSetMultimap.copyOf(
+        Multimaps.index(
+            mapBindings,
+            new Function<ContributionBinding, Object>() {
+              @Override
+              public Object apply(ContributionBinding mapBinding) {
+                AnnotationMirror mapKey = getMapKey(mapBinding.bindingElement()).get();
+                Optional<? extends AnnotationValue> unwrappedValue = unwrapValue(mapKey);
+                return unwrappedValue.isPresent() ? unwrappedValue.get().getValue() : mapKey;
+              }
+            }));
+  }
+
+  /**
+   * Indexes map-multibindings by map key annotation type.
+   */
+  static ImmutableSetMultimap<Wrapper<DeclaredType>, ContributionBinding>
+      indexMapBindingsByAnnotationType(Set<ContributionBinding> mapBindings) {
+    return ImmutableSetMultimap.copyOf(
+        Multimaps.index(
+            mapBindings,
+            new Function<ContributionBinding, Equivalence.Wrapper<DeclaredType>>() {
+              @Override
+              public Equivalence.Wrapper<DeclaredType> apply(ContributionBinding mapBinding) {
+                return MoreTypes.equivalence()
+                    .wrap(getMapKey(mapBinding.bindingElement()).get().getAnnotationType());
+              }
+            }));
+  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProductionBindingFormatter.java b/compiler/src/main/java/dagger/internal/codegen/ContributionBindingFormatter.java
similarity index 71%
rename from compiler/src/main/java/dagger/internal/codegen/ProductionBindingFormatter.java
rename to compiler/src/main/java/dagger/internal/codegen/ContributionBindingFormatter.java
index e7e7e778a..0d267619b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProductionBindingFormatter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ContributionBindingFormatter.java
@@ -21,26 +21,32 @@
 import static com.google.auto.common.MoreTypes.asDeclared;
 
 /**
- * Formats a {@link ProductionBinding} into a {@link String} suitable for use in error messages.
+ * Formats a {@link ContributionBinding} into a {@link String} suitable for use in error messages.
  *
- * @author Jesse Beder
+ * @author Christian Gruber
  * @since 2.0
  */
-final class ProductionBindingFormatter extends Formatter<ProductionBinding> {
+final class ContributionBindingFormatter extends Formatter<ContributionBinding> {
   private final MethodSignatureFormatter methodSignatureFormatter;
-
-  ProductionBindingFormatter(MethodSignatureFormatter methodSignatureFormatter) {
+  
+  ContributionBindingFormatter(MethodSignatureFormatter methodSignatureFormatter) { 
     this.methodSignatureFormatter = methodSignatureFormatter;
   }
 
-  @Override public String format(ProductionBinding binding) {
+  @Override public String format(ContributionBinding binding) {
     switch (binding.bindingKind()) {
+      case COMPONENT_PROVISION:
+      case COMPONENT_PRODUCTION:
+        return methodSignatureFormatter.format(asExecutable(binding.bindingElement()));
+
+      case PROVISION:
+      case SUBCOMPONENT_BUILDER:
       case IMMEDIATE:
       case FUTURE_PRODUCTION:
-        return methodSignatureFormatter.format(asExecutable(binding.bindingElement()),
+        return methodSignatureFormatter.format(
+            asExecutable(binding.bindingElement()),
             Optional.of(asDeclared(binding.contributedBy().get().asType())));
-      case COMPONENT_PRODUCTION:
-        return methodSignatureFormatter.format(asExecutable(binding.bindingElement()));
+
       default:
         throw new UnsupportedOperationException(
             "Not yet supporting " + binding.bindingKind() + " binding types.");
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
index 7097b9991..49fcd9c9b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
@@ -29,23 +29,27 @@
 import dagger.Provides;
 import dagger.producers.Produced;
 import dagger.producers.Producer;
+import dagger.producers.internal.AbstractProducer;
 import java.util.List;
 import javax.inject.Inject;
 import javax.inject.Provider;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.ExecutableType;
 import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Elements;
 
 import static com.google.auto.common.MoreTypes.isTypeOf;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
 import static javax.lang.model.type.TypeKind.DECLARED;
+import static javax.lang.model.util.ElementFilter.constructorsIn;
 
 /**
  * Represents a request for a key at an injection point. Parameters to {@link Inject} constructors
@@ -57,6 +61,13 @@
 // TODO(gak): Set bindings and the permutations thereof need to be addressed
 @AutoValue
 abstract class DependencyRequest {
+  static final Function<DependencyRequest, BindingKey> BINDING_KEY_FUNCTION =
+      new Function<DependencyRequest, BindingKey>() {
+        @Override public BindingKey apply(DependencyRequest request) {
+          return request.bindingKey();
+        }
+      };
+
   enum Kind {
     /** A default request for an instance.  E.g.: {@code Blah} */
     INSTANCE,
@@ -107,6 +118,12 @@ BindingKey bindingKey() {
   /** Returns true if this request allows null objects. */
   abstract boolean isNullable();
 
+  /**
+   * An optional name for this request when it's referred to in generated code. If absent, it will
+   * use a name derived from {@link #requestElement}.
+   */
+  abstract Optional<String> overriddenVariableName();
+
   /**
    * Factory for {@link DependencyRequest}s.
    *
@@ -114,9 +131,11 @@ BindingKey bindingKey() {
    * which may mean that the type will be generated in a later round of processing.
    */
   static final class Factory {
+    private final Elements elements;
     private final Key.Factory keyFactory;
 
-    Factory(Key.Factory keyFactory) {
+    Factory(Elements elements, Key.Factory keyFactory) {
+      this.elements = elements;
       this.keyFactory = keyFactory;
     }
 
@@ -133,33 +152,46 @@ BindingKey bindingKey() {
     ImmutableSet<DependencyRequest> forRequiredVariables(
         List<? extends VariableElement> variables) {
       return FluentIterable.from(variables)
-          .transform(new Function<VariableElement, DependencyRequest>() {
-            @Override public DependencyRequest apply(VariableElement input) {
-              return forRequiredVariable(input);
-            }
-          })
+          .transform(
+              new Function<VariableElement, DependencyRequest>() {
+                @Override
+                public DependencyRequest apply(VariableElement input) {
+                  return forRequiredVariable(input);
+                }
+              })
           .toSet();
     }
 
     /**
-     * Creates a DependencyRequest for implictMapBinding, this request's key will be
-     * {@code Map<K, Provider<V>>}, this DependencyRequest is depended by the DependencyRequest
-     * whose key is {@code Map<K, V>}
+     * Creates a implicit {@link DependencyRequest} for {@code mapOfFactoryKey}, which will be used
+     * to satisfy the {@code mapOfValueRequest}.
+     * 
+     * @param mapOfValueRequest a request for {@code Map<K, V>}
+     * @param mapOfFactoryKey a key equivalent to {@code mapOfValueRequest}'s key, whose type is
+     *     {@code Map<K, Provider<V>>} or {@code Map<K, Producer<V>>}
      */
-    DependencyRequest forImplicitMapBinding(DependencyRequest delegatingRequest, Key delegateKey) {
-      checkNotNull(delegatingRequest);
-      return new AutoValue_DependencyRequest(Kind.PROVIDER, delegateKey,
-          delegatingRequest.requestElement(),
-          getEnclosingType(delegatingRequest.requestElement()),
-          false /* doesn't allow null */);
+    DependencyRequest forImplicitMapBinding(
+        DependencyRequest mapOfValueRequest, Key mapOfFactoryKey) {
+      checkNotNull(mapOfValueRequest);
+      return new AutoValue_DependencyRequest(
+          Kind.PROVIDER,
+          mapOfFactoryKey,
+          mapOfValueRequest.requestElement(),
+          mapOfValueRequest.enclosingType(),
+          false /* doesn't allow null */,
+          Optional.<String>absent());
     }
 
     DependencyRequest forRequiredVariable(VariableElement variableElement) {
+      return forRequiredVariable(variableElement, Optional.<String>absent());
+    }
+
+    DependencyRequest forRequiredVariable(VariableElement variableElement, Optional<String> name) {
       checkNotNull(variableElement);
       TypeMirror type = variableElement.asType();
       Optional<AnnotationMirror> qualifier = InjectionAnnotations.getQualifier(variableElement);
-      return newDependencyRequest(variableElement, type, qualifier,
-          getEnclosingType(variableElement));
+      return newDependencyRequest(
+          variableElement, type, qualifier, getEnclosingType(variableElement), name);
     }
 
     DependencyRequest forRequiredResolvedVariable(DeclaredType container,
@@ -168,18 +200,25 @@ DependencyRequest forRequiredResolvedVariable(DeclaredType container,
       checkNotNull(variableElement);
       checkNotNull(resolvedType);
       Optional<AnnotationMirror> qualifier = InjectionAnnotations.getQualifier(variableElement);
-      return newDependencyRequest(variableElement, resolvedType, qualifier, container);
+      return newDependencyRequest(
+          variableElement, resolvedType, qualifier, container, Optional.<String>absent());
     }
 
     DependencyRequest forComponentProvisionMethod(ExecutableElement provisionMethod,
         ExecutableType provisionMethodType) {
       checkNotNull(provisionMethod);
       checkNotNull(provisionMethodType);
-      checkArgument(provisionMethod.getParameters().isEmpty(),
-          "Component provision methods must be empty: " + provisionMethod);
+      checkArgument(
+          provisionMethod.getParameters().isEmpty(),
+          "Component provision methods must be empty: %s",
+          provisionMethod);
       Optional<AnnotationMirror> qualifier = InjectionAnnotations.getQualifier(provisionMethod);
-      return newDependencyRequest(provisionMethod, provisionMethodType.getReturnType(), qualifier,
-          getEnclosingType(provisionMethod));
+      return newDependencyRequest(
+          provisionMethod,
+          provisionMethodType.getReturnType(),
+          qualifier,
+          getEnclosingType(provisionMethod),
+          Optional.<String>absent());
     }
 
     DependencyRequest forComponentProductionMethod(ExecutableElement productionMethod,
@@ -196,13 +235,15 @@ DependencyRequest forComponentProductionMethod(ExecutableElement productionMetho
       if (isTypeOf(ListenableFuture.class, type)) {
         return new AutoValue_DependencyRequest(
             Kind.FUTURE,
-            keyFactory.forQualifiedType(qualifier,
-                Iterables.getOnlyElement(((DeclaredType) type).getTypeArguments())),
+            keyFactory.forQualifiedType(
+                qualifier, Iterables.getOnlyElement(((DeclaredType) type).getTypeArguments())),
             productionMethod,
             container,
-            false /* doesn't allow null */);
+            false /* doesn't allow null */,
+            Optional.<String>absent());
       } else {
-        return newDependencyRequest(productionMethod, type, qualifier, container);
+        return newDependencyRequest(
+            productionMethod, type, qualifier, container, Optional.<String>absent());
       }
     }
 
@@ -216,32 +257,53 @@ DependencyRequest forComponentMembersInjectionMethod(ExecutableElement membersIn
       TypeMirror returnType = membersInjectionMethodType.getReturnType();
       if (returnType.getKind().equals(DECLARED)
           && MoreTypes.isTypeOf(MembersInjector.class, returnType)) {
-        return new AutoValue_DependencyRequest(Kind.MEMBERS_INJECTOR,
+        return new AutoValue_DependencyRequest(
+            Kind.MEMBERS_INJECTOR,
             keyFactory.forMembersInjectedType(
                 Iterables.getOnlyElement(((DeclaredType) returnType).getTypeArguments())),
-                membersInjectionMethod,
-                getEnclosingType(membersInjectionMethod),
-                false /* doesn't allow null */);
+            membersInjectionMethod,
+            getEnclosingType(membersInjectionMethod),
+            false /* doesn't allow null */,
+            Optional.<String>absent());
       } else {
-        return new AutoValue_DependencyRequest(Kind.MEMBERS_INJECTOR,
+        return new AutoValue_DependencyRequest(
+            Kind.MEMBERS_INJECTOR,
             keyFactory.forMembersInjectedType(
                 Iterables.getOnlyElement(membersInjectionMethodType.getParameterTypes())),
-                membersInjectionMethod,
-                getEnclosingType(membersInjectionMethod),
-                false /* doesn't allow null */);
+            membersInjectionMethod,
+            getEnclosingType(membersInjectionMethod),
+            false /* doesn't allow null */,
+            Optional.<String>absent());
       }
     }
 
     DependencyRequest forMembersInjectedType(DeclaredType type) {
-      return new AutoValue_DependencyRequest(Kind.MEMBERS_INJECTOR,
+      return new AutoValue_DependencyRequest(
+          Kind.MEMBERS_INJECTOR,
           keyFactory.forMembersInjectedType(type),
           type.asElement(),
           type,
-          false /* doesn't allow null */);
+          false /* doesn't allow null */,
+          Optional.<String>absent());
+    }
+
+    DependencyRequest forProductionComponentMonitorProvider() {
+      TypeElement element = elements.getTypeElement(AbstractProducer.class.getCanonicalName());
+      for (ExecutableElement constructor : constructorsIn(element.getEnclosedElements())) {
+        if (constructor.getParameters().size() == 2) {
+          // the 2-arg constructor has the appropriate dependency as its first arg
+          return forRequiredVariable(constructor.getParameters().get(0), Optional.of("monitor"));
+        }
+      }
+      throw new AssertionError("expected 2-arg constructor in AbstractProducer");
     }
 
-    private DependencyRequest newDependencyRequest(Element requestElement,
-        TypeMirror type, Optional<AnnotationMirror> qualifier, DeclaredType container) {
+    private DependencyRequest newDependencyRequest(
+        Element requestElement,
+        TypeMirror type,
+        Optional<AnnotationMirror> qualifier,
+        DeclaredType container,
+        Optional<String> name) {
       KindAndType kindAndType = extractKindAndType(type);
       if (kindAndType.kind().equals(Kind.MEMBERS_INJECTOR)) {
         checkArgument(!qualifier.isPresent());
@@ -251,11 +313,13 @@ private DependencyRequest newDependencyRequest(Element requestElement,
       // TODO(sameb): should Produced/Producer always require non-nullable?
       boolean allowsNull = !kindAndType.kind().equals(Kind.INSTANCE)
           || ConfigurationAnnotations.getNullableType(requestElement).isPresent();
-      return new AutoValue_DependencyRequest(kindAndType.kind(),
+      return new AutoValue_DependencyRequest(
+          kindAndType.kind(),
           keyFactory.forQualifiedType(qualifier, kindAndType.type()),
           requestElement,
           container,
-          allowsNull);
+          allowsNull,
+          name);
     }
 
     @AutoValue
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyVariableNamer.java b/compiler/src/main/java/dagger/internal/codegen/DependencyVariableNamer.java
index 1643adbc4..5ba5635cd 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DependencyVariableNamer.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyVariableNamer.java
@@ -33,6 +33,9 @@
 final class DependencyVariableNamer implements Function<DependencyRequest, String> {
   @Override
   public String apply(DependencyRequest dependency) {
+    if (dependency.overriddenVariableName().isPresent()) {
+      return dependency.overriddenVariableName().get();
+    }
     String variableName = dependency.requestElement().getSimpleName().toString();
     switch (dependency.kind()) {
       case INSTANCE:
diff --git a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
index 12da8deae..1f52aca98 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
@@ -31,6 +31,7 @@
    * Common constants.
    */
   static final String INDENT = "    ";
+  static final int DUPLICATE_SIZE_LIMIT = 10;
 
   /*
    * JSR-330 errors
@@ -76,10 +77,16 @@
   /* fields */
   static final String PRIVATE_INJECT_FIELD =
       "Dagger does not support injection into private fields";
+  
+  static final String STATIC_INJECT_FIELD =
+      "Dagger does not support injection into static fields";
 
   /* methods */
   static final String PRIVATE_INJECT_METHOD =
       "Dagger does not support injection into private methods";
+  
+  static final String STATIC_INJECT_METHOD =
+      "Dagger does not support injection into static methods";
 
   /* all */
   static final String INJECT_INTO_PRIVATE_CLASS =
@@ -94,6 +101,14 @@
   static final String DUPLICATE_BINDINGS_FOR_KEY_FORMAT =
       "%s is bound multiple times:";
 
+  static String duplicateMapKeysError(String key) {
+    return "The same map key is bound more than once for " + key;
+  }
+
+  static String inconsistentMapKeyAnnotationsError(String key) {
+    return key + " uses more than one @MapKey annotation type";
+  }
+
   static final String PROVIDES_METHOD_RETURN_TYPE =
       "@Provides methods must either return a primitive, an array or a declared type.";
 
@@ -145,7 +160,7 @@
       "%s is listed as a module, but is an abstract class or interface";
 
   static final String REFERENCED_MODULE_NOT_ANNOTATED =
-      "%s is listed as a module, but is not annotated with @%s";
+      "%s is listed as a module, but is not annotated with %s";
 
   static final String REFERENCED_MODULE_MUST_NOT_HAVE_TYPE_PARAMS =
       "%s is listed as a module, but has type parameters";
@@ -170,7 +185,7 @@
       "Map key annotations with unwrapped values cannot use arrays";
 
   /* collection binding errors */
-  static final String MULTIPLE_BINDING_TYPES_FORMAT =
+  static final String MULTIPLE_CONTRIBUTION_TYPES_FORMAT =
       "More than one binding present of different types %s";
 
   static final String MULTIPLE_BINDING_TYPES_FOR_KEY_FORMAT =
@@ -209,8 +224,12 @@
   static final String MALFORMED_MODULE_METHOD_FORMAT =
       "Cannot generated a graph because method %s on module %s was malformed";
 
-  static final String NULLABLE_TO_NON_NULLABLE =
-      "%s is not nullable, but is being provided by %s";
+  static String nullableToNonNullable(String typeName, String bindingString) {
+    return String.format(
+            "%s is not nullable, but is being provided by %s",
+            typeName,
+            bindingString);
+  }
 
   static final String CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD =
       "Cannot return null from a non-@Nullable component method";
@@ -224,6 +243,8 @@ static ComponentBuilderMessages builderMsgsFor(ComponentDescriptor.Kind kind) {
         return ComponentBuilderMessages.INSTANCE;
       case SUBCOMPONENT:
         return SubcomponentBuilderMessages.INSTANCE;
+      case PRODUCTION_COMPONENT:
+        return ProductionComponentBuilderMessages.INSTANCE;
       default:
         throw new IllegalStateException(kind.toString());
     }
@@ -355,6 +376,17 @@ String moreThanOneRefToSubcomponent() {
     }
   }
 
+  static final class ProductionComponentBuilderMessages extends ComponentBuilderMessages {
+    @SuppressWarnings("hiding")
+    static final ProductionComponentBuilderMessages INSTANCE =
+        new ProductionComponentBuilderMessages();
+
+    @Override protected String process(String s) {
+      return s.replaceAll("component", "production component")
+          .replaceAll("Component", "ProductionComponent");
+    }
+  }
+
   /**
    * A regular expression to match a small list of specific packages deemed to
    * be unhelpful to display in fully qualified types in error messages.
diff --git a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
index c7eb6326f..a0a48c81e 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
@@ -52,11 +52,11 @@
 
 import static com.google.common.base.Preconditions.checkState;
 import static dagger.Provides.Type.SET;
+import static dagger.internal.codegen.ContributionBinding.Kind.PROVISION;
 import static dagger.internal.codegen.ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_PROVIDES_METHOD;
-import static dagger.internal.codegen.ProvisionBinding.Kind.PROVISION;
-import static dagger.internal.codegen.SourceFiles.factoryNameForProvisionBinding;
 import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
-import static dagger.internal.codegen.SourceFiles.parameterizedFactoryNameForProvisionBinding;
+import static dagger.internal.codegen.SourceFiles.generatedClassNameForBinding;
+import static dagger.internal.codegen.SourceFiles.parameterizedGeneratedTypeNameForBinding;
 import static dagger.internal.codegen.writer.Snippet.makeParametersSnippet;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
@@ -83,7 +83,7 @@
 
   @Override
   ClassName nameGeneratedType(ProvisionBinding binding) {
-    return factoryNameForProvisionBinding(binding);
+    return generatedClassNameForBinding(binding);
   }
 
   @Override
@@ -156,7 +156,7 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
     getMethodWriter.annotate(Override.class);
     getMethodWriter.addModifiers(PUBLIC);
 
-    if (binding.memberInjectionRequest().isPresent()) {
+    if (binding.membersInjectionRequest().isPresent()) {
       ParameterizedTypeName membersInjectorType = ParameterizedTypeName.create(
           MembersInjector.class, providedTypeName);
       factoryWriter.addField(membersInjectorType, "membersInjector").addModifiers(PRIVATE, FINAL);
@@ -211,7 +211,7 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
             break;
           case CLASS_CONSTRUCTOR:
             createMethodWriter.body().addSnippet("return new %s(%s);",
-                parameterizedFactoryNameForProvisionBinding(binding),
+                parameterizedGeneratedTypeNameForBinding(binding),
                 Joiner.on(", ").join(params.keySet()));
             break;
           default:
@@ -262,7 +262,7 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
             providesMethodInvocation,
             failMsg));
       }
-    } else if (binding.memberInjectionRequest().isPresent()) {
+    } else if (binding.membersInjectionRequest().isPresent()) {
       getMethodWriter.body().addSnippet("%1$s instance = new %1$s(%2$s);",
           providedTypeName, parametersSnippet);
       getMethodWriter.body().addSnippet("membersInjector.injectMembers(instance);");
diff --git a/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java b/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java
index f6b207c09..38e8f026a 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java
@@ -17,11 +17,21 @@
 
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
+import com.google.common.base.CaseFormat;
+import com.google.common.collect.ImmutableSet;
+import dagger.MembersInjector;
 import dagger.internal.codegen.writer.ClassName;
 import dagger.internal.codegen.writer.ParameterizedTypeName;
-import dagger.internal.codegen.writer.TypeName;
 import dagger.internal.codegen.writer.TypeNames;
+import javax.lang.model.element.ElementVisitor;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.ElementKindVisitor6;
+
+import static com.google.common.collect.Iterables.any;
+import static com.google.common.collect.Iterables.getOnlyElement;
+import static dagger.internal.codegen.ContributionBinding.contributionTypeFor;
 
 /**
  * A value object that represents a field used by Dagger-generated code.
@@ -33,7 +43,6 @@
 abstract class FrameworkField {
   // TODO(gak): reexamine the this class and how consistently we're using it and its creation
   // methods
-
   static FrameworkField createWithTypeFromKey(
       Class<?> frameworkClass, BindingKey bindingKey, String name) {
     String suffix = frameworkClass.getSimpleName();
@@ -44,18 +53,113 @@ static FrameworkField createWithTypeFromKey(
         name.endsWith(suffix) ? name : name + suffix);
   }
 
-  static FrameworkField createForMapBindingContribution(
+  private static FrameworkField createForMapBindingContribution(
       Class<?> frameworkClass, BindingKey bindingKey, String name) {
     TypeMirror mapValueType =
         MoreTypes.asDeclared(bindingKey.key().type()).getTypeArguments().get(1);
     return new AutoValue_FrameworkField(frameworkClass,
-        TypeNames.forTypeMirror(mapValueType),
+        (ParameterizedTypeName) TypeNames.forTypeMirror(mapValueType),
         bindingKey,
         name);
   }
 
+  static FrameworkField createForSyntheticContributionBinding(
+      int contributionNumber, ContributionBinding contributionBinding) {
+    switch (contributionBinding.contributionType()) {
+      case MAP:
+        return createForMapBindingContribution(
+            contributionBinding.frameworkClass(),
+            contributionBinding.bindingKey(),
+            KeyVariableNamer.INSTANCE.apply(contributionBinding.key())
+                + "Contribution"
+                + contributionNumber);
+
+      case SET:
+      case UNIQUE:
+        return createWithTypeFromKey(
+            contributionBinding.frameworkClass(),
+            contributionBinding.bindingKey(),
+            KeyVariableNamer.INSTANCE.apply(contributionBinding.key())
+                + "Contribution"
+                + contributionNumber);
+      default:
+        throw new AssertionError();
+    }
+  }
+
+  static FrameworkField createForResolvedBindings(ResolvedBindings resolvedBindings) {
+    BindingKey bindingKey = resolvedBindings.bindingKey();
+    switch (bindingKey.kind()) {
+      case CONTRIBUTION:
+        ImmutableSet<ContributionBinding> contributionBindings =
+            resolvedBindings.contributionBindings();
+        switch (contributionTypeFor(contributionBindings)) {
+          case SET:
+          case MAP:
+            return createWithTypeFromKey(
+                FrameworkField.frameworkClassForResolvedBindings(resolvedBindings),
+                bindingKey,
+                KeyVariableNamer.INSTANCE.apply(bindingKey.key()));
+          case UNIQUE:
+            ContributionBinding binding = getOnlyElement(contributionBindings);
+            return createWithTypeFromKey(
+                FrameworkField.frameworkClassForResolvedBindings(resolvedBindings),
+                bindingKey,
+                BINDING_ELEMENT_NAME.visit(binding.bindingElement()));
+          default:
+            throw new AssertionError();
+        }
+      case MEMBERS_INJECTION:
+        return createWithTypeFromKey(
+            MembersInjector.class,
+            bindingKey,
+            CaseFormat.UPPER_CAMEL.to(
+                CaseFormat.LOWER_CAMEL,
+                resolvedBindings
+                    .membersInjectionBinding()
+                    .get()
+                    .bindingElement()
+                    .getSimpleName()
+                    .toString()));
+      default:
+        throw new AssertionError();
+    }
+  }
+
+  private static final ElementVisitor<String, Void> BINDING_ELEMENT_NAME =
+      new ElementKindVisitor6<String, Void>() {
+        @Override
+        public String visitExecutableAsConstructor(ExecutableElement e, Void p) {
+          return visit(e.getEnclosingElement());
+        }
+
+        @Override
+        public String visitExecutableAsMethod(ExecutableElement e, Void p) {
+          return e.getSimpleName().toString();
+        }
+
+        @Override
+        public String visitType(TypeElement e, Void p) {
+          return CaseFormat.UPPER_CAMEL.to(
+              CaseFormat.LOWER_CAMEL, e.getSimpleName().toString());
+        }
+      };
+
+  static Class<?> frameworkClassForResolvedBindings(ResolvedBindings resolvedBindings) {
+    switch (resolvedBindings.bindingKey().kind()) {
+      case CONTRIBUTION:
+        return any(resolvedBindings.contributionBindings(), Binding.Type.PRODUCTION)
+            ? Binding.Type.PRODUCTION.frameworkClass()
+            : Binding.Type.PROVISION.frameworkClass();
+      case MEMBERS_INJECTION:
+        return MembersInjector.class;
+      default:
+        throw new AssertionError();
+    }
+  }
+
   abstract Class<?> frameworkClass();
-  abstract TypeName frameworkType();
+  abstract ParameterizedTypeName frameworkType();
   abstract BindingKey bindingKey();
   abstract String name();
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java b/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
index 071ce6982..f7ca429f3 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
@@ -45,6 +45,7 @@
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
+import static dagger.internal.codegen.SourceFiles.generatedClassNameForBinding;
 
 /**
  * Maintains the collection of provision bindings from {@link Inject} constructors and members
@@ -64,7 +65,7 @@
   final class BindingsCollection<B extends Binding> {
     private final Map<Key, B> bindingsByKey = Maps.newLinkedHashMap();
     private final Deque<B> bindingsRequiringGeneration = new ArrayDeque<>();
-    private final Set<B> materializedBindings = Sets.newLinkedHashSet();
+    private final Set<Key> materializedBindingKeys = Sets.newLinkedHashSet();
 
     void generateBindings(SourceFileGenerator<B> generator) throws SourceFileGenerationException {
       for (B binding = bindingsRequiringGeneration.poll();
@@ -72,8 +73,11 @@ void generateBindings(SourceFileGenerator<B> generator) throws SourceFileGenerat
           binding = bindingsRequiringGeneration.poll()) {
         checkState(!binding.hasNonDefaultTypeParameters());
         generator.generate(binding);
-        materializedBindings.add(binding);
+        materializedBindingKeys.add(binding.key());
       }
+      // Because Elements instantiated across processing rounds are not guaranteed to be equals() to
+      // the logically same element, clear the cache after generating 
+      bindingsByKey.clear();
     }
 
     /** Returns a previously cached binding. */
@@ -81,15 +85,6 @@ B getBinding(Key key) {
       return bindingsByKey.get(key);
     }
 
-    /** Caches the binding and pretends a binding is generated without actually generating it. */
-    B pretendBindingGenerated(B binding, ClassName factoryName) {
-      tryToCacheBinding(binding);
-      if (shouldGenerateBinding(binding, factoryName)) {
-        materializedBindings.add(binding);
-      }
-      return binding;
-    }
-
     /** Caches the binding and generates it if it needs generation. */
     void tryRegisterBinding(B binding, ClassName factoryName, boolean explicit) {
       tryToCacheBinding(binding);
@@ -116,7 +111,7 @@ void tryToGenerateBinding(B binding, ClassName factoryName, boolean explicit) {
     private boolean shouldGenerateBinding(B binding, ClassName factoryName) {
       return !binding.hasNonDefaultTypeParameters()
           && elements.getTypeElement(factoryName.canonicalName()) == null
-          && !materializedBindings.contains(binding)
+          && !materializedBindingKeys.contains(binding.key())
           && !bindingsRequiringGeneration.contains(binding);
 
     }
@@ -176,7 +171,7 @@ MembersInjectionBinding registerBinding(MembersInjectionBinding binding) {
    * attempt to register an unresolved version of it.
    */
   private ProvisionBinding registerBinding(ProvisionBinding binding, boolean explicit) {
-    ClassName factoryName = SourceFiles.factoryNameForProvisionBinding(binding);
+    ClassName factoryName = generatedClassNameForBinding(binding);
     provisionBindings.tryRegisterBinding(binding, factoryName, explicit);
     if (binding.hasNonDefaultTypeParameters()) {
       provisionBindings.tryToGenerateBinding(provisionBindingFactory.unresolve(binding),
@@ -191,22 +186,11 @@ private ProvisionBinding registerBinding(ProvisionBinding binding, boolean expli
    */
   private MembersInjectionBinding registerBinding(
       MembersInjectionBinding binding, boolean explicit) {
-    ClassName membersInjectorName =
-        SourceFiles.membersInjectorNameForMembersInjectionBinding(binding);
-    if (binding.injectionSites().isEmpty()) {
-      // empty members injection bindings are special and don't need source files.
-      // so, we just pretend
-      membersInjectionBindings.pretendBindingGenerated(binding, membersInjectorName);
-      if (binding.hasNonDefaultTypeParameters()) {
-        membersInjectionBindings.pretendBindingGenerated(
-            membersInjectionBindingFactory.unresolve(binding), membersInjectorName);
-      }
-    } else {
-      membersInjectionBindings.tryRegisterBinding(binding, membersInjectorName, explicit);
-      if (binding.hasNonDefaultTypeParameters()) {
-        membersInjectionBindings.tryToGenerateBinding(
-            membersInjectionBindingFactory.unresolve(binding), membersInjectorName, explicit);
-      }
+    ClassName membersInjectorName = generatedClassNameForBinding(binding);
+    membersInjectionBindings.tryRegisterBinding(binding, membersInjectorName, explicit);
+    if (binding.hasNonDefaultTypeParameters()) {
+      membersInjectionBindings.tryToGenerateBinding(
+          membersInjectionBindingFactory.unresolve(binding), membersInjectorName, explicit);
     }
     return binding;
   }
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectConstructorValidator.java b/compiler/src/main/java/dagger/internal/codegen/InjectConstructorValidator.java
index ac4f914e3..11cd066fc 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectConstructorValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectConstructorValidator.java
@@ -44,29 +44,28 @@
 import static javax.lang.model.element.Modifier.STATIC;
 
 /**
- * A {@link Validator} for {@link Inject} constructors.
+ * A {@linkplain ValidationReport validator} for {@link Inject} constructors.
  *
  * @author Gregory Kick
  * @since 2.0
  */
-final class InjectConstructorValidator implements Validator<ExecutableElement> {
-  @Override
-  public ValidationReport<ExecutableElement> validate(ExecutableElement constructorElement) {
-    ValidationReport.Builder<ExecutableElement> builder =
-        ValidationReport.Builder.about(constructorElement);
+final class InjectConstructorValidator {
+  ValidationReport<TypeElement> validate(ExecutableElement constructorElement) {
+    ValidationReport.Builder<TypeElement> builder =
+        ValidationReport.about(MoreElements.asType(constructorElement.getEnclosingElement()));
     if (constructorElement.getModifiers().contains(PRIVATE)) {
-      builder.addItem(INJECT_ON_PRIVATE_CONSTRUCTOR, constructorElement);
+      builder.addError(INJECT_ON_PRIVATE_CONSTRUCTOR, constructorElement);
     }
 
     for (AnnotationMirror qualifier : getQualifiers(constructorElement)) {
-      builder.addItem(QUALIFIER_ON_INJECT_CONSTRUCTOR, constructorElement, qualifier);
+      builder.addError(QUALIFIER_ON_INJECT_CONSTRUCTOR, constructorElement, qualifier);
     }
 
     for (VariableElement parameter : constructorElement.getParameters()) {
       ImmutableSet<? extends AnnotationMirror> qualifiers = getQualifiers(parameter);
       if (qualifiers.size() > 1) {
         for (AnnotationMirror qualifier : qualifiers) {
-          builder.addItem(MULTIPLE_QUALIFIERS, constructorElement, qualifier);
+          builder.addError(MULTIPLE_QUALIFIERS, constructorElement, qualifier);
         }
       }
     }
@@ -76,16 +75,16 @@
     Set<Modifier> typeModifiers = enclosingElement.getModifiers();
 
     if (typeModifiers.contains(PRIVATE)) {
-      builder.addItem(INJECT_INTO_PRIVATE_CLASS, constructorElement);
+      builder.addError(INJECT_INTO_PRIVATE_CLASS, constructorElement);
     }
 
     if (typeModifiers.contains(ABSTRACT)) {
-      builder.addItem(INJECT_CONSTRUCTOR_ON_ABSTRACT_CLASS, constructorElement);
+      builder.addError(INJECT_CONSTRUCTOR_ON_ABSTRACT_CLASS, constructorElement);
     }
 
     if (enclosingElement.getNestingKind().isNested()
         && !typeModifiers.contains(STATIC)) {
-      builder.addItem(INJECT_CONSTRUCTOR_ON_INNER_CLASS, constructorElement);
+      builder.addError(INJECT_CONSTRUCTOR_ON_INNER_CLASS, constructorElement);
     }
 
     // This is computationally expensive, but probably preferable to a giant index
@@ -98,13 +97,13 @@
             });
 
     if (injectConstructors.size() > 1) {
-      builder.addItem(MULTIPLE_INJECT_CONSTRUCTORS, constructorElement);
+      builder.addError(MULTIPLE_INJECT_CONSTRUCTORS, constructorElement);
     }
 
     ImmutableSet<? extends AnnotationMirror> scopes = getScopes(enclosingElement);
     if (scopes.size() > 1) {
       for (AnnotationMirror scope : scopes) {
-        builder.addItem(MULTIPLE_SCOPES, enclosingElement, scope);
+        builder.addError(MULTIPLE_SCOPES, enclosingElement, scope);
       }
     }
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectFieldValidator.java b/compiler/src/main/java/dagger/internal/codegen/InjectFieldValidator.java
index 1841290ea..e30678af7 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectFieldValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectFieldValidator.java
@@ -21,38 +21,52 @@
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.VariableElement;
+import javax.tools.Diagnostic.Kind;
 
 import static dagger.internal.codegen.ErrorMessages.FINAL_INJECT_FIELD;
 import static dagger.internal.codegen.ErrorMessages.MULTIPLE_QUALIFIERS;
 import static dagger.internal.codegen.ErrorMessages.PRIVATE_INJECT_FIELD;
+import static dagger.internal.codegen.ErrorMessages.STATIC_INJECT_FIELD;
 import static dagger.internal.codegen.InjectionAnnotations.getQualifiers;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
+import static javax.lang.model.element.Modifier.STATIC;
 
 /**
- * A {@link Validator} for {@link Inject} fields.
+ * A {@linkplain ValidationReport validator} for {@link Inject} fields.
  *
  * @author Gregory Kick
  * @since 2.0
  */
-final class InjectFieldValidator implements Validator<VariableElement> {
-  @Override
-  public ValidationReport<VariableElement> validate(VariableElement fieldElement) {
-    ValidationReport.Builder<VariableElement> builder =
-        ValidationReport.Builder.about(fieldElement);
+final class InjectFieldValidator {
+  private Kind privateMemberValidationKind;
+  private Kind staticMemberValidationKind;
+  
+  public InjectFieldValidator(
+      Kind privateMemberValidationKind, Kind staticMemberValidationKind) {
+    this.privateMemberValidationKind = privateMemberValidationKind;
+    this.staticMemberValidationKind = staticMemberValidationKind;
+  }
+
+  ValidationReport<VariableElement> validate(VariableElement fieldElement) {
+    ValidationReport.Builder<VariableElement> builder = ValidationReport.about(fieldElement);
     Set<Modifier> modifiers = fieldElement.getModifiers();
     if (modifiers.contains(FINAL)) {
-      builder.addItem(FINAL_INJECT_FIELD, fieldElement);
+      builder.addError(FINAL_INJECT_FIELD, fieldElement);
     }
 
     if (modifiers.contains(PRIVATE)) {
-      builder.addItem(PRIVATE_INJECT_FIELD, fieldElement);
+      builder.addItem(PRIVATE_INJECT_FIELD, privateMemberValidationKind, fieldElement);
     }
 
+    if (modifiers.contains(STATIC)) {
+      builder.addItem(STATIC_INJECT_FIELD, staticMemberValidationKind, fieldElement);
+    }
+    
     ImmutableSet<? extends AnnotationMirror> qualifiers = getQualifiers(fieldElement);
     if (qualifiers.size() > 1) {
       for (AnnotationMirror qualifier : qualifiers) {
-        builder.addItem(MULTIPLE_QUALIFIERS, fieldElement, qualifier);
+        builder.addError(MULTIPLE_QUALIFIERS, fieldElement, qualifier);
       }
     }
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/InjectMethodValidator.java
index 9454f230e..a716b7d81 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectMethodValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectMethodValidator.java
@@ -22,44 +22,58 @@
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.VariableElement;
+import javax.tools.Diagnostic.Kind;
 
 import static dagger.internal.codegen.ErrorMessages.ABSTRACT_INJECT_METHOD;
 import static dagger.internal.codegen.ErrorMessages.GENERIC_INJECT_METHOD;
 import static dagger.internal.codegen.ErrorMessages.MULTIPLE_QUALIFIERS;
 import static dagger.internal.codegen.ErrorMessages.PRIVATE_INJECT_METHOD;
+import static dagger.internal.codegen.ErrorMessages.STATIC_INJECT_METHOD;
 import static dagger.internal.codegen.InjectionAnnotations.getQualifiers;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.element.Modifier.PRIVATE;
+import static javax.lang.model.element.Modifier.STATIC;
 
 /**
- * A {@link Validator} for {@link Inject} methods.
+ * A {@linkplain ValidationReport validator} for {@link Inject} methods.
  *
  * @author Gregory Kick
  * @since 2.0
  */
-final class InjectMethodValidator implements Validator<ExecutableElement> {
-  @Override
-  public ValidationReport<ExecutableElement> validate(ExecutableElement methodElement) {
-    ValidationReport.Builder<ExecutableElement> builder =
-        ValidationReport.Builder.about(methodElement);
+final class InjectMethodValidator {
+  private Kind privateMemberValidationKind;
+  private Kind staticMemberValidationKind;
+  
+  public InjectMethodValidator(
+      Kind privateMemberValidationKind, Kind staticMemberValidationKind) {
+    this.privateMemberValidationKind = privateMemberValidationKind;
+    this.staticMemberValidationKind = staticMemberValidationKind;
+  }
+
+  ValidationReport<ExecutableElement> validate(ExecutableElement methodElement) {
+    ValidationReport.Builder<ExecutableElement> builder = ValidationReport.about(methodElement);
     Set<Modifier> modifiers = methodElement.getModifiers();
     if (modifiers.contains(ABSTRACT)) {
-      builder.addItem(ABSTRACT_INJECT_METHOD, methodElement);
+      builder.addError(ABSTRACT_INJECT_METHOD, methodElement);
     }
 
     if (modifiers.contains(PRIVATE)) {
-      builder.addItem(PRIVATE_INJECT_METHOD, methodElement);
+      builder.addItem(PRIVATE_INJECT_METHOD, privateMemberValidationKind, methodElement);
+    }
+    
+    if (modifiers.contains(STATIC)) {
+      builder.addItem(STATIC_INJECT_METHOD, staticMemberValidationKind, methodElement);
     }
 
     if (!methodElement.getTypeParameters().isEmpty()) {
-      builder.addItem(GENERIC_INJECT_METHOD, methodElement);
+      builder.addError(GENERIC_INJECT_METHOD, methodElement);
     }
 
     for (VariableElement parameter : methodElement.getParameters()) {
       ImmutableSet<? extends AnnotationMirror> qualifiers = getQualifiers(parameter);
       if (qualifiers.size() > 1) {
         for (AnnotationMirror qualifier : qualifiers) {
-          builder.addItem(MULTIPLE_QUALIFIERS, methodElement, qualifier);
+          builder.addError(MULTIPLE_QUALIFIERS, methodElement, qualifier);
         }
       }
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/InjectProcessingStep.java
index 708763b8c..dac904fdc 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectProcessingStep.java
@@ -20,12 +20,15 @@
 import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.SetMultimap;
+
 import java.lang.annotation.Annotation;
 import java.util.Set;
+
 import javax.annotation.processing.Messager;
 import javax.inject.Inject;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeMirror;
@@ -47,7 +50,8 @@
   private final MembersInjectionBinding.Factory membersInjectionBindingFactory;
   private final InjectBindingRegistry injectBindingRegistry;
 
-  InjectProcessingStep(Messager messager,
+  InjectProcessingStep(
+      Messager messager,
       InjectConstructorValidator constructorValidator,
       InjectFieldValidator fieldValidator,
       InjectMethodValidator methodValidator,
@@ -71,59 +75,71 @@
   @Override
   public Set<Element> process(
       SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
+    ImmutableSet.Builder<Element> rejectedElements = ImmutableSet.builder();
     // TODO(gak): add some error handling for bad source files
     final ImmutableSet.Builder<ProvisionBinding> provisions = ImmutableSet.builder();
     // TODO(gak): instead, we should collect reports by type and check later
     final ImmutableSet.Builder<DeclaredType> membersInjectedTypes = ImmutableSet.builder();
 
     for (Element injectElement : elementsByAnnotation.get(Inject.class)) {
-      injectElement.accept(
-          new ElementKindVisitor6<Void, Void>() {
-            @Override
-            public Void visitExecutableAsConstructor(
-                ExecutableElement constructorElement, Void v) {
-              ValidationReport<ExecutableElement> report =
-                  constructorValidator.validate(constructorElement);
-
-              report.printMessagesTo(messager);
-
-              if (report.isClean()) {
-                provisions.add(provisionBindingFactory.forInjectConstructor(constructorElement,
-                    Optional.<TypeMirror>absent()));
+      try {
+        injectElement.accept(
+            new ElementKindVisitor6<Void, Void>() {
+              @Override
+              public Void visitExecutableAsConstructor(
+                  ExecutableElement constructorElement, Void v) {
+                ValidationReport<TypeElement> report =
+                    constructorValidator.validate(constructorElement);
+
+                report.printMessagesTo(messager);
+
+                if (report.isClean()) {
+                  provisions.add(
+                      provisionBindingFactory.forInjectConstructor(
+                          constructorElement, Optional.<TypeMirror>absent()));
+                  DeclaredType type =
+                      MoreTypes.asDeclared(constructorElement.getEnclosingElement().asType());
+                  if (membersInjectionBindingFactory.hasInjectedMembers(type)) {
+                    membersInjectedTypes.add(type);
+                  }
+                }
+
+                return null;
               }
 
-              return null;
-            }
+              @Override
+              public Void visitVariableAsField(VariableElement fieldElement, Void p) {
+                ValidationReport<VariableElement> report = fieldValidator.validate(fieldElement);
 
-            @Override
-            public Void visitVariableAsField(VariableElement fieldElement, Void p) {
-              ValidationReport<VariableElement> report = fieldValidator.validate(fieldElement);
+                report.printMessagesTo(messager);
 
-              report.printMessagesTo(messager);
+                if (report.isClean()) {
+                  membersInjectedTypes.add(
+                      MoreTypes.asDeclared(fieldElement.getEnclosingElement().asType()));
+                }
 
-              if (report.isClean()) {
-                membersInjectedTypes.add(
-                    MoreTypes.asDeclared(fieldElement.getEnclosingElement().asType()));
+                return null;
               }
 
-              return null;
-            }
+              @Override
+              public Void visitExecutableAsMethod(ExecutableElement methodElement, Void p) {
+                ValidationReport<ExecutableElement> report =
+                    methodValidator.validate(methodElement);
 
-            @Override
-            public Void visitExecutableAsMethod(ExecutableElement methodElement, Void p) {
-              ValidationReport<ExecutableElement> report =
-                  methodValidator.validate(methodElement);
+                report.printMessagesTo(messager);
 
-              report.printMessagesTo(messager);
+                if (report.isClean()) {
+                  membersInjectedTypes.add(
+                      MoreTypes.asDeclared(methodElement.getEnclosingElement().asType()));
+                }
 
-              if (report.isClean()) {
-                membersInjectedTypes.add(
-                    MoreTypes.asDeclared(methodElement.getEnclosingElement().asType()));
+                return null;
               }
-
-              return null;
-            }
-          }, null);
+            },
+            null);
+      } catch (TypeNotPresentException e) {
+        rejectedElements.add(injectElement);
+      }
     }
 
     for (DeclaredType injectedType : membersInjectedTypes.build()) {
@@ -134,6 +150,6 @@ public Void visitExecutableAsMethod(ExecutableElement methodElement, Void p) {
     for (ProvisionBinding binding : provisions.build()) {
       injectBindingRegistry.registerBinding(binding);
     }
-    return ImmutableSet.of();
+    return rejectedElements.build();
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/Key.java b/compiler/src/main/java/dagger/internal/codegen/Key.java
index cd7579659..f0bd3a04f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Key.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Key.java
@@ -24,8 +24,8 @@
 import com.google.common.base.Optional;
 import com.google.common.collect.Iterables;
 import com.google.common.util.concurrent.ListenableFuture;
-import dagger.MapKey;
 import dagger.Provides;
+import dagger.producers.Produced;
 import dagger.producers.Producer;
 import dagger.producers.Produces;
 import java.util.Map;
@@ -46,6 +46,7 @@
 import javax.lang.model.util.SimpleTypeVisitor6;
 import javax.lang.model.util.Types;
 
+import static com.google.auto.common.MoreTypes.asExecutable;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static dagger.internal.codegen.InjectionAnnotations.getQualifier;
@@ -201,6 +202,16 @@ Key forProductionComponentMethod(ExecutableElement componentMethod) {
       return forMethod(componentMethod, keyType);
     }
 
+    Key forSubcomponentBuilderMethod(
+        ExecutableElement subcomponentBuilderMethod, DeclaredType declaredContainer) {
+      checkNotNull(subcomponentBuilderMethod);
+      checkArgument(subcomponentBuilderMethod.getKind().equals(METHOD));
+      ExecutableType resolvedMethod =
+          asExecutable(types.asMemberOf(declaredContainer, subcomponentBuilderMethod));
+      TypeMirror returnType = normalize(types, resolvedMethod.getReturnType());
+      return forMethod(subcomponentBuilderMethod, returnType);
+    }
+
     Key forProvidesMethod(ExecutableType executableType, ExecutableElement method) {
       checkNotNull(method);
       checkArgument(method.getKind().equals(METHOD));
@@ -273,8 +284,7 @@ private TypeMirror mapOfFactoryType(
 
     private TypeMirror mapKeyType(ExecutableElement method) {
       AnnotationMirror mapKeyAnnotation = getMapKey(method).get();
-      MapKey mapKey = mapKeyAnnotation.getAnnotationType().asElement().getAnnotation(MapKey.class);
-      return mapKey.unwrapValue()
+      return MapKeys.unwrapValue(mapKeyAnnotation).isPresent()
           ? getUnwrappedMapKeyType(mapKeyAnnotation.getAnnotationType(), types)
           : mapKeyAnnotation.getAnnotationType();
     }
@@ -336,7 +346,7 @@ Key forQualifiedType(Optional<AnnotationMirror> qualifier, TypeMirror type) {
         DeclaredType declaredMapType = MoreTypes.asDeclared(possibleMapKey.type());
         TypeMirror mapValueType = Util.getValueTypeOfMap(declaredMapType);
         if (!MoreTypes.isTypeOf(wrappingClass, mapValueType)) {
-          DeclaredType keyType = Util.getKeyTypeOfMap(declaredMapType);
+          TypeMirror keyType = Util.getKeyTypeOfMap(declaredMapType);
           TypeElement wrappingElement = getClassElement(wrappingClass);
           if (wrappingElement == null) {
             // This target might not be compiled with Producers, so wrappingClass might not have an
@@ -352,5 +362,22 @@ Key forQualifiedType(Optional<AnnotationMirror> qualifier, TypeMirror type) {
       }
       return Optional.absent();
     }
+
+    /**
+     * Optionally extract a {@link Key} for a {@code Set<T>} if the given key is for
+     * {@code Set<Produced<T>>}.
+     */
+    Optional<Key> implicitSetKeyFromProduced(Key possibleSetOfProducedKey) {
+      if (MoreTypes.isTypeOf(Set.class, possibleSetOfProducedKey.type())) {
+        TypeMirror argType =
+            MoreTypes.asDeclared(possibleSetOfProducedKey.type()).getTypeArguments().get(0);
+        if (MoreTypes.isTypeOf(Produced.class, argType)) {
+          TypeMirror producedArgType = MoreTypes.asDeclared(argType).getTypeArguments().get(0);
+          TypeMirror setType = types.getDeclaredType(getSetElement(), producedArgType);
+          return Optional.of(possibleSetOfProducedKey.withType(types, setType));
+        }
+      }
+      return Optional.absent();
+    }
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/KeyFormatter.java b/compiler/src/main/java/dagger/internal/codegen/KeyFormatter.java
index d2e62fcab..6e695f33a 100644
--- a/compiler/src/main/java/dagger/internal/codegen/KeyFormatter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/KeyFormatter.java
@@ -26,7 +26,7 @@
   @Override public String format(Key request) {
     StringBuilder builder = new StringBuilder();
     if (request.qualifier().isPresent()) {
-      builder.append(request.qualifier()); // TODO(cgruber): Use AnnotationMirrorFormatter.
+      builder.append(request.qualifier().get());
       builder.append(' ');
     }
     builder.append(request.type()); // TODO(cgruber): Use TypeMirrorFormatter.
diff --git a/compiler/src/main/java/dagger/internal/codegen/KeyVariableNamer.java b/compiler/src/main/java/dagger/internal/codegen/KeyVariableNamer.java
index c32d50806..5fe12b102 100644
--- a/compiler/src/main/java/dagger/internal/codegen/KeyVariableNamer.java
+++ b/compiler/src/main/java/dagger/internal/codegen/KeyVariableNamer.java
@@ -39,10 +39,7 @@ public String apply(Key key) {
     StringBuilder builder = new StringBuilder();
 
     if (key.qualifier().isPresent()) {
-      if (!key.qualifier().get().getElementValues().isEmpty()) {
-        // TODO(gak): obviously we need to support this
-        throw new UnsupportedOperationException();
-      }
+      // TODO(gak): Use a better name for fields with qualifiers with members.
       builder.append(key.qualifier().get().getAnnotationType().asElement().getSimpleName());
     }
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/MapKeyValidator.java b/compiler/src/main/java/dagger/internal/codegen/MapKeyValidator.java
index 01b0951a6..586a1e935 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MapKeyValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MapKeyValidator.java
@@ -28,24 +28,23 @@
 import static javax.lang.model.util.ElementFilter.methodsIn;
 
 /**
- * A {@link Validator} for {@link MapKey} annotations.
+ * A validator for {@link MapKey} annotations.
  *
  * @author Chenying Hou
  * @since 2.0
  */
 // TODO(dpb,gak): Should unwrapped MapKeys be required to have their single member be named "value"?
-final class MapKeyValidator implements Validator<Element> {
-  @Override
-  public ValidationReport<Element> validate(Element element) {
-    ValidationReport.Builder<Element> builder = ValidationReport.Builder.about(element);
+final class MapKeyValidator {
+  ValidationReport<Element> validate(Element element) {
+    ValidationReport.Builder<Element> builder = ValidationReport.about(element);
     List<ExecutableElement> members = methodsIn(((TypeElement) element).getEnclosedElements());
     if (members.isEmpty()) {
-      builder.addItem(MAPKEY_WITHOUT_MEMBERS, element);
+      builder.addError(MAPKEY_WITHOUT_MEMBERS, element);
     } else if (element.getAnnotation(MapKey.class).unwrapValue()) {
       if (members.size() > 1) {
-        builder.addItem(UNWRAPPED_MAP_KEY_WITH_TOO_MANY_MEMBERS, element);
+        builder.addError(UNWRAPPED_MAP_KEY_WITH_TOO_MANY_MEMBERS, element);
       } else if (members.get(0).getReturnType().getKind() == TypeKind.ARRAY) {
-        builder.addItem(UNWRAPPED_MAP_KEY_WITH_ARRAY_MEMBER, element);
+        builder.addError(UNWRAPPED_MAP_KEY_WITH_ARRAY_MEMBER, element);
       }
     }
     return builder.build();
diff --git a/compiler/src/main/java/dagger/internal/codegen/MapKeys.java b/compiler/src/main/java/dagger/internal/codegen/MapKeys.java
index f378bbb26..fbbd8cf82 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MapKeys.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MapKeys.java
@@ -76,6 +76,22 @@
     return getAnnotatedAnnotations(bindingElement, MapKey.class);
   }
 
+  /**
+   * Returns the annotation value if {@code mapKey}'s type is annotated with
+   * {@link MapKey @MapKey(unwrapValue = true)}.
+   *
+   * @throws IllegalArgumentException if {@code mapKey}'s type is not annotated with
+   *     {@link MapKey @MapKey} at all.
+   */
+  static Optional<? extends AnnotationValue> unwrapValue(AnnotationMirror mapKey) {
+    MapKey mapKeyAnnotation = mapKey.getAnnotationType().asElement().getAnnotation(MapKey.class);
+    checkArgument(
+        mapKeyAnnotation != null, "%s is not annotated with @MapKey", mapKey.getAnnotationType());
+    return mapKeyAnnotation.unwrapValue()
+        ? Optional.of(getOnlyElement(mapKey.getElementValues().values()))
+        : Optional.<AnnotationValue>absent();
+  }
+
   /**
    * Returns the map key type for an unwrapped {@link MapKey} annotation type. If the single member
    * type is primitive, returns the boxed type.
@@ -121,10 +137,8 @@ public DeclaredType visitDeclared(DeclaredType t, Void p) {
    * {@link MapKey} annotation type.
    */
   public static ClassName getMapKeyCreatorClassName(TypeElement mapKeyType) {
-    ClassName enclosingClassName = ClassName.fromTypeElement(mapKeyType);
-    return enclosingClassName
-        .topLevelClassName()
-        .peerNamed(enclosingClassName.classFileName() + "Creator");
+    ClassName mapKeyTypeName = ClassName.fromTypeElement(mapKeyType);
+    return mapKeyTypeName.topLevelClassName().peerNamed(mapKeyTypeName.classFileName() + "Creator");
   }
 
   /**
@@ -138,11 +152,12 @@ public static ClassName getMapKeyCreatorClassName(TypeElement mapKeyType) {
    */
   static Snippet getMapKeySnippet(Element bindingElement) {
     AnnotationMirror mapKey = getMapKey(bindingElement).get();
-    TypeElement mapKeyAnnotationType = MoreTypes.asTypeElement(mapKey.getAnnotationType());
-    ClassName mapKeyCreator = MapKeys.getMapKeyCreatorClassName(mapKeyAnnotationType);
-    if (mapKeyAnnotationType.getAnnotation(MapKey.class).unwrapValue()) {
-      AnnotationValue memberToUnwrap = getOnlyElement(mapKey.getElementValues().values());
-      return new MapKeySnippetExceptArrays(mapKeyCreator).visit(memberToUnwrap, memberToUnwrap);
+    ClassName mapKeyCreator =
+        getMapKeyCreatorClassName(MoreTypes.asTypeElement(mapKey.getAnnotationType()));
+    Optional<? extends AnnotationValue> unwrappedValue = unwrapValue(mapKey);
+    if (unwrappedValue.isPresent()) {
+      return new MapKeySnippetExceptArrays(mapKeyCreator)
+          .visit(unwrappedValue.get(), unwrappedValue.get());
     } else {
       return annotationSnippet(mapKey, new MapKeySnippet(mapKeyCreator));
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
index 4f48d8d59..7fbcf115d 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
@@ -24,11 +24,17 @@
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ImmutableSortedSet;
-import com.google.common.collect.Ordering;
+import com.google.common.collect.LinkedHashMultimap;
+import com.google.common.collect.SetMultimap;
+import java.util.ArrayList;
+import java.util.Comparator;
+import java.util.HashSet;
+import java.util.List;
 import java.util.Set;
 import javax.inject.Inject;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ElementKind;
+import javax.lang.model.element.ElementVisitor;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
@@ -43,6 +49,8 @@
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
+import static javax.lang.model.element.Modifier.PRIVATE;
+import static javax.lang.model.element.Modifier.STATIC;
 
 /**
  * Represents the full members injection of a particular type. This does not pay attention to
@@ -54,7 +62,7 @@
 @AutoValue
 abstract class MembersInjectionBinding extends Binding {
   @Override abstract TypeElement bindingElement();
-
+        
   /** The set of individual sites where {@link Inject} is applied. */
   abstract ImmutableSortedSet<InjectionSite> injectionSites();
 
@@ -62,18 +70,11 @@
 
   enum Strategy {
     NO_OP,
-    DELEGATE,
     INJECT_MEMBERS,
   }
 
   Strategy injectionStrategy() {
-    if (injectionSites().isEmpty()) {
-      return parentInjectorRequest().isPresent()
-          ? Strategy.DELEGATE
-          : Strategy.NO_OP;
-    } else {
-      return Strategy.INJECT_MEMBERS;
-    }
+    return injectionSites().isEmpty() ? Strategy.NO_OP : Strategy.INJECT_MEMBERS;
   }
 
   MembersInjectionBinding withoutParentInjectorRequest() {
@@ -88,26 +89,10 @@ MembersInjectionBinding withoutParentInjectorRequest() {
           Optional.<DependencyRequest>absent());
   }
 
-  private static final Ordering<InjectionSite> INJECTION_ORDERING =
-      new Ordering<InjectionSite>() {
-        @Override
-        public int compare(InjectionSite left, InjectionSite right) {
-          checkArgument(left.element().getEnclosingElement()
-              .equals(right.element().getEnclosingElement()));
-          return ComparisonChain.start()
-              // fields before methods
-              .compare(left.element().getKind(), right.element().getKind())
-              // then sort by whichever element comes first in the parent
-              // this isn't necessary, but makes the processor nice and predictable
-              .compare(targetIndexInEnclosing(left), targetIndexInEnclosing(right))
-              .result();
-        }
-
-        private int targetIndexInEnclosing(InjectionSite injectionSite)  {
-          return injectionSite.element().getEnclosingElement().getEnclosedElements()
-              .indexOf(injectionSite.element());
-        }
-      };
+  @Override
+  protected Binding.Type bindingType() {
+    return Binding.Type.MEMBERS_INJECTION;
+  }
 
   @AutoValue
   abstract static class InjectionSite {
@@ -121,6 +106,14 @@ private int targetIndexInEnclosing(InjectionSite injectionSite)  {
     abstract Element element();
 
     abstract ImmutableSet<DependencyRequest> dependencies();
+    
+    protected int indexAmongSiblingMembers(InjectionSite injectionSite) {
+      return injectionSite
+          .element()
+          .getEnclosingElement()
+          .getEnclosedElements()
+          .indexOf(injectionSite.element());
+    }
   }
 
   static final class Factory {
@@ -137,31 +130,31 @@ private int targetIndexInEnclosing(InjectionSite injectionSite)  {
       this.dependencyRequestFactory = checkNotNull(dependencyRequestFactory);
     }
 
-    private InjectionSite injectionSiteForInjectMethod(ExecutableElement methodElement,
-        DeclaredType containingType) {
+    private InjectionSite injectionSiteForInjectMethod(
+        ExecutableElement methodElement, DeclaredType containingType) {
       checkNotNull(methodElement);
       checkArgument(methodElement.getKind().equals(ElementKind.METHOD));
-      checkArgument(isAnnotationPresent(methodElement, Inject.class));
       ExecutableType resolved =
           MoreTypes.asExecutable(types.asMemberOf(containingType, methodElement));
-      return new AutoValue_MembersInjectionBinding_InjectionSite(InjectionSite.Kind.METHOD,
+      return new AutoValue_MembersInjectionBinding_InjectionSite(
+          InjectionSite.Kind.METHOD,
           methodElement,
           dependencyRequestFactory.forRequiredResolvedVariables(
-              containingType,
-              methodElement.getParameters(),
-              resolved.getParameterTypes()));
+              containingType, methodElement.getParameters(), resolved.getParameterTypes()));
     }
 
-    private InjectionSite injectionSiteForInjectField(VariableElement fieldElement,
-        DeclaredType containingType) {
+    private InjectionSite injectionSiteForInjectField(
+        VariableElement fieldElement, DeclaredType containingType) {
       checkNotNull(fieldElement);
       checkArgument(fieldElement.getKind().equals(ElementKind.FIELD));
       checkArgument(isAnnotationPresent(fieldElement, Inject.class));
       TypeMirror resolved = types.asMemberOf(containingType, fieldElement);
-      return new AutoValue_MembersInjectionBinding_InjectionSite(InjectionSite.Kind.FIELD,
+      return new AutoValue_MembersInjectionBinding_InjectionSite(
+          InjectionSite.Kind.FIELD,
           fieldElement,
-          ImmutableSet.of(dependencyRequestFactory.forRequiredResolvedVariable(
-              containingType, fieldElement, resolved)));
+          ImmutableSet.of(
+              dependencyRequestFactory.forRequiredResolvedVariable(
+                  containingType, fieldElement, resolved)));
     }
 
     /** Returns an unresolved version of this binding. */
@@ -171,77 +164,156 @@ MembersInjectionBinding unresolve(MembersInjectionBinding binding) {
       return forInjectedType(unresolved, Optional.<TypeMirror>absent());
     }
 
+    /** Returns true if the type has some injected members in itself or any of its super classes. */
+    boolean hasInjectedMembers(DeclaredType declaredType) {
+      return !getInjectionSites(declaredType).isEmpty();
+    }
+
     /**
      * Returns a MembersInjectionBinding for the given type. If {@code resolvedType} is present,
      * this will return a resolved binding, with the key & type resolved to the given type (using
      * {@link Types#asMemberOf(DeclaredType, Element)}).
      */
-    MembersInjectionBinding forInjectedType(DeclaredType type, Optional<TypeMirror> resolvedType) {
+    MembersInjectionBinding forInjectedType(
+        DeclaredType declaredType, Optional<TypeMirror> resolvedType) {
       // If the class this is injecting has some type arguments, resolve everything.
-      if (!type.getTypeArguments().isEmpty() && resolvedType.isPresent()) {
+      if (!declaredType.getTypeArguments().isEmpty() && resolvedType.isPresent()) {
         DeclaredType resolved = MoreTypes.asDeclared(resolvedType.get());
         // Validate that we're resolving from the correct type.
-        checkState(types.isSameType(types.erasure(resolved), types.erasure(type)),
+        checkState(
+            types.isSameType(types.erasure(resolved), types.erasure(declaredType)),
             "erased expected type: %s, erased actual type: %s",
-            types.erasure(resolved), types.erasure(type));
-        type = resolved;
-      }
-
-      TypeElement typeElement = MoreElements.asType(type.asElement());
-      final DeclaredType resolved = type;
-      ImmutableSortedSet.Builder<InjectionSite> injectionSitesBuilder =
-          ImmutableSortedSet.orderedBy(INJECTION_ORDERING);
-      for (Element enclosedElement : typeElement.getEnclosedElements()) {
-        injectionSitesBuilder.addAll(enclosedElement.accept(
-            new ElementKindVisitor6<Optional<InjectionSite>, Void>(
-                Optional.<InjectionSite>absent()) {
-                  @Override
-                  public Optional<InjectionSite> visitExecutableAsMethod(ExecutableElement e,
-                      Void p) {
-                    return isAnnotationPresent(e, Inject.class)
-                        ? Optional.of(injectionSiteForInjectMethod(e, resolved))
-                        : Optional.<InjectionSite>absent();
-                  }
-
-                  @Override
-                  public Optional<InjectionSite> visitVariableAsField(VariableElement e, Void p) {
-                    return isAnnotationPresent(e, Inject.class)
-                        ? Optional.of(injectionSiteForInjectField(e, resolved))
-                        : Optional.<InjectionSite>absent();
-                  }
-                }, null).asSet());
+            types.erasure(resolved),
+            types.erasure(declaredType));
+        declaredType = resolved;
       }
-      ImmutableSortedSet<InjectionSite> injectionSites = injectionSitesBuilder.build();
-
-      ImmutableSet<DependencyRequest> dependencies = FluentIterable.from(injectionSites)
-          .transformAndConcat(new Function<InjectionSite, Set<DependencyRequest>>() {
-            @Override public Set<DependencyRequest> apply(InjectionSite input) {
-              return input.dependencies();
-            }
-          })
-          .toSet();
+      ImmutableSortedSet<InjectionSite> injectionSites = getInjectionSites(declaredType);
+      ImmutableSet<DependencyRequest> dependencies =
+          FluentIterable.from(injectionSites)
+              .transformAndConcat(
+                  new Function<InjectionSite, Set<DependencyRequest>>() {
+                    @Override
+                    public Set<DependencyRequest> apply(InjectionSite input) {
+                      return input.dependencies();
+                    }
+                  })
+              .toSet();
 
       Optional<DependencyRequest> parentInjectorRequest =
-          MoreTypes.nonObjectSuperclass(types, elements, type)
-              .transform(new Function<DeclaredType, DependencyRequest>() {
-                @Override public DependencyRequest apply(DeclaredType input) {
-                  return dependencyRequestFactory.forMembersInjectedType(input);
-                }
-              });
-
-      Key key = keyFactory.forMembersInjectedType(type);
+          MoreTypes.nonObjectSuperclass(types, elements, declaredType)
+              .transform(
+                  new Function<DeclaredType, DependencyRequest>() {
+                    @Override
+                    public DependencyRequest apply(DeclaredType input) {
+                      return dependencyRequestFactory.forMembersInjectedType(input);
+                    }
+                  });
+
+      Key key = keyFactory.forMembersInjectedType(declaredType);
+      TypeElement typeElement = MoreElements.asType(declaredType.asElement());
       return new AutoValue_MembersInjectionBinding(
           key,
           dependencies,
-          new ImmutableSet.Builder<DependencyRequest>()
-              .addAll(parentInjectorRequest.asSet())
-              .addAll(dependencies)
-              .build(),
+          dependencies,
           findBindingPackage(key),
           hasNonDefaultTypeParameters(typeElement, key.type(), types),
           typeElement,
           injectionSites,
           parentInjectorRequest);
     }
+
+    private ImmutableSortedSet<InjectionSite> getInjectionSites(DeclaredType declaredType) {
+      Set<InjectionSite> injectionSites = new HashSet<>();
+      final List<TypeElement> ancestors = new ArrayList<>();
+      SetMultimap<String, ExecutableElement> overriddenMethodMap = LinkedHashMultimap.create();
+      for (Optional<DeclaredType> currentType = Optional.of(declaredType);
+          currentType.isPresent();
+          currentType = MoreTypes.nonObjectSuperclass(types, elements, currentType.get())) {
+        final DeclaredType type = currentType.get();
+        ancestors.add(MoreElements.asType(type.asElement()));
+        for (Element enclosedElement : type.asElement().getEnclosedElements()) {
+          Optional<InjectionSite> maybeInjectionSite =
+              injectionSiteVisitor.visit(enclosedElement, type);
+          if (maybeInjectionSite.isPresent()) {
+            InjectionSite injectionSite = maybeInjectionSite.get();
+            if (shouldBeInjected(injectionSite.element(), overriddenMethodMap)) {
+              injectionSites.add(injectionSite);
+            }
+            if (injectionSite.kind() == InjectionSite.Kind.METHOD) {
+              ExecutableElement injectionSiteMethod =
+                  MoreElements.asExecutable(injectionSite.element());
+              overriddenMethodMap.put(
+                  injectionSiteMethod.getSimpleName().toString(), injectionSiteMethod);
+            }
+          }
+        }
+      }
+      return ImmutableSortedSet.copyOf(
+          new Comparator<InjectionSite>() {
+            @Override
+            public int compare(InjectionSite left, InjectionSite right) {
+              return ComparisonChain.start()
+                  // supertypes before subtypes
+                  .compare(
+                      ancestors.indexOf(right.element().getEnclosingElement()),
+                      ancestors.indexOf(left.element().getEnclosingElement()))
+                  // fields before methods
+                  .compare(left.element().getKind(), right.element().getKind())
+                  // then sort by whichever element comes first in the parent
+                  // this isn't necessary, but makes the processor nice and predictable
+                  .compare(
+                      left.indexAmongSiblingMembers(left), right.indexAmongSiblingMembers(right))
+                  .result();
+            }
+          },
+          injectionSites);
+    }
+
+    private boolean shouldBeInjected(
+        Element injectionSite, SetMultimap<String, ExecutableElement> overriddenMethodMap) {
+      if (!isAnnotationPresent(injectionSite, Inject.class)
+          || injectionSite.getModifiers().contains(PRIVATE)
+          || injectionSite.getModifiers().contains(STATIC)) {
+        return false;
+      }
+
+      if (injectionSite.getKind().isField()) { // Inject all fields (self and ancestors)
+        return true;
+      }
+
+      // For each method with the same name belonging to any descendant class, return false if any
+      // method has already overridden the injectionSite method. To decrease the number of methods
+      // that are checked, we store the already injected methods in a SetMultimap and only
+      // check the methods with the same name.
+      ExecutableElement injectionSiteMethod = MoreElements.asExecutable(injectionSite);
+      TypeElement injectionSiteType = MoreElements.asType(injectionSite.getEnclosingElement());
+      for (ExecutableElement method :
+          overriddenMethodMap.get(injectionSiteMethod.getSimpleName().toString())) {
+        if (elements.overrides(method, injectionSiteMethod, injectionSiteType)) {
+          return false;
+        }
+      }
+      return true;
+    }
+
+    private final ElementVisitor<Optional<InjectionSite>, DeclaredType> injectionSiteVisitor =
+        new ElementKindVisitor6<Optional<InjectionSite>, DeclaredType>(
+            Optional.<InjectionSite>absent()) {
+          @Override
+          public Optional<InjectionSite> visitExecutableAsMethod(
+              ExecutableElement e, DeclaredType type) {
+            return Optional.of(injectionSiteForInjectMethod(e, type));
+          }
+
+          @Override
+          public Optional<InjectionSite> visitVariableAsField(
+              VariableElement e, DeclaredType type) {
+            return (isAnnotationPresent(e, Inject.class)
+                    && !e.getModifiers().contains(PRIVATE)
+                    && !e.getModifiers().contains(STATIC))
+                ? Optional.of(injectionSiteForInjectField(e, type))
+                : Optional.<InjectionSite>absent();
+          }
+        };
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
index c4d0db6cc..3694d2e81 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
@@ -15,7 +15,8 @@
  */
 package dagger.internal.codegen;
 
-import com.google.auto.common.MoreTypes;
+import com.google.auto.common.MoreElements;
+import com.google.common.base.CaseFormat;
 import com.google.common.base.Function;
 import com.google.common.base.Joiner;
 import com.google.common.base.Optional;
@@ -23,7 +24,6 @@
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.Iterables;
 import com.google.common.collect.Lists;
 import dagger.MembersInjector;
 import dagger.internal.codegen.MembersInjectionBinding.InjectionSite;
@@ -33,31 +33,41 @@
 import dagger.internal.codegen.writer.FieldWriter;
 import dagger.internal.codegen.writer.JavaWriter;
 import dagger.internal.codegen.writer.MethodWriter;
+import dagger.internal.codegen.writer.Modifiable;
 import dagger.internal.codegen.writer.ParameterizedTypeName;
 import dagger.internal.codegen.writer.Snippet;
 import dagger.internal.codegen.writer.TypeName;
 import dagger.internal.codegen.writer.TypeNames;
 import dagger.internal.codegen.writer.TypeVariableName;
+import dagger.internal.codegen.writer.VariableWriter;
 import dagger.internal.codegen.writer.VoidName;
+import dagger.producers.Producer;
+import java.util.HashSet;
 import java.util.List;
-import java.util.Map;
 import java.util.Map.Entry;
+import java.util.Set;
 import javax.annotation.Generated;
 import javax.annotation.processing.Filer;
+import javax.inject.Provider;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.TypeParameterElement;
+import javax.lang.model.type.ArrayType;
 import javax.lang.model.type.DeclaredType;
-import javax.lang.model.util.Elements;
-import javax.lang.model.util.Types;
+import javax.lang.model.type.TypeVisitor;
+import javax.lang.model.util.SimpleTypeVisitor7;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.auto.common.MoreElements.getPackage;
 import static com.google.common.base.Preconditions.checkState;
+import static com.google.common.collect.Iterables.getOnlyElement;
 import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
-import static dagger.internal.codegen.SourceFiles.parameterizedMembersInjectorNameForMembersInjectionBinding;
+import static dagger.internal.codegen.SourceFiles.membersInjectorNameForType;
+import static dagger.internal.codegen.SourceFiles.parameterizedGeneratedTypeNameForBinding;
+import static dagger.internal.codegen.writer.Snippet.makeParametersSnippet;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.PUBLIC;
+import static javax.lang.model.element.Modifier.STATIC;
 
 /**
  * Generates {@link MembersInjector} implementations from {@link MembersInjectionBinding} instances.
@@ -66,24 +76,18 @@
  * @since 2.0
  */
 final class MembersInjectorGenerator extends SourceFileGenerator<MembersInjectionBinding> {
-  private final Elements elements;
-  private final Types types;
   private final DependencyRequestMapper dependencyRequestMapper;
 
   MembersInjectorGenerator(
       Filer filer,
-      Elements elements,
-      Types types,
       DependencyRequestMapper dependencyRequestMapper) {
     super(filer);
-    this.elements = checkNotNull(elements);
-    this.types = checkNotNull(types);
     this.dependencyRequestMapper = dependencyRequestMapper;
   }
 
   @Override
   ClassName nameGeneratedType(MembersInjectionBinding binding) {
-    return SourceFiles.membersInjectorNameForMembersInjectionBinding(binding);
+    return membersInjectorNameForType(binding.bindingElement());
   }
 
   @Override
@@ -102,11 +106,17 @@ ClassName nameGeneratedType(MembersInjectionBinding binding) {
   Optional<? extends Element> getElementForErrorReporting(MembersInjectionBinding binding) {
     return Optional.of(binding.bindingElement());
   }
-
+  
   @Override
   ImmutableSet<JavaWriter> write(ClassName generatedTypeName, MembersInjectionBinding binding) {
+    // Empty members injection bindings are special and don't need source files.
+    if (binding.injectionSites().isEmpty()) {
+      return ImmutableSet.of();
+    }
+    Set<String> delegateMethods = new HashSet<>();
+
     // We don't want to write out resolved bindings -- we want to write out the generic version.
-    checkState(!binding.hasNonDefaultTypeParameters());
+    checkState(!binding.hasNonDefaultTypeParameters()); 
 
     TypeName injectedTypeName = TypeNames.forTypeMirror(binding.key().type());
     JavaWriter writer = JavaWriter.inPackage(generatedTypeName.packageName());
@@ -135,38 +145,12 @@ ClassName nameGeneratedType(MembersInjectionBinding binding) {
         "  throw new NullPointerException(\"Cannot inject members into a null reference\");",
         "}"));
 
-    Optional<DeclaredType> supertype =
-        MoreTypes.nonObjectSuperclass(types, elements, MoreTypes.asDeclared(binding.key().type()));
-    if (supertype.isPresent()) {
-      ParameterizedTypeName supertypeMemebersInjectorType = ParameterizedTypeName.create(
-          MembersInjector.class, TypeNames.forTypeMirror(supertype.get()));
-      injectorWriter
-          .addField(supertypeMemebersInjectorType, "supertypeInjector")
-          .addModifiers(PRIVATE, FINAL);
-      constructorWriter.addParameter(supertypeMemebersInjectorType, "supertypeInjector");
-      constructorWriter.body()
-          .addSnippet("assert supertypeInjector != null;")
-          .addSnippet("this.supertypeInjector = supertypeInjector;");
-      injectMembersWriter.body().addSnippet("supertypeInjector.injectMembers(instance);");
-    }
-
     ImmutableMap<BindingKey, FrameworkField> fields =
         SourceFiles.generateBindingFieldsForDependencies(
             dependencyRequestMapper, ImmutableSet.copyOf(binding.dependencies()));
 
     ImmutableMap.Builder<BindingKey, FieldWriter> dependencyFieldsBuilder =
         ImmutableMap.builder();
-
-    for (Entry<BindingKey, FrameworkField> fieldEntry : fields.entrySet()) {
-      FrameworkField bindingField = fieldEntry.getValue();
-      TypeName fieldType = bindingField.frameworkType();
-      FieldWriter field = injectorWriter.addField(fieldType, bindingField.name());
-      field.addModifiers(PRIVATE, FINAL);
-      constructorWriter.addParameter(field.type(), field.name());
-      constructorWriter.body().addSnippet("assert %s != null;", field.name());
-      constructorWriter.body().addSnippet("this.%1$s = %1$s;", field.name());
-      dependencyFieldsBuilder.put(fieldEntry.getKey(), field);
-    }
     
     // We use a static create method so that generated components can avoid having
     // to refer to the generic types of the factory.
@@ -174,43 +158,245 @@ ClassName nameGeneratedType(MembersInjectionBinding binding) {
     MethodWriter createMethodWriter = injectorWriter.addMethod(implementedType, "create");
     createMethodWriter.addTypeParameters(typeParameters);
     createMethodWriter.addModifiers(Modifier.PUBLIC, Modifier.STATIC);
-    Map<String, TypeName> params = constructorWriter.parameters();
-    for (Map.Entry<String, TypeName> param : params.entrySet()) {
-      createMethodWriter.addParameter(param.getValue(), param.getKey());      
+
+    boolean usesRawFrameworkTypes = false;
+    for (Entry<BindingKey, FrameworkField> fieldEntry : fields.entrySet()) {
+      BindingKey bindingKey = fieldEntry.getKey();
+      FrameworkField bindingField = fieldEntry.getValue();
+
+      // If the dependency type is not visible to this members injector, then use the raw framework
+      // type for the field.
+      boolean useRawFrameworkType =
+          !VISIBLE_TO_MEMBERS_INJECTOR.visit(bindingKey.key().type(), binding);
+
+      FieldWriter field =
+          injectorWriter.addField(
+              useRawFrameworkType
+                  ? bindingField.frameworkType().type()
+                  : bindingField.frameworkType(),
+              bindingField.name());
+
+      field.addModifiers(PRIVATE, FINAL);
+      VariableWriter constructorParameter =
+          constructorWriter.addParameter(field.type(), field.name());
+      VariableWriter createMethodParameter =
+          createMethodWriter.addParameter(constructorParameter.type(), constructorParameter.name());
+
+      // If we're using the raw type for the field, then suppress the injectMembers method's
+      // unchecked-type warning and the field's and the constructor and create-method's
+      // parameters' raw-type warnings.
+      if (useRawFrameworkType) {
+        usesRawFrameworkTypes = true;
+        suppressRawTypesWarning(field);
+        suppressRawTypesWarning(constructorParameter);
+        suppressRawTypesWarning(createMethodParameter);
+      }
+
+      constructorWriter.body().addSnippet("assert %s != null;", field.name());
+      constructorWriter.body().addSnippet("this.%1$s = %1$s;", field.name());
+      dependencyFieldsBuilder.put(bindingKey, field);
     }
-    createMethodWriter.body().addSnippet("  return new %s(%s);",
-        parameterizedMembersInjectorNameForMembersInjectionBinding(binding),
-        Joiner.on(", ").join(params.keySet()));
-    
-    ImmutableMap<BindingKey, FieldWriter> depedencyFields = dependencyFieldsBuilder.build();
+
+    createMethodWriter
+        .body()
+        .addSnippet(
+            "  return new %s(%s);",
+            parameterizedGeneratedTypeNameForBinding(binding),
+            Joiner.on(", ").join(constructorWriter.parameters().keySet()));
+
+    ImmutableMap<BindingKey, FieldWriter> dependencyFields = dependencyFieldsBuilder.build();
     for (InjectionSite injectionSite : binding.injectionSites()) {
-      switch (injectionSite.kind()) {
-        case FIELD:
-          DependencyRequest fieldDependency =
-              Iterables.getOnlyElement(injectionSite.dependencies());
-          FieldWriter singleField = depedencyFields.get(
-              fieldDependency.bindingKey());
-          injectMembersWriter.body().addSnippet("instance.%s = %s;",
-              injectionSite.element().getSimpleName(),
-              frameworkTypeUsageStatement(Snippet.format(singleField.name()),
-                  fieldDependency.kind()));
-          break;
-        case METHOD:
-          ImmutableList.Builder<Snippet> parameters = ImmutableList.builder();
-          for (DependencyRequest methodDependency : injectionSite.dependencies()) {
-            FieldWriter field = depedencyFields.get(
-                methodDependency.bindingKey());
-            parameters.add(frameworkTypeUsageStatement(Snippet.format(field.name()),
-                methodDependency.kind()));
-          }
-          injectMembersWriter.body().addSnippet("instance.%s(%s);",
-              injectionSite.element().getSimpleName(),
-              Snippet.makeParametersSnippet(parameters.build()));
-          break;
-        default:
-          throw new AssertionError();
+      injectMembersWriter
+          .body()
+          .addSnippet(
+              visibleToMembersInjector(binding, injectionSite.element())
+                  ? directInjectMemberSnippet(binding, dependencyFields, injectionSite)
+                  : delegateInjectMemberSnippet(dependencyFields, injectionSite));
+      if (!injectionSite.element().getModifiers().contains(PUBLIC)
+          && injectionSite.element().getEnclosingElement().equals(binding.bindingElement())
+          && delegateMethods.add(injectionSiteDelegateMethodName(injectionSite.element()))) {
+        writeInjectorMethodForSubclasses(
+            injectorWriter,
+            dependencyFields,
+            typeParameters,
+            injectedTypeName,
+            injectionSite.element(),
+            injectionSite.dependencies());
       }
     }
+    
+    if (usesRawFrameworkTypes) {
+      injectMembersWriter.annotate(SuppressWarnings.class).setValue("unchecked");
+    }
+
     return ImmutableSet.of(writer);
   }
+
+  /**
+   * Returns {@code true} if {@code element} is visible to the members injector for {@code binding}.
+   */
+  // TODO(dpb,gak): Make sure that all cases are covered here. E.g., what if element is public but
+  // enclosed in a package-private element?
+  private static boolean visibleToMembersInjector(
+      MembersInjectionBinding binding, Element element) {
+    return getPackage(element).equals(getPackage(binding.bindingElement()))
+        || element.getModifiers().contains(PUBLIC);
+  }
+
+  /**
+   * Returns a snippet that directly injects the instance's field or method.
+   */
+  private Snippet directInjectMemberSnippet(
+      MembersInjectionBinding binding,
+      ImmutableMap<BindingKey, FieldWriter> dependencyFields,
+      InjectionSite injectionSite) {
+    return Snippet.format(
+        injectionSite.element().getKind().isField() ? "%s.%s = %s;" : "%s.%s(%s);",
+        getInstanceSnippetWithPotentialCast(
+            injectionSite.element().getEnclosingElement(), binding.bindingElement()),
+        injectionSite.element().getSimpleName(),
+        makeParametersSnippet(
+            parameterSnippets(dependencyFields, injectionSite.dependencies(), true)));
+  }
+
+  /**
+   * Returns a snippet that injects the instance's field or method by calling a static method on the
+   * parent members injector class.
+   */
+  private Snippet delegateInjectMemberSnippet(
+      ImmutableMap<BindingKey, FieldWriter> dependencyFields, InjectionSite injectionSite) {
+    return Snippet.format(
+        "%s.%s(%s);",
+        membersInjectorNameForType(
+            MoreElements.asType(injectionSite.element().getEnclosingElement())),
+        injectionSiteDelegateMethodName(injectionSite.element()),
+        makeParametersSnippet(
+            new ImmutableList.Builder<Snippet>()
+                .add(Snippet.format("instance"))
+                .addAll(parameterSnippets(dependencyFields, injectionSite.dependencies(), false))
+                .build()));
+  }
+
+  /**
+   * Returns the parameters for injecting a member.
+   *
+   * @param passValue if {@code true}, each parameter snippet will be the result of converting the
+   *     field from the framework type ({@link Provider}, {@link Producer}, etc.) to the real value;
+   *     if {@code false}, each parameter snippet will be just the field
+   */
+  private ImmutableList<Snippet> parameterSnippets(
+      ImmutableMap<BindingKey, FieldWriter> dependencyFields,
+      ImmutableSet<DependencyRequest> dependencies,
+      boolean passValue) {
+    ImmutableList.Builder<Snippet> parameters = ImmutableList.builder();
+    for (DependencyRequest dependency : dependencies) {
+      Snippet fieldSnippet =
+          Snippet.format("%s", dependencyFields.get(dependency.bindingKey()).name());
+      parameters.add(
+          passValue ? frameworkTypeUsageStatement(fieldSnippet, dependency.kind()) : fieldSnippet);
+    }
+    return parameters.build();
+  }
+
+  private Snippet getInstanceSnippetWithPotentialCast(
+      Element injectionSiteElement, Element bindingElement) {
+    return (injectionSiteElement.equals(bindingElement))
+        ? Snippet.format("instance")
+        : Snippet.format("((%s)instance)", injectionSiteElement);
+  }
+
+  private String injectionSiteDelegateMethodName(Element injectionSiteElement) {
+    return "inject"
+        + CaseFormat.LOWER_CAMEL.to(
+            CaseFormat.UPPER_CAMEL, injectionSiteElement.getSimpleName().toString());
+  }
+
+  private void writeInjectorMethodForSubclasses(
+      ClassWriter injectorWriter,
+      ImmutableMap<BindingKey, FieldWriter> dependencyFields,
+      List<TypeVariableName> typeParameters,
+      TypeName injectedTypeName,
+      Element injectionElement,
+      ImmutableSet<DependencyRequest> dependencies) {
+    MethodWriter methodWriter =
+        injectorWriter.addMethod(VoidName.VOID, injectionSiteDelegateMethodName(injectionElement));
+    methodWriter.addModifiers(PUBLIC, STATIC);
+    methodWriter.addParameter(injectedTypeName, "instance");
+    methodWriter.addTypeParameters(typeParameters);
+    ImmutableList.Builder<Snippet> providedParameters = ImmutableList.builder();
+    Set<String> parameterNames = new HashSet<>();
+    for (DependencyRequest dependency : dependencies) {
+      FieldWriter field = dependencyFields.get(dependency.bindingKey());
+      VariableWriter parameter =
+          methodWriter.addParameter(
+              field.type(),
+              staticInjectMethodDependencyParameterName(parameterNames, dependency, field));
+      providedParameters.add(
+          frameworkTypeUsageStatement(Snippet.format("%s", parameter.name()), dependency.kind()));
+    }
+    if (injectionElement.getKind().isField()) {
+      methodWriter
+          .body()
+          .addSnippet(
+              "instance.%s = %s;",
+              injectionElement.getSimpleName(),
+              getOnlyElement(providedParameters.build()));
+    } else {
+      methodWriter
+          .body()
+          .addSnippet(
+              "instance.%s(%s);",
+              injectionElement.getSimpleName(),
+              makeParametersSnippet(providedParameters.build()));
+    }
+  }
+
+  /**
+   * Returns the static inject method parameter name for a dependency.
+   *
+   * @param parameterNames the parameter names used so far
+   * @param dependency the dependency
+   * @param field the field used to hold the framework type for the dependency
+   */
+  private String staticInjectMethodDependencyParameterName(
+      Set<String> parameterNames, DependencyRequest dependency, FieldWriter field) {
+    StringBuilder parameterName =
+        new StringBuilder(dependency.requestElement().getSimpleName().toString());
+    switch (dependency.kind()) {
+      case LAZY:
+      case INSTANCE:
+      case FUTURE:
+        String suffix = ((ParameterizedTypeName) field.type()).type().simpleName();
+        if (parameterName.length() <= suffix.length()
+            || !parameterName.substring(parameterName.length() - suffix.length()).equals(suffix)) {
+          parameterName.append(suffix);
+        }
+        break;
+
+      default:
+        break;
+    }
+    int baseLength = parameterName.length();
+    for (int i = 2; !parameterNames.add(parameterName.toString()); i++) {
+      parameterName.replace(baseLength, parameterName.length(), String.valueOf(i));
+    }
+    return parameterName.toString();
+  }
+
+  private void suppressRawTypesWarning(Modifiable modifiable) {
+    modifiable.annotate(SuppressWarnings.class).setValue("rawtypes");
+  }
+
+  private static final TypeVisitor<Boolean, MembersInjectionBinding> VISIBLE_TO_MEMBERS_INJECTOR =
+      new SimpleTypeVisitor7<Boolean, MembersInjectionBinding>(true) {
+        @Override
+        public Boolean visitArray(ArrayType t, MembersInjectionBinding p) {
+          return visit(t.getComponentType(), p);
+        }
+
+        @Override
+        public Boolean visitDeclared(DeclaredType t, MembersInjectionBinding p) {
+          return visibleToMembersInjector(p, t.asElement());
+        }
+      };
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/MissingBindingSuggestions.java b/compiler/src/main/java/dagger/internal/codegen/MissingBindingSuggestions.java
index dcabab52d..4b6f0c33c 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MissingBindingSuggestions.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MissingBindingSuggestions.java
@@ -15,9 +15,7 @@
  */
 package dagger.internal.codegen;
 
-import com.google.auto.value.AutoValue;
 import com.google.common.collect.ImmutableList;
-
 import java.util.ArrayDeque;
 import java.util.Deque;
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java
index f5e33b59d..c938af2c3 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java
@@ -42,7 +42,7 @@
 
   abstract ImmutableSet<ModuleDescriptor> includedModules();
 
-  abstract ImmutableSet<? extends ContributionBinding> bindings();
+  abstract ImmutableSet<ContributionBinding> bindings();
 
   enum DefaultCreationStrategy {
     PASSED,
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java b/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java
index f2116b110..8b0c9a217 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java
@@ -50,6 +50,7 @@
 import static com.google.auto.common.Visibility.PRIVATE;
 import static com.google.auto.common.Visibility.PUBLIC;
 import static com.google.auto.common.Visibility.effectiveVisibilityOfElement;
+import static com.google.common.collect.Iterables.any;
 import static dagger.internal.codegen.ConfigurationAnnotations.getModuleIncludes;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_WITH_SAME_NAME;
 import static dagger.internal.codegen.ErrorMessages.METHOD_OVERRIDES_PROVIDES_METHOD;
@@ -61,15 +62,16 @@
 import static javax.lang.model.element.Modifier.ABSTRACT;
 
 /**
- * A {@link Validator} for {@link Module}s or {@link ProducerModule}s.
+ * A {@linkplain ValidationReport validator} for {@link Module}s or {@link ProducerModule}s.
  *
  * @author Gregory Kick
  * @since 2.0
  */
-final class ModuleValidator implements Validator<TypeElement> {
+final class ModuleValidator {
   private final Types types;
   private final Elements elements;
   private final Class<? extends Annotation> moduleClass;
+  private final ImmutableList<Class<? extends Annotation>> includedModuleClasses;
   private final Class<? extends Annotation> methodClass;
   private final MethodSignatureFormatter methodSignatureFormatter;
 
@@ -78,17 +80,18 @@
       Elements elements,
       MethodSignatureFormatter methodSignatureFormatter,
       Class<? extends Annotation> moduleClass,
+      ImmutableList<Class<? extends Annotation>> includedModuleClasses,
       Class<? extends Annotation> methodClass) {
     this.types = types;
     this.elements = elements;
     this.moduleClass = moduleClass;
+    this.includedModuleClasses = includedModuleClasses;
     this.methodClass = methodClass;
     this.methodSignatureFormatter = methodSignatureFormatter;
   }
 
-  @Override
-  public ValidationReport<TypeElement> validate(final TypeElement subject) {
-    final ValidationReport.Builder<TypeElement> builder = ValidationReport.Builder.about(subject);
+  ValidationReport<TypeElement> validate(final TypeElement subject) {
+    final ValidationReport.Builder<TypeElement> builder = ValidationReport.about(subject);
 
     List<ExecutableElement> moduleMethods = ElementFilter.methodsIn(subject.getEnclosedElements());
     ListMultimap<String, ExecutableElement> allMethodsByName = ArrayListMultimap.create();
@@ -99,88 +102,122 @@
       }
       allMethodsByName.put(moduleMethod.getSimpleName().toString(), moduleMethod);
     }
-      
+
     validateModuleVisibility(subject, builder);
     validateMethodsWithSameName(builder, bindingMethodsByName);
     if (subject.getKind() != ElementKind.INTERFACE) {
       validateProvidesOverrides(subject, builder, allMethodsByName, bindingMethodsByName);
     }
-    validateModifiers(subject, builder);    
+    validateModifiers(subject, builder);
     validateReferencedModules(subject, builder);
-    
+
     // TODO(gak): port the dagger 1 module validation?
     return builder.build();
   }
 
-  private void validateModifiers(TypeElement subject,
-      ValidationReport.Builder<TypeElement> builder) {    
+  private void validateModifiers(
+      TypeElement subject, ValidationReport.Builder<TypeElement> builder) {
     // This coupled with the check for abstract modules in ComponentValidator guarantees that
-    // only modules without type parameters are referenced from @Component(modules={...}). 
+    // only modules without type parameters are referenced from @Component(modules={...}).
     if (!subject.getTypeParameters().isEmpty() && !subject.getModifiers().contains(ABSTRACT)) {
-      builder.addItem(MODULES_WITH_TYPE_PARAMS_MUST_BE_ABSTRACT, subject);
+      builder.addError(MODULES_WITH_TYPE_PARAMS_MUST_BE_ABSTRACT, subject);
     }
   }
-  
-  private void validateMethodsWithSameName(ValidationReport.Builder<TypeElement> builder,
+
+  private void validateMethodsWithSameName(
+      ValidationReport.Builder<TypeElement> builder,
       ListMultimap<String, ExecutableElement> bindingMethodsByName) {
     for (Entry<String, Collection<ExecutableElement>> entry :
         bindingMethodsByName.asMap().entrySet()) {
       if (entry.getValue().size() > 1) {
         for (ExecutableElement offendingMethod : entry.getValue()) {
-          builder.addItem(String.format(BINDING_METHOD_WITH_SAME_NAME, methodClass.getSimpleName()),
+          builder.addError(
+              String.format(BINDING_METHOD_WITH_SAME_NAME, methodClass.getSimpleName()),
               offendingMethod);
         }
       }
-    }    
+    }
   }
-  
-  private void validateReferencedModules(final TypeElement subject,
-      final ValidationReport.Builder<TypeElement> builder) {
+
+  private void validateReferencedModules(
+      TypeElement subject, ValidationReport.Builder<TypeElement> builder) {
     // Validate that all the modules we include are valid for inclusion.
     AnnotationMirror mirror = getAnnotationMirror(subject, moduleClass).get();
     ImmutableList<TypeMirror> includedTypes = getModuleIncludes(mirror);
     validateReferencedModules(subject,  builder, includedTypes);
   }
-  
+
   /**
    * Used by {@link ModuleValidator} & {@link ComponentValidator} to validate referenced modules.
    */
-  void validateReferencedModules(final TypeElement subject,
+  void validateReferencedModules(
+      final TypeElement subject,
       final ValidationReport.Builder<TypeElement> builder,
       ImmutableList<TypeMirror> includedTypes) {
     for (TypeMirror includedType : includedTypes) {
-      includedType.accept(new SimpleTypeVisitor6<Void, Void>() {
-        @Override
-        protected Void defaultAction(TypeMirror mirror, Void p) {
-          builder.addItem(mirror + " is not a valid module type.", subject);
-          return null;
-        }
+      includedType.accept(
+          new SimpleTypeVisitor6<Void, Void>() {
+            @Override
+            protected Void defaultAction(TypeMirror mirror, Void p) {
+              builder.addError(mirror + " is not a valid module type.", subject);
+              return null;
+            }
 
-        @Override
-        public Void visitDeclared(DeclaredType t, Void p) {
-          TypeElement element = MoreElements.asType(t.asElement()); 
-          if (!t.getTypeArguments().isEmpty()) {
-            builder.addItem(String.format(REFERENCED_MODULE_MUST_NOT_HAVE_TYPE_PARAMS,
-                element.getQualifiedName()), subject);
-          }
-          if (!getAnnotationMirror(element, moduleClass).isPresent()) {
-            builder.addItem(String.format(REFERENCED_MODULE_NOT_ANNOTATED,
-                element.getQualifiedName(), moduleClass.getSimpleName()), subject);
-          }
-          if (element.getModifiers().contains(ABSTRACT)) {
-            builder.addItem(String.format(REFERENCED_MODULES_MUST_NOT_BE_ABSTRACT,
-                element.getQualifiedName()), subject);
-          }
-          return null;
-        }
-      }, null);
+            @Override
+            public Void visitDeclared(DeclaredType t, Void p) {
+              final TypeElement element = MoreElements.asType(t.asElement());
+              if (!t.getTypeArguments().isEmpty()) {
+                builder.addError(
+                    String.format(
+                        REFERENCED_MODULE_MUST_NOT_HAVE_TYPE_PARAMS, element.getQualifiedName()),
+                    subject);
+              }
+              boolean isIncludedModule =
+                  any(
+                      includedModuleClasses,
+                      new Predicate<Class<? extends Annotation>>() {
+                        @Override
+                        public boolean apply(Class<? extends Annotation> otherClass) {
+                          return MoreElements.isAnnotationPresent(element, otherClass);
+                        }
+                      });
+              if (!isIncludedModule) {
+                builder.addError(
+                    String.format(
+                        REFERENCED_MODULE_NOT_ANNOTATED,
+                        element.getQualifiedName(),
+                        (includedModuleClasses.size() > 1 ? "one of " : "")
+                            + Joiner.on(", ")
+                                .join(
+                                    FluentIterable.from(includedModuleClasses)
+                                        .transform(
+                                            new Function<Class<? extends Annotation>, String>() {
+                                              @Override
+                                              public String apply(
+                                                  Class<? extends Annotation> otherClass) {
+                                                return "@" + otherClass.getSimpleName();
+                                              }
+                                            }))),
+                    subject);
+              }
+              if (element.getModifiers().contains(ABSTRACT)) {
+                builder.addError(
+                    String.format(
+                        REFERENCED_MODULES_MUST_NOT_BE_ABSTRACT, element.getQualifiedName()),
+                    subject);
+              }
+              return null;
+            }
+          },
+          null);
     }
   }
-  
-  private void validateProvidesOverrides(TypeElement subject,
+
+  private void validateProvidesOverrides(
+      TypeElement subject,
       ValidationReport.Builder<TypeElement> builder,
       ListMultimap<String, ExecutableElement> allMethodsByName,
-      ListMultimap<String, ExecutableElement> bindingMethodsByName) { 
+      ListMultimap<String, ExecutableElement> bindingMethodsByName) {
     // For every @Provides method, confirm it overrides nothing *and* nothing overrides it.
     // Consider the following hierarchy:
     // class Parent {
@@ -211,8 +248,11 @@ private void validateProvidesOverrides(TypeElement subject,
           if (!failedMethods.contains(providesMethod)
               && elements.overrides(providesMethod, superclassMethod, subject)) {
             failedMethods.add(providesMethod);
-            builder.addItem(String.format(PROVIDES_METHOD_OVERRIDES_ANOTHER,
-                methodClass.getSimpleName(), methodSignatureFormatter.format(superclassMethod)),
+            builder.addError(
+                String.format(
+                    PROVIDES_METHOD_OVERRIDES_ANOTHER,
+                    methodClass.getSimpleName(),
+                    methodSignatureFormatter.format(superclassMethod)),
                 providesMethod);
           }
         }
@@ -222,8 +262,11 @@ private void validateProvidesOverrides(TypeElement subject,
             if (!failedMethods.contains(method)
                 && elements.overrides(method, superclassMethod, subject)) {
               failedMethods.add(method);
-              builder.addItem(String.format(METHOD_OVERRIDES_PROVIDES_METHOD,
-                  methodClass.getSimpleName(), methodSignatureFormatter.format(superclassMethod)),
+              builder.addError(
+                  String.format(
+                      METHOD_OVERRIDES_PROVIDES_METHOD,
+                      methodClass.getSimpleName(),
+                      methodSignatureFormatter.format(superclassMethod)),
                   method);
             }
           }
@@ -237,9 +280,9 @@ private void validateModuleVisibility(final TypeElement moduleElement,
       final ValidationReport.Builder<?> reportBuilder) {
     Visibility moduleVisibility = Visibility.ofElement(moduleElement);
     if (moduleVisibility.equals(PRIVATE)) {
-      reportBuilder.addItem("Modules cannot be private.", moduleElement);
+      reportBuilder.addError("Modules cannot be private.", moduleElement);
     } else if (effectiveVisibilityOfElement(moduleElement).equals(PRIVATE)) {
-      reportBuilder.addItem("Modules cannot be enclosed in private types.", moduleElement);
+      reportBuilder.addError("Modules cannot be enclosed in private types.", moduleElement);
     }
 
     switch (moduleElement.getNestingKind()) {
@@ -264,7 +307,7 @@ private void validateModuleVisibility(final TypeElement moduleElement,
                   })
                   .toSet();
           if (!nonPublicModules.isEmpty()) {
-            reportBuilder.addItem(
+            reportBuilder.addError(
                 String.format(
                     "This module is public, but it includes non-public "
                         + "(or effectively non-public) modules. "
diff --git a/compiler/src/main/java/dagger/internal/codegen/MonitoringModuleGenerator.java b/compiler/src/main/java/dagger/internal/codegen/MonitoringModuleGenerator.java
new file mode 100644
index 000000000..a4e020b32
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/MonitoringModuleGenerator.java
@@ -0,0 +1,99 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.common.base.Optional;
+import com.google.common.collect.ImmutableSet;
+import dagger.Module;
+import dagger.Provides;
+import dagger.internal.codegen.writer.ClassName;
+import dagger.internal.codegen.writer.ClassWriter;
+import dagger.internal.codegen.writer.FieldWriter;
+import dagger.internal.codegen.writer.JavaWriter;
+import dagger.internal.codegen.writer.MethodWriter;
+import dagger.internal.codegen.writer.ParameterizedTypeName;
+import dagger.internal.codegen.writer.TypeName;
+import dagger.producers.monitoring.ProductionComponentMonitor;
+import dagger.producers.monitoring.internal.MonitorCache;
+
+import java.util.Set;
+import javax.annotation.Generated;
+import javax.annotation.processing.Filer;
+import javax.inject.Provider;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.TypeElement;
+
+import static javax.lang.model.element.Modifier.PRIVATE;
+import static javax.lang.model.element.Modifier.STATIC;
+import static javax.lang.model.element.Modifier.FINAL;
+
+/** Generates a monitoring module for use with production components. */
+final class MonitoringModuleGenerator extends SourceFileGenerator<TypeElement> {
+  private static final TypeName SET_OF_FACTORIES =
+      ParameterizedTypeName.create(
+          Set.class, ClassName.fromClass(ProductionComponentMonitor.Factory.class));
+
+  MonitoringModuleGenerator(Filer filer) {
+    super(filer);
+  }
+
+  @Override
+  ClassName nameGeneratedType(TypeElement componentElement) {
+    return SourceFiles.generatedMonitoringModuleName(componentElement);
+  }
+
+  @Override
+  Iterable<? extends Element> getOriginatingElements(TypeElement componentElement) {
+    return ImmutableSet.of(componentElement);
+  }
+
+  @Override
+  Optional<? extends Element> getElementForErrorReporting(TypeElement componentElement) {
+    return Optional.of(componentElement);
+  }
+
+  @Override
+  ImmutableSet<JavaWriter> write(ClassName generatedTypeName, TypeElement componentElement) {
+    JavaWriter writer = JavaWriter.inPackage(generatedTypeName.packageName());
+    ClassWriter classWriter = writer.addClass(generatedTypeName.simpleName());
+    classWriter.annotate(Generated.class).setValue(ComponentProcessor.class.getName());
+    classWriter.annotate(Module.class);
+    classWriter.addModifiers(FINAL);
+
+    // TODO(beder): Replace this default set binding with EmptyCollections when it exists.
+    MethodWriter emptySetBindingMethod =
+        classWriter.addMethod(SET_OF_FACTORIES, "defaultSetOfFactories");
+    emptySetBindingMethod.addModifiers(STATIC);
+    emptySetBindingMethod.annotate(Provides.class).setMember("type", Provides.Type.SET_VALUES);
+    emptySetBindingMethod
+        .body()
+        .addSnippet("return %s.of();", ClassName.fromClass(ImmutableSet.class));
+
+    FieldWriter providerField = classWriter.addField(MonitorCache.class, "monitorCache");
+    providerField.addModifiers(PRIVATE, FINAL);
+    providerField.setInitializer("new %s()", ClassName.fromClass(MonitorCache.class));
+    MethodWriter monitorMethod = classWriter.addMethod(ProductionComponentMonitor.class, "monitor");
+    monitorMethod.annotate(Provides.class);
+    monitorMethod.addParameter(
+        ParameterizedTypeName.create(Provider.class, ClassName.fromTypeElement(componentElement)),
+        "component");
+    monitorMethod.addParameter(
+        ParameterizedTypeName.create(Provider.class, SET_OF_FACTORIES), "factories");
+    monitorMethod.body().addSnippet("return monitorCache.monitor(component, factories);");
+
+    return ImmutableSet.of(writer);
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/MonitoringModuleProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/MonitoringModuleProcessingStep.java
new file mode 100644
index 000000000..91b10e7ef
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/MonitoringModuleProcessingStep.java
@@ -0,0 +1,61 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.common.BasicAnnotationProcessor.ProcessingStep;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.SetMultimap;
+import dagger.producers.ProductionComponent;
+import java.lang.annotation.Annotation;
+import java.util.Set;
+import javax.annotation.processing.Messager;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.TypeElement;
+
+import static javax.lang.model.util.ElementFilter.typesIn;
+
+/**
+ * A processing step that is responsible for generating a special module for a
+ * {@link ProductionComponent}.
+ */
+final class MonitoringModuleProcessingStep implements ProcessingStep {
+  private final Messager messager;
+  private final MonitoringModuleGenerator monitoringModuleGenerator;
+
+  MonitoringModuleProcessingStep(
+      Messager messager, MonitoringModuleGenerator monitoringModuleGenerator) {
+    this.messager = messager;
+    this.monitoringModuleGenerator = monitoringModuleGenerator;
+  }
+
+  @Override
+  public Set<? extends Class<? extends Annotation>> annotations() {
+    return ImmutableSet.of(ProductionComponent.class);
+  }
+
+  @Override
+  public Set<Element> process(
+      SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
+    for (TypeElement element : typesIn(elementsByAnnotation.get(ProductionComponent.class))) {
+      try {
+        monitoringModuleGenerator.generate(element);
+      } catch (SourceFileGenerationException e) {
+        e.printMessageTo(messager);
+      }
+    }
+    return ImmutableSet.of();
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/PrintableErrorMessage.java b/compiler/src/main/java/dagger/internal/codegen/PrintableErrorMessage.java
deleted file mode 100644
index bb9ba982c..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/PrintableErrorMessage.java
+++ /dev/null
@@ -1,34 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen;
-
-import javax.annotation.processing.Messager;
-
-/**
- * An interface for types that represent a compilation
- * {@linkplain javax.tools.Diagnostic.Kind#ERROR error} (though, not necessarily a
- * {@link Throwable}) that can be printed using a {@link Messager}.
- *
- * @author Gregory Kick
- * @since 2.0
- */
-interface PrintableErrorMessage {
-  /**
-   * Prints the information represented by this object to the given {@link Messager} as an
-   * {@link javax.tools.Diagnostic.Kind#ERROR}.
-   */
-  void printMessageTo(Messager messager);
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
index 10565a1b7..90a0337bd 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
@@ -44,21 +44,23 @@
 import dagger.producers.Produces;
 import dagger.producers.internal.AbstractProducer;
 import dagger.producers.internal.Producers;
+import dagger.producers.monitoring.ProducerMonitor;
+import dagger.producers.monitoring.ProducerToken;
 import java.util.List;
-import java.util.concurrent.Callable;
 import java.util.concurrent.Executor;
 import javax.annotation.Generated;
 import javax.annotation.processing.Filer;
 import javax.lang.model.element.Element;
 import javax.lang.model.type.TypeMirror;
 
-import static dagger.internal.codegen.SourceFiles.factoryNameForProductionBinding;
 import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
+import static dagger.internal.codegen.SourceFiles.generatedClassNameForBinding;
 import static dagger.internal.codegen.writer.Snippet.makeParametersSnippet;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.PROTECTED;
 import static javax.lang.model.element.Modifier.PUBLIC;
+import static javax.lang.model.element.Modifier.STATIC;
 
 /**
  * Generates {@link Producer} implementations from {@link ProductionBinding} instances.
@@ -76,7 +78,7 @@
 
   @Override
   ClassName nameGeneratedType(ProductionBinding binding) {
-    return factoryNameForProductionBinding(binding);
+    return generatedClassNameForBinding(binding);
   }
 
   @Override
@@ -103,12 +105,26 @@ ClassName nameGeneratedType(ProductionBinding binding) {
     ConstructorWriter constructorWriter = factoryWriter.addConstructor();
     constructorWriter.addModifiers(PUBLIC);
 
-    factoryWriter.addField(binding.bindingTypeElement(), "module")
-        .addModifiers(PRIVATE, FINAL);
-    constructorWriter.addParameter(binding.bindingTypeElement(), "module");
-    constructorWriter.body()
-        .addSnippet("assert module != null;")
-        .addSnippet("this.module = module;");
+    ImmutableMap<BindingKey, FrameworkField> fields =
+        SourceFiles.generateBindingFieldsForDependencies(
+            dependencyRequestMapper, binding.implicitDependencies());
+
+    constructorWriter
+        .body()
+        .addSnippet(
+            "super(%s, %s.create(%s.class));",
+            fields.get(binding.monitorRequest().get().bindingKey()).name(),
+            ClassName.fromClass(ProducerToken.class),
+            factoryWriter.name());
+
+    if (!binding.bindingElement().getModifiers().contains(STATIC)) {
+      factoryWriter.addField(binding.bindingTypeElement(), "module")
+          .addModifiers(PRIVATE, FINAL);
+      constructorWriter.addParameter(binding.bindingTypeElement(), "module");
+      constructorWriter.body()
+          .addSnippet("assert module != null;")
+          .addSnippet("this.module = module;");
+    }
 
     factoryWriter.addField(Executor.class, "executor")
         .addModifiers(PRIVATE, FINAL);
@@ -123,13 +139,10 @@ ClassName nameGeneratedType(ProductionBinding binding) {
     factoryWriter.setSuperclass(
         ParameterizedTypeName.create(AbstractProducer.class, providedTypeName));
 
-    MethodWriter getMethodWriter = factoryWriter.addMethod(futureTypeName, "compute");
-    getMethodWriter.annotate(Override.class);
-    getMethodWriter.addModifiers(PROTECTED);
-
-    final ImmutableMap<BindingKey, FrameworkField> fields =
-        SourceFiles.generateBindingFieldsForDependencies(
-            dependencyRequestMapper, binding.dependencies());
+    MethodWriter computeMethodWriter = factoryWriter.addMethod(futureTypeName, "compute");
+    computeMethodWriter.annotate(Override.class);
+    computeMethodWriter.addModifiers(PROTECTED);
+    computeMethodWriter.addParameter(ProducerMonitor.class, "monitor").addModifiers(FINAL);
 
     for (FrameworkField bindingField : fields.values()) {
       TypeName fieldType = bindingField.frameworkType();
@@ -141,15 +154,18 @@ ClassName nameGeneratedType(ProductionBinding binding) {
           .addSnippet("this.%1$s = %1$s;", field.name());
     }
 
-    boolean returnsFuture = binding.bindingKind().equals(ProductionBinding.Kind.FUTURE_PRODUCTION);
-    ImmutableList<DependencyRequest> asyncDependencies = FluentIterable
-        .from(binding.dependencies())
-        .filter(new Predicate<DependencyRequest>() {
-          @Override public boolean apply(DependencyRequest dependency) {
-            return isAsyncDependency(dependency);
-          }
-        })
-        .toList();
+    boolean returnsFuture =
+        binding.bindingKind().equals(ContributionBinding.Kind.FUTURE_PRODUCTION);
+    ImmutableList<DependencyRequest> asyncDependencies =
+        FluentIterable.from(binding.implicitDependencies())
+            .filter(
+                new Predicate<DependencyRequest>() {
+                  @Override
+                  public boolean apply(DependencyRequest dependency) {
+                    return isAsyncDependency(dependency);
+                  }
+                })
+            .toList();
 
     for (DependencyRequest dependency : asyncDependencies) {
       ParameterizedTypeName futureType = ParameterizedTypeName.create(
@@ -157,127 +173,229 @@ ClassName nameGeneratedType(ProductionBinding binding) {
           asyncDependencyType(dependency));
       String name = fields.get(dependency.bindingKey()).name();
       Snippet futureAccess = Snippet.format("%s.get()", name);
-      getMethodWriter.body().addSnippet("%s %sFuture = %s;",
-          futureType,
-          name,
-          dependency.kind().equals(DependencyRequest.Kind.PRODUCED)
-              ? Snippet.format("%s.createFutureProduced(%s)",
-                  ClassName.fromClass(Producers.class), futureAccess)
-              : futureAccess);
+      computeMethodWriter
+          .body()
+          .addSnippet(
+              "%s %sFuture = %s;",
+              futureType,
+              name,
+              dependency.kind().equals(DependencyRequest.Kind.PRODUCED)
+                  ? Snippet.format(
+                      "%s.createFutureProduced(%s)",
+                      ClassName.fromClass(Producers.class),
+                      futureAccess)
+                  : futureAccess);
     }
 
-    if (asyncDependencies.isEmpty()) {
-      ImmutableList.Builder<Snippet> parameterSnippets = ImmutableList.builder();
-      for (DependencyRequest dependency : binding.dependencies()) {
-        parameterSnippets.add(frameworkTypeUsageStatement(
-            Snippet.format(fields.get(dependency.bindingKey()).name()), dependency.kind()));
-      }
-      final boolean wrapWithFuture = false;  // since submitToExecutor will create the future
-      Snippet invocationSnippet = getInvocationSnippet(wrapWithFuture, binding,
-          parameterSnippets.build());
-      TypeName callableReturnType = returnsFuture ? futureTypeName : providedTypeName;
-      Snippet throwsClause = getThrowsClause(binding.thrownTypes());
-      Snippet callableSnippet = Snippet.format(Joiner.on('\n').join(
-          "new %1$s<%2$s>() {",
-          "  @Override public %2$s call() %3$s{",
-          "    return %4$s;",
-          "  }",
-          "}"),
-          ClassName.fromClass(Callable.class),
-          callableReturnType,
-          throwsClause,
-          invocationSnippet);
-      getMethodWriter.body().addSnippet("%s future = %s.submitToExecutor(%s, executor);",
-          ParameterizedTypeName.create(
-              ClassName.fromClass(ListenableFuture.class),
-              callableReturnType),
-          ClassName.fromClass(Producers.class),
-          callableSnippet);
-      getMethodWriter.body().addSnippet("return %s;",
-          returnsFuture
-              ? Snippet.format("%s.dereference(future)", ClassName.fromClass(Futures.class))
-              : "future");
-    } else {
-      final Snippet futureSnippet;
-      final Snippet transformSnippet;
-      if (asyncDependencies.size() == 1) {
-        DependencyRequest asyncDependency = Iterables.getOnlyElement(asyncDependencies);
-        futureSnippet = Snippet.format("%s",
-            fields.get(asyncDependency.bindingKey()).name() + "Future");
-        String argName = asyncDependency.requestElement().getSimpleName().toString();
-        ImmutableList.Builder<Snippet> parameterSnippets = ImmutableList.builder();
-        for (DependencyRequest dependency : binding.dependencies()) {
-          // We really want to compare instances here, because asyncDependency is an element in the
-          // set binding.dependencies().
-          if (dependency == asyncDependency) {
-            parameterSnippets.add(Snippet.format("%s", argName));
-          } else {
-            parameterSnippets.add(frameworkTypeUsageStatement(
-                Snippet.format(fields.get(dependency.bindingKey()).name()),
-                dependency.kind()));
-          }
-        }
-        boolean wrapWithFuture = !returnsFuture;  // only wrap if we don't already have a future
-        Snippet invocationSnippet = getInvocationSnippet(wrapWithFuture, binding,
-            parameterSnippets.build());
-        Snippet throwsClause = getThrowsClause(binding.thrownTypes());
-        transformSnippet = Snippet.format(Joiner.on('\n').join(
-            "new %1$s<%2$s, %3$s>() {",
-            "  @Override public %4$s apply(%2$s %5$s) %6$s{",
-            "    return %7$s;",
-            "  }",
-            "}"),
+    FutureTransform futureTransform = FutureTransform.create(fields, binding, asyncDependencies);
+    Snippet transformSnippet =
+        Snippet.format(
+            Joiner.on('\n')
+                .join(
+                    "new %1$s<%2$s, %3$s>() {",
+                    "  %4$s",
+                    "  @Override public %5$s apply(%2$s %6$s) %7$s {",
+                    "    %8$s",
+                    "  }",
+                    "}"),
             ClassName.fromClass(AsyncFunction.class),
-            asyncDependencyType(asyncDependency),
+            futureTransform.applyArgType(),
             providedTypeName,
+            futureTransform.hasUncheckedCast()
+                ? "@SuppressWarnings(\"unchecked\")  // safe by specification"
+                : "",
             futureTypeName,
-            argName,
-            throwsClause,
-            invocationSnippet);
-      } else {
-        futureSnippet = Snippet.format("%s.<%s>allAsList(%s)",
+            futureTransform.applyArgName(),
+            getThrowsClause(binding.thrownTypes()),
+            getInvocationSnippet(!returnsFuture, binding, futureTransform.parameterSnippets()));
+    computeMethodWriter
+        .body()
+        .addSnippet(
+            "return %s.transform(%s, %s, executor);",
             ClassName.fromClass(Futures.class),
-            ClassName.fromClass(Object.class),
-            Joiner.on(",").join(FluentIterable
-                .from(asyncDependencies)
-                .transform(new Function<DependencyRequest, String>() {
-                  @Override public String apply(DependencyRequest dependency) {
-                    return fields.get(dependency.bindingKey()).name() + "Future";
-                  }
-                })));
-        ImmutableList<Snippet> parameterSnippets = getParameterSnippets(binding, fields, "args");
-        boolean wrapWithFuture = !returnsFuture;  // only wrap if we don't already have a future
-        Snippet invocationSnippet = getInvocationSnippet(wrapWithFuture, binding,
-            parameterSnippets);
-        ParameterizedTypeName listOfObject = ParameterizedTypeName.create(
-            ClassName.fromClass(List.class), ClassName.fromClass(Object.class));
-        Snippet throwsClause = getThrowsClause(binding.thrownTypes());
-        transformSnippet = Snippet.format(Joiner.on('\n').join(
-            "new %1$s<%2$s, %3$s>() {",
-            "  @SuppressWarnings(\"unchecked\")  // safe by specification",
-            "  @Override public %4$s apply(%2$s args) %5$s{",
-            "    return %6$s;",
-            "  }",
-            "}"),
-            ClassName.fromClass(AsyncFunction.class),
-            listOfObject,
-            providedTypeName,
-            futureTypeName,
-            throwsClause,
-            invocationSnippet);
+            futureTransform.futureSnippet(),
+            transformSnippet);
+
+    // TODO(gak): write a sensible toString
+    return ImmutableSet.of(writer);
+  }
+
+  /** Represents the transformation of an input future by a producer method. */
+  abstract static class FutureTransform {
+    protected final ImmutableMap<BindingKey, FrameworkField> fields;
+    protected final ProductionBinding binding;
+
+    FutureTransform(ImmutableMap<BindingKey, FrameworkField> fields, ProductionBinding binding) {
+      this.fields = fields;
+      this.binding = binding;
+    }
+
+    /** The snippet representing the future that should be transformed. */
+    abstract Snippet futureSnippet();
+
+    /** The type of the argument to the apply method. */
+    abstract TypeName applyArgType();
+
+    /** The name of the argument to the apply method */
+    abstract String applyArgName();
+
+    /** The snippets to be passed to the produces method itself. */
+    abstract ImmutableList<Snippet> parameterSnippets();
+
+    /** Whether the transform method has an unchecked cast. */
+    boolean hasUncheckedCast() {
+      return false;
+    }
+
+    static FutureTransform create(
+        ImmutableMap<BindingKey, FrameworkField> fields,
+        ProductionBinding binding,
+        ImmutableList<DependencyRequest> asyncDependencies) {
+      if (asyncDependencies.isEmpty()) {
+        return new NoArgFutureTransform(fields, binding);
+      } else if (asyncDependencies.size() == 1) {
+        return new SingleArgFutureTransform(
+            fields, binding, Iterables.getOnlyElement(asyncDependencies));
+      } else {
+        return new MultiArgFutureTransform(fields, binding, asyncDependencies);
       }
-      getMethodWriter.body().addSnippet("return %s.%s(%s, %s, executor);",
+    }
+  }
+
+  static final class NoArgFutureTransform extends FutureTransform {
+    NoArgFutureTransform(
+        ImmutableMap<BindingKey, FrameworkField> fields, ProductionBinding binding) {
+      super(fields, binding);
+    }
+
+    @Override
+    Snippet futureSnippet() {
+      return Snippet.format(
+          "%s.<%s>immediateFuture(null)",
           ClassName.fromClass(Futures.class),
-          "transform",
-          futureSnippet,
-          transformSnippet);
+          ClassName.fromClass(Void.class));
     }
 
-    // TODO(gak): write a sensible toString
-    return ImmutableSet.of(writer);
+    @Override
+    TypeName applyArgType() {
+      return ClassName.fromClass(Void.class);
+    }
+
+    @Override
+    String applyArgName() {
+      return "ignoredVoidArg";
+    }
+
+    @Override
+    ImmutableList<Snippet> parameterSnippets() {
+      ImmutableList.Builder<Snippet> parameterSnippets = ImmutableList.builder();
+      for (DependencyRequest dependency : binding.dependencies()) {
+        parameterSnippets.add(
+            frameworkTypeUsageStatement(
+                Snippet.format(
+                    "%s", fields.get(dependency.bindingKey()).name()), dependency.kind()));
+      }
+      return parameterSnippets.build();
+    }
   }
 
-  private boolean isAsyncDependency(DependencyRequest dependency) {
+  static final class SingleArgFutureTransform extends FutureTransform {
+    private final DependencyRequest asyncDependency;
+
+    SingleArgFutureTransform(
+        ImmutableMap<BindingKey, FrameworkField> fields,
+        ProductionBinding binding,
+        DependencyRequest asyncDependency) {
+      super(fields, binding);
+      this.asyncDependency = asyncDependency;
+    }
+
+    @Override
+    Snippet futureSnippet() {
+      return Snippet.format("%s", fields.get(asyncDependency.bindingKey()).name() + "Future");
+    }
+
+    @Override
+    TypeName applyArgType() {
+      return asyncDependencyType(asyncDependency);
+    }
+
+    @Override
+    String applyArgName() {
+      return asyncDependency.requestElement().getSimpleName().toString();
+    }
+
+    @Override
+    ImmutableList<Snippet> parameterSnippets() {
+      ImmutableList.Builder<Snippet> parameterSnippets = ImmutableList.builder();
+      for (DependencyRequest dependency : binding.dependencies()) {
+        // We really want to compare instances here, because asyncDependency is an element in the
+        // set binding.dependencies().
+        if (dependency == asyncDependency) {
+          parameterSnippets.add(Snippet.format("%s", applyArgName()));
+        } else {
+          parameterSnippets.add(
+              frameworkTypeUsageStatement(
+                  Snippet.format(
+                      "%s", fields.get(dependency.bindingKey()).name()), dependency.kind()));
+        }
+      }
+      return parameterSnippets.build();
+    }
+  }
+
+  static final class MultiArgFutureTransform extends FutureTransform {
+    private final ImmutableList<DependencyRequest> asyncDependencies;
+
+    MultiArgFutureTransform(
+        ImmutableMap<BindingKey, FrameworkField> fields,
+        ProductionBinding binding,
+        ImmutableList<DependencyRequest> asyncDependencies) {
+      super(fields, binding);
+      this.asyncDependencies = asyncDependencies;
+    }
+
+    @Override
+    Snippet futureSnippet() {
+      return Snippet.format(
+          "%s.<%s>allAsList(%s)",
+          ClassName.fromClass(Futures.class),
+          ClassName.fromClass(Object.class),
+          makeParametersSnippet(
+              FluentIterable.from(asyncDependencies)
+                  .transform(DependencyRequest.BINDING_KEY_FUNCTION)
+                  .transform(
+                      new Function<BindingKey, Snippet>() {
+                        @Override
+                        public Snippet apply(BindingKey bindingKey) {
+                          return Snippet.format("%s", fields.get(bindingKey).name() + "Future");
+                        }
+                      })));
+    }
+
+    @Override
+    TypeName applyArgType() {
+      return ParameterizedTypeName.create(
+          ClassName.fromClass(List.class), ClassName.fromClass(Object.class));
+    }
+
+    @Override
+    String applyArgName() {
+      return "args";
+    }
+
+    @Override
+    ImmutableList<Snippet> parameterSnippets() {
+      return getParameterSnippets(binding, fields, applyArgName());
+    }
+
+    @Override
+    boolean hasUncheckedCast() {
+      return true;
+    }
+  }
+
+  private static boolean isAsyncDependency(DependencyRequest dependency) {
     switch (dependency.kind()) {
       case INSTANCE:
       case PRODUCED:
@@ -287,7 +405,7 @@ private boolean isAsyncDependency(DependencyRequest dependency) {
     }
   }
 
-  private TypeName asyncDependencyType(DependencyRequest dependency) {
+  private static TypeName asyncDependencyType(DependencyRequest dependency) {
     TypeName keyName = TypeNames.forTypeMirror(dependency.key().type());
     switch (dependency.kind()) {
       case INSTANCE:
@@ -299,7 +417,8 @@ private TypeName asyncDependencyType(DependencyRequest dependency) {
     }
   }
 
-  private ImmutableList<Snippet> getParameterSnippets(ProductionBinding binding,
+  private static ImmutableList<Snippet> getParameterSnippets(
+      ProductionBinding binding,
       ImmutableMap<BindingKey, FrameworkField> fields,
       String listArgName) {
     int argIndex = 0;
@@ -314,43 +433,69 @@ private TypeName asyncDependencyType(DependencyRequest dependency) {
         argIndex++;
       } else {
         snippets.add(frameworkTypeUsageStatement(
-            Snippet.format(fields.get(dependency.bindingKey()).name()), dependency.kind()));
+            Snippet.format("%s", fields.get(dependency.bindingKey()).name()), dependency.kind()));
       }
     }
     return snippets.build();
   }
 
   /**
-   * Creates a Snippet for the invocation of the producer method from the module.
+   * Creates a snippet for the invocation of the producer method from the module, which should be
+   * used entirely within a method body.
    *
    * @param wrapWithFuture If true, wraps the result of the call to the producer method
    *        in an immediate future.
    * @param binding The binding to generate the invocation snippet for.
    * @param parameterSnippets The snippets for all the parameters to the producer method.
    */
-  private Snippet getInvocationSnippet(boolean wrapWithFuture, ProductionBinding binding,
-      ImmutableList<Snippet> parameterSnippets) {
-    Snippet moduleSnippet = Snippet.format("module.%s(%s)",
+  private Snippet getInvocationSnippet(
+      boolean wrapWithFuture, ProductionBinding binding, ImmutableList<Snippet> parameterSnippets) {
+     Snippet moduleSnippet = Snippet.format("%s.%s(%s)",
+        binding.bindingElement().getModifiers().contains(STATIC)
+            ? ClassName.fromTypeElement(binding.bindingTypeElement())
+            : "module",
         binding.bindingElement().getSimpleName(),
         makeParametersSnippet(parameterSnippets));
-    if (wrapWithFuture) {
-      moduleSnippet = Snippet.format("%s.immediateFuture(%s)",
-          ClassName.fromClass(Futures.class),
-          moduleSnippet);
-    }
+
+    // NOTE(beder): We don't worry about catching exeptions from the monitor methods themselves
+    // because we'll wrap all monitoring in non-throwing monitors before we pass them to the
+    // factories.
+    ImmutableList.Builder<Snippet> snippets = ImmutableList.builder();
+    snippets.add(Snippet.format("monitor.methodStarting();"));
+
+    final Snippet valueSnippet;
     if (binding.productionType().equals(Produces.Type.SET)) {
-      if (binding.bindingKind().equals(ProductionBinding.Kind.FUTURE_PRODUCTION)) {
-        return Snippet.format("%s.createFutureSingletonSet(%s)",
-            ClassName.fromClass(Producers.class),
-            moduleSnippet);
+      if (binding.bindingKind().equals(ContributionBinding.Kind.FUTURE_PRODUCTION)) {
+        valueSnippet =
+            Snippet.format(
+                "%s.createFutureSingletonSet(%s)",
+                ClassName.fromClass(Producers.class),
+                moduleSnippet);
       } else {
-        return Snippet.format("%s.of(%s)",
-            ClassName.fromClass(ImmutableSet.class),
-            moduleSnippet);
+        valueSnippet =
+            Snippet.format("%s.of(%s)", ClassName.fromClass(ImmutableSet.class), moduleSnippet);
       }
     } else {
-      return moduleSnippet;
+      valueSnippet = moduleSnippet;
     }
+    Snippet returnSnippet =
+        wrapWithFuture
+            ? Snippet.format(
+                "%s.<%s>immediateFuture(%s)",
+                ClassName.fromClass(Futures.class),
+                TypeNames.forTypeMirror(binding.key().type()),
+                valueSnippet)
+            : valueSnippet;
+    return Snippet.format(
+        Joiner.on('\n')
+            .join(
+                "monitor.methodStarting();",
+                "try {",
+                "  return %s;",
+                "} finally {",
+                "  monitor.methodFinished();",
+                "}"),
+        returnSnippet);
   }
 
   /**
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProducesMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/ProducesMethodValidator.java
index a6e77a712..b0b4df1cc 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProducesMethodValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProducesMethodValidator.java
@@ -55,14 +55,14 @@
 import static javax.lang.model.type.TypeKind.VOID;
 
 /**
- * A {@link Validator} for {@link Produces} methods.
+ * A {@linkplain ValidationReport validator} for {@link Produces} methods.
  *
  * @author Jesse Beder
  * @since 2.0
  */
 // TODO(user): Consider unifying this with the ProvidesMethodValidator after Provides.Type and
 // Produces.Type are reconciled.
-final class ProducesMethodValidator implements Validator<ExecutableElement> {
+final class ProducesMethodValidator {
   private final Elements elements;
 
   ProducesMethodValidator(Elements elements) {
@@ -73,43 +73,42 @@ private TypeElement getSetElement() {
     return elements.getTypeElement(Set.class.getCanonicalName());
   }
 
-  @Override
-  public ValidationReport<ExecutableElement> validate(ExecutableElement producesMethodElement) {
+  ValidationReport<ExecutableElement> validate(ExecutableElement producesMethodElement) {
     ValidationReport.Builder<ExecutableElement> builder =
-        ValidationReport.Builder.about(producesMethodElement);
+        ValidationReport.about(producesMethodElement);
 
     Produces producesAnnotation = producesMethodElement.getAnnotation(Produces.class);
     checkArgument(producesAnnotation != null);
 
     Element enclosingElement = producesMethodElement.getEnclosingElement();
     if (!isAnnotationPresent(enclosingElement, ProducerModule.class)) {
-      builder.addItem(formatModuleErrorMessage(BINDING_METHOD_NOT_IN_MODULE),
-          producesMethodElement);
+      builder.addError(
+          formatModuleErrorMessage(BINDING_METHOD_NOT_IN_MODULE), producesMethodElement);
     }
 
     if (!producesMethodElement.getTypeParameters().isEmpty()) {
-      builder.addItem(formatErrorMessage(BINDING_METHOD_TYPE_PARAMETER), producesMethodElement);
+      builder.addError(formatErrorMessage(BINDING_METHOD_TYPE_PARAMETER), producesMethodElement);
     }
 
     Set<Modifier> modifiers = producesMethodElement.getModifiers();
     if (modifiers.contains(PRIVATE)) {
-      builder.addItem(formatErrorMessage(BINDING_METHOD_PRIVATE), producesMethodElement);
+      builder.addError(formatErrorMessage(BINDING_METHOD_PRIVATE), producesMethodElement);
     }
     if (modifiers.contains(ABSTRACT)) {
-      builder.addItem(formatErrorMessage(BINDING_METHOD_ABSTRACT), producesMethodElement);
+      builder.addError(formatErrorMessage(BINDING_METHOD_ABSTRACT), producesMethodElement);
     }
 
     TypeMirror returnType = producesMethodElement.getReturnType();
     TypeKind returnTypeKind = returnType.getKind();
     if (returnTypeKind.equals(VOID)) {
-      builder.addItem(formatErrorMessage(BINDING_METHOD_MUST_RETURN_A_VALUE),
-          producesMethodElement);
+      builder.addError(
+          formatErrorMessage(BINDING_METHOD_MUST_RETURN_A_VALUE), producesMethodElement);
     }
 
     // check mapkey is right
     if (!producesAnnotation.type().equals(Produces.Type.MAP)
         && !getMapKeys(producesMethodElement).isEmpty()) {
-      builder.addItem(
+      builder.addError(
           formatErrorMessage(BINDING_METHOD_NOT_MAP_HAS_MAP_KEY), producesMethodElement);
     }
 
@@ -125,13 +124,13 @@ private TypeElement getSetElement() {
         ImmutableSet<? extends AnnotationMirror> mapKeys = getMapKeys(producesMethodElement);
         switch (mapKeys.size()) {
           case 0:
-            builder.addItem(
+            builder.addError(
                 formatErrorMessage(BINDING_METHOD_WITH_NO_MAP_KEY), producesMethodElement);
             break;
           case 1:
             break;
           default:
-            builder.addItem(
+            builder.addError(
                 formatErrorMessage(BINDING_METHOD_WITH_MULTIPLE_MAP_KEY), producesMethodElement);
             break;
         }
@@ -167,7 +166,7 @@ private void validateKeyType(ValidationReport.Builder<? extends Element> reportB
       TypeMirror type) {
     TypeKind kind = type.getKind();
     if (!(kind.isPrimitive() || kind.equals(DECLARED) || kind.equals(ARRAY))) {
-      reportBuilder.addItem(PRODUCES_METHOD_RETURN_TYPE, reportBuilder.getSubject());
+      reportBuilder.addError(PRODUCES_METHOD_RETURN_TYPE, reportBuilder.getSubject());
     }
   }
 
@@ -176,7 +175,7 @@ private void validateSingleReturnType(ValidationReport.Builder<? extends Element
     if (type.getKind().equals(DECLARED) && MoreTypes.isTypeOf(ListenableFuture.class, type)) {
       DeclaredType declaredType = MoreTypes.asDeclared(type);
       if (declaredType.getTypeArguments().isEmpty()) {
-        reportBuilder.addItem(PRODUCES_METHOD_RAW_FUTURE, reportBuilder.getSubject());
+        reportBuilder.addError(PRODUCES_METHOD_RAW_FUTURE, reportBuilder.getSubject());
       } else {
         validateKeyType(reportBuilder, Iterables.getOnlyElement(declaredType.getTypeArguments()));
       }
@@ -188,17 +187,17 @@ private void validateSingleReturnType(ValidationReport.Builder<? extends Element
   private void validateSetType(ValidationReport.Builder<? extends Element> reportBuilder,
       TypeMirror type) {
     if (!type.getKind().equals(DECLARED)) {
-      reportBuilder.addItem(PRODUCES_METHOD_SET_VALUES_RETURN_SET, reportBuilder.getSubject());
+      reportBuilder.addError(PRODUCES_METHOD_SET_VALUES_RETURN_SET, reportBuilder.getSubject());
       return;
     }
 
     // TODO(gak): should we allow "covariant return" for set values?
     DeclaredType declaredType = MoreTypes.asDeclared(type);
     if (!declaredType.asElement().equals(getSetElement())) {
-      reportBuilder.addItem(PRODUCES_METHOD_SET_VALUES_RETURN_SET, reportBuilder.getSubject());
+      reportBuilder.addError(PRODUCES_METHOD_SET_VALUES_RETURN_SET, reportBuilder.getSubject());
     } else if (declaredType.getTypeArguments().isEmpty()) {
-      reportBuilder.addItem(formatErrorMessage(BINDING_METHOD_SET_VALUES_RAW_SET),
-          reportBuilder.getSubject());
+      reportBuilder.addError(
+          formatErrorMessage(BINDING_METHOD_SET_VALUES_RAW_SET), reportBuilder.getSubject());
     } else {
       validateSingleReturnType(reportBuilder,
           Iterables.getOnlyElement(declaredType.getTypeArguments()));
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
index 38d45e6a2..1666fbf8c 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
@@ -20,9 +20,11 @@
 import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Sets;
 import com.google.common.util.concurrent.ListenableFuture;
-import dagger.producers.Producer;
+import dagger.Provides;
 import dagger.producers.Produces;
+import java.util.Set;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.DeclaredType;
@@ -44,33 +46,26 @@
  */
 @AutoValue
 abstract class ProductionBinding extends ContributionBinding {
+
   @Override
-  ImmutableSet<DependencyRequest> implicitDependencies() {
-    return dependencies();
+  Binding.Type bindingType() {
+    return Binding.Type.PRODUCTION;
   }
 
-  enum Kind {
-    /** Represents a binding configured by {@link Produces} that doesn't return a future. */
-    IMMEDIATE,
-    /** Represents a binding configured by {@link Produces} that returns a future. */
-    FUTURE_PRODUCTION,
-    /**
-     * Represents a binding that is not explicitly tied to code, but generated implicitly by the
-     * framework.
-     */
-    SYNTHETIC_PRODUCTION,
-    /**
-     * Represents a binding from a production method on a component dependency that returns a
-     * future. Methods that return immediate values are considered provision bindings.
-     */
-    COMPONENT_PRODUCTION,
+  @Override
+  Provides.Type provisionType() {
+    return Provides.Type.valueOf(productionType().name());
   }
 
-  /**
-   * The type of binding (whether the {@link Produces} method returns a future). For the particular
-   * type of production, use {@link #productionType}.
-   */
-  abstract Kind bindingKind();
+  @Override
+  Set<DependencyRequest> implicitDependencies() {
+    // Similar optimizations to ContributionBinding.implicitDependencies().
+    if (!monitorRequest().isPresent()) {
+      return super.implicitDependencies();
+    } else {
+      return Sets.union(monitorRequest().asSet(), super.implicitDependencies());
+    }
+  }
 
   /** Returns provision type that was used to bind the key. */
   abstract Produces.Type productionType();
@@ -78,40 +73,31 @@
   /** Returns the list of types in the throws clause of the method. */
   abstract ImmutableList<? extends TypeMirror> thrownTypes();
 
+  /** If this production requires a monitor, this will be the corresponding request. */
+  abstract Optional<DependencyRequest> monitorRequest();
+
   @Override
-  BindingType bindingType() {
+  ContributionType contributionType() {
     switch (productionType()) {
       case SET:
       case SET_VALUES:
-        return BindingType.SET;
+        return ContributionType.SET;
       case MAP:
-        return BindingType.MAP;
+        return ContributionType.MAP;
       case UNIQUE:
-        return BindingType.UNIQUE;
+        return ContributionType.UNIQUE;
       default:
-        throw new IllegalStateException("Unknown production type: " + productionType());
+        throw new AssertionError("Unknown production type: " + productionType());
     }
   }
 
-  @Override
-  boolean isSyntheticBinding() {
-    return bindingKind().equals(Kind.SYNTHETIC_PRODUCTION);
-  }
-
-  @Override
-  Class<?> frameworkClass() {
-    return Producer.class;
-  }
-
   static final class Factory {
     private final Types types;
     private final Key.Factory keyFactory;
     private final DependencyRequest.Factory dependencyRequestFactory;
 
-    Factory(Types types,
-        Key.Factory keyFactory,
-        DependencyRequest.Factory
-        dependencyRequestFactory) {
+    Factory(
+        Types types, Key.Factory keyFactory, DependencyRequest.Factory dependencyRequestFactory) {
       this.types = types;
       this.keyFactory = keyFactory;
       this.dependencyRequestFactory = dependencyRequestFactory;
@@ -133,6 +119,8 @@ ProductionBinding forProducesMethod(
               declaredContainer,
               producesMethod.getParameters(),
               resolvedMethod.getParameterTypes());
+      DependencyRequest monitorRequest =
+          dependencyRequestFactory.forProductionComponentMonitorProvider();
       Kind kind = MoreTypes.isTypeOf(ListenableFuture.class, producesMethod.getReturnType())
           ? Kind.FUTURE_PRODUCTION
           : Kind.IMMEDIATE;
@@ -144,27 +132,35 @@ ProductionBinding forProducesMethod(
           false,
           ConfigurationAnnotations.getNullableType(producesMethod),
           Optional.of(MoreTypes.asTypeElement(declaredContainer)),
+          Optional.<DependencyRequest>absent(),
           kind,
           producesAnnotation.type(),
-          ImmutableList.copyOf(producesMethod.getThrownTypes()));
+          ImmutableList.copyOf(producesMethod.getThrownTypes()),
+          Optional.of(monitorRequest));
     }
 
-    ProductionBinding forImplicitMapBinding(DependencyRequest explicitRequest,
-        DependencyRequest implicitRequest) {
-      checkNotNull(explicitRequest);
-      checkNotNull(implicitRequest);
-      ImmutableSet<DependencyRequest> dependencies = ImmutableSet.of(implicitRequest);
+    ProductionBinding implicitMapOfProducerBinding(DependencyRequest mapOfValueRequest) {
+      checkNotNull(mapOfValueRequest);
+      Optional<Key> implicitMapOfProducerKey =
+          keyFactory.implicitMapProducerKeyFrom(mapOfValueRequest.key());
+      checkArgument(
+          implicitMapOfProducerKey.isPresent(), "%s is not for a Map<K, V>", mapOfValueRequest);
+      DependencyRequest implicitMapOfProducerRequest =
+          dependencyRequestFactory.forImplicitMapBinding(
+              mapOfValueRequest, implicitMapOfProducerKey.get());
       return new AutoValue_ProductionBinding(
-          explicitRequest.key(),
-          implicitRequest.requestElement(),
-          dependencies,
-          findBindingPackage(explicitRequest.key()),
+          mapOfValueRequest.key(),
+          implicitMapOfProducerRequest.requestElement(),
+          ImmutableSet.of(implicitMapOfProducerRequest),
+          findBindingPackage(mapOfValueRequest.key()),
           false,
           Optional.<DeclaredType>absent(),
           Optional.<TypeElement>absent(),
-          Kind.SYNTHETIC_PRODUCTION,
+          Optional.<DependencyRequest>absent(),
+          Kind.SYNTHETIC,
           Produces.Type.MAP,
-          ImmutableList.<TypeMirror>of());
+          ImmutableList.<TypeMirror>of(),
+          Optional.<DependencyRequest>absent());
     }
 
     ProductionBinding forComponentMethod(ExecutableElement componentMethod) {
@@ -180,9 +176,11 @@ ProductionBinding forComponentMethod(ExecutableElement componentMethod) {
           false,
           Optional.<DeclaredType>absent(),
           Optional.<TypeElement>absent(),
+          Optional.<DependencyRequest>absent(),
           Kind.COMPONENT_PRODUCTION,
           Produces.Type.UNIQUE,
-          ImmutableList.copyOf(componentMethod.getThrownTypes()));
+          ImmutableList.copyOf(componentMethod.getThrownTypes()),
+          Optional.<DependencyRequest>absent());
     }
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProductionComponentProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/ProductionComponentProcessingStep.java
index a424d12b4..0581b1bb1 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProductionComponentProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProductionComponentProcessingStep.java
@@ -18,9 +18,11 @@
 import com.google.auto.common.BasicAnnotationProcessor.ProcessingStep;
 import com.google.auto.common.MoreElements;
 import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Maps;
 import com.google.common.collect.SetMultimap;
 import dagger.producers.ProductionComponent;
 import java.lang.annotation.Annotation;
+import java.util.Map;
 import java.util.Set;
 import javax.annotation.processing.Messager;
 import javax.lang.model.element.Element;
@@ -35,45 +37,67 @@
 final class ProductionComponentProcessingStep extends AbstractComponentProcessingStep {
   private final Messager messager;
   private final ProductionComponentValidator componentValidator;
-  private final ComponentDescriptor.Factory componentDescriptorFactory;
+  private final BuilderValidator componentBuilderValidator;
 
   ProductionComponentProcessingStep(
       Messager messager,
       ProductionComponentValidator componentValidator,
+      BuilderValidator componentBuilderValidator,
+      ComponentHierarchyValidator componentHierarchyValidator,
       BindingGraphValidator bindingGraphValidator,
       ComponentDescriptor.Factory componentDescriptorFactory,
       BindingGraph.Factory bindingGraphFactory,
       ComponentGenerator componentGenerator) {
     super(
+        ProductionComponent.class,
         messager,
+        componentHierarchyValidator,
         bindingGraphValidator,
+        componentDescriptorFactory,
         bindingGraphFactory,
         componentGenerator);
     this.messager = messager;
     this.componentValidator = componentValidator;
-    this.componentDescriptorFactory = componentDescriptorFactory;
+    this.componentBuilderValidator = componentBuilderValidator;
   }
 
   @Override
   public Set<Class<? extends Annotation>> annotations() {
-    return ImmutableSet.<Class<? extends Annotation>>of(ProductionComponent.class);
+    return ImmutableSet.<Class<? extends Annotation>>of(
+        ProductionComponent.class, ProductionComponent.Builder.class);
   }
 
+  // TODO(beder): Move common logic into the AbstractComponentProcessingStep when implementing
+  // production subcomponents.
   @Override
-  protected ImmutableSet<ComponentDescriptor> componentDescriptors(
+  protected ComponentElementValidator componentElementValidator(
       SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
-    ImmutableSet.Builder<ComponentDescriptor> componentDescriptors = ImmutableSet.builder();
-    Set<Element> componentElements = elementsByAnnotation.get(ProductionComponent.class);
-    for (Element element : componentElements) {
-      TypeElement componentTypeElement = MoreElements.asType(element);
-      ValidationReport<TypeElement> componentReport =
-          componentValidator.validate(componentTypeElement);
-      componentReport.printMessagesTo(messager);
-      if (componentReport.isClean()) {
-        componentDescriptors.add(
-            componentDescriptorFactory.forProductionComponent(componentTypeElement));
+    final Map<Element, ValidationReport<TypeElement>> builderReportsByComponent =
+        processComponentBuilders(elementsByAnnotation.get(ProductionComponent.Builder.class));
+    return new ComponentElementValidator() {
+      @Override
+      boolean validateComponent(TypeElement componentTypeElement, Messager messager) {
+        ValidationReport<TypeElement> validationReport =
+            componentValidator.validate(componentTypeElement);
+        validationReport.printMessagesTo(messager);
+        if (!validationReport.isClean()) {
+          return false;
+        }
+        ValidationReport<?> builderReport = builderReportsByComponent.get(componentTypeElement);
+        return builderReport == null || builderReport.isClean();
       }
+    };
+  }
+
+  private Map<Element, ValidationReport<TypeElement>> processComponentBuilders(
+      Set<? extends Element> componentBuilderElements) {
+    Map<Element, ValidationReport<TypeElement>> builderReportsByComponent = Maps.newHashMap();
+    for (Element element : componentBuilderElements) {
+      ValidationReport<TypeElement> report =
+          componentBuilderValidator.validate(MoreElements.asType(element));
+      report.printMessagesTo(messager);
+      builderReportsByComponent.put(element.getEnclosingElement(), report);
     }
-    return componentDescriptors.build();
+    return builderReportsByComponent;
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProductionComponentValidator.java b/compiler/src/main/java/dagger/internal/codegen/ProductionComponentValidator.java
index 6107280e4..2e2291d34 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProductionComponentValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProductionComponentValidator.java
@@ -38,14 +38,14 @@
  *
  * @author Jesse Beder
  */
-final class ProductionComponentValidator implements Validator<TypeElement> {
-  @Override public ValidationReport<TypeElement> validate(final TypeElement subject) {
-    final ValidationReport.Builder<TypeElement> builder = ValidationReport.Builder.about(subject);
+final class ProductionComponentValidator {
+  ValidationReport<TypeElement> validate(final TypeElement subject) {
+    final ValidationReport.Builder<TypeElement> builder = ValidationReport.about(subject);
 
     if (!subject.getKind().equals(INTERFACE)
         && !(subject.getKind().equals(CLASS) && subject.getModifiers().contains(ABSTRACT))) {
-      builder.addItem("@ProductionComponent may only be applied to an interface or abstract class",
-          subject);
+      builder.addError(
+          "@ProductionComponent may only be applied to an interface or abstract class", subject);
     }
 
     AnnotationMirror componentMirror =
@@ -54,26 +54,30 @@
 
     // TODO(gak): make unused modules an error
     for (TypeMirror moduleType : moduleTypes) {
-      moduleType.accept(new SimpleTypeVisitor6<Void, Void>() {
-        @Override
-        protected Void defaultAction(TypeMirror mirror, Void p) {
-          builder.addItem(mirror + " is not a valid module type.", subject);
-          return null;
-        }
+      moduleType.accept(
+          new SimpleTypeVisitor6<Void, Void>() {
+            @Override
+            protected Void defaultAction(TypeMirror mirror, Void p) {
+              builder.addError(mirror + " is not a valid module type.", subject);
+              return null;
+            }
 
-        @Override
-        public Void visitDeclared(DeclaredType t, Void p) {
-          checkState(t.getTypeArguments().isEmpty());
-          TypeElement moduleElement = MoreElements.asType(t.asElement());
-          if (!getAnnotationMirror(moduleElement, Module.class).isPresent()
-              && !getAnnotationMirror(moduleElement, ProducerModule.class).isPresent()) {
-            builder.addItem(moduleElement.getQualifiedName()
-                + " is listed as a module, but is not annotated with @Module or @ProducerModule",
-                subject);
-          }
-          return null;
-        }
-      }, null);
+            @Override
+            public Void visitDeclared(DeclaredType t, Void p) {
+              checkState(t.getTypeArguments().isEmpty());
+              TypeElement moduleElement = MoreElements.asType(t.asElement());
+              if (!getAnnotationMirror(moduleElement, Module.class).isPresent()
+                  && !getAnnotationMirror(moduleElement, ProducerModule.class).isPresent()) {
+                builder.addError(
+                    moduleElement.getQualifiedName()
+                        + " is listed as a module, but is not annotated with @Module or"
+                        + " @ProducerModule",
+                    subject);
+              }
+              return null;
+            }
+          },
+          null);
     }
 
     return builder.build();
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java
index af2e1f0d6..e9c8b1629 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java
@@ -54,12 +54,12 @@
 import static javax.lang.model.type.TypeKind.VOID;
 
 /**
- * A {@link Validator} for {@link Provides} methods.
+ * A {@linkplain ValidationReport validator} for {@link Provides} methods.
  *
  * @author Gregory Kick
  * @since 2.0
  */
-final class ProvidesMethodValidator implements Validator<ExecutableElement> {
+final class ProvidesMethodValidator {
   private final Elements elements;
 
   ProvidesMethodValidator(Elements elements) {
@@ -70,45 +70,42 @@ private TypeElement getSetElement() {
     return elements.getTypeElement(Set.class.getCanonicalName());
   }
 
-  @Override
-  public ValidationReport<ExecutableElement> validate(ExecutableElement providesMethodElement) {
+  ValidationReport<ExecutableElement> validate(ExecutableElement providesMethodElement) {
     ValidationReport.Builder<ExecutableElement> builder =
-        ValidationReport.Builder.about(providesMethodElement);
+        ValidationReport.about(providesMethodElement);
 
     Provides providesAnnotation = providesMethodElement.getAnnotation(Provides.class);
     checkArgument(providesAnnotation != null);
 
     Element enclosingElement = providesMethodElement.getEnclosingElement();
     if (!isAnnotationPresent(enclosingElement, Module.class)) {
-      builder.addItem(formatModuleErrorMessage(BINDING_METHOD_NOT_IN_MODULE),
-          providesMethodElement);
+      builder.addError(
+          formatModuleErrorMessage(BINDING_METHOD_NOT_IN_MODULE), providesMethodElement);
     }
 
     if (!providesMethodElement.getTypeParameters().isEmpty()) {
-      builder.addItem(formatErrorMessage(BINDING_METHOD_TYPE_PARAMETER),
-          providesMethodElement);
+      builder.addError(formatErrorMessage(BINDING_METHOD_TYPE_PARAMETER), providesMethodElement);
     }
 
     Set<Modifier> modifiers = providesMethodElement.getModifiers();
     if (modifiers.contains(PRIVATE)) {
-      builder.addItem(formatErrorMessage(BINDING_METHOD_PRIVATE),
-          providesMethodElement);
+      builder.addError(formatErrorMessage(BINDING_METHOD_PRIVATE), providesMethodElement);
     }
     if (modifiers.contains(ABSTRACT)) {
-      builder.addItem(formatErrorMessage(BINDING_METHOD_ABSTRACT), providesMethodElement);
+      builder.addError(formatErrorMessage(BINDING_METHOD_ABSTRACT), providesMethodElement);
     }
 
     TypeMirror returnType = providesMethodElement.getReturnType();
     TypeKind returnTypeKind = returnType.getKind();
     if (returnTypeKind.equals(VOID)) {
-      builder.addItem(formatErrorMessage(BINDING_METHOD_MUST_RETURN_A_VALUE),
-          providesMethodElement);
+      builder.addError(
+          formatErrorMessage(BINDING_METHOD_MUST_RETURN_A_VALUE), providesMethodElement);
     }
 
     // check mapkey is right
     if (!providesAnnotation.type().equals(Provides.Type.MAP)
         && !getMapKeys(providesMethodElement).isEmpty()) {
-      builder.addItem(
+      builder.addError(
           formatErrorMessage(BINDING_METHOD_NOT_MAP_HAS_MAP_KEY), providesMethodElement);
     }
 
@@ -124,28 +121,28 @@ private TypeElement getSetElement() {
         ImmutableSet<? extends AnnotationMirror> mapKeys = getMapKeys(providesMethodElement);
         switch (mapKeys.size()) {
           case 0:
-            builder.addItem(
+            builder.addError(
                 formatErrorMessage(BINDING_METHOD_WITH_NO_MAP_KEY), providesMethodElement);
             break;
           case 1:
             break;
           default:
-            builder.addItem(
+            builder.addError(
                 formatErrorMessage(BINDING_METHOD_WITH_MULTIPLE_MAP_KEY), providesMethodElement);
             break;
         }
         break;
       case SET_VALUES:
         if (!returnTypeKind.equals(DECLARED)) {
-          builder.addItem(PROVIDES_METHOD_SET_VALUES_RETURN_SET, providesMethodElement);
+          builder.addError(PROVIDES_METHOD_SET_VALUES_RETURN_SET, providesMethodElement);
         } else {
           DeclaredType declaredReturnType = (DeclaredType) returnType;
           // TODO(gak): should we allow "covariant return" for set values?
           if (!declaredReturnType.asElement().equals(getSetElement())) {
-            builder.addItem(PROVIDES_METHOD_SET_VALUES_RETURN_SET, providesMethodElement);
+            builder.addError(PROVIDES_METHOD_SET_VALUES_RETURN_SET, providesMethodElement);
           } else if (declaredReturnType.getTypeArguments().isEmpty()) {
-            builder.addItem(formatErrorMessage(BINDING_METHOD_SET_VALUES_RAW_SET),
-                providesMethodElement);
+            builder.addError(
+                formatErrorMessage(BINDING_METHOD_SET_VALUES_RAW_SET), providesMethodElement);
           } else {
             validateKeyType(builder,
                 Iterables.getOnlyElement(declaredReturnType.getTypeArguments()));
@@ -165,7 +162,7 @@ static void validateMethodQualifiers(ValidationReport.Builder<ExecutableElement>
     ImmutableSet<? extends AnnotationMirror> qualifiers = getQualifiers(methodElement);
     if (qualifiers.size() > 1) {
       for (AnnotationMirror qualifier : qualifiers) {
-        builder.addItem(PROVIDES_OR_PRODUCES_METHOD_MULTIPLE_QUALIFIERS, methodElement, qualifier);
+        builder.addError(PROVIDES_OR_PRODUCES_METHOD_MULTIPLE_QUALIFIERS, methodElement, qualifier);
       }
     }
   }
@@ -182,7 +179,7 @@ private void validateKeyType(ValidationReport.Builder<? extends Element> reportB
       TypeMirror type) {
     TypeKind kind = type.getKind();
     if (!(kind.isPrimitive() || kind.equals(DECLARED) || kind.equals(ARRAY))) {
-      reportBuilder.addItem(PROVIDES_METHOD_RETURN_TYPE, reportBuilder.getSubject());
+      reportBuilder.addError(PROVIDES_METHOD_RETURN_TYPE, reportBuilder.getSubject());
     }
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
index aec51f038..b2ac74fb3 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
@@ -15,19 +15,14 @@
  */
 package dagger.internal.codegen;
 
-import com.google.auto.common.AnnotationMirrors;
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
-import com.google.common.base.Equivalence;
 import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Sets;
 import dagger.Provides;
-import java.util.Set;
 import javax.inject.Inject;
-import javax.inject.Provider;
-import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ElementKind;
 import javax.lang.model.element.ExecutableElement;
@@ -40,19 +35,15 @@
 import javax.lang.model.util.Types;
 
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
+import static com.google.auto.common.MoreTypes.asDeclared;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
 import static dagger.internal.codegen.InjectionAnnotations.getQualifier;
-import static dagger.internal.codegen.InjectionAnnotations.getScopeAnnotation;
-import static dagger.internal.codegen.ProvisionBinding.Kind.INJECTION;
-import static dagger.internal.codegen.ProvisionBinding.Kind.PROVISION;
-import static dagger.internal.codegen.Util.unwrapOptionalEquivalence;
-import static dagger.internal.codegen.Util.wrapOptionalInEquivalence;
+import static dagger.internal.codegen.Scope.scopeOf;
 import static javax.lang.model.element.ElementKind.CONSTRUCTOR;
 import static javax.lang.model.element.ElementKind.FIELD;
 import static javax.lang.model.element.ElementKind.METHOD;
-import static javax.lang.model.element.Modifier.STATIC;
 
 /**
  * A value object representing the mechanism by which a {@link Key} can be provided. New instances
@@ -63,98 +54,14 @@
  */
 @AutoValue
 abstract class ProvisionBinding extends ContributionBinding {
+  
   @Override
-  Set<DependencyRequest> implicitDependencies() {
-    // Optimization: If we don't need the memberInjectionRequest, don't create more objects.
-    if (!memberInjectionRequest().isPresent()) {
-      return dependencies();
-    } else {
-      // Optimization: Avoid creating an ImmutableSet+Builder just to union two things together.
-      return Sets.union(memberInjectionRequest().asSet(), dependencies());
-    }
-  }
-
-  enum Kind {
-    /** Represents an {@link Inject} binding. */
-    INJECTION,
-    /** Represents a binding configured by {@link Provides}. */
-    PROVISION,
-    /**
-     * Represents a binding that is not explicitly tied to code, but generated implicitly by the
-     * framework.
-     */
-    SYNTHETIC_PROVISON,
-    /** Represents the implicit binding to the component. */
-    COMPONENT,
-    /** Represents a binding from a provision method on a component dependency. */
-    COMPONENT_PROVISION,
-  }
-
-  /**
-   * The type of binding ({@link Inject} or {@link Provides}). For the particular type of provision,
-   * use {@link #provisionType}.
-   */
-  abstract Kind bindingKind();
-
-  /** Returns provision type that was used to bind the key. */
-  abstract Provides.Type provisionType();
-
-  /** The scope in which the binding declares the {@link #key()}. */
-  Optional<AnnotationMirror> scope() {
-    return unwrapOptionalEquivalence(wrappedScope());
+  Binding.Type bindingType() {
+    return Binding.Type.PROVISION;
   }
-
-  /**
-   * An optional annotation constraining the scope of this component wrapped in an
-   * {@link com.google.common.base.Equivalence.Wrapper} to preserve comparison semantics of
-   * {@link AnnotationMirror}.
-   */
-  abstract Optional<Equivalence.Wrapper<AnnotationMirror>> wrappedScope();
-
-  /** If this provision requires members injection, this will be the corresponding request. */
-  abstract Optional<DependencyRequest> memberInjectionRequest();
-
+  
   @Override
-  BindingType bindingType() {
-    switch (provisionType()) {
-      case SET:
-      case SET_VALUES:
-        return BindingType.SET;
-      case MAP:
-        return BindingType.MAP;
-      case UNIQUE:
-        return BindingType.UNIQUE;
-      default:
-        throw new IllegalStateException("Unknown provision type: " + provisionType());
-    }
-  }
-
-  @Override
-  boolean isSyntheticBinding() {
-    return bindingKind().equals(Kind.SYNTHETIC_PROVISON);
-  }
-
-  @Override
-  Class<?> frameworkClass() {
-    return Provider.class;
-  }
-
-  enum FactoryCreationStrategy {
-    ENUM_INSTANCE,
-    CLASS_CONSTRUCTOR,
-  }
-
-  FactoryCreationStrategy factoryCreationStrategy() {
-    if (bindingKind().equals(INJECTION) && implicitDependencies().isEmpty()) {
-      return FactoryCreationStrategy.ENUM_INSTANCE;
-    }
-    if (bindingKind().equals(PROVISION)
-        && implicitDependencies().isEmpty()
-        && bindingElement().getModifiers().contains(STATIC)) {
-      return FactoryCreationStrategy.ENUM_INSTANCE;
-    }
-    return FactoryCreationStrategy.CLASS_CONSTRUCTOR;
-  }
+  abstract Scope scope();
 
   static final class Factory {
     private final Elements elements;
@@ -211,8 +118,7 @@ ProvisionBinding forInjectConstructor(ExecutableElement constructorElement,
               cxtorType.getParameterTypes());
       Optional<DependencyRequest> membersInjectionRequest =
           membersInjectionRequest(enclosingCxtorType);
-      Optional<AnnotationMirror> scope =
-          getScopeAnnotation(constructorElement.getEnclosingElement());
+      Scope scope = Scope.scopeOf(constructorElement.getEnclosingElement());
 
       TypeElement bindingTypeElement =
           MoreElements.asType(constructorElement.getEnclosingElement());
@@ -225,10 +131,10 @@ ProvisionBinding forInjectConstructor(ExecutableElement constructorElement,
           hasNonDefaultTypeParameters(bindingTypeElement, key.type(), types),
           Optional.<DeclaredType>absent(),
           Optional.<TypeElement>absent(),
+          membersInjectionRequest,
           Kind.INJECTION,
           Provides.Type.UNIQUE,
-          wrapOptionalInEquivalence(AnnotationMirrors.equivalence(), scope),
-          membersInjectionRequest);
+          scope);
     }
 
     private static final ImmutableSet<ElementKind> MEMBER_KINDS =
@@ -264,7 +170,7 @@ ProvisionBinding forProvidesMethod(ExecutableElement providesMethod, TypeMirror
               declaredContainer,
               providesMethod.getParameters(),
               resolvedMethod.getParameterTypes());
-      Optional<AnnotationMirror> scope = getScopeAnnotation(providesMethod);
+      Scope scope = Scope.scopeOf(providesMethod);
       return new AutoValue_ProvisionBinding(
           key,
           providesMethod,
@@ -273,30 +179,35 @@ ProvisionBinding forProvidesMethod(ExecutableElement providesMethod, TypeMirror
           false /* no non-default parameter types */,
           ConfigurationAnnotations.getNullableType(providesMethod),
           Optional.of(MoreTypes.asTypeElement(declaredContainer)),
+          Optional.<DependencyRequest>absent(),
           Kind.PROVISION,
           providesAnnotation.type(),
-          wrapOptionalInEquivalence(AnnotationMirrors.equivalence(), scope),
-          Optional.<DependencyRequest>absent());
+          scope);
     }
 
-    ProvisionBinding forImplicitMapBinding(DependencyRequest explicitRequest,
-        DependencyRequest implicitRequest) {
-      checkNotNull(explicitRequest);
-      checkNotNull(implicitRequest);
-      ImmutableSet<DependencyRequest> dependencies = ImmutableSet.of(implicitRequest);
-      Optional<AnnotationMirror> scope = getScopeAnnotation(implicitRequest.requestElement());
+    ProvisionBinding implicitMapOfProviderBinding(DependencyRequest mapOfValueRequest) {
+      checkNotNull(mapOfValueRequest);
+      Optional<Key> implicitMapOfProviderKey =
+          keyFactory.implicitMapProviderKeyFrom(mapOfValueRequest.key());
+      checkArgument(
+          implicitMapOfProviderKey.isPresent(),
+          "%s is not a request for Map<K, V>",
+          mapOfValueRequest);
+      DependencyRequest implicitMapOfProviderRequest =
+          dependencyRequestFactory.forImplicitMapBinding(
+              mapOfValueRequest, implicitMapOfProviderKey.get());
       return new AutoValue_ProvisionBinding(
-          explicitRequest.key(),
-          implicitRequest.requestElement(),
-          dependencies,
-          findBindingPackage(explicitRequest.key()),
+          mapOfValueRequest.key(),
+          implicitMapOfProviderRequest.requestElement(),
+          ImmutableSet.of(implicitMapOfProviderRequest),
+          findBindingPackage(mapOfValueRequest.key()),
           false /* no non-default parameter types */,
           Optional.<DeclaredType>absent(),
           Optional.<TypeElement>absent(),
-          Kind.SYNTHETIC_PROVISON,
+          Optional.<DependencyRequest>absent(),
+          Kind.SYNTHETIC,
           Provides.Type.MAP,
-          wrapOptionalInEquivalence(AnnotationMirrors.equivalence(), scope),
-          Optional.<DependencyRequest>absent());
+          scopeOf(implicitMapOfProviderRequest.requestElement()));
     }
 
     ProvisionBinding forComponent(TypeElement componentDefinitionType) {
@@ -309,17 +220,17 @@ ProvisionBinding forComponent(TypeElement componentDefinitionType) {
           false /* no non-default parameter types */,
           Optional.<DeclaredType>absent(),
           Optional.<TypeElement>absent(),
+          Optional.<DependencyRequest>absent(),
           Kind.COMPONENT,
           Provides.Type.UNIQUE,
-          Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
-          Optional.<DependencyRequest>absent());
+          Scope.unscoped());
     }
 
     ProvisionBinding forComponentMethod(ExecutableElement componentMethod) {
       checkNotNull(componentMethod);
       checkArgument(componentMethod.getKind().equals(METHOD));
       checkArgument(componentMethod.getParameters().isEmpty());
-      Optional<AnnotationMirror> scope = getScopeAnnotation(componentMethod);
+      Scope scope = Scope.scopeOf(componentMethod);
       return new AutoValue_ProvisionBinding(
           keyFactory.forComponentMethod(componentMethod),
           componentMethod,
@@ -328,10 +239,30 @@ ProvisionBinding forComponentMethod(ExecutableElement componentMethod) {
           false /* no non-default parameter types */,
           ConfigurationAnnotations.getNullableType(componentMethod),
           Optional.<TypeElement>absent(),
+          Optional.<DependencyRequest>absent(),
           Kind.COMPONENT_PROVISION,
           Provides.Type.UNIQUE,
-          wrapOptionalInEquivalence(AnnotationMirrors.equivalence(), scope),
-          Optional.<DependencyRequest>absent());
+          scope);
+    }
+
+    ProvisionBinding forSubcomponentBuilderMethod(
+        ExecutableElement subcomponentBuilderMethod, TypeElement contributedBy) {
+      checkNotNull(subcomponentBuilderMethod);
+      checkArgument(subcomponentBuilderMethod.getKind().equals(METHOD));
+      checkArgument(subcomponentBuilderMethod.getParameters().isEmpty());
+      DeclaredType declaredContainer = asDeclared(contributedBy.asType());
+      return new AutoValue_ProvisionBinding(
+          keyFactory.forSubcomponentBuilderMethod(subcomponentBuilderMethod, declaredContainer),
+          subcomponentBuilderMethod,
+          ImmutableSet.<DependencyRequest>of(),
+          Optional.<String>absent(),
+          false /* no non-default parameter types */,
+          Optional.<DeclaredType>absent(),
+          Optional.of(contributedBy),
+          Optional.<DependencyRequest>absent(),
+          Kind.SUBCOMPONENT_BUILDER,
+          Provides.Type.UNIQUE,
+          Scope.unscoped());
     }
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvisionBindingFormatter.java b/compiler/src/main/java/dagger/internal/codegen/ProvisionBindingFormatter.java
deleted file mode 100644
index 92d031042..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/ProvisionBindingFormatter.java
+++ /dev/null
@@ -1,48 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen;
-
-import com.google.common.base.Optional;
-
-import static com.google.auto.common.MoreElements.asExecutable;
-import static com.google.auto.common.MoreTypes.asDeclared;
-
-/**
- * Formats a {@link ProvisionBinding} into a {@link String} suitable for use in error messages.
- *
- * @author Christian Gruber
- * @since 2.0
- */
-final class ProvisionBindingFormatter extends Formatter<ProvisionBinding> {
-  private final MethodSignatureFormatter methodSignatureFormatter;
-  
-  ProvisionBindingFormatter(MethodSignatureFormatter methodSignatureFormatter) { 
-    this.methodSignatureFormatter = methodSignatureFormatter;
-  }
-
-  @Override public String format(ProvisionBinding binding) {
-    switch (binding.bindingKind()) {
-      case PROVISION:
-        return methodSignatureFormatter.format(asExecutable(binding.bindingElement()),
-            Optional.of(asDeclared(binding.contributedBy().get().asType())));
-      case COMPONENT_PROVISION:
-        return methodSignatureFormatter.format(asExecutable(binding.bindingElement()));
-      default:
-        throw new UnsupportedOperationException(
-            "Not yet supporting " + binding.bindingKind() + " binding types.");
-    }
-  }
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java b/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
index e44ba4ca7..024097ef0 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
@@ -16,10 +16,17 @@
 package dagger.internal.codegen;
 
 import com.google.auto.value.AutoValue;
+import com.google.common.base.Optional;
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
-import java.util.Set;
+import com.google.common.collect.ImmutableSetMultimap;
+import com.google.common.collect.Iterables;
+import com.google.common.collect.Multimap;
 
+import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkState;
+import static dagger.internal.codegen.ContributionBinding.contributionTypeFor;
 
 /**
  * The collection of bindings that have been resolved for a binding key.
@@ -28,46 +35,194 @@
  */
 @AutoValue
 abstract class ResolvedBindings {
+  /**
+   * The binding key for which the {@link #bindings()} have been resolved.
+   */
   abstract BindingKey bindingKey();
-  abstract ImmutableSet<? extends Binding> ownedBindings();
-  abstract ImmutableSet<? extends Binding> bindings();
 
-  static ResolvedBindings create(
+  /**
+   * The component in which the bindings in {@link #ownedBindings()},
+   * {@link #ownedContributionBindings()}, and {@link #ownedMembersInjectionBinding()} were
+   * resolved.
+   */
+  abstract ComponentDescriptor owningComponent();
+
+  /**
+   * The contribution bindings for {@link #bindingKey()} that were resolved in
+   * {@link #owningComponent()} or its ancestor components, keyed by the component in which the
+   * binding was resolved. If {@link #bindingKey()}'s kind is not
+   * {@link BindingKey.Kind#CONTRIBUTION}, this is empty.
+   */
+  abstract ImmutableSetMultimap<ComponentDescriptor, ContributionBinding> allContributionBindings();
+
+  /**
+   * The members-injection bindings for {@link #bindingKey()} that were resolved in
+   * {@link #owningComponent()} or its ancestor components, keyed by the component in which the
+   * binding was resolved. If {@link #bindingKey()}'s kind is not
+   * {@link BindingKey.Kind#MEMBERS_INJECTION}, this is empty.
+   */
+  abstract ImmutableMap<ComponentDescriptor, MembersInjectionBinding> allMembersInjectionBindings();
+
+  /**
+   * All bindings for {@link #bindingKey()}, regardless of in which component they were resolved.
+   */
+  ImmutableSet<? extends Binding> bindings() {
+    switch (bindingKey().kind()) {
+      case CONTRIBUTION:
+        return contributionBindings();
+
+      case MEMBERS_INJECTION:
+        return ImmutableSet.copyOf(membersInjectionBinding().asSet());
+
+      default:
+        throw new AssertionError(bindingKey());
+    }
+  }
+
+  /**
+   * All bindings for {@link #bindingKey()} that were resolved in {@link #owningComponent()}.
+   */
+  ImmutableSet<? extends Binding> ownedBindings() {
+    switch (bindingKey().kind()) {
+      case CONTRIBUTION:
+        return ownedContributionBindings();
+
+      case MEMBERS_INJECTION:
+        return ImmutableSet.copyOf(ownedMembersInjectionBinding().asSet());
+
+      default:
+        throw new AssertionError(bindingKey());
+    }
+  }
+
+  /**
+   * All contribution bindings, regardless of owning component.
+   *
+   * @throws IllegalStateException if {@link #bindingKey()} is not a
+   * {@link BindingKey.Kind#CONTRIBUTION}.
+   */
+  ImmutableSet<ContributionBinding> contributionBindings() {
+    checkState(bindingKey().kind().equals(BindingKey.Kind.CONTRIBUTION));
+    return ImmutableSet.copyOf(allContributionBindings().values());
+  }
+
+  /**
+   * The contribution bindings that were resolved in {@link #owningComponent()}.
+   *
+   * @throws IllegalStateException if {@link #bindingKey()} is not a
+   * {@link BindingKey.Kind#CONTRIBUTION}.
+   */
+  ImmutableSet<ContributionBinding> ownedContributionBindings() {
+    checkState(bindingKey().kind().equals(BindingKey.Kind.CONTRIBUTION));
+    return allContributionBindings().get(owningComponent());
+  }
+
+  /**
+   * The members-injection binding, regardless of owning component.
+   *
+   * @throws IllegalStateException if {@link #bindingKey()} is not a
+   * {@link BindingKey.Kind#MEMBERS_INJECTION}.
+   */
+  Optional<MembersInjectionBinding> membersInjectionBinding() {
+    checkState(bindingKey().kind().equals(BindingKey.Kind.MEMBERS_INJECTION));
+    ImmutableSet<MembersInjectionBinding> membersInjectionBindings =
+        FluentIterable.from(allMembersInjectionBindings().values()).toSet();
+    return membersInjectionBindings.isEmpty()
+        ? Optional.<MembersInjectionBinding>absent()
+        : Optional.of(Iterables.getOnlyElement(membersInjectionBindings));
+  }
+
+  /**
+   * The members-injection binding that was resolved in {@link #owningComponent()}.
+   *
+   * @throws IllegalStateException if {@link #bindingKey()} is not a
+   * {@link BindingKey.Kind#MEMBERS_INJECTION}.
+   */
+  Optional<MembersInjectionBinding> ownedMembersInjectionBinding() {
+    checkState(bindingKey().kind().equals(BindingKey.Kind.MEMBERS_INJECTION));
+    return Optional.fromNullable(allMembersInjectionBindings().get(owningComponent()));
+  }
+
+  /**
+   * Creates a {@link ResolvedBindings} for contribution bindings.
+   */
+  static ResolvedBindings forContributionBindings(
       BindingKey bindingKey,
-      Set<? extends Binding> ownedBindings,
-      Set<? extends Binding> inheritedBindings) {
-    ImmutableSet<Binding> immutableOwnedBindings = ImmutableSet.copyOf(ownedBindings);
+      ComponentDescriptor owningComponent,
+      Multimap<ComponentDescriptor, ? extends ContributionBinding> contributionBindings) {
+    checkArgument(bindingKey.kind().equals(BindingKey.Kind.CONTRIBUTION));
     return new AutoValue_ResolvedBindings(
         bindingKey,
-        immutableOwnedBindings,
-        ImmutableSet.<Binding>builder()
-        .addAll(inheritedBindings)
-        .addAll(immutableOwnedBindings)
-        .build());
+        owningComponent,
+        ImmutableSetMultimap.<ComponentDescriptor, ContributionBinding>copyOf(contributionBindings),
+        ImmutableMap.<ComponentDescriptor, MembersInjectionBinding>of());
   }
 
-  static ResolvedBindings create(
+  /**
+   * Creates a {@link ResolvedBindings} for contribution bindings.
+   */
+  static ResolvedBindings forContributionBindings(
       BindingKey bindingKey,
-      Binding... ownedBindings) {
-    ImmutableSet<Binding> bindings = ImmutableSet.copyOf(ownedBindings);
-    return new AutoValue_ResolvedBindings(bindingKey, bindings, bindings);
+      ComponentDescriptor owningComponent,
+      ContributionBinding... ownedContributionBindings) {
+    return forContributionBindings(
+        bindingKey,
+        owningComponent,
+        ImmutableSetMultimap.<ComponentDescriptor, ContributionBinding>builder()
+            .putAll(owningComponent, ownedContributionBindings)
+            .build());
   }
 
-  @SuppressWarnings("unchecked")  // checked by validator
-  ImmutableSet<? extends ContributionBinding> ownedContributionBindings() {
-    checkState(bindingKey().kind().equals(BindingKey.Kind.CONTRIBUTION));
-    return (ImmutableSet<? extends ContributionBinding>) ownedBindings();
+  /**
+   * Creates a {@link ResolvedBindings} for members injection bindings.
+   */
+  static ResolvedBindings forMembersInjectionBinding(
+      BindingKey bindingKey,
+      ComponentDescriptor owningComponent,
+      MembersInjectionBinding ownedMembersInjectionBinding) {
+    checkArgument(bindingKey.kind().equals(BindingKey.Kind.MEMBERS_INJECTION));
+    return new AutoValue_ResolvedBindings(
+        bindingKey,
+        owningComponent,
+        ImmutableSetMultimap.<ComponentDescriptor, ContributionBinding>of(),
+        ImmutableMap.of(owningComponent, ownedMembersInjectionBinding));
   }
 
-  @SuppressWarnings("unchecked")  // checked by validator
-  ImmutableSet<? extends ContributionBinding> contributionBindings() {
-    checkState(bindingKey().kind().equals(BindingKey.Kind.CONTRIBUTION));
-    return (ImmutableSet<? extends ContributionBinding>) bindings();
+  /**
+   * Creates a {@link ResolvedBindings} appropriate for when there are no bindings for the key.
+   */
+  static ResolvedBindings noBindings(BindingKey bindingKey, ComponentDescriptor owningComponent) {
+    return new AutoValue_ResolvedBindings(
+        bindingKey,
+        owningComponent,
+        ImmutableSetMultimap.<ComponentDescriptor, ContributionBinding>of(),
+        ImmutableMap.<ComponentDescriptor, MembersInjectionBinding>of());
   }
 
-  @SuppressWarnings("unchecked")  // checked by validator
-  ImmutableSet<? extends MembersInjectionBinding> membersInjectionBindings() {
-    checkState(bindingKey().kind().equals(BindingKey.Kind.MEMBERS_INJECTION));
-    return (ImmutableSet<? extends MembersInjectionBinding>) bindings();
+  /**
+   * Returns a {@code ResolvedBindings} with the same {@link #bindingKey()} and {@link #bindings()}
+   * as this one, but no {@link #ownedBindings()}.
+   */
+  ResolvedBindings asInheritedIn(ComponentDescriptor owningComponent) {
+    return new AutoValue_ResolvedBindings(
+        bindingKey(), owningComponent, allContributionBindings(), allMembersInjectionBindings());
+  }
+
+  /**
+   * {@code true} if this is a multibindings contribution.
+   */
+  boolean isMultibindings() {
+    return bindingKey().kind().equals(BindingKey.Kind.CONTRIBUTION)
+        && !contributionBindings().isEmpty()
+        && contributionTypeFor(contributionBindings()).isMultibinding();
+  }
+
+  /**
+   * {@code true} if this is a unique contribution binding.
+   */
+  boolean isUniqueContribution() {
+    return bindingKey().kind().equals(BindingKey.Kind.CONTRIBUTION)
+        && !contributionBindings().isEmpty()
+        && !contributionTypeFor(contributionBindings()).isMultibinding();
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/Scope.java b/compiler/src/main/java/dagger/internal/codegen/Scope.java
new file mode 100644
index 000000000..bcb009d1e
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/Scope.java
@@ -0,0 +1,145 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.common.AnnotationMirrors;
+import com.google.auto.common.MoreTypes;
+import com.google.common.base.Optional;
+import com.google.common.base.Preconditions;
+import javax.annotation.Nullable;
+import javax.inject.Singleton;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.TypeElement;
+
+import static com.google.auto.common.MoreTypes.isTypeOf;
+import static dagger.internal.codegen.ErrorMessages.stripCommonTypePrefixes;
+import static dagger.internal.codegen.InjectionAnnotations.getScopeAnnotation;
+
+/**
+ * A representation of the scope (or lack of it) associated with a component, providing method
+ * or injection location.
+ */
+final class Scope {
+
+  /**
+   * An internal representation for an unscoped binding.
+   */
+  private static final Scope UNSCOPED = new Scope();
+
+  /**
+   * The underlying {@link AnnotationMirror} that represents the scope annotation.
+   */
+  @Nullable
+  private final AnnotationMirror annotationMirror;
+
+  private Scope(@Nullable AnnotationMirror annotationMirror) {
+    this.annotationMirror = annotationMirror;
+  }
+
+  private Scope() {
+    this(null);
+  }
+
+  /**
+   * Returns representation for an unscoped binding.
+   */
+  static Scope unscoped() {
+    return UNSCOPED;
+  }
+
+  /**
+   * If the source code element has an associated scoped annotation then returns a representation
+   * of that scope, otherwise returns a representation for an unscoped binding.
+   */
+  static Scope scopeOf(Element element) {
+    Optional<AnnotationMirror> scopeAnnotation = getScopeAnnotation(element);
+    return scopeAnnotation.isPresent() ? new Scope(scopeAnnotation.get()) : UNSCOPED;
+  }
+
+  /**
+   * Returns true if the scope is present, i.e. it's not unscoped binding.
+   */
+  public boolean isPresent() {
+    return annotationMirror != null;
+  }
+
+  /**
+   * Returns true if the scope represents the {@link Singleton @Singleton} annotation.
+   */
+  public boolean isSingleton() {
+    return annotationMirror != null
+        && isTypeOf(Singleton.class, annotationMirror.getAnnotationType());
+  }
+
+  /**
+   * Returns the readable source representation (name with @ prefix) of the annotation type.
+   *
+   * <p>It's readable source because it has had common package prefixes removed, e.g.
+   * {@code @javax.inject.Singleton} is returned as {@code @Singleton}.
+   *
+   * <p>Make sure that the scope is actually {@link #isPresent() present} before calling as it will
+   * throw an {@link IllegalStateException} otherwise. This does not return any annotation values
+   * as according to {@link javax.inject.Scope} scope annotations are not supposed to use them.
+   */
+  public String getReadableSource() {
+    return stripCommonTypePrefixes("@" + getQualifiedName());
+  }
+
+  /**
+   * Returns the fully qualified name of the annotation type.
+   *
+   * <p>Make sure that the scope is actually {@link #isPresent() present} before calling as it will
+   * throw an {@link IllegalStateException} otherwise. This does not return any annotation values
+   * as according to {@link javax.inject.Scope} scope annotations are not supposed to use them.
+   */
+  public String getQualifiedName() {
+    Preconditions.checkState(annotationMirror != null,
+        "Cannot create a stripped source representation of no annotation");
+    TypeElement typeElement = MoreTypes.asTypeElement(annotationMirror.getAnnotationType());
+    return typeElement.getQualifiedName().toString();
+  }
+
+  /**
+   * Scopes are equal if the underlying {@link AnnotationMirror} are equivalent according to
+   * {@link AnnotationMirrors#equivalence()}.
+   */
+  @Override
+  public boolean equals(Object obj) {
+    if (this == obj) {
+      return true;
+    } else if (obj instanceof Scope) {
+      Scope that = (Scope) obj;
+      return AnnotationMirrors.equivalence()
+        .equivalent(this.annotationMirror, that.annotationMirror);
+    } else {
+      return false;
+    }
+  }
+
+  @Override
+  public int hashCode() {
+    return AnnotationMirrors.equivalence().hash(annotationMirror);
+  }
+
+  /**
+   * Returns a debug representation of the scope.
+   */
+  @Override
+  public String toString() {
+    return annotationMirror == null ? "UNSCOPED" : annotationMirror.toString();
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerationException.java b/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerationException.java
index 6ea9729d1..c2620981a 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerationException.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerationException.java
@@ -35,7 +35,7 @@
  * @author Gregory Kick
  * @since 2.0
  */
-final class SourceFileGenerationException extends Exception implements PrintableErrorMessage {
+final class SourceFileGenerationException extends Exception {
   private final ImmutableSet<ClassName> generatedClassNames;
   private final Optional<? extends Element> associatedElement;
 
@@ -71,8 +71,7 @@ private static String createMessage(Iterable<ClassName> generatedClassNames, Str
         message);
   }
 
-  @Override
-  public void printMessageTo(Messager messager) {
+  void printMessageTo(Messager messager) {
     if (associatedElement.isPresent()) {
       messager.printMessage(ERROR, getMessage(), associatedElement.get());
     } else {
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerator.java b/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerator.java
index 13430c670..4b6efc0ea 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerator.java
@@ -48,7 +48,8 @@
 
   final void generate(T input) throws SourceFileGenerationException {
     ClassName generatedTypeName = nameGeneratedType(input);
-    ImmutableSet<Element> originatingElements = ImmutableSet.copyOf(getOriginatingElements(input));
+    ImmutableSet<Element> originatingElements =
+        ImmutableSet.<Element>copyOf(getOriginatingElements(input));
     try {
       ImmutableSet<JavaWriter> writers = write(generatedTypeName, input);
       for (JavaWriter javaWriter : writers) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
index 57c815b23..7ad0acbc4 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
@@ -23,7 +23,6 @@
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Ordering;
 import dagger.internal.DoubleCheckLazy;
-import dagger.internal.codegen.ContributionBinding.BindingType;
 import dagger.internal.codegen.writer.ClassName;
 import dagger.internal.codegen.writer.ParameterizedTypeName;
 import dagger.internal.codegen.writer.Snippet;
@@ -31,7 +30,6 @@
 import dagger.internal.codegen.writer.TypeNames;
 import java.util.Collection;
 import java.util.Iterator;
-import java.util.List;
 import java.util.Map;
 import java.util.Map.Entry;
 import javax.lang.model.element.ExecutableElement;
@@ -40,6 +38,7 @@
 import javax.lang.model.util.Types;
 
 import static com.google.common.base.CaseFormat.UPPER_CAMEL;
+import static com.google.common.base.Preconditions.checkArgument;
 
 /**
  * Utilities for generating files.
@@ -184,107 +183,121 @@ static Snippet frameworkTypeUsageStatement(Snippet frameworkTypeMemberSelect,
         throw new AssertionError();
     }
   }
-
-  static ClassName factoryNameForProvisionBinding(ProvisionBinding binding) {
-    TypeElement enclosingTypeElement = binding.bindingTypeElement();
-    ClassName enclosingClassName = ClassName.fromTypeElement(enclosingTypeElement);
-    switch (binding.bindingKind()) {
-      case INJECTION:
+  
+  /**
+   * Returns the generated factory or members injector name for a binding.
+   */
+  static ClassName generatedClassNameForBinding(Binding binding) {
+    switch (binding.bindingType()) {
       case PROVISION:
-        return enclosingClassName.topLevelClassName().peerNamed(
-            enclosingClassName.classFileName() + "_" + factoryPrefix(binding) + "Factory");
-      case SYNTHETIC_PROVISON:
-        throw new IllegalArgumentException();
+      case PRODUCTION:
+        ContributionBinding contribution = (ContributionBinding) binding;
+        checkArgument(!contribution.isSyntheticBinding());
+        ClassName enclosingClassName = ClassName.fromTypeElement(contribution.bindingTypeElement());
+        switch (contribution.bindingKind()) {
+          case INJECTION:
+          case PROVISION:
+          case IMMEDIATE:
+          case FUTURE_PRODUCTION:
+            return enclosingClassName
+                .topLevelClassName()
+                .peerNamed(
+                    enclosingClassName.classFileName()
+                        + "_"
+                        + factoryPrefix(contribution)
+                        + "Factory");
+
+          default:
+            throw new AssertionError();
+        }
+
+      case MEMBERS_INJECTION:
+        return membersInjectorNameForType(binding.bindingTypeElement());
+
       default:
         throw new AssertionError();
     }
   }
 
   /**
-   * Returns the factory name parameterized with the ProvisionBinding's parameters (if necessary).
+   * Returns the generated factory or members injector name parameterized with the proper type
+   * parameters if necessary.
    */
-  static TypeName parameterizedFactoryNameForProvisionBinding(
-      ProvisionBinding binding) {
-    ClassName factoryName = factoryNameForProvisionBinding(binding);
-    List<TypeName> parameters = ImmutableList.of();
-    if (binding.bindingType().equals(BindingType.UNIQUE)) {
-      switch(binding.bindingKind()) {
-        case INJECTION:
-          TypeName bindingName = TypeNames.forTypeMirror(binding.key().type());
-          // If the binding is parameterized, parameterize the factory.
-          if (bindingName instanceof ParameterizedTypeName) {
-            parameters = ((ParameterizedTypeName) bindingName).parameters();
-          }
-          break;
-        case PROVISION:
-          // For provision bindings, we parameterize creation on the types of
-          // the module, not the types of the binding.
-          // Consider: Module<A, B, C> { @Provides List<B> provideB(B b) { .. }}
-          // The binding is just parameterized on <B>, but we need all of <A, B, C>.
-          if (!binding.bindingTypeElement().getTypeParameters().isEmpty()) {
-            parameters = ((ParameterizedTypeName) TypeNames.forTypeMirror(
-                binding.bindingTypeElement().asType())).parameters();
-          }
-          break;
-        default: // fall through.
-      }
-    }
-    return parameters.isEmpty() ? factoryName
-        : ParameterizedTypeName.create(factoryName, parameters);
+  static TypeName parameterizedGeneratedTypeNameForBinding(Binding binding) {
+    return generatedClassNameForBinding(binding).withTypeParameters(bindingTypeParameters(binding));
   }
+  
+  private static ImmutableList<TypeName> bindingTypeParameters(Binding binding)
+      throws AssertionError {
+    TypeMirror bindingType;
+    switch (binding.bindingType()) {
+      case PROVISION:
+      case PRODUCTION:
+        ContributionBinding contributionBinding = (ContributionBinding) binding;
+        if (contributionBinding.contributionType().isMultibinding()) {
+          return ImmutableList.of();
+        }
+        switch (contributionBinding.bindingKind()) {
+          case INJECTION:
+            bindingType = contributionBinding.key().type();
+            break;
+            
+          case PROVISION:
+            // For provision bindings, we parameterize creation on the types of
+            // the module, not the types of the binding.
+            // Consider: Module<A, B, C> { @Provides List<B> provideB(B b) { .. }}
+            // The binding is just parameterized on <B>, but we need all of <A, B, C>.
+            bindingType = contributionBinding.bindingTypeElement().asType();
+            break;
+            
+          case IMMEDIATE:
+          case FUTURE_PRODUCTION:
+            // TODO(beder): Can these be treated just like PROVISION?
+            throw new UnsupportedOperationException();
+            
+          default:
+            return ImmutableList.of();
+        }
+        break;
+
+      case MEMBERS_INJECTION:
+        bindingType = binding.key().type();
+        break;
 
-  static ClassName factoryNameForProductionBinding(ProductionBinding binding) {
-    TypeElement enclosingTypeElement = binding.bindingTypeElement();
-    ClassName enclosingClassName = ClassName.fromTypeElement(enclosingTypeElement);
-    switch (binding.bindingKind()) {
-      case IMMEDIATE:
-      case FUTURE_PRODUCTION:
-        return enclosingClassName.topLevelClassName().peerNamed(
-            enclosingClassName.classFileName() + "_" + factoryPrefix(binding) + "Factory");
       default:
         throw new AssertionError();
     }
+    TypeName bindingTypeName = TypeNames.forTypeMirror(bindingType);
+    return bindingTypeName instanceof ParameterizedTypeName
+        ? ((ParameterizedTypeName) bindingTypeName).parameters()
+        : ImmutableList.<TypeName>of();
   }
-
-  /**
-   * Returns the members injector's name parameterized with the binding's parameters (if necessary).
-   */
-  static TypeName parameterizedMembersInjectorNameForMembersInjectionBinding(
-      MembersInjectionBinding binding) {
-    ClassName factoryName = membersInjectorNameForMembersInjectionBinding(binding);
-    TypeName bindingName = TypeNames.forTypeMirror(binding.key().type());
-    // If the binding is parameterized, parameterize the MembersInjector.
-    if (bindingName instanceof ParameterizedTypeName) {
-      return ParameterizedTypeName.create(factoryName,
-          ((ParameterizedTypeName) bindingName).parameters());
-    }
-    return factoryName;
+  
+  static ClassName membersInjectorNameForType(TypeElement typeElement) {
+    ClassName injectedClassName = ClassName.fromTypeElement(typeElement);
+    return injectedClassName
+        .topLevelClassName()
+        .peerNamed(injectedClassName.classFileName() + "_MembersInjector");
   }
 
-  static ClassName membersInjectorNameForMembersInjectionBinding(MembersInjectionBinding binding) {
-    ClassName injectedClassName = ClassName.fromTypeElement(binding.bindingElement());
-    return injectedClassName.topLevelClassName().peerNamed(
-        injectedClassName.classFileName() + "_MembersInjector");
+  static ClassName generatedMonitoringModuleName(TypeElement componentElement) {
+    ClassName componentName = ClassName.fromTypeElement(componentElement);
+    return componentName
+        .topLevelClassName()
+        .peerNamed(componentName.classFileName() + "_MonitoringModule");
   }
 
-  private static String factoryPrefix(ProvisionBinding binding) {
+  private static String factoryPrefix(ContributionBinding binding) {
     switch (binding.bindingKind()) {
       case INJECTION:
         return "";
-      case PROVISION:
-        return CaseFormat.LOWER_CAMEL.to(UPPER_CAMEL,
-            ((ExecutableElement) binding.bindingElement()).getSimpleName().toString());
-      default:
-        throw new IllegalArgumentException();
-    }
-  }
 
-  private static String factoryPrefix(ProductionBinding binding) {
-    switch (binding.bindingKind()) {
+      case PROVISION:
       case IMMEDIATE:
       case FUTURE_PRODUCTION:
-        return CaseFormat.LOWER_CAMEL.to(UPPER_CAMEL,
-            ((ExecutableElement) binding.bindingElement()).getSimpleName().toString());
+        return CaseFormat.LOWER_CAMEL.to(
+            UPPER_CAMEL, ((ExecutableElement) binding.bindingElement()).getSimpleName().toString());
+
       default:
         throw new IllegalArgumentException();
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/SubcomponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/SubcomponentWriter.java
new file mode 100644
index 000000000..128766872
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/SubcomponentWriter.java
@@ -0,0 +1,210 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.common.MoreTypes;
+import com.google.common.base.CaseFormat;
+import com.google.common.base.Optional;
+import com.google.common.collect.ImmutableList;
+import dagger.internal.codegen.ComponentDescriptor.BuilderSpec;
+import dagger.internal.codegen.ComponentGenerator.MemberSelect;
+import dagger.internal.codegen.writer.ClassName;
+import dagger.internal.codegen.writer.ClassWriter;
+import dagger.internal.codegen.writer.FieldWriter;
+import dagger.internal.codegen.writer.MethodWriter;
+import dagger.internal.codegen.writer.Snippet;
+import dagger.internal.codegen.writer.TypeName;
+import dagger.internal.codegen.writer.TypeNames;
+import java.util.List;
+import java.util.Set;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.ExecutableType;
+import javax.lang.model.type.TypeMirror;
+
+import static com.google.common.base.CaseFormat.LOWER_CAMEL;
+import static com.google.common.base.Verify.verify;
+import static com.google.common.collect.Sets.difference;
+import static dagger.internal.codegen.AbstractComponentWriter.InitializationState.UNINITIALIZED;
+import static javax.lang.model.element.Modifier.FINAL;
+import static javax.lang.model.element.Modifier.PRIVATE;
+import static javax.lang.model.element.Modifier.PUBLIC;
+
+/**
+ * Creates the nested implementation class for a subcomponent.
+ */
+class SubcomponentWriter extends AbstractComponentWriter {
+
+  private AbstractComponentWriter parent;
+  private ExecutableElement subcomponentFactoryMethod;
+
+  public SubcomponentWriter(
+      AbstractComponentWriter parent,
+      ExecutableElement subcomponentFactoryMethod,
+      BindingGraph subgraph) {
+    super(
+        parent.types,
+        parent.elements,
+        parent.keyFactory,
+        parent.nullableValidationType,
+        parent.name.nestedClassNamed(subcomponentSimpleName(subgraph)),
+        subgraph);
+    this.parent = parent;
+    this.subcomponentFactoryMethod = subcomponentFactoryMethod;
+  }
+
+  private static String subcomponentSimpleName(BindingGraph subgraph) {
+    return subgraph.componentDescriptor().componentDefinitionType().getSimpleName() + "Impl";
+  }
+  
+  @Override
+  protected InitializationState getInitializationState(BindingKey bindingKey) {
+    InitializationState initializationState = super.getInitializationState(bindingKey);
+    return initializationState.equals(UNINITIALIZED)
+        ? parent.getInitializationState(bindingKey)
+        : initializationState;
+  }
+
+  @Override
+  protected Optional<Snippet> getOrCreateComponentContributionFieldSnippet(
+      TypeElement contributionType) {
+    return super.getOrCreateComponentContributionFieldSnippet(contributionType)
+        .or(parent.getOrCreateComponentContributionFieldSnippet(contributionType));
+  }
+
+  @Override
+  protected MemberSelect getMemberSelect(BindingKey key) {
+    MemberSelect memberSelect = super.getMemberSelect(key);
+    return memberSelect == null ? parent.getMemberSelect(key) : memberSelect;
+  }
+
+  @Override
+  protected Optional<MemberSelect> getMultibindingContributionSnippet(ContributionBinding binding) {
+    return super.getMultibindingContributionSnippet(binding)
+        .or(parent.getMultibindingContributionSnippet(binding));
+  }
+
+  private ExecutableType resolvedSubcomponentFactoryMethod() {
+    return MoreTypes.asExecutable(
+        types.asMemberOf(
+            MoreTypes.asDeclared(parent.componentDefinitionType().asType()),
+            subcomponentFactoryMethod));
+  }
+
+  @Override
+  protected ClassWriter createComponentClass() {
+    ClassWriter componentWriter = parent.componentWriter.addNestedClass(name.simpleName());
+    componentWriter.addModifiers(PRIVATE, FINAL);
+    componentWriter.setSupertype(
+        MoreTypes.asTypeElement(
+            graph.componentDescriptor().builderSpec().isPresent()
+                ? graph
+                    .componentDescriptor()
+                    .builderSpec()
+                    .get()
+                    .componentType()
+                : resolvedSubcomponentFactoryMethod().getReturnType()));
+    return componentWriter;
+  }
+
+  @Override
+  protected void addBuilder() {
+    // Only write subcomponent builders if there is a spec.
+    if (graph.componentDescriptor().builderSpec().isPresent()) {
+      super.addBuilder();
+    }
+  }
+
+  @Override
+  protected ClassWriter createBuilder() {
+    // Only write subcomponent builders if there is a spec.
+    verify(graph.componentDescriptor().builderSpec().isPresent());
+    return parent.componentWriter.addNestedClass(
+        componentDefinitionTypeName().simpleName() + "Builder");
+  }
+
+  @Override
+  protected void addFactoryMethods() {
+    MethodWriter componentMethod;
+    if (graph.componentDescriptor().builderSpec().isPresent()) {
+      BuilderSpec spec = graph.componentDescriptor().builderSpec().get();
+      componentMethod =
+          parent.componentWriter.addMethod(
+              spec.builderDefinitionType().asType(),
+              subcomponentFactoryMethod.getSimpleName().toString());
+      componentMethod.body().addSnippet("return new %s();", builderName.get());
+    } else {
+      ExecutableType resolvedMethod = resolvedSubcomponentFactoryMethod();
+      componentMethod =
+          parent.componentWriter.addMethod(
+              resolvedMethod.getReturnType(), subcomponentFactoryMethod.getSimpleName().toString());
+      writeSubcomponentWithoutBuilder(componentMethod, resolvedMethod);
+    }
+    componentMethod.addModifiers(PUBLIC);
+    componentMethod.annotate(Override.class);
+  }
+
+  private void writeSubcomponentWithoutBuilder(
+      MethodWriter componentMethod, ExecutableType resolvedMethod) {
+    ImmutableList.Builder<Snippet> subcomponentConstructorParameters = ImmutableList.builder();
+    List<? extends VariableElement> params = subcomponentFactoryMethod.getParameters();
+    List<? extends TypeMirror> paramTypes = resolvedMethod.getParameterTypes();
+    for (int i = 0; i < params.size(); i++) {
+      VariableElement moduleVariable = params.get(i);
+      TypeElement moduleTypeElement = MoreTypes.asTypeElement(paramTypes.get(i));
+      TypeName moduleType = TypeNames.forTypeMirror(paramTypes.get(i));
+      componentMethod.addParameter(moduleType, moduleVariable.getSimpleName().toString());
+      if (!componentContributionFields.containsKey(moduleTypeElement)) {
+        String preferredModuleName =
+            CaseFormat.UPPER_CAMEL.to(LOWER_CAMEL, moduleTypeElement.getSimpleName().toString());
+        FieldWriter contributionField =
+            componentWriter.addField(moduleTypeElement, preferredModuleName);
+        contributionField.addModifiers(PRIVATE, FINAL);
+        String actualModuleName = contributionField.name();
+        constructorWriter.addParameter(moduleType, actualModuleName);
+        constructorWriter.body()
+            .addSnippet("if (%s == null) {", actualModuleName)
+            .addSnippet("  throw new NullPointerException();")
+            .addSnippet("}");
+        constructorWriter.body().addSnippet("this.%1$s = %1$s;", actualModuleName);
+        MemberSelect moduleSelect =
+            MemberSelect.instanceSelect(name, Snippet.format(actualModuleName));
+        componentContributionFields.put(moduleTypeElement, moduleSelect);
+        subcomponentConstructorParameters.add(Snippet.format("%s", moduleVariable.getSimpleName()));
+      }
+    }
+
+    Set<TypeElement> uninitializedModules =
+        difference(graph.componentRequirements(), componentContributionFields.keySet());
+    
+    for (TypeElement moduleType : uninitializedModules) {
+      String preferredModuleName =
+          CaseFormat.UPPER_CAMEL.to(LOWER_CAMEL, moduleType.getSimpleName().toString());
+      FieldWriter contributionField = componentWriter.addField(moduleType, preferredModuleName);
+      contributionField.addModifiers(PRIVATE, FINAL);
+      String actualModuleName = contributionField.name();
+      constructorWriter.body().addSnippet("this.%s = new %s();",
+          actualModuleName, ClassName.fromTypeElement(moduleType));
+      MemberSelect moduleSelect =
+          MemberSelect.instanceSelect(name, Snippet.format(actualModuleName));
+      componentContributionFields.put(moduleType, moduleSelect);
+    }
+
+    componentMethod.body().addSnippet("return new %s(%s);",
+        name, Snippet.makeParametersSnippet(subcomponentConstructorParameters.build()));
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/Util.java b/compiler/src/main/java/dagger/internal/codegen/Util.java
index 1eca18f68..8c1aba399 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Util.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Util.java
@@ -16,29 +16,25 @@
  */
 package dagger.internal.codegen;
 
-import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.common.base.Equivalence;
 import com.google.common.base.Equivalence.Wrapper;
 import com.google.common.base.Optional;
-import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.ImmutableSet.Builder;
-import com.google.common.collect.Iterables;
-import com.google.common.collect.Lists;
-import java.util.Iterator;
-import java.util.List;
+import dagger.producers.Produced;
 import java.util.Map;
+import java.util.Set;
+import javax.inject.Provider;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.DeclaredType;
-import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
-import javax.lang.model.util.ElementFilter;
 import javax.lang.model.util.Elements;
 
+import static com.google.auto.common.MoreElements.getLocalAndInheritedMethods;
+import static com.google.auto.common.MoreTypes.asDeclared;
 import static com.google.common.base.Preconditions.checkState;
 import static javax.lang.model.element.ElementKind.CONSTRUCTOR;
 import static javax.lang.model.element.Modifier.ABSTRACT;
@@ -50,12 +46,12 @@
  */
 final class Util {
   /**
-   * Returns the {@code V} type for a {@link Map} type like Map<K, Provider<V>>} if the map
+   * Returns the {@code V} type for a {@link Map} type like {@code Map<K, Provider<V>>} if the map
    * includes such a construction
    */
   public static TypeMirror getProvidedValueTypeOfMap(DeclaredType mapType) {
     checkState(MoreTypes.isTypeOf(Map.class, mapType), "%s is not a Map.", mapType);
-    return MoreTypes.asDeclared(mapType.getTypeArguments().get(1)).getTypeArguments().get(0);
+    return asDeclared(mapType.getTypeArguments().get(1)).getTypeArguments().get(0);
   }
 
   // TODO(cgruber): Consider an object that holds and exposes the various parts of a Map type.
@@ -64,17 +60,40 @@ public static TypeMirror getProvidedValueTypeOfMap(DeclaredType mapType) {
    */
   public static TypeMirror getValueTypeOfMap(DeclaredType mapType) {
     checkState(MoreTypes.isTypeOf(Map.class, mapType), "%s is not a Map.", mapType);
-    List<? extends TypeMirror> mapArgs = mapType.getTypeArguments();
-    return mapArgs.get(1);
+    return mapType.getTypeArguments().get(1);
   }
 
   /**
    * Returns the key type for a {@link Map} type like Map<K, Provider<V>>}
    */
-  public static DeclaredType getKeyTypeOfMap(DeclaredType mapType) {
+  public static TypeMirror getKeyTypeOfMap(DeclaredType mapType) {
     checkState(MoreTypes.isTypeOf(Map.class, mapType), "%s is not a Map.", mapType);
-    List<? extends TypeMirror> mapArgs = mapType.getTypeArguments();
-    return MoreTypes.asDeclared(mapArgs.get(0));
+    return mapType.getTypeArguments().get(0);
+  }
+
+  /**
+   * Returns true if {@code type} is a {@link Map} whose value type is not a {@link Provider}.
+   */
+  public static boolean isMapWithNonProvidedValues(TypeMirror type) {
+    return MoreTypes.isType(type)
+        && MoreTypes.isTypeOf(Map.class, type)
+        && !MoreTypes.isTypeOf(Provider.class, asDeclared(type).getTypeArguments().get(1));
+  }
+
+  /**
+   * Returns true if {@code type} is a {@link Map} whose value type is a {@link Provider}.
+   */
+  public static boolean isMapWithProvidedValues(TypeMirror type) {
+    return MoreTypes.isType(type)
+        && MoreTypes.isTypeOf(Map.class, type)
+        && MoreTypes.isTypeOf(Provider.class, asDeclared(type).getTypeArguments().get(1));
+  }
+
+  /** Returns true if {@code type} is a {@code Set<Produced<T>>}. */
+  static boolean isSetOfProduced(TypeMirror type) {
+    return MoreTypes.isType(type)
+        && MoreTypes.isTypeOf(Set.class, type)
+        && MoreTypes.isTypeOf(Produced.class, MoreTypes.asDeclared(type).getTypeArguments().get(0));
   }
 
   /**
@@ -150,67 +169,10 @@ static boolean componentCanMakeNewInstances(TypeElement typeElement) {
     return false;
   }
 
-  /*
-   * Borrowed from AutoValue and slightly modified. TODO(gak): reconcile and put in autocommon.
-   */
-  private static ImmutableList<ExecutableElement> findLocalAndInheritedMethods(Elements elements,
-      TypeElement type) {
-    List<ExecutableElement> methods = Lists.newArrayList();
-    TypeElement objectType = elements.getTypeElement(Object.class.getName());
-    findLocalAndInheritedMethodsRecursive(objectType, elements, type, methods);
-    return ImmutableList.copyOf(methods);
-  }
-
-  private static void findLocalAndInheritedMethodsRecursive(
-      TypeElement objectType,
-      Elements elements,
-      TypeElement type,
-      List<ExecutableElement> methods) {
-    if (objectType.equals(type)) {
-      return;
-    }
-
-    for (TypeMirror superInterface : type.getInterfaces()) {
-      findLocalAndInheritedMethodsRecursive(objectType,
-          elements, MoreElements.asType(MoreTypes.asElement(superInterface)), methods);
-    }
-    if (type.getSuperclass().getKind() != TypeKind.NONE) {
-      // Visit the superclass after superinterfaces so we will always see the implementation of a
-      // method after any interfaces that declared it.
-      findLocalAndInheritedMethodsRecursive(objectType,
-          elements, MoreElements.asType(MoreTypes.asElement(type.getSuperclass())), methods);
-    }
-    // Add each method of this class, and in so doing remove any inherited method it overrides.
-    // This algorithm is quadratic in the number of methods but it's hard to see how to improve
-    // that while still using Elements.overrides.
-    List<ExecutableElement> theseMethods = ElementFilter.methodsIn(type.getEnclosedElements());
-    for (ExecutableElement method : theseMethods) {
-      if (!method.getModifiers().contains(Modifier.PRIVATE)) {
-        boolean alreadySeen = false;
-        for (Iterator<ExecutableElement> methodIter = methods.iterator(); methodIter.hasNext();) {
-          ExecutableElement otherMethod = methodIter.next();
-          if (elements.overrides(method, otherMethod, type)) {
-            methodIter.remove();
-          } else if (method.getSimpleName().equals(otherMethod.getSimpleName())
-              && method.getParameters().equals(otherMethod.getParameters())) {
-            // If we inherit this method on more than one path, we don't want to add it twice.
-            alreadySeen = true;
-          }
-        }
-        if (!alreadySeen) {
-          methods.add(method);
-        }
-      }
-    }
-  }
-
-  /*
-   * Borrowed from AutoValue and slightly modified. TODO(gak): reconcile and put in autocommon.
-   */
   static ImmutableSet<ExecutableElement> getUnimplementedMethods(
       Elements elements, TypeElement type) {
     ImmutableSet.Builder<ExecutableElement> unimplementedMethods = ImmutableSet.builder();
-    List<ExecutableElement> methods = findLocalAndInheritedMethods(elements, type);
+    Set<ExecutableElement> methods = getLocalAndInheritedMethods(type, elements);
     for (ExecutableElement method : methods) {
       if (method.getModifiers().contains(Modifier.ABSTRACT)) {
         unimplementedMethods.add(method);
diff --git a/compiler/src/main/java/dagger/internal/codegen/ValidationReport.java b/compiler/src/main/java/dagger/internal/codegen/ValidationReport.java
index d9e9daef7..e17406755 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ValidationReport.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ValidationReport.java
@@ -21,23 +21,37 @@
 import javax.annotation.processing.Messager;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.util.SimpleElementVisitor6;
+import javax.tools.Diagnostic;
 import javax.tools.Diagnostic.Kind;
 
 import static javax.tools.Diagnostic.Kind.ERROR;
+import static javax.tools.Diagnostic.Kind.NOTE;
+import static javax.tools.Diagnostic.Kind.WARNING;
 
 /**
  * A collection of items describing contractual issues with the code as presented to an annotation
- * processor.  A "clean" report (i.e. with no issues) is a report with no {@linkplain Item items}.
- * Callers will typically print the results of the report to a {@link Messager} instance using
- * {@link #printMessagesTo}.
+ * processor.  A "clean" report (i.e. with no issues) is a report with no {@linkplain Item items}
+ * and clean subreports. Callers will typically print the results of the report to a
+ * {@link Messager} instance using {@link #printMessagesTo}.
+ *
+ * <p>A report describes a subject {@link Element}.  Callers may choose to add report items about
+ * other elements that are contained within or related to the subject. Since {@link Diagnostic}
+ * reporting is expected to be associated with elements that are currently being compiled,
+ * {@link #printMessagesTo(Messager)} will only associate messages with non-subject elements if they
+ * are contained within the subject. Otherwise, they will be associated with the subject and contain
+ * a reference to the item's element in the message string. It is the responsibility of the caller
+ * to choose subjects that are part of the compilation.
  *
  * @author Gregory Kick
  * @since 2.0
  */
 @AutoValue
-abstract class ValidationReport<T> {
+abstract class ValidationReport<T extends Element> {
   abstract T subject();
   abstract ImmutableSet<Item> items();
+  abstract ImmutableSet<ValidationReport<?>> subreports();
 
   boolean isClean() {
     for (Item item : items()) {
@@ -48,39 +62,80 @@ boolean isClean() {
           break;
       }
     }
+    for (ValidationReport<?> subreport : subreports()) {
+      if (!subreport.isClean()) {
+        return false;
+      }
+    }
     return true;
   }
 
   void printMessagesTo(Messager messager) {
     for (Item item : items()) {
-      item.printMessageTo(messager);
+      if (isEnclosedIn(subject(), item.element())) {
+        if (item.annotation().isPresent()) {
+          messager.printMessage(
+              item.kind(), item.message(), item.element(), item.annotation().get());
+        } else {
+          messager.printMessage(item.kind(), item.message(), item.element());
+        }
+      } else {
+        String message = String.format("[%s] %s", elementString(item.element()), item.message());
+        if (item.annotation().isPresent()) {
+          messager.printMessage(item.kind(), message, subject(), item.annotation().get());
+        } else {
+          messager.printMessage(item.kind(), message, subject());
+        }
+      }
+    }
+    for (ValidationReport<?> subreport : subreports()) {
+      subreport.printMessagesTo(messager);
     }
   }
 
+  private static String elementString(Element element) {
+    return element.accept(
+        new SimpleElementVisitor6<String, Void>() {
+          @Override
+          protected String defaultAction(Element e, Void p) {
+            return e.toString();
+          }
+
+          @Override
+          public String visitExecutable(ExecutableElement e, Void p) {
+            return e.getEnclosingElement().accept(this, null) + '.' + e.toString();
+          }
+        },
+        null);
+  }
+
+  private static boolean isEnclosedIn(Element parent, Element child) {
+    Element current = child;
+    while (current != null) {
+      if (current.equals(parent)) {
+        return true;
+      }
+      current = current.getEnclosingElement();
+    }
+    return false;
+  }
+
   @AutoValue
-  static abstract class Item implements PrintableErrorMessage {
+  static abstract class Item {
     abstract String message();
     abstract Kind kind();
     abstract Element element();
     abstract Optional<AnnotationMirror> annotation();
-
-    @Override
-    public void printMessageTo(Messager messager) {
-      if (annotation().isPresent()) {
-        messager.printMessage(kind(), message(), element(), annotation().get());
-      } else {
-        messager.printMessage(kind(), message(), element());
-      }
-    }
   }
 
-  static final class Builder<T> {
-    static <T> Builder<T> about(T subject) {
-      return new Builder<T>(subject);
-    }
+  static <T extends Element> Builder<T> about(T subject) {
+    return new Builder<T>(subject);
+  }
 
+  static final class Builder<T extends Element> {
     private final T subject;
     private final ImmutableSet.Builder<Item> items = ImmutableSet.builder();
+    private final ImmutableSet.Builder<ValidationReport<?>> subreports = ImmutableSet.builder();
 
     private Builder(T subject) {
       this.subject = subject;
@@ -89,27 +144,62 @@ private Builder(T subject) {
     T getSubject() {
       return subject;
     }
-    
+
     Builder<T> addItems(Iterable<Item> newItems) {
       items.addAll(newItems);
       return this;
     }
 
-    Builder<T> addItem(String message, Element element) {
-      addItem(message, ERROR, element, Optional.<AnnotationMirror>absent());
+    Builder<T> addError(String message) {
+      addItem(message, ERROR, subject, Optional.<AnnotationMirror>absent());
       return this;
     }
 
-    Builder<T> addItem(String message, Kind kind, Element element) {
-      addItem(message, kind, element, Optional.<AnnotationMirror>absent());
+    Builder<T> addError(String message, Element element) {
+      addItem(message, ERROR, element, Optional.<AnnotationMirror>absent());
       return this;
     }
 
-    Builder<T> addItem(String message, Element element, AnnotationMirror annotation) {
+    Builder<T> addError(String message, Element element, AnnotationMirror annotation) {
       addItem(message, ERROR, element, Optional.of(annotation));
       return this;
     }
 
+    Builder<T> addWarning(String message) {
+      addItem(message, WARNING, subject, Optional.<AnnotationMirror>absent());
+      return this;
+    }
+
+    Builder<T> addWarning(String message, Element element) {
+      addItem(message, WARNING, element, Optional.<AnnotationMirror>absent());
+      return this;
+    }
+
+    Builder<T> addWarning(String message, Element element, AnnotationMirror annotation) {
+      addItem(message, WARNING, element, Optional.of(annotation));
+      return this;
+    }
+
+    Builder<T> addNote(String message) {
+      addItem(message, NOTE, subject, Optional.<AnnotationMirror>absent());
+      return this;
+    }
+
+    Builder<T> addNote(String message, Element element) {
+      addItem(message, NOTE, element, Optional.<AnnotationMirror>absent());
+      return this;
+    }
+
+    Builder<T> addNote(String message, Element element, AnnotationMirror annotation) {
+      addItem(message, NOTE, element, Optional.of(annotation));
+      return this;
+    }
+
+    Builder<T> addItem(String message, Kind kind, Element element) {
+      addItem(message, kind, element, Optional.<AnnotationMirror>absent());
+      return this;
+    }
+
     Builder<T> addItem(String message, Kind kind, Element element, AnnotationMirror annotation) {
       addItem(message, kind, element, Optional.of(annotation));
       return this;
@@ -121,8 +211,13 @@ T getSubject() {
       return this;
     }
 
+    Builder<T> addSubreport(ValidationReport<?> subreport) {
+      subreports.add(subreport);
+      return this;
+    }
+
     ValidationReport<T> build() {
-      return new AutoValue_ValidationReport<T>(subject, items.build());
+      return new AutoValue_ValidationReport<T>(subject, items.build(), subreports.build());
     }
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/Validator.java b/compiler/src/main/java/dagger/internal/codegen/Validator.java
deleted file mode 100644
index 615f863c0..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/Validator.java
+++ /dev/null
@@ -1,25 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen;
-
-/**
- * Validates a given subject and produces a {@link ValidationReport} containing the result.
- *
- * @param <T> the type of the {@linkplain ValidationReport#subject} of validation
- */
-interface Validator<T> {
-  ValidationReport<T> validate(T subject);
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/AnnotationWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/AnnotationWriter.java
index b2cb45134..8dbf27bc3 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/AnnotationWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/AnnotationWriter.java
@@ -15,9 +15,10 @@
  */
 package dagger.internal.codegen.writer;
 
-import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.FluentIterable;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Maps;
+import com.google.common.collect.Sets;
 import java.io.IOException;
 import java.util.Map.Entry;
 import java.util.Set;
@@ -27,6 +28,7 @@
 
 public final class AnnotationWriter implements Writable, HasClassReferences {
   private final ClassName annotationName;
+  private final Set<HasClassReferences> memberReferences = Sets.newLinkedHashSet();
   private final SortedMap<String, Writable> memberMap = Maps.newTreeMap();
 
   AnnotationWriter(ClassName annotationName) {
@@ -45,6 +47,12 @@ public void setMember(String name, String value) {
     memberMap.put(name, toStringWritable(StringLiteral.forValue(value)));
   }
 
+  public <T extends Enum<T>> void setMember(String name, T value) {
+    Snippet snippet = Snippet.format("%s.%s", ClassName.fromClass(value.getClass()), value);
+    memberMap.put(name, snippet);
+    memberReferences.add(snippet);
+  }
+
   @Override
   public Appendable write(Appendable appendable, Context context) throws IOException {
     appendable.append('@');
@@ -65,6 +73,9 @@ public Appendable write(Appendable appendable, Context context) throws IOExcepti
 
   @Override
   public Set<ClassName> referencedClasses() {
-    return ImmutableSet.of(annotationName);
+    return FluentIterable.from(memberReferences)
+        .append(annotationName)
+        .transformAndConcat(HasClassReferences.COMBINER)
+        .toSet();
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/ClassName.java b/compiler/src/main/java/dagger/internal/codegen/writer/ClassName.java
index 0b2615e9a..bd0791fc6 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/ClassName.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/ClassName.java
@@ -95,11 +95,23 @@ public String canonicalName() {
     return fullyQualifiedName;
   }
 
+  /**
+   * Equivalent to {@link #classFileName(char) classFileName('$')}
+   */
   public String classFileName() {
+    return classFileName('$');
+  }
+
+  /**
+   * Returns the class name (excluding package).
+   *
+   * <p>The returned value includes the names of its enclosing classes (if any) but not the package
+   * name. e.g. {@code fromClass(Map.Entry.class).classFileName('_')} will return {@code Map_Entry}.
+   */
+  public String classFileName(char separator) {
     StringBuilder builder = new StringBuilder();
-    Joiner.on('$').appendTo(builder, enclosingSimpleNames());
-    if (!enclosingSimpleNames().isEmpty()) {
-      builder.append('$');
+    for (String enclosingSimpleName : enclosingSimpleNames) {
+      builder.append(enclosingSimpleName).append(separator);
     }
     return builder.append(simpleName()).toString();
   }
@@ -115,7 +127,6 @@ public ClassName topLevelClassName() {
   public ClassName nestedClassNamed(String memberClassName) {
     checkNotNull(memberClassName);
     checkArgument(SourceVersion.isIdentifier(memberClassName));
-    checkArgument(Ascii.isUpperCase(memberClassName.charAt(0)));
     return new ClassName(packageName(),
         new ImmutableList.Builder<String>()
             .addAll(enclosingSimpleNames())
@@ -127,10 +138,17 @@ public ClassName nestedClassNamed(String memberClassName) {
   public ClassName peerNamed(String peerClassName) {
     checkNotNull(peerClassName);
     checkArgument(SourceVersion.isIdentifier(peerClassName));
-    checkArgument(Ascii.isUpperCase(peerClassName.charAt(0)));
     return new ClassName(packageName(), enclosingSimpleNames(), peerClassName);
   }
 
+  /**
+   * Returns a parameterized type name with this as its raw type if {@code parameters} is not empty.
+   * If {@code parameters} is empty, returns this object.
+   */
+  public TypeName withTypeParameters(List<? extends TypeName> parameters) {
+    return parameters.isEmpty() ? this : ParameterizedTypeName.create(this, parameters);
+  }
+
   private static final ImmutableSet<NestingKind> ACCEPTABLE_NESTING_KINDS =
       Sets.immutableEnumSet(TOP_LEVEL, MEMBER);
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/ClassWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/ClassWriter.java
index 95ddf0c39..edaba3a2d 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/ClassWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/ClassWriter.java
@@ -138,17 +138,16 @@ private boolean isDefaultConstructor(ConstructorWriter constructorWriter) {
 
   @Override
   public Set<ClassName> referencedClasses() {
-    @SuppressWarnings("unchecked")
-    Iterable<? extends HasClassReferences> concat =
-        Iterables.concat(nestedTypeWriters, fieldWriters.values(), constructorWriters,
-            methodWriters, implementedTypes, superclass.asSet(), annotations, typeParameters);
-    return FluentIterable.from(concat)
-        .transformAndConcat(new Function<HasClassReferences, Set<ClassName>>() {
-          @Override
-          public Set<ClassName> apply(HasClassReferences input) {
-            return input.referencedClasses();
-          }
-        })
+    return FluentIterable.from(ImmutableList.<HasClassReferences>of())
+        .append(nestedTypeWriters)
+        .append(fieldWriters.values())
+        .append(constructorWriters)
+        .append(methodWriters)
+        .append(implementedTypes)
+        .append(superclass.asSet())
+        .append(annotations)
+        .append(typeParameters)
+        .transformAndConcat(HasClassReferences.COMBINER)
         .toSet();
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/ConstructorWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/ConstructorWriter.java
index f4a2c15f7..387c1ddf1 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/ConstructorWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/ConstructorWriter.java
@@ -15,11 +15,9 @@
  */
 package dagger.internal.codegen.writer;
 
-import com.google.common.base.Function;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
-import com.google.common.collect.Iterables;
 import com.google.common.collect.Maps;
 import java.io.IOException;
 import java.util.Map;
@@ -78,19 +76,17 @@ private VariableWriter addParameter(ClassName type, String name) {
 
   @Override
   public Set<ClassName> referencedClasses() {
-    return FluentIterable.from(
-        Iterables.concat(parameterWriters.values(), ImmutableList.of(blockWriter)))
-            .transformAndConcat(new Function<HasClassReferences, Set<ClassName>>() {
-              @Override
-              public Set<ClassName> apply(HasClassReferences input) {
-                return input.referencedClasses();
-              }
-            })
-            .toSet();
+    return FluentIterable.from(ImmutableList.<HasClassReferences>of())
+        .append(parameterWriters.values())
+        .append(annotations)
+        .append(blockWriter)
+        .transformAndConcat(HasClassReferences.COMBINER)
+        .toSet();
   }
 
   @Override
   public Appendable write(Appendable appendable, Context context) throws IOException {
+    writeAnnotations(appendable, context);
     writeModifiers(appendable).append(name).append('(');
     Writables.join(", ", parameterWriters.values(), appendable, context);
     appendable.append(") {");
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/EnumWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/EnumWriter.java
index cb0d75e73..4ab017d79 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/EnumWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/EnumWriter.java
@@ -18,7 +18,6 @@
 import com.google.common.base.Function;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
-import com.google.common.collect.Iterables;
 import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
 import com.google.common.collect.Sets;
@@ -123,17 +122,15 @@ private boolean isDefaultConstructor(ConstructorWriter constructorWriter) {
 
   @Override
   public Set<ClassName> referencedClasses() {
-    @SuppressWarnings("unchecked")
-    Iterable<? extends HasClassReferences> concat =
-        Iterables.concat(nestedTypeWriters, constantWriters.values(), fieldWriters.values(),
-            constructorWriters, methodWriters, implementedTypes, annotations);
-    return FluentIterable.from(concat)
-        .transformAndConcat(new Function<HasClassReferences, Set<ClassName>>() {
-          @Override
-          public Set<ClassName> apply(HasClassReferences input) {
-            return input.referencedClasses();
-          }
-        })
+    return FluentIterable.from(ImmutableList.<HasClassReferences>of())
+        .append(nestedTypeWriters)
+        .append(constantWriters.values())
+        .append(fieldWriters.values())
+        .append(constructorWriters)
+        .append(methodWriters)
+        .append(implementedTypes)
+        .append(annotations)
+        .transformAndConcat(HasClassReferences.COMBINER)
         .toSet();
   }
 
@@ -170,12 +167,7 @@ public Appendable write(Appendable appendable, Context context) throws IOExcepti
     @Override
     public Set<ClassName> referencedClasses() {
       return FluentIterable.from(constructorSnippets)
-          .transformAndConcat(new Function<Snippet, Set<ClassName>>() {
-            @Override
-            public Set<ClassName> apply(Snippet input) {
-              return input.referencedClasses();
-            }
-          })
+          .transformAndConcat(HasClassReferences.COMBINER)
           .toSet();
     }
   }
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/HasClassReferences.java b/compiler/src/main/java/dagger/internal/codegen/writer/HasClassReferences.java
index 15b412068..e463ea2cb 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/HasClassReferences.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/HasClassReferences.java
@@ -15,8 +15,17 @@
  */
 package dagger.internal.codegen.writer;
 
+import com.google.common.base.Function;
 import java.util.Set;
 
 public interface HasClassReferences {
   Set<ClassName> referencedClasses();
+
+  static final Function<HasClassReferences, Set<ClassName>> COMBINER =
+      new Function<HasClassReferences, Set<ClassName>>() {
+        @Override
+        public Set<ClassName> apply(HasClassReferences input) {
+          return input.referencedClasses();
+        }
+      };
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/InterfaceWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/InterfaceWriter.java
index 5eac8a9ee..ffcfc7562 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/InterfaceWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/InterfaceWriter.java
@@ -18,7 +18,7 @@
 import com.google.common.base.Function;
 import com.google.common.base.Joiner;
 import com.google.common.collect.FluentIterable;
-import com.google.common.collect.Iterables;
+import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Lists;
 import java.io.IOException;
 import java.util.Iterator;
@@ -76,16 +76,12 @@ public Appendable write(Appendable appendable, Context context) throws IOExcepti
 
   @Override
   public Set<ClassName> referencedClasses() {
-    @SuppressWarnings("unchecked")
-    Iterable<? extends HasClassReferences> concat =
-        Iterables.concat(nestedTypeWriters, methodWriters, implementedTypes, annotations);
-    return FluentIterable.from(concat)
-        .transformAndConcat(new Function<HasClassReferences, Set<ClassName>>() {
-          @Override
-          public Set<ClassName> apply(HasClassReferences input) {
-            return input.referencedClasses();
-          }
-        })
+    return FluentIterable.from(ImmutableList.<HasClassReferences>of())
+        .append(nestedTypeWriters)
+        .append(methodWriters)
+        .append(implementedTypes)
+        .append(annotations)
+        .transformAndConcat(HasClassReferences.COMBINER)
         .toSet();
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/JavaWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/JavaWriter.java
index 4fa5a3fc9..5977371ac 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/JavaWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/JavaWriter.java
@@ -26,9 +26,13 @@
 import com.google.common.collect.Lists;
 import com.google.common.collect.Ordering;
 import com.google.common.collect.Sets;
-import com.google.common.io.Closer;
+import com.google.common.io.CharSink;
+import com.google.common.io.CharSource;
+import com.google.googlejavaformat.java.Formatter;
+import com.google.googlejavaformat.java.FormatterException;
 import dagger.internal.codegen.writer.Writable.Context;
 import java.io.IOException;
+import java.io.Writer;
 import java.util.ArrayDeque;
 import java.util.Deque;
 import java.util.List;
@@ -97,7 +101,7 @@ public InterfaceWriter addInterface(String simpleName) {
     return writer;
   }
 
-  public Appendable write(Appendable appendable) throws IOException {
+  public <A extends Appendable> A write(A appendable) throws IOException {
     if (!packageName.isEmpty()) {
       appendable.append("package ").append(packageName).append(";\n\n");
     }
@@ -173,20 +177,19 @@ public void file(Filer filer, Iterable<? extends Element> originatingElements)
 
   public void file(Filer filer, CharSequence name,  Iterable<? extends Element> originatingElements)
       throws IOException {
-    JavaFileObject sourceFile = filer.createSourceFile(name,
+    final JavaFileObject sourceFile = filer.createSourceFile(name,
         Iterables.toArray(originatingElements, Element.class));
-    Closer closer = Closer.create();
     try {
-      write(closer.register(sourceFile.openWriter()));
-    } catch (Exception e) {
-      try {
-        sourceFile.delete();
-      } catch (Exception e2) {
-        // couldn't delete the file
-      }
-      throw closer.rethrow(e);
-    } finally {
-      closer.close();
+      new Formatter().formatSource(
+          CharSource.wrap(write(new StringBuilder())),
+          new CharSink() {
+            @Override public Writer openStream() throws IOException {
+              return sourceFile.openWriter();
+            }
+          });
+    } catch (FormatterException e) {
+      throw new IllegalStateException(
+          "The writer produced code that could not be parsed by the formatter", e);
     }
   }
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/MethodWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/MethodWriter.java
index 7831fe816..eb4ff8d51 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/MethodWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/MethodWriter.java
@@ -15,7 +15,6 @@
  */
 package dagger.internal.codegen.writer;
 
-import com.google.common.base.Function;
 import com.google.common.base.Optional;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
@@ -111,14 +110,12 @@ public Appendable write(Appendable appendable, Context context) throws IOExcepti
 
   @Override
   public Set<ClassName> referencedClasses() {
-    return FluentIterable.from(
-        Iterables.concat(ImmutableList.of(returnType), parameterWriters.values(), body.asSet()))
-            .transformAndConcat(new Function<HasClassReferences, Set<ClassName>>() {
-              @Override
-              public Set<ClassName> apply(HasClassReferences input) {
-                return input.referencedClasses();
-              }
-            })
-            .toSet();
+    return FluentIterable.from(ImmutableList.<HasClassReferences>of())
+        .append(parameterWriters.values())
+        .append(returnType)
+        .append(body.asSet())
+        .append(annotations)
+        .transformAndConcat(HasClassReferences.COMBINER)
+        .toSet();
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/ParameterizedTypeName.java b/compiler/src/main/java/dagger/internal/codegen/writer/ParameterizedTypeName.java
index 63cf3dd95..e46a96186 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/ParameterizedTypeName.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/ParameterizedTypeName.java
@@ -31,7 +31,7 @@
 
   ParameterizedTypeName(ClassName type, Iterable<? extends TypeName> parameters) {
     this.type = type;
-    this.parameters = ImmutableList.copyOf(parameters);
+    this.parameters = ImmutableList.<TypeName>copyOf(parameters);
   }
   
   public ClassName type() {
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/Snippet.java b/compiler/src/main/java/dagger/internal/codegen/writer/Snippet.java
index 50dc91838..80ab944f8 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/Snippet.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/Snippet.java
@@ -27,28 +27,9 @@
 import java.util.Iterator;
 import java.util.Set;
 
-public final class Snippet implements HasClassReferences, Writable {
-  private final String format;
-  private final ImmutableSet<TypeName> types;
-  private final ImmutableList<Object> args;
-
-  private Snippet(String format, ImmutableSet<TypeName> types, ImmutableList<Object> args) {
-    this.format = format;
-    this.types = types;
-    this.args = args;
-  }
-
-  public String format() {
-    return format;
-  }
+public abstract class Snippet implements HasClassReferences, Writable {
 
-  public ImmutableList<Object> args() {
-    return args;
-  }
-
-  public ImmutableSet<TypeName> types() {
-    return types;
-  }
+  abstract ImmutableSet<TypeName> types();
 
   @Override
   public String toString() {
@@ -56,40 +37,96 @@ public String toString() {
   }
 
   @Override
-  public Set<ClassName> referencedClasses() {
-    return FluentIterable.from(types)
-        .transformAndConcat(new Function<TypeName, Set<ClassName>>() {
-          @Override
-          public Set<ClassName> apply(TypeName input) {
-            return input.referencedClasses();
-          }
-        })
+  public final Set<ClassName> referencedClasses() {
+    return FluentIterable.from(types())
+        .transformAndConcat(
+            new Function<TypeName, Set<ClassName>>() {
+              @Override
+              public Set<ClassName> apply(TypeName input) {
+                return input.referencedClasses();
+              }
+            })
         .toSet();
   }
 
-  @Override
-  public Appendable write(Appendable appendable, Context context) throws IOException {
-    ImmutableList.Builder<Object> formattedArgsBuilder = ImmutableList.builder();
-    for (Object arg : args) {
-      if (arg instanceof Writable) {
-        formattedArgsBuilder.add(((Writable) arg).write(new StringBuilder(), context).toString());
-      } else {
-        formattedArgsBuilder.add(arg);
+  private static final class BasicSnippet extends Snippet {
+    final String format;
+    final ImmutableSet<TypeName> types;
+    final ImmutableList<Object> args;
+
+    BasicSnippet(String format, ImmutableSet<TypeName> types, ImmutableList<Object> args) {
+      this.format = format;
+      this.types = types;
+      this.args = args;
+    }
+
+    @Override
+    ImmutableSet<TypeName> types() {
+      return types;
+    }
+
+    @Override
+    public Appendable write(Appendable appendable, Context context) throws IOException {
+      ImmutableList.Builder<Object> formattedArgsBuilder = ImmutableList.builder();
+      for (Object arg : args) {
+        if (arg instanceof Writable) {
+          formattedArgsBuilder.add(((Writable) arg).write(new StringBuilder(), context).toString());
+        } else {
+          formattedArgsBuilder.add(arg);
+        }
       }
+
+      @SuppressWarnings("resource") // intentionally don't close the formatter
+      Formatter formatter = new Formatter(appendable);
+      formatter.format(format, Iterables.toArray(formattedArgsBuilder.build(), Object.class));
+
+      return appendable;
     }
+  }
 
-    @SuppressWarnings("resource") // intentionally don't close the formatter
-    Formatter formatter = new Formatter(appendable);
-    formatter.format(format, formattedArgsBuilder.build().toArray(new Object[0]));
+  private static final class CompoundSnippet extends Snippet {
+    final String joinToken;
+    final ImmutableList<Snippet> snippets;
+
+    CompoundSnippet(String joinToken, ImmutableList<Snippet> snippets) {
+      this.joinToken = joinToken;
+      this.snippets = snippets;
+    }
 
-    return appendable;
+    @Override
+    ImmutableSet<TypeName> types() {
+      return FluentIterable.from(snippets)
+          .transformAndConcat(
+              new Function<Snippet, Iterable<TypeName>>() {
+                @Override
+                public Iterable<TypeName> apply(Snippet input) {
+                  return input.types();
+                }
+              })
+          .toSet();
+    }
+
+    @Override
+    public Appendable write(Appendable appendable, Context context) throws IOException {
+      Iterator<Snippet> snippetIterator = snippets.iterator();
+      if (snippetIterator.hasNext()) {
+        Snippet firstSnippet = snippetIterator.next();
+        firstSnippet.write(appendable, context);
+        while (snippetIterator.hasNext()) {
+          Snippet nextSnippet = snippetIterator.next();
+          appendable.append(joinToken);
+          nextSnippet.write(appendable, context);
+        }
+      }
+      return appendable;
+    }
   }
 
   public static Snippet format(String format, Object... args) {
     ImmutableSet.Builder<TypeName> types = ImmutableSet.builder();
     for (Object arg : args) {
       if (arg instanceof Snippet) {
-        types.addAll(((Snippet) arg).types);
+        types.addAll(((Snippet) arg).types());
       }
       if (arg instanceof TypeName) {
         types.add((TypeName) arg);
@@ -98,7 +135,7 @@ public static Snippet format(String format, Object... args) {
         types.add(((HasTypeName) arg).name());
       }
     }
-    return new Snippet(format, types.build(), ImmutableList.copyOf(args));
+    return new BasicSnippet(format, types.build(), ImmutableList.copyOf(args));
   }
 
   public static Snippet format(String format, Iterable<? extends Object> args) {
@@ -110,65 +147,31 @@ public static Snippet memberSelectSnippet(Iterable<? extends Object> selectors)
         selectors);
   }
 
+  public static Snippet nullCheck(Object thingToCheck) {
+    return format("if (%s == null) { throw new NullPointerException(); } ", thingToCheck);
+  }
+
+  public static Snippet nullCheck(Object thingToCheck, String message) {
+    return format("if (%s == null) { throw new NullPointerException(%s); } ",
+        thingToCheck,
+        StringLiteral.forValue(message));
+  }
+
   public static Snippet makeParametersSnippet(Iterable<Snippet> parameterSnippets) {
-    Iterator<Snippet> iterator = parameterSnippets.iterator();
-    StringBuilder stringBuilder = new StringBuilder();
-    ImmutableSet.Builder<TypeName> typesBuilder = ImmutableSet.builder();
-    ImmutableList.Builder<Object> argsBuilder = ImmutableList.builder();
-    if (iterator.hasNext()) {
-      Snippet firstSnippet = iterator.next();
-      stringBuilder.append(firstSnippet.format());
-      typesBuilder.addAll(firstSnippet.types());
-      argsBuilder.addAll(firstSnippet.args());
-    }
-    while (iterator.hasNext()) {
-      Snippet nextSnippet = iterator.next();
-      stringBuilder.append(", ").append(nextSnippet.format());
-      typesBuilder.addAll(nextSnippet.types());
-      argsBuilder.addAll(nextSnippet.args());
-    }
-    return new Snippet(stringBuilder.toString(), typesBuilder.build(), argsBuilder.build());
+    return join(", ", parameterSnippets);
   }
 
   /**
-   * A snippet that concatenates its arguments.
+   * A snippet that concatenates its arguments with each snippet separated by a new line.
    */
   public static Snippet concat(Iterable<Snippet> snippets) {
-    return join(Joiner.on(""), snippets);
+    return join("\n", snippets);
   }
 
   /**
    * A snippet that joins its arguments with {@code joiner}.
    */
-  public static Snippet join(Joiner joiner, Iterable<Snippet> snippets) {
-    FluentIterable<Snippet> fluentSnippets = FluentIterable.from(snippets);
-    return new Snippet(
-        fluentSnippets
-            .transform(
-                new Function<Snippet, String>() {
-                  @Override
-                  public String apply(Snippet snippet) {
-                    return snippet.format;
-                  }
-                })
-            .join(joiner),
-        fluentSnippets
-            .transformAndConcat(
-                new Function<Snippet, ImmutableSet<TypeName>>() {
-                  @Override
-                  public ImmutableSet<TypeName> apply(Snippet snippet) {
-                    return snippet.types;
-                  }
-                })
-            .toSet(),
-        fluentSnippets
-            .transformAndConcat(
-                new Function<Snippet, ImmutableList<Object>>() {
-                  @Override
-                  public ImmutableList<Object> apply(Snippet snippet) {
-                    return snippet.args;
-                  }
-                })
-            .toList());
+  public static Snippet join(String joinToken, Iterable<Snippet> snippets) {
+    return new CompoundSnippet(joinToken, ImmutableList.copyOf(snippets));
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/VariableWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/VariableWriter.java
index 28a290e35..58ee1e494 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/VariableWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/VariableWriter.java
@@ -15,6 +15,8 @@
  */
 package dagger.internal.codegen.writer;
 
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableList;
 import java.io.IOException;
 import java.util.Set;
 
@@ -39,6 +41,7 @@ public String name() {
 
   @Override
   public Appendable write(Appendable appendable, Context context) throws IOException {
+    writeAnnotations(appendable, context);
     writeModifiers(appendable);
     type.write(appendable, context);
     return appendable.append(' ').append(name);
@@ -46,6 +49,10 @@ public Appendable write(Appendable appendable, Context context) throws IOExcepti
 
   @Override
   public Set<ClassName> referencedClasses() {
-    return type.referencedClasses();
+    return FluentIterable.from(ImmutableList.<HasClassReferences>of())
+        .append(annotations)
+        .append(type)
+        .transformAndConcat(HasClassReferences.COMBINER)
+        .toSet();
   }
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/ComponentBuilderTest.java b/compiler/src/test/java/dagger/internal/codegen/ComponentBuilderTest.java
index de59af6ec..cf0e69d33 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ComponentBuilderTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ComponentBuilderTest.java
@@ -29,10 +29,10 @@
 /** Tests for {@link dagger.Component.Builder} */
 @RunWith(JUnit4.class)
 public class ComponentBuilderTest {
-  
+
   private static final ErrorMessages.ComponentBuilderMessages MSGS =
       ErrorMessages.ComponentBuilderMessages.INSTANCE;
-  
+
   @Test
   public void testEmptyBuilder() {
     JavaFileObject injectableTypeFile = JavaFileObjects.forSourceLines("test.SomeInjectableType",
@@ -57,7 +57,7 @@ public void testEmptyBuilder() {
         "  @Component.Builder",
         "  static interface Builder {",
         "     SimpleComponent build();",
-        "  }",        
+        "  }",
         "}");
     JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
         "test.DaggerSimpleComponent",
@@ -81,6 +81,7 @@ public void testEmptyBuilder() {
         "    return builder().build();",
         "  }",
         "",
+        "  @SuppressWarnings(\"unchecked\")",
         "  private void initialize(final Builder builder) {",
         "  }",
         "",
@@ -101,7 +102,7 @@ public void testEmptyBuilder() {
         .compilesWithoutError()
         .and().generatesSources(generatedComponent);
   }
-  
+
   @Test
   public void testUsesBuildAndSetterNames() {
     JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
@@ -155,6 +156,7 @@ public void testUsesBuildAndSetterNames() {
         "    return builder().create();",
         "  }",
         "",
+        "  @SuppressWarnings(\"unchecked\")",
         "  private void initialize(final Builder builder) {",
         "    this.stringProvider = TestModule_StringFactory.create(builder.testModule);",
         "  }",
@@ -178,7 +180,7 @@ public void testUsesBuildAndSetterNames() {
         "    @Override",
         "    public Builder setTestModule(TestModule testModule) {",
         "      if (testModule == null) {",
-        "        throw new NullPointerException(\"testModule\");",
+        "        throw new NullPointerException();",
         "      }",
         "      this.testModule = testModule;",
         "      return this;",
@@ -191,7 +193,7 @@ public void testUsesBuildAndSetterNames() {
         .compilesWithoutError()
         .and().generatesSources(generatedComponent);
   }
-  
+
   @Test
   public void testIgnoresModulesNotInApi() {
     JavaFileObject module1 = JavaFileObjects.forSourceLines("test.TestModule1",
@@ -227,7 +229,7 @@ public void testIgnoresModulesNotInApi() {
         "",
         "  @Component.Builder",
         "  interface Builder {",
-        "    Builder testModule1(TestModule1 testModule);",
+        "    Builder testModule1(TestModule1 testModule1);",
         "    TestComponent build();",
         "  }",
         "}");
@@ -257,6 +259,7 @@ public void testIgnoresModulesNotInApi() {
         "    return builder().build();",
         "  }",
         "",
+        "  @SuppressWarnings(\"unchecked\")",
         "  private void initialize(final Builder builder) {",
         "    this.stringProvider = TestModule1_StringFactory.create(builder.testModule1);",
         "    this.integerProvider = TestModule2_IntegerFactory.create(builder.testModule2);",
@@ -290,7 +293,7 @@ public void testIgnoresModulesNotInApi() {
         "    @Override",
         "    public Builder testModule1(TestModule1 testModule1) {",
         "      if (testModule1 == null) {",
-        "        throw new NullPointerException(\"testModule1\");",
+        "        throw new NullPointerException();",
         "      }",
         "      this.testModule1 = testModule1;",
         "      return this;",
@@ -303,7 +306,7 @@ public void testIgnoresModulesNotInApi() {
         .compilesWithoutError()
         .and().generatesSources(generatedComponent);
   }
-  
+
   @Test
   public void testMoreThanOneBuilderFails() {
     JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
@@ -323,7 +326,7 @@ public void testMoreThanOneBuilderFails() {
         "  @Component.Builder",
         "  interface Builder2 {",
         "     SimpleComponent build();",
-        "  }",           
+        "  }",
         "}");
     assertAbout(javaSource()).that(componentFile)
         .processedWith(new ComponentProcessor())
@@ -332,7 +335,7 @@ public void testMoreThanOneBuilderFails() {
             "[test.SimpleComponent.Builder, test.SimpleComponent.Builder2]"))
         .in(componentFile);
   }
-  
+
   @Test
   public void testBuilderGenericsFails() {
     JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
@@ -347,7 +350,7 @@ public void testBuilderGenericsFails() {
         "  @Component.Builder",
         "  interface Builder<T> {",
         "     SimpleComponent build();",
-        "  }",           
+        "  }",
         "}");
     assertAbout(javaSource()).that(componentFile)
         .processedWith(new ComponentProcessor())
@@ -355,7 +358,7 @@ public void testBuilderGenericsFails() {
         .withErrorContaining(MSGS.generics())
         .in(componentFile);
   }
-  
+
   @Test
   public void testBuilderNotInComponentFails() {
     JavaFileObject builder = JavaFileObjects.forSourceLines("test.Builder",
@@ -371,7 +374,7 @@ public void testBuilderNotInComponentFails() {
         .withErrorContaining(MSGS.mustBeInComponent())
         .in(builder);
   }
-  
+
   @Test
   public void testBuilderMissingBuildMethodFails() {
     JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
@@ -392,7 +395,7 @@ public void testBuilderMissingBuildMethodFails() {
         .withErrorContaining(MSGS.missingBuildMethod())
         .in(componentFile);
   }
-  
+
   @Test
   public void testPrivateBuilderFails() {
     JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
@@ -413,7 +416,7 @@ public void testPrivateBuilderFails() {
         .withErrorContaining(MSGS.isPrivate())
         .in(componentFile);
   }
-  
+
   @Test
   public void testNonStaticBuilderFails() {
     JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
@@ -434,7 +437,7 @@ public void testNonStaticBuilderFails() {
         .withErrorContaining(MSGS.mustBeStatic())
         .in(componentFile);
   }
-  
+
   @Test
   public void testNonAbstractBuilderFails() {
     JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
@@ -454,7 +457,7 @@ public void testNonAbstractBuilderFails() {
         .failsToCompile()
         .withErrorContaining(MSGS.mustBeAbstract());
   }
-  
+
   @Test
   public void testBuilderOneCxtorWithArgsFails() {
     JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
@@ -477,7 +480,7 @@ public void testBuilderOneCxtorWithArgsFails() {
         .withErrorContaining(MSGS.cxtorOnlyOneAndNoArgs())
         .in(componentFile);
   }
-  
+
   @Test
   public void testBuilderMoreThanOneCxtorFails() {
     JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
@@ -501,7 +504,7 @@ public void testBuilderMoreThanOneCxtorFails() {
         .withErrorContaining(MSGS.cxtorOnlyOneAndNoArgs())
         .in(componentFile);
   }
-  
+
   @Test
   public void testBuilderEnumFails() {
     JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
@@ -522,7 +525,7 @@ public void testBuilderEnumFails() {
         .withErrorContaining(MSGS.mustBeClassOrInterface())
         .in(componentFile);
   }
-  
+
   @Test
   public void testBuilderBuildReturnsWrongTypeFails() {
     JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
@@ -545,7 +548,7 @@ public void testBuilderBuildReturnsWrongTypeFails() {
         .withErrorContaining(MSGS.buildMustReturnComponentType())
             .in(componentFile).onLine(11);
   }
-  
+
   @Test
   public void testInheritedBuilderBuildReturnsWrongTypeFails() {
     JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
@@ -571,7 +574,7 @@ public void testInheritedBuilderBuildReturnsWrongTypeFails() {
             String.format(MSGS.inheritedBuildMustReturnComponentType(), "build"))
             .in(componentFile).onLine(14);
   }
-  
+
   @Test
   public void testTwoBuildMethodsFails() {
     JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
@@ -595,7 +598,7 @@ public void testTwoBuildMethodsFails() {
         .withErrorContaining(String.format(MSGS.twoBuildMethods(), "build()"))
             .in(componentFile).onLine(12);
   }
-  
+
   @Test
   public void testInheritedTwoBuildMethodsFails() {
     JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
@@ -622,7 +625,7 @@ public void testInheritedTwoBuildMethodsFails() {
             String.format(MSGS.inheritedTwoBuildMethods(), "create()", "build()"))
             .in(componentFile).onLine(15);
   }
-  
+
   @Test
   public void testMoreThanOneArgFails() {
     JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
@@ -649,7 +652,7 @@ public void testMoreThanOneArgFails() {
         .and().withErrorContaining(MSGS.methodsMustTakeOneArg())
             .in(componentFile).onLine(13);
   }
-  
+
   @Test
   public void testInheritedMoreThanOneArgFails() {
     JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
@@ -677,7 +680,7 @@ public void testInheritedMoreThanOneArgFails() {
                 "set1(java.lang.String,java.lang.Integer)"))
             .in(componentFile).onLine(15);
   }
-  
+
   @Test
   public void testSetterReturningNonVoidOrBuilderFails() {
     JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
@@ -701,7 +704,7 @@ public void testSetterReturningNonVoidOrBuilderFails() {
         .withErrorContaining(MSGS.methodsMustReturnVoidOrBuilder())
             .in(componentFile).onLine(12);
   }
-  
+
   @Test
   public void testInheritedSetterReturningNonVoidOrBuilderFails() {
     JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
@@ -727,9 +730,9 @@ public void testInheritedSetterReturningNonVoidOrBuilderFails() {
         .withErrorContaining(
             String.format(MSGS.inheritedMethodsMustReturnVoidOrBuilder(),
                 "set(java.lang.Integer)"))
-            .in(componentFile).onLine(15);    
+            .in(componentFile).onLine(15);
   }
-  
+
   @Test
   public void testGenericsOnSetterMethodFails() {
     JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
@@ -753,7 +756,7 @@ public void testGenericsOnSetterMethodFails() {
         .withErrorContaining(MSGS.methodsMayNotHaveTypeParameters())
             .in(componentFile).onLine(12);
   }
-  
+
   @Test
   public void testGenericsOnInheritedSetterMethodFails() {
     JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
@@ -778,9 +781,9 @@ public void testGenericsOnInheritedSetterMethodFails() {
         .failsToCompile()
         .withErrorContaining(
             String.format(MSGS.inheritedMethodsMayNotHaveTypeParameters(), "<T>set(T)"))
-            .in(componentFile).onLine(15);    
+            .in(componentFile).onLine(15);
   }
-  
+
   @Test
   public void testMultipleSettersPerTypeFails() {
     JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
@@ -807,7 +810,7 @@ public void testMultipleSettersPerTypeFails() {
                   "java.lang.String", "[set1(java.lang.String), set2(java.lang.String)]"))
             .in(componentFile).onLine(10);
   }
-  
+
   @Test
   public void testMultipleSettersPerTypeIncludingResolvedGenericsFails() {
     JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
@@ -837,7 +840,7 @@ public void testMultipleSettersPerTypeIncludingResolvedGenericsFails() {
                   "java.lang.String", "[set1(T), set2(java.lang.String)]"))
             .in(componentFile).onLine(14);
   }
-  
+
   @Test
   public void testExtraSettersFails() {
     JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
@@ -864,9 +867,9 @@ public void testExtraSettersFails() {
                   "[void test.SimpleComponent.Builder.set1(String),"
                   + " void test.SimpleComponent.Builder.set2(Integer)]"))
             .in(componentFile).onLine(10);
-    
+
   }
-  
+
   @Test
   public void testMissingSettersFail() {
     JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
diff --git a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
index f7e79da29..28e3b4570 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
@@ -37,6 +37,7 @@
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
 import static dagger.internal.codegen.ErrorMessages.REFERENCED_MODULES_MUST_NOT_BE_ABSTRACT;
+import static javax.tools.StandardLocation.SOURCE_OUTPUT;
 
 @RunWith(JUnit4.class)
 public class ComponentProcessorTest {
@@ -231,6 +232,7 @@ private void checkCannotReferToModuleOfType(String moduleType) {
         "    return builder().build();",
         "  }",
         "",
+        "  @SuppressWarnings(\"unchecked\")",
         "  private void initialize(final Builder builder) {",
         "  }",
         "",
@@ -317,6 +319,7 @@ private void checkCannotReferToModuleOfType(String moduleType) {
         "    return builder().build();",
         "  }",
         "",
+        "  @SuppressWarnings(\"unchecked\")",
         "  private void initialize(final Builder builder) {",
         "    this.someInjectableTypeProvider =",
         "        ScopedProvider.create(SomeInjectableType_Factory.create());",
@@ -399,6 +402,7 @@ private void checkCannotReferToModuleOfType(String moduleType) {
         "    return builder().build();",
         "  }",
         "",
+        "  @SuppressWarnings(\"unchecked\")",
         "  private void initialize(final Builder builder) {",
         "    this.bMembersInjector =",
         "        OuterType$B_MembersInjector.create(OuterType$A_Factory.create());",
@@ -498,6 +502,7 @@ private void checkCannotReferToModuleOfType(String moduleType) {
         "    return builder().build();",
         "  }",
         "",
+        "  @SuppressWarnings(\"unchecked\")",
         "  private void initialize(final Builder builder) {",
         "    this.bProvider = TestModule_BFactory.create(builder.testModule,",
         "        C_Factory.create());",
@@ -524,7 +529,7 @@ private void checkCannotReferToModuleOfType(String moduleType) {
         "",
         "    public Builder testModule(TestModule testModule) {",
         "      if (testModule == null) {",
-        "        throw new NullPointerException(\"testModule\");",
+        "        throw new NullPointerException();",
         "      }",
         "      this.testModule = testModule;",
         "      return this;",
@@ -630,83 +635,58 @@ private void checkCannotReferToModuleOfType(String moduleType) {
         "  }",
         "",
         "  public static final class Builder {",
-        "    private TestModule testModule;",
-        "    private ParentTestIncluded parentTestIncluded;",
-        "    private AlwaysIncluded alwaysIncluded;",
-        "    private DepModule depModule;",
-        "    private ParentDepIncluded parentDepIncluded;",
-        "    private RefByDep refByDep;",
-        "",
         "    private Builder() {",
         "    }",
         "",
         "    public TestComponent build() {",
-        "      if (testModule == null) {",
-        "        this.testModule = new TestModule();",
-        "      }",
-        "      if (parentTestIncluded == null) {",
-        "        this.parentTestIncluded = new ParentTestIncluded();",
-        "      }",
-        "      if (alwaysIncluded == null) {",
-        "        this.alwaysIncluded = new AlwaysIncluded();",
-        "      }",
-        "      if (depModule == null) {",
-        "        this.depModule = new DepModule();",
-        "      }",
-        "      if (parentDepIncluded == null) {",
-        "        this.parentDepIncluded = new ParentDepIncluded();",
-        "      }",
-        "      if (refByDep == null) {",
-        "        this.refByDep = new RefByDep();",
-        "      }",
         "      return new DaggerTestComponent(this);",
         "    }",
         "",
+        "    @Deprecated",
         "    public Builder testModule(TestModule testModule) {",
         "      if (testModule == null) {",
-        "        throw new NullPointerException(\"testModule\");",
+        "        throw new NullPointerException();",
         "      }",
-        "      this.testModule = testModule;",
         "      return this;",
         "    }",
         "",
+        "    @Deprecated",
         "    public Builder parentTestIncluded(ParentTestIncluded parentTestIncluded) {",
         "      if (parentTestIncluded == null) {",
-        "        throw new NullPointerException(\"parentTestIncluded\");",
+        "        throw new NullPointerException();",
         "      }",
-        "      this.parentTestIncluded = parentTestIncluded;",
         "      return this;",
         "    }",
         "",
+        "    @Deprecated",
         "    public Builder alwaysIncluded(AlwaysIncluded alwaysIncluded) {",
         "      if (alwaysIncluded == null) {",
-        "        throw new NullPointerException(\"alwaysIncluded\");",
+        "        throw new NullPointerException();",
         "      }",
-        "      this.alwaysIncluded = alwaysIncluded;",
         "      return this;",
         "    }",
         "",
+        "    @Deprecated",
         "    public Builder depModule(DepModule depModule) {",
         "      if (depModule == null) {",
-        "        throw new NullPointerException(\"depModule\");",
+        "        throw new NullPointerException();",
         "      }",
-        "      this.depModule = depModule;",
         "      return this;",
         "    }",
         "",
+        "    @Deprecated",
         "    public Builder parentDepIncluded(ParentDepIncluded parentDepIncluded) {",
         "      if (parentDepIncluded == null) {",
-        "        throw new NullPointerException(\"parentDepIncluded\");",
+        "        throw new NullPointerException();",
         "      }",
-        "      this.parentDepIncluded = parentDepIncluded;",
         "      return this;",
         "    }",
         "",
+        "    @Deprecated",
         "    public Builder refByDep(RefByDep refByDep) {",
         "      if (refByDep == null) {",
-        "        throw new NullPointerException(\"refByDep\");",
+        "        throw new NullPointerException();",
         "      }",
-        "      this.refByDep = refByDep;",
         "      return this;",
         "    }",
         "  }",
@@ -761,6 +741,201 @@ public void generatedTransitiveModule() {
         .compilesWithoutError();
   }
 
+  @Test
+  public void generatedModuleInSubcomponent() {
+    JavaFileObject subcomponent =
+        JavaFileObjects.forSourceLines(
+            "test.ChildComponent",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = GeneratedModule.class)",
+            "interface ChildComponent {}");
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface TestComponent {",
+            "  ChildComponent childComponent();",
+            "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(subcomponent, component))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile();
+    assertAbout(javaSources())
+        .that(ImmutableList.of(subcomponent, component))
+        .processedWith(
+            new ComponentProcessor(),
+            new GeneratingProcessor(
+                "test.GeneratedModule",
+                "package test;",
+                "",
+                "import dagger.Module;",
+                "",
+                "@Module",
+                "final class GeneratedModule {}"))
+        .compilesWithoutError();
+  }
+
+  @Test
+  public void subcomponentOmitsInheritedBindings() {
+    JavaFileObject parent =
+        JavaFileObjects.forSourceLines(
+            "test.Parent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = ParentModule.class)",
+            "interface Parent {",
+            "  Child child();",
+            "}");
+    JavaFileObject parentModule =
+        JavaFileObjects.forSourceLines(
+            "test.ParentModule",
+            "package test;",
+            "",
+            "import dagger.mapkeys.StringKey;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "import static dagger.Provides.Type.SET;",
+            "import static dagger.Provides.Type.MAP;",
+            "",
+            "@Module",
+            "class ParentModule {",
+            "  @Provides(type = SET) static Object parentObject() {",
+            "    return \"parent object\";",
+            "  }",
+            "",
+            "  @Provides(type = MAP) @StringKey(\"parent key\") Object parentKeyObject() {",
+            "    return \"parent value\";",
+            "  }",
+            "}");
+    JavaFileObject child =
+        JavaFileObjects.forSourceLines(
+            "test.Child",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "import java.util.Map;",
+            "import java.util.Set;",
+            "",
+            "@Subcomponent",
+            "interface Child {",
+            "  Set<Object> objectSet();",
+            "  Map<String, Object> objectMap();",
+            "}");
+    JavaFileObject expected =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerParent",
+            "package test;",
+            "",
+            "import dagger.internal.MapFactory;",
+            "import dagger.internal.MapProviderFactory;",
+            "import dagger.internal.SetFactory;",
+            "import java.util.Map;",
+            "import java.util.Set;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+            "public final class DaggerParent implements Parent {",
+            "  private Provider<Set<Object>> setOfObjectContribution1Provider;",
+            "  private Provider<Set<Object>> setOfObjectProvider;",
+            "  private Provider<Object> mapOfStringAndProviderOfObjectContribution1;",
+            "  private Provider<Map<String, Provider<Object>>>",
+            "      mapOfStringAndProviderOfObjectProvider;",
+            "",
+            "  private DaggerParent(Builder builder) {",
+            "    assert builder != null;",
+            "    initialize(builder);",
+            "  }",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static Parent create() {",
+            "    return builder().build();",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize(final Builder builder) {",
+            "    this.setOfObjectContribution1Provider =",
+            "        ParentModule_ParentObjectFactory.create();",
+            "    this.setOfObjectProvider = SetFactory.create(setOfObjectContribution1Provider);",
+            "    this.mapOfStringAndProviderOfObjectContribution1 =",
+            "        ParentModule_ParentKeyObjectFactory.create(builder.parentModule);",
+            "    this.mapOfStringAndProviderOfObjectProvider =",
+            "        MapProviderFactory.<String, Object>builder(1)",
+            "            .put(\"parent key\", mapOfStringAndProviderOfObjectContribution1)",
+            "            .build();",
+            "  }",
+            "",
+            "  @Override",
+            "  public Child child() {",
+            "    return new ChildImpl();",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private ParentModule parentModule;",
+            "",
+            "    private Builder() {}",
+            "",
+            "    public Parent build() {",
+            "      if (parentModule == null) {",
+            "        this.parentModule = new ParentModule();",
+            "      }",
+            "      return new DaggerParent(this);",
+            "    }",
+            "",
+            "    public Builder parentModule(ParentModule parentModule) {",
+            "      if (parentModule == null) {",
+            "        throw new NullPointerException();",
+            "      }",
+            "      this.parentModule = parentModule;",
+            "      return this;",
+            "    }",
+            "  }",
+            "",
+            "  private final class ChildImpl implements Child {",
+            "    private Provider<Map<String, Object>> mapOfStringAndObjectProvider;",
+            "",
+            "    private ChildImpl() {",
+            "      initialize();",
+            "    }",
+            "",
+            "    @SuppressWarnings(\"unchecked\")",
+            "    private void initialize() {",
+            "      this.mapOfStringAndObjectProvider = MapFactory.create(",
+            "          DaggerParent.this.mapOfStringAndProviderOfObjectProvider);",
+            "    }",
+            "",
+            "    @Override",
+            "    public Set<Object> objectSet() {",
+            "      return DaggerParent.this.setOfObjectProvider.get();",
+            "    }",
+            "",
+            "    @Override",
+            "    public Map<String, Object> objectMap() {",
+            "      return mapOfStringAndObjectProvider.get();",
+            "    }",
+            "  }",
+            "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(parent, parentModule, child))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and()
+        .generatesSources(expected);
+  }
+
   @Test public void testDefaultPackage() {
     JavaFileObject aClass = JavaFileObjects.forSourceLines("AClass", "class AClass {}");
     JavaFileObject bClass = JavaFileObjects.forSourceLines("BClass",
@@ -858,6 +1033,7 @@ public void generatedTransitiveModule() {
         "    return builder().build();",
         "  }",
         "",
+        "  @SuppressWarnings(\"unchecked\")",
         "  private void initialize(final Builder builder) {",
         "    this.setOfStringContribution1Provider =",
         "        EmptySetModule_EmptySetFactory.create(builder.emptySetModule);",
@@ -891,7 +1067,7 @@ public void generatedTransitiveModule() {
         "",
         "    public Builder emptySetModule(EmptySetModule emptySetModule) {",
         "      if (emptySetModule == null) {",
-        "        throw new NullPointerException(\"emptySetModule\");",
+        "        throw new NullPointerException();",
         "      }",
         "      this.emptySetModule = emptySetModule;",
         "      return this;",
@@ -899,7 +1075,7 @@ public void generatedTransitiveModule() {
         "",
         "    public Builder setModule(SetModule setModule) {",
         "      if (setModule == null) {",
-        "        throw new NullPointerException(\"setModule\");",
+        "        throw new NullPointerException();",
         "      }",
         "      this.setModule = setModule;",
         "      return this;",
@@ -968,6 +1144,7 @@ public void generatedTransitiveModule() {
         "    return builder().build();",
         "  }",
         "",
+        "  @SuppressWarnings(\"unchecked\")",
         "  private void initialize(final Builder builder) {",
         "    this.someInjectedTypeMembersInjector =",
         "        SomeInjectedType_MembersInjector.create(SomeInjectableType_Factory.create());",
@@ -1047,6 +1224,7 @@ public void generatedTransitiveModule() {
         "    return builder().build();",
         "  }",
         "",
+        "  @SuppressWarnings(\"unchecked\")",
         "  private void initialize(final Builder builder) {",
         "    this.simpleComponentProvider = InstanceFactory.<SimpleComponent>create(this);",
         "    this.someInjectableTypeProvider =",
@@ -1126,6 +1304,7 @@ public void generatedTransitiveModule() {
         "    return builder().build();",
         "  }",
         "",
+        "  @SuppressWarnings(\"unchecked\")",
         "  private void initialize(final Builder builder) {",
         "    this.someInjectedTypeMembersInjector =",
         "        SomeInjectedType_MembersInjector.create(SomeInjectableType_Factory.create());",
@@ -1203,6 +1382,7 @@ public void generatedTransitiveModule() {
         "    return builder().build();",
         "  }",
         "",
+        "  @SuppressWarnings(\"unchecked\")",
         "  private void initialize(final Builder builder) {",
         "    this.someInjectableTypeProvider =",
         "        SomeInjectableType_Factory.create((MembersInjector) MembersInjectors.noOp());",
@@ -1292,6 +1472,7 @@ public void generatedTransitiveModule() {
         "    return new Builder();",
         "  }",
         "",
+        "  @SuppressWarnings(\"unchecked\")",
         "  private void initialize(final Builder builder) {",
         "    this.aProvider = new Factory<A>() {",
         "      private final AComponent aComponent = builder.aComponent;",
@@ -1319,14 +1500,15 @@ public void generatedTransitiveModule() {
         "",
         "    public BComponent build() {",
         "      if (aComponent == null) {",
-        "        throw new IllegalStateException(\"aComponent must be set\");",
+        "        throw new IllegalStateException(AComponent.class.getCanonicalName()",
+        "            + \" must be set\");",
         "      }",
         "      return new DaggerBComponent(this);",
         "    }",
         "",
         "    public Builder aComponent(AComponent aComponent) {",
         "      if (aComponent == null) {",
-        "        throw new NullPointerException(\"aComponent\");",
+        "        throw new NullPointerException();",
         "      }",
         "      this.aComponent = aComponent;",
         "      return this;",
@@ -1411,6 +1593,7 @@ public void generatedTransitiveModule() {
         "    return builder().build();",
         "  }",
         "",
+        "  @SuppressWarnings(\"unchecked\")",
         "  private void initialize(final Builder builder) {",
         "    this.aProvider = test.TestModule_AFactory.create(builder.testModule);",
         "    this.aProvider1 = TestModule_AFactory.create(builder.testModule1);",
@@ -1445,7 +1628,7 @@ public void generatedTransitiveModule() {
         "",
         "    public Builder testModule(test.TestModule testModule) {",
         "      if (testModule == null) {",
-        "        throw new NullPointerException(\"testModule\");",
+        "        throw new NullPointerException();",
         "      }",
         "      this.testModule = testModule;",
         "      return this;",
@@ -1453,7 +1636,7 @@ public void generatedTransitiveModule() {
         "",
         "    public Builder testModule(TestModule testModule) {",
         "      if (testModule == null) {",
-        "        throw new NullPointerException(\"testModule\");",
+        "        throw new NullPointerException();",
         "      }",
         "      this.testModule1 = testModule;",
         "      return this;",
@@ -1540,6 +1723,7 @@ public void generatedTransitiveModule() {
         "    return builder().build();",
         "  }",
         "",
+        "  @SuppressWarnings(\"unchecked\")",
         "  private void initialize(final Builder builder) {",
         "    this.bProvider = B_Factory.create(C_Factory.create());",
         "    this.aProvider = A_Factory.create(bProvider);",
@@ -1642,6 +1826,7 @@ public void generatedTransitiveModule() {
         "    return builder().build();",
         "  }",
         "",
+        "  @SuppressWarnings(\"unchecked\")",
         "  private void initialize(final Builder builder) {}",
         "",
         "  @Override",
@@ -1730,6 +1915,7 @@ public void generatedTransitiveModule() {
         "    return builder().build();",
         "  }",
         "",
+        "  @SuppressWarnings(\"unchecked\")",
         "  private void initialize(final Builder builder) {}",
         "",
         "  @Override",
@@ -1798,7 +1984,6 @@ public void generatedTransitiveModule() {
         .withErrorContaining(
             "test.B<? extends test.A> cannot be provided without an @Provides-annotated method");
   }
-
   @Test
   public void componentImplicitlyDependsOnGeneratedType() {
     JavaFileObject injectableTypeFile = JavaFileObjects.forSourceLines("test.SomeInjectableType",
@@ -1813,9 +1998,6 @@ public void componentImplicitlyDependsOnGeneratedType() {
         "package test;",
         "",
         "import dagger.Component;",
-        "import dagger.Lazy;",
-        "",
-        "import javax.inject.Provider;",
         "",
         "@Component",
         "interface SimpleComponent {",
@@ -1825,7 +2007,8 @@ public void componentImplicitlyDependsOnGeneratedType() {
         .that(ImmutableList.of(injectableTypeFile, componentFile))
         .processedWith(
             new ComponentProcessor(),
-            new GeneratingProcessor("test.GeneratedType",
+            new GeneratingProcessor(
+                "test.GeneratedType",
                 "package test;",
                 "",
                 "import javax.inject.Inject;",
@@ -1833,7 +2016,45 @@ public void componentImplicitlyDependsOnGeneratedType() {
                 "final class GeneratedType {",
                 "  @Inject GeneratedType() {}",
                 "}"))
-        .compilesWithoutError();
+        .compilesWithoutError()
+        .and()
+        .generatesFileNamed(SOURCE_OUTPUT, "test", "DaggerSimpleComponent.java");
+  }
+  @Test
+  public void componentSupertypeDependsOnGeneratedType() {
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface SimpleComponent extends SimpleComponentInterface {}");
+    JavaFileObject interfaceFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleComponentInterface",
+            "package test;",
+            "",
+            "interface SimpleComponentInterface {",
+            "  GeneratedType generatedType();",
+            "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(componentFile, interfaceFile))
+        .processedWith(
+            new ComponentProcessor(),
+            new GeneratingProcessor(
+                "test.GeneratedType",
+                "package test;",
+                "",
+                "import javax.inject.Inject;",
+                "",
+                "final class GeneratedType {",
+                "  @Inject GeneratedType() {}",
+                "}"))
+        .compilesWithoutError()
+        .and()
+        .generatesFileNamed(SOURCE_OUTPUT, "test", "DaggerSimpleComponent.java");
   }
 
   @Test
@@ -1893,7 +2114,7 @@ public void genericTestToLetMeDebugInEclipse() {
          "",
          "  private DaggerSimpleComponent(Builder builder) {",
          "    assert builder != null;",
-         "    initialize();",
+         "    initialize(builder);",
          "  }",
          "",
          "  public static Builder builder() {",
@@ -1904,7 +2125,8 @@ public void genericTestToLetMeDebugInEclipse() {
          "    return builder().build();",
          "  }",
          "",
-         "  private void initialize() {",
+         "  @SuppressWarnings(\"unchecked\")",
+         "  private void initialize(final Builder builder) {",
          "    this.dProvider = new D_Factory(B_Factory.INSTANCE);",
          "  }",
          "",
diff --git a/compiler/src/test/java/dagger/internal/codegen/DependencyRequestMapperTest.java b/compiler/src/test/java/dagger/internal/codegen/DependencyRequestMapperTest.java
index 76b28e461..b47a43c1c 100644
--- a/compiler/src/test/java/dagger/internal/codegen/DependencyRequestMapperTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/DependencyRequestMapperTest.java
@@ -57,7 +57,7 @@
     this.types = compilationRule.getTypes();
     this.elements = compilationRule.getElements();
     this.keyFactory = new Key.Factory(types, elements);
-    this.dependencyRequestFactory = new DependencyRequest.Factory(keyFactory);
+    this.dependencyRequestFactory = new DependencyRequest.Factory(elements, keyFactory);
   }
 
   private List<? extends VariableElement> sampleProviderParameters() {
@@ -131,7 +131,7 @@ private DependencyRequest dependencyRequestForProduced() {
   @Module
   static final class ProvidesMethodModule {
     @Provides String provideString(
-        Integer a, Lazy<Integer> b, Provider<Integer> c, MembersInjector<Integer> d) {
+        Integer a, Lazy<Integer> b, Provider<Integer> c, MembersInjector<Y> d) {
       return null;
     }
   }
@@ -142,4 +142,6 @@ private DependencyRequest dependencyRequestForProduced() {
       return null;
     }
   }
+  
+  static final class Y {}
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/GraphValidationScopingTest.java b/compiler/src/test/java/dagger/internal/codegen/GraphValidationScopingTest.java
index da0c2b06c..e207fe0ee 100644
--- a/compiler/src/test/java/dagger/internal/codegen/GraphValidationScopingTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/GraphValidationScopingTest.java
@@ -130,6 +130,7 @@
         "import javax.inject.Inject;",
         "",
         "class SimpleType {",
+        "  @Inject SimpleType() {}",
         "  static class A { @Inject A() {} }",
         "  static class B { @Inject B() {} }",
         "}");
diff --git a/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java b/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
index 19b9c9419..6001ea713 100644
--- a/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
@@ -20,6 +20,7 @@
 import com.google.testing.compile.JavaFileObjects;
 import java.util.Arrays;
 import javax.tools.JavaFileObject;
+import org.junit.Ignore;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
@@ -27,7 +28,7 @@
 import static com.google.common.truth.Truth.assertAbout;
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
-import static dagger.internal.codegen.ErrorMessages.NULLABLE_TO_NON_NULLABLE;
+import static dagger.internal.codegen.ErrorMessages.nullableToNonNullable;
 
 @RunWith(JUnit4.class)
 public class GraphValidationTest {
@@ -67,25 +68,38 @@
   }
 
   @Test public void componentProvisionWithNoDependencyChain() {
-    JavaFileObject component = JavaFileObjects.forSourceLines("test.TestClass",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "",
-        "final class TestClass {",
-        "  interface A {}",
-        "",
-        "  @Component()",
-        "  interface AComponent {",
-        "    A getA();",
-        "  }",
-        "}");
-    String expectedError =
-        "test.TestClass.A cannot be provided without an @Provides-annotated method.";
-    assertAbout(javaSource()).that(component)
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestClass",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Qualifier;",
+            "",
+            "final class TestClass {",
+            "  @Qualifier @interface Q {}",
+            "  interface A {}",
+            "",
+            "  @Component()",
+            "  interface AComponent {",
+            "    A getA();",
+            "    @Q A qualifiedA();",
+            "  }",
+            "}");
+    assertAbout(javaSource())
+        .that(component)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
-        .withErrorContaining(expectedError).in(component).onLine(10);
+        .withErrorContaining(
+            "test.TestClass.A cannot be provided without an @Provides-annotated method.")
+        .in(component)
+        .onLine(12)
+        .and()
+        .withErrorContaining(
+            "@test.TestClass.Q test.TestClass.A "
+                + "cannot be provided without an @Provides-annotated method.")
+        .in(component)
+        .onLine(13);
   }
 
   @Test public void constructorInjectionWithoutAnnotation() {
@@ -190,36 +204,38 @@
   }
 
   @Test public void cyclicDependencyNotIncludingEntryPoint() {
-    JavaFileObject component = JavaFileObjects.forSourceLines("test.Outer",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "import javax.inject.Inject;",
-        "",
-        "final class Outer {",
-        "  static class A {",
-        "    @Inject A(C cParam) {}",
-        "  }",
-        "",
-        "  static class B {",
-        "    @Inject B(A aParam) {}",
-        "  }",
-        "",
-        "  static class C {",
-        "    @Inject C(B bParam) {}",
-        "  }",
-
-        "  static class D {",
-        "    @Inject D(C cParam) {}",
-        "  }",
-        "",
-        "  @Component()",
-        "  interface DComponent {",
-        "    D getD();",
-        "  }",
-        "}");
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.Outer",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import javax.inject.Inject;",
+            "",
+            "final class Outer {",
+            "  static class A {",
+            "    @Inject A(C cParam) {}",
+            "  }",
+            "",
+            "  static class B {",
+            "    @Inject B(A aParam) {}",
+            "  }",
+            "",
+            "  static class C {",
+            "    @Inject C(B bParam) {}",
+            "  }",
+            "",
+            "  static class D {",
+            "    @Inject D(C cParam) {}",
+            "  }",
+            "",
+            "  @Component()",
+            "  interface DComponent {",
+            "    D getD();",
+            "  }",
+            "}");
 
     String expectedError = "test.Outer.DComponent.getD() contains a dependency cycle:\n"
         + "      test.Outer.D.<init>(test.Outer.C cParam)\n"
@@ -231,12 +247,236 @@
         + "      test.Outer.A.<init>(test.Outer.C cParam)\n"
         + "          [parameter: test.Outer.C cParam]";
 
-    assertAbout(javaSource()).that(component)
+    assertAbout(javaSource())
+        .that(component)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
-        .withErrorContaining(expectedError).in(component).onLine(26);
+        .withErrorContaining(expectedError)
+        .in(component)
+        .onLine(27);
   }
 
+  @Test
+  public void cyclicDependencyNotBrokenByMapBinding() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.Outer",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import dagger.MapKey;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import java.util.Map;",
+            "import javax.inject.Inject;",
+            "",
+            "final class Outer {",
+            "  static class A {",
+            "    @Inject A(Map<String, C> cMap) {}",
+            "  }",
+            "",
+            "  static class B {",
+            "    @Inject B(A aParam) {}",
+            "  }",
+            "",
+            "  static class C {",
+            "    @Inject C(B bParam) {}",
+            "  }",
+            "",
+            "  @Component(modules = CModule.class)",
+            "  interface CComponent {",
+            "    C getC();",
+            "  }",
+            "",
+            "  @Module",
+            "  static class CModule {",
+            "    @Provides(type = Provides.Type.MAP)",
+            "    @StringKey(\"C\")",
+            "    static C c(C c) {",
+            "      return c;",
+            "    }",
+            "  }",
+            "",
+            "  @MapKey",
+            "  @interface StringKey {",
+            "    String value();",
+            "  }",
+            "}");
+
+    String expectedError =
+        Joiner.on('\n')
+            .join(
+                "test.Outer.CComponent.getC() contains a dependency cycle:",
+                "      test.Outer.C.<init>(test.Outer.B bParam)",
+                "          [parameter: test.Outer.B bParam]",
+                "      test.Outer.B.<init>(test.Outer.A aParam)",
+                "          [parameter: test.Outer.A aParam]",
+                "      test.Outer.A.<init>(java.util.Map<java.lang.String,test.Outer.C> cMap)",
+                "          [parameter: java.util.Map<java.lang.String,test.Outer.C> cMap]",
+                "      test.Outer.A.<init>(java.util.Map<java.lang.String,test.Outer.C> cMap)",
+                "          [parameter: java.util.Map<java.lang.String,test.Outer.C> cMap]",
+                "      test.Outer.CModule.c(test.Outer.C c)",
+                "          [parameter: test.Outer.C c]");
+
+    assertAbout(javaSource())
+        .that(component)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(expectedError)
+        .in(component)
+        .onLine(25);
+  }
+
+  @Test
+  public void falsePositiveCyclicDependencyIndirectionDetected() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.Outer",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import javax.inject.Inject;",
+            "import javax.inject.Provider;",
+            "",
+            "final class Outer {",
+            "  static class A {",
+            "    @Inject A(C cParam) {}",
+            "  }",
+            "",
+            "  static class B {",
+            "    @Inject B(A aParam) {}",
+            "  }",
+            "",
+            "  static class C {",
+            "    @Inject C(B bParam) {}",
+            "  }",
+            "",
+            "  static class D {",
+            "    @Inject D(Provider<C> cParam) {}",
+            "  }",
+            "",
+            "  @Component()",
+            "  interface DComponent {",
+            "    D getD();",
+            "  }",
+            "}");
+
+    String expectedError =
+        "test.Outer.DComponent.getD() contains a dependency cycle:\n"
+            + "      test.Outer.D.<init>(javax.inject.Provider<test.Outer.C> cParam)\n"
+            + "          [parameter: javax.inject.Provider<test.Outer.C> cParam]\n"
+            + "      test.Outer.C.<init>(test.Outer.B bParam)\n"
+            + "          [parameter: test.Outer.B bParam]\n"
+            + "      test.Outer.B.<init>(test.Outer.A aParam)\n"
+            + "          [parameter: test.Outer.A aParam]\n"
+            + "      test.Outer.A.<init>(test.Outer.C cParam)\n"
+            + "          [parameter: test.Outer.C cParam]";
+
+    assertAbout(javaSource())
+        .that(component)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(expectedError)
+        .in(component)
+        .onLine(28);
+  }
+
+  @Ignore @Test public void cyclicDependencySimpleProviderIndirectionWarning() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.Outer",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import javax.inject.Inject;",
+            "import javax.inject.Provider;",
+            "",
+            "final class Outer {",
+            "  static class A {",
+            "    @Inject A(B bParam) {}",
+            "  }",
+            "",
+            "  static class B {",
+            "    @Inject B(C bParam, D dParam) {}",
+            "  }",
+            "",
+            "  static class C {",
+            "    @Inject C(Provider<A> aParam) {}",
+            "  }",
+            "",
+            "  static class D {",
+            "    @Inject D() {}",
+            "  }",
+            "",
+            "  @Component()",
+            "  interface CComponent {",
+            "    C get();",
+            "  }",
+            "}");
+
+    /* String expectedWarning =
+     "test.Outer.CComponent.get() contains a dependency cycle:"
+     + "      test.Outer.C.<init>(javax.inject.Provider<test.Outer.A> aParam)"
+     + "          [parameter: javax.inject.Provider<test.Outer.A> aParam]"
+     + "      test.Outer.A.<init>(test.Outer.B bParam)"
+     + "          [parameter: test.Outer.B bParam]"
+     + "      test.Outer.B.<init>(test.Outer.C bParam, test.Outer.D dParam)"
+     + "          [parameter: test.Outer.C bParam]";
+     */
+    assertAbout(javaSource()) // TODO(cgruber): Implement warning checks.
+        .that(component)
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError();
+        //.withWarningContaining(expectedWarning).in(component).onLine(X);
+  }
+
+  @Ignore @Test public void cyclicDependencySimpleProviderIndirectionWarningSuppressed() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.Outer",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import javax.inject.Inject;",
+            "import javax.inject.Provider;",
+            "",
+            "final class Outer {",
+            "  static class A {",
+            "    @Inject A(B bParam) {}",
+            "  }",
+            "",
+            "  static class B {",
+            "    @Inject B(C bParam, D dParam) {}",
+            "  }",
+            "",
+            "  static class C {",
+            "    @Inject C(Provider<A> aParam) {}",
+            "  }",
+            "",
+            "  static class D {",
+            "    @Inject D() {}",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"dependency-cycle\")",
+            "  @Component()",
+            "  interface CComponent {",
+            "    C get();",
+            "  }",
+            "}");
+
+    assertAbout(javaSource())
+        .that(component)
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError();
+        //.compilesWithoutWarning(); //TODO(cgruber)
+  }
+  
   @Test public void duplicateExplicitBindings_ProvidesAndComponentProvision() {
     JavaFileObject component = JavaFileObjects.forSourceLines("test.Outer",
         "package test;",
@@ -320,7 +560,7 @@
         .failsToCompile()
         .withErrorContaining(expectedError).in(component).onLine(24);
   }
-
+  
   @Test public void duplicateExplicitBindings_MultipleProvisionTypes() {
     JavaFileObject component = JavaFileObjects.forSourceLines("test.Outer",
         "package test;",
@@ -391,7 +631,7 @@
         .withErrorContaining(expectedSetError).in(component).onLine(43)
         .and().withErrorContaining(expectedMapError).in(component).onLine(44);
   }
-
+  
   @Test public void duplicateBindings_TruncateAfterLimit() {
     JavaFileObject component = JavaFileObjects.forSourceLines("test.Outer",
         "package test;",
@@ -695,8 +935,10 @@
     assertAbout(javaSources()).that(ImmutableList.of(NULLABLE, a, module, component))
         .processedWith(new ComponentProcessor())
         .failsToCompile()
-        .withErrorContaining(String.format(NULLABLE_TO_NON_NULLABLE, "java.lang.String",
-            "@test.Nullable @Provides String test.TestModule.provideString()"));
+        .withErrorContaining(
+            nullableToNonNullable(
+                "java.lang.String",
+                "@test.Nullable @Provides String test.TestModule.provideString()"));
 
     // but if we disable the validation, then it compiles fine.
     assertAbout(javaSources()).that(ImmutableList.of(NULLABLE, a, module, component))
@@ -737,8 +979,10 @@
     assertAbout(javaSources()).that(ImmutableList.of(NULLABLE, a, module, component))
         .processedWith(new ComponentProcessor())
         .failsToCompile()
-        .withErrorContaining(String.format(NULLABLE_TO_NON_NULLABLE, "java.lang.String",
-            "@test.Nullable @Provides String test.TestModule.provideString()"));
+        .withErrorContaining(
+            nullableToNonNullable(
+                "java.lang.String",
+                "@test.Nullable @Provides String test.TestModule.provideString()"));
 
     // but if we disable the validation, then it compiles fine.
     assertAbout(javaSources()).that(ImmutableList.of(NULLABLE, a, module, component))
@@ -779,8 +1023,10 @@
     assertAbout(javaSources()).that(ImmutableList.of(NULLABLE, a, module, component))
         .processedWith(new ComponentProcessor())
         .failsToCompile()
-        .withErrorContaining(String.format(NULLABLE_TO_NON_NULLABLE, "java.lang.String",
-            "@test.Nullable @Provides String test.TestModule.provideString()"));
+        .withErrorContaining(
+            nullableToNonNullable(
+                "java.lang.String",
+                "@test.Nullable @Provides String test.TestModule.provideString()"));
 
     // but if we disable the validation, then it compiles fine.
     assertAbout(javaSources()).that(ImmutableList.of(NULLABLE, a, module, component))
@@ -812,8 +1058,10 @@
     assertAbout(javaSources()).that(ImmutableList.of(NULLABLE, module, component))
         .processedWith(new ComponentProcessor())
         .failsToCompile()
-        .withErrorContaining(String.format(NULLABLE_TO_NON_NULLABLE, "java.lang.String",
-            "@test.Nullable @Provides String test.TestModule.provideString()"));
+        .withErrorContaining(
+            nullableToNonNullable(
+                "java.lang.String",
+                "@test.Nullable @Provides String test.TestModule.provideString()"));
 
     // but if we disable the validation, then it compiles fine.
     assertAbout(javaSources()).that(ImmutableList.of(NULLABLE, module, component))
@@ -821,4 +1069,75 @@
         .processedWith(new ComponentProcessor())
         .compilesWithoutError();
   }
+
+  @Test public void componentDependencyMustNotCycle_Direct() {
+    JavaFileObject shortLifetime = JavaFileObjects.forSourceLines("test.ComponentShort",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component(dependencies = ComponentShort.class)",
+        "interface ComponentShort {",
+        "}");
+    String errorMessage =
+        "test.ComponentShort contains a cycle in its component dependencies:\n"
+            + "      test.ComponentShort";
+    assertAbout(javaSource())
+        .that(shortLifetime)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(errorMessage);
+  }
+
+  @Test public void componentDependencyMustNotCycle_Indirect() {
+    JavaFileObject longLifetime = JavaFileObjects.forSourceLines("test.ComponentLong",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component(dependencies = ComponentMedium.class)",
+        "interface ComponentLong {",
+        "}");
+    JavaFileObject mediumLifetime = JavaFileObjects.forSourceLines("test.ComponentMedium",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component(dependencies = ComponentLong.class)",
+        "interface ComponentMedium {",
+        "}");
+    JavaFileObject shortLifetime = JavaFileObjects.forSourceLines("test.ComponentShort",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component(dependencies = ComponentMedium.class)",
+        "interface ComponentShort {",
+        "}");
+    String longErrorMessage =
+        "test.ComponentLong contains a cycle in its component dependencies:\n"
+            + "      test.ComponentLong\n"
+            + "      test.ComponentMedium\n"
+            + "      test.ComponentLong";
+    String mediumErrorMessage =
+        "test.ComponentMedium contains a cycle in its component dependencies:\n"
+            + "      test.ComponentMedium\n"
+            + "      test.ComponentLong\n"
+            + "      test.ComponentMedium";
+    String shortErrorMessage =
+        "test.ComponentShort contains a cycle in its component dependencies:\n"
+            + "      test.ComponentMedium\n"
+            + "      test.ComponentLong\n"
+            + "      test.ComponentMedium\n"
+            + "      test.ComponentShort";
+    assertAbout(javaSources())
+        .that(ImmutableList.of(longLifetime, mediumLifetime, shortLifetime))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(longErrorMessage).in(longLifetime)
+        .and()
+        .withErrorContaining(mediumErrorMessage).in(mediumLifetime)
+        .and()
+        .withErrorContaining(shortErrorMessage).in(shortLifetime);
+  }
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/PackageProxyTest.java b/compiler/src/test/java/dagger/internal/codegen/InaccessibleTypeTest.java
similarity index 66%
rename from compiler/src/test/java/dagger/internal/codegen/PackageProxyTest.java
rename to compiler/src/test/java/dagger/internal/codegen/InaccessibleTypeTest.java
index 40ceb7ede..635592214 100644
--- a/compiler/src/test/java/dagger/internal/codegen/PackageProxyTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/InaccessibleTypeTest.java
@@ -1,3 +1,18 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package dagger.internal.codegen;
 
 import com.google.common.collect.ImmutableList;
@@ -7,12 +22,12 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import static com.google.common.truth.Truth.assert_;
+import static com.google.common.truth.Truth.assertAbout;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
 
 @RunWith(JUnit4.class)
-public class PackageProxyTest {
-  @Test public void basicPackageProxy() {
+public class InaccessibleTypeTest {
+  @Test public void basicInjectedType() {
     JavaFileObject noDepClassFile = JavaFileObjects.forSourceLines("foreign.NoDepClass",
         "package foreign;",
         "",
@@ -62,7 +77,6 @@
         "test.DaggerTestComponent",
         "package test;",
         "",
-        "import foreign.DaggerTestComponent_PackageProxy;",
         "import foreign.NoDepClass_Factory;",
         "import foreign.NonPublicClass1_Factory;",
         "import foreign.NonPublicClass2_Factory;",
@@ -73,8 +87,10 @@
         "",
         "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
         "public final class DaggerTestComponent implements TestComponent {",
-        "  private final DaggerTestComponent_PackageProxy foreign_Proxy =",
-        "      new DaggerTestComponent_PackageProxy();",
+        "  @SuppressWarnings(\"rawtypes\")",
+        "  private Provider nonPublicClass1Provider;",
+        "  @SuppressWarnings(\"rawtypes\")",
+        "  private Provider nonPublicClass2Provider;",
         "  private Provider<PublicClass> publicClassProvider;",
         "",
         "  private DaggerTestComponent(Builder builder) {",
@@ -90,14 +106,15 @@
         "    return builder().build();",
         "  }",
         "",
+        "  @SuppressWarnings(\"unchecked\")",
         "  private void initialize(final Builder builder) {",
-        "    this.foreign_Proxy.nonPublicClass1Provider =",
+        "    this.nonPublicClass1Provider =",
         "        NonPublicClass1_Factory.create(NoDepClass_Factory.create());",
-        "    this.foreign_Proxy.nonPublicClass2Provider =",
+        "    this.nonPublicClass2Provider =",
         "        NonPublicClass2_Factory.create(NoDepClass_Factory.create());",
         "    this.publicClassProvider = PublicClass_Factory.create(",
-        "        foreign_Proxy.nonPublicClass1Provider,",
-        "        foreign_Proxy.nonPublicClass2Provider,",
+        "        nonPublicClass1Provider,",
+        "        nonPublicClass2Provider,",
         "        NoDepClass_Factory.create());",
         "  }",
         "",
@@ -115,19 +132,20 @@
         "    }",
         "  }",
         "}");
-    assert_().about(javaSources())
+    assertAbout(javaSources())
         .that(ImmutableList.of(
             noDepClassFile,
             publicClassFile,
             nonPublicClass1File,
             nonPublicClass2File,
             componentFile))
+        .withCompilerOptions("-Xlint:rawtypes", "-Xlint:unchecked", "-Werror")
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and().generatesSources(generatedComponent);
   }
 
-  @Test public void memberInjectionPackageProxy() {
+  @Test public void memberInjectedType() {
     JavaFileObject noDepClassFile = JavaFileObjects.forSourceLines("test.NoDepClass",
         "package test;",
         "",
@@ -184,63 +202,51 @@
         "interface TestComponent {",
         "  void injectA(A a);",
         "}");
-    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
-        "test.DaggerTestComponent",
-        "package test;",
-        "",
-        "import dagger.MembersInjector;",
-        "import foreign.B;",
-        "import foreign.B_MembersInjector;",
-        "import foreign.C_MembersInjector;",
-        "import foreign.DaggerTestComponent_PackageProxy;",
-        "import javax.annotation.Generated;",
-        "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class DaggerTestComponent implements TestComponent {",
-        "  private MembersInjector<D> dMembersInjector;",
-        "  private final DaggerTestComponent_PackageProxy foreign_Proxy =",
-        "      new DaggerTestComponent_PackageProxy();",
-        "  private MembersInjector<B> bMembersInjector;",
-        "  private MembersInjector<A> aMembersInjector;",
-        "",
-        "  private DaggerTestComponent(Builder builder) {",
-        "    assert builder != null;",
-        "    initialize(builder);",
-        "  }",
-        "",
-        "  public static Builder builder() {",
-        "    return new Builder();",
-        "  }",
-        "",
-        "  public static TestComponent create() {",
-        "    return builder().build();",
-        "  }",
-        "",
-        "  private void initialize(final Builder builder) {",
-        "    this.dMembersInjector = D_MembersInjector.create(NoDepClass_Factory.create());",
-        "    this.foreign_Proxy.cMembersInjector =",
-        "        C_MembersInjector.create(dMembersInjector, NoDepClass_Factory.create());",
-        "    this.bMembersInjector = B_MembersInjector.create(",
-        "        foreign_Proxy.cMembersInjector, NoDepClass_Factory.create());",
-        "    this.aMembersInjector = A_MembersInjector.create(",
-        "        bMembersInjector, NoDepClass_Factory.create());",
-        "  }",
-        "",
-        "  @Override",
-        "  public void injectA(A a) {",
-        "    aMembersInjector.injectMembers(a);",
-        "  }",
-        "",
-        "  public static final class Builder {",
-        "    private Builder() {",
-        "    }",
-        "",
-        "    public TestComponent build() {",
-        "      return new DaggerTestComponent(this);",
-        "    }",
-        "  }",
-        "}");
-    assert_().about(javaSources())
+    JavaFileObject generatedComponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerTestComponent",
+            "package test;",
+            "",
+            "import dagger.MembersInjector;",
+            "import javax.annotation.Generated;",
+            "",
+            "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+            "public final class DaggerTestComponent implements TestComponent {",
+            "  private MembersInjector<A> aMembersInjector;",
+            "",
+            "  private DaggerTestComponent(Builder builder) {",
+            "    assert builder != null;",
+            "    initialize(builder);",
+            "  }",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static TestComponent create() {",
+            "    return builder().build();",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize(final Builder builder) {",
+            "     this.aMembersInjector = A_MembersInjector.create(NoDepClass_Factory.create());",
+            "  }",
+            "",
+            "  @Override",
+            "  public void injectA(A a) {",
+            "    aMembersInjector.injectMembers(a);",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private Builder() {",
+            "    }",
+            "",
+            "    public TestComponent build() {",
+            "      return new DaggerTestComponent(this);",
+            "    }",
+            "  }",
+            "}");
+    assertAbout(javaSources())
         .that(ImmutableList.of(
             noDepClassFile,
             aClassFile,
@@ -248,6 +254,7 @@
             cClassFile,
             dClassFile,
             componentFile))
+        .withCompilerOptions("-Xlint:rawtypes", "-Xlint:unchecked", "-Werror")
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and().generatesSources(generatedComponent);
diff --git a/compiler/src/test/java/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java b/compiler/src/test/java/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java
index 6310b1d16..ca0494e47 100644
--- a/compiler/src/test/java/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java
@@ -37,6 +37,8 @@
 import static dagger.internal.codegen.ErrorMessages.PRIVATE_INJECT_FIELD;
 import static dagger.internal.codegen.ErrorMessages.PRIVATE_INJECT_METHOD;
 import static dagger.internal.codegen.ErrorMessages.QUALIFIER_ON_INJECT_CONSTRUCTOR;
+import static dagger.internal.codegen.ErrorMessages.STATIC_INJECT_FIELD;
+import static dagger.internal.codegen.ErrorMessages.STATIC_INJECT_METHOD;
 
 @RunWith(JUnit4.class)
 // TODO(gak): add tests for generation in the default package.
@@ -517,7 +519,7 @@
         .withErrorContaining(FINAL_INJECT_FIELD).in(file).onLine(6);
   }
 
-  @Test public void privateInjectField() {
+  @Test public void privateInjectFieldError() {
     JavaFileObject file = JavaFileObjects.forSourceLines("test.PrivateInjectField",
         "package test;",
         "",
@@ -531,6 +533,51 @@
         .failsToCompile()
         .withErrorContaining(PRIVATE_INJECT_FIELD).in(file).onLine(6);
   }
+  
+  @Test public void privateInjectFieldWarning() {
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.PrivateInjectField",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "class PrivateInjectField {",
+        "  @Inject private String s;",
+        "}");
+    assertAbout(javaSource()).that(file)
+        .withCompilerOptions("-Adagger.privateMemberValidation=WARNING")
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError(); // TODO: Verify warning message when supported
+  }
+  
+  @Test public void staticInjectFieldError() {
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.StaticInjectField",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "class StaticInjectField {",
+        "  @Inject static String s;",
+        "}");
+    assertAbout(javaSource()).that(file)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(STATIC_INJECT_FIELD).in(file).onLine(6);
+  }
+  
+  @Test public void staticInjectFieldWarning() {
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.StaticInjectField",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "class StaticInjectField {",
+        "  @Inject static String s;",
+        "}");
+    assertAbout(javaSource()).that(file)
+        .withCompilerOptions("-Adagger.staticMemberValidation=WARNING")
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError(); // TODO: Verify warning message when supported
+  }
 
   @Test public void multipleQualifiersOnField() {
     JavaFileObject file = JavaFileObjects.forSourceLines("test.MultipleQualifierInjectField",
@@ -562,20 +609,65 @@
         .withErrorContaining(ABSTRACT_INJECT_METHOD).in(file).onLine(6);
   }
 
-  @Test public void privateInjectMethod() {
+  @Test public void privateInjectMethodError() {
     JavaFileObject file = JavaFileObjects.forSourceLines("test.PrivateInjectMethod",
         "package test;",
         "",
         "import javax.inject.Inject;",
         "",
         "class PrivateInjectMethod {",
-        "  @Inject private void method();",
+        "  @Inject private void method(){}",
         "}");
     assertAbout(javaSource()).that(file)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(PRIVATE_INJECT_METHOD).in(file).onLine(6);
   }
+  
+  @Test public void privateInjectMethodWarning() {
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.PrivateInjectMethod",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "class PrivateInjectMethod {",
+        "  @Inject private void method(){}",
+        "}");
+    assertAbout(javaSource()).that(file)
+        .withCompilerOptions("-Adagger.privateMemberValidation=WARNING")
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError(); // TODO: Verify warning message when supported
+  }
+  
+  @Test public void staticInjectMethodError() {
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.StaticInjectMethod",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "class StaticInjectMethod {",
+        "  @Inject static void method(){}",
+        "}");
+    assertAbout(javaSource()).that(file)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(STATIC_INJECT_METHOD).in(file).onLine(6);
+  }
+  
+  @Test public void staticInjectMethodWarning() {
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.StaticInjectMethod",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "class StaticInjectMethod {",
+        "  @Inject static void method(){}",
+        "}");
+    assertAbout(javaSource()).that(file)
+        .withCompilerOptions("-Adagger.staticMemberValidation=WARNING")
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError(); // TODO: Verify warning message when supported
+  }
 
   @Test public void genericInjectMethod() {
     JavaFileObject file = JavaFileObjects.forSourceLines("test.GenericInjectMethod",
diff --git a/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java
index cf5a94a2f..9e1b6dccd 100644
--- a/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java
@@ -23,7 +23,7 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import static com.google.common.truth.Truth.assert_;
+import static com.google.common.truth.Truth.assertAbout;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
 
 @RunWith(JUnit4.class)
@@ -137,6 +137,7 @@ public void mapBindingsWithEnumKey() {
         "    return builder().build();",
         "  }",
         "",
+        "  @SuppressWarnings(\"unchecked\")",
         "  private void initialize(final Builder builder) {",
         "    this.mapOfPathEnumAndProviderOfHandlerContribution1 =",
         "        MapModuleOne_ProvideAdminHandlerFactory.create(builder.mapModuleOne);",
@@ -175,7 +176,7 @@ public void mapBindingsWithEnumKey() {
         "",
         "    public Builder mapModuleOne(MapModuleOne mapModuleOne) {",
         "      if (mapModuleOne == null) {",
-        "        throw new NullPointerException(\"mapModuleOne\");",
+        "        throw new NullPointerException();",
         "      }",
         "      this.mapModuleOne = mapModuleOne;",
         "      return this;",
@@ -183,14 +184,14 @@ public void mapBindingsWithEnumKey() {
         "",
         "    public Builder mapModuleTwo(MapModuleTwo mapModuleTwo) {",
         "      if (mapModuleTwo == null) {",
-        "        throw new NullPointerException(\"mapModuleTwo\");",
+        "        throw new NullPointerException();",
         "      }",
         "      this.mapModuleTwo = mapModuleTwo;",
         "      return this;",
         "    }",
         "  }",
         "}");
-    assert_().about(javaSources())
+    assertAbout(javaSources())
         .that(ImmutableList.of(mapModuleOneFile,
             mapModuleTwoFile,
             enumKeyFile,
@@ -216,6 +217,7 @@ public void mapBindingsWithStringKey() {
                 "",
                 "import dagger.Module;",
                 "import dagger.Provides;",
+                "import dagger.mapkeys.StringKey;",
                 "",
                 "@Module",
                 "final class MapModuleOne {",
@@ -232,6 +234,7 @@ public void mapBindingsWithStringKey() {
                 "",
                 "import dagger.Module;",
                 "import dagger.Provides;",
+                "import dagger.mapkeys.StringKey;",
                 "",
                 "@Module",
                 "final class MapModuleTwo {",
@@ -239,17 +242,6 @@ public void mapBindingsWithStringKey() {
                 "    return new LoginHandler();",
                 "  }",
                 "}");
-    JavaFileObject stringKeyFile = JavaFileObjects.forSourceLines("test.StringKey",
-        "package test;",
-        "import dagger.MapKey;",
-        "import java.lang.annotation.Retention;",
-        "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
-        "",
-        "@MapKey(unwrapValue = true)",
-        "@Retention(RUNTIME)",
-        "public @interface StringKey {",
-        "  String value();",
-        "}");
     JavaFileObject HandlerFile = JavaFileObjects.forSourceLines("test.Handler",
         "package test;",
         "",
@@ -305,6 +297,7 @@ public void mapBindingsWithStringKey() {
         "    return builder().build();",
         "  }",
         "",
+        "  @SuppressWarnings(\"unchecked\")",
         "  private void initialize(final Builder builder) {",
         "    this.mapOfStringAndProviderOfHandlerContribution1 =",
         "        MapModuleOne_ProvideAdminHandlerFactory.create(builder.mapModuleOne);",
@@ -341,7 +334,7 @@ public void mapBindingsWithStringKey() {
         "",
         "    public Builder mapModuleOne(MapModuleOne mapModuleOne) {",
         "      if (mapModuleOne == null) {",
-        "        throw new NullPointerException(\"mapModuleOne\");",
+        "        throw new NullPointerException();",
         "      }",
         "      this.mapModuleOne = mapModuleOne;",
         "      return this;",
@@ -349,17 +342,16 @@ public void mapBindingsWithStringKey() {
         "",
         "    public Builder mapModuleTwo(MapModuleTwo mapModuleTwo) {",
         "      if (mapModuleTwo == null) {",
-        "        throw new NullPointerException(\"mapModuleTwo\");",
+        "        throw new NullPointerException();",
         "      }",
         "      this.mapModuleTwo = mapModuleTwo;",
         "      return this;",
         "    }",
         "  }",
         "}");
-    assert_().about(javaSources())
+    assertAbout(javaSources())
         .that(ImmutableList.of(mapModuleOneFile,
             mapModuleTwoFile,
-            stringKeyFile,
             HandlerFile,
             LoginHandlerFile,
             AdminHandlerFile,
@@ -384,7 +376,8 @@ public void mapBindingsWithWrappedKey() {
                 "",
                 "@Module",
                 "final class MapModuleOne {",
-                "  @Provides(type = MAP) @ClassKey(Integer.class) Handler provideAdminHandler() {",
+                "  @Provides(type = MAP)",
+                "  @WrappedClassKey(Integer.class) Handler provideAdminHandler() {",
                 "    return new AdminHandler();",
                 "  }",
                 "}");
@@ -400,11 +393,12 @@ public void mapBindingsWithWrappedKey() {
                 "",
                 "@Module",
                 "final class MapModuleTwo {",
-                "  @Provides(type = MAP) @ClassKey(Long.class) Handler provideLoginHandler() {",
+                "  @Provides(type = MAP)",
+                "  @WrappedClassKey(Long.class) Handler provideLoginHandler() {",
                 "    return new LoginHandler();",
                 "  }",
                 "}");
-    JavaFileObject classKeyFile = JavaFileObjects.forSourceLines("test.ClassKey",
+    JavaFileObject wrappedClassKeyFile = JavaFileObjects.forSourceLines("test.WrappedClassKey",
         "package test;",
         "import dagger.MapKey;",
         "import java.lang.annotation.Retention;",
@@ -412,7 +406,7 @@ public void mapBindingsWithWrappedKey() {
         "",
         "@MapKey(unwrapValue = false)",
         "@Retention(RUNTIME)",
-        "public @interface ClassKey {",
+        "public @interface WrappedClassKey {",
         "  Class<?> value();",
         "}");
     JavaFileObject HandlerFile = JavaFileObjects.forSourceLines("test.Handler",
@@ -440,7 +434,7 @@ public void mapBindingsWithWrappedKey() {
         "",
         "@Component(modules = {MapModuleOne.class, MapModuleTwo.class})",
         "interface TestComponent {",
-        "  Map<ClassKey, Provider<Handler>> dispatcher();",
+        "  Map<WrappedClassKey, Provider<Handler>> dispatcher();",
         "}");
     JavaFileObject generatedComponent = JavaFileObjects.forSourceLines("test.DaggerTestComponent",
         "package test;",
@@ -452,10 +446,10 @@ public void mapBindingsWithWrappedKey() {
         "",
         "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
         "public final class DaggerTestComponent implements TestComponent {",
-        "  private Provider<Handler> mapOfClassKeyAndProviderOfHandlerContribution1;",
-        "  private Provider<Handler> mapOfClassKeyAndProviderOfHandlerContribution2;",
-        "  private Provider<Map<ClassKey, Provider<Handler>>>",
-        "      mapOfClassKeyAndProviderOfHandlerProvider;",
+        "  private Provider<Handler> mapOfWrappedClassKeyAndProviderOfHandlerContribution1;",
+        "  private Provider<Handler> mapOfWrappedClassKeyAndProviderOfHandlerContribution2;",
+        "  private Provider<Map<WrappedClassKey, Provider<Handler>>>",
+        "      mapOfWrappedClassKeyAndProviderOfHandlerProvider;",
         "",
         "  private DaggerTestComponent(Builder builder) {",
         "    assert builder != null;",
@@ -470,23 +464,24 @@ public void mapBindingsWithWrappedKey() {
         "    return builder().build();",
         "  }",
         "",
+        "  @SuppressWarnings(\"unchecked\")",
         "  private void initialize(final Builder builder) {",
-        "    this.mapOfClassKeyAndProviderOfHandlerContribution1 =",
+        "    this.mapOfWrappedClassKeyAndProviderOfHandlerContribution1 =",
         "        MapModuleOne_ProvideAdminHandlerFactory.create(builder.mapModuleOne);",
-        "    this.mapOfClassKeyAndProviderOfHandlerContribution2 =",
+        "    this.mapOfWrappedClassKeyAndProviderOfHandlerContribution2 =",
         "        MapModuleTwo_ProvideLoginHandlerFactory.create(builder.mapModuleTwo);",
-        "    this.mapOfClassKeyAndProviderOfHandlerProvider =",
-        "        MapProviderFactory.<ClassKey, Handler>builder(2)",
-        "            .put(ClassKeyCreator.createClassKey(Integer.class),",
-        "                mapOfClassKeyAndProviderOfHandlerContribution1)",
-        "            .put(ClassKeyCreator.createClassKey(Long.class),",
-        "                mapOfClassKeyAndProviderOfHandlerContribution2)",
+        "    this.mapOfWrappedClassKeyAndProviderOfHandlerProvider =",
+        "        MapProviderFactory.<WrappedClassKey, Handler>builder(2)",
+        "            .put(WrappedClassKeyCreator.createWrappedClassKey(Integer.class),",
+        "                mapOfWrappedClassKeyAndProviderOfHandlerContribution1)",
+        "            .put(WrappedClassKeyCreator.createWrappedClassKey(Long.class),",
+        "                mapOfWrappedClassKeyAndProviderOfHandlerContribution2)",
         "            .build();",
         "  }",
         "",
         "  @Override",
-        "  public Map<ClassKey, Provider<Handler>> dispatcher() {",
-        "    return mapOfClassKeyAndProviderOfHandlerProvider.get();",
+        "  public Map<WrappedClassKey, Provider<Handler>> dispatcher() {",
+        "    return mapOfWrappedClassKeyAndProviderOfHandlerProvider.get();",
         "  }",
         "",
         "  public static final class Builder {",
@@ -508,7 +503,7 @@ public void mapBindingsWithWrappedKey() {
         "",
         "    public Builder mapModuleOne(MapModuleOne mapModuleOne) {",
         "      if (mapModuleOne == null) {",
-        "        throw new NullPointerException(\"mapModuleOne\");",
+        "        throw new NullPointerException();",
         "      }",
         "      this.mapModuleOne = mapModuleOne;",
         "      return this;",
@@ -516,17 +511,17 @@ public void mapBindingsWithWrappedKey() {
         "",
         "    public Builder mapModuleTwo(MapModuleTwo mapModuleTwo) {",
         "      if (mapModuleTwo == null) {",
-        "        throw new NullPointerException(\"mapModuleTwo\");",
+        "        throw new NullPointerException();",
         "      }",
         "      this.mapModuleTwo = mapModuleTwo;",
         "      return this;",
         "    }",
         "  }",
         "}");
-    assert_().about(javaSources())
+    assertAbout(javaSources())
         .that(ImmutableList.of(mapModuleOneFile,
             mapModuleTwoFile,
-            classKeyFile,
+            wrappedClassKeyFile,
             HandlerFile,
             LoginHandlerFile,
             AdminHandlerFile,
@@ -642,6 +637,7 @@ public void mapBindingsWithNonProviderValue() {
         "    return builder().build();",
         "  }",
         "",
+        "  @SuppressWarnings(\"unchecked\")",
         "  private void initialize(final Builder builder) {",
         "    this.mapOfPathEnumAndProviderOfHandlerContribution1 =",
         "        MapModuleOne_ProvideAdminHandlerFactory.create(builder.mapModuleOne);",
@@ -682,7 +678,7 @@ public void mapBindingsWithNonProviderValue() {
         "",
         "    public Builder mapModuleOne(MapModuleOne mapModuleOne) {",
         "      if (mapModuleOne == null) {",
-        "        throw new NullPointerException(\"mapModuleOne\");",
+        "        throw new NullPointerException();",
         "      }",
         "      this.mapModuleOne = mapModuleOne;",
         "      return this;",
@@ -690,14 +686,14 @@ public void mapBindingsWithNonProviderValue() {
         "",
         "    public Builder mapModuleTwo(MapModuleTwo mapModuleTwo) {",
         "      if (mapModuleTwo == null) {",
-        "        throw new NullPointerException(\"mapModuleTwo\");",
+        "        throw new NullPointerException();",
         "      }",
         "      this.mapModuleTwo = mapModuleTwo;",
         "      return this;",
         "    }",
         "  }",
         "}");
-    assert_().about(javaSources())
+    assertAbout(javaSources())
         .that(ImmutableList.of(mapModuleOneFile,
             mapModuleTwoFile,
             enumKeyFile,
@@ -716,7 +712,6 @@ public void injectMapWithoutMapBinding() {
     JavaFileObject mapModuleFile = JavaFileObjects.forSourceLines("test.MapModule",
         "package test;",
         "",
-        "",
         "import dagger.Module;",
         "import dagger.Provides;",
         "import java.util.HashMap;",
@@ -735,7 +730,6 @@ public void injectMapWithoutMapBinding() {
         "",
         "import dagger.Component;",
         "import java.util.Map;",
-        "import javax.inject.Provider;",
         "",
         "@Component(modules = {MapModule.class})",
         "interface TestComponent {",
@@ -765,6 +759,7 @@ public void injectMapWithoutMapBinding() {
         "    return builder().build();",
         "  }",
         "",
+        "  @SuppressWarnings(\"unchecked\")",
         "  private void initialize(final Builder builder) {",
         "    this.provideAMapProvider = MapModule_ProvideAMapFactory.create(builder.mapModule);",
         "  }",
@@ -789,15 +784,123 @@ public void injectMapWithoutMapBinding() {
         "",
         "    public Builder mapModule(MapModule mapModule) {",
         "      if (mapModule == null) {",
-        "        throw new NullPointerException(\"mapModule\");",
+        "        throw new NullPointerException();",
         "      }",
         "      this.mapModule = mapModule;",
         "      return this;",
         "    }",
         "  }",
         "}");
-    assert_().about(javaSources()).that(ImmutableList.of(mapModuleFile,componentFile))
+    assertAbout(javaSources()).that(ImmutableList.of(mapModuleFile,componentFile))
         .processedWith(new ComponentProcessor()).compilesWithoutError()
         .and().generatesSources(generatedComponent);
   }
+
+  @Test
+  public void mapBindingsWithDuplicateKeys() {
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.MapModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.mapkeys.StringKey;",
+            "",
+            "import static dagger.Provides.Type.MAP;",
+            "",
+            "@Module",
+            "final class MapModule {",
+            "  @Provides(type = MAP) @StringKey(\"AKey\") Object provideObjectForAKey() {",
+            "    return \"one\";",
+            "  }",
+            "",
+            "  @Provides(type = MAP) @StringKey(\"AKey\") Object provideObjectForAKeyAgain() {",
+            "    return \"one again\";",
+            "  }",
+            "}");
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import java.util.Map;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component(modules = {MapModule.class})",
+            "interface TestComponent {",
+            "  Map<String, Object> objects();",
+            "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(module, componentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("The same map key is bound more than once")
+        .and()
+        .withErrorContaining("provideObjectForAKey()")
+        .and()
+        .withErrorContaining("provideObjectForAKeyAgain()")
+        .and()
+        .withErrorCount(1);
+  }
+
+  @Test
+  public void mapBindingsWithInconsistentKeyAnnotations() {
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.MapModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.mapkeys.StringKey;",
+            "",
+            "import static dagger.Provides.Type.MAP;",
+            "",
+            "@Module",
+            "final class MapModule {",
+            "  @Provides(type = MAP) @StringKey(\"AKey\") Object provideObjectForAKey() {",
+            "    return \"one\";",
+            "  }",
+            "",
+            "  @Provides(type = MAP) @StringKeyTwo(\"BKey\") Object provideObjectForBKey() {",
+            "    return \"two\";",
+            "  }",
+            "}");
+    JavaFileObject stringKeyTwoFile =
+        JavaFileObjects.forSourceLines(
+            "test.StringKeyTwo",
+            "package test;",
+            "",
+            "import dagger.MapKey;",
+            "",
+            "@MapKey(unwrapValue = true)",
+            "public @interface StringKeyTwo {",
+            "  String value();",
+            "}");
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import java.util.Map;",
+            "",
+            "@Component(modules = {MapModule.class})",
+            "interface TestComponent {",
+            "  Map<String, Object> objects();",
+            "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(module, stringKeyTwoFile, componentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("uses more than one @MapKey annotation type")
+        .and()
+        .withErrorContaining("provideObjectForAKey()")
+        .and()
+        .withErrorContaining("provideObjectForBKey()")
+        .and()
+        .withErrorCount(1);
+  }
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/MapKeyProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/MapKeyProcessorTest.java
index 531ae722b..191ee6c12 100644
--- a/compiler/src/test/java/dagger/internal/codegen/MapKeyProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/MapKeyProcessorTest.java
@@ -23,7 +23,7 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import static com.google.common.truth.Truth.assert_;
+import static com.google.common.truth.Truth.assertAbout;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
 
 @RunWith(JUnit4.class)
@@ -49,26 +49,27 @@ public void mapKeyCreatorFile() {
         "    ADMIN,",
         "    LOGIN;",
         "}");
-    JavaFileObject generatedKeyCreator = JavaFileObjects.forSourceLines("test.PathKeyCreator",
-        "package test;",
-        "",
-        "import javax.annotation.Generated;",
-        "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class PathKeyCreator {",
-        "  @com.google.auto.value.AutoAnnotation",
-        "  public static PathKey createPathKey(PathEnum value, String relativePath) {",
-        "    return new AutoAnnotation_PathKeyCreator_createPathKey(value, relativePath);",
-        "  }",
-        "}");
-    assert_().about(javaSources())
-    .that(ImmutableList.of(
-        enumKeyFile,
-        pathEnumFile))
-    .processedWith(new ComponentProcessor(), new AutoAnnotationProcessor())
-    .compilesWithoutError()
-    .and()
-    .generatesSources(generatedKeyCreator);
+    JavaFileObject generatedKeyCreator =
+        JavaFileObjects.forSourceLines(
+            "test.PathKeyCreator",
+            "package test;",
+            "",
+            "import com.google.auto.value.AutoAnnotation;",
+            "import javax.annotation.Generated;",
+            "",
+            "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+            "public final class PathKeyCreator {",
+            "  @AutoAnnotation",
+            "  public static PathKey createPathKey(PathEnum value, String relativePath) {",
+            "    return new AutoAnnotation_PathKeyCreator_createPathKey(value, relativePath);",
+            "  }",
+            "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(enumKeyFile, pathEnumFile))
+        .processedWith(new ComponentProcessor(), new AutoAnnotationProcessor())
+        .compilesWithoutError()
+        .and()
+        .generatesSources(generatedKeyCreator);
   }
 
   @Test
@@ -95,28 +96,28 @@ public void nestedMapKeyCreatorFile() {
         "    LOGIN;",
         "}");
     JavaFileObject generatedKeyCreator =
-        JavaFileObjects.forSourceLines("test.Container$PathKeyCreator",
+        JavaFileObjects.forSourceLines(
+            "test.Container$PathKeyCreator",
             "package test;",
             "",
+            "import com.google.auto.value.AutoAnnotation;",
             "import javax.annotation.Generated;",
             "import test.Container.PathKey",
             "",
             "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
             "public final class Container$PathKeyCreator {",
-            "  @com.google.auto.value.AutoAnnotation",
+            "  @AutoAnnotation",
             "  public static PathKey createPathKey(PathEnum value, String relativePath) {",
             "    return new AutoAnnotation_Container$PathKeyCreator_createPathKey(",
             "        value, relativePath);",
             "  }",
             "}");
-    assert_().about(javaSources())
-    .that(ImmutableList.of(
-        enumKeyFile,
-        pathEnumFile))
-    .processedWith(new ComponentProcessor(), new AutoAnnotationProcessor())
-    .compilesWithoutError()
-    .and()
-    .generatesSources(generatedKeyCreator);
+    assertAbout(javaSources())
+        .that(ImmutableList.of(enumKeyFile, pathEnumFile))
+        .processedWith(new ComponentProcessor(), new AutoAnnotationProcessor())
+        .compilesWithoutError()
+        .and()
+        .generatesSources(generatedKeyCreator);
   }
 
   @Test
@@ -225,6 +226,7 @@ public void mapKeyComponentFileWithDisorderedKeyField() {
         "    return builder().build();",
         "  }",
         "",
+        "  @SuppressWarnings(\"unchecked\")",
         "  private void initialize(final Builder builder) {",
         "    this.mapOfPathKeyAndProviderOfHandlerContribution1 =",
         "        MapModuleOne_ProvideAdminHandlerFactory.create(builder.mapModuleOne);",
@@ -263,7 +265,7 @@ public void mapKeyComponentFileWithDisorderedKeyField() {
         "",
         "    public Builder mapModuleOne(MapModuleOne mapModuleOne) {",
         "      if (mapModuleOne == null) {",
-        "        throw new NullPointerException(\"mapModuleOne\");",
+        "        throw new NullPointerException();",
         "      }",
         "      this.mapModuleOne = mapModuleOne;",
         "      return this;",
@@ -271,23 +273,24 @@ public void mapKeyComponentFileWithDisorderedKeyField() {
         "",
         "    public Builder mapModuleTwo(MapModuleTwo mapModuleTwo) {",
         "      if (mapModuleTwo == null) {",
-        "        throw new NullPointerException(\"mapModuleTwo\");",
+        "        throw new NullPointerException();",
         "      }",
         "      this.mapModuleTwo = mapModuleTwo;",
         "      return this;",
         "    }",
         "  }",
         "}");
-    assert_().about(javaSources())
-        .that(ImmutableList.of(
-            mapModuleOneFile,
-            mapModuleTwoFile,
-            enumKeyFile,
-            pathEnumFile,
-            handlerFile,
-            loginHandlerFile,
-            adminHandlerFile,
-            componentFile))
+    assertAbout(javaSources())
+        .that(
+            ImmutableList.of(
+                mapModuleOneFile,
+                mapModuleTwoFile,
+                enumKeyFile,
+                pathEnumFile,
+                handlerFile,
+                loginHandlerFile,
+                adminHandlerFile,
+                componentFile))
         .processedWith(new ComponentProcessor(), new AutoAnnotationProcessor())
         .compilesWithoutError()
         .and()
@@ -399,6 +402,7 @@ public void mapKeyComponentFileWithDefaultField() {
         "    return builder().build();",
         "  }",
         "",
+        "  @SuppressWarnings(\"unchecked\")",
         "  private void initialize(final Builder builder) {",
         "    this.mapOfPathKeyAndProviderOfHandlerContribution1 =",
         "        MapModuleOne_ProvideAdminHandlerFactory.create(builder.mapModuleOne);",
@@ -437,7 +441,7 @@ public void mapKeyComponentFileWithDefaultField() {
         "",
         "    public Builder mapModuleOne(MapModuleOne mapModuleOne) {",
         "      if (mapModuleOne == null) {",
-        "        throw new NullPointerException(\"mapModuleOne\");",
+        "        throw new NullPointerException();",
         "      }",
         "      this.mapModuleOne = mapModuleOne;",
         "      return this;",
@@ -445,23 +449,24 @@ public void mapKeyComponentFileWithDefaultField() {
         "",
         "    public Builder mapModuleTwo(MapModuleTwo mapModuleTwo) {",
         "      if (mapModuleTwo == null) {",
-        "        throw new NullPointerException(\"mapModuleTwo\");",
+        "        throw new NullPointerException();",
         "      }",
         "      this.mapModuleTwo = mapModuleTwo;",
         "      return this;",
         "    }",
         "  }",
         "}");
-    assert_().about(javaSources())
-        .that(ImmutableList.of(
-            mapModuleOneFile,
-            mapModuleTwoFile,
-            enumKeyFile,
-            pathEnumFile,
-            handlerFile,
-            loginHandlerFile,
-            adminHandlerFile,
-            componentFile))
+    assertAbout(javaSources())
+        .that(
+            ImmutableList.of(
+                mapModuleOneFile,
+                mapModuleTwoFile,
+                enumKeyFile,
+                pathEnumFile,
+                handlerFile,
+                loginHandlerFile,
+                adminHandlerFile,
+                componentFile))
         .processedWith(new ComponentProcessor(), new AutoAnnotationProcessor())
         .compilesWithoutError()
         .and()
diff --git a/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java b/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java
index 25762ea94..52be72ae9 100644
--- a/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java
@@ -15,8 +15,16 @@
  */
 package dagger.internal.codegen;
 
+import com.google.common.base.Joiner;
 import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
 import com.google.testing.compile.JavaFileObjects;
+import java.io.IOException;
+import java.io.Writer;
+import java.util.Set;
+import javax.annotation.processing.AbstractProcessor;
+import javax.annotation.processing.RoundEnvironment;
+import javax.lang.model.element.TypeElement;
 import javax.tools.JavaFileObject;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -25,6 +33,7 @@
 import static com.google.common.truth.Truth.assertAbout;
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+import static javax.tools.StandardLocation.CLASS_OUTPUT;
 
 @RunWith(JUnit4.class)
 public class MembersInjectionTest {
@@ -79,6 +88,7 @@ public void parentClass_noInjectedMembers() {
         "    return builder().build();",
         "  }",
         "",
+        "  @SuppressWarnings(\"unchecked\")",
         "  private void initialize(final Builder builder) {",
         "    this.childProvider =",
         "        Child_Factory.create((MembersInjector) MembersInjectors.noOp());",
@@ -141,59 +151,58 @@ public void parentClass_injectedMembersInSupertype() {
         "interface TestComponent {",
         "  Child child();",
         "}");
-    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
-        "test.DaggerTestComponent",
-        "package test;",
-        "",
-        "import dagger.MembersInjector;",
-        "import dagger.internal.MembersInjectors;",
-        "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
-        "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class DaggerTestComponent implements TestComponent {",
-        "  private MembersInjector<Parent> parentMembersInjector;",
-        "  private MembersInjector<Child> childMembersInjector;",
-        "  private Provider<Child> childProvider;",
-        "",
-        "  private DaggerTestComponent(Builder builder) {",
-        "    assert builder != null;",
-        "    initialize(builder);",
-        "  }",
-        "",
-        "  public static Builder builder() {",
-        "    return new Builder();",
-        "  }",
-        "",
-        "  public static TestComponent create() {",
-        "    return builder().build();",
-        "  }",
-        "",
-        "  private void initialize(final Builder builder) {",
-        "    this.parentMembersInjector = Parent_MembersInjector.create(Dep_Factory.create());",
-        "    this.childMembersInjector = MembersInjectors.delegatingTo(parentMembersInjector);",
-        "    this.childProvider = Child_Factory.create(childMembersInjector);",
-        "  }",
-        "",
-        "  @Override",
-        "  public Child child() {",
-        "    return childProvider.get();",
-        "  }",
-        "",
-        "  public static final class Builder {",
-        "    private Builder() {",
-        "    }",
-        "",
-        "    public TestComponent build() {",
-        "      return new DaggerTestComponent(this);",
-        "    }",
-        "  }",
-        "}");
+    JavaFileObject generatedComponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerTestComponent",
+            "package test;",
+            "",
+            "import dagger.MembersInjector;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+            "public final class DaggerTestComponent implements TestComponent {",
+            "  private MembersInjector<Child> childMembersInjector;",
+            "  private Provider<Child> childProvider;",
+            "",
+            "  private DaggerTestComponent(Builder builder) {",
+            "    assert builder != null;",
+            "    initialize(builder);",
+            "  }",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static TestComponent create() {",
+            "    return builder().build();",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize(final Builder builder) {",
+            "    this.childMembersInjector = Child_MembersInjector.create(Dep_Factory.create());",
+            "    this.childProvider = Child_Factory.create(childMembersInjector);",
+            "  }",
+            "",
+            "  @Override",
+            "  public Child child() {",
+            "    return childProvider.get();",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private Builder() {}",
+            "",
+            "    public TestComponent build() {",
+            "      return new DaggerTestComponent(this);",
+            "    }",
+            "  }",
+            "}");
     assertAbout(javaSources())
         .that(ImmutableList.of(childFile, parentFile, depFile, componentFile))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
-        .and().generatesSources(generatedComponent);
+        .and()
+        .generatesSources(generatedComponent);
   }
 
   @Test public void fieldAndMethodGenerics() {
@@ -209,7 +218,8 @@ public void parentClass_injectedMembersInSupertype() {
         "",
         " @Inject void register(B b) {}",
         "}");
-    JavaFileObject expected = JavaFileObjects.forSourceLines("test.GenericClass_MembersInjector",
+    JavaFileObject expected = JavaFileObjects.forSourceLines(
+        "test.GenericClass_MembersInjector",
         "package test;",
         "",
         "import dagger.MembersInjector;",
@@ -232,21 +242,33 @@ public void parentClass_injectedMembersInSupertype() {
         "  @Override",
         "  public void injectMembers(GenericClass<A, B> instance) {",
         "    if (instance == null) {",
-        "      throw new NullPointerException(\"Cannot inject members into a null reference\")",
+        "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
         "    }",
         "    instance.a = aProvider.get();",
-        "    instance.register(bProvider.get())",
+        "    instance.register(bProvider.get());",
         "  }",
         "",
         "  public static <A, B> MembersInjector<GenericClass<A, B>> create(",
         "      Provider<A> aProvider, Provider<B> bProvider) {",
         "    return new GenericClass_MembersInjector<A, B>(aProvider, bProvider);",
         "  }",
+        "",
+        "  public static <A, B> void injectA(GenericClass<A, B> instance, Provider<A> aProvider) {",
+        "    instance.a = aProvider.get();",
+        "  }",
+        "",
+        "  public static <A, B> void injectRegister(",
+        "      GenericClass<A, B> instance, Provider<B> bProvider) {",
+        "    instance.register(bProvider.get());",
+        "  }",
+        "",
         "}");
-    assertAbout(javaSource()).that(file)
+    assertAbout(javaSource())
+        .that(file)
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
-        .and().generatesSources(expected);
+        .and()
+        .generatesSources(expected);
   }
 
   @Test public void subclassedGenericMembersInjectors() {
@@ -289,7 +311,8 @@ public void parentClass_injectedMembersInSupertype() {
         "",
         "  @Inject Child() {}",
         "}");
-    JavaFileObject expected = JavaFileObjects.forSourceLines("test.GenericClass_MembersInjector",
+    JavaFileObject expected = JavaFileObjects.forSourceLines(
+        "test.Child_MembersInjector",
         "package test;",
         "",
         "import dagger.MembersInjector;",
@@ -299,41 +322,51 @@ public void parentClass_injectedMembersInSupertype() {
         "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
         "public final class Child_MembersInjector<T>",
         "    implements MembersInjector<Child<T>> {",
-        "  private final MembersInjector<Parent<T, A>> supertypeInjector;",
-        "  private final Provider<A> aProvider;",
-        "  private final Provider<T> tProvider;",
+        "  private final Provider<T> tAndXProvider;",
+        "  private final Provider<A> aAndYProvider;",
+        "  private final Provider<A2> a2Provider;",
         "",
         "  public Child_MembersInjector(",
-        "      MembersInjector<Parent<T, A>> supertypeInjector, ",
-        "      Provider<A> aProvider, Provider<T> tProvider) {",
-        "    assert supertypeInjector != null;",
-        "    this.supertypeInjector = supertypeInjector;",
-        "    assert aProvider != null;",
-        "    this.aProvider = aProvider;",
-        "    assert tProvider != null;",
-        "    this.tProvider = tProvider;",
+        "      Provider<T> tAndXProvider, Provider<A> aAndYProvider, Provider<A2> a2Provider) {",
+        "    assert tAndXProvider != null;",
+        "    this.tAndXProvider = tAndXProvider;",
+        "    assert aAndYProvider != null;",
+        "    this.aAndYProvider = aAndYProvider;",
+        "    assert a2Provider != null;",
+        "    this.a2Provider = a2Provider;",
         "  }",
         "",
         "  @Override",
         "  public void injectMembers(Child<T> instance) {",
         "    if (instance == null) {",
-        "      throw new NullPointerException(\"Cannot inject members into a null reference\")",
+        "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
         "    }",
-        "    supertypeInjector.injectMembers(instance);",
-        "    instance.a = aProvider.get();",
-        "    instance.t = tProvider.get();",
+        "    ((test.Parent) instance).x = tAndXProvider.get();",
+        "    ((test.Parent) instance).y = aAndYProvider.get();",
+        "    ((test.Parent) instance).a2 = a2Provider.get();",
+        "    instance.a = aAndYProvider.get();",
+        "    instance.t = tAndXProvider.get();",
         "  }",
         "",
         "  public static <T> MembersInjector<Child<T>> create(",
-        "      MembersInjector<Parent<T, A>> supertypeInjector, ",
-        "      Provider<A> aProvider, Provider<T> tProvider) {",
-        "    return new Child_MembersInjector<T>(supertypeInjector, aProvider, tProvider);",
+        "      Provider<T> tAndXProvider, Provider<A> aAndYProvider, Provider<A2> a2Provider) {",
+        "    return new Child_MembersInjector<T>(tAndXProvider, aAndYProvider, a2Provider);",
+        "  }",
+        "",
+        "  public static <T> void injectA(Child<T> instance, Provider<A> aProvider) {",
+        "    instance.a = aProvider.get();",
+        "  }",
+        "",
+        "  public static <T> void injectT(Child<T> instance, Provider<T> tProvider) {",
+        "    instance.t = tProvider.get();",
         "  }",
         "}");
-    assertAbout(javaSources()).that(ImmutableList.of(a, a2, parent, child))
+    assertAbout(javaSources())
+        .that(ImmutableList.of(a, a2, parent, child))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
-        .and().generatesSources(expected);
+        .and()
+        .generatesSources(expected);
   }
 
   @Test public void fieldInjection() {
@@ -349,7 +382,8 @@ public void parentClass_injectedMembersInSupertype() {
         "  @Inject Lazy<String> lazyString;",
         "  @Inject Provider<String> stringProvider;",
         "}");
-    JavaFileObject expected = JavaFileObjects.forSourceLines("test.FieldInjection_MembersInjector",
+    JavaFileObject expected = JavaFileObjects.forSourceLines(
+        "test.FieldInjection_MembersInjector",
         "package test;",
         "",
         "import dagger.MembersInjector;",
@@ -358,9 +392,8 @@ public void parentClass_injectedMembersInSupertype() {
         "import javax.inject.Provider;",
         "",
         "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class FieldInjection_MembersInjector ",
+        "public final class FieldInjection_MembersInjector",
         "    implements MembersInjector<FieldInjection> {",
-        "",
         "  private final Provider<String> stringProvider;",
         "",
         "  public FieldInjection_MembersInjector(Provider<String> stringProvider) {",
@@ -368,7 +401,8 @@ public void parentClass_injectedMembersInSupertype() {
         "    this.stringProvider = stringProvider;",
         "  }",
         "",
-        "  @Override public void injectMembers(FieldInjection instance) {",
+        "  @Override",
+        "  public void injectMembers(FieldInjection instance) {",
         "    if (instance == null) {",
         "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
         "    }",
@@ -377,14 +411,31 @@ public void parentClass_injectedMembersInSupertype() {
         "    instance.stringProvider = stringProvider;",
         "  }",
         "",
-        "  public static MembersInjector<FieldInjection> create(",
-        "      Provider<String> stringProvider) {",
+        "  public static MembersInjector<FieldInjection> create(Provider<String> stringProvider) {",
         "    return new FieldInjection_MembersInjector(stringProvider);",
         "  }",
+        "",
+        "  public static void injectString(",
+        "      FieldInjection instance, Provider<String> stringProvider) {",
+        "    instance.string = stringProvider.get();",
+        "  }",
+        "",
+        "  public static void injectLazyString(",
+        "      FieldInjection instance, Provider<String> lazyStringProvider) {",
+        "    instance.lazyString = DoubleCheckLazy.create(lazyStringProvider);",
+        "  }",
+        "",
+        "  public static void injectStringProvider(",
+        "      FieldInjection instance, Provider<String> stringProvider) {",
+        "    instance.stringProvider = stringProvider;",
+        "  }",
         "}");
-    assertAbout(javaSource()).that(file).processedWith(new ComponentProcessor())
+    assertAbout(javaSource())
+        .that(file)
+        .processedWith(new ComponentProcessor())
         .compilesWithoutError()
-        .and().generatesSources(expected);
+        .and()
+        .generatesSources(expected);
   }
 
   @Test public void methodInjection() {
@@ -411,8 +462,8 @@ public void parentClass_injectedMembersInSupertype() {
         "import javax.inject.Provider;",
         "",
         "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class MethodInjection_MembersInjector ",
-        "    implements MembersInjector<MethodInjection> {",
+        "public final class MethodInjection_MembersInjector",
+        "     implements MembersInjector<MethodInjection> {",
         "",
         "  private final Provider<String> stringProvider;",
         "",
@@ -421,7 +472,8 @@ public void parentClass_injectedMembersInSupertype() {
         "    this.stringProvider = stringProvider;",
         "  }",
         "",
-        "  @Override public void injectMembers(MethodInjection instance) {",
+        "  @Override",
+        "  public void injectMembers(MethodInjection instance) {",
         "    if (instance == null) {",
         "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
         "    }",
@@ -435,14 +487,39 @@ public void parentClass_injectedMembersInSupertype() {
         "      Provider<String> stringProvider) {",
         "    return new MethodInjection_MembersInjector(stringProvider);",
         "  }",
+        "",
+        "  public static void injectNoArgs(MethodInjection instance) {",
+        "    instance.noArgs();",
+        "  }",
+        "",
+        "  public static void injectOneArg(",
+        "      MethodInjection instance, Provider<String> stringProvider) {",
+        "    instance.oneArg(stringProvider.get());",
+        "  }",
+        "",
+        "  public static void injectManyArgs(",
+        "      MethodInjection instance,",
+        "      Provider<String> stringProvider,",
+        "      Provider<String> lazyStringProvider,",
+        "      Provider<String> stringProvider2) {",
+        "    instance.manyArgs(",
+        "        stringProvider.get(),",
+        "        DoubleCheckLazy.create(lazyStringProvider),",
+        "        stringProvider2);",
+        "  }",
         "}");
-    assertAbout(javaSource()).that(file).processedWith(new ComponentProcessor())
+    assertAbout(javaSource())
+        .that(file)
+        .processedWith(new ComponentProcessor())
         .compilesWithoutError()
-        .and().generatesSources(expected);
+        .and()
+        .generatesSources(expected);
   }
 
-  @Test public void mixedMemberInjection() {
-    JavaFileObject file = JavaFileObjects.forSourceLines("test.MixedMemberInjection",
+  @Test
+  public void mixedMemberInjection() {
+    JavaFileObject file = JavaFileObjects.forSourceLines(
+        "test.MixedMemberInjection",
         "package test;",
         "",
         "import dagger.Lazy;",
@@ -464,13 +541,14 @@ public void parentClass_injectedMembersInSupertype() {
         "import javax.inject.Provider;",
         "",
         "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class MixedMemberInjection_MembersInjector ",
+        "public final class MixedMemberInjection_MembersInjector",
         "    implements MembersInjector<MixedMemberInjection> {",
         "",
         "  private final Provider<String> stringAndSProvider;",
         "  private final Provider<Object> objectAndOProvider;",
         "",
-        "  public MixedMemberInjection_MembersInjector(Provider<String> stringAndSProvider,",
+        "  public MixedMemberInjection_MembersInjector(",
+        "      Provider<String> stringAndSProvider,",
         "      Provider<Object> objectAndOProvider) {",
         "    assert stringAndSProvider != null;",
         "    this.stringAndSProvider = stringAndSProvider;",
@@ -478,7 +556,8 @@ public void parentClass_injectedMembersInSupertype() {
         "    this.objectAndOProvider = objectAndOProvider;",
         "  }",
         "",
-        "  @Override public void injectMembers(MixedMemberInjection instance) {",
+        "  @Override",
+        "  public void injectMembers(MixedMemberInjection instance) {",
         "    if (instance == null) {",
         "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
         "    }",
@@ -494,10 +573,32 @@ public void parentClass_injectedMembersInSupertype() {
         "    return new MixedMemberInjection_MembersInjector(",
         "        stringAndSProvider, objectAndOProvider);",
         "  }",
+        "  public static void injectString(",
+        "      MixedMemberInjection instance, Provider<String> stringProvider) {",
+        "    instance.string = stringProvider.get();",
+        "  }",
+        "",
+        "  public static void injectObject(",
+        "      MixedMemberInjection instance, Provider<Object> objectProvider) {",
+        "    instance.object = objectProvider.get();",
+        "  }",
+        "",
+        "  public static void injectSetString(",
+        "      MixedMemberInjection instance, Provider<String> sProvider) {",
+        "    instance.setString(sProvider.get());",
+        "  }",
+        "",
+        "  public static void injectSetObject(",
+        "      MixedMemberInjection instance, Provider<Object> oProvider) {",
+        "    instance.setObject(oProvider.get());",
+        "  }",
         "}");
-    assertAbout(javaSource()).that(file).processedWith(new ComponentProcessor())
+    assertAbout(javaSource())
+        .that(file)
+        .processedWith(new ComponentProcessor())
         .compilesWithoutError()
-        .and().generatesSources(expected);
+        .and()
+        .generatesSources(expected);
   }
 
   @Test public void injectConstructorAndMembersInjection() {
@@ -530,7 +631,8 @@ public void parentClass_injectedMembersInSupertype() {
         "    this.sProvider = sProvider;",
         "  }",
         "",
-        "  @Override public void injectMembers(AllInjections instance) {",
+        "  @Override",
+        "  public void injectMembers(AllInjections instance) {",
         "    if (instance == null) {",
         "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
         "    }",
@@ -539,10 +641,16 @@ public void parentClass_injectedMembersInSupertype() {
         "  }",
         "",
         "  public static MembersInjector<AllInjections> create(Provider<String> sProvider) {",
-        "    return new AllInjections_MembersInjector(sProvider);",
+        "      return new AllInjections_MembersInjector(sProvider);",
+        "  }",
+        "",
+        "  public static void injectS(AllInjections instance, Provider<String> sProvider) {",
+        "    instance.s = sProvider.get();",
         "  }",
         "}");
-    assertAbout(javaSource()).that(file).processedWith(new ComponentProcessor())
+    assertAbout(javaSource())
+        .that(file)
+        .processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and()
         .generatesSources(expectedMembersInjector);
@@ -570,93 +678,244 @@ public void parentClass_injectedMembersInSupertype() {
         "import javax.inject.Provider;",
         "",
         "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class B_MembersInjector ",
-        "    implements MembersInjector<B> {",
-        "",
-        "  private final MembersInjector<A> supertypeInjector;",
+        "public final class B_MembersInjector implements MembersInjector<B> {",
         "  private final Provider<String> sProvider;",
         "",
-        "  public B_MembersInjector(MembersInjector<A> supertypeInjector,",
-        "      Provider<String> sProvider) {",
-        "    assert supertypeInjector != null;",
-        "    this.supertypeInjector = supertypeInjector;",
+        "  public B_MembersInjector(Provider<String> sProvider) {",
         "    assert sProvider != null;",
         "    this.sProvider = sProvider;",
         "  }",
         "",
-        "  @Override public void injectMembers(B instance) {",
+        "  @Override",
+        "  public void injectMembers(B instance) {",
         "    if (instance == null) {",
         "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
         "    }",
-        "    supertypeInjector.injectMembers(instance);",
         "    instance.s = sProvider.get();",
         "  }",
         "",
-        "  public static MembersInjector<B> create(",
-        "      MembersInjector<A> supertypeInjector,",
-        "      Provider<String> sProvider) {",
-        "    return new B_MembersInjector(supertypeInjector, sProvider);",
+        "  public static MembersInjector<B> create(Provider<String> sProvider) {",
+        "      return new B_MembersInjector(sProvider);",
+        "  }",
+        "  public static void injectS(B instance, Provider<String> sProvider) {",
+        "    instance.s = sProvider.get();",
         "  }",
         "}");
-    assertAbout(javaSources()).that(ImmutableList.of(aFile, bFile))
+    assertAbout(javaSources())
+        .that(ImmutableList.of(aFile, bFile))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
-        .and().generatesSources(expectedMembersInjector);
+        .and()
+        .generatesSources(expectedMembersInjector);
   }
 
-  @Test public void simpleComponentWithNesting() {
-    JavaFileObject nestedTypesFile = JavaFileObjects.forSourceLines("test.OuterType",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import javax.inject.Inject;",
-        "",
-        "final class OuterType {",
-        "  static class A {",
-        "    @Inject A() {}",
-        "  }",
-        "  static class B {",
-        "    @Inject A a;",
-        "  }",
-        "  @Component interface SimpleComponent {",
-        "    A a();",
-        "    void inject(B b);",
-        "  }",
-        "}");
+  @Test
+  public void simpleComponentWithNesting() {
+    JavaFileObject nestedTypesFile = JavaFileObjects.forSourceLines(
+          "test.OuterType",
+          "package test;",
+          "",
+          "import dagger.Component;",
+          "import javax.inject.Inject;",
+          "",
+          "final class OuterType {",
+          "  static class A {",
+          "    @Inject A() {}",
+          "  }",
+          "  static class B {",
+          "    @Inject A a;",
+          "  }",
+          "  @Component interface SimpleComponent {",
+          "    A a();",
+          "    void inject(B b);",
+          "  }",
+          "}");
     JavaFileObject bMembersInjector = JavaFileObjects.forSourceLines(
-        "test.OuterType$B_MembersInjector",
-        "package test;",
-        "",
-        "import dagger.MembersInjector;",
-        "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
-        "import test.OuterType.A;",
-        "import test.OuterType.B;",
-        "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class OuterType$B_MembersInjector implements MembersInjector<B> {",
-        "  private final Provider<A> aProvider;",
-        "",
-        "  public OuterType$B_MembersInjector(Provider<A> aProvider) {",
-        "    assert aProvider != null;",
-        "    this.aProvider = aProvider;",
-        "  }",
-         "",
-        "  @Override",
-        "  public void injectMembers(B instance) {",
-        "    if (instance == null) {",
-        "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
-        "    }",
-        "    instance.a = aProvider.get();",
-        "  }",
-        "",
-        "  public static MembersInjector<B> create(Provider<A> aProvider) {",
-        "    return new OuterType$B_MembersInjector(aProvider);",
-        "  }",
-        "}");
-    assertAbout(javaSources()).that(ImmutableList.of(nestedTypesFile))
+          "test.OuterType$B_MembersInjector",
+          "package test;",
+          "",
+          "import dagger.MembersInjector;",
+          "import javax.annotation.Generated;",
+          "import javax.inject.Provider;",
+          "import test.OuterType.A;",
+          "import test.OuterType.B;",
+          "",
+          "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+          "public final class OuterType$B_MembersInjector implements MembersInjector<B> {",
+          "  private final Provider<A> aProvider;",
+          "",
+          "  public OuterType$B_MembersInjector(Provider<A> aProvider) {",
+          "    assert aProvider != null;",
+          "    this.aProvider = aProvider;",
+          "  }",
+          "",
+          "  @Override",
+          "  public void injectMembers(B instance) {",
+          "    if (instance == null) {",
+          "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
+          "    }",
+          "    instance.a = aProvider.get();",
+          "  }",
+          "",
+          "  public static MembersInjector<B> create(Provider<A> aProvider) {",
+          "    return new OuterType$B_MembersInjector(aProvider);",
+          "  }",
+          "",
+          "  public static void injectA(B instance, Provider<A> aProvider) {",
+          "    instance.a = aProvider.get();",
+          "  }",
+          "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(nestedTypesFile))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and()
+        .generatesSources(bMembersInjector);
+  }
+
+  @Test
+  public void componentWithNestingAndGeneratedType() {
+    JavaFileObject nestedTypesFile =
+        JavaFileObjects.forSourceLines(
+            "test.OuterType",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Inject;",
+            "",
+            "final class OuterType {",
+            "  @Inject GeneratedType generated;",
+            "  static class A {",
+            "    @Inject A() {}",
+            "  }",
+            "  static class B {",
+            "    @Inject A a;",
+            "  }",
+            "  @Component interface SimpleComponent {",
+            "    A a();",
+            "    void inject(B b);",
+            "  }",
+            "}");
+    JavaFileObject bMembersInjector =
+        JavaFileObjects.forSourceLines(
+            "test.OuterType$B_MembersInjector",
+            "package test;",
+            "",
+            "import dagger.MembersInjector;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "import test.OuterType.A;",
+            "import test.OuterType.B;",
+            "",
+            "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+            "public final class OuterType$B_MembersInjector implements MembersInjector<B> {",
+            "  private final Provider<A> aProvider;",
+            "",
+            "  public OuterType$B_MembersInjector(Provider<A> aProvider) {",
+            "    assert aProvider != null;",
+            "    this.aProvider = aProvider;",
+            "  }",
+            "",
+            "  @Override",
+            "  public void injectMembers(B instance) {",
+            "    if (instance == null) {",
+            "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
+            "    }",
+            "    instance.a = aProvider.get();",
+            "  }",
+            "",
+            "  public static MembersInjector<B> create(Provider<A> aProvider) {",
+            "    return new OuterType$B_MembersInjector(aProvider);",
+            "  }",
+            "",
+            "  public static void injectA(B instance, Provider<A> aProvider) {",
+            "    instance.a = aProvider.get();",
+            "  }",
+            "}");
+    assertAbout(javaSource())
+        .that(nestedTypesFile)
+        .processedWith(
+            new ComponentProcessor(),
+            new AbstractProcessor() {
+              private boolean done;
+
+              @Override
+              public Set<String> getSupportedAnnotationTypes() {
+                return ImmutableSet.of("*");
+              }
+
+              @Override
+              public boolean process(
+                  Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
+                if (!done) {
+                  done = true;
+                  try (Writer writer =
+                          processingEnv
+                              .getFiler()
+                              .createSourceFile("test.GeneratedType")
+                              .openWriter()) {
+                    writer.write(
+                        Joiner.on('\n')
+                            .join(
+                                "package test;",
+                                "",
+                                "import javax.inject.Inject;",
+                                "",
+                                "class GeneratedType {",
+                                "  @Inject GeneratedType() {}",
+                                "}"));
+                  } catch (IOException e) {
+                    throw new RuntimeException(e);
+                  }
+                }
+                return false;
+              }
+            })
+        .compilesWithoutError()
+        .and()
+        .generatesSources(bMembersInjector);
+  }
+
+  @Test
+  public void lowerCaseNamedMembersInjector_forLowerCaseType() {
+    JavaFileObject foo =
+        JavaFileObjects.forSourceLines(
+            "test.foo",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class foo {",
+            "  @Inject String string;",
+            "}");
+    JavaFileObject fooModule =
+        JavaFileObjects.forSourceLines(
+            "test.fooModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "class fooModule {",
+            "  @Provides String string() { return \"foo\"; }",
+            "}");
+    JavaFileObject fooComponent =
+        JavaFileObjects.forSourceLines(
+            "test.fooComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = fooModule.class)",
+            "interface fooComponent {",
+            "  void inject(foo target);",
+            "}");
+
+    assertAbout(javaSources())
+        .that(ImmutableList.of(foo, fooModule, fooComponent))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
-        .and().generatesSources(bMembersInjector);
+        .and().generatesFileNamed(CLASS_OUTPUT, "test", "foo_MembersInjector.class");
   }
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/MissingBindingSuggestionsTest.java b/compiler/src/test/java/dagger/internal/codegen/MissingBindingSuggestionsTest.java
index 0ae01b40c..03ec35d9b 100644
--- a/compiler/src/test/java/dagger/internal/codegen/MissingBindingSuggestionsTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/MissingBindingSuggestionsTest.java
@@ -15,17 +15,14 @@
  */
 package dagger.internal.codegen;
 
-import com.google.common.base.Joiner;
 import com.google.common.collect.ImmutableList;
 import com.google.testing.compile.JavaFileObjects;
-import java.util.Arrays;
 import javax.tools.JavaFileObject;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
 import static com.google.common.truth.Truth.assertAbout;
-import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
 
 @RunWith(JUnit4.class)
diff --git a/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java b/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
index 1eeda25e3..72248e0c7 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
@@ -322,11 +322,13 @@ private String formatModuleErrorMessage(String msg) {
         "",
         "@Module(includes = Void.class)",
         "class TestModule {}");
-    assertAbout(javaSources()).that(ImmutableList.of(module))
+    assertAbout(javaSources())
+        .that(ImmutableList.of(module))
         .processedWith(new ComponentProcessor())
         .failsToCompile()
-        .withErrorContaining(String.format(ErrorMessages.REFERENCED_MODULE_NOT_ANNOTATED,
-            "java.lang.Void", "Module"));
+        .withErrorContaining(
+            String.format(
+                ErrorMessages.REFERENCED_MODULE_NOT_ANNOTATED, "java.lang.Void", "@Module"));
   }
 
   @Test public void referencedModulesMustNotBeAbstract() {
diff --git a/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java b/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
index 9e209bb00..f9c287859 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+// TODO(beder): Merge the error-handling tests with the ModuleFactoryGeneratorTest.
 package dagger.internal.codegen;
 
 import com.google.common.collect.ImmutableList;
@@ -378,6 +379,31 @@ public void enclosedInPrivateModule() {
         .in(moduleFile).onLine(7);
   }
 
+  @Test
+  public void includesNonModule() {
+    JavaFileObject xFile =
+        JavaFileObjects.forSourceLines("test.X", "package test;", "", "public final class X {}");
+    JavaFileObject moduleFile =
+        JavaFileObjects.forSourceLines(
+            "test.FooModule",
+            "package test;",
+            "",
+            "import dagger.producers.ProducerModule;",
+            "",
+            "@ProducerModule(includes = X.class)",
+            "public final class FooModule {",
+            "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(xFile, moduleFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            String.format(
+                ErrorMessages.REFERENCED_MODULE_NOT_ANNOTATED,
+                "X",
+                "one of @Module, @ProducerModule"));
+  }
+
   @Test
   public void publicModuleNonPublicIncludes() {
     JavaFileObject publicModuleFile = JavaFileObjects.forSourceLines("test.PublicModule",
@@ -440,699 +466,65 @@ public void publicModuleNonPublicIncludes() {
         "    return null;",
         "  }",
         "}");
-    JavaFileObject factoryFile = JavaFileObjects.forSourceLines("TestModule_ProduceStringFactory",
-        "package test;",
-        "",
-        "import com.google.common.util.concurrent.Futures;",
-        "import com.google.common.util.concurrent.ListenableFuture;",
-        "import dagger.producers.internal.AbstractProducer;",
-        "import dagger.producers.internal.Producers;",
-        "import java.util.concurrent.Callable;",
-        "import java.util.concurrent.Executor;",
-        "import javax.annotation.Generated;",
-        "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class TestModule_ProduceStringFactory extends AbstractProducer<String> {",
-        "  private final TestModule module;",
-        "  private final Executor executor;",
-        "",
-        "  public TestModule_ProduceStringFactory(TestModule module, Executor executor) {",
-        "    assert module != null;",
-        "    this.module = module;",
-        "    assert executor != null;",
-        "    this.executor = executor;",
-        "  }",
-        "",
-        "  @Override protected ListenableFuture<String> compute() {",
-        "    ListenableFuture<ListenableFuture<String>> future = Producers.submitToExecutor(",
-        "      new Callable<ListenableFuture<String>>() {",
-        "        @Override public ListenableFuture<String> call() {",
-        "          return module.produceString();",
-        "        }",
-        "      }, executor);",
-        "    return Futures.dereference(future);",
-        "  }",
-        "}");
-    assertAbout(javaSource()).that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError()
-        .and().generatesSources(factoryFile);
-  }
-
-  @Test public void singleProducesMethodNoArgsFutureSet() {
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import com.google.common.util.concurrent.ListenableFuture;",
-        "import dagger.producers.ProducerModule;",
-        "import dagger.producers.Produces;",
-        "",
-        "@ProducerModule",
-        "final class TestModule {",
-        "  @Produces(type = Produces.Type.SET)",
-        "  ListenableFuture<String> produceString() {",
-        "    return null;",
-        "  }",
-        "}");
-    JavaFileObject factoryFile = JavaFileObjects.forSourceLines("TestModule_ProduceStringFactory",
-        "package test;",
-        "",
-        "import com.google.common.util.concurrent.Futures;",
-        "import com.google.common.util.concurrent.ListenableFuture;",
-        "import dagger.producers.internal.AbstractProducer;",
-        "import dagger.producers.internal.Producers;",
-        "import java.util.Set;",
-        "import java.util.concurrent.Callable;",
-        "import java.util.concurrent.Executor;",
-        "import javax.annotation.Generated;",
-        "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class TestModule_ProduceStringFactory",
-        "    extends AbstractProducer<Set<String>> {",
-        "  private final TestModule module;",
-        "  private final Executor executor;",
-        "",
-        "  public TestModule_ProduceStringFactory(TestModule module, Executor executor) {  ",
-        "    assert module != null;",
-        "    this.module = module;",
-        "    assert executor != null;",
-        "    this.executor = executor;",
-        "  }",
-        "",
-        "  @Override",
-        "  protected ListenableFuture<Set<String>> compute() {  ",
-        "    ListenableFuture<ListenableFuture<Set<String>>> future =",
-        "        Producers.submitToExecutor(new Callable<ListenableFuture<Set<String>>>() {",
-        "      @Override public ListenableFuture<Set<String>> call() {",
-        "        return Producers.createFutureSingletonSet(module.produceString());",
-        "      }",
-        "    }, executor);",
-        "    return Futures.dereference(future);",
-        "  }",
-        "}");
-    assertAbout(javaSource()).that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError()
-        .and().generatesSources(factoryFile);
-  }
-
-  @Test public void singleProducesMethodNoArgsNoFuture() {
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import dagger.producers.ProducerModule;",
-        "import dagger.producers.Produces;",
-        "",
-        "@ProducerModule",
-        "final class TestModule {",
-        "  @Produces String produceString() {",
-        "    return \"\";",
-        "  }",
-        "}");
-    JavaFileObject factoryFile = JavaFileObjects.forSourceLines("TestModule_ProduceStringFactory",
-        "package test;",
-        "",
-        "import com.google.common.util.concurrent.ListenableFuture;",
-        "import dagger.producers.internal.AbstractProducer;",
-        "import dagger.producers.internal.Producers;",
-        "import java.util.concurrent.Callable;",
-        "import java.util.concurrent.Executor;",
-        "import javax.annotation.Generated;",
-        "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class TestModule_ProduceStringFactory extends AbstractProducer<String> {",
-        "  private final TestModule module;",
-        "  private final Executor executor;",
-        "",
-        "  public TestModule_ProduceStringFactory(TestModule module, Executor executor) {",
-        "    assert module != null;",
-        "    this.module = module;",
-        "    assert executor != null;",
-        "    this.executor = executor;",
-        "  }",
-        "",
-        "  @Override protected ListenableFuture<String> compute() {",
-        "    ListenableFuture<String> future = Producers.submitToExecutor(",
-        "      new Callable<String>() {",
-        "        @Override public String call() {",
-        "          return module.produceString();",
-        "        }",
-        "      }, executor);",
-        "    return future;",
-        "  }",
-        "}");
-    assertAbout(javaSource()).that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError()
-        .and().generatesSources(factoryFile);
-  }
-
-  @Test public void singleProducesMethodNoArgsNoFutureSet() {
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import dagger.producers.ProducerModule;",
-        "import dagger.producers.Produces;",
-        "",
-        "@ProducerModule",
-        "final class TestModule {",
-        "  @Produces(type = Produces.Type.SET)",
-        "  String produceString() {",
-        "    return \"\";",
-        "  }",
-        "}");
-    JavaFileObject factoryFile = JavaFileObjects.forSourceLines("TestModule_ProduceStringFactory",
-        "package test;",
-        "",
-        "import com.google.common.collect.ImmutableSet;",
-        "import com.google.common.util.concurrent.ListenableFuture;",
-        "import dagger.producers.internal.AbstractProducer;",
-        "import dagger.producers.internal.Producers;",
-        "import java.util.Set;",
-        "import java.util.concurrent.Callable;",
-        "import java.util.concurrent.Executor;",
-        "import javax.annotation.Generated;",
-        "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class TestModule_ProduceStringFactory",
-        "    extends AbstractProducer<Set<String>> {",
-        "  private final TestModule module;",
-        "  private final Executor executor;",
-        "",
-        "  public TestModule_ProduceStringFactory(TestModule module, Executor executor) {  ",
-        "    assert module != null;",
-        "    this.module = module;",
-        "    assert executor != null;",
-        "    this.executor = executor;",
-        "  }",
-        "",
-        "  @Override",
-        "  protected ListenableFuture<Set<String>> compute() {  ",
-        "    ListenableFuture<Set<String>> future =",
-        "        Producers.submitToExecutor(new Callable<Set<String>>() {",
-        "      @Override public Set<String> call() {",
-        "        return ImmutableSet.of(module.produceString());",
-        "      }",
-        "    }, executor);",
-        "    return future;",
-        "  }",
-        "}");
-    assertAbout(javaSource()).that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError()
-        .and().generatesSources(factoryFile);
-  }
-
-  @Test public void singleProducesMethodArgsFuture() {
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import com.google.common.util.concurrent.ListenableFuture;",
-        "import dagger.producers.Produced;",
-        "import dagger.producers.Producer;",
-        "import dagger.producers.ProducerModule;",
-        "import dagger.producers.Produces;",
-        "import javax.inject.Provider;",
-        "",
-        "@ProducerModule",
-        "final class TestModule {",
-        "  @Produces ListenableFuture<String> produceString(",
-        "      int a, Produced<Double> b, Producer<Object> c, Provider<Boolean> d) {",
-        "    return null;",
-        "  }",
-        "}");
-    JavaFileObject factoryFile = JavaFileObjects.forSourceLines("TestModule_ProduceStringFactory",
-        "package test;",
-        "",
-        "import com.google.common.util.concurrent.AsyncFunction;",
-        "import com.google.common.util.concurrent.Futures;",
-        "import com.google.common.util.concurrent.ListenableFuture;",
-        "import dagger.producers.Produced;",
-        "import dagger.producers.Producer;",
-        "import dagger.producers.internal.AbstractProducer;",
-        "import dagger.producers.internal.Producers;",
-        "import java.util.List;",
-        "import java.util.concurrent.Executor;",
-        "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
-        "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class TestModule_ProduceStringFactory extends AbstractProducer<String> {",
-        "  private final TestModule module;",
-        "  private final Executor executor;",
-        "  private final Producer<Integer> aProducer;",
-        "  private final Producer<Double> bProducer;",
-        "  private final Producer<Object> cProducer;",
-        "  private final Provider<Boolean> dProvider;",
-        "",
-        "  public TestModule_ProduceStringFactory(",
-        "      TestModule module,",
-        "      Executor executor,",
-        "      Producer<Integer> aProducer,",
-        "      Producer<Double> bProducer,",
-        "      Producer<Object> cProducer,",
-        "      Provider<Boolean> dProvider) {",
-        "    assert module != null;",
-        "    this.module = module;",
-        "    assert executor != null;",
-        "    this.executor = executor;",
-        "    assert aProducer != null;",
-        "    this.aProducer = aProducer;",
-        "    assert bProducer != null;",
-        "    this.bProducer = bProducer;",
-        "    assert cProducer != null;",
-        "    this.cProducer = cProducer;",
-        "    assert dProvider != null;",
-        "    this.dProvider = dProvider;",
-        "  }",
-        "",
-        "  @Override protected ListenableFuture<String> compute() {",
-        "    ListenableFuture<Integer> aProducerFuture = aProducer.get();",
-        "    ListenableFuture<Produced<Double>> bProducerFuture =",
-        "        Producers.createFutureProduced(bProducer.get());",
-        "    return Futures.transform(",
-        "        Futures.<Object>allAsList(aProducerFuture, bProducerFuture),",
-        "        new AsyncFunction<List<Object>, String>() {",
-        "          @SuppressWarnings(\"unchecked\")  // safe by specification",
-        "          @Override public ListenableFuture<String> apply(List<Object> args) {",
-        "            return module.produceString(",
-        "                (Integer) args.get(0),",
-        "                (Produced<Double>) args.get(1),",
-        "                cProducer,",
-        "                dProvider);",
-        "          }",
-        "        }, executor);",
-        "  }",
-        "}");
-    assertAbout(javaSource()).that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError()
-        .and().generatesSources(factoryFile);
-  }
-
-  @Test public void singleProducesMethodArgsNoFuture() {
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import dagger.producers.Produced;",
-        "import dagger.producers.Producer;",
-        "import dagger.producers.ProducerModule;",
-        "import dagger.producers.Produces;",
-        "import javax.inject.Provider;",
-        "",
-        "@ProducerModule",
-        "final class TestModule {",
-        "  @Produces String produceString(",
-        "      int a, Produced<Double> b, Producer<Object> c, Provider<Boolean> d) {",
-        "    return \"\";",
-        "  }",
-        "}");
-    JavaFileObject factoryFile = JavaFileObjects.forSourceLines("TestModule_ProduceStringFactory",
-        "package test;",
-        "",
-        "import com.google.common.util.concurrent.AsyncFunction;",
-        "import com.google.common.util.concurrent.Futures;",
-        "import com.google.common.util.concurrent.ListenableFuture;",
-        "import dagger.producers.Produced;",
-        "import dagger.producers.Producer;",
-        "import dagger.producers.internal.AbstractProducer;",
-        "import dagger.producers.internal.Producers;",
-        "import java.util.List;",
-        "import java.util.concurrent.Executor;",
-        "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
-        "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class TestModule_ProduceStringFactory extends AbstractProducer<String> {",
-        "  private final TestModule module;",
-        "  private final Executor executor;",
-        "  private final Producer<Integer> aProducer;",
-        "  private final Producer<Double> bProducer;",
-        "  private final Producer<Object> cProducer;",
-        "  private final Provider<Boolean> dProvider;",
-        "",
-        "  public TestModule_ProduceStringFactory(",
-        "      TestModule module,",
-        "      Executor executor,",
-        "      Producer<Integer> aProducer,",
-        "      Producer<Double> bProducer,",
-        "      Producer<Object> cProducer,",
-        "      Provider<Boolean> dProvider) {",
-        "    assert module != null;",
-        "    this.module = module;",
-        "    assert executor != null;",
-        "    this.executor = executor;",
-        "    assert aProducer != null;",
-        "    this.aProducer = aProducer;",
-        "    assert bProducer != null;",
-        "    this.bProducer = bProducer;",
-        "    assert cProducer != null;",
-        "    this.cProducer = cProducer;",
-        "    assert dProvider != null;",
-        "    this.dProvider = dProvider;",
-        "  }",
-        "",
-        "  @Override protected ListenableFuture<String> compute() {",
-        "    ListenableFuture<Integer> aProducerFuture = aProducer.get();",
-        "    ListenableFuture<Produced<Double>> bProducerFuture =",
-        "        Producers.createFutureProduced(bProducer.get());",
-        "    return Futures.transform(",
-        "        Futures.<Object>allAsList(aProducerFuture, bProducerFuture),",
-        "        new AsyncFunction<List<Object>, String>() {",
-        "          @SuppressWarnings(\"unchecked\")  // safe by specification",
-        "          @Override public ListenableFuture<String> apply(List<Object> args) {",
-        "            return Futures.immediateFuture(module.produceString(",
-        "                (Integer) args.get(0),",
-        "                (Produced<Double>) args.get(1),",
-        "                cProducer,",
-        "                dProvider));",
-        "          }",
-        "        }, executor);",
-        "  }",
-        "}");
-    assertAbout(javaSource()).that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError()
-        .and().generatesSources(factoryFile);
-  }
-
-  @Test public void singleProducesMethodSingleArgsFuture() {
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import com.google.common.util.concurrent.ListenableFuture;",
-        "import dagger.producers.ProducerModule;",
-        "import dagger.producers.Produces;",
-        "",
-        "@ProducerModule",
-        "final class TestModule {",
-        "  @Produces ListenableFuture<String> produceString(int a) {",
-        "    return null;",
-        "  }",
-        "}");
-    JavaFileObject factoryFile = JavaFileObjects.forSourceLines("TestModule_ProduceStringFactory",
-        "package test;",
-        "",
-        "import com.google.common.util.concurrent.AsyncFunction;",
-        "import com.google.common.util.concurrent.Futures;",
-        "import com.google.common.util.concurrent.ListenableFuture;",
-        "import dagger.producers.Producer;",
-        "import dagger.producers.internal.AbstractProducer;",
-        "import java.util.concurrent.Executor;",
-        "import javax.annotation.Generated;",
-        "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class TestModule_ProduceStringFactory extends AbstractProducer<String> {",
-        "  private final TestModule module;",
-        "  private final Executor executor;",
-        "  private final Producer<Integer> aProducer;",
-        "",
-        "  public TestModule_ProduceStringFactory(",
-        "      TestModule module,",
-        "      Executor executor,",
-        "      Producer<Integer> aProducer) {",
-        "    assert module != null;",
-        "    this.module = module;",
-        "    assert executor != null;",
-        "    this.executor = executor;",
-        "    assert aProducer != null;",
-        "    this.aProducer = aProducer;",
-        "  }",
-        "",
-        "  @Override protected ListenableFuture<String> compute() {",
-        "    ListenableFuture<Integer> aProducerFuture = aProducer.get();",
-        "    return Futures.transform(aProducerFuture,",
-        "        new AsyncFunction<Integer, String>() {",
-        "          @Override public ListenableFuture<String> apply(Integer a) {",
-        "            return module.produceString(a);",
-        "          }",
-        "        }, executor);",
-        "  }",
-        "}");
-    assertAbout(javaSource()).that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError()
-        .and().generatesSources(factoryFile);
-  }
-
-  @Test public void singleProducesMethodCheckedException() {
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import com.google.common.util.concurrent.ListenableFuture;",
-        "import dagger.producers.ProducerModule;",
-        "import dagger.producers.Produces;",
-        "import java.io.IOException;",
-        "",
-        "@ProducerModule",
-        "final class TestModule {",
-        "  @Produces ListenableFuture<String> produceString()",
-        "      throws InterruptedException, IOException {",
-        "    return null;",
-        "  }",
-        "}");
-    JavaFileObject factoryFile = JavaFileObjects.forSourceLines("TestModule_ProduceStringFactory",
-        "package test;",
-        "",
-        "import com.google.common.util.concurrent.Futures;",
-        "import com.google.common.util.concurrent.ListenableFuture;",
-        "import dagger.producers.internal.AbstractProducer;",
-        "import dagger.producers.internal.Producers;",
-        "import java.io.IOException;",
-        "import java.util.concurrent.Callable;",
-        "import java.util.concurrent.Executor;",
-        "import javax.annotation.Generated;",
-        "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class TestModule_ProduceStringFactory extends AbstractProducer<String> {",
-        "  private final TestModule module;",
-        "  private final Executor executor;",
-        "",
-        "  public TestModule_ProduceStringFactory(TestModule module, Executor executor) {",
-        "    assert module != null;",
-        "    this.module = module;",
-        "    assert executor != null;",
-        "    this.executor = executor;",
-        "  }",
-        "",
-        "  @Override protected ListenableFuture<String> compute() {",
-        "    ListenableFuture<ListenableFuture<String>> future = Producers.submitToExecutor(",
-        "      new Callable<ListenableFuture<String>>() {",
-        "        @Override public ListenableFuture<String> call()",
-        "            throws InterruptedException, IOException {",
-        "          return module.produceString();",
-        "        }",
-        "      }, executor);",
-        "    return Futures.dereference(future);",
-        "  }",
-        "}");
-    assertAbout(javaSource()).that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError()
-        .and().generatesSources(factoryFile);
-  }
-
-  @Test public void singleProducesMethodCheckedExceptionNoFuture() {
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import dagger.producers.ProducerModule;",
-        "import dagger.producers.Produces;",
-        "import java.io.IOException;",
-        "",
-        "@ProducerModule",
-        "final class TestModule {",
-        "  @Produces String produceString() throws IOException {",
-        "    return \"\";",
-        "  }",
-        "}");
-    JavaFileObject factoryFile = JavaFileObjects.forSourceLines("TestModule_ProduceStringFactory",
-        "package test;",
-        "",
-        "import com.google.common.util.concurrent.ListenableFuture;",
-        "import dagger.producers.internal.AbstractProducer;",
-        "import dagger.producers.internal.Producers;",
-        "import java.io.IOException;",
-        "import java.util.concurrent.Callable;",
-        "import java.util.concurrent.Executor;",
-        "import javax.annotation.Generated;",
-        "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class TestModule_ProduceStringFactory extends AbstractProducer<String> {",
-        "  private final TestModule module;",
-        "  private final Executor executor;",
-        "",
-        "  public TestModule_ProduceStringFactory(TestModule module, Executor executor) {",
-        "    assert module != null;",
-        "    this.module = module;",
-        "    assert executor != null;",
-        "    this.executor = executor;",
-        "  }",
-        "",
-        "  @Override protected ListenableFuture<String> compute() {",
-        "    ListenableFuture<String> future = Producers.submitToExecutor(",
-        "      new Callable<String>() {",
-        "        @Override public String call() throws IOException {",
-        "          return module.produceString();",
-        "        }",
-        "      }, executor);",
-        "    return future;",
-        "  }",
-        "}");
-    assertAbout(javaSource()).that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError()
-        .and().generatesSources(factoryFile);
-  }
-
-  @Test public void singleProducesMethodCheckedExceptionFuture() {
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import com.google.common.util.concurrent.ListenableFuture;",
-        "import dagger.producers.Produced;",
-        "import dagger.producers.Producer;",
-        "import dagger.producers.ProducerModule;",
-        "import dagger.producers.Produces;",
-        "import java.io.IOException;",
-        "import javax.inject.Provider;",
-        "",
-        "@ProducerModule",
-        "final class TestModule {",
-        "  @Produces ListenableFuture<String> produceString(",
-        "      int a, Produced<Double> b, Producer<Object> c, Provider<Boolean> d)",
-        "          throws IOException {",
-        "    return null;",
-        "  }",
-        "}");
-    JavaFileObject factoryFile = JavaFileObjects.forSourceLines("TestModule_ProduceStringFactory",
-        "package test;",
-        "",
-        "import com.google.common.util.concurrent.AsyncFunction;",
-        "import com.google.common.util.concurrent.Futures;",
-        "import com.google.common.util.concurrent.ListenableFuture;",
-        "import dagger.producers.Produced;",
-        "import dagger.producers.Producer;",
-        "import dagger.producers.internal.AbstractProducer;",
-        "import dagger.producers.internal.Producers;",
-        "import java.io.IOException;",
-        "import java.util.List;",
-        "import java.util.concurrent.Executor;",
-        "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
-        "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class TestModule_ProduceStringFactory extends AbstractProducer<String> {",
-        "  private final TestModule module;",
-        "  private final Executor executor;",
-        "  private final Producer<Integer> aProducer;",
-        "  private final Producer<Double> bProducer;",
-        "  private final Producer<Object> cProducer;",
-        "  private final Provider<Boolean> dProvider;",
-        "",
-        "  public TestModule_ProduceStringFactory(",
-        "      TestModule module,",
-        "      Executor executor,",
-        "      Producer<Integer> aProducer,",
-        "      Producer<Double> bProducer,",
-        "      Producer<Object> cProducer,",
-        "      Provider<Boolean> dProvider) {",
-        "    assert module != null;",
-        "    this.module = module;",
-        "    assert executor != null;",
-        "    this.executor = executor;",
-        "    assert aProducer != null;",
-        "    this.aProducer = aProducer;",
-        "    assert bProducer != null;",
-        "    this.bProducer = bProducer;",
-        "    assert cProducer != null;",
-        "    this.cProducer = cProducer;",
-        "    assert dProvider != null;",
-        "    this.dProvider = dProvider;",
-        "  }",
-        "",
-        "  @Override protected ListenableFuture<String> compute() {",
-        "    ListenableFuture<Integer> aProducerFuture = aProducer.get();",
-        "    ListenableFuture<Produced<Double>> bProducerFuture =",
-        "        Producers.createFutureProduced(bProducer.get());",
-        "    return Futures.transform(",
-        "        Futures.<Object>allAsList(aProducerFuture, bProducerFuture),",
-        "        new AsyncFunction<List<Object>, String>() {",
-        "          @SuppressWarnings(\"unchecked\")  // safe by specification",
-        "          @Override public ListenableFuture<String> apply(List<Object> args)",
-        "              throws IOException {",
-        "            return module.produceString(",
-        "                (Integer) args.get(0),",
-        "                (Produced<Double>) args.get(1),",
-        "                cProducer,",
-        "                dProvider);",
-        "          }",
-        "        }, executor);",
-        "  }",
-        "}");
-    assertAbout(javaSource()).that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError()
-        .and().generatesSources(factoryFile);
-  }
-
-  @Test public void singleProducesMethodCheckedExceptionNoArgsFutureSet() {
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import com.google.common.util.concurrent.ListenableFuture;",
-        "import dagger.producers.ProducerModule;",
-        "import dagger.producers.Produces;",
-        "import java.io.IOException;",
-        "",
-        "@ProducerModule",
-        "final class TestModule {",
-        "  @Produces(type = Produces.Type.SET)",
-        "  ListenableFuture<String> produceString() throws IOException {",
-        "    return null;",
-        "  }",
-        "}");
-    JavaFileObject factoryFile = JavaFileObjects.forSourceLines("TestModule_ProduceStringFactory",
-        "package test;",
-        "",
-        "import com.google.common.util.concurrent.Futures;",
-        "import com.google.common.util.concurrent.ListenableFuture;",
-        "import dagger.producers.internal.AbstractProducer;",
-        "import dagger.producers.internal.Producers;",
-        "import java.io.IOException;",
-        "import java.util.Set;",
-        "import java.util.concurrent.Callable;",
-        "import java.util.concurrent.Executor;",
-        "import javax.annotation.Generated;",
-        "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class TestModule_ProduceStringFactory",
-        "    extends AbstractProducer<Set<String>> {",
-        "  private final TestModule module;",
-        "  private final Executor executor;",
-        "",
-        "  public TestModule_ProduceStringFactory(TestModule module, Executor executor) {  ",
-        "    assert module != null;",
-        "    this.module = module;",
-        "    assert executor != null;",
-        "    this.executor = executor;",
-        "  }",
-        "",
-        "  @Override",
-        "  protected ListenableFuture<Set<String>> compute() {  ",
-        "    ListenableFuture<ListenableFuture<Set<String>>> future =",
-        "        Producers.submitToExecutor(new Callable<ListenableFuture<Set<String>>>() {",
-        "      @Override public ListenableFuture<Set<String>> call() throws IOException {",
-        "        return Producers.createFutureSingletonSet(module.produceString());",
-        "      }",
-        "    }, executor);",
-        "    return Futures.dereference(future);",
-        "  }",
-        "}");
-    assertAbout(javaSource()).that(moduleFile)
+    JavaFileObject factoryFile =
+        JavaFileObjects.forSourceLines(
+            "TestModule_ProduceStringFactory",
+            "package test;",
+            "",
+            "import com.google.common.util.concurrent.AsyncFunction;",
+            "import com.google.common.util.concurrent.Futures;",
+            "import com.google.common.util.concurrent.ListenableFuture;",
+            "import dagger.producers.internal.AbstractProducer;",
+            "import dagger.producers.monitoring.ProducerMonitor;",
+            "import dagger.producers.monitoring.ProducerToken;",
+            "import dagger.producers.monitoring.ProductionComponentMonitor;",
+            "import java.util.concurrent.Executor;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+            "public final class TestModule_ProduceStringFactory extends AbstractProducer<String> {",
+            "  private final TestModule module;",
+            "  private final Executor executor;",
+            "  private final Provider<ProductionComponentMonitor> monitorProvider;",
+            "",
+            "  public TestModule_ProduceStringFactory(",
+            "      TestModule module,",
+            "      Executor executor,",
+            "      Provider<ProductionComponentMonitor> monitorProvider) {",
+            "    super(",
+            "        monitorProvider,",
+            "        ProducerToken.create(TestModule_ProduceStringFactory.class));",
+            "    assert module != null;",
+            "    this.module = module;",
+            "    assert executor != null;",
+            "    this.executor = executor;",
+            "    assert monitorProvider != null;",
+            "    this.monitorProvider = monitorProvider;",
+            "  }",
+            "",
+            "  @Override protected ListenableFuture<String> compute(",
+            "      final ProducerMonitor monitor) {",
+            "    return Futures.transform(",
+            "      Futures.<Void>immediateFuture(null),",
+            "      new AsyncFunction<Void, String>() {",
+            "        @Override public ListenableFuture<String> apply(Void ignoredVoidArg) {",
+            "          monitor.methodStarting();",
+            "          try {",
+            "            return module.produceString();",
+            "          } finally {",
+            "            monitor.methodFinished();",
+            "          }",
+            "        }",
+            "      }, executor);",
+            "  }",
+            "}");
+    assertAbout(javaSource())
+        .that(moduleFile)
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
-        .and().generatesSources(factoryFile);
+        .and()
+        .generatesSources(factoryFile);
   }
 
   private static final JavaFileObject QUALIFIER_A =
diff --git a/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java
index b5ebd972b..a8e39b28a 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java
@@ -123,94 +123,136 @@
         "    ListenableFuture<A> a();",
         "  }",
         "}");
-    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
-        "test.DaggerTestClass_SimpleComponent",
-        "package test;",
-        "",
-        "import com.google.common.util.concurrent.ListenableFuture;",
-        "import dagger.producers.Producer;",
-        "import dagger.producers.internal.Producers;",
-        "import java.util.concurrent.Executor;",
-        "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
-        "import test.TestClass.A;",
-        "import test.TestClass.AModule;",
-        "import test.TestClass.B;",
-        "import test.TestClass.BModule;",
-        "import test.TestClass.SimpleComponent;",
-        "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class DaggerTestClass_SimpleComponent implements SimpleComponent {",
-        "  private Provider<B> bProvider;",
-        "  private Producer<A> aProducer;",
-        "",
-        "  private DaggerTestClass_SimpleComponent(Builder builder) {",
-        "    assert builder != null;",
-        "    initialize(builder);",
-        "  }",
-        "",
-        "  public static Builder builder() {",
-        "    return new Builder();",
-        "  }",
-        "",
-        "  private void initialize(final Builder builder) {",
-        "    this.bProvider = TestClass$BModule_BFactory.create(",
-        "        builder.bModule, TestClass$C_Factory.create());",
-        "    this.aProducer = new TestClass$AModule_AFactory(",
-        "        builder.aModule, builder.executor, Producers.producerFromProvider(bProvider));",
-        "  }",
-        "",
-        "  @Override",
-        "  public ListenableFuture<A> a() {",
-        "    return aProducer.get();",
-        "  }",
-        "",
-        "  public static final class Builder {",
-        "    private AModule aModule;",
-        "    private BModule bModule;",
-        "    private Executor executor;",
-        "",
-        "    private Builder() {",
-        "    }",
-        "",
-        "    public SimpleComponent build() {",
-        "      if (aModule == null) {",
-        "        this.aModule = new AModule();",
-        "      }",
-        "      if (bModule == null) {",
-        "        this.bModule = new BModule();",
-        "      }",
-        "      if (executor == null) {",
-        "        throw new IllegalStateException(\"executor must be set\");",
-        "      }",
-        "      return new DaggerTestClass_SimpleComponent(this);",
-        "    }",
-        "",
-        "    public Builder aModule(AModule aModule) {",
-        "      if (aModule == null) {",
-        "        throw new NullPointerException(\"aModule\");",
-        "      }",
-        "      this.aModule = aModule;",
-        "      return this;",
-        "    }",
-        "",
-        "    public Builder bModule(BModule bModule) {",
-        "      if (bModule == null) {",
-        "        throw new NullPointerException(\"bModule\");",
-        "      }",
-        "      this.bModule = bModule;",
-        "      return this;",
-        "    }",
-        "",
-        "    public Builder executor(Executor executor) {",
-        "      if (executor == null) {",
-        "        throw new NullPointerException(\"executor\");",
-        "      }",
-        "      this.executor = executor;",
-        "      return this;",
-        "    }",
-        "  }",
-        "}");
+    JavaFileObject generatedComponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerTestClass_SimpleComponent",
+            "package test;",
+            "",
+            "import com.google.common.util.concurrent.ListenableFuture;",
+            "import dagger.internal.InstanceFactory;",
+            "import dagger.internal.SetFactory;",
+            "import dagger.producers.Producer;",
+            "import dagger.producers.internal.Producers;",
+            "import dagger.producers.monitoring.ProductionComponentMonitor;",
+            "import dagger.producers.monitoring.ProductionComponentMonitor.Factory;",
+            "import java.util.Set;",
+            "import java.util.concurrent.Executor;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "import test.TestClass.A;",
+            "import test.TestClass.AModule;",
+            "import test.TestClass.B;",
+            "import test.TestClass.BModule;",
+            "import test.TestClass.SimpleComponent;",
+            "",
+            "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+            "public final class DaggerTestClass_SimpleComponent implements SimpleComponent {",
+            "  private Provider<SimpleComponent> simpleComponentProvider;",
+            "  private Provider<Set<Factory>> setOfFactoryContribution1Provider;",
+            "  private Provider<Set<Factory>> setOfFactoryProvider;",
+            "  private Provider<ProductionComponentMonitor> monitorProvider;",
+            "  private Provider<B> bProvider;",
+            "  private Producer<A> aProducer;",
+            "",
+            "  private DaggerTestClass_SimpleComponent(Builder builder) {",
+            "    assert builder != null;",
+            "    initialize(builder);",
+            "  }",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize(final Builder builder) {",
+            "    this.simpleComponentProvider = InstanceFactory.<SimpleComponent>create(this);",
+            "    this.setOfFactoryContribution1Provider =",
+            "        TestClass$SimpleComponent_MonitoringModule_DefaultSetOfFactoriesFactory",
+            "            .create();",
+            "    this.setOfFactoryProvider = SetFactory.create(setOfFactoryContribution1Provider);",
+            "    this.monitorProvider =",
+            "        TestClass$SimpleComponent_MonitoringModule_MonitorFactory.create(",
+            "            builder.testClass$SimpleComponent_MonitoringModule,",
+            "            simpleComponentProvider,",
+            "            setOfFactoryProvider);",
+            "    this.bProvider = TestClass$BModule_BFactory.create(",
+            "        builder.bModule, TestClass$C_Factory.create());",
+            "    this.aProducer = new TestClass$AModule_AFactory(",
+            "        builder.aModule,",
+            "        builder.executor,",
+            "        monitorProvider,",
+            "        Producers.producerFromProvider(bProvider));",
+            "  }",
+            "",
+            "  @Override",
+            "  public ListenableFuture<A> a() {",
+            "    return aProducer.get();",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private TestClass$SimpleComponent_MonitoringModule",
+            "        testClass$SimpleComponent_MonitoringModule;",
+            "    private BModule bModule;",
+            "    private AModule aModule;",
+            "    private Executor executor;",
+            "",
+            "    private Builder() {",
+            "    }",
+            "",
+            "    public SimpleComponent build() {",
+            "      if (testClass$SimpleComponent_MonitoringModule == null) {",
+            "        this.testClass$SimpleComponent_MonitoringModule =",
+            "            new TestClass$SimpleComponent_MonitoringModule();",
+            "      }",
+            "      if (bModule == null) {",
+            "        this.bModule = new BModule();",
+            "      }",
+            "      if (aModule == null) {",
+            "        this.aModule = new AModule();",
+            "      }",
+            "      if (executor == null) {",
+            "        throw new IllegalStateException(Executor.class.getCanonicalName()",
+            "            + \" must be set\");",
+            "      }",
+            "      return new DaggerTestClass_SimpleComponent(this);",
+            "    }",
+            "",
+            "    public Builder aModule(AModule aModule) {",
+            "      if (aModule == null) {",
+            "        throw new NullPointerException();",
+            "      }",
+            "      this.aModule = aModule;",
+            "      return this;",
+            "    }",
+            "",
+            "    public Builder bModule(BModule bModule) {",
+            "      if (bModule == null) {",
+            "        throw new NullPointerException();",
+            "      }",
+            "      this.bModule = bModule;",
+            "      return this;",
+            "    }",
+            "",
+            "    public Builder testClass$SimpleComponent_MonitoringModule(",
+            "        TestClass$SimpleComponent_MonitoringModule",
+            "        testClass$SimpleComponent_MonitoringModule) {",
+            "      if (testClass$SimpleComponent_MonitoringModule == null) {",
+            "        throw new NullPointerException();",
+            "      }",
+            "      this.testClass$SimpleComponent_MonitoringModule =",
+            "          testClass$SimpleComponent_MonitoringModule;",
+            "      return this;",
+            "    }",
+            "",
+            "    public Builder executor(Executor executor) {",
+            "      if (executor == null) {",
+            "        throw new NullPointerException();",
+            "      }",
+            "      this.executor = executor;",
+            "      return this;",
+            "    }",
+            "  }",
+            "}");
     assertAbout(javaSource()).that(component)
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
diff --git a/compiler/src/test/java/dagger/internal/codegen/ProductionGraphValidationTest.java b/compiler/src/test/java/dagger/internal/codegen/ProductionGraphValidationTest.java
index 9f577b722..6fc871684 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ProductionGraphValidationTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ProductionGraphValidationTest.java
@@ -161,4 +161,110 @@
         .failsToCompile()
         .withErrorContaining(expectedError).in(component).onLine(20);
   }
+
+  @Test
+  public void monitoringDependsOnUnboundType() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestClass",
+            "package test;",
+            "",
+            "import com.google.common.util.concurrent.ListenableFuture;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.producers.ProducerModule;",
+            "import dagger.producers.Produces;",
+            "import dagger.producers.ProductionComponent;",
+            "import dagger.producers.monitoring.ProductionComponentMonitor;",
+            "",
+            "import static dagger.Provides.Type.SET;",
+            "",
+            "final class TestClass {",
+            "  interface A {}",
+            "",
+            "  @Module",
+            "  final class MonitoringModule {",
+            "    @Provides(type = SET)",
+            "    ProductionComponentMonitor.Factory monitorFactory(A unbound) {",
+            "      return null;",
+            "    }",
+            "  }",
+            "",
+            "  @ProducerModule",
+            "  final class StringModule {",
+            "    @Produces ListenableFuture<String> str() {",
+            "      return null;",
+            "    }",
+            "  }",
+            "",
+            "  @ProductionComponent(modules = {MonitoringModule.class, StringModule.class})",
+            "  interface StringComponent {",
+            "    ListenableFuture<String> getString();",
+            "  }",
+            "}");
+    String expectedError =
+        "test.TestClass.A cannot be provided without an @Provides-annotated method.";
+    assertAbout(javaSource())
+        .that(component)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(expectedError)
+        .in(component)
+        .onLine(33);
+  }
+
+  @Test
+  public void monitoringDependsOnProduction() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestClass",
+            "package test;",
+            "",
+            "import com.google.common.util.concurrent.ListenableFuture;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.producers.ProducerModule;",
+            "import dagger.producers.Produces;",
+            "import dagger.producers.ProductionComponent;",
+            "import dagger.producers.monitoring.ProductionComponentMonitor;",
+            "",
+            "import static dagger.Provides.Type.SET;",
+            "",
+            "final class TestClass {",
+            "  interface A {}",
+            "",
+            "  @Module",
+            "  final class MonitoringModule {",
+            "    @Provides(type = SET) ProductionComponentMonitor.Factory monitorFactory(A a) {",
+            "      return null;",
+            "    }",
+            "  }",
+            "",
+            "  @ProducerModule",
+            "  final class StringModule {",
+            "    @Produces A a() {",
+            "      return null;",
+            "    }",
+            "",
+            "    @Produces ListenableFuture<String> str() {",
+            "      return null;",
+            "    }",
+            "  }",
+            "",
+            "  @ProductionComponent(modules = {MonitoringModule.class, StringModule.class})",
+            "  interface StringComponent {",
+            "    ListenableFuture<String> getString();",
+            "  }",
+            "}");
+    String expectedError =
+        "java.util.Set<dagger.producers.monitoring.ProductionComponentMonitor.Factory> is a"
+            + " provision, which cannot depend on a production.";
+    assertAbout(javaSource())
+        .that(component)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(expectedError)
+        .in(component)
+        .onLine(36);
+  }
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/RepeatedModuleValidationTest.java b/compiler/src/test/java/dagger/internal/codegen/RepeatedModuleValidationTest.java
new file mode 100644
index 000000000..6bf0c9ee0
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/RepeatedModuleValidationTest.java
@@ -0,0 +1,121 @@
+package dagger.internal.codegen;
+
+import com.google.common.collect.ImmutableList;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assertAbout;
+import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+
+@RunWith(JUnit4.class)
+public class RepeatedModuleValidationTest {
+  private static final JavaFileObject MODULE_FILE =
+      JavaFileObjects.forSourceLines(
+          "test.TestModule",
+          "package test;",
+          "",
+          "import dagger.Module;",
+          "",
+          "@Module",
+          "final class TestModule {}");
+
+  @Test
+  public void moduleRepeatedInSubcomponentFactoryMethod() {
+    JavaFileObject subcomponentFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestSubcomponent",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = TestModule.class)",
+            "interface TestSubcomponent {",
+            "}");
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = TestModule.class)",
+            "interface TestComponent {",
+            "  TestSubcomponent newTestSubcomponent(TestModule module);",
+            "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(MODULE_FILE, subcomponentFile, componentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("This module is present in test.TestComponent.")
+        .in(componentFile)
+        .onLine(7)
+        .atColumn(51);
+  }
+
+  @Test
+  public void moduleRepeatedInSubcomponentBuilderMethod() {
+    JavaFileObject subcomponentFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestSubcomponent",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = TestModule.class)",
+            "interface TestSubcomponent {",
+            "  @Subcomponent.Builder",
+            "  interface Builder {",
+            "    Builder testModule(TestModule testModule);",
+            "    TestSubcomponent build();",
+            "  }",
+            "}");
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = TestModule.class)",
+            "interface TestComponent {",
+            "  TestSubcomponent.Builder newTestSubcomponentBuilder();",
+            "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(MODULE_FILE, subcomponentFile, componentFile))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError();
+    // TODO(gak): assert about the warning when we have that ability
+  }
+
+  @Test
+  public void moduleRepeatedButNotPassed() {
+    JavaFileObject subcomponentFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestSubcomponent",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = TestModule.class)",
+            "interface TestSubcomponent {",
+            "}");
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = TestModule.class)",
+            "interface TestComponent {",
+            "  TestSubcomponent newTestSubcomponent();",
+            "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(MODULE_FILE, subcomponentFile, componentFile))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError();
+  }
+}
diff --git a/compiler/src/test/java/dagger/internal/codegen/SubcomponentValidationTest.java b/compiler/src/test/java/dagger/internal/codegen/SubcomponentValidationTest.java
index 91035b291..d47c32839 100644
--- a/compiler/src/test/java/dagger/internal/codegen/SubcomponentValidationTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/SubcomponentValidationTest.java
@@ -43,15 +43,26 @@
         "import dagger.Subcomponent;",
         "",
         "@Subcomponent(modules = ModuleWithParameters.class)",
-        "interface ChildComponent {}");
+        "interface ChildComponent {",
+        "  Object object();",
+        "}");
     JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.ModuleWithParameters",
         "package test;",
         "",
         "import dagger.Module;",
+        "import dagger.Provides;",
         "",
         "@Module",
         "final class ModuleWithParameters {",
-        "  ModuleWithParameters(Object whatever) {}",
+        "  private final Object object;",
+        "",
+        "  ModuleWithParameters(Object object) {",
+        "    this.object = object;",
+        "  }",
+        "",
+        "  @Provides Object object() {",
+        "    return object;",
+        "  }",
         "}");
     assertAbout(javaSources()).that(ImmutableList.of(componentFile, childComponentFile, moduleFile))
         .processedWith(new ComponentProcessor())
@@ -244,4 +255,195 @@
         .failsToCompile()
         .withErrorContaining("@Singleton");
   }
+
+  @Test
+  public void delegateFactoryNotCreatedForSubcomponentWhenProviderExistsInParent() {
+    JavaFileObject parentComponentFile =
+        JavaFileObjects.forSourceLines(
+            "test.ParentComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface ParentComponent {",
+            "  ChildComponent childComponent();",
+            "  Dep1 getDep1();",
+            "  Dep2 getDep2();",
+            "}");
+    JavaFileObject childComponentFile =
+        JavaFileObjects.forSourceLines(
+            "test.ChildComponent",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = ChildModule.class)",
+            "interface ChildComponent {",
+            "  Object getObject();",
+            "}");
+    JavaFileObject childModuleFile =
+        JavaFileObjects.forSourceLines(
+            "test.ChildModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "final class ChildModule {",
+            "  @Provides Object provideObject(A a) { return null; }",
+            "}");
+    JavaFileObject aFile =
+        JavaFileObjects.forSourceLines(
+            "test.A",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "final class A {",
+            "  @Inject public A(NeedsDep1 a, Dep1 b, Dep2 c) { }",
+            "  @Inject public void methodA() { }",
+            "}");
+    JavaFileObject needsDep1File =
+        JavaFileObjects.forSourceLines(
+            "test.NeedsDep1",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "final class NeedsDep1 {",
+            "  @Inject public NeedsDep1(Dep1 d) { }",
+            "}");
+    JavaFileObject dep1File =
+        JavaFileObjects.forSourceLines(
+            "test.Dep1",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "final class Dep1 {",
+            "  @Inject public Dep1() { }",
+            "  @Inject public void dep1Method() { }",
+            "}");
+    JavaFileObject dep2File =
+        JavaFileObjects.forSourceLines(
+            "test.Dep2",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "final class Dep2 {",
+            "  @Inject public Dep2() { }",
+            "  @Inject public void dep2Method() { }",
+            "}");
+
+    JavaFileObject componentGeneratedFile =
+        JavaFileObjects.forSourceLines(
+            "DaggerParentComponent",
+            "package test;",
+            "",
+            "import dagger.MembersInjector;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+            "public final class DaggerParentComponent implements ParentComponent {",
+            "  private MembersInjector<Dep1> dep1MembersInjector;",
+            "  private Provider<Dep1> dep1Provider;",
+            "  private MembersInjector<Dep2> dep2MembersInjector;",
+            "  private Provider<Dep2> dep2Provider;",
+            "",
+            "  private DaggerParentComponent(Builder builder) {  ",
+            "    assert builder != null;",
+            "    initialize(builder);",
+            "  }",
+            "",
+            "  public static Builder builder() {  ",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static ParentComponent create() {  ",
+            "    return builder().build();",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize(final Builder builder) {  ",
+            "    this.dep1MembersInjector = Dep1_MembersInjector.create();",
+            "    this.dep1Provider = Dep1_Factory.create(dep1MembersInjector);",
+            "    this.dep2MembersInjector = Dep2_MembersInjector.create();",
+            "    this.dep2Provider = Dep2_Factory.create(dep2MembersInjector);",
+            "  }",
+            "",
+            "  @Override",
+            "  public Dep1 getDep1() {  ",
+            "    return dep1Provider.get();",
+            "  }",
+            "",
+            "  @Override",
+            "  public Dep2 getDep2() {  ",
+            "    return dep2Provider.get();",
+            "  }",
+            "",
+            "  @Override",
+            "  public ChildComponent childComponent() {  ",
+            "    return new ChildComponentImpl();",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private Builder() {  ",
+            "    }",
+            "  ",
+            "    public ParentComponent build() {  ",
+            "      return new DaggerParentComponent(this);",
+            "    }",
+            "  }",
+            "",
+            "  private final class ChildComponentImpl implements ChildComponent {",
+            "    private final ChildModule childModule;",
+            "    private MembersInjector<A> aMembersInjector;",
+            "    private Provider<NeedsDep1> needsDep1Provider;",
+            "    private Provider<A> aProvider;",
+            "    private Provider<Object> provideObjectProvider;",
+            "  ",
+            "    private ChildComponentImpl() {  ",
+            "      this.childModule = new ChildModule();",
+            "      initialize();",
+            "    }",
+            "",
+            "    @SuppressWarnings(\"unchecked\")",
+            "    private void initialize() {  ",
+            "      this.aMembersInjector = A_MembersInjector.create();",
+            "      this.needsDep1Provider = NeedsDep1_Factory.create(",
+            "          DaggerParentComponent.this.dep1Provider);",
+            "      this.aProvider = A_Factory.create(",
+            "          aMembersInjector,",
+            "          needsDep1Provider,",
+            "          DaggerParentComponent.this.dep1Provider,",
+            "          DaggerParentComponent.this.dep2Provider);",
+            "      this.provideObjectProvider = ChildModule_ProvideObjectFactory.create(",
+            "          childModule, aProvider);",
+            "    }",
+            "  ",
+            "    @Override",
+            "    public Object getObject() {  ",
+            "      return provideObjectProvider.get();",
+            "    }",
+            "  }",
+            "}");
+    assertAbout(javaSources())
+        .that(
+            ImmutableList.of(
+                parentComponentFile,
+                childComponentFile,
+                childModuleFile,
+                aFile,
+                needsDep1File,
+                dep1File,
+                dep2File))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and()
+        .generatesSources(componentGeneratedFile);
+  }
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/ValidationReportTest.java b/compiler/src/test/java/dagger/internal/codegen/ValidationReportTest.java
new file mode 100644
index 000000000..d7f445125
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/ValidationReportTest.java
@@ -0,0 +1,129 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.common.collect.ImmutableSet;
+import com.google.testing.compile.JavaFileObjects;
+import dagger.internal.codegen.ValidationReport.Builder;
+import java.util.Set;
+import javax.annotation.processing.AbstractProcessor;
+import javax.annotation.processing.RoundEnvironment;
+import javax.lang.model.element.TypeElement;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assertAbout;
+import static com.google.common.truth.Truth.assertThat;
+import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+
+@RunWith(JUnit4.class)
+public class ValidationReportTest {
+  private static final JavaFileObject TEST_CLASS_FILE =
+      JavaFileObjects.forSourceLines("test.TestClass",
+          "package test;",
+          "",
+          "final class TestClass {}");
+
+  @Test
+  public void basicReport() {
+    assertAbout(javaSource())
+        .that(TEST_CLASS_FILE)
+        .processedWith(
+            new SimpleTestProcessor() {
+              @Override
+              void test() {
+                Builder<TypeElement> reportBuilder =
+                    ValidationReport.about(getTypeElement("test.TestClass"));
+                reportBuilder.addError("simple error");
+                reportBuilder.build().printMessagesTo(processingEnv.getMessager());
+              }
+            })
+        .failsToCompile()
+        .withErrorContaining("simple error")
+        .in(TEST_CLASS_FILE)
+        .onLine(3);
+  }
+
+  @Test
+  public void messageOnDifferentElement() {
+    assertAbout(javaSource())
+        .that(TEST_CLASS_FILE)
+        .processedWith(
+            new SimpleTestProcessor() {
+              @Override
+              void test() {
+                Builder<TypeElement> reportBuilder =
+                    ValidationReport.about(getTypeElement("test.TestClass"));
+                reportBuilder.addError("simple error", getTypeElement(String.class));
+                reportBuilder.build().printMessagesTo(processingEnv.getMessager());
+              }
+            })
+        .failsToCompile()
+        .withErrorContaining("[java.lang.String] simple error")
+        .in(TEST_CLASS_FILE)
+        .onLine(3);
+  }
+
+  @Test
+  public void subreport() {
+    assertAbout(javaSource())
+        .that(TEST_CLASS_FILE)
+        .processedWith(
+            new SimpleTestProcessor() {
+              @Override
+              void test() {
+                Builder<TypeElement> reportBuilder =
+                    ValidationReport.about(getTypeElement("test.TestClass"));
+                reportBuilder.addError("simple error");
+                ValidationReport<TypeElement> parentReport =
+                    ValidationReport.about(getTypeElement(String.class))
+                        .addSubreport(reportBuilder.build())
+                        .build();
+                assertThat(parentReport.isClean()).isFalse();
+                parentReport.printMessagesTo(processingEnv.getMessager());
+              }
+            })
+        .failsToCompile()
+        .withErrorContaining("simple error")
+        .in(TEST_CLASS_FILE)
+        .onLine(3);
+  }
+
+  private static abstract class SimpleTestProcessor extends AbstractProcessor {
+    @Override
+    public Set<String> getSupportedAnnotationTypes() {
+      return ImmutableSet.of("*");
+    }
+
+    @Override
+    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
+      test();
+      return false;
+    }
+
+    protected final TypeElement getTypeElement(Class<?> clazz) {
+      return getTypeElement(clazz.getCanonicalName());
+    }
+
+    protected final TypeElement getTypeElement(String canonicalName) {
+      return processingEnv.getElementUtils().getTypeElement(canonicalName);
+    }
+
+    abstract void test();
+  }
+}
diff --git a/compiler/src/test/java/dagger/internal/codegen/writer/ClassNameTest.java b/compiler/src/test/java/dagger/internal/codegen/writer/ClassNameTest.java
index acf895e74..eff01b849 100644
--- a/compiler/src/test/java/dagger/internal/codegen/writer/ClassNameTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/writer/ClassNameTest.java
@@ -120,4 +120,9 @@
     assertThat(className.canonicalName()).isEqualTo(
         "dagger.internal.codegen.writer.ClassNameTest.OuterClass.InnerClass");
   }
+
+  @Test public void fromClass_classFileName() {
+    ClassName className = ClassName.fromClass(InnerClass.class);
+    assertThat(className.classFileName('_')).isEqualTo("ClassNameTest_OuterClass_InnerClass");
+  }
 }
diff --git a/compiler/src/test/java/dagger/tests/integration/operation/PrimitiveInjectionTest.java b/compiler/src/test/java/dagger/tests/integration/operation/PrimitiveInjectionTest.java
index 349b2feee..58fa26307 100644
--- a/compiler/src/test/java/dagger/tests/integration/operation/PrimitiveInjectionTest.java
+++ b/compiler/src/test/java/dagger/tests/integration/operation/PrimitiveInjectionTest.java
@@ -92,6 +92,7 @@
       "    return builder().build();",
       "  }",
       "",
+      "  @SuppressWarnings(\"unchecked\")",
       "  private void initialize(final Builder builder) {",
       "    this.primitiveIntProvider =",
       "        PrimitiveModule_PrimitiveIntFactory.create(builder.primitiveModule);",
@@ -124,7 +125,7 @@
       "",
       "    public Builder primitiveModule(PrimitiveModule primitiveModule) {",
       "      if (primitiveModule == null) {",
-      "        throw new NullPointerException(\"primitiveModule\");",
+      "        throw new NullPointerException();",
       "      }",
       "      this.primitiveModule = primitiveModule;",
       "      return this;",
diff --git a/core/src/main/java/dagger/Lazy.java b/core/src/main/java/dagger/Lazy.java
index 59419abd3..e04cc03e3 100644
--- a/core/src/main/java/dagger/Lazy.java
+++ b/core/src/main/java/dagger/Lazy.java
@@ -30,12 +30,11 @@
  * injection</strong> and <strong>lazy injection</strong> are best demonstrated
  * with an example. Start with a module that computes a different integer for
  * each use:<pre><code>
- *   &#64;Module
- *   public class CounterModule {
- *
+ *   {@literal @Module}
+ *   final class CounterModule {
  *     int next = 100;
  *
- *     &#64;Provides Integer provideInteger() {
+ *     {@literal @Provides} Integer provideInteger() {
  *       System.out.println("computing...");
  *       return next++;
  *     }
@@ -44,11 +43,10 @@
  *
  * <h3>Direct Injection</h3>
  * This class injects that integer and prints it 3 times:<pre><code>
- *   public class DirectCounter {
- *
- *     &#64Inject Integer value;
+ *   final class DirectCounter {
+ *     {@literal @Inject} Integer value;
  *
- *     public void print() {
+ *     void print() {
  *       System.out.println("printing...");
  *       System.out.println(value);
  *       System.out.println(value);
@@ -69,11 +67,10 @@
  * This class injects a {@linkplain javax.inject.Provider provider} for the
  * integer. It calls {@code Provider.get()} 3 times and prints each result:
  * <pre><code>
- *   public class ProviderCounter {
- *
- *     &#64;Inject Provider<Integer> provider;
+ *   final class ProviderCounter {
+ *     {@literal @Inject Provider<Integer> provider;}
  *
- *     public void print() {
+ *     void print() {
  *       System.out.println("printing...");
  *       System.out.println(provider.get());
  *       System.out.println(provider.get());
@@ -95,11 +92,10 @@
  * <h3>Lazy Injection</h3>
  * This class injects a {@code Lazy} for the integer. Like the provider above,
  * it calls {@code Lazy.get()} 3 times and prints each result:<pre><code>
- *   public static class LazyCounter {
+ *   final class LazyCounter {
+ *     {@literal @Inject Lazy<Integer> lazy;}
  *
- *     &#64;Inject Lazy<Integer> lazy;
- *
- *     public void print() {
+ *     void print() {
  *       System.out.println("printing...");
  *       System.out.println(lazy.get());
  *       System.out.println(lazy.get());
@@ -122,17 +118,17 @@
  * in isolation of other {@code Lazy} instances. In this example, two {@code
  * LazyCounter} objects are created and {@code print()} is called on each:
  * <pre><code>
- *     public void run() {
- *       ObjectGraph graph = ObjectGraph.create(new CounterModule());
+ *   final class LazyCounters {
+ *     {@literal @Inject} LazyCounter counter1;
+ *     {@literal @Inject} LazyCounter counter2;
  *
- *       LazyCounter counter1 = graph.get(LazyCounter.class);
+ *     void print() {
  *       counter1.print();
- *
- *       LazyCounter counter2 = graph.get(LazyCounter.class);
  *       counter2.print();
  *     }
+ *   }
  * </code></pre>
- * The program's output demonstrates that each {@code Lazy} works independently:
+ * The output demonstrates that each {@code Lazy} works independently:
  * <pre><code>
  *   printing...
  *   computing...
@@ -145,8 +141,8 @@
  *   101
  *   101
  * </code></pre>
- * Use {@linkplain javax.inject.Singleton @Singleton} to share one instance
- * among all clients, and {@code Lazy} for lazy computation in a single client.
+ * Use {@link javax.inject.Singleton @Singleton} to share one instance among all
+ * clients, and {@code Lazy} for lazy computation in a single client.
  */
 public interface Lazy<T> {
   /**
diff --git a/core/src/main/java/dagger/MapKey.java b/core/src/main/java/dagger/MapKey.java
index 3ebd13b31..106c00183 100644
--- a/core/src/main/java/dagger/MapKey.java
+++ b/core/src/main/java/dagger/MapKey.java
@@ -34,19 +34,19 @@
  *
  * <p>Typically, the key annotation has a single member, whose value is used as the map key.
  *
- * <p>For example, to add an entry to a {@code Map<String, Integer>} with key "foo", you could use
- * an annotation called {@code @StringKey}:
+ * <p>For example, to add an entry to a {@code Map<SomeEnum, Integer>} with key
+ * {@code SomeEnum.FOO}, you could use an annotation called {@code @SomeEnumKey}:
  *
  * <pre><code>
  * {@literal @}MapKey
- * {@literal @}interface StringKey {
- *   String value();
+ * {@literal @}interface SomeEnumKey {
+ *   SomeEnum value();
  * }
  *
  * {@literal @}Module
  * class SomeModule {
  *   {@literal @}Provides(type = MAP)
- *   {@literal @}StringKey("foo")
+ *   {@literal @}SomeEnumKey(SomeEnum.FOO)
  *   Integer provideFooValue() {
  *     return 2;
  *   }
@@ -54,8 +54,8 @@
  *
  * class SomeInjectedType {
  *   {@literal @}Inject
- *   SomeInjectedType(Map<String, Integer> map) {
- *     assert map.get("foo") == 2;
+ *   SomeInjectedType(Map<SomeEnum, Integer> map) {
+ *     assert map.get(SomeEnum.FOO) == 2;
  *   }
  * }
  * </code></pre>
@@ -63,6 +63,9 @@
  * <p>If {@code unwrapValue} is true, the annotation's single member can be any type except an
  * array.
  *
+ * <p>See {@link dagger.mapkeys} for standard unwrapped map key annotations for keys that are boxed
+ * primitives, strings, or classes.
+ *
  * <h2>Annotations as keys</h2>
  *
  * <p>If {@link #unwrapValue} is false, then the annotation itself is used as the map key. For
@@ -94,6 +97,7 @@
  *
  * <p>(Note that there must be a class {@code MyMapKeyImpl} that implements {@code MyMapKey} in
  * order to call {@link Map#get(Object)} on the provided map.)
+ *
  */
 @Documented
 @Target(ANNOTATION_TYPE)
diff --git a/core/src/main/java/dagger/Provides.java b/core/src/main/java/dagger/Provides.java
index b0524b4ef..741a54a2d 100644
--- a/core/src/main/java/dagger/Provides.java
+++ b/core/src/main/java/dagger/Provides.java
@@ -46,6 +46,7 @@
      * returned value is contributed to the set. The object graph will pass dependencies to the
      * method as parameters. The {@code Set<T>} produced from the accumulation of values will be
      * immutable.
+     *
      */
     SET,
 
@@ -53,6 +54,7 @@
      * Like {@link #SET}, except the method's return type is {@code Set<T>}, where any values are
      * contributed to the set. An example use is to provide a default empty set binding, which is
      * otherwise not possible using {@link #SET}.
+     *
      */
     SET_VALUES,
 
@@ -61,6 +63,7 @@
      * {@code Map<K, Provider<V>>}, and the combination of the annotated key and the returned value
      * is contributed to the map as a key/value pair. The {@code Map<K, Provider<V>>} produced from
      * the accumulation of values will be immutable.
+     *
      */
     @Beta
     MAP;
diff --git a/core/src/main/java/dagger/Subcomponent.java b/core/src/main/java/dagger/Subcomponent.java
index 0ef47011f..988f17b49 100644
--- a/core/src/main/java/dagger/Subcomponent.java
+++ b/core/src/main/java/dagger/Subcomponent.java
@@ -16,9 +16,11 @@
 package dagger;
 
 import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 
 import static java.lang.annotation.ElementType.TYPE;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
 /**
  * A subcomponent that inherits the bindings from a parent {@link Component} or
@@ -28,6 +30,7 @@
  * @author Gregory Kick
  * @since 2.0
  */
+@Retention(RUNTIME) // Allows runtimes to have specialized behavior interoperating with Dagger.
 @Target(TYPE)
 @Documented
 public @interface Subcomponent {
diff --git a/core/src/main/java/dagger/internal/DelegateFactory.java b/core/src/main/java/dagger/internal/DelegateFactory.java
new file mode 100644
index 000000000..d1e864d17
--- /dev/null
+++ b/core/src/main/java/dagger/internal/DelegateFactory.java
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal;
+
+import javax.inject.Provider;
+
+/**
+ * A DelegateFactory that is used to stitch Provider/Lazy indirection based dependency cycles.
+ * 
+ * @since 2.0.1
+ */
+public final class DelegateFactory<T> implements Factory<T> {
+  private Provider<T> delegate;
+
+  @Override
+  public T get() {
+    if (delegate == null) {
+      throw new IllegalStateException();
+    }
+    return delegate.get();
+  }
+
+  public void setDelegatedProvider(Provider<T> delegate) {
+    if (delegate == null) {
+      throw new IllegalArgumentException();
+    }
+    if (this.delegate != null) {
+      throw new IllegalStateException();
+    }
+    this.delegate = delegate;
+  }
+}
+
diff --git a/core/src/main/java/dagger/internal/DoubleCheckLazy.java b/core/src/main/java/dagger/internal/DoubleCheckLazy.java
index 6db11f381..d0f102896 100644
--- a/core/src/main/java/dagger/internal/DoubleCheckLazy.java
+++ b/core/src/main/java/dagger/internal/DoubleCheckLazy.java
@@ -57,6 +57,16 @@ public T get() {
     if (provider == null) {
       throw new NullPointerException();
     }
+    if (provider instanceof Lazy) {
+      @SuppressWarnings("unchecked")
+      final Lazy<T> lazy = (Lazy<T>) provider;
+      // Avoids memoizing a value that is already memoized.
+      // NOTE: There is a pathological case where Provider<P> may implement Lazy<L>, but P and L
+      // are different types using covariant return on get(). Right now this is used with
+      // ScopedProvider<T> exclusively, which is implemented such that P and L are always the same
+      // so it will be fine for that case.
+      return lazy;
+    }
     return new DoubleCheckLazy<T>(provider);
   }
 }
diff --git a/core/src/main/java/dagger/internal/ScopedProvider.java b/core/src/main/java/dagger/internal/ScopedProvider.java
index 15917dd27..b25db380a 100644
--- a/core/src/main/java/dagger/internal/ScopedProvider.java
+++ b/core/src/main/java/dagger/internal/ScopedProvider.java
@@ -15,6 +15,7 @@
  */
 package dagger.internal;
 
+import dagger.Lazy;
 import javax.inject.Provider;
 
 /**
@@ -23,7 +24,7 @@
  * @author Gregory Kick
  * @since 2.0
  */
-public final class ScopedProvider<T> implements Provider<T> {
+public final class ScopedProvider<T> implements Provider<T>, Lazy<T> {
   private static final Object UNINITIALIZED = new Object();
 
   private final Factory<T> factory;
diff --git a/core/src/main/java/dagger/mapkeys/ClassKey.java b/core/src/main/java/dagger/mapkeys/ClassKey.java
new file mode 100644
index 000000000..21497c681
--- /dev/null
+++ b/core/src/main/java/dagger/mapkeys/ClassKey.java
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.mapkeys;
+
+import dagger.MapKey;
+import java.lang.annotation.Documented;
+import java.lang.annotation.Target;
+
+import static java.lang.annotation.ElementType.METHOD;
+
+/**
+ * A {@link MapKey} annotation for maps with {@code Class<?>} keys.
+ * 
+ * <p>If your map's keys can be constrained, consider using a custom annotation instead, with a
+ * member whose type is {@code Class<? extends Something>}.
+ */
+@Documented
+@Target(METHOD)
+@MapKey
+public @interface ClassKey {
+  Class<?> value();
+}
\ No newline at end of file
diff --git a/core/src/main/java/dagger/mapkeys/IntKey.java b/core/src/main/java/dagger/mapkeys/IntKey.java
new file mode 100644
index 000000000..011b49fe8
--- /dev/null
+++ b/core/src/main/java/dagger/mapkeys/IntKey.java
@@ -0,0 +1,30 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.mapkeys;
+
+import dagger.MapKey;
+import java.lang.annotation.Documented;
+import java.lang.annotation.Target;
+
+import static java.lang.annotation.ElementType.METHOD;
+
+/** A {@link MapKey} annotation for maps with {@code int} keys. */
+@Documented
+@Target(METHOD)
+@MapKey
+public @interface IntKey {
+  int value();
+}
\ No newline at end of file
diff --git a/core/src/main/java/dagger/mapkeys/LongKey.java b/core/src/main/java/dagger/mapkeys/LongKey.java
new file mode 100644
index 000000000..183b74d02
--- /dev/null
+++ b/core/src/main/java/dagger/mapkeys/LongKey.java
@@ -0,0 +1,30 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.mapkeys;
+
+import dagger.MapKey;
+import java.lang.annotation.Documented;
+import java.lang.annotation.Target;
+
+import static java.lang.annotation.ElementType.METHOD;
+
+/** A {@link MapKey} annotation for maps with {@code long} keys. */
+@Documented
+@Target(METHOD)
+@MapKey
+public @interface LongKey {
+  long value();
+}
\ No newline at end of file
diff --git a/core/src/main/java/dagger/mapkeys/StringKey.java b/core/src/main/java/dagger/mapkeys/StringKey.java
new file mode 100644
index 000000000..7455a9bc5
--- /dev/null
+++ b/core/src/main/java/dagger/mapkeys/StringKey.java
@@ -0,0 +1,30 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.mapkeys;
+
+import dagger.MapKey;
+import java.lang.annotation.Documented;
+import java.lang.annotation.Target;
+
+import static java.lang.annotation.ElementType.METHOD;
+
+/** A {@link MapKey} annotation for maps with {@link String} keys. */
+@Documented
+@Target(METHOD)
+@MapKey
+public @interface StringKey {
+  String value();
+}
\ No newline at end of file
diff --git a/examples/android-activity-graphs/pom.xml b/examples/android-activity-graphs/pom.xml
index 53de228ff..340c59c54 100644
--- a/examples/android-activity-graphs/pom.xml
+++ b/examples/android-activity-graphs/pom.xml
@@ -37,6 +37,7 @@
       <groupId>com.google.dagger</groupId>
       <artifactId>dagger-compiler</artifactId>
       <version>${project.version}</version>
+      <scope>provided</scope>
       <optional>true</optional>
     </dependency>
 
@@ -54,7 +55,7 @@
   <build>
     <plugins>
       <plugin>
-        <groupId>com.jayway.maven.plugins.android.generation2</groupId>
+        <groupId>com.simpligility.maven.plugins</groupId>
         <artifactId>android-maven-plugin</artifactId>
         <extensions>true</extensions>
       </plugin>
diff --git a/examples/android-activity-graphs/AndroidManifest.xml b/examples/android-activity-graphs/src/main/AndroidManifest.xml
similarity index 100%
rename from examples/android-activity-graphs/AndroidManifest.xml
rename to examples/android-activity-graphs/src/main/AndroidManifest.xml
diff --git a/examples/android-simple/pom.xml b/examples/android-simple/pom.xml
index 332aeb66b..fb934e6d6 100644
--- a/examples/android-simple/pom.xml
+++ b/examples/android-simple/pom.xml
@@ -37,6 +37,7 @@
       <groupId>com.google.dagger</groupId>
       <artifactId>dagger-compiler</artifactId>
       <version>${project.version}</version>
+      <scope>provided</scope>
       <optional>true</optional>
     </dependency>
 
@@ -50,7 +51,7 @@
   <build>
     <plugins>
       <plugin>
-        <groupId>com.jayway.maven.plugins.android.generation2</groupId>
+        <groupId>com.simpligility.maven.plugins</groupId>
         <artifactId>android-maven-plugin</artifactId>
         <extensions>true</extensions>
       </plugin>
diff --git a/examples/android-simple/AndroidManifest.xml b/examples/android-simple/src/main/AndroidManifest.xml
similarity index 100%
rename from examples/android-simple/AndroidManifest.xml
rename to examples/android-simple/src/main/AndroidManifest.xml
diff --git a/examples/pom.xml b/examples/pom.xml
index 708635f1a..eb4685aa0 100644
--- a/examples/pom.xml
+++ b/examples/pom.xml
@@ -62,12 +62,13 @@
           </configuration>
         </plugin>
         <plugin>
-          <groupId>com.jayway.maven.plugins.android.generation2</groupId>
+          <groupId>com.simpligility.maven.plugins</groupId>
           <artifactId>android-maven-plugin</artifactId>
-          <version>3.8.2</version>
+          <version>4.3.0</version>
           <configuration>
             <sdk>
-              <platform>16</platform>
+              <platform>23</platform>
+              <path>${env.ANDROID_HOME}</path>
             </sdk>
           </configuration>
         </plugin>
diff --git a/pom.xml b/pom.xml
index d584d49d0..1d702c6db 100644
--- a/pom.xml
+++ b/pom.xml
@@ -44,15 +44,18 @@
     <!-- Compilation -->
     <java.version>1.7</java.version>
     <javax.inject.version>1</javax.inject.version>
+    <javax.annotation.version>2.0.1</javax.annotation.version>
     <javawriter.version>2.5.0</javawriter.version>
     <auto.common.version>1.0-SNAPSHOT</auto.common.version>
-    <auto.factory.version>1.0-SNAPSHOT</auto.factory.version>
+    <auto.factory.version>1.0-beta3</auto.factory.version>
     <auto.service.version>1.0-rc2</auto.service.version>
     <auto.value.version>1.0</auto.value.version>
-    <guava.version>18.0</guava.version>
+    <guava.version>19.0-rc2</guava.version>
+    <google.java.format.version>0.1-SNAPSHOT</google.java.format.version>
+
 
     <!-- Test Dependencies -->
-    <compile-testing.version>0.7</compile-testing.version>
+    <compile-testing.version>1.0-SNAPSHOT</compile-testing.version>
     <junit.version>4.11</junit.version>
     <mockito.version>1.9.5</mockito.version>
     <truth.version>0.26</truth.version>
@@ -88,6 +91,16 @@
         <groupId>javax.inject</groupId>
         <artifactId>javax.inject</artifactId>
         <version>${javax.inject.version}</version>
+      </dependency>
+       <dependency>
+        <groupId>javax.inject</groupId>
+        <artifactId>javax.inject-tck</artifactId>
+        <version>${javax.inject.version}</version>
+      </dependency>
+      <dependency>
+        <groupId>com.google.code.findbugs</groupId>
+        <artifactId>jsr305</artifactId>
+        <version>${javax.annotation.version}</version>
       </dependency>
       <dependency>
         <groupId>com.squareup</groupId>
@@ -104,6 +117,11 @@
         <artifactId>guava-testlib</artifactId>
         <version>${guava.version}</version>
       </dependency>
+      <dependency>
+        <groupId>com.google.googlejavaformat</groupId>
+        <artifactId>google-java-format</artifactId>
+        <version>${google.java.format.version}</version>
+      </dependency>
       <dependency>
         <groupId>com.google.auto</groupId>
         <artifactId>auto-common</artifactId>
diff --git a/producers/pom.xml b/producers/pom.xml
index 32ecaf0a5..edaeca428 100644
--- a/producers/pom.xml
+++ b/producers/pom.xml
@@ -35,6 +35,11 @@
       <artifactId>dagger</artifactId>
       <version>${project.version}</version>
     </dependency>
+    <dependency>
+      <groupId>com.google.code.findbugs</groupId>
+      <artifactId>jsr305</artifactId>
+      <optional>true</optional>
+    </dependency>
     <dependency>
       <groupId>com.google.guava</groupId>
       <artifactId>guava</artifactId>
@@ -49,5 +54,15 @@
       <artifactId>truth</artifactId>
       <scope>test</scope>
     </dependency>
+    <dependency>
+      <groupId>com.google.guava</groupId>
+      <artifactId>guava-testlib</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.mockito</groupId>
+      <artifactId>mockito-core</artifactId>
+      <scope>test</scope>
+    </dependency>
   </dependencies>
 </project>
diff --git a/producers/src/main/java/dagger/producers/Produced.java b/producers/src/main/java/dagger/producers/Produced.java
index 3fbbee24c..db5c133ff 100644
--- a/producers/src/main/java/dagger/producers/Produced.java
+++ b/producers/src/main/java/dagger/producers/Produced.java
@@ -15,8 +15,12 @@
  */
 package dagger.producers;
 
+import com.google.common.base.Objects;
 import dagger.internal.Beta;
 import java.util.concurrent.ExecutionException;
+import javax.annotation.Nullable;
+
+import static com.google.common.base.Preconditions.checkNotNull;
 
 /**
  * An interface that represents the result of a {@linkplain Producer production} of type {@code T},
@@ -39,11 +43,91 @@
  * @author Jesse Beder
  */
 @Beta
-public interface Produced<T> {
+public abstract class Produced<T> {
   /**
    * Returns the result of a production.
    *
    * @throws ExecutionException if the production threw an exception
    */
-  T get() throws ExecutionException;
+  public abstract T get() throws ExecutionException;
+
+  /**
+   * Two {@code Produced} objects compare equal if both are successful with equal values, or both
+   * are failed with equal exceptions.
+   */
+  @Override
+  public abstract boolean equals(Object o);
+
+  /** Returns an appropriate hash code to match {@link #equals). */
+  @Override
+  public abstract int hashCode();
+
+  /** Returns a successful {@code Produced}, whose {@link #get} will return the given value. */
+  public static <T> Produced<T> successful(@Nullable T value) {
+    return new Successful<T>(value);
+  }
+
+  /**
+   * Returns a failed {@code Produced}, whose {@link #get} will throw an
+   * {@code ExecutionException} with the given cause.
+   */
+  public static <T> Produced<T> failed(Throwable throwable) {
+    return new Failed<T>(checkNotNull(throwable));
+  }
+
+  private static final class Successful<T> extends Produced<T> {
+    @Nullable private final T value;
+
+    private Successful(@Nullable T value) {
+      this.value = value;
+    }
+
+    @Override public T get() {
+      return value;
+    }
+
+    @Override public boolean equals(Object o) {
+      if (o == this) {
+        return true;
+      } else if (o instanceof Successful) {
+        Successful<?> that = (Successful<?>) o;
+        return Objects.equal(this.value, that.value);
+      } else {
+        return false;
+      }
+    }
+
+    @Override public int hashCode() {
+      return value == null ? 0 : value.hashCode();
+    }
+  }
+
+  private static final class Failed<T> extends Produced<T> {
+    private final Throwable throwable;
+
+    private Failed(Throwable throwable) {
+      this.throwable = checkNotNull(throwable);
+    }
+
+    @Override public T get() throws ExecutionException {
+      throw new ExecutionException(throwable);
+    }
+
+    @Override public boolean equals(Object o) {
+      if (o == this) {
+        return true;
+      } else if (o instanceof Failed) {
+        Failed<?> that = (Failed<?>) o;
+        return this.throwable.equals(that.throwable);
+      } else {
+        return false;
+      }
+    }
+
+    @Override public int hashCode() {
+      return throwable.hashCode();
+    }
+  }
+
+  private Produced() {}
 }
diff --git a/producers/src/main/java/dagger/producers/ProductionComponent.java b/producers/src/main/java/dagger/producers/ProductionComponent.java
index 6aa9ea8f0..8ccdb4433 100644
--- a/producers/src/main/java/dagger/producers/ProductionComponent.java
+++ b/producers/src/main/java/dagger/producers/ProductionComponent.java
@@ -62,7 +62,7 @@
  * <p>If a non-execution exception is thrown (e.g., an {@code InterruptedException} or
  * {@code CancellationException}), then exception is handled as in
  * {@link com.google.common.util.concurrent.Futures#transform}.
- * <!-- TODO(user): Explain this more thoroughly, and update the javadocs of those utilities. -->
+ * <!-- TODO(beder): Explain this more thoroughly, and update the javadocs of those utilities. -->
  *
  * @author Jesse Beder
  */
@@ -80,4 +80,42 @@
    * A list of types that are to be used as component dependencies.
    */
   Class<?>[] dependencies() default {};
+
+  /**
+   * A builder for a component. Components may have a single nested static abstract class or
+   * interface annotated with {@code @ProductionComponent.Builder}. If they do, then the component's
+   * generated builder will match the API in the type.  Builders must follow some rules:
+   * <ul>
+   * <li> A single abstract method with no arguments must exist, and must return the component.
+   *      (This is typically the {@code build()} method.)
+   * <li> All other abstract methods must take a single argument and must return void,
+   *      the builder type, or a supertype of the builder.
+   * <li> There <b>must</b> be an abstract method whose parameter is
+   *      {@link java.util.concurrent.Executor}.
+   * <li> Each component dependency <b>must</b> have an abstract setter method.
+   * <li> Each module dependency that Dagger can't instantiate itself (i.e., the module
+   *      doesn't have a visible no-args constructor) <b>must</b> have an abstract setter method.
+   *      Other module dependencies (ones that Dagger can instantiate) are allowed, but not
+   *      required.
+   * <li> Non-abstract methods are allowed, but ignored as far as validation and builder generation
+   *      are concerned.
+   * </ul>
+   *
+   * For example, this could be a valid {@code ProductionComponent} with a builder: <pre><code>
+   * {@literal @}ProductionComponent(modules = {BackendModule.class, FrontendModule.class})
+   * interface MyComponent {
+   *   {@literal ListenableFuture<MyWidget>} myWidget();
+   *
+   *   {@literal @}ProductionComponent.Builder
+   *   interface Builder {
+   *     MyComponent build();
+   *     Builder executor(Executor executor);
+   *     Builder backendModule(BackendModule bm);
+   *     Builder frontendModule(FrontendModule fm);
+   *   }
+   * }</code></pre>
+   */
+  @Target(TYPE)
+  @Documented
+  @interface Builder {}
 }
diff --git a/producers/src/main/java/dagger/producers/internal/AbstractProducer.java b/producers/src/main/java/dagger/producers/internal/AbstractProducer.java
index 43659980b..f7e8ec0e5 100644
--- a/producers/src/main/java/dagger/producers/internal/AbstractProducer.java
+++ b/producers/src/main/java/dagger/producers/internal/AbstractProducer.java
@@ -17,6 +17,15 @@
 
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.producers.Producer;
+import dagger.producers.monitoring.ProducerMonitor;
+import dagger.producers.monitoring.ProducerToken;
+import dagger.producers.monitoring.ProductionComponentMonitor;
+import dagger.producers.monitoring.internal.Monitors;
+
+import static com.google.common.base.Preconditions.checkNotNull;
+
+import javax.annotation.Nullable;
+import javax.inject.Provider;
 
 /**
  * An abstract {@link Producer} implementation that memoizes the result of its compute method.
@@ -25,10 +34,22 @@
  * @since 2.0
  */
 public abstract class AbstractProducer<T> implements Producer<T> {
+  private final Provider<ProductionComponentMonitor> monitorProvider;
+  @Nullable private final ProducerToken token;
   private volatile ListenableFuture<T> instance = null;
 
+  protected AbstractProducer() {
+    this(Monitors.noOpProductionComponentMonitorProvider(), null);
+  }
+
+  protected AbstractProducer(
+      Provider<ProductionComponentMonitor> monitorProvider, @Nullable ProducerToken token) {
+    this.monitorProvider = checkNotNull(monitorProvider);
+    this.token = token;
+  }
+
   /** Computes this producer's future, which is then cached in {@link #get}. */
-  protected abstract ListenableFuture<T> compute();
+  protected abstract ListenableFuture<T> compute(ProducerMonitor monitor);
 
   @Override
   public final ListenableFuture<T> get() {
@@ -38,10 +59,12 @@
       synchronized (this) {
         result = instance;
         if (result == null) {
-          instance = result = compute();
+          ProducerMonitor monitor = monitorProvider.get().producerMonitorFor(token);
+          instance = result = compute(monitor);
           if (result == null) {
             throw new NullPointerException("compute returned null");
           }
+          monitor.addCallbackTo(result);
         }
       }
     }
diff --git a/producers/src/main/java/dagger/producers/internal/Producers.java b/producers/src/main/java/dagger/producers/internal/Producers.java
index c850caa33..4156e99e0 100644
--- a/producers/src/main/java/dagger/producers/internal/Producers.java
+++ b/producers/src/main/java/dagger/producers/internal/Producers.java
@@ -17,17 +17,13 @@
 
 import com.google.common.base.Function;
 import com.google.common.collect.ImmutableSet;
-import com.google.common.util.concurrent.FutureFallback;
+import com.google.common.util.concurrent.AsyncFunction;
 import com.google.common.util.concurrent.Futures;
 import com.google.common.util.concurrent.ListenableFuture;
-import com.google.common.util.concurrent.ListenableFutureTask;
 import dagger.producers.Produced;
 import dagger.producers.Producer;
+import dagger.producers.monitoring.ProducerMonitor;
 import java.util.Set;
-import java.util.concurrent.Callable;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.Executor;
-import java.util.concurrent.RejectedExecutionException;
 import javax.inject.Provider;
 
 import static com.google.common.base.Preconditions.checkNotNull;
@@ -52,34 +48,32 @@
   // TODO(user): Document what happens with an InterruptedException after you figure out how to
   // trigger one in a test.
   public static <T> ListenableFuture<Produced<T>> createFutureProduced(ListenableFuture<T> future) {
-    return Futures.withFallback(
-        Futures.transform(future, new Function<T, Produced<T>>() {
-          @Override public Produced<T> apply(final T value) {
-            return new Produced<T>() {
-              @Override public T get() {
-                return value;
+    return Futures.catchingAsync(
+        Futures.transform(
+            future,
+            new Function<T, Produced<T>>() {
+              @Override
+              public Produced<T> apply(final T value) {
+                return Produced.successful(value);
               }
-            };
-          }
-        }), Producers.<T>futureFallbackForProduced());
+            }),
+        Throwable.class,
+        Producers.<T>futureFallbackForProduced());
 
   }
 
-  private static final FutureFallback<Produced<Object>> FUTURE_FALLBACK_FOR_PRODUCED =
-      new FutureFallback<Produced<Object>>() {
-    @Override public ListenableFuture<Produced<Object>> create(final Throwable t) {
-      Produced<Object> produced = new Produced<Object>() {
-        @Override public Object get() throws ExecutionException {
-          throw new ExecutionException(t);
+  private static final AsyncFunction<Throwable, Produced<Object>> FUTURE_FALLBACK_FOR_PRODUCED =
+      new AsyncFunction<Throwable, Produced<Object>>() {
+        @Override
+        public ListenableFuture<Produced<Object>> apply(Throwable t) throws Exception {
+          Produced<Object> produced = Produced.failed(t);
+          return Futures.immediateFuture(produced);
         }
       };
-      return Futures.immediateFuture(produced);
-    }
-  };
 
-  @SuppressWarnings({"unchecked", "rawtypes"})  // bivariant implementation
-  private static <T> FutureFallback<Produced<T>> futureFallbackForProduced() {
-    return (FutureFallback) FUTURE_FALLBACK_FOR_PRODUCED;
+  @SuppressWarnings({"unchecked", "rawtypes"}) // bivariant implementation
+  private static <T> AsyncFunction<Throwable, Produced<T>> futureFallbackForProduced() {
+    return (AsyncFunction) FUTURE_FALLBACK_FOR_PRODUCED;
   }
 
   /**
@@ -94,19 +88,6 @@
     });
   }
 
-  /**
-   * Submits a callable to an executor, returning the future representing the task. This mirrors
-   * {@link com.google.common.util.concurrent.ListeningExecutorService#submit}, but only requires an
-   * {@link Executor}.
-   *
-   * @throws RejectedExecutionException if this task cannot be accepted for execution.
-   */
-  public static <T> ListenableFuture<T> submitToExecutor(Callable<T> callable, Executor executor) {
-    ListenableFutureTask<T> future = ListenableFutureTask.create(callable);
-    executor.execute(future);
-    return future;
-  }
-
   /**
    * Returns a producer that immediately executes the binding logic for the given provider every
    * time it is called.
@@ -114,11 +95,32 @@
   public static <T> Producer<T> producerFromProvider(final Provider<T> provider) {
     checkNotNull(provider);
     return new AbstractProducer<T>() {
-      @Override protected ListenableFuture<T> compute() {
+      @Override
+      protected ListenableFuture<T> compute(ProducerMonitor unusedMonitor) {
         return Futures.immediateFuture(provider.get());
       }
     };
   }
 
+  /** Returns a producer that succeeds with the given value. */
+  public static <T> Producer<T> immediateProducer(final T value) {
+    return new Producer<T>() {
+      @Override
+      public ListenableFuture<T> get() {
+        return Futures.immediateFuture(value);
+      }
+    };
+  }
+
+  /** Returns a producer that fails with the given exception. */
+  public static <T> Producer<T> immediateFailedProducer(final Throwable throwable) {
+    return new Producer<T>() {
+      @Override
+      public ListenableFuture<T> get() {
+        return Futures.immediateFailedFuture(throwable);
+      }
+    };
+  }
+
   private Producers() {}
 }
diff --git a/producers/src/main/java/dagger/producers/internal/SetOfProducedProducer.java b/producers/src/main/java/dagger/producers/internal/SetOfProducedProducer.java
new file mode 100644
index 000000000..e51bcad42
--- /dev/null
+++ b/producers/src/main/java/dagger/producers/internal/SetOfProducedProducer.java
@@ -0,0 +1,117 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.producers.internal;
+
+import com.google.common.base.Function;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.util.concurrent.Futures;
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.producers.Produced;
+import dagger.producers.Producer;
+import dagger.producers.monitoring.ProducerMonitor;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Set;
+import java.util.concurrent.ExecutionException;
+
+/**
+ * A {@link Producer} implementation used to implement {@link Set} bindings. This producer returns a
+ * future {@code Set<Produced<T>>} whose elements are populated by subsequent calls to the delegate
+ * {@link Producer#get} methods.
+ *
+ * @author Jesse Beder
+ * @since 2.0
+ */
+public final class SetOfProducedProducer<T> extends AbstractProducer<Set<Produced<T>>> {
+  /**
+   * Returns a new producer that creates {@link Set} futures from the union of the given
+   * {@link Producer} instances.
+   */
+  @SafeVarargs
+  public static <T> Producer<Set<Produced<T>>> create(Producer<Set<T>>... producers) {
+    return new SetOfProducedProducer<T>(ImmutableSet.copyOf(producers));
+  }
+
+  private final ImmutableSet<Producer<Set<T>>> contributingProducers;
+
+  private SetOfProducedProducer(ImmutableSet<Producer<Set<T>>> contributingProducers) {
+    this.contributingProducers = contributingProducers;
+  }
+
+  /**
+   * Returns a future {@link Set} of {@link Produced} values whose iteration order is that of the
+   * elements given by each of the producers, which are invoked in the order given at creation.
+   *
+   * <p>If any of the delegate sets, or any elements therein, are null, then that corresponding
+   * {@code Produced} element will fail with a NullPointerException.
+   *
+   * <p>Canceling this future will attempt to cancel all of the component futures; but if any of the
+   * delegate futures fail or are canceled, this future succeeds, with the appropriate failed
+   * {@link Produced}.
+   *
+   * @throws NullPointerException if any of the delegate producers return null
+   */
+  @Override
+  public ListenableFuture<Set<Produced<T>>> compute(ProducerMonitor unusedMonitor) {
+    List<ListenableFuture<Produced<Set<T>>>> futureProducedSets =
+        new ArrayList<ListenableFuture<Produced<Set<T>>>>(contributingProducers.size());
+    for (Producer<Set<T>> producer : contributingProducers) {
+      ListenableFuture<Set<T>> futureSet = producer.get();
+      if (futureSet == null) {
+        throw new NullPointerException(producer + " returned null");
+      }
+      futureProducedSets.add(Producers.createFutureProduced(futureSet));
+    }
+    return Futures.transform(
+        Futures.allAsList(futureProducedSets),
+        new Function<List<Produced<Set<T>>>, Set<Produced<T>>>() {
+          @Override
+          public Set<Produced<T>> apply(List<Produced<Set<T>>> producedSets) {
+            ImmutableSet.Builder<Produced<T>> builder = ImmutableSet.builder();
+            for (Produced<Set<T>> producedSet : producedSets) {
+              try {
+                Set<T> set = producedSet.get();
+                if (set == null) {
+                  // TODO(beder): This is a vague exception. Can we somehow point to the failing
+                  // producer? See the similar comment in the component writer about null
+                  // provisions.
+                  builder.add(
+                      Produced.<T>failed(
+                          new NullPointerException(
+                              "Cannot contribute a null set into a producer set binding when it's"
+                                  + " injected as Set<Produced<T>>.")));
+                } else {
+                  for (T value : set) {
+                    if (value == null) {
+                      builder.add(
+                          Produced.<T>failed(
+                              new NullPointerException(
+                                  "Cannot contribute a null element into a producer set binding"
+                                      + " when it's injected as Set<Produced<T>>.")));
+                    } else {
+                      builder.add(Produced.successful(value));
+                    }
+                  }
+                }
+              } catch (ExecutionException e) {
+                builder.add(Produced.<T>failed(e.getCause()));
+              }
+            }
+            return builder.build();
+          }
+        });
+  }
+}
diff --git a/producers/src/main/java/dagger/producers/internal/SetProducer.java b/producers/src/main/java/dagger/producers/internal/SetProducer.java
index 399dbd031..5b3c0902d 100644
--- a/producers/src/main/java/dagger/producers/internal/SetProducer.java
+++ b/producers/src/main/java/dagger/producers/internal/SetProducer.java
@@ -20,6 +20,7 @@
 import com.google.common.util.concurrent.Futures;
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.producers.Producer;
+import dagger.producers.monitoring.ProducerMonitor;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Set;
@@ -37,14 +38,15 @@
    * Returns a new producer that creates {@link Set} futures from the union of the given
    * {@link Producer} instances.
    */
-  public static <T> Producer<Set<T>> create(
-      @SuppressWarnings("unchecked") Producer<Set<T>>... producers) {
+  @SafeVarargs
+  public static <T> Producer<Set<T>> create(Producer<Set<T>>... producers) {
     return new SetProducer<T>(ImmutableSet.copyOf(producers));
   }
 
   private final Set<Producer<Set<T>>> contributingProducers;
 
   private SetProducer(Set<Producer<Set<T>>> contributingProducers) {
+    super();
     this.contributingProducers = contributingProducers;
   }
 
@@ -61,7 +63,7 @@ private SetProducer(Set<Producer<Set<T>>> contributingProducers) {
    * @throws NullPointerException if any of the delegate producers return null
    */
   @Override
-  public ListenableFuture<Set<T>> compute() {
+  public ListenableFuture<Set<T>> compute(ProducerMonitor unusedMonitor) {
     List<ListenableFuture<Set<T>>> futureSets =
         new ArrayList<ListenableFuture<Set<T>>>(contributingProducers.size());
     for (Producer<Set<T>> producer : contributingProducers) {
diff --git a/producers/src/main/java/dagger/producers/monitoring/ProducerMonitor.java b/producers/src/main/java/dagger/producers/monitoring/ProducerMonitor.java
new file mode 100644
index 000000000..20551c3db
--- /dev/null
+++ b/producers/src/main/java/dagger/producers/monitoring/ProducerMonitor.java
@@ -0,0 +1,106 @@
+/*
+ * Copyright (C) 2015 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.producers.monitoring;
+
+import com.google.common.util.concurrent.FutureCallback;
+import com.google.common.util.concurrent.Futures;
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.producers.Produces;
+
+/**
+ * A hook for monitoring the execution of individual {@linkplain Produces producer methods}. See
+ * {@link ProductionComponentMonitor} for how to install these monitors.
+ *
+ * <p>The lifecycle of the monitor, under normal conditions, is:
+ * <ul>
+ *   <li>{@link #methodStarting()}
+ *   <li>The method is called
+ *   <li>{@link #methodFinished()}
+ *   <li>If the method returns a value, then:
+ *   <ul>
+ *     <li>{@link #succeeded(Object)} if the method returned normally; or
+ *     <li>{@link #failed(Throwable)} if the method threw an exception.
+ *   </ul>
+ *   <li>If the method returns a future, then:
+ *   <ul>
+ *     <li>{@link #succeeded(Object)} if the method returned normally, and the future succeeded; or
+ *     <li>{@link #failed(Throwable)} if the method threw an exception, or returned normally and the
+ *         future failed.
+ *   </ul>
+ * </ul>
+ *
+ * <p>If any input to the monitored producer fails, {@link #failed(Throwable)} will be called
+ * immediately with the failed input's exception. If more than one input fails, an arbitrary failed
+ * input's exception is used.
+ *
+ * <p>If any of the monitor's methods throw, then the exception will be logged and processing will
+ * continue unaffected.
+ *
+ * @author Jesse Beder
+ */
+public abstract class ProducerMonitor {
+  /**
+   * Called when the producer method is about to start executing.
+   *
+   * <p>When multiple monitors are installed, the order that each monitor will call this method is
+   * unspecified, but will remain consistent throughout the course of the execution of a component.
+   */
+  public void methodStarting() {}
+
+  /**
+   * Called when the producer method has finished executing.
+   *
+   * <p>When multiple monitors are installed, calls to this method will be in the reverse order from
+   * calls to {@link #methodStarting()}.
+   */
+  public void methodFinished() {}
+
+  /**
+   * Called when the producer’s future has completed successfully with a value.
+   *
+   * <p>When multiple monitors are installed, calls to this method will be in the reverse order from
+   * calls to {@link #methodStarting()}.
+   */
+  public void succeeded(Object o) {}
+
+  /**
+   * Called when the producer's future has failed with an exception.
+   *
+   * <p>When multiple monitors are installed, calls to this method will be in the reverse order from
+   * calls to {@link #methodStarting()}.
+   */
+  public void failed(Throwable t) {}
+
+  /**
+   * Adds this monitor's completion methods as a callback to the future. This is only intended to be
+   * overridden in the framework!
+   */
+  public <T> void addCallbackTo(ListenableFuture<T> future) {
+    Futures.addCallback(
+        future,
+        new FutureCallback<T>() {
+          @Override
+          public void onSuccess(T value) {
+            succeeded(value);
+          }
+
+          @Override
+          public void onFailure(Throwable t) {
+            failed(t);
+          }
+        });
+  }
+}
diff --git a/producers/src/main/java/dagger/producers/monitoring/ProducerToken.java b/producers/src/main/java/dagger/producers/monitoring/ProducerToken.java
new file mode 100644
index 000000000..5834206ee
--- /dev/null
+++ b/producers/src/main/java/dagger/producers/monitoring/ProducerToken.java
@@ -0,0 +1,64 @@
+/*
+ * Copyright (C) 2015 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.producers.monitoring;
+
+import dagger.producers.Produces;
+
+import static com.google.common.base.Preconditions.checkNotNull;
+
+/** A token that represents an individual {@linkplain Produces producer method}. */
+public final class ProducerToken {
+  private final Class<?> classToken;
+
+  private ProducerToken(Class<?> classToken) {
+    this.classToken = classToken;
+  }
+
+  /**
+   * Creates a token for a class token that represents the generated factory for a producer method.
+   *
+   * <p><b>Do not use this!</b> This is intended to be called by generated code only, and its
+   * signature may change at any time.
+   */
+  public static ProducerToken create(Class<?> classToken) {
+    return new ProducerToken(checkNotNull(classToken));
+  }
+
+  /** Two tokens are equal if they represent the same method. */
+  @Override
+  public boolean equals(Object o) {
+    if (o == this) {
+      return true;
+    } else if (o instanceof ProducerToken) {
+      ProducerToken that = (ProducerToken) o;
+      return this.classToken.equals(that.classToken);
+    } else {
+      return false;
+    }
+  }
+
+  /** Returns an appropriate hash code to match {@link #equals). */
+  @Override
+  public int hashCode() {
+    return classToken.hashCode();
+  }
+
+  /** Returns a representation of the method. */
+  @Override
+  public String toString() {
+    return classToken.toString();
+  }
+}
diff --git a/producers/src/main/java/dagger/producers/monitoring/ProductionComponentMonitor.java b/producers/src/main/java/dagger/producers/monitoring/ProductionComponentMonitor.java
new file mode 100644
index 000000000..4dc2903fa
--- /dev/null
+++ b/producers/src/main/java/dagger/producers/monitoring/ProductionComponentMonitor.java
@@ -0,0 +1,56 @@
+/*
+ * Copyright (C) 2015 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.producers.monitoring;
+
+import dagger.producers.Produces;
+import dagger.producers.ProductionComponent;
+
+/**
+ * A hook for monitoring execution of {@linkplain ProductionComponent production components}. To
+ * install a {@code ProductionComponentMonitor}, contribute to a set binding of
+ * {@code ProductionComponentMonitor.Factory}. The factory will be asked to create one monitor for
+ * the component, and the resulting single instance will be used to create individual monitors for
+ * producers.
+ *
+ * <p>For example: <pre><code>
+ *   {@literal @Module}
+ *   final class MyMonitorModule {
+ *     {@literal @Provides(type = SET)} ProductionComponentMonitor.Factory provideMonitorFactory(
+ *         MyProductionComponentMonitor.Factory monitorFactory) {
+ *       return monitorFactory;
+ *     }
+ *   }
+ *
+ *   {@literal @ProductionComponent(modules = {MyMonitorModule.class, MyProducerModule.class})}
+ *   interface MyComponent {
+ *     {@literal ListenableFuture<SomeType>} someType();
+ *   }
+ * </code></pre>
+ *
+ * <p>If any of these methods throw, then the exception will be logged, and the framework will act
+ * as though a no-op monitor was returned.
+ *
+ * @author Jesse Beder
+ */
+public interface ProductionComponentMonitor {
+  /** Returns a monitor for an individual {@linkplain Produces producer method}. */
+  ProducerMonitor producerMonitorFor(ProducerToken token);
+
+  public interface Factory {
+    /** Creates a component-specific monitor when the component is created. */
+    ProductionComponentMonitor create(Object component);
+  }
+}
diff --git a/producers/src/main/java/dagger/producers/monitoring/internal/MonitorCache.java b/producers/src/main/java/dagger/producers/monitoring/internal/MonitorCache.java
new file mode 100644
index 000000000..2a76c5f71
--- /dev/null
+++ b/producers/src/main/java/dagger/producers/monitoring/internal/MonitorCache.java
@@ -0,0 +1,62 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.producers.monitoring.internal;
+
+import dagger.producers.monitoring.ProductionComponentMonitor;
+import java.util.Set;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+import javax.inject.Provider;
+
+/**
+ * A class that provides a {@link ProductionComponentMonitor} for use in production components.
+ *
+ * <p>This caches the underlying the monitor, since we want a single instance for each component.
+ */
+public final class MonitorCache {
+  private static final Logger logger = Logger.getLogger(MonitorCache.class.getName());
+
+  private volatile ProductionComponentMonitor monitor;
+
+  /**
+   * Returns the underlying monitor. This will only actually compute the monitor the first time it
+   * is called; subsequent calls will simply return the cached value, so the arguments to this
+   * method are ignored. It is expected (though not checked) that this method is called with
+   * equivalent arguments each time (like a {@link dagger.Provides @Provides} method would).
+   */
+  public ProductionComponentMonitor monitor(
+      Provider<?> componentProvider,
+      Provider<Set<ProductionComponentMonitor.Factory>> monitorFactorySetProvider) {
+    ProductionComponentMonitor result = monitor;
+    if (result == null) {
+      synchronized (this) {
+        result = monitor;
+        if (result == null) {
+          try {
+            ProductionComponentMonitor.Factory factory =
+                Monitors.delegatingProductionComponentMonitorFactory(
+                    monitorFactorySetProvider.get());
+            result = monitor = factory.create(componentProvider.get());
+          } catch (RuntimeException e) {
+            logger.log(Level.SEVERE, "RuntimeException while constructing monitor factories.", e);
+            result = monitor = Monitors.noOpProductionComponentMonitor();
+          }
+        }
+      }
+    }
+    return result;
+  }
+}
diff --git a/producers/src/main/java/dagger/producers/monitoring/internal/Monitors.java b/producers/src/main/java/dagger/producers/monitoring/internal/Monitors.java
new file mode 100644
index 000000000..f27ce37b1
--- /dev/null
+++ b/producers/src/main/java/dagger/producers/monitoring/internal/Monitors.java
@@ -0,0 +1,371 @@
+/*
+ * Copyright (C) 2015 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.producers.monitoring.internal;
+
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.Iterables;
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.producers.monitoring.ProducerMonitor;
+import dagger.producers.monitoring.ProducerToken;
+import dagger.producers.monitoring.ProductionComponentMonitor;
+import java.util.Collection;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+import javax.inject.Provider;
+
+/**
+ * Utility methods relating to monitoring, for use in generated producers code.
+ *
+ * @author Jesse Beder
+ */
+public final class Monitors {
+  private static final Logger logger = Logger.getLogger(Monitors.class.getName());
+
+  /**
+   * Returns a monitor factory that delegates to the given factories, and ensures that any method
+   * called on this object, even transitively, does not throw a {@link RuntimeException} or return
+   * null.
+   *
+   * <p>If the delegate monitors throw an {@link Error}, then that will escape this monitor
+   * implementation. Errors are treated as unrecoverable conditions, and may cause the entire
+   * component's execution to fail.
+   */
+  public static ProductionComponentMonitor.Factory delegatingProductionComponentMonitorFactory(
+      Collection<? extends ProductionComponentMonitor.Factory> factories) {
+    if (factories.isEmpty()) {
+      return noOpProductionComponentMonitorFactory();
+    } else if (factories.size() == 1) {
+      return new NonThrowingProductionComponentMonitor.Factory(Iterables.getOnlyElement(factories));
+    } else {
+      return new DelegatingProductionComponentMonitor.Factory(factories);
+    }
+  }
+
+  /**
+   * A component monitor that delegates to a single monitor, and catches and logs all exceptions
+   * that the delegate throws.
+   */
+  private static final class NonThrowingProductionComponentMonitor
+      implements ProductionComponentMonitor {
+    private final ProductionComponentMonitor delegate;
+
+    NonThrowingProductionComponentMonitor(ProductionComponentMonitor delegate) {
+      this.delegate = delegate;
+    }
+
+    @Override
+    public ProducerMonitor producerMonitorFor(ProducerToken token) {
+      try {
+        ProducerMonitor monitor = delegate.producerMonitorFor(token);
+        return monitor == null ? noOpProducerMonitor() : new NonThrowingProducerMonitor(monitor);
+      } catch (RuntimeException e) {
+        logProducerMonitorForException(e, delegate, token);
+        return noOpProducerMonitor();
+      }
+    }
+
+    static final class Factory implements ProductionComponentMonitor.Factory {
+      private final ProductionComponentMonitor.Factory delegate;
+
+      Factory(ProductionComponentMonitor.Factory delegate) {
+        this.delegate = delegate;
+      }
+
+      @Override
+      public ProductionComponentMonitor create(Object component) {
+        try {
+          ProductionComponentMonitor monitor = delegate.create(component);
+          return monitor == null
+              ? noOpProductionComponentMonitor()
+              : new NonThrowingProductionComponentMonitor(monitor);
+        } catch (RuntimeException e) {
+          logCreateException(e, delegate, component);
+          return noOpProductionComponentMonitor();
+        }
+      }
+    }
+  }
+
+  /**
+   * A producer monitor that delegates to a single monitor, and catches and logs all exceptions
+   * that the delegate throws.
+   */
+  private static final class NonThrowingProducerMonitor extends ProducerMonitor {
+    private final ProducerMonitor delegate;
+
+    NonThrowingProducerMonitor(ProducerMonitor delegate) {
+      this.delegate = delegate;
+    }
+
+    @Override
+    public void methodStarting() {
+      try {
+        delegate.methodStarting();
+      } catch (RuntimeException e) {
+        logProducerMonitorMethodException(e, delegate, "methodStarting");
+      }
+    }
+
+    @Override
+    public void methodFinished() {
+      try {
+        delegate.methodFinished();
+      } catch (RuntimeException e) {
+        logProducerMonitorMethodException(e, delegate, "methodFinished");
+      }
+    }
+
+    @Override
+    public void succeeded(Object o) {
+      try {
+        delegate.succeeded(o);
+      } catch (RuntimeException e) {
+        logProducerMonitorArgMethodException(e, delegate, "succeeded", o);
+      }
+    }
+
+    @Override
+    public void failed(Throwable t) {
+      try {
+        delegate.failed(t);
+      } catch (RuntimeException e) {
+        logProducerMonitorArgMethodException(e, delegate, "failed", t);
+      }
+    }
+  }
+
+  /**
+   * A component monitor that delegates to several monitors, and catches and logs all exceptions
+   * that the delegates throw.
+   */
+  private static final class DelegatingProductionComponentMonitor
+      implements ProductionComponentMonitor {
+    private final ImmutableList<ProductionComponentMonitor> delegates;
+
+    DelegatingProductionComponentMonitor(ImmutableList<ProductionComponentMonitor> delegates) {
+      this.delegates = delegates;
+    }
+
+    @Override
+    public ProducerMonitor producerMonitorFor(ProducerToken token) {
+      ImmutableList.Builder<ProducerMonitor> monitorsBuilder = ImmutableList.builder();
+      for (ProductionComponentMonitor delegate : delegates) {
+        try {
+          ProducerMonitor monitor = delegate.producerMonitorFor(token);
+          if (monitor != null) {
+            monitorsBuilder.add(monitor);
+          }
+        } catch (RuntimeException e) {
+          logProducerMonitorForException(e, delegate, token);
+        }
+      }
+      ImmutableList<ProducerMonitor> monitors = monitorsBuilder.build();
+      if (monitors.isEmpty()) {
+        return noOpProducerMonitor();
+      } else if (monitors.size() == 1) {
+        return new NonThrowingProducerMonitor(Iterables.getOnlyElement(monitors));
+      } else {
+        return new DelegatingProducerMonitor(monitors);
+      }
+    }
+
+    static final class Factory implements ProductionComponentMonitor.Factory {
+      private final ImmutableList<? extends ProductionComponentMonitor.Factory> delegates;
+
+      Factory(Iterable<? extends ProductionComponentMonitor.Factory> delegates) {
+        this.delegates = ImmutableList.copyOf(delegates);
+      }
+
+      @Override
+      public ProductionComponentMonitor create(Object component) {
+        ImmutableList.Builder<ProductionComponentMonitor> monitorsBuilder = ImmutableList.builder();
+        for (ProductionComponentMonitor.Factory delegate : delegates) {
+          try {
+            ProductionComponentMonitor monitor = delegate.create(component);
+            if (monitor != null) {
+              monitorsBuilder.add(monitor);
+            }
+          } catch (RuntimeException e) {
+            logCreateException(e, delegate, component);
+          }
+        }
+        ImmutableList<ProductionComponentMonitor> monitors = monitorsBuilder.build();
+        if (monitors.isEmpty()) {
+          return noOpProductionComponentMonitor();
+        } else if (monitors.size() == 1) {
+          return new NonThrowingProductionComponentMonitor(Iterables.getOnlyElement(monitors));
+        } else {
+          return new DelegatingProductionComponentMonitor(monitors);
+        }
+      }
+    }
+  }
+
+  /**
+   * A producer monitor that delegates to several monitors, and catches and logs all exceptions
+   * that the delegates throw.
+   */
+  private static final class DelegatingProducerMonitor extends ProducerMonitor {
+    private final ImmutableList<ProducerMonitor> delegates;
+
+    DelegatingProducerMonitor(ImmutableList<ProducerMonitor> delegates) {
+      this.delegates = delegates;
+    }
+
+    @Override
+    public void methodStarting() {
+      for (ProducerMonitor delegate : delegates) {
+        try {
+          delegate.methodStarting();
+        } catch (RuntimeException e) {
+          logProducerMonitorMethodException(e, delegate, "methodStarting");
+        }
+      }
+    }
+
+    @Override
+    public void methodFinished() {
+      for (ProducerMonitor delegate : delegates.reverse()) {
+        try {
+          delegate.methodFinished();
+        } catch (RuntimeException e) {
+          logProducerMonitorMethodException(e, delegate, "methodFinished");
+        }
+      }
+    }
+
+    @Override
+    public void succeeded(Object o) {
+      for (ProducerMonitor delegate : delegates.reverse()) {
+        try {
+          delegate.succeeded(o);
+        } catch (RuntimeException e) {
+          logProducerMonitorArgMethodException(e, delegate, "succeeded", o);
+        }
+      }
+    }
+
+    @Override
+    public void failed(Throwable t) {
+      for (ProducerMonitor delegate : delegates.reverse()) {
+        try {
+          delegate.failed(t);
+        } catch (RuntimeException e) {
+          logProducerMonitorArgMethodException(e, delegate, "failed", t);
+        }
+      }
+    }
+  }
+
+  /** Returns a monitor factory that returns no-op component monitors. */
+  public static ProductionComponentMonitor.Factory noOpProductionComponentMonitorFactory() {
+    return NO_OP_PRODUCTION_COMPONENT_MONITOR_FACTORY;
+  }
+
+  /** Returns a component monitor that returns no-op producer monitors. */
+  public static ProductionComponentMonitor noOpProductionComponentMonitor() {
+    return NO_OP_PRODUCTION_COMPONENT_MONITOR;
+  }
+
+  /** Returns a producer monitor that does nothing. */
+  public static ProducerMonitor noOpProducerMonitor() {
+    return NO_OP_PRODUCER_MONITOR;
+  }
+
+  /** Returns a provider of a no-op component monitor. */
+  public static Provider<ProductionComponentMonitor> noOpProductionComponentMonitorProvider() {
+    return NO_OP_PRODUCTION_COMPONENT_MONITOR_PROVIDER;
+  }
+
+  private static final ProductionComponentMonitor.Factory
+      NO_OP_PRODUCTION_COMPONENT_MONITOR_FACTORY =
+          new ProductionComponentMonitor.Factory() {
+            @Override
+            public ProductionComponentMonitor create(Object component) {
+              return noOpProductionComponentMonitor();
+            }
+          };
+
+  private static final ProductionComponentMonitor NO_OP_PRODUCTION_COMPONENT_MONITOR =
+      new ProductionComponentMonitor() {
+        @Override
+        public ProducerMonitor producerMonitorFor(ProducerToken token) {
+          return noOpProducerMonitor();
+        }
+      };
+
+  private static final ProducerMonitor NO_OP_PRODUCER_MONITOR =
+      new ProducerMonitor() {
+        @Override
+        public <T> void addCallbackTo(ListenableFuture<T> future) {
+          // overridden to avoid adding a do-nothing callback
+        }
+      };
+
+  private static final Provider<ProductionComponentMonitor>
+      NO_OP_PRODUCTION_COMPONENT_MONITOR_PROVIDER =
+          new Provider() {
+            @Override
+            public ProductionComponentMonitor get() {
+              return noOpProductionComponentMonitor();
+            }
+          };
+
+  private static void logCreateException(
+      RuntimeException e, ProductionComponentMonitor.Factory factory, Object component) {
+    logger.log(
+        Level.SEVERE,
+        "RuntimeException while calling ProductionComponentMonitor.Factory.create on factory "
+            + factory
+            + " with component "
+            + component,
+        e);
+  }
+
+  private static void logProducerMonitorForException(
+      RuntimeException e, ProductionComponentMonitor monitor, ProducerToken token) {
+    logger.log(
+        Level.SEVERE,
+        "RuntimeException while calling ProductionComponentMonitor.producerMonitorFor on monitor "
+            + monitor
+            + " with token "
+            + token,
+        e);
+  }
+
+  private static void logProducerMonitorMethodException(
+      RuntimeException e, ProducerMonitor monitor, String method) {
+    logger.log(
+        Level.SEVERE,
+        "RuntimeException while calling ProducerMonitor." + method + " on monitor " + monitor,
+        e);
+  }
+
+  private static void logProducerMonitorArgMethodException(
+      RuntimeException e, ProducerMonitor monitor, String method, Object arg) {
+    logger.log(
+        Level.SEVERE,
+        "RuntimeException while calling ProducerMonitor."
+            + method
+            + " on monitor "
+            + monitor
+            + " with "
+            + arg,
+        e);
+  }
+
+  private Monitors() {}
+}
diff --git a/producers/src/main/java/dagger/producers/monitoring/package-info.java b/producers/src/main/java/dagger/producers/monitoring/package-info.java
new file mode 100644
index 000000000..d10408706
--- /dev/null
+++ b/producers/src/main/java/dagger/producers/monitoring/package-info.java
@@ -0,0 +1,23 @@
+/*
+ * Copyright (C) 2015 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * This package provides hooks for monitoring producers.
+ *
+ * <p>The interfaces in this package are not stable. Do not use these interfaces unless you are
+ * prepared to be broken.
+ */
+package dagger.producers.monitoring;
diff --git a/producers/src/test/java/dagger/producers/ProducedTest.java b/producers/src/test/java/dagger/producers/ProducedTest.java
new file mode 100644
index 000000000..165e7301c
--- /dev/null
+++ b/producers/src/test/java/dagger/producers/ProducedTest.java
@@ -0,0 +1,60 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.producers;
+
+import com.google.common.testing.EqualsTester;
+import java.util.concurrent.CancellationException;
+import java.util.concurrent.ExecutionException;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+
+/**
+ * Tests {@link Produced}.
+ */
+@RunWith(JUnit4.class)
+public class ProducedTest {
+  @Test public void successfulProduced() throws ExecutionException {
+    Object o = new Object();
+    assertThat(Produced.successful(5).get()).isEqualTo(5);
+    assertThat(Produced.successful("monkey").get()).isEqualTo("monkey");
+    assertThat(Produced.successful(o).get()).isSameAs(o);
+  }
+
+  @Test public void failedProduced() {
+    RuntimeException cause = new RuntimeException("monkey");
+    try {
+      Produced.failed(cause).get();
+      fail();
+    } catch (ExecutionException e) {
+      assertThat(e.getCause()).isSameAs(cause);
+    }
+  }
+
+  @Test public void producedEquivalence() {
+    RuntimeException e1 = new RuntimeException("monkey");
+    RuntimeException e2 = new CancellationException();
+    new EqualsTester()
+        .addEqualityGroup(Produced.successful(132435), Produced.successful(132435))
+        .addEqualityGroup(Produced.successful("hi"), Produced.successful("hi"))
+        .addEqualityGroup(Produced.failed(e1), Produced.failed(e1))
+        .addEqualityGroup(Produced.failed(e2), Produced.failed(e2))
+        .testEquals();
+  }
+}
diff --git a/producers/src/test/java/dagger/producers/internal/AbstractProducerTest.java b/producers/src/test/java/dagger/producers/internal/AbstractProducerTest.java
index e307166f5..923ea70a1 100644
--- a/producers/src/test/java/dagger/producers/internal/AbstractProducerTest.java
+++ b/producers/src/test/java/dagger/producers/internal/AbstractProducerTest.java
@@ -17,25 +17,54 @@
 
 import com.google.common.util.concurrent.Futures;
 import com.google.common.util.concurrent.ListenableFuture;
+import com.google.common.util.concurrent.SettableFuture;
 import dagger.producers.Producer;
+import dagger.producers.monitoring.ProducerMonitor;
+import dagger.producers.monitoring.ProducerToken;
+import dagger.producers.monitoring.ProductionComponentMonitor;
+import java.util.concurrent.ExecutionException;
+import javax.inject.Provider;
+import org.mockito.Mock;
+import org.mockito.Mockito;
+import org.mockito.MockitoAnnotations;
+import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.fail;
+import static org.mockito.Mockito.any;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.verifyNoMoreInteractions;
+import static org.mockito.Mockito.when;
 
 /**
  * Tests {@link AbstractProducer}.
  */
 @RunWith(JUnit4.class)
 public class AbstractProducerTest {
-  @Test public void get_nullPointerException() {
-    Producer<Object> producer = new AbstractProducer<Object>() {
-      @Override public ListenableFuture<Object> compute() {
-        return null;
-      }
-    };
+  @Mock private ProductionComponentMonitor componentMonitor;
+  private ProducerMonitor monitor;
+  private Provider<ProductionComponentMonitor> componentMonitorProvider;
+
+  @Before
+  public void initMocks() {
+    MockitoAnnotations.initMocks(this);
+    monitor = Mockito.mock(ProducerMonitor.class, Mockito.CALLS_REAL_METHODS);
+    when(componentMonitor.producerMonitorFor(any(ProducerToken.class))).thenReturn(monitor);
+    componentMonitorProvider =
+        new Provider<ProductionComponentMonitor>() {
+          @Override
+          public ProductionComponentMonitor get() {
+            return componentMonitor;
+          }
+        };
+  }
+
+  @Test
+  public void get_nullPointerException() {
+    Producer<Object> producer = new DelegateProducer<>(componentMonitorProvider, null);
     try {
       producer.get();
       fail();
@@ -44,15 +73,72 @@
   }
 
   @Test public void get() throws Exception {
-    Producer<Integer> producer = new AbstractProducer<Integer>() {
-      int i = 0;
+    Producer<Integer> producer =
+        new AbstractProducer<Integer>(componentMonitorProvider, null) {
+          int i = 0;
 
-      @Override public ListenableFuture<Integer> compute() {
-        return Futures.immediateFuture(i++);
-      }
-    };
+          @Override
+          public ListenableFuture<Integer> compute(ProducerMonitor unusedMonitor) {
+            return Futures.immediateFuture(i++);
+          }
+        };
     assertThat(producer.get().get()).isEqualTo(0);
     assertThat(producer.get().get()).isEqualTo(0);
     assertThat(producer.get().get()).isEqualTo(0);
   }
+
+  @Test
+  public void monitor_success() throws Exception {
+    SettableFuture<Integer> delegateFuture = SettableFuture.create();
+    Producer<Integer> producer = new DelegateProducer<>(componentMonitorProvider, delegateFuture);
+
+    ListenableFuture<Integer> future = producer.get();
+    assertThat(future.isDone()).isFalse();
+    verify(monitor).addCallbackTo(any(ListenableFuture.class));
+    delegateFuture.set(-42);
+    assertThat(future.get()).isEqualTo(-42);
+    verify(monitor).succeeded(-42);
+    verifyNoMoreInteractions(monitor);
+  }
+
+  @Test
+  public void monitor_failure() throws Exception {
+    SettableFuture<Integer> delegateFuture = SettableFuture.create();
+    Producer<Integer> producer = new DelegateProducer<>(componentMonitorProvider, delegateFuture);
+
+    ListenableFuture<Integer> future = producer.get();
+    assertThat(future.isDone()).isFalse();
+    verify(monitor).addCallbackTo(any(ListenableFuture.class));
+    Throwable t = new RuntimeException("monkey");
+    delegateFuture.setException(t);
+    try {
+      future.get();
+      fail();
+    } catch (ExecutionException e) {
+      assertThat(e.getCause()).isSameAs(t);
+    }
+    verify(monitor).failed(t);
+    verifyNoMoreInteractions(monitor);
+  }
+
+  @Test(expected = NullPointerException.class)
+  public void monitor_null() throws Exception {
+    new DelegateProducer<>(null, Futures.immediateFuture(42));
+  }
+
+  static final class DelegateProducer<T> extends AbstractProducer<T> {
+    private final ListenableFuture<T> delegate;
+
+    DelegateProducer(
+        Provider<ProductionComponentMonitor> componentMonitorProvider,
+        ListenableFuture<T> delegate) {
+      super(componentMonitorProvider, null);
+      this.delegate = delegate;
+    }
+
+    @Override
+    public ListenableFuture<T> compute(ProducerMonitor unusedMonitor) {
+      return delegate;
+    }
+  }
 }
diff --git a/producers/src/test/java/dagger/producers/internal/ProducersTest.java b/producers/src/test/java/dagger/producers/internal/ProducersTest.java
index 43564089f..e2707b342 100644
--- a/producers/src/test/java/dagger/producers/internal/ProducersTest.java
+++ b/producers/src/test/java/dagger/producers/internal/ProducersTest.java
@@ -17,12 +17,10 @@
 
 import com.google.common.util.concurrent.Futures;
 import com.google.common.util.concurrent.ListenableFuture;
-import com.google.common.util.concurrent.MoreExecutors;
 import com.google.common.util.concurrent.SettableFuture;
 import dagger.producers.Produced;
 import dagger.producers.Producer;
 import java.util.Set;
-import java.util.concurrent.Callable;
 import java.util.concurrent.CancellationException;
 import java.util.concurrent.ExecutionException;
 import javax.inject.Provider;
@@ -98,16 +96,6 @@
     }
   }
 
-  @Test public void submitToExecutor() throws Exception {
-    ListenableFuture<Integer> future = Producers.submitToExecutor(new Callable<Integer>() {
-      @Override public Integer call() {
-        return 42;
-      }
-    }, MoreExecutors.directExecutor());
-    assertThat(future.isDone()).isTrue();
-    assertThat(future.get()).isEqualTo(42);
-  }
-
   @Test public void producerFromProvider() throws Exception {
     Producer<Integer> producer = Producers.producerFromProvider(new Provider<Integer>() {
       int i = 0;
diff --git a/producers/src/test/java/dagger/producers/internal/SetOfProducedProducerTest.java b/producers/src/test/java/dagger/producers/internal/SetOfProducedProducerTest.java
new file mode 100644
index 000000000..e36ba05a4
--- /dev/null
+++ b/producers/src/test/java/dagger/producers/internal/SetOfProducedProducerTest.java
@@ -0,0 +1,134 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.producers.internal;
+
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Iterables;
+import com.google.common.collect.Sets;
+import dagger.producers.Produced;
+import dagger.producers.Producer;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.Set;
+import java.util.concurrent.ExecutionException;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assertThat;
+
+/**
+ * Tests {@link SetOfProducedProducer}.
+ */
+@RunWith(JUnit4.class)
+public class SetOfProducedProducerTest {
+  @Test
+  public void success() throws Exception {
+    Producer<Set<Produced<Integer>>> producer =
+        SetOfProducedProducer.create(
+            Producers.<Set<Integer>>immediateProducer(ImmutableSet.of(1, 2)),
+            Producers.<Set<Integer>>immediateProducer(ImmutableSet.of(5, 7)));
+    assertThat(producer.get().get())
+        .containsExactly(
+            Produced.successful(1),
+            Produced.successful(2),
+            Produced.successful(5),
+            Produced.successful(7));
+  }
+
+  @Test
+  public void failure() throws Exception {
+    RuntimeException e = new RuntimeException("monkey");
+    Producer<Set<Produced<Integer>>> producer =
+        SetOfProducedProducer.create(
+            Producers.<Set<Integer>>immediateProducer(ImmutableSet.of(1, 2)),
+            Producers.<Set<Integer>>immediateFailedProducer(e));
+    assertThat(producer.get().get())
+        .containsExactly(
+            Produced.successful(1), Produced.successful(2), Produced.<Integer>failed(e));
+  }
+
+  @Test
+  public void delegateSetNpe() throws Exception {
+    Producer<Set<Produced<Integer>>> producer =
+        SetOfProducedProducer.create(Producers.<Set<Integer>>immediateProducer(null));
+    Results<Integer> results = Results.create(producer.get().get());
+    assertThat(results.successes).isEmpty();
+    assertThat(results.failures).hasSize(1);
+    assertThat(Iterables.getOnlyElement(results.failures).getCause())
+        .isInstanceOf(NullPointerException.class);
+  }
+
+  @Test
+  public void oneOfDelegateSetNpe() throws Exception {
+    Producer<Set<Produced<Integer>>> producer =
+        SetOfProducedProducer.create(
+            Producers.<Set<Integer>>immediateProducer(null),
+            Producers.<Set<Integer>>immediateProducer(ImmutableSet.of(7, 3)));
+    Results<Integer> results = Results.create(producer.get().get());
+    assertThat(results.successes).containsExactly(3, 7);
+    assertThat(results.failures).hasSize(1);
+    assertThat(Iterables.getOnlyElement(results.failures).getCause())
+        .isInstanceOf(NullPointerException.class);
+  }
+
+  @Test
+  public void delegateElementNpe() throws Exception {
+    Producer<Set<Produced<Integer>>> producer =
+        SetOfProducedProducer.create(
+            Producers.<Set<Integer>>immediateProducer(Collections.<Integer>singleton(null)));
+    Results<Integer> results = Results.create(producer.get().get());
+    assertThat(results.successes).isEmpty();
+    assertThat(results.failures).hasSize(1);
+    assertThat(Iterables.getOnlyElement(results.failures).getCause())
+        .isInstanceOf(NullPointerException.class);
+  }
+
+  @Test
+  public void oneOfDelegateElementNpe() throws Exception {
+    Producer<Set<Produced<Integer>>> producer =
+        SetOfProducedProducer.create(
+            Producers.<Set<Integer>>immediateProducer(Sets.newHashSet(Arrays.asList(5, 2, null))));
+    Results<Integer> results = Results.create(producer.get().get());
+    assertThat(results.successes).containsExactly(2, 5);
+    assertThat(results.failures).hasSize(1);
+    assertThat(Iterables.getOnlyElement(results.failures).getCause())
+        .isInstanceOf(NullPointerException.class);
+  }
+
+  static final class Results<T> {
+    final ImmutableSet<T> successes;
+    final ImmutableSet<ExecutionException> failures;
+
+    private Results(ImmutableSet<T> successes, ImmutableSet<ExecutionException> failures) {
+      this.successes = successes;
+      this.failures = failures;
+    }
+
+    static <T> Results<T> create(Set<Produced<T>> setOfProduced) {
+      ImmutableSet.Builder<T> successes = ImmutableSet.builder();
+      ImmutableSet.Builder<ExecutionException> failures = ImmutableSet.builder();
+      for (Produced<T> produced : setOfProduced) {
+        try {
+          successes.add(produced.get());
+        } catch (ExecutionException e) {
+          failures.add(e);
+        }
+      }
+      return new Results<T>(successes.build(), failures.build());
+    }
+  }
+}
diff --git a/producers/src/test/java/dagger/producers/internal/SetProducerTest.java b/producers/src/test/java/dagger/producers/internal/SetProducerTest.java
index 1f8ff7c3a..a38830f0a 100644
--- a/producers/src/test/java/dagger/producers/internal/SetProducerTest.java
+++ b/producers/src/test/java/dagger/producers/internal/SetProducerTest.java
@@ -16,7 +16,6 @@
 package dagger.producers.internal;
 
 import com.google.common.collect.ImmutableSet;
-import com.google.common.util.concurrent.Futures;
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.producers.Producer;
 import java.util.Collections;
@@ -35,16 +34,18 @@
 @RunWith(JUnit4.class)
 public class SetProducerTest {
   @Test public void success() throws Exception {
-    Producer<Set<Integer>> producer = SetProducer.create(
-        new ImmediateProducer<Set<Integer>>(ImmutableSet.of(1, 2)),
-        new ImmediateProducer<Set<Integer>>(ImmutableSet.of(5, 7)));
+    Producer<Set<Integer>> producer =
+        SetProducer.create(
+            Producers.<Set<Integer>>immediateProducer(ImmutableSet.of(1, 2)),
+            Producers.<Set<Integer>>immediateProducer(ImmutableSet.of(5, 7)));
     assertThat(producer.get().get()).containsExactly(1, 2, 5, 7);
   }
 
   @Test public void delegateSetNpe() throws Exception {
-    Producer<Set<Integer>> producer = SetProducer.create(
-        new ImmediateProducer<Set<Integer>>(ImmutableSet.of(1, 2)),
-        new ImmediateProducer<Set<Integer>>(null));
+    Producer<Set<Integer>> producer =
+        SetProducer.create(
+            Producers.<Set<Integer>>immediateProducer(ImmutableSet.of(1, 2)),
+            Producers.<Set<Integer>>immediateProducer(null));
     ListenableFuture<Set<Integer>> future = producer.get();
     try {
       future.get();
@@ -55,10 +56,10 @@
   }
 
   @Test public void delegateElementNpe() throws Exception {
-    Producer<Set<Integer>> producer = SetProducer.create(
-        new ImmediateProducer<Set<Integer>>(ImmutableSet.of(1, 2)),
-        new ImmediateProducer<Set<Integer>>(
-            Collections.<Integer>singleton(null)));
+    Producer<Set<Integer>> producer =
+        SetProducer.create(
+            Producers.<Set<Integer>>immediateProducer(ImmutableSet.of(1, 2)),
+            Producers.<Set<Integer>>immediateProducer(Collections.<Integer>singleton(null)));
     ListenableFuture<Set<Integer>> future = producer.get();
     try {
       future.get();
@@ -67,16 +68,4 @@
       assertThat(e.getCause()).isInstanceOf(NullPointerException.class);
     }
   }
-
-  private static final class ImmediateProducer<T> implements Producer<T> {
-    private final T value;
-
-    ImmediateProducer(T value) {
-      this.value = value;
-    }
-
-    @Override public ListenableFuture<T> get() {
-      return Futures.immediateFuture(value);
-    }
-  }
 }
diff --git a/producers/src/test/java/dagger/producers/monitoring/internal/MonitorsTest.java b/producers/src/test/java/dagger/producers/monitoring/internal/MonitorsTest.java
new file mode 100644
index 000000000..e7f42746b
--- /dev/null
+++ b/producers/src/test/java/dagger/producers/monitoring/internal/MonitorsTest.java
@@ -0,0 +1,453 @@
+/*
+ * Copyright (C) 2015 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.producers.monitoring.internal;
+
+import com.google.common.collect.ImmutableList;
+import dagger.producers.monitoring.ProducerMonitor;
+import dagger.producers.monitoring.ProducerToken;
+import dagger.producers.monitoring.ProductionComponentMonitor;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import org.mockito.InOrder;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.doThrow;
+import static org.mockito.Mockito.inOrder;
+import static org.mockito.Mockito.verifyNoMoreInteractions;
+import static org.mockito.Mockito.when;
+
+@RunWith(JUnit4.class)
+public final class MonitorsTest {
+  @Mock private ProductionComponentMonitor.Factory mockProductionComponentMonitorFactory;
+  @Mock private ProductionComponentMonitor mockProductionComponentMonitor;
+  @Mock private ProducerMonitor mockProducerMonitor;
+  @Mock private ProductionComponentMonitor.Factory mockProductionComponentMonitorFactoryA;
+  @Mock private ProductionComponentMonitor.Factory mockProductionComponentMonitorFactoryB;
+  @Mock private ProductionComponentMonitor.Factory mockProductionComponentMonitorFactoryC;
+  @Mock private ProductionComponentMonitor mockProductionComponentMonitorA;
+  @Mock private ProductionComponentMonitor mockProductionComponentMonitorB;
+  @Mock private ProductionComponentMonitor mockProductionComponentMonitorC;
+  @Mock private ProducerMonitor mockProducerMonitorA;
+  @Mock private ProducerMonitor mockProducerMonitorB;
+  @Mock private ProducerMonitor mockProducerMonitorC;
+
+  @Before
+  public void initMocks() {
+    MockitoAnnotations.initMocks(this);
+  }
+
+  @Test
+  public void zeroMonitorsReturnsNoOp() {
+    ProductionComponentMonitor.Factory factory =
+        Monitors.delegatingProductionComponentMonitorFactory(
+            ImmutableList.<ProductionComponentMonitor.Factory>of());
+    assertThat(factory).isSameAs(Monitors.noOpProductionComponentMonitorFactory());
+  }
+
+  @Test
+  public void singleMonitor_nullProductionComponentMonitor() {
+    when(mockProductionComponentMonitorFactory.create(any(Object.class))).thenReturn(null);
+    ProductionComponentMonitor.Factory factory =
+        Monitors.delegatingProductionComponentMonitorFactory(
+            ImmutableList.of(mockProductionComponentMonitorFactory));
+    assertThat(factory.create(new Object())).isSameAs(Monitors.noOpProductionComponentMonitor());
+  }
+
+  @Test
+  public void singleMonitor_throwingProductionComponentMonitorFactory() {
+    doThrow(new RuntimeException("monkey"))
+        .when(mockProductionComponentMonitorFactory)
+        .create(any(Object.class));
+    ProductionComponentMonitor.Factory factory =
+        Monitors.delegatingProductionComponentMonitorFactory(
+            ImmutableList.of(mockProductionComponentMonitorFactory));
+    assertThat(factory.create(new Object())).isSameAs(Monitors.noOpProductionComponentMonitor());
+  }
+
+  @Test
+  public void singleMonitor_nullProducerMonitor() {
+    when(mockProductionComponentMonitorFactory.create(any(Object.class)))
+        .thenReturn(mockProductionComponentMonitor);
+    when(mockProductionComponentMonitor.producerMonitorFor(any(ProducerToken.class)))
+        .thenReturn(null);
+    ProductionComponentMonitor.Factory factory =
+        Monitors.delegatingProductionComponentMonitorFactory(
+            ImmutableList.of(mockProductionComponentMonitorFactory));
+    ProductionComponentMonitor monitor = factory.create(new Object());
+    assertThat(monitor.producerMonitorFor(ProducerToken.create(Object.class)))
+        .isSameAs(Monitors.noOpProducerMonitor());
+  }
+
+  @Test
+  public void singleMonitor_throwingProductionComponentMonitor() {
+    when(mockProductionComponentMonitorFactory.create(any(Object.class)))
+        .thenReturn(mockProductionComponentMonitor);
+    doThrow(new RuntimeException("monkey"))
+        .when(mockProductionComponentMonitor)
+        .producerMonitorFor(any(ProducerToken.class));
+    ProductionComponentMonitor.Factory factory =
+        Monitors.delegatingProductionComponentMonitorFactory(
+            ImmutableList.of(mockProductionComponentMonitorFactory));
+    ProductionComponentMonitor monitor = factory.create(new Object());
+    assertThat(monitor.producerMonitorFor(ProducerToken.create(Object.class)))
+        .isSameAs(Monitors.noOpProducerMonitor());
+  }
+
+  @Test
+  public void singleMonitor_normalProducerMonitorSuccess() {
+    setUpNormalSingleMonitor();
+    ProductionComponentMonitor.Factory factory =
+        Monitors.delegatingProductionComponentMonitorFactory(
+            ImmutableList.of(mockProductionComponentMonitorFactory));
+    ProductionComponentMonitor monitor = factory.create(new Object());
+    ProducerMonitor producerMonitor =
+        monitor.producerMonitorFor(ProducerToken.create(Object.class));
+    Object o = new Object();
+    producerMonitor.methodStarting();
+    producerMonitor.methodFinished();
+    producerMonitor.succeeded(o);
+
+    InOrder order = inOrder(mockProducerMonitor);
+    order.verify(mockProducerMonitor).methodStarting();
+    order.verify(mockProducerMonitor).methodFinished();
+    order.verify(mockProducerMonitor).succeeded(o);
+    verifyNoMoreInteractions(mockProducerMonitor);
+  }
+
+  @Test
+  public void singleMonitor_normalProducerMonitorFailure() {
+    setUpNormalSingleMonitor();
+    ProductionComponentMonitor.Factory factory =
+        Monitors.delegatingProductionComponentMonitorFactory(
+            ImmutableList.of(mockProductionComponentMonitorFactory));
+    ProductionComponentMonitor monitor = factory.create(new Object());
+    ProducerMonitor producerMonitor =
+        monitor.producerMonitorFor(ProducerToken.create(Object.class));
+    Throwable t = new RuntimeException("monkey");
+    producerMonitor.methodStarting();
+    producerMonitor.methodFinished();
+    producerMonitor.failed(t);
+
+    InOrder order = inOrder(mockProducerMonitor);
+    order.verify(mockProducerMonitor).methodStarting();
+    order.verify(mockProducerMonitor).methodFinished();
+    order.verify(mockProducerMonitor).failed(t);
+    verifyNoMoreInteractions(mockProducerMonitor);
+  }
+
+  @Test
+  public void singleMonitor_throwingProducerMonitorSuccess() {
+    setUpNormalSingleMonitor();
+    doThrow(new RuntimeException("monkey")).when(mockProducerMonitor).methodStarting();
+    doThrow(new RuntimeException("monkey")).when(mockProducerMonitor).methodFinished();
+    doThrow(new RuntimeException("monkey")).when(mockProducerMonitor).succeeded(any(Object.class));
+    ProductionComponentMonitor.Factory factory =
+        Monitors.delegatingProductionComponentMonitorFactory(
+            ImmutableList.of(mockProductionComponentMonitorFactory));
+    ProductionComponentMonitor monitor = factory.create(new Object());
+    ProducerMonitor producerMonitor =
+        monitor.producerMonitorFor(ProducerToken.create(Object.class));
+    Object o = new Object();
+    producerMonitor.methodStarting();
+    producerMonitor.methodFinished();
+    producerMonitor.succeeded(o);
+
+    InOrder order = inOrder(mockProducerMonitor);
+    order.verify(mockProducerMonitor).methodStarting();
+    order.verify(mockProducerMonitor).methodFinished();
+    order.verify(mockProducerMonitor).succeeded(o);
+    verifyNoMoreInteractions(mockProducerMonitor);
+  }
+
+  @Test
+  public void singleMonitor_throwingProducerMonitorFailure() {
+    setUpNormalSingleMonitor();
+    doThrow(new RuntimeException("monkey")).when(mockProducerMonitor).methodStarting();
+    doThrow(new RuntimeException("monkey")).when(mockProducerMonitor).methodFinished();
+    doThrow(new RuntimeException("monkey")).when(mockProducerMonitor).failed(any(Throwable.class));
+    ProductionComponentMonitor.Factory factory =
+        Monitors.delegatingProductionComponentMonitorFactory(
+            ImmutableList.of(mockProductionComponentMonitorFactory));
+    ProductionComponentMonitor monitor = factory.create(new Object());
+    ProducerMonitor producerMonitor =
+        monitor.producerMonitorFor(ProducerToken.create(Object.class));
+    Throwable t = new RuntimeException("gorilla");
+    producerMonitor.methodStarting();
+    producerMonitor.methodFinished();
+    producerMonitor.failed(t);
+
+    InOrder order = inOrder(mockProducerMonitor);
+    order.verify(mockProducerMonitor).methodStarting();
+    order.verify(mockProducerMonitor).methodFinished();
+    order.verify(mockProducerMonitor).failed(t);
+    verifyNoMoreInteractions(mockProducerMonitor);
+  }
+
+  @Test
+  public void multipleMonitors_nullProductionComponentMonitors() {
+    when(mockProductionComponentMonitorFactoryA.create(any(Object.class))).thenReturn(null);
+    when(mockProductionComponentMonitorFactoryB.create(any(Object.class))).thenReturn(null);
+    when(mockProductionComponentMonitorFactoryC.create(any(Object.class))).thenReturn(null);
+    ProductionComponentMonitor.Factory factory =
+        Monitors.delegatingProductionComponentMonitorFactory(
+            ImmutableList.of(
+                mockProductionComponentMonitorFactoryA,
+                mockProductionComponentMonitorFactoryB,
+                mockProductionComponentMonitorFactoryC));
+    assertThat(factory.create(new Object())).isSameAs(Monitors.noOpProductionComponentMonitor());
+  }
+
+  @Test
+  public void multipleMonitors_throwingProductionComponentMonitorFactories() {
+    doThrow(new RuntimeException("monkey"))
+        .when(mockProductionComponentMonitorFactoryA)
+        .create(any(Object.class));
+    doThrow(new RuntimeException("monkey"))
+        .when(mockProductionComponentMonitorFactoryB)
+        .create(any(Object.class));
+    doThrow(new RuntimeException("monkey"))
+        .when(mockProductionComponentMonitorFactoryC)
+        .create(any(Object.class));
+    ProductionComponentMonitor.Factory factory =
+        Monitors.delegatingProductionComponentMonitorFactory(
+            ImmutableList.of(
+                mockProductionComponentMonitorFactoryA,
+                mockProductionComponentMonitorFactoryB,
+                mockProductionComponentMonitorFactoryC));
+    assertThat(factory.create(new Object())).isSameAs(Monitors.noOpProductionComponentMonitor());
+  }
+
+  @Test
+  public void multipleMonitors_someNullProductionComponentMonitors() {
+    when(mockProductionComponentMonitorFactoryA.create(any(Object.class)))
+        .thenReturn(mockProductionComponentMonitorA);
+    when(mockProductionComponentMonitorFactoryB.create(any(Object.class))).thenReturn(null);
+    when(mockProductionComponentMonitorFactoryC.create(any(Object.class))).thenReturn(null);
+    when(mockProductionComponentMonitorA.producerMonitorFor(any(ProducerToken.class)))
+        .thenReturn(mockProducerMonitorA);
+    ProductionComponentMonitor.Factory factory =
+        Monitors.delegatingProductionComponentMonitorFactory(
+            ImmutableList.of(
+                mockProductionComponentMonitorFactoryA,
+                mockProductionComponentMonitorFactoryB,
+                mockProductionComponentMonitorFactoryC));
+    ProductionComponentMonitor monitor = factory.create(new Object());
+    ProducerMonitor producerMonitor =
+        monitor.producerMonitorFor(ProducerToken.create(Object.class));
+
+    Object o = new Object();
+    producerMonitor.methodStarting();
+    producerMonitor.methodFinished();
+    producerMonitor.succeeded(o);
+
+    InOrder order = inOrder(mockProducerMonitorA);
+    order.verify(mockProducerMonitorA).methodStarting();
+    order.verify(mockProducerMonitorA).methodFinished();
+    order.verify(mockProducerMonitorA).succeeded(o);
+    verifyNoMoreInteractions(mockProducerMonitorA);
+  }
+
+  @Test
+  public void multipleMonitors_someThrowingProductionComponentMonitorFactories() {
+    when(mockProductionComponentMonitorFactoryA.create(any(Object.class)))
+        .thenReturn(mockProductionComponentMonitorA);
+    doThrow(new RuntimeException("monkey"))
+        .when(mockProductionComponentMonitorFactoryB)
+        .create(any(Object.class));
+    doThrow(new RuntimeException("monkey"))
+        .when(mockProductionComponentMonitorFactoryC)
+        .create(any(Object.class));
+    when(mockProductionComponentMonitorA.producerMonitorFor(any(ProducerToken.class)))
+        .thenReturn(mockProducerMonitorA);
+    ProductionComponentMonitor.Factory factory =
+        Monitors.delegatingProductionComponentMonitorFactory(
+            ImmutableList.of(
+                mockProductionComponentMonitorFactoryA,
+                mockProductionComponentMonitorFactoryB,
+                mockProductionComponentMonitorFactoryC));
+    ProductionComponentMonitor monitor = factory.create(new Object());
+    ProducerMonitor producerMonitor =
+        monitor.producerMonitorFor(ProducerToken.create(Object.class));
+
+    Object o = new Object();
+    producerMonitor.methodStarting();
+    producerMonitor.methodFinished();
+    producerMonitor.succeeded(o);
+
+    InOrder order = inOrder(mockProducerMonitorA);
+    order.verify(mockProducerMonitorA).methodStarting();
+    order.verify(mockProducerMonitorA).methodFinished();
+    order.verify(mockProducerMonitorA).succeeded(o);
+    verifyNoMoreInteractions(mockProducerMonitorA);
+  }
+
+  @Test
+  public void multipleMonitors_normalProductionComponentMonitorSuccess() {
+    setUpNormalMultipleMonitors();
+    ProductionComponentMonitor.Factory factory =
+        Monitors.delegatingProductionComponentMonitorFactory(
+            ImmutableList.of(
+                mockProductionComponentMonitorFactoryA,
+                mockProductionComponentMonitorFactoryB,
+                mockProductionComponentMonitorFactoryC));
+    ProductionComponentMonitor monitor = factory.create(new Object());
+    ProducerMonitor producerMonitor =
+        monitor.producerMonitorFor(ProducerToken.create(Object.class));
+
+    Object o = new Object();
+    producerMonitor.methodStarting();
+    producerMonitor.methodFinished();
+    producerMonitor.succeeded(o);
+
+    InOrder order = inOrder(mockProducerMonitorA, mockProducerMonitorB, mockProducerMonitorC);
+    order.verify(mockProducerMonitorA).methodStarting();
+    order.verify(mockProducerMonitorB).methodStarting();
+    order.verify(mockProducerMonitorC).methodStarting();
+    order.verify(mockProducerMonitorC).methodFinished();
+    order.verify(mockProducerMonitorB).methodFinished();
+    order.verify(mockProducerMonitorA).methodFinished();
+    order.verify(mockProducerMonitorC).succeeded(o);
+    order.verify(mockProducerMonitorB).succeeded(o);
+    order.verify(mockProducerMonitorA).succeeded(o);
+    verifyNoMoreInteractions(mockProducerMonitorA, mockProducerMonitorB, mockProducerMonitorC);
+  }
+
+  @Test
+  public void multipleMonitors_normalProductionComponentMonitorFailure() {
+    setUpNormalMultipleMonitors();
+    ProductionComponentMonitor.Factory factory =
+        Monitors.delegatingProductionComponentMonitorFactory(
+            ImmutableList.of(
+                mockProductionComponentMonitorFactoryA,
+                mockProductionComponentMonitorFactoryB,
+                mockProductionComponentMonitorFactoryC));
+    ProductionComponentMonitor monitor = factory.create(new Object());
+    ProducerMonitor producerMonitor =
+        monitor.producerMonitorFor(ProducerToken.create(Object.class));
+
+    Throwable t = new RuntimeException("chimpanzee");
+    producerMonitor.methodStarting();
+    producerMonitor.methodFinished();
+    producerMonitor.failed(t);
+
+    InOrder order = inOrder(mockProducerMonitorA, mockProducerMonitorB, mockProducerMonitorC);
+    order.verify(mockProducerMonitorA).methodStarting();
+    order.verify(mockProducerMonitorB).methodStarting();
+    order.verify(mockProducerMonitorC).methodStarting();
+    order.verify(mockProducerMonitorC).methodFinished();
+    order.verify(mockProducerMonitorB).methodFinished();
+    order.verify(mockProducerMonitorA).methodFinished();
+    order.verify(mockProducerMonitorC).failed(t);
+    order.verify(mockProducerMonitorB).failed(t);
+    order.verify(mockProducerMonitorA).failed(t);
+    verifyNoMoreInteractions(mockProducerMonitorA, mockProducerMonitorB, mockProducerMonitorC);
+  }
+
+  @Test
+  public void multipleMonitors_someThrowingProducerMonitorsSuccess() {
+    setUpNormalMultipleMonitors();
+    doThrow(new RuntimeException("monkey")).when(mockProducerMonitorA).methodStarting();
+    doThrow(new RuntimeException("monkey")).when(mockProducerMonitorB).methodFinished();
+    doThrow(new RuntimeException("monkey")).when(mockProducerMonitorC).succeeded(any(Object.class));
+    ProductionComponentMonitor.Factory factory =
+        Monitors.delegatingProductionComponentMonitorFactory(
+            ImmutableList.of(
+                mockProductionComponentMonitorFactoryA,
+                mockProductionComponentMonitorFactoryB,
+                mockProductionComponentMonitorFactoryC));
+    ProductionComponentMonitor monitor = factory.create(new Object());
+    ProducerMonitor producerMonitor =
+        monitor.producerMonitorFor(ProducerToken.create(Object.class));
+
+    Object o = new Object();
+    producerMonitor.methodStarting();
+    producerMonitor.methodFinished();
+    producerMonitor.succeeded(o);
+
+    InOrder order = inOrder(mockProducerMonitorA, mockProducerMonitorB, mockProducerMonitorC);
+    order.verify(mockProducerMonitorA).methodStarting();
+    order.verify(mockProducerMonitorB).methodStarting();
+    order.verify(mockProducerMonitorC).methodStarting();
+    order.verify(mockProducerMonitorC).methodFinished();
+    order.verify(mockProducerMonitorB).methodFinished();
+    order.verify(mockProducerMonitorA).methodFinished();
+    order.verify(mockProducerMonitorC).succeeded(o);
+    order.verify(mockProducerMonitorB).succeeded(o);
+    order.verify(mockProducerMonitorA).succeeded(o);
+    verifyNoMoreInteractions(mockProducerMonitorA, mockProducerMonitorB, mockProducerMonitorC);
+  }
+
+  @Test
+  public void multipleMonitors_someThrowingProducerMonitorsFailure() {
+    setUpNormalMultipleMonitors();
+    doThrow(new RuntimeException("monkey")).when(mockProducerMonitorA).methodStarting();
+    doThrow(new RuntimeException("monkey")).when(mockProducerMonitorB).methodFinished();
+    doThrow(new RuntimeException("monkey")).when(mockProducerMonitorC).failed(any(Throwable.class));
+    ProductionComponentMonitor.Factory factory =
+        Monitors.delegatingProductionComponentMonitorFactory(
+            ImmutableList.of(
+                mockProductionComponentMonitorFactoryA,
+                mockProductionComponentMonitorFactoryB,
+                mockProductionComponentMonitorFactoryC));
+    ProductionComponentMonitor monitor = factory.create(new Object());
+    ProducerMonitor producerMonitor =
+        monitor.producerMonitorFor(ProducerToken.create(Object.class));
+
+    Throwable t = new RuntimeException("chimpanzee");
+    producerMonitor.methodStarting();
+    producerMonitor.methodFinished();
+    producerMonitor.failed(t);
+
+    InOrder order = inOrder(mockProducerMonitorA, mockProducerMonitorB, mockProducerMonitorC);
+    order.verify(mockProducerMonitorA).methodStarting();
+    order.verify(mockProducerMonitorB).methodStarting();
+    order.verify(mockProducerMonitorC).methodStarting();
+    order.verify(mockProducerMonitorC).methodFinished();
+    order.verify(mockProducerMonitorB).methodFinished();
+    order.verify(mockProducerMonitorA).methodFinished();
+    order.verify(mockProducerMonitorC).failed(t);
+    order.verify(mockProducerMonitorB).failed(t);
+    order.verify(mockProducerMonitorA).failed(t);
+    verifyNoMoreInteractions(mockProducerMonitorA, mockProducerMonitorB, mockProducerMonitorC);
+  }
+
+  private void setUpNormalSingleMonitor() {
+    when(mockProductionComponentMonitorFactory.create(any(Object.class)))
+        .thenReturn(mockProductionComponentMonitor);
+    when(mockProductionComponentMonitor.producerMonitorFor(any(ProducerToken.class)))
+        .thenReturn(mockProducerMonitor);
+  }
+
+  private void setUpNormalMultipleMonitors() {
+    when(mockProductionComponentMonitorFactoryA.create(any(Object.class)))
+        .thenReturn(mockProductionComponentMonitorA);
+    when(mockProductionComponentMonitorFactoryB.create(any(Object.class)))
+        .thenReturn(mockProductionComponentMonitorB);
+    when(mockProductionComponentMonitorFactoryC.create(any(Object.class)))
+        .thenReturn(mockProductionComponentMonitorC);
+    when(mockProductionComponentMonitorA.producerMonitorFor(any(ProducerToken.class)))
+        .thenReturn(mockProducerMonitorA);
+    when(mockProductionComponentMonitorB.producerMonitorFor(any(ProducerToken.class)))
+        .thenReturn(mockProducerMonitorB);
+    when(mockProductionComponentMonitorC.producerMonitorFor(any(ProducerToken.class)))
+        .thenReturn(mockProducerMonitorC);
+  }
+}
