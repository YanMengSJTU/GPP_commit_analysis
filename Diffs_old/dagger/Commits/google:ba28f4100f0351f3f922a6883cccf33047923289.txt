diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
index f170f3988..c0d1d45aa 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
@@ -33,6 +33,7 @@
 import dagger.Component;
 import dagger.Subcomponent;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
+import dagger.producers.Producer;
 import dagger.producers.ProductionComponent;
 import java.util.ArrayDeque;
 import java.util.Collection;
@@ -45,6 +46,7 @@
 import java.util.concurrent.Callable;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.Executor;
+import javax.inject.Inject;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
@@ -145,20 +147,17 @@
     private final Elements elements;
     private final InjectBindingRegistry injectBindingRegistry;
     private final Key.Factory keyFactory;
-    private final DependencyRequest.Factory dependencyRequestFactory;
     private final ProvisionBinding.Factory provisionBindingFactory;
     private final ProductionBinding.Factory productionBindingFactory;
 
     Factory(Elements elements,
         InjectBindingRegistry injectBindingRegistry,
         Key.Factory keyFactory,
-        DependencyRequest.Factory dependencyRequestFactory,
         ProvisionBinding.Factory provisionBindingFactory,
         ProductionBinding.Factory productionBindingFactory) {
       this.elements = elements;
       this.injectBindingRegistry = injectBindingRegistry;
       this.keyFactory = keyFactory;
-      this.dependencyRequestFactory = dependencyRequestFactory;
       this.provisionBindingFactory = provisionBindingFactory;
       this.productionBindingFactory = productionBindingFactory;
     }
@@ -295,9 +294,14 @@ private BindingGraph create(
       }
 
       /**
-       *  Looks up the bindings associated with a given dependency request and returns them.  In the
-       *  event that the binding is owned by a parent component it will trigger resolution in that
-       *  component's resolver but will return an {@link Optional#absent} value.
+       * Looks up the bindings associated with a given dependency request and returns them.
+       *
+       * <p>Requests for {@code Map<K, V>} for which there are only bindings for
+       * {@code Map<K, Provider<V>>} will resolve to a single implicit binding for the latter map
+       * (and similarly for {@link Producer}s).
+       *
+       * <p>If there are no explicit bindings for a contribution, looks for implicit
+       * {@link Inject @Inject}-annotated constructor types.
        */
       ResolvedBindings lookUpBindings(DependencyRequest request) {
         BindingKey bindingKey = request.bindingKey();
@@ -325,8 +329,8 @@ ResolvedBindings lookUpBindings(DependencyRequest request) {
 
             if (!explicitProvisionBindingsForKey.isEmpty()
                 || !explicitProductionBindingsForKey.isEmpty()) {
-              // we have some explicit binding for this key, so we collect all explicit implicit map
-              // bindings that might conflict with this and let the validator sort it out
+              /* If there are any explicit bindings for this key, then combine those with any
+               * conflicting Map<K, Provider<V>> bindings and let the validator fail. */
               ImmutableSet.Builder<ContributionBinding> ownedBindings = ImmutableSet.builder();
               ImmutableSetMultimap.Builder<ComponentDescriptor, ContributionBinding>
                   inheritedBindings = ImmutableSetMultimap.builder();
@@ -348,41 +352,38 @@ ResolvedBindings lookUpBindings(DependencyRequest request) {
                       .addAll(explicitMapProductionBindings)
                       .build(),
                   inheritedBindings.build());
+            } else if (!explicitMapProductionBindings.isEmpty()) {
+              /* If this binding is for Map<K, V> and there are no explicit Map<K, V> bindings but
+               * some explicit Map<K, Producer<V>> bindings, then this binding must have only the
+               * implicit dependency on Map<K, Producer<V>>. */
+              return ResolvedBindings.create(
+                  bindingKey,
+                  componentDescriptor,
+                  productionBindingFactory.implicitMapOfProducerBinding(request));
+            } else if (!explicitMapProvisionBindings.isEmpty()) {
+              /* If this binding is for Map<K, V> and there are no explicit Map<K, V> bindings but
+               * some explicit Map<K, Provider<V>> bindings, then this binding must have only the
+               * implicit dependency on Map<K, Provider<V>>. */
+              return ResolvedBindings.create(
+                  bindingKey,
+                  componentDescriptor,
+                  provisionBindingFactory.implicitMapOfProviderBinding(request));
             } else {
-              if (!explicitMapProductionBindings.isEmpty()) {
-                // if we have any explicit Map<K, Producer<V>> bindings, then this Map<K, V> binding
-                // must be considered an implicit ProductionBinding
-                DependencyRequest implicitRequest =
-                    dependencyRequestFactory.forImplicitMapBinding(request, mapProducerKey.get());
+              /* If there are no explicit bindings at all, look for an implicit @Inject-constructed
+               * binding. */
+              Optional<ProvisionBinding> provisionBinding =
+                  injectBindingRegistry.getOrFindProvisionBinding(bindingKey.key());
+              if (provisionBinding.isPresent()
+                  && isResolvedInParent(request, provisionBinding.get())
+                  && !shouldOwnParentBinding(request, provisionBinding.get())) {
                 return ResolvedBindings.create(
                     bindingKey,
                     componentDescriptor,
-                    productionBindingFactory.forImplicitMapBinding(request, implicitRequest));
-              } else if (!explicitMapProvisionBindings.isEmpty()) {
-                // if there are Map<K, Provider<V>> bindings, then it'll be an implicit
-                // ProvisionBinding
-                DependencyRequest implicitRequest =
-                    dependencyRequestFactory.forImplicitMapBinding(request, mapProviderKey.get());
-                return ResolvedBindings.create(
-                    bindingKey,
-                    componentDescriptor,
-                    provisionBindingFactory.forImplicitMapBinding(request, implicitRequest));
+                    ImmutableSet.<Binding>of(),
+                    ImmutableSetMultimap.of(
+                        getOwningResolver(provisionBinding.get()).get().componentDescriptor,
+                        provisionBinding.get()));
               } else {
-                // no explicit binding, look it up.
-                Optional<ProvisionBinding> provisionBinding =
-                    injectBindingRegistry.getOrFindProvisionBinding(bindingKey.key());
-                if (provisionBinding.isPresent()) {
-                  if (isResolvedInParent(request, provisionBinding.get())
-                      && !shouldOwnParentBinding(request, provisionBinding.get())) {
-                    return ResolvedBindings.create(
-                        bindingKey,
-                        componentDescriptor,
-                        ImmutableSet.<Binding>of(),
-                        ImmutableSetMultimap.of(
-                            getOwningResolver(provisionBinding.get()).get().componentDescriptor,
-                            provisionBinding.get()));
-                  }
-                }
                 return ResolvedBindings.create(
                     bindingKey,
                     componentDescriptor,
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
index 1e96a534a..e5bb1baba 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -156,7 +156,6 @@ public SourceVersion getSupportedSourceVersion() {
         elements,
         injectBindingRegistry,
         keyFactory,
-        dependencyRequestFactory,
         provisionBindingFactory,
         productionBindingFactory);
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
index 5af9a82c5..a100a40dc 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
@@ -149,15 +149,21 @@ BindingKey bindingKey() {
     }
 
     /**
-     * Creates a DependencyRequest for implictMapBinding, this request's key will be
-     * {@code Map<K, Provider<V>>}, this DependencyRequest is depended by the DependencyRequest
-     * whose key is {@code Map<K, V>}
+     * Creates a implicit {@link DependencyRequest} for {@code mapOfFactoryKey}, which will be used
+     * to satisfy the {@code mapOfValueRequest}.
+     * 
+     * @param mapOfValueRequest a request for {@code Map<K, V>}
+     * @param mapOfFactoryKey a key equivalent to {@code mapOfValueRequest}'s key, whose type is
+     *     {@code Map<K, Provider<V>>} or {@code Map<K, Producer<V>>}
      */
-    DependencyRequest forImplicitMapBinding(DependencyRequest delegatingRequest, Key delegateKey) {
-      checkNotNull(delegatingRequest);
-      return new AutoValue_DependencyRequest(Kind.PROVIDER, delegateKey,
-          delegatingRequest.requestElement(),
-          delegatingRequest.enclosingType(),
+    DependencyRequest forImplicitMapBinding(
+        DependencyRequest mapOfValueRequest, Key mapOfFactoryKey) {
+      checkNotNull(mapOfValueRequest);
+      return new AutoValue_DependencyRequest(
+          Kind.PROVIDER,
+          mapOfFactoryKey,
+          mapOfValueRequest.requestElement(),
+          mapOfValueRequest.enclosingType(),
           false /* doesn't allow null */);
     }
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
index 38d45e6a2..f57eec4ab 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
@@ -149,16 +149,20 @@ ProductionBinding forProducesMethod(
           ImmutableList.copyOf(producesMethod.getThrownTypes()));
     }
 
-    ProductionBinding forImplicitMapBinding(DependencyRequest explicitRequest,
-        DependencyRequest implicitRequest) {
-      checkNotNull(explicitRequest);
-      checkNotNull(implicitRequest);
-      ImmutableSet<DependencyRequest> dependencies = ImmutableSet.of(implicitRequest);
+    ProductionBinding implicitMapOfProducerBinding(DependencyRequest mapOfValueRequest) {
+      checkNotNull(mapOfValueRequest);
+      Optional<Key> implicitMapOfProducerKey =
+          keyFactory.implicitMapProducerKeyFrom(mapOfValueRequest.key());
+      checkArgument(
+          implicitMapOfProducerKey.isPresent(), "%s is not for a Map<K, V>", mapOfValueRequest);
+      DependencyRequest implicitMapOfProducerRequest =
+          dependencyRequestFactory.forImplicitMapBinding(
+              mapOfValueRequest, implicitMapOfProducerKey.get());
       return new AutoValue_ProductionBinding(
-          explicitRequest.key(),
-          implicitRequest.requestElement(),
-          dependencies,
-          findBindingPackage(explicitRequest.key()),
+          mapOfValueRequest.key(),
+          implicitMapOfProducerRequest.requestElement(),
+          ImmutableSet.of(implicitMapOfProducerRequest),
+          findBindingPackage(mapOfValueRequest.key()),
           false,
           Optional.<DeclaredType>absent(),
           Optional.<TypeElement>absent(),
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
index 8a3c203c8..f55613f20 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
@@ -43,6 +43,7 @@
 import static dagger.internal.codegen.InjectionAnnotations.getQualifier;
 import static dagger.internal.codegen.ProvisionBinding.Kind.INJECTION;
 import static dagger.internal.codegen.ProvisionBinding.Kind.PROVISION;
+import static dagger.internal.codegen.Scope.scopeOf;
 import static javax.lang.model.element.ElementKind.CONSTRUCTOR;
 import static javax.lang.model.element.ElementKind.FIELD;
 import static javax.lang.model.element.ElementKind.METHOD;
@@ -265,23 +266,28 @@ ProvisionBinding forProvidesMethod(ExecutableElement providesMethod, TypeMirror
           Optional.<DependencyRequest>absent());
     }
 
-    ProvisionBinding forImplicitMapBinding(DependencyRequest explicitRequest,
-        DependencyRequest implicitRequest) {
-      checkNotNull(explicitRequest);
-      checkNotNull(implicitRequest);
-      ImmutableSet<DependencyRequest> dependencies = ImmutableSet.of(implicitRequest);
-      Scope scope = Scope.scopeOf(implicitRequest.requestElement());
+    ProvisionBinding implicitMapOfProviderBinding(DependencyRequest mapOfValueRequest) {
+      checkNotNull(mapOfValueRequest);
+      Optional<Key> implicitMapOfProviderKey =
+          keyFactory.implicitMapProviderKeyFrom(mapOfValueRequest.key());
+      checkArgument(
+          implicitMapOfProviderKey.isPresent(),
+          "%s is not a request for Map<K, V>",
+          mapOfValueRequest);
+      DependencyRequest implicitMapOfProviderRequest =
+          dependencyRequestFactory.forImplicitMapBinding(
+              mapOfValueRequest, implicitMapOfProviderKey.get());
       return new AutoValue_ProvisionBinding(
-          explicitRequest.key(),
-          implicitRequest.requestElement(),
-          dependencies,
-          findBindingPackage(explicitRequest.key()),
+          mapOfValueRequest.key(),
+          implicitMapOfProviderRequest.requestElement(),
+          ImmutableSet.of(implicitMapOfProviderRequest),
+          findBindingPackage(mapOfValueRequest.key()),
           false /* no non-default parameter types */,
           Optional.<DeclaredType>absent(),
           Optional.<TypeElement>absent(),
           Kind.SYNTHETIC_PROVISON,
           Provides.Type.MAP,
-          scope,
+          scopeOf(implicitMapOfProviderRequest.requestElement()),
           Optional.<DependencyRequest>absent());
     }
 
