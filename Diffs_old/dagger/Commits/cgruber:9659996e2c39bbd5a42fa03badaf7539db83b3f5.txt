diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java b/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
index e758cb73e..664d2db57 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
@@ -28,14 +28,12 @@
 import dagger.internal.codegen.writer.ClassName;
 import java.util.ArrayDeque;
 import java.util.Deque;
-import java.util.List;
 import java.util.Map;
 import java.util.Set;
 import javax.annotation.processing.Messager;
 import javax.inject.Inject;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
-import javax.lang.model.util.ElementFilter;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 import javax.tools.Diagnostic.Kind;
@@ -47,6 +45,7 @@
 import static com.google.common.base.Preconditions.checkState;
 import static dagger.internal.codegen.MembersInjectionBinding.Strategy.INJECT_MEMBERS;
 import static dagger.internal.codegen.SourceFiles.generatedClassNameForBinding;
+import static javax.lang.model.util.ElementFilter.constructorsIn;
 
 /**
  * Maintains the collection of provision bindings from {@link Inject} constructors and members
@@ -87,19 +86,19 @@ B getBinding(Key key) {
     }
 
     /** Caches the binding and generates it if it needs generation. */
-    void tryRegisterBinding(B binding, ClassName factoryName, boolean explicit) {
+    void tryRegisterBinding(B binding, ClassName factoryName, boolean warnIfNotAlreadyGenerated) {
       tryToCacheBinding(binding);
-      tryToGenerateBinding(binding, factoryName, explicit);
+      tryToGenerateBinding(binding, factoryName, warnIfNotAlreadyGenerated);
     }
 
     /**
      * Tries to generate a binding, not generating if it already is generated. For resolved
      * bindings, this will try to generate the unresolved version of the binding.
      */
-    void tryToGenerateBinding(B binding, ClassName factoryName, boolean explicit) {
+    void tryToGenerateBinding(B binding, ClassName factoryName, boolean warnIfNotAlreadyGenerated) {
       if (shouldGenerateBinding(binding, factoryName)) {
         bindingsRequiringGeneration.offer(binding);
-        if (!explicit) {
+        if (warnIfNotAlreadyGenerated) {
           messager.printMessage(Kind.NOTE, String.format(
               "Generating a MembersInjector or Factory for %s. "
                     + "Prefer to run the dagger processor over that class instead.",
@@ -160,38 +159,56 @@ void generateSourcesForRequiredBindings(FactoryGenerator factoryGenerator,
   }
 
   ProvisionBinding registerBinding(ProvisionBinding binding) {
-    return registerBinding(binding, true);
+    return registerBinding(binding, false);
   }
 
   MembersInjectionBinding registerBinding(MembersInjectionBinding binding) {
-    return registerBinding(binding, true);
+    return registerBinding(binding, false);
   }
 
   /**
-   * Registers the binding for generation & later lookup. If the binding is resolved, we also
+   * Registers the binding for generation and later lookup. If the binding is resolved, we also
    * attempt to register an unresolved version of it.
    */
-  private ProvisionBinding registerBinding(ProvisionBinding binding, boolean explicit) {
+  private ProvisionBinding registerBinding(
+      ProvisionBinding binding, boolean warnIfNotAlreadyGenerated) {
     ClassName factoryName = generatedClassNameForBinding(binding);
-    provisionBindings.tryRegisterBinding(binding, factoryName, explicit);
+    provisionBindings.tryRegisterBinding(binding, factoryName, warnIfNotAlreadyGenerated);
     if (binding.hasNonDefaultTypeParameters()) {
-      provisionBindings.tryToGenerateBinding(provisionBindingFactory.unresolve(binding),
-          factoryName, explicit);
+      provisionBindings.tryToGenerateBinding(
+          provisionBindingFactory.unresolve(binding), factoryName, warnIfNotAlreadyGenerated);
     }
     return binding;
   }
 
   /**
-   * Registers the binding for generation & later lookup. If the binding is resolved, we also
+   * Registers the binding for generation and later lookup. If the binding is resolved, we also
    * attempt to register an unresolved version of it.
    */
   private MembersInjectionBinding registerBinding(
-      MembersInjectionBinding binding, boolean explicit) {
+      MembersInjectionBinding binding, boolean warnIfNotAlreadyGenerated) {
+    /*
+     * We generate MembersInjector classes for types with @Inject constructors only if they have any
+     * injection sites.
+     *
+     * We generate MembersInjector classes for types without @Inject constructors only if they have
+     * local (non-inherited) injection sites.
+     *
+     * Warn only when registering bindings post-hoc for those types.
+     */
+    warnIfNotAlreadyGenerated =
+        warnIfNotAlreadyGenerated
+            && (!injectedConstructors(binding.bindingElement()).isEmpty()
+                ? !binding.injectionSites().isEmpty()
+                : binding.hasLocalInjectionSites());
     ClassName membersInjectorName = generatedClassNameForBinding(binding);
-    membersInjectionBindings.tryRegisterBinding(binding, membersInjectorName, explicit);
+    membersInjectionBindings.tryRegisterBinding(
+        binding, membersInjectorName, warnIfNotAlreadyGenerated);
     if (binding.hasNonDefaultTypeParameters()) {
       membersInjectionBindings.tryToGenerateBinding(
-          membersInjectionBindingFactory.unresolve(binding), membersInjectorName, explicit);
+          membersInjectionBindingFactory.unresolve(binding),
+          membersInjectorName,
+          warnIfNotAlreadyGenerated);
     }
     return binding;
   }
@@ -208,28 +225,34 @@ private MembersInjectionBinding registerBinding(
 
     // ok, let's see if we can find an @Inject constructor
     TypeElement element = MoreElements.asType(types.asElement(key.type()));
-    List<ExecutableElement> constructors =
-        ElementFilter.constructorsIn(element.getEnclosedElements());
-    ImmutableSet<ExecutableElement> injectConstructors = FluentIterable.from(constructors)
-        .filter(new Predicate<ExecutableElement>() {
-          @Override public boolean apply(ExecutableElement input) {
-            return isAnnotationPresent(input, Inject.class);
-          }
-        }).toSet();
+    ImmutableSet<ExecutableElement> injectConstructors = injectedConstructors(element);
     switch (injectConstructors.size()) {
       case 0:
         // No constructor found.
         return Optional.absent();
       case 1:
-        ProvisionBinding constructorBinding = provisionBindingFactory.forInjectConstructor(
-            Iterables.getOnlyElement(injectConstructors), Optional.of(key.type()));
-        return Optional.of(registerBinding(constructorBinding, false));
+        ProvisionBinding constructorBinding =
+            provisionBindingFactory.forInjectConstructor(
+                Iterables.getOnlyElement(injectConstructors), Optional.of(key.type()));
+        return Optional.of(registerBinding(constructorBinding, true));
       default:
         throw new IllegalStateException("Found multiple @Inject constructors: "
             + injectConstructors);
     }
   }
 
+  private ImmutableSet<ExecutableElement> injectedConstructors(TypeElement element) {
+    return FluentIterable.from(constructorsIn(element.getEnclosedElements()))
+        .filter(
+            new Predicate<ExecutableElement>() {
+              @Override
+              public boolean apply(ExecutableElement constructor) {
+                return isAnnotationPresent(constructor, Inject.class);
+              }
+            })
+        .toSet();
+  }
+
   /**
    * Returns a {@link MembersInjectionBinding} for {@code key}. If none has been registered yet,
    * registers one, along with all necessary members injection bindings for superclasses.
@@ -245,7 +268,7 @@ MembersInjectionBinding getOrFindMembersInjectionBinding(Key key) {
     MembersInjectionBinding newBinding =
         membersInjectionBindingFactory.forInjectedType(
             asDeclared(key.type()), Optional.of(key.type()));
-    registerBinding(newBinding, false);
+    registerBinding(newBinding, true);
     if (newBinding.parentKey().isPresent()
         && newBinding.injectionStrategy().equals(INJECT_MEMBERS)) {
       getOrFindMembersInjectionBinding(newBinding.parentKey().get());
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
index 7deb9023c..3346883b9 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
@@ -20,6 +20,7 @@
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Function;
 import com.google.common.base.Optional;
+import com.google.common.base.Predicate;
 import com.google.common.collect.ComparisonChain;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableSet;
@@ -85,6 +86,20 @@ Strategy injectionStrategy() {
     return Binding.Type.MEMBERS_INJECTION;
   }
 
+  /**
+   * Returns {@code true} if any of this binding's injection sites are directly on the bound type.
+   */
+  boolean hasLocalInjectionSites() {
+    return FluentIterable.from(injectionSites())
+        .anyMatch(
+            new Predicate<InjectionSite>() {
+              @Override
+              public boolean apply(InjectionSite injectionSite) {
+                return injectionSite.element().getEnclosingElement().equals(bindingElement());
+              }
+            });
+  }
+
   @AutoValue
   abstract static class InjectionSite {
     enum Kind {
diff --git a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
index 28e3b4570..99e86148b 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
@@ -15,17 +15,27 @@
  */
 package dagger.internal.codegen;
 
+import com.google.auto.common.MoreElements;
 import com.google.common.base.Joiner;
+import com.google.common.base.Predicate;
+import com.google.common.base.Predicates;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Sets;
 import com.google.testing.compile.JavaFileObjects;
+import dagger.MembersInjector;
 import dagger.internal.codegen.writer.StringLiteral;
 import java.io.IOException;
 import java.io.Writer;
+import java.lang.annotation.Annotation;
 import java.util.Set;
 import javax.annotation.processing.AbstractProcessor;
+import javax.annotation.processing.ProcessingEnvironment;
 import javax.annotation.processing.Processor;
 import javax.annotation.processing.RoundEnvironment;
+import javax.inject.Inject;
+import javax.lang.model.SourceVersion;
+import javax.lang.model.element.Element;
 import javax.lang.model.element.TypeElement;
 import javax.tools.JavaFileObject;
 import org.junit.Ignore;
@@ -2150,6 +2160,197 @@ public void genericTestToLetMeDebugInEclipse() {
          .and().generatesSources(generatedComponent);
    }
 
+  /**
+   * We warn when generating a {@link MembersInjector} for a type post-hoc (i.e., if Dagger wasn't
+   * invoked when compiling the type). But Dagger only generates {@link MembersInjector}s for types
+   * with {@link Inject @Inject} constructors if they have any injection sites, and it only
+   * generates them for types without {@link Inject @Inject} constructors if they have local
+   * (non-inherited) injection sites. So make sure we warn in only those cases where running the
+   * Dagger processor actually generates a {@link MembersInjector}.
+   */
+  @Test
+  public void unprocessedMembersInjectorNotes() {
+    assertAbout(javaSources())
+        .that(
+            ImmutableList.of(
+                JavaFileObjects.forSourceLines(
+                    "test.TestComponent",
+                    "package test;",
+                    "",
+                    "import dagger.Component;",
+                    "",
+                    "@Component(modules = TestModule.class)",
+                    "interface TestComponent {",
+                    "  void inject(test.inject.NoInjectMemberNoConstructor object);",
+                    "  void inject(test.inject.NoInjectMemberWithConstructor object);",
+                    "  void inject(test.inject.LocalInjectMemberNoConstructor object);",
+                    "  void inject(test.inject.LocalInjectMemberWithConstructor object);",
+                    "  void inject(test.inject.ParentInjectMemberNoConstructor object);",
+                    "  void inject(test.inject.ParentInjectMemberWithConstructor object);",
+                    "}"),
+                JavaFileObjects.forSourceLines(
+                    "test.TestModule",
+                    "package test;",
+                    "",
+                    "import dagger.Module;",
+                    "import dagger.Provides;",
+                    "",
+                    "@Module",
+                    "class TestModule {",
+                    "  @Provides static Object object() {",
+                    "    return \"object\";",
+                    "  }",
+                    "}"),
+                JavaFileObjects.forSourceLines(
+                    "test.inject.NoInjectMemberNoConstructor",
+                    "package test.inject;",
+                    "",
+                    "public class NoInjectMemberNoConstructor {",
+                    "}"),
+                JavaFileObjects.forSourceLines(
+                    "test.inject.NoInjectMemberWithConstructor",
+                    "package test.inject;",
+                    "",
+                    "import javax.inject.Inject;",
+                    "",
+                    "public class NoInjectMemberWithConstructor {",
+                    "  @Inject NoInjectMemberWithConstructor() {}",
+                    "}"),
+                JavaFileObjects.forSourceLines(
+                    "test.inject.LocalInjectMemberNoConstructor",
+                    "package test.inject;",
+                    "",
+                    "import javax.inject.Inject;",
+                    "",
+                    "public class LocalInjectMemberNoConstructor {",
+                    "  @Inject Object object;",
+                    "}"),
+                JavaFileObjects.forSourceLines(
+                    "test.inject.LocalInjectMemberWithConstructor",
+                    "package test.inject;",
+                    "",
+                    "import javax.inject.Inject;",
+                    "",
+                    "public class LocalInjectMemberWithConstructor {",
+                    "  @Inject LocalInjectMemberWithConstructor() {}",
+                    "  @Inject Object object;",
+                    "}"),
+                JavaFileObjects.forSourceLines(
+                    "test.inject.ParentInjectMemberNoConstructor",
+                    "package test.inject;",
+                    "",
+                    "import javax.inject.Inject;",
+                    "",
+                    "public class ParentInjectMemberNoConstructor",
+                    "    extends LocalInjectMemberNoConstructor {}"),
+                JavaFileObjects.forSourceLines(
+                    "test.inject.ParentInjectMemberWithConstructor",
+                    "package test.inject;",
+                    "",
+                    "import javax.inject.Inject;",
+                    "",
+                    "public class ParentInjectMemberWithConstructor",
+                    "    extends LocalInjectMemberNoConstructor {",
+                    "  @Inject ParentInjectMemberWithConstructor() {}",
+                    "}")))
+        .processedWith(
+            new ElementFilteringComponentProcessor(
+                Predicates.not(
+                    new Predicate<Element>() {
+                      @Override
+                      public boolean apply(Element element) {
+                        return MoreElements.getPackage(element)
+                            .getQualifiedName()
+                            .toString()
+                            .equals("test.inject");
+                      }
+                    })))
+        .compilesWithoutError();
+        /* TODO(b/23108801): Uncomment when compilesWithoutWarnings() is implemented.
+        .compilesWithoutWarnings()
+        .withNoteContaining(
+            "Generating a MembersInjector or Factory for "
+                + "test.inject.LocalInjectMemberNoConstructor. "
+                + "Prefer to run the dagger processor over that class instead.")
+        .and()
+        .withNoteContaining(
+            "Generating a MembersInjector or Factory for "
+                + "test.inject.LocalInjectMemberWithConstructor. "
+                + "Prefer to run the dagger processor over that class instead.")
+        .and()
+        .withNoteContaining(
+            "Generating a MembersInjector or Factory for "
+                + "test.inject.ParentInjectMemberWithConstructor. "
+                + "Prefer to run the dagger processor over that class instead.")
+        .and()
+        .withNoteCount(3);
+         */
+  }
+
+  /**
+   * A {@link ComponentProcessor} that excludes elements using a {@link Predicate}.
+   */
+  private static final class ElementFilteringComponentProcessor extends AbstractProcessor {
+    private final ComponentProcessor componentProcessor = new ComponentProcessor();
+    private final Predicate<? super Element> filter;
+
+    /**
+     * Creates a {@link ComponentProcessor} that only processes elements that match {@code filter}.
+     */
+    public ElementFilteringComponentProcessor(Predicate<? super Element> filter) {
+      this.filter = filter;
+    }
+
+    @Override
+    public synchronized void init(ProcessingEnvironment processingEnv) {
+      super.init(processingEnv);
+      componentProcessor.init(processingEnv);
+    }
+
+    @Override
+    public Set<String> getSupportedAnnotationTypes() {
+      return componentProcessor.getSupportedAnnotationTypes();
+    }
+
+    @Override
+    public SourceVersion getSupportedSourceVersion() {
+      return componentProcessor.getSupportedSourceVersion();
+    }
+
+    @Override
+    public boolean process(
+        Set<? extends TypeElement> annotations, final RoundEnvironment roundEnv) {
+      return componentProcessor.process(
+          annotations,
+          new RoundEnvironment() {
+            @Override
+            public boolean processingOver() {
+              return roundEnv.processingOver();
+            }
+
+            @Override
+            public Set<? extends Element> getRootElements() {
+              return Sets.filter(roundEnv.getRootElements(), filter);
+            }
+
+            @Override
+            public Set<? extends Element> getElementsAnnotatedWith(Class<? extends Annotation> a) {
+              return Sets.filter(roundEnv.getElementsAnnotatedWith(a), filter);
+            }
+
+            @Override
+            public Set<? extends Element> getElementsAnnotatedWith(TypeElement a) {
+              return Sets.filter(roundEnv.getElementsAnnotatedWith(a), filter);
+            }
+
+            @Override
+            public boolean errorRaised() {
+              return roundEnv.errorRaised();
+            }
+          });
+    }
+  }
+
   /**
    * A simple {@link Processor} that generates one source file.
    */
