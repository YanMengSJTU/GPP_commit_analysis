diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java
index 586a69301..5503e17c3 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java
@@ -15,11 +15,6 @@
  */
 package dagger.internal.codegen;
 
-import com.google.common.base.Function;
-import com.google.common.base.Joiner;
-import com.google.common.collect.FluentIterable;
-import com.google.common.collect.ImmutableList;
-import com.google.common.collect.Ordering;
 import com.squareup.javawriter.JavaWriter;
 import dagger.Lazy;
 import dagger.Module;
@@ -71,9 +66,9 @@
 import static dagger.internal.codegen.Util.getNoArgsConstructor;
 import static dagger.internal.codegen.Util.getPackage;
 import static dagger.internal.codegen.Util.isCallableConstructor;
+import static dagger.internal.codegen.Util.isInterface;
 import static dagger.internal.codegen.Util.typeToString;
 import static dagger.internal.loaders.GeneratedAdapters.MODULE_ADAPTER_SUFFIX;
-import static java.util.Arrays.asList;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
@@ -269,33 +264,15 @@ private void generateModuleAdapter(Writer ioWriter, String adapterName, TypeElem
     writer.beginType(adapterName, "class", EnumSet.of(PUBLIC, FINAL),
         JavaWriter.type(ModuleAdapter.class, typeName));
 
-    final List<String> providedTypes = FluentIterable.from(providerMethods)
-        .transform(new Function<ExecutableElement, String>() {
-          @Override public String apply(ExecutableElement element) {
-            return GeneratorKeys.get(element.getReturnType());
-          }
-        }).toList();
-    StringBuilder injectsField = new StringBuilder("{");
-    Iterable<String> injectsFieldKeys = FluentIterable.<Object>from(asList(injects))
-        .transform(new Cast<TypeMirror>())
-        .transformAndConcat(new Function<TypeMirror, Iterable<String>>() {
-          @Override public Iterable<String> apply(TypeMirror type) {
-            String key = GeneratorKeys.get(type);
-            if (!providedTypes.contains(key) && Util.needsMemberInjection(type)) {
-              String membersKey = GeneratorKeys.rawMembersKey(type);
-              Iterable<String> keys = ImmutableList.of(membersKey, key);
-              return keys;
-            }
-            return ImmutableList.of(key);
-          }
-        })
-        .transform(new Function<String, String>() {
-          @Override public String apply(String key) {
-            return JavaWriter.stringLiteral(key);
-          }
-        })
-        .toSortedSet(Ordering.natural());
-    Joiner.on(", ").appendTo(injectsField, injectsFieldKeys).append("}");
+    StringBuilder injectsField = new StringBuilder().append("{ ");
+    for (Object injectableType : injects) {
+      TypeMirror typeMirror = (TypeMirror) injectableType;
+      String key = isInterface(typeMirror)
+          ? GeneratorKeys.get(typeMirror)
+          : GeneratorKeys.rawMembersKey(typeMirror);
+      injectsField.append(JavaWriter.stringLiteral(key)).append(", ");
+    }
+    injectsField.append("}");
     writer.emitField("String[]", "INJECTS", EnumSet.of(PRIVATE, STATIC, FINAL),
         injectsField.toString());
 
@@ -536,17 +513,4 @@ private String parameterName(Element parameter) {
     }
     return parameter.getSimpleName().toString();
   }
-
-  /**
-   * A function used to perform a cast to a strongly known type.  This does not actually
-   * perform any casting logic, but bridges Java's typesystem.  {@link Cast} should only
-   * be used in circumstances where the cast is bullet-proof and safe.
-   */
-  private static final class Cast<T> implements Function<Object, T> {
-    @SuppressWarnings("unchecked")
-    @Override
-    public T apply(Object o) {
-      return (T) o;
-    }
-  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/Util.java b/compiler/src/main/java/dagger/internal/codegen/Util.java
index 000785923..0f8b36c24 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Util.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Util.java
@@ -16,15 +16,12 @@
  */
 package dagger.internal.codegen;
 
-import com.google.common.base.Predicate;
-import com.google.common.collect.FluentIterable;
 import dagger.internal.Keys;
 import java.lang.reflect.Method;
 import java.util.Arrays;
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
-import javax.inject.Inject;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.AnnotationValue;
 import javax.lang.model.element.AnnotationValueVisitor;
@@ -34,14 +31,12 @@
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.PackageElement;
 import javax.lang.model.element.TypeElement;
-import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.ArrayType;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.ErrorType;
 import javax.lang.model.type.PrimitiveType;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.type.TypeVariable;
-import javax.lang.model.util.ElementFilter;
 import javax.lang.model.util.SimpleAnnotationValueVisitor6;
 import javax.lang.model.util.SimpleTypeVisitor6;
 
@@ -243,23 +238,6 @@ private static boolean lenientIsInstance(Class<?> expectedClass, Object value) {
     }
   }
 
-  /**
-   * Returns true if the type reflected by this TypeMirror contains @Inject fields.
-   */
-  public static boolean needsMemberInjection(TypeMirror type) {
-    return type.accept(new SimpleTypeVisitor6<Boolean, Void>() {
-      @Override public Boolean visitDeclared(DeclaredType declaredType, Void v) {
-        List<? extends Element> enclosed = declaredType.asElement().getEnclosedElements();
-        return FluentIterable.<VariableElement>from(ElementFilter.fieldsIn(enclosed))
-            .anyMatch(new Predicate<VariableElement>() {
-              @Override public boolean apply(VariableElement e) {
-                return e.getAnnotation(Inject.class) != null;
-              }
-            });
-      }
-    }, null);
-  }
-
   // TODO(sgoldfed): better format for other types of elements?
   static String elementToString(Element element) {
     switch (element.getKind()) {
diff --git a/compiler/src/test/java/dagger/tests/integration/codegen/InjectAdapterGenerationTest.java b/compiler/src/test/java/dagger/tests/integration/codegen/InjectAdapterGenerationTest.java
index 857b54643..59aff69f6 100644
--- a/compiler/src/test/java/dagger/tests/integration/codegen/InjectAdapterGenerationTest.java
+++ b/compiler/src/test/java/dagger/tests/integration/codegen/InjectAdapterGenerationTest.java
@@ -44,7 +44,7 @@
             "import dagger.internal.ModuleAdapter;",
             "public final class Basic$AModule$$ModuleAdapter",
             "    extends ModuleAdapter<Basic.AModule> {",
-            "  private static final String[] INJECTS = {\"Basic$A\"};",
+            "  private static final String[] INJECTS = {\"members/Basic$A\"};",
             "  private static final Class<?>[] STATIC_INJECTIONS = {};",
             "  private static final Class<?>[] INCLUDES = {};",
             "  public Basic$AModule$$ModuleAdapter() {",
@@ -76,99 +76,4 @@
         .generatesSources(expectedModuleAdapter, expectedInjectAdapter);
 
   }
-
-  /**
-   * Shows current behavior for a {@link dagger.Provides provides method}
-   * used to supply an injected ctor parameter.
-   *
-   * <ul>
-   *   <li>{@code ProvidesAdapter} invokes the module's provides method on
-   *   {@code get}</li>
-   *   <li>On {@code getBindings}, the above is newed up and linked to its type
-   *   key.
-   *   <li>{@code InjectAdapter} contains a field for the parameter binding,
-   *   referenced in {@code getDependencies} and set on {@code attach}</li>
-   *   <li>On {@code get}, the injected constructor is called with the value of
-   *   {@link dagger.internal.Binding#get}</li>
-   * </ul>
-   */
-  @Test public void providerForCtorInjection() {
-    JavaFileObject sourceFile = JavaFileObjects.forSourceString("Field", Joiner.on("\n").join(
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "import javax.inject.Inject;",
-        "class Field {",
-        "  static class A { final String name; @Inject A(String name) { this.name = name; }}",
-        "  @Module(injects = { A.class, String.class })",
-        "  static class AModule { @Provides String name() { return \"foo\"; }}",
-        "}"));
-
-    JavaFileObject expectedModuleAdapter =
-        JavaFileObjects.forSourceString("Field$AModule$$ModuleAdapter", Joiner.on("\n").join(
-        "import dagger.internal.Binding;",
-        "import dagger.internal.ModuleAdapter;",
-        "import java.util.Map;",
-        "import javax.inject.Provider;",
-        "public final class Field$AModule$$ModuleAdapter",
-        "    extends ModuleAdapter<Field.AModule> {",
-        "  private static final String[] INJECTS = ",
-        "      {\"Field$A\", \"java.lang.String\"};",
-        "  private static final Class<?>[] STATIC_INJECTIONS = {};",
-        "  private static final Class<?>[] INCLUDES = {};",
-        "  public Field$AModule$$ModuleAdapter() {",
-        "    super(Field.AModule.class, INJECTS, STATIC_INJECTIONS, false, INCLUDES, true, false);",
-        "  }",
-        "  @Override public Field.AModule newModule() {",
-        "    return new Field.AModule();",
-        "  }",
-        "  @Override public void getBindings(Map<String, Binding<?>> map, Field.AModule module) {",
-        "    map.put(\"java.lang.String\", new NameProvidesAdapter(module));", // eager new!
-        "  }",
-        "  public static final class NameProvidesAdapter", // corresponds to method name
-        "      extends Binding<String> implements Provider<String> {",
-        "    private final Field.AModule module;",
-        "    public NameProvidesAdapter(Field.AModule module) {",
-        "      super(\"java.lang.String\", null, NOT_SINGLETON, \"Field.AModule.name()\");",
-        "      this.module = module;",
-        "      setLibrary(false);",
-        "    }",
-        "    @Override public String get() {",
-        "      return module.name();", // corresponds to @Provides method
-        "    }",
-        "  }",
-        "}"));
-
-    JavaFileObject expectedInjectAdapter =
-        JavaFileObjects.forSourceString("Field$A$$InjectAdapter", Joiner.on("\n").join(
-            "import dagger.internal.Binding;",
-            "import dagger.internal.Linker;",
-            "import java.util.Set;",
-            "import javax.inject.Provider;",
-            "public final class Field$A$$InjectAdapter",
-            "    extends Binding<Field.A> implements Provider<Field.A> {",
-            "  private Binding<String> name;", // for ctor
-            "  public Field$A$$InjectAdapter() {",
-            "    super(\"Field$A\", \"members/Field$A\", NOT_SINGLETON, Field.A.class);",
-            "  }",
-            "  @Override @SuppressWarnings(\"unchecked\")",
-            "  public void attach(Linker linker) {",
-            "    name = (Binding<String>)linker.requestBinding(", // binding key is not a class
-            "      \"java.lang.String\", Field.A.class, getClass().getClassLoader());",
-            "  }",
-            "  @Override public void getDependencies(",
-            "      Set<Binding<?>> getBindings, Set<Binding<?>> injectMembersBindings) {",
-            "    getBindings.add(name);", // name is added to dependencies
-            "  }",
-            "  @Override public Field.A get() {",
-            "    Field.A result = new Field.A(name.get());", // adds ctor param
-            "    return result;",
-            "  }",
-            "}"));
-
-    ASSERT.about(javaSource()).that(sourceFile).processedWith(daggerProcessors())
-        .compilesWithoutError()
-        .and()
-        .generatesSources(expectedModuleAdapter, expectedInjectAdapter);
-
-  }
 }
diff --git a/compiler/src/test/java/dagger/tests/integration/codegen/ModuleAdapterGenerationTest.java b/compiler/src/test/java/dagger/tests/integration/codegen/ModuleAdapterGenerationTest.java
index d7af842a4..3983ee9ce 100644
--- a/compiler/src/test/java/dagger/tests/integration/codegen/ModuleAdapterGenerationTest.java
+++ b/compiler/src/test/java/dagger/tests/integration/codegen/ModuleAdapterGenerationTest.java
@@ -31,6 +31,101 @@
 
 @RunWith(JUnit4.class)
 public final class ModuleAdapterGenerationTest {
+  /**
+   * Shows current behavior for a {@link dagger.Provides provides method}
+   * used to supply an injected ctor parameter.
+   *
+   * <ul>
+   *   <li>{@code ProvidesAdapter} invokes the module's provides method on
+   *   {@code get}</li>
+   *   <li>On {@code getBindings}, the above is newed up and linked to its type
+   *   key.
+   *   <li>{@code InjectAdapter} contains a field for the parameter binding,
+   *   referenced in {@code getDependencies} and set on {@code attach}</li>
+   *   <li>On {@code get}, the injected constructor is called with the value of
+   *   {@link dagger.internal.Binding#get}</li>
+   * </ul>
+   */
+  @Test public void providerForCtorInjection() {
+    JavaFileObject sourceFile = JavaFileObjects.forSourceString("Field", Joiner.on("\n").join(
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import javax.inject.Inject;",
+        "class Field {",
+        "  static class A { final String name; @Inject A(String name) { this.name = name; }}",
+        "  @Module(injects = { A.class, String.class })",
+        "  static class AModule { @Provides String name() { return \"foo\"; }}",
+        "}"));
+
+    JavaFileObject expectedModuleAdapter =
+        JavaFileObjects.forSourceString("Field$AModule$$ModuleAdapter", Joiner.on("\n").join(
+        "import dagger.internal.Binding;",
+        "import dagger.internal.ModuleAdapter;",
+        "import java.util.Map;",
+        "import javax.inject.Provider;",
+        "public final class Field$AModule$$ModuleAdapter",
+        "    extends ModuleAdapter<Field.AModule> {",
+        "  private static final String[] INJECTS = ",
+        "      {\"members/Field$A\", \"members/java.lang.String\"};",
+        "  private static final Class<?>[] STATIC_INJECTIONS = {};",
+        "  private static final Class<?>[] INCLUDES = {};",
+        "  public Field$AModule$$ModuleAdapter() {",
+        "    super(Field.AModule.class, INJECTS, STATIC_INJECTIONS, false, INCLUDES, true, false);",
+        "  }",
+        "  @Override public Field.AModule newModule() {",
+        "    return new Field.AModule();",
+        "  }",
+        "  @Override public void getBindings(Map<String, Binding<?>> map, Field.AModule module) {",
+        "    map.put(\"java.lang.String\", new NameProvidesAdapter(module));", // eager new!
+        "  }",
+        "  public static final class NameProvidesAdapter", // corresponds to method name
+        "      extends Binding<String> implements Provider<String> {",
+        "    private final Field.AModule module;",
+        "    public NameProvidesAdapter(Field.AModule module) {",
+        "      super(\"java.lang.String\", null, NOT_SINGLETON, \"Field.AModule.name()\");",
+        "      this.module = module;",
+        "      setLibrary(false);",
+        "    }",
+        "    @Override public String get() {",
+        "      return module.name();", // corresponds to @Provides method
+        "    }",
+        "  }",
+        "}"));
+
+    JavaFileObject expectedInjectAdapter =
+        JavaFileObjects.forSourceString("Field$A$$InjectAdapter", Joiner.on("\n").join(
+            "import dagger.internal.Binding;",
+            "import dagger.internal.Linker;",
+            "import java.util.Set;",
+            "import javax.inject.Provider;",
+            "public final class Field$A$$InjectAdapter",
+            "    extends Binding<Field.A> implements Provider<Field.A> {",
+            "  private Binding<String> name;", // for ctor
+            "  public Field$A$$InjectAdapter() {",
+            "    super(\"Field$A\", \"members/Field$A\", NOT_SINGLETON, Field.A.class);",
+            "  }",
+            "  @Override @SuppressWarnings(\"unchecked\")",
+            "  public void attach(Linker linker) {",
+            "    name = (Binding<String>)linker.requestBinding(", // binding key is not a class
+            "      \"java.lang.String\", Field.A.class, getClass().getClassLoader());",
+            "  }",
+            "  @Override public void getDependencies(",
+            "      Set<Binding<?>> getBindings, Set<Binding<?>> injectMembersBindings) {",
+            "    getBindings.add(name);", // name is added to dependencies
+            "  }",
+            "  @Override public Field.A get() {",
+            "    Field.A result = new Field.A(name.get());", // adds ctor param
+            "    return result;",
+            "  }",
+            "}"));
+
+    ASSERT.about(javaSource()).that(sourceFile).processedWith(daggerProcessors())
+        .compilesWithoutError()
+        .and()
+        .generatesSources(expectedModuleAdapter, expectedInjectAdapter);
+
+  }
+
   @Test public void injectsMembersInjectedAndProvidedAndConstructedTypes() {
     JavaFileObject sourceFile = JavaFileObjects.forSourceString("Field", Joiner.on("\n").join(
         "import dagger.Module;",
@@ -51,7 +146,7 @@
         "import javax.inject.Provider;",
         "public final class Field$AModule$$ModuleAdapter extends ModuleAdapter<Field.AModule> {",
         "  private static final String[] INJECTS = ",
-        "      {\"Field$A\", \"Field$B\", \"java.lang.String\", \"members/Field$B\"};",
+        "      {\"members/Field$A\", \"members/java.lang.String\", \"members/Field$B\"};",
         "  private static final Class<?>[] STATIC_INJECTIONS = {};",
         "  private static final Class<?>[] INCLUDES = {};",
         "  public Field$AModule$$ModuleAdapter() {",
@@ -141,6 +236,7 @@
         .generatesSources(expectedModuleAdapter, expectedInjectAdapterA, expectedInjectAdapterB);
   }
 
+
   @Test public void providesHasParameterNamedModule() {
     JavaFileObject a = JavaFileObjects.forSourceString("A", Joiner.on("\n").join(
         "import javax.inject.Inject;",
@@ -152,10 +248,12 @@
     JavaFileObject module = JavaFileObjects.forSourceString("BModule", Joiner.on("\n").join(
         "import dagger.Module;",
         "import dagger.Provides;",
+        "import javax.inject.Inject;",
         "@Module(injects = B.class)",
         "class BModule { @Provides B b(A module) { return new B(); }}"));
 
     ASSERT.about(javaSources()).that(asList(a, b, module)).processedWith(daggerProcessors())
         .compilesWithoutError();
   }
+
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/PrimitiveInjectionTest.java b/compiler/src/test/java/dagger/tests/integration/operation/PrimitiveInjectionTest.java
similarity index 98%
rename from compiler/src/test/java/dagger/internal/codegen/PrimitiveInjectionTest.java
rename to compiler/src/test/java/dagger/tests/integration/operation/PrimitiveInjectionTest.java
index adeea2a75..5f7451c6b 100644
--- a/compiler/src/test/java/dagger/internal/codegen/PrimitiveInjectionTest.java
+++ b/compiler/src/test/java/dagger/tests/integration/operation/PrimitiveInjectionTest.java
@@ -14,7 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package dagger.internal.codegen;
+package dagger.tests.integration.operation;
 
 import dagger.Module;
 import dagger.ObjectGraph;
diff --git a/compiler/src/test/java/dagger/tests/integration/operation/SimpleInjectionTest.java b/compiler/src/test/java/dagger/tests/integration/operation/SimpleInjectionTest.java
new file mode 100644
index 000000000..994c7800b
--- /dev/null
+++ b/compiler/src/test/java/dagger/tests/integration/operation/SimpleInjectionTest.java
@@ -0,0 +1,90 @@
+/**
+ * Copyright (C) 2013 Google, Inc.
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.tests.integration.operation;
+
+import dagger.Module;
+import dagger.ObjectGraph;
+import dagger.Provides;
+import javax.inject.Inject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static org.truth0.Truth.ASSERT;
+
+@RunWith(JUnit4.class)
+public final class SimpleInjectionTest {
+  static abstract class AbstractFoo {
+    @Inject String blah;
+  }
+
+  static class Foo extends AbstractFoo { }
+
+  @Module(injects = Foo.class)
+  static class FooModule {
+    @Provides String string() { return "blah"; }
+  }
+
+  @Module(injects = Foo.class)
+  static class ProvidingFooModule {
+    @Provides String string() { return "blah"; }
+    @Provides Foo foo(String blah) {
+      Foo foo = new Foo();
+      foo.blah = blah;
+      return foo;
+    }
+  }
+
+  @Test public void memberInject_WithoutProvidesMethod() {
+    Foo foo = new Foo();
+    ObjectGraph.create(FooModule.class).inject(foo);
+    ASSERT.that(foo.blah).equals("blah");
+  }
+
+  @Test public void membersInject_WithProvidesMethod() {
+    Foo foo = new Foo();
+    ObjectGraph.create(ProvidingFooModule.class).inject(foo);
+    ASSERT.that(foo.blah).equals("blah");
+  }
+
+  @Test public void get_WithProvidesMethod() {
+    Foo foo = ObjectGraph.create(ProvidingFooModule.class).get(Foo.class);
+    ASSERT.that(foo.blah).equals("blah");
+  }
+
+  static class Bar { }
+
+  @Module(injects = Bar.class)
+  static class BarModule {
+  }
+
+  @Test public void membersInject_WithNonInjectable() {
+    Bar bar = new Bar();
+    ObjectGraph.create(BarModule.class).inject(bar);
+  }
+
+  @Module(injects = Bar.class)
+  static class ProvidingBarModule {
+    @Provides public Bar bar() { return new Bar(); }
+  }
+
+  @Test public void membersInject_WithProvidedNonInjectable() {
+    Bar bar = ObjectGraph.create(ProvidingBarModule.class).get(Bar.class);
+    ASSERT.that(bar).isNotNull();
+  }
+
+}
