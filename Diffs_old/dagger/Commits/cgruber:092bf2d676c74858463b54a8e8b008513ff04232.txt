diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/ChildComponent.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/ChildComponent.java
new file mode 100644
index 000000000..badb7cac6
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/ChildComponent.java
@@ -0,0 +1,14 @@
+
+
+package test.subcomponent.repeat;
+
+import dagger.Subcomponent;
+
+import java.util.Set;
+
+@Subcomponent(modules = RepeatedModule.class)
+interface ChildComponent {
+  String getString();
+  Set<String> getMultiboundStrings();
+  OnlyUsedInChild getOnlyUsedInChild();
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/ParentComponent.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/ParentComponent.java
index f0af00237..91df02cc3 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/ParentComponent.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/ParentComponent.java
@@ -1,39 +1,19 @@
-/*
- * Copyright (C) 2015 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
 package test.subcomponent.repeat;
 
 import dagger.Component;
+
 import java.util.Set;
 
 @Component(modules = RepeatedModule.class)
 interface ParentComponent {
-  Object state();
-
   String getString();
   Set<String> getMultiboundStrings();
   OnlyUsedInParent getOnlyUsedInParent();
 
-  SubcomponentWithRepeatedModule.Builder newChildComponentBuilder();
-
-  SubcomponentWithoutRepeatedModule newChildComponentWithoutRepeatedModule();
+  ChildComponent newChildComponent();
 
   @Component.Builder
   interface Builder {
-    Builder repeatedModule(RepeatedModule repeatedModule);
-
     ParentComponent build();
   }
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/RepeatedModule.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/RepeatedModule.java
index d0997513d..508a41b56 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/RepeatedModule.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/RepeatedModule.java
@@ -1,51 +1,25 @@
-/*
- * Copyright (C) 2015 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
 package test.subcomponent.repeat;
 
+import static dagger.Provides.Type.SET;
+
 import dagger.Module;
 import dagger.Provides;
 
-import static dagger.Provides.Type.SET;
-
 @Module
 final class RepeatedModule {
-  private final Object state = new Object();
-
-  @Provides
-  Object state() {
-    return state;
-  }
-
-  @Provides
-  static String provideString() {
+  @Provides String provideString() {
     return "a string";
   }
 
-  @Provides(type = SET)
-  static String contributeString() {
+  @Provides(type = SET) String contributeString() {
     return "a string in a set";
   }
 
-  @Provides
-  static OnlyUsedInParent provideOnlyUsedInParent() {
+  @Provides OnlyUsedInParent provideOnlyUsedInParent() {
     return new OnlyUsedInParent() {};
   }
 
-  @Provides
-  static OnlyUsedInChild provideOnlyUsedInChild() {
+  @Provides OnlyUsedInChild provideOnlyUsedInChild() {
     return new OnlyUsedInChild() {};
   }
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/SubcomponentWithRepeatedModule.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/SubcomponentWithRepeatedModule.java
deleted file mode 100644
index 9e97d7bd3..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/SubcomponentWithRepeatedModule.java
+++ /dev/null
@@ -1,35 +0,0 @@
-/*
- * Copyright (C) 2015 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package test.subcomponent.repeat;
-
-import dagger.Subcomponent;
-import java.util.Set;
-
-@Subcomponent(modules = RepeatedModule.class)
-interface SubcomponentWithRepeatedModule {
-  Object state();
-
-  String getString();
-  Set<String> getMultiboundStrings();
-  OnlyUsedInChild getOnlyUsedInChild();
-
-  @Subcomponent.Builder
-  interface Builder {
-    Builder repeatedModule(RepeatedModule repeatedModule);
-
-    SubcomponentWithRepeatedModule build();
-  }
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/SubcomponentWithoutRepeatedModule.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/SubcomponentWithoutRepeatedModule.java
deleted file mode 100644
index e63c9a0ae..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/SubcomponentWithoutRepeatedModule.java
+++ /dev/null
@@ -1,23 +0,0 @@
-/*
- * Copyright (C) 2015 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package test.subcomponent.repeat;
-
-import dagger.Subcomponent;
-
-@Subcomponent
-interface SubcomponentWithoutRepeatedModule {
-  SubcomponentWithRepeatedModule.Builder newGrandchildBuilder();
-}
diff --git a/compiler/src/it/functional-tests/src/test/java/test/subcomponent/repeat/RepeatedModuleTest.java b/compiler/src/it/functional-tests/src/test/java/test/subcomponent/repeat/RepeatedModuleTest.java
deleted file mode 100644
index 7e92371bf..000000000
--- a/compiler/src/it/functional-tests/src/test/java/test/subcomponent/repeat/RepeatedModuleTest.java
+++ /dev/null
@@ -1,82 +0,0 @@
-/*
- * Copyright (C) 2015 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package test.subcomponent.repeat;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-import static com.google.common.truth.Truth.assertThat;
-import static org.junit.Assert.fail;
-
-@RunWith(JUnit4.class)
-public final class RepeatedModuleTest {
-  private ParentComponent parentComponent;
-
-  @Before
-  public void initializeParentComponent() {
-    this.parentComponent = DaggerParentComponent.builder().build();
-  }
-
-  @Test
-  public void repeatedModuleHasSameStateInSubcomponent() {
-    SubcomponentWithRepeatedModule childComponent =
-        parentComponent.newChildComponentBuilder().build();
-    assertThat(parentComponent.state()).isSameAs(childComponent.state());
-  }
-
-  @Test
-  public void repeatedModuleHasSameStateInGrandchildSubcomponent() {
-    SubcomponentWithoutRepeatedModule childComponent =
-        parentComponent.newChildComponentWithoutRepeatedModule();
-    SubcomponentWithRepeatedModule grandchildComponent =
-        childComponent.newGrandchildBuilder().build();
-    assertThat(parentComponent.state()).isSameAs(grandchildComponent.state());
-  }
-
-  @Test
-  public void repeatedModuleBuilderThrowsInSubcomponent() {
-    SubcomponentWithRepeatedModule.Builder childComponentBuilder =
-        parentComponent.newChildComponentBuilder();
-    try {
-      childComponentBuilder.repeatedModule(new RepeatedModule());
-      fail();
-    } catch (UnsupportedOperationException expected) {
-      assertThat(expected)
-          .hasMessage(
-              "test.subcomponent.repeat.RepeatedModule cannot be set "
-                  + "because it is inherited from the enclosing component");
-    }
-  }
-
-  @Test
-  public void repeatedModuleBuilderThrowsInGrandchildSubcomponent() {
-    SubcomponentWithoutRepeatedModule childComponent =
-        parentComponent.newChildComponentWithoutRepeatedModule();
-    SubcomponentWithRepeatedModule.Builder grandchildComponentBuilder =
-        childComponent.newGrandchildBuilder();
-    try {
-      grandchildComponentBuilder.repeatedModule(new RepeatedModule());
-      fail();
-    } catch (UnsupportedOperationException expected) {
-      assertThat(expected)
-          .hasMessage(
-              "test.subcomponent.repeat.RepeatedModule cannot be set "
-                  + "because it is inherited from the enclosing component");
-    }
-  }
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentProcessingStep.java
index fe8a53624..f78d1ac0d 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentProcessingStep.java
@@ -31,7 +31,6 @@
 abstract class AbstractComponentProcessingStep implements ProcessingStep {
 
   private final Messager messager;
-  private final ComponentHierarchyValidator componentHierarchyValidator;
   private final BindingGraphValidator bindingGraphValidator;
   private final ComponentDescriptor.Factory componentDescriptorFactory;
   private final BindingGraph.Factory bindingGraphFactory;
@@ -39,13 +38,11 @@
 
   AbstractComponentProcessingStep(
       Messager messager,
-      ComponentHierarchyValidator componentHierarchyValidator,
       BindingGraphValidator bindingGraphValidator,
       ComponentDescriptor.Factory componentDescriptorFactory,
       BindingGraph.Factory bindingGraphFactory,
       ComponentGenerator componentGenerator) {
     this.messager = messager;
-    this.componentHierarchyValidator = componentHierarchyValidator;
     this.bindingGraphValidator = bindingGraphValidator;
     this.componentDescriptorFactory = componentDescriptorFactory;
     this.bindingGraphFactory = bindingGraphFactory;
@@ -60,19 +57,14 @@
       try {
         ComponentDescriptor componentDescriptor =
             componentDescriptorFactory.forComponent(componentTypeElement);
-        ValidationReport<TypeElement> hierarchyReport =
-            componentHierarchyValidator.validate(componentDescriptor);
-        hierarchyReport.printMessagesTo(messager);
-        if (hierarchyReport.isClean()) {
-          BindingGraph bindingGraph = bindingGraphFactory.create(componentDescriptor);
-          ValidationReport<TypeElement> graphReport = bindingGraphValidator.validate(bindingGraph);
-          graphReport.printMessagesTo(messager);
-          if (graphReport.isClean()) {
-            try {
-              componentGenerator.generate(bindingGraph);
-            } catch (SourceFileGenerationException e) {
-              e.printMessageTo(messager);
-            }
+        BindingGraph bindingGraph = bindingGraphFactory.create(componentDescriptor);
+        ValidationReport<TypeElement> graphReport = bindingGraphValidator.validate(bindingGraph);
+        graphReport.printMessagesTo(messager);
+        if (graphReport.isClean()) {
+          try {
+            componentGenerator.generate(bindingGraph);
+          } catch (SourceFileGenerationException e) {
+            e.printMessageTo(messager);
           }
         }
       } catch (TypeNotPresentException e) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
index 51a5953d6..de830cc8f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -75,7 +75,6 @@
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.ExecutableType;
 import javax.lang.model.type.TypeKind;
-import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Types;
 import javax.tools.Diagnostic;
 import javax.tools.Diagnostic.Kind;
@@ -113,6 +112,7 @@
  * Creates the implementation class for a component or subcomponent.
  */
 abstract class AbstractComponentWriter {
+
   // TODO(dpb): Make all these fields private after refactoring is complete.
 
   protected final Types types;
@@ -267,9 +267,8 @@ protected void addBuilder() {
       // Note: we don't use the specBuildMethod.getReturnType() as the return type
       // because it might be a type variable.  We make use of covariant returns to allow
       // us to return the component type, which will always be valid.
-      buildMethod =
-          builderWriter.addMethod(
-              componentDefinitionTypeName(), specBuildMethod.getSimpleName().toString());
+      buildMethod = builderWriter.addMethod(componentDefinitionTypeName(),
+          specBuildMethod.getSimpleName().toString());
       buildMethod.annotate(Override.class);
     } else {
       buildMethod = builderWriter.addMethod(componentDefinitionTypeName(), "build");
@@ -286,30 +285,36 @@ protected void addBuilder() {
       builderField.addModifiers(PRIVATE);
       builderFieldsBuilder.put(contributionElement, builderField);
       if (componentCanMakeNewInstances(contributionElement)) {
-        buildMethod
-            .body()
+        buildMethod.body()
             .addSnippet("if (%s == null) {", builderField.name())
-            .addSnippet(
-                "  this.%s = new %s();",
-                builderField.name(),
-                ClassName.fromTypeElement(contributionElement))
+            .addSnippet("  this.%s = new %s();",
+                builderField.name(), ClassName.fromTypeElement(contributionElement))
             .addSnippet("}");
       } else {
-        buildMethod
-            .body()
+        buildMethod.body()
             .addSnippet("if (%s == null) {", builderField.name())
-            .addSnippet(
-                "  throw new IllegalStateException(\"%s must be set\");", builderField.name())
+            .addSnippet("  throw new IllegalStateException(\"%s must be set\");",
+                builderField.name())
             .addSnippet("}");
       }
-
       MethodWriter builderMethod;
+      boolean returnsVoid = false;
       if (builderSpec.isPresent()) {
         ExecutableElement method = builderSpec.get().methodMap().get(contributionElement);
         if (method == null) { // no method in the API, nothing to write out.
           continue;
         }
-        builderMethod = addBuilderMethodFromSpec(builderWriter, method);
+        // If the return type is void, we add a method with the void return type.
+        // Otherwise we use the builderWriter and take advantage of covariant returns
+        // (so that we don't have to worry about setter methods that return type variables).
+        if (method.getReturnType().getKind().equals(TypeKind.VOID)) {
+          returnsVoid = true;
+          builderMethod =
+              builderWriter.addMethod(method.getReturnType(), method.getSimpleName().toString());
+        } else {
+          builderMethod = builderWriter.addMethod(builderWriter, method.getSimpleName().toString());
+        }
+        builderMethod.annotate(Override.class);
       } else {
         builderMethod = builderWriter.addMethod(builderWriter, contributionName);
       }
@@ -318,60 +323,20 @@ protected void addBuilder() {
       //  but makes generated code prettier.)
       builderMethod.addModifiers(PUBLIC);
       builderMethod.addParameter(contributionElement, contributionName);
-      builderMethod
-          .body()
+      builderMethod.body()
           .addSnippet("if (%s == null) {", contributionName)
-          .addSnippet(
-              "  throw new NullPointerException(%s);", StringLiteral.forValue(contributionName))
+          .addSnippet("  throw new NullPointerException(%s);",
+              StringLiteral.forValue(contributionName))
           .addSnippet("}")
           .addSnippet("this.%s = %s;", builderField.name(), contributionName);
-      if (!builderMethod.returnType().equals(VoidName.VOID)) {
+      if (!returnsVoid) {
         builderMethod.body().addSnippet("return this;");
       }
     }
-
-    if (builderSpec.isPresent()) {
-      /* We know that the graph is properly formed because it passed validation, so all
-       * component requirements that are in the builder spec but _not_ owned by the component must
-       * be inherited. */
-      for (TypeElement inheritedRequirement :
-          Sets.difference(builderSpec.get().methodMap().keySet(), graph.componentRequirements())) {
-        MethodWriter builderMethod =
-            addBuilderMethodFromSpec(
-                builderWriter, builderSpec.get().methodMap().get(inheritedRequirement));
-        builderMethod.addModifiers(PUBLIC);
-        builderMethod.addParameter(inheritedRequirement, simpleVariableName(inheritedRequirement));
-        builderMethod
-            .body()
-            .addSnippet(
-                "throw new %s(%s.format(%s, %s.class.getCanonicalName()));",
-                ClassName.fromClass(UnsupportedOperationException.class),
-                ClassName.fromClass(String.class),
-                StringLiteral.forValue(
-                    "%s cannot be set because it is inherited from the enclosing component"),
-                ClassName.fromTypeElement(inheritedRequirement));
-      }
-    }
-
     builderFields = builderFieldsBuilder.build();
     buildMethod.body().addSnippet("return new %s(this);", name);
   }
 
-  private MethodWriter addBuilderMethodFromSpec(
-      ClassWriter builderWriter, ExecutableElement method) {
-    String methodName = method.getSimpleName().toString();
-    TypeMirror returnType = method.getReturnType();
-    // If the return type is void, we add a method with the void return type.
-    // Otherwise we use the builderWriter and take advantage of covariant returns
-    // (so that we don't have to worry about setter methods that return type variables).
-    MethodWriter builderMethod =
-        returnType.getKind().equals(TypeKind.VOID)
-            ? builderWriter.addMethod(returnType, methodName)
-            : builderWriter.addMethod(builderWriter, methodName);
-    builderMethod.annotate(Override.class);
-    return builderMethod;
-  }
-
   /**
    * Creates the builder class.
    */
@@ -397,7 +362,8 @@ private void addFields() {
     }
 
     memberSelectSnippets = ImmutableMap.copyOf(memberSelectSnippetsBuilder);
-    multibindingContributionSnippets = ImmutableMap.copyOf(multibindingContributionSnippetsBuilder);
+    multibindingContributionSnippets =
+        ImmutableMap.copyOf(multibindingContributionSnippetsBuilder);
     enumBindingKeys = enumBindingKeysBuilder.build();
   }
 
@@ -446,8 +412,8 @@ private void addField(
         proxyWriter.addModifiers(PUBLIC, FINAL);
         // create the field for the proxy in the component
         FieldWriter proxyFieldWriter =
-            componentWriter.addField(
-                proxyWriter.name(), bindingPackage.replace('.', '_') + "_Proxy");
+            componentWriter.addField(proxyWriter.name(),
+                bindingPackage.replace('.', '_') + "_Proxy");
         proxyFieldWriter.addModifiers(PRIVATE, FINAL);
         proxyFieldWriter.setInitializer("new %s()", proxyWriter.name());
         proxyClassAndField = ProxyClassAndField.create(proxyWriter, proxyFieldWriter);
@@ -499,11 +465,10 @@ private void addField(
         classWithFields.addField(bindingField.frameworkType(), bindingField.name());
     frameworkField.addModifiers(fieldModifiers);
 
-    ImmutableList<String> memberSelectTokens =
-        new ImmutableList.Builder<String>()
-            .addAll(proxySelector.asSet())
-            .add(frameworkField.name())
-            .build();
+    ImmutableList<String> memberSelectTokens = new ImmutableList.Builder<String>()
+        .addAll(proxySelector.asSet())
+        .add(frameworkField.name())
+        .build();
     memberSelectSnippetsBuilder.put(
         bindingKey,
         MemberSelect.instanceSelect(name, Snippet.memberSelectSnippet(memberSelectTokens)));
@@ -569,12 +534,10 @@ private void implementInterfaceMethods() {
             requestElement.getSimpleName().toString(), requestType);
         if (!interfaceMethods.contains(signature)) {
           interfaceMethods.add(signature);
-          MethodWriter interfaceMethod =
-              requestType.getReturnType().getKind().equals(VOID)
-                  ? componentWriter.addMethod(
-                      VoidName.VOID, requestElement.getSimpleName().toString())
-                  : componentWriter.addMethod(
-                      requestType.getReturnType(), requestElement.getSimpleName().toString());
+          MethodWriter interfaceMethod = requestType.getReturnType().getKind().equals(VOID)
+              ? componentWriter.addMethod(VoidName.VOID, requestElement.getSimpleName().toString())
+              : componentWriter.addMethod(requestType.getReturnType(),
+                  requestElement.getSimpleName().toString());
           interfaceMethod.annotate(Override.class);
           interfaceMethod.addModifiers(PUBLIC);
           BindingKey bindingKey = interfaceRequest.bindingKey();
@@ -612,9 +575,8 @@ private void implementInterfaceMethods() {
                 // If using a parameterized enum type, then we need to store the factory
                 // in a temporary variable, in order to help javac be able to infer
                 // the generics of the Factory.create methods.
-                TypeName factoryType =
-                    ParameterizedTypeName.create(
-                        Provider.class, TypeNames.forTypeMirror(requestType.getReturnType()));
+                TypeName factoryType = ParameterizedTypeName.create(Provider.class,
+                    TypeNames.forTypeMirror(requestType.getReturnType()));
                 interfaceMethod
                     .body()
                     .addSnippet(
@@ -691,16 +653,13 @@ private void initializeFrameworkTypes() {
                   }
                   parameterSnippets.add(snippet);
                 }
-                Snippet initializeSetSnippet =
-                    Snippet.format(
-                        "%s.create(%s)",
-                        hasOnlyProvisions
-                            ? ClassName.fromClass(SetFactory.class)
-                            : ClassName.fromClass(SetProducer.class),
-                        Snippet.makeParametersSnippet(parameterSnippets.build()));
-                initializeMethod
-                    .body()
-                    .addSnippet("this.%s = %s;", memberSelectSnippet, initializeSetSnippet);
+                Snippet initializeSetSnippet = Snippet.format("%s.create(%s)",
+                    hasOnlyProvisions
+                        ? ClassName.fromClass(SetFactory.class)
+                        : ClassName.fromClass(SetProducer.class),
+                    Snippet.makeParametersSnippet(parameterSnippets.build()));
+                initializeMethod.body().addSnippet("this.%s = %s;",
+                    memberSelectSnippet, initializeSetSnippet);
                 break;
               case MAP:
                 if (Sets.filter(bindings, Predicates.instanceOf(ProductionBinding.class))
@@ -714,21 +673,14 @@ private void initializeFrameworkTypes() {
                     if (!isMapWithNonProvidedValues(provisionBinding.key().type())
                         && multibindingContributionSnippet.isPresent()
                         && multibindingContributionSnippet.get().owningClass().equals(name)) {
-                      initializeMethod
-                          .body()
-                          .addSnippet(
-                              "this.%s = %s;",
-                              multibindingContributionSnippet.get().getSnippetFor(name),
-                              initializeFactoryForProvisionBinding(provisionBinding));
+                      initializeMethod.body().addSnippet("this.%s = %s;",
+                          multibindingContributionSnippet.get().getSnippetFor(name),
+                          initializeFactoryForProvisionBinding(provisionBinding));
                     }
                   }
                   if (!provisionBindings.isEmpty()) {
-                    initializeMethod
-                        .body()
-                        .addSnippet(
-                            "this.%s = %s;",
-                            memberSelectSnippet,
-                            initializeMapBinding(provisionBindings));
+                    initializeMethod.body().addSnippet("this.%s = %s;",
+                        memberSelectSnippet, initializeMapBinding(provisionBindings));
                   }
                 } else {
                   // TODO(beder): Implement producer map bindings.
@@ -743,21 +695,15 @@ private void initializeFrameworkTypes() {
                     initializeDelegateFactories(binding, initializeMethod);
                     if (!provisionBinding.factoryCreationStrategy().equals(ENUM_INSTANCE)
                         || provisionBinding.scope().isPresent()) {
-                      initializeMethod
-                          .body()
-                          .addSnippet(
-                              "this.%s = %s;",
-                              memberSelectSnippet,
-                              initializeFactoryForProvisionBinding(provisionBinding));
+                      initializeMethod.body().addSnippet("this.%s = %s;",
+                          memberSelectSnippet,
+                          initializeFactoryForProvisionBinding(provisionBinding));
                     }
                   } else if (binding instanceof ProductionBinding) {
                     ProductionBinding productionBinding = (ProductionBinding) binding;
-                    initializeMethod
-                        .body()
-                        .addSnippet(
-                            "this.%s = %s;",
-                            memberSelectSnippet,
-                            initializeFactoryForProductionBinding(productionBinding));
+                    initializeMethod.body().addSnippet("this.%s = %s;",
+                        memberSelectSnippet,
+                        initializeFactoryForProductionBinding(productionBinding));
                   } else {
                     throw new AssertionError();
                   }
@@ -768,8 +714,8 @@ private void initializeFrameworkTypes() {
             }
             break;
           case MEMBERS_INJECTION:
-            MembersInjectionBinding binding =
-                Iterables.getOnlyElement(resolvedBindings.membersInjectionBindings());
+            MembersInjectionBinding binding = Iterables.getOnlyElement(
+                resolvedBindings.membersInjectionBindings());
             if (!binding.injectionStrategy().equals(MembersInjectionBinding.Strategy.NO_OP)) {
               initializeDelegateFactories(binding, initializeMethod);
               initializeMethod
@@ -786,9 +732,7 @@ private void initializeFrameworkTypes() {
         bindingKeysWithInitializedProviders.add(bindingKey);
       }
       for (BindingKey key : bindingKeysWithDelegates) {
-        initializeMethod
-            .body()
-            .addSnippet(
+        initializeMethod.body().addSnippet(
                 "%s.setDelegatedProvider(%s);",
                 delegateFactoryVariableSnippet(key),
                 getMemberSelectSnippet(key));
@@ -803,15 +747,15 @@ private void initializeDelegateFactories(Binding binding, MethodWriter initializ
             .values()) {
       BindingKey dependencyKey =
           Iterables.getOnlyElement(
-              FluentIterable.from(requestsForKey)
-                  .transform(
-                      new Function<DependencyRequest, BindingKey>() {
-                        @Override
-                        public BindingKey apply(DependencyRequest request) {
-                          return request.bindingKey();
-                        }
-                      })
-                  .toSet());
+                  FluentIterable.from(requestsForKey)
+                      .transform(
+                          new Function<DependencyRequest, BindingKey>() {
+                            @Override
+                            public BindingKey apply(DependencyRequest request) {
+                              return request.bindingKey();
+                            }
+                          })
+                      .toSet());
       if (!getMemberSelect(dependencyKey).staticMember()
           && !isProviderInitialized(dependencyKey)
           && !bindingKeysWithDelegates.contains(dependencyKey)) {
@@ -857,10 +801,9 @@ private Snippet initializeFactoryForProvisionBinding(ProvisionBinding binding) {
             graph.componentDescriptor().dependencyMethodIndex().get(binding.bindingElement());
         if (binding.nullableType().isPresent()
             || nullableValidationType.equals(Diagnostic.Kind.WARNING)) {
-          Snippet nullableSnippet =
-              binding.nullableType().isPresent()
-                  ? Snippet.format("@%s ", TypeNames.forTypeMirror(binding.nullableType().get()))
-                  : Snippet.format("");
+          Snippet nullableSnippet = binding.nullableType().isPresent()
+              ? Snippet.format("@%s ", TypeNames.forTypeMirror(binding.nullableType().get()))
+              : Snippet.format("");
           return Snippet.format(
               Joiner.on('\n')
                   .join(
@@ -996,17 +939,13 @@ private Snippet initializeMembersInjectorForBinding(MembersInjectionBinding bind
     ImmutableList.Builder<Snippet> parameters = ImmutableList.builder();
     for (Collection<DependencyRequest> requestsForKey :
         SourceFiles.indexDependenciesByUnresolvedKey(types, dependencies).asMap().values()) {
-      BindingKey key =
-          Iterables.getOnlyElement(
-              FluentIterable.from(requestsForKey)
-                  .transform(
-                      new Function<DependencyRequest, BindingKey>() {
-                        @Override
-                        public BindingKey apply(DependencyRequest request) {
-                          return request.bindingKey();
-                        }
-                      })
-                  .toSet());
+      BindingKey key = Iterables.getOnlyElement(FluentIterable.from(requestsForKey)
+          .transform(new Function<DependencyRequest, BindingKey>() {
+            @Override public BindingKey apply(DependencyRequest request) {
+              return request.bindingKey();
+            }
+          })
+          .toSet());
       if (bindingKeysWithDelegates.contains(key)) {
         parameters.add(delegateFactoryVariableSnippet(key));
       } else {
@@ -1016,24 +955,22 @@ public BindingKey apply(DependencyRequest request) {
     return parameters.build();
   }
 
-  private List<Snippet> getProducerDependencyParameters(Iterable<DependencyRequest> dependencies) {
+  private List<Snippet> getProducerDependencyParameters(
+      Iterable<DependencyRequest> dependencies) {
     ImmutableList.Builder<Snippet> parameters = ImmutableList.builder();
     for (Collection<DependencyRequest> requestsForKey :
         SourceFiles.indexDependenciesByUnresolvedKey(types, dependencies).asMap().values()) {
-      BindingKey key =
-          Iterables.getOnlyElement(
-              FluentIterable.from(requestsForKey)
-                  .transform(
-                      new Function<DependencyRequest, BindingKey>() {
-                        @Override
-                        public BindingKey apply(DependencyRequest request) {
-                          return request.bindingKey();
-                        }
-                      }));
+      BindingKey key = Iterables.getOnlyElement(FluentIterable.from(requestsForKey)
+          .transform(new Function<DependencyRequest, BindingKey>() {
+            @Override public BindingKey apply(DependencyRequest request) {
+              return request.bindingKey();
+            }
+          }));
       ResolvedBindings resolvedBindings = graph.resolvedBindings().get(key);
       Class<?> frameworkClass =
           DependencyRequestMapper.FOR_PRODUCER.getFrameworkClass(requestsForKey);
-      if (FrameworkField.frameworkClassForResolvedBindings(resolvedBindings).equals(Provider.class)
+      if (FrameworkField.frameworkClassForResolvedBindings(resolvedBindings)
+              .equals(Provider.class)
           && frameworkClass.equals(Producer.class)) {
         parameters.add(
             Snippet.format(
@@ -1084,3 +1021,4 @@ private static String simpleVariableName(TypeElement typeElement) {
     return UPPER_CAMEL.to(LOWER_CAMEL, typeElement.getSimpleName().toString());
   }
 }
+
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
index 8ec742f63..2e5d869b1 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
@@ -18,19 +18,19 @@
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Equivalence;
+import com.google.common.base.Function;
 import com.google.common.base.Optional;
 import com.google.common.cache.Cache;
 import com.google.common.cache.CacheBuilder;
-import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ImmutableSetMultimap;
+import com.google.common.collect.Iterables;
 import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
 import com.google.common.collect.Sets;
 import dagger.Component;
-import dagger.Subcomponent;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
 import dagger.producers.ProductionComponent;
 import java.util.ArrayDeque;
@@ -69,22 +69,6 @@
   abstract ImmutableMap<BindingKey, ResolvedBindings> resolvedBindings();
   abstract ImmutableMap<ExecutableElement, BindingGraph> subgraphs();
 
-  /**
-   * Returns the set of modules that are owned by this graph regardless of whether or not any of
-   * their bindings are used in this graph. For graphs representing top-level {@link Component
-   * components}, this set will be the same as
-   * {@linkplain ComponentDescriptor#transitiveModules the component's transitive modules}. For
-   * {@linkplain Subcomponent subcomponents}, this set will be the transitive modules that are not
-   * owned by any of their ancestors.
-   */
-  abstract ImmutableSet<ModuleDescriptor> ownedModules();
-
-  ImmutableSet<TypeElement> ownedModuleTypes() {
-    return FluentIterable.from(ownedModules())
-        .transform(ModuleDescriptor.getModuleElement())
-        .toSet();
-  }
-
   /**
    * Returns the set of types necessary to implement the component, but are not part of the injected
    * graph.  This includes modules, component dependencies and an {@link Executor} in the case of
@@ -92,15 +76,13 @@
    */
   ImmutableSet<TypeElement> componentRequirements() {
     return new ImmutableSet.Builder<TypeElement>()
-        .addAll(ownedModuleTypes())
-        .addAll(componentDescriptor().dependencies())
-        .addAll(componentDescriptor().executorDependency().asSet())
-        .build();
-  }
-
-  ImmutableSet<TypeElement> availableDependencies() {
-    return new ImmutableSet.Builder<TypeElement>()
-        .addAll(componentDescriptor().transitiveModuleTypes())
+        .addAll(Iterables.transform(
+            componentDescriptor().transitiveModules(),
+            new Function<ModuleDescriptor, TypeElement>() {
+              @Override public TypeElement apply(ModuleDescriptor input) {
+                return input.moduleElement();
+              }
+            }))
         .addAll(componentDescriptor().dependencies())
         .addAll(componentDescriptor().executorDependency().asSet())
         .build();
@@ -129,11 +111,11 @@
     }
 
     BindingGraph create(ComponentDescriptor componentDescriptor) {
-      return create(Optional.<Resolver>absent(), componentDescriptor);
+      return create(Optional.<RequestResolver>absent(), componentDescriptor);
     }
 
-    private BindingGraph create(
-        Optional<Resolver> parentResolver, ComponentDescriptor componentDescriptor) {
+    private BindingGraph create(Optional<RequestResolver> parentResolver,
+        ComponentDescriptor componentDescriptor) {
       ImmutableSet.Builder<ProvisionBinding> explicitProvisionBindingsBuilder =
           ImmutableSet.builder();
       ImmutableSet.Builder<ProductionBinding> explicitProductionBindingsBuilder =
@@ -184,12 +166,11 @@ private BindingGraph create(
         }
       }
 
-      Resolver requestResolver =
-          new Resolver(
-              parentResolver,
-              componentDescriptor,
-              explicitBindingsByKey(explicitProvisionBindingsBuilder.build()),
-              explicitBindingsByKey(explicitProductionBindingsBuilder.build()));
+      RequestResolver requestResolver = new RequestResolver(
+          parentResolver,
+          componentDescriptor.wrappedScope(),
+          explicitBindingsByKey(explicitProvisionBindingsBuilder.build()),
+          explicitBindingsByKey(explicitProductionBindingsBuilder.build()));
       for (ComponentMethodDescriptor componentMethod : componentDescriptor.componentMethods()) {
         Optional<DependencyRequest> componentMethodRequest = componentMethod.dependencyRequest();
         if (componentMethodRequest.isPresent()) {
@@ -199,18 +180,16 @@ private BindingGraph create(
 
       ImmutableMap.Builder<ExecutableElement, BindingGraph> subgraphsBuilder =
           ImmutableMap.builder();
-      for (Entry<ComponentMethodDescriptor, ComponentDescriptor> subcomponentEntry :
+      for (Entry<ExecutableElement, ComponentDescriptor> subcomponentEntry :
           componentDescriptor.subcomponents().entrySet()) {
-        subgraphsBuilder.put(
-            subcomponentEntry.getKey().methodElement(),
+        subgraphsBuilder.put(subcomponentEntry.getKey(),
             create(Optional.of(requestResolver), subcomponentEntry.getValue()));
       }
 
       return new AutoValue_BindingGraph(
           componentDescriptor,
           requestResolver.getResolvedBindings(),
-          subgraphsBuilder.build(),
-          requestResolver.getOwnedModules());
+          subgraphsBuilder.build());
     }
 
     private <B extends ContributionBinding> ImmutableSetMultimap<Key, B> explicitBindingsByKey(
@@ -223,9 +202,9 @@ private BindingGraph create(
       return builder.build();
     }
 
-    private final class Resolver {
-      final Optional<Resolver> parentResolver;
-      final ComponentDescriptor componentDescriptor;
+    private final class RequestResolver {
+      final Optional<RequestResolver> parentResolver;
+      final Optional<Equivalence.Wrapper<AnnotationMirror>> targetScope;
       final ImmutableSetMultimap<Key, ProvisionBinding> explicitProvisionBindings;
       final ImmutableSet<ProvisionBinding> explicitProvisionBindingsSet;
       final ImmutableSetMultimap<Key, ProductionBinding> explicitProductionBindings;
@@ -234,15 +213,14 @@ private BindingGraph create(
       final Cache<BindingKey, Boolean> dependsOnLocalMultibindingsCache =
           CacheBuilder.newBuilder().<BindingKey, Boolean>build();
 
-      Resolver(
-          Optional<Resolver> parentResolver,
-          ComponentDescriptor componentDescriptor,
+      RequestResolver(Optional<RequestResolver> parentResolver,
+          Optional<Equivalence.Wrapper<AnnotationMirror>> targetScope,
           ImmutableSetMultimap<Key, ProvisionBinding> explicitProvisionBindings,
           ImmutableSetMultimap<Key, ProductionBinding> explicitProductionBindings) {
         assert parentResolver != null;
         this.parentResolver = parentResolver;
-        assert componentDescriptor != null;
-        this.componentDescriptor = componentDescriptor;
+        assert targetScope != null;
+        this.targetScope = targetScope;
         assert explicitProvisionBindings != null;
         this.explicitProvisionBindings = explicitProvisionBindings;
         this.explicitProvisionBindingsSet = ImmutableSet.copyOf(explicitProvisionBindings.values());
@@ -346,7 +324,7 @@ ResolvedBindings lookUpBindings(DependencyRequest request) {
        */
       private boolean isResolvedInParent(
           DependencyRequest request, ProvisionBinding provisionBinding) {
-        Optional<Resolver> owningResolver = getOwningResolver(provisionBinding);
+        Optional<RequestResolver> owningResolver = getOwningResolver(provisionBinding);
         if (owningResolver.isPresent() && !owningResolver.get().equals(this)) {
           owningResolver.get().resolve(request);
           return true;
@@ -383,8 +361,8 @@ private MembersInjectionBinding rollUpMembersInjectionBindings(Key key) {
         return membersInjectionBinding;
       }
 
-      private Optional<Resolver> getOwningResolver(ProvisionBinding provisionBinding) {
-        for (Resolver requestResolver : getResolverLineage().reverse()) {
+      private Optional<RequestResolver> getOwningResolver(ProvisionBinding provisionBinding) {
+        for (RequestResolver requestResolver : getResolverLineage().reverse()) {
           if (requestResolver.explicitProvisionBindingsSet.contains(provisionBinding)) {
             return Optional.of(requestResolver);
           }
@@ -395,8 +373,8 @@ private MembersInjectionBinding rollUpMembersInjectionBindings(Key key) {
         Optional<Equivalence.Wrapper<AnnotationMirror>> bindingScope =
             provisionBinding.wrappedScope();
         if (bindingScope.isPresent()) {
-          for (Resolver requestResolver : getResolverLineage().reverse()) {
-            if (bindingScope.equals(requestResolver.componentDescriptor.wrappedScope())) {
+          for (RequestResolver requestResolver : getResolverLineage().reverse()) {
+            if (bindingScope.equals(requestResolver.targetScope)) {
               return Optional.of(requestResolver);
             }
           }
@@ -405,9 +383,9 @@ private MembersInjectionBinding rollUpMembersInjectionBindings(Key key) {
       }
 
       /** Returns the resolver lineage from parent to child. */
-      private ImmutableList<Resolver> getResolverLineage() {
-        List<Resolver> resolverList = Lists.newArrayList();
-        for (Optional<Resolver> currentResolver = Optional.of(this);
+      private ImmutableList<RequestResolver> getResolverLineage() {
+        List<RequestResolver> resolverList = Lists.newArrayList();
+        for (Optional<RequestResolver> currentResolver = Optional.of(this);
             currentResolver.isPresent();
             currentResolver = currentResolver.get().parentResolver) {
           resolverList.add(currentResolver.get());
@@ -417,16 +395,18 @@ private MembersInjectionBinding rollUpMembersInjectionBindings(Key key) {
 
       private ImmutableSet<ProvisionBinding> getExplicitProvisionBindings(Key requestKey) {
         ImmutableSet.Builder<ProvisionBinding> explicitBindingsForKey = ImmutableSet.builder();
-        for (Resolver resolver : getResolverLineage()) {
-          explicitBindingsForKey.addAll(resolver.explicitProvisionBindings.get(requestKey));
+        for (RequestResolver resolver : getResolverLineage()) {
+          explicitBindingsForKey.addAll(
+              resolver.explicitProvisionBindings.get(requestKey));
         }
         return explicitBindingsForKey.build();
       }
 
       private ImmutableSet<ProductionBinding> getExplicitProductionBindings(Key requestKey) {
         ImmutableSet.Builder<ProductionBinding> explicitBindingsForKey = ImmutableSet.builder();
-        for (Resolver resolver : getResolverLineage()) {
-          explicitBindingsForKey.addAll(resolver.explicitProductionBindings.get(requestKey));
+        for (RequestResolver resolver : getResolverLineage()) {
+          explicitBindingsForKey.addAll(
+              resolver.explicitProductionBindings.get(requestKey));
         }
         return explicitBindingsForKey.build();
       }
@@ -560,20 +540,6 @@ private boolean isScoped(Binding binding) {
         }
         return resolvedBindingsBuilder.build();
       }
-
-      ImmutableSet<ModuleDescriptor> getInheritedModules() {
-        return parentResolver.isPresent()
-            ? Sets.union(
-                    parentResolver.get().getInheritedModules(),
-                    parentResolver.get().componentDescriptor.transitiveModules())
-                .immutableCopy()
-            : ImmutableSet.<ModuleDescriptor>of();
-      }
-
-      ImmutableSet<ModuleDescriptor> getOwnedModules() {
-        return Sets.difference(componentDescriptor.transitiveModules(), getInheritedModules())
-            .immutableCopy();
-      }
     }
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
index 0f940cfc8..3ddf36c45 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -544,22 +544,19 @@ private void validateBuilders() {
         return;
       }
 
-      Set<TypeElement> availableDependencies = subject.availableDependencies();
-      Set<TypeElement> requiredDependencies =
-          Sets.filter(
-              availableDependencies,
-              new Predicate<TypeElement>() {
-                @Override
-                public boolean apply(TypeElement input) {
-                  return !Util.componentCanMakeNewInstances(input);
-                }
-              });
+      Set<TypeElement> allDependents = subject.componentRequirements();
+      Set<TypeElement> requiredDependents =
+          Sets.filter(allDependents, new Predicate<TypeElement>() {
+            @Override public boolean apply(TypeElement input) {
+              return !Util.componentCanMakeNewInstances(input);
+            }
+          });
       final BuilderSpec spec = componentDesc.builderSpec().get();
       Map<TypeElement, ExecutableElement> allSetters = spec.methodMap();
 
       ErrorMessages.ComponentBuilderMessages msgs =
           ErrorMessages.builderMsgsFor(subject.componentDescriptor().kind());
-      Set<TypeElement> extraSetters = Sets.difference(allSetters.keySet(), availableDependencies);
+      Set<TypeElement> extraSetters = Sets.difference(allSetters.keySet(), allDependents);
       if (!extraSetters.isEmpty()) {
         Collection<ExecutableElement> excessMethods =
             Maps.filterKeys(allSetters, Predicates.in(extraSetters)).values();
@@ -573,7 +570,7 @@ public boolean apply(TypeElement input) {
             String.format(msgs.extraSetters(), formatted), spec.builderDefinitionType());
       }
 
-      Set<TypeElement> missingSetters = Sets.difference(requiredDependencies, allSetters.keySet());
+      Set<TypeElement> missingSetters = Sets.difference(requiredDependents, allSetters.keySet());
       if (!missingSetters.isEmpty()) {
         reportBuilder.addError(
             String.format(msgs.missingSetters(), missingSetters), spec.builderDefinitionType());
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
index dcb33aa95..2f20482d5 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
@@ -21,7 +21,6 @@
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Equivalence;
 import com.google.common.base.Optional;
-import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
@@ -29,7 +28,6 @@
 import dagger.Component;
 import dagger.Lazy;
 import dagger.MembersInjector;
-import dagger.Module;
 import dagger.Subcomponent;
 import dagger.producers.ProductionComponent;
 import java.lang.annotation.Annotation;
@@ -87,7 +85,7 @@
     /**
      * Returns the kind of an annotated element if it is annotated with one of the
      * {@linkplain #annotationType() annotation types}.
-     *
+     * 
      * @throws IllegalArgumentException if the element is annotated with more than one of the
      *     annotation types
      */
@@ -140,20 +138,8 @@ boolean isTopLevel() {
    */
   abstract ImmutableSet<TypeElement> dependencies();
 
-  /**
-   * The set of {@link ModuleDescriptor modules} declared directly in {@link Component#modules}.
-   * Use {@link #transitiveModules} to get the full set of modules available upon traversing
-   * {@link Module#includes}.
-   */
   abstract ImmutableSet<ModuleDescriptor> modules();
 
-  /**
-   * Returns the set of {@link ModuleDescriptor modules} declared in {@link Component#modules} and
-   * those reachable by traversing {@link Module#includes}.
-   *
-   * <p>Note that for subcomponents this <em>will not</em> include descriptors for any modules that
-   * are declared in parent components.
-   */
   ImmutableSet<ModuleDescriptor> transitiveModules() {
     Set<ModuleDescriptor> transitiveModules = new LinkedHashSet<>();
     for (ModuleDescriptor module : modules()) {
@@ -162,12 +148,6 @@ boolean isTopLevel() {
     return ImmutableSet.copyOf(transitiveModules);
   }
 
-  ImmutableSet<TypeElement> transitiveModuleTypes() {
-    return FluentIterable.from(transitiveModules())
-        .transform(ModuleDescriptor.getModuleElement())
-        .toSet();
-  }
-
   private static Set<ModuleDescriptor> addTransitiveModules(
       Set<ModuleDescriptor> transitiveModules, ModuleDescriptor module) {
     if (transitiveModules.add(module)) {
@@ -204,7 +184,7 @@ boolean isTopLevel() {
    */
   abstract Optional<Equivalence.Wrapper<AnnotationMirror>> wrappedScope();
 
-  abstract ImmutableMap<ComponentMethodDescriptor, ComponentDescriptor> subcomponents();
+  abstract ImmutableMap<ExecutableElement, ComponentDescriptor> subcomponents();
 
   abstract ImmutableSet<ComponentMethodDescriptor> componentMethods();
 
@@ -305,7 +285,7 @@ private ComponentDescriptor create(TypeElement componentDefinitionType, Kind kin
       ImmutableSet.Builder<ComponentMethodDescriptor> componentMethodsBuilder =
           ImmutableSet.builder();
 
-      ImmutableMap.Builder<ComponentMethodDescriptor, ComponentDescriptor> subcomponentDescriptors =
+      ImmutableMap.Builder<ExecutableElement, ComponentDescriptor> subcomponentDescriptors =
           ImmutableMap.builder();
       for (ExecutableElement componentMethod : unimplementedMethods) {
         ExecutableType resolvedMethod =
@@ -315,18 +295,13 @@ private ComponentDescriptor create(TypeElement componentDefinitionType, Kind kin
         componentMethodsBuilder.add(componentMethodDescriptor);
         switch (componentMethodDescriptor.kind()) {
           case SUBCOMPONENT:
-            subcomponentDescriptors.put(
-                componentMethodDescriptor,
-                create(
-                    MoreElements.asType(MoreTypes.asElement(resolvedMethod.getReturnType())),
+            subcomponentDescriptors.put(componentMethod,
+                create(MoreElements.asType(MoreTypes.asElement(resolvedMethod.getReturnType())),
                     Kind.SUBCOMPONENT));
             break;
           case SUBCOMPONENT_BUILDER:
-            subcomponentDescriptors.put(
-                componentMethodDescriptor,
-                create(
-                    MoreElements.asType(
-                        MoreTypes.asElement(resolvedMethod.getReturnType()).getEnclosingElement()),
+            subcomponentDescriptors.put(componentMethod, create(MoreElements.asType(
+                MoreTypes.asElement(resolvedMethod.getReturnType()).getEnclosingElement()),
                     Kind.SUBCOMPONENT));
             break;
           default: // nothing special to do for other methods.
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentHierarchyValidator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentHierarchyValidator.java
deleted file mode 100644
index 8fb4191a5..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentHierarchyValidator.java
+++ /dev/null
@@ -1,115 +0,0 @@
-/*
- * Copyright (C) 2015 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen;
-
-import com.google.auto.common.MoreTypes;
-import com.google.common.collect.ImmutableMap;
-import com.google.common.collect.Maps;
-import com.google.common.collect.Sets;
-import dagger.internal.codegen.ComponentDescriptor.BuilderSpec;
-import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
-import java.util.Map;
-import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.TypeElement;
-import javax.lang.model.element.VariableElement;
-
-import static com.google.common.base.Functions.constant;
-
-/**
- * Validates the relationships between parent components and subcomponents.
- */
-final class ComponentHierarchyValidator {
-  ValidationReport<TypeElement> validate(ComponentDescriptor componentDescriptor) {
-    return validateSubcomponentMethods(
-        componentDescriptor,
-        Maps.toMap(
-            componentDescriptor.transitiveModuleTypes(),
-            constant(componentDescriptor.componentDefinitionType())));
-  }
-
-  private ValidationReport<TypeElement> validateSubcomponentMethods(
-      ComponentDescriptor componentDescriptor,
-      Map<TypeElement, TypeElement> existingModuleToOwners) {
-    ValidationReport.Builder<TypeElement> reportBuilder =
-        ValidationReport.about(componentDescriptor.componentDefinitionType());
-    for (Map.Entry<ComponentMethodDescriptor, ComponentDescriptor> subcomponentEntry :
-        componentDescriptor.subcomponents().entrySet()) {
-      ComponentMethodDescriptor subcomponentMethodDescriptor = subcomponentEntry.getKey();
-      ComponentDescriptor subcomponentDescriptor = subcomponentEntry.getValue();
-      // validate the way that we create subcomponents
-      switch (subcomponentMethodDescriptor.kind()) {
-        case SUBCOMPONENT:
-          for (VariableElement factoryMethodParameter :
-              subcomponentMethodDescriptor.methodElement().getParameters()) {
-            TypeElement origininatingComponent =
-                existingModuleToOwners.get(
-                    MoreTypes.asTypeElement(factoryMethodParameter.asType()));
-            if (origininatingComponent != null) {
-              /* Factory method tries to pass a module that is already present in the parent.
-               * This is an error. */
-              reportBuilder.addError(
-                  String.format(
-                      "This module is present in %s. Subcomponents cannot use an instance of a "
-                          + "module that differs from its parent.",
-                      origininatingComponent.getQualifiedName()),
-                  factoryMethodParameter);
-            }
-          }
-          break;
-        case SUBCOMPONENT_BUILDER:
-          BuilderSpec subcomponentBuilderSpec = subcomponentDescriptor.builderSpec().get();
-          for (Map.Entry<TypeElement, ExecutableElement> builderMethodEntry :
-              subcomponentBuilderSpec.methodMap().entrySet()) {
-            TypeElement origininatingComponent =
-                existingModuleToOwners.get(builderMethodEntry.getKey());
-            if (origininatingComponent != null) {
-              /* A subcomponent builder allows you to pass a module that is already present in the
-               * parent.  This can't be an error because it might be valid in _other_ components, so
-               * we warn here. */
-              ExecutableElement builderMethodElement = builderMethodEntry.getValue();
-              /* TODO(gak): consider putting this on the builder method directly if it's in the
-               * component being compiled */
-              reportBuilder.addWarning(
-                  String.format(
-                      "This module is present in %s. Subcomponents cannot use an instance of a "
-                          + "module that differs from its parent. The implementation of %s "
-                          + "in this component will throw %s.",
-                      origininatingComponent.getQualifiedName(),
-                      builderMethodElement.getSimpleName(),
-                      UnsupportedOperationException.class.getSimpleName()),
-                  builderMethodElement);
-            }
-          }
-          break;
-        default:
-          throw new AssertionError();
-      }
-      reportBuilder.addSubreport(
-          validateSubcomponentMethods(
-              subcomponentDescriptor,
-              new ImmutableMap.Builder<TypeElement, TypeElement>()
-                  .putAll(existingModuleToOwners)
-                  .putAll(
-                      Maps.toMap(
-                          Sets.difference(
-                              subcomponentDescriptor.transitiveModuleTypes(),
-                              existingModuleToOwners.keySet()),
-                          constant(subcomponentDescriptor.componentDefinitionType())))
-                  .build()));
-    }
-    return reportBuilder.build();
-  }
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java
index 93128f58f..c9c8d5514 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java
@@ -50,14 +50,12 @@
       ComponentValidator subcomponentValidator,
       BuilderValidator componentBuilderValidator,
       BuilderValidator subcomponentBuilderValidator,
-      ComponentHierarchyValidator componentHierarchyValidator,
       BindingGraphValidator bindingGraphValidator,
       Factory componentDescriptorFactory,
       BindingGraph.Factory bindingGraphFactory,
       ComponentGenerator componentGenerator) {
     super(
         messager,
-        componentHierarchyValidator,
         bindingGraphValidator,
         componentDescriptorFactory,
         bindingGraphFactory,
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
index b4e535a82..cea6fe232 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -148,21 +148,23 @@ public SourceVersion getSupportedSourceVersion() {
         productionBindingFactory);
 
     MapKeyGenerator mapKeyGenerator = new MapKeyGenerator(filer);
-    ComponentHierarchyValidator componentHierarchyValidator = new ComponentHierarchyValidator();
-    BindingGraphValidator bindingGraphValidator =
-        new BindingGraphValidator(
-            types,
-            injectBindingRegistry,
-            scopeValidationType(processingEnv),
-            nullableDiagnosticType,
-            provisionBindingFormatter,
-            productionBindingFormatter,
-            methodSignatureFormatter,
-            dependencyRequestFormatter,
-            keyFormatter);
+    BindingGraphValidator bindingGraphValidator = new BindingGraphValidator(
+        types,
+        injectBindingRegistry,
+        scopeValidationType(processingEnv),
+        nullableDiagnosticType,
+        provisionBindingFormatter,
+        productionBindingFormatter,
+        methodSignatureFormatter,
+        dependencyRequestFormatter,
+        keyFormatter);
 
     return ImmutableList.<ProcessingStep>of(
-        new MapKeyProcessingStep(messager, types, mapKeyValidator, mapKeyGenerator),
+        new MapKeyProcessingStep(
+            messager,
+            types,
+            mapKeyValidator,
+            mapKeyGenerator),
         new InjectProcessingStep(
             messager,
             injectConstructorValidator,
@@ -183,7 +185,6 @@ public SourceVersion getSupportedSourceVersion() {
             subcomponentValidator,
             componentBuilderValidator,
             subcomponentBuilderValidator,
-            componentHierarchyValidator,
             bindingGraphValidator,
             componentDescriptorFactory,
             bindingGraphFactory,
@@ -197,7 +198,6 @@ public SourceVersion getSupportedSourceVersion() {
         new ProductionComponentProcessingStep(
             messager,
             productionComponentValidator,
-            componentHierarchyValidator,
             bindingGraphValidator,
             componentDescriptorFactory,
             bindingGraphFactory,
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProductionComponentProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/ProductionComponentProcessingStep.java
index c7bd2cc8c..c7cd790b8 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProductionComponentProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProductionComponentProcessingStep.java
@@ -39,14 +39,12 @@
   ProductionComponentProcessingStep(
       Messager messager,
       ProductionComponentValidator componentValidator,
-      ComponentHierarchyValidator componentHierarchyValidator,
       BindingGraphValidator bindingGraphValidator,
       ComponentDescriptor.Factory componentDescriptorFactory,
       BindingGraph.Factory bindingGraphFactory,
       ComponentGenerator componentGenerator) {
     super(
         messager,
-        componentHierarchyValidator,
         bindingGraphValidator,
         componentDescriptorFactory,
         bindingGraphFactory,
diff --git a/compiler/src/main/java/dagger/internal/codegen/ValidationReport.java b/compiler/src/main/java/dagger/internal/codegen/ValidationReport.java
index e17406755..f79ec7562 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ValidationReport.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ValidationReport.java
@@ -21,8 +21,6 @@
 import javax.annotation.processing.Messager;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
-import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.util.SimpleElementVisitor6;
 import javax.tools.Diagnostic;
 import javax.tools.Diagnostic.Kind;
 
@@ -80,7 +78,7 @@ void printMessagesTo(Messager messager) {
           messager.printMessage(item.kind(), item.message(), item.element());
         }
       } else {
-        String message = String.format("[%s] %s", elementString(item.element()), item.message());
+        String message = String.format("[%s] %s", item.element(), item.message());
         if (item.annotation().isPresent()) {
           messager.printMessage(item.kind(), message, subject(), item.annotation().get());
         } else {
@@ -93,22 +91,6 @@ void printMessagesTo(Messager messager) {
     }
   }
 
-  private static String elementString(Element element) {
-    return element.accept(
-        new SimpleElementVisitor6<String, Void>() {
-          @Override
-          protected String defaultAction(Element e, Void p) {
-            return e.toString();
-          }
-
-          @Override
-          public String visitExecutable(ExecutableElement e, Void p) {
-            return e.getEnclosingElement().accept(this, null) + '.' + e.toString();
-          }
-        },
-        null);
-  }
-
   private static boolean isEnclosedIn(Element parent, Element child) {
     Element current = child;
     while (current != null) {
diff --git a/compiler/src/test/java/dagger/internal/codegen/RepeatedModuleValidationTest.java b/compiler/src/test/java/dagger/internal/codegen/RepeatedModuleValidationTest.java
deleted file mode 100644
index aa560b835..000000000
--- a/compiler/src/test/java/dagger/internal/codegen/RepeatedModuleValidationTest.java
+++ /dev/null
@@ -1,121 +0,0 @@
-package dagger.internal.codegen;
-
-import com.google.common.collect.ImmutableList;
-import com.google.testing.compile.JavaFileObjects;
-import javax.tools.JavaFileObject;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-import static com.google.common.truth.Truth.assertAbout;
-import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
-
-@RunWith(JUnit4.class)
-public class RepeatedModuleValidationTest {
-  private static final JavaFileObject MODULE_FILE =
-      JavaFileObjects.forSourceLines(
-          "test.TestModule",
-          "package test;",
-          "",
-          "import dagger.Module;",
-          "",
-          "@Module",
-          "final class TestModule {}");
-
-  @Test
-  public void moduleRepeatedInSubcomponentFactoryMethod() {
-    JavaFileObject subcomponentFile =
-        JavaFileObjects.forSourceLines(
-            "test.TestSubcomponent",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent(modules = TestModule.class)",
-            "interface TestSubcomponent {",
-            "}");
-    JavaFileObject componentFile =
-        JavaFileObjects.forSourceLines(
-            "test.TestComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "",
-            "@Component(modules = TestModule.class)",
-            "interface TestComponent {",
-            "  TestSubcomponent newTestSubcomponent(TestModule module);",
-            "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(MODULE_FILE, subcomponentFile, componentFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("This module is present in test.TestComponent.")
-        .in(componentFile)
-        .onLine(7)
-        .atColumn(51);
-  }
-
-  @Test
-  public void moduleRepeatedInSubcomponentBuilderMethod() {
-    JavaFileObject subcomponentFile =
-        JavaFileObjects.forSourceLines(
-            "test.TestSubcomponent",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent(modules = TestModule.class)",
-            "interface TestSubcomponent {",
-            "  @Subcomponent.Builder",
-            "  interface Builder {",
-            "    Builder testModule(TestModule testModule);",
-            "    TestSubcomponent build();",
-            "  }",
-            "}");
-    JavaFileObject componentFile =
-        JavaFileObjects.forSourceLines(
-            "test.TestComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "",
-            "@Component(modules = TestModule.class)",
-            "interface TestComponent {",
-            "  TestSubcomponent.Builder newTestSubcomponentBuilder();",
-            "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(MODULE_FILE, subcomponentFile, componentFile))
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError();
-    // TOOD(gak): assert about the warning when we have that ability
-  }
-
-  @Test
-  public void moduleRepeatedButNotPassed() {
-    JavaFileObject subcomponentFile =
-        JavaFileObjects.forSourceLines(
-            "test.TestSubcomponent",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent(modules = TestModule.class)",
-            "interface TestSubcomponent {",
-            "}");
-    JavaFileObject componentFile =
-        JavaFileObjects.forSourceLines(
-            "test.TestComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "",
-            "@Component(modules = TestModule.class)",
-            "interface TestComponent {",
-            "  TestSubcomponent newTestSubcomponent();",
-            "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(MODULE_FILE, subcomponentFile, componentFile))
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError();
-  }
-}
