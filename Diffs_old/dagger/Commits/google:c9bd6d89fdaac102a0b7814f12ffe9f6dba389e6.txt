diff --git a/compiler/src/it/functional-tests/src/main/java/test/BasicComponent.java b/compiler/src/it/functional-tests/src/main/java/test/BasicComponent.java
index b9b54d914..5629a0f09 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/BasicComponent.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/BasicComponent.java
@@ -74,6 +74,7 @@
   InjectedThing injectedThing();
   Provider<InjectedThing> injectedThingProvider();
   Lazy<InjectedThing> lazyInjectedThing();
+  Provider<Lazy<InjectedThing>> lazyInjectedThingProvider();
   MembersInjector<InjectedThing> injectedThingMembersInjector();
   
   @Nullable Object nullObject();
diff --git a/compiler/src/it/functional-tests/src/main/java/test/InjectedThing.java b/compiler/src/it/functional-tests/src/main/java/test/InjectedThing.java
index 73a46e8aa..438b69f16 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/InjectedThing.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/InjectedThing.java
@@ -88,6 +88,7 @@
   @Inject Thing thing;
   @Inject Provider<Thing> thingProvider;
   @Inject Lazy<Thing> lazyThing;
+  @Inject Provider<Lazy<Thing>> lazyThingProvider;
   @Inject MembersInjector<Thing> thingMembersInjector;
 
   @Inject InjectedThing(
diff --git a/compiler/src/it/functional-tests/src/test/java/test/BasicTest.java b/compiler/src/it/functional-tests/src/test/java/test/BasicTest.java
index 4514457c1..cc3c52584 100644
--- a/compiler/src/it/functional-tests/src/test/java/test/BasicTest.java
+++ b/compiler/src/it/functional-tests/src/test/java/test/BasicTest.java
@@ -15,6 +15,8 @@
 */
 package test;
 
+import dagger.Lazy;
+import javax.inject.Provider;
 import org.junit.experimental.theories.DataPoint;
 import org.junit.experimental.theories.Theories;
 import org.junit.experimental.theories.Theory;
@@ -120,4 +122,16 @@ public void nullableInjection(BasicComponent basicComponent) {
     assertThat(basicComponent.nullObjectProvider().get()).isNull();
     assertThat(basicComponent.lazyNullObject().get()).isNull();
   }
+  
+  @Theory
+  public void providerOfLazy(BasicComponent basicComponent) {
+    Provider<Lazy<InjectedThing>> lazyInjectedThingProvider =
+        basicComponent.lazyInjectedThingProvider();
+    Lazy<InjectedThing> lazyInjectedThing1 = lazyInjectedThingProvider.get();
+    Lazy<InjectedThing> lazyInjectedThing2 = lazyInjectedThingProvider.get();
+    assertThat(lazyInjectedThing2).isNotSameAs(lazyInjectedThing1);
+    assertThat(lazyInjectedThing1.get()).isSameAs(lazyInjectedThing1.get());
+    assertThat(lazyInjectedThing2.get()).isSameAs(lazyInjectedThing2.get());
+    assertThat(lazyInjectedThing2.get()).isNotSameAs(lazyInjectedThing1.get());
+  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
index 31ef80248..fe7d31792 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -695,6 +695,7 @@ private void implementInterfaceMethods() {
             case PRODUCED:
             case PRODUCER:
             case PROVIDER:
+            case PROVIDER_OF_LAZY:
             case FUTURE:
               interfaceMethod.addStatement(
                   "return $L",
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
index b59d2caca..f25b941a8 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
@@ -28,6 +28,7 @@
 import dagger.Lazy;
 import dagger.MembersInjector;
 import dagger.Provides;
+import dagger.internal.codegen.DependencyRequest.Factory.KindAndType;
 import dagger.producers.Produced;
 import dagger.producers.Producer;
 import dagger.producers.internal.AbstractProducer;
@@ -47,6 +48,8 @@
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.SimpleTypeVisitor7;
 
+import static com.google.auto.common.MoreTypes.asDeclared;
+import static com.google.auto.common.MoreTypes.isType;
 import static com.google.auto.common.MoreTypes.isTypeOf;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
@@ -74,22 +77,25 @@
   enum Kind {
     /** A default request for an instance.  E.g.: {@code Blah} */
     INSTANCE,
-    
+
     /** A request for a {@link Provider}.  E.g.: {@code Provider<Blah>} */
     PROVIDER(Provider.class),
-    
+
     /** A request for a {@link Lazy}.  E.g.: {@code Lazy<Blah>} */
     LAZY(Lazy.class),
-    
+
+    /** A request for a {@link Provider} of a {@link Lazy}. E.g.: {@code Provider<Lazy<Blah>>} */
+    PROVIDER_OF_LAZY,
+
     /** A request for a {@link MembersInjector}.  E.g.: {@code MembersInjector<Blah>} */
     MEMBERS_INJECTOR(MembersInjector.class),
-    
+
     /** A request for a {@link Producer}.  E.g.: {@code Producer<Blah>} */
     PRODUCER(Producer.class),
-    
+
     /** A request for a {@link Produced}.  E.g.: {@code Produced<Blah>} */
     PRODUCED(Produced.class),
-    
+
     /**
      * A request for a {@link ListenableFuture}.  E.g.: {@code ListenableFuture<Blah>}.
      * These can only be requested by component interfaces.
@@ -106,6 +112,23 @@
     Kind() {
       this.frameworkClass = Optional.absent();
     }
+    
+    /**
+     * If {@code type}'s raw type is {@link #frameworkClass}, returns a {@link KindAndType} with
+     * this kind that represents the dependency request.
+     */
+    Optional<KindAndType> from(TypeMirror type) {
+      return frameworkClass.isPresent() && isType(type) && isTypeOf(frameworkClass.get(), type)
+          ? Optional.of(this.ofType(getOnlyElement(asDeclared(type).getTypeArguments())))
+          : Optional.<KindAndType>absent();
+    }
+
+    /**
+     * Returns a {@link KindAndType} with this kind and {@code type} type.
+     */
+    KindAndType ofType(TypeMirror type) {
+      return new AutoValue_DependencyRequest_Factory_KindAndType(this, type);
+    }
   }
 
   abstract Kind kind();
@@ -116,6 +139,7 @@ BindingKey bindingKey() {
       case INSTANCE:
       case LAZY:
       case PROVIDER:
+      case PROVIDER_OF_LAZY:
       case PRODUCER:
       case PRODUCED:
       case FUTURE:
@@ -403,6 +427,31 @@ private DependencyRequest newDependencyRequest(
     static abstract class KindAndType {
       abstract Kind kind();
       abstract TypeMirror type();
+
+      static Optional<KindAndType> from(TypeMirror type) {
+        for (Kind kind : Kind.values()) {
+          Optional<KindAndType> kindAndType = kind.from(type);
+          if (kindAndType.isPresent()) {
+            return kindAndType.get().maybeProviderOfLazy().or(kindAndType);
+          }
+        }
+        return Optional.absent();
+      }
+
+      /**
+       * If {@code kindAndType} represents a {@link Kind#PROVIDER} of a {@code Lazy<T>} for some
+       * type {@code T}, then this method returns ({@link Kind#PROVIDER_OF_LAZY}, {@code T}).
+       */
+      private Optional<KindAndType> maybeProviderOfLazy() {
+        if (kind().equals(Kind.PROVIDER)) {
+          Optional<KindAndType> providedKindAndType = from(type());
+          if (providedKindAndType.isPresent()
+              && providedKindAndType.get().kind().equals(Kind.LAZY)) {
+            return Optional.of(Kind.PROVIDER_OF_LAZY.ofType(providedKindAndType.get().type()));
+          }
+        }
+        return Optional.absent();
+      }
     }
 
     /**
@@ -428,14 +477,7 @@ public KindAndType visitExecutable(ExecutableType executableType, Void p) {
 
             @Override
             public KindAndType visitDeclared(DeclaredType declaredType, Void p) {
-              for (Kind kind : Kind.values()) {
-                if (kind.frameworkClass.isPresent()
-                    && isTypeOf(kind.frameworkClass.get(), declaredType)) {
-                  return new AutoValue_DependencyRequest_Factory_KindAndType(
-                      kind, Iterables.getOnlyElement(declaredType.getTypeArguments()));
-                }
-              }
-              return defaultAction(declaredType, p);
+              return KindAndType.from(declaredType).or(defaultAction(declaredType, p));
             }
 
             @Override
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyRequestMapper.java b/compiler/src/main/java/dagger/internal/codegen/DependencyRequestMapper.java
index 9ca294206..c57bed0b0 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DependencyRequestMapper.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyRequestMapper.java
@@ -60,6 +60,7 @@
       switch (request.kind()) {
         case INSTANCE:
         case PROVIDER:
+        case PROVIDER_OF_LAZY:
         case LAZY:
           return Provider.class;
         case MEMBERS_INJECTOR:
@@ -83,6 +84,7 @@
         case PRODUCER:
           return Producer.class;
         case PROVIDER:
+        case PROVIDER_OF_LAZY:
         case LAZY:
           return Provider.class;
         case MEMBERS_INJECTOR:
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyVariableNamer.java b/compiler/src/main/java/dagger/internal/codegen/DependencyVariableNamer.java
index b12a854d9..81a2d13eb 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DependencyVariableNamer.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyVariableNamer.java
@@ -19,6 +19,8 @@
 import com.google.common.base.CaseFormat;
 import com.google.common.base.Function;
 import dagger.Lazy;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
 import javax.inject.Provider;
 
 /**
@@ -32,6 +34,8 @@
  */
 //TODO(gak): develop the heuristics to get better names
 final class DependencyVariableNamer implements Function<DependencyRequest, String> {
+  private static final Pattern LAZY_PROVIDER_PATTERN = Pattern.compile("lazy(\\w+)Provider");
+
   @Override
   public String apply(DependencyRequest dependency) {
     if (dependency.overriddenVariableName().isPresent()) {
@@ -48,6 +52,12 @@ public String apply(DependencyRequest dependency) {
         return variableName.startsWith("lazy") && !variableName.equals("lazy")
             ? toLowerCamel(variableName.substring(4))
             : variableName;
+      case PROVIDER_OF_LAZY:
+        Matcher matcher = LAZY_PROVIDER_PATTERN.matcher(variableName);
+        if (matcher.matches()) {
+          return toLowerCamel(matcher.group(1));
+        }
+        // fall through
       case PROVIDER:
         return variableName.endsWith("Provider") && !variableName.equals("Provider")
             ? variableName.substring(0, variableName.length() - 8)
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
index 366240948..ab7c64937 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
@@ -38,6 +38,7 @@
 import static com.google.common.base.Preconditions.checkArgument;
 import static dagger.internal.codegen.FrameworkDependency.frameworkDependenciesForBinding;
 import static dagger.internal.codegen.TypeNames.DOUBLE_CHECK;
+import static dagger.internal.codegen.TypeNames.PROVIDER_OF_LAZY;
 
 /**
  * Utilities for generating files.
@@ -133,6 +134,8 @@ static CodeBlock frameworkTypeUsageStatement(
       case PRODUCER:
       case MEMBERS_INJECTOR:
         return CodeBlock.of("$L", frameworkTypeMemberSelect);
+      case PROVIDER_OF_LAZY:
+        return CodeBlock.of("$T.create($L)", PROVIDER_OF_LAZY, frameworkTypeMemberSelect);
       default:
         throw new AssertionError();
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/TypeNames.java b/compiler/src/main/java/dagger/internal/codegen/TypeNames.java
index 8135f4416..f16e38364 100644
--- a/compiler/src/main/java/dagger/internal/codegen/TypeNames.java
+++ b/compiler/src/main/java/dagger/internal/codegen/TypeNames.java
@@ -30,6 +30,7 @@
 import dagger.internal.MapFactory;
 import dagger.internal.MapProviderFactory;
 import dagger.internal.MembersInjectors;
+import dagger.internal.ProviderOfLazy;
 import dagger.internal.SetFactory;
 import dagger.internal.SingleCheck;
 import dagger.producers.Produced;
@@ -77,11 +78,12 @@
   static final ClassName PRODUCER = ClassName.get(Producer.class);
   static final ClassName PRODUCERS = ClassName.get(Producers.class);
   static final ClassName PROVIDER = ClassName.get(Provider.class);
-  static final ClassName SINGLE_CHECK = ClassName.get(SingleCheck.class);
+  static final ClassName PROVIDER_OF_LAZY = ClassName.get(ProviderOfLazy.class);
   static final ClassName SET = ClassName.get(Set.class);
   static final ClassName SET_FACTORY = ClassName.get(SetFactory.class);
   static final ClassName SET_OF_PRODUCED_PRODUCER = ClassName.get(SetOfProducedProducer.class);
   static final ClassName SET_PRODUCER = ClassName.get(SetProducer.class);
+  static final ClassName SINGLE_CHECK = ClassName.get(SingleCheck.class);
   static final ClassName STRING = ClassName.get(String.class);
   static final ClassName UNSUPPORTED_OPERATION_EXCEPTION =
       ClassName.get(UnsupportedOperationException.class);
diff --git a/core/src/main/java/dagger/internal/ProviderOfLazy.java b/core/src/main/java/dagger/internal/ProviderOfLazy.java
new file mode 100644
index 000000000..77d4961dd
--- /dev/null
+++ b/core/src/main/java/dagger/internal/ProviderOfLazy.java
@@ -0,0 +1,53 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal;
+
+import dagger.Lazy;
+import javax.inject.Provider;
+
+import static dagger.internal.Preconditions.checkNotNull;
+
+/**
+ * A {@link Provider} of {@link Lazy} instances that each delegate to a given {@link Provider}.
+ */
+public final class ProviderOfLazy<T> implements Provider<Lazy<T>> {
+
+  private final Provider<T> provider;
+
+  private ProviderOfLazy(Provider<T> provider) {
+    assert provider != null;
+    this.provider = provider;
+  }
+
+  /**
+   * Returns a new instance of {@link Lazy Lazy&lt;T&gt;}, which calls {@link Provider#get()} at
+   * most once on the {@link Provider} held by this object.
+   */
+  @Override
+  public Lazy<T> get() {
+    return DoubleCheck.lazy(provider);
+  }
+
+  /**
+   * Creates a new {@link Provider Provider&lt;Lazy&lt;T&gt;&gt;} that decorates the given
+   * {@link Provider}.
+   *
+   * @see #get()
+   */
+  public static <T> Provider<Lazy<T>> create(Provider<T> provider) {
+    return new ProviderOfLazy<T>(checkNotNull(provider));
+  }
+}
