diff --git a/java/dagger/internal/codegen/ComponentCreatorImplementationFactory.java b/java/dagger/internal/codegen/ComponentCreatorImplementationFactory.java
index 17ed528d7..377ca0538 100644
--- a/java/dagger/internal/codegen/ComponentCreatorImplementationFactory.java
+++ b/java/dagger/internal/codegen/ComponentCreatorImplementationFactory.java
@@ -131,6 +131,14 @@ final BindingGraph graph() {
       return componentImplementation.graph();
     }
 
+    /**
+     * The set of requirements that must be passed to the component's constructor in the order
+     * they must be passed.
+     */
+    final ImmutableSet<ComponentRequirement> componentConstructorRequirements() {
+      return componentImplementation.requirements();
+    }
+
     /** Returns the requirements that have setter methods on the creator type. */
     abstract ImmutableSet<ComponentRequirement> setterMethods();
 
@@ -153,7 +161,7 @@ final BindingGraph graph() {
      */
     private Set<ComponentRequirement> neededUserSettableRequirements() {
       return Sets.intersection(
-          userSettableRequirements().keySet(), componentImplementation.requirements());
+          userSettableRequirements().keySet(), componentConstructorRequirements());
     }
 
     private void setModifiers() {
@@ -282,13 +290,18 @@ MethodSpec factoryMethod() {
 
       ImmutableMap<ComponentRequirement, String> factoryMethodParameters =
           factoryMethodParameters();
-      neededUserSettableRequirements()
+      userSettableRequirements()
+          .keySet()
           .forEach(
               requirement -> {
-                if (fields.containsKey(requirement)) {
+                if (fields.containsKey(requirement)
+                    && componentConstructorRequirements().contains(requirement)) {
+                  // In AOT mode, there can be a field for a requirement even if the component's
+                  // constructor doesn't need it, because the base class for the creator was created
+                  // before the final graph for the component was known.
                   FieldSpec field = fields.get(requirement);
                   addNullHandlingForField(requirement, field, factoryMethod);
-                } else {
+                } else if (factoryMethodParameters.containsKey(requirement)) {
                   String parameterName = factoryMethodParameters.get(requirement);
                   addNullHandlingForParameter(requirement, parameterName, factoryMethod);
                 }
@@ -338,7 +351,7 @@ private void addNullHandlingForParameter(
 
     private CodeBlock componentConstructorArgs(
         ImmutableMap<ComponentRequirement, String> factoryMethodParameters) {
-      return componentImplementation.requirements().stream()
+      return componentConstructorRequirements().stream()
           .map(
               requirement -> {
                 if (fields.containsKey(requirement)) {
@@ -438,7 +451,7 @@ private RequirementStatus requirementStatus(ComponentRequirement requirement) {
         return RequirementStatus.IMPLEMENTED_IN_SUPERTYPE;
       }
 
-      return componentImplementation.requirements().contains(requirement)
+      return componentConstructorRequirements().contains(requirement)
           ? RequirementStatus.NEEDED
           : RequirementStatus.UNNEEDED;
     }
@@ -448,7 +461,7 @@ private RequirementStatus requirementStatus(ComponentRequirement requirement) {
      * component. This creator is not allowed to set such a module.
      */
     final boolean isRepeatedModule(ComponentRequirement requirement) {
-      return !componentImplementation.requirements().contains(requirement)
+      return !componentConstructorRequirements().contains(requirement)
           && !isOwnedModule(requirement);
     }
 
@@ -490,7 +503,7 @@ private boolean hasBaseCreatorImplementation() {
       return Maps.toMap(
           setterMethods(),
           requirement ->
-              componentImplementation.requirements().contains(requirement)
+              componentConstructorRequirements().contains(requirement)
                   ? RequirementStatus.NEEDED
                   : RequirementStatus.UNNEEDED);
     }
diff --git a/javatests/dagger/functional/factory/FactoryImplicitModulesTest.java b/javatests/dagger/functional/factory/FactoryImplicitModulesTest.java
index 3cc163064..143f32244 100644
--- a/javatests/dagger/functional/factory/FactoryImplicitModulesTest.java
+++ b/javatests/dagger/functional/factory/FactoryImplicitModulesTest.java
@@ -136,17 +136,19 @@ public void concreteModuleThatCouldBeAbstract_withFactoryParameter() {
   }
 
   @Test
-  public void concreteModuleThatCouldBeAbstract_withFactoryParameter_doesNotFailOnNull() {
-    // TODO(cgdecker): Is this really what we want to happen?
-    // Builders allow there to be a setter for such a module; the setter checks that the argument
-    // is not null but otherwise ignores it. If nothing else, we should probably throw if the arg
-    // is null. But it's not clear to me that we should even allow such a parameter for a factory,
-    // since unlike a builder, where the setter can just not be called, a factory doesn't give the
-    // option of not passing *something* for the unused parameter.
-    ConcreteModuleThatCouldBeAbstractWithFactoryParameterComponent component =
-        DaggerFactoryImplicitModulesTest_ConcreteModuleThatCouldBeAbstractWithFactoryParameterComponent
-            .factory()
-            .create(null); // the parameter is unused and therefore not checked
-    assertThat(component.getDouble()).isEqualTo(42.0);
+  public void concreteModuleThatCouldBeAbstract_withFactoryParameter_failsOnNull() {
+    // This matches what builders do when there's a setter for such a module; the setter checks that
+    // the argument is not null but otherwise ignores it.
+    // It's possible that we shouldn't even allow such a parameter for a factory, since unlike a
+    // builder, where the setter can just not be called, a factory doesn't give the option of not
+    // passing *something* for the unused parameter.
+    try {
+      ConcreteModuleThatCouldBeAbstractWithFactoryParameterComponent component =
+          DaggerFactoryImplicitModulesTest_ConcreteModuleThatCouldBeAbstractWithFactoryParameterComponent
+              .factory()
+              .create(null);
+      fail();
+    } catch (NullPointerException expected) {
+    }
   }
 }
