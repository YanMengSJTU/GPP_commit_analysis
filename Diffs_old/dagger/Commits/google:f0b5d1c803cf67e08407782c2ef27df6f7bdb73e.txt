diff --git a/java/dagger/internal/codegen/BindingGraph.java b/java/dagger/internal/codegen/BindingGraph.java
index f211415d7..4f1b63f73 100644
--- a/java/dagger/internal/codegen/BindingGraph.java
+++ b/java/dagger/internal/codegen/BindingGraph.java
@@ -19,6 +19,7 @@
 import static com.google.common.base.Preconditions.checkState;
 import static dagger.internal.codegen.ComponentRequirement.Kind.BOUND_INSTANCE;
 import static dagger.internal.codegen.DaggerStreams.presentValues;
+import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
 
 import com.google.auto.value.AutoValue;
 import com.google.auto.value.extension.memoized.Memoized;
@@ -150,10 +151,47 @@ TypeElement componentTypeElement() {
    */
   @Memoized
   ImmutableSet<ComponentRequirement> componentRequirements() {
+    return componentRequirements(
+        StreamSupport.stream(SUBGRAPH_TRAVERSER.depthFirstPreOrder(this).spliterator(), false)
+            .flatMap(graph -> graph.contributionBindings().values().stream())
+            .flatMap(bindings -> bindings.contributionBindings().stream())
+        .collect(toImmutableSet()));
+  }
+
+  /**
+   * The types for which the component may need instances, depending on how it is resolved in a
+   * parent component.
+   *
+   * <ul>
+   *   <li>{@linkplain #ownedModules() Owned modules} with concrete instance bindings. If the module
+   *       is never used in the fully resolved binding graph, the instance will not be required
+   *       unless a component builder requests it.
+   *   <li>Bound instances (always required)
+   * </ul>
+   */
+  @Memoized
+  ImmutableSet<ComponentRequirement> possiblyNecessaryRequirements() {
+    checkState(!componentDescriptor().kind().isTopLevel());
+    return componentRequirements(
+        StreamSupport.stream(SUBGRAPH_TRAVERSER.depthFirstPreOrder(this).spliterator(), false)
+            .flatMap(graph -> graph.ownedModules().stream())
+            .flatMap(module -> module.bindings().stream())
+            .collect(toImmutableSet()));
+  }
+
+  /**
+   * The types for which the component needs instances.
+   *
+   * <ul>
+   *   <li>component dependencies
+   *   <li>The modules of {@code bindings} that require a module instance
+   *   <li>bound instances
+   * </ul>
+   */
+  private ImmutableSet<ComponentRequirement> componentRequirements(
+      ImmutableSet<ContributionBinding> bindings) {
     ImmutableSet.Builder<ComponentRequirement> requirements = ImmutableSet.builder();
-    StreamSupport.stream(SUBGRAPH_TRAVERSER.depthFirstPreOrder(this).spliterator(), false)
-        .flatMap(graph -> graph.contributionBindings().values().stream())
-        .flatMap(bindings -> bindings.contributionBindings().stream())
+    bindings.stream()
         .filter(ContributionBinding::requiresModuleInstance)
         .map(ContributionBinding::contributingModule)
         .flatMap(presentValues())
diff --git a/java/dagger/internal/codegen/ComponentBuilderImplementation.java b/java/dagger/internal/codegen/ComponentBuilderImplementation.java
index 1de19cc43..ea5f18d42 100644
--- a/java/dagger/internal/codegen/ComponentBuilderImplementation.java
+++ b/java/dagger/internal/codegen/ComponentBuilderImplementation.java
@@ -44,6 +44,7 @@
 import dagger.internal.codegen.ComponentDescriptor.BuilderSpec;
 import java.util.Optional;
 import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.Modifier;
 import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
@@ -81,6 +82,15 @@ ClassName name() {
       BindingGraph graph,
       Elements elements,
       Types types) {
+    if (componentImplementation.superclassImplementation().isPresent()
+        && componentImplementation.isAbstract()) {
+      // The component builder in ahead-of-time mode is generated with the base subcomponent
+      // implementation, with the exception of the build method since that requires invoking the
+      // constructor of a subclass component implementation. Intermediate component implementations,
+      // because they still can't invoke the eventual constructor and have no additional extensions
+      // to the builder, can ignore generating a builder implementation.
+      return Optional.empty();
+    }
     return graph.componentDescriptor().hasBuilder()
         ? Optional.of(new Creator(componentImplementation, graph, elements, types).create())
         : Optional.empty();
@@ -129,21 +139,22 @@ ComponentBuilderImplementation create() {
             .addMethod(constructorBuilder().addModifiers(PRIVATE).build());
       }
 
-      ImmutableMap<ComponentRequirement, FieldSpec> builderFields = builderFields(graph);
+      ImmutableMap<ComponentRequirement, FieldSpec> builderFields = builderFields();
 
       if (componentImplementation.isAbstract()) {
         componentBuilderClass.addModifiers(ABSTRACT);
       } else {
         componentBuilderClass.addModifiers(FINAL);
-        // Can only instantiate concrete classes.
         componentBuilderClass.addMethod(buildMethod(builderFields));
       }
 
-      componentBuilderClass
-          .addFields(builderFields.values())
-          // TODO(ronshapiro): this should be switched with buildMethod(), but that currently breaks
-          // compile-testing tests that rely on the order of the methods
-          .addMethods(builderMethods(builderFields));
+      if (!componentImplementation.baseImplementation().isPresent()) {
+        componentBuilderClass.addFields(builderFields.values());
+      }
+
+      // TODO(ronshapiro): this should be switched with buildMethod(), but that currently breaks
+      // compile-testing tests that rely on the order of the methods
+      componentBuilderClass.addMethods(builderMethods(builderFields));
 
       return new ComponentBuilderImplementation(
           componentBuilderClass.build(), componentImplementation.getBuilderName(), builderFields);
@@ -151,27 +162,33 @@ ComponentBuilderImplementation create() {
 
     /** Set the superclass being extended or interface being implemented for this builder. */
     void setSupertype() {
-      if (componentImplementation.superclassImplementation().isPresent()) {
+      if (componentImplementation.baseImplementation().isPresent()) {
         // If there's a superclass, extend the Builder defined there.
         componentBuilderClass.superclass(
-            componentImplementation.superclassImplementation().get().getBuilderName());
+            componentImplementation.baseImplementation().get().getBuilderName());
       } else {
         addSupertype(componentBuilderClass, builderSpec().get().builderDefinitionType());
       }
     }
 
     /**
-     * Computes fields for each of the {@linkplain BindingGraph#componentRequirements component
-     * requirements}. Regardless of builder spec, there is always one field per requirement.
+     * Computes fields for each of the {@link ComponentRequirement}s}. Regardless of builder spec,
+     * there is always one field per requirement.
+     *
+     * <p>If the base implementation's builder is being generated in ahead-of-time-subcomponents
+     * mode, this uses {@link BindingGraph#possiblyNecessaryRequirements()} since Dagger doesn't
+     * know what modules may end up being unused. Otherwise, we use the {@link
+     * BindingGraph#componentRequirements() necessary component requirements}.
      */
-    static ImmutableMap<ComponentRequirement, FieldSpec> builderFields(BindingGraph graph) {
+    ImmutableMap<ComponentRequirement, FieldSpec> builderFields() {
       UniqueNameSet fieldNames = new UniqueNameSet();
       ImmutableMap.Builder<ComponentRequirement, FieldSpec> builderFields = ImmutableMap.builder();
-      for (ComponentRequirement componentRequirement : graph.componentRequirements()) {
+      Modifier modifier = componentImplementation.isAbstract() ? PUBLIC : PRIVATE;
+      for (ComponentRequirement componentRequirement : componentRequirements()) {
         String name = fieldNames.getUniqueName(componentRequirement.variableName());
         builderFields.put(
             componentRequirement,
-            FieldSpec.builder(TypeName.get(componentRequirement.type()), name, PRIVATE).build());
+            FieldSpec.builder(TypeName.get(componentRequirement.type()), name, modifier).build());
       }
       return builderFields.build();
     }
@@ -224,9 +241,21 @@ MethodSpec buildMethod(ImmutableMap<ComponentRequirement, FieldSpec> builderFiel
      */
     ImmutableSet<MethodSpec> builderMethods(
         ImmutableMap<ComponentRequirement, FieldSpec> builderFields) {
-      ImmutableSet<ComponentRequirement> componentRequirements = graph.componentRequirements();
+      ImmutableSet<ComponentRequirement> componentRequirements = componentRequirements();
       ImmutableSet.Builder<MethodSpec> methods = ImmutableSet.builder();
+      // TODO(ronshapiro): extract two separate methods: builderMethodsForBuilderSpec and
+      // builderMethodsForGeneratedTopLevelComponentBuilder()
       if (builderSpec().isPresent()) {
+        // In ahead-of-time subcomponents mode, all builder methods are defined at the base
+        // implementation. The only case where a method needs to be overridden is for a repeated
+        // module, which is unknown at the point when a base implementation is generated. We do this
+        // at the root for simplicity (and as an aside, repeated modules are never used in google
+        // as of 11/28/18, and thus the additional cost of including these methods at the root is
+        // negligible).
+        boolean hasBaseBuilderImplementation =
+            !componentImplementation.isAbstract()
+                && componentImplementation.baseImplementation().isPresent();
+
         UniqueNameSet parameterNames = new UniqueNameSet();
         for (BuilderRequirementMethod requirementMethod :
             builderSpec().get().requirementMethods()) {
@@ -244,7 +273,11 @@ MethodSpec buildMethod(ImmutableMap<ComponentRequirement, FieldSpec> builderFiel
                   : TypeName.get(builderRequirement.type());
 
           builderMethod.addParameter(argType, parameterName);
+
           if (componentRequirements.contains(builderRequirement)) {
+            if (hasBaseBuilderImplementation) {
+              continue;
+            }
             // required type
             builderMethod.addStatement(
                 "this.$N = $L",
@@ -256,6 +289,9 @@ MethodSpec buildMethod(ImmutableMap<ComponentRequirement, FieldSpec> builderFiel
                     : CodeBlock.of("$T.checkNotNull($L)", Preconditions.class, parameterName));
             addBuilderMethodReturnStatementForSpec(specMethod, builderMethod);
           } else if (graph.ownedModuleTypes().contains(builderRequirement.typeElement())) {
+            if (hasBaseBuilderImplementation) {
+              continue;
+            }
             // owned, but not required
             builderMethod.addJavadoc(NOOP_BUILDER_METHOD_JAVADOC);
             addBuilderMethodReturnStatementForSpec(specMethod, builderMethod);
@@ -268,6 +304,7 @@ MethodSpec buildMethod(ImmutableMap<ComponentRequirement, FieldSpec> builderFiel
                 "%s cannot be set because it is inherited from the enclosing component",
                 TypeNames.rawTypeName(TypeName.get(builderRequirement.type())));
           }
+
           methods.add(builderMethod.build());
         }
       } else {
@@ -298,6 +335,13 @@ MethodSpec buildMethod(ImmutableMap<ComponentRequirement, FieldSpec> builderFiel
       return methods.build();
     }
 
+    private ImmutableSet<ComponentRequirement> componentRequirements() {
+      return !componentImplementation.superclassImplementation().isPresent()
+              && componentImplementation.isAbstract()
+          ? graph.possiblyNecessaryRequirements()
+          : graph.componentRequirements();
+    }
+
     MethodSpec.Builder addBuilderMethodFromSpec(ExecutableElement method) {
       TypeMirror returnType = method.getReturnType();
       MethodSpec.Builder builderMethod =
diff --git a/java/dagger/internal/codegen/ComponentImplementation.java b/java/dagger/internal/codegen/ComponentImplementation.java
index 4a349469c..be2542b2f 100644
--- a/java/dagger/internal/codegen/ComponentImplementation.java
+++ b/java/dagger/internal/codegen/ComponentImplementation.java
@@ -146,6 +146,7 @@
   private final NestingKind nestingKind;
   private final boolean isAbstract;
   private final Optional<ComponentImplementation> superclassImplementation;
+  private Optional<ComponentBuilderImplementation> builderImplementation;
   private final Map<TypeElement, ComponentImplementation> childImplementations = new HashMap<>();
   private final TypeSpec.Builder component;
   private final SubcomponentNames subcomponentNames;
@@ -241,6 +242,16 @@ boolean isAbstract() {
     return superclassImplementation;
   }
 
+  /**
+   * Returns the base implementation of this component in ahead-of-time subcomponents mode. If this
+   * is the base implementation, this returns {@link Optional#empty()}.
+   */
+  Optional<ComponentImplementation> baseImplementation() {
+    return superclassImplementation.isPresent()
+        ? Optional.of(Optionals.rootmostValue(this, c -> c.superclassImplementation))
+        : Optional.empty();
+  }
+
   /**
    * Returns the {@link #configureInitializationMethod()} of the nearest supertype that defines one,
    * if any.
@@ -277,6 +288,17 @@ void setConfigureInitializationMethod(MethodSpec method) {
     addMethod(MethodSpecKind.CONFIGURE_INITIALIZATION_METHOD, method);
   }
 
+  void setBuilderImplementation(Optional<ComponentBuilderImplementation> builderImplementation) {
+    checkState(
+        this.builderImplementation == null, "setBuilderImplementation has already been called");
+    this.builderImplementation = builderImplementation;
+  }
+
+  Optional<ComponentBuilderImplementation> builderImplementation() {
+    checkState(builderImplementation != null, "setBuilderImplementation has not been called yet");
+    return builderImplementation;
+  }
+
   /**
    * Returns the name of the builder class for this component. It will be a sibling of this
    * generated class unless this is a top-level component, in which case it will be nested.
diff --git a/java/dagger/internal/codegen/ComponentImplementationFactory.java b/java/dagger/internal/codegen/ComponentImplementationFactory.java
index 569d90306..b48e8eb3e 100644
--- a/java/dagger/internal/codegen/ComponentImplementationFactory.java
+++ b/java/dagger/internal/codegen/ComponentImplementationFactory.java
@@ -110,9 +110,9 @@ ComponentImplementation createComponentImplementation(BindingGraph bindingGraph)
     Optional<ComponentBuilderImplementation> componentBuilderImplementation =
         ComponentBuilderImplementation.create(
             componentImplementation, bindingGraph, elements, types);
+    componentImplementation.setBuilderImplementation(componentBuilderImplementation);
     ComponentRequirementFields componentRequirementFields =
-        new ComponentRequirementFields(
-            bindingGraph, componentImplementation, componentBuilderImplementation);
+        new ComponentRequirementFields(bindingGraph, componentImplementation);
     ComponentBindingExpressions bindingExpressions =
         new ComponentBindingExpressions(
             bindingGraph,
@@ -134,8 +134,7 @@ ComponentImplementation createComponentImplementation(BindingGraph bindingGraph)
               componentImplementation,
               optionalFactories,
               bindingExpressions,
-              componentRequirementFields,
-              componentBuilderImplementation)
+              componentRequirementFields)
           .build();
     } else {
       return new RootComponentImplementationBuilder(
@@ -143,8 +142,7 @@ ComponentImplementation createComponentImplementation(BindingGraph bindingGraph)
               componentImplementation,
               optionalFactories,
               bindingExpressions,
-              componentRequirementFields,
-              componentBuilderImplementation.get())
+              componentRequirementFields)
           .build();
     }
   }
@@ -167,7 +165,6 @@ ComponentImplementation topLevelImplementation(ClassName name, BindingGraph grap
     final ComponentRequirementFields componentRequirementFields;
     final ComponentImplementation componentImplementation;
     final OptionalFactories optionalFactories;
-    final Optional<ComponentBuilderImplementation> componentBuilderImplementation;
     boolean done;
 
     ComponentImplementationBuilder(
@@ -175,14 +172,12 @@ ComponentImplementation topLevelImplementation(ClassName name, BindingGraph grap
         ComponentImplementation componentImplementation,
         OptionalFactories optionalFactories,
         ComponentBindingExpressions bindingExpressions,
-        ComponentRequirementFields componentRequirementFields,
-        Optional<ComponentBuilderImplementation> componentBuilderImplementation) {
+        ComponentRequirementFields componentRequirementFields) {
       this.graph = graph;
       this.componentImplementation = componentImplementation;
       this.optionalFactories = optionalFactories;
       this.bindingExpressions = bindingExpressions;
       this.componentRequirementFields = componentRequirementFields;
-      this.componentBuilderImplementation = componentBuilderImplementation;
     }
 
     /**
@@ -196,7 +191,8 @@ final ComponentImplementation build() {
           "ComponentImplementationBuilder has already built the ComponentImplementation for [%s].",
           componentImplementation.name());
       setSupertype();
-      componentBuilderImplementation
+      componentImplementation
+          .builderImplementation()
           .map(ComponentBuilderImplementation::componentBuilderClass)
           .ifPresent(this::addBuilderClass);
 
@@ -386,9 +382,9 @@ final ComponentImplementation buildChildImplementation(BindingGraph childGraph)
               : concreteSubcomponent(childGraph.componentDescriptor());
       Optional<ComponentBuilderImplementation> childBuilderImplementation =
           ComponentBuilderImplementation.create(childImplementation, childGraph, elements, types);
+      childImplementation.setBuilderImplementation(childBuilderImplementation);
       ComponentRequirementFields childComponentRequirementFields =
-          componentRequirementFields.forChildComponent(
-              childGraph, childImplementation, childBuilderImplementation);
+          componentRequirementFields.forChildComponent(childGraph, childImplementation);
       ComponentBindingExpressions childBindingExpressions =
           bindingExpressions.forChildComponent(
               childGraph, childImplementation, childComponentRequirementFields);
@@ -398,8 +394,7 @@ final ComponentImplementation buildChildImplementation(BindingGraph childGraph)
               childImplementation,
               optionalFactories,
               childBindingExpressions,
-              childComponentRequirementFields,
-              childBuilderImplementation)
+              childComponentRequirementFields)
           .build();
     }
 
@@ -523,9 +518,21 @@ final void addConstructor() {
 
     /** Returns the list of {@link ParameterSpec}s for the constructor. */
     final ImmutableList<ParameterSpec> constructorParameters() {
-      if (componentBuilderImplementation.isPresent()) {
+      Optional<ClassName> componentBuilderName;
+      if (componentImplementation.builderImplementation().isPresent()) {
+        componentBuilderName =
+            componentImplementation.builderImplementation().map(builder -> builder.name());
+      } else {
+        componentBuilderName =
+            componentImplementation
+                .baseImplementation()
+                .filter(component -> component.componentDescriptor().hasBuilder())
+                .map(ComponentImplementation::getBuilderName);
+      }
+
+      if (componentBuilderName.isPresent()) {
         return ImmutableList.of(
-            ParameterSpec.builder(componentBuilderImplementation.get().name(), "builder").build());
+            ParameterSpec.builder(componentBuilderName.get(), "builder").build());
       } else if (componentImplementation.isAbstract() && componentImplementation.isNested()) {
         // If we're generating an abstract inner subcomponent, then we are not implementing module
         // instance bindings and have no need for factory method parameters.
@@ -545,23 +552,21 @@ final void addConstructor() {
 
   /** Builds a root component implementation. */
   private final class RootComponentImplementationBuilder extends ComponentImplementationBuilder {
-    private final ClassName componentBuilderClassName;
+    private final ClassName componentBuilderName;
 
     RootComponentImplementationBuilder(
         BindingGraph graph,
         ComponentImplementation componentImplementation,
         OptionalFactories optionalFactories,
         ComponentBindingExpressions bindingExpressions,
-        ComponentRequirementFields componentRequirementFields,
-        ComponentBuilderImplementation componentBuilderImplementation) {
+        ComponentRequirementFields componentRequirementFields) {
       super(
           graph,
           componentImplementation,
           optionalFactories,
           bindingExpressions,
-          componentRequirementFields,
-          Optional.of(componentBuilderImplementation));
-      this.componentBuilderClassName = componentBuilderImplementation.name();
+          componentRequirementFields);
+      this.componentBuilderName = componentImplementation.builderImplementation().get().name();
     }
 
     @Override
@@ -579,8 +584,8 @@ void addFactoryMethods() {
               .returns(
                   builderSpec()
                       .map(builderSpec -> ClassName.get(builderSpec.builderDefinitionType()))
-                      .orElse(componentBuilderClassName))
-              .addStatement("return new $T()", componentBuilderClassName)
+                      .orElse(componentBuilderName))
+              .addStatement("return new $T()", componentBuilderName)
               .build();
       componentImplementation.addMethod(BUILDER_METHOD, builderFactoryMethod);
       if (canInstantiateAllRequirements()) {
@@ -623,15 +628,13 @@ boolean canInstantiateAllRequirements() {
         ComponentImplementation componentImplementation,
         OptionalFactories optionalFactories,
         ComponentBindingExpressions bindingExpressions,
-        ComponentRequirementFields componentRequirementFields,
-        Optional<ComponentBuilderImplementation> componentBuilderImplementation) {
+        ComponentRequirementFields componentRequirementFields) {
       super(
           graph,
           componentImplementation,
           optionalFactories,
           bindingExpressions,
-          componentRequirementFields,
-          componentBuilderImplementation);
+          componentRequirementFields);
       this.parent = parent;
     }
 
diff --git a/java/dagger/internal/codegen/ComponentRequirementFields.java b/java/dagger/internal/codegen/ComponentRequirementFields.java
index 7c28dd58d..312fd86e8 100644
--- a/java/dagger/internal/codegen/ComponentRequirementFields.java
+++ b/java/dagger/internal/codegen/ComponentRequirementFields.java
@@ -47,33 +47,26 @@
       new HashMap<>();
   private final BindingGraph graph;
   private final ComponentImplementation componentImplementation;
-  private final Optional<ComponentBuilderImplementation> componentBuilderImplementation;
 
   private ComponentRequirementFields(
       Optional<ComponentRequirementFields> parent,
       BindingGraph graph,
-      ComponentImplementation componentImplementation,
-      Optional<ComponentBuilderImplementation> componentBuilderImplementation) {
+      ComponentImplementation componentImplementation) {
     this.parent = parent;
     this.graph = graph;
     this.componentImplementation = componentImplementation;
-    this.componentBuilderImplementation = componentBuilderImplementation;
   }
 
+  // TODO(ronshapiro): give ComponentImplementation a graph() method
   ComponentRequirementFields(
-      BindingGraph graph,
-      ComponentImplementation componentImplementation,
-      Optional<ComponentBuilderImplementation> componentBuilderImplementation) {
-    this(Optional.empty(), graph, componentImplementation, componentBuilderImplementation);
+      BindingGraph graph, ComponentImplementation componentImplementation) {
+    this(Optional.empty(), graph, componentImplementation);
   }
 
   /** Returns a new object representing the fields available from a child component of this one. */
   ComponentRequirementFields forChildComponent(
-      BindingGraph graph,
-      ComponentImplementation componentImplementation,
-      Optional<ComponentBuilderImplementation> componentBuilderImplementation) {
-    return new ComponentRequirementFields(
-        Optional.of(this), graph, componentImplementation, componentBuilderImplementation);
+      BindingGraph graph, ComponentImplementation componentImplementation) {
+    return new ComponentRequirementFields(Optional.of(this), graph, componentImplementation);
   }
 
   /**
@@ -110,9 +103,12 @@ ComponentRequirementField getField(ComponentRequirement componentRequirement) {
 
   /** Returns a {@link ComponentRequirementField} for a {@link ComponentRequirement}. */
   private ComponentRequirementField create(ComponentRequirement requirement) {
-    if (componentBuilderImplementation.isPresent()) {
-      FieldSpec builderField =
-          componentBuilderImplementation.get().builderFields().get(requirement);
+    Optional<ComponentBuilderImplementation> builderImplementation =
+        Optionals.firstPresent(
+            componentImplementation.baseImplementation().flatMap(c -> c.builderImplementation()),
+            componentImplementation.builderImplementation());
+    if (builderImplementation.isPresent()) {
+      FieldSpec builderField = builderImplementation.get().builderFields().get(requirement);
       return new BuilderField(requirement, componentImplementation, builderField);
     } else if (graph.factoryMethod().isPresent()
         && graph.factoryMethodParameters().containsKey(requirement)) {
@@ -122,7 +118,8 @@ private ComponentRequirementField create(ComponentRequirement requirement) {
     } else if (requirement.kind().equals(ComponentRequirement.Kind.MODULE)) {
       return new ComponentInstantiableField(requirement, componentImplementation);
     } else {
-      throw new AssertionError("cannot create field for " + requirement);
+      throw new AssertionError(
+          String.format("Can't create %s in %s", requirement, componentImplementation.name()));
     }
   }
 
diff --git a/java/dagger/internal/codegen/HjarSourceFileGenerator.java b/java/dagger/internal/codegen/HjarSourceFileGenerator.java
index 4b1de01a2..9e3a14c60 100644
--- a/java/dagger/internal/codegen/HjarSourceFileGenerator.java
+++ b/java/dagger/internal/codegen/HjarSourceFileGenerator.java
@@ -22,10 +22,12 @@
 import static javax.lang.model.element.Modifier.PRIVATE;
 
 import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.FieldSpec;
 import com.squareup.javapoet.MethodSpec;
 import com.squareup.javapoet.TypeSpec;
 import java.util.Optional;
 import javax.lang.model.element.Element;
+import javax.lang.model.element.Modifier;
 
 /**
  * A source file generator that only writes the relevant code necessary for Bazel to create a
@@ -77,13 +79,15 @@ Element originatingElement(T input) {
         .map(this::skeletonMethod)
         .forEach(skeleton::addMethod);
 
+    completeType.fieldSpecs.stream()
+        .filter(field -> !field.modifiers.contains(PRIVATE))
+        .map(this::skeletonField)
+        .forEach(skeleton::addField);
+
     completeType.typeSpecs.stream()
         .map(type -> skeletonType(type).build())
         .forEach(skeleton::addType);
 
-    // Dagger has no fields that are exposed in its APIs, but if we add some, we need to implement
-    // skeleton fields here.
-
     return skeleton;
   }
 
@@ -108,4 +112,12 @@ private MethodSpec skeletonMethod(MethodSpec completeMethod) {
         .varargs(completeMethod.varargs)
         .build();
   }
+
+  private FieldSpec skeletonField(FieldSpec completeField) {
+    return FieldSpec.builder(
+            completeField.type,
+            completeField.name,
+            completeField.modifiers.toArray(new Modifier[0]))
+        .build();
+  }
 }
diff --git a/java/dagger/internal/codegen/Optionals.java b/java/dagger/internal/codegen/Optionals.java
index f8963db36..1021c35ed 100644
--- a/java/dagger/internal/codegen/Optionals.java
+++ b/java/dagger/internal/codegen/Optionals.java
@@ -21,6 +21,7 @@
 
 import java.util.Comparator;
 import java.util.Optional;
+import java.util.function.Function;
 
 /** Utilities for {@link Optional}s. */
 final class Optionals {
@@ -48,5 +49,20 @@
         .orElse(Optional.empty());
   }
 
+  /**
+   * Walks a chain of present optionals as defined by successive calls to {@code nextFunction},
+   * returning the value of the final optional that is present. The first optional in the chain is
+   * the result of {@code nextFunction(start)}.
+   */
+  static <T> T rootmostValue(T start, Function<T, Optional<T>> nextFunction) {
+    T current = start;
+    for (Optional<T> next = nextFunction.apply(start);
+        next.isPresent();
+        next = nextFunction.apply(current)) {
+      current = next.get();
+    }
+    return current;
+  }
+
   private Optionals() {}
 }
diff --git a/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java b/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java
index 331535f92..e036743d5 100644
--- a/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java
+++ b/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java
@@ -745,8 +745,6 @@ public void generatedInstanceBinding() {
             "public abstract class DaggerAncestor implements Ancestor {",
             "  protected DaggerAncestor() {}",
             "",
-            "  protected abstract class LeafBuilder extends DaggerLeaf.Builder {}",
-            "",
             "  protected abstract class LeafImpl extends DaggerLeaf {",
             "    protected LeafImpl() {}",
             "  }",
@@ -807,7 +805,7 @@ public void generatedInstanceBinding() {
             "      return new LeafBuilder();",
             "    }",
             "",
-            "    private final class LeafBuilder extends DaggerAncestor.LeafBuilder {",
+            "    private final class LeafBuilder extends DaggerLeaf.Builder {",
             "      @Override",
             "      public Leaf build() {",
             "        return new LeafImpl(this);",
@@ -5050,6 +5048,643 @@ public void missingBindingAccessInLeafAndAncestor() {
         .hasSourceEquivalentTo(generatedAncestor);
   }
 
+  @Test
+  public void subcomponentBuilders() {
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
+    createAncillaryClasses(filesToCompile, "InducesDependenciesOnBuilderFields");
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.LeafModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "class LeafModule {",
+            "  private final Object object;",
+            "",
+            "  LeafModule(Object object) {",
+            "    this.object = object;",
+            "  }",
+            "",
+            "  @Provides",
+            "  Object fromModule() {",
+            "    return object;",
+            "  }",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.MultibindingsModule",
+            "package test;",
+            "",
+            "import dagger.Binds;",
+            "import dagger.Module;",
+            "import dagger.multibindings.IntoSet;",
+            "",
+            "@Module",
+            "interface MultibindingsModule {",
+            "  @Binds",
+            "  @IntoSet",
+            "  String string(String string);",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.Leaf",
+            "package test;",
+            "",
+            "import dagger.BindsInstance;",
+            "import dagger.Subcomponent;",
+            "import javax.inject.Provider;",
+            "",
+            "@Subcomponent(modules = {LeafModule.class, MultibindingsModule.class})",
+            "interface Leaf {",
+            "  int bindsInstance();",
+            "  Object fromModule();",
+            "  InducesDependenciesOnBuilderFields inducesDependenciesOnBuilderFields();",
+            "",
+            "  @Subcomponent.Builder",
+            "  interface Builder {",
+            "    @BindsInstance Builder bindsInstance(int boundInstance);",
+            "    @BindsInstance Builder inducedInSubclass(String induced);",
+            "    Builder module(LeafModule module);",
+            "",
+            "    Leaf build();",
+            "  }",
+            "}"));
+    JavaFileObject generatedLeaf =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerLeaf",
+            "package test;",
+            "",
+            "import dagger.internal.Preconditions;",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerLeaf implements Leaf {",
+            "  private Integer bindsInstance;",
+            "  private LeafModule leafModule;",
+            "",
+            "  protected DaggerLeaf() {}",
+            "",
+            "  protected void configureInitialization(Builder builder) {",
+            "    initialize(builder);",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize(final Builder builder) {",
+            "    this.bindsInstance = builder.bindsInstance;",
+            "    this.leafModule = builder.leafModule;",
+            "  }",
+            "",
+            "  @Override",
+            "  public int bindsInstance() {",
+            "    return bindsInstance;",
+            "  }",
+            "",
+            "  @Override",
+            "  public Object fromModule() {",
+            "    return LeafModule_FromModuleFactory.proxyFromModule(leafModule);",
+            "  }",
+            "",
+            "  public abstract static class Builder implements Leaf.Builder {",
+            "    public LeafModule leafModule;",
+            "    public Integer bindsInstance;",
+            "    public String inducedInSubclass;",
+            "",
+            "    @Override",
+            "    public Builder bindsInstance(int boundInstance) {",
+            "      this.bindsInstance = Preconditions.checkNotNull(boundInstance);",
+            "      return this;",
+            "    }",
+            "",
+            "    @Override",
+            "    public Builder inducedInSubclass(String induced) {",
+            "      this.inducedInSubclass = Preconditions.checkNotNull(induced);",
+            "      return this;",
+            "    }",
+            "",
+            "    @Override",
+            "    public Builder module(LeafModule module) {",
+            "      this.leafModule = Preconditions.checkNotNull(module);",
+            "      return this;",
+            "    }",
+            "  }",
+            "}");
+    Compilation compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerLeaf")
+        .hasSourceEquivalentTo(generatedLeaf);
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Ancestor",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = MultibindingInducingModule.class)",
+            "interface Ancestor {",
+            "  Leaf.Builder leaf();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.MultibindingInducingModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.multibindings.Multibinds;",
+            "import dagger.Provides;",
+            "import java.util.Set;",
+            "",
+            "@Module",
+            "interface MultibindingInducingModule {",
+            "  @Provides",
+            "  static InducesDependenciesOnBuilderFields induce(",
+            "      Set<String> multibindingWithBuilderFieldDeps) { ",
+            "    return new InducesDependenciesOnBuilderFields();",
+            "  }",
+            "",
+            "  @Multibinds",
+            "  Set<String> multibinding();",
+            "}"));
+    JavaFileObject generatedAncestor =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerAncestor",
+            "package test;",
+            "",
+            "import com.google.common.collect.ImmutableSet;",
+            "import java.util.Set;",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerAncestor implements Ancestor {",
+            "  protected DaggerAncestor() {}",
+            "",
+            "  protected abstract class LeafImpl extends DaggerLeaf {",
+            "    private String inducedInSubclass;",
+            "",
+            "    protected LeafImpl() {}",
+            "",
+            "    @Override",
+            "    protected void configureInitialization(DaggerLeaf.Builder builder) {",
+            "      super.configureInitialization(builder);",
+            "      initialize(builder);",
+            "    }",
+            "",
+            "    @SuppressWarnings(\"unchecked\")",
+            "    private void initialize(final DaggerLeaf.Builder builder) {",
+            "      this.inducedInSubclass = builder.inducedInSubclass;",
+            "    }",
+            "",
+            "    protected Set<String> getSetOfString() {",
+            "      return ImmutableSet.<String>of(inducedInSubclass);",
+            "    }",
+            "",
+            "    @Override",
+            "    public final InducesDependenciesOnBuilderFields",
+            "        inducesDependenciesOnBuilderFields() {",
+            "      return MultibindingInducingModule_InduceFactory.proxyInduce(getSetOfString());",
+            "    }",
+            "  }",
+            "}");
+    compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerAncestor")
+        .hasSourceEquivalentTo(generatedAncestor);
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Root",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface Root {",
+            "  Ancestor ancestor();",
+            "}"));
+    JavaFileObject generatedRoot =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerRoot",
+            "package test;",
+            "",
+            "import dagger.internal.Preconditions;",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerRoot implements Root {",
+            "  private DaggerRoot(Builder builder) {}",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static Root create() {",
+            "    return new Builder().build();",
+            "  }",
+            "",
+            "  @Override",
+            "  public Ancestor ancestor() {",
+            "    return new AncestorImpl();",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private Builder() {}",
+            "",
+            "    public Root build() {",
+            "      return new DaggerRoot(this);",
+            "    }",
+            "  }",
+            "",
+            "  protected final class AncestorImpl extends DaggerAncestor {",
+            "    private AncestorImpl() {}",
+            "",
+            "    @Override",
+            "    public Leaf.Builder leaf() {",
+            "      return new LeafBuilder();",
+            "    }",
+            "",
+            "    private final class LeafBuilder extends DaggerLeaf.Builder {",
+            "      @Override",
+            "      public Leaf build() {",
+            // TODO(b/117833324): Can we stick the validations into a method on the base class
+            // builder so that the contents of this method are just call to that and then new
+            // FooImpl? But repeated modules may make this more complicated, since those *should*
+            // be null
+            "        Preconditions.checkBuilderRequirement(leafModule, LeafModule.class);",
+            "        Preconditions.checkBuilderRequirement(bindsInstance, Integer.class);",
+            "        Preconditions.checkBuilderRequirement(inducedInSubclass, String.class);",
+            "        return new LeafImpl(this);",
+            "      }",
+            "    }",
+            "",
+            "    protected final class LeafImpl extends DaggerAncestor.LeafImpl {",
+            "      private LeafModule leafModule;",
+            "",
+            "      private LeafImpl(LeafBuilder builder) {",
+            "        configureInitialization(builder);",
+            "        initialize(builder);",
+            "      }",
+            "",
+            "      @SuppressWarnings(\"unchecked\")",
+            "      private void initialize(final LeafBuilder builder) {",
+            "        this.leafModule = builder.leafModule;",
+            "      }",
+            "",
+            "      @Override",
+            "      public Object fromModule() {",
+            "        return LeafModule_FromModuleFactory.proxyFromModule(leafModule);",
+            "      }",
+            "    }",
+            "  }",
+            "}");
+    compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerRoot")
+        .hasSourceEquivalentTo(generatedRoot);
+  }
+
+  @Test
+  public void subcomponentBuilders_moduleWithUnusedInstanceBindings() {
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
+    createAncillaryClasses(filesToCompile, "Used", "Unused");
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.ModuleWithUsedBinding",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "class ModuleWithUsedBinding {",
+            "  @Provides",
+            "  Used used() {",
+            "    return new Used();",
+            "  }",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.ModuleWithUnusedBinding",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "class ModuleWithUnusedBinding {",
+            "  @Provides",
+            "  Unused unused() {",
+            "    return new Unused();",
+            "  }",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.Leaf",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = {ModuleWithUsedBinding.class, ModuleWithUnusedBinding.class})",
+            "interface Leaf {",
+            "  Used used();",
+            "",
+            "  @Subcomponent.Builder",
+            "  interface Builder {",
+            "    Leaf build();",
+            "  }",
+            "}"));
+    JavaFileObject generatedLeaf =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerLeaf",
+            "package test;",
+            "",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerLeaf implements Leaf {",
+            "  private ModuleWithUsedBinding moduleWithUsedBinding;",
+            "",
+            "  protected DaggerLeaf() {}",
+            "",
+            "  protected void configureInitialization(Builder builder) {",
+            "    initialize(builder);",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize(final Builder builder) {",
+            "    this.moduleWithUsedBinding = builder.moduleWithUsedBinding;",
+            "  }",
+            "",
+            "  @Override",
+            "  public Used used() {",
+            "    return ModuleWithUsedBinding_UsedFactory.proxyUsed(moduleWithUsedBinding);",
+            "  }",
+            "",
+            "  public abstract static class Builder implements Leaf.Builder {",
+            "    public ModuleWithUsedBinding moduleWithUsedBinding;",
+            "    public ModuleWithUnusedBinding moduleWithUnusedBinding;",
+            "  }",
+            "}");
+    Compilation compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerLeaf")
+        .hasSourceEquivalentTo(generatedLeaf);
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Root",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface Root {",
+            "  Leaf.Builder leaf();",
+            "}"));
+    JavaFileObject generatedRoot =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerRoot",
+            "package test;",
+            "",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerRoot implements Root {",
+            "  private DaggerRoot(Builder builder) {}",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static Root create() {",
+            "    return new Builder().build();",
+            "  }",
+            "",
+            "  @Override",
+            "  public Leaf.Builder leaf() {",
+            "    return new LeafBuilder();",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private Builder() {}",
+            "",
+            "    public Root build() {",
+            "      return new DaggerRoot(this);",
+            "    }",
+            "  }",
+            "",
+            "  private final class LeafBuilder extends DaggerLeaf.Builder {",
+            "    @Override",
+            "    public Leaf build() {",
+            "      if (moduleWithUsedBinding == null) {",
+            "        this.moduleWithUsedBinding = new ModuleWithUsedBinding();",
+            "      }",
+            // ModuleWithUnusedBinding is not verified since it's not used
+            "      return new LeafImpl(this);",
+            "    }",
+            "  }",
+            "",
+            "  protected final class LeafImpl extends DaggerLeaf {",
+            "    private ModuleWithUsedBinding moduleWithUsedBinding;",
+            "",
+            "    private LeafImpl(LeafBuilder builder) {",
+            "      configureInitialization(builder);",
+            "      initialize(builder);",
+            "    }",
+            "",
+            "    @SuppressWarnings(\"unchecked\")",
+            "    private void initialize(final LeafBuilder builder) {",
+            "      this.moduleWithUsedBinding = builder.moduleWithUsedBinding;",
+            "    }",
+            "",
+            "    @Override",
+            "    public Used used() {",
+            "      return ModuleWithUsedBinding_UsedFactory.proxyUsed(moduleWithUsedBinding);",
+            "    }",
+            "  }",
+            "}");
+    compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerRoot")
+        .hasSourceEquivalentTo(generatedRoot);
+  }
+
+  @Test
+  public void subcomponentBuilders_repeatedModule() {
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.RepeatedModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "class RepeatedModule {",
+            "  @Provides",
+            "  int i() {",
+            "    return 1;",
+            "  }",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.Leaf",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = RepeatedModule.class)",
+            "interface Leaf {",
+            "  int i();",
+            "",
+            "  @Subcomponent.Builder",
+            "  interface Builder {",
+            "    Builder repeatedModule(RepeatedModule repeatedModule);",
+            "    Leaf build();",
+            "  }",
+            "}"));
+    JavaFileObject generatedLeaf =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerLeaf",
+            "package test;",
+            "",
+            "import dagger.internal.Preconditions;",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerLeaf implements Leaf {",
+            "  private RepeatedModule repeatedModule;",
+            "",
+            "  protected DaggerLeaf() {}",
+            "",
+            "  protected void configureInitialization(Builder builder) {",
+            "    initialize(builder);",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize(final Builder builder) {",
+            "    this.repeatedModule = builder.repeatedModule;",
+            "  }",
+            "",
+            "  @Override",
+            "  public int i() {",
+            "    return repeatedModule.i();",
+            "  }",
+            "",
+            "  public abstract static class Builder implements Leaf.Builder {",
+            "    public RepeatedModule repeatedModule;",
+            "",
+            "    @Override",
+            "    public Builder repeatedModule(RepeatedModule repeatedModule) {",
+            "      this.repeatedModule = Preconditions.checkNotNull(repeatedModule);",
+            "      return this;",
+            "    }",
+            "  }",
+            "}");
+    Compilation compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerLeaf")
+        .hasSourceEquivalentTo(generatedLeaf);
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Root",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = RepeatedModule.class)",
+            "interface Root {",
+            "  Leaf.Builder leaf();",
+            "}"));
+    JavaFileObject generatedRoot =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerRoot",
+            "package test;",
+            "",
+            "import dagger.internal.Preconditions;",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerRoot implements Root {",
+            "  private RepeatedModule repeatedModule;",
+            "",
+            "  private DaggerRoot(Builder builder) {",
+            "    initialize(builder);",
+            "  }",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static Root create() {",
+            "    return new Builder().build();",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize(final Builder builder) {",
+            "    this.repeatedModule = builder.repeatedModule;",
+            "  }",
+            "",
+            "  @Override",
+            "  public Leaf.Builder leaf() {",
+            "    return new LeafBuilder();",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private RepeatedModule repeatedModule;",
+            "",
+            "    private Builder() {}",
+            "",
+            "    public Root build() {",
+            "      if (repeatedModule == null) {",
+            "        this.repeatedModule = new RepeatedModule();",
+            "      }",
+            "      return new DaggerRoot(this);",
+            "    }",
+            "",
+            "    public Builder repeatedModule(RepeatedModule repeatedModule) {",
+            "      this.repeatedModule = Preconditions.checkNotNull(repeatedModule);",
+            "      return this;",
+            "    }",
+            "  }",
+            "",
+            "  private final class LeafBuilder extends DaggerLeaf.Builder {",
+            "    @Override",
+            "    public Leaf build() {",
+            "      return new LeafImpl(this);",
+            "    }",
+            "",
+            "    @Override",
+            "    public LeafBuilder repeatedModule(RepeatedModule repeatedModule) {",
+            "      throw new UnsupportedOperationException(",
+            "        String.format(",
+            "          \"%s cannot be set because it is inherited from the enclosing component\",",
+            "          RepeatedModule.class.getCanonicalName()));",
+            "    }",
+            "  }",
+            "",
+            "  protected final class LeafImpl extends DaggerLeaf {",
+            "    private LeafImpl(LeafBuilder builder) {",
+            "      configureInitialization(builder);",
+            "    }",
+            "",
+            "    @Override",
+            "    public int i() {",
+            "      return DaggerRoot.this.repeatedModule.i();",
+            "    }",
+            "  }",
+            "}");
+    compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerRoot")
+        .hasSourceEquivalentTo(generatedRoot);
+  }
+
   private void createAncillaryClasses(
       ImmutableList.Builder<JavaFileObject> filesBuilder, String... ancillaryClasses) {
     for (String className : ancillaryClasses) {
