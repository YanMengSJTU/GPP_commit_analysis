diff --git a/compiler/src/main/java/dagger/internal/codegen/Mirrors.java b/compiler/src/main/java/dagger/internal/codegen/Mirrors.java
index 10c5d2dc4..4c317002b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Mirrors.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Mirrors.java
@@ -15,6 +15,7 @@
  */
 package dagger.internal.codegen;
 
+import static com.google.common.base.Preconditions.checkNotNull;
 import static javax.lang.model.type.TypeKind.ARRAY;
 import static javax.lang.model.type.TypeKind.DECLARED;
 import static javax.lang.model.type.TypeKind.EXECUTABLE;
@@ -22,10 +23,13 @@
 import static javax.lang.model.type.TypeKind.WILDCARD;
 
 import com.google.common.base.Equivalence;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.ImmutableSet.Builder;
 
 import java.util.Iterator;
 import java.util.List;
 
+import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.ArrayType;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.ErrorType;
@@ -243,5 +247,47 @@ static int hash(TypeMirror mirror) {
     return mirror == null ? 0 : mirror.accept(HASH_VISITOR, null);
   }
 
+  static ImmutableSet<TypeElement> referencedTypes(TypeMirror type) {
+    checkNotNull(type);
+    ImmutableSet.Builder<TypeElement> elements = ImmutableSet.builder();
+    type.accept(new SimpleTypeVisitor6<Void, ImmutableSet.Builder<TypeElement>>() {
+      @Override
+      public Void visitArray(ArrayType t, Builder<TypeElement> p) {
+        t.getComponentType().accept(this, p);
+        return null;
+      }
+
+      @Override
+      public Void visitDeclared(DeclaredType t, Builder<TypeElement> p) {
+        p.add(ElementUtil.asTypeElement(t.asElement()));
+        for (TypeMirror typeArgument : t.getTypeArguments()) {
+          typeArgument.accept(this, p);
+        }
+        return null;
+      }
+
+      @Override
+      public Void visitTypeVariable(TypeVariable t, Builder<TypeElement> p) {
+        t.getLowerBound().accept(this, p);
+        t.getUpperBound().accept(this, p);
+        return null;
+      }
+
+      @Override
+      public Void visitWildcard(WildcardType t, Builder<TypeElement> p) {
+        TypeMirror extendsBound = t.getExtendsBound();
+        if (extendsBound != null) {
+          extendsBound.accept(this, p);
+        }
+        TypeMirror superBound = t.getSuperBound();
+        if (superBound != null) {
+          superBound.accept(this, p);
+        }
+        return null;
+      }
+    }, elements);
+    return elements.build();
+  }
+
   private Mirrors() {}
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/MirrorsTest.java b/compiler/src/test/java/dagger/internal/codegen/MirrorsTest.java
index 5eb86ef5c..689951d8e 100644
--- a/compiler/src/test/java/dagger/internal/codegen/MirrorsTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/MirrorsTest.java
@@ -17,19 +17,16 @@
 
 import static javax.lang.model.type.TypeKind.NONE;
 import static javax.lang.model.type.TypeKind.VOID;
+import static org.truth0.Truth.ASSERT;
 
 import com.google.common.base.Function;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.testing.EquivalenceTester;
 import com.google.testing.compile.CompilationRule;
 
-import org.junit.Rule;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
 import java.lang.annotation.Annotation;
 import java.util.List;
 import java.util.Map;
@@ -38,6 +35,7 @@
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.ErrorType;
 import javax.lang.model.type.PrimitiveType;
@@ -45,9 +43,15 @@
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.type.TypeVisitor;
 import javax.lang.model.type.WildcardType;
+import javax.lang.model.util.ElementFilter;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
 /**
  * Tests {@link Mirrors}.
  */
@@ -164,6 +168,72 @@ public static void b() throws RuntimeException {}
     public static <T> void b() {}
   }
 
+  @Test public void testReferencedTypes() {
+    Elements elements = compilationRule.getElements();
+    TypeElement testDataElement = elements
+        .getTypeElement(ReferencedTypesTestData.class.getCanonicalName());
+    ImmutableMap<String, VariableElement> fieldIndex =
+        FluentIterable.from(ElementFilter.fieldsIn(testDataElement.getEnclosedElements()))
+            .uniqueIndex(new Function<VariableElement, String>() {
+              @Override public String apply(VariableElement input) {
+                return input.getSimpleName().toString();
+              }
+            });
+
+    TypeElement objectElement =
+        elements.getTypeElement(Object.class.getCanonicalName());
+    TypeElement stringElement =
+        elements.getTypeElement(String.class.getCanonicalName());
+    TypeElement integerElement =
+        elements.getTypeElement(Integer.class.getCanonicalName());
+    TypeElement setElement =
+        elements.getTypeElement(Set.class.getCanonicalName());
+    TypeElement mapElement =
+        elements.getTypeElement(Map.class.getCanonicalName());
+    TypeElement charSequenceElement =
+        elements.getTypeElement(CharSequence.class.getCanonicalName());
+
+    ASSERT.that(Mirrors.referencedTypes(fieldIndex.get("f1").asType()))
+        .has().exactly(objectElement);
+    ASSERT.that(Mirrors.referencedTypes(fieldIndex.get("f2").asType()))
+        .has().exactly(setElement, stringElement);
+    ASSERT.that(Mirrors.referencedTypes(fieldIndex.get("f3").asType()))
+        .has().exactly(mapElement, stringElement, objectElement);
+    ASSERT.that(Mirrors.referencedTypes(fieldIndex.get("f4").asType()))
+        .has().exactly(integerElement);
+    ASSERT.that(Mirrors.referencedTypes(fieldIndex.get("f5").asType()))
+        .has().exactly(setElement);
+    ASSERT.that(Mirrors.referencedTypes(fieldIndex.get("f6").asType()))
+        .has().exactly(setElement, charSequenceElement);
+    ASSERT.that(Mirrors.referencedTypes(fieldIndex.get("f7").asType()))
+        .has().exactly(mapElement, stringElement, setElement, charSequenceElement);
+    ASSERT.that(Mirrors.referencedTypes(fieldIndex.get("f8").asType()))
+        .has().exactly(stringElement);
+    ASSERT.that(Mirrors.referencedTypes(fieldIndex.get("f9").asType()))
+        .has().exactly(stringElement);
+    ASSERT.that(Mirrors.referencedTypes(fieldIndex.get("f10").asType())).isEmpty();
+    ASSERT.that(Mirrors.referencedTypes(fieldIndex.get("f11").asType())).isEmpty();
+    ASSERT.that(Mirrors.referencedTypes(fieldIndex.get("f12").asType()))
+        .has().exactly(setElement, stringElement);
+  }
+
+  @SuppressWarnings("unused") // types used in compiler tests
+  private static final class ReferencedTypesTestData {
+    Object f1;
+    Set<String> f2;
+    Map<String, Object> f3;
+    Integer f4;
+    Set<?> f5;
+    Set<? extends CharSequence> f6;
+    Map<String, Set<? extends CharSequence>> f7;
+    String[] f8;
+    String[][] f9;
+    int f10;
+    int[] f11;
+    Set<? super String> f12;
+  }
+
+
   private static final ErrorType FAKE_ERROR_TYPE = new ErrorType() {
     @Override
     public TypeKind getKind() {
