diff --git a/compiler/src/it/functional-tests/src/main/java/test/MultibindingComponent.java b/compiler/src/it/functional-tests/src/main/java/test/MultibindingComponent.java
index 3b76fc642..731df3f57 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/MultibindingComponent.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/MultibindingComponent.java
@@ -16,9 +16,16 @@
 package test;
 
 import dagger.Component;
+import java.util.Collection;
 import java.util.Map;
+import java.util.Set;
+import javax.inject.Provider;
 
 @Component(modules = MultibindingModule.class)
 interface MultibindingComponent {
   Map<String, String> map();
+  Map<String, Provider<String>> mapOfProviders();
+  Set<String> mapKeys();
+  Collection<String> mapValues();
+  Set<Integer> set();
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/MultibindingModule.java b/compiler/src/it/functional-tests/src/main/java/test/MultibindingModule.java
index 0e83ed519..2b9b441ac 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/MultibindingModule.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/MultibindingModule.java
@@ -17,8 +17,13 @@
 
 import dagger.Module;
 import dagger.Provides;
+import java.util.Collection;
+import java.util.Map;
+import java.util.Set;
+import javax.inject.Provider;
 
 import static dagger.Provides.Type.MAP;
+import static dagger.Provides.Type.SET;
 
 @Module
 class MultibindingModule {
@@ -29,4 +34,20 @@
   @Provides(type = MAP) @TestKey("bar") String provideBarKey() {
     return "bar value";
   }
+
+  @Provides(type = SET) int provideFiveToSet() {
+    return 5;
+  }
+
+  @Provides(type = SET) int provideSixToSet() {
+    return 6;
+  }
+
+  @Provides Set<String> provideMapKeys(Map<String, Provider<String>> map) {
+    return map.keySet();
+  }
+
+  @Provides Collection<String> provideMapValues(Map<String, String> map) {
+    return map.values();
+  }
 }
diff --git a/compiler/src/it/functional-tests/src/test/java/test/MultibindingTest.java b/compiler/src/it/functional-tests/src/test/java/test/MultibindingTest.java
index dfcf34189..23fb61bb7 100644
--- a/compiler/src/it/functional-tests/src/test/java/test/MultibindingTest.java
+++ b/compiler/src/it/functional-tests/src/test/java/test/MultibindingTest.java
@@ -16,6 +16,7 @@
 package test;
 
 import java.util.Map;
+import javax.inject.Provider;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
@@ -30,5 +31,12 @@
     assertThat(map).hasSize(2);
     assertThat(map).containsEntry("foo", "foo value");
     assertThat(map).containsEntry("bar", "bar value");
+    Map<String, Provider<String>> mapOfProviders = multibindingComponent.mapOfProviders();
+    assertThat(mapOfProviders).hasSize(2);
+    assertThat(mapOfProviders.get("foo").get()).isEqualTo("foo value");
+    assertThat(mapOfProviders.get("bar").get()).isEqualTo("bar value");
+    assertThat(multibindingComponent.mapKeys()).containsExactly("foo", "bar");
+    assertThat(multibindingComponent.mapValues()).containsExactly("foo value", "bar value");
+    assertThat(multibindingComponent.set()).containsExactly(5, 6);
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
index bce63acc0..c2c5c0178 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
@@ -15,8 +15,8 @@
  */
 package dagger.internal.codegen;
 
+import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
-
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Function;
 import com.google.common.base.Optional;
@@ -124,7 +124,7 @@ DependencyRequest forImplicitMapBinding(DependencyRequest delegatingRequest, Key
       checkNotNull(delegatingRequest);
       return new AutoValue_DependencyRequest(Kind.PROVIDER, delegateKey,
           delegatingRequest.requestElement(),
-          MoreTypes.asDeclared(delegatingRequest.requestElement().getEnclosingElement().asType()),
+          getEnclosingType(delegatingRequest.requestElement()),
           false /* doesn't allow null */);
     }
 
@@ -132,8 +132,8 @@ DependencyRequest forRequiredVariable(VariableElement variableElement) {
       checkNotNull(variableElement);
       TypeMirror type = variableElement.asType();
       Optional<AnnotationMirror> qualifier = InjectionAnnotations.getQualifier(variableElement);
-      return newDependencyRequest(variableElement, type, qualifier, MoreTypes.asDeclared(
-          variableElement.getEnclosingElement().getEnclosingElement().asType()));
+      return newDependencyRequest(variableElement, type, qualifier,
+          getEnclosingType(variableElement));
     }
 
     DependencyRequest forRequiredResolvedVariable(DeclaredType container,
@@ -152,7 +152,7 @@ DependencyRequest forComponentProvisionMethod(ExecutableElement provisionMethod)
       TypeMirror type = provisionMethod.getReturnType();
       Optional<AnnotationMirror> qualifier = InjectionAnnotations.getQualifier(provisionMethod);
       return newDependencyRequest(provisionMethod, type, qualifier,
-          MoreTypes.asDeclared(provisionMethod.getEnclosingElement().asType()));
+          getEnclosingType(provisionMethod));
     }
 
     DependencyRequest forComponentProductionMethod(ExecutableElement productionMethod) {
@@ -161,8 +161,7 @@ DependencyRequest forComponentProductionMethod(ExecutableElement productionMetho
           "Component production methods must be empty: %s", productionMethod);
       TypeMirror type = productionMethod.getReturnType();
       Optional<AnnotationMirror> qualifier = InjectionAnnotations.getQualifier(productionMethod);
-      DeclaredType container =
-          MoreTypes.asDeclared(productionMethod.getEnclosingElement().asType());
+      DeclaredType container = getEnclosingType(productionMethod);
       // Only a component production method can be a request for a ListenableFuture, so we
       // special-case it here.
       if (isTypeOf(ListenableFuture.class, type)) {
@@ -187,7 +186,7 @@ DependencyRequest forComponentMembersInjectionMethod(ExecutableElement membersIn
           keyFactory.forMembersInjectedType(
               Iterables.getOnlyElement(membersInjectionMethod.getParameters()).asType()),
           membersInjectionMethod,
-          MoreTypes.asDeclared(membersInjectionMethod.getEnclosingElement().asType()),
+          getEnclosingType(membersInjectionMethod),
           false /* doesn't allow null */);
     }
 
@@ -252,5 +251,12 @@ static KindAndType extractKindAndType(TypeMirror type) {
         return new AutoValue_DependencyRequest_Factory_KindAndType(Kind.INSTANCE, type);
       }
     }
+
+    static DeclaredType getEnclosingType(Element element) {
+      while (!MoreElements.isType(element)) {
+        element = element.getEnclosingElement();
+      }
+      return MoreTypes.asDeclared(element.asType());
+    }
   }
 }
