diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
index 795a5e185..7ff49b5b8 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -71,6 +71,7 @@
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.PUBLIC;
+import static javax.lang.model.element.Modifier.STATIC;
 import static javax.lang.model.type.TypeKind.DECLARED;
 import static javax.lang.model.type.TypeKind.VOID;
 
@@ -1106,9 +1107,9 @@ private CodeBlock initializeFactoryForContributionBinding(ContributionBinding bi
         {
           TypeElement dependencyType = dependencyTypeForBinding(binding);
           String dependencyVariable = simpleVariableName(dependencyType);
+          String componentMethod = binding.bindingElement().get().getSimpleName().toString();
           CodeBlock callFactoryMethod =
-              CodeBlock.of(
-                  "$L.$L()", dependencyVariable, binding.bindingElement().get().getSimpleName());
+              CodeBlock.of("$L.$L()", dependencyVariable, componentMethod);
           // TODO(sameb): This throws a very vague NPE right now.  The stack trace doesn't
           // help to figure out what the method or return type is.  If we include a string
           // of the return type or method name in the error message, that can defeat obfuscation.
@@ -1124,26 +1125,36 @@ private CodeBlock initializeFactoryForContributionBinding(ContributionBinding bi
                       Preconditions.class,
                       callFactoryMethod,
                       CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD);
+          ClassName dependencyClassName = ClassName.get(dependencyType);
+          String factoryName =
+              dependencyClassName.toString().replaceAll("\\.", "_") + "_" + componentMethod;
+          MethodSpec.Builder getMethod =
+              methodBuilder("get")
+                  .addAnnotation(Override.class)
+                  .addModifiers(PUBLIC)
+                  .returns(bindingKeyTypeName)
+                  .addCode(getMethodBody);
+          if (binding.nullableType().isPresent()) {
+            getMethod.addAnnotation(
+                ClassName.get(MoreTypes.asTypeElement(binding.nullableType().get())));
+          }
+          component.addType(
+              TypeSpec.classBuilder(factoryName)
+                  .addSuperinterface(providerOf(bindingKeyTypeName))
+                  .addModifiers(PRIVATE, STATIC)
+                  .addField(dependencyClassName, dependencyVariable, PRIVATE, FINAL)
+                  .addMethod(
+                      constructorBuilder()
+                          .addParameter(dependencyClassName, dependencyVariable)
+                          .addStatement("this.$1L = $1L", dependencyVariable)
+                          .build())
+                  .addMethod(getMethod.build())
+                  .build());
           return CodeBlock.of(
-              Joiner.on('\n')
-                  .join(
-                      "new $1L<$2T>() {",
-                      "  private final $5T $6L = $3L;",
-                      "  $4L@Override public $2T get() {",
-                      "    $7L",
-                      "  }",
-                      "}"),
-              // TODO(ronshapiro): Until we remove Factory, fully qualify the import so it doesn't
-              // conflict with anyone that has Factory as an inner type of a component (like
-              // AndroidInjector.Factory
-              /* 1 */ "dagger.internal.Factory",
-              /* 2 */ bindingKeyTypeName,
-              /* 3 */ getComponentContributionExpression(
-                  ComponentRequirement.forDependency(dependencyType.asType())),
-              /* 4 */ nullableAnnotation(binding.nullableType()),
-              /* 5 */ TypeName.get(dependencyType.asType()),
-              /* 6 */ dependencyVariable,
-              /* 7 */ getMethodBody);
+              "new $L($L)",
+              factoryName,
+              getComponentContributionExpression(
+                  ComponentRequirement.forDependency(dependencyType.asType())));
         }
 
       case SUBCOMPONENT_BUILDER:
@@ -1282,12 +1293,6 @@ private CodeBlock decorateForScope(CodeBlock factoryCreate, Scope scope) {
     }
   }
 
-  private CodeBlock nullableAnnotation(Optional<DeclaredType> nullableType) {
-    return nullableType.isPresent()
-        ? CodeBlock.of("@$T ", TypeName.get(nullableType.get()))
-        : CodeBlock.of("");
-  }
-
   private CodeBlock initializeMembersInjectorForBinding(MembersInjectionBinding binding) {
     return binding.injectionSites().isEmpty()
         ? CodeBlock.of("$T.noOp()", MEMBERS_INJECTORS)
diff --git a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
index 74e1b9e57..cd4dba515 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
@@ -1685,12 +1685,7 @@ public void testDefaultPackage() {
             "",
             "  @SuppressWarnings(\"unchecked\")",
             "  private void initialize(final Builder builder) {",
-            "    this.aProvider = new dagger.internal.Factory<A>() {",
-            "      private final AComponent aComponent = builder.aComponent;",
-            "      @Override public A get() {",
-            "        return Preconditions.checkNotNull(aComponent.a(), " + NPE_LITERAL + ");",
-            "      }",
-            "    };",
+            "    this.aProvider = new test_AComponent_a(builder.aComponent);",
             "    this.bProvider = B_Factory.create(aProvider);",
             "  }",
             "",
@@ -1718,6 +1713,19 @@ public void testDefaultPackage() {
             "      return this;",
             "    }",
             "  }",
+            "",
+            "  private static class test_AComponent_a implements Provider<A> {",
+            "    private final AComponent aComponent;",
+            "    ",
+            "    test_AComponent_a(AComponent aComponent) {",
+            "        this.aComponent = aComponent;",
+            "    }",
+            "    ",
+            "    @Override()",
+            "    public A get() {",
+            "      return Preconditions.checkNotNull(aComponent.a(), " + NPE_LITERAL + ");",
+            "    }",
+            "  }",
             "}");
     Compilation compilation =
         daggerCompiler().compile(aFile, bFile, aComponentFile, bComponentFile);
