diff --git a/java/dagger/internal/codegen/MultibindingExpression.java b/java/dagger/internal/codegen/MultibindingExpression.java
index 337802ec1..93c773740 100644
--- a/java/dagger/internal/codegen/MultibindingExpression.java
+++ b/java/dagger/internal/codegen/MultibindingExpression.java
@@ -16,7 +16,6 @@
 
 package dagger.internal.codegen;
 
-import static com.google.common.base.Preconditions.checkState;
 import static dagger.internal.codegen.BindingRequest.bindingRequest;
 
 import com.google.common.collect.ImmutableSet;
@@ -55,11 +54,11 @@ Expression getDependencyExpression(ClassName requestingClass) {
   protected abstract Expression buildDependencyExpression(ClassName requestingClass);
 
   /**
-   * Returns the subset of {@code dependencies} that represent multibinding
-   * contributions that were not included in a superclass implementation of this multibinding
-   * method. This is relevant only for ahead-of-time subcomponents. When not generating
-   * ahead-of-time subcomponents there is only one implementation of a multibinding expression and
-   * all {@link DependencyRequest}s from the argment are returned.
+   * Returns the subset of {@code dependencies} that represent multibinding contributions that were
+   * not included in a superclass implementation of this multibinding method. This is relevant only
+   * for ahead-of-time subcomponents. When not generating ahead-of-time subcomponents there is only
+   * one implementation of a multibinding expression and all {@link DependencyRequest}s from the
+   * argment are returned.
    */
   protected SetView<DependencyRequest> getNewContributions(
       ImmutableSet<DependencyRequest> dependencies) {
@@ -77,16 +76,12 @@ Expression getDependencyExpression(ClassName requestingClass) {
       Optional<ModifiableBindingMethod> method =
           generatedComponentModel.getModifiableBindingMethod(
               bindingRequest(binding.key(), RequestKind.INSTANCE));
-      checkState(
-          method.isPresent(),
-          "Generating a multibinding super method call when no method has been registered for the "
-              + "binding. Binding is for a %s in %s",
-          binding.key(),
-          generatedComponentModel.name());
-      ImmutableSet<DependencyRequest> superclassContributions =
-          generatedComponentModel.superclassContributionsMade(binding.key());
-      if (!superclassContributions.isEmpty()) {
-        return Optional.of(CodeBlock.of("super.$L()", method.get().methodSpec().name));
+      if (method.isPresent()) {
+        ImmutableSet<DependencyRequest> superclassContributions =
+            generatedComponentModel.superclassContributionsMade(binding.key());
+        if (!superclassContributions.isEmpty()) {
+          return Optional.of(CodeBlock.of("super.$L()", method.get().methodSpec().name));
+        }
       }
     }
     return Optional.empty();
diff --git a/javatests/dagger/functional/BUILD b/javatests/dagger/functional/BUILD
index 65bc0399c..6d5f0d5d9 100644
--- a/javatests/dagger/functional/BUILD
+++ b/javatests/dagger/functional/BUILD
@@ -60,8 +60,6 @@ GenJavaTests(
             "ReleasableReferencesComponentsTest.java",
             "ReusableTest.java",
             "ComponentWithReusableBindings.java",
-            "subcomponent/MultibindingSubcomponents.java",
-            "subcomponent/SubcomponentMultibindingsTest.java",
         ],
     ),
     javacopts = DOCLINT_HTML_AND_SYNTAX,
