diff --git a/java/dagger/android/AndroidInjectionKey.java b/java/dagger/android/AndroidInjectionKey.java
new file mode 100644
index 000000000..d4a5d72c2
--- /dev/null
+++ b/java/dagger/android/AndroidInjectionKey.java
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android;
+
+import static java.lang.annotation.ElementType.METHOD;
+
+import dagger.MapKey;
+import dagger.internal.Beta;
+import java.lang.annotation.Documented;
+import java.lang.annotation.Target;
+
+/**
+ * {@link MapKey} annotation to key {@link AndroidInjector.Factory} bindings. The {@linkplain
+ * #value() value} of the annotation is the canonical name of the class that will be passed to
+ * {@link AndroidInjector#inject(Object)}.
+ *
+ * <p>All key strings will be obfuscated by ProGuard/R8/AppReduce if the named class is obfuscated.
+ *
+ * <p>
+ * You should only use this annotation if you are using a version of ProGuard/R8/AppReduce that
+ * supports the {@code -identifiernamestring} flag.
+ */
+@Beta
+@MapKey
+@Target(METHOD)
+@Documented
+public @interface AndroidInjectionKey {
+  /** The fully qualified class name of the type to be injected. */
+  String value();
+}
diff --git a/java/dagger/android/AndroidInjectionModule.java b/java/dagger/android/AndroidInjectionModule.java
index 224e07f71..05f1adae3 100644
--- a/java/dagger/android/AndroidInjectionModule.java
+++ b/java/dagger/android/AndroidInjectionModule.java
@@ -38,23 +38,42 @@
   abstract Map<Class<? extends Activity>, AndroidInjector.Factory<? extends Activity>>
       activityInjectorFactories();
 
+  @Multibinds
+  abstract Map<String, AndroidInjector.Factory<? extends Activity>>
+      activityInjectorFactoriesWithStringKeys();
+
   @Multibinds
   abstract Map<Class<? extends Fragment>, AndroidInjector.Factory<? extends Fragment>>
       fragmentInjectorFactories();
 
+  @Multibinds
+  abstract Map<String, AndroidInjector.Factory<? extends Fragment>>
+      fragmentInjectorFactoriesWithStringKeys();
+
   @Multibinds
   abstract Map<Class<? extends Service>, AndroidInjector.Factory<? extends Service>>
       serviceInjectorFactories();
 
+  @Multibinds
+  abstract Map<String, AndroidInjector.Factory<? extends Service>>
+      serviceInjectorFactoriesWithStringKeys();
+
   @Multibinds
   abstract Map<
           Class<? extends BroadcastReceiver>, AndroidInjector.Factory<? extends BroadcastReceiver>>
       broadcastReceiverInjectorFactories();
 
   @Multibinds
-  abstract Map<
-          Class<? extends ContentProvider>, AndroidInjector.Factory<? extends ContentProvider>>
+  abstract Map<String, AndroidInjector.Factory<? extends BroadcastReceiver>>
+      broadcastReceiverInjectorFactoriesWithStringKeys();
+
+  @Multibinds
+  abstract Map<Class<? extends ContentProvider>, AndroidInjector.Factory<? extends ContentProvider>>
       contentProviderInjectorFactories();
 
+  @Multibinds
+  abstract Map<String, AndroidInjector.Factory<? extends ContentProvider>>
+      contentProviderInjectorFactoriesWithStringKeys();
+
   private AndroidInjectionModule() {}
 }
diff --git a/java/dagger/android/BUILD b/java/dagger/android/BUILD
index cb2aa8c17..6dfa1c5e3 100644
--- a/java/dagger/android/BUILD
+++ b/java/dagger/android/BUILD
@@ -27,7 +27,10 @@ load("//tools:maven.bzl", "pom_file", "POM_VERSION")
 
 # Work around b/70476182 which prevents Kythe from connecting :producers to the .java files it
 # contains.
-SRCS = glob(["*.java"])
+SRCS = glob([
+    "*.java",
+    "internal/*.java",
+])
 
 filegroup(
     name = "android-srcs",
@@ -82,6 +85,7 @@ javadoc_library(
     name = "android-javadoc",
     srcs = [":android-srcs"],
     android_api_level = 26,
+    exclude_packages = ["dagger.android.internal"],
     root_packages = ["dagger.android"],
     deps = [":android"],
 )
diff --git a/java/dagger/android/DispatchingAndroidInjector.java b/java/dagger/android/DispatchingAndroidInjector.java
index 3c9b7775b..9b011dd13 100644
--- a/java/dagger/android/DispatchingAndroidInjector.java
+++ b/java/dagger/android/DispatchingAndroidInjector.java
@@ -16,6 +16,7 @@
 
 package dagger.android;
 
+import static dagger.internal.DaggerCollections.newLinkedHashMapWithExpectedSize;
 import static dagger.internal.Preconditions.checkNotNull;
 
 import android.app.Activity;
@@ -26,6 +27,7 @@
 import java.util.Collections;
 import java.util.List;
 import java.util.Map;
+import java.util.Map.Entry;
 import javax.inject.Inject;
 import javax.inject.Provider;
 
@@ -47,13 +49,39 @@
       "No injector factory bound for Class<%1$s>. Injector factories were bound for supertypes "
           + "of %1$s: %2$s. Did you mean to bind an injector factory for the subtype?";
 
-  private final Map<Class<? extends T>, Provider<AndroidInjector.Factory<? extends T>>>
-      injectorFactories;
+  private final Map<String, Provider<AndroidInjector.Factory<? extends T>>> injectorFactories;
 
   @Inject
   DispatchingAndroidInjector(
-      Map<Class<? extends T>, Provider<AndroidInjector.Factory<? extends T>>> injectorFactories) {
-    this.injectorFactories = injectorFactories;
+      Map<Class<? extends T>, Provider<Factory<? extends T>>> injectorFactoriesWithClassKeys,
+      Map<String, Provider<Factory<? extends T>>> injectorFactoriesWithStringKeys) {
+    this.injectorFactories = merge(injectorFactoriesWithClassKeys, injectorFactoriesWithStringKeys);
+  }
+
+  /**
+   * Merges the two maps into one by transforming the values of the {@code classKeyedMap} with
+   * {@link Class#getName()}.
+   *
+   * <p>An SPI plugin verifies the logical uniqueness of the keysets of these two maps so we're
+   * assured there's no overlap.
+   *
+   * <p>Ideally we could achieve this with a generic {@code @Provides} method, but we'd need to have
+   * <i>N</i> modules that each extend one base module.
+   */
+  private static <C, V> Map<String, V> merge(
+      Map<Class<? extends C>, V> classKeyedMap, Map<String, V> stringKeyedMap) {
+    if (classKeyedMap.isEmpty()) {
+      return stringKeyedMap;
+    }
+
+    Map<String, V> merged =
+        newLinkedHashMapWithExpectedSize(classKeyedMap.size() + stringKeyedMap.size());
+    merged.putAll(stringKeyedMap);
+    for (Entry<Class<? extends C>, V> entry : classKeyedMap.entrySet()) {
+      merged.put(entry.getKey().getName(), entry.getValue());
+    }
+
+    return Collections.unmodifiableMap(merged);
   }
 
   /**
@@ -66,7 +94,7 @@
   @CanIgnoreReturnValue
   public boolean maybeInject(T instance) {
     Provider<AndroidInjector.Factory<? extends T>> factoryProvider =
-        injectorFactories.get(instance.getClass());
+        injectorFactories.get(instance.getClass().getName());
     if (factoryProvider == null) {
       return false;
     }
@@ -119,13 +147,12 @@ public void inject(T instance) {
 
   /** Returns an error message with the class names that are supertypes of {@code instance}. */
   private String errorMessageSuggestions(T instance) {
-    List<String> suggestions = new ArrayList<String>();
-    for (Class<? extends T> activityClass : injectorFactories.keySet()) {
-      if (activityClass.isInstance(instance)) {
-        suggestions.add(activityClass.getCanonicalName());
+    List<String> suggestions = new ArrayList<>();
+    for (Class<?> clazz = instance.getClass(); clazz != null; clazz = clazz.getSuperclass()) {
+      if (injectorFactories.containsKey(clazz.getCanonicalName())) {
+        suggestions.add(clazz.getCanonicalName());
       }
     }
-    Collections.sort(suggestions);
 
     return suggestions.isEmpty()
         ? String.format(NO_SUPERTYPES_BOUND_FORMAT, instance.getClass().getCanonicalName())
diff --git a/java/dagger/android/internal/AndroidInjectionKeys.java b/java/dagger/android/internal/AndroidInjectionKeys.java
new file mode 100644
index 000000000..f30b92cdd
--- /dev/null
+++ b/java/dagger/android/internal/AndroidInjectionKeys.java
@@ -0,0 +1,37 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.internal;
+
+/**
+ * An internal implementation detail of Dagger's generated code. This is not guaranteed to remain
+ * consistent from version to version.
+ */
+public final class AndroidInjectionKeys {
+  /**
+   * Accepts the fully qualified name of a class that is injected with {@code dagger.android}.
+   *
+   * <p>From a runtime perspective, this method does nothing except return its single argument. It
+   * is used as a signal to bytecode shrinking tools that its argument should be rewritten if it
+   * corresponds to a class that has been obfuscated/relocated. Once it is done so, it is expected
+   * that the argument will be inlined and this method will go away.
+   */
+  public static String of(String mapKey) {
+    return mapKey;
+  }
+
+  private AndroidInjectionKeys() {}
+}
diff --git a/java/dagger/android/processor/AndroidMapKeyValidator.java b/java/dagger/android/processor/AndroidMapKeyValidator.java
index a6c8a80f0..4084ff4e2 100644
--- a/java/dagger/android/processor/AndroidMapKeyValidator.java
+++ b/java/dagger/android/processor/AndroidMapKeyValidator.java
@@ -17,11 +17,11 @@
 package dagger.android.processor;
 
 import static com.google.auto.common.AnnotationMirrors.getAnnotatedAnnotations;
-import static com.google.auto.common.AnnotationMirrors.getAnnotationValue;
 import static com.google.auto.common.MoreElements.getAnnotationMirror;
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static dagger.android.processor.AndroidMapKeys.annotationsAndFrameworkTypes;
+import static dagger.android.processor.AndroidMapKeys.injectedTypeFromMapKey;
 
 import com.google.auto.common.BasicAnnotationProcessor.ProcessingStep;
 import com.google.auto.common.MoreElements;
@@ -29,6 +29,7 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.SetMultimap;
 import dagger.Binds;
+import dagger.android.AndroidInjectionKey;
 import dagger.android.AndroidInjector;
 import java.lang.annotation.Annotation;
 import java.util.Set;
@@ -62,7 +63,10 @@
 
   @Override
   public Set<? extends Class<? extends Annotation>> annotations() {
-    return annotationsAndFrameworkTypes(elements).keySet();
+    return ImmutableSet.<Class<? extends Annotation>>builder()
+        .addAll(annotationsAndFrameworkTypes(elements).keySet())
+        .add(AndroidInjectionKey.class)
+        .build();
   }
 
   @Override
@@ -84,7 +88,7 @@ private void validateMethod(Class<? extends Annotation> annotation, ExecutableEl
       return;
     }
 
-    TypeMirror frameworkType = annotationsAndFrameworkTypes(elements).get(annotation);
+    TypeMirror frameworkType = frameworkTypeForMapKey(method, annotation);
 
     if (!getAnnotatedAnnotations(method, Scope.class).isEmpty()) {
       SuppressWarnings suppressedWarnings = method.getAnnotation(SuppressWarnings.class);
@@ -102,11 +106,16 @@ private void validateMethod(Class<? extends Annotation> annotation, ExecutableEl
 
     DeclaredType intendedReturnType = injectorFactoryOf(types.getWildcardType(frameworkType, null));
     if (!MoreTypes.equivalence().equivalent(returnType, intendedReturnType)) {
+      String subject =
+          annotation.equals(AndroidInjectionKey.class)
+              ? method.toString()
+              : String.format("@%s methods", annotation.getCanonicalName());
+
       messager.printMessage(
           Kind.ERROR,
           String.format(
-              "@%s methods should bind %s, not %s. See https://google.github.io/dagger/android",
-              annotation.getCanonicalName(), intendedReturnType, returnType),
+              "%s should bind %s, not %s. See https://google.github.io/dagger/android",
+              subject, intendedReturnType, returnType),
           method);
     }
 
@@ -135,16 +144,30 @@ private void validateMapKeyMatchesBindsParameter(
       Class<? extends Annotation> annotation, ExecutableElement method) {
     TypeMirror parameterType = getOnlyElement(method.getParameters()).asType();
     AnnotationMirror annotationMirror = getAnnotationMirror(method, annotation).get();
-    TypeMirror mapKeyValue = (TypeMirror) getAnnotationValue(annotationMirror, "value").getValue();
-    if (!types.isAssignable(parameterType, injectorFactoryOf(mapKeyValue))) {
+    TypeMirror mapKeyType =
+        elements.getTypeElement(injectedTypeFromMapKey(annotationMirror).get()).asType();
+    if (!types.isAssignable(parameterType, injectorFactoryOf(mapKeyType))) {
       messager.printMessage(
           Kind.ERROR,
-          String.format("%s does not implement AndroidInjector<%s>", parameterType, mapKeyValue),
+          String.format("%s does not implement AndroidInjector<%s>", parameterType, mapKeyType),
           method,
           annotationMirror);
     }
   }
 
+  private TypeMirror frameworkTypeForMapKey(
+      ExecutableElement method, Class<? extends Annotation> annotation) {
+    AnnotationMirror annotationMirror = getAnnotationMirror(method, annotation).get();
+    TypeMirror mapKeyType =
+        elements.getTypeElement(injectedTypeFromMapKey(annotationMirror).get()).asType();
+    return annotationsAndFrameworkTypes(elements)
+        .values()
+        .stream()
+        .filter(frameworkType -> types.isAssignable(mapKeyType, frameworkType))
+        .findFirst()
+        .get();
+  }
+
   /** Returns a {@link DeclaredType} for {@code AndroidInjector.Factory<implementationType>}. */
   private DeclaredType injectorFactoryOf(TypeMirror implementationType) {
     return types.getDeclaredType(factoryElement(), implementationType);
diff --git a/java/dagger/android/processor/AndroidMapKeys.java b/java/dagger/android/processor/AndroidMapKeys.java
index 61eee8e75..64682070a 100644
--- a/java/dagger/android/processor/AndroidMapKeys.java
+++ b/java/dagger/android/processor/AndroidMapKeys.java
@@ -16,6 +16,7 @@
 
 package dagger.android.processor;
 
+import static com.google.auto.common.AnnotationMirrors.getAnnotationValue;
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static java.util.stream.Collectors.toMap;
@@ -25,9 +26,12 @@
 import com.google.auto.common.MoreTypes;
 import com.google.common.collect.ImmutableMap;
 import dagger.MapKey;
+import dagger.android.AndroidInjectionKey;
 import java.lang.annotation.Annotation;
 import java.util.List;
+import java.util.Optional;
 import java.util.stream.Stream;
+import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.TypeMirror;
@@ -50,12 +54,17 @@
                 elements.getPackageElement("dagger.android.support"))
             .filter(packageElement -> packageElement != null)
             .flatMap(packageElement -> typesIn(packageElement.getEnclosedElements()).stream())
+            .filter(AndroidMapKeys::isNotAndroidInjectionKey)
             .filter(type -> isAnnotationPresent(type, MapKey.class))
             .filter(mapKey -> mapKey.getAnnotation(MapKey.class).unwrapValue())
             .flatMap(AndroidMapKeys::classForAnnotationElement)
             .collect(toMap(key -> key, key -> mapKeyValue(key, elements))));
   }
 
+  private static boolean isNotAndroidInjectionKey(TypeElement type) {
+    return !type.getQualifiedName().contentEquals(AndroidInjectionKey.class.getCanonicalName());
+  }
+
   private static Stream<Class<? extends Annotation>> classForAnnotationElement(TypeElement type) {
     try {
       @SuppressWarnings("unchecked")
@@ -75,4 +84,21 @@ private static TypeMirror mapKeyValue(Class<? extends Annotation> annotation, El
     return ((WildcardType) getOnlyElement(MoreTypes.asDeclared(returnType).getTypeArguments()))
         .getExtendsBound();
   }
+
+  /**
+   * If {@code mapKey} is {@link AndroidInjectionKey}, returns the string value for the map key. If
+   * it's {@link dagger.android.ActivityKey} or one of the other class-based keys, returns the
+   * fully-qualified class name of the annotation value. Otherwise returns {@link Optional#empty()}.
+   */
+  static Optional<String> injectedTypeFromMapKey(AnnotationMirror mapKey) {
+    Object mapKeyClass = getAnnotationValue(mapKey, "value").getValue();
+    if (mapKeyClass instanceof String) {
+      return Optional.of((String) mapKeyClass);
+    } else if (mapKeyClass instanceof TypeMirror) {
+      TypeElement type = MoreTypes.asTypeElement((TypeMirror) mapKeyClass);
+      return Optional.of(type.getQualifiedName().toString());
+    } else {
+      return Optional.empty();
+    }
+  }
 }
diff --git a/java/dagger/android/processor/AndroidProcessor.java b/java/dagger/android/processor/AndroidProcessor.java
index 5db7fabeb..c46817018 100644
--- a/java/dagger/android/processor/AndroidProcessor.java
+++ b/java/dagger/android/processor/AndroidProcessor.java
@@ -16,13 +16,23 @@
 
 package dagger.android.processor;
 
+import static javax.tools.Diagnostic.Kind.ERROR;
+import static javax.tools.StandardLocation.CLASS_OUTPUT;
+
 import com.google.auto.common.BasicAnnotationProcessor;
 import com.google.auto.service.AutoService;
+import com.google.common.base.Ascii;
+import com.google.common.base.Joiner;
 import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
 import com.google.googlejavaformat.java.filer.FormattingFiler;
+import java.io.IOException;
+import java.io.Writer;
+import java.util.Set;
 import javax.annotation.processing.Filer;
 import javax.annotation.processing.Messager;
 import javax.annotation.processing.Processor;
+import javax.annotation.processing.RoundEnvironment;
 import javax.lang.model.SourceVersion;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
@@ -30,9 +40,22 @@
 /**
  * An {@linkplain javax.annotation.processing.Processor annotation processor} to verify usage of
  * {@code dagger.android} code.
+ *
+ * <p>Additionally, if {@code -Adagger.android.experimentalUseStringKeys} is passed to the
+ * compilation, a file will be generated to support obfuscated injected Android types used with
+ * {@code @AndroidInjectionKey}. The fact that this is generated is deliberate: not all versions of
+ * ProGuard/R8 support {@code -identifiernamestring}, so we can't include a ProGuard file in the
+ * dagger-android artifact Instead, we generate the file in {@code META-INF/proguard} only when
+ * users enable the flag. They should only be enabling it if their shrinker supports those files,
+ * and any version that does so will also support {@code -identifiernamestring}. This was added to
+ * R8 in <a href="https://r8.googlesource.com/r8/+/389123dfcc11e6dda0eec31ab62e1b7eb0da80d2">May
+ * 2018</a>.
  */
 @AutoService(Processor.class)
 public final class AndroidProcessor extends BasicAnnotationProcessor {
+  private static final String FLAG_EXPERIMENTAL_USE_STRING_KEYS =
+      "dagger.android.experimentalUseStringKeys";
+
   @Override
   protected Iterable<? extends ProcessingStep> initSteps() {
     Filer filer = new FormattingFiler(processingEnv.getFiler());
@@ -44,11 +67,61 @@
         new AndroidMapKeyValidator(elements, types, messager),
         new ContributesAndroidInjectorGenerator(
             new AndroidInjectorDescriptor.Validator(types, elements, messager),
+            useStringKeys(),
             filer,
             elements,
             processingEnv.getSourceVersion()));
   }
 
+  private boolean useStringKeys() {
+    if (!processingEnv.getOptions().containsKey(FLAG_EXPERIMENTAL_USE_STRING_KEYS)) {
+      return false;
+    }
+    String flagValue = processingEnv.getOptions().get(FLAG_EXPERIMENTAL_USE_STRING_KEYS);
+    if (flagValue == null || Ascii.equalsIgnoreCase(flagValue, "true")) {
+      return true;
+    } else if (Ascii.equalsIgnoreCase(flagValue, "false")) {
+      return false;
+    } else {
+      processingEnv
+          .getMessager()
+          .printMessage(
+              ERROR,
+              String.format(
+                  "Unknown flag value: %s. %s must be set to either 'true' or 'false'.",
+                  flagValue, FLAG_EXPERIMENTAL_USE_STRING_KEYS));
+      return false;
+    }
+  }
+
+  @Override
+  protected void postRound(RoundEnvironment roundEnv) {
+    if (roundEnv.processingOver() && useStringKeys()) {
+      try (Writer writer = createProguardFile()){
+        writer.write(
+            Joiner.on("\n")
+                .join(
+                    "-identifiernamestring class dagger.android.internal.AndroidInjectionKeys {",
+                    "  java.lang.String of(java.lang.String);",
+                    "}"));
+      } catch (IOException e) {
+        e.printStackTrace();
+      }
+    }
+  }
+
+  private Writer createProguardFile() throws IOException {
+    return processingEnv
+        .getFiler()
+        .createResource(CLASS_OUTPUT, "", "META-INF/proguard/dagger.android.AndroidInjectionKeys")
+        .openWriter();
+  }
+
+  @Override
+  public Set<String> getSupportedOptions() {
+    return ImmutableSet.of(FLAG_EXPERIMENTAL_USE_STRING_KEYS);
+  }
+
   @Override
   public SourceVersion getSupportedSourceVersion() {
     return SourceVersion.latestSupported();
diff --git a/java/dagger/android/processor/BUILD b/java/dagger/android/processor/BUILD
index 565b1b8a3..94caad6a1 100644
--- a/java/dagger/android/processor/BUILD
+++ b/java/dagger/android/processor/BUILD
@@ -42,6 +42,8 @@ java_library(
         "@google_bazel_common//third_party/java/javapoet",
         "@google_bazel_common//third_party/java/google_java_format",
         "//java/dagger:core",
+        "//java/dagger/model",
+        "//java/dagger/spi",
         # https://github.com/bazelbuild/bazel/issues/2517
         ":dagger-android-jars",
     ],
diff --git a/java/dagger/android/processor/ContributesAndroidInjectorGenerator.java b/java/dagger/android/processor/ContributesAndroidInjectorGenerator.java
index 2d1023abc..57404764c 100644
--- a/java/dagger/android/processor/ContributesAndroidInjectorGenerator.java
+++ b/java/dagger/android/processor/ContributesAndroidInjectorGenerator.java
@@ -46,6 +46,7 @@
 import dagger.Module;
 import dagger.Subcomponent;
 import dagger.Subcomponent.Builder;
+import dagger.android.AndroidInjectionKey;
 import dagger.android.AndroidInjector;
 import dagger.android.ContributesAndroidInjector;
 import dagger.android.processor.AndroidInjectorDescriptor.Validator;
@@ -65,12 +66,18 @@
   private final AndroidInjectorDescriptor.Validator validator;
   private final Filer filer;
   private final Elements elements;
+  private final boolean useStringKeys;
   private final SourceVersion sourceVersion;
 
   ContributesAndroidInjectorGenerator(
-      Validator validator, Filer filer, Elements elements, SourceVersion sourceVersion) {
-    this.filer = filer;
+      Validator validator,
+      boolean useStringKeys,
+      Filer filer,
+      Elements elements,
+      SourceVersion sourceVersion) {
     this.validator = validator;
+    this.useStringKeys = useStringKeys;
+    this.filer = filer;
     this.elements = elements;
     this.sourceVersion = sourceVersion;
   }
@@ -131,10 +138,7 @@ private MethodSpec bindAndroidInjectorFactory(
     return methodBuilder("bindAndroidInjectorFactory")
         .addAnnotation(Binds.class)
         .addAnnotation(IntoMap.class)
-        .addAnnotation(
-            AnnotationSpec.builder(descriptor.mapKeyType())
-                .addMember("value", "$T.class", descriptor.injectedType())
-                .build())
+        .addAnnotation(androidInjectorMapKey(descriptor))
         .addModifiers(ABSTRACT)
         .returns(
             parameterizedTypeName(
@@ -144,6 +148,17 @@ private MethodSpec bindAndroidInjectorFactory(
         .build();
   }
 
+  private AnnotationSpec androidInjectorMapKey(AndroidInjectorDescriptor descriptor) {
+    if (useStringKeys) {
+      return AnnotationSpec.builder(AndroidInjectionKey.class)
+          .addMember("value", "$S", descriptor.injectedType().toString())
+          .build();
+    }
+    return AnnotationSpec.builder(descriptor.mapKeyType())
+        .addMember("value", "$T.class", descriptor.injectedType())
+        .build();
+  }
+
   private TypeSpec subcomponent(
       AndroidInjectorDescriptor descriptor,
       ClassName subcomponentName,
diff --git a/java/dagger/android/processor/DuplicateAndroidInjectorsChecker.java b/java/dagger/android/processor/DuplicateAndroidInjectorsChecker.java
new file mode 100644
index 000000000..0e08debb3
--- /dev/null
+++ b/java/dagger/android/processor/DuplicateAndroidInjectorsChecker.java
@@ -0,0 +1,173 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.processor;
+
+import static com.google.auto.common.AnnotationMirrors.getAnnotatedAnnotations;
+import static com.google.common.collect.Iterables.getOnlyElement;
+import static dagger.android.processor.AndroidMapKeys.injectedTypeFromMapKey;
+import static java.util.stream.Collectors.collectingAndThen;
+import static java.util.stream.Collectors.toList;
+import static javax.tools.Diagnostic.Kind.ERROR;
+
+import com.google.auto.common.MoreTypes;
+import com.google.auto.service.AutoService;
+import com.google.common.collect.ImmutableListMultimap;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Maps;
+import com.google.common.collect.Multimaps;
+import dagger.MapKey;
+import dagger.android.AndroidInjector;
+import dagger.android.DispatchingAndroidInjector;
+import dagger.model.BindingGraph;
+import dagger.model.BindingGraph.BindingNode;
+import dagger.model.BindingKind;
+import dagger.model.Key;
+import dagger.spi.BindingGraphPlugin;
+import dagger.spi.DiagnosticReporter;
+import java.util.Formatter;
+import java.util.List;
+import java.util.Map;
+import java.util.Optional;
+import java.util.stream.Stream;
+import javax.inject.Provider;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.type.TypeKind;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
+
+/**
+ * Validates that the two maps that {@link DispatchingAndroidInjector} injects have logically
+ * different keys. If a contribution exists for the same {@code FooActivity} with
+ * {@code @ActivityKey(FooActivity.class)} and
+ * {@code @AndroidInjectionKey("com.example.FooActivity")}, report an error.
+ */
+@AutoService(BindingGraphPlugin.class)
+public final class DuplicateAndroidInjectorsChecker implements BindingGraphPlugin {
+  private Types types;
+  private Elements elements;
+
+  @Override
+  public void visitGraph(BindingGraph graph, DiagnosticReporter diagnosticReporter) {
+    for (BindingNode node : graph.bindingNodes()) {
+      if (isDispatchingAndroidInjector(node)) {
+        validateMapKeyUniqueness(node, graph, diagnosticReporter);
+      }
+    }
+  }
+
+  private boolean isDispatchingAndroidInjector(BindingNode node) {
+    Key key = node.binding().key();
+    return MoreTypes.isTypeOf(DispatchingAndroidInjector.class, key.type())
+        && !key.qualifier().isPresent();
+  }
+
+  private void validateMapKeyUniqueness(
+      BindingNode dispatchingAndroidInjectorNode,
+      BindingGraph graph,
+      DiagnosticReporter diagnosticReporter) {
+    ImmutableSet<BindingNode> injectorFactories =
+        injectorMapDependencies(dispatchingAndroidInjectorNode, graph)
+            .flatMap(injectorFactoryMap -> dependencies(injectorFactoryMap, graph))
+            .collect(collectingAndThen(toList(), ImmutableSet::copyOf));
+
+    ImmutableListMultimap.Builder<String, BindingNode> mapKeyIndex =
+        ImmutableListMultimap.builder();
+    for (BindingNode injectorFactory : injectorFactories) {
+      AnnotationMirror mapKey = mapKey(injectorFactory).get();
+      Optional<String> injectedType = injectedTypeFromMapKey(mapKey);
+      if (injectedType.isPresent()) {
+        mapKeyIndex.put(injectedType.get(), injectorFactory);
+      } else {
+        diagnosticReporter.reportBinding(
+            ERROR, injectorFactory, "Unrecognized class: %s", mapKey);
+      }
+    }
+
+    Map<String, List<BindingNode>> duplicates =
+        Maps.filterValues(
+            Multimaps.asMap(mapKeyIndex.build()), bindingNodes -> bindingNodes.size() > 1);
+    if (!duplicates.isEmpty()) {
+      StringBuilder errorMessage =
+          new StringBuilder("Multiple injector factories bound for the same type:\n");
+      Formatter formatter = new Formatter(errorMessage);
+      duplicates.forEach(
+          (injectedType, duplicateFactories) -> {
+            formatter.format("  %s:\n", injectedType);
+            duplicateFactories.forEach(duplicate -> formatter.format("    %s\n", duplicate));
+          });
+      diagnosticReporter.reportBinding(
+          ERROR, dispatchingAndroidInjectorNode, errorMessage.toString());
+    }
+  }
+
+  private Stream<BindingNode> dependencies(BindingNode bindingNode, BindingGraph graph) {
+    return graph
+        .successors(bindingNode)
+        .stream()
+        // TODO(ronshapiro): reuse DaggerStreams.instancesOf()?
+        .filter(BindingNode.class::isInstance)
+        .map(BindingNode.class::cast);
+  }
+
+  /**
+   * Returns a stream of the dependencies of {@code bindingNode} that have a key type of {@code
+   * Map<K, Provider<AndroidInjector.Factory<?>>}.
+   */
+  private Stream<BindingNode> injectorMapDependencies(BindingNode bindingNode, BindingGraph graph) {
+    return dependencies(bindingNode, graph)
+        .filter(node -> node.binding().kind().equals(BindingKind.MULTIBOUND_MAP))
+        .filter(
+            node -> {
+              TypeMirror valueType =
+                  MoreTypes.asDeclared(node.binding().key().type()).getTypeArguments().get(1);
+              if (!MoreTypes.isTypeOf(Provider.class, valueType)
+                  || !valueType.getKind().equals(TypeKind.DECLARED)) {
+                return false;
+              }
+              TypeMirror providedType = MoreTypes.asDeclared(valueType).getTypeArguments().get(0);
+              return MoreTypes.isTypeOf(AndroidInjector.Factory.class, providedType);
+            });
+  }
+
+  private Optional<AnnotationMirror> mapKey(BindingNode bindingNode) {
+    return bindingNode
+        .binding()
+        .bindingElement()
+        .map(bindingElement -> getAnnotatedAnnotations(bindingElement, MapKey.class))
+        .flatMap(
+            annotations ->
+                annotations.isEmpty()
+                    ? Optional.empty()
+                    : Optional.of(getOnlyElement(annotations)));
+  }
+
+  @Override
+  public String pluginName() {
+    return "Dagger/Android/DuplicateAndroidInjectors";
+  }
+
+  @Override
+  public void initTypes(Types types) {
+    this.types = types;
+  }
+
+  @Override
+  public void initElements(Elements elements) {
+    this.elements = elements;
+  }
+}
diff --git a/java/dagger/android/support/AndroidSupportInjectionModule.java b/java/dagger/android/support/AndroidSupportInjectionModule.java
index 6349afb67..85b277a97 100644
--- a/java/dagger/android/support/AndroidSupportInjectionModule.java
+++ b/java/dagger/android/support/AndroidSupportInjectionModule.java
@@ -36,5 +36,9 @@
   abstract Map<Class<? extends Fragment>, AndroidInjector.Factory<? extends Fragment>>
       supportFragmentInjectorFactories();
 
+  @Multibinds
+  abstract Map<String, AndroidInjector.Factory<? extends Fragment>>
+      supportFragmentInjectorFactoriesWithStringKeys();
+
   private AndroidSupportInjectionModule() {}
 }
diff --git a/java/dagger/internal/DaggerCollections.java b/java/dagger/internal/DaggerCollections.java
index 3d47a8497..cebca42d2 100644
--- a/java/dagger/internal/DaggerCollections.java
+++ b/java/dagger/internal/DaggerCollections.java
@@ -70,7 +70,7 @@ public static boolean hasDuplicates(List<?> list) {
    * Creates a {@link LinkedHashMap} instance, with a high enough "initial capacity" that it
    * <em>should</em> hold {@code expectedSize} elements without growth.
    */
-  static <K, V> LinkedHashMap<K, V> newLinkedHashMapWithExpectedSize(int expectedSize) {
+  public static <K, V> LinkedHashMap<K, V> newLinkedHashMapWithExpectedSize(int expectedSize) {
     return new LinkedHashMap<K, V>(calculateInitialCapacity(expectedSize));
   }
 
diff --git a/java/dagger/internal/codegen/ComponentBindingExpressions.java b/java/dagger/internal/codegen/ComponentBindingExpressions.java
index e87e6f558..a78f6acb9 100644
--- a/java/dagger/internal/codegen/ComponentBindingExpressions.java
+++ b/java/dagger/internal/codegen/ComponentBindingExpressions.java
@@ -373,7 +373,8 @@ private FrameworkInstanceCreationExpression frameworkInstanceCreationExpression(
         return new SetFactoryCreationExpression(binding, generatedComponentModel, this, graph);
 
       case MULTIBOUND_MAP:
-        return new MapFactoryCreationExpression(binding, generatedComponentModel, this, graph);
+        return new MapFactoryCreationExpression(
+            binding, generatedComponentModel, this, graph, elements);
 
       case RELEASABLE_REFERENCE_MANAGER:
         return new ReleasableReferenceManagerProviderCreationExpression(
diff --git a/java/dagger/internal/codegen/InaccessibleMapKeyProxyGenerator.java b/java/dagger/internal/codegen/InaccessibleMapKeyProxyGenerator.java
index 0a042332c..db6844706 100644
--- a/java/dagger/internal/codegen/InaccessibleMapKeyProxyGenerator.java
+++ b/java/dagger/internal/codegen/InaccessibleMapKeyProxyGenerator.java
@@ -36,12 +36,14 @@
  */
 final class InaccessibleMapKeyProxyGenerator extends SourceFileGenerator<ContributionBinding> {
   private final DaggerTypes types;
+  private final DaggerElements elements;
 
   @Inject
   InaccessibleMapKeyProxyGenerator(
       Filer filer, DaggerTypes types, DaggerElements elements, SourceVersion sourceVersion) {
     super(filer, elements, sourceVersion);
     this.types = types;
+    this.elements = elements;
   }
 
   @Override
@@ -56,7 +58,7 @@ ClassName nameGeneratedType(ContributionBinding binding) {
 
   @Override
   Optional<TypeSpec.Builder> write(ClassName generatedName, ContributionBinding binding) {
-    return MapKeys.mapKeyFactoryMethod(binding, types)
+    return MapKeys.mapKeyFactoryMethod(binding, types, elements)
         .map(
             method ->
                 classBuilder(generatedName)
diff --git a/java/dagger/internal/codegen/MapBindingExpression.java b/java/dagger/internal/codegen/MapBindingExpression.java
index 8a1f70360..25e2e001b 100644
--- a/java/dagger/internal/codegen/MapBindingExpression.java
+++ b/java/dagger/internal/codegen/MapBindingExpression.java
@@ -124,7 +124,7 @@ private DeclaredType immutableMapType() {
   private CodeBlock keyAndValueExpression(DependencyRequest dependency, ClassName requestingClass) {
     return CodeBlock.of(
         "$L, $L",
-        getMapKeyExpression(dependencies.get(dependency), requestingClass),
+        getMapKeyExpression(dependencies.get(dependency), requestingClass, elements),
         componentBindingExpressions
             .getDependencyExpression(dependency, requestingClass)
             .codeBlock());
diff --git a/java/dagger/internal/codegen/MapFactoryCreationExpression.java b/java/dagger/internal/codegen/MapFactoryCreationExpression.java
index b5804908b..3e61293b7 100644
--- a/java/dagger/internal/codegen/MapFactoryCreationExpression.java
+++ b/java/dagger/internal/codegen/MapFactoryCreationExpression.java
@@ -37,16 +37,19 @@
   private final ComponentBindingExpressions componentBindingExpressions;
   private final BindingGraph graph;
   private final ContributionBinding binding;
+  private final DaggerElements elements;
 
   MapFactoryCreationExpression(
       ContributionBinding binding,
       GeneratedComponentModel generatedComponentModel,
       ComponentBindingExpressions componentBindingExpressions,
-      BindingGraph graph) {
+      BindingGraph graph,
+      DaggerElements elements) {
     this.binding = checkNotNull(binding);
     this.generatedComponentModel = checkNotNull(generatedComponentModel);
     this.componentBindingExpressions = checkNotNull(componentBindingExpressions);
     this.graph = checkNotNull(graph);
+    this.elements = checkNotNull(elements);
   }
 
   @Override
@@ -84,7 +87,7 @@ public CodeBlock creationExpression() {
               .codeBlock();
       builder.add(
           ".put($L, $L)",
-          getMapKeyExpression(contributionBinding, generatedComponentModel.name()),
+          getMapKeyExpression(contributionBinding, generatedComponentModel.name(), elements),
           useRawType ? CodeBlocks.cast(value, frameworkDependency.frameworkClass()) : value);
     }
     builder.add(".build()");
diff --git a/java/dagger/internal/codegen/MapKeys.java b/java/dagger/internal/codegen/MapKeys.java
index 59dea8660..af0e98ea1 100644
--- a/java/dagger/internal/codegen/MapKeys.java
+++ b/java/dagger/internal/codegen/MapKeys.java
@@ -42,6 +42,7 @@
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ElementKind;
 import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.ArrayType;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.PrimitiveType;
@@ -145,11 +146,12 @@ public DeclaredType visitDeclared(DeclaredType t, Void p) {
    * @throws IllegalStateException if {@code binding} is not a {@link dagger.multibindings.IntoMap
    *     map} contribution.
    */
-  static CodeBlock getMapKeyExpression(ContributionBinding binding, ClassName requestingClass) {
+  static CodeBlock getMapKeyExpression(
+      ContributionBinding binding, ClassName requestingClass, DaggerElements elements) {
     AnnotationMirror mapKeyAnnotation = binding.mapKeyAnnotation().get();
     return MapKeyAccessibility.isMapKeyAccessibleFrom(
             mapKeyAnnotation, requestingClass.packageName())
-        ? directMapKeyExpression(mapKeyAnnotation)
+        ? directMapKeyExpression(mapKeyAnnotation, elements)
         : CodeBlock.of("$T.create()", mapKeyProxyClassName(binding));
   }
 
@@ -157,17 +159,30 @@ static CodeBlock getMapKeyExpression(ContributionBinding binding, ClassName requ
    * Returns a code block for the map key annotation {@code mapKey}.
    *
    * <p>This method assumes the map key will be accessible in the context that the returned {@link
-   * CodeBlock} is used. Use {@link #getMapKeyExpression(ContributionBinding, ClassName)} when that
-   * assumption is not guaranteed.
+   * CodeBlock} is used. Use {@link #getMapKeyExpression(ContributionBinding, ClassName,
+   * DaggerElements)} when that assumption is not guaranteed.
    *
    * @throws IllegalArgumentException if the element is annotated with more than one {@code MapKey}
    *     annotation
    * @throws IllegalStateException if {@code bindingElement} is not annotated with a {@code MapKey}
    *     annotation
    */
-  private static CodeBlock directMapKeyExpression(AnnotationMirror mapKey) {
+  private static CodeBlock directMapKeyExpression(
+      AnnotationMirror mapKey, DaggerElements elements) {
     Optional<? extends AnnotationValue> unwrappedValue = unwrapValue(mapKey);
     AnnotationExpression annotationExpression = new AnnotationExpression(mapKey);
+
+    if (MoreTypes.asTypeElement(mapKey.getAnnotationType())
+        .getQualifiedName()
+        .contentEquals("dagger.android.AndroidInjectionKey")) {
+      TypeElement unwrappedType =
+          elements.checkTypePresent((String) unwrappedValue.get().getValue());
+      return CodeBlock.of(
+          "$T.of($S)",
+          ClassName.get("dagger.android.internal", "AndroidInjectionKeys"),
+          ClassName.get(unwrappedType).reflectionName());
+    }
+
     if (unwrappedValue.isPresent()) {
       TypeMirror unwrappedValueType =
           getOnlyElement(getAnnotationValuesWithDefaults(mapKey).keySet()).getReturnType();
@@ -178,8 +193,8 @@ private static CodeBlock directMapKeyExpression(AnnotationMirror mapKey) {
   }
 
   /**
-   * Returns the {@link ClassName} in which {@link #mapKeyFactoryMethod(ContributionBinding, Types)}
-   * is generated.
+   * Returns the {@link ClassName} in which {@link #mapKeyFactoryMethod(ContributionBinding, Types,
+   * DaggerElements)} is generated.
    */
   static ClassName mapKeyProxyClassName(ContributionBinding binding) {
     return elementBasedClassName(
@@ -191,7 +206,8 @@ static ClassName mapKeyProxyClassName(ContributionBinding binding) {
    * #mapKeyProxyClassName(ContributionBinding)} when the {@code @MapKey} annotation is not publicly
    * accessible.
    */
-  static Optional<MethodSpec> mapKeyFactoryMethod(ContributionBinding binding, Types types) {
+  static Optional<MethodSpec> mapKeyFactoryMethod(
+      ContributionBinding binding, Types types, DaggerElements elements) {
     return binding
         .mapKeyAnnotation()
         .filter(mapKey -> !isMapKeyPubliclyAccessible(mapKey))
@@ -200,7 +216,7 @@ static ClassName mapKeyProxyClassName(ContributionBinding binding) {
                 methodBuilder("create")
                     .addModifiers(PUBLIC, STATIC)
                     .returns(TypeName.get(mapKeyType(mapKey, types)))
-                    .addStatement("return $L", directMapKeyExpression(mapKey))
+                    .addStatement("return $L", directMapKeyExpression(mapKey, elements))
                     .build());
   }
 
diff --git a/javatests/dagger/android/DispatchingAndroidInjectorTest.java b/javatests/dagger/android/DispatchingAndroidInjectorTest.java
index 2d1e6132c..338e7039c 100644
--- a/javatests/dagger/android/DispatchingAndroidInjectorTest.java
+++ b/javatests/dagger/android/DispatchingAndroidInjectorTest.java
@@ -20,12 +20,9 @@
 import static org.junit.Assert.fail;
 
 import android.app.Activity;
+import com.google.common.collect.ImmutableMap;
 import org.robolectric.RobolectricTestRunner;
 import dagger.android.DispatchingAndroidInjector.InvalidInjectorBindingException;
-import java.util.HashMap;
-import java.util.Map;
-import javax.inject.Provider;
-import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
@@ -34,36 +31,59 @@
 @Config(manifest = Config.NONE)
 @RunWith(RobolectricTestRunner.class)
 public final class DispatchingAndroidInjectorTest {
-  private DispatchingAndroidInjector<Activity> dispatchingAndroidInjector;
-
-  @Before
-  public void setup() {
-    Map<Class<? extends Activity>, Provider<AndroidInjector.Factory<? extends Activity>>>
-        injectorFactories = new HashMap<>();
-    injectorFactories.put(FooActivity.class, FooInjector.Factory::new);
-    injectorFactories.put(ReturnsNullActivity.class, () -> null);
-    injectorFactories.put(WrongActivity.class, FooInjector.Factory::new);
-    dispatchingAndroidInjector = new DispatchingAndroidInjector<>(injectorFactories);
+  @Test
+  public void withClassKeys() {
+    DispatchingAndroidInjector<Activity> dispatchingAndroidInjector =
+        new DispatchingAndroidInjector<>(
+            ImmutableMap.of(FooActivity.class, FooInjector.Factory::new), ImmutableMap.of());
+
+    FooActivity activity = Robolectric.setupActivity(FooActivity.class);
+    assertThat(dispatchingAndroidInjector.maybeInject(activity)).isTrue();
+  }
+
+  @Test
+  public void withStringKeys() {
+    DispatchingAndroidInjector<Activity> dispatchingAndroidInjector =
+        new DispatchingAndroidInjector<>(
+            ImmutableMap.of(),
+            ImmutableMap.of(FooActivity.class.getName(), FooInjector.Factory::new));
+
+    FooActivity activity = Robolectric.setupActivity(FooActivity.class);
+    assertThat(dispatchingAndroidInjector.maybeInject(activity)).isTrue();
   }
 
   @Test
-  public void maybeInject_returnsTrue_ifMatchingInjectorExists() {
+  public void withMixedKeys() {
+    DispatchingAndroidInjector<Activity> dispatchingAndroidInjector =
+        new DispatchingAndroidInjector<>(
+            ImmutableMap.of(FooActivity.class, FooInjector.Factory::new),
+            ImmutableMap.of(BarActivity.class.getName(), BarInjector.Factory::new));
+
     FooActivity fooActivity = Robolectric.setupActivity(FooActivity.class);
     assertThat(dispatchingAndroidInjector.maybeInject(fooActivity)).isTrue();
+    BarActivity barActivity = Robolectric.setupActivity(BarActivity.class);
+    assertThat(dispatchingAndroidInjector.maybeInject(barActivity)).isTrue();
   }
 
   @Test
   public void maybeInject_returnsFalse_ifNoMatchingInjectorExists() {
-    BarActivity barActivity = Robolectric.setupActivity(BarActivity.class);
-    assertThat(dispatchingAndroidInjector.maybeInject(barActivity)).isFalse();
+    DispatchingAndroidInjector<Activity> dispatchingAndroidInjector =
+        new DispatchingAndroidInjector<>(ImmutableMap.of(), ImmutableMap.of());
+    
+    BarActivity activity = Robolectric.setupActivity(BarActivity.class);
+    assertThat(dispatchingAndroidInjector.maybeInject(activity)).isFalse();
   }
 
   @Test
   public void throwsIfFactoryCreateReturnsNull() {
-    ReturnsNullActivity returnsNullActivity = Robolectric.setupActivity(ReturnsNullActivity.class);
+    DispatchingAndroidInjector<Activity> dispatchingAndroidInjector =
+        new DispatchingAndroidInjector<>(
+            ImmutableMap.of(FooActivity.class, () -> null),
+            ImmutableMap.of());
+    FooActivity activity = Robolectric.setupActivity(FooActivity.class);
 
     try {
-      dispatchingAndroidInjector.maybeInject(returnsNullActivity);
+      dispatchingAndroidInjector.maybeInject(activity);
       fail("Expected NullPointerException");
     } catch (NullPointerException expected) {
     }
@@ -71,10 +91,13 @@ public void throwsIfFactoryCreateReturnsNull() {
 
   @Test
   public void throwsIfClassMismatched() {
-    WrongActivity wrongActivity = Robolectric.setupActivity(WrongActivity.class);
+    DispatchingAndroidInjector<Activity> dispatchingAndroidInjector =
+        new DispatchingAndroidInjector<>(
+            ImmutableMap.of(FooActivity.class, BarInjector.Factory::new), ImmutableMap.of());
+    FooActivity activity = Robolectric.setupActivity(FooActivity.class);
 
     try {
-      dispatchingAndroidInjector.maybeInject(wrongActivity);
+      dispatchingAndroidInjector.maybeInject(activity);
       fail("Expected InvalidInjectorBindingException");
     } catch (InvalidInjectorBindingException expected) {
     }
@@ -84,10 +107,6 @@ public void throwsIfClassMismatched() {
 
   static class BarActivity extends Activity {}
 
-  static class ReturnsNullActivity extends Activity {}
-
-  static class WrongActivity extends Activity {}
-
   static class FooInjector implements AndroidInjector<FooActivity> {
     @Override
     public void inject(FooActivity instance) {}
@@ -99,4 +118,16 @@ public void inject(FooActivity instance) {}
       }
     }
   }
+
+  static class BarInjector implements AndroidInjector<BarActivity> {
+    @Override
+    public void inject(BarActivity instance) {}
+
+    static class Factory implements AndroidInjector.Factory<BarActivity> {
+      @Override
+      public AndroidInjector<BarActivity> create(BarActivity activity) {
+        return new BarInjector();
+      }
+    }
+  }
 }
diff --git a/javatests/dagger/android/processor/AndroidMapKeyValidatorTest.java b/javatests/dagger/android/processor/AndroidMapKeyValidatorTest.java
new file mode 100644
index 000000000..8f1a5290b
--- /dev/null
+++ b/javatests/dagger/android/processor/AndroidMapKeyValidatorTest.java
@@ -0,0 +1,451 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.processor;
+
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static com.google.testing.compile.Compiler.javac;
+
+import com.google.common.base.Joiner;
+import com.google.testing.compile.Compilation;
+import com.google.testing.compile.JavaFileObjects;
+import dagger.internal.codegen.ComponentProcessor;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public class AndroidMapKeyValidatorTest {
+  private static final JavaFileObject FOO_ACTIVITY =
+      JavaFileObjects.forSourceLines(
+          "test.FooActivity",
+          "package test;",
+          "",
+          "import android.app.Activity;",
+          "import dagger.android.AndroidInjector;",
+          "",
+          "public class FooActivity extends Activity {",
+          "  interface Factory extends AndroidInjector.Factory<FooActivity> {}",
+          "  abstract static class Builder extends AndroidInjector.Builder<FooActivity> {}",
+          "}");
+  private static final JavaFileObject BAR_ACTIVITY =
+      JavaFileObjects.forSourceLines(
+          "test.BarActivity",
+          "package test;",
+          "",
+          "import android.app.Activity;",
+          "",
+          "public class BarActivity extends Activity {}");
+  private static final JavaFileObject BAZ_FRAGMENT =
+      JavaFileObjects.forSourceLines(
+          "test.BazFragment",
+          "package test;",
+          "",
+          "import android.app.Fragment;",
+          "",
+          "public class BazFragment extends Fragment {}");
+
+  private static JavaFileObject moduleWithMethod(String... lines) {
+    return JavaFileObjects.forSourceLines(
+        "test.AndroidModule",
+        "package test;",
+        "",
+        "import android.app.Activity;",
+        "import android.app.Fragment;",
+        "import dagger.Module;",
+        "import dagger.*;",
+        "import dagger.android.*;",
+        "import dagger.multibindings.IntoMap;",
+        "import javax.inject.*;",
+        "",
+        "@Module",
+        "abstract class AndroidModule {",
+        "  " + Joiner.on("\n  ").join(lines),
+        "}");
+  }
+
+  // TODO(dpb): Change these tests to use onLineContaining() instead of onLine().
+  private static final int LINES_BEFORE_METHOD = 12;
+
+  @Test
+  public void rawFactoryType() {
+    JavaFileObject module =
+        moduleWithMethod(
+            "@Binds",
+            "@IntoMap",
+            "@ActivityKey(FooActivity.class)",
+            "abstract AndroidInjector.Factory bindRawFactory(FooActivity.Factory factory);");
+    Compilation compilation = compile(module, FOO_ACTIVITY);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            "@dagger.android.ActivityKey methods should bind "
+                + "dagger.android.AndroidInjector.Factory<? extends android.app.Activity>, not "
+                + "dagger.android.AndroidInjector.Factory");
+  }
+
+  @Test
+  public void rawBuilderType() {
+    JavaFileObject module =
+        moduleWithMethod(
+            "@Binds",
+            "@IntoMap",
+            "@ActivityKey(FooActivity.class)",
+            "abstract AndroidInjector.Builder bindRawBuilder(FooActivity.Builder builder);");
+    Compilation compilation = compile(module, FOO_ACTIVITY);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            "@dagger.android.ActivityKey methods should bind "
+                + "dagger.android.AndroidInjector.Factory<? extends android.app.Activity>, not "
+                + "dagger.android.AndroidInjector.Builder");
+  }
+
+  @Test
+  public void bindsToBuilderNotFactory() {
+    JavaFileObject module =
+        moduleWithMethod(
+            "@Binds",
+            "@IntoMap",
+            "@ActivityKey(FooActivity.class)",
+            "abstract AndroidInjector.Builder<? extends Activity> bindBuilder(",
+            "    FooActivity.Builder builder);");
+    Compilation compilation = compile(module, FOO_ACTIVITY);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            "@dagger.android.ActivityKey methods should bind "
+                + "dagger.android.AndroidInjector.Factory<? extends android.app.Activity>, not "
+                + "dagger.android.AndroidInjector.Builder<? extends android.app.Activity>");
+  }
+
+  @Test
+  public void providesToBuilderNotFactory() {
+    JavaFileObject module =
+        moduleWithMethod(
+            "@Provides",
+            "@IntoMap",
+            "@ActivityKey(FooActivity.class)",
+            "static AndroidInjector.Builder<? extends Activity> bindBuilder(",
+            "    FooActivity.Builder builder) {",
+            "  return builder;",
+            "}");
+    Compilation compilation = compile(module, FOO_ACTIVITY);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            "@dagger.android.ActivityKey methods should bind "
+                + "dagger.android.AndroidInjector.Factory<? extends android.app.Activity>, not "
+                + "dagger.android.AndroidInjector.Builder<? extends android.app.Activity>");
+  }
+
+  @Test
+  public void mapKeyDoesntMatchCoreType() {
+    JavaFileObject module =
+        moduleWithMethod(
+            "@Binds",
+            "@IntoMap",
+            "@FragmentKey(BazFragment.class)",
+            "abstract AndroidInjector.Factory<? extends Activity> bindWrongFrameworkType(",
+            "    FooActivity.Builder builder);");
+    Compilation compilation = compile(module, FOO_ACTIVITY, BAZ_FRAGMENT);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            "@dagger.android.FragmentKey methods should bind "
+                + "dagger.android.AndroidInjector.Factory<? extends android.app.Fragment>, not "
+                + "dagger.android.AndroidInjector.Factory<? extends android.app.Activity>");
+    assertThat(compilation)
+        .hadErrorContaining(
+            "test.FooActivity.Builder does not implement " + "AndroidInjector<test.BazFragment>")
+        .inFile(module)
+        .onLine(LINES_BEFORE_METHOD + 3);
+  }
+
+  @Test
+  public void mapKeyDoesntMatchCoreType_AndroidInjectionKey() {
+    JavaFileObject module =
+        moduleWithMethod(
+            "@Binds",
+            "@IntoMap",
+            "@AndroidInjectionKey(\"test.BazFragment\")",
+            "abstract AndroidInjector.Factory<? extends Activity> bindWrongFrameworkType(",
+            "    FooActivity.Builder builder);");
+    Compilation compilation = compile(module, FOO_ACTIVITY, BAZ_FRAGMENT);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            "bindWrongFrameworkType(test.FooActivity.Builder) should bind "
+                + "dagger.android.AndroidInjector.Factory<? extends android.app.Fragment>, not "
+                + "dagger.android.AndroidInjector.Factory<? extends android.app.Activity>");
+    assertThat(compilation)
+        .hadErrorContaining(
+            "test.FooActivity.Builder does not implement AndroidInjector<test.BazFragment>")
+        .inFile(module)
+        .onLine(LINES_BEFORE_METHOD + 3);
+  }
+
+  @Test
+  public void mapKeyDoesntMatchCoreType_supportFragments() {
+    JavaFileObject supportFragment =
+        JavaFileObjects.forSourceLines(
+            "test.SupportFragment",
+            "package test;",
+            "",
+            "import android.support.v4.app.Fragment;",
+            "import dagger.android.AndroidInjector;",
+            "",
+            "public class SupportFragment extends Fragment {",
+            "  interface Factory extends AndroidInjector.Factory<SupportFragment> {}",
+            "}");
+
+    JavaFileObject module =
+        moduleWithMethod(
+            "@Binds",
+            "@IntoMap",
+            "@dagger.android.FragmentKey(BazFragment.class)",
+            "abstract AndroidInjector.Factory<? extends android.support.v4.app.Fragment> ",
+            "    bindWrongFrameworkType(SupportFragment.Factory factory);");
+    Compilation compilation = compile(module, BAZ_FRAGMENT, supportFragment);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            "@dagger.android.FragmentKey methods should bind "
+                + "dagger.android.AndroidInjector.Factory<? extends android.app.Fragment>, not "
+                + "dagger.android.AndroidInjector.Factory<? extends "
+                + "android.support.v4.app.Fragment>");
+    assertThat(compilation)
+        .hadErrorContaining(
+            "test.SupportFragment.Factory does not implement AndroidInjector<test.BazFragment>")
+        .inFile(module)
+        .onLine(LINES_BEFORE_METHOD + 3);
+  }
+
+  @Test
+  public void bindsToConcreteTypeInsteadOfWildcard() {
+    JavaFileObject module =
+        moduleWithMethod(
+            "@Binds",
+            "@IntoMap",
+            "@ActivityKey(FooActivity.class)",
+            "abstract AndroidInjector.Builder<FooActivity> bindBuilder(",
+            "    FooActivity.Builder builder);");
+    Compilation compilation = compile(module, FOO_ACTIVITY);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            "@dagger.android.ActivityKey methods should bind "
+                + "dagger.android.AndroidInjector.Factory<? extends android.app.Activity>, not "
+                + "dagger.android.AndroidInjector.Builder<test.FooActivity>");
+  }
+
+  @Test
+  public void bindsToBaseTypeInsteadOfWildcard() {
+    JavaFileObject module =
+        moduleWithMethod(
+            "@Binds",
+            "@IntoMap",
+            "@ActivityKey(FooActivity.class)",
+            "abstract AndroidInjector.Builder<Activity> bindBuilder(",
+            "    FooActivity.Builder builder);");
+    Compilation compilation = compile(module, FOO_ACTIVITY);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("@Binds methods' parameter type must be assignable to the return type");
+  }
+
+  @Test
+  public void bindsCorrectType() {
+    JavaFileObject module =
+        moduleWithMethod(
+            "@Binds",
+            "@IntoMap",
+            "@ActivityKey(FooActivity.class)",
+            "abstract AndroidInjector.Factory<? extends Activity> bindCorrectType(",
+            "    FooActivity.Builder builder);");
+    Compilation compilation = compile(module, FOO_ACTIVITY);
+    assertThat(compilation).succeededWithoutWarnings();
+  }
+
+  @Test
+  public void bindsCorrectType_AndroidInjectionKey() {
+    JavaFileObject module =
+        moduleWithMethod(
+            "@Binds",
+            "@IntoMap",
+            "@AndroidInjectionKey(\"test.FooActivity\")",
+            "abstract AndroidInjector.Factory<? extends Activity> bindCorrectType(",
+            "    FooActivity.Builder builder);");
+    Compilation compilation = compile(module, FOO_ACTIVITY);
+    assertThat(compilation).succeededWithoutWarnings();
+  }
+
+  @Test
+  public void bindsWithScope() {
+    JavaFileObject module =
+        moduleWithMethod(
+            "@Binds",
+            "@IntoMap",
+            "@ActivityKey(FooActivity.class)",
+            "@Singleton",
+            "abstract AndroidInjector.Factory<? extends Activity> bindWithScope(",
+            "    FooActivity.Builder builder);");
+    Compilation compilation = compile(module, FOO_ACTIVITY);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining("should not be scoped");
+  }
+
+  @Test
+  public void bindsWithScope_suppressWarnings() {
+    JavaFileObject module =
+        moduleWithMethod(
+            "@SuppressWarnings(\"dagger.android.ScopedInjectorFactory\")",
+            "@Binds",
+            "@IntoMap",
+            "@ActivityKey(FooActivity.class)",
+            "@Singleton",
+            "abstract AndroidInjector.Factory<? extends Activity> bindWithScope(",
+            "    FooActivity.Builder builder);");
+    Compilation compilation = compile(module, FOO_ACTIVITY);
+    assertThat(compilation).succeededWithoutWarnings();
+  }
+
+  @Test
+  public void mismatchedMapKey_bindsFactory() {
+    JavaFileObject module =
+        moduleWithMethod(
+            "@Binds",
+            "@IntoMap",
+            "@ActivityKey(BarActivity.class)",
+            "abstract AndroidInjector.Factory<?> mismatchedFactory(",
+            "    FooActivity.Factory factory);");
+    Compilation compilation = compile(module, FOO_ACTIVITY, BAR_ACTIVITY);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            "test.FooActivity.Factory does not implement AndroidInjector<test.BarActivity>")
+        .inFile(module)
+        .onLine(LINES_BEFORE_METHOD + 3);
+  }
+
+  @Test
+  public void mismatchedMapKey_bindsBuilder() {
+    JavaFileObject module =
+        moduleWithMethod(
+            "@Binds",
+            "@IntoMap",
+            "@ActivityKey(BarActivity.class)",
+            "abstract AndroidInjector.Factory<? extends Activity> mismatchedBuilder(",
+            "    FooActivity.Builder builder);");
+    Compilation compilation = compile(module, FOO_ACTIVITY, BAR_ACTIVITY);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            "test.FooActivity.Builder does not implement AndroidInjector<test.BarActivity>")
+        .inFile(module)
+        .onLine(LINES_BEFORE_METHOD + 3);
+  }
+
+  @Test
+  public void mismatchedMapKey_bindsBuilder_androidInjectionKey() {
+    JavaFileObject module =
+        moduleWithMethod(
+            "@Binds",
+            "@IntoMap",
+            "@AndroidInjectionKey(\"test.BarActivity\")",
+            "abstract AndroidInjector.Factory<? extends Activity> mismatchedBuilder(",
+            "    FooActivity.Builder builder);");
+    Compilation compilation = compile(module, FOO_ACTIVITY, BAR_ACTIVITY);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            "test.FooActivity.Builder does not implement AndroidInjector<test.BarActivity>")
+        .inFile(module)
+        .onLine(LINES_BEFORE_METHOD + 3);
+  }
+
+  @Test
+  public void mismatchedMapKey_providesBuilder() {
+    JavaFileObject module =
+        moduleWithMethod(
+            "@Provides",
+            "@IntoMap",
+            "@ActivityKey(BarActivity.class)",
+            "static AndroidInjector.Factory<? extends Activity> mismatchedBuilder(",
+            "    FooActivity.Builder builder) {",
+            "  return builder;",
+            "}");
+    Compilation compilation = compile(module, FOO_ACTIVITY, BAR_ACTIVITY);
+    assertThat(compilation).succeededWithoutWarnings();
+  }
+
+  @Test
+  public void bindsQualifier_ignoresChecks() {
+    JavaFileObject module =
+        moduleWithMethod(
+            "@Binds",
+            "@IntoMap",
+            "@ActivityKey(FooActivity.class)",
+            "@Named(\"unused\")",
+            // normally this should fail, since it is binding to a Builder not a Factory
+            "abstract AndroidInjector.Builder<?> bindsBuilderWithQualifier(",
+            "    FooActivity.Builder builder);");
+    Compilation compilation = compile(module, FOO_ACTIVITY);
+    assertThat(compilation).succeededWithoutWarnings();
+  }
+
+  @Test
+  public void bindToPrimitive() {
+    JavaFileObject module =
+        moduleWithMethod(
+            "@Binds",
+            "@IntoMap",
+            "@ActivityKey(FooActivity.class)",
+            "abstract int bindInt(@Named(\"unused\") int otherInt);");
+    Compilation compilation = compile(module, FOO_ACTIVITY);
+    assertThat(compilation).succeededWithoutWarnings();
+  }
+
+  @Test
+  public void bindToNonFrameworkClass() {
+    JavaFileObject module =
+        moduleWithMethod(
+            "@Binds",
+            "@IntoMap",
+            "@ActivityKey(FooActivity.class)",
+            "abstract Number bindInt(Integer integer);");
+    Compilation compilation = compile(module, FOO_ACTIVITY);
+    assertThat(compilation).succeededWithoutWarnings();
+  }
+
+  @Test
+  public void invalidBindsMethod() {
+    JavaFileObject module =
+        moduleWithMethod(
+            "@Binds",
+            "@IntoMap",
+            "@ActivityKey(FooActivity.class)",
+            "abstract AndroidInjector.Factory<?> bindCorrectType(",
+            "    FooActivity.Builder builder, FooActivity.Builder builder2);");
+    Compilation compilation = compile(module, FOO_ACTIVITY);
+    assertThat(compilation).failed();
+  }
+
+  private Compilation compile(JavaFileObject... files) {
+    return javac().withProcessors(new ComponentProcessor(), new AndroidProcessor()).compile(files);
+  }
+}
diff --git a/javatests/dagger/android/processor/AndroidProcessorTest.java b/javatests/dagger/android/processor/AndroidProcessorTest.java
new file mode 100644
index 000000000..1a45bdd05
--- /dev/null
+++ b/javatests/dagger/android/processor/AndroidProcessorTest.java
@@ -0,0 +1,81 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.processor;
+
+import static com.google.common.truth.Truth8.assertThat;
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static com.google.testing.compile.Compiler.javac;
+import static javax.tools.StandardLocation.CLASS_OUTPUT;
+
+import com.google.testing.compile.Compilation;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public final class AndroidProcessorTest {
+  @Test
+  public void generatedProguardFile() {
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.android.AndroidInjectionKey;",
+            "import dagger.Module;",
+            "import dagger.multibindings.IntoMap;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "class TestModule {",
+            "  @Provides",
+            "  @IntoMap",
+            "  @AndroidInjectionKey(\"test.TestActivity\")",
+            "  static int i() { ",
+            "    return 1;",
+            "  }",
+            "}");
+    Compilation enabled =
+        javac()
+            .withProcessors(new AndroidProcessor())
+            .withOptions("-Adagger.android.experimentalUseStringKeys=true")
+            .compile(module);
+    assertThat(enabled).succeeded();
+    assertThat(enabled)
+        .generatedFile(CLASS_OUTPUT, "META-INF/proguard/dagger.android.AndroidInjectionKeys");
+
+    Compilation disabled =
+        javac()
+            .withProcessors(new AndroidProcessor())
+            .withOptions("-Adagger.android.experimentalUseStringKeys=false")
+            .compile(module);
+    assertThat(disabled).succeeded();
+    assertThat(
+            disabled.generatedFile(
+                CLASS_OUTPUT, "META-INF/proguard/dagger.android.AndroidInjectionKeys"))
+        .isEmpty();
+
+    Compilation noFlag = javac().withProcessors(new AndroidProcessor()).compile(module);
+    assertThat(noFlag).succeeded();
+    assertThat(
+            noFlag.generatedFile(
+                CLASS_OUTPUT, "META-INF/proguard/dagger.android.AndroidInjectionKeys"))
+        .isEmpty();
+  }
+}
diff --git a/javatests/dagger/android/processor/BUILD b/javatests/dagger/android/processor/BUILD
new file mode 100644
index 000000000..afc31ffc1
--- /dev/null
+++ b/javatests/dagger/android/processor/BUILD
@@ -0,0 +1,42 @@
+# Copyright (C) 2017 The Dagger Authors.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+# Description:
+#   Tests for Dagger's Android integrations
+
+package(default_visibility = ["//:src"])
+
+load("//:build_defs.bzl", "DOCLINT_HTML_AND_SYNTAX")
+load("//:test_defs.bzl", "GenJavaTests")
+
+GenJavaTests(
+    name = "android_processor_tests",
+    srcs = glob(["*.java"]),
+    functional = False,
+    javacopts = DOCLINT_HTML_AND_SYNTAX,
+    deps = [
+        "@google_bazel_common//third_party/java/guava",
+        "@androidsdk//com.android.support:support-fragment-25.0.0",
+        # TODO(ronshapiro): create a common location to define the current Android version
+        "@androidsdk//:platforms/android-25/android.jar",
+        "@google_bazel_common//third_party/java/compile_testing",
+        "//:dagger_with_compiler",
+        "@google_bazel_common//third_party/java/junit",
+        "@google_bazel_common//third_party/java/truth",
+        "@google_bazel_common//third_party/java/truth:truth8",
+        "//java/dagger/android",
+        "//java/dagger/android/processor",
+        "//java/dagger/internal/codegen:processor",
+    ],
+)
diff --git a/javatests/dagger/android/processor/ContributesAndroidInjectorTest.java b/javatests/dagger/android/processor/ContributesAndroidInjectorTest.java
new file mode 100644
index 000000000..7ac0d53ac
--- /dev/null
+++ b/javatests/dagger/android/processor/ContributesAndroidInjectorTest.java
@@ -0,0 +1,238 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.processor;
+
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static com.google.testing.compile.Compiler.javac;
+
+import com.google.testing.compile.Compilation;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public final class ContributesAndroidInjectorTest {
+  private static final JavaFileObject TEST_ACTIVITY =
+      JavaFileObjects.forSourceLines(
+          "test.TestActivity",
+          "package test;",
+          "",
+          "import android.app.Activity;",
+          "",
+          "class TestActivity extends Activity {}");
+
+  @Test
+  public void notAbstract() {
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.android.ContributesAndroidInjector;",
+            "",
+            "@Module",
+            "abstract class TestModule {",
+            "  @ContributesAndroidInjector",
+            "  static TestActivity test() {",
+            "    return null;",
+            "  }",
+            "}");
+
+    Compilation compilation = compile(module, TEST_ACTIVITY);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("must be abstract")
+        .inFile(module)
+        .onLineContaining("test()");
+  }
+
+  @Test
+  public void hasParameters() {
+    JavaFileObject otherActivity =
+        JavaFileObjects.forSourceLines(
+            "test.OtherActivity",
+            "package test;",
+            "",
+            "import android.app.Activity;",
+            "",
+            "class OtherActivity extends Activity {}");
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.android.ContributesAndroidInjector;",
+            "",
+            "@Module",
+            "abstract class TestModule {",
+            "  @ContributesAndroidInjector",
+            "  abstract TestActivity oneParam(TestActivity one);",
+            "",
+            "  @ContributesAndroidInjector",
+            "  abstract OtherActivity manyParams(OtherActivity two, Object o);",
+            "}");
+
+    Compilation compilation = compile(module, TEST_ACTIVITY, otherActivity);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("cannot have parameters")
+        .inFile(module)
+        .onLineContaining("oneParam(");
+    assertThat(compilation)
+        .hadErrorContaining("cannot have parameters")
+        .inFile(module)
+        .onLineContaining("manyParams(");
+  }
+
+  @Test
+  public void notInAModule() {
+    JavaFileObject randomFile =
+        JavaFileObjects.forSourceLines(
+            "test.RandomFile",
+            "package test;",
+            "",
+            "import dagger.android.ContributesAndroidInjector;",
+            "",
+            "abstract class RandomFile {",
+            "  @ContributesAndroidInjector",
+            "  abstract TestActivity test() {}",
+            "}");
+
+    Compilation compilation = compile(randomFile, TEST_ACTIVITY);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("must be in a @Module")
+        .inFile(randomFile)
+        .onLineContaining("test()");
+  }
+
+  @Test
+  public void parameterizedReturnType() {
+    JavaFileObject parameterizedActivity =
+        JavaFileObjects.forSourceLines(
+            "test.ParameterizedActivity",
+            "package test;",
+            "",
+            "import android.app.Activity;",
+            "",
+            "class ParameterizedActivity<T> extends Activity {}");
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.android.ContributesAndroidInjector;",
+            "",
+            "@Module",
+            "abstract class TestModule {",
+            "  @ContributesAndroidInjector",
+            "  abstract <T> ParameterizedActivity<T> test();",
+            "}");
+
+    Compilation compilation = compile(module, TEST_ACTIVITY, parameterizedActivity);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("cannot return parameterized types")
+        .inFile(module)
+        .onLineContaining("test()");
+  }
+
+  @Test
+  public void notAFrameworkType() {
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.android.ContributesAndroidInjector;",
+            "",
+            "@Module",
+            "abstract class TestModule {",
+            "  @ContributesAndroidInjector",
+            "  abstract android.content.Intent intent();",
+            "}");
+
+    Compilation compilation = compile(module);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("is not a framework type")
+        .inFile(module)
+        .onLineContaining("intent()");
+  }
+
+  @Test
+  public void moduleIsntModule() {
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.android.ContributesAndroidInjector;",
+            "",
+            "@Module",
+            "abstract class TestModule {",
+            "  @ContributesAndroidInjector(modules = android.content.Intent.class)",
+            "  abstract TestActivity test();",
+            "}");
+
+    Compilation compilation = compile(module, TEST_ACTIVITY);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("Intent is not a @Module")
+        .inFile(module)
+        .onLineContaining("modules = android.content.Intent.class");
+  }
+
+  @Test
+  public void hasQualifier() {
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.android.ContributesAndroidInjector;",
+            "import javax.inject.Qualifier;",
+            "",
+            "@Module",
+            "abstract class TestModule {",
+            "  @Qualifier @interface AndroidQualifier {}",
+            "",
+            "  @AndroidQualifier",
+            "  @ContributesAndroidInjector",
+            "  abstract TestActivity test();",
+            "}");
+
+    Compilation compilation = compile(module, TEST_ACTIVITY);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("@ContributesAndroidInjector methods cannot have qualifiers")
+        .inFile(module)
+        .onLineContaining("@AndroidQualifier");
+  }
+
+  private static Compilation compile(JavaFileObject... javaFileObjects) {
+    return javac().withProcessors(new AndroidProcessor()).compile(javaFileObjects);
+  }
+}
diff --git a/javatests/dagger/android/processor/DuplicateAndroidInjectorsCheckerTest.java b/javatests/dagger/android/processor/DuplicateAndroidInjectorsCheckerTest.java
new file mode 100644
index 000000000..76167511e
--- /dev/null
+++ b/javatests/dagger/android/processor/DuplicateAndroidInjectorsCheckerTest.java
@@ -0,0 +1,106 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.processor;
+
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static com.google.testing.compile.Compiler.javac;
+
+import com.google.testing.compile.Compilation;
+import com.google.testing.compile.JavaFileObjects;
+import dagger.internal.codegen.ComponentProcessor;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public final class DuplicateAndroidInjectorsCheckerTest {
+  @Test
+  public void conflictingMapKeys() {
+    JavaFileObject activity =
+        JavaFileObjects.forSourceLines(
+            "test.TestActivity",
+            "package test;",
+            "",
+            "import android.app.Activity;",
+            "",
+            "public class TestActivity extends Activity {}");
+    JavaFileObject injectorFactory =
+        JavaFileObjects.forSourceLines(
+            "test.TestInjectorFactory",
+            "package test;",
+            "",
+            "import dagger.android.AndroidInjector;",
+            "import javax.inject.Inject;",
+            "",
+            "class TestInjectorFactory implements AndroidInjector.Factory<TestActivity> {",
+            "  @Inject TestInjectorFactory() {}",
+            "",
+            "  @Override",
+            "  public AndroidInjector<TestActivity> create(TestActivity instance) { return null; }",
+            "}");
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import android.app.Activity;",
+            "import dagger.Binds;",
+            "import dagger.Module;",
+            "import dagger.android.*;",
+            "import dagger.multibindings.*;",
+            "",
+            "@Module",
+            "interface TestModule {",
+            "  @Binds",
+            "  @IntoMap",
+            "  @ActivityKey(TestActivity.class)",
+            "  AndroidInjector.Factory<? extends Activity> classKey(TestInjectorFactory factory);",
+            "",
+            "  @Binds",
+            "  @IntoMap",
+            "  @AndroidInjectionKey(\"test.TestActivity\")",
+            "  AndroidInjector.Factory<? extends Activity> stringKey(TestInjectorFactory factory);",
+            "}");
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import android.app.Activity;",
+            "import dagger.Component;",
+            "import dagger.android.DispatchingAndroidInjector;",
+            "",
+            "@Component(modules = TestModule.class)",
+            "interface TestComponent {",
+            "  DispatchingAndroidInjector<Activity> dispatchingInjector();",
+            "}");
+
+    Compilation compilation =
+        javac()
+            .withProcessors(ComponentProcessor.forTesting(new DuplicateAndroidInjectorsChecker()))
+            .compile(activity, injectorFactory, module, component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("Multiple injector factories bound for the same type")
+        .inFile(component)
+        .onLineContaining("dispatchingInjector()");
+    assertThat(compilation).hadErrorContaining("classKey(test.TestInjectorFactory)");
+    assertThat(compilation).hadErrorContaining("stringKey(test.TestInjectorFactory)");
+    assertThat(compilation).hadErrorCount(1);
+  }
+}
diff --git a/javatests/dagger/android/support/functional/AllControllersAreDirectChildrenOfApplication.java b/javatests/dagger/android/support/functional/AllControllersAreDirectChildrenOfApplication.java
index 271bafc94..1382af1ed 100644
--- a/javatests/dagger/android/support/functional/AllControllersAreDirectChildrenOfApplication.java
+++ b/javatests/dagger/android/support/functional/AllControllersAreDirectChildrenOfApplication.java
@@ -36,6 +36,7 @@
 import dagger.android.support.FragmentKey;
 import dagger.android.support.functional.AllControllersAreDirectChildrenOfApplication.ApplicationComponent.BroadcastReceiverSubcomponent.BroadcastReceiverModule;
 import dagger.android.support.functional.AllControllersAreDirectChildrenOfApplication.ApplicationComponent.ContentProviderSubcomponent.ContentProviderModule;
+import dagger.android.support.functional.AllControllersAreDirectChildrenOfApplication.ApplicationComponent.InnerActivitySubcomponent.InnerActivityModule;
 import dagger.android.support.functional.AllControllersAreDirectChildrenOfApplication.ApplicationComponent.IntentServiceSubcomponent.IntentServiceModule;
 import dagger.android.support.functional.AllControllersAreDirectChildrenOfApplication.ApplicationComponent.ServiceSubcomponent.ServiceModule;
 import dagger.multibindings.IntoMap;
@@ -56,6 +57,7 @@
     @Module(
       subcomponents = {
         ActivitySubcomponent.class,
+        InnerActivitySubcomponent.class,
         ParentFragmentSubcomponent.class,
         ChildFragmentSubcomponent.class,
         DialogFragmentSubcomponent.class,
@@ -78,6 +80,12 @@
       abstract AndroidInjector.Factory<? extends Activity> bindFactoryForTestActivity(
           ActivitySubcomponent.Builder builder);
 
+      @Binds
+      @IntoMap
+      @ActivityKey(OuterClass.TestInnerClassActivity.class)
+      abstract AndroidInjector.Factory<? extends Activity> bindFactoryForInnerActivity(
+          InnerActivitySubcomponent.Builder builder);
+
       @Binds
       @IntoMap
       @FragmentKey(TestParentFragment.class)
@@ -136,6 +144,21 @@
       abstract class Builder extends AndroidInjector.Builder<TestActivity> {}
     }
 
+    @Subcomponent(modules = InnerActivityModule.class)
+    interface InnerActivitySubcomponent extends AndroidInjector<OuterClass.TestInnerClassActivity> {
+      @Subcomponent.Builder
+      abstract class Builder extends AndroidInjector.Builder<OuterClass.TestInnerClassActivity> {}
+
+      @Module
+      abstract class InnerActivityModule {
+        @Provides
+        @IntoSet
+        static Class<?> addToComponentHierarchy() {
+          return InnerActivitySubcomponent.class;
+        }
+      }
+    }
+
     @Subcomponent(modules = ParentFragmentSubcomponent.ParentFragmentModule.class)
     interface ParentFragmentSubcomponent extends AndroidInjector<TestParentFragment> {
       @Module
diff --git a/javatests/dagger/android/support/functional/AndroidManifest.xml b/javatests/dagger/android/support/functional/AndroidManifest.xml
index 1ace8cb8f..c89d30667 100644
--- a/javatests/dagger/android/support/functional/AndroidManifest.xml
+++ b/javatests/dagger/android/support/functional/AndroidManifest.xml
@@ -16,7 +16,8 @@
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
   package="dagger.android.support.functional">
 
-  <application android:theme="@style/Theme.AppCompat">
+  <application android:theme="@style/Theme.AppCompat"
+      android:name=".UsesGeneratedModulesApplication">
     <activity android:name="dagger.android.support.functional.ParentOfFragmentActivity"/>
     <activity android:name="dagger.android.support.functional.SiblingOfFragmentActivity"/>
     <activity android:name="dagger.android.support.functional.InjectedWithoutSubcomponentActivity"/>
diff --git a/javatests/dagger/android/support/functional/ComponentStructureFollowsControllerStructureApplication.java b/javatests/dagger/android/support/functional/ComponentStructureFollowsControllerStructureApplication.java
index 9490f48e5..379c795f0 100644
--- a/javatests/dagger/android/support/functional/ComponentStructureFollowsControllerStructureApplication.java
+++ b/javatests/dagger/android/support/functional/ComponentStructureFollowsControllerStructureApplication.java
@@ -36,6 +36,7 @@
 import dagger.android.support.FragmentKey;
 import dagger.android.support.functional.ComponentStructureFollowsControllerStructureApplication.ApplicationComponent.BroadcastReceiverSubcomponent.BroadcastReceiverModule;
 import dagger.android.support.functional.ComponentStructureFollowsControllerStructureApplication.ApplicationComponent.ContentProviderSubcomponent.ContentProviderModule;
+import dagger.android.support.functional.ComponentStructureFollowsControllerStructureApplication.ApplicationComponent.InnerActivitySubcomponent.InnerActivityModule;
 import dagger.android.support.functional.ComponentStructureFollowsControllerStructureApplication.ApplicationComponent.IntentServiceSubcomponent.IntentServiceModule;
 import dagger.android.support.functional.ComponentStructureFollowsControllerStructureApplication.ApplicationComponent.ServiceSubcomponent.ServiceModule;
 import dagger.multibindings.IntoMap;
@@ -58,6 +59,7 @@
     @Module(
       subcomponents = {
         ActivitySubcomponent.class,
+        InnerActivitySubcomponent.class,
         ServiceSubcomponent.class,
         IntentServiceSubcomponent.class,
         BroadcastReceiverSubcomponent.class,
@@ -77,6 +79,12 @@
       abstract AndroidInjector.Factory<? extends Activity> bindFactoryForTestActivity(
           ActivitySubcomponent.Builder builder);
 
+      @Binds
+      @IntoMap
+      @ActivityKey(OuterClass.TestInnerClassActivity.class)
+      abstract AndroidInjector.Factory<? extends Activity> bindFactoryForInnerActivity(
+          InnerActivitySubcomponent.Builder builder);
+
       @Binds
       @IntoMap
       @ServiceKey(TestService.class)
@@ -180,6 +188,21 @@
       }
     }
 
+    @Subcomponent(modules = InnerActivityModule.class)
+    interface InnerActivitySubcomponent extends AndroidInjector<OuterClass.TestInnerClassActivity> {
+      @Subcomponent.Builder
+      abstract class Builder extends AndroidInjector.Builder<OuterClass.TestInnerClassActivity> {}
+
+      @Module
+      abstract class InnerActivityModule {
+        @Provides
+        @IntoSet
+        static Class<?> addToComponentHierarchy() {
+          return InnerActivitySubcomponent.class;
+        }
+      }
+    }
+
     @Subcomponent(modules = ServiceModule.class)
     interface ServiceSubcomponent extends AndroidInjector<TestService> {
       @Subcomponent.Builder
diff --git a/javatests/dagger/android/support/functional/InjectorsTest.java b/javatests/dagger/android/support/functional/InjectorsTest.java
index 7303e2b1c..277b156c1 100644
--- a/javatests/dagger/android/support/functional/InjectorsTest.java
+++ b/javatests/dagger/android/support/functional/InjectorsTest.java
@@ -127,6 +127,14 @@ public void componentStructureFollowsControllerStructure() {
                 .ContentProviderSubcomponent.class);
 
     changeConfiguration();
+
+    OuterClass.TestInnerClassActivity innerClassActivity =
+        Robolectric.setupActivity(OuterClass.TestInnerClassActivity.class);
+    assertThat(innerClassActivity.componentHierarchy)
+        .containsExactly(
+            ComponentStructureFollowsControllerStructureApplication.ApplicationComponent.class,
+            ComponentStructureFollowsControllerStructureApplication.ApplicationComponent
+                .InnerActivitySubcomponent.class);
   }
 
   @Test
@@ -177,6 +185,14 @@ public void allControllersAreDirectChildrenOfApplication() {
                 .ContentProviderSubcomponent.class);
 
     changeConfiguration();
+
+    OuterClass.TestInnerClassActivity innerClassActivity =
+        Robolectric.setupActivity(OuterClass.TestInnerClassActivity.class);
+    assertThat(innerClassActivity.componentHierarchy)
+        .containsExactly(
+            AllControllersAreDirectChildrenOfApplication.ApplicationComponent.class,
+            AllControllersAreDirectChildrenOfApplication.ApplicationComponent
+                .InnerActivitySubcomponent.class);
   }
 
   @Test
@@ -224,6 +240,13 @@ public void usesGeneratedModules() {
         Robolectric.setupActivity(TestActivityWithScope.class);
     assertThat(activityWithScope.scopedStringProvider.get())
         .isSameAs(activityWithScope.scopedStringProvider.get());
+
+    OuterClass.TestInnerClassActivity innerClassActivity =
+        Robolectric.setupActivity(OuterClass.TestInnerClassActivity.class);
+    assertThat(innerClassActivity.componentHierarchy)
+        .containsExactly(
+            UsesGeneratedModulesApplication.ApplicationComponent.class,
+            UsesGeneratedModulesApplication.DummyInnerActivitySubcomponent.class);
   }
 
   // https://github.com/google/dagger/issues/598
diff --git a/javatests/dagger/android/support/functional/OuterClass.java b/javatests/dagger/android/support/functional/OuterClass.java
new file mode 100644
index 000000000..e5d6ed595
--- /dev/null
+++ b/javatests/dagger/android/support/functional/OuterClass.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.support.functional;
+
+import dagger.android.support.DaggerAppCompatActivity;
+import java.util.Set;
+import javax.inject.Inject;
+
+final class OuterClass {
+  public static class TestInnerClassActivity extends DaggerAppCompatActivity {
+    @Inject
+    Set<Class<?>> componentHierarchy;
+  }
+}
diff --git a/javatests/dagger/android/support/functional/UsesGeneratedModulesApplication.java b/javatests/dagger/android/support/functional/UsesGeneratedModulesApplication.java
index 661426244..cf340e319 100644
--- a/javatests/dagger/android/support/functional/UsesGeneratedModulesApplication.java
+++ b/javatests/dagger/android/support/functional/UsesGeneratedModulesApplication.java
@@ -55,6 +55,9 @@
     @ContributesAndroidInjector(modules = DummyActivitySubcomponent.AddToHierarchy.class)
     abstract TestActivity contributeTestActivityInjector();
 
+    @ContributesAndroidInjector(modules = DummyInnerActivitySubcomponent.AddToHierarchy.class)
+    abstract OuterClass.TestInnerClassActivity contributeInnerActivityInjector();
+
     @ContributesAndroidInjector(modules = DummyParentFragmentSubcomponent.AddToHierarchy.class)
     abstract TestParentFragment contributeTestParentFragmentInjector();
 
@@ -101,6 +104,17 @@ static String provideScopedString() {
     }
   }
 
+  interface DummyInnerActivitySubcomponent {
+    @Module
+    abstract class AddToHierarchy {
+      @Provides
+      @IntoSet
+      static Class<?> addDummyValueToComponentHierarchy() {
+        return DummyInnerActivitySubcomponent.class;
+      }
+    }
+  }
+
   interface DummyParentFragmentSubcomponent {
     @Module
     abstract class AddToHierarchy {
