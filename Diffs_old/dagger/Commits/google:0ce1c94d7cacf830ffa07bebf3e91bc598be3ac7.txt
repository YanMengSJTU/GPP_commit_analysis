diff --git a/compiler/src/main/java/dagger/internal/codegen/MapKeyGenerator.java b/compiler/src/main/java/dagger/internal/codegen/AnnotationCreatorGenerator.java
similarity index 56%
rename from compiler/src/main/java/dagger/internal/codegen/MapKeyGenerator.java
rename to compiler/src/main/java/dagger/internal/codegen/AnnotationCreatorGenerator.java
index 22c329b48..b4d3726c3 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MapKeyGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AnnotationCreatorGenerator.java
@@ -20,7 +20,7 @@
 import static com.squareup.javapoet.MethodSpec.methodBuilder;
 import static com.squareup.javapoet.TypeSpec.classBuilder;
 import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
-import static dagger.internal.codegen.MapKeys.getMapKeyCreatorClassName;
+import static dagger.internal.codegen.SourceFiles.classFileName;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.PUBLIC;
@@ -29,7 +29,6 @@
 
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoAnnotation;
-import com.google.auto.value.AutoValue;
 import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableList;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
@@ -38,8 +37,6 @@
 import com.squareup.javapoet.MethodSpec;
 import com.squareup.javapoet.TypeName;
 import com.squareup.javapoet.TypeSpec;
-import dagger.MapKey;
-import dagger.internal.codegen.MapKeyGenerator.MapKeyCreatorSpecification;
 import java.util.LinkedHashSet;
 import java.util.Set;
 import javax.annotation.processing.Filer;
@@ -52,81 +49,75 @@
 import javax.lang.model.util.SimpleTypeVisitor6;
 
 /**
- * Generates classes that create annotations required to instantiate {@link MapKey}s.
+ * Generates classes that create annotation instances for an annotation type. The generated class
+ * will have a private empty constructor, a static method that creates the annotation type itself,
+ * and a static method that creates each annotation type that is nested in the top-level annotation
+ * type.
  *
- * @since 2.0
+ * <p>So for an example annotation:
+ *
+ * <pre>
+ *   {@literal @interface} Foo {
+ *     String s();
+ *     int i();
+ *     Bar bar(); // an annotation defined elsewhere
+ *   }
+ * </pre>
+ *
+ * the generated class will look like:
+ *
+ * <pre>
+ *   public final class FooCreator {
+ *     private FooCreator() {}
+ *
+ *     public static Foo createFoo(String s, int i, Bar bar) { … }
+ *     public static Bar createBar(…) { … }
+ *   }
+ * </pre>
  */
-final class MapKeyGenerator extends SourceFileGenerator<MapKeyCreatorSpecification> {
+class AnnotationCreatorGenerator extends SourceFileGenerator<TypeElement> {
 
   /**
-   * Specification of the {@link MapKey} annotation and the annotation type to generate.
+   * Returns the name of the generated class that contains the static {@code create} methods for an
+   * annotation type.
    */
-  @AutoValue
-  abstract static class MapKeyCreatorSpecification {
-    /**
-     * The {@link MapKey}-annotated annotation.
-     */
-    abstract TypeElement mapKeyElement();
-
-    /**
-     * The annotation type to write create methods for. For wrapped {@link MapKey}s, this is
-     * {@link #mapKeyElement()}. For unwrapped {@code MapKey}s whose single element is an
-     * annotation, this is that annotation element.
-     */
-    abstract TypeElement annotationElement();
-
-    /**
-     * Returns a specification for a wrapped {@link MapKey}-annotated annotation.
-     */
-    static MapKeyCreatorSpecification wrappedMapKey(TypeElement mapKeyElement) {
-      return new AutoValue_MapKeyGenerator_MapKeyCreatorSpecification(mapKeyElement, mapKeyElement);
-    }
-
-    /**
-     * Returns a specification for an unwrapped {@link MapKey}-annotated annotation whose single
-     * element is a nested annotation.
-     */
-    static MapKeyCreatorSpecification unwrappedMapKeyWithAnnotationValue(
-        TypeElement mapKeyElement, TypeElement annotationElement) {
-      return new AutoValue_MapKeyGenerator_MapKeyCreatorSpecification(
-          mapKeyElement, annotationElement);
-    }
+  static ClassName getAnnotationCreatorClassName(TypeElement annotationType) {
+    ClassName annotationTypeName = ClassName.get(annotationType);
+    return annotationTypeName
+        .topLevelClassName()
+        .peerClass(classFileName(annotationTypeName) + "Creator");
   }
 
-  MapKeyGenerator(Filer filer, Elements elements) {
+  AnnotationCreatorGenerator(Filer filer, Elements elements) {
     super(filer, elements);
   }
 
   @Override
-  ClassName nameGeneratedType(MapKeyCreatorSpecification mapKeyCreatorType) {
-    return getMapKeyCreatorClassName(mapKeyCreatorType.mapKeyElement());
+  ClassName nameGeneratedType(TypeElement annotationType) {
+    return getAnnotationCreatorClassName(annotationType);
   }
 
   @Override
-  Optional<? extends Element> getElementForErrorReporting(
-      MapKeyCreatorSpecification mapKeyCreatorType) {
-    return Optional.of(mapKeyCreatorType.mapKeyElement());
+  Optional<? extends Element> getElementForErrorReporting(TypeElement annotationType) {
+    return Optional.of(annotationType);
   }
 
   @Override
-  Optional<TypeSpec.Builder> write(
-      ClassName generatedTypeName, MapKeyCreatorSpecification mapKeyCreatorType) {
-    TypeSpec.Builder mapKeyCreatorBuilder =
-        classBuilder(generatedTypeName).addModifiers(PUBLIC, FINAL);
-
-    mapKeyCreatorBuilder.addMethod(constructorBuilder().addModifiers(PRIVATE).build());
-
-    for (TypeElement annotationElement :
-        nestedAnnotationElements(mapKeyCreatorType.annotationElement())) {
-      mapKeyCreatorBuilder.addMethod(buildCreateMethod(generatedTypeName, annotationElement));
+  Optional<TypeSpec.Builder> write(ClassName generatedTypeName, TypeElement annotationType) {
+    TypeSpec.Builder annotationCreatorBuilder =
+        classBuilder(generatedTypeName)
+            .addModifiers(PUBLIC, FINAL)
+            .addMethod(constructorBuilder().addModifiers(PRIVATE).build());
+
+    for (TypeElement annotationElement : annotationsToCreate(annotationType)) {
+      annotationCreatorBuilder.addMethod(buildCreateMethod(generatedTypeName, annotationElement));
     }
 
-    return Optional.of(mapKeyCreatorBuilder);
+    return Optional.of(annotationCreatorBuilder);
   }
 
-  private MethodSpec buildCreateMethod(
-      ClassName mapKeyGeneratedTypeName, TypeElement annotationElement) {
-    String createMethodName = "create" + annotationElement.getSimpleName();
+  private MethodSpec buildCreateMethod(ClassName generatedTypeName, TypeElement annotationElement) {
+    String createMethodName = createMethodName(annotationElement);
     MethodSpec.Builder createMethod =
         methodBuilder(createMethodName)
             .addAnnotation(AutoAnnotation.class)
@@ -141,14 +132,23 @@ private MethodSpec buildCreateMethod(
       parameters.add(CodeBlock.of("$L", parameterName));
     }
 
-    ClassName autoAnnotationClass = mapKeyGeneratedTypeName.peerClass(
-        "AutoAnnotation_" + mapKeyGeneratedTypeName.simpleName() + "_" + createMethodName);
+    ClassName autoAnnotationClass =
+        generatedTypeName.peerClass(
+            "AutoAnnotation_" + generatedTypeName.simpleName() + "_" + createMethodName);
     createMethod.addStatement(
         "return new $T($L)", autoAnnotationClass, makeParametersCodeBlock(parameters.build()));
     return createMethod.build();
   }
 
-  private static Set<TypeElement> nestedAnnotationElements(TypeElement annotationElement) {
+  static String createMethodName(TypeElement annotationType) {
+    return "create" + annotationType.getSimpleName();
+  }
+
+  /**
+   * Returns the annotation types for which {@code @AutoAnnotation static Foo createFoo(…)} methods
+   * should be written.
+   */
+  protected Set<TypeElement> annotationsToCreate(TypeElement annotationElement) {
     return nestedAnnotationElements(annotationElement, new LinkedHashSet<TypeElement>());
   }
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/AnnotationExpression.java b/compiler/src/main/java/dagger/internal/codegen/AnnotationExpression.java
new file mode 100644
index 000000000..a3bb91caf
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/AnnotationExpression.java
@@ -0,0 +1,196 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.auto.common.AnnotationMirrors.getAnnotationValuesWithDefaults;
+import static com.google.common.collect.Iterables.transform;
+import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
+
+import com.google.auto.common.MoreElements;
+import com.google.auto.common.MoreTypes;
+import com.google.common.base.Function;
+import com.google.common.collect.ImmutableList;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.TypeName;
+import java.util.List;
+import java.util.Map;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.AnnotationValue;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.ArrayType;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.SimpleAnnotationValueVisitor6;
+import javax.lang.model.util.SimpleTypeVisitor6;
+
+/**
+ * Returns an expression creating an instance of the visited annotation type. Its parameter must be
+ * a class as generated by {@link AnnotationCreatorGenerator}.
+ *
+ * <p>Note that {@link AnnotationValue#toString()} is the source-code representation of the value
+ * <em>when used in an annotation</em>, which is not always the same as the representation needed
+ * when creating the value in a method body.
+ *
+ * <p>For example, inside an annotation, a nested array of {@code int}s is simply {@code {1, 2, 3}},
+ * but in code it would have to be {@code new int[] {1, 2, 3}}.
+ */
+class AnnotationExpression extends SimpleAnnotationValueVisitor6<CodeBlock, AnnotationValue> {
+
+  private final AnnotationMirror annotation;
+  private final ClassName creatorClass;
+
+  AnnotationExpression(AnnotationMirror annotation) {
+    this.annotation = annotation;
+    this.creatorClass =
+        AnnotationCreatorGenerator.getAnnotationCreatorClassName(
+            MoreTypes.asTypeElement(annotation.getAnnotationType()));
+  }
+
+  /**
+   * Returns an expression that calls static methods on the annotation's creator class to create an
+   * annotation instance equivalent the annotation passed to the constructor.
+   */
+  CodeBlock getAnnotationInstanceExpression() {
+    return getAnnotationInstanceExpression(annotation);
+  }
+
+  private CodeBlock getAnnotationInstanceExpression(AnnotationMirror annotation) {
+    return CodeBlock.of(
+        "$T.$L($L)",
+        creatorClass,
+        AnnotationCreatorGenerator.createMethodName(
+            MoreElements.asType(annotation.getAnnotationType().asElement())),
+        makeParametersCodeBlock(
+            transform(
+                getAnnotationValuesWithDefaults(annotation).entrySet(),
+                new Function<Map.Entry<ExecutableElement, AnnotationValue>, CodeBlock>() {
+                  @Override
+                  public CodeBlock apply(Map.Entry<ExecutableElement, AnnotationValue> entry) {
+                    return getValueExpression(entry.getKey().getReturnType(), entry.getValue());
+                  }
+                })));
+  }
+
+  /**
+   * Returns an expression that evaluates to a {@code value} of a given type on an {@code
+   * annotation}.
+   */
+  CodeBlock getValueExpression(TypeMirror valueType, AnnotationValue value) {
+    return ARRAY_LITERAL_PREFIX.visit(valueType, this.visit(value, value));
+  }
+
+  @Override
+  public CodeBlock visitEnumConstant(VariableElement c, AnnotationValue p) {
+    return CodeBlock.of("$T.$L", TypeName.get(c.getEnclosingElement().asType()), c.getSimpleName());
+  }
+
+  @Override
+  public CodeBlock visitAnnotation(AnnotationMirror a, AnnotationValue p) {
+    return getAnnotationInstanceExpression(a);
+  }
+
+  @Override
+  public CodeBlock visitType(TypeMirror t, AnnotationValue p) {
+    return CodeBlock.of("$T.class", TypeName.get(t));
+  }
+
+  @Override
+  public CodeBlock visitString(String s, AnnotationValue p) {
+    return CodeBlock.of("$S", s);
+  }
+
+  @Override
+  public CodeBlock visitByte(byte b, AnnotationValue p) {
+    return CodeBlock.of("(byte) $L", b);
+  }
+
+  @Override
+  public CodeBlock visitChar(char c, AnnotationValue p) {
+    return CodeBlock.of("$L", p);
+  }
+
+  @Override
+  public CodeBlock visitDouble(double d, AnnotationValue p) {
+    return CodeBlock.of("$LD", d);
+  }
+
+  @Override
+  public CodeBlock visitFloat(float f, AnnotationValue p) {
+    return CodeBlock.of("$LF", f);
+  }
+
+  @Override
+  public CodeBlock visitLong(long i, AnnotationValue p) {
+    return CodeBlock.of("$LL", i);
+  }
+
+  @Override
+  public CodeBlock visitShort(short s, AnnotationValue p) {
+    return CodeBlock.of("(short) $L", s);
+  }
+
+  @Override
+  protected CodeBlock defaultAction(Object o, AnnotationValue p) {
+    return CodeBlock.of("$L", o);
+  }
+
+  @Override
+  public CodeBlock visitArray(List<? extends AnnotationValue> values, AnnotationValue p) {
+    ImmutableList.Builder<CodeBlock> codeBlocks = ImmutableList.builder();
+    for (AnnotationValue value : values) {
+      codeBlocks.add(this.visit(value, p));
+    }
+    return CodeBlock.of("{$L}", makeParametersCodeBlock(codeBlocks.build()));
+  }
+
+  /**
+   * If the visited type is an array, prefixes the parameter code block with {@code new T[]}, where
+   * {@code T} is the raw array component type.
+   */
+  private static final SimpleTypeVisitor6<CodeBlock, CodeBlock> ARRAY_LITERAL_PREFIX =
+      new SimpleTypeVisitor6<CodeBlock, CodeBlock>() {
+
+        @Override
+        public CodeBlock visitArray(ArrayType t, CodeBlock p) {
+          return CodeBlock.of("new $T[] $L", RAW_TYPE_NAME.visit(t.getComponentType()), p);
+        }
+
+        @Override
+        protected CodeBlock defaultAction(TypeMirror e, CodeBlock p) {
+          return p;
+        }
+      };
+
+  /**
+   * If the visited type is an array, returns the name of its raw component type; otherwise returns
+   * the name of the type itself.
+   */
+  private static final SimpleTypeVisitor6<TypeName, Void> RAW_TYPE_NAME =
+      new SimpleTypeVisitor6<TypeName, Void>() {
+        @Override
+        public TypeName visitDeclared(DeclaredType t, Void p) {
+          return ClassName.get(MoreTypes.asTypeElement(t));
+        }
+
+        @Override
+        protected TypeName defaultAction(TypeMirror e, Void p) {
+          return TypeName.get(e);
+        }
+      };
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
index be36c9bfb..b61872b66 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -158,7 +158,10 @@ public SourceVersion getSupportedSourceVersion() {
             provisionBindingFactory,
             productionBindingFactory);
 
-    MapKeyGenerator mapKeyGenerator = new MapKeyGenerator(filer, elements);
+    AnnotationCreatorGenerator annotationCreatorGenerator =
+        new AnnotationCreatorGenerator(filer, elements);
+    UnwrappedMapKeyGenerator unwrappedMapKeyGenerator =
+        new UnwrappedMapKeyGenerator(filer, elements);
     ComponentHierarchyValidator componentHierarchyValidator = new ComponentHierarchyValidator();
     BindingGraphValidator bindingGraphValidator =
         new BindingGraphValidator(
@@ -174,7 +177,8 @@ public SourceVersion getSupportedSourceVersion() {
             keyFactory);
 
     return ImmutableList.of(
-        new MapKeyProcessingStep(messager, types, mapKeyValidator, mapKeyGenerator),
+        new MapKeyProcessingStep(
+            messager, types, mapKeyValidator, annotationCreatorGenerator, unwrappedMapKeyGenerator),
         new InjectProcessingStep(injectBindingRegistry),
         new MonitoringModuleProcessingStep(messager, monitoringModuleGenerator),
         new ProductionExecutorModuleProcessingStep(messager, productionExecutorModuleGenerator),
diff --git a/compiler/src/main/java/dagger/internal/codegen/MapKeyProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/MapKeyProcessingStep.java
index 2dfe472c1..241e61771 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MapKeyProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MapKeyProcessingStep.java
@@ -16,8 +16,6 @@
 
 package dagger.internal.codegen;
 
-import static dagger.internal.codegen.MapKeyGenerator.MapKeyCreatorSpecification.unwrappedMapKeyWithAnnotationValue;
-import static dagger.internal.codegen.MapKeyGenerator.MapKeyCreatorSpecification.wrappedMapKey;
 import static dagger.internal.codegen.MapKeys.getUnwrappedMapKeyType;
 import static javax.lang.model.element.ElementKind.ANNOTATION_TYPE;
 import static javax.lang.model.util.ElementFilter.typesIn;
@@ -31,6 +29,7 @@
 import java.util.Set;
 import javax.annotation.processing.Messager;
 import javax.lang.model.element.Element;
+import javax.lang.model.element.ElementKind;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.util.Types;
@@ -46,17 +45,20 @@
   private final Messager messager;
   private final Types types;
   private final MapKeyValidator mapKeyValidator;
-  private final MapKeyGenerator mapKeyGenerator;
+  private final AnnotationCreatorGenerator annotationCreatorGenerator;
+  private final UnwrappedMapKeyGenerator unwrappedMapKeyGenerator;
 
   MapKeyProcessingStep(
       Messager messager,
       Types types,
       MapKeyValidator mapKeyValidator,
-      MapKeyGenerator mapKeyGenerator) {
+      AnnotationCreatorGenerator annotationCreatorGenerator,
+      UnwrappedMapKeyGenerator unwrappedMapKeyGenerator) {
     this.messager = messager;
     this.types = types;
     this.mapKeyValidator = mapKeyValidator;
-    this.mapKeyGenerator = mapKeyGenerator;
+    this.annotationCreatorGenerator = annotationCreatorGenerator;
+    this.unwrappedMapKeyGenerator = unwrappedMapKeyGenerator;
   }
 
   @Override
@@ -67,26 +69,25 @@
   @Override
   public Set<Element> process(
       SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
-    for (TypeElement mapKeyAnnotation : typesIn(elementsByAnnotation.get(MapKey.class))) {
-      ValidationReport<Element> mapKeyReport = mapKeyValidator.validate(mapKeyAnnotation);
+    for (TypeElement mapKeyAnnotationType : typesIn(elementsByAnnotation.get(MapKey.class))) {
+      ValidationReport<Element> mapKeyReport = mapKeyValidator.validate(mapKeyAnnotationType);
       mapKeyReport.printMessagesTo(messager);
 
       if (mapKeyReport.isClean()) {
-        MapKey mapkey = mapKeyAnnotation.getAnnotation(MapKey.class);
-        if (mapkey.unwrapValue()) {
-          DeclaredType keyType =
-              getUnwrappedMapKeyType(MoreTypes.asDeclared(mapKeyAnnotation.asType()), types);
-          if (keyType.asElement().getKind().equals(ANNOTATION_TYPE)) {
-            mapKeyGenerator.generate(
-                unwrappedMapKeyWithAnnotationValue(
-                    mapKeyAnnotation, MoreTypes.asTypeElement(keyType)),
-                messager);
-          }
-        } else {
-          mapKeyGenerator.generate(wrappedMapKey(mapKeyAnnotation), messager);
+        MapKey mapkey = mapKeyAnnotationType.getAnnotation(MapKey.class);
+        if (!mapkey.unwrapValue()) {
+          annotationCreatorGenerator.generate(mapKeyAnnotationType, messager);
+        } else if (unwrappedValueKind(mapKeyAnnotationType).equals(ANNOTATION_TYPE)) {
+          unwrappedMapKeyGenerator.generate(mapKeyAnnotationType, messager);
         }
       }
     }
     return ImmutableSet.of();
   }
+
+  private ElementKind unwrappedValueKind(TypeElement mapKeyAnnotationType) {
+    DeclaredType unwrappedMapKeyType =
+        getUnwrappedMapKeyType(MoreTypes.asDeclared(mapKeyAnnotationType.asType()), types);
+    return unwrappedMapKeyType.asElement().getKind();
+  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/MapKeys.java b/compiler/src/main/java/dagger/internal/codegen/MapKeys.java
index c086d1420..3aec5796b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MapKeys.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MapKeys.java
@@ -20,35 +20,23 @@
 import static com.google.auto.common.AnnotationMirrors.getAnnotationValuesWithDefaults;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.collect.Iterables.getOnlyElement;
-import static com.google.common.collect.Iterables.transform;
-import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
-import static dagger.internal.codegen.SourceFiles.classFileName;
 import static javax.lang.model.util.ElementFilter.methodsIn;
 
 import com.google.auto.common.MoreTypes;
-import com.google.common.base.Function;
 import com.google.common.base.Optional;
-import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
-import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
-import com.squareup.javapoet.TypeName;
 import dagger.MapKey;
-import java.util.List;
-import java.util.Map;
 import java.util.NoSuchElementException;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.AnnotationValue;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ElementKind;
 import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.TypeElement;
-import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.ArrayType;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.PrimitiveType;
 import javax.lang.model.type.TypeMirror;
-import javax.lang.model.util.SimpleAnnotationValueVisitor6;
 import javax.lang.model.util.SimpleTypeVisitor6;
 import javax.lang.model.util.Types;
 
@@ -133,15 +121,6 @@ public DeclaredType visitDeclared(DeclaredType t, Void p) {
     return keyTypeElementVisitor.visit(onlyElement.getReturnType());
   }
 
-  /**
-   * Returns the name of the generated class that contains the static {@code create} methods for a
-   * {@link MapKey} annotation type.
-   */
-  public static ClassName getMapKeyCreatorClassName(TypeElement mapKeyType) {
-    ClassName mapKeyTypeName = ClassName.get(mapKeyType);
-    return mapKeyTypeName.topLevelClassName().peerClass(classFileName(mapKeyTypeName) + "Creator");
-  }
-
   /**
    * Returns a code block for the map key specified by the {@link MapKey} annotation on
    * {@code bindingElement}.
@@ -152,183 +131,16 @@ public static ClassName getMapKeyCreatorClassName(TypeElement mapKeyType) {
    *     annotation
    */
   static CodeBlock getMapKeyExpression(AnnotationMirror mapKey) {
-    ClassName mapKeyCreator =
-        getMapKeyCreatorClassName(MoreTypes.asTypeElement(mapKey.getAnnotationType()));
     Optional<? extends AnnotationValue> unwrappedValue = unwrapValue(mapKey);
+    AnnotationExpression annotationExpression = new AnnotationExpression(mapKey);
     if (unwrappedValue.isPresent()) {
-      return new MapKeyExpressionExceptArrays(mapKeyCreator)
-          .visit(unwrappedValue.get(), unwrappedValue.get());
+      TypeMirror unwrappedValueType =
+          getOnlyElement(getAnnotationValuesWithDefaults(mapKey).keySet()).getReturnType();
+      return annotationExpression.getValueExpression(unwrappedValueType, unwrappedValue.get());
     } else {
-      return annotationExpression(mapKey, new MapKeyExpression(mapKeyCreator));
+      return annotationExpression.getAnnotationInstanceExpression();
     }
   }
 
-  /**
-   * Returns a code block to create the visited value in code. Expects its parameter to be a class
-   * with static creation methods for all nested annotation types.
-   *
-   * <p>Note that {@link AnnotationValue#toString()} is the source-code representation of the value
-   * <em>when used in an annotation</em>, which is not always the same as the representation needed
-   * when creating the value in a method body.
-   *
-   * <p>For example, inside an annotation, a nested array of {@code int}s is simply
-   * {@code {1, 2, 3}}, but in code it would have to be {@code new int[] {1, 2, 3}}.
-   */
-  private static class MapKeyExpression
-      extends SimpleAnnotationValueVisitor6<CodeBlock, AnnotationValue> {
-
-    final ClassName mapKeyCreator;
-
-    MapKeyExpression(ClassName mapKeyCreator) {
-      this.mapKeyCreator = mapKeyCreator;
-    }
-
-    @Override
-    public CodeBlock visitEnumConstant(VariableElement c, AnnotationValue p) {
-      return CodeBlock.of(
-          "$T.$L", TypeName.get(c.getEnclosingElement().asType()), c.getSimpleName());
-    }
-
-    @Override
-    public CodeBlock visitAnnotation(AnnotationMirror a, AnnotationValue p) {
-      return annotationExpression(a, this);
-    }
-
-    @Override
-    public CodeBlock visitType(TypeMirror t, AnnotationValue p) {
-      return CodeBlock.of("$T.class", TypeName.get(t));
-    }
-
-    @Override
-    public CodeBlock visitString(String s, AnnotationValue p) {
-      return CodeBlock.of("$S", s);
-    }
-
-    @Override
-    public CodeBlock visitByte(byte b, AnnotationValue p) {
-      return CodeBlock.of("(byte) $L", b);
-    }
-
-    @Override
-    public CodeBlock visitChar(char c, AnnotationValue p) {
-      return CodeBlock.of("$L", p);
-    }
-
-    @Override
-    public CodeBlock visitDouble(double d, AnnotationValue p) {
-      return CodeBlock.of("$LD", d);
-    }
-
-    @Override
-    public CodeBlock visitFloat(float f, AnnotationValue p) {
-      return CodeBlock.of("$LF", f);
-    }
-
-    @Override
-    public CodeBlock visitInt(int i, AnnotationValue p) {
-      return CodeBlock.of("(int) $L", i);
-    }
-
-    @Override
-    public CodeBlock visitLong(long i, AnnotationValue p) {
-      return CodeBlock.of("$LL", i);
-    }
-
-    @Override
-    public CodeBlock visitShort(short s, AnnotationValue p) {
-      return CodeBlock.of("(short) $L", s);
-    }
-
-    @Override
-    protected CodeBlock defaultAction(Object o, AnnotationValue p) {
-      return CodeBlock.of("$L", o);
-    }
-
-    @Override
-    public CodeBlock visitArray(List<? extends AnnotationValue> values, AnnotationValue p) {
-      ImmutableList.Builder<CodeBlock> codeBlocks = ImmutableList.builder();
-      for (int i = 0; i < values.size(); i++) {
-        codeBlocks.add(this.visit(values.get(i), p));
-      }
-      return CodeBlock.of("{$L}", makeParametersCodeBlock(codeBlocks.build()));
-    }
-  }
-
-  /**
-   * Returns a code block for the visited value. Expects its parameter to be a class with static
-   * creation methods for all nested annotation types.
-   *
-   * <p>Throws {@link IllegalArgumentException} if the visited value is an array.
-   */
-  private static class MapKeyExpressionExceptArrays extends MapKeyExpression {
-
-    MapKeyExpressionExceptArrays(ClassName mapKeyCreator) {
-      super(mapKeyCreator);
-    }
-
-    @Override
-    public CodeBlock visitArray(List<? extends AnnotationValue> values, AnnotationValue p) {
-      throw new IllegalArgumentException("Cannot unwrap arrays");
-    }
-  }
-
-  /**
-   * Returns a code block that calls a static method on {@code mapKeyCodeBlock.mapKeyCreator} to
-   * create an annotation from {@code mapKeyAnnotation}.
-   */
-  private static CodeBlock annotationExpression(
-      AnnotationMirror mapKeyAnnotation, final MapKeyExpression mapKeyExpression) {
-    return CodeBlock.of(
-        "$T.create$L($L)",
-        mapKeyExpression.mapKeyCreator,
-        mapKeyAnnotation.getAnnotationType().asElement().getSimpleName(),
-        makeParametersCodeBlock(
-            transform(
-                getAnnotationValuesWithDefaults(mapKeyAnnotation).entrySet(),
-                new Function<Map.Entry<ExecutableElement, AnnotationValue>, CodeBlock>() {
-                  @Override
-                  public CodeBlock apply(Map.Entry<ExecutableElement, AnnotationValue> entry) {
-                    return ARRAY_LITERAL_PREFIX.visit(
-                        entry.getKey().getReturnType(),
-                        mapKeyExpression.visit(entry.getValue(), entry.getValue()));
-                  }
-                })));
-  }
-
-  /**
-   * If the visited type is an array, prefixes the parameter code block with {@code new T[]}, where
-   * {@code T} is the raw array component type.
-   */
-  private static final SimpleTypeVisitor6<CodeBlock, CodeBlock> ARRAY_LITERAL_PREFIX =
-      new SimpleTypeVisitor6<CodeBlock, CodeBlock>() {
-
-        @Override
-        public CodeBlock visitArray(ArrayType t, CodeBlock p) {
-          return CodeBlock.of("new $T[] $L", RAW_TYPE_NAME.visit(t.getComponentType()), p);
-        }
-
-        @Override
-        protected CodeBlock defaultAction(TypeMirror e, CodeBlock p) {
-          return p;
-        }
-      };
-
-  /**
-   * If the visited type is an array, returns the name of its raw component type; otherwise returns
-   * the name of the type itself.
-   */
-  private static final SimpleTypeVisitor6<TypeName, Void> RAW_TYPE_NAME =
-      new SimpleTypeVisitor6<TypeName, Void>() {
-        @Override
-        public TypeName visitDeclared(DeclaredType t, Void p) {
-          return ClassName.get(MoreTypes.asTypeElement(t));
-        }
-
-        @Override
-        protected TypeName defaultAction(TypeMirror e, Void p) {
-          return TypeName.get(e);
-        }
-      };
-
   private MapKeys() {}
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/UnwrappedMapKeyGenerator.java b/compiler/src/main/java/dagger/internal/codegen/UnwrappedMapKeyGenerator.java
new file mode 100644
index 000000000..47a6293a0
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/UnwrappedMapKeyGenerator.java
@@ -0,0 +1,66 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import dagger.MapKey;
+import java.util.Set;
+import javax.annotation.processing.Filer;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.util.Elements;
+
+/**
+ * Generates classes that create annotation instances for an unwrapped {@link MapKey} annotation
+ * type whose nested value is an annotation. The generated class will have a private empty
+ * constructor and a static method that creates each annotation type that is nested in the top-level
+ * annotation type.
+ *
+ * <p>So for an example {@link MapKey} annotation:
+ *
+ * <pre>
+ *   {@literal @MapKey}(unwrapValue = true)
+ *   {@literal @interface} Foo {
+ *     Bar bar();
+ *   }
+ *
+ *   {@literal @interface} Bar {
+ *     Class<?> baz();
+ *   }
+ * </pre>
+ *
+ * the generated class will look like:
+ *
+ * <pre>
+ *   public final class FooCreator {
+ *     private FooCreator() {}
+ *
+ *     public static Bar createBar(Class<?> baz) { … }
+ *   }
+ * </pre>
+ */
+final class UnwrappedMapKeyGenerator extends AnnotationCreatorGenerator {
+
+  UnwrappedMapKeyGenerator(Filer filer, Elements elements) {
+    super(filer, elements);
+  }
+
+  @Override
+  protected Set<TypeElement> annotationsToCreate(TypeElement annotationElement) {
+    Set<TypeElement> nestedAnnotationElements = super.annotationsToCreate(annotationElement);
+    nestedAnnotationElements.remove(annotationElement);
+    return nestedAnnotationElements;
+  }
+}
