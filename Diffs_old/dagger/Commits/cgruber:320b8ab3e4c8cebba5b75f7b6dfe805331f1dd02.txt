diff --git a/java/dagger/internal/codegen/BindingGraph.java b/java/dagger/internal/codegen/BindingGraph.java
index bcc741a08..c66ec826e 100644
--- a/java/dagger/internal/codegen/BindingGraph.java
+++ b/java/dagger/internal/codegen/BindingGraph.java
@@ -76,6 +76,7 @@
 import java.util.Optional;
 import java.util.Queue;
 import java.util.Set;
+import java.util.function.Function;
 import java.util.stream.Stream;
 import java.util.stream.StreamSupport;
 import javax.inject.Inject;
@@ -528,70 +529,45 @@ private BindingGraph create(
        * </ul>
        */
       ResolvedBindings lookUpBindings(Key requestKey) {
-        Set<ContributionBinding> contributionBindings = new LinkedHashSet<>();
-        ImmutableSet.Builder<ContributionBinding> multibindingContributionsBuilder =
-            ImmutableSet.builder();
-        ImmutableSet.Builder<MultibindingDeclaration> multibindingDeclarationsBuilder =
-            ImmutableSet.builder();
-        ImmutableSet.Builder<SubcomponentDeclaration> subcomponentDeclarationsBuilder =
-            ImmutableSet.builder();
-        ImmutableSet.Builder<OptionalBindingDeclaration> optionalBindingDeclarationsBuilder =
-            ImmutableSet.builder();
-
-        for (Key key : keysMatchingRequest(requestKey)) {
-          contributionBindings.addAll(getExplicitBindings(key));
-          multibindingContributionsBuilder.addAll(getExplicitMultibindings(key));
-          multibindingDeclarationsBuilder.addAll(getMultibindingDeclarations(key));
-          subcomponentDeclarationsBuilder.addAll(getSubcomponentDeclarations(key));
-          optionalBindingDeclarationsBuilder.addAll(getOptionalBindingDeclarations(key));
-        }
+        Set<ContributionBinding> bindings = new LinkedHashSet<>();
+        bindings.addAll(getExplicitBindings(requestKey));
 
         ImmutableSet<ContributionBinding> multibindingContributions =
-            multibindingContributionsBuilder.build();
+            getAllMatchingBindingDeclarations(requestKey, this::getExplicitMultibindings);
         ImmutableSet<MultibindingDeclaration> multibindingDeclarations =
-            multibindingDeclarationsBuilder.build();
-        ImmutableSet<SubcomponentDeclaration> subcomponentDeclarations =
-            subcomponentDeclarationsBuilder.build();
+            getAllMatchingBindingDeclarations(requestKey, this::getMultibindingDeclarations);
+
+        syntheticMultibinding(requestKey, multibindingContributions, multibindingDeclarations)
+            .ifPresent(bindings::add);
+
         ImmutableSet<OptionalBindingDeclaration> optionalBindingDeclarations =
-            optionalBindingDeclarationsBuilder.build();
+            getAllMatchingBindingDeclarations(requestKey, this::getOptionalBindingDeclarations);
+        syntheticOptionalBinding(requestKey, optionalBindingDeclarations).ifPresent(bindings::add);
 
-        ImmutableSet.Builder<Optional<? extends ContributionBinding>> maybeContributionBindings =
-            ImmutableSet.builder();
-        maybeContributionBindings.add(
-            syntheticMultibinding(
-                requestKey, multibindingContributions, multibindingDeclarations));
+        ImmutableSet<SubcomponentDeclaration> subcomponentDeclarations =
+            getSubcomponentDeclarations(requestKey);
         syntheticSubcomponentBuilderBinding(subcomponentDeclarations)
             .ifPresent(
                 binding -> {
-                  contributionBindings.add(binding);
+                  bindings.add(binding);
                   addSubcomponentToOwningResolver(binding);
                 });
-        maybeContributionBindings.add(
-            syntheticOptionalBinding(requestKey, optionalBindingDeclarations));
-
-        /* If there are no bindings, add the implicit @Inject-constructed binding if there is
-         * one. */
-        if (contributionBindings.isEmpty()) {
-          maybeContributionBindings.add(
-              injectBindingRegistry.getOrFindProvisionBinding(requestKey));
-        }
 
         if (isType(requestKey.type()) && isTypeOf(MembersInjector.class, requestKey.type())) {
-          maybeContributionBindings.add(
-              injectBindingRegistry.getOrFindMembersInjectorProvisionBinding(requestKey));
+          injectBindingRegistry
+              .getOrFindMembersInjectorProvisionBinding(requestKey)
+              .ifPresent(bindings::add);
         }
 
-        maybeContributionBindings
-            .build()
-            .stream()
-            .filter(Optional::isPresent)
-            .map(Optional::get)
-            .forEach(contributionBindings::add);
+        // If there are no bindings, add the implicit @Inject-constructed binding if there is one.
+        if (bindings.isEmpty()) {
+          injectBindingRegistry.getOrFindProvisionBinding(requestKey).ifPresent(bindings::add);
+        }
 
         return ResolvedBindings.forContributionBindings(
             requestKey,
             componentDescriptor,
-            indexBindingsByOwningComponent(requestKey, ImmutableSet.copyOf(contributionBindings)),
+            indexBindingsByOwningComponent(requestKey, ImmutableSet.copyOf(bindings)),
             multibindingDeclarations,
             subcomponentDeclarations,
             optionalBindingDeclarations);
@@ -866,6 +842,18 @@ private boolean isResolvedInParent(Key requestKey, ContributionBinding binding)
         return ImmutableList.copyOf(Lists.reverse(resolverList));
       }
 
+      /**
+       * For all {@linkplain #keysMatchingRequest(Key) keys matching {@code requestKey}}, applies
+       * {@code getDeclarationsPerKey} and collects the values into an {@link ImmutableSet}.
+       */
+      private <T extends BindingDeclaration> ImmutableSet<T> getAllMatchingBindingDeclarations(
+          Key requestKey, Function<Key, Collection<T>> getDeclarationsPerKey) {
+        return keysMatchingRequest(requestKey)
+            .stream()
+            .flatMap(key -> getDeclarationsPerKey.apply(key).stream())
+            .collect(toImmutableSet());
+      }
+
       /**
        * Returns the explicit {@link ContributionBinding}s that match the {@code key} from this and
        * all ancestor resolvers.
diff --git a/javatests/dagger/internal/codegen/MultibindingTest.java b/javatests/dagger/internal/codegen/MultibindingTest.java
index dce0b65d2..49f78203a 100644
--- a/javatests/dagger/internal/codegen/MultibindingTest.java
+++ b/javatests/dagger/internal/codegen/MultibindingTest.java
@@ -18,7 +18,9 @@
 
 import static com.google.testing.compile.CompilationSubject.assertThat;
 import static com.google.testing.compile.JavaSourcesSubject.assertThat;
+import static dagger.internal.codegen.Compilers.daggerCompiler;
 
+import com.google.testing.compile.Compilation;
 import com.google.testing.compile.JavaFileObjects;
 import javax.tools.JavaFileObject;
 import org.junit.Test;
@@ -94,4 +96,99 @@ public void appliedOnInvalidMethods_failsToCompile() {
         .in(component)
         .onLine(13);
   }
+
+  @Test
+  public void concreteBindingForMultibindingAlias() {
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import java.util.Collections;",
+            "import java.util.Map;",
+            "import javax.inject.Provider;",
+            "",
+            "@Module",
+            "class TestModule {",
+            "  @Provides",
+            "  Map<String, Provider<String>> mapOfStringToProviderOfString() {",
+            "    return Collections.emptyMap();",
+            "  }",
+            "}");
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import java.util.Map;",
+            "",
+            "@Component(modules = TestModule.class)",
+            "interface TestComponent {",
+            "  Map<String, String> mapOfStringToString();",
+            "}");
+    Compilation compilation = daggerCompiler().compile(module, component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            "java.util.Map<java.lang.String,java.lang.String> "
+                + "cannot be provided without an @Provides-annotated method")
+        .inFile(component)
+        .onLineContaining("mapOfStringToString()");
+  }
+
+  @Test
+  public void produceConcreteSet_andRequestSetOfProduced() {
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.producers.ProducerModule;",
+            "import dagger.producers.Produces;",
+            "import java.util.Collections;",
+            "import java.util.Set;",
+            "",
+            "@ProducerModule",
+            "class TestModule {",
+            "  @Produces",
+            "  Set<String> setOfString() {",
+            "    return Collections.emptySet();",
+            "  }",
+            "}");
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import com.google.common.util.concurrent.ListenableFuture;",
+            "import dagger.BindsInstance;",
+            "import dagger.producers.Produced;",
+            "import dagger.producers.Production;",
+            "import dagger.producers.ProductionComponent;",
+            "import java.util.concurrent.Executor;",
+            "import java.util.Set;",
+            "",
+            "@ProductionComponent(modules = TestModule.class)",
+            "interface TestComponent {",
+            "  ListenableFuture<Set<Produced<String>>> setOfProduced();",
+            "",
+            "  @ProductionComponent.Builder",
+            "  interface Builder {",
+            "    @BindsInstance Builder executor(@Production Executor executor);",
+            "    TestComponent build();",
+            "  }",
+            "}");
+    Compilation compilation = daggerCompiler().compile(module, component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            "java.util.Set<dagger.producers.Produced<java.lang.String>> "
+                + "cannot be provided without an @Provides- or @Produces-annotated method")
+        .inFile(component)
+        .onLineContaining("setOfProduced()");
+
+  }
 }
