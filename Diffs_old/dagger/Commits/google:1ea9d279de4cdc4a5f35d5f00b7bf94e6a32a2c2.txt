diff --git a/README.md b/README.md
index c8a50ec4f..2ad89f8d9 100644
--- a/README.md
+++ b/README.md
@@ -1,5 +1,5 @@
-Dagger
-======
+Dagger 2
+========
 
 A fast dependency injector for Android and Java.
 
diff --git a/compiler/pom.xml b/compiler/pom.xml
index 5ae96f62d..465c1ae3b 100644
--- a/compiler/pom.xml
+++ b/compiler/pom.xml
@@ -57,6 +57,7 @@
     <dependency>
       <groupId>com.google.auto.value</groupId>
       <artifactId>auto-value</artifactId>
+      <version>1.0-SNAPSHOT</version>
       <optional>true</optional>
     </dependency>
 
@@ -65,11 +66,6 @@
       <artifactId>junit</artifactId>
       <scope>test</scope>
     </dependency>
-    <dependency>
-      <groupId>org.easytesting</groupId>
-      <artifactId>fest-assert</artifactId>
-      <scope>test</scope>
-    </dependency>
     <dependency>
       <groupId>${project.groupId}</groupId>
       <artifactId>dagger</artifactId>
@@ -110,8 +106,8 @@
             <goals><goal>compile</goal></goals>
             <configuration>
               <annotationProcessors>
-                <annotationProcessor>com.google.auto.service.processor.AutoServiceProcessor</annotationProcessor>
                 <annotationProcessor>com.google.auto.value.processor.AutoValueProcessor</annotationProcessor>
+                <annotationProcessor>com.google.auto.service.processor.AutoServiceProcessor</annotationProcessor>
               </annotationProcessors>
             </configuration>
           </execution>
@@ -120,16 +116,12 @@
             <goals><goal>testCompile</goal></goals>
             <configuration>
               <annotationProcessors>
-                <annotationProcessor>dagger.internal.codegen.dagger1.ValidationProcessor</annotationProcessor>
-                <annotationProcessor>dagger.internal.codegen.dagger1.InjectAdapterProcessor</annotationProcessor>
-                <annotationProcessor>dagger.internal.codegen.dagger1.ModuleAdapterProcessor</annotationProcessor>
-                <annotationProcessor>dagger.internal.codegen.dagger1.GraphAnalysisProcessor</annotationProcessor>
+                <annotationProcessor>dagger.internal.codegen.ComponentProcessor</annotationProcessor>
               </annotationProcessors>
             </configuration>
           </execution>
         </executions>
       </plugin>
-
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-assembly-plugin</artifactId>
diff --git a/compiler/src/it/abstract-parent-with-injected-members/pom.xml b/compiler/src/it/abstract-parent-with-injected-members/pom.xml
deleted file mode 100644
index b1638a3c4..000000000
--- a/compiler/src/it/abstract-parent-with-injected-members/pom.xml
+++ /dev/null
@@ -1,51 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--
- Copyright (C) 2013 Google, Inc.
-
-  Licensed under the Apache License, Version 2.0 (the "License");
-  you may not use this file except in compliance with the License.
-  You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-  Unless required by applicable law or agreed to in writing, software
-  distributed under the License is distributed on an "AS IS" BASIS,
-  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-  See the License for the specific language governing permissions and
-  limitations under the License.
--->
-<project
-    xmlns="http://maven.apache.org/POM/4.0.0"
-    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-  <groupId>com.example.dagger.tests</groupId>
-  <artifactId>abstract-parent-with-injected-members</artifactId>
-  <version>HEAD-SNAPSHOT</version>
-  <name>Dagger Integration Test Basic</name>
-  <dependencies>
-    <dependency>
-      <groupId>@dagger.groupId@</groupId>
-      <artifactId>dagger</artifactId>
-      <version>@dagger.version@</version>
-    </dependency>
-    <dependency>
-      <groupId>@dagger.groupId@</groupId>
-      <artifactId>dagger-compiler</artifactId>
-      <version>@dagger.version@</version>
-      <optional>true</optional>
-    </dependency>
-  </dependencies>
-  <build>
-    <plugins>
-      <plugin>
-        <artifactId>maven-compiler-plugin</artifactId>
-        <version>3.1</version>
-        <configuration>
-          <source>1.5</source>
-          <target>1.5</target>
-        </configuration>
-      </plugin>
-    </plugins>
-  </build>
-</project>
diff --git a/compiler/src/it/abstract-parent-with-injected-members/src/main/java/test/TestApp.java b/compiler/src/it/abstract-parent-with-injected-members/src/main/java/test/TestApp.java
deleted file mode 100644
index 6b3cf5c7e..000000000
--- a/compiler/src/it/abstract-parent-with-injected-members/src/main/java/test/TestApp.java
+++ /dev/null
@@ -1,39 +0,0 @@
-/*
- * Copyright (C) 2013 Google, Inc.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package test;
-
-import dagger.Module;
-import dagger.Provides;
-import javax.inject.Inject;
-import test.parentpackage.AbstractParentWithInjectedMember;
-
-class TestApp {
-   
-  static class InjectableSubclass extends AbstractParentWithInjectedMember {
-     @Inject String string;
-  }
-
-  @Module(injects = InjectableSubclass.class)
-  static class TestModule {
-    @Provides String provideString() {
-      return "string";
-    }
-    
-    @Provides Integer provideInteger() {
-      return 5;
-    }
-  }
-}
diff --git a/compiler/src/it/abstract-parent-with-injected-members/src/main/java/test/parentpackage/AbstractParentWithInjectedMember.java b/compiler/src/it/abstract-parent-with-injected-members/src/main/java/test/parentpackage/AbstractParentWithInjectedMember.java
deleted file mode 100644
index 321030c4b..000000000
--- a/compiler/src/it/abstract-parent-with-injected-members/src/main/java/test/parentpackage/AbstractParentWithInjectedMember.java
+++ /dev/null
@@ -1,22 +0,0 @@
-/*
- * Copyright (C) 2013 Google, Inc.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package test.parentpackage;
-
-import javax.inject.Inject;
-
-public abstract class AbstractParentWithInjectedMember {
-  @Inject Integer integer;
-}
diff --git a/compiler/src/it/abstract-parent-with-injected-members/verify.bsh b/compiler/src/it/abstract-parent-with-injected-members/verify.bsh
deleted file mode 100644
index 18d727d84..000000000
--- a/compiler/src/it/abstract-parent-with-injected-members/verify.bsh
+++ /dev/null
@@ -1,23 +0,0 @@
-import java.io.File;
-
-File classes = new File(basedir, "target/classes/test/");
-
-File moduleAdapter = new File(classes, "TestApp$TestModule$$ModuleAdapter.class");
-if (!moduleAdapter.exists()) throw new Exception("No binding generated for module");
-
-File integerBinding = 
-    new File(classes, "TestApp$TestModule$$ModuleAdapter$ProvideIntegerProvidesAdapter.class");
-if (!integerBinding.exists()) throw new Exception("No binding generated for integer()");
-
-File stringBinding =
-    new File(classes, "TestApp$TestModule$$ModuleAdapter$ProvideStringProvidesAdapter.class");
-if (!stringBinding.exists()) throw new Exception("No binding generated for string()");
-
-File injectAdapter = new File(classes, "TestApp$InjectableSubclass$$InjectAdapter.class");
-if (!injectAdapter.exists()) 
-  throw new Exception("No inject adapter generated for InjectableSubclass");
-
-File parentAdapter = 
-    new File(classes, "parentpackage/AbstractParentWithInjectedMember$$ParentAdapter$$test_TestApp$InjectableSubclass.class");
-if (!parentAdapter.exists()) 
-  throw new Exception("No parent adapter generated for AbstractParentWithInjectedMember");
diff --git a/compiler/src/it/default-package-injected-type/pom.xml b/compiler/src/it/default-package-injected-type/pom.xml
deleted file mode 100644
index eaab5f1c9..000000000
--- a/compiler/src/it/default-package-injected-type/pom.xml
+++ /dev/null
@@ -1,52 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--
- Copyright (C) 2012 Square, Inc.
- Copyright (C) 2012 Google, Inc.
-
-  Licensed under the Apache License, Version 2.0 (the "License");
-  you may not use this file except in compliance with the License.
-  You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-  Unless required by applicable law or agreed to in writing, software
-  distributed under the License is distributed on an "AS IS" BASIS,
-  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-  See the License for the specific language governing permissions and
-  limitations under the License.
--->
-<project
-    xmlns="http://maven.apache.org/POM/4.0.0"
-    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-  <groupId>com.example.dagger.tests</groupId>
-  <artifactId>default-package-injected-type</artifactId>
-  <version>HEAD-SNAPSHOT</version>
-  <name>Default Package Injected Type</name>
-  <dependencies>
-    <dependency>
-      <groupId>@dagger.groupId@</groupId>
-      <artifactId>dagger</artifactId>
-      <version>@dagger.version@</version>
-    </dependency>
-    <dependency>
-      <groupId>@dagger.groupId@</groupId>
-      <artifactId>dagger-compiler</artifactId>
-      <version>@dagger.version@</version>
-      <optional>true</optional>
-    </dependency>
-  </dependencies>
-  <build>
-    <plugins>
-      <plugin>
-        <artifactId>maven-compiler-plugin</artifactId>
-        <version>3.1</version>
-        <configuration>
-          <source>1.5</source>
-          <target>1.5</target>
-        </configuration>
-      </plugin>
-    </plugins>
-  </build>
-</project>
diff --git a/compiler/src/it/default-package-injected-type/src/main/java/TestApp.java b/compiler/src/it/default-package-injected-type/src/main/java/TestApp.java
deleted file mode 100644
index ec414b45b..000000000
--- a/compiler/src/it/default-package-injected-type/src/main/java/TestApp.java
+++ /dev/null
@@ -1,42 +0,0 @@
-/*
- * Copyright (C) 2012 Google, Inc.
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import dagger.ObjectGraph;
-import dagger.Module;
-import javax.inject.Inject;
-import javax.inject.Singleton;
-
-class TestApp implements Runnable {
-  @Inject A a;
-
-  @Override public void run() {
-    a.doit();
-  }
-
-  public static void main(String[] args) {
-    ObjectGraph.create(new TestModule()).get(TestApp.class).run();
-  }
-  
-  @Module(injects = { TestApp.class })
-  static class TestModule {}
-
-  @Singleton
-  static class A {
-    @Inject A() {}
-    public void doit() {};
-  }
-}
diff --git a/compiler/src/it/extension-graph-setvalues/pom.xml b/compiler/src/it/extension-graph-setvalues/pom.xml
deleted file mode 100644
index 3d308ca11..000000000
--- a/compiler/src/it/extension-graph-setvalues/pom.xml
+++ /dev/null
@@ -1,52 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--
- Copyright (C) 2013 Square, Inc.
- Copyright (C) 2013 Google, Inc.
-
-  Licensed under the Apache License, Version 2.0 (the "License");
-  you may not use this file except in compliance with the License.
-  You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-  Unless required by applicable law or agreed to in writing, software
-  distributed under the License is distributed on an "AS IS" BASIS,
-  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-  See the License for the specific language governing permissions and
-  limitations under the License.
--->
-<project
-    xmlns="http://maven.apache.org/POM/4.0.0"
-    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-  <groupId>com.example.dagger.tests</groupId>
-  <artifactId>extension-graph-setvalues</artifactId>
-  <version>HEAD-SNAPSHOT</version>
-  <name>Dagger Integration Test Basic</name>
-  <dependencies>
-    <dependency>
-      <groupId>@dagger.groupId@</groupId>
-      <artifactId>dagger</artifactId>
-      <version>@dagger.version@</version>
-    </dependency>
-    <dependency>
-      <groupId>@dagger.groupId@</groupId>
-      <artifactId>dagger-compiler</artifactId>
-      <version>@dagger.version@</version>
-      <optional>true</optional>
-    </dependency>
-  </dependencies>
-  <build>
-    <plugins>
-      <plugin>
-        <artifactId>maven-compiler-plugin</artifactId>
-        <version>3.1</version>
-        <configuration>
-          <source>1.5</source>
-          <target>1.5</target>
-        </configuration>
-      </plugin>
-    </plugins>
-  </build>
-</project>
diff --git a/compiler/src/it/extension-graph-setvalues/src/main/java/test/TestApp.java b/compiler/src/it/extension-graph-setvalues/src/main/java/test/TestApp.java
deleted file mode 100644
index 9ad18af99..000000000
--- a/compiler/src/it/extension-graph-setvalues/src/main/java/test/TestApp.java
+++ /dev/null
@@ -1,64 +0,0 @@
-/*
- * Copyright (C) 2013 Google, Inc.
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package test;
-
-import dagger.ObjectGraph;
-import dagger.Module;
-import dagger.Provides;
-import java.util.HashSet;
-import java.util.Set;
-import javax.inject.Inject;
-import javax.inject.Provider;
-import javax.inject.Singleton;
-
-import static dagger.Provides.Type.SET;
-import static dagger.Provides.Type.SET_VALUES;
-
-/**
- * Contributions to {@code SET_VALUES} binding do not affect Set of providers.
- */
-class TestApp implements Runnable {
-  @Inject Set<Provider<String>> providers;
-  @Inject Set<String> strings;
-
-  @Override public void run() {
-    System.out.println(strings);
-  }
-
-  public static void main(String[] args) {
-    ObjectGraph root = ObjectGraph.create(new RootModule());
-    ObjectGraph extension = root.plus(new ExtensionModule());
-    extension.get(TestApp.class).run();
-  }
-  
-  @Module(injects = TestApp.class)
-  static class RootModule {
-    @Provides Set<Provider<String>> providers() {
-      return new HashSet<Provider<String>>();
-    }
-    @Provides(type = SET_VALUES) Set<String> strings() {
-      return new HashSet<String>();
-    }
-  }
-
-  @Module(addsTo = RootModule.class, injects = TestApp.class)
-  static class ExtensionModule {
-    @Provides(type = SET) String addToSet() {
-      return "contributed";
-    }
-  }
-}
diff --git a/compiler/src/it/extension-graph/pom.xml b/compiler/src/it/extension-graph/pom.xml
deleted file mode 100644
index 3c0190b03..000000000
--- a/compiler/src/it/extension-graph/pom.xml
+++ /dev/null
@@ -1,52 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--
- Copyright (C) 2012 Square, Inc.
- Copyright (C) 2012 Google, Inc.
-
-  Licensed under the Apache License, Version 2.0 (the "License");
-  you may not use this file except in compliance with the License.
-  You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-  Unless required by applicable law or agreed to in writing, software
-  distributed under the License is distributed on an "AS IS" BASIS,
-  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-  See the License for the specific language governing permissions and
-  limitations under the License.
--->
-<project
-    xmlns="http://maven.apache.org/POM/4.0.0"
-    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-  <groupId>com.example.dagger.tests</groupId>
-  <artifactId>extension-graph</artifactId>
-  <version>HEAD-SNAPSHOT</version>
-  <name>Dagger Integration Test Basic</name>
-  <dependencies>
-    <dependency>
-      <groupId>@dagger.groupId@</groupId>
-      <artifactId>dagger</artifactId>
-      <version>@dagger.version@</version>
-    </dependency>
-    <dependency>
-      <groupId>@dagger.groupId@</groupId>
-      <artifactId>dagger-compiler</artifactId>
-      <version>@dagger.version@</version>
-      <optional>true</optional>
-    </dependency>
-  </dependencies>
-  <build>
-    <plugins>
-      <plugin>
-        <artifactId>maven-compiler-plugin</artifactId>
-        <version>3.1</version>
-        <configuration>
-          <source>1.5</source>
-          <target>1.5</target>
-        </configuration>
-      </plugin>
-    </plugins>
-  </build>
-</project>
diff --git a/compiler/src/it/extension-graph/src/main/java/test/TestApp.java b/compiler/src/it/extension-graph/src/main/java/test/TestApp.java
deleted file mode 100644
index 5850d6ce4..000000000
--- a/compiler/src/it/extension-graph/src/main/java/test/TestApp.java
+++ /dev/null
@@ -1,59 +0,0 @@
-/*
- * Copyright (C) 2012 Google, Inc.
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package test;
-
-import dagger.ObjectGraph;
-import dagger.Module;
-import javax.inject.Inject;
-import javax.inject.Singleton;
-
-class TestApp implements Runnable {
-  @Inject C c;
-
-  @Override public void run() {
-    c.doit();
-  }
-
-  public static void main(String[] args) {
-    ObjectGraph root = ObjectGraph.create(new RootModule());
-    ObjectGraph extension = root.plus(new ExtensionModule());
-    extension.get(TestApp.class).run();
-  }
-  
-  @Module(injects = { A.class, B.class })
-  static class RootModule { }
-
-  @Module(addsTo=RootModule.class, injects = { C.class, TestApp.class })
-  static class ExtensionModule { }
-
-  @Singleton
-  static class A {
-    @Inject A() {}
-  }
-
-  static class B {
-    @Inject A a;
-    @Inject B() {}
-  }
-
-  static class C {
-    @Inject A a;
-    @Inject B b;
-    @Inject C() {}
-    public void doit() {};
-  }
-}
diff --git a/compiler/src/it/final-field-inject/invoker.properties b/compiler/src/it/final-field-inject/invoker.properties
deleted file mode 100644
index fdd3d204d..000000000
--- a/compiler/src/it/final-field-inject/invoker.properties
+++ /dev/null
@@ -1 +0,0 @@
-invoker.buildResult=failure
diff --git a/compiler/src/it/final-field-inject/pom.xml b/compiler/src/it/final-field-inject/pom.xml
deleted file mode 100644
index 83aa81fb7..000000000
--- a/compiler/src/it/final-field-inject/pom.xml
+++ /dev/null
@@ -1,51 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--
-  Copyright (C) 2013 Google, Inc.
-  Copyright (C) 2013 Square, Inc.
-
-  Licensed under the Apache License, Version 2.0 (the "License");
-  you may not use this file except in compliance with the License.
-  You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-  Unless required by applicable law or agreed to in writing, software
-  distributed under the License is distributed on an "AS IS" BASIS,
-  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-  See the License for the specific language governing permissions and
-  limitations under the License.
--->
-<project
-    xmlns="http://maven.apache.org/POM/4.0.0"
-    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-  <groupId>com.example.dagger.tests</groupId>
-  <artifactId>final-field-inject</artifactId>
-  <version>HEAD-SNAPSHOT</version>
-  <dependencies>
-    <dependency>
-      <groupId>@dagger.groupId@</groupId>
-      <artifactId>dagger</artifactId>
-      <version>@dagger.version@</version>
-    </dependency>
-    <dependency>
-      <groupId>@dagger.groupId@</groupId>
-      <artifactId>dagger-compiler</artifactId>
-      <version>@dagger.version@</version>
-      <optional>true</optional>
-    </dependency>
-  </dependencies>
-  <build>
-    <plugins>
-      <plugin>
-        <artifactId>maven-compiler-plugin</artifactId>
-        <version>3.1</version>
-        <configuration>
-          <source>1.5</source>
-          <target>1.5</target>
-        </configuration>
-      </plugin>
-    </plugins>
-  </build>
-</project>
diff --git a/compiler/src/it/final-field-inject/src/main/java/test/TestApp.java b/compiler/src/it/final-field-inject/src/main/java/test/TestApp.java
deleted file mode 100644
index fd955fc65..000000000
--- a/compiler/src/it/final-field-inject/src/main/java/test/TestApp.java
+++ /dev/null
@@ -1,23 +0,0 @@
-/*
- * Copyright (C) 2013 Google, Inc.
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package test;
-
-import javax.inject.Inject;
-
-class TestApp {
-  @Inject final Object nope;
-}
diff --git a/compiler/src/it/final-field-inject/verify.bsh b/compiler/src/it/final-field-inject/verify.bsh
deleted file mode 100644
index 1c30652d4..000000000
--- a/compiler/src/it/final-field-inject/verify.bsh
+++ /dev/null
@@ -1,6 +0,0 @@
-import dagger.testing.it.BuildLogValidator;
-import java.io.File;
-
-File buildLog = new File(basedir, "build.log");
-new BuildLogValidator().assertHasText(buildLog, new String[]{
-    "Can't inject a final field: test.TestApp.nope"});
diff --git a/compiler/src/it/grandparent-with-injected-members/pom.xml b/compiler/src/it/grandparent-with-injected-members/pom.xml
deleted file mode 100644
index aab4460c8..000000000
--- a/compiler/src/it/grandparent-with-injected-members/pom.xml
+++ /dev/null
@@ -1,51 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--
- Copyright (C) 2013 Google, Inc.
-
-  Licensed under the Apache License, Version 2.0 (the "License");
-  you may not use this file except in compliance with the License.
-  You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-  Unless required by applicable law or agreed to in writing, software
-  distributed under the License is distributed on an "AS IS" BASIS,
-  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-  See the License for the specific language governing permissions and
-  limitations under the License.
--->
-<project
-    xmlns="http://maven.apache.org/POM/4.0.0"
-    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-  <groupId>com.example.dagger.tests</groupId>
-  <artifactId>grandparent-with-injected-members</artifactId>
-  <version>HEAD-SNAPSHOT</version>
-  <name>Dagger Integration Test Basic</name>
-  <dependencies>
-    <dependency>
-      <groupId>@dagger.groupId@</groupId>
-      <artifactId>dagger</artifactId>
-      <version>@dagger.version@</version>
-    </dependency>
-    <dependency>
-      <groupId>@dagger.groupId@</groupId>
-      <artifactId>dagger-compiler</artifactId>
-      <version>@dagger.version@</version>
-      <optional>true</optional>
-    </dependency>
-  </dependencies>
-  <build>
-    <plugins>
-      <plugin>
-        <artifactId>maven-compiler-plugin</artifactId>
-        <version>3.1</version>
-        <configuration>
-          <source>1.5</source>
-          <target>1.5</target>
-        </configuration>
-      </plugin>
-    </plugins>
-  </build>
-</project>
diff --git a/compiler/src/it/grandparent-with-injected-members/src/main/java/test/TestApp.java b/compiler/src/it/grandparent-with-injected-members/src/main/java/test/TestApp.java
deleted file mode 100644
index c33a37d28..000000000
--- a/compiler/src/it/grandparent-with-injected-members/src/main/java/test/TestApp.java
+++ /dev/null
@@ -1,39 +0,0 @@
-/*
- * Copyright (C) 2013 Google, Inc.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package test;
-
-import dagger.Module;
-import dagger.Provides;
-import javax.inject.Inject;
-import test.parentpackage.ParentWithNoInjectedMembers;
-
-class TestApp {
-   
-  static class InjectableSubclass extends ParentWithNoInjectedMembers {
-     @Inject String string;
-  }
-
-  @Module(injects = InjectableSubclass.class)
-  static class TestModule {
-    @Provides String provideString() {
-      return "string";
-    }
-    
-    @Provides Integer provideInteger() {
-      return 5;
-    }
-  }
-}
diff --git a/compiler/src/it/grandparent-with-injected-members/src/main/java/test/grandparentpackage/GrandparentWithInjectedMember.java b/compiler/src/it/grandparent-with-injected-members/src/main/java/test/grandparentpackage/GrandparentWithInjectedMember.java
deleted file mode 100644
index bde757000..000000000
--- a/compiler/src/it/grandparent-with-injected-members/src/main/java/test/grandparentpackage/GrandparentWithInjectedMember.java
+++ /dev/null
@@ -1,22 +0,0 @@
-/*
- * Copyright (C) 2013 Google, Inc.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package test.grandparentpackage;
-
-import javax.inject.Inject;
-
-public class GrandparentWithInjectedMember {
-  @Inject Integer integer;
-}
diff --git a/compiler/src/it/grandparent-with-injected-members/src/main/java/test/parentpackage/ParentWithNoInjectedMembers.java b/compiler/src/it/grandparent-with-injected-members/src/main/java/test/parentpackage/ParentWithNoInjectedMembers.java
deleted file mode 100644
index 6dfd89fc2..000000000
--- a/compiler/src/it/grandparent-with-injected-members/src/main/java/test/parentpackage/ParentWithNoInjectedMembers.java
+++ /dev/null
@@ -1,21 +0,0 @@
-/*
- * Copyright (C) 2013 Google, Inc.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package test.parentpackage;
-
-import test.grandparentpackage.GrandparentWithInjectedMember;
-
-public class ParentWithNoInjectedMembers extends GrandparentWithInjectedMember {
-}
diff --git a/compiler/src/it/grandparent-with-injected-members/verify.bsh b/compiler/src/it/grandparent-with-injected-members/verify.bsh
deleted file mode 100644
index 2b018d41e..000000000
--- a/compiler/src/it/grandparent-with-injected-members/verify.bsh
+++ /dev/null
@@ -1,28 +0,0 @@
-import java.io.File;
-
-File classes = new File(basedir, "target/classes/test/");
-
-File moduleAdapter = new File(classes, "TestApp$TestModule$$ModuleAdapter.class");
-if (!moduleAdapter.exists()) throw new Exception("No binding generated for module");
-
-File integerBinding = 
-    new File(classes, "TestApp$TestModule$$ModuleAdapter$ProvideIntegerProvidesAdapter.class");
-if (!integerBinding.exists()) throw new Exception("No binding generated for integer()");
-
-File stringBinding =
-    new File(classes, "TestApp$TestModule$$ModuleAdapter$ProvideStringProvidesAdapter.class");
-if (!stringBinding.exists()) throw new Exception("No binding generated for string()");
-
-File injectAdapter = new File(classes, "TestApp$InjectableSubclass$$InjectAdapter.class");
-if (!injectAdapter.exists()) 
-  throw new Exception("No inject adapter generated for InjectableSubclass");
-
-File parentAdapter = 
-    new File(classes, "parentpackage/ParentWithNoInjectedMembers$$ParentAdapter$$test_TestApp$InjectableSubclass.class");
-if (parentAdapter.exists()) 
-  throw new Exception("An unnecessary parent adapter was generated for ParentwithNoInjectedMembers.");
-    
-File grandparentAdapter = 
-    new File(classes, "grandparentpackage/GrandparentWithInjectedMember$$ParentAdapter$$test_TestApp$InjectableSubclass.class");
-if (!grandparentAdapter.exists()) 
-  throw new Exception("No parent adapter was generated for GrandparentwithInjectedMember.");
diff --git a/compiler/src/it/include-non-module/invoker.properties b/compiler/src/it/include-non-module/invoker.properties
deleted file mode 100644
index 324b5fb99..000000000
--- a/compiler/src/it/include-non-module/invoker.properties
+++ /dev/null
@@ -1 +0,0 @@
-invoker.buildResult=failure
\ No newline at end of file
diff --git a/compiler/src/it/include-non-module/pom.xml b/compiler/src/it/include-non-module/pom.xml
deleted file mode 100644
index 871f53851..000000000
--- a/compiler/src/it/include-non-module/pom.xml
+++ /dev/null
@@ -1,52 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--
- Copyright (C) 2013 Square, Inc.
- Copyright (C) 2013 Google, Inc.
-
-  Licensed under the Apache License, Version 2.0 (the "License");
-  you may not use this file except in compliance with the License.
-  You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-  Unless required by applicable law or agreed to in writing, software
-  distributed under the License is distributed on an "AS IS" BASIS,
-  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-  See the License for the specific language governing permissions and
-  limitations under the License.
--->
-<project
-    xmlns="http://maven.apache.org/POM/4.0.0"
-    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-  <groupId>com.example.dagger.tests</groupId>
-  <artifactId>include-non-module</artifactId>
-  <version>HEAD-SNAPSHOT</version>
-  <name>Dagger Integration Test Basic</name>
-  <dependencies>
-    <dependency>
-      <groupId>@dagger.groupId@</groupId>
-      <artifactId>dagger</artifactId>
-      <version>@dagger.version@</version>
-    </dependency>
-    <dependency>
-      <groupId>@dagger.groupId@</groupId>
-      <artifactId>dagger-compiler</artifactId>
-      <version>@dagger.version@</version>
-      <optional>true</optional>
-    </dependency>
-  </dependencies>
-  <build>
-    <plugins>
-      <plugin>
-        <artifactId>maven-compiler-plugin</artifactId>
-        <version>3.1</version>
-        <configuration>
-          <source>1.5</source>
-          <target>1.5</target>
-        </configuration>
-      </plugin>
-    </plugins>
-  </build>
-</project>
diff --git a/compiler/src/it/include-non-module/src/main/java/test/TestApp.java b/compiler/src/it/include-non-module/src/main/java/test/TestApp.java
deleted file mode 100644
index f658f4289..000000000
--- a/compiler/src/it/include-non-module/src/main/java/test/TestApp.java
+++ /dev/null
@@ -1,39 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package test;
-
-import dagger.Module;
-import dagger.ObjectGraph;
-import dagger.Provides;
-import javax.inject.Inject;
-import java.lang.String;
-
-class TestApp {
-  public static void main(String[] args) {
-    TestApp app = ObjectGraph.create(new TestModule()).get(TestApp.class);
-  }
-
-  @Inject String s;
-
-  @Module(
-      injects = TestApp.class,
-      includes = TestApp.class)
-  static class TestModule {
-    @Provides String provideString() {
-      return "a";
-    }
-  }
-}
diff --git a/compiler/src/it/inject-on-class/invoker.properties b/compiler/src/it/inject-on-class/invoker.properties
deleted file mode 100644
index 324b5fb99..000000000
--- a/compiler/src/it/inject-on-class/invoker.properties
+++ /dev/null
@@ -1 +0,0 @@
-invoker.buildResult=failure
\ No newline at end of file
diff --git a/compiler/src/it/inject-on-class/pom.xml b/compiler/src/it/inject-on-class/pom.xml
deleted file mode 100644
index e0f80c4bc..000000000
--- a/compiler/src/it/inject-on-class/pom.xml
+++ /dev/null
@@ -1,50 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--
-  Copyright (C) 2013 Square, Inc.
-
-  Licensed under the Apache License, Version 2.0 (the "License");
-  you may not use this file except in compliance with the License.
-  You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-  Unless required by applicable law or agreed to in writing, software
-  distributed under the License is distributed on an "AS IS" BASIS,
-  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-  See the License for the specific language governing permissions and
-  limitations under the License.
--->
-<project
-    xmlns="http://maven.apache.org/POM/4.0.0"
-    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-  <groupId>com.example.dagger.tests</groupId>
-  <artifactId>method-injection</artifactId>
-  <version>HEAD-SNAPSHOT</version>
-  <dependencies>
-    <dependency>
-      <groupId>@dagger.groupId@</groupId>
-      <artifactId>dagger</artifactId>
-      <version>@dagger.version@</version>
-    </dependency>
-    <dependency>
-      <groupId>@dagger.groupId@</groupId>
-      <artifactId>dagger-compiler</artifactId>
-      <version>@dagger.version@</version>
-      <optional>true</optional>
-    </dependency>
-  </dependencies>
-  <build>
-    <plugins>
-      <plugin>
-        <artifactId>maven-compiler-plugin</artifactId>
-        <version>3.1</version>
-        <configuration>
-          <source>1.5</source>
-          <target>1.5</target>
-        </configuration>
-      </plugin>
-    </plugins>
-  </build>
-</project>
diff --git a/compiler/src/it/inject-on-class/src/main/java/test/TestApp.java b/compiler/src/it/inject-on-class/src/main/java/test/TestApp.java
deleted file mode 100644
index 75df33189..000000000
--- a/compiler/src/it/inject-on-class/src/main/java/test/TestApp.java
+++ /dev/null
@@ -1,22 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package test;
-
-import javax.inject.Inject;
-
-@Inject
-class TestApp {
-}
diff --git a/compiler/src/it/inject-on-class/verify.bsh b/compiler/src/it/inject-on-class/verify.bsh
deleted file mode 100644
index 03031dd45..000000000
--- a/compiler/src/it/inject-on-class/verify.bsh
+++ /dev/null
@@ -1,6 +0,0 @@
-import dagger.testing.it.BuildLogValidator;
-import java.io.File;
-
-File buildLog = new File(basedir, "build.log");
-new BuildLogValidator().assertHasText(buildLog, new String[]{
-    "@Inject is not valid on a class: test.TestApp"});
diff --git a/compiler/src/it/inject-parameterized-type/pom.xml b/compiler/src/it/inject-parameterized-type/pom.xml
deleted file mode 100644
index 0437e26f3..000000000
--- a/compiler/src/it/inject-parameterized-type/pom.xml
+++ /dev/null
@@ -1,52 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--
- Copyright (C) 2013 Square, Inc.
- Copyright (C) 2013 Google, Inc.
-
-  Licensed under the Apache License, Version 2.0 (the "License");
-  you may not use this file except in compliance with the License.
-  You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-  Unless required by applicable law or agreed to in writing, software
-  distributed under the License is distributed on an "AS IS" BASIS,
-  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-  See the License for the specific language governing permissions and
-  limitations under the License.
--->
-<project
-    xmlns="http://maven.apache.org/POM/4.0.0"
-    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-  <groupId>com.example.dagger.tests</groupId>
-  <artifactId>inject-parameterized-type</artifactId>
-  <version>HEAD-SNAPSHOT</version>
-  <name>Dagger Integration Test Basic</name>
-  <dependencies>
-    <dependency>
-      <groupId>@dagger.groupId@</groupId>
-      <artifactId>dagger</artifactId>
-      <version>@dagger.version@</version>
-    </dependency>
-    <dependency>
-      <groupId>@dagger.groupId@</groupId>
-      <artifactId>dagger-compiler</artifactId>
-      <version>@dagger.version@</version>
-      <optional>true</optional>
-    </dependency>
-  </dependencies>
-  <build>
-    <plugins>
-      <plugin>
-        <artifactId>maven-compiler-plugin</artifactId>
-        <version>3.1</version>
-        <configuration>
-          <source>1.5</source>
-          <target>1.5</target>
-        </configuration>
-      </plugin>
-    </plugins>
-  </build>
-</project>
diff --git a/compiler/src/it/inner-classes-complaint-injection/invoker.properties b/compiler/src/it/inner-classes-complaint-injection/invoker.properties
deleted file mode 100644
index 324b5fb99..000000000
--- a/compiler/src/it/inner-classes-complaint-injection/invoker.properties
+++ /dev/null
@@ -1 +0,0 @@
-invoker.buildResult=failure
\ No newline at end of file
diff --git a/compiler/src/it/inner-classes-complaint-injection/pom.xml b/compiler/src/it/inner-classes-complaint-injection/pom.xml
deleted file mode 100644
index d8ceecb8a..000000000
--- a/compiler/src/it/inner-classes-complaint-injection/pom.xml
+++ /dev/null
@@ -1,51 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--
-  Copyright (C) 2013 Square, Inc.
-
-  Licensed under the Apache License, Version 2.0 (the "License");
-  you may not use this file except in compliance with the License.
-  You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-  Unless required by applicable law or agreed to in writing, software
-  distributed under the License is distributed on an "AS IS" BASIS,
-  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-  See the License for the specific language governing permissions and
-  limitations under the License.
--->
-<project
-    xmlns="http://maven.apache.org/POM/4.0.0"
-    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-  <groupId>com.example.dagger.tests</groupId>
-  <artifactId>inner-classes-complaint-injection</artifactId>
-  <version>HEAD-SNAPSHOT</version>
-  <name>Dagger Integration Test Basic</name>
-  <dependencies>
-    <dependency>
-      <groupId>@dagger.groupId@</groupId>
-      <artifactId>dagger</artifactId>
-      <version>@dagger.version@</version>
-    </dependency>
-    <dependency>
-      <groupId>@dagger.groupId@</groupId>
-      <artifactId>dagger-compiler</artifactId>
-      <version>@dagger.version@</version>
-      <optional>true</optional>
-    </dependency>
-  </dependencies>
-  <build>
-    <plugins>
-      <plugin>
-        <artifactId>maven-compiler-plugin</artifactId>
-        <version>3.1</version>
-        <configuration>
-          <source>1.5</source>
-          <target>1.5</target>
-        </configuration>
-      </plugin>
-    </plugins>
-  </build>
-</project>
diff --git a/compiler/src/it/inner-classes-complaint-injection/src/main/java/test/TestApp.java b/compiler/src/it/inner-classes-complaint-injection/src/main/java/test/TestApp.java
deleted file mode 100644
index ab3ce3c14..000000000
--- a/compiler/src/it/inner-classes-complaint-injection/src/main/java/test/TestApp.java
+++ /dev/null
@@ -1,31 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package test;
-
-import dagger.Module;
-
-import dagger.ObjectGraph;
-import dagger.Provides;
-
-import javax.inject.Inject;
-import java.lang.Override;
-
-class TestApp {
-
-  class Foo {
-    @Inject public Foo() {}
-  }
-}
diff --git a/compiler/src/it/inner-classes-complaint-injection/verify.bsh b/compiler/src/it/inner-classes-complaint-injection/verify.bsh
deleted file mode 100644
index 0b02b8022..000000000
--- a/compiler/src/it/inner-classes-complaint-injection/verify.bsh
+++ /dev/null
@@ -1,6 +0,0 @@
-import dagger.testing.it.BuildLogValidator;
-import java.io.File;
-
-File buildLog = new File(basedir, "build.log");
-new BuildLogValidator().assertHasText(buildLog, new String[]{
-    "Can't inject a non-static inner class: test.TestApp.Foo"});
diff --git a/compiler/src/it/method-injection/invoker.properties b/compiler/src/it/method-injection/invoker.properties
deleted file mode 100644
index 324b5fb99..000000000
--- a/compiler/src/it/method-injection/invoker.properties
+++ /dev/null
@@ -1 +0,0 @@
-invoker.buildResult=failure
\ No newline at end of file
diff --git a/compiler/src/it/method-injection/pom.xml b/compiler/src/it/method-injection/pom.xml
deleted file mode 100644
index e0f80c4bc..000000000
--- a/compiler/src/it/method-injection/pom.xml
+++ /dev/null
@@ -1,50 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--
-  Copyright (C) 2013 Square, Inc.
-
-  Licensed under the Apache License, Version 2.0 (the "License");
-  you may not use this file except in compliance with the License.
-  You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-  Unless required by applicable law or agreed to in writing, software
-  distributed under the License is distributed on an "AS IS" BASIS,
-  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-  See the License for the specific language governing permissions and
-  limitations under the License.
--->
-<project
-    xmlns="http://maven.apache.org/POM/4.0.0"
-    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-  <groupId>com.example.dagger.tests</groupId>
-  <artifactId>method-injection</artifactId>
-  <version>HEAD-SNAPSHOT</version>
-  <dependencies>
-    <dependency>
-      <groupId>@dagger.groupId@</groupId>
-      <artifactId>dagger</artifactId>
-      <version>@dagger.version@</version>
-    </dependency>
-    <dependency>
-      <groupId>@dagger.groupId@</groupId>
-      <artifactId>dagger-compiler</artifactId>
-      <version>@dagger.version@</version>
-      <optional>true</optional>
-    </dependency>
-  </dependencies>
-  <build>
-    <plugins>
-      <plugin>
-        <artifactId>maven-compiler-plugin</artifactId>
-        <version>3.1</version>
-        <configuration>
-          <source>1.5</source>
-          <target>1.5</target>
-        </configuration>
-      </plugin>
-    </plugins>
-  </build>
-</project>
diff --git a/compiler/src/it/method-injection/src/main/java/test/TestApp.java b/compiler/src/it/method-injection/src/main/java/test/TestApp.java
deleted file mode 100644
index 4103a20dc..000000000
--- a/compiler/src/it/method-injection/src/main/java/test/TestApp.java
+++ /dev/null
@@ -1,23 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package test;
-
-import javax.inject.Inject;
-
-class TestApp {
-  @Inject public void doThings(Object things) {
-  }
-}
diff --git a/compiler/src/it/method-injection/verify.bsh b/compiler/src/it/method-injection/verify.bsh
deleted file mode 100644
index 002cfbfdf..000000000
--- a/compiler/src/it/method-injection/verify.bsh
+++ /dev/null
@@ -1,6 +0,0 @@
-import dagger.testing.it.BuildLogValidator;
-import java.io.File;
-
-File buildLog = new File(basedir, "build.log");
-new BuildLogValidator().assertHasText(buildLog, new String[]{
-    "Method injection is not supported: test.TestApp.doThings"});
diff --git a/compiler/src/it/missing-at-inject-constructor/invoker.properties b/compiler/src/it/missing-at-inject-constructor/invoker.properties
deleted file mode 100644
index 324b5fb99..000000000
--- a/compiler/src/it/missing-at-inject-constructor/invoker.properties
+++ /dev/null
@@ -1 +0,0 @@
-invoker.buildResult=failure
\ No newline at end of file
diff --git a/compiler/src/it/missing-at-inject-constructor/pom.xml b/compiler/src/it/missing-at-inject-constructor/pom.xml
deleted file mode 100644
index ea8134772..000000000
--- a/compiler/src/it/missing-at-inject-constructor/pom.xml
+++ /dev/null
@@ -1,52 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--
- Copyright (C) 2012 Square, Inc.
- Copyright (C) 2012 Google, Inc.
-
-  Licensed under the Apache License, Version 2.0 (the "License");
-  you may not use this file except in compliance with the License.
-  You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-  Unless required by applicable law or agreed to in writing, software
-  distributed under the License is distributed on an "AS IS" BASIS,
-  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-  See the License for the specific language governing permissions and
-  limitations under the License.
--->
-<project
-    xmlns="http://maven.apache.org/POM/4.0.0"
-    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-  <groupId>com.example.dagger.tests</groupId>
-  <artifactId>missing-at-inject-constructor</artifactId>
-  <version>HEAD-SNAPSHOT</version>
-  <name>Dagger Integration Test Basic</name>
-  <dependencies>
-    <dependency>
-      <groupId>@dagger.groupId@</groupId>
-      <artifactId>dagger</artifactId>
-      <version>@dagger.version@</version>
-    </dependency>
-    <dependency>
-      <groupId>@dagger.groupId@</groupId>
-      <artifactId>dagger-compiler</artifactId>
-      <version>@dagger.version@</version>
-      <optional>true</optional>
-    </dependency>
-  </dependencies>
-  <build>
-    <plugins>
-      <plugin>
-        <artifactId>maven-compiler-plugin</artifactId>
-        <version>3.1</version>
-        <configuration>
-          <source>1.5</source>
-          <target>1.5</target>
-        </configuration>
-      </plugin>
-    </plugins>
-  </build>
-</project>
diff --git a/compiler/src/it/missing-at-inject-constructor/src/main/java/test/TestApp.java b/compiler/src/it/missing-at-inject-constructor/src/main/java/test/TestApp.java
deleted file mode 100644
index 935218f8f..000000000
--- a/compiler/src/it/missing-at-inject-constructor/src/main/java/test/TestApp.java
+++ /dev/null
@@ -1,44 +0,0 @@
-/*
- * Copyright (C) 2012 Google, Inc.
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package test;
-
-import dagger.Module;
-
-import dagger.ObjectGraph;
-import javax.inject.Inject;
-
-class TestApp implements Runnable {
-  @Inject Dependency dep;
-
-  @Override public void run() {
-    dep.doit();
-  }
-
-  public static void main(String[] args) {
-    ObjectGraph.create(new TestModule()).get(TestApp.class).run();
-  }
-  
-  static class Dependency {
-    // missing @Inject Dependency() {}
-    public void doit() { throw AssertionError(); };
-  }
-  
-  @Module(injects = TestApp.class)
-  static class TestModule {
-    /* missing */ // @Provides Dependency a() { return new Dependency(); }
-  }
-}
diff --git a/compiler/src/it/missing-at-inject-constructor/verify.bsh b/compiler/src/it/missing-at-inject-constructor/verify.bsh
deleted file mode 100644
index f1a4c7601..000000000
--- a/compiler/src/it/missing-at-inject-constructor/verify.bsh
+++ /dev/null
@@ -1,7 +0,0 @@
-import dagger.testing.it.BuildLogValidator;
-import java.io.File;
-
-File buildLog = new File(basedir, "build.log");
-new BuildLogValidator().assertHasText(buildLog, new String[]{
-    "No injectable members on test.TestApp.Dependency.", 
-	"required by test.TestApp for test.TestApp.TestModule"});
diff --git a/compiler/src/it/module-type-validation/invoker.properties b/compiler/src/it/module-type-validation/invoker.properties
deleted file mode 100644
index 324b5fb99..000000000
--- a/compiler/src/it/module-type-validation/invoker.properties
+++ /dev/null
@@ -1 +0,0 @@
-invoker.buildResult=failure
\ No newline at end of file
diff --git a/compiler/src/it/module-type-validation/pom.xml b/compiler/src/it/module-type-validation/pom.xml
deleted file mode 100644
index cc510b24b..000000000
--- a/compiler/src/it/module-type-validation/pom.xml
+++ /dev/null
@@ -1,50 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--
-  Copyright (C) 2013 Square, Inc.
-
-  Licensed under the Apache License, Version 2.0 (the "License");
-  you may not use this file except in compliance with the License.
-  You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-  Unless required by applicable law or agreed to in writing, software
-  distributed under the License is distributed on an "AS IS" BASIS,
-  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-  See the License for the specific language governing permissions and
-  limitations under the License.
--->
-<project
-    xmlns="http://maven.apache.org/POM/4.0.0"
-    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-  <groupId>com.example.dagger.tests</groupId>
-  <artifactId>module-type-validation</artifactId>
-  <version>HEAD-SNAPSHOT</version>
-  <dependencies>
-    <dependency>
-      <groupId>@dagger.groupId@</groupId>
-      <artifactId>dagger</artifactId>
-      <version>@dagger.version@</version>
-    </dependency>
-    <dependency>
-      <groupId>@dagger.groupId@</groupId>
-      <artifactId>dagger-compiler</artifactId>
-      <version>@dagger.version@</version>
-      <optional>true</optional>
-    </dependency>
-  </dependencies>
-  <build>
-    <plugins>
-      <plugin>
-        <artifactId>maven-compiler-plugin</artifactId>
-        <version>3.1</version>
-        <configuration>
-          <source>1.5</source>
-          <target>1.5</target>
-        </configuration>
-      </plugin>
-    </plugins>
-  </build>
-</project>
diff --git a/compiler/src/it/module-type-validation/src/main/java/test/TestModule.java b/compiler/src/it/module-type-validation/src/main/java/test/TestModule.java
deleted file mode 100644
index ed5520839..000000000
--- a/compiler/src/it/module-type-validation/src/main/java/test/TestModule.java
+++ /dev/null
@@ -1,30 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package test;
-
-import dagger.Module;
-
-@Module
-class ThreadModule extends Thread {
-}
-
-@Module
-enum EnumModule {
-}
-
-@Module
-interface InterfaceModule {
-}
diff --git a/compiler/src/it/module-type-validation/verify.bsh b/compiler/src/it/module-type-validation/verify.bsh
deleted file mode 100644
index ce3f6a7e4..000000000
--- a/compiler/src/it/module-type-validation/verify.bsh
+++ /dev/null
@@ -1,10 +0,0 @@
-import dagger.testing.it.BuildLogValidator;
-import java.io.File;
-
-File buildLog = new File(basedir, "build.log");
-new BuildLogValidator().assertHasText(buildLog, new String[]{
-    "Modules must not extend from other classes: test.ThreadModule"});
-new BuildLogValidator().assertHasText(buildLog, new String[]{
-    "Modules must be classes: test.EnumModule"});
-new BuildLogValidator().assertHasText(buildLog, new String[]{
-    "Modules must be classes: test.InterfaceModule"});
\ No newline at end of file
diff --git a/compiler/src/it/multiple-modules-setvalues/pom.xml b/compiler/src/it/multiple-modules-setvalues/pom.xml
deleted file mode 100644
index bb49416c9..000000000
--- a/compiler/src/it/multiple-modules-setvalues/pom.xml
+++ /dev/null
@@ -1,52 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--
- Copyright (C) 2013 Square, Inc.
- Copyright (C) 2013 Google, Inc.
-
-  Licensed under the Apache License, Version 2.0 (the "License");
-  you may not use this file except in compliance with the License.
-  You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-  Unless required by applicable law or agreed to in writing, software
-  distributed under the License is distributed on an "AS IS" BASIS,
-  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-  See the License for the specific language governing permissions and
-  limitations under the License.
--->
-<project
-    xmlns="http://maven.apache.org/POM/4.0.0"
-    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-  <groupId>com.example.dagger.tests</groupId>
-  <artifactId>multiple-modules-setvalues</artifactId>
-  <version>HEAD-SNAPSHOT</version>
-  <name>Dagger Integration Test Basic</name>
-  <dependencies>
-    <dependency>
-      <groupId>@dagger.groupId@</groupId>
-      <artifactId>dagger</artifactId>
-      <version>@dagger.version@</version>
-    </dependency>
-    <dependency>
-      <groupId>@dagger.groupId@</groupId>
-      <artifactId>dagger-compiler</artifactId>
-      <version>@dagger.version@</version>
-      <optional>true</optional>
-    </dependency>
-  </dependencies>
-  <build>
-    <plugins>
-      <plugin>
-        <artifactId>maven-compiler-plugin</artifactId>
-        <version>3.1</version>
-        <configuration>
-          <source>1.5</source>
-          <target>1.5</target>
-        </configuration>
-      </plugin>
-    </plugins>
-  </build>
-</project>
diff --git a/compiler/src/it/multiple-modules-setvalues/src/main/java/test/TestApp.java b/compiler/src/it/multiple-modules-setvalues/src/main/java/test/TestApp.java
deleted file mode 100644
index edeeae08a..000000000
--- a/compiler/src/it/multiple-modules-setvalues/src/main/java/test/TestApp.java
+++ /dev/null
@@ -1,63 +0,0 @@
-/*
- * Copyright (C) 2013 Google, Inc.
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package test;
-
-import dagger.ObjectGraph;
-import dagger.Module;
-import dagger.Provides;
-import java.util.HashSet;
-import java.util.Set;
-import javax.inject.Inject;
-import javax.inject.Provider;
-import javax.inject.Singleton;
-
-import static dagger.Provides.Type.SET;
-import static dagger.Provides.Type.SET_VALUES;
-
-/**
- * Contributions to {@code SET_VALUES} binding do not affect Set of providers.
- */
-class TestApp implements Runnable {
-  @Inject Set<Provider<String>> providers;
-  @Inject Set<String> strings;
-
-  @Override public void run() {
-    System.out.println(strings);
-  }
-
-  public static void main(String[] args) {
-    ObjectGraph root = ObjectGraph.create(new RootModule(), new ContributingModule());
-    root.get(TestApp.class).run();
-  }
-  
-  @Module(injects = TestApp.class)
-  static class RootModule {
-    @Provides Set<Provider<String>> providers() {
-      return new HashSet<Provider<String>>();
-    }
-    @Provides(type = SET_VALUES) Set<String> strings() {
-      return new HashSet<String>();
-    }
-  }
-
-  @Module(injects = TestApp.class, complete = false)
-  static class ContributingModule {
-    @Provides(type = SET) String addToSet() {
-      return "contributed";
-    }
-  }
-}
diff --git a/compiler/src/it/multiple-provides-methods/pom.xml b/compiler/src/it/multiple-provides-methods/pom.xml
deleted file mode 100644
index ea11d6e0d..000000000
--- a/compiler/src/it/multiple-provides-methods/pom.xml
+++ /dev/null
@@ -1,52 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--
- Copyright (C) 2013 Square, Inc.
- Copyright (C) 2013 Google, Inc.
-
-  Licensed under the Apache License, Version 2.0 (the "License");
-  you may not use this file except in compliance with the License.
-  You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-  Unless required by applicable law or agreed to in writing, software
-  distributed under the License is distributed on an "AS IS" BASIS,
-  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-  See the License for the specific language governing permissions and
-  limitations under the License.
--->
-<project
-    xmlns="http://maven.apache.org/POM/4.0.0"
-    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-  <groupId>com.example.dagger.tests</groupId>
-  <artifactId>multiple-provides-methods</artifactId>
-  <version>HEAD-SNAPSHOT</version>
-  <name>Dagger Integration Test Basic</name>
-  <dependencies>
-    <dependency>
-      <groupId>@dagger.groupId@</groupId>
-      <artifactId>dagger</artifactId>
-      <version>@dagger.version@</version>
-    </dependency>
-    <dependency>
-      <groupId>@dagger.groupId@</groupId>
-      <artifactId>dagger-compiler</artifactId>
-      <version>@dagger.version@</version>
-      <optional>true</optional>
-    </dependency>
-  </dependencies>
-  <build>
-    <plugins>
-      <plugin>
-        <artifactId>maven-compiler-plugin</artifactId>
-        <version>3.1</version>
-        <configuration>
-          <source>1.5</source>
-          <target>1.5</target>
-        </configuration>
-      </plugin>
-    </plugins>
-  </build>
-</project>
diff --git a/compiler/src/it/multiple-provides-methods/src/main/java/test/TestApp.java b/compiler/src/it/multiple-provides-methods/src/main/java/test/TestApp.java
deleted file mode 100644
index 31823d107..000000000
--- a/compiler/src/it/multiple-provides-methods/src/main/java/test/TestApp.java
+++ /dev/null
@@ -1,41 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- * Copyright (C) 2013 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package test;
-
-import dagger.Module;
-import dagger.Provides;
-import javax.inject.Inject;
-
-class TestApp {
-  static class NotInjectable {
-  }
-
-  static class InjectableSubclass extends NotInjectable {
-    @Inject String string;
-    @Inject Integer integer;
-  }
-
-  @Module(injects = InjectableSubclass.class)
-  static class TestModule {
-    @Provides String string() {
-      return "string";
-    }
-    @Provides Integer integer() {
-      return 5;
-    }
-  }
-}
diff --git a/compiler/src/it/multiple-provides-methods/verify.bsh b/compiler/src/it/multiple-provides-methods/verify.bsh
deleted file mode 100644
index 5890213e1..000000000
--- a/compiler/src/it/multiple-provides-methods/verify.bsh
+++ /dev/null
@@ -1,12 +0,0 @@
-import java.io.File;
-
-File classes = new File(basedir, "target/classes/test/");
-
-File moduleAdapter = new File(classes, "TestApp$TestModule$$ModuleAdapter.class");
-if (!moduleAdapter.exists()) throw new Exception("No binding generated for module");
-
-File integerBinding = new File(classes, "TestApp$TestModule$$ModuleAdapter$IntegerProvidesAdapter.class");
-if (!integerBinding.exists()) throw new Exception("No binding generated for integer()");
-
-File stringBinding = new File(classes, "TestApp$TestModule$$ModuleAdapter$StringProvidesAdapter.class");
-if (!stringBinding.exists()) throw new Exception("No binding generated for string()");
diff --git a/compiler/src/it/multiple-qualifiers/invoker.properties b/compiler/src/it/multiple-qualifiers/invoker.properties
deleted file mode 100644
index fdd3d204d..000000000
--- a/compiler/src/it/multiple-qualifiers/invoker.properties
+++ /dev/null
@@ -1 +0,0 @@
-invoker.buildResult=failure
diff --git a/compiler/src/it/multiple-qualifiers/pom.xml b/compiler/src/it/multiple-qualifiers/pom.xml
deleted file mode 100644
index 655be009c..000000000
--- a/compiler/src/it/multiple-qualifiers/pom.xml
+++ /dev/null
@@ -1,51 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--
-  Copyright (C) 2013 Google, Inc.
-  Copyright (C) 2013 Square, Inc.
-
-  Licensed under the Apache License, Version 2.0 (the "License");
-  you may not use this file except in compliance with the License.
-  You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-  Unless required by applicable law or agreed to in writing, software
-  distributed under the License is distributed on an "AS IS" BASIS,
-  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-  See the License for the specific language governing permissions and
-  limitations under the License.
--->
-<project
-    xmlns="http://maven.apache.org/POM/4.0.0"
-    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-  <groupId>com.example.dagger.tests</groupId>
-  <artifactId>multiple-qualifiers</artifactId>
-  <version>HEAD-SNAPSHOT</version>
-  <dependencies>
-    <dependency>
-      <groupId>@dagger.groupId@</groupId>
-      <artifactId>dagger</artifactId>
-      <version>@dagger.version@</version>
-    </dependency>
-    <dependency>
-      <groupId>@dagger.groupId@</groupId>
-      <artifactId>dagger-compiler</artifactId>
-      <version>@dagger.version@</version>
-      <optional>true</optional>
-    </dependency>
-  </dependencies>
-  <build>
-    <plugins>
-      <plugin>
-        <artifactId>maven-compiler-plugin</artifactId>
-        <version>3.1</version>
-        <configuration>
-          <source>1.5</source>
-          <target>1.5</target>
-        </configuration>
-      </plugin>
-    </plugins>
-  </build>
-</project>
diff --git a/compiler/src/it/multiple-qualifiers/src/main/java/test/TestApp.java b/compiler/src/it/multiple-qualifiers/src/main/java/test/TestApp.java
deleted file mode 100644
index 55a51f4e1..000000000
--- a/compiler/src/it/multiple-qualifiers/src/main/java/test/TestApp.java
+++ /dev/null
@@ -1,61 +0,0 @@
-/*
- * Copyright (C) 2013 Google, Inc.
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package test;
-
-import dagger.Module;
-import dagger.Provides;
-import java.lang.annotation.Retention;
-import javax.inject.Inject;
-import javax.inject.Singleton;
-import javax.inject.Qualifier;
-
-import static java.lang.annotation.RetentionPolicy.RUNTIME;
-
-class TestApp {
-  static class TestClass1 {
-    @Inject
-    @MyQualifier1
-    @MyQualifier2
-    String field;
-  }
-
-  static class TestClass2 {
-    String string;
-
-    public TestClass2(@MyQualifier1 @MyQualifier2 String constructorParam) {
-      this.string = string;
-    }
-  }
-
-  @Module(injects = TestClass1.class)
-  static class TestModule {
-    @MyQualifier1
-    @MyQualifier2
-    @Provides
-    String providesString() {
-      return "string";
-    }
-  }
- 
-  @Qualifier
-  @Retention(value = RUNTIME)
-  @interface MyQualifier1 {}
- 
-  @Qualifier
-  @Retention(value = RUNTIME)
-  @interface MyQualifier2 {}
-}
diff --git a/compiler/src/it/multiple-qualifiers/verify.bsh b/compiler/src/it/multiple-qualifiers/verify.bsh
deleted file mode 100644
index b3fc2a850..000000000
--- a/compiler/src/it/multiple-qualifiers/verify.bsh
+++ /dev/null
@@ -1,10 +0,0 @@
-import dagger.testing.it.BuildLogValidator;
-import java.io.File;
-
-File buildLog = new File(basedir, "build.log");
-new BuildLogValidator().assertHasText(buildLog, new String[]{
-    "Only one qualifier annotation is allowed per element: test.TestApp.TestClass1.field"});
-new BuildLogValidator().assertHasText(buildLog, new String[]{
-    "Only one qualifier annotation is allowed per element: constructorParam"});   
-new BuildLogValidator().assertHasText(buildLog, new String[]{
-    "Only one qualifier annotation is allowed per element: test.TestApp.TestModule.providesString()"});
diff --git a/compiler/src/it/parent-with-injected-members/pom.xml b/compiler/src/it/parent-with-injected-members/pom.xml
deleted file mode 100644
index b5c5d1092..000000000
--- a/compiler/src/it/parent-with-injected-members/pom.xml
+++ /dev/null
@@ -1,51 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--
- Copyright (C) 2013 Google, Inc.
-
-  Licensed under the Apache License, Version 2.0 (the "License");
-  you may not use this file except in compliance with the License.
-  You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-  Unless required by applicable law or agreed to in writing, software
-  distributed under the License is distributed on an "AS IS" BASIS,
-  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-  See the License for the specific language governing permissions and
-  limitations under the License.
--->
-<project
-    xmlns="http://maven.apache.org/POM/4.0.0"
-    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-  <groupId>com.example.dagger.tests</groupId>
-  <artifactId>parent-with-injected-members</artifactId>
-  <version>HEAD-SNAPSHOT</version>
-  <name>Dagger Integration Test Basic</name>
-  <dependencies>
-    <dependency>
-      <groupId>@dagger.groupId@</groupId>
-      <artifactId>dagger</artifactId>
-      <version>@dagger.version@</version>
-    </dependency>
-    <dependency>
-      <groupId>@dagger.groupId@</groupId>
-      <artifactId>dagger-compiler</artifactId>
-      <version>@dagger.version@</version>
-      <optional>true</optional>
-    </dependency>
-  </dependencies>
-  <build>
-    <plugins>
-      <plugin>
-        <artifactId>maven-compiler-plugin</artifactId>
-        <version>3.1</version>
-        <configuration>
-          <source>1.5</source>
-          <target>1.5</target>
-        </configuration>
-      </plugin>
-    </plugins>
-  </build>
-</project>
diff --git a/compiler/src/it/parent-with-injected-members/src/main/java/test/TestApp.java b/compiler/src/it/parent-with-injected-members/src/main/java/test/TestApp.java
deleted file mode 100644
index 33e0a69e4..000000000
--- a/compiler/src/it/parent-with-injected-members/src/main/java/test/TestApp.java
+++ /dev/null
@@ -1,39 +0,0 @@
-/*
- * Copyright (C) 2013 Google, Inc.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package test;
-
-import dagger.Module;
-import dagger.Provides;
-import javax.inject.Inject;
-import test.parentpackage.ParentWithInjectedMember;
-
-class TestApp {
-   
-  static class InjectableSubclass extends ParentWithInjectedMember {
-     @Inject String string;
-  }
-
-  @Module(injects = InjectableSubclass.class)
-  static class TestModule {
-    @Provides String provideString() {
-      return "string";
-    }
-    
-    @Provides Integer provideInteger() {
-      return 5;
-    }
-  }
-}
diff --git a/compiler/src/it/parent-with-injected-members/src/main/java/test/grandparentpackage/GrandparentWithNoInjectedMembers.java b/compiler/src/it/parent-with-injected-members/src/main/java/test/grandparentpackage/GrandparentWithNoInjectedMembers.java
deleted file mode 100644
index eec9ce3d6..000000000
--- a/compiler/src/it/parent-with-injected-members/src/main/java/test/grandparentpackage/GrandparentWithNoInjectedMembers.java
+++ /dev/null
@@ -1,19 +0,0 @@
-/*
- * Copyright (C) 2013 Google, Inc.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package test.grandparentpackage;
-
-public class GrandparentWithNoInjectedMembers {
-}
diff --git a/compiler/src/it/parent-with-injected-members/src/main/java/test/parentpackage/ParentWithInjectedMember.java b/compiler/src/it/parent-with-injected-members/src/main/java/test/parentpackage/ParentWithInjectedMember.java
deleted file mode 100644
index dfcd26f3a..000000000
--- a/compiler/src/it/parent-with-injected-members/src/main/java/test/parentpackage/ParentWithInjectedMember.java
+++ /dev/null
@@ -1,23 +0,0 @@
-/*
- * Copyright (C) 2013 Google, Inc.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package test.parentpackage;
-
-import javax.inject.Inject;
-import test.grandparentpackage.GrandparentWithNoInjectedMembers;
-
-public class ParentWithInjectedMember extends GrandparentWithNoInjectedMembers {
-  @Inject Integer integer;
-}
diff --git a/compiler/src/it/parent-with-injected-members/verify.bsh b/compiler/src/it/parent-with-injected-members/verify.bsh
deleted file mode 100644
index c91bc9a08..000000000
--- a/compiler/src/it/parent-with-injected-members/verify.bsh
+++ /dev/null
@@ -1,28 +0,0 @@
-import java.io.File;
-
-File classes = new File(basedir, "target/classes/test/");
-
-File moduleAdapter = new File(classes, "TestApp$TestModule$$ModuleAdapter.class");
-if (!moduleAdapter.exists()) throw new Exception("No binding generated for module");
-
-File integerBinding = 
-    new File(classes, "TestApp$TestModule$$ModuleAdapter$ProvideIntegerProvidesAdapter.class");
-if (!integerBinding.exists()) throw new Exception("No binding generated for integer()");
-
-File stringBinding =
-    new File(classes, "TestApp$TestModule$$ModuleAdapter$ProvideStringProvidesAdapter.class");
-if (!stringBinding.exists()) throw new Exception("No binding generated for string()");
-
-File injectAdapter = new File(classes, "TestApp$InjectableSubclass$$InjectAdapter.class");
-if (!injectAdapter.exists()) 
-  throw new Exception("No inject adapter generated for InjectableSubclass");
-
-File parentAdapter = 
-    new File(classes, "parentpackage/ParentWithInjectedMember$$ParentAdapter$$test_TestApp$InjectableSubclass.class");
-if (!parentAdapter.exists()) 
-  throw new Exception("No parent adapter generated for ParentWithInjectedMember");
-  
-File grandparentAdapter = 
-    new File(classes, "grandparentpackage/GrandparentWithNoInjectedMembers$$ParentAdapter$$test_TestApp$InjectableSubclass.class");
-if (grandparentAdapter.exists()) 
-  throw new Exception("An unnecessary parent adapter was generated for GrandparentwithNoInjectedMembers.");
diff --git a/compiler/src/it/private-inject/invoker.properties b/compiler/src/it/private-inject/invoker.properties
deleted file mode 100644
index 324b5fb99..000000000
--- a/compiler/src/it/private-inject/invoker.properties
+++ /dev/null
@@ -1 +0,0 @@
-invoker.buildResult=failure
\ No newline at end of file
diff --git a/compiler/src/it/private-inject/pom.xml b/compiler/src/it/private-inject/pom.xml
deleted file mode 100644
index cc5673ede..000000000
--- a/compiler/src/it/private-inject/pom.xml
+++ /dev/null
@@ -1,50 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--
-  Copyright (C) 2013 Square, Inc.
-
-  Licensed under the Apache License, Version 2.0 (the "License");
-  you may not use this file except in compliance with the License.
-  You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-  Unless required by applicable law or agreed to in writing, software
-  distributed under the License is distributed on an "AS IS" BASIS,
-  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-  See the License for the specific language governing permissions and
-  limitations under the License.
--->
-<project
-    xmlns="http://maven.apache.org/POM/4.0.0"
-    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-  <groupId>com.example.dagger.tests</groupId>
-  <artifactId>private-inject</artifactId>
-  <version>HEAD-SNAPSHOT</version>
-  <dependencies>
-    <dependency>
-      <groupId>@dagger.groupId@</groupId>
-      <artifactId>dagger</artifactId>
-      <version>@dagger.version@</version>
-    </dependency>
-    <dependency>
-      <groupId>@dagger.groupId@</groupId>
-      <artifactId>dagger-compiler</artifactId>
-      <version>@dagger.version@</version>
-      <optional>true</optional>
-    </dependency>
-  </dependencies>
-  <build>
-    <plugins>
-      <plugin>
-        <artifactId>maven-compiler-plugin</artifactId>
-        <version>3.1</version>
-        <configuration>
-          <source>1.5</source>
-          <target>1.5</target>
-        </configuration>
-      </plugin>
-    </plugins>
-  </build>
-</project>
diff --git a/compiler/src/it/private-inject/src/main/java/test/TestApp.java b/compiler/src/it/private-inject/src/main/java/test/TestApp.java
deleted file mode 100644
index f3d3f97f0..000000000
--- a/compiler/src/it/private-inject/src/main/java/test/TestApp.java
+++ /dev/null
@@ -1,22 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package test;
-
-import javax.inject.Inject;
-
-class TestApp {
-  @Inject private Object nope;
-}
diff --git a/compiler/src/it/private-inject/src/main/java/test/TestFoo.java b/compiler/src/it/private-inject/src/main/java/test/TestFoo.java
deleted file mode 100644
index 61a69048c..000000000
--- a/compiler/src/it/private-inject/src/main/java/test/TestFoo.java
+++ /dev/null
@@ -1,23 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package test;
-
-import javax.inject.Inject;
-
-class TestFoo {
-  @Inject private TestFoo() {
-  }
-}
diff --git a/compiler/src/it/private-inject/verify.bsh b/compiler/src/it/private-inject/verify.bsh
deleted file mode 100644
index c327478d9..000000000
--- a/compiler/src/it/private-inject/verify.bsh
+++ /dev/null
@@ -1,8 +0,0 @@
-import dagger.testing.it.BuildLogValidator;
-import java.io.File;
-
-File buildLog = new File(basedir, "build.log");
-new BuildLogValidator().assertHasText(buildLog, new String[]{
-    "Can't inject a private field: test.TestApp.nope"});
-new BuildLogValidator().assertHasText(buildLog, new String[]{
-    "Can't inject a private constructor: test.TestFoo.TestFoo()"});
diff --git a/compiler/src/it/provide-provider-or-lazy/invoker.properties b/compiler/src/it/provide-provider-or-lazy/invoker.properties
deleted file mode 100644
index 324b5fb99..000000000
--- a/compiler/src/it/provide-provider-or-lazy/invoker.properties
+++ /dev/null
@@ -1 +0,0 @@
-invoker.buildResult=failure
\ No newline at end of file
diff --git a/compiler/src/it/provide-provider-or-lazy/pom.xml b/compiler/src/it/provide-provider-or-lazy/pom.xml
deleted file mode 100644
index 40b760099..000000000
--- a/compiler/src/it/provide-provider-or-lazy/pom.xml
+++ /dev/null
@@ -1,50 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--
-  Copyright (C) 2013 Square, Inc.
-
-  Licensed under the Apache License, Version 2.0 (the "License");
-  you may not use this file except in compliance with the License.
-  You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-  Unless required by applicable law or agreed to in writing, software
-  distributed under the License is distributed on an "AS IS" BASIS,
-  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-  See the License for the specific language governing permissions and
-  limitations under the License.
--->
-<project
-    xmlns="http://maven.apache.org/POM/4.0.0"
-    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-  <groupId>com.example.dagger.tests</groupId>
-  <artifactId>provide-provider-or-lazy</artifactId>
-  <version>HEAD-SNAPSHOT</version>
-  <dependencies>
-    <dependency>
-      <groupId>@dagger.groupId@</groupId>
-      <artifactId>dagger</artifactId>
-      <version>@dagger.version@</version>
-    </dependency>
-    <dependency>
-      <groupId>@dagger.groupId@</groupId>
-      <artifactId>dagger-compiler</artifactId>
-      <version>@dagger.version@</version>
-      <optional>true</optional>
-    </dependency>
-  </dependencies>
-  <build>
-    <plugins>
-      <plugin>
-        <artifactId>maven-compiler-plugin</artifactId>
-        <version>3.1</version>
-        <configuration>
-          <source>1.5</source>
-          <target>1.5</target>
-        </configuration>
-      </plugin>
-    </plugins>
-  </build>
-</project>
diff --git a/compiler/src/it/provide-provider-or-lazy/src/main/java/test/TestModule.java b/compiler/src/it/provide-provider-or-lazy/src/main/java/test/TestModule.java
deleted file mode 100644
index 0a80aee57..000000000
--- a/compiler/src/it/provide-provider-or-lazy/src/main/java/test/TestModule.java
+++ /dev/null
@@ -1,39 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package test;
-
-import dagger.Lazy;
-import dagger.Module;
-import dagger.Provides;
-import javax.inject.Provider;
-
-@Module class TestModule {
-  @Provides Provider<Object> provideProvider() {
-    return null;
-  }
-
-  @Provides Provider provideRawProvider() {
-    return null;
-  }
-
-  @Provides Lazy<Object> provideLazy() {
-    return null;
-  }
-
-  @Provides Lazy provideRawLazy() {
-    return null;
-  }
-}
diff --git a/compiler/src/it/provide-provider-or-lazy/verify.bsh b/compiler/src/it/provide-provider-or-lazy/verify.bsh
deleted file mode 100644
index 7a5cfd088..000000000
--- a/compiler/src/it/provide-provider-or-lazy/verify.bsh
+++ /dev/null
@@ -1,12 +0,0 @@
-import dagger.testing.it.BuildLogValidator;
-import java.io.File;
-
-File buildLog = new File(basedir, "build.log");
-new BuildLogValidator().assertHasText(buildLog, new String[]{
-    "@Provides method must not return javax.inject.Provider directly: test.TestModule.provideProvider"});
-new BuildLogValidator().assertHasText(buildLog, new String[]{
-    "@Provides method must not return javax.inject.Provider directly: test.TestModule.provideRawProvider"});
-new BuildLogValidator().assertHasText(buildLog, new String[]{
-    "@Provides method must not return dagger.Lazy directly: test.TestModule.provideLazy"});
-new BuildLogValidator().assertHasText(buildLog, new String[]{
-    "@Provides method must not return dagger.Lazy directly: test.TestModule.provideRawLazy"});
diff --git a/compiler/src/it/provides-method-not-in-module/invoker.properties b/compiler/src/it/provides-method-not-in-module/invoker.properties
deleted file mode 100644
index fdd3d204d..000000000
--- a/compiler/src/it/provides-method-not-in-module/invoker.properties
+++ /dev/null
@@ -1 +0,0 @@
-invoker.buildResult=failure
diff --git a/compiler/src/it/provides-method-not-in-module/pom.xml b/compiler/src/it/provides-method-not-in-module/pom.xml
deleted file mode 100644
index 89f527d9b..000000000
--- a/compiler/src/it/provides-method-not-in-module/pom.xml
+++ /dev/null
@@ -1,51 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--
-  Copyright (C) 2013 Google, Inc.
-  Copyright (C) 2013 Square, Inc.
-
-  Licensed under the Apache License, Version 2.0 (the "License");
-  you may not use this file except in compliance with the License.
-  You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-  Unless required by applicable law or agreed to in writing, software
-  distributed under the License is distributed on an "AS IS" BASIS,
-  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-  See the License for the specific language governing permissions and
-  limitations under the License.
--->
-<project
-    xmlns="http://maven.apache.org/POM/4.0.0"
-    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-  <groupId>com.example.dagger.tests</groupId>
-  <artifactId>provides-method-not-in-module</artifactId>
-  <version>HEAD-SNAPSHOT</version>
-  <dependencies>
-    <dependency>
-      <groupId>@dagger.groupId@</groupId>
-      <artifactId>dagger</artifactId>
-      <version>@dagger.version@</version>
-    </dependency>
-    <dependency>
-      <groupId>@dagger.groupId@</groupId>
-      <artifactId>dagger-compiler</artifactId>
-      <version>@dagger.version@</version>
-      <optional>true</optional>
-    </dependency>
-  </dependencies>
-  <build>
-    <plugins>
-      <plugin>
-        <artifactId>maven-compiler-plugin</artifactId>
-        <version>3.1</version>
-        <configuration>
-          <source>1.5</source>
-          <target>1.5</target>
-        </configuration>
-      </plugin>
-    </plugins>
-  </build>
-</project>
diff --git a/compiler/src/it/provides-method-not-in-module/src/main/java/test/TestApp.java b/compiler/src/it/provides-method-not-in-module/src/main/java/test/TestApp.java
deleted file mode 100644
index 8748d3784..000000000
--- a/compiler/src/it/provides-method-not-in-module/src/main/java/test/TestApp.java
+++ /dev/null
@@ -1,27 +0,0 @@
-/*
- * Copyright (C) 2013 Google, Inc.
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package test;
-
-import dagger.Provides;
-
-class TestApp {
-
-  @Provides
-  String providesString() {
-    return "string";
-  }
-}
diff --git a/compiler/src/it/provides-method-not-in-module/verify.bsh b/compiler/src/it/provides-method-not-in-module/verify.bsh
deleted file mode 100644
index 22cdec585..000000000
--- a/compiler/src/it/provides-method-not-in-module/verify.bsh
+++ /dev/null
@@ -1,6 +0,0 @@
-import dagger.testing.it.BuildLogValidator;
-import java.io.File;
-
-File buildLog = new File(basedir, "build.log");
-new BuildLogValidator().assertHasText(buildLog, new String[]{
-    "@Provides methods must be declared in modules: test.TestApp.providesString()"});
diff --git a/compiler/src/it/provides-method-with-throws-clause/invoker.properties b/compiler/src/it/provides-method-with-throws-clause/invoker.properties
deleted file mode 100644
index 324b5fb99..000000000
--- a/compiler/src/it/provides-method-with-throws-clause/invoker.properties
+++ /dev/null
@@ -1 +0,0 @@
-invoker.buildResult=failure
\ No newline at end of file
diff --git a/compiler/src/it/provides-method-with-throws-clause/pom.xml b/compiler/src/it/provides-method-with-throws-clause/pom.xml
deleted file mode 100644
index 7e268d34f..000000000
--- a/compiler/src/it/provides-method-with-throws-clause/pom.xml
+++ /dev/null
@@ -1,52 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--
- Copyright (C) 2013 Square, Inc.
- Copyright (C) 2013 Google, Inc.
-
-  Licensed under the Apache License, Version 2.0 (the "License");
-  you may not use this file except in compliance with the License.
-  You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-  Unless required by applicable law or agreed to in writing, software
-  distributed under the License is distributed on an "AS IS" BASIS,
-  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-  See the License for the specific language governing permissions and
-  limitations under the License.
--->
-<project
-    xmlns="http://maven.apache.org/POM/4.0.0"
-    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-  <groupId>com.example.dagger.tests</groupId>
-  <artifactId>provides-method-with-throws-clause</artifactId>
-  <version>HEAD-SNAPSHOT</version>
-  <name>Dagger Integration Test Basic</name>
-  <dependencies>
-    <dependency>
-      <groupId>@dagger.groupId@</groupId>
-      <artifactId>dagger</artifactId>
-      <version>@dagger.version@</version>
-    </dependency>
-    <dependency>
-      <groupId>@dagger.groupId@</groupId>
-      <artifactId>dagger-compiler</artifactId>
-      <version>@dagger.version@</version>
-      <optional>true</optional>
-    </dependency>
-  </dependencies>
-  <build>
-    <plugins>
-      <plugin>
-        <artifactId>maven-compiler-plugin</artifactId>
-        <version>3.1</version>
-        <configuration>
-          <source>1.5</source>
-          <target>1.5</target>
-        </configuration>
-      </plugin>
-    </plugins>
-  </build>
-</project>
diff --git a/compiler/src/it/provides-method-with-throws-clause/src/main/java/test/TestApp.java b/compiler/src/it/provides-method-with-throws-clause/src/main/java/test/TestApp.java
deleted file mode 100644
index 51718621a..000000000
--- a/compiler/src/it/provides-method-with-throws-clause/src/main/java/test/TestApp.java
+++ /dev/null
@@ -1,47 +0,0 @@
-/*
- * Copyright (C) 2013 Google, Inc.
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package test;
-
-import dagger.Module;
-
-import dagger.ObjectGraph;
-import dagger.Provides;
-
-import javax.inject.Inject;
-import java.io.IOException;
-import java.lang.Override;
-
-class TestApp implements Runnable {
-
-  @Inject String string;
-
-  @Override public void run() {
-    // Yay! \o/
-  }
-
-  public static void main(String[] args) {
-    ObjectGraph.create(new TestModule()).get(TestApp.class).run();
-  }
-
-  @Module(injects = TestApp.class)
-  static class TestModule {
-
-    @Provides String string() throws IOException {
-      return "string";
-    }
-  }
-}
diff --git a/compiler/src/it/provides-method-with-throws-clause/verify.bsh b/compiler/src/it/provides-method-with-throws-clause/verify.bsh
deleted file mode 100644
index ab61c03ea..000000000
--- a/compiler/src/it/provides-method-with-throws-clause/verify.bsh
+++ /dev/null
@@ -1,6 +0,0 @@
-import dagger.testing.it.BuildLogValidator;
-import java.io.File;
-
-File buildLog = new File(basedir, "build.log");
-new BuildLogValidator().assertHasText(buildLog, new String[]{
-    "@Provides methods must not have a throws clause"});
diff --git a/compiler/src/it/qualifiers-on-invalid-elements-errors/invoker.properties b/compiler/src/it/qualifiers-on-invalid-elements-errors/invoker.properties
deleted file mode 100644
index fdd3d204d..000000000
--- a/compiler/src/it/qualifiers-on-invalid-elements-errors/invoker.properties
+++ /dev/null
@@ -1 +0,0 @@
-invoker.buildResult=failure
diff --git a/compiler/src/it/qualifiers-on-invalid-elements-errors/pom.xml b/compiler/src/it/qualifiers-on-invalid-elements-errors/pom.xml
deleted file mode 100644
index adb65c262..000000000
--- a/compiler/src/it/qualifiers-on-invalid-elements-errors/pom.xml
+++ /dev/null
@@ -1,52 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--
-  Copyright (C) 2013 Google, Inc.
-  Copyright (C) 2013 Square, Inc.
-
-  Licensed under the Apache License, Version 2.0 (the "License");
-  you may not use this file except in compliance with the License.
-  You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-  Unless required by applicable law or agreed to in writing, software
-  distributed under the License is distributed on an "AS IS" BASIS,
-  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-  See the License for the specific language governing permissions and
-  limitations under the License.
--->
-<project
-    xmlns="http://maven.apache.org/POM/4.0.0"
-    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-  <groupId>com.example.dagger.tests</groupId>
-  <artifactId>qualifiers-on-invalid-elements-errors</artifactId>
-  <version>HEAD-SNAPSHOT</version>
-  <dependencies>
-    <dependency>
-      <groupId>@dagger.groupId@</groupId>
-      <artifactId>dagger</artifactId>
-      <version>@dagger.version@</version>
-    </dependency>
-    <dependency>
-      <groupId>@dagger.groupId@</groupId>
-      <artifactId>dagger-compiler</artifactId>
-      <version>@dagger.version@</version>
-      <optional>true</optional>
-    </dependency>
-  </dependencies>
-  <build>
-    <plugins>
-      <plugin>
-        <artifactId>maven-compiler-plugin</artifactId>
-        <version>3.1</version>
-        <configuration>
-          <source>1.5</source>
-          <target>1.5</target>
-          <showWarnings>true</showWarnings>
-        </configuration>
-      </plugin>
-    </plugins>
-  </build>
-</project>
diff --git a/compiler/src/it/qualifiers-on-invalid-elements-errors/src/main/java/test/TestApp.java b/compiler/src/it/qualifiers-on-invalid-elements-errors/src/main/java/test/TestApp.java
deleted file mode 100644
index b423221f2..000000000
--- a/compiler/src/it/qualifiers-on-invalid-elements-errors/src/main/java/test/TestApp.java
+++ /dev/null
@@ -1,49 +0,0 @@
-/*
- * Copyright (C) 2013 Google, Inc.
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package test;
-
-import dagger.Module;
-import dagger.Provides;
-import java.lang.annotation.Retention;
-import javax.inject.Inject;
-import javax.inject.Qualifier;
-
-import static java.lang.annotation.RetentionPolicy.RUNTIME;
-
-class TestApp {
-
-  @MyQualifier
-  static class TestClass1 {
-    
-    @MyQualifier // qualfier on non-injectable constructor
-    public TestClass1(String constructorParam) {}
-  }
-  
-  static class TestClass2 {
-    String string;
-    
-    @Inject
-    @MyQualifier // qualifier on injectable constructor
-    public TestClass2(String injectableConstructorParam) {
-      this.string = string;
-    }  
-  }
-  
-  @Qualifier
-  @Retention(value = RUNTIME)
-  @interface MyQualifier {}
-}
diff --git a/compiler/src/it/qualifiers-on-invalid-elements-errors/verify.bsh b/compiler/src/it/qualifiers-on-invalid-elements-errors/verify.bsh
deleted file mode 100644
index 814ff8b54..000000000
--- a/compiler/src/it/qualifiers-on-invalid-elements-errors/verify.bsh
+++ /dev/null
@@ -1,10 +0,0 @@
-import dagger.testing.it.BuildLogValidator;
-import java.io.File;
-
-File buildLog = new File(basedir, "build.log");
-new BuildLogValidator().assertHasText(buildLog, new String[]{
-    "Qualifier annotations are only allowed on fields, methods, and parameters: test.TestApp.TestClass1"});   
-new BuildLogValidator().assertHasText(buildLog, new String[]{
-    "Qualifier annotations are only allowed on fields, methods, and parameters: test.TestApp.TestClass1.TestClass1(java.lang.String)"});   
-new BuildLogValidator().assertHasText(buildLog, new String[]{
-    "Qualifier annotations are only allowed on fields, methods, and parameters: test.TestApp.TestClass2.TestClass2(java.lang.String)"});
diff --git a/compiler/src/it/qualifiers-on-invalid-elements-warnings/pom.xml b/compiler/src/it/qualifiers-on-invalid-elements-warnings/pom.xml
deleted file mode 100644
index ca4cb327b..000000000
--- a/compiler/src/it/qualifiers-on-invalid-elements-warnings/pom.xml
+++ /dev/null
@@ -1,52 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--
-  Copyright (C) 2013 Google, Inc.
-  Copyright (C) 2013 Square, Inc.
-
-  Licensed under the Apache License, Version 2.0 (the "License");
-  you may not use this file except in compliance with the License.
-  You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-  Unless required by applicable law or agreed to in writing, software
-  distributed under the License is distributed on an "AS IS" BASIS,
-  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-  See the License for the specific language governing permissions and
-  limitations under the License.
--->
-<project
-    xmlns="http://maven.apache.org/POM/4.0.0"
-    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-  <groupId>com.example.dagger.tests</groupId>
-  <artifactId>qualifiers-on-invalid-elements-warnings</artifactId>
-  <version>HEAD-SNAPSHOT</version>
-  <dependencies>
-    <dependency>
-      <groupId>@dagger.groupId@</groupId>
-      <artifactId>dagger</artifactId>
-      <version>@dagger.version@</version>
-    </dependency>
-    <dependency>
-      <groupId>@dagger.groupId@</groupId>
-      <artifactId>dagger-compiler</artifactId>
-      <version>@dagger.version@</version>
-      <optional>true</optional>
-    </dependency>
-  </dependencies>
-  <build>
-    <plugins>
-      <plugin>
-        <artifactId>maven-compiler-plugin</artifactId>
-        <version>3.1</version>
-        <configuration>
-          <source>1.5</source>
-          <target>1.5</target>
-          <showWarnings>true</showWarnings>
-        </configuration>
-      </plugin>
-    </plugins>
-  </build>
-</project>
diff --git a/compiler/src/it/qualifiers-on-invalid-elements-warnings/src/main/java/test/TestApp.java b/compiler/src/it/qualifiers-on-invalid-elements-warnings/src/main/java/test/TestApp.java
deleted file mode 100644
index 4b2c7464d..000000000
--- a/compiler/src/it/qualifiers-on-invalid-elements-warnings/src/main/java/test/TestApp.java
+++ /dev/null
@@ -1,54 +0,0 @@
-/*
- * Copyright (C) 2013 Google, Inc.
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package test;
-
-import dagger.Module;
-import dagger.Provides;
-import java.lang.annotation.Retention;
-import javax.inject.Inject;
-import javax.inject.Qualifier;
-
-import static java.lang.annotation.RetentionPolicy.RUNTIME;
-
-class TestApp {
-
-  static class TestClass {
-    @MyQualifier int field1; // non-injectable field
-    
-    @SuppressWarnings("some string other than 'qualifiers'")
-    @MyQualifier 
-    int field2;
-    
-    @SuppressWarnings("qualifiers")
-    @MyQualifier 
-    int fieldWithWarningSuppressed1;
-    
-    @SuppressWarnings({"foo", "qualifiers", "bar"})
-    @MyQualifier 
-    int fieldWithWarningSuppressed2;
-    
-    // qualfier on non-injectable constructor parameter
-    public TestClass(@MyQualifier String constructorParam) {}
-    
-    @MyQualifier 
-    void nonProvidesMethod(@MyQualifier String methodParam) {}
-  }
-  
-  @Qualifier
-  @Retention(value = RUNTIME)
-  @interface MyQualifier {}
-}
diff --git a/compiler/src/it/qualifiers-on-invalid-elements-warnings/verify.bsh b/compiler/src/it/qualifiers-on-invalid-elements-warnings/verify.bsh
deleted file mode 100644
index 82afe08a1..000000000
--- a/compiler/src/it/qualifiers-on-invalid-elements-warnings/verify.bsh
+++ /dev/null
@@ -1,18 +0,0 @@
-import dagger.testing.it.BuildLogValidator;
-import java.io.File;
-
-File buildLog = new File(basedir, "build.log");
-new BuildLogValidator().assertHasText(buildLog, new String[]{
-    "Dagger will ignore qualifier annotations on fields that are not annotated with @Inject: test.TestApp.TestClass.field1"});   
-new BuildLogValidator().assertHasText(buildLog, new String[]{
-    "Dagger will ignore qualifier annotations on fields that are not annotated with @Inject: test.TestApp.TestClass.field2"});   
-new BuildLogValidator().assertHasText(buildLog, new String[]{
-    "Dagger will ignore qualifier annotations on methods that are not @Provides methods: test.TestApp.TestClass.nonProvidesMethod(java.lang.String)"});  
-new BuildLogValidator().assertHasText(buildLog, new String[]{
-    "Dagger will ignore qualifier annotations on parameters that are not @Inject constructor parameters or @Provides method parameters: methodParam"});  
-new BuildLogValidator().assertHasText(buildLog, new String[]{
-    "Dagger will ignore qualifier annotations on parameters that are not @Inject constructor parameters or @Provides method parameters: constructorParam"});
-new BuildLogValidator().assertDoesNotHaveText(buildLog, new String[]{
-    "Dagger will ignore qualifier annotations on fields that are not annotated with @Inject: test.TestApp.TestClass.fieldWithWarningSuppressed1"});
-new BuildLogValidator().assertDoesNotHaveText(buildLog, new String[]{
-    "Dagger will ignore qualifier annotations on fields that are not annotated with @Inject: test.TestApp.TestClass.fieldWithWarningSuppressed2"});
diff --git a/compiler/src/it/same-provides-method-name/pom.xml b/compiler/src/it/same-provides-method-name/pom.xml
deleted file mode 100644
index 938165e9a..000000000
--- a/compiler/src/it/same-provides-method-name/pom.xml
+++ /dev/null
@@ -1,52 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--
- Copyright (C) 2012 Square, Inc.
- Copyright (C) 2012 Google, Inc.
-
-  Licensed under the Apache License, Version 2.0 (the "License");
-  you may not use this file except in compliance with the License.
-  You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-  Unless required by applicable law or agreed to in writing, software
-  distributed under the License is distributed on an "AS IS" BASIS,
-  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-  See the License for the specific language governing permissions and
-  limitations under the License.
--->
-<project
-    xmlns="http://maven.apache.org/POM/4.0.0"
-    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-  <groupId>com.example.dagger.tests</groupId>
-  <artifactId>same-provides-method-name</artifactId>
-  <version>HEAD-SNAPSHOT</version>
-  <name>Dagger Integration Test Basic</name>
-  <dependencies>
-    <dependency>
-      <groupId>@dagger.groupId@</groupId>
-      <artifactId>dagger</artifactId>
-      <version>@dagger.version@</version>
-    </dependency>
-    <dependency>
-      <groupId>@dagger.groupId@</groupId>
-      <artifactId>dagger-compiler</artifactId>
-      <version>@dagger.version@</version>
-      <optional>true</optional>
-    </dependency>
-  </dependencies>
-  <build>
-    <plugins>
-      <plugin>
-        <artifactId>maven-compiler-plugin</artifactId>
-        <version>3.1</version>
-        <configuration>
-          <source>1.5</source>
-          <target>1.5</target>
-        </configuration>
-      </plugin>
-    </plugins>
-  </build>
-</project>
diff --git a/compiler/src/it/same-provides-method-name/src/main/java/test/TestApp.java b/compiler/src/it/same-provides-method-name/src/main/java/test/TestApp.java
deleted file mode 100644
index 6af417cb0..000000000
--- a/compiler/src/it/same-provides-method-name/src/main/java/test/TestApp.java
+++ /dev/null
@@ -1,56 +0,0 @@
-/*
- * Copyright (C) 2012 Google, Inc.
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package test;
-
-import dagger.Module;
-
-import dagger.ObjectGraph;
-import dagger.Provides;
-
-import javax.inject.Inject;
-import java.lang.Override;
-
-class TestApp implements Runnable {
-
-  @Inject Foo foo;
-
-  @Override public void run() {
-    // Yay! \o/
-  }
-
-  public static void main(String[] args) {
-    ObjectGraph.create(new TestModule()).get(TestApp.class).run();
-  }
-
-  static class Foo {
-  }
-
-  static class MyFoo extends Foo {
-  }
-
-  @Module(injects = TestApp.class)
-  static class TestModule {
-
-    @Provides Foo providesFoo(MyFoo foo) {
-      return foo;
-    }
-
-    @Provides MyFoo providesFoo() {
-      return new MyFoo();
-    }
-  }
-}
diff --git a/compiler/src/it/static-injected-binding-doesnt-fail-providers/pom.xml b/compiler/src/it/static-injected-binding-doesnt-fail-providers/pom.xml
deleted file mode 100644
index b93d3bf64..000000000
--- a/compiler/src/it/static-injected-binding-doesnt-fail-providers/pom.xml
+++ /dev/null
@@ -1,52 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--
-  Copyright (C) 2013 Square, Inc.
-
-  Licensed under the Apache License, Version 2.0 (the "License");
-  you may not use this file except in compliance with the License.
-  You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-  Unless required by applicable law or agreed to in writing, software
-  distributed under the License is distributed on an "AS IS" BASIS,
-  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-  See the License for the specific language governing permissions and
-  limitations under the License.
--->
-<project
-    xmlns="http://maven.apache.org/POM/4.0.0"
-    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-  <groupId>com.squareup.dagger.tests</groupId>
-  <artifactId>static-injected-binding-doesnt-fail-providers</artifactId>
-  <version>@dagger.version@</version>
-  <packaging>jar</packaging>
-  <name>Dagger Integration Test Basic</name>
-  <dependencies>
-    <dependency>
-      <groupId>@dagger.groupId@</groupId>
-      <artifactId>dagger</artifactId>
-      <version>@dagger.version@</version>
-    </dependency>
-    <dependency>
-      <groupId>@dagger.groupId@</groupId>
-      <artifactId>dagger-compiler</artifactId>
-      <version>@dagger.version@</version>
-      <optional>true</optional>
-    </dependency>
-  </dependencies>
-  <build>
-    <plugins>
-      <plugin>
-        <artifactId>maven-compiler-plugin</artifactId>
-        <version>3.1</version>
-        <configuration>
-          <source>1.5</source>
-          <target>1.5</target>
-        </configuration>
-      </plugin>
-    </plugins>
-  </build>
-</project>
diff --git a/compiler/src/it/static-injected-binding-doesnt-fail-providers/src/main/java/test/Test.java b/compiler/src/it/static-injected-binding-doesnt-fail-providers/src/main/java/test/Test.java
deleted file mode 100644
index 450f7948a..000000000
--- a/compiler/src/it/static-injected-binding-doesnt-fail-providers/src/main/java/test/Test.java
+++ /dev/null
@@ -1,38 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package test;
-
-import dagger.Module;
-
-import dagger.ObjectGraph;
-import dagger.Provides;
-import javax.inject.Inject;
-
-import java.lang.Override;
-
-public class Test {
-
-  public static class InjectsOneField {
-    @Inject static String staticallyInjectedString;
-  }
-
-  @Module(staticInjections = { InjectsOneField.class })
-  public static class TestModule {
-    @Provides String string() {
-      return "string";
-    }
-  }
-}
diff --git a/compiler/src/it/uninjectable-supertype/pom.xml b/compiler/src/it/uninjectable-supertype/pom.xml
deleted file mode 100644
index 84f323f4c..000000000
--- a/compiler/src/it/uninjectable-supertype/pom.xml
+++ /dev/null
@@ -1,52 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--
- Copyright (C) 2012 Square, Inc.
- Copyright (C) 2012 Google, Inc.
-
-  Licensed under the Apache License, Version 2.0 (the "License");
-  you may not use this file except in compliance with the License.
-  You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-  Unless required by applicable law or agreed to in writing, software
-  distributed under the License is distributed on an "AS IS" BASIS,
-  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-  See the License for the specific language governing permissions and
-  limitations under the License.
--->
-<project
-    xmlns="http://maven.apache.org/POM/4.0.0"
-    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-  <groupId>com.example.dagger.tests</groupId>
-  <artifactId>uninjectable-supertype</artifactId>
-  <version>HEAD-SNAPSHOT</version>
-  <name>Dagger Integration Test Basic</name>
-  <dependencies>
-    <dependency>
-      <groupId>@dagger.groupId@</groupId>
-      <artifactId>dagger</artifactId>
-      <version>@dagger.version@</version>
-    </dependency>
-    <dependency>
-      <groupId>@dagger.groupId@</groupId>
-      <artifactId>dagger-compiler</artifactId>
-      <version>@dagger.version@</version>
-      <optional>true</optional>
-    </dependency>
-  </dependencies>
-  <build>
-    <plugins>
-      <plugin>
-        <artifactId>maven-compiler-plugin</artifactId>
-        <version>3.1</version>
-        <configuration>
-          <source>1.5</source>
-          <target>1.5</target>
-        </configuration>
-      </plugin>
-    </plugins>
-  </build>
-</project>
diff --git a/compiler/src/it/uninjectable-supertype/src/main/java/test/TestApp.java b/compiler/src/it/uninjectable-supertype/src/main/java/test/TestApp.java
deleted file mode 100644
index fa6d4cb17..000000000
--- a/compiler/src/it/uninjectable-supertype/src/main/java/test/TestApp.java
+++ /dev/null
@@ -1,36 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package test;
-
-import dagger.Module;
-import dagger.Provides;
-import javax.inject.Inject;
-
-class TestApp {
-  static class NotInjectable {
-  }
-
-  static class InjectableSubclass extends NotInjectable {
-    @Inject String string;
-  }
-
-  @Module(injects = InjectableSubclass.class)
-  static class TestModule {
-    @Provides String provideString() {
-      return "string";
-    }
-  }
-}
diff --git a/compiler/src/it/valid-use-of-qualifiers/pom.xml b/compiler/src/it/valid-use-of-qualifiers/pom.xml
deleted file mode 100644
index 50bac37d5..000000000
--- a/compiler/src/it/valid-use-of-qualifiers/pom.xml
+++ /dev/null
@@ -1,53 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!--
- Copyright (C) 2013 Google, Inc.
- Copyright (C) 2013 Square, Inc.
-
-  Licensed under the Apache License, Version 2.0 (the "License");
-  you may not use this file except in compliance with the License.
-  You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-  Unless required by applicable law or agreed to in writing, software
-  distributed under the License is distributed on an "AS IS" BASIS,
-  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-  See the License for the specific language governing permissions and
-  limitations under the License.
--->
-<project
-    xmlns="http://maven.apache.org/POM/4.0.0"
-    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-  <groupId>com.example.dagger.tests</groupId>
-  <artifactId>valid-use-ofqualifiers</artifactId>
-  <version>HEAD-SNAPSHOT</version>
-  <name>Dagger Integration Test Basic</name>
-  <dependencies>
-    <dependency>
-      <groupId>@dagger.groupId@</groupId>
-      <artifactId>dagger</artifactId>
-      <version>@dagger.version@</version>
-    </dependency>
-    <dependency>
-      <groupId>@dagger.groupId@</groupId>
-      <artifactId>dagger-compiler</artifactId>
-      <version>@dagger.version@</version>
-      <optional>true</optional>
-    </dependency>
-  </dependencies>
-  <build>
-    <plugins>
-      <plugin>
-        <artifactId>maven-compiler-plugin</artifactId>
-        <version>3.1</version>
-        <configuration>
-          <source>1.5</source>
-          <target>1.5</target>
-          <showWarnings>true</showWarnings>
-        </configuration>
-      </plugin>
-    </plugins>
-  </build>
-</project>
diff --git a/compiler/src/it/valid-use-of-qualifiers/src/main/java/test/TestApp.java b/compiler/src/it/valid-use-of-qualifiers/src/main/java/test/TestApp.java
deleted file mode 100644
index da21df53d..000000000
--- a/compiler/src/it/valid-use-of-qualifiers/src/main/java/test/TestApp.java
+++ /dev/null
@@ -1,63 +0,0 @@
-/*
- * Copyright (C) 2013 Google, Inc.
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package test;
-
-import dagger.Module;
-import dagger.Provides;
-import java.lang.annotation.Retention;
-import javax.inject.Inject;
-import javax.inject.Qualifier;
-
-import static java.lang.annotation.RetentionPolicy.RUNTIME;
-
-class TestApp {
-  static class TestClass1 {
-    @Inject @MyQualifier1 String field;
-  }
-  
-  static class TestClass2 {
-    String string;
-    
-    @Inject
-    public TestClass2(@MyQualifier1 String constructorParam) {
-      this.string = string;
-    }
-  }
-
-  @Module(injects = TestClass1.class)
-  static class TestModule {
-
-    @Provides
-    @MyQualifier1
-    String providesString(@MyQualifier2 String providesMethodParam) {
-      return providesMethodParam + "foo";
-    }
-    
-    @Provides
-    @MyQualifier2
-    String providesString() {
-      return "foo";
-    }
-  }
-  @Qualifier
-  @Retention(value = RUNTIME)
-  @interface MyQualifier1 {}
-  
-  @Qualifier
-  @Retention(value = RUNTIME)
-  @interface MyQualifier2 {}
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
index 0c6855c6a..69a4a0521 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
@@ -557,8 +557,8 @@ private static Snippet initializeMembersInjectorForBinding(
   private static List<Snippet> getDependencyParameters(Iterable<DependencyRequest> dependencies,
       ImmutableMap<Key, Snippet> memberSelectSnippets) {
     ImmutableList.Builder<Snippet> parameters = ImmutableList.builder();
-    for (DependencyRequest dependency : dependencies) {
-      parameters.add(memberSelectSnippets.get(dependency.key()));
+    for (Key dependencyKey : SourceFiles.indexDependenciesByKey(dependencies).keySet()) {
+      parameters.add(memberSelectSnippets.get(dependencyKey));
     }
     return parameters.build();
   }
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
index 6a0a04a86..dfd68f090 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
@@ -59,6 +59,17 @@ public int compare(DependencyRequest left, DependencyRequest right) {
     }
   };
 
+  static ImmutableSetMultimap<Key, DependencyRequest> indexDependenciesByKey(
+      Iterable<? extends DependencyRequest> dependencies) {
+    ImmutableSetMultimap.Builder<Key, DependencyRequest> dependenciesByKeyBuilder =
+        new ImmutableSetMultimap.Builder<Key, DependencyRequest>().orderValuesBy(
+            DEPENDENCY_ORDERING);
+    for (DependencyRequest dependency : dependencies) {
+      dependenciesByKeyBuilder.put(dependency.key(), dependency);
+    }
+    return dependenciesByKeyBuilder.build();
+  }
+
   /**
    * This method generates names for the {@link Provider} references necessary for all of the
    * bindings. It is responsible for the following:
@@ -74,14 +85,8 @@ public int compare(DependencyRequest left, DependencyRequest right) {
    */
   static ImmutableMap<Key, String> generateFrameworkReferenceNamesForDependencies(
       Iterable<? extends DependencyRequest> dependencies) {
-    ImmutableSetMultimap.Builder<Key, DependencyRequest> dependenciesByKeyBuilder =
-        new ImmutableSetMultimap.Builder<Key, DependencyRequest>().orderValuesBy(
-            DEPENDENCY_ORDERING);
-    for (DependencyRequest dependency : dependencies) {
-      dependenciesByKeyBuilder.put(dependency.key(), dependency);
-    }
     ImmutableSetMultimap<Key, DependencyRequest> dependenciesByKey =
-        dependenciesByKeyBuilder.build();
+        indexDependenciesByKey(dependencies);
     Map<Key, Collection<DependencyRequest>> dependenciesByKeyMap = dependenciesByKey.asMap();
     ImmutableMap.Builder<Key, String> providerNames = ImmutableMap.builder();
     for (Entry<Key, Collection<DependencyRequest>> entry : dependenciesByKeyMap.entrySet()) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/dagger1/AdapterJavadocs.java b/compiler/src/main/java/dagger/internal/codegen/dagger1/AdapterJavadocs.java
deleted file mode 100644
index bd289ec31..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/dagger1/AdapterJavadocs.java
+++ /dev/null
@@ -1,72 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- * Copyright (C) 2013 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen.dagger1;
-
-/**
- * Utility class providing some commonly used boilerplate between {@code InjectAdapterProcessor}
- * and {@code ModuleAdapterProcessor}.
- */
-public final class AdapterJavadocs {
-  static final String GENERATED_BY_DAGGER = "Code generated by dagger-compiler.  Do not edit.";
-  static final String MEMBERS_INJECT_METHOD = ""
-      + "Injects any {@code @Inject} annotated fields in the given instance,\n"
-      + "satisfying the contract for {@code Provider<%s>}.";
-  static final String GET_METHOD = ""
-      + "Returns the fully provisioned instance satisfying the contract for\n"
-      + "{@code Provider<%s>}.";
-  static final String GET_DEPENDENCIES_METHOD = ""
-      + "Used internally obtain dependency information, such as for cyclical\n"
-      + "graph detection.";
-  static final String ATTACH_METHOD = ""
-      + "Used internally to link bindings/providers together at run time\n"
-      + "according to their dependency graph.";
-  static final String STATIC_INJECT_METHOD = ""
-      + "Performs the injections of dependencies into static fields when requested by\n"
-      + "the {@code dagger.ObjectGraph}.";
-  static final String MODULE_TYPE = ""
-      + "A manager of modules and provides adapters allowing for proper linking and\n"
-      + "instance provision of types served by {@code @Provides} methods.";
-  static final String STATIC_INJECTION_TYPE = ""
-      + "A manager for {@code %s}'s injections into static fields.";
-  static final String PARENT_ADAPTER_TYPE = ""
-      + "An internal adapter used to provide InjectAdapters with access to their injected\n"
-      + "type's inheritance hierarchy allowing members injection, linker attachment,/n"
-      + "and dependency collection.";
-
-  /** Creates an appropriate javadoc depending on aspects of the type in question. */
-  static String bindingTypeDocs(String type, boolean abstrakt, boolean members, boolean dependent) {
-    StringBuffer sb = new StringBuffer();
-    sb.append("A {@code Binding<").append(type).append(">} implementation which satisfies\n");
-    sb.append("Dagger's infrastructure requirements including:");
-    if (dependent) {
-      sb.append("\n\n");
-      sb.append("Owning the dependency links between {@code " + type + "} and its\n");
-      sb.append("dependencies.");
-    }
-    if (!abstrakt) {
-      sb.append("\n\n");
-      sb.append("Being a {@code Provider<" + type + ">} and handling creation and\n");
-      sb.append("preparation of object instances.");
-    }
-    if (members) {
-      sb.append("\n\n");
-      sb.append("Being a {@code MembersInjector<" + type + ">} and handling injection\n");
-      sb.append("of annotated fields.");
-    }
-    return sb.toString();
-  }
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/dagger1/GeneratorKeys.java b/compiler/src/main/java/dagger/internal/codegen/dagger1/GeneratorKeys.java
deleted file mode 100644
index cddc4390f..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/dagger1/GeneratorKeys.java
+++ /dev/null
@@ -1,118 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen.dagger1;
-
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-import javax.inject.Qualifier;
-import javax.lang.model.element.AnnotationMirror;
-import javax.lang.model.element.AnnotationValue;
-import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.VariableElement;
-import javax.lang.model.type.TypeMirror;
-
-import static dagger.internal.codegen.dagger1.Util.rawTypeToString;
-import static dagger.internal.codegen.dagger1.Util.typeToString;
-
-/**
- * Creates keys using javac's mirror APIs. Unlike {@code Keys}, this class uses
- * APIs not available on Android.
- */
-final class GeneratorKeys {
-  private static final String SET_PREFIX = Set.class.getCanonicalName() + "<";
-
-  private GeneratorKeys() {
-  }
-
-  /**
-   * Returns the members injector key for the raw type of {@code type}.
-   * Parameterized types are not currently supported for members injection in
-   * generated code.
-   */
-  public static String rawMembersKey(TypeMirror type) {
-    return "members/" + rawTypeToString(type, '$');
-  }
-
-  /** Returns the provider key for {@code type}. */
-  public static String get(TypeMirror type) {
-    StringBuilder result = new StringBuilder();
-    typeToString(type, result, '$');
-    return result.toString();
-  }
-
-  /** Returns the provided key for {@code method}. */
-  public static String get(ExecutableElement method) {
-    StringBuilder result = new StringBuilder();
-    AnnotationMirror qualifier = getQualifier(method.getAnnotationMirrors());
-    if (qualifier != null) {
-      qualifierToString(qualifier, result);
-    }
-    typeToString(method.getReturnType(), result, '$');
-    return result.toString();
-  }
-
-  /** Returns the provided key for {@code method} wrapped by {@code Set}. */
-  public static String getSetKey(ExecutableElement method) {
-    StringBuilder result = new StringBuilder();
-    AnnotationMirror qualifier = getQualifier(method.getAnnotationMirrors());
-    if (qualifier != null) {
-      qualifierToString(qualifier, result);
-    }
-    result.append(SET_PREFIX);
-    typeToString(method.getReturnType(), result, '$');
-    result.append(">");
-    return result.toString();
-  }
-
-  /** Returns the provider key for {@code variable}. */
-  public static String get(VariableElement variable) {
-    StringBuilder result = new StringBuilder();
-    AnnotationMirror qualifier = getQualifier(variable.getAnnotationMirrors());
-    if (qualifier != null) {
-      qualifierToString(qualifier, result);
-    }
-    typeToString(variable.asType(), result, '$');
-    return result.toString();
-  }
-
-  private static void qualifierToString(AnnotationMirror qualifier, StringBuilder result) {
-    // TODO: guarantee that element values are sorted by name (if there are multiple)
-    result.append('@');
-    typeToString(qualifier.getAnnotationType(), result, '$');
-    result.append('(');
-    for (Map.Entry<? extends ExecutableElement, ? extends AnnotationValue> entry
-        : qualifier.getElementValues().entrySet()) {
-      result.append(entry.getKey().getSimpleName());
-      result.append('=');
-      result.append(entry.getValue().getValue());
-    }
-    result.append(")/");
-  }
-
-  /** Does not test for multiple qualifiers. This is tested in {@code ValidationProcessor}.  */
-  private static AnnotationMirror getQualifier(
-      List<? extends AnnotationMirror> annotations) {
-    AnnotationMirror qualifier = null;
-    for (AnnotationMirror annotation : annotations) {
-      if (annotation.getAnnotationType().asElement().getAnnotation(Qualifier.class) == null) {
-        continue;
-      }
-      qualifier = annotation;
-    }
-    return qualifier;
-  }
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/dagger1/GraphAnalysisErrorHandler.java b/compiler/src/main/java/dagger/internal/codegen/dagger1/GraphAnalysisErrorHandler.java
deleted file mode 100644
index d7ba79704..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/dagger1/GraphAnalysisErrorHandler.java
+++ /dev/null
@@ -1,44 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen.dagger1;
-
-import dagger.internal.Linker;
-import java.util.List;
-import javax.annotation.processing.ProcessingEnvironment;
-import javax.lang.model.element.TypeElement;
-import javax.tools.Diagnostic;
-
-/**
- * A {@code Linker.ErrorHandler} which gathers errors and reports them via a processing
- * environment.
- */
-final class GraphAnalysisErrorHandler implements Linker.ErrorHandler {
-  private final ProcessingEnvironment processingEnv;
-  private final String moduleName;
-
-  GraphAnalysisErrorHandler(ProcessingEnvironment processingEnv, String moduleName) {
-    this.processingEnv = processingEnv;
-    this.moduleName = moduleName;
-  }
-
-  @Override public void handleErrors(List<String> errors) {
-    TypeElement module = processingEnv.getElementUtils().getTypeElement(moduleName);
-    for (String error : errors) {
-      processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, error + " for " + moduleName,
-          module);
-    }
-  }
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/dagger1/GraphAnalysisInjectBinding.java b/compiler/src/main/java/dagger/internal/codegen/dagger1/GraphAnalysisInjectBinding.java
deleted file mode 100644
index 4bd7106f3..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/dagger1/GraphAnalysisInjectBinding.java
+++ /dev/null
@@ -1,147 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen.dagger1;
-
-import dagger.internal.Binding;
-import dagger.internal.Linker;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.List;
-import java.util.Set;
-import javax.inject.Inject;
-import javax.inject.Singleton;
-import javax.lang.model.element.Element;
-import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.Modifier;
-import javax.lang.model.element.TypeElement;
-import javax.lang.model.element.VariableElement;
-import javax.lang.model.type.TypeMirror;
-
-import static com.google.auto.common.MoreElements.isAnnotationPresent;
-import static dagger.internal.codegen.dagger1.Util.getApplicationSupertype;
-
-/**
- * A build time binding that injects the constructor and fields of a class.
- */
-final class GraphAnalysisInjectBinding extends Binding<Object> {
-  private final TypeElement type;
-  private final List<String> keys;
-  private final Binding<?>[] bindings;
-  private final String supertypeKey;
-
-  private GraphAnalysisInjectBinding(String provideKey, String membersKey,
-      TypeElement type, List<String> keys, String supertypeKey) {
-    super(provideKey, membersKey, isAnnotationPresent(type, Singleton.class),
-        type.getQualifiedName().toString());
-    this.type = type;
-    this.keys = keys;
-    this.bindings = new Binding<?>[keys.size()];
-    this.supertypeKey = supertypeKey;
-  }
-
-  static GraphAnalysisInjectBinding create(TypeElement type, boolean mustHaveInjections) {
-    List<String> requiredKeys = new ArrayList<String>();
-    boolean hasInjectConstructor = false;
-    boolean hasNoArgsConstructor = false;
-
-    for (Element enclosed : type.getEnclosedElements()) {
-      switch (enclosed.getKind()) {
-      case FIELD:
-        if (hasAtInject(enclosed) && !enclosed.getModifiers().contains(Modifier.STATIC)) {
-          // Attach the non-static fields of 'type'.
-          requiredKeys.add(GeneratorKeys.get((VariableElement) enclosed));
-        }
-        break;
-
-      case CONSTRUCTOR:
-        ExecutableElement constructor = (ExecutableElement) enclosed;
-        List<? extends VariableElement> parameters = constructor.getParameters();
-        if (hasAtInject(enclosed)) {
-          if (hasAtSingleton(enclosed)) {
-            throw new IllegalArgumentException("Singleton annotations have no effect on "
-                + "constructors. Did you mean to annotate the class? "
-                + type.getQualifiedName().toString());
-          }
-          if (hasInjectConstructor) {
-            throw new IllegalArgumentException("Too many injectable constructors on "
-                + type.getQualifiedName().toString());
-          }
-          hasInjectConstructor = true;
-          for (VariableElement parameter : parameters) {
-            requiredKeys.add(GeneratorKeys.get(parameter));
-          }
-        } else if (parameters.isEmpty()) {
-          hasNoArgsConstructor = true;
-        }
-        break;
-
-      default:
-        if (hasAtInject(enclosed)) {
-          throw new IllegalArgumentException("Unexpected @Inject annotation on " + enclosed);
-        }
-      }
-    }
-
-    if (!hasInjectConstructor && requiredKeys.isEmpty() && mustHaveInjections) {
-      throw new IllegalArgumentException("No injectable members on "
-          + type.getQualifiedName().toString() + ". Do you want to add an injectable constructor?");
-    }
-
-    // Attach the supertype.
-    TypeMirror supertype = getApplicationSupertype(type);
-    String supertypeKey = supertype != null
-        ? GeneratorKeys.rawMembersKey(supertype)
-        : null;
-
-    String provideKey = hasInjectConstructor || (hasNoArgsConstructor && !requiredKeys.isEmpty())
-        ? GeneratorKeys.get(type.asType())
-        : null;
-    String membersKey = GeneratorKeys.rawMembersKey(type.asType());
-    return new GraphAnalysisInjectBinding(provideKey, membersKey, type, requiredKeys, supertypeKey);
-  }
-
-  private static boolean hasAtInject(Element enclosed) {
-    return isAnnotationPresent(enclosed, Inject.class);
-  }
-
-  private static boolean hasAtSingleton(Element enclosed) {
-    return isAnnotationPresent(enclosed, Singleton.class);
-  }
-
-  @Override public void attach(Linker linker) {
-    String requiredBy = type.getQualifiedName().toString();
-    for (int i = 0; i < keys.size(); i++) {
-      bindings[i] = linker.requestBinding(keys.get(i), requiredBy,
-          getClass().getClassLoader());
-    }
-    if (supertypeKey != null) {
-      // Force the binding lookup.
-      linker.requestBinding(supertypeKey, requiredBy, getClass().getClassLoader(), false, true);
-    }
-  }
-
-  @Override public Object get() {
-    throw new AssertionError("Compile-time binding should never be called to inject.");
-  }
-
-  @Override public void injectMembers(Object t) {
-    throw new AssertionError("Compile-time binding should never be called to inject.");
-  }
-
-  @Override public void getDependencies(Set<Binding<?>> get, Set<Binding<?>> injectMembers) {
-    Collections.addAll(get, bindings);
-  }
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/dagger1/GraphAnalysisLoader.java b/compiler/src/main/java/dagger/internal/codegen/dagger1/GraphAnalysisLoader.java
deleted file mode 100644
index 78ac9ecd9..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/dagger1/GraphAnalysisLoader.java
+++ /dev/null
@@ -1,64 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen.dagger1;
-
-import dagger.internal.Binding;
-import dagger.internal.Loader;
-import dagger.internal.ModuleAdapter;
-import dagger.internal.StaticInjection;
-import javax.annotation.processing.ProcessingEnvironment;
-import javax.lang.model.element.ElementKind;
-import javax.lang.model.element.TypeElement;
-
-/**
- * A {@code Binding.Resolver} suitable for tool use at build time. The bindings created by
- * this {@code Binding.Resolver} have the correct dependency graph, but do not implement
- * {@link Binding#get} or {@link Binding#injectMembers} methods. They are only suitable
- * for graph analysis and error detection.
- */
-public final class GraphAnalysisLoader extends Loader {
-
-  private final ProcessingEnvironment processingEnv;
-
-  public GraphAnalysisLoader(ProcessingEnvironment processingEnv) {
-    this.processingEnv = processingEnv;
-  }
-
-  @Override public Binding<?> getAtInjectBinding(
-      String key, String className, ClassLoader classLoader, boolean mustHaveInjections) {
-    String sourceClassName = className.replace('$', '.');
-    TypeElement type = processingEnv.getElementUtils().getTypeElement(sourceClassName);
-    if (type == null) {
-      // We've encountered a type that the compiler can't introspect. If this
-      // causes problems in practice (due to incremental compiles, etc.) we
-      // should return a new unresolved binding and warn about the possibility
-      // of runtime failures.
-      return null;
-    }
-    if (type.getKind() == ElementKind.INTERFACE) {
-      return null;
-    }
-    return GraphAnalysisInjectBinding.create(type, mustHaveInjections);
-  }
-
-  @Override public <T> ModuleAdapter<T> getModuleAdapter(Class<T> moduleClass) {
-    throw new UnsupportedOperationException();
-  }
-
-  @Override public StaticInjection getStaticInjection(Class<?> injectedClass) {
-    throw new UnsupportedOperationException();
-  }
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/dagger1/GraphAnalysisProcessor.java b/compiler/src/main/java/dagger/internal/codegen/dagger1/GraphAnalysisProcessor.java
deleted file mode 100644
index a2ee6a642..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/dagger1/GraphAnalysisProcessor.java
+++ /dev/null
@@ -1,395 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen.dagger1;
-
-import com.google.auto.service.AutoService;
-import dagger.Module;
-import dagger.Provides;
-import dagger.internal.Binding;
-import dagger.internal.Binding.InvalidBindingException;
-import dagger.internal.BindingsGroup;
-import dagger.internal.Linker;
-import dagger.internal.ProblemDetector;
-import dagger.internal.ProvidesBinding;
-import dagger.internal.SetBinding;
-import dagger.internal.codegen.dagger1.Util.CodeGenerationIncompleteException;
-import java.io.IOException;
-import java.io.PrintWriter;
-import java.io.StringWriter;
-import java.io.Writer;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.Deque;
-import java.util.LinkedHashMap;
-import java.util.LinkedHashSet;
-import java.util.LinkedList;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-import javax.annotation.processing.AbstractProcessor;
-import javax.annotation.processing.Processor;
-import javax.annotation.processing.RoundEnvironment;
-import javax.annotation.processing.SupportedAnnotationTypes;
-import javax.inject.Singleton;
-import javax.lang.model.SourceVersion;
-import javax.lang.model.element.Element;
-import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.TypeElement;
-import javax.lang.model.element.VariableElement;
-import javax.lang.model.type.TypeMirror;
-import javax.lang.model.util.Elements;
-import javax.lang.model.util.Types;
-import javax.tools.Diagnostic;
-import javax.tools.FileObject;
-import javax.tools.JavaFileManager;
-import javax.tools.StandardLocation;
-
-import static com.google.auto.common.MoreElements.isAnnotationPresent;
-import static dagger.Provides.Type.SET;
-import static dagger.Provides.Type.SET_VALUES;
-import static dagger.internal.codegen.dagger1.Util.className;
-import static dagger.internal.codegen.dagger1.Util.getAnnotation;
-import static dagger.internal.codegen.dagger1.Util.getPackage;
-import static dagger.internal.codegen.dagger1.Util.isInterface;
-import static java.util.Arrays.asList;
-
-/**
- * Performs full graph analysis on a module.
- */
-@AutoService(Processor.class)
-@SupportedAnnotationTypes("dagger.Module")
-public final class GraphAnalysisProcessor extends AbstractProcessor {
-  private static final Set<String> ERROR_NAMES_TO_PROPAGATE = new LinkedHashSet<String>(asList(
-      "com.sun.tools.javac.code.Symbol$CompletionFailure"));
-
-  private final Set<String> delayedModuleNames = new LinkedHashSet<String>();
-
-  @Override public SourceVersion getSupportedSourceVersion() {
-    return SourceVersion.latestSupported();
-  }
-
-  /**
-   * Perform full-graph analysis on complete modules. This checks that all of
-   * the module's dependencies are satisfied.
-   */
-  @Override public boolean process(Set<? extends TypeElement> types, RoundEnvironment env) {
-    if (!env.processingOver()) {
-      // Storing module names for later retrieval as the element instance is invalidated across
-      // passes.
-      for (Element e : env.getElementsAnnotatedWith(Module.class)) {
-        if (!(e instanceof TypeElement)) {
-          error("@Module applies to a type, " + e.getSimpleName() + " is a " + e.getKind(), e);
-          continue;
-        }
-        delayedModuleNames.add(((TypeElement) e).getQualifiedName().toString());
-      }
-      return false;
-    }
-
-    Set<Element> modules = new LinkedHashSet<Element>();
-    for (String moduleName : delayedModuleNames) {
-      modules.add(elements().getTypeElement(moduleName));
-    }
-
-    for (Element element : modules) {
-      if (element == null) {
-        continue; // skip this element. An up-stream compiler error is in play.
-      }
-      Map<String, Object> annotation = null;
-      try {
-        annotation = getAnnotation(Module.class, element);
-      } catch (CodeGenerationIncompleteException e) {
-        continue; // skip this element. An up-stream compiler error is in play.
-      }
-
-      TypeElement moduleType = (TypeElement) element;
-      if (annotation == null) {
-        error("Missing @Module annotation.", moduleType);
-        continue;
-      }
-      if (annotation.get("complete").equals(Boolean.TRUE)) {
-        Map<String, Binding<?>> bindings;
-        try {
-          bindings = processCompleteModule(moduleType, false);
-          new ProblemDetector().detectCircularDependencies(bindings.values());
-        } catch (ModuleValidationException e) {
-          error("Graph validation failed: " + e.getMessage(), e.source);
-          continue;
-        } catch (InvalidBindingException e) {
-          error("Graph validation failed: " + e.getMessage(), elements().getTypeElement(e.type));
-          continue;
-        } catch (RuntimeException e) {
-          if (ERROR_NAMES_TO_PROPAGATE.contains(e.getClass().getName())) {
-            throw e;
-          }
-          error("Unknown error " + e.getClass().getName() + " thrown by javac in graph validation: "
-              + e.getMessage(), moduleType);
-          continue;
-        }
-        try {
-          writeDotFile(moduleType, bindings);
-        } catch (IOException e) {
-          StringWriter sw = new StringWriter();
-          e.printStackTrace(new PrintWriter(sw));
-          processingEnv.getMessager()
-              .printMessage(Diagnostic.Kind.WARNING,
-                  "Graph visualization failed. Please report this as a bug.\n\n" + sw, moduleType);
-        }
-      }
-
-      if (annotation.get("library").equals(Boolean.FALSE)) {
-        Map<String, Binding<?>> bindings = processCompleteModule(moduleType, true);
-        try {
-          new ProblemDetector().detectUnusedBinding(bindings.values());
-        } catch (IllegalStateException e) {
-          error("Graph validation failed: " + e.getMessage(), moduleType);
-        }
-      }
-    }
-    return false;
-  }
-
-  private void error(String message, Element element) {
-    processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, message, element);
-  }
-
-  private Map<String, Binding<?>> processCompleteModule(TypeElement rootModule,
-      boolean ignoreCompletenessErrors) {
-    Map<String, TypeElement> allModules = new LinkedHashMap<String, TypeElement>();
-    collectIncludesRecursively(rootModule, allModules, new LinkedList<String>());
-    ArrayList<GraphAnalysisStaticInjection> staticInjections =
-        new ArrayList<GraphAnalysisStaticInjection>();
-
-    Linker.ErrorHandler errorHandler = ignoreCompletenessErrors ? Linker.ErrorHandler.NULL
-        : new GraphAnalysisErrorHandler(processingEnv, rootModule.getQualifiedName().toString());
-    Linker linker = new Linker(null, new GraphAnalysisLoader(processingEnv), errorHandler);
-    // Linker requires synchronization for calls to requestBinding and linkAll.
-    // We know statically that we're single threaded, but we synchronize anyway
-    // to make the linker happy.
-    synchronized (linker) {
-      BindingsGroup baseBindings = new BindingsGroup() {
-        @Override public Binding<?> contributeSetBinding(String key, SetBinding<?> value) {
-          return super.put(key, value);
-        }
-      };
-      BindingsGroup overrideBindings = new BindingsGroup() {
-        @Override public Binding<?> contributeSetBinding(String key, SetBinding<?> value) {
-          throw new IllegalStateException("Module overrides cannot contribute set bindings.");
-        }
-      };
-      for (TypeElement module : allModules.values()) {
-        Map<String, Object> annotation = getAnnotation(Module.class, module);
-        boolean overrides = (Boolean) annotation.get("overrides");
-        boolean library = (Boolean) annotation.get("library");
-        BindingsGroup addTo = overrides ? overrideBindings : baseBindings;
-
-        // Gather the injectable types from the annotation.
-        Set<String> injectsProvisionKeys = new LinkedHashSet<String>();
-        for (Object injectableTypeObject : (Object[]) annotation.get("injects")) {
-          TypeMirror injectableType = (TypeMirror) injectableTypeObject;
-          String providerKey = GeneratorKeys.get(injectableType);
-          injectsProvisionKeys.add(providerKey);
-          String key = isInterface(injectableType)
-              ? providerKey
-              : GeneratorKeys.rawMembersKey(injectableType);
-          linker.requestBinding(key, module.getQualifiedName().toString(),
-              getClass().getClassLoader(), false, true);
-        }
-
-        // Gather the static injections.
-        for (Object staticInjection : (Object[]) annotation.get("staticInjections")) {
-          TypeMirror staticInjectionTypeMirror = (TypeMirror) staticInjection;
-          Element element = processingEnv.getTypeUtils().asElement(staticInjectionTypeMirror);
-          staticInjections.add(new GraphAnalysisStaticInjection(element));
-        }
-
-        // Gather the enclosed @Provides methods.
-        for (Element enclosed : module.getEnclosedElements()) {
-          Provides provides = enclosed.getAnnotation(Provides.class);
-          if (provides == null) {
-            continue;
-          }
-          ExecutableElement providerMethod = (ExecutableElement) enclosed;
-          String key = GeneratorKeys.get(providerMethod);
-          ProvidesBinding<?> binding = new ProviderMethodBinding(key, providerMethod, library);
-
-          Binding<?> previous = addTo.get(key);
-          if (previous != null) {
-            if ((provides.type() == SET || provides.type() == SET_VALUES)
-                && previous instanceof SetBinding) {
-              // No duplicate bindings error if both bindings are set bindings.
-            } else {
-              String message = "Duplicate bindings for " + key;
-              if (overrides) {
-                message += " in override module(s) - cannot override an override";
-              }
-              message += ":\n    " + previous.requiredBy + "\n    " + binding.requiredBy;
-              error(message, providerMethod);
-            }
-          }
-
-          switch (provides.type()) {
-            case UNIQUE:
-              if (injectsProvisionKeys.contains(binding.provideKey)) {
-                binding.setDependedOn(true);
-              }
-              try {
-                addTo.contributeProvidesBinding(key, binding);
-              } catch (IllegalStateException ise) {
-                throw new ModuleValidationException(ise.getMessage(), providerMethod);
-              }
-              break;
-
-            case SET:
-              String setKey = GeneratorKeys.getSetKey(providerMethod);
-              SetBinding.add(addTo, setKey, binding);
-              break;
-
-            case SET_VALUES:
-              SetBinding.add(addTo, key, binding);
-              break;
-
-            default:
-              throw new AssertionError("Unknown @Provides type " + provides.type());
-          }
-        }
-      }
-
-      linker.installBindings(baseBindings);
-      linker.installBindings(overrideBindings);
-      for (GraphAnalysisStaticInjection staticInjection : staticInjections) {
-        staticInjection.attach(linker);
-      }
-
-      // Link the bindings. This will traverse the dependency graph, and report
-      // errors if any dependencies are missing.
-      return linker.linkAll();
-    }
-  }
-
-  private Elements elements() {
-    return processingEnv.getElementUtils();
-  }
-
-  void collectIncludesRecursively(
-      TypeElement module, Map<String, TypeElement> result, Deque<String> path) {
-    Map<String, Object> annotation = getAnnotation(Module.class, module);
-    if (annotation == null) {
-      // TODO(user): pass annotation information
-      throw new ModuleValidationException("No @Module on " + module, module);
-    }
-
-    // Add the module.
-    String name = module.getQualifiedName().toString();
-    if (path.contains(name)) {
-      StringBuilder message = new StringBuilder("Module Inclusion Cycle: ");
-      if (path.size() == 1) {
-        message.append(name).append(" includes itself directly.");
-      } else {
-        String current = null;
-        String includer = name;
-        for (int i = 0; path.size() > 0; i++) {
-          current = includer;
-          includer = path.pop();
-          message.append("\n").append(i).append(". ")
-              .append(current).append(" included by ").append(includer);
-        }
-        message.append("\n0. ").append(name);
-      }
-      throw new ModuleValidationException(message.toString(), module);
-    }
-    result.put(name, module);
-
-    // Recurse for each included module.
-    Types types = processingEnv.getTypeUtils();
-    List<Object> seedModules = new ArrayList<Object>();
-    seedModules.addAll(Arrays.asList((Object[]) annotation.get("includes")));
-    if (!annotation.get("addsTo").equals(Void.class)) seedModules.add(annotation.get("addsTo"));
-    for (Object include : seedModules) {
-      if (!(include instanceof TypeMirror)) {
-        // TODO(user): pass annotation information
-        processingEnv.getMessager().printMessage(Diagnostic.Kind.WARNING,
-            "Unexpected value for include: " + include + " in " + module, module);
-        continue;
-      }
-      TypeElement includedModule = (TypeElement) types.asElement((TypeMirror) include);
-      path.push(name);
-      collectIncludesRecursively(includedModule, result, path);
-      path.pop();
-    }
-  }
-
-  static class ProviderMethodBinding extends ProvidesBinding<Object> {
-    private final ExecutableElement method;
-    private final Binding<?>[] parameters;
-
-    protected ProviderMethodBinding(String provideKey, ExecutableElement method, boolean library) {
-      super(provideKey, isAnnotationPresent(method, Singleton.class), className(method),
-          method.getSimpleName().toString());
-      this.method = method;
-      this.parameters = new Binding[method.getParameters().size()];
-      setLibrary(library);
-    }
-
-    @Override public void attach(Linker linker) {
-      for (int i = 0; i < method.getParameters().size(); i++) {
-        VariableElement parameter = method.getParameters().get(i);
-        String parameterKey = GeneratorKeys.get(parameter);
-        parameters[i] = linker.requestBinding(parameterKey, method.toString(),
-            getClass().getClassLoader());
-      }
-    }
-
-    @Override public Object get() {
-      throw new AssertionError("Compile-time binding should never be called to inject.");
-    }
-
-    @Override public void injectMembers(Object t) {
-      throw new AssertionError("Compile-time binding should never be called to inject.");
-    }
-
-    @Override public void getDependencies(Set<Binding<?>> get, Set<Binding<?>> injectMembers) {
-      Collections.addAll(get, parameters);
-    }
-
-    @Override public String toString() {
-      return "ProvidesBinding[key=" + provideKey
-          + " method=" + moduleClass + "." + method.getSimpleName() + "()";
-    }
-  }
-
-  void writeDotFile(TypeElement module, Map<String, Binding<?>> bindings) throws IOException {
-    JavaFileManager.Location location = StandardLocation.SOURCE_OUTPUT;
-    String path = getPackage(module).getQualifiedName().toString();
-    String file = module.getQualifiedName().toString().substring(path.length() + 1) + ".dot";
-    FileObject resource = processingEnv.getFiler().createResource(location, path, file, module);
-
-    Writer writer = resource.openWriter();
-    GraphVizWriter dotWriter = new GraphVizWriter(writer);
-    new GraphVisualizer().write(bindings, dotWriter);
-    dotWriter.close();
-  }
-
-  static class ModuleValidationException extends IllegalStateException {
-    final Element source;
-
-    public ModuleValidationException(String message, Element source) {
-      super(message);
-      this.source = source;
-    }
-  }
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/dagger1/GraphAnalysisStaticInjection.java b/compiler/src/main/java/dagger/internal/codegen/dagger1/GraphAnalysisStaticInjection.java
deleted file mode 100644
index 5ca2d422f..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/dagger1/GraphAnalysisStaticInjection.java
+++ /dev/null
@@ -1,49 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen.dagger1;
-
-import dagger.internal.Linker;
-import dagger.internal.StaticInjection;
-import javax.inject.Inject;
-import javax.lang.model.element.Element;
-
-import static dagger.internal.codegen.dagger1.Util.isStatic;
-
-public final class GraphAnalysisStaticInjection extends StaticInjection {
-
-  private final Element enclosingClass;
-
-  public GraphAnalysisStaticInjection(Element enclosingClass) {
-    this.enclosingClass = enclosingClass;
-  }
-
-  @Override public void attach(Linker linker) {
-    for (Element enclosedElement : enclosingClass.getEnclosedElements()) {
-      if (enclosedElement.getKind().isField() && isStatic(enclosedElement)) {
-        Inject injectAnnotation = enclosedElement.getAnnotation(Inject.class);
-        if (injectAnnotation != null) {
-          String key = GeneratorKeys.get(enclosedElement.asType());
-          linker.requestBinding(key, enclosingClass.toString(),
-              getClass().getClassLoader());
-        }
-      }
-    }
-  }
-
-  @Override public void inject() {
-    throw new UnsupportedOperationException();
-  }
-}
\ No newline at end of file
diff --git a/compiler/src/main/java/dagger/internal/codegen/dagger1/GraphVisualizer.java b/compiler/src/main/java/dagger/internal/codegen/dagger1/GraphVisualizer.java
deleted file mode 100644
index e0c251c9c..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/dagger1/GraphVisualizer.java
+++ /dev/null
@@ -1,139 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen.dagger1;
-
-import dagger.internal.Binding;
-import java.io.IOException;
-import java.util.Comparator;
-import java.util.HashSet;
-import java.util.LinkedHashMap;
-import java.util.Map;
-import java.util.Set;
-import java.util.TreeMap;
-import java.util.TreeSet;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
-
-/**
- * Emits an object graph in dot format.
- */
-public final class GraphVisualizer {
-  private static final Pattern KEY_PATTERN = Pattern.compile(""
-      + "(?:@"            // Full annotation start.
-      + "(?:[\\w$]+\\.)*" // Annotation package
-      + "([\\w$]+)"       // Annotation simple name. Group 1.
-      + "(?:\\(.*\\))?"   // Annotation arguments
-      + "/)?"             // Full annotation end.
-      + "(?:members/)?"   // Members prefix.
-      + "(?:[\\w$]+\\.)*" // Type package.
-      + "([\\w$]+)"       // Type simple name. Group 2.
-      + "(\\<[^/]+\\>)?"  // Type parameters. Group 3.
-      + "((\\[\\])*)"     // Arrays. Group 4.
-      + "");
-
-  public void write(Map<String, Binding<?>> bindings, GraphVizWriter writer) throws IOException {
-    Map<Binding<?>, String> namesIndex = buildNamesIndex(bindings);
-
-    writer.beginGraph("concentrate", "true");
-    for (Map.Entry<Binding<?>, String> entry : namesIndex.entrySet()) {
-      Binding<?> sourceBinding = entry.getKey();
-      String sourceName = entry.getValue();
-      Set<Binding<?>> dependencies = new TreeSet<Binding<?>>(new BindingComparator());
-      sourceBinding.getDependencies(dependencies, dependencies);
-      for (Binding<?> targetBinding : dependencies) {
-        String targetName = namesIndex.get(targetBinding);
-        if (targetName == null) {
-          targetName = "Unbound:" + targetBinding.provideKey;
-        }
-        writer.edge(sourceName, targetName);
-      }
-    }
-    writer.endGraph();
-  }
-
-  private Map<Binding<?>, String> buildNamesIndex(Map<String, Binding<?>> bindings) {
-    // Optimistically shorten each binding to the class short name; remembering collisions.
-    Map<String, Binding<?>> shortNameToBinding = new TreeMap<String, Binding<?>>();
-    Set<Binding<?>> collisions = new HashSet<Binding<?>>();
-    for (Map.Entry<String, Binding<?>> entry : bindings.entrySet()) {
-      String key = entry.getKey();
-      Binding<?> binding = entry.getValue();
-      String shortName = shortName(key);
-      Binding<?> collision = shortNameToBinding.put(shortName, binding);
-      if (collision != null && collision != binding) {
-        collisions.add(binding);
-        collisions.add(collision);
-      }
-    }
-
-    // Replace collisions with full names.
-    for (Map.Entry<String, Binding<?>> entry : bindings.entrySet()) {
-      Binding<?> binding = entry.getValue();
-      if (collisions.contains(binding)) {
-        String key = entry.getKey();
-        String shortName = shortName(key);
-        shortNameToBinding.remove(shortName);
-        shortNameToBinding.put(key, binding);
-      }
-    }
-
-    // Reverse the map.
-    Map<Binding<?>, String> bindingToName = new LinkedHashMap<Binding<?>, String>();
-    for (Map.Entry<String, Binding<?>> entry : shortNameToBinding.entrySet()) {
-      bindingToName.put(entry.getValue(), entry.getKey());
-    }
-
-    return bindingToName;
-  }
-
-  String shortName(String key) {
-    Matcher matcher = KEY_PATTERN.matcher(key);
-    if (!matcher.matches()) throw new IllegalArgumentException("Unexpected key: " + key);
-    StringBuilder result = new StringBuilder();
-
-    String annotationSimpleName = matcher.group(1);
-    if (annotationSimpleName != null) {
-      result.append('@').append(annotationSimpleName).append(' ');
-    }
-
-    String simpleName = matcher.group(2);
-    result.append(simpleName);
-
-    String typeParameters = matcher.group(3);
-    if (typeParameters != null) {
-      result.append(typeParameters);
-    }
-
-    String arrays = matcher.group(4);
-    if (arrays != null) {
-      result.append(arrays);
-    }
-
-    return result.toString();
-  }
-
-  /** A Comparator for Bindings so we can insure a consistent ordering of output. */
-  private static class BindingComparator implements Comparator<Binding<?>> {
-    @Override
-    public int compare(Binding<?> left, Binding<?> right) {
-      return getStringForBinding(left).compareTo(getStringForBinding(right));
-    }
-
-    private String getStringForBinding(Binding<?> binding) {
-      return binding == null ? "" : binding.toString();
-    }
-  }
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/dagger1/GraphVizWriter.java b/compiler/src/main/java/dagger/internal/codegen/dagger1/GraphVizWriter.java
deleted file mode 100644
index 624d1963e..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/dagger1/GraphVizWriter.java
+++ /dev/null
@@ -1,147 +0,0 @@
-/**
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen.dagger1;
-
-import com.squareup.javawriter.JavaWriter;
-import java.io.Closeable;
-import java.io.IOException;
-import java.io.Writer;
-import java.util.LinkedHashMap;
-import java.util.Map;
-
-/**
- * Emits dot graphs.
- */
-public final class GraphVizWriter implements Closeable {
-  private static final String INDENT = "  ";
-  private final Writer out;
-  private int indent = 0;
-  private int nextName = 1;
-  private final Map<String, String> generatedNames = new LinkedHashMap<String, String>();
-
-  /**
-   * @param out the stream to which dot data will be written. This should be a
-   *     buffered stream.
-   */
-  public GraphVizWriter(Writer out) {
-    this.out = out;
-  }
-
-  public void beginGraph(String... attributes) throws IOException {
-    indent();
-    String type = indent == 0 ? "digraph " : "subgraph ";
-    String name = nextName(indent == 0 ? "G" : "cluster");
-    out.write(type);
-    out.write(name);
-    out.write(" {\n");
-    indent++;
-    attributes(attributes);
-  }
-
-  public void endGraph() throws IOException {
-    indent--;
-    indent();
-    out.write("}\n");
-  }
-
-  public void node(String name, String... attributes) throws IOException {
-    name = nodeName(name);
-    indent();
-    out.write(name);
-    inlineAttributes(attributes);
-    out.write(";\n");
-  }
-
-  public void edge(String source, String target, String... attributes) throws IOException {
-    source = nodeName(source);
-    target = nodeName(target);
-    indent();
-    out.write(source);
-    out.write(" -> ");
-    out.write(target);
-    inlineAttributes(attributes);
-    out.write(";\n");
-  }
-
-  public void nodeDefaults(String... attributes) throws IOException {
-    if (attributes.length == 0) return;
-    indent();
-    out.write("node");
-    inlineAttributes(attributes);
-    out.write(";\n");
-  }
-
-  public void edgeDefaults(String... attributes) throws IOException {
-    if (attributes.length == 0) return;
-    indent();
-    out.write("edge");
-    inlineAttributes(attributes);
-    out.write(";\n");
-  }
-
-  private void attributes(String[] attributes) throws IOException {
-    if (attributes.length == 0) return;
-    if (attributes.length % 2 != 0) throw new IllegalArgumentException();
-    for (int i = 0; i < attributes.length; i += 2) {
-      indent();
-      out.write(attributes[i]);
-      out.write(" = ");
-      out.write(literal(attributes[i + 1]));
-      out.write(";\n");
-    }
-  }
-
-  private void inlineAttributes(String[] attributes) throws IOException {
-    if (attributes.length == 0) return;
-    if (attributes.length % 2 != 0) throw new IllegalArgumentException();
-    out.write(" [");
-    for (int i = 0; i < attributes.length; i += 2) {
-      if (i != 0) out.write(";");
-      out.write(attributes[i]);
-      out.write("=");
-      out.write(literal(attributes[i + 1]));
-    }
-    out.write("]");
-  }
-
-  private String nodeName(String name) throws IOException {
-    if (name.matches("\\w+")) return name;
-    String generatedName = generatedNames.get(name);
-    if (generatedName != null) return generatedName;
-    generatedName = nextName("n");
-    generatedNames.put(name, generatedName);
-    node(generatedName, "label", name);
-    return generatedName;
-  }
-
-  private String literal(String raw) {
-    return raw.matches("\\w+") ? raw : JavaWriter.stringLiteral(raw);
-  }
-
-  private void indent() throws IOException {
-    for (int i = 0; i < indent; i++) {
-      out.write(INDENT);
-    }
-  }
-
-  private String nextName(String prefix) {
-    return prefix + (nextName++);
-  }
-
-  @Override public void close() throws IOException {
-    out.close();
-  }
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/dagger1/InjectAdapterProcessor.java b/compiler/src/main/java/dagger/internal/codegen/dagger1/InjectAdapterProcessor.java
deleted file mode 100644
index 7c3b9e271..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/dagger1/InjectAdapterProcessor.java
+++ /dev/null
@@ -1,610 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- * Copyright (C) 2013 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen.dagger1;
-
-import com.google.auto.common.SuperficialValidation;
-import com.google.auto.service.AutoService;
-import com.squareup.javawriter.JavaWriter;
-import dagger.MembersInjector;
-import dagger.internal.Binding;
-import dagger.internal.Linker;
-import dagger.internal.StaticInjection;
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.EnumSet;
-import java.util.Iterator;
-import java.util.LinkedHashSet;
-import java.util.List;
-import java.util.Set;
-import javax.annotation.processing.AbstractProcessor;
-import javax.annotation.processing.Processor;
-import javax.annotation.processing.RoundEnvironment;
-import javax.annotation.processing.SupportedAnnotationTypes;
-import javax.inject.Inject;
-import javax.inject.Provider;
-import javax.inject.Singleton;
-import javax.lang.model.SourceVersion;
-import javax.lang.model.element.Element;
-import javax.lang.model.element.ElementKind;
-import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.TypeElement;
-import javax.lang.model.element.VariableElement;
-import javax.lang.model.type.TypeMirror;
-import javax.tools.Diagnostic;
-import javax.tools.JavaFileObject;
-
-import static com.google.auto.common.MoreElements.isAnnotationPresent;
-import static dagger.internal.Keys.isPlatformType;
-import static dagger.internal.codegen.dagger1.AdapterJavadocs.bindingTypeDocs;
-import static dagger.internal.codegen.dagger1.Util.adapterName;
-import static dagger.internal.codegen.dagger1.Util.elementToString;
-import static dagger.internal.codegen.dagger1.Util.getNoArgsConstructor;
-import static dagger.internal.codegen.dagger1.Util.getPackage;
-import static dagger.internal.codegen.dagger1.Util.isCallableConstructor;
-import static dagger.internal.codegen.dagger1.Util.rawTypeToString;
-import static dagger.internal.codegen.dagger1.Util.typeToString;
-import static dagger.internal.loaders.GeneratedAdapters.INJECT_ADAPTER_SUFFIX;
-import static dagger.internal.loaders.GeneratedAdapters.STATIC_INJECTION_SUFFIX;
-import static javax.lang.model.element.Modifier.ABSTRACT;
-import static javax.lang.model.element.Modifier.FINAL;
-import static javax.lang.model.element.Modifier.PRIVATE;
-import static javax.lang.model.element.Modifier.PUBLIC;
-import static javax.lang.model.element.Modifier.STATIC;
-
-/**
- * Generates an implementation of {@link Binding} that injects the {@literal @}{@code Inject}
- * -annotated members of a class.
- */
-@AutoService(Processor.class)
-@SupportedAnnotationTypes("javax.inject.Inject")
-public final class InjectAdapterProcessor extends AbstractProcessor {
-  private final Set<String> remainingTypeNames = new LinkedHashSet<String>();
-
-  public static final String PARENT_ADAPTER_INFIX = "$$ParentAdapter$$";
-
-  @Override public SourceVersion getSupportedSourceVersion() {
-    return SourceVersion.latestSupported();
-  }
-
-  @Override public boolean process(Set<? extends TypeElement> types, RoundEnvironment env) {
-    remainingTypeNames.addAll(findInjectedClassNames(env));
-    for (Iterator<String> i = remainingTypeNames.iterator(); i.hasNext();) {
-      InjectedClass injectedClass = createInjectedClass(i.next());
-      // Verify that we have access to all types to be injected on this pass.
-      if (SuperficialValidation.validateElement(injectedClass.type)) {
-        try {
-          generateInjectionsForClass(injectedClass);
-        } catch (IOException e) {
-          error("Code gen failed: " + e, injectedClass.type);
-        }
-        i.remove();
-      }
-    }
-    if (env.processingOver() && !remainingTypeNames.isEmpty()) {
-      processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR,
-          "Could not find injection type required by " + remainingTypeNames);
-    }
-    return false;
-  }
-
-  private void generateInjectionsForClass(InjectedClass injectedClass) throws IOException {
-    if (injectedClass.constructor != null || !injectedClass.fields.isEmpty()) {
-      generateInjectAdapter(injectedClass.type, injectedClass.constructor, injectedClass.fields);
-    }
-    if (!injectedClass.staticFields.isEmpty()) {
-      generateStaticInjection(injectedClass.type, injectedClass.staticFields);
-    }
-  }
-
-  private Set<String> findInjectedClassNames(RoundEnvironment env) {
-    // First gather the set of classes that have @Inject-annotated members.
-    Set<String> injectedTypeNames = new LinkedHashSet<String>();
-    for (Element element : env.getElementsAnnotatedWith(Inject.class)) {
-      if (!validateInjectable(element)) {
-        continue;
-      }
-      injectedTypeNames.add(rawTypeToString(element.getEnclosingElement().asType(), '.'));
-    }
-    return injectedTypeNames;
-  }
-
-  private boolean validateInjectable(Element injectable) {
-    Element injectableType = injectable.getEnclosingElement();
-
-    if (injectable.getKind() == ElementKind.CLASS) {
-      error("@Inject is not valid on a class: " + elementToString(injectable), injectable);
-      return false;
-    }
-
-    if (injectable.getKind() == ElementKind.METHOD) {
-      error("Method injection is not supported: " + elementToString(injectable), injectable);
-      return false;
-    }
-
-    if (injectable.getKind() == ElementKind.FIELD
-        && injectable.getModifiers().contains(FINAL)) {
-      error("Can't inject a final field: " + elementToString(injectable), injectable);
-      return false;
-    }
-
-    if (injectable.getKind() == ElementKind.FIELD
-        && injectable.getModifiers().contains(PRIVATE)) {
-      error("Can't inject a private field: " + elementToString(injectable), injectable);
-      return false;
-    }
-
-    if (injectable.getKind() == ElementKind.CONSTRUCTOR
-        && injectable.getModifiers().contains(PRIVATE)) {
-      error("Can't inject a private constructor: " + elementToString(injectable), injectable);
-      return false;
-    }
-
-    ElementKind elementKind = injectableType.getEnclosingElement().getKind();
-    boolean isClassOrInterface = elementKind.isClass() || elementKind.isInterface();
-    boolean isStatic = injectableType.getModifiers().contains(STATIC);
-
-    if (isClassOrInterface && !isStatic) {
-      error("Can't inject a non-static inner class: " + elementToString(injectable),
-          injectableType);
-      return false;
-    }
-
-    return true;
-  }
-
-  /**
-   * @param injectedClassName the name of a class with an @Inject-annotated member.
-   */
-  private InjectedClass createInjectedClass(String injectedClassName) {
-    TypeElement type = processingEnv.getElementUtils().getTypeElement(injectedClassName);
-    boolean isAbstract = type.getModifiers().contains(ABSTRACT);
-    List<Element> staticFields = new ArrayList<Element>();
-    ExecutableElement constructor = null;
-    List<Element> fields = new ArrayList<Element>();
-    for (Element member : type.getEnclosedElements()) {
-      if (member.getAnnotation(Inject.class) == null) {
-        continue;
-      }
-
-      switch (member.getKind()) {
-        case FIELD:
-          if (member.getModifiers().contains(STATIC)) {
-            staticFields.add(member);
-          } else {
-            fields.add(member);
-          }
-          break;
-        case CONSTRUCTOR:
-          if (constructor != null) {
-            // TODO(user): pass annotation information
-            error("Too many injectable constructors on " + type.getQualifiedName(), member);
-          } else if (isAbstract) {
-            // TODO(user): pass annotation information
-            error("Abstract class " + type.getQualifiedName()
-                + " must not have an @Inject-annotated constructor.", member);
-          }
-          constructor = (ExecutableElement) member;
-          break;
-        default:
-          // TODO(user): pass annotation information
-          error("Cannot inject " + elementToString(member), member);
-          break;
-      }
-    }
-
-    if (constructor == null && !isAbstract) {
-      constructor = getNoArgsConstructor(type);
-      if (constructor != null && !isCallableConstructor(constructor)) {
-        constructor = null;
-      }
-    }
-
-    return new InjectedClass(type, staticFields, constructor, fields);
-  }
-
-  /**
-   * Write a companion class for {@code type} that extends {@link Binding}.
-   *
-   * @param constructor the injectable constructor, or null if this binding
-   *     supports members injection only.
-   */
-  private void generateInjectAdapter(TypeElement type, ExecutableElement constructor,
-      List<Element> fields) throws IOException {
-    String packageName = getPackage(type).getQualifiedName().toString();
-    String strippedTypeName =
-        strippedTypeName(type.getQualifiedName().toString(), packageName);
-    TypeMirror supertype = getNextMemberInjectedAncestor(type);
-    String adapterName = adapterName(type, INJECT_ADAPTER_SUFFIX);
-    JavaFileObject sourceFile = processingEnv.getFiler().createSourceFile(adapterName, type);
-    JavaWriter writer = new JavaWriter(sourceFile.openWriter());
-    boolean isAbstract = type.getModifiers().contains(ABSTRACT);
-    boolean injectMembers = !fields.isEmpty() || supertype != null;
-    boolean disambiguateFields = !fields.isEmpty()
-        && (constructor != null)
-        && !constructor.getParameters().isEmpty();
-    boolean dependent = injectMembers
-        || ((constructor != null) && !constructor.getParameters().isEmpty());
-
-    writer.emitSingleLineComment(AdapterJavadocs.GENERATED_BY_DAGGER);
-    writer.emitPackage(packageName);
-    writer.emitImports(findImports(dependent, injectMembers, constructor != null));
-    writer.emitEmptyLine();
-    writer.emitJavadoc(bindingTypeDocs(strippedTypeName, isAbstract, injectMembers, dependent));
-    writer.beginType(adapterName, "class", EnumSet.of(PUBLIC, FINAL),
-        JavaWriter.type(Binding.class, strippedTypeName),
-        implementedInterfaces(strippedTypeName, injectMembers, constructor != null));
-    writeMemberBindingsFields(writer, fields, disambiguateFields);
-    if (constructor != null) {
-      writeParameterBindingsFields(writer, constructor, disambiguateFields);
-     }
-    if (supertype != null) {
-      writeSupertypeInjectorField(writer, type, supertype);
-    }
-    writer.emitEmptyLine();
-    writeInjectAdapterConstructor(writer, constructor, type, strippedTypeName, adapterName);
-    if (dependent) {
-      writeAttachMethod(writer, constructor, fields, disambiguateFields, strippedTypeName,
-          supertype, true);
-      writeGetDependenciesMethod(writer, constructor, fields, disambiguateFields, supertype, true);
-    }
-    if (constructor != null) {
-      writeGetMethod(writer, constructor, disambiguateFields, injectMembers, strippedTypeName);
-    }
-    if (injectMembers) {
-      writeMembersInjectMethod(writer, fields, disambiguateFields, strippedTypeName, supertype);
-    }
-    writer.endType();
-    writer.close();
-    if (supertype != null) {
-      generateParentBindings(type,
-          ((TypeElement) processingEnv.getTypeUtils().asElement(supertype)));
-    }
-  }
-
-  private void generateParentBindings(TypeElement originChild, TypeElement ancestor)
-      throws IOException {
-    List<Element> ancestorFields = createInjectedClass(ancestor.toString()).fields;
-    TypeMirror nextAncestor = getNextMemberInjectedAncestor(ancestor);
-    TypeElement nextAncestorElement =
-        (nextAncestor != null) ? (TypeElement) processingEnv.getTypeUtils().asElement(nextAncestor)
-            : null;
-    String ancestorPackageName = getPackage(ancestor).getQualifiedName().toString();
-    String strippedAncestorType =
-        strippedTypeName(ancestor.getQualifiedName().toString(), ancestorPackageName);
-    String adapterName = parentAdapterName(originChild, ancestor);
-    JavaFileObject sourceFile = processingEnv.getFiler().createSourceFile(adapterName, ancestor);
-    JavaWriter writer = new JavaWriter(sourceFile.openWriter());
-    writer.emitSingleLineComment(AdapterJavadocs.GENERATED_BY_DAGGER);
-    writer.emitPackage(ancestorPackageName);
-    writer.emitImports(MembersInjector.class.getCanonicalName(), Binding.class.getCanonicalName());
-    writer.emitEmptyLine();
-    writer.emitJavadoc(AdapterJavadocs.PARENT_ADAPTER_TYPE);
-    writer.beginType(adapterName, "class", EnumSet.of(PUBLIC, FINAL), null,
-        JavaWriter.type(MembersInjector.class, strippedAncestorType));
-    writeMemberBindingsFields(writer, ancestorFields, false);
-    if (nextAncestor != null) {
-      writeSupertypeInjectorField(writer, originChild, nextAncestor); // next injectable ancestor
-    }
-    writer.emitEmptyLine();
-    writeAttachMethod(writer, null, ancestorFields, false, strippedAncestorType, nextAncestor,
-        false);
-    writeGetDependenciesMethod(writer, null, ancestorFields, false, nextAncestor, false);
-    writeMembersInjectMethod(writer, ancestorFields, false, strippedAncestorType, nextAncestor);
-    writer.endType();
-    writer.close();
-    if (nextAncestor != null) {
-      generateParentBindings(originChild, nextAncestorElement);
-    }
-  }
-
-  /**
-   * Returns the closest ancestor that has members injected or {@code null}
-   * if the class has no ancestors with injected members.
-   */
-  private TypeMirror getNextMemberInjectedAncestor(TypeElement type) {
-    TypeMirror nextAncestor = type.getSuperclass();
-    TypeElement nextAncestorElement =
-        (TypeElement) processingEnv.getTypeUtils().asElement(nextAncestor);
-    if (nextAncestor == null || nextAncestorElement == null) {
-      return null;
-    }
-    if (isPlatformType(nextAncestor.toString())) {
-      return null;
-    }
-    if (!createInjectedClass(nextAncestorElement.toString()).fields.isEmpty()) {
-      return nextAncestor;
-    }
-    return getNextMemberInjectedAncestor(nextAncestorElement);
-  }
-
-  /**
-   * Write a companion class for {@code type} that extends {@link StaticInjection}.
-   */
-  private void generateStaticInjection(TypeElement type, List<Element> fields) throws IOException {
-    String typeName = type.getQualifiedName().toString();
-    String adapterName = adapterName(type, STATIC_INJECTION_SUFFIX);
-    JavaFileObject sourceFile = processingEnv.getFiler()
-        .createSourceFile(adapterName, type);
-    JavaWriter writer = new JavaWriter(sourceFile.openWriter());
-
-    writer.emitSingleLineComment(AdapterJavadocs.GENERATED_BY_DAGGER);
-    writer.emitPackage(getPackage(type).getQualifiedName().toString());
-    writer.emitImports(Arrays.asList(
-        StaticInjection.class.getName(),
-        Binding.class.getName(),
-        Linker.class.getName()));
-    writer.emitEmptyLine();
-    writer.emitJavadoc(AdapterJavadocs.STATIC_INJECTION_TYPE, type.getSimpleName());
-    writer.beginType(
-        adapterName, "class", EnumSet.of(PUBLIC, FINAL), StaticInjection.class.getSimpleName());
-    writeMemberBindingsFields(writer, fields, false);
-    writer.emitEmptyLine();
-    writeAttachMethod(writer, null, fields, false, typeName, null, true);
-    writeStaticInjectMethod(writer, fields, typeName);
-    writer.endType();
-    writer.close();
-  }
-
-  private void writeMemberBindingsFields(
-      JavaWriter writer, List<Element> fields, boolean disambiguateFields) throws IOException {
-    for (Element field : fields) {
-      writer.emitField(JavaWriter.type(Binding.class, typeToString(field.asType())),
-          fieldName(disambiguateFields, field), EnumSet.of(PRIVATE));
-    }
-  }
-
-  private void writeParameterBindingsFields(
-      JavaWriter writer, ExecutableElement constructor, boolean disambiguateFields)
-      throws IOException {
-    for (VariableElement parameter : constructor.getParameters()) {
-      writer.emitField(JavaWriter.type(Binding.class,
-          typeToString(parameter.asType())),
-          parameterName(disambiguateFields, parameter), EnumSet.of(PRIVATE));
-    }
-  }
-
-  private void writeSupertypeInjectorField(
-      JavaWriter writer, TypeElement type, TypeMirror nextAncestor) throws IOException {
-    TypeElement supertypeElement =
-        ((TypeElement) processingEnv.getTypeUtils().asElement(nextAncestor));
-    String adapterName = parentAdapterName(type, supertypeElement);
-    writer.emitField(
-        adapterName, "nextInjectableAncestor", EnumSet.of(PRIVATE), "new " + adapterName + "()");
-  }
-
-  private void writeInjectAdapterConstructor(JavaWriter writer, ExecutableElement constructor,
-      TypeElement type, String strippedTypeName, String adapterName) throws IOException {
-    writer.beginMethod(null, adapterName, EnumSet.of(PUBLIC));
-    String key = (constructor != null)
-        ? JavaWriter.stringLiteral(GeneratorKeys.get(type.asType()))
-        : null;
-    String membersKey = JavaWriter.stringLiteral(GeneratorKeys.rawMembersKey(type.asType()));
-    boolean singleton = isAnnotationPresent(type, Singleton.class);
-    writer.emitStatement("super(%s, %s, %s, %s.class)",
-        key, membersKey, (singleton ? "IS_SINGLETON" : "NOT_SINGLETON"), strippedTypeName);
-    writer.endMethod();
-    writer.emitEmptyLine();
-  }
-
-  /**
-   * Writes the {@code attach()} method for the generated adapters. The {@code supertype} provided
-   * is the next injectable ancestor.
-   */
-  private void writeAttachMethod(JavaWriter writer, ExecutableElement constructor,
-      List<Element> fields, boolean disambiguateFields, String typeName, TypeMirror supertype,
-      boolean extendsBinding) throws IOException {
-    writer.emitJavadoc(AdapterJavadocs.ATTACH_METHOD);
-    if (extendsBinding) {
-      writer.emitAnnotation(Override.class);
-    }
-    writer.emitAnnotation(SuppressWarnings.class, JavaWriter.stringLiteral("unchecked"));
-    writer.beginMethod(
-        "void", "attach", EnumSet.of(PUBLIC), Linker.class.getCanonicalName(), "linker");
-    if (supertype != null) {
-      writer.emitStatement("nextInjectableAncestor.attach(linker)");
-    }
-    if (constructor != null) {
-      for (VariableElement parameter : constructor.getParameters()) {
-        writer.emitStatement(
-            "%s = (%s) linker.requestBinding(%s, %s.class, getClass().getClassLoader())",
-            parameterName(disambiguateFields, parameter),
-            writer.compressType(JavaWriter.type(Binding.class, typeToString(parameter.asType()))),
-            JavaWriter.stringLiteral(GeneratorKeys.get(parameter)), typeName);
-      }
-    }
-    for (Element field : fields) {
-      writer.emitStatement(
-          "%s = (%s) linker.requestBinding(%s, %s.class, getClass().getClassLoader())",
-          fieldName(disambiguateFields, field),
-          writer.compressType(JavaWriter.type(Binding.class, typeToString(field.asType()))),
-          JavaWriter.stringLiteral(GeneratorKeys.get((VariableElement) field)), typeName);
-    }
-    writer.endMethod();
-    writer.emitEmptyLine();
-  }
-
-  /**
-   * Writes the {@code getDependencies()} method for the generated adapters. The {@code supertype}
-   * provided is the next injectable ancestor.
-   */
-  private void writeGetDependenciesMethod(JavaWriter writer, ExecutableElement constructor,
-      List<Element> fields, boolean disambiguateFields, TypeMirror supertype,
-      boolean extendsBinding) throws IOException {
-    writer.emitJavadoc(AdapterJavadocs.GET_DEPENDENCIES_METHOD);
-    if (extendsBinding) {
-      writer.emitAnnotation(Override.class);
-    }
-    String setOfBindings = JavaWriter.type(Set.class, "Binding<?>");
-    writer.beginMethod("void", "getDependencies", EnumSet.of(PUBLIC), setOfBindings, "getBindings",
-        setOfBindings, "injectMembersBindings");
-    if (constructor != null) {
-      for (Element parameter : constructor.getParameters()) {
-        writer.emitStatement("getBindings.add(%s)", parameterName(disambiguateFields, parameter));
-      }
-    }
-    for (Element field : fields) {
-      writer.emitStatement("injectMembersBindings.add(%s)", fieldName(disambiguateFields, field));
-    }
-    if (supertype != null) {
-      writer.emitStatement("nextInjectableAncestor.getDependencies(null, injectMembersBindings)");
-    }
-    writer.endMethod();
-    writer.emitEmptyLine();
-  }
-
-  private void writeGetMethod(JavaWriter writer, ExecutableElement constructor,
-      boolean disambiguateFields, boolean injectMembers, String strippedTypeName)
-      throws IOException {
-    writer.emitJavadoc(AdapterJavadocs.GET_METHOD, strippedTypeName);
-    writer.emitAnnotation(Override.class);
-    writer.beginMethod(strippedTypeName, "get", EnumSet.of(PUBLIC));
-    StringBuilder newInstance = new StringBuilder();
-    newInstance.append(strippedTypeName).append(" result = new ");
-    newInstance.append(strippedTypeName).append('(');
-    boolean first = true;
-    for (VariableElement parameter : constructor.getParameters()) {
-      if (!first) newInstance.append(", ");
-      else first = false;
-      newInstance.append(parameterName(disambiguateFields, parameter)).append(".get()");
-    }
-    newInstance.append(')');
-    writer.emitStatement(newInstance.toString());
-    if (injectMembers) {
-      writer.emitStatement("injectMembers(result)");
-    }
-    writer.emitStatement("return result");
-    writer.endMethod();
-    writer.emitEmptyLine();
-  }
-
-  /**
-   * Writes the {@code injectMembers()} method for the generated adapters. The {@code supertype}
-   * provided is the next injectable ancestor.
-   */
-  private void writeMembersInjectMethod(JavaWriter writer, List<Element> fields,
-      boolean disambiguateFields, String strippedTypeName, TypeMirror supertype)
-      throws IOException {
-    writer.emitJavadoc(AdapterJavadocs.MEMBERS_INJECT_METHOD, strippedTypeName);
-    writer.emitAnnotation(Override.class);
-    writer.beginMethod("void", "injectMembers", EnumSet.of(PUBLIC), strippedTypeName, "object");
-    for (Element field : fields) {
-      writer.emitStatement("object.%s = %s.get()",
-          field.getSimpleName(),
-          fieldName(disambiguateFields, field));
-    }
-    if (supertype != null) {
-      writer.emitStatement("nextInjectableAncestor.injectMembers(object)");
-    }
-    writer.endMethod();
-    writer.emitEmptyLine();
-  }
-
-  private void writeStaticInjectMethod(JavaWriter writer, List<Element> fields, String typeName)
-      throws IOException {
-    writer.emitEmptyLine();
-    writer.emitJavadoc(AdapterJavadocs.STATIC_INJECT_METHOD);
-    writer.emitAnnotation(Override.class);
-    writer.beginMethod("void", "inject", EnumSet.of(PUBLIC));
-    for (Element field : fields) {
-      writer.emitStatement("%s.%s = %s.get()",
-          writer.compressType(typeName),
-          field.getSimpleName().toString(),
-          fieldName(false, field));
-    }
-    writer.endMethod();
-    writer.emitEmptyLine();
-  }
-
-  private Set<String> findImports(boolean dependent, boolean injectMembers, boolean isProvider) {
-    Set<String> imports = new LinkedHashSet<String>();
-    imports.add(Binding.class.getCanonicalName());
-    if (dependent) {
-      imports.add(Linker.class.getCanonicalName());
-      imports.add(Set.class.getCanonicalName());
-    }
-    if (injectMembers) imports.add(MembersInjector.class.getCanonicalName());
-    if (isProvider) imports.add(Provider.class.getCanonicalName());
-    return imports;
-  }
-
-  private String[] implementedInterfaces(
-      String strippedTypeName, boolean hasFields, boolean isProvider) {
-    List<String> interfaces = new ArrayList<String>();
-    if (isProvider) {
-      interfaces.add(JavaWriter.type(Provider.class, strippedTypeName));
-    }
-    if (hasFields) {
-      interfaces.add(JavaWriter.type(MembersInjector.class, strippedTypeName));
-    }
-    return interfaces.toArray(new String[interfaces.size()]);
-  }
-
-  private String strippedTypeName(String type, String packageName) {
-    return type.substring(packageName.isEmpty() ? 0 : packageName.length() + 1);
-  }
-
-  private String fieldName(boolean disambiguateFields, Element field) {
-    return (disambiguateFields ? "field_" : "") + field.getSimpleName().toString();
-  }
-
-  private String parameterName(boolean disambiguateFields, Element parameter) {
-    return (disambiguateFields ? "parameter_" : "") + parameter.getSimpleName().toString();
-  }
-
-  private String parentAdapterName(TypeElement originChild, TypeElement ancestor) {
-    StringBuilder result = new StringBuilder();
-    String ancestorPackageName = getPackage(ancestor).getQualifiedName().toString();
-    String childPackageName = getPackage(originChild).getQualifiedName().toString();
-    String childName = strippedTypeName(originChild.getQualifiedName().toString(), childPackageName)
-        .replace('.', '$');
-    String ancestorName = strippedTypeName(
-        ancestor.getQualifiedName().toString(), ancestorPackageName).replace('.', '$');
-    if (!ancestorPackageName.isEmpty()) {
-      result.append(ancestorPackageName);
-      result.append('.');
-    }
-    result.append(ancestorName);
-    result.append(PARENT_ADAPTER_INFIX);
-    if (!childPackageName.isEmpty()) {
-      result.append(childPackageName.replace('.', '_'));
-      result.append('_');
-    }
-    result.append(childName);
-    return result.toString();
-  }
-
-  private void error(String msg, Element element) {
-    processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, msg, element);
-  }
-
-  static class InjectedClass {
-    final TypeElement type;
-    final List<Element> staticFields;
-    final ExecutableElement constructor;
-    final List<Element> fields;
-
-    InjectedClass(TypeElement type, List<Element> staticFields, ExecutableElement constructor,
-        List<Element> fields) {
-      this.type = type;
-      this.staticFields = staticFields;
-      this.constructor = constructor;
-      this.fields = fields;
-    }
-  }
-
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/dagger1/ModuleAdapterProcessor.java b/compiler/src/main/java/dagger/internal/codegen/dagger1/ModuleAdapterProcessor.java
deleted file mode 100644
index 3ec8b41e8..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/dagger1/ModuleAdapterProcessor.java
+++ /dev/null
@@ -1,533 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen.dagger1;
-
-import com.google.auto.service.AutoService;
-import com.squareup.javawriter.JavaWriter;
-import dagger.Lazy;
-import dagger.Module;
-import dagger.Provides;
-import dagger.internal.Binding;
-import dagger.internal.BindingsGroup;
-import dagger.internal.Linker;
-import dagger.internal.ModuleAdapter;
-import dagger.internal.ProvidesBinding;
-import dagger.internal.SetBinding;
-import dagger.internal.codegen.dagger1.Util.CodeGenerationIncompleteException;
-import java.io.IOException;
-import java.io.StringWriter;
-import java.io.Writer;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.EnumSet;
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.LinkedHashMap;
-import java.util.LinkedHashSet;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-import java.util.concurrent.atomic.AtomicInteger;
-import javax.annotation.processing.AbstractProcessor;
-import javax.annotation.processing.Processor;
-import javax.annotation.processing.RoundEnvironment;
-import javax.annotation.processing.SupportedAnnotationTypes;
-import javax.inject.Provider;
-import javax.inject.Singleton;
-import javax.lang.model.SourceVersion;
-import javax.lang.model.element.Element;
-import javax.lang.model.element.ElementKind;
-import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.Modifier;
-import javax.lang.model.element.TypeElement;
-import javax.lang.model.element.VariableElement;
-import javax.lang.model.type.TypeKind;
-import javax.lang.model.type.TypeMirror;
-import javax.lang.model.util.Elements;
-import javax.lang.model.util.Types;
-import javax.tools.Diagnostic;
-import javax.tools.JavaFileObject;
-
-import static com.google.auto.common.MoreElements.isAnnotationPresent;
-import static dagger.Provides.Type.SET;
-import static dagger.Provides.Type.SET_VALUES;
-import static dagger.internal.codegen.dagger1.AdapterJavadocs.bindingTypeDocs;
-import static dagger.internal.codegen.dagger1.Util.adapterName;
-import static dagger.internal.codegen.dagger1.Util.elementToString;
-import static dagger.internal.codegen.dagger1.Util.getAnnotation;
-import static dagger.internal.codegen.dagger1.Util.getNoArgsConstructor;
-import static dagger.internal.codegen.dagger1.Util.getPackage;
-import static dagger.internal.codegen.dagger1.Util.isCallableConstructor;
-import static dagger.internal.codegen.dagger1.Util.isInterface;
-import static dagger.internal.codegen.dagger1.Util.typeToString;
-import static dagger.internal.loaders.GeneratedAdapters.MODULE_ADAPTER_SUFFIX;
-import static javax.lang.model.element.Modifier.ABSTRACT;
-import static javax.lang.model.element.Modifier.FINAL;
-import static javax.lang.model.element.Modifier.PRIVATE;
-import static javax.lang.model.element.Modifier.PUBLIC;
-import static javax.lang.model.element.Modifier.STATIC;
-
-/**
- * Generates an implementation of {@link ModuleAdapter} that includes a binding for each
- * {@code @Provides} method of a target class.
- */
-@AutoService(Processor.class)
-@SupportedAnnotationTypes({ "*" })
-public final class ModuleAdapterProcessor extends AbstractProcessor {
-  private static final String BINDINGS_MAP = JavaWriter.type(BindingsGroup.class);
-  private static final List<String> INVALID_RETURN_TYPES =
-      Arrays.asList(Provider.class.getCanonicalName(), Lazy.class.getCanonicalName());
-
-  private final LinkedHashMap<String, List<ExecutableElement>> remainingTypes =
-      new LinkedHashMap<String, List<ExecutableElement>>();
-
-  @Override public SourceVersion getSupportedSourceVersion() {
-    return SourceVersion.latestSupported();
-  }
-
-  @Override public boolean process(Set<? extends TypeElement> types, RoundEnvironment env) {
-    try {
-      remainingTypes.putAll(providerMethodsByClass(env));
-    } catch (ClassCastException e) {
-      return false; // upstream compiler issues - bail cleanly.
-    } catch (CodeGenerationIncompleteException e) {
-      return false; // upstream compiler issues - bail cleanly.
-    }
-    for (Iterator<String> i = remainingTypes.keySet().iterator(); i.hasNext();) {
-      String typeName = i.next();
-      TypeElement type = processingEnv.getElementUtils().getTypeElement(typeName);
-      List<ExecutableElement> providesTypes = remainingTypes.get(typeName);
-
-      try {
-        // Attempt to get the annotation. If types are missing, this will throw
-        // CodeGenerationIncompleteException.
-        Map<String, Object> parsedAnnotation = getAnnotation(Module.class, type);
-
-        //TODO(user): Figure out an initial sizing of the StringWriter.
-        StringWriter stringWriter = new StringWriter();
-        String adapterName = adapterName(type, MODULE_ADAPTER_SUFFIX);
-        generateModuleAdapter(stringWriter, adapterName, type, parsedAnnotation, providesTypes);
-        JavaFileObject sourceFile = processingEnv.getFiler().createSourceFile(adapterName, type);
-        Writer sourceWriter = sourceFile.openWriter();
-        sourceWriter.append(stringWriter.getBuffer());
-        sourceWriter.close();
-      } catch (CodeGenerationIncompleteException e) {
-        continue; // A dependent type was not defined, we'll try to catch it on another pass.
-      } catch (IOException e) {
-        error("Code gen failed: " + e, type);
-      }
-      i.remove();
-    }
-    if (env.processingOver() && remainingTypes.size() > 0) {
-      processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR,
-          "Could not find types required by provides methods for " + remainingTypes.keySet());
-    }
-    return false; // FullGraphProcessor needs an opportunity to process.
-  }
-
-  private void error(String msg, Element element) {
-    processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, msg, element);
-  }
-
-  /**
-   * Returns a map containing all {@code @Provides} methods, indexed by class.
-   */
-  private Map<String, List<ExecutableElement>> providerMethodsByClass(RoundEnvironment env) {
-    Elements elementUtils = processingEnv.getElementUtils();
-    Types types = processingEnv.getTypeUtils();
-
-    Map<String, List<ExecutableElement>> result = new HashMap<String, List<ExecutableElement>>();
-
-    provides:
-    for (Element providerMethod : findProvidesMethods(env)) {
-      if (providerMethod.getAnnotation(Provides.class) == null) {
-        throw new CodeGenerationIncompleteException("Missing import of dagger.Provides.");
-      }
-
-      switch (providerMethod.getEnclosingElement().getKind()) {
-        case CLASS:
-          break; // valid, move along
-        default:
-          // TODO(user): pass annotation information
-          error("Unexpected @Provides on " + elementToString(providerMethod), providerMethod);
-          continue;
-      }
-      TypeElement type = (TypeElement) providerMethod.getEnclosingElement();
-      Set<Modifier> typeModifiers = type.getModifiers();
-      if (typeModifiers.contains(PRIVATE)
-          || typeModifiers.contains(ABSTRACT)) {
-        error("Classes declaring @Provides methods must not be private or abstract: "
-                + type.getQualifiedName(), type);
-        continue;
-      }
-
-      Set<Modifier> methodModifiers = providerMethod.getModifiers();
-      if (methodModifiers.contains(PRIVATE)
-          || methodModifiers.contains(ABSTRACT)
-          || methodModifiers.contains(STATIC)) {
-        error("@Provides methods must not be private, abstract or static: "
-                + type.getQualifiedName() + "." + providerMethod, providerMethod);
-        continue;
-      }
-
-      ExecutableElement providerMethodAsExecutable = (ExecutableElement) providerMethod;
-      if (!providerMethodAsExecutable.getThrownTypes().isEmpty()) {
-        error("@Provides methods must not have a throws clause: "
-            + type.getQualifiedName() + "." + providerMethod, providerMethod);
-        continue;
-      }
-
-      // Invalidate return types.
-      TypeMirror returnType = types.erasure(providerMethodAsExecutable.getReturnType());
-      if (!returnType.getKind().equals(TypeKind.ERROR)) {
-        // Validate if we have a type to validate (a type yet to be generated by other
-        // processors is not "invalid" in this way, so ignore).
-        for (String invalidTypeName : INVALID_RETURN_TYPES) {
-          TypeElement invalidTypeElement = elementUtils.getTypeElement(invalidTypeName);
-          if (invalidTypeElement != null && types.isSameType(returnType,
-              types.erasure(invalidTypeElement.asType()))) {
-            error(String.format("@Provides method must not return %s directly: %s.%s",
-                invalidTypeElement, type.getQualifiedName(), providerMethod), providerMethod);
-            continue provides; // Skip to next provides method.
-          }
-        }
-      }
-
-      List<ExecutableElement> methods = result.get(type.getQualifiedName().toString());
-      if (methods == null) {
-        methods = new ArrayList<ExecutableElement>();
-        result.put(type.getQualifiedName().toString(), methods);
-      }
-      methods.add(providerMethodAsExecutable);
-    }
-
-    TypeMirror objectType = elementUtils.getTypeElement("java.lang.Object").asType();
-
-    // Catch any stray modules without @Provides since their injectable types
-    // should still be registered and a ModuleAdapter should still be written.
-    for (Element module : env.getElementsAnnotatedWith(Module.class)) {
-      if (!module.getKind().equals(ElementKind.CLASS)) {
-        error("Modules must be classes: " + elementToString(module), module);
-        continue;
-      }
-
-      TypeElement moduleType = (TypeElement) module;
-
-      // Verify that all modules do not extend from non-Object types.
-      if (!moduleType.getSuperclass().equals(objectType)) {
-        error("Modules must not extend from other classes: " + elementToString(module), module);
-      }
-
-      String moduleName = moduleType.getQualifiedName().toString();
-      if (result.containsKey(moduleName)) continue;
-      result.put(moduleName, new ArrayList<ExecutableElement>());
-    }
-    return result;
-  }
-
-  private Set<? extends Element> findProvidesMethods(RoundEnvironment env) {
-    Set<Element> result = new LinkedHashSet<Element>();
-    result.addAll(env.getElementsAnnotatedWith(Provides.class));
-    return result;
-  }
-
-  /**
-   * Write a companion class for {@code type} that implements {@link
-   * ModuleAdapter} to expose its provider methods.
-   */
-  private void generateModuleAdapter(Writer ioWriter, String adapterName, TypeElement type,
-      Map<String, Object> module, List<ExecutableElement> providerMethods) throws IOException {
-    if (module == null) {
-      error(type + " has @Provides methods but no @Module annotation", type);
-      return;
-    }
-
-    Object[] staticInjections = (Object[]) module.get("staticInjections");
-    Object[] injects = (Object[]) module.get("injects");
-    Object[] includes = (Object[]) module.get("includes");
-
-    boolean overrides = (Boolean) module.get("overrides");
-    boolean complete = (Boolean) module.get("complete");
-    boolean library = (Boolean) module.get("library");
-
-    JavaWriter writer = new JavaWriter(ioWriter);
-
-    boolean multibindings = checkForMultibindings(providerMethods);
-    boolean providerMethodDependencies = checkForDependencies(providerMethods);
-
-    writer.emitSingleLineComment(AdapterJavadocs.GENERATED_BY_DAGGER);
-    writer.emitPackage(getPackage(type).getQualifiedName().toString());
-    writer.emitImports(
-        findImports(multibindings, !providerMethods.isEmpty(), providerMethodDependencies));
-
-    String typeName = type.getQualifiedName().toString();
-    writer.emitEmptyLine();
-    writer.emitJavadoc(AdapterJavadocs.MODULE_TYPE);
-    writer.beginType(adapterName, "class", EnumSet.of(PUBLIC, FINAL),
-        JavaWriter.type(ModuleAdapter.class, typeName));
-
-    StringBuilder injectsField = new StringBuilder().append("{ ");
-    for (Object injectableType : injects) {
-      TypeMirror typeMirror = (TypeMirror) injectableType;
-      String key = isInterface(typeMirror)
-          ? GeneratorKeys.get(typeMirror)
-          : GeneratorKeys.rawMembersKey(typeMirror);
-      injectsField.append(JavaWriter.stringLiteral(key)).append(", ");
-    }
-    injectsField.append("}");
-    writer.emitField("String[]", "INJECTS", EnumSet.of(PRIVATE, STATIC, FINAL),
-        injectsField.toString());
-
-    StringBuilder staticInjectionsField = new StringBuilder().append("{ ");
-    for (Object staticInjection : staticInjections) {
-      TypeMirror typeMirror = (TypeMirror) staticInjection;
-      staticInjectionsField.append(typeToString(typeMirror)).append(".class, ");
-    }
-    staticInjectionsField.append("}");
-    writer.emitField("Class<?>[]", "STATIC_INJECTIONS", EnumSet.of(PRIVATE, STATIC, FINAL),
-        staticInjectionsField.toString());
-
-    StringBuilder includesField = new StringBuilder().append("{ ");
-    for (Object include : includes) {
-      if (!(include instanceof TypeMirror)) {
-        // TODO(user): pass annotation information
-        processingEnv.getMessager().printMessage(Diagnostic.Kind.WARNING,
-            "Unexpected value: " + include + " in includes of " + type, type);
-        continue;
-      }
-      TypeMirror typeMirror = (TypeMirror) include;
-      includesField.append(typeToString(typeMirror)).append(".class, ");
-    }
-    includesField.append("}");
-    writer.emitField(
-        "Class<?>[]", "INCLUDES", EnumSet.of(PRIVATE, STATIC, FINAL), includesField.toString());
-
-    writer.emitEmptyLine();
-    writer.beginMethod(null, adapterName, EnumSet.of(PUBLIC));
-    writer.emitStatement("super(%s.class, INJECTS, STATIC_INJECTIONS, %s /*overrides*/, "
-        + "INCLUDES, %s /*complete*/, %s /*library*/)", typeName,  overrides, complete, library);
-    writer.endMethod();
-
-    ExecutableElement noArgsConstructor = getNoArgsConstructor(type);
-    if (noArgsConstructor != null && isCallableConstructor(noArgsConstructor)) {
-      writer.emitEmptyLine();
-      writer.emitAnnotation(Override.class);
-      writer.beginMethod(typeName, "newModule", EnumSet.of(PUBLIC));
-      writer.emitStatement("return new %s()", typeName);
-      writer.endMethod();
-    }
-    // caches
-    Map<ExecutableElement, String> methodToClassName
-        = new LinkedHashMap<ExecutableElement, String>();
-    Map<String, AtomicInteger> methodNameToNextId = new LinkedHashMap<String, AtomicInteger>();
-
-    if (!providerMethods.isEmpty()) {
-      writer.emitEmptyLine();
-      writer.emitJavadoc(AdapterJavadocs.GET_DEPENDENCIES_METHOD);
-      writer.emitAnnotation(Override.class);
-      writer.beginMethod("void", "getBindings", EnumSet.of(PUBLIC), BINDINGS_MAP, "bindings",
-          typeName, "module");
-
-      for (ExecutableElement providerMethod : providerMethods) {
-        Provides provides = providerMethod.getAnnotation(Provides.class);
-        switch (provides.type()) {
-          case UNIQUE: {
-            String key = GeneratorKeys.get(providerMethod);
-            writer.emitStatement("bindings.contributeProvidesBinding(%s, new %s(module))",
-                JavaWriter.stringLiteral(key),
-                bindingClassName(providerMethod, methodToClassName, methodNameToNextId));
-            break;
-          }
-          case SET: {
-            String key = GeneratorKeys.getSetKey(providerMethod);
-            writer.emitStatement("SetBinding.add(bindings, %s, new %s(module))",
-                JavaWriter.stringLiteral(key),
-                bindingClassName(providerMethod, methodToClassName, methodNameToNextId));
-            break;
-          }
-          case SET_VALUES: {
-            String key = GeneratorKeys.get(providerMethod);
-            writer.emitStatement("SetBinding.add(bindings, %s, new %s(module))",
-                JavaWriter.stringLiteral(key),
-                bindingClassName(providerMethod, methodToClassName, methodNameToNextId));
-            break;
-          }
-          default:
-            throw new AssertionError("Unknown @Provides type " + provides.type());
-        }
-      }
-      writer.endMethod();
-    }
-
-    for (ExecutableElement providerMethod : providerMethods) {
-      generateProvidesAdapter(
-          writer, providerMethod, methodToClassName, methodNameToNextId, library);
-    }
-
-    writer.endType();
-    writer.close();
-  }
-
-  private Set<String> findImports(boolean multibindings, boolean providers, boolean dependencies) {
-    Set<String> imports = new LinkedHashSet<String>();
-    imports.add(ModuleAdapter.class.getCanonicalName());
-    if (providers) {
-      imports.add(BindingsGroup.class.getCanonicalName());
-      imports.add(Provider.class.getCanonicalName());
-      imports.add(ProvidesBinding.class.getCanonicalName());
-    }
-    if (dependencies) {
-      imports.add(Linker.class.getCanonicalName());
-      imports.add(Set.class.getCanonicalName());
-      imports.add(Binding.class.getCanonicalName());
-    }
-    if (multibindings) {
-      imports.add(SetBinding.class.getCanonicalName());
-    }
-    return imports;
-  }
-
-  private boolean checkForDependencies(List<ExecutableElement> providerMethods) {
-    for (ExecutableElement element : providerMethods) {
-      if (!element.getParameters().isEmpty()) {
-        return true;
-      }
-    }
-    return false;
-  }
-
-  private boolean checkForMultibindings(List<ExecutableElement> providerMethods) {
-    for (ExecutableElement element : providerMethods) {
-      Provides.Type providesType = element.getAnnotation(Provides.class).type();
-      if (providesType == SET || providesType == SET_VALUES) {
-        return true;
-      }
-    }
-    return false;
-  }
-
-  private String bindingClassName(ExecutableElement providerMethod,
-      Map<ExecutableElement, String> methodToClassName,
-      Map<String, AtomicInteger> methodNameToNextId) {
-    String className = methodToClassName.get(providerMethod);
-    if (className != null) return className;
-
-    String methodName = providerMethod.getSimpleName().toString();
-    String suffix = "";
-    AtomicInteger id = methodNameToNextId.get(methodName);
-    if (id == null) {
-      methodNameToNextId.put(methodName, new AtomicInteger(2));
-    } else {
-      suffix = id.toString();
-      id.incrementAndGet();
-    }
-    String uppercaseMethodName = Character.toUpperCase(methodName.charAt(0))
-        + methodName.substring(1);
-    className = uppercaseMethodName + "ProvidesAdapter" + suffix;
-    methodToClassName.put(providerMethod, className);
-    return className;
-  }
-
-  private void generateProvidesAdapter(JavaWriter writer, ExecutableElement providerMethod,
-      Map<ExecutableElement, String> methodToClassName,
-      Map<String, AtomicInteger> methodNameToNextId, boolean library)
-      throws IOException {
-    String methodName = providerMethod.getSimpleName().toString();
-    String moduleType = typeToString(providerMethod.getEnclosingElement().asType());
-    String className =
-        bindingClassName(providerMethod, methodToClassName, methodNameToNextId);
-    String returnType = typeToString(providerMethod.getReturnType());
-    List<? extends VariableElement> parameters = providerMethod.getParameters();
-    boolean dependent = !parameters.isEmpty();
-
-    writer.emitEmptyLine();
-    writer.emitJavadoc(bindingTypeDocs(returnType, false, false, dependent));
-    writer.beginType(className, "class", EnumSet.of(PUBLIC, STATIC, FINAL),
-        JavaWriter.type(ProvidesBinding.class, returnType),
-        JavaWriter.type(Provider.class, returnType));
-    writer.emitField(moduleType, "module", EnumSet.of(PRIVATE, FINAL));
-    for (Element parameter : parameters) {
-      TypeMirror parameterType = parameter.asType();
-      writer.emitField(JavaWriter.type(Binding.class, typeToString(parameterType)),
-          parameterName(parameter), EnumSet.of(PRIVATE));
-    }
-
-    writer.emitEmptyLine();
-    writer.beginMethod(null, className, EnumSet.of(PUBLIC), moduleType, "module");
-    boolean singleton = isAnnotationPresent(providerMethod, Singleton.class);
-    String key = JavaWriter.stringLiteral(GeneratorKeys.get(providerMethod));
-    writer.emitStatement("super(%s, %s, %s, %s)",
-        key, (singleton ? "IS_SINGLETON" : "NOT_SINGLETON"),
-        JavaWriter.stringLiteral(moduleType),
-        JavaWriter.stringLiteral(methodName));
-    writer.emitStatement("this.module = module");
-    writer.emitStatement("setLibrary(%s)", library);
-    writer.endMethod();
-
-    if (dependent) {
-      writer.emitEmptyLine();
-      writer.emitJavadoc(AdapterJavadocs.ATTACH_METHOD);
-      writer.emitAnnotation(Override.class);
-      writer.emitAnnotation(SuppressWarnings.class, JavaWriter.stringLiteral("unchecked"));
-      writer.beginMethod(
-          "void", "attach", EnumSet.of(PUBLIC), Linker.class.getCanonicalName(), "linker");
-      for (VariableElement parameter : parameters) {
-        String parameterKey = GeneratorKeys.get(parameter);
-        writer.emitStatement(
-            "%s = (%s) linker.requestBinding(%s, %s.class, getClass().getClassLoader())",
-            parameterName(parameter),
-            writer.compressType(JavaWriter.type(Binding.class, typeToString(parameter.asType()))),
-            JavaWriter.stringLiteral(parameterKey),
-            writer.compressType(moduleType));
-      }
-      writer.endMethod();
-
-      writer.emitEmptyLine();
-      writer.emitJavadoc(AdapterJavadocs.GET_DEPENDENCIES_METHOD);
-      writer.emitAnnotation(Override.class);
-      String setOfBindings = JavaWriter.type(Set.class, "Binding<?>");
-      writer.beginMethod("void", "getDependencies", EnumSet.of(PUBLIC), setOfBindings,
-          "getBindings", setOfBindings, "injectMembersBindings");
-      for (Element parameter : parameters) {
-        writer.emitStatement("getBindings.add(%s)", parameterName(parameter));
-      }
-      writer.endMethod();
-    }
-
-    writer.emitEmptyLine();
-    writer.emitJavadoc(AdapterJavadocs.GET_METHOD, returnType);
-    writer.emitAnnotation(Override.class);
-    writer.beginMethod(returnType, "get", EnumSet.of(PUBLIC));
-    StringBuilder args = new StringBuilder();
-    boolean first = true;
-    for (Element parameter : parameters) {
-      if (!first) args.append(", ");
-      else first = false;
-      args.append(String.format("%s.get()", parameterName(parameter)));
-    }
-    writer.emitStatement("return module.%s(%s)", methodName, args.toString());
-    writer.endMethod();
-
-    writer.endType();
-  }
-
-  private String parameterName(Element parameter) {
-    if (parameter.getSimpleName().contentEquals("module")) {
-      return "parameter_" + parameter.getSimpleName().toString();
-    }
-    return parameter.getSimpleName().toString();
-  }
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/dagger1/Util.java b/compiler/src/main/java/dagger/internal/codegen/dagger1/Util.java
deleted file mode 100644
index 1afad0dcb..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/dagger1/Util.java
+++ /dev/null
@@ -1,386 +0,0 @@
-/*
- * Copyright (C) 2013 Google, Inc.
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen.dagger1;
-
-import dagger.internal.Keys;
-import java.lang.reflect.Method;
-import java.util.Arrays;
-import java.util.LinkedHashMap;
-import java.util.List;
-import java.util.Map;
-import javax.lang.model.element.AnnotationMirror;
-import javax.lang.model.element.AnnotationValue;
-import javax.lang.model.element.AnnotationValueVisitor;
-import javax.lang.model.element.Element;
-import javax.lang.model.element.ElementKind;
-import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.Modifier;
-import javax.lang.model.element.PackageElement;
-import javax.lang.model.element.TypeElement;
-import javax.lang.model.type.ArrayType;
-import javax.lang.model.type.DeclaredType;
-import javax.lang.model.type.ErrorType;
-import javax.lang.model.type.PrimitiveType;
-import javax.lang.model.type.TypeMirror;
-import javax.lang.model.type.TypeVariable;
-import javax.lang.model.type.WildcardType;
-import javax.lang.model.util.SimpleAnnotationValueVisitor6;
-import javax.lang.model.util.SimpleTypeVisitor6;
-
-import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
-
-/**
- * Utilities for handling types in annotation processors
- */
-final class Util {
-  private Util() {
-  }
-
-  public static PackageElement getPackage(Element type) {
-    while (type.getKind() != ElementKind.PACKAGE) {
-      type = type.getEnclosingElement();
-    }
-    return (PackageElement) type;
-  }
-
-  /**
-   * Returns the supertype, or {@code null} if the supertype is a platform
-   * class. This is intended for annotation processors that assume platform
-   * classes will never be annotated with application annotations.
-   */
-  public static TypeMirror getApplicationSupertype(TypeElement type) {
-    TypeMirror supertype = type.getSuperclass();
-    return Keys.isPlatformType(supertype.toString()) ? null : supertype;
-  }
-
-  /** Returns a fully qualified class name to complement {@code type}. */
-  public static String adapterName(TypeElement typeElement, String suffix) {
-    StringBuilder builder = new StringBuilder();
-    rawTypeToString(builder, typeElement, '$');
-    builder.append(suffix);
-    return builder.toString();
-  }
-
-  /** Returns a string for {@code type}. Primitive types are always boxed. */
-  public static String typeToString(TypeMirror type) {
-    StringBuilder result = new StringBuilder();
-    typeToString(type, result, '.');
-    return result.toString();
-  }
-
-  /** Returns a string for the raw type of {@code type}. Primitive types are always boxed. */
-  public static String rawTypeToString(TypeMirror type, char innerClassSeparator) {
-    if (!(type instanceof DeclaredType)) {
-      throw new IllegalArgumentException("Unexpected type: " + type);
-    }
-    StringBuilder result = new StringBuilder();
-    DeclaredType declaredType = (DeclaredType) type;
-    rawTypeToString(result, (TypeElement) declaredType.asElement(), innerClassSeparator);
-    return result.toString();
-  }
-
-  /**
-   * Appends a string for {@code type} to {@code result}. Primitive types are
-   * always boxed.
-   *
-   * @param innerClassSeparator either '.' or '$', which will appear in a
-   *     class name like "java.lang.Map.Entry" or "java.lang.Map$Entry".
-   *     Use '.' for references to existing types in code. Use '$' to define new
-   *     class names and for strings that will be used by runtime reflection.
-   */
-  public static void typeToString(final TypeMirror type, final StringBuilder result,
-      final char innerClassSeparator) {
-    type.accept(new SimpleTypeVisitor6<Void, Void>() {
-      @Override public Void visitDeclared(DeclaredType declaredType, Void v) {
-        TypeElement typeElement = (TypeElement) declaredType.asElement();
-        rawTypeToString(result, typeElement, innerClassSeparator);
-        List<? extends TypeMirror> typeArguments = declaredType.getTypeArguments();
-        if (!typeArguments.isEmpty()) {
-          result.append("<");
-          for (int i = 0; i < typeArguments.size(); i++) {
-            if (i != 0) {
-              result.append(", ");
-            }
-            typeToString(typeArguments.get(i), result, innerClassSeparator);
-          }
-          result.append(">");
-        }
-        return null;
-      }
-      @Override public Void visitPrimitive(PrimitiveType primitiveType, Void v) {
-        result.append(box((PrimitiveType) type).getName());
-        return null;
-      }
-      @Override public Void visitArray(ArrayType arrayType, Void v) {
-        TypeMirror type = arrayType.getComponentType();
-        if (type instanceof PrimitiveType) {
-          result.append(type.toString()); // Don't box, since this is an array.
-        } else {
-          typeToString(arrayType.getComponentType(), result, innerClassSeparator);
-        }
-        result.append("[]");
-        return null;
-      }
-      @Override public Void visitTypeVariable(TypeVariable typeVariable, Void v) {
-        result.append(typeVariable.asElement().getSimpleName());
-        return null;
-      }
-      @Override public Void visitError(ErrorType errorType, Void v) {
-        // Error type found, a type may not yet have been generated, but we need the type
-        // so we can generate the correct code in anticipation of the type being available
-        // to the compiler.
-
-        // Paramterized types which don't exist are returned as an error type whose name is "<any>"
-        if ("<any>".equals(errorType.toString())) {
-          throw new CodeGenerationIncompleteException(
-              "Type reported as <any> is likely a not-yet generated parameterized type.");
-        }
-        // TODO(user): Figure out a strategy for non-FQCN cases.
-        result.append(errorType.toString());
-        return null;
-      }
-      public Void visitWildcard(WildcardType wildcardType, Void v) {
-        result.append("?");
-        if (wildcardType.getExtendsBound() != null) {
-          result.append(" extends ");
-          typeToString(wildcardType.getExtendsBound(), result, innerClassSeparator);
-        } else if (wildcardType.getSuperBound() != null) {
-          result.append(" super ");
-          typeToString(wildcardType.getSuperBound(), result, innerClassSeparator);
-        }
-        return null;
-      }
-      @Override protected Void defaultAction(TypeMirror typeMirror, Void v) {
-        throw new UnsupportedOperationException(
-            "Unexpected TypeKind " + typeMirror.getKind() + " for "  + typeMirror);
-      }
-    }, null);
-  }
-
-  private static final AnnotationValueVisitor<Object, Void> VALUE_EXTRACTOR =
-      new SimpleAnnotationValueVisitor6<Object, Void>() {
-        @Override public Object visitString(String s, Void p) {
-          if ("<error>".equals(s)) {
-            throw new CodeGenerationIncompleteException("Unknown type returned as <error>.");
-          } else if ("<any>".equals(s)) {
-            throw new CodeGenerationIncompleteException("Unknown type returned as <any>.");
-          }
-          return s;
-        }
-        @Override public Object visitType(TypeMirror t, Void p) {
-          return t;
-        }
-        @Override protected Object defaultAction(Object o, Void v) {
-          return o;
-        }
-        @Override public Object visitArray(List<? extends AnnotationValue> values, Void v) {
-          Object[] result = new Object[values.size()];
-          for (int i = 0; i < values.size(); i++) {
-            result[i] = values.get(i).accept(this, null);
-          }
-          return result;
-        }
-      };
-
-  /**
-   * Returns the annotation on {@code element} formatted as a Map. This returns
-   * a Map rather than an instance of the annotation interface to work-around
-   * the fact that Class and Class[] fields won't work at code generation time.
-   * See http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=5089128
-   */
-  public static Map<String, Object> getAnnotation(Class<?> annotationType, Element element) {
-    for (AnnotationMirror annotation : element.getAnnotationMirrors()) {
-      if (!rawTypeToString(annotation.getAnnotationType(), '$')
-          .equals(annotationType.getName())) {
-        continue;
-      }
-
-      Map<String, Object> result = new LinkedHashMap<String, Object>();
-      for (Method m : annotationType.getMethods()) {
-        result.put(m.getName(), m.getDefaultValue());
-      }
-      for (Map.Entry<? extends ExecutableElement, ? extends AnnotationValue> e
-          : annotation.getElementValues().entrySet()) {
-        String name = e.getKey().getSimpleName().toString();
-        Object value = e.getValue().accept(VALUE_EXTRACTOR, null);
-        Object defaultValue = result.get(name);
-        if (!lenientIsInstance(defaultValue.getClass(), value)) {
-          throw new IllegalStateException(String.format(
-              "Value of %s.%s is a %s but expected a %s\n    value: %s",
-              annotationType, name, value.getClass().getName(), defaultValue.getClass().getName(),
-              value instanceof Object[] ? Arrays.toString((Object[]) value) : value));
-        }
-        result.put(name, value);
-      }
-      return result;
-    }
-    return null; // Annotation not found.
-  }
-
-  /**
-   * Returns true if {@code value} can be assigned to {@code expectedClass}.
-   * Like {@link Class#isInstance} but more lenient for {@code Class<?>} values.
-   */
-  private static boolean lenientIsInstance(Class<?> expectedClass, Object value) {
-    if (expectedClass.isArray()) {
-      Class<?> componentType = expectedClass.getComponentType();
-      if (!(value instanceof Object[])) {
-        return false;
-      }
-      for (Object element : (Object[]) value) {
-        if (!lenientIsInstance(componentType, element)) return false;
-      }
-      return true;
-    } else if (expectedClass == Class.class) {
-      return value instanceof TypeMirror;
-    } else {
-      return expectedClass == value.getClass();
-    }
-  }
-
-  // TODO(user): better format for other types of elements?
-  static String elementToString(Element element) {
-    switch (element.getKind()) {
-      case FIELD:
-      // fall through
-      case CONSTRUCTOR:
-      // fall through
-      case METHOD:
-        return element.getEnclosingElement() + "." + element;
-      default:
-        return element.toString();
-    }
-  }
-
-  static void rawTypeToString(StringBuilder result, TypeElement type,
-      char innerClassSeparator) {
-    String packageName = getPackage(type).getQualifiedName().toString();
-    String qualifiedName = type.getQualifiedName().toString();
-    if (packageName.isEmpty()) {
-        result.append(qualifiedName.replace('.', innerClassSeparator));
-    } else {
-      result.append(packageName);
-      result.append('.');
-      result.append(
-          qualifiedName.substring(packageName.length() + 1).replace('.', innerClassSeparator));
-    }
-  }
-
-  private static Class<?> box(PrimitiveType primitiveType) {
-    switch (primitiveType.getKind()) {
-      case BYTE:
-        return Byte.class;
-      case SHORT:
-        return Short.class;
-      case INT:
-        return Integer.class;
-      case LONG:
-        return Long.class;
-      case FLOAT:
-        return Float.class;
-      case DOUBLE:
-        return Double.class;
-      case BOOLEAN:
-        return Boolean.class;
-      case CHAR:
-        return Character.class;
-      case VOID:
-        return Void.class;
-      default:
-        throw new AssertionError();
-    }
-  }
-
-  /**
-   * Returns the no-args constructor for {@code type}, or null if no such
-   * constructor exists.
-   */
-  public static ExecutableElement getNoArgsConstructor(TypeElement type) {
-    for (Element enclosed : type.getEnclosedElements()) {
-      if (enclosed.getKind() != ElementKind.CONSTRUCTOR) {
-        continue;
-      }
-      ExecutableElement constructor = (ExecutableElement) enclosed;
-      if (constructor.getParameters().isEmpty()) {
-        return constructor;
-      }
-    }
-    return null;
-  }
-
-  /**
-   * Returns true if generated code can invoke {@code constructor}. That is, if
-   * the constructor is non-private and its enclosing class is either a
-   * top-level class or a static nested class.
-   */
-  public static boolean isCallableConstructor(ExecutableElement constructor) {
-    if (constructor.getModifiers().contains(Modifier.PRIVATE)) {
-      return false;
-    }
-    TypeElement type = (TypeElement) constructor.getEnclosingElement();
-    return type.getEnclosingElement().getKind() == ElementKind.PACKAGE
-        || type.getModifiers().contains(Modifier.STATIC);
-  }
-
-  /**
-   * Returns a user-presentable string like {@code coffee.CoffeeModule}.
-   */
-  public static String className(ExecutableElement method) {
-    return ((TypeElement) method.getEnclosingElement()).getQualifiedName().toString();
-  }
-
-  public static boolean isInterface(TypeMirror typeMirror) {
-    return typeMirror instanceof DeclaredType
-        && ((DeclaredType) typeMirror).asElement().getKind() == ElementKind.INTERFACE;
-  }
-
-  static boolean isStatic(Element element) {
-    for (Modifier modifier : element.getModifiers()) {
-      if (modifier.equals(Modifier.STATIC)) {
-        return true;
-      }
-    }
-    return false;
-  }
-
-  static boolean isValidJavaIdentifier(String possibleIdentifier) {
-    checkNotNull(possibleIdentifier);
-    checkArgument(!possibleIdentifier.isEmpty());
-    if (!Character.isJavaIdentifierStart(possibleIdentifier.charAt(0))) {
-      return false;
-    }
-    for (int i = 1; i < possibleIdentifier.length(); i++) {
-      if (!Character.isJavaIdentifierPart(possibleIdentifier.charAt(i))) {
-        return false;
-      }
-    }
-    return true;
-  }
-
-  /**
-   * An exception thrown when a type is not extant (returns as an error type),
-   * usually as a result of another processor not having yet generated its types upon
-   * which a dagger-annotated type depends.
-   */
-  final static class CodeGenerationIncompleteException extends IllegalStateException {
-    public CodeGenerationIncompleteException(String s) {
-      super(s);
-    }
-  }
-
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/dagger1/ValidationProcessor.java b/compiler/src/main/java/dagger/internal/codegen/dagger1/ValidationProcessor.java
deleted file mode 100644
index e58e1a080..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/dagger1/ValidationProcessor.java
+++ /dev/null
@@ -1,220 +0,0 @@
-/*
- * Copyright (C) 2013 Google, Inc.
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen.dagger1;
-
-import com.google.auto.service.AutoService;
-import dagger.Module;
-import dagger.Provides;
-import dagger.internal.codegen.dagger1.Util.CodeGenerationIncompleteException;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.LinkedHashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-import javax.annotation.processing.AbstractProcessor;
-import javax.annotation.processing.Processor;
-import javax.annotation.processing.RoundEnvironment;
-import javax.annotation.processing.SupportedAnnotationTypes;
-import javax.inject.Inject;
-import javax.inject.Qualifier;
-import javax.inject.Scope;
-import javax.lang.model.SourceVersion;
-import javax.lang.model.element.AnnotationMirror;
-import javax.lang.model.element.Element;
-import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.TypeElement;
-import javax.tools.Diagnostic;
-
-import static com.google.auto.common.MoreElements.isAnnotationPresent;
-import static dagger.internal.codegen.dagger1.Util.elementToString;
-import static javax.lang.model.element.ElementKind.CONSTRUCTOR;
-import static javax.lang.model.element.ElementKind.METHOD;
-import static javax.lang.model.element.Modifier.ABSTRACT;
-
-/**
- * Checks for errors that are not directly related to modules and {@code @Inject} annotated
- * elements.
- *
- * <p>Warnings for invalid use of qualifier annotations can be suppressed with
- * @SuppressWarnings("qualifiers")
- *
- * <p>Warnings for invalid use of scoping annotations can be suppressed with
- * @SuppressWarnings("scoping")
- */
-@AutoService(Processor.class)
-@SupportedAnnotationTypes({ "*" })
-public final class ValidationProcessor extends AbstractProcessor {
-
-  @Override public SourceVersion getSupportedSourceVersion() {
-    return SourceVersion.latestSupported();
-  }
-
-  @Override public boolean process(Set<? extends TypeElement> types, RoundEnvironment env) {
-    List<Element> allElements = new ArrayList<Element>();
-    Map<Element, Element> parametersToTheirMethods = new LinkedHashMap<Element, Element>();
-    getAllElements(env, allElements, parametersToTheirMethods);
-    for (Element element : allElements) {
-      try {
-        validateProvides(element);
-      } catch (CodeGenerationIncompleteException e) {
-        continue; // Upstream compiler issue in play. Ignore this element.
-      }
-      validateScoping(element);
-      validateQualifiers(element, parametersToTheirMethods);
-    }
-    return false;
-  }
-
-  private void validateProvides(Element element) {
-    if (isAnnotationPresent(element, Provides.class)
-        && Util.getAnnotation(Module.class, element.getEnclosingElement()) == null) {
-      error("@Provides methods must be declared in modules: " + elementToString(element), element);
-    }
-  }
-
-  private void validateQualifiers(Element element, Map<Element, Element> parametersToTheirMethods) {
-    boolean suppressWarnings = isAnnotationPresent(element, SuppressWarnings.class)
-       && Arrays.asList(element.getAnnotation(SuppressWarnings.class).value())
-           .contains("qualifiers");
-    int numberOfQualifiersOnElement = 0;
-    for (AnnotationMirror annotation : element.getAnnotationMirrors()) {
-      if (annotation.getAnnotationType().asElement().getAnnotation(Qualifier.class) == null) {
-       continue;
-      }
-      switch (element.getKind()) {
-        case FIELD:
-          numberOfQualifiersOnElement++;
-          if (element.getAnnotation(Inject.class) == null && !suppressWarnings) {
-            warning("Dagger will ignore qualifier annotations on fields that are not "
-                + "annotated with @Inject: " + elementToString(element), element);
-          }
-          break;
-        case METHOD:
-          numberOfQualifiersOnElement++;
-          if (!isProvidesMethod(element) && !suppressWarnings) {
-            warning("Dagger will ignore qualifier annotations on methods that are not "
-                + "@Provides methods: " + elementToString(element), element);
-          }
-          break;
-        case PARAMETER:
-          numberOfQualifiersOnElement++;
-          if (!isInjectableConstructorParameter(element, parametersToTheirMethods)
-              && !isProvidesMethodParameter(element, parametersToTheirMethods)
-              && !suppressWarnings) {
-            warning("Dagger will ignore qualifier annotations on parameters that are not "
-                + "@Inject constructor parameters or @Provides method parameters: "
-                + elementToString(element), element);
-          }
-          break;
-        default:
-          error("Qualifier annotations are only allowed on fields, methods, and parameters: "
-              + elementToString(element), element);
-      }
-    }
-    if (numberOfQualifiersOnElement > 1) {
-      error("Only one qualifier annotation is allowed per element: " + elementToString(element),
-          element);
-    }
-  }
-
-  private void validateScoping(Element element) {
-    boolean suppressWarnings = isAnnotationPresent(element, SuppressWarnings.class)
-        && Arrays.asList(element.getAnnotation(SuppressWarnings.class).value()).contains("scoping");
-    int numberOfScopingAnnotationsOnElement = 0;
-    for (AnnotationMirror annotation : element.getAnnotationMirrors()) {
-      if (annotation.getAnnotationType().asElement().getAnnotation(Scope.class) == null) {
-        continue;
-      }
-      switch (element.getKind()) {
-        case METHOD:
-          numberOfScopingAnnotationsOnElement++;
-          if (!isProvidesMethod(element) && !suppressWarnings) {
-            warning("Dagger will ignore scoping annotations on methods that are not "
-                + "@Provides methods: " + elementToString(element), element);
-          }
-          break;
-        case CLASS:
-          if (!element.getModifiers().contains(ABSTRACT)) {
-            numberOfScopingAnnotationsOnElement++;
-            break;
-          }
-        // fall through if abstract
-        default:
-          error("Scoping annotations are only allowed on concrete types and @Provides methods: "
-              + elementToString(element), element);
-      }
-    }
-    if (numberOfScopingAnnotationsOnElement > 1) {
-      error("Only one scoping annotation is allowed per element: " + elementToString(element),
-          element);
-    }
-  }
-
-  private void getAllElements(
-      RoundEnvironment env, List<Element> result, Map<Element, Element> parametersToTheirMethods) {
-    for (Element element : env.getRootElements()) {
-      addAllEnclosed(element, result, parametersToTheirMethods);
-    }
-  }
-
-  private void addAllEnclosed(
-      Element element, List<Element> result, Map<Element, Element> parametersToTheirMethods) {
-    result.add(element);
-    for (Element enclosed : element.getEnclosedElements()) {
-      addAllEnclosed(enclosed, result, parametersToTheirMethods);
-      if (enclosed.getKind() == METHOD || enclosed.getKind() == CONSTRUCTOR) {
-        for (Element parameter : ((ExecutableElement) enclosed).getParameters()) {
-          result.add(parameter);
-          parametersToTheirMethods.put(parameter, enclosed);
-        }
-      }
-    }
-  }
-
-  private boolean isProvidesMethod(Element element) {
-    return element.getKind() == METHOD && isAnnotationPresent(element, Provides.class);
-  }
-
-  /**
-   * @param parameter an {@code Element} whose {@code Kind} is parameter. The {@code Kind} is not
-   *        tested here.
-   */
-  private boolean isProvidesMethodParameter(
-      Element parameter, Map<Element, Element> parametersToTheirMethods) {
-    return isAnnotationPresent(parametersToTheirMethods.get(parameter), Provides.class);
-  }
-
-  /**
-   * @param parameter an {@code Element} whose {@code Kind} is parameter. The {@code Kind} is not
-   *        tested here.
-   */
-  private boolean isInjectableConstructorParameter(
-      Element parameter, Map<Element, Element> parametersToTheirMethods) {
-    return parametersToTheirMethods.get(parameter).getKind() == CONSTRUCTOR
-        && isAnnotationPresent(parametersToTheirMethods.get(parameter), Inject.class);
-  }
-
-  private void error(String msg, Element element) {
-    processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, msg, element);
-  }
-
-  private void warning(String msg, Element element) {
-    processingEnv.getMessager().printMessage(Diagnostic.Kind.WARNING, msg, element);
-  }
-
-}
diff --git a/compiler/src/test/java/dagger/internal/codegen/MultipleRequestTest.java b/compiler/src/test/java/dagger/internal/codegen/MultipleRequestTest.java
new file mode 100644
index 000000000..27e720d01
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/MultipleRequestTest.java
@@ -0,0 +1,119 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.common.collect.ImmutableList;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assert_;
+import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+
+@RunWith(JUnit4.class)
+public class MultipleRequestTest {
+  private static final JavaFileObject DEP_FILE = JavaFileObjects.forSourceLines("test.Dep",
+      "package test;",
+      "",
+      "import javax.inject.Inject;",
+      "",
+      "class Dep {",
+      "  @Inject Dep() {}",
+      "}");
+
+  @Test public void multipleRequests_constructor() {
+    assert_().about(javaSources())
+        .that(ImmutableList.of(
+            DEP_FILE,
+            JavaFileObjects.forSourceLines("test.ConstructorInjectsMultiple",
+                "package test;",
+                "",
+                "import javax.inject.Inject;",
+                "",
+                "class ConstructorInjectsMultiple {",
+                "  @Inject ConstructorInjectsMultiple(Dep d1, Dep d2) {}",
+                "}"),
+            JavaFileObjects.forSourceLines("test.SimpleComponent",
+                "package test;",
+                "",
+                "import dagger.Component;",
+                "",
+                "@Component",
+                "interface SimpleComponent {",
+                "  ConstructorInjectsMultiple get();",
+                "}")))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError();
+  }
+
+  @Test public void multipleRequests_field() {
+    assert_().about(javaSources())
+        .that(ImmutableList.of(
+            DEP_FILE,
+            JavaFileObjects.forSourceLines("test.FieldInjectsMultiple",
+                "package test;",
+                "",
+                "import javax.inject.Inject;",
+                "",
+                "class FieldInjectsMultiple {",
+                "  @Inject Dep d1;",
+                "  @Inject Dep d2;",
+                "  @Inject FieldInjectsMultiple() {}",
+                "}"),
+            JavaFileObjects.forSourceLines("test.SimpleComponent",
+                "package test;",
+                "",
+                "import dagger.Component;",
+                "",
+                "@Component",
+                "interface SimpleComponent {",
+                "  FieldInjectsMultiple get();",
+                "}")))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError();
+  }
+
+  @Test public void multipleRequests_providesMethod() {
+    assert_().about(javaSources())
+        .that(ImmutableList.of(
+            DEP_FILE,
+            JavaFileObjects.forSourceLines("test.FieldInjectsMultiple",
+                "package test;",
+                "",
+                "import dagger.Module;",
+                "import dagger.Provides;",
+                "",
+                "@Module",
+                "class SimpleModule {",
+                "  @Provides Object provide(Dep d1, Dep d2) {",
+                "    return null;",
+                "  }",
+                "}"),
+            JavaFileObjects.forSourceLines("test.SimpleComponent",
+                "package test;",
+                "",
+                "import dagger.Component;",
+                "",
+                "@Component(modules = SimpleModule.class)",
+                "interface SimpleComponent {",
+                "  Object get();",
+                "}")))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError();
+  }
+}
diff --git a/compiler/src/test/java/dagger/internal/codegen/dagger1/DotWriterTest.java b/compiler/src/test/java/dagger/internal/codegen/dagger1/DotWriterTest.java
deleted file mode 100644
index 5eecefbfc..000000000
--- a/compiler/src/test/java/dagger/internal/codegen/dagger1/DotWriterTest.java
+++ /dev/null
@@ -1,97 +0,0 @@
-/**
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen.dagger1;
-
-import java.io.IOException;
-import java.io.StringWriter;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-import static org.fest.assertions.Assertions.assertThat;
-
-@RunWith(JUnit4.class)
-public final class DotWriterTest {
-  private final StringWriter stringWriter = new StringWriter();
-  private final GraphVizWriter dotWriter = new GraphVizWriter(stringWriter);
-
-  @Test public void graphWithAttributes() throws IOException {
-    dotWriter.beginGraph();
-    dotWriter.edge("CoffeeMaker", "Heater", "style", "dotted", "color", "red");
-    dotWriter.edge("CoffeeMaker", "Pump");
-    dotWriter.node("CoffeeMaker", "shape", "box");
-    dotWriter.endGraph();
-    assertGraph(""
-        + "digraph G1 {\n"
-        + "  CoffeeMaker -> Heater [style=dotted;color=red];\n"
-        + "  CoffeeMaker -> Pump;\n"
-        + "  CoffeeMaker [shape=box];\n"
-        + "}\n");
-  }
-
-  @Test public void subgraph() throws IOException {
-    dotWriter.beginGraph("label", "10\" tall");
-    dotWriter.beginGraph("style", "filled", "color", "lightgrey");
-    dotWriter.edge("ElectricHeater", "Heater");
-    dotWriter.endGraph();
-    dotWriter.edge("CoffeeMaker", "Heater");
-    dotWriter.edge("CoffeeMaker", "Pump");
-    dotWriter.endGraph();
-    assertGraph(""
-        + "digraph G1 {\n"
-        + "  label = \"10\\\" tall\";\n"
-        + "  subgraph cluster2 {\n"
-        + "    style = filled;\n"
-        + "    color = lightgrey;\n"
-        + "    ElectricHeater -> Heater;\n"
-        + "  }\n"
-        + "  CoffeeMaker -> Heater;\n"
-        + "  CoffeeMaker -> Pump;\n"
-        + "}\n");
-  }
-
-  @Test public void defaultAttributes() throws IOException {
-    dotWriter.beginGraph();
-    dotWriter.nodeDefaults("color", "red");
-    dotWriter.edgeDefaults("style", "dotted");
-    dotWriter.edge("CoffeeMaker", "Heater");
-    dotWriter.endGraph();
-    assertGraph(""
-        + "digraph G1 {\n"
-        + "  node [color=red];\n"
-        + "  edge [style=dotted];\n"
-        + "  CoffeeMaker -> Heater;\n"
-        + "}\n");
-  }
-
-  @Test public void invalidNodeNames() throws IOException {
-    dotWriter.beginGraph();
-    dotWriter.edge("a.b", "a c");
-    dotWriter.edge("a c", "a_d");
-    dotWriter.endGraph();
-    assertGraph(""
-        + "digraph G1 {\n"
-        + "  n2 [label=\"a.b\"];\n"
-        + "  n3 [label=\"a c\"];\n"
-        + "  n2 -> n3;\n"
-        + "  n3 -> a_d;\n"
-        + "}\n");
-  }
-
-  private void assertGraph(String expected) {
-    assertThat(stringWriter.toString()).isEqualTo(expected);
-  }
-}
diff --git a/compiler/src/test/java/dagger/internal/codegen/dagger1/GraphVisualizerTest.java b/compiler/src/test/java/dagger/internal/codegen/dagger1/GraphVisualizerTest.java
deleted file mode 100644
index 8afd7b9bc..000000000
--- a/compiler/src/test/java/dagger/internal/codegen/dagger1/GraphVisualizerTest.java
+++ /dev/null
@@ -1,84 +0,0 @@
-/**
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen.dagger1;
-
-import dagger.internal.Keys;
-import java.lang.reflect.Field;
-import java.util.Map;
-import java.util.Set;
-import javax.inject.Named;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-import static org.fest.assertions.Assertions.assertThat;
-
-@RunWith(JUnit4.class)
-public final class GraphVisualizerTest {
-  private final GraphVisualizer graphVisualizer = new GraphVisualizer();
-
-  String simpleKey;
-  @Test public void testSimpleKey() throws Exception {
-    String key = fieldKey("simpleKey");
-    assertThat(graphVisualizer.shortName(key)).isEqualTo("String");
-  }
-
-  @SuppressWarnings("qualifiers")
-  @Named String annotatedKey;
-  @Test public void testAnnotatedKey() throws Exception {
-    String key = fieldKey("annotatedKey");
-    assertThat(graphVisualizer.shortName(key)).isEqualTo("@Named String");
-  }
-
-  @SuppressWarnings("qualifiers")
-  @Named("/@<>[]()") String annotatedKeyWithParameters;
-  @Test public void testAnnotatedKeyWithParameters() throws Exception {
-    String key = fieldKey("annotatedKeyWithParameters");
-    // We intentionally omit parameters on annotated keys!
-    assertThat(graphVisualizer.shortName(key)).isEqualTo("@Named String");
-  }
-
-  String[][] arrayKey;
-  @Test public void testArrayKey() throws Exception {
-    String key = fieldKey("arrayKey");
-    assertThat(graphVisualizer.shortName(key)).isEqualTo("String[][]");
-  }
-
-  Map<String, Set<Object>> typeParameterKey;
-  @Test public void testTypeParameterKey() throws Exception {
-    String key = fieldKey("typeParameterKey");
-    assertThat(graphVisualizer.shortName(key))
-        .isEqualTo("Map<java.lang.String, java.util.Set<java.lang.Object>>");
-  }
-
-  @SuppressWarnings("qualifiers")
-  @Named("/@<>[]()") Map<String, Set<Object>>[] everythingKey;
-  @Test public void testEverythingKey() throws Exception {
-    String key = fieldKey("everythingKey");
-    assertThat(graphVisualizer.shortName(key))
-        .isEqualTo("@Named Map<java.lang.String, java.util.Set<java.lang.Object>>[]");
-  }
-
-  @Test public void testMembersKey() throws Exception {
-    String key = Keys.getMembersKey(String.class);
-    assertThat(graphVisualizer.shortName(key)).isEqualTo("String");
-  }
-
-  private String fieldKey(String fieldName) throws NoSuchFieldException {
-    Field field = GraphVisualizerTest.class.getDeclaredField(fieldName);
-    return Keys.get(field.getGenericType(), field.getAnnotations(), field);
-  }
-}
diff --git a/compiler/src/test/java/dagger/testing/it/BuildLogValidator.java b/compiler/src/test/java/dagger/testing/it/BuildLogValidator.java
deleted file mode 100644
index ebd11b68e..000000000
--- a/compiler/src/test/java/dagger/testing/it/BuildLogValidator.java
+++ /dev/null
@@ -1,108 +0,0 @@
-/*
- * Copyright (C) 2012 Google, Inc.
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.testing.it;
-
-import java.io.File;
-import java.io.FileInputStream;
-import java.nio.MappedByteBuffer;
-import java.nio.channels.FileChannel;
-import java.nio.charset.Charset;
-
-// TODO(user) remove when invoker tests are deleted.
-public class BuildLogValidator {
-
-  /**
-   * Processes a log file, ensuring it has all the provided strings within it.
-   *
-   * @param buildLogfile a log file to be searched
-   * @param expectedStrings the strings that must be present in the log file for it to be valid
-   */
-  public void assertHasText(File buildLogfile, String ... expectedStrings) throws Throwable {
-    String buildOutput = getBuildOutput(buildLogfile);
-
-    StringBuilder sb = new StringBuilder("Build output did not contain expected error text:");
-    boolean missing = false;
-
-    for (String expected : expectedStrings) {
-      if (!buildOutput.contains(expected)) {
-        missing = true;
-        sb.append("\n    \"").append(expected).append("\"");
-      }
-    }
-    if (missing) {
-      appendBuildStatus(sb, buildOutput);
-      throw new Exception(sb.toString());
-    }
-  }
-
-  /**
-   * Processes a log file, ensuring it does not contain any of the provided strings within it.
-   *
-   * @param buildLogfile a log file to be searched
-   * @param unexpectedStrings the strings that must not be present in the log file for it to be
-   *        valid
-   */
-  public void assertDoesNotHaveText(File buildLogfile, String... unexpectedStrings)
-      throws Throwable {
-    String buildOutput = getBuildOutput(buildLogfile);
-
-    StringBuilder sb = new StringBuilder("Build output contained unexpected text:");
-    boolean found = false;
-
-    for (String unexpected : unexpectedStrings) {
-      if (buildOutput.contains(unexpected)) {
-        found = true;
-        sb.append("\n    \"").append(unexpected).append("\"");
-      }
-    }
-    if (found) {
-      appendBuildStatus(sb, buildOutput);
-      throw new Exception(sb.toString());
-    }
-  }
-
-  private String getBuildOutput(File buildLogfile) throws Throwable {
-    String buildOutput;
-    FileInputStream stream = new FileInputStream(buildLogfile);
-    try {
-      FileChannel fc = stream.getChannel();
-      MappedByteBuffer buf = fc.map(FileChannel.MapMode.READ_ONLY, 0, fc.size());
-      buildOutput = Charset.defaultCharset().decode(buf).toString();
-    } finally {
-      stream.close();
-    }
-    if (buildOutput == null) {
-      throw new Exception("Could not read build output");
-    }
-    return buildOutput;
-  }
-
-  private void appendBuildStatus(StringBuilder sb, String buildOutput) {
-    sb.append("\n\nBuild Output:\n\n");
-    boolean containsError = false;
-    for(String line : buildOutput.split("\n")) {
-      if (line.contains("[ERROR]")) {
-        containsError = true;
-        sb.append("\n        ").append(line);
-      }
-    }
-    if (!containsError) {
-      sb.append("\nTEST BUILD SUCCEEDED.\n");
-    }
-  }
-
-}
diff --git a/compiler/src/test/java/dagger/tests/integration/codegen/dagger1/InjectAdapterGenerationTest.java b/compiler/src/test/java/dagger/tests/integration/codegen/dagger1/InjectAdapterGenerationTest.java
deleted file mode 100644
index 703cf83d3..000000000
--- a/compiler/src/test/java/dagger/tests/integration/codegen/dagger1/InjectAdapterGenerationTest.java
+++ /dev/null
@@ -1,79 +0,0 @@
-/*
- * Copyright (C) 2013 Google Inc.
- * Copyright (C) 2013 Square Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.tests.integration.codegen.dagger1;
-
-import com.google.common.base.Joiner;
-import com.google.testing.compile.JavaFileObjects;
-import javax.tools.JavaFileObject;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-import static com.google.common.truth.Truth.assert_;
-import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
-import static dagger.tests.integration.dagger1.ProcessorTestUtils.daggerProcessors;
-
-@RunWith(JUnit4.class)
-public final class InjectAdapterGenerationTest {
-  @Test public void basicInjectAdapter() {
-    JavaFileObject sourceFile = JavaFileObjects.forSourceString("Basic", Joiner.on("\n").join(
-        "import dagger.Module;",
-        "import javax.inject.Inject;",
-        "class Basic {",
-        "  static class A { @Inject A() { } }",
-        "  @Module(injects = A.class)",
-        "  static class AModule { }",
-        "}"));
-
-    JavaFileObject expectedModuleAdapter =
-        JavaFileObjects.forSourceString("Basic$AModule$$ModuleAdapter", Joiner.on("\n").join(
-            "import dagger.internal.ModuleAdapter;",
-            "public final class Basic$AModule$$ModuleAdapter",
-            "    extends ModuleAdapter<Basic.AModule> {",
-            "  private static final String[] INJECTS = {\"members/Basic$A\"};",
-            "  private static final Class<?>[] STATIC_INJECTIONS = {};",
-            "  private static final Class<?>[] INCLUDES = {};",
-            "  public Basic$AModule$$ModuleAdapter() {",
-            "    super(Basic.AModule.class, INJECTS, STATIC_INJECTIONS, false, INCLUDES,",
-            "      true, true);",
-            "  }",
-            "  @Override public Basic.AModule newModule() {",
-            "    return new Basic.AModule();",
-            "  }",
-            "}"));
-
-    JavaFileObject expectedInjectAdapter =
-        JavaFileObjects.forSourceString("Basic$A$$InjectAdapter", Joiner.on("\n").join(
-            "import dagger.internal.Binding;",
-            "import javax.inject.Provider;",
-            "public final class Basic$A$$InjectAdapter",
-            "    extends Binding<Basic.A> implements Provider<Basic.A> {",
-            "  public Basic$A$$InjectAdapter() {",
-            "    super(\"Basic$A\", \"members/Basic$A\", NOT_SINGLETON, Basic.A.class);",
-            "  }",
-            "  @Override public Basic.A get() {",
-            "    Basic.A result = new Basic.A();",
-            "    return result;",
-            "  }",
-            "}"));
-
-    assert_().about(javaSource()).that(sourceFile).processedWith(daggerProcessors())
-        .compilesWithoutError().and()
-        .generatesSources(expectedModuleAdapter, expectedInjectAdapter);
-
-  }
-}
diff --git a/compiler/src/test/java/dagger/tests/integration/codegen/dagger1/ModuleAdapterGenerationTest.java b/compiler/src/test/java/dagger/tests/integration/codegen/dagger1/ModuleAdapterGenerationTest.java
deleted file mode 100644
index 12ef23f0c..000000000
--- a/compiler/src/test/java/dagger/tests/integration/codegen/dagger1/ModuleAdapterGenerationTest.java
+++ /dev/null
@@ -1,260 +0,0 @@
-/*
- * Copyright (C) 2013 Google Inc.
- * Copyright (C) 2013 Square Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.tests.integration.codegen.dagger1;
-
-import com.google.common.base.Joiner;
-import com.google.testing.compile.JavaFileObjects;
-import javax.tools.JavaFileObject;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-import static com.google.common.truth.Truth.assert_;
-import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
-import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
-import static dagger.tests.integration.dagger1.ProcessorTestUtils.daggerProcessors;
-import static java.util.Arrays.asList;
-
-@RunWith(JUnit4.class)
-public final class ModuleAdapterGenerationTest {
-  /**
-   * Shows current behavior for a {@link dagger.Provides provides method}
-   * used to supply an injected ctor parameter.
-   *
-   * <ul>
-   *   <li>{@code ProvidesAdapter} invokes the module's provides method on
-   *   {@code get}</li>
-   *   <li>On {@code getBindings}, the above is newed up and linked to its type
-   *   key.
-   *   <li>{@code InjectAdapter} contains a field for the parameter binding,
-   *   referenced in {@code getDependencies} and set on {@code attach}</li>
-   *   <li>On {@code get}, the injected constructor is called with the value of
-   *   {@link dagger.internal.Binding#get}</li>
-   * </ul>
-   */
-  @Test public void providerForCtorInjection() {
-    JavaFileObject sourceFile = JavaFileObjects.forSourceString("Field", Joiner.on("\n").join(
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "import javax.inject.Inject;",
-        "class Field {",
-        "  static class A { final String name; @Inject A(String name) { this.name = name; }}",
-        "  @Module(injects = { A.class, String.class })",
-        "  static class AModule { @Provides String name() { return \"foo\"; }}",
-        "}"));
-
-    JavaFileObject expectedModuleAdapter =
-        JavaFileObjects.forSourceString("Field$AModule$$ModuleAdapter", Joiner.on("\n").join(
-        "import dagger.internal.BindingsGroup;",
-        "import dagger.internal.ModuleAdapter;",
-        "import dagger.internal.ProvidesBinding;",
-        "import javax.inject.Provider;",
-        "public final class Field$AModule$$ModuleAdapter",
-        "    extends ModuleAdapter<Field.AModule> {",
-        "  private static final String[] INJECTS = ",
-        "      {\"members/Field$A\", \"members/java.lang.String\"};",
-        "  private static final Class<?>[] STATIC_INJECTIONS = {};",
-        "  private static final Class<?>[] INCLUDES = {};",
-        "  public Field$AModule$$ModuleAdapter() {",
-        "    super(Field.AModule.class, INJECTS, STATIC_INJECTIONS, false, INCLUDES, true, true);",
-        "  }",
-        "  @Override public Field.AModule newModule() {",
-        "    return new Field.AModule();",
-        "  }",
-        "  @Override public void getBindings(BindingsGroup bindings, Field.AModule module) {",
-        "    bindings.contributeProvidesBinding(\"java.lang.String\",",
-        "        new NameProvidesAdapter(module));", // eager new!
-        "  }",
-        "  public static final class NameProvidesAdapter", // corresponds to method name
-        "      extends ProvidesBinding<String> implements Provider<String> {",
-        "    private final Field.AModule module;",
-        "    public NameProvidesAdapter(Field.AModule module) {",
-        "      super(\"java.lang.String\", NOT_SINGLETON, \"Field.AModule\", \"name\");",
-        "      this.module = module;",
-        "      setLibrary(true);",
-        "    }",
-        "    @Override public String get() {",
-        "      return module.name();", // corresponds to @Provides method
-        "    }",
-        "  }",
-        "}"));
-
-    JavaFileObject expectedInjectAdapter =
-        JavaFileObjects.forSourceString("Field$A$$InjectAdapter", Joiner.on("\n").join(
-            "import dagger.internal.Binding;",
-            "import dagger.internal.Linker;",
-            "import java.util.Set;",
-            "import javax.inject.Provider;",
-            "public final class Field$A$$InjectAdapter",
-            "    extends Binding<Field.A> implements Provider<Field.A> {",
-            "  private Binding<String> name;", // for ctor
-            "  public Field$A$$InjectAdapter() {",
-            "    super(\"Field$A\", \"members/Field$A\", NOT_SINGLETON, Field.A.class);",
-            "  }",
-            "  @Override @SuppressWarnings(\"unchecked\")",
-            "  public void attach(Linker linker) {",
-            "    name = (Binding<String>)linker.requestBinding(", // binding key is not a class
-            "      \"java.lang.String\", Field.A.class, getClass().getClassLoader());",
-            "  }",
-            "  @Override public void getDependencies(",
-            "      Set<Binding<?>> getBindings, Set<Binding<?>> injectMembersBindings) {",
-            "    getBindings.add(name);", // name is added to dependencies
-            "  }",
-            "  @Override public Field.A get() {",
-            "    Field.A result = new Field.A(name.get());", // adds ctor param
-            "    return result;",
-            "  }",
-            "}"));
-
-    assert_().about(javaSource()).that(sourceFile).processedWith(daggerProcessors())
-        .compilesWithoutError()
-        .and()
-        .generatesSources(expectedModuleAdapter, expectedInjectAdapter);
-
-  }
-
-  @Test public void injectsMembersInjectedAndProvidedAndConstructedTypes() {
-    JavaFileObject sourceFile = JavaFileObjects.forSourceString("Field", Joiner.on("\n").join(
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "import javax.inject.Inject;",
-        "class Field {",
-        "  static class A { final String name; @Inject A(String name) { this.name = name; }}",
-        "  static class B { @Inject String name; }",
-        "  @Module(injects = { A.class, String.class, B.class })",
-        "  static class AModule { @Provides String name() { return \"foo\"; }}",
-        "}"));
-
-    JavaFileObject expectedModuleAdapter =
-        JavaFileObjects.forSourceString("Field$AModule$$ModuleAdapter", Joiner.on("\n").join(
-        "import dagger.internal.BindingsGroup;",
-        "import dagger.internal.ModuleAdapter;",
-        "import dagger.internal.ProvidesBinding;",
-        "import javax.inject.Provider;",
-        "public final class Field$AModule$$ModuleAdapter extends ModuleAdapter<Field.AModule> {",
-        "  private static final String[] INJECTS = ",
-        "      {\"members/Field$A\", \"members/java.lang.String\", \"members/Field$B\"};",
-        "  private static final Class<?>[] STATIC_INJECTIONS = {};",
-        "  private static final Class<?>[] INCLUDES = {};",
-        "  public Field$AModule$$ModuleAdapter() {",
-        "    super(Field.AModule.class, INJECTS, STATIC_INJECTIONS, false, INCLUDES, true, true);",
-        "  }",
-        "  @Override public Field.AModule newModule() {",
-        "    return new Field.AModule();",
-        "  }",
-        "  @Override public void getBindings(BindingsGroup bindings, Field.AModule module) {",
-        "    bindings.contributeProvidesBinding(\"java.lang.String\",",
-        "        new NameProvidesAdapter(module));", // eager new!
-        "  }",
-        "  public static final class NameProvidesAdapter", // corresponds to method name
-        "      extends ProvidesBinding<String> implements Provider<String> {",
-        "    private final Field.AModule module;",
-        "    public NameProvidesAdapter(Field.AModule module) {",
-        "      super(\"java.lang.String\", NOT_SINGLETON, \"Field.AModule\", \"name\");",
-        "      this.module = module;",
-        "      setLibrary(true);",
-        "    }",
-        "    @Override public String get() {",
-        "      return module.name();", // corresponds to @Provides method
-        "    }",
-        "  }",
-        "}"));
-
-    JavaFileObject expectedInjectAdapterA =
-        JavaFileObjects.forSourceString("Field$A$$InjectAdapter", Joiner.on("\n").join(
-            "import dagger.internal.Binding;",
-            "import dagger.internal.Linker;",
-            "import java.util.Set;",
-            "import javax.inject.Provider;",
-            "public final class Field$A$$InjectAdapter",
-            "    extends Binding<Field.A> implements Provider<Field.A> {",
-            "  private Binding<String> name;", // For Constructor.
-            "  public Field$A$$InjectAdapter() {",
-            "    super(\"Field$A\", \"members/Field$A\", NOT_SINGLETON, Field.A.class);",
-            "  }",
-            "  @Override @SuppressWarnings(\"unchecked\")",
-            "  public void attach(Linker linker) {",
-            "    name = (Binding<String>)linker.requestBinding(",
-            "      \"java.lang.String\", Field.A.class, getClass().getClassLoader());",
-            "  }",
-            "  @Override public void getDependencies(",
-            "      Set<Binding<?>> getBindings, Set<Binding<?>> injectMembersBindings) {",
-            "    getBindings.add(name);", // Name is added to dependencies.
-            "  }",
-            "  @Override public Field.A get() {",
-            "    Field.A result = new Field.A(name.get());", // Adds constructor parameter.
-            "    return result;",
-            "  }",
-            "}"));
-
-    JavaFileObject expectedInjectAdapterB =
-        JavaFileObjects.forSourceString("Field$B$$InjectAdapter", Joiner.on("\n").join(
-            "import dagger.MembersInjector;",
-            "import dagger.internal.Binding;",
-            "import dagger.internal.Linker;",
-            "import java.util.Set;",
-            "import javax.inject.Provider;",
-            "public final class Field$B$$InjectAdapter",
-            "    extends Binding<Field.B> implements Provider<Field.B>, MembersInjector<Field.B> {",
-            "  private Binding<String> name;", // For field.
-            "  public Field$B$$InjectAdapter() {",
-            "    super(\"Field$B\", \"members/Field$B\", NOT_SINGLETON, Field.B.class);",
-            "  }",
-            "  @Override @SuppressWarnings(\"unchecked\")",
-            "  public void attach(Linker linker) {",
-            "    name = (Binding<String>)linker.requestBinding(",
-            "      \"java.lang.String\", Field.B.class, getClass().getClassLoader());",
-            "  }",
-            "  @Override public void getDependencies(",
-            "      Set<Binding<?>> getBindings, Set<Binding<?>> injectMembersBindings) {",
-            "    injectMembersBindings.add(name);", // Name is added to dependencies.
-            "  }",
-            "  @Override public Field.B get() {",
-            "    Field.B result = new Field.B();",
-            "    injectMembers(result);",
-            "    return result;",
-            "  }",
-            "  @Override public void injectMembers(Field.B object) {",
-            "    object.name = name.get();", // Inject field.
-            "  }",
-            "}"));
-    assert_().about(javaSource()).that(sourceFile).processedWith(daggerProcessors())
-        .compilesWithoutError()
-        .and()
-        .generatesSources(expectedModuleAdapter, expectedInjectAdapterA, expectedInjectAdapterB);
-  }
-
-  @Test public void providesHasParameterNamedModule() {
-    JavaFileObject a = JavaFileObjects.forSourceString("A", Joiner.on("\n").join(
-        "import javax.inject.Inject;",
-        "class A { @Inject A(){ }}"));
-    JavaFileObject b = JavaFileObjects.forSourceString("B", Joiner.on("\n").join(
-        "import javax.inject.Inject;",
-        "class B { @Inject B(){ }}"));
-
-    JavaFileObject module = JavaFileObjects.forSourceString("BModule", Joiner.on("\n").join(
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "import javax.inject.Inject;",
-        "@Module(injects = B.class)",
-        "class BModule { @Provides B b(A module) { return new B(); }}"));
-
-    assert_().about(javaSources()).that(asList(a, b, module)).processedWith(daggerProcessors())
-        .compilesWithoutError();
-  }
-
-}
diff --git a/compiler/src/test/java/dagger/tests/integration/dagger1/ProcessorTestUtils.java b/compiler/src/test/java/dagger/tests/integration/dagger1/ProcessorTestUtils.java
deleted file mode 100644
index ea4c6f6d5..000000000
--- a/compiler/src/test/java/dagger/tests/integration/dagger1/ProcessorTestUtils.java
+++ /dev/null
@@ -1,37 +0,0 @@
-/*
- * Copyright (c) 2013 Google, Inc.
- * Copyright (c) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.tests.integration.dagger1;
-
-import dagger.internal.codegen.dagger1.GraphAnalysisProcessor;
-import dagger.internal.codegen.dagger1.InjectAdapterProcessor;
-import dagger.internal.codegen.dagger1.ModuleAdapterProcessor;
-import dagger.internal.codegen.dagger1.ValidationProcessor;
-import java.util.Arrays;
-import javax.annotation.processing.Processor;
-
-/**
- * Internal test utilities.
- */
-public class ProcessorTestUtils {
-  public static Iterable<? extends Processor> daggerProcessors() {
-    return Arrays.asList(
-        new InjectAdapterProcessor(),
-        new ModuleAdapterProcessor(),
-        new GraphAnalysisProcessor(),
-        new ValidationProcessor());
-  }
-}
diff --git a/compiler/src/test/java/dagger/tests/integration/operation/dagger1/FailureModeErrorsTest.java b/compiler/src/test/java/dagger/tests/integration/operation/dagger1/FailureModeErrorsTest.java
deleted file mode 100644
index fd530d9ad..000000000
--- a/compiler/src/test/java/dagger/tests/integration/operation/dagger1/FailureModeErrorsTest.java
+++ /dev/null
@@ -1,77 +0,0 @@
-/**
- * Copyright (C) 2014 Google, Inc.
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.tests.integration.operation.dagger1;
-
-import dagger.Module;
-import dagger.ObjectGraph;
-import javax.inject.Inject;
-import javax.inject.Qualifier;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-import static junit.framework.Assert.fail;
-import static org.fest.assertions.Assertions.assertThat;
-
-@RunWith(JUnit4.class)
-public final class FailureModeErrorsTest {
-
-  @Module
-  static class CompleteModule {}
-
-  static class ArrayFoo {
-    @Inject ArrayFoo(String[] ignored) {}
-  }
-
-  @Module(injects = ArrayFoo.class, complete = false)
-  static class ArrayFooModule {}
-
-  @Test public void failOnMissingModule_array_or_generics() {
-    // Generics here are crazy to try to test for, but this code path is legit regardless.
-    try {
-      ObjectGraph.create(new CompleteModule(), new ArrayFooModule()).get(ArrayFoo.class);
-      fail("Should have thrown.");
-    } catch (IllegalStateException e) {
-      assertThat(e.getMessage()).contains(
-          "java.lang.String[] is a generic class or an array and can only be bound with "
-              + "concrete type parameter(s) in a @Provides method. required by class "
-              + FailureModeErrorsTest.class.getCanonicalName() + "$ArrayFoo");
-    }
-  }
-
-  @Qualifier @interface MyFoo {}
-
-  static class QualifyingFoo {
-    @Inject QualifyingFoo(@MyFoo String ignored) {}
-  }
-
-  @Module(injects = QualifyingFoo.class, complete = false)
-  static class QualifyingFooModule {}
-
-  @Test public void failOnMissingModule_qualified() {
-    try {
-      ObjectGraph.create(new CompleteModule(), new QualifyingFooModule()).get(QualifyingFoo.class);
-      fail("Should have thrown.");
-    } catch (IllegalStateException e) {
-      assertThat(e.getMessage()).contains(
-          "@" + FailureModeErrorsTest.class.getCanonicalName() + "$MyFoo()/java.lang.String "
-              + "is a @Qualifier-annotated type and must be bound by a @Provides method. required "
-              + "by class "
-              + FailureModeErrorsTest.class.getCanonicalName() + "$QualifyingFoo");
-    }
-  }
-}
diff --git a/compiler/src/test/java/dagger/tests/integration/operation/dagger1/SimpleInjectionTest.java b/compiler/src/test/java/dagger/tests/integration/operation/dagger1/SimpleInjectionTest.java
deleted file mode 100644
index c5b3acd0b..000000000
--- a/compiler/src/test/java/dagger/tests/integration/operation/dagger1/SimpleInjectionTest.java
+++ /dev/null
@@ -1,90 +0,0 @@
-/**
- * Copyright (C) 2013 Google, Inc.
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.tests.integration.operation.dagger1;
-
-import dagger.Module;
-import dagger.ObjectGraph;
-import dagger.Provides;
-import javax.inject.Inject;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-import static com.google.common.truth.Truth.assert_;
-
-@RunWith(JUnit4.class)
-public final class SimpleInjectionTest {
-  static abstract class AbstractFoo {
-    @Inject String blah;
-  }
-
-  static class Foo extends AbstractFoo { }
-
-  @Module(injects = Foo.class)
-  static class FooModule {
-    @Provides String string() { return "blah"; }
-  }
-
-  @Module(injects = Foo.class)
-  static class ProvidingFooModule {
-    @Provides String string() { return "blah"; }
-    @Provides Foo foo(String blah) {
-      Foo foo = new Foo();
-      foo.blah = blah;
-      return foo;
-    }
-  }
-
-  @Test public void memberInject_WithoutProvidesMethod() {
-    Foo foo = new Foo();
-    ObjectGraph.create(FooModule.class).inject(foo);
-    assert_().that(foo.blah).isEqualTo("blah");
-  }
-
-  @Test public void membersInject_WithProvidesMethod() {
-    Foo foo = new Foo();
-    ObjectGraph.create(ProvidingFooModule.class).inject(foo);
-    assert_().that(foo.blah).isEqualTo("blah");
-  }
-
-  @Test public void get_WithProvidesMethod() {
-    Foo foo = ObjectGraph.create(ProvidingFooModule.class).get(Foo.class);
-    assert_().that(foo.blah).isEqualTo("blah");
-  }
-
-  static class Bar { }
-
-  @Module(injects = Bar.class)
-  static class BarModule {
-  }
-
-  @Test public void membersInject_WithNonInjectable() {
-    Bar bar = new Bar();
-    ObjectGraph.create(BarModule.class).inject(bar);
-  }
-
-  @Module(injects = Bar.class)
-  static class ProvidingBarModule {
-    @Provides public Bar bar() { return new Bar(); }
-  }
-
-  @Test public void membersInject_WithProvidedNonInjectable() {
-    Bar bar = ObjectGraph.create(ProvidingBarModule.class).get(Bar.class);
-    assert_().that(bar).isNotNull();
-  }
-
-}
diff --git a/compiler/src/test/java/dagger/tests/integration/validation/dagger1/CyclicDependencyTest.java b/compiler/src/test/java/dagger/tests/integration/validation/dagger1/CyclicDependencyTest.java
deleted file mode 100644
index f09be125d..000000000
--- a/compiler/src/test/java/dagger/tests/integration/validation/dagger1/CyclicDependencyTest.java
+++ /dev/null
@@ -1,85 +0,0 @@
-/**
- * Copyright (c) 2013 Google, Inc.
- * Copyright (c) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.tests.integration.validation.dagger1;
-
-import com.google.common.base.Joiner;
-import com.google.testing.compile.JavaFileObjects;
-import javax.tools.JavaFileObject;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-import static com.google.common.truth.Truth.assert_;
-import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
-import static dagger.tests.integration.dagger1.ProcessorTestUtils.daggerProcessors;
-
-@RunWith(JUnit4.class)
-public class CyclicDependencyTest {
-
-  @Test public void cyclicDepsWithInjectables() {
-    JavaFileObject sourceFile = JavaFileObjects.forSourceString("CyclicDeps", Joiner.on("\n").join(
-        "import dagger.Module;",
-        "import javax.inject.Inject;",
-        "class CyclicDeps {",
-        "  static class Foo {",
-        "    @Inject Foo(Bar b) { }",
-        "  }",
-        "  static class Bar {",
-        "    @Inject Bar(Blah b) { }",
-        "  }",
-        "  static class Blah {",
-        "    @Inject Blah(Foo f) { }",
-        "  }",
-        "  static class EntryPoint {",
-        "    @Inject Foo f;",
-        "  }",
-        "  @Module(injects = EntryPoint.class)",
-        "  static class TestModule { }",
-        "}"));
-
-    assert_().about(javaSource()).that(sourceFile).processedWith(daggerProcessors()).failsToCompile()
-        .withErrorContaining("0. CyclicDeps$Foo bound by").in(sourceFile).onLine(17).and()
-        .withErrorContaining("1. CyclicDeps$Bar bound by").in(sourceFile).onLine(17).and()
-        .withErrorContaining("2. CyclicDeps$Blah bound by").in(sourceFile).onLine(17);
-  }
-
-  @Test public void cyclicDepsWithProvidesMethods() {
-    JavaFileObject sourceFile = JavaFileObjects.forSourceString("CyclicDeps", Joiner.on("\n").join(
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "class CyclicDeps {",
-        "  static class A { }",
-        "  static class B { }",
-        "  static class C { }",
-        "  static class D { }",
-        "  @Module(injects = D.class)",
-        "  static class CyclicModule {",
-        "    @Provides A a(D d) { return null; }",
-        "    @Provides B b(A a) { return null; }",
-        "    @Provides C c(B b) { return null; }",
-        "    @Provides D d(C c) { return null; }",
-        "  }",
-        "}"));
-
-    assert_().about(javaSource()).that(sourceFile).processedWith(daggerProcessors()).failsToCompile()
-        .withErrorContaining("0. CyclicDeps$A bound by Provides").in(sourceFile).onLine(9).and()
-        .withErrorContaining("1. CyclicDeps$D bound by Provides").in(sourceFile).onLine(9).and()
-        .withErrorContaining("2. CyclicDeps$C bound by Provides").in(sourceFile).onLine(9).and()
-        .withErrorContaining("3. CyclicDeps$B bound by Provides").in(sourceFile).onLine(9);
-  }
-
-}
diff --git a/compiler/src/test/java/dagger/tests/integration/validation/dagger1/CyclicModuleIncludesTest.java b/compiler/src/test/java/dagger/tests/integration/validation/dagger1/CyclicModuleIncludesTest.java
deleted file mode 100644
index b7e43f4dc..000000000
--- a/compiler/src/test/java/dagger/tests/integration/validation/dagger1/CyclicModuleIncludesTest.java
+++ /dev/null
@@ -1,84 +0,0 @@
-/**
- * Copyright (c) 2013 Google, Inc.
- * Copyright (c) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.tests.integration.validation.dagger1;
-
-import com.google.common.base.Joiner;
-import com.google.testing.compile.JavaFileObjects;
-import javax.tools.JavaFileObject;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-import static com.google.common.truth.Truth.assert_;
-import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
-import static dagger.tests.integration.dagger1.ProcessorTestUtils.daggerProcessors;
-
-@RunWith(JUnit4.class)
-public class CyclicModuleIncludesTest {
-  private final JavaFileObject javaFile =
-      JavaFileObjects.forSourceString("CyclicModules", Joiner.on("\n").join(
-          "import dagger.Module;",
-          "class CyclicModules {",
-          "  @Module(includes = SelfReferencingModule.class)",
-          "  static class SelfReferencingModule { }",
-          "  @Module(includes = Spock.class)",
-          "  static class Rock {}",
-          "  @Module(includes = Rock.class)",
-          "  static class Paper {}",
-          "  @Module(includes = Paper.class)",
-          "  static class Scissors {}",
-          "  @Module(includes = Scissors.class)",
-          "  static class Lizard {}",
-          "  @Module(includes = Lizard.class)",
-          "  static class Spock {}",
-          "}"));
-
-  @Test public void cyclicModuleSelfIncludes() {
-    assert_().about(javaSource()).that(javaFile).processedWith(daggerProcessors()).failsToCompile()
-        .withErrorContaining("CyclicModules.SelfReferencingModule includes itself directly")
-            .in(javaFile).onLine(4);
-  }
-
-  @Test public void cyclicModuleIncludes_full_cycle() {
-    assert_().about(javaSource()).that(javaFile).processedWith(daggerProcessors()).failsToCompile()
-        .withErrorContaining("0. CyclicModules.Rock included by CyclicModules.Paper")
-            .in(javaFile).onLine(6).and()
-        .withErrorContaining("1. CyclicModules.Paper included by CyclicModules.Scissors")
-            .in(javaFile).onLine(6).and()
-        .withErrorContaining("2. CyclicModules.Scissors included by CyclicModules.Lizard")
-            .in(javaFile).onLine(6).and()
-        .withErrorContaining("3. CyclicModules.Lizard included by CyclicModules.Spock")
-            .in(javaFile).onLine(6).and()
-        .withErrorContaining("4. CyclicModules.Spock included by CyclicModules.Rock")
-            .in(javaFile).onLine(6);
-  }
-
-  @Test public void cyclicModuleIncludes_initial_inclusion() {
-    assert_().about(javaSource()).that(javaFile).processedWith(daggerProcessors()).failsToCompile()
-        .withErrorContaining("0. CyclicModules.Rock included by CyclicModules.Paper")
-            .in(javaFile).onLine(6).and()
-        .withErrorContaining("0. CyclicModules.Paper included by CyclicModules.Scissors")
-            .in(javaFile).onLine(8).and()
-        .withErrorContaining("0. CyclicModules.Scissors included by CyclicModules.Lizard")
-            .in(javaFile).onLine(10).and()
-        .withErrorContaining("0. CyclicModules.Lizard included by CyclicModules.Spock")
-            .in(javaFile).onLine(12).and()
-        .withErrorContaining("0. CyclicModules.Spock included by CyclicModules.Rock")
-            .in(javaFile).onLine(14);
-  }
-
-}
diff --git a/compiler/src/test/java/dagger/tests/integration/validation/dagger1/GeneratedTypesNotReadyTest.java b/compiler/src/test/java/dagger/tests/integration/validation/dagger1/GeneratedTypesNotReadyTest.java
deleted file mode 100644
index 1e41f2292..000000000
--- a/compiler/src/test/java/dagger/tests/integration/validation/dagger1/GeneratedTypesNotReadyTest.java
+++ /dev/null
@@ -1,211 +0,0 @@
-/**
- * Copyright (c) 2013 Google, Inc.
- * Copyright (c) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.tests.integration.validation.dagger1;
-
-import com.google.common.base.Joiner;
-import com.google.testing.compile.JavaFileObjects;
-import java.io.IOException;
-import java.io.Writer;
-import java.util.Set;
-import javax.annotation.processing.AbstractProcessor;
-import javax.annotation.processing.RoundEnvironment;
-import javax.annotation.processing.SupportedAnnotationTypes;
-import javax.lang.model.SourceVersion;
-import javax.lang.model.element.TypeElement;
-import javax.tools.JavaFileObject;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-import static com.google.common.collect.Iterables.concat;
-import static com.google.common.truth.Truth.assert_;
-import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
-import static dagger.tests.integration.dagger1.ProcessorTestUtils.daggerProcessors;
-import static java.util.Arrays.asList;
-
-/**
- * Tests that the annotation processor(s) will properly handle the case where
- * code they are processing and depending on is generated by other processors
- * in the environment, and so the types they need may not exist yet.
- */
-@RunWith(JUnit4.class)
-public class GeneratedTypesNotReadyTest {
-  private final JavaFileObject foo = JavaFileObjects.forSourceString("Foo", Joiner.on("\n").join(
-      "package myPackage;",
-      "public interface Foo {}"
-  ));
-  private final JavaFileObject main = JavaFileObjects.forSourceString("Main", Joiner.on("\n").join(
-      "import javax.inject.Inject;",
-      "import myPackage.Foo;",
-      "class Main {",
-      "  @Inject Foo f;",
-      "}"));
-
-  @Test public void withstandsMissingTypeReferencedInInjects() {
-    // TODO(user): remove Foo (interface) from this when injects= analysis is fixed.
-    JavaFileObject module = JavaFileObjects.forSourceString("FooModule", Joiner.on("\n").join(
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "import myPackage.Foo;",
-        "@Module(injects = { Main.class, myPackage.FooImpl.class })",
-        "class FooModule {",
-        "  @Provides Foo provideFoo(myPackage.FooImpl impl) {",
-        "    return impl;",
-        "  }",
-        "}"));
-
-    assert_().about(javaSources()).that(asList(foo, main, module))
-        .processedWith(concat(asList(new FooImplGenerator()), daggerProcessors()))
-        .compilesWithoutError();
-  }
-
-  @Test public void withstandsMissingTypeReferencedInsideModule() {
-    JavaFileObject module = JavaFileObjects.forSourceString("FooModule", Joiner.on("\n").join(
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "import myPackage.Foo;",
-        "@Module(injects = { Main.class })",
-        "class FooModule {",
-        "  @Provides Foo provideFoo(myPackage.FooImpl impl) {",
-        "    return impl;",
-        "  }",
-        "}"));
-
-    assert_().about(javaSources()).that(asList(foo, module, main))
-        .processedWith(concat(daggerProcessors(), asList(new FooImplGenerator())))
-        .compilesWithoutError();
-  }
-
-  @Test public void withstandsMissingTypeReferencedByProvidesReturnType() {
-    JavaFileObject main = JavaFileObjects.forSourceString("Main", Joiner.on("\n").join(
-        "import javax.inject.Inject;",
-        "class Main {",
-        "  @Inject myPackage.FooImpl f;",
-        "}"));
-    JavaFileObject module = JavaFileObjects.forSourceString("FooModule", Joiner.on("\n").join(
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "@Module(injects = { Main.class })",
-        "class FooModule {",
-        "  @Provides myPackage.FooImpl provideFoo() {",
-        "    return new myPackage.FooImpl();",
-        "  }",
-        "}"));
-
-    assert_().about(javaSources()).that(asList(foo, module, main))
-        .processedWith(concat(daggerProcessors(), asList(new FooImplGenerator())))
-        .compilesWithoutError();
-  }
-
-  @Test public void failsWhenMissingGenericTypeReferencedByProvidesReturnType() {
-    JavaFileObject main = JavaFileObjects.forSourceString("Main", Joiner.on("\n").join(
-        "import javax.inject.Inject;",
-        "class Main {",
-        "  @Inject myPackage.FooImpl2<String> f;",
-        "}"));
-    JavaFileObject module = JavaFileObjects.forSourceString("FooModule", Joiner.on("\n").join(
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "@Module(injects = { Main.class })",
-        "class FooModule {",
-        "  @Provides myPackage.FooImpl2<String> provideFoo() {",
-        "    return new myPackage.FooImpl2<String>();",
-        "  }",
-        "}"));
-
-    assert_().about(javaSources()).that(asList(foo, module, main))
-        .processedWith(new FooImplGenerator())
-        .compilesWithoutError();
-    assert_().about(javaSources()).that(asList(foo, module, main))
-        .processedWith(concat(daggerProcessors(), asList(new FooImplGenerator())))
-        .failsToCompile()
-        .withErrorContaining("Could not find types required by provides methods for [FooModule]");
-  }
-
-  @Test public void withstandsMissingTypeReferencedInTransitiveJITDependency() {
-    JavaFileObject main = JavaFileObjects.forSourceString("Main", Joiner.on("\n").join(
-        "import javax.inject.Inject;",
-        "import myPackage.FooImpl;",
-        "class Main {",
-        "  @Inject FooImpl f;",
-        "}"));
-    JavaFileObject module = JavaFileObjects.forSourceString("FooModule", Joiner.on("\n").join(
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "@Module(injects = { Main.class })",
-        "class FooModule {",
-        "}"));
-
-    assert_().about(javaSources()).that(asList(foo, module, main))
-        .processedWith(concat(daggerProcessors(), asList(new FooImplGenerator())))
-        .compilesWithoutError();
-  }
-
-  @Test public void verifyFooImplGeneratorIsCompilingWithoutDagger() {
-    JavaFileObject module = JavaFileObjects.forSourceString("FooModule", Joiner.on("\n").join(
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "import myPackage.Foo;",
-        "@Module(injects = { Main.class })",
-        "class FooModule {",
-        "  @Provides Foo provideFoo(myPackage.FooImpl impl) {",
-        "    return impl;",
-        "  }",
-        "}"));
-    assert_().about(javaSources()).that(asList(foo, module, main))
-        .processedWith(new FooImplGenerator())
-        .compilesWithoutError();
-  }
-
-  @SupportedAnnotationTypes("*")
-  private final class FooImplGenerator extends AbstractProcessor {
-    boolean written = false;
-    @Override public boolean process(Set<? extends TypeElement> na1, RoundEnvironment na2) {
-      if (!written) {
-        try {
-          JavaFileObject sourceFile = processingEnv.getFiler().createSourceFile("FooImpl");
-          Writer writer = sourceFile.openWriter();
-          writer.write(Joiner.on("\n").join(
-              "package myPackage;",
-              "import javax.inject.Inject;",
-              "public final class FooImpl implements Foo {",
-              "  @Inject public FooImpl() { }",
-              "}"));
-          writer.close();
-          sourceFile = processingEnv.getFiler().createSourceFile("FooImpl2");
-          writer = sourceFile.openWriter();
-          writer.write(Joiner.on("\n").join(
-              "package myPackage;",
-              "import javax.inject.Inject;",
-              "public final class FooImpl2<T> implements Foo {",
-              "  @Inject public FooImpl2() { }",
-              "}"));
-          writer.close();
-          written = true;
-        } catch (IOException e) {
-          throw new RuntimeException(e);
-        }
-      }
-      return false;
-    }
-
-    @Override public SourceVersion getSupportedSourceVersion() {
-      return SourceVersion.latestSupported();
-    }
-  }
-
-}
diff --git a/compiler/src/test/java/dagger/tests/integration/validation/dagger1/LibraryModuleTest.java b/compiler/src/test/java/dagger/tests/integration/validation/dagger1/LibraryModuleTest.java
deleted file mode 100644
index 32368f24e..000000000
--- a/compiler/src/test/java/dagger/tests/integration/validation/dagger1/LibraryModuleTest.java
+++ /dev/null
@@ -1,101 +0,0 @@
-/**
- * Copyright (C) 2013 Google, Inc.
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.tests.integration.validation.dagger1;
-
-import com.google.common.base.Joiner;
-import com.google.testing.compile.JavaFileObjects;
-import java.util.Arrays;
-import javax.tools.JavaFileObject;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-import static com.google.common.truth.Truth.assert_;
-import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
-import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
-import static dagger.tests.integration.dagger1.ProcessorTestUtils.daggerProcessors;
-
-@RunWith(JUnit4.class)
-public final class LibraryModuleTest {
-  @Test public void unusedProviderMethodsPassOnLibrary() {
-    JavaFileObject source = JavaFileObjects.forSourceString("Library", Joiner.on("\n").join(
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "import java.lang.Override;",
-        "@Module(library = true)",
-        "class TestModule {",
-        "  @Provides String string() {",
-        "    return \"string\";",
-        "  }",
-        "}"));
-    assert_().about(javaSource())
-        .that(source).processedWith(daggerProcessors()).compilesWithoutError();
-  }
-
-  @Test public void unusedProviderMethodsFailOnNonLibrary() {
-    JavaFileObject source = JavaFileObjects.forSourceString("Library", Joiner.on("\n").join(
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "import java.lang.Override;",
-        "@Module(library = false)",
-        "class TestModule {",
-        "  @Provides String string() {",
-        "    return \"string\";",
-        "  }",
-        "}"));
-    assert_().about(javaSource()).that(source).processedWith(daggerProcessors()).failsToCompile()
-        .withErrorContaining("Graph validation failed:").in(source).onLine(5).and()
-        .withErrorContaining("You have these unused @Provider methods:").in(source).onLine(5).and()
-        .withErrorContaining("1. TestModule.string()").in(source).onLine(5).and()
-        .withErrorContaining("Set library=true in your module").in(source).onLine(5);
-  }
-
-  @Test public void injectsOfInterfaceMakesProvidesBindingNotAnOrphan() {
-    JavaFileObject foo = JavaFileObjects.forSourceString("Foo", "interface Foo {}");
-    JavaFileObject module = JavaFileObjects.forSourceString("TestModule", Joiner.on("\n").join(
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "import javax.inject.Singleton;",
-        "@Module(injects = Foo.class, library = false)",
-        "class TestModule {",
-        "  @Singleton @Provides Foo provideFoo() {",
-        "    return new Foo() {};",
-        "  }",
-        "}"));
-    assert_().about(javaSources()).that(Arrays.asList(foo, module))
-        .processedWith(daggerProcessors())
-        .compilesWithoutError();
-  }
-
-  @Test public void injectsOfClassMakesProvidesBindingNotAnOrphan() {
-    JavaFileObject foo = JavaFileObjects.forSourceString("Foo", "class Foo {}");
-    JavaFileObject module = JavaFileObjects.forSourceString("TestModule", Joiner.on("\n").join(
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "import javax.inject.Singleton;",
-        "@Module(injects = Foo.class, library = false)",
-        "class TestModule {",
-        "  @Singleton @Provides Foo provideFoo() {",
-        "    return new Foo() {};",
-        "  }",
-        "}"));
-    assert_().about(javaSources()).that(Arrays.asList(foo, module))
-        .processedWith(daggerProcessors())
-        .compilesWithoutError();
-  }
-
-}
diff --git a/compiler/src/test/java/dagger/tests/integration/validation/dagger1/ScopeAnnotationUseTest.java b/compiler/src/test/java/dagger/tests/integration/validation/dagger1/ScopeAnnotationUseTest.java
deleted file mode 100644
index 8895778ae..000000000
--- a/compiler/src/test/java/dagger/tests/integration/validation/dagger1/ScopeAnnotationUseTest.java
+++ /dev/null
@@ -1,251 +0,0 @@
-/**
- * Copyright (c) 2013 Google, Inc.
- * Copyright (c) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.tests.integration.validation.dagger1;
-
-import com.google.common.base.Joiner;
-import com.google.testing.compile.JavaFileObjects;
-import javax.tools.JavaFileObject;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-import static com.google.common.truth.Truth.assert_;
-import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
-import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
-import static dagger.tests.integration.dagger1.ProcessorTestUtils.daggerProcessors;
-import static java.util.Arrays.asList;
-
-/**
- * Integration tests for the validation processors related to the use
- * of Scoping Annotations.
- */
-// TODO(user): Audit this class when http://github.com/google/compile-testing
-//                has error/warning counts and other warning predicates available.
-@RunWith(JUnit4.class)
-public class ScopeAnnotationUseTest {
-  private static final String ABSTRACTION_SCOPING_TEXT =
-      "Scoping annotations are only allowed on concrete types and @Provides methods:";
-
-  // TODO(user): uncomment when http://github.com/google/compile-testing supports warnings.
-  //private static final String MISUSED_SCOPE_TEXT =
-  //    "Dagger will ignore scoping annotations on methods that are not @Provides methods:";
-
-  @Test public void compileSucceedsScopeOnConcreteType() {
-    JavaFileObject sourceFile = JavaFileObjects.forSourceString("Test", Joiner.on("\n").join(
-        "import javax.inject.Inject;",
-        "import javax.inject.Singleton;",
-        "@Singleton",
-        "class Test {",
-        "  @Inject public Test() { }",
-        "}"));
-
-    // TODO(user): uncomment when http://github.com/google/compile-testing has hasNoWarnings()
-    assert_().about(javaSource())
-        .that(sourceFile).processedWith(daggerProcessors()).compilesWithoutError();
-        //.and().hasNoWarnings();
-  }
-
-  @Test public void compileSucceedsScopeOnProvidesMethod() {
-    JavaFileObject sourceFile = JavaFileObjects.forSourceString("Test", Joiner.on("\n").join(
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "import javax.inject.Singleton;",
-        "@Module(library = true, injects = String.class)",
-        "class Test {",
-        "  @Provides @Singleton public String provideString() { return \"\"; }",
-        "}"));
-
-    // TODO(user): uncomment when http://github.com/google/compile-testing has hasNoWarnings()
-    assert_().about(javaSource())
-        .that(sourceFile).processedWith(daggerProcessors()).compilesWithoutError();
-        //.and().hasNoWarnings();
-  }
-
-  @Test public void compileSucceedsWithScopedSuppressedNonProvidesMethod() {
-    JavaFileObject sourceFile = JavaFileObjects.forSourceString("Test", Joiner.on("\n").join(
-        "import javax.inject.Singleton;",
-        "class Test {",
-        "  @SuppressWarnings(\"scoping\")",
-        "  @Singleton void method() { }",
-        "}"));
-
-    // TODO(user): uncomment when http://github.com/google/compile-testing has hasNoWarnings()
-    assert_().about(javaSource())
-        .that(sourceFile).processedWith(daggerProcessors()).compilesWithoutError();
-        //.and().hasNoWarnings();
-  }
-
-  @Test public void compileSucceedsWithScopedMultiplySuppressedNonProvidesMethod() {
-    JavaFileObject sourceFile = JavaFileObjects.forSourceString("Test", Joiner.on("\n").join(
-        "import javax.inject.Singleton;",
-        "class Test {",
-        "  @SuppressWarnings({\"blah\", \"scoping\", \"foo\"})",
-        "  @Singleton void method() { }",
-        "}"));
-
-    // TODO(user): uncomment when http://github.com/google/compile-testing has hasNoWarnings()
-    assert_().about(javaSource())
-        .that(sourceFile).processedWith(daggerProcessors()).compilesWithoutError();
-        //.and().hasNoWarnings();
-  }
-
-  @Test public void compileWarnsWithScopedNonProvidesMethod() {
-    JavaFileObject sourceFile = JavaFileObjects.forSourceString("Test", Joiner.on("\n").join(
-        "import javax.inject.Singleton;",
-        "class Test {",
-        "  @Singleton void method() { }",
-        "}"));
-
-    // TODO(user): uncomment when http://github.com/google/compile-testing supports warnings.
-    assert_().about(javaSource())
-        .that(sourceFile).processedWith(daggerProcessors()).compilesWithoutError();
-        //.withWarningContaining(MISUSED_SCOPE_TEXT).in(sourceFile).onLine(3).atColumn(49).and()
-        //.withWarningContaining("Test.method()").in(sourceFile).onLine(3).atColumn(49);
-  }
-
-  @Test public void compileWarnsWithScopedIncorrectlySuppressedNonProvidesMethod() {
-    JavaFileObject sourceFile = JavaFileObjects.forSourceString("Test", Joiner.on("\n").join(
-        "import javax.inject.Singleton;",
-        "class Test {",
-        "  @SuppressWarnings(\"some string other than 'scoping'\")",
-        "  @Singleton void method() { }",
-        "}"));
-
-    // TODO(user): uncomment when http://github.com/google/compile-testing supports warnings.
-    assert_().about(javaSource())
-        .that(sourceFile).processedWith(daggerProcessors()).compilesWithoutError();
-        //.withWarningContaining(MISUSED_SCOPE_TEXT).in(sourceFile).onLine(4).atColumn(49).and()
-        //.withWarningContaining("Test.method()").in(sourceFile).onLine(4).atColumn(49);
-  }
-
-  @Test public void compileFailsWithScopeOnInterface() {
-    JavaFileObject sourceFile = JavaFileObjects.forSourceString("Test", Joiner.on("\n").join(
-        "import dagger.Module;",
-        "import javax.inject.Singleton;",
-        "class Test {",
-        "  @Module(injects = TestType.class) class TestModule { }",
-        "  @Singleton interface TestType { }",
-        "}"));
-
-    assert_().about(javaSource())
-        .that(sourceFile).processedWith(daggerProcessors()).failsToCompile()
-        .withErrorContaining(ABSTRACTION_SCOPING_TEXT).in(sourceFile).onLine(5).atColumn(14).and()
-        .withErrorContaining("Test.TestType").in(sourceFile).onLine(5).atColumn(14);
-  }
-
-  @Test public void compileFailsWithScopeOnAbstractClass() {
-    JavaFileObject sourceFile = JavaFileObjects.forSourceString("Test", Joiner.on("\n").join(
-        "import dagger.Module;",
-        "import javax.inject.Singleton;",
-        "class Test {",
-        "  @Module(injects = TestType.class) class TestModule { }",
-        "  @Singleton abstract class TestType { }",
-        "}"));
-
-    assert_().about(javaSource())
-        .that(sourceFile).processedWith(daggerProcessors()).failsToCompile()
-        .withErrorContaining(ABSTRACTION_SCOPING_TEXT).in(sourceFile).onLine(5).atColumn(23).and()
-        .withErrorContaining("Test.TestType").in(sourceFile).onLine(5).atColumn(23);
-  }
-
-  @Test public void compileFailsWithScopeOnField() {
-    JavaFileObject sourceFile = JavaFileObjects.forSourceString("Test", Joiner.on("\n").join(
-        "import dagger.Module;",
-        "import javax.inject.Inject;",
-        "import javax.inject.Singleton;",
-        "class Test {",
-        "  @Singleton String field;",
-        "  @Inject public Test() { }",
-        "  @Module(injects = Test.class) class TestModule { }",
-        "}"));
-
-    assert_().about(javaSource())
-        .that(sourceFile).processedWith(daggerProcessors()).failsToCompile()
-        .withErrorContaining(ABSTRACTION_SCOPING_TEXT).in(sourceFile).onLine(5).atColumn(21).and()
-        .withErrorContaining("Test.field").in(sourceFile).onLine(5).atColumn(21);
-  }
-
-  @Test public void compileFailsWithScopeOnMethodParameter() {
-    JavaFileObject sourceFile = JavaFileObjects.forSourceString("Test", Joiner.on("\n").join(
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "import javax.inject.Singleton;",
-        "@Module(library = true, injects = String.class)",
-        "class Test {",
-        "  @Provides int provideInteger() { return 0; }",
-        "  @Provides String provideString(@Singleton int intParam) { return \"\"; }",
-        "}"));
-
-    assert_().about(javaSource())
-        .that(sourceFile).processedWith(daggerProcessors()).failsToCompile()
-        .withErrorContaining(ABSTRACTION_SCOPING_TEXT).in(sourceFile).onLine(7).atColumn(49).and()
-        .withErrorContaining("intParam").in(sourceFile).onLine(7).atColumn(49);
-  }
-
-  @Test public void compileFailsWithMultipleScopeAnnotations() {
-    JavaFileObject annotation = JavaFileObjects.forSourceString("MyScope", Joiner.on("\n").join(
-        "import java.lang.annotation.Retention;",
-        "import javax.inject.Scope;",
-        "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
-        "@Scope @Retention(RUNTIME) public @interface MyScope { }"));
-
-    JavaFileObject module = JavaFileObjects.forSourceString("MyModule", Joiner.on("\n").join(
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "import javax.inject.Singleton;",
-        "@Module(library = true, injects = Injectable.class)",
-        "class MyModule {",
-        "  @Provides @Singleton @MyScope String method() { return \"\"; }",
-        "}"));
-
-    JavaFileObject injectable = JavaFileObjects.forSourceString("Test", Joiner.on("\n").join(
-        "import javax.inject.Inject;",
-        "import javax.inject.Singleton;",
-        "@Singleton @MyScope",
-        "class Injectable {",
-        "  @Inject String string;",
-        "}"));
-
-    String error = "Only one scoping annotation is allowed per element: ";
-
-    assert_().about(javaSources()).that(asList(annotation, module, injectable))
-        .processedWith(daggerProcessors()).failsToCompile()
-        .withErrorContaining(error + "MyModule.method()").in(module).onLine(6).atColumn(40).and()
-        .withErrorContaining(error + "Injectable").in(injectable).onLine(4).atColumn(1);
-  }
-
-  @Test public void compileFailsWithScopeOnConstructor() {
-    JavaFileObject sourceFile = JavaFileObjects.forSourceString("Test", Joiner.on("\n").join(
-        "import dagger.Module;",
-        "import javax.inject.Inject;",
-        "import javax.inject.Singleton;",
-        "class Test {",
-        "  @Singleton @Inject public Test() { }",
-        "  @Module(injects = Test.class) class TestModule { }",
-        "}"));
-
-   String singletonErrorText = ""
-        + "Singleton annotations have no effect on constructors. "
-        + "Did you mean to annotate the class?";
-
-    assert_().about(javaSource())
-        .that(sourceFile).processedWith(daggerProcessors()).failsToCompile()
-        .withErrorContaining(ABSTRACTION_SCOPING_TEXT).in(sourceFile).onLine(5).atColumn(29).and()
-        .withErrorContaining("Test.Test()").in(sourceFile).onLine(5).atColumn(29).and()
-        .withErrorContaining(singletonErrorText).in(sourceFile).onLine(6).atColumn(33);
-  }
-}
diff --git a/compiler/src/test/java/dagger/tests/integration/validation/dagger1/SimpleMissingDependencyTest.java b/compiler/src/test/java/dagger/tests/integration/validation/dagger1/SimpleMissingDependencyTest.java
deleted file mode 100644
index 0534ba42d..000000000
--- a/compiler/src/test/java/dagger/tests/integration/validation/dagger1/SimpleMissingDependencyTest.java
+++ /dev/null
@@ -1,54 +0,0 @@
-/**
- * Copyright (c) 2013 Google, Inc.
- * Copyright (c) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.tests.integration.validation.dagger1;
-
-import com.google.common.base.Joiner;
-import com.google.testing.compile.JavaFileObjects;
-import javax.tools.JavaFileObject;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-import static com.google.common.truth.Truth.assert_;
-import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
-import static dagger.tests.integration.dagger1.ProcessorTestUtils.daggerProcessors;
-
-@RunWith(JUnit4.class)
-public class SimpleMissingDependencyTest {
-
-  @Test public void missingDependency() {
-    JavaFileObject file = JavaFileObjects.forSourceString("MissingDep", Joiner.on("\n").join(
-        "import dagger.Module;",
-        "import javax.inject.Inject;",
-        "class MissingDep {",
-        "  @Inject Dependency dep;",
-        "  static interface Dependency {",
-        "    void doit();",
-        "  }",
-        "  @Module(injects = MissingDep.class)",
-        "  static class DaModule {",
-        "    /* missing */ // @Provides Dependency a() { return new Dependency(); }",
-        "  }",
-        "}"));
-
-    assert_().about(javaSource())
-        .that(file).processedWith(daggerProcessors())
-        .failsToCompile()
-        .withErrorContaining("MissingDep$Dependency could not be bound").in(file).onLine(9).and()
-        .withErrorContaining("required by MissingDep for MissingDep.DaModule").in(file).onLine(9);
-  }
-}
diff --git a/core/pom.xml b/core/pom.xml
index 3749c6607..3551075be 100644
--- a/core/pom.xml
+++ b/core/pom.xml
@@ -42,11 +42,6 @@
       <artifactId>junit</artifactId>
       <scope>test</scope>
     </dependency>
-    <dependency>
-      <groupId>org.easytesting</groupId>
-      <artifactId>fest-assert</artifactId>
-      <scope>test</scope>
-    </dependency>
     <dependency>
       <groupId>com.google.truth</groupId>
       <artifactId>truth</artifactId>
diff --git a/core/src/main/java/dagger/ObjectGraph.java b/core/src/main/java/dagger/ObjectGraph.java
deleted file mode 100644
index cd94d3069..000000000
--- a/core/src/main/java/dagger/ObjectGraph.java
+++ /dev/null
@@ -1,372 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- * Copyright (C) 2012 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger;
-
-import dagger.internal.Binding;
-import dagger.internal.BindingsGroup;
-import dagger.internal.FailoverLoader;
-import dagger.internal.Keys;
-import dagger.internal.Linker;
-import dagger.internal.Loader;
-import dagger.internal.ModuleAdapter;
-import dagger.internal.Modules;
-import dagger.internal.Modules.ModuleWithAdapter;
-import dagger.internal.ProblemDetector;
-import dagger.internal.SetBinding;
-import dagger.internal.StaticInjection;
-import dagger.internal.ThrowingErrorHandler;
-import java.lang.reflect.Method;
-import java.util.ArrayList;
-import java.util.LinkedHashMap;
-import java.util.List;
-import java.util.Map;
-
-/**
- * A graph of objects linked by their dependencies.
- *
- * <p>The following injection features are supported:
- * <ul>
- *   <li>Field injection. A class may have any number of field injections, and
- *       fields may be of any visibility. Static fields will be injected each
- *       time an instance is injected.
- *   <li>Constructor injection. A class may have a single
- *       {@code @Inject}-annotated constructor. Classes that have fields
- *       injected may omit the {@code @Inject} annotation if they have a public
- *       no-arguments constructor.
- *   <li>Injection of {@code @Provides} method parameters.
- *   <li>{@code @Provides} methods annotated {@code @Singleton}.
- *   <li>Constructor-injected classes annotated {@code @Singleton}.
- *   <li>Injection of {@code Provider}s.
- *   <li>Injection of {@code MembersInjector}s.
- *   <li>Qualifier annotations on injected parameters and fields.
- *   <li>JSR 330 annotations.
- * </ul>
- *
- * <p>The following injection features are not currently supported:
- * <ul>
- *   <li>Method injection.</li>
- *   <li>Circular dependencies.</li>
- * </ul>
- */
-public abstract class ObjectGraph {
-  ObjectGraph() {
-  }
-
-  /**
-   * Returns an instance of {@code type}.
-   *
-   * @throws IllegalArgumentException if {@code type} is not one of this object
-   *     graph's {@link Module#injects injectable types}.
-   */
-  public abstract <T> T get(Class<T> type);
-
-  /**
-   * Injects the members of {@code instance}, including injectable members
-   * inherited from its supertypes.
-   *
-   * @throws IllegalArgumentException if the runtime type of {@code instance} is
-   *     not one of this object graph's {@link Module#injects injectable types}.
-   */
-  public abstract <T> T inject(T instance);
-
-  /**
-   * Returns a new object graph that includes all of the objects in this graph,
-   * plus additional objects in the {@literal @}{@link Module}-annotated
-   * modules. This graph is a subgraph of the returned graph.
-   *
-   * <p>The current graph is not modified by this operation: its objects and the
-   * dependency links between them are unchanged. But this graph's objects may
-   * be shared by both graphs. For example, the singletons of this graph may be
-   * injected and used by the returned graph.
-   *
-   * <p>This <strong>does not</strong> inject any members or validate the graph.
-   * See {@link #create} for guidance on injection and validation.
-   */
-  public abstract ObjectGraph plus(Object... modules);
-
-  /**
-   * Do runtime graph problem detection. For fastest graph creation, rely on
-   * build time tools for graph validation.
-   *
-   * @throws IllegalStateException if this graph has problems.
-   */
-  public abstract void validate();
-
-  /**
-   * Injects the static fields of the classes listed in the object graph's
-   * {@code staticInjections} property.
-   */
-  public abstract void injectStatics();
-
-  /**
-   * Returns a new dependency graph using the {@literal @}{@link
-   * Module}-annotated modules.
-   *
-   * <p>This <strong>does not</strong> inject any members. Most applications
-   * should call {@link #injectStatics} to inject static members and {@link
-   * #inject} or get {@link #get(Class)} to inject instance members when this
-   * method has returned.
-   *
-   * <p>This <strong>does not</strong> validate the graph. Rely on build time
-   * tools for graph validation, or call {@link #validate} to find problems in
-   * the graph at runtime.
-   */
-  public static ObjectGraph create(Object... modules) {
-    return DaggerObjectGraph.makeGraph(null, new FailoverLoader(), modules);
-  }
-
-  /**
-   * Load the graph with a custom loading strategy.  If you're not using this to work around
-   * proguard obfuscation, then use {@link #create(Object...)}
-   *
-   * @deprecated Recreated for reflective use of Dagger in the obfuscation case, and will be
-   *     entirely obsolete in Dagger 2.0.
-   */
-  @Deprecated
-  public static ObjectGraph createWith(Loader loader, Object... modules) {
-    return DaggerObjectGraph.makeGraph(null, loader, modules);
-  }
-
-  // TODO(user): Move this internal implementation of ObjectGraph into the internal package.
-  static class DaggerObjectGraph extends ObjectGraph {
-    private final DaggerObjectGraph base;
-    private final Linker linker;
-    private final Loader plugin;
-    private final Map<Class<?>, StaticInjection> staticInjections;
-    private final Map<String, Class<?>> injectableTypes;
-    private final List<SetBinding<?>> setBindings;
-
-    DaggerObjectGraph(DaggerObjectGraph base,
-        Linker linker,
-        Loader plugin,
-        Map<Class<?>, StaticInjection> staticInjections,
-        Map<String, Class<?>> injectableTypes,
-        List<SetBinding<?>> setBindings) {
-
-      this.base = base;
-      this.linker = checkNotNull(linker, "linker");
-      this.plugin = checkNotNull(plugin, "plugin");
-      this.staticInjections = checkNotNull(staticInjections, "staticInjections");
-      this.injectableTypes = checkNotNull(injectableTypes, "injectableTypes");
-      this.setBindings = checkNotNull(setBindings, "setBindings");
-    }
-
-    private static <T> T checkNotNull(T object, String label) {
-      if (object == null) throw new NullPointerException(label);
-      return object;
-    }
-
-    private static ObjectGraph makeGraph(DaggerObjectGraph base, Loader plugin, Object... modules) {
-      Map<String, Class<?>> injectableTypes = new LinkedHashMap<String, Class<?>>();
-      Map<Class<?>, StaticInjection> staticInjections
-          = new LinkedHashMap<Class<?>, StaticInjection>();
-      StandardBindings baseBindings =
-          (base == null) ? new StandardBindings() : new StandardBindings(base.setBindings);
-      BindingsGroup overrideBindings = new OverridesBindings();
-
-      ArrayList<ModuleWithAdapter> loadedModules = Modules.loadModules(plugin, modules);
-      int loadedModulesCount = loadedModules.size();
-      for (int moduleIndex = 0; moduleIndex < loadedModulesCount; moduleIndex++) {
-        ModuleWithAdapter loadedModule = loadedModules.get(moduleIndex);
-        @SuppressWarnings("unchecked")
-        ModuleAdapter<Object> moduleAdapter =
-            (ModuleAdapter<Object>) loadedModule.getModuleAdapter();
-        for (int i = 0; i < moduleAdapter.injectableTypes.length; i++) {
-          injectableTypes.put(moduleAdapter.injectableTypes[i], moduleAdapter.moduleClass);
-        }
-        for (int i = 0; i < moduleAdapter.staticInjections.length; i++) {
-          staticInjections.put(moduleAdapter.staticInjections[i], null);
-        }
-        try {
-          BindingsGroup addTo = moduleAdapter.overrides ? overrideBindings : baseBindings;
-          moduleAdapter.getBindings(addTo, loadedModule.getModule());
-        } catch (IllegalArgumentException e) {
-          throw new IllegalArgumentException(
-              moduleAdapter.moduleClass.getSimpleName() + ": " + e.getMessage(), e);
-        }
-      }
-
-      // Create a linker and install all of the user's bindings
-      Linker linker =
-          new Linker((base != null) ? base.linker : null, plugin, new ThrowingErrorHandler());
-      linker.installBindings(baseBindings);
-      linker.installBindings(overrideBindings);
-
-      return new DaggerObjectGraph(
-          base, linker, plugin, staticInjections, injectableTypes, baseBindings.setBindings);
-    }
-
-    @Override public ObjectGraph plus(Object... modules) {
-      linkEverything();
-      return makeGraph(this, plugin, modules);
-    }
-
-    private void linkStaticInjections() {
-      for (Map.Entry<Class<?>, StaticInjection> entry : staticInjections.entrySet()) {
-        StaticInjection staticInjection = entry.getValue();
-        if (staticInjection == null) {
-          staticInjection = plugin.getStaticInjection(entry.getKey());
-          entry.setValue(staticInjection);
-        }
-        staticInjection.attach(linker);
-      }
-    }
-
-    private void linkInjectableTypes() {
-      for (Map.Entry<String, Class<?>> entry : injectableTypes.entrySet()) {
-        linker.requestBinding(entry.getKey(), entry.getValue(), entry.getValue().getClassLoader(),
-            false, true);
-      }
-    }
-
-    @Override public void validate() {
-      Map<String, Binding<?>> allBindings = linkEverything();
-      new ProblemDetector().detectProblems(allBindings.values());
-    }
-
-    /**
-     * Links all bindings, injectable types and static injections.
-     */
-    private Map<String, Binding<?>> linkEverything() {
-      Map<String, Binding<?>> bindings = linker.fullyLinkedBindings();
-      if (bindings != null) {
-        return bindings;
-      }
-      synchronized (linker) {
-        if ((bindings = linker.fullyLinkedBindings()) != null) {
-          return bindings;
-        }
-        linkStaticInjections();
-        linkInjectableTypes();
-        return linker.linkAll(); // Linker.linkAll() implicitly does Linker.linkRequested().
-      }
-    }
-
-    @Override public void injectStatics() {
-      // We call linkStaticInjections() twice on purpose. The first time through
-      // we request all of the bindings we need. The linker returns null for
-      // bindings it doesn't have. Then we ask the linker to link all of those
-      // requested bindings. Finally we call linkStaticInjections() again: this
-      // time the linker won't return null because everything has been linked.
-      synchronized (linker) {
-        linkStaticInjections();
-        linker.linkRequested();
-        linkStaticInjections();
-      }
-
-      for (Map.Entry<Class<?>, StaticInjection> entry : staticInjections.entrySet()) {
-        entry.getValue().inject();
-      }
-    }
-
-    @Override public <T> T get(Class<T> type) {
-      String key = Keys.get(type);
-      String injectableTypeKey = type.isInterface() ? key : Keys.getMembersKey(type);
-      ClassLoader classLoader = type.getClassLoader();
-      @SuppressWarnings("unchecked") // The linker matches keys to bindings by their type.
-      Binding<T> binding =
-          (Binding<T>) getInjectableTypeBinding(classLoader, injectableTypeKey, key);
-      return binding.get();
-    }
-
-    @Override public <T> T inject(T instance) {
-      String membersKey = Keys.getMembersKey(instance.getClass());
-      ClassLoader classLoader = instance.getClass().getClassLoader();
-      @SuppressWarnings("unchecked") // The linker matches keys to bindings by their type.
-      Binding<T> binding =
-          (Binding<T>) getInjectableTypeBinding(classLoader, membersKey, membersKey);
-      binding.injectMembers(instance);
-      return instance;
-    }
-
-    /**
-     * @param classLoader the {@code ClassLoader} used to load dependent bindings.
-     * @param injectableKey the key used to store the injectable type. This
-     *     is a provides key for interfaces and a members injection key for
-     *     other types. That way keys can always be created, even if the type
-     *     has no injectable constructor.
-     * @param key the key to use when retrieving the binding. This may be a
-     *     regular (provider) key or a members key.
-     */
-    private Binding<?> getInjectableTypeBinding(
-        ClassLoader classLoader, String injectableKey, String key) {
-      Class<?> moduleClass = getModuleClassDeclaringInjects(injectableKey);
-      if (moduleClass == null) {
-        throw new IllegalArgumentException("No inject registered for " + injectableKey
-            + ". You must explicitly add it to the 'injects' option in one of your modules.");
-      }
-
-      synchronized (linker) {
-        Binding<?> binding = linker.requestBinding(key, moduleClass, classLoader, false, true);
-        if (binding == null || !binding.isLinked()) {
-          linker.linkRequested();
-          binding = linker.requestBinding(key, moduleClass, classLoader, false, true);
-        }
-        return binding;
-      }
-    }
-
-    private Class<?> getModuleClassDeclaringInjects(String injectableKey) {
-      Class<?> moduleClass = null;
-      for (DaggerObjectGraph graph = this; graph != null; graph = graph.base) {
-        moduleClass = graph.injectableTypes.get(injectableKey);
-        if (moduleClass != null) break;
-      }
-      return moduleClass;
-    }
-  }
-
-  /**
-   * A BindingsGroup which fails when existing values are clobbered and sets aside
-   * {@link SetBinding}.
-   */
-  private static final class StandardBindings extends BindingsGroup {
-    private final List<SetBinding<?>> setBindings;
-
-    public StandardBindings() {
-      setBindings = new ArrayList<SetBinding<?>>();
-    }
-
-    public StandardBindings(List<SetBinding<?>> baseSetBindings) {
-      setBindings = new ArrayList<SetBinding<?>>(baseSetBindings.size());
-      for (SetBinding<?> sb : baseSetBindings) {
-        @SuppressWarnings({ "rawtypes", "unchecked" })
-        SetBinding<?> child = new SetBinding(sb);
-        setBindings.add(child);
-        put(child.provideKey, child);
-      }
-    }
-
-    @Override public Binding<?> contributeSetBinding(String key, SetBinding<?> value) {
-      setBindings.add(value);
-      return super.put(key, value);
-    }
-  }
-
-  /**
-   * A BindingsGroup which throws an {@link IllegalArgumentException} when a
-   * {@link SetBinding} is contributed, since overrides modules cannot contribute such
-   * bindings.
-   */
-  private static final class OverridesBindings extends BindingsGroup {
-    OverridesBindings() { }
-
-    @Override public Binding<?> contributeSetBinding(String key, SetBinding<?> value) {
-      throw new IllegalArgumentException("Module overrides cannot contribute set bindings.");
-    }
-  }
-}
diff --git a/core/src/main/java/dagger/internal/ArrayQueue.java b/core/src/main/java/dagger/internal/ArrayQueue.java
deleted file mode 100644
index fbcc27e66..000000000
--- a/core/src/main/java/dagger/internal/ArrayQueue.java
+++ /dev/null
@@ -1,606 +0,0 @@
-/*
- * Written by Josh Bloch of Google Inc. and released to the public domain,
- * as explained at http://creativecommons.org/publicdomain/zero/1.0/.
- *
- * Adapted from https://android.googlesource.com/platform/libcore/+
- *     android-4.2.2_r1/luni/src/main/java/java/util/ArrayDeque.java
- */
-package dagger.internal;
-
-import java.lang.reflect.Array;
-import java.util.AbstractCollection;
-import java.util.Collection;
-import java.util.ConcurrentModificationException;
-import java.util.Iterator;
-import java.util.LinkedList;
-import java.util.List;
-import java.util.NoSuchElementException;
-import java.util.Queue;
-
-/**
- * Resizable-array implementation of the {@link Queue} interface.  Array
- * queues have no capacity restrictions; they grow as necessary to support
- * usage.  They are not thread-safe; in the absence of external
- * synchronization, they do not support concurrent access by multiple threads.
- * Null elements are prohibited.  This class is likely to be faster than
- * {@link LinkedList} when used as a queue.
- *
- * <p>Most <tt>ArrayBackedQueue</tt> operations run in amortized constant time.
- * Exceptions include {@link #remove(Object) remove}, {@link
- * #removeFirstOccurrence removeFirstOccurrence}, {@link #contains contains},
- * {@link #iterator iterator.remove()}, and the bulk operations, all of which
- * run in linear time.
- *
- * <p>The iterators returned by this class's <tt>iterator</tt> method are
- * <i>fail-fast</i>: If the queue is modified at any time after the iterator
- * is created, in any way except through the iterator's own <tt>remove</tt>
- * method, the iterator will generally throw a {@link
- * ConcurrentModificationException}.  Thus, in the face of concurrent
- * modification, the iterator fails quickly and cleanly, rather than risking
- * arbitrary, non-deterministic behavior at an undetermined time in the
- * future.
- *
- * <p>Note that the fail-fast behavior of an iterator cannot be guaranteed
- * as it is, generally speaking, impossible to make any hard guarantees in the
- * presence of unsynchronized concurrent modification.  Fail-fast iterators
- * throw <tt>ConcurrentModificationException</tt> on a best-effort basis.
- * Therefore, it would be wrong to write a program that depended on this
- * exception for its correctness: <i>the fail-fast behavior of iterators
- * should be used only to detect bugs.</i>
- *
- * <p>This class and its iterator implement all of the
- * <em>optional</em> methods of the {@link Collection} and {@link
- * Iterator} interfaces.
- *
- * @author  Josh Bloch and Doug Lea
- * @param <E> the type of elements held in this collection
- */
-public class ArrayQueue<E> extends AbstractCollection<E>
-                           implements Queue<E>, Cloneable, java.io.Serializable {
-    /**
-     * The array in which the elements of the queue are stored.
-     * The capacity of the queue is the length of this array, which is
-     * always a power of two. The array is never allowed to become
-     * full, except transiently within an addX method where it is
-     * resized (see doubleCapacity) immediately upon becoming full,
-     * thus avoiding head and tail wrapping around to equal each
-     * other.  We also guarantee that all array cells not holding
-     * queue elements are always null.
-     */
-    private transient Object[] elements;
-
-    /**
-     * The index of the element at the head of the queue (which is the
-     * element that would be removed by remove() or pop()); or an
-     * arbitrary number equal to tail if the queue is empty.
-     */
-    private transient int head;
-
-    /**
-     * The index at which the next element would be added to the tail
-     * of the queue (via addLast(E), add(E), or push(E)).
-     */
-    private transient int tail;
-
-    /**
-     * The minimum capacity that we'll use for a newly created queue.
-     * Must be a power of 2.
-     */
-    private static final int MIN_INITIAL_CAPACITY = 8;
-
-    // ******  Array allocation and resizing utilities ******
-
-    /**
-     * Allocate empty array to hold the given number of elements.
-     *
-     * @param numElements  the number of elements to hold
-     */
-    private void allocateElements(int numElements) {
-        int initialCapacity = MIN_INITIAL_CAPACITY;
-        // Find the best power of two to hold elements.
-        // Tests "<=" because arrays aren't kept full.
-        if (numElements >= initialCapacity) {
-            initialCapacity = numElements;
-            initialCapacity |= (initialCapacity >>>  1);
-            initialCapacity |= (initialCapacity >>>  2);
-            initialCapacity |= (initialCapacity >>>  4);
-            initialCapacity |= (initialCapacity >>>  8);
-            initialCapacity |= (initialCapacity >>> 16);
-            initialCapacity++;
-
-            if (initialCapacity < 0)   // Too many elements, must back off
-                initialCapacity >>>= 1; // Good luck allocating 2 ^ 30 elements
-        }
-        elements = new Object[initialCapacity];
-    }
-
-    /**
-     * Double the capacity of this queue.  Call only when full, i.e.,
-     * when head and tail have wrapped around to become equal.
-     */
-    private void doubleCapacity() {
-        // assert head == tail;
-        int p = head;
-        int n = elements.length;
-        int r = n - p; // number of elements to the right of p
-        int newCapacity = n << 1;
-        if (newCapacity < 0)
-            throw new IllegalStateException("Sorry, queue too big");
-        Object[] a = new Object[newCapacity];
-        System.arraycopy(elements, p, a, 0, r);
-        System.arraycopy(elements, 0, a, r, p);
-        elements = a;
-        head = 0;
-        tail = n;
-    }
-
-    /**
-     * Constructs an empty array queue with an initial capacity
-     * sufficient to hold 16 elements.
-     */
-    public ArrayQueue() {
-        elements = new Object[16];
-    }
-
-    /**
-     * Constructs an empty array queue with an initial capacity
-     * sufficient to hold the specified number of elements.
-     *
-     * @param numElements  lower bound on initial capacity of the queue
-     */
-    public ArrayQueue(int numElements) {
-        allocateElements(numElements);
-    }
-
-    /**
-     * Constructs a queue containing the elements of the specified
-     * collection, in the order they are returned by the collection's
-     * iterator.  (The first element returned by the collection's
-     * iterator becomes the first element, or <i>front</i> of the
-     * queue.)
-     *
-     * @param c the collection whose elements are to be placed into the queue
-     * @throws NullPointerException if the specified collection is null
-     */
-    public ArrayQueue(Collection<? extends E> c) {
-        allocateElements(c.size());
-        addAll(c);
-    }
-
-    /**
-     * Inserts the specified element at the end of this queue.
-     *
-     * <p>This method is equivalent to {@link #offer}.
-     *
-     * @param e the element to add
-     * @return <tt>true</tt> (as specified by {@link Collection#add})
-     * @throws NullPointerException if the specified element is null
-     */
-    @Override
-    public boolean add(E e) {
-        if (e == null)
-            throw new NullPointerException("e == null");
-        elements[tail] = e;
-        if ((tail = (tail + 1) & (elements.length - 1)) == head)
-            doubleCapacity();
-        return true;
-    }
-
-    /**
-     * Inserts the specified element at the end of this queue.
-     *
-     * @param e the element to add
-     * @return <tt>true</tt> (as specified by {@link Queue#offer})
-     * @throws NullPointerException if the specified element is null
-     */
-    @Override
-    public boolean offer(E e) {
-        return add(e);
-    }
-
-    /**
-     * Retrieves and removes the head of the queue represented by this queue.
-     *
-     * This method differs from {@link #poll poll} only in that it throws an
-     * exception if this queue is empty.
-     *
-     * @return the head of the queue represented by this queue
-     * @throws NoSuchElementException {@inheritDoc}
-     */
-    @Override
-    public E remove() {
-        E x = poll();
-        if (x == null)
-            throw new NoSuchElementException();
-        return x;
-    }
-
-    /**
-     * Retrieves and removes the head of the queue represented by this queue
-     * (in other words, the first element of this queue), or returns
-     * <tt>null</tt> if this queue is empty.
-     *
-     * @return the head of the queue represented by this queue, or
-     *         <tt>null</tt> if this queue is empty
-     */
-    @Override
-    public E poll() {
-        int h = head;
-        @SuppressWarnings("unchecked") E result = (E) elements[h];
-        // Element is null if queue empty
-        if (result == null)
-            return null;
-        elements[h] = null;     // Must null out slot
-        head = (h + 1) & (elements.length - 1);
-        return result;
-    }
-
-    /**
-     * Retrieves, but does not remove, the head of the queue represented by
-     * this queue.  This method differs from {@link #peek peek} only in
-     * that it throws an exception if this queue is empty.
-     *
-     * @return the head of the queue represented by this queue
-     * @throws NoSuchElementException {@inheritDoc}
-     */
-    @Override
-    public E element() {
-        @SuppressWarnings("unchecked") E result = (E) elements[head];
-        if (result == null)
-            throw new NoSuchElementException();
-        return result;
-    }
-
-    /**
-     * Retrieves, but does not remove, the head of the queue represented by
-     * this queue, or returns <tt>null</tt> if this queue is empty.
-     *
-     * @return the head of the queue represented by this queue, or
-     *         <tt>null</tt> if this queue is empty
-     */
-    @Override
-    public E peek() {
-        @SuppressWarnings("unchecked") E result = (E) elements[head];
-        // elements[head] is null if queue empty
-        return result;
-    }
-
-    /**
-     * Removes the element at the specified position in the elements array,
-     * adjusting head and tail as necessary.  This can result in motion of
-     * elements backwards or forwards in the array.
-     *
-     * <p>This method is called delete rather than remove to emphasize
-     * that its semantics differ from those of {@link List#remove(int)}.
-     *
-     * @return true if elements moved backwards
-     */
-    private boolean delete(int i) {
-        //checkInvariants();
-        final Object[] elements = this.elements;
-        final int mask = elements.length - 1;
-        final int h = head;
-        final int t = tail;
-        final int front = (i - h) & mask;
-        final int back  = (t - i) & mask;
-
-        // Invariant: head <= i < tail mod circularity
-        if (front >= ((t - h) & mask))
-            throw new ConcurrentModificationException();
-
-        // Optimize for least element motion
-        if (front < back) {
-            if (h <= i) {
-                System.arraycopy(elements, h, elements, h + 1, front);
-            } else { // Wrap around
-                System.arraycopy(elements, 0, elements, 1, i);
-                elements[0] = elements[mask];
-                System.arraycopy(elements, h, elements, h + 1, mask - h);
-            }
-            elements[h] = null;
-            head = (h + 1) & mask;
-            return false;
-        } else {
-            if (i < t) { // Copy the null tail as well
-                System.arraycopy(elements, i + 1, elements, i, back);
-                tail = t - 1;
-            } else { // Wrap around
-                System.arraycopy(elements, i + 1, elements, i, mask - i);
-                elements[mask] = elements[0];
-                System.arraycopy(elements, 1, elements, 0, t);
-                tail = (t - 1) & mask;
-            }
-            return true;
-        }
-    }
-
-    // *** Collection Methods ***
-
-    /**
-     * Returns the number of elements in this queue.
-     *
-     * @return the number of elements in this queue
-     */
-    @Override
-    public int size() {
-        return (tail - head) & (elements.length - 1);
-    }
-
-    /**
-     * Returns <tt>true</tt> if this queue contains no elements.
-     *
-     * @return <tt>true</tt> if this queue contains no elements
-     */
-    @Override
-    public boolean isEmpty() {
-        return head == tail;
-    }
-
-    /**
-     * Returns an iterator over the elements in this queue.  The elements
-     * will be ordered from first (head) to last (tail).  This is the same
-     * order that elements would be queueued (via successive calls to
-     * {@link #remove} or popped (via successive calls to {@link #pop}).
-     *
-     * @return an iterator over the elements in this queue
-     */
-    @Override
-    public Iterator<E> iterator() {
-        return new QueueIterator();
-    }
-
-    private class QueueIterator implements Iterator<E> {
-        /**
-         * Index of element to be returned by subsequent call to next.
-         */
-        private int cursor = head;
-
-        /**
-         * Tail recorded at construction (also in remove), to stop
-         * iterator and also to check for comodification.
-         */
-        private int fence = tail;
-
-        /**
-         * Index of element returned by most recent call to next.
-         * Reset to -1 if element is deleted by a call to remove.
-         */
-        private int lastRet = -1;
-
-        @Override
-        public boolean hasNext() {
-            return cursor != fence;
-        }
-
-        @Override
-        public E next() {
-            if (cursor == fence)
-                throw new NoSuchElementException();
-            @SuppressWarnings("unchecked") E result = (E) elements[cursor];
-            // This check doesn't catch all possible comodifications,
-            // but does catch the ones that corrupt traversal
-            if (tail != fence || result == null)
-                throw new ConcurrentModificationException();
-            lastRet = cursor;
-            cursor = (cursor + 1) & (elements.length - 1);
-            return result;
-        }
-
-        @Override
-        public void remove() {
-            if (lastRet < 0)
-                throw new IllegalStateException();
-            if (delete(lastRet)) { // if left-shifted, undo increment in next()
-                cursor = (cursor - 1) & (elements.length - 1);
-                fence = tail;
-            }
-            lastRet = -1;
-        }
-    }
-
-    /**
-     * Returns <tt>true</tt> if this queue contains the specified element.
-     * More formally, returns <tt>true</tt> if and only if this queue contains
-     * at least one element <tt>e</tt> such that <tt>o.equals(e)</tt>.
-     *
-     * @param o object to be checked for containment in this queue
-     * @return <tt>true</tt> if this queue contains the specified element
-     */
-    @Override
-    public boolean contains(Object o) {
-        if (o == null)
-            return false;
-        int mask = elements.length - 1;
-        int i = head;
-        Object x;
-        while ((x = elements[i]) != null) {
-            if (o.equals(x))
-                return true;
-            i = (i + 1) & mask;
-        }
-        return false;
-    }
-
-    /**
-     * Removes a single instance of the specified element from this queue.
-     * If the queue does not contain the element, it is unchanged.
-     * More formally, removes the first element <tt>e</tt> such that
-     * <tt>o.equals(e)</tt> (if such an element exists).
-     * Returns <tt>true</tt> if this queue contained the specified element
-     * (or equivalently, if this queue changed as a result of the call).
-     *
-     * @param o element to be removed from this queue, if present
-     * @return <tt>true</tt> if this queue contained the specified element
-     */
-    @Override
-    public boolean remove(Object o) {
-        if (o == null)
-            return false;
-        int mask = elements.length - 1;
-        int i = head;
-        Object x;
-        while ((x = elements[i]) != null) {
-            if (o.equals(x)) {
-                delete(i);
-                return true;
-            }
-            i = (i + 1) & mask;
-        }
-        return false;
-    }
-
-    /**
-     * Removes all of the elements from this queue.
-     * The queue will be empty after this call returns.
-     */
-    @Override
-    public void clear() {
-        int h = head;
-        int t = tail;
-        if (h != t) { // clear all cells
-            head = tail = 0;
-            int i = h;
-            int mask = elements.length - 1;
-            do {
-                elements[i] = null;
-                i = (i + 1) & mask;
-            } while (i != t);
-        }
-    }
-
-    /**
-     * Returns an array containing all of the elements in this queue
-     * in proper sequence (from first to last element).
-     *
-     * <p>The returned array will be "safe" in that no references to it are
-     * maintained by this queue.  (In other words, this method must allocate
-     * a new array).  The caller is thus free to modify the returned array.
-     *
-     * <p>This method acts as bridge between array-based and collection-based
-     * APIs.
-     *
-     * @return an array containing all of the elements in this queue
-     */
-    @Override
-    public Object[] toArray() {
-        return toArray(new Object[size()]);
-    }
-
-    /**
-     * Returns an array containing all of the elements in this queue in
-     * proper sequence (from first to last element); the runtime type of the
-     * returned array is that of the specified array.  If the queue fits in
-     * the specified array, it is returned therein.  Otherwise, a new array
-     * is allocated with the runtime type of the specified array and the
-     * size of this queue.
-     *
-     * <p>If this queue fits in the specified array with room to spare
-     * (i.e., the array has more elements than this queue), the element in
-     * the array immediately following the end of the queue is set to
-     * <tt>null</tt>.
-     *
-     * <p>Like the {@link #toArray()} method, this method acts as bridge between
-     * array-based and collection-based APIs.  Further, this method allows
-     * precise control over the runtime type of the output array, and may,
-     * under certain circumstances, be used to save allocation costs.
-     *
-     * <p>Suppose <tt>x</tt> is a queue known to contain only strings.
-     * The following code can be used to dump the queue into a newly
-     * allocated array of <tt>String</tt>:
-     *
-     *  <pre> {@code String[] y = x.toArray(new String[0]);}</pre>
-     *
-     * Note that <tt>toArray(new Object[0])</tt> is identical in function to
-     * <tt>toArray()</tt>.
-     *
-     * @param a the array into which the elements of the queue are to
-     *          be stored, if it is big enough; otherwise, a new array of the
-     *          same runtime type is allocated for this purpose
-     * @return an array containing all of the elements in this queue
-     * @throws ArrayStoreException if the runtime type of the specified array
-     *         is not a supertype of the runtime type of every element in
-     *         this queue
-     * @throws NullPointerException if the specified array is null
-     */
-    @Override
-    public <T> T[] toArray(T[] a) {
-        int size = size();
-        if (a.length < size)
-            a = (T[]) java.lang.reflect.Array.newInstance(
-                    a.getClass().getComponentType(), size);
-        if (head < tail) {
-            System.arraycopy(elements, head, a, 0, size());
-        } else if (head > tail) {
-            int headPortionLen = elements.length - head;
-            System.arraycopy(elements, head, a, 0, headPortionLen);
-            System.arraycopy(elements, 0, a, headPortionLen, tail);
-        }
-        if (a.length > size)
-            a[size] = null;
-        return a;
-    }
-
-    // *** Object methods ***
-
-    /**
-     * Returns a copy of this queue.
-     *
-     * @return a copy of this queue
-     */
-    @Override
-    public ArrayQueue<E> clone() {
-        try {
-            ArrayQueue<E> result = (ArrayQueue<E>) super.clone();
-            E[] newElements = (E[]) Array.newInstance(elements.getClass().getComponentType(),
-                elements.length);
-            System.arraycopy(elements, 0, newElements, 0, elements.length);
-            result.elements = newElements;
-            return result;
-        } catch (CloneNotSupportedException e) {
-            throw new AssertionError();
-        }
-    }
-
-    /**
-     * Appease the serialization gods.
-     */
-    private static final long serialVersionUID = 2340985798034038923L;
-
-    /**
-     * Serialize this queue.
-     *
-     * @serialData The current size (<tt>int</tt>) of the queue,
-     * followed by all of its elements (each an object reference) in
-     * first-to-last order.
-     */
-    private void writeObject(java.io.ObjectOutputStream s)
-            throws java.io.IOException {
-        s.defaultWriteObject();
-
-        // Write out size
-        s.writeInt(size());
-
-        // Write out elements in order.
-        int mask = elements.length - 1;
-        for (int i = head; i != tail; i = (i + 1) & mask)
-            s.writeObject(elements[i]);
-    }
-
-    /**
-     * Deserialize this queue.
-     */
-    private void readObject(java.io.ObjectInputStream s)
-            throws java.io.IOException, ClassNotFoundException {
-        s.defaultReadObject();
-
-        // Read in size and allocate array
-        int size = s.readInt();
-        allocateElements(size);
-        head = 0;
-        tail = size;
-
-        // Read in all elements in the proper order.
-        for (int i = 0; i < size; i++)
-            elements[i] = s.readObject();
-    }
-}
diff --git a/core/src/main/java/dagger/internal/Binding.java b/core/src/main/java/dagger/internal/Binding.java
deleted file mode 100644
index 893dd9515..000000000
--- a/core/src/main/java/dagger/internal/Binding.java
+++ /dev/null
@@ -1,168 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal;
-
-import dagger.MembersInjector;
-import java.util.Set;
-import javax.inject.Provider;
-
-/**
- * Injects a value of a specific type.
- */
-public abstract class Binding<T> implements Provider<T>, MembersInjector<T> {
-  public static final Binding<Object> UNRESOLVED = new Binding<Object>(null, null, false, null) {
-    @Override public Object get() {
-      throw new AssertionError("Unresolved binding should never be called to inject.");
-    }
-    @Override public void injectMembers(Object t) {
-      throw new AssertionError("Unresolved binding should never be called to inject.");
-    }
-  };
-  protected static final boolean IS_SINGLETON = true;
-  protected static final boolean NOT_SINGLETON = false;
-
-  /** Set if the provided instance is always the same object. */
-  private static final int SINGLETON = 1 << 0;
-
-  /** Set if this binding's {@link #attach} completed without any missing dependencies. */
-  private static final int LINKED = 1 << 1;
-
-  /** Set if {@link ProblemDetector} is actively visiting this binding. */
-  private static final int VISITING = 1 << 2;
-
-  /** Set if {@link ProblemDetector} has confirmed this binding has no circular dependencies. */
-  private static final int CYCLE_FREE = 1 << 3;
-
-  private static final int DEPENDED_ON = 1 << 4;
-
-  private static final int LIBRARY = 1 << 5;
-
-  /** The key used to provide instances of 'T', or null if this binding cannot provide instances. */
-  public final String provideKey;
-
-  /** The key used to inject members of 'T', or null if this binding cannot inject members. */
-  public final String membersKey;
-
-  /** Bitfield of states like SINGLETON and LINKED. */
-  private int bits;
-
-  public final Object requiredBy;
-
-  protected Binding(String provideKey, String membersKey, boolean singleton, Object requiredBy) {
-    if (singleton && provideKey == null) {
-      throw new InvalidBindingException(Keys.getClassName(membersKey),
-          "is exclusively members injected and therefore cannot be scoped");
-    }
-    this.provideKey = provideKey;
-    this.membersKey = membersKey;
-    this.requiredBy = requiredBy;
-    this.bits = (singleton ? SINGLETON : 0);
-  }
-
-  /**
-   * Links this binding to its dependencies.
-   */
-  public void attach(Linker linker) {
-  }
-
-  @Override public void injectMembers(T t) {
-    // If no members to inject, no-op.  Some classes will have no injectable members even
-    // if their supertypes do.
-  }
-
-  @Override public T get() {
-    throw new UnsupportedOperationException("No injectable constructor on " + getClass().getName());
-  }
-
-  /**
-   * Populates {@code getBindings} and {@code injectMembersBindings} with the
-   * bindings used by this binding to satisfy {@link #get} and {@link
-   * #injectMembers} calls, respectively.
-   *
-   * @param getBindings the bindings required by this binding's {@code get}
-   *     method. Although {@code get} usually calls into {@code injectMembers},
-   *     this <i>does not</i> contain the injectMembers bindings.
-   * @param injectMembersBindings the bindings required by this binding's {@code
-   *     injectMembers} method.
-   */
-  public void getDependencies(Set<Binding<?>> getBindings, Set<Binding<?>> injectMembersBindings) {
-    // Do nothing.  No override == no dependencies to contribute.
-  }
-
-  void setLinked() {
-    bits |= LINKED;
-  }
-
-  public boolean isLinked() {
-    return (bits & LINKED) != 0;
-  }
-
-  boolean isSingleton() {
-    return (bits & SINGLETON) != 0;
-  }
-
-  public boolean isVisiting() {
-    return (bits & VISITING) != 0;
-  }
-
-  public void setVisiting(boolean visiting) {
-    this.bits = visiting ? (bits | VISITING) : (bits & ~VISITING);
-  }
-
-  public boolean isCycleFree() {
-    return (bits & CYCLE_FREE) != 0;
-  }
-
-  public void setCycleFree(boolean cycleFree) {
-    this.bits = cycleFree ? (bits | CYCLE_FREE) : (bits & ~CYCLE_FREE);
-  }
-
-  public void setLibrary(boolean library) {
-    this.bits = library ? (bits | LIBRARY) : (bits & ~LIBRARY);
-  }
-
-  public boolean library() {
-    return (bits & LIBRARY) != 0;
-  }
-
-  public void setDependedOn(boolean dependedOn) {
-    this.bits = dependedOn ? (bits | DEPENDED_ON) : (bits & ~DEPENDED_ON);
-  }
-
-  public boolean dependedOn() {
-    return (bits & DEPENDED_ON) != 0;
-  }
-
-  @Override public String toString() {
-    return getClass().getSimpleName()
-            + "[provideKey=\"" + provideKey + "\", memberskey=\"" + membersKey + "\"]";
-  }
-
-  /** An exception thrown by anything attempting to construct a binding which is invalid. */
-  public static class InvalidBindingException extends RuntimeException {
-    public final String type;
-
-    public InvalidBindingException(String type, String error) {
-      super(error);
-      this.type = type;
-    }
-
-    public InvalidBindingException(String type, String error, Throwable cause) {
-      super("Binding for " + type + " was invalid: " + error, cause);
-      this.type = type;
-    }
-  }
-}
diff --git a/core/src/main/java/dagger/internal/BindingsGroup.java b/core/src/main/java/dagger/internal/BindingsGroup.java
deleted file mode 100644
index 861f7de86..000000000
--- a/core/src/main/java/dagger/internal/BindingsGroup.java
+++ /dev/null
@@ -1,57 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- * Copyright (C) 2013 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal;
-
-import java.util.LinkedHashMap;
-import java.util.Map;
-import java.util.Map.Entry;
-import java.util.Set;
-
-/**
- * A grouping of bindings that fails when existing values are clobbered, to be used in collecting
- * the initial set of bindings for a graph (from provides methods).
- */
-public abstract class BindingsGroup {
-  private final Map<String, Binding<?>> bindings = new LinkedHashMap<String, Binding<?>>();
-
-  public abstract Binding<?> contributeSetBinding(String key, SetBinding<?> value);
-
-  public Binding<?> contributeProvidesBinding(String key, ProvidesBinding<?> value) {
-    return put(key, value);
-  }
-
-  protected Binding<?> put(String key, Binding<?> value) {
-    Binding<?> clobbered = bindings.put(key, value);
-    if (clobbered != null) {
-      bindings.put(key, clobbered); // Put things back as they were.
-      throw new IllegalArgumentException("Duplicate:\n    " + clobbered + "\n    " + value);
-    }
-    return null;
-  }
-
-  public Binding<?> get(String key) {
-    return bindings.get(key);
-  }
-
-  public final Set<Entry<String, Binding<?>>> entrySet() {
-    return bindings.entrySet();
-  }
-
-  @Override public String toString() {
-    return getClass().getSimpleName() + bindings.toString();
-  }
-}
diff --git a/core/src/main/java/dagger/internal/BuiltInBinding.java b/core/src/main/java/dagger/internal/BuiltInBinding.java
deleted file mode 100644
index 425c4ff94..000000000
--- a/core/src/main/java/dagger/internal/BuiltInBinding.java
+++ /dev/null
@@ -1,52 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal;
-
-/**
- * Injects a Provider or a MembersInjector.
- */
-final class BuiltInBinding<T> extends Binding<T> {
-  private final String delegateKey;
-  private final ClassLoader classLoader;
-  private Binding<?> delegate;
-
-  public BuiltInBinding(
-      String key, Object requiredBy, ClassLoader classLoader, String delegateKey) {
-    super(key, null, false, requiredBy);
-    this.classLoader = classLoader;
-    this.delegateKey = delegateKey;
-  }
-
-  @Override public void attach(Linker linker) {
-    delegate = linker.requestBinding(delegateKey, requiredBy, classLoader);
-  }
-
-  @Override public void injectMembers(T t) {
-    throw new UnsupportedOperationException();
-  }
-
-  @SuppressWarnings("unchecked") // At runtime we know 'T' is a Provider or MembersInjector.
-  @Override public T get() {
-    return (T) delegate;
-  }
-
-  public Binding<?> getDelegate() {
-    return delegate;
-  }
-
-  // public void getDependencies() not overridden.
-  // We don't add 'delegate' because it isn't actually used by get() or injectMembers().
-}
diff --git a/core/src/main/java/dagger/internal/FailoverLoader.java b/core/src/main/java/dagger/internal/FailoverLoader.java
deleted file mode 100644
index e55daf06a..000000000
--- a/core/src/main/java/dagger/internal/FailoverLoader.java
+++ /dev/null
@@ -1,173 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- * Copyright (C) 2013 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal;
-
-import dagger.internal.loaders.ReflectiveAtInjectBinding;
-import dagger.internal.loaders.ReflectiveStaticInjection;
-import java.lang.reflect.Constructor;
-import java.lang.reflect.InvocationTargetException;
-
-import static dagger.internal.loaders.GeneratedAdapters.INJECT_ADAPTER_SUFFIX;
-import static dagger.internal.loaders.GeneratedAdapters.MODULE_ADAPTER_SUFFIX;
-import static dagger.internal.loaders.GeneratedAdapters.STATIC_INJECTION_SUFFIX;
-
-/**
- * Handles loading/finding of modules, injection bindings, and static injections by use of a
- * strategy of "load the appropriate generated code" or, if no such code is found, create a
- * reflective equivalent.
- */
-public final class FailoverLoader extends Loader {
-  /*
-   * Note that String.concat is used throughout this code because it is the most efficient way to
-   * concatenate _two_ strings.  javac uses StringBuilder for the + operator and it has proven to
-   * be wasteful in terms of both CPU and memory allocated.
-   */
-
-  private final Memoizer<Class<?>, ModuleAdapter<?>> loadedAdapters =
-      new Memoizer<Class<?>, ModuleAdapter<?>>() {
-        @Override protected ModuleAdapter<?> create(Class<?> type) {
-          ModuleAdapter<?> result =
-              instantiate(type.getName().concat(MODULE_ADAPTER_SUFFIX), type.getClassLoader());
-          if (result == null) {
-            throw new IllegalStateException("Module adapter for " + type + " could not be loaded. "
-                + "Please ensure that code generation was run for this module.");
-          }
-          return result;
-        }
-      };
-
-  /**
-   * Obtains a module adapter for {@code module} from the first responding resolver.
-   */
-  @SuppressWarnings("unchecked") // cache ensures types match
-  @Override public <T> ModuleAdapter<T> getModuleAdapter(Class<T> type) {
-    return (ModuleAdapter<T>) loadedAdapters.get(type);
-  }
-
-  private final Memoizer<AtInjectBindingKey, AtInjectBindingInfo> atInjectBindings =
-      new Memoizer<AtInjectBindingKey, AtInjectBindingInfo>() {
-        @Override protected AtInjectBindingInfo create(AtInjectBindingKey key) {
-          return getAtInjectBindingInfo(key.classLoader, key.className);
-        }
-      };
-
-  private static final class AtInjectBindingKey {
-    // classLoader can be null
-    private final ClassLoader classLoader;
-    private final String className;
-
-    AtInjectBindingKey(ClassLoader classLoader, String className) {
-      this.classLoader = classLoader;
-      this.className = className;
-    }
-
-    @Override
-    public int hashCode() {
-      // It is highly unlikely for the same class name to be present in multiple class loaders. If
-      // this does happen, we'll just let those keys collide.
-      return className.hashCode();
-    }
-
-    @Override
-    public boolean equals(Object object) {
-      if (object == this) {
-        return true;
-      }
-      if (object instanceof AtInjectBindingKey) {
-        AtInjectBindingKey other = (AtInjectBindingKey) object;
-        return (classLoader == other.classLoader) && className.equals(other.className);
-      }
-      return false;
-
-    }
-  }
-
-  private static final class AtInjectBindingInfo {
-    private final Constructor<Binding<?>> adapterConstructor;
-    private final ReflectiveAtInjectBinding.Factory<?> reflectiveBindingFactory;
-
-    AtInjectBindingInfo(Constructor<Binding<?>> adapterConstructor,
-        ReflectiveAtInjectBinding.Factory<?> reflectiveBindingFactory) {
-      this.adapterConstructor = adapterConstructor;
-      this.reflectiveBindingFactory = reflectiveBindingFactory;
-    }
-  }
-
-  @Override public Binding<?> getAtInjectBinding(
-      String key, String className, ClassLoader classLoader, boolean mustHaveInjections) {
-    AtInjectBindingInfo info = atInjectBindings.get(new AtInjectBindingKey(classLoader, className));
-    if (info.adapterConstructor != null) {
-      try {
-        return info.adapterConstructor.newInstance();
-        // Duplicated catch statements becase: android.
-      } catch (InstantiationException e) {
-        throw new IllegalStateException(
-            "Could not create an instance of the inject adapter for class " + className, e);
-      } catch (IllegalAccessException e) {
-        throw new IllegalStateException(
-            "Could not create an instance of the inject adapter for class " + className, e);
-      } catch (IllegalArgumentException e) {
-        throw new IllegalStateException(
-            "Could not create an instance of the inject adapter for class " + className, e);
-      } catch (InvocationTargetException e) {
-        throw new IllegalStateException(
-            "Could not create an instance of the inject adapter for class " + className, e);
-      }
-    } else if (info.reflectiveBindingFactory != null) {
-      return info.reflectiveBindingFactory.create(mustHaveInjections);
-    } else {
-      return null;
-    }
-  }
-
-  private AtInjectBindingInfo getAtInjectBindingInfo(ClassLoader classLoader, String className) {
-    Class<?> adapterClass = loadClass(classLoader, className.concat(INJECT_ADAPTER_SUFFIX));
-    if (!adapterClass.equals(Void.class)) {
-      // Found loadable adapter, using it.
-      try {
-        @SuppressWarnings("unchecked")
-        Constructor<Binding<?>> constructor
-            = (Constructor<Binding<?>>) adapterClass.getConstructor();
-        return new AtInjectBindingInfo(constructor, null);
-      } catch (NoSuchMethodException e) {
-        throw new IllegalStateException(
-            "Couldn't find default constructor in the generated inject adapter for class "
-            + className);
-      }
-    }
-    Class<?> type = loadClass(classLoader, className);
-    if (type.equals(Void.class)) {
-      throw new IllegalStateException("Could not load class " + className);
-    }
-    if (type.isInterface()) {
-      // Short-circuit since we can't build reflective bindings for interfaces.
-      return new AtInjectBindingInfo(null, null);
-    }
-    ReflectiveAtInjectBinding.Factory<?> reflectiveBindingFactory
-        = ReflectiveAtInjectBinding.createFactory(type);
-    return new AtInjectBindingInfo(null, reflectiveBindingFactory);
-  }
-
-  @Override public StaticInjection getStaticInjection(Class<?> injectedClass) {
-    StaticInjection result = instantiate(
-          injectedClass.getName().concat(STATIC_INJECTION_SUFFIX), injectedClass.getClassLoader());
-    if (result != null) {
-      return result;
-    }
-    return ReflectiveStaticInjection.create(injectedClass);
-  }
-}
diff --git a/core/src/main/java/dagger/internal/Keys.java b/core/src/main/java/dagger/internal/Keys.java
deleted file mode 100644
index 2a5fe120f..000000000
--- a/core/src/main/java/dagger/internal/Keys.java
+++ /dev/null
@@ -1,274 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- * Copyright (C) 2012 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal;
-
-import dagger.Lazy;
-import dagger.MembersInjector;
-import java.lang.annotation.Annotation;
-import java.lang.reflect.GenericArrayType;
-import java.lang.reflect.ParameterizedType;
-import java.lang.reflect.Type;
-import java.util.Set;
-import javax.inject.Provider;
-import javax.inject.Qualifier;
-
-/**
- * Formats strings that identify the value to be injected. Keys are of one of
- * three forms:
- * <ol>
- *   <li>{@code com.square.Foo}: provides instances of Foo.
- *   <li>{@code @com.square.Bar/com.square.Foo}: provides instances of Foo
- *       qualified by the annotation.
- *   <li>{@code members/com.square.Foo}: injects members of Foo.
- * </ol>
- * Bindings from {@code @Provides} methods are of the first two types. BindingsGroup
- * created from {@code @Inject}-annotated members of a class are of the first
- * and last types.
- */
-public final class Keys {
-  private static final String PROVIDER_PREFIX = Provider.class.getCanonicalName() + "<";
-  private static final String MEMBERS_INJECTOR_PREFIX =
-      MembersInjector.class.getCanonicalName() + "<";
-  private static final String LAZY_PREFIX = Lazy.class.getCanonicalName() + "<";
-  private static final String SET_PREFIX = Set.class.getCanonicalName() + "<";
-
-  private static final Memoizer<Class<? extends Annotation>, Boolean> IS_QUALIFIER_ANNOTATION =
-      new Memoizer<Class<? extends Annotation>, Boolean>() {
-        @Override protected Boolean create(Class<? extends Annotation> annotationType) {
-          return annotationType.isAnnotationPresent(Qualifier.class);
-        }
-      };
-
-  Keys() {
-  }
-
-  /** Returns a key for {@code type} with no annotation. */
-  public static String get(Type type) {
-    return get(type, null);
-  }
-
-  /** Returns a key for the members of {@code type}. */
-  public static String getMembersKey(Class<?> key) {
-    // for classes key.getName() is equivalent to get(key)
-    return "members/".concat(key.getName());
-  }
-
-  /** Returns a key for {@code type} annotated by {@code annotation}. */
-  private static String get(Type type, Annotation annotation) {
-    type = boxIfPrimitive(type);
-    if (annotation == null && type instanceof Class && !((Class<?>) type).isArray()) {
-      return ((Class<?>) type).getName();
-    }
-    StringBuilder result = new StringBuilder();
-    if (annotation != null) {
-      result.append(annotation).append("/");
-    }
-    typeToString(type, result, true);
-    return result.toString();
-  }
-
-  /**
-   * Returns a key for {@code type} annotated with {@code annotations},
-   * wrapped by {@code Set}, reporting failures against {@code subject}.
-   *
-   * @param annotations the annotations on a single method, field or parameter.
-   *     This array may contain at most one qualifier annotation.
-   */
-  public static String getSetKey(Type type, Annotation[] annotations, Object subject) {
-    Annotation qualifier = extractQualifier(annotations, subject);
-    type = boxIfPrimitive(type);
-    StringBuilder result = new StringBuilder();
-    if (qualifier != null) {
-      result.append(qualifier).append("/");
-    }
-    result.append(SET_PREFIX);
-    typeToString(type, result, true);
-    result.append(">");
-    return result.toString();
-  }
-
-  /**
-   * Returns a key for {@code type} annotated with {@code annotations},
-   * reporting failures against {@code subject}.
-   *
-   * @param annotations the annotations on a single method, field or parameter.
-   *     This array may contain at most one qualifier annotation.
-   */
-  public static String get(Type type, Annotation[] annotations, Object subject) {
-    return get(type, extractQualifier(annotations, subject));
-  }
-
-  /**
-   * Validates that among {@code annotations} there exists only one annotation which is, itself
-   * qualified by {@code \@Qualifier}
-   */
-  private static Annotation extractQualifier(Annotation[] annotations,
-      Object subject) {
-    Annotation qualifier = null;
-    for (Annotation a : annotations) {
-      if (!IS_QUALIFIER_ANNOTATION.get(a.annotationType())) {
-        continue;
-      }
-      if (qualifier != null) {
-        throw new IllegalArgumentException("Too many qualifier annotations on " + subject);
-      }
-      qualifier = a;
-    }
-    return qualifier;
-  }
-
-  /**
-   * @param topLevel true if this is a top-level type where primitive types
-   *     like 'int' are forbidden. Recursive calls pass 'false' to support
-   *     arrays like {@code int[]}.
-   */
-  private static void typeToString(Type type, StringBuilder result, boolean topLevel) {
-    if (type instanceof Class) {
-      Class<?> c = (Class<?>) type;
-      if (c.isArray()) {
-        typeToString(c.getComponentType(), result, false);
-        result.append("[]");
-      } else if (c.isPrimitive()) {
-        if (topLevel) {
-          throw new UnsupportedOperationException("Uninjectable type " + c.getName());
-        }
-        result.append(c.getName());
-      } else {
-        result.append(c.getName());
-      }
-    } else if (type instanceof ParameterizedType) {
-      ParameterizedType parameterizedType = (ParameterizedType) type;
-      typeToString(parameterizedType.getRawType(), result, true);
-      Type[] arguments = parameterizedType.getActualTypeArguments();
-      result.append("<");
-      for (int i = 0; i < arguments.length; i++) {
-        if (i != 0) {
-          result.append(", ");
-        }
-        typeToString(arguments[i], result, true);
-      }
-      result.append(">");
-    } else if (type instanceof GenericArrayType) {
-      GenericArrayType genericArrayType = (GenericArrayType) type;
-      typeToString(genericArrayType.getGenericComponentType(), result, false);
-      result.append("[]");
-    } else {
-      throw new UnsupportedOperationException("Uninjectable type " + type);
-    }
-  }
-
-  /**
-   * Returns a key for the type provided by, or injected by this key. For
-   * example, if this is a key for a {@code Provider<Foo>}, this returns the
-   * key for {@code Foo}. This retains annotations and supports both Provider
-   * keys and MembersInjector keys.
-   */
-  static String getBuiltInBindingsKey(String key) {
-    int start = startOfType(key);
-    if (substringStartsWith(key, start, PROVIDER_PREFIX)) {
-      return extractKey(key, start, key.substring(0, start), PROVIDER_PREFIX);
-    } else if (substringStartsWith(key, start, MEMBERS_INJECTOR_PREFIX)) {
-      return extractKey(key, start, "members/", MEMBERS_INJECTOR_PREFIX);
-    } else {
-      return null;
-    }
-  }
-
-  /**
-   * Returns a key for the underlying binding of a {@code Lazy<T>} value. For example,
-   * if this is a key for a {@code Lazy<Foo>}, this returns the key for
-   * {@code Foo}. This retains annotations.
-   */
-  static String getLazyKey(String key) {
-    int start = startOfType(key);
-    if (substringStartsWith(key, start, LAZY_PREFIX)) {
-      return extractKey(key, start, key.substring(0, start), LAZY_PREFIX);
-    } else {
-      return null;
-    }
-  }
-
-  /**
-   * Returns the start of a key if it is a plain key, and the start of the
-   * underlying key if it is an annotated key
-   */
-  private static int startOfType(String key) {
-    return (key.startsWith("@")) ? key.lastIndexOf('/') + 1 : 0;
-  }
-
-  /**
-   * Returns an unwrapped key (the key for {@code T} from a {@code Provider<T>} for example),
-   * removing all wrapping key information, but preserving annotations or known
-   * prefixes.
-   *
-   * @param key the key from which the delegate key should be extracted.
-   * @param start
-   *          an index into the key representing the key's "real" start after
-   *          any annotations.
-   * @param delegatePrefix
-   *          key prefix elements extracted from the underlying delegate
-   *          (annotations, "members/", etc.)
-   * @param prefix the prefix to strip.
-   */
-  private static String extractKey(String key, int start, String delegatePrefix, String prefix) {
-    return delegatePrefix + key.substring(start + prefix.length(), key.length() - 1);
-  }
-
-  /** Returns true if {@code string.substring(offset).startsWith(substring)}. */
-  private static boolean substringStartsWith(String string, int offset, String substring) {
-    return string.regionMatches(offset, substring, 0, substring.length());
-  }
-
-  /** Returns true if {@code key} has a qualifier annotation. */
-  public static boolean isAnnotated(String key) {
-    return key.startsWith("@");
-  }
-
-  /**
-   * Returns the class name for {@code key}, if {@code key} was created with a
-   * class instance. Returns null if {@code key} represents a parameterized type
-   * or an array type.
-   */
-  public static String getClassName(String key) {
-    int start = 0;
-    if (key.startsWith("@") || key.startsWith("members/")) {
-      start = key.lastIndexOf('/') + 1;
-    }
-    return (key.indexOf('<', start) == -1 && key.indexOf('[', start) == -1)
-        ? key.substring(start)
-        : null;
-  }
-
-  /** Returns true if {@code name} is the name of a platform-provided class. */
-  public static boolean isPlatformType(String name) {
-    return name.startsWith("java.") || name.startsWith("javax.") || name.startsWith("android.");
-  }
-
-  private static Type boxIfPrimitive(Type type) {
-    if (type == byte.class) return Byte.class;
-    if (type == short.class) return Short.class;
-    if (type == int.class) return Integer.class;
-    if (type == long.class) return Long.class;
-    if (type == char.class) return Character.class;
-    if (type == boolean.class) return Boolean.class;
-    if (type == float.class) return Float.class;
-    if (type == double.class) return Double.class;
-    if (type == void.class) return Void.class;
-    return type;
-  }
-
-}
diff --git a/core/src/main/java/dagger/internal/LazyBinding.java b/core/src/main/java/dagger/internal/LazyBinding.java
deleted file mode 100644
index ef6f11c98..000000000
--- a/core/src/main/java/dagger/internal/LazyBinding.java
+++ /dev/null
@@ -1,71 +0,0 @@
-/*
- * Copyright (C) 2012 Google, Inc.
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal;
-
-import dagger.Lazy;
-
-/**
- * Injects a Lazy wrapper for a type T
- */
-final class LazyBinding<T> extends Binding<Lazy<T>> {
-
-  private final static Object NOT_PRESENT = new Object();
-
-  private final String lazyKey;
-  private final ClassLoader loader;
-  private Binding<T> delegate;
-
-  public LazyBinding(String key, Object requiredBy, ClassLoader loader, String lazyKey) {
-    super(key, null, false, requiredBy);
-    this.loader = loader;
-    this.lazyKey = lazyKey;
-  }
-
-  @SuppressWarnings("unchecked") // At runtime we know it's a Binding<Lazy<T>>.
-  @Override
-  public void attach(Linker linker) {
-    delegate = (Binding<T>) linker.requestBinding(lazyKey, requiredBy, loader);
-  }
-
-  @Override public void injectMembers(Lazy<T> t) {
-    throw new UnsupportedOperationException(); // Injecting into a custom Lazy not supported.
-  }
-
-  @Override
-  public Lazy<T> get() {
-    // TODO(gak): Use DoubleCheckLazy
-    return new Lazy<T>() {
-      private volatile Object cacheValue = NOT_PRESENT;
-
-      @SuppressWarnings("unchecked") // Delegate is of type T
-      @Override
-      public T get() {
-        if (cacheValue == NOT_PRESENT) {
-          synchronized (this) {
-            if (cacheValue == NOT_PRESENT) {
-              cacheValue = delegate.get();
-            }
-          }
-        }
-        return (T) cacheValue;
-      }
-    };
-  }
-
-  // public void getDependencies() not overridden.
-  // We don't add 'delegate' because it isn't actually used by get() or injectMembers().
-}
diff --git a/core/src/main/java/dagger/internal/Linker.java b/core/src/main/java/dagger/internal/Linker.java
deleted file mode 100644
index e9cf9f4b6..000000000
--- a/core/src/main/java/dagger/internal/Linker.java
+++ /dev/null
@@ -1,472 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal;
-
-import dagger.internal.Binding.InvalidBindingException;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.Queue;
-import java.util.Set;
-
-/**
- * Links bindings to their dependencies.
- */
-public final class Linker {
-  private static final Object UNINITIALIZED = new Object();
-
-  /**
-   * The base {@code Linker} which will be consulted to satisfy bindings not
-   * otherwise satisfiable from this {@code Linker}. The top-most {@code Linker}
-   * in a chain will have a null base linker.
-   */
-  private final Linker base;
-
-  /** Bindings requiring a call to attach(). May contain deferred bindings. */
-  private final Queue<Binding<?>> toLink = new ArrayQueue<Binding<?>>();
-
-  /** True unless calls to requestBinding() were unable to satisfy the binding. */
-  private boolean attachSuccess = true;
-
-  /** All errors encountered during injection. */
-  private final List<String> errors = new ArrayList<String>();
-
-  /** All of the object graph's bindings. This may contain unlinked bindings. */
-  private final Map<String, Binding<?>> bindings = new HashMap<String, Binding<?>>();
-
-  /**
-   * An unmodifiable map containing all of the bindings available in this linker, fully linked.
-   * This will be null if the bindings are not yet fully linked. It provides both a signal
-   * of completion of the {@link #linkAll()} method, as well as a place to reference the final,
-   * fully linked map of bindings.
-   */
-  private volatile Map<String, Binding<?>> linkedBindings = null;
-
-  private final Loader plugin;
-
-  private final ErrorHandler errorHandler;
-
-  public Linker(Linker base, Loader plugin, ErrorHandler errorHandler) {
-    if (plugin == null) throw new NullPointerException("plugin");
-    if (errorHandler == null) throw new NullPointerException("errorHandler");
-
-    this.base = base;
-    this.plugin = plugin;
-    this.errorHandler = errorHandler;
-  }
-
-  /**
-   * Adds all bindings in {@code toInstall}. The caller must call either {@link
-   * #linkAll} or {@link #requestBinding} and {@link #linkRequested} before the
-   * bindings can be used.
-   *
-   * This method may only be called before {@link #linkAll()}. Subsequent calls to
-   * {@link #installBindings(BindingsGroup)} will throw an {@link IllegalStateException}.
-   */
-  public void installBindings(BindingsGroup toInstall) {
-    if (linkedBindings != null) {
-      throw new IllegalStateException("Cannot install further bindings after calling linkAll().");
-    }
-    for (Map.Entry<String, ? extends Binding<?>> entry : toInstall.entrySet()) {
-      bindings.put(entry.getKey(), scope(entry.getValue()));
-    }
-  }
-
-  /**
-   * Links all known bindings (whether requested or installed), plus all of their
-   * transitive dependencies. This loads injectable types' bindings as necessary to fill in
-   * the gaps.  If this method has returned successfully at least once, all further
-   * work is short-circuited.
-   *
-   * @throws AssertionError if this method is not called within a synchronized block which
-   *     holds this {@link Linker} as the lock object.
-   */
-  public Map<String, Binding<?>> linkAll() {
-    assertLockHeld();
-    if (linkedBindings != null) {
-      return linkedBindings;
-    }
-    for (Binding<?> binding : bindings.values()) {
-      if (!binding.isLinked()) {
-        toLink.add(binding);
-      }
-    }
-    linkRequested(); // This method throws if bindings are not resolvable/linkable.
-    linkedBindings = Collections.unmodifiableMap(bindings);
-    return linkedBindings;
-  }
-
-  /**
-   * Returns the map of all bindings available to this {@link Linker}, if and only if
-   * {@link #linkAll()} has successfully returned at least once, otherwise it returns null;
-   */
-  public Map<String, Binding<?>> fullyLinkedBindings() {
-    return linkedBindings;
-  }
-
-  /**
-   * Links all requested bindings plus their transitive dependencies. This
-   * creates JIT bindings as necessary to fill in the gaps.
-   *
-   * @throws AssertionError if this method is not called within a synchronized block which
-   *     holds this {@link Linker} as the lock object.
-   */
-  public void linkRequested() {
-    assertLockHeld();
-    Binding<?> binding;
-    while ((binding = toLink.poll()) != null) {
-      if (binding instanceof DeferredBinding) {
-        DeferredBinding deferred = (DeferredBinding) binding;
-        String key = deferred.deferredKey;
-        boolean mustHaveInjections = deferred.mustHaveInjections;
-        if (bindings.containsKey(key)) {
-          continue; // A binding for this key has since been linked.
-        }
-        try {
-          Binding<?> resolvedBinding =
-              createBinding(key, binding.requiredBy, deferred.classLoader, mustHaveInjections);
-          resolvedBinding.setLibrary(binding.library());
-          resolvedBinding.setDependedOn(binding.dependedOn());
-          // Fail if the type of binding we got wasn't capable of what was requested.
-          if (!key.equals(resolvedBinding.provideKey) && !key.equals(resolvedBinding.membersKey)) {
-            throw new IllegalStateException("Unable to create binding for " + key);
-          }
-          // Enqueue the JIT binding so its own dependencies can be linked.
-          Binding<?> scopedBinding = scope(resolvedBinding);
-          toLink.add(scopedBinding);
-          putBinding(scopedBinding);
-        } catch (InvalidBindingException e) {
-          addError(e.type + " " + e.getMessage() + " required by " + binding.requiredBy);
-          bindings.put(key, Binding.UNRESOLVED);
-        } catch (UnsupportedOperationException e) {
-          addError("Unsupported: " + e.getMessage() + " required by " + binding.requiredBy);
-          bindings.put(key, Binding.UNRESOLVED);
-        } catch (IllegalArgumentException e) {
-          addError(e.getMessage() + " required by " + binding.requiredBy);
-          bindings.put(key, Binding.UNRESOLVED);
-        } catch (RuntimeException e) {
-          throw e;
-        } catch (Exception e) {
-          throw new RuntimeException(e);
-        }
-      } else {
-        // Attempt to attach the binding to its dependencies. If any dependency
-        // is not available, the attach will fail. We'll enqueue creation of
-        // that dependency and retry the attachment later.
-        attachSuccess = true;
-        binding.attach(this);
-        if (attachSuccess) {
-          binding.setLinked();
-        } else {
-          toLink.add(binding);
-        }
-      }
-    }
-
-    try {
-      errorHandler.handleErrors(errors);
-    } finally {
-      errors.clear();
-    }
-  }
-
-  /**
-   * Don't permit bindings to be linked without a lock. Callers should lock
-   * before requesting any bindings, link the requested bindings, retrieve
-   * the linked bindings, and then release the lock.
-   */
-  private void assertLockHeld() {
-    if (!Thread.holdsLock(this)) throw new AssertionError();
-  }
-
-  /**
-   * Returns a binding for the key in {@code deferred}. The type of binding
-   * to be created depends on the key's type:
-   * <ul>
-   *   <li>Injections of {@code Provider<Foo>}, {@code MembersInjector<Bar>}, and
-   *       {@code Lazy<Blah>} will delegate to the bindings of {@code Foo}, {@code Bar}, and
-   *       {@code Blah} respectively.
-   *   <li>Injections of raw types will use the injectable constructors of those classes.
-   *   <li>Any other injection types require @Provides bindings and will error out.
-   * </ul>
-   */
-  private Binding<?> createBinding(String key, Object requiredBy, ClassLoader classLoader,
-      boolean mustHaveInjections) {
-    String builtInBindingsKey = Keys.getBuiltInBindingsKey(key);
-    if (builtInBindingsKey != null) {
-      return new BuiltInBinding<Object>(key, requiredBy, classLoader, builtInBindingsKey);
-    }
-    String lazyKey = Keys.getLazyKey(key);
-    if (lazyKey != null) {
-      return new LazyBinding<Object>(key, requiredBy, classLoader, lazyKey);
-    }
-
-    String className = Keys.getClassName(key);
-    if (className == null) {
-      throw new InvalidBindingException(key,
-          "is a generic class or an array and can only be bound with concrete type parameter(s) "
-          + "in a @Provides method.");
-    }
-    if (Keys.isAnnotated(key)) {
-      throw new InvalidBindingException(key,
-          "is a @Qualifier-annotated type and must be bound by a @Provides method.");
-    }
-    Binding<?> binding =
-        plugin.getAtInjectBinding(key, className, classLoader, mustHaveInjections);
-    if (binding != null) {
-      return binding;
-    }
-    throw new InvalidBindingException(className, "could not be bound with key " + key);
-  }
-
-  /** @deprecated Older, generated code still using this should be re-generated. */
-  @Deprecated
-  public Binding<?> requestBinding(String key, Object requiredBy) {
-    return requestBinding(
-        key, requiredBy, getClass().getClassLoader(), true, true);
-  }
-
-  /**
-   * Returns the binding if it exists immediately. Otherwise this returns
-   * null. If the returned binding didn't exist or was unlinked, it will be
-   * enqueued to be linked.
-   */
-  public Binding<?> requestBinding(String key, Object requiredBy, ClassLoader classLoader) {
-    return requestBinding(key, requiredBy, classLoader, true, true);
-  }
-
-  /** @deprecated Older, generated code still using this should be re-generated. */
-  @Deprecated
-  public Binding<?> requestBinding(String key, Object requiredBy,
-      boolean mustHaveInjections, boolean library) {
-    return requestBinding(key, requiredBy, getClass().getClassLoader(),
-        mustHaveInjections, library);
-  }
-
-  /**
-   * Returns the binding if it exists immediately. Otherwise this returns
-   * null. If the returned binding didn't exist or was unlinked, it will be
-   * enqueued to be linked.
-   *
-   * @param mustHaveInjections true if the the referenced key requires either an
-   *     {@code @Inject} annotation is produced by a {@code @Provides} method.
-   *     This isn't necessary for Module.injects types because frameworks need
-   *     to inject arbitrary classes like JUnit test cases and Android
-   *     activities. It also isn't necessary for supertypes.
-   */
-  public Binding<?> requestBinding(String key, Object requiredBy, ClassLoader classLoader,
-      boolean mustHaveInjections, boolean library) {
-    assertLockHeld();
-
-    Binding<?> binding = null;
-    for (Linker linker = this; linker != null; linker = linker.base) {
-      binding = linker.bindings.get(key);
-      if (binding != null) {
-        if (linker != this && !binding.isLinked()) throw new AssertionError();
-        break;
-      }
-    }
-
-    if (binding == null) {
-      // We can't satisfy this binding. Make sure it'll work next time!
-      Binding<?> deferredBinding =
-          new DeferredBinding(key, classLoader, requiredBy, mustHaveInjections);
-      deferredBinding.setLibrary(library);
-      deferredBinding.setDependedOn(true);
-      toLink.add(deferredBinding);
-      attachSuccess = false;
-      return null;
-    }
-
-    if (!binding.isLinked()) {
-      toLink.add(binding); // This binding was never linked; link it now!
-    }
-
-    binding.setLibrary(library);
-    binding.setDependedOn(true);
-    return binding;
-  }
-
-  private <T> void putBinding(final Binding<T> binding) {
-
-    // At binding insertion time it's possible that another binding for the same
-    // key to already exist. This occurs when an @Provides method returns a type T
-    // and we also inject the members of that type.
-    if (binding.provideKey != null) {
-      putIfAbsent(bindings, binding.provideKey, binding);
-    }
-    if (binding.membersKey != null) {
-      putIfAbsent(bindings, binding.membersKey, binding);
-    }
-  }
-
-  /**
-   * Returns a scoped binding for {@code binding}.
-   */
-  static <T> Binding<T> scope(final Binding<T> binding) {
-    if (!binding.isSingleton() || binding instanceof SingletonBinding) {
-      return binding; // Default scoped binding or already a scoped binding.
-    }
-    return new SingletonBinding<T>(binding);
-  }
-
-  /**
-   * Puts the mapping {@code key, value} in {@code map} if no mapping for {@code
-   * key} already exists.
-   */
-  private <K, V> void putIfAbsent(Map<K, V> map, K key, V value) {
-    V replaced = map.put(key, value); // Optimistic: prefer only one hash operation lookup.
-    if (replaced != null) {
-      map.put(key, replaced);
-    }
-  }
-
-  /** Enqueue {@code message} as a fatal error to be reported to the user. */
-  private void addError(String message) {
-    errors.add(message);
-  }
-
-  /**
-   * A Binding that implements singleton behaviour around an existing binding.
-   */
-  private static class SingletonBinding<T> extends Binding<T> {
-    private final Binding<T> binding;
-    private volatile Object onlyInstance = UNINITIALIZED;
-
-    private SingletonBinding(Binding<T> binding) {
-      super(binding.provideKey, binding.membersKey, true, binding.requiredBy);
-      this.binding = binding;
-    }
-
-    @Override public void attach(Linker linker) {
-      binding.attach(linker);
-    }
-
-    @Override public void injectMembers(T t) {
-      binding.injectMembers(t);
-    }
-
-    @SuppressWarnings("unchecked") // onlyInstance is either 'UNINITIALIZED' or a 'T'.
-    @Override public T get() {
-      if (onlyInstance == UNINITIALIZED) {
-        synchronized (this) {
-          if (onlyInstance == UNINITIALIZED) {
-            onlyInstance = binding.get();
-          }
-        }
-      }
-      return (T) onlyInstance;
-    }
-
-    @Override public void getDependencies(Set<Binding<?>> get, Set<Binding<?>> injectMembers) {
-      binding.getDependencies(get, injectMembers);
-    }
-
-    @Override public boolean isCycleFree() {
-      return binding.isCycleFree();
-    }
-
-    @Override public boolean isLinked() {
-      return binding.isLinked();
-    }
-
-    @Override public boolean isVisiting() {
-      return binding.isVisiting();
-    }
-
-    @Override public boolean library() {
-      return binding.library();
-    }
-
-    @Override public boolean dependedOn() {
-      return binding.dependedOn();
-    }
-
-    @Override public void setCycleFree(final boolean cycleFree) {
-      binding.setCycleFree(cycleFree);
-    }
-
-    @Override public void setVisiting(final boolean visiting) {
-      binding.setVisiting(visiting);
-    }
-
-    @Override public void setLibrary(boolean library) {
-      binding.setLibrary(true);
-    }
-
-    @Override public void setDependedOn(boolean dependedOn) {
-      binding.setDependedOn(dependedOn);
-    }
-
-    @Override protected boolean isSingleton() {
-      return true;
-    }
-
-    @Override protected void setLinked() {
-      binding.setLinked();
-    }
-
-    @Override public String toString() {
-      return "@Singleton/" + binding.toString();
-    }
-  }
-
-  /** Handles linker errors appropriately. */
-  public interface ErrorHandler {
-    ErrorHandler NULL = new ErrorHandler() {
-      @Override public void handleErrors(List<String> errors) {
-      }
-    };
-
-    /**
-     * Fail if any errors have been enqueued.
-     * Implementations may throw exceptions or report the errors through another
-     * channel.  Callers are responsible for clearing enqueued errors.
-     *
-     * @param errors a potentially empty list of error messages.
-     */
-    void handleErrors(List<String> errors);
-  }
-
-  private static class DeferredBinding extends Binding<Object> {
-    /** Loader originally intended to load this binding, to be used in loading the actual one */
-    final ClassLoader classLoader;
-    final String deferredKey;
-    final boolean mustHaveInjections;
-
-    private DeferredBinding(String deferredKey, ClassLoader classLoader, Object requiredBy,
-        boolean mustHaveInjections) {
-      super(null, null, false, requiredBy);
-      this.deferredKey = deferredKey;
-      this.classLoader = classLoader;
-      this.mustHaveInjections = mustHaveInjections;
-    }
-
-    @Override public void injectMembers(Object t) {
-      throw new UnsupportedOperationException("Deferred bindings must resolve first.");
-    }
-
-    @Override public void getDependencies(Set<Binding<?>> get, Set<Binding<?>> injectMembers) {
-      throw new UnsupportedOperationException("Deferred bindings must resolve first.");
-    }
-
-    @Override public String toString() {
-      return "DeferredBinding[deferredKey=" + deferredKey + "]";
-    }
-  }
-}
diff --git a/core/src/main/java/dagger/internal/Loader.java b/core/src/main/java/dagger/internal/Loader.java
deleted file mode 100644
index 16e0e2322..000000000
--- a/core/src/main/java/dagger/internal/Loader.java
+++ /dev/null
@@ -1,92 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- * Copyright (C) 2013 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal;
-
-import java.lang.reflect.AccessibleObject;
-
-/**
- * Provides a point of configuration of the basic resolving functions within Dagger, namely
- * that of Module handling, injection binding creation, and static injection.  A plugin must
- * provide all resolution methods
- */
-public abstract class Loader {
-  private final Memoizer<ClassLoader, Memoizer<String, Class<?>>> caches =
-      new Memoizer<ClassLoader, Memoizer<String, Class<?>>>() {
-        @Override protected Memoizer<String, Class<?>> create(final ClassLoader classLoader) {
-          return new Memoizer<String, Class<?>>() {
-            @Override protected Class<?> create(String className) {
-              try {
-                return classLoader.loadClass(className);
-              } catch (ClassNotFoundException e) {
-                return Void.class; // Cache the failure (negative case).
-              }
-            }
-          };
-        }
-      };
-
-  /**
-   * Returns a binding that uses {@code @Inject} annotations, or null if no valid binding can
-   * be found or created.
-   */
-  public abstract Binding<?> getAtInjectBinding(
-      String key, String className, ClassLoader classLoader, boolean mustHaveInjections);
-
-  /**
-   * Returns a module adapter for {@code moduleClass} or throws a {@code TypeNotPresentException} if
-   * none can be found.
-   */
-  public abstract <T> ModuleAdapter<T> getModuleAdapter(Class<T> moduleClass);
-
-  /**
-   * Returns the static injection for {@code injectedClass}.
-   */
-  public abstract StaticInjection getStaticInjection(Class<?> injectedClass);
-
-  /**
-   * Loads a class from a {@code ClassLoader}-specific cache if it's already there, or
-   * loads it from the given {@code ClassLoader} and caching it for future requests.  Failures
-   * to load are also cached using the Void.class type.  A null {@code ClassLoader} is assumed
-   * to be the system classloader.
-   */
-  protected Class<?> loadClass(ClassLoader classLoader, String name) {
-    // A null classloader is the system classloader.
-    classLoader = (classLoader != null) ? classLoader : ClassLoader.getSystemClassLoader();
-    return caches.get(classLoader).get(name);
-  }
-
-  /**
-   * Instantiates a class using its default constructor and the given {@link ClassLoader}. This
-   * method does not attempt to {@linkplain AccessibleObject#setAccessible set accessibility}.
-   */
-  protected <T> T instantiate(String name, ClassLoader classLoader) {
-    try {
-      Class<?> generatedClass = loadClass(classLoader, name);
-      if (generatedClass == Void.class) {
-        return null;
-      }
-      @SuppressWarnings("unchecked")
-      T instance = (T) generatedClass.newInstance();
-      return instance;
-    } catch (InstantiationException e) {
-      throw new RuntimeException("Failed to initialize " + name, e);
-    } catch (IllegalAccessException e) {
-      throw new RuntimeException("Failed to initialize " + name, e);
-    }
-  }
-
-}
\ No newline at end of file
diff --git a/core/src/main/java/dagger/internal/MapProviderFactory.java b/core/src/main/java/dagger/internal/MapProviderFactory.java
index 5cc62c312..e4b8ef4ff 100644
--- a/core/src/main/java/dagger/internal/MapProviderFactory.java
+++ b/core/src/main/java/dagger/internal/MapProviderFactory.java
@@ -16,11 +16,9 @@
 package dagger.internal;
 
 import dagger.Factory;
-
 import java.util.Collections;
 import java.util.LinkedHashMap;
 import java.util.Map;
-
 import javax.inject.Provider;
 
 /**
diff --git a/core/src/main/java/dagger/internal/ModuleAdapter.java b/core/src/main/java/dagger/internal/ModuleAdapter.java
deleted file mode 100644
index ba7bc7062..000000000
--- a/core/src/main/java/dagger/internal/ModuleAdapter.java
+++ /dev/null
@@ -1,76 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- * Copyright (C) 2012 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal;
-
-/**
- * Extracts bindings from an {@code @Module}-annotated class.
- */
-public abstract class ModuleAdapter<T> {
-  public final Class<T> moduleClass;
-  public final String[] injectableTypes;
-  public final Class<?>[] staticInjections;
-  public final boolean overrides;
-  public final Class<?>[] includes;
-  public final boolean complete;
-  public final boolean library;
-
-  protected ModuleAdapter(Class<T> moduleClass, String[] injectableTypes,
-      Class<?>[] staticInjections, boolean overrides, Class<?>[] includes, boolean complete,
-      boolean library) {
-    this.moduleClass = moduleClass;
-    this.injectableTypes = injectableTypes;
-    this.staticInjections = staticInjections;
-    this.overrides = overrides;
-    this.includes = includes;
-    this.complete = complete;
-    this.library = library;
-  }
-
-  /**
-   * Returns bindings for the {@code @Provides} methods of {@code module}. The
-   * returned bindings must be linked before they can be used to inject values.
-   */
-  @SuppressWarnings("unused")
-  public void getBindings(BindingsGroup map, T module) {
-    // no-op;
-  }
-
-  /**
-   * Returns a new instance of the module class created using a no-args
-   * constructor. Only used when a manually-constructed module is not supplied.
-   */
-  protected T newModule() {
-    throw new UnsupportedOperationException("No no-args constructor on " + getClass().getName());
-  }
-
-  @Override
-  public final boolean equals(Object obj) {
-    if (obj == this) {
-      return true;
-    } else if (obj instanceof ModuleAdapter<?>) {
-      ModuleAdapter<?> that = (ModuleAdapter<?>) obj;
-      return this.moduleClass.equals(that.moduleClass);
-    } else {
-      return false;
-    }
-  }
-
-  @Override
-  public final int hashCode() {
-    return moduleClass.hashCode();
-  }
-}
diff --git a/core/src/main/java/dagger/internal/Modules.java b/core/src/main/java/dagger/internal/Modules.java
deleted file mode 100644
index 4f8d3cf7d..000000000
--- a/core/src/main/java/dagger/internal/Modules.java
+++ /dev/null
@@ -1,103 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- * Copyright (C) 2012 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal;
-
-import java.util.ArrayList;
-import java.util.HashSet;
-import java.util.List;
-
-/**
- * Static helper for organizing modules.
- */
-public final class Modules {
-
-  private Modules() { }
-
-  /**
-   * Returns a full set of module adapters, including module adapters for included
-   * modules.
-   */
-  public static ArrayList<ModuleWithAdapter> loadModules(Loader loader,
-      Object[] seedModulesOrClasses) {
-    int seedModuleCount = seedModulesOrClasses.length;
-    ArrayList<ModuleWithAdapter> result = new ArrayList<ModuleWithAdapter>(seedModuleCount);
-    HashSet<Class<?>> visitedClasses = new HashSet<Class<?>>(seedModuleCount);
-    // Add all seed classes to visited classes right away, so that we won't instantiate modules for
-    // them in collectIncludedModulesRecursively
-    // Iterate over seedModulesOrClasses in reverse, so that if multiple instances/classes of the
-    // same module are provided, the later one is used (this matches previous behavior which some
-    // code came to depend on.)
-    for (int i = seedModuleCount-1; i >= 0; i--) {
-      Object moduleOrClass = seedModulesOrClasses[i];
-      if (moduleOrClass instanceof Class<?>) {
-        if (visitedClasses.add((Class<?>) moduleOrClass)) {
-          ModuleAdapter<?> moduleAdapter = loader.getModuleAdapter((Class<?>) moduleOrClass);
-          result.add(new ModuleWithAdapter(moduleAdapter, moduleAdapter.newModule()));
-        }
-      } else {
-        if (visitedClasses.add(moduleOrClass.getClass())) {
-          ModuleAdapter<?> moduleAdapter = loader.getModuleAdapter(moduleOrClass.getClass());
-          result.add(new ModuleWithAdapter(moduleAdapter, moduleOrClass));
-        }
-      }
-    }
-    int dedupedSeedModuleCount = result.size();
-    for (int i = 0; i < dedupedSeedModuleCount; i++) {
-      ModuleAdapter<?> seedAdapter = result.get(i).getModuleAdapter();
-      collectIncludedModulesRecursively(loader, seedAdapter, result, visitedClasses);
-    }
-    return result;
-  }
-
-  /**
-   * Wrapper around a module adapter and an instance of the corresponding module.
-   */
-  public static class ModuleWithAdapter {
-    private final ModuleAdapter<?> moduleAdapter;
-    private final Object module;
-
-    ModuleWithAdapter(ModuleAdapter<?> moduleAdapter, Object module) {
-      this.moduleAdapter = moduleAdapter;
-      this.module = module;
-    }
-
-    public ModuleAdapter<?> getModuleAdapter() {
-      return moduleAdapter;
-    }
-
-    public Object getModule() {
-      return module;
-    }
-  }
-
-  /**
-   * Fills {@code result} with the module adapters for the includes of {@code
-   * adapter}, and their includes recursively.
-   */
-  private static void collectIncludedModulesRecursively(Loader plugin, ModuleAdapter<?> adapter,
-      List<ModuleWithAdapter> result, HashSet<Class<?>> visitedClasses) {
-    for (Class<?> include : adapter.includes) {
-      if (!visitedClasses.contains(include)) {
-        ModuleAdapter<?> includedModuleAdapter = plugin.getModuleAdapter(include);
-        result.add(new ModuleWithAdapter(includedModuleAdapter, includedModuleAdapter.newModule()));
-        visitedClasses.add(include);
-        collectIncludedModulesRecursively(plugin, includedModuleAdapter, result, visitedClasses);
-      }
-    }
-  }
-
-}
diff --git a/core/src/main/java/dagger/internal/ProblemDetector.java b/core/src/main/java/dagger/internal/ProblemDetector.java
deleted file mode 100644
index 8df091558..000000000
--- a/core/src/main/java/dagger/internal/ProblemDetector.java
+++ /dev/null
@@ -1,105 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal;
-
-import java.util.AbstractSet;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Iterator;
-import java.util.List;
-
-/**
- * Detects problems like cyclic dependencies.
- */
-public final class ProblemDetector {
-  public void detectCircularDependencies(Collection<Binding<?>> bindings) {
-    detectCircularDependencies(bindings, new ArrayList<Binding<?>>());
-  }
-
-  public void detectUnusedBinding(Collection<Binding<?>> bindings) {
-    List<Binding> unusedBindings = new ArrayList<Binding>();
-    for (Binding<?> binding : bindings) {
-      if (!binding.library() && !binding.dependedOn()) {
-        unusedBindings.add(binding);
-      }
-    }
-    if (!unusedBindings.isEmpty()) {
-      StringBuilder builder = new StringBuilder();
-      builder.append("You have these unused @Provider methods:");
-      for (int i = 0; i < unusedBindings.size(); i++) {
-        builder.append("\n    ").append(i + 1).append(". ")
-            .append(unusedBindings.get(i).requiredBy);
-      }
-      builder.append("\n    Set library=true in your module to disable this check.");
-      throw new IllegalStateException(builder.toString());
-    }
-  }
-
-  private static void detectCircularDependencies(Collection<Binding<?>> bindings,
-      List<Binding<?>> path) {
-    for (Binding<?> binding : bindings) {
-      if (binding.isCycleFree()) {
-        continue;
-      }
-
-      if (binding.isVisiting()) {
-        int index = path.indexOf(binding);
-        StringBuilder message = new StringBuilder()
-            .append("Dependency cycle:");
-        for (int i = index; i < path.size(); i++) {
-          message.append("\n    ").append(i - index).append(". ")
-              .append(path.get(i).provideKey).append(" bound by ").append(path.get(i));
-        }
-        message.append("\n    ").append(0).append(". ").append(binding.provideKey);
-        throw new IllegalStateException(message.toString());
-      }
-
-      binding.setVisiting(true);
-      path.add(binding);
-      try {
-        ArraySet<Binding<?>> dependencies = new ArraySet<Binding<?>>();
-        binding.getDependencies(dependencies, dependencies);
-        detectCircularDependencies(dependencies, path);
-        binding.setCycleFree(true);
-      } finally {
-        path.remove(path.size() - 1);
-        binding.setVisiting(false);
-      }
-    }
-  }
-
-  public void detectProblems(Collection<Binding<?>> values) {
-    detectCircularDependencies(values);
-    detectUnusedBinding(values);
-  }
-
-  static class ArraySet<T> extends AbstractSet<T> {
-    private final ArrayList<T> list = new ArrayList<T>();
-
-    @Override public boolean add(T t) {
-      list.add(t);
-      return true;
-    }
-
-    @Override public Iterator<T> iterator() {
-      return list.iterator();
-    }
-
-    @Override public int size() {
-      throw new UnsupportedOperationException();
-    }
-  }
-}
diff --git a/core/src/main/java/dagger/internal/ProvidesBinding.java b/core/src/main/java/dagger/internal/ProvidesBinding.java
deleted file mode 100644
index 43b3ac2c6..000000000
--- a/core/src/main/java/dagger/internal/ProvidesBinding.java
+++ /dev/null
@@ -1,52 +0,0 @@
-/*
- * Copyright (C) 2013 Google, Inc.
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal;
-
-/**
- * A {@code Binding<T>} which delegates to a module method.
- */
-public abstract class ProvidesBinding<T> extends Binding<T> {
-  protected final String moduleClass;
-
-  protected final String methodName;
-
-  /**
-   * Creates a new {@code ProvidesBinding} with the given "provides" key, a flag as to whether
-   * this binding should be scoped, and the requiredBy object for traceability.
-   */
-  public ProvidesBinding(String key, boolean singleton, String moduleClass, String methodName) {
-    // Set requiredBy as fullMethodName to preserve older debugging meaning.
-    // Use an explicitly sized StringBuilder as this code is invoked often
-    super(key, null, singleton,
-        new StringBuilder(moduleClass.length() + methodName.length() + 3)
-            .append(moduleClass).append('.').append(methodName).append("()").toString());
-    this.moduleClass = moduleClass;
-    this.methodName = methodName;
-  }
-
-  /**
-   * A provides binding is responsible for implementing storage of the module instance, and
-   * delegation to that module instance's method.
-   */
-  @Override
-  public abstract T get();
-
-  @Override public String toString() {
-    return getClass().getName() + "[key=" + provideKey
-        + " method=" + moduleClass + "." + methodName + "()" + "]";
-  }
-}
diff --git a/core/src/main/java/dagger/internal/ReflectiveLoader.java b/core/src/main/java/dagger/internal/ReflectiveLoader.java
deleted file mode 100644
index 4d20522a0..000000000
--- a/core/src/main/java/dagger/internal/ReflectiveLoader.java
+++ /dev/null
@@ -1,58 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- * Copyright (C) 2013 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal;
-
-import dagger.internal.loaders.ReflectiveAtInjectBinding;
-import dagger.internal.loaders.ReflectiveModuleAdapter;
-import dagger.internal.loaders.ReflectiveStaticInjection;
-
-/**
- * Handles loading/finding of modules, injection bindings, and static injections by use of a
- * reflective bindings.
- *
- * @deprecated Provided only to work around proguard obfuscation - obsolete in 2.0.
- */
-@Deprecated
-public final class ReflectiveLoader extends Loader {
-  /**
-   * Obtains a {@link ReflectiveModuleAdapter} for {@code module}.
-   */
-  @SuppressWarnings("unchecked") // cache ensures types match
-  @Override public <T> ModuleAdapter<T> getModuleAdapter(Class<T> type) {
-    return ReflectiveModuleAdapter.create(type);
-  }
-
-  /**
-   * Obtains a {@link ReflectiveAtInjectBinding} for a given key.
-   */
-  @Override public Binding<?> getAtInjectBinding(
-      String key, String className, ClassLoader classLoader, boolean mustHaveInjections) {
-    Class<?> type = loadClass(classLoader, className);
-    if (type.equals(Void.class)) {
-      throw new IllegalStateException(
-          String.format("Could not load class %s needed for binding %s", className, key));
-    }
-    if (type.isInterface()) {
-      return null; // Short-circuit since we can't build reflective bindings for interfaces.
-    }
-    return ReflectiveAtInjectBinding.createFactory(type).create(mustHaveInjections);
-  }
-
-  @Override public StaticInjection getStaticInjection(Class<?> injectedClass) {
-    return ReflectiveStaticInjection.create(injectedClass);
-  }
-}
diff --git a/core/src/main/java/dagger/internal/SetBinding.java b/core/src/main/java/dagger/internal/SetBinding.java
deleted file mode 100644
index af3729061..000000000
--- a/core/src/main/java/dagger/internal/SetBinding.java
+++ /dev/null
@@ -1,145 +0,0 @@
-/*
- * Copyright (C) 2012 Google, Inc.
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal;
-
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.LinkedHashSet;
-import java.util.List;
-import java.util.Set;
-
-/**
- * A {@code Binding<T>} which contains contributors (other bindings marked with
- * {@code @Provides} {@code @OneOf}), to which it delegates provision
- * requests on an as-needed basis.
- */
-public final class SetBinding<T> extends Binding<Set<T>> {
-
-  public static <T> void add(BindingsGroup bindings, String setKey, Binding<?> binding) {
-    prepareSetBinding(bindings, setKey, binding).contributors.add(Linker.scope(binding));
-  }
-
-  @SuppressWarnings("unchecked")
-  private static <T> SetBinding<T> prepareSetBinding(
-      BindingsGroup bindings, String setKey, Binding<?> binding) {
-    Binding<?> previous = bindings.get(setKey);
-    SetBinding<T> setBinding;
-    if (previous instanceof SetBinding) {
-      setBinding = (SetBinding<T>) previous;
-      setBinding.setLibrary(setBinding.library() && binding.library());
-      return setBinding;
-    } else if (previous != null) {
-      throw new IllegalArgumentException("Duplicate:\n    " + previous + "\n    " + binding);
-    } else {
-      setBinding = new SetBinding<T>(setKey, binding.requiredBy);
-      setBinding.setLibrary(binding.library());
-      bindings.contributeSetBinding(setKey, setBinding);
-      return (SetBinding<T>) bindings.get(setKey); // BindingMap.put() copies SetBindings.
-    }
-  }
-
-  /**
-   * A {@link SetBinding} with whose contributing bindings this set-binding provides a union
-   * view.
-   */
-  private final SetBinding<T> parent;
-
-  /**
-   * A {@link Set} of {@link Binding} instances which contribute values to the injected set.
-   */
-  private final List<Binding<?>> contributors;
-
-  /**
-   * Creates a new {@code SetBinding} with the given "provides" key, and the requiredBy object
-   * for traceability.
-   */
-  public SetBinding(String key, Object requiredBy) {
-    super(key, null, false, requiredBy);
-    parent = null;
-    contributors = new ArrayList<Binding<?>>();
-  }
-
-  /**
-   * Creates a new {@code SetBinding} with all of the contributing bindings of the provided
-   * original {@code SetBinding}.
-   */
-  public SetBinding(SetBinding<T> original) {
-    super(original.provideKey, null, false, original.requiredBy);
-    parent = original;
-    this.setLibrary(original.library());
-    this.setDependedOn(original.dependedOn());
-    contributors = new ArrayList<Binding<?>>();
-  }
-
-  @Override public void attach(Linker linker) {
-    for (Binding<?> contributor : contributors) {
-      contributor.attach(linker);
-    }
-  }
-
-  public int size() {
-    int size = 0;
-    for (SetBinding<T> binding = this; binding != null; binding = binding.parent) {
-      size += binding.contributors.size();
-    }
-    return size;
-  }
-
-  @SuppressWarnings("unchecked") // Only Binding<T> and Set<T> are added to contributors.
-  @Override public Set<T> get() {
-    List<T> result = new ArrayList<T>();
-    for (SetBinding<T> setBinding = this; setBinding != null; setBinding = setBinding.parent) {
-      for (int i = 0, size = setBinding.contributors.size(); i < size; i++) {
-        Binding<?> contributor = setBinding.contributors.get(i);
-        Object contribution = contributor.get(); // Let runtime exceptions through.
-        if (contributor.provideKey.equals(provideKey)) {
-          result.addAll((Set<T>) contribution);
-        } else {
-          result.add((T) contribution);
-        }
-      }
-    }
-    return Collections.unmodifiableSet(new LinkedHashSet<T>(result));
-  }
-
-  @Override public void getDependencies(
-      Set<Binding<?>> getBindings, Set<Binding<?>> injectMembersBindings) {
-    for (SetBinding<T> binding = this; binding != null; binding = binding.parent) {
-      getBindings.addAll(binding.contributors);
-    }
-  }
-
-  @Override public void injectMembers(Set<T> t) {
-    throw new UnsupportedOperationException("Cannot inject members on a contributed Set<T>.");
-  }
-
-  @Override public String toString() {
-    boolean first = true;
-    StringBuilder builder = new StringBuilder("SetBinding[");
-    for (SetBinding<T> setBinding = this; setBinding != null; setBinding = setBinding.parent) {
-      for (int i = 0, size = setBinding.contributors.size(); i < size; i++) {
-        if (!first) {
-          builder.append(",");
-        }
-        builder.append(setBinding.contributors.get(i));
-        first = false;
-      }
-    }
-    builder.append("]");
-    return builder.toString();
-  }
-}
diff --git a/core/src/main/java/dagger/internal/StaticInjection.java b/core/src/main/java/dagger/internal/StaticInjection.java
deleted file mode 100644
index d9399a37a..000000000
--- a/core/src/main/java/dagger/internal/StaticInjection.java
+++ /dev/null
@@ -1,28 +0,0 @@
-/*
- * Copyright (C) 2012 Square Inc.
- * Copyright (C) 2012 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal;
-
-/**
- * Injects the static fields of a class.
- */
-public abstract class StaticInjection {
-
-  public abstract void attach(Linker linker);
-
-  public abstract void inject();
-
-}
diff --git a/core/src/main/java/dagger/internal/ThrowingErrorHandler.java b/core/src/main/java/dagger/internal/ThrowingErrorHandler.java
deleted file mode 100644
index d17ae7a92..000000000
--- a/core/src/main/java/dagger/internal/ThrowingErrorHandler.java
+++ /dev/null
@@ -1,36 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal;
-
-import java.util.List;
-
-/**
- * Handles errors by throwing an exception containing all the available errors.
- */
-public final class ThrowingErrorHandler implements Linker.ErrorHandler {
-
-  @Override public void handleErrors(List<String> errors) {
-    if (errors.isEmpty()) {
-      return;
-    }
-    StringBuilder message = new StringBuilder();
-    message.append("Errors creating object graph:");
-    for (String error : errors) {
-      message.append("\n  ").append(error);
-    }
-    throw new IllegalStateException(message.toString());
-  }
-}
diff --git a/core/src/main/java/dagger/internal/loaders/GeneratedAdapters.java b/core/src/main/java/dagger/internal/loaders/GeneratedAdapters.java
deleted file mode 100644
index 3c126898b..000000000
--- a/core/src/main/java/dagger/internal/loaders/GeneratedAdapters.java
+++ /dev/null
@@ -1,29 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- * Copyright (C) 2013 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.loaders;
-
-/**
- * A single point for API used in common by Adapters and Adapter generators
- */
-public final class GeneratedAdapters {
-  private static final String SEPARATOR = "$$";
-  public static final String INJECT_ADAPTER_SUFFIX = SEPARATOR + "InjectAdapter";
-  public static final String MODULE_ADAPTER_SUFFIX = SEPARATOR + "ModuleAdapter";
-  public static final String STATIC_INJECTION_SUFFIX = SEPARATOR + "StaticInjection";
-
-  private GeneratedAdapters() { }
-}
diff --git a/core/src/main/java/dagger/internal/loaders/ReflectiveAtInjectBinding.java b/core/src/main/java/dagger/internal/loaders/ReflectiveAtInjectBinding.java
deleted file mode 100644
index d464ec50e..000000000
--- a/core/src/main/java/dagger/internal/loaders/ReflectiveAtInjectBinding.java
+++ /dev/null
@@ -1,270 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.loaders;
-
-import dagger.internal.Binding;
-import dagger.internal.Keys;
-import dagger.internal.Linker;
-import java.lang.annotation.Annotation;
-import java.lang.reflect.Constructor;
-import java.lang.reflect.Field;
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Modifier;
-import java.lang.reflect.Type;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.List;
-import java.util.Set;
-import javax.inject.Inject;
-import javax.inject.Singleton;
-
-/**
- * Injects the {@code @Inject}-annotated fields and constructors of a class
- * using reflection.
- */
-public final class ReflectiveAtInjectBinding<T> extends Binding<T> {
-  private final Field[] fields;
-  private final ClassLoader loader;
-  private final Constructor<T> constructor;
-  private final Class<?> supertype;
-  private final String[] keys;
-  private final Binding<?>[] fieldBindings;
-  private final Binding<?>[] parameterBindings;
-  private Binding<? super T> supertypeBinding;
-
-  /**
-   * @param keys keys for the fields, constructor parameters and supertype in
-   *     that order. These are precomputed to minimize reflection when {@code
-   *     attach} is called multiple times.
-   * @param constructor the injectable constructor, or null if this binding
-   *     supports members injection only.
-   * @param supertype the injectable supertype, or null if the supertype is a
-   */
-  private ReflectiveAtInjectBinding(String provideKey, String membersKey, boolean singleton,
-      Class<?> type, Field[] fields, Constructor<T> constructor, int parameterCount,
-      Class<?> supertype, String[] keys) {
-    super(provideKey, membersKey, singleton, type);
-    this.constructor = constructor;
-    this.fields = fields;
-    this.supertype = supertype;
-    this.keys = keys;
-    this.parameterBindings = new Binding<?>[parameterCount];
-    this.fieldBindings = new Binding<?>[fields.length];
-    this.loader = type.getClassLoader();
-  }
-
-  @SuppressWarnings("unchecked") // We're careful to make keys and bindings match up.
-  @Override public void attach(Linker linker) {
-    int k = 0;
-    for (int i = 0; i < fields.length; i++) {
-      if (fieldBindings[i] == null) {
-        fieldBindings[i] = linker.requestBinding(keys[k], fields[i], loader);
-      }
-      k++;
-    }
-    if (constructor != null) {
-      for (int i = 0; i < parameterBindings.length; i++) {
-        if (parameterBindings[i] == null) {
-          parameterBindings[i] = linker.requestBinding(keys[k], constructor, loader);
-        }
-        k++;
-      }
-    }
-    if (supertype != null && supertypeBinding == null) {
-      supertypeBinding =
-          (Binding<? super T>) linker.requestBinding(keys[k], membersKey, loader, false, true);
-    }
-  }
-
-  @Override public T get() {
-    if (constructor == null) {
-      throw new UnsupportedOperationException();
-    }
-    Object[] args = new Object[parameterBindings.length];
-    for (int i = 0; i < parameterBindings.length; i++) {
-      args[i] = parameterBindings[i].get();
-    }
-    T result;
-    try {
-      result = constructor.newInstance(args);
-    } catch (InvocationTargetException e) {
-      Throwable cause = e.getCause();
-      throw cause instanceof RuntimeException
-          ? (RuntimeException) cause
-          : new RuntimeException(cause);
-    } catch (IllegalAccessException e) {
-      throw new AssertionError(e);
-    } catch (InstantiationException e) {
-      throw new RuntimeException(e);
-    }
-    injectMembers(result);
-    return result;
-  }
-
-  @Override public void injectMembers(T t) {
-    try {
-      for (int i = 0; i < fields.length; i++) {
-        fields[i].set(t, fieldBindings[i].get());
-      }
-      if (supertypeBinding != null) {
-        supertypeBinding.injectMembers(t);
-      }
-    } catch (IllegalAccessException e) {
-      throw new AssertionError(e);
-    }
-  }
-
-  @Override public void getDependencies(Set<Binding<?>> get, Set<Binding<?>> injectMembers) {
-    if (parameterBindings != null) {
-      Collections.addAll(get, parameterBindings);
-    }
-    Collections.addAll(injectMembers, fieldBindings);
-    if (supertypeBinding != null) {
-      injectMembers.add(supertypeBinding);
-    }
-  }
-
-  @Override public String toString() {
-    return provideKey != null ? provideKey : membersKey;
-  }
-
-  /**
-   * A factory for creating {@code ReflectiveAtInjectBinding<T>}.
-   */
-  public static class Factory<T> {
-    private final String provideKey;
-    private final String membersKey;
-    private final boolean singleton;
-    private final Class<?> type;
-    private final Field[] fields;
-    private final Constructor<T> constructor;
-    private final int parameterCount;
-    private final Class<?> supertype;
-    private final String[] keys;
-
-    private Factory(String provideKey, String membersKey, boolean singleton,
-        Class<?> type, Field[] fields, Constructor<T> constructor, int parameterCount,
-        Class<?> supertype, String[] keys) {
-      this.provideKey = provideKey;
-      this.membersKey = membersKey;
-      this.singleton = singleton;
-      this.type = type;
-      this.fields = fields;
-      this.constructor = constructor;
-      this.parameterCount = parameterCount;
-      this.supertype = supertype;
-      this.keys = keys;
-    }
-
-    public ReflectiveAtInjectBinding<T> create(boolean mustHaveInjections) {
-      if (mustHaveInjections && constructor == null && fields.length == 0) {
-        throw new InvalidBindingException(type.getName(),
-            "has no injectable members. Do you want to add an injectable constructor?");
-      }
-      return new ReflectiveAtInjectBinding<T>(provideKey, membersKey, singleton,
-          type, fields, constructor, parameterCount,
-          supertype, keys);
-    }
-  }
-
-  public static <T> Factory<T> createFactory(Class<T> type) {
-    boolean singleton = type.isAnnotationPresent(Singleton.class);
-    List<String> keys = new ArrayList<String>();
-
-    // Lookup the injectable fields and their corresponding keys.
-    List<Field> injectedFields = new ArrayList<Field>();
-    for (Class<?> c = type; c != Object.class; c = c.getSuperclass()) {
-      for (Field field : c.getDeclaredFields()) {
-        if (!field.isAnnotationPresent(Inject.class) || Modifier.isStatic(field.getModifiers())) {
-          continue;
-        }
-        if ((field.getModifiers() & Modifier.PRIVATE) != 0) {
-          throw new IllegalStateException("Can't inject private field: " + field);
-        }
-        field.setAccessible(true);
-        injectedFields.add(field);
-        keys.add(Keys.get(field.getGenericType(), field.getAnnotations(), field));
-      }
-    }
-
-    // Look up @Inject-annotated constructors. If there's no @Inject-annotated
-    // constructor, use a default public constructor if the class has other
-    // injections. Otherwise treat the class as non-injectable.
-    Constructor<T> injectedConstructor = null;
-    for (Constructor<T> constructor : getConstructorsForType(type)) {
-      if (!constructor.isAnnotationPresent(Inject.class)) {
-        continue;
-      }
-      if (injectedConstructor != null) {
-        throw new InvalidBindingException(type.getName(), "has too many injectable constructors");
-      }
-      injectedConstructor = constructor;
-    }
-    if (injectedConstructor == null) {
-      if (!injectedFields.isEmpty()) {
-        try {
-          injectedConstructor = type.getDeclaredConstructor();
-        } catch (NoSuchMethodException ignored) {
-        }
-      }
-    }
-
-    int parameterCount;
-    String provideKey;
-    if (injectedConstructor != null) {
-      if ((injectedConstructor.getModifiers() & Modifier.PRIVATE) != 0) {
-        throw new IllegalStateException("Can't inject private constructor: " + injectedConstructor);
-      }
-
-      provideKey = Keys.get(type);
-      injectedConstructor.setAccessible(true);
-      Type[] types = injectedConstructor.getGenericParameterTypes();
-      parameterCount = types.length;
-      if (parameterCount != 0) {
-        Annotation[][] annotations = injectedConstructor.getParameterAnnotations();
-        for (int p = 0; p < types.length; p++) {
-          keys.add(Keys.get(types[p], annotations[p], injectedConstructor));
-        }
-      }
-    } else {
-      provideKey = null;
-      parameterCount = 0;
-      if (singleton) {
-        throw new IllegalArgumentException(
-            "No injectable constructor on @Singleton " + type.getName());
-      }
-    }
-
-    Class<? super T> supertype = type.getSuperclass();
-    if (supertype != null) {
-      if (Keys.isPlatformType(supertype.getName())) {
-        supertype = null;
-      } else {
-        keys.add(Keys.getMembersKey(supertype));
-      }
-    }
-
-    String membersKey = Keys.getMembersKey(type);
-    return new Factory<T>(provideKey, membersKey, singleton, type,
-        injectedFields.toArray(new Field[injectedFields.size()]), injectedConstructor,
-        parameterCount, supertype, keys.toArray(new String[keys.size()]));
-  }
-
-  @SuppressWarnings("unchecked") // Class.getDeclaredConstructors is an unsafe API.
-  private static <T> Constructor<T>[] getConstructorsForType(Class<T> type) {
-    return (Constructor<T>[]) type.getDeclaredConstructors();
-  }
-}
diff --git a/core/src/main/java/dagger/internal/loaders/ReflectiveModuleAdapter.java b/core/src/main/java/dagger/internal/loaders/ReflectiveModuleAdapter.java
deleted file mode 100644
index a37ebb791..000000000
--- a/core/src/main/java/dagger/internal/loaders/ReflectiveModuleAdapter.java
+++ /dev/null
@@ -1,216 +0,0 @@
-package dagger.internal.loaders;
-
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import dagger.Lazy;
-import dagger.Module;
-import dagger.Provides;
-import dagger.internal.Binding;
-import dagger.internal.BindingsGroup;
-import dagger.internal.Keys;
-import dagger.internal.Linker;
-import dagger.internal.ModuleAdapter;
-import dagger.internal.ProvidesBinding;
-import dagger.internal.SetBinding;
-import java.lang.annotation.Annotation;
-import java.lang.reflect.Constructor;
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
-import java.lang.reflect.ParameterizedType;
-import java.lang.reflect.Type;
-import java.util.Set;
-import javax.inject.Provider;
-import javax.inject.Singleton;
-
-/**
- * @deprecated this is in place to temporarily support obfuscation needs and
- *     will not exist as of Dagger 2.0
- */
-@Deprecated
-public class ReflectiveModuleAdapter<M> extends ModuleAdapter<M> {
-  public ReflectiveModuleAdapter(Class<M> moduleClass, Module annotation) {
-    super(
-        moduleClass,
-        injectableTypesToKeys(annotation.injects()),
-        annotation.staticInjections(),
-        annotation.overrides(),
-        annotation.includes(),
-        annotation.complete(),
-        annotation.library());
-  }
-
-  private static String[] injectableTypesToKeys(Class<?>[] injectableTypes) {
-    String[] result = new String[injectableTypes.length];
-    for (int i = 0; i < injectableTypes.length; i++) {
-      Class<?> injectableType = injectableTypes[i];
-      result[i] = injectableType.isInterface()
-          ? Keys.get(injectableType)
-          : Keys.getMembersKey(injectableType);
-    }
-    return result;
-  }
-
-  @Override public void getBindings(BindingsGroup bindings, M module) {
-    for (Class<?> c = moduleClass; !c.equals(Object.class); c = c.getSuperclass()) {
-      for (Method method : c.getDeclaredMethods()) {
-        Provides provides = method.getAnnotation(Provides.class);
-        if (provides != null) {
-          Type genericReturnType = method.getGenericReturnType();
-
-          Type typeToCheck = genericReturnType;
-          if (genericReturnType instanceof ParameterizedType) {
-            typeToCheck = ((ParameterizedType) genericReturnType).getRawType();
-          }
-          if (Provider.class.equals(typeToCheck)) {
-            throw new IllegalStateException("@Provides method must not return Provider directly: "
-                + c.getName()
-                + "."
-                + method.getName());
-          }
-          if (Lazy.class.equals(typeToCheck)) {
-            throw new IllegalStateException("@Provides method must not return Lazy directly: "
-                + c.getName()
-                + "."
-                + method.getName());
-          }
-
-          String key = Keys.get(genericReturnType, method.getAnnotations(), method);
-          switch (provides.type()) {
-            case UNIQUE:
-              handleBindings(bindings, module, method, key, library);
-              break;
-            case SET:
-              String setKey = Keys.getSetKey(method.getGenericReturnType(),
-                  method.getAnnotations(), method);
-              handleSetBindings(bindings, module, method, setKey, key, library);
-              break;
-            case SET_VALUES:
-              handleSetBindings(bindings, module, method, key, key, library);
-              break;
-            default:
-              throw new AssertionError("Unknown @Provides type " + provides.type());
-          }
-        }
-      }
-    }
-  }
-
-  private void handleBindings(BindingsGroup bindings, M module, Method method, String key,
-      boolean library) {
-    bindings.contributeProvidesBinding(key,
-        new ReflectiveProvidesBinding<M>(method, key, moduleClass.getName(), module, library));
-  }
-
-  private void handleSetBindings(BindingsGroup bindings, M module, Method method,
-      String setKey, String providerKey, boolean library) {
-    SetBinding.<M>add(bindings, setKey,
-        new ReflectiveProvidesBinding<M>(
-            method, providerKey, moduleClass.getName(), module, library));
-  }
-
-  @Override public M newModule() {
-    try {
-      Constructor<?> constructor = moduleClass.getDeclaredConstructor();
-      constructor.setAccessible(true);
-      return (M)constructor.newInstance();
-    } catch (InvocationTargetException e) {
-      throw new IllegalArgumentException(e.getCause());
-    } catch (NoSuchMethodException e) {
-      throw new IllegalArgumentException("Could not construct " + moduleClass.getName()
-          + " as it lacks an accessible no-args constructor. This module must be passed"
-          + " in as an instance, or an accessible no-args constructor must be added.", e);
-    } catch (InstantiationException e) {
-      throw new IllegalArgumentException("Failed to construct " + moduleClass.getName(), e);
-    } catch (IllegalAccessException e) {
-      throw new AssertionError();
-    }
-  }
-
-  @Override public String toString() {
-    return "ReflectiveModuleAdapter[" + this.moduleClass.getName() + "]";
-  }
-
-  /**
-   * Creates a ReflectiveModuleAdapter or throws an {@code IllegalArgumentException}.
-   */
-  public static <M> ModuleAdapter<M> create(Class<M> moduleClass) {
-    Module annotation = moduleClass.getAnnotation(Module.class);
-    if (annotation == null) {
-      throw new IllegalArgumentException("No @Module on " + moduleClass.getName());
-    }
-    if (!moduleClass.getSuperclass().equals(Object.class)) {
-      throw new IllegalArgumentException(
-          "Modules must not extend from other classes: " + moduleClass.getName());
-    }
-    return new ReflectiveModuleAdapter<M>(moduleClass, annotation);
-  }
-
-  /**
-   * Invokes a method to provide a value. The method's parameters are injected.
-   */
-  private static final class ReflectiveProvidesBinding<T> extends ProvidesBinding<T> {
-    private Binding<?>[] parameters;
-    private final Method method;
-    private final Object instance;
-
-    public ReflectiveProvidesBinding(Method method, String key, String moduleClass,
-        Object instance, boolean library) {
-      super(key, method.isAnnotationPresent(Singleton.class), moduleClass, method.getName());
-      this.method = method;
-      this.instance = instance;
-      method.setAccessible(true);
-      setLibrary(library);
-    }
-
-    @Override public void attach(Linker linker) {
-      Type[] types = method.getGenericParameterTypes();
-      Annotation[][] annotations = method.getParameterAnnotations();
-      parameters = new Binding[types.length];
-      for (int i = 0; i < parameters.length; i++) {
-        String key = Keys.get(types[i], annotations[i], method + " parameter " + i);
-        parameters[i] = linker.requestBinding(key, method, instance.getClass().getClassLoader());
-      }
-    }
-
-    @Override public T get() {
-      Object[] args = new Object[parameters.length];
-      for (int i = 0; i < parameters.length; i++) {
-        args[i] = parameters[i].get();
-      }
-      try {
-        return (T) method.invoke(instance, args);
-      } catch (InvocationTargetException e) {
-        Throwable cause = e.getCause();
-        throw cause instanceof RuntimeException
-            ? (RuntimeException) cause
-            : new RuntimeException(cause);
-      } catch (IllegalAccessException e) {
-        throw new RuntimeException(e);
-      }
-    }
-
-    @Override public void getDependencies(Set<Binding<?>> get, Set<Binding<?>> injectMembers) {
-      for (Binding<?> binding : parameters) {
-        get.add(binding);
-      }
-    }
-
-    @Override public void injectMembers(T t) {
-      throw new AssertionError("Provides method bindings are not MembersInjectors");
-    }
-  }
-}
diff --git a/core/src/main/java/dagger/internal/loaders/ReflectiveStaticInjection.java b/core/src/main/java/dagger/internal/loaders/ReflectiveStaticInjection.java
deleted file mode 100644
index 1150eed5d..000000000
--- a/core/src/main/java/dagger/internal/loaders/ReflectiveStaticInjection.java
+++ /dev/null
@@ -1,74 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.loaders;
-
-import dagger.internal.Binding;
-import dagger.internal.Keys;
-import dagger.internal.Linker;
-import dagger.internal.StaticInjection;
-import java.lang.reflect.Field;
-import java.lang.reflect.Modifier;
-import java.util.ArrayList;
-import java.util.List;
-import javax.inject.Inject;
-
-/**
- * Uses reflection to inject the static fields of a class.
- */
-public final class ReflectiveStaticInjection extends StaticInjection {
-  private final ClassLoader loader;
-  private final Field[] fields;
-  private Binding<?>[] bindings;
-
-  private ReflectiveStaticInjection(ClassLoader loader, Field[] fields) {
-    this.fields = fields;
-    this.loader = loader;
-  }
-
-  @Override public void attach(Linker linker) {
-    bindings = new Binding<?>[fields.length];
-    for (int i = 0; i < fields.length; i++) {
-      Field field = fields[i];
-      String key = Keys.get(field.getGenericType(), field.getAnnotations(), field);
-      bindings[i] = linker.requestBinding(key, field, loader);
-    }
-  }
-
-  @Override public void inject() {
-    try {
-      for (int f = 0; f < fields.length; f++) {
-        fields[f].set(null, bindings[f].get());
-      }
-    } catch (IllegalAccessException e) {
-      throw new AssertionError(e);
-    }
-  }
-
-  public static StaticInjection create(Class<?> injectedClass) {
-    List<Field> fields = new ArrayList<Field>();
-    for (Field field : injectedClass.getDeclaredFields()) {
-      if (Modifier.isStatic(field.getModifiers()) && field.isAnnotationPresent(Inject.class)) {
-        field.setAccessible(true);
-        fields.add(field);
-      }
-    }
-    if (fields.isEmpty()) {
-      throw new IllegalArgumentException("No static injections: " + injectedClass.getName());
-    }
-    return new ReflectiveStaticInjection(injectedClass.getClassLoader(),
-        fields.toArray(new Field[fields.size()]));
-  }
-}
\ No newline at end of file
diff --git a/core/src/test/java/dagger/ExtensionTest.java b/core/src/test/java/dagger/ExtensionTest.java
deleted file mode 100644
index 06f9b865e..000000000
--- a/core/src/test/java/dagger/ExtensionTest.java
+++ /dev/null
@@ -1,113 +0,0 @@
-/*
- * Copyright (C) 2012 Google Inc.
- * Copyright (C) 2012 Square Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger;
-
-import dagger.internal.TestingLoader;
-import java.util.Arrays;
-import javax.inject.Inject;
-import javax.inject.Singleton;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-import static org.fest.assertions.Assertions.assertThat;
-import static org.junit.Assert.assertNotNull;
-
-@RunWith(JUnit4.class)
-public final class ExtensionTest {
-  @Singleton
-  static class A {
-    @Inject A() {}
-  }
-
-  static class B {
-    @Inject A a;
-  }
-
-  @Singleton
-  static class C {
-    @Inject A a;
-    @Inject B b;
-  }
-
-  static class D {
-    @Inject A a;
-    @Inject B b;
-    @Inject C c;
-  }
-
-  @Module(injects = { A.class, B.class }) static class RootModule { }
-
-  @Module(addsTo = RootModule.class, injects = { C.class, D.class })
-  static class ExtensionModule { }
-
-  @Test public void basicExtension() {
-    assertNotNull(ObjectGraph.createWith(new TestingLoader(), new RootModule())
-        .plus(new ExtensionModule()));
-  }
-
-  @Test public void basicInjection() {
-    ObjectGraph root = ObjectGraph.createWith(new TestingLoader(), new RootModule());
-    assertThat(root.get(A.class)).isNotNull();
-    assertThat(root.get(A.class)).isSameAs(root.get(A.class)); // Present and Singleton.
-    assertThat(root.get(B.class)).isNotSameAs(root.get(B.class)); // Not singleton.
-    assertFailInjectNotRegistered(root, C.class); // Not declared in RootModule.
-    assertFailInjectNotRegistered(root, D.class); // Not declared in RootModule.
-
-    // Extension graph behaves as the root graph would for root-ish things.
-    ObjectGraph extension = root.plus(new ExtensionModule());
-    assertThat(root.get(A.class)).isSameAs(extension.get(A.class));
-    assertThat(root.get(B.class)).isNotSameAs(extension.get(B.class));
-    assertThat(root.get(B.class).a).isSameAs(extension.get(B.class).a);
-
-    assertThat(extension.get(C.class).a).isNotNull();
-    assertThat(extension.get(D.class).c).isNotNull();
-  }
-
-  @Test public void scopedGraphs() {
-    ObjectGraph app = ObjectGraph.createWith(new TestingLoader(), new RootModule());
-    assertThat(app.get(A.class)).isNotNull();
-    assertThat(app.get(A.class)).isSameAs(app.get(A.class));
-    assertThat(app.get(B.class)).isNotSameAs(app.get(B.class));
-    assertFailInjectNotRegistered(app, C.class);
-    assertFailInjectNotRegistered(app, D.class);
-
-    ObjectGraph request1 = app.plus(new ExtensionModule());
-    ObjectGraph request2 = app.plus(new ExtensionModule());
-    for (ObjectGraph request : Arrays.asList(request1, request2)) {
-      assertThat(request.get(A.class)).isNotNull();
-      assertThat(request.get(A.class)).isSameAs(request.get(A.class));
-      assertThat(request.get(B.class)).isNotSameAs(request.get(B.class));
-      assertThat(request.get(C.class)).isNotNull();
-      assertThat(request.get(C.class)).isSameAs(request.get(C.class));
-      assertThat(request.get(D.class)).isNotSameAs(request.get(D.class));
-    }
-
-    // Singletons are one-per-graph-instance where they are declared.
-    assertThat(request1.get(C.class)).isNotSameAs(request2.get(C.class));
-    // Singletons that come from common roots should be one-per-common-graph-instance.
-    assertThat(request1.get(C.class).a).isSameAs(request2.get(C.class).a);
-  }
-
-  private void assertFailInjectNotRegistered(ObjectGraph graph, Class<?> clazz) {
-    try {
-      assertThat(graph.get(clazz)).isNull();
-    } catch (IllegalArgumentException e) {
-      assertThat(e.getMessage()).contains("No inject");
-    }
-  }
-}
diff --git a/core/src/test/java/dagger/ExtensionWithSetBindingsTest.java b/core/src/test/java/dagger/ExtensionWithSetBindingsTest.java
deleted file mode 100644
index 2a629536c..000000000
--- a/core/src/test/java/dagger/ExtensionWithSetBindingsTest.java
+++ /dev/null
@@ -1,107 +0,0 @@
-/*
- * Copyright (C) 2013 Google Inc.
- * Copyright (C) 2013 Square Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger;
-
-import dagger.internal.TestingLoader;
-import java.util.Set;
-import java.util.concurrent.atomic.AtomicInteger;
-import javax.inject.Inject;
-import javax.inject.Singleton;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-import static dagger.Provides.Type.SET;
-import static org.fest.assertions.Assertions.assertThat;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-
-@RunWith(JUnit4.class)
-public final class ExtensionWithSetBindingsTest {
-  private static final AtomicInteger counter = new AtomicInteger(0);
-
-  @Singleton
-  static class RealSingleton {
-    @Inject Set<Integer> ints;
-  }
-
-  @Singleton
-  static class Main {
-    @Inject Set<Integer> ints;
-  }
-
-  @Module(injects = RealSingleton.class)
-  static class RootModule {
-    @Provides(type=SET) @Singleton Integer provideA() { return counter.getAndIncrement(); }
-    @Provides(type=SET) @Singleton Integer provideB() { return counter.getAndIncrement(); }
-  }
-
-  @Module(addsTo = RootModule.class, injects = Main.class )
-  static class ExtensionModule {
-    @Provides(type=SET) @Singleton Integer provideC() { return counter.getAndIncrement(); }
-    @Provides(type=SET) @Singleton Integer provideD() { return counter.getAndIncrement(); }
-  }
-
-  @Module
-  static class EmptyModule {
-  }
-
-  @Module(library = true)
-  static class DuplicateModule {
-    @Provides @Singleton String provideFoo() { return "foo"; }
-    @Provides @Singleton String provideBar() { return "bar"; }
-  }
-
-  @Test public void basicInjectionWithExtension() {
-    ObjectGraph root = ObjectGraph.createWith(new TestingLoader(), new RootModule());
-    RealSingleton rs = root.get(RealSingleton.class);
-    assertThat(rs.ints).containsOnly(0, 1);
-
-    ObjectGraph extension = root.plus(new ExtensionModule());
-    Main main = extension.get(Main.class);
-    assertThat(main.ints).containsOnly(0, 1, 2, 3);
-
-    // Second time around.
-    ObjectGraph extension2 = root.plus(new ExtensionModule());
-    Main main2 = extension2.get(Main.class);
-    assertThat(main2.ints).containsOnly(0, 1, 4, 5);
-  }
-
-  @Module(includes = ExtensionModule.class, overrides = true)
-  static class TestModule {
-    @Provides(type=SET) @Singleton Integer provide9999() { return 9999; }
-  }
-
-  @Test public void basicInjectionWithExtensionAndOverrides() {
-    try {
-      ObjectGraph.createWith(new TestingLoader(), new RootModule()).plus(new TestModule());
-      fail("Should throw exception.");
-    } catch (IllegalArgumentException e) {
-      assertEquals("TestModule: Module overrides cannot contribute set bindings.", e.getMessage());
-    }
-  }
-
-  @Test public void duplicateBindingsInSecondaryModule() {
-    try {
-      ObjectGraph.createWith(new TestingLoader(), new EmptyModule(), new DuplicateModule());
-      fail("Should throw exception.");
-    } catch (IllegalArgumentException e) {
-      assertTrue(e.getMessage().startsWith("DuplicateModule: Duplicate"));
-    }
-  }
-}
diff --git a/core/src/test/java/dagger/ExtensionWithStateTest.java b/core/src/test/java/dagger/ExtensionWithStateTest.java
deleted file mode 100644
index ff35e2a87..000000000
--- a/core/src/test/java/dagger/ExtensionWithStateTest.java
+++ /dev/null
@@ -1,61 +0,0 @@
-/*
- * Copyright (C) 2013 Google Inc.
- * Copyright (C) 2013 Square Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger;
-
-import dagger.internal.TestingLoader;
-import javax.inject.Inject;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-import static org.fest.assertions.Assertions.assertThat;
-
-@RunWith(JUnit4.class)
-public final class ExtensionWithStateTest {
-  static class A { }
-
-  static class B {
-    @Inject A a;
-  }
-
-  @Module(
-      injects = A.class, // for testing
-      complete = false
-  )
-  static class RootModule {
-    final A a;
-    RootModule(A a) {
-      this.a = a;
-    }
-    @Provides A provideA() { return a; }
-  }
-
-  @Module(addsTo = RootModule.class, injects = { B.class })
-  static class ExtensionModule { }
-
-  @Test public void basicInjectionWithExtension() {
-    A a = new A();
-    ObjectGraph root = ObjectGraph.createWith(new TestingLoader(), new RootModule(a));
-    assertThat(root.get(A.class)).isSameAs(a);
-
-    // Extension graph behaves as the root graph would for root-ish things.
-    ObjectGraph extension = root.plus(new ExtensionModule());
-    assertThat(extension.get(A.class)).isSameAs(a);
-    assertThat(extension.get(B.class).a).isSameAs(a);
-  }
-
-}
diff --git a/core/src/test/java/dagger/InjectStaticsTest.java b/core/src/test/java/dagger/InjectStaticsTest.java
deleted file mode 100644
index a19456b8d..000000000
--- a/core/src/test/java/dagger/InjectStaticsTest.java
+++ /dev/null
@@ -1,96 +0,0 @@
-/*
- * Copyright (C) 2012 Square Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger;
-
-import dagger.internal.TestingLoader;
-import javax.inject.Inject;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-import static org.fest.assertions.Assertions.assertThat;
-
-@RunWith(JUnit4.class)
-public final class InjectStaticsTest {
-  @Before public void setUp() {
-    InjectsOneField.staticField = null;
-    InjectsStaticAndNonStatic.staticField = null;
-  }
-
-  public static class InjectsOneField {
-    @Inject static String staticField;
-  }
-
-  public static class InjectsStaticAndNonStatic {
-    @Inject Integer nonStaticField;
-    @Inject static String staticField;
-  }
-
-  @Test public void injectStatics() {
-    @Module(staticInjections = InjectsOneField.class)
-    class TestModule {
-      @Provides String provideString() {
-        return "static";
-      }
-    }
-
-    ObjectGraph graph = ObjectGraph.createWith(new TestingLoader(),new TestModule());
-    assertThat(InjectsOneField.staticField).isNull();
-    graph.injectStatics();
-    assertThat(InjectsOneField.staticField).isEqualTo("static");
-  }
-
-  @Test public void instanceFieldsNotInjectedByInjectStatics() {
-    @Module(
-        staticInjections = InjectsStaticAndNonStatic.class,
-        injects = InjectsStaticAndNonStatic.class)
-    class TestModule {
-      @Provides String provideString() {
-        return "static";
-      }
-      @Provides Integer provideInteger() {
-        throw new AssertionError();
-      }
-    }
-
-    ObjectGraph graph = ObjectGraph.createWith(new TestingLoader(), new TestModule());
-    assertThat(InjectsStaticAndNonStatic.staticField).isNull();
-    graph.injectStatics();
-    assertThat(InjectsStaticAndNonStatic.staticField).isEqualTo("static");
-  }
-
-  @Test public void staticFieldsNotInjectedByInjectMembers() {
-    @Module(
-        staticInjections = InjectsStaticAndNonStatic.class,
-        injects = InjectsStaticAndNonStatic.class)
-    class TestModule {
-      @Provides String provideString() {
-        throw new AssertionError();
-      }
-      @Provides Integer provideInteger() {
-        return 5;
-      }
-    }
-
-    ObjectGraph graph = ObjectGraph.createWith(new TestingLoader(), new TestModule());
-    assertThat(InjectsStaticAndNonStatic.staticField).isNull();
-    InjectsStaticAndNonStatic object = new InjectsStaticAndNonStatic();
-    graph.inject(object);
-    assertThat(InjectsStaticAndNonStatic.staticField).isNull();
-    assertThat(object.nonStaticField).isEqualTo(5);
-  }
-}
diff --git a/core/src/test/java/dagger/InjectionOfLazyTest.java b/core/src/test/java/dagger/InjectionOfLazyTest.java
deleted file mode 100644
index 7156c968c..000000000
--- a/core/src/test/java/dagger/InjectionOfLazyTest.java
+++ /dev/null
@@ -1,133 +0,0 @@
-/*
- * Copyright (C) 2012 Google Inc.
- * Copyright (C) 2012 Square Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger;
-
-import dagger.internal.TestingLoader;
-import java.util.concurrent.atomic.AtomicInteger;
-import javax.inject.Inject;
-import javax.inject.Provider;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNull;
-
-/**
- * Tests of injection of Lazy<T> bindings.
- */
-@RunWith(JUnit4.class)
-public final class InjectionOfLazyTest {
-  @Test public void lazyValueCreation() {
-    final AtomicInteger counter = new AtomicInteger();
-    class TestEntryPoint {
-      @Inject Lazy<Integer> i;
-      @Inject Lazy<Integer> j;
-    }
-
-    @Module(injects = TestEntryPoint.class)
-    class TestModule {
-      @Provides Integer provideInteger() {
-        return counter.incrementAndGet();
-      }
-    }
-
-    TestEntryPoint ep = injectWithModule(new TestEntryPoint(), new TestModule());
-    assertEquals(0, counter.get());
-    assertEquals(1, ep.i.get().intValue());
-    assertEquals(1, counter.get());
-    assertEquals(2, ep.j.get().intValue());
-    assertEquals(1, ep.i.get().intValue());
-    assertEquals(2, counter.get());
-  }
-
-  @Test public void lazyNullCreation() {
-    final AtomicInteger provideCounter = new AtomicInteger(0);
-    class TestEntryPoint {
-      @Inject Lazy<String> i;
-    }
-    @Module(injects = TestEntryPoint.class)
-    class TestModule {
-      @Provides String provideInteger() {
-        provideCounter.incrementAndGet();
-        return null;
-      }
-    }
-
-    TestEntryPoint ep = injectWithModule(new TestEntryPoint(), new TestModule());
-    assertEquals(0, provideCounter.get());
-    assertNull(ep.i.get());
-    assertEquals(1, provideCounter.get());
-    assertNull(ep.i.get()); // still null
-    assertEquals(1, provideCounter.get()); // still only called once.
-  }
-
-  @Test public void providerOfLazyOfSomething() {
-    final AtomicInteger counter = new AtomicInteger();
-    class TestEntryPoint {
-      @Inject Provider<Lazy<Integer>> providerOfLazyInteger;
-    }
-
-    @Module(injects = TestEntryPoint.class)
-    class TestModule {
-      @Provides Integer provideInteger() {
-        return counter.incrementAndGet();
-      }
-    }
-
-    TestEntryPoint ep = injectWithModule(new TestEntryPoint(), new TestModule());
-    assertEquals(0, counter.get());
-    Lazy<Integer> i = ep.providerOfLazyInteger.get();
-    assertEquals(1, i.get().intValue());
-    assertEquals(1, counter.get());
-    assertEquals(1, i.get().intValue());
-    Lazy<Integer> j = ep.providerOfLazyInteger.get();
-    assertEquals(2, j.get().intValue());
-    assertEquals(2, counter.get());
-    assertEquals(1, i.get().intValue());
-  }
-
-  @Test public void sideBySideLazyVsProvider() {
-    final AtomicInteger counter = new AtomicInteger();
-    class TestEntryPoint {
-      @Inject Provider<Integer> providerOfInteger;
-      @Inject Lazy<Integer> lazyInteger;
-    }
-
-    @Module(injects = TestEntryPoint.class)
-    class TestModule {
-      @Provides Integer provideInteger() {
-        return counter.incrementAndGet();
-      }
-    }
-
-    TestEntryPoint ep = injectWithModule(new TestEntryPoint(), new TestModule());
-    assertEquals(0, counter.get());
-    assertEquals(0, counter.get());
-    assertEquals(1, ep.lazyInteger.get().intValue());
-    assertEquals(1, counter.get());
-    assertEquals(2, ep.providerOfInteger.get().intValue()); // fresh instance
-    assertEquals(1, ep.lazyInteger.get().intValue()); // still the same instance
-    assertEquals(2, counter.get());
-    assertEquals(3, ep.providerOfInteger.get().intValue()); // fresh instance
-    assertEquals(1, ep.lazyInteger.get().intValue()); // still the same instance.
-  }
-
-  private <T> T injectWithModule(T ep, Object ... modules) {
-    return ObjectGraph.createWith(new TestingLoader(), modules).inject(ep);
-  }
-}
diff --git a/core/src/test/java/dagger/InjectionTest.java b/core/src/test/java/dagger/InjectionTest.java
deleted file mode 100644
index 884c43928..000000000
--- a/core/src/test/java/dagger/InjectionTest.java
+++ /dev/null
@@ -1,936 +0,0 @@
-/*
- * Copyright (C) 2010 Google Inc.
- * Copyright (C) 2012 Square Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger;
-
-import dagger.internal.TestingLoader;
-import java.util.AbstractList;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.List;
-import java.util.RandomAccess;
-import java.util.Set;
-import java.util.concurrent.atomic.AtomicInteger;
-import javax.inject.Inject;
-import javax.inject.Named;
-import javax.inject.Provider;
-import javax.inject.Singleton;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-import static org.fest.assertions.Assertions.assertThat;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.fail;
-
-@RunWith(JUnit4.class)
-public final class InjectionTest {
-  @Test public void basicInjection() {
-    class TestEntryPoint {
-      @Inject Provider<G> gProvider;
-    }
-
-    @Module(injects = TestEntryPoint.class)
-    class TestModule {
-      @Provides E provideE(F f) {
-        return new E(f);
-      }
-      @Provides F provideF() {
-        return new F();
-      }
-    }
-
-    TestEntryPoint entryPoint = new TestEntryPoint();
-    ObjectGraph.createWith(new TestingLoader(), new TestModule()).inject(entryPoint);
-    G g = entryPoint.gProvider.get();
-    assertThat(g.a).isNotNull();
-    assertThat(g.b).isNotNull();
-    assertThat(g.c).isNotNull();
-    assertThat(g.d).isNotNull();
-    assertThat(g.e).isNotNull();
-    assertThat(g.e.f).isNotNull();
-  }
-
-  static class A {
-    @Inject A() {}
-  }
-
-  static class B {
-    @Inject B() {}
-  }
-
-  @Singleton
-  static class C {
-    @Inject C() {}
-  }
-
-  @Singleton
-  static class D {
-    @Inject D() {}
-  }
-
-  static class E {
-    F f;
-    E(F f) {
-      this.f = f;
-    }
-  }
-
-  static class F {}
-
-  static class G {
-    @Inject A a;
-    @Inject B b;
-    C c;
-    D d;
-    @Inject E e;
-    @Inject G(C c, D d) {
-      this.c = c;
-      this.d = d;
-    }
-  }
-
-  @Test public void providerInjection() {
-    class TestEntryPoint {
-      @Inject Provider<A> aProvider;
-    }
-
-    @Module(injects = TestEntryPoint.class)
-    class TestModule {
-    }
-
-    TestEntryPoint entryPoint = new TestEntryPoint();
-    ObjectGraph.createWith(new TestingLoader(), new TestModule()).inject(entryPoint);
-
-    assertThat(entryPoint.aProvider.get()).isNotNull();
-    assertThat(entryPoint.aProvider.get()).isNotNull();
-    assertThat(entryPoint.aProvider.get()).isNotSameAs(entryPoint.aProvider.get());
-  }
-
-  @Test public void singletons() {
-    class TestEntryPoint {
-      @Inject Provider<F> fProvider;
-      @Inject Provider<I> iProvider;
-    }
-
-    @Module(injects = TestEntryPoint.class)
-    class TestModule {
-      @Provides @Singleton F provideF() {
-        return new F();
-      }
-    }
-
-    TestEntryPoint entryPoint = new TestEntryPoint();
-    ObjectGraph.createWith(new TestingLoader(), new TestModule()).inject(entryPoint);
-    assertThat(entryPoint.fProvider.get()).isSameAs(entryPoint.fProvider.get());
-    assertThat(entryPoint.iProvider.get()).isSameAs(entryPoint.iProvider.get());
-  }
-
-  @Singleton
-  static class I {
-    @Inject I() {}
-  }
-
-  @Test public void bindingAnnotations() {
-    final A one = new A();
-    final A two = new A();
-
-    class TestEntryPoint {
-      @Inject A a;
-      @Inject @Named("one") A aOne;
-      @Inject @Named("two") A aTwo;
-    }
-
-    @Module(injects = TestEntryPoint.class)
-    class TestModule {
-      @Provides @Named("one") A getOne() {
-        return one;
-      }
-      @Provides @Named("two") A getTwo() {
-        return two;
-      }
-    }
-
-    TestEntryPoint entryPoint = new TestEntryPoint();
-    ObjectGraph.createWith(new TestingLoader(), new TestModule()).inject(entryPoint);
-    assertThat(entryPoint.a).isNotNull();
-    assertThat(one).isSameAs(entryPoint.aOne);
-    assertThat(two).isSameAs(entryPoint.aTwo);
-  }
-
-  @Test public void singletonBindingAnnotationAndProvider() {
-    class TestEntryPoint {
-      @Inject Provider<L> lProvider;
-    }
-
-    @Module(injects = TestEntryPoint.class)
-    class TestModule {
-      A a1;
-      A a2;
-
-      @Provides @Singleton @Named("one") F provideF(Provider<A> aProvider) {
-        a1 = aProvider.get();
-        a2 = aProvider.get();
-        return new F();
-      }
-    }
-
-    TestEntryPoint entryPoint = new TestEntryPoint();
-    TestModule module = new TestModule();
-    ObjectGraph.createWith(new TestingLoader(), module).inject(entryPoint);
-    entryPoint.lProvider.get();
-
-    assertThat(module.a1).isNotNull();
-    assertThat(module.a2).isNotNull();
-    assertThat(module.a1).isNotSameAs(module.a2);
-    assertThat(entryPoint.lProvider.get()).isSameAs(entryPoint.lProvider.get());
-  }
-
-  @Singleton
-  public static class L {
-    @Inject @Named("one") F f;
-    @Inject Provider<L> lProvider;
-  }
-
-  @Test public void singletonInGraph() {
-    class TestEntryPoint {
-      @Inject N n1;
-      @Inject N n2;
-      @Inject F f1;
-      @Inject F f2;
-    }
-
-    @Module(injects = TestEntryPoint.class)
-    class TestModule {
-      @Provides @Singleton F provideF() {
-        return new F();
-      }
-    }
-
-    TestEntryPoint entryPoint = new TestEntryPoint();
-    ObjectGraph.createWith(new TestingLoader(), new TestModule()).inject(entryPoint);
-
-    assertThat(entryPoint.f1).isSameAs(entryPoint.f2);
-    assertThat(entryPoint.f1).isSameAs(entryPoint.n1.f1);
-    assertThat(entryPoint.f1).isSameAs(entryPoint.n1.f2);
-    assertThat(entryPoint.f1).isSameAs(entryPoint.n2.f1);
-    assertThat(entryPoint.f1).isSameAs(entryPoint.n2.f2);
-    assertThat(entryPoint.f1).isSameAs(entryPoint.n1.fProvider.get());
-    assertThat(entryPoint.f1).isSameAs(entryPoint.n2.fProvider.get());
-  }
-
-  public static class N {
-    @Inject F f1;
-    @Inject F f2;
-    @Inject Provider<F> fProvider;
-  }
-
-  @Test public void noJitBindingsForAnnotations() {
-    class TestEntryPoint {
-      @Inject @Named("a") A a;
-    }
-
-    @Module(injects = TestEntryPoint.class)
-    class TestModule {
-    }
-
-    ObjectGraph graph = ObjectGraph.createWith(new TestingLoader(), new TestModule());
-    try {
-      graph.validate();
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-  }
-
-  @Test public void injectableSupertypes() {
-    class TestEntryPoint {
-      @Inject Q q;
-    }
-
-    @Module(injects = TestEntryPoint.class)
-    class TestModule {
-      @Provides F provideF() {
-        return new F();
-      }
-    }
-
-    TestEntryPoint entryPoint = new TestEntryPoint();
-    ObjectGraph.createWith(new TestingLoader(), new TestModule()).inject(entryPoint);
-    assertThat(entryPoint.q.f).isNotNull();
-  }
-
-  @Test public void uninjectableSupertypes() {
-    class TestEntryPoint {
-      @Inject T t;
-    }
-
-    @Module(injects = TestEntryPoint.class)
-    class TestModule {
-    }
-
-    TestEntryPoint entryPoint = new TestEntryPoint();
-    ObjectGraph.createWith(new TestingLoader(), new TestModule()).inject(entryPoint);
-    assertThat(entryPoint.t).isNotNull();
-  }
-
-  public static class P {
-    @Inject F f;
-  }
-
-  public static class Q extends P {
-    @Inject Q() {}
-  }
-
-  static class S {
-  }
-
-  public static class T extends S {
-    @Inject T() {}
-  }
-
-  @Test public void singletonsAreNotEager() {
-    class TestEntryPoint {
-      @Inject Provider<A> aProvider;
-    }
-
-    @Module(injects = TestEntryPoint.class)
-    class TestModule {
-      boolean sInjected = false;
-
-      @Provides F provideF(R r) {
-        return new F();
-      }
-
-      @Provides @Singleton S provideS() {
-        sInjected = true;
-        return new S();
-      }
-    }
-
-    R.injected = false;
-    TestEntryPoint entryPoint = new TestEntryPoint();
-    TestModule module = new TestModule();
-    ObjectGraph.createWith(new TestingLoader(), module).inject(entryPoint);
-
-    assertThat(R.injected).isFalse();
-    assertThat(module.sInjected).isFalse();
-  }
-
-  @Singleton
-  static class R {
-    static boolean injected = false;
-    @Inject R() {
-      injected = true;
-    }
-  }
-
-  @Test public void providesSet() {
-    final Set<A> set = Collections.emptySet();
-
-    class TestEntryPoint {
-      @Inject Set<A> set;
-    }
-
-    @Module(injects = TestEntryPoint.class)
-    class TestModule {
-      @Provides Set<A> provideSet() {
-        return set;
-      }
-    }
-
-    TestEntryPoint entryPoint = new TestEntryPoint();
-    TestModule module = new TestModule();
-    ObjectGraph.createWith(new TestingLoader(), module).inject(entryPoint);
-
-    assertThat(entryPoint.set).isSameAs(set);
-  }
-
-  @Test public void providesSetValues() {
-    final Set<A> set = Collections.emptySet();
-
-    class TestEntryPoint {
-      @Inject Set<A> set;
-    }
-
-    @Module(injects = TestEntryPoint.class)
-    class TestModule {
-      @Provides(type = Provides.Type.SET_VALUES) Set<A> provideSet() {
-        return set;
-      }
-    }
-
-    TestEntryPoint entryPoint = new TestEntryPoint();
-    TestModule module = new TestModule();
-    ObjectGraph.createWith(new TestingLoader(), module).inject(entryPoint);
-
-    // copies into immutable collection
-    assertThat(entryPoint.set).isNotSameAs(set);
-    assertThat(entryPoint.set).isEqualTo(set);
-  }
-
-  @Test public void providerMethodsConflict() {
-    @Module
-    class TestModule {
-      @Provides A provideA1() {
-        throw new AssertionError();
-      }
-      @Provides A provideA2() {
-        throw new AssertionError();
-      }
-    }
-
-    try {
-      ObjectGraph.createWith(new TestingLoader(), new TestModule());
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void providesSetConflictsWithProvidesTypeSet() {
-    @Module
-    class TestModule {
-      @Provides(type = Provides.Type.SET) A provideSetElement() {
-        throw new AssertionError();
-      }
-      @Provides Set<A> provideSet() {
-        throw new AssertionError();
-      }
-    }
-
-    try {
-      ObjectGraph.createWith(new TestingLoader(), new TestModule());
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void providesSetConflictsWithProvidesTypeSetValues() {
-    @Module
-    class TestModule {
-      @Provides(type = Provides.Type.SET_VALUES) Set<A> provideSetContribution() {
-        throw new AssertionError();
-      }
-      @Provides Set<A> provideSet() {
-        throw new AssertionError();
-      }
-    }
-
-    try {
-      ObjectGraph.createWith(new TestingLoader(), new TestModule());
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void providesSetOfProvidersIsDifferentThanProvidesTypeSetValues() {
-    final Set<A> set = Collections.emptySet();
-    final Set<Provider<A>> providers = Collections.emptySet();
-
-    class TestEntryPoint {
-      @Inject Set<A> set;
-      @Inject Set<Provider<A>> providers;
-    }
-
-    @Module(injects = TestEntryPoint.class)
-    class TestModule {
-      @Provides(type = Provides.Type.SET_VALUES) Set<A> provideSetContribution() {
-        return set;
-      }
-      @Provides Set<Provider<A>> provideProviders() {
-        return providers;
-      }
-    }
-
-    TestEntryPoint entryPoint = new TestEntryPoint();
-    TestModule module = new TestModule();
-    ObjectGraph.createWith(new TestingLoader(), module).inject(entryPoint);
-
-    // copies into immutable collection
-    assertThat(entryPoint.set).isNotSameAs(set);
-    assertThat(entryPoint.set).isEqualTo(set);
-    assertThat(entryPoint.providers).isSameAs(providers);
-  }
-
-  @Test public void singletonsInjectedOnlyIntoProviders() {
-    class TestEntryPoint {
-      @Inject Provider<A> aProvider;
-    }
-
-    @Module(injects = TestEntryPoint.class)
-    class TestModule {
-      @Provides @Singleton A provideA() {
-        return new A();
-      }
-    }
-
-    TestEntryPoint entryPoint = new TestEntryPoint();
-    ObjectGraph.createWith(new TestingLoader(), new TestModule()).inject(entryPoint);
-    assertThat(entryPoint.aProvider.get()).isSameAs(entryPoint.aProvider.get());
-  }
-
-  @Test public void moduleOverrides() {
-    class TestEntryPoint {
-      @Inject Provider<E> eProvider;
-    }
-
-    @Module(injects = TestEntryPoint.class)
-    class BaseModule {
-      @Provides F provideF() {
-        throw new AssertionError();
-      }
-      @Provides E provideE(F f) {
-        return new E(f);
-      }
-    }
-
-    @Module(overrides = true)
-    class OverridesModule {
-      @Provides F provideF() {
-        return new F();
-      }
-    }
-
-    TestEntryPoint entryPoint = new TestEntryPoint();
-    ObjectGraph.createWith(new TestingLoader(), new BaseModule(), new OverridesModule()).inject(entryPoint);
-    E e = entryPoint.eProvider.get();
-    assertThat(e).isNotNull();
-    assertThat(e.f).isNotNull();
-  }
-
-  @Test public void noJitBindingsForInterfaces() {
-    class TestEntryPoint {
-      @Inject RandomAccess randomAccess;
-    }
-
-    @Module(injects = TestEntryPoint.class)
-    class TestModule {
-    }
-
-    ObjectGraph graph = ObjectGraph.createWith(new TestingLoader(), new TestModule());
-    try {
-      graph.validate();
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-  }
-
-  @Test public void objectGraphGetInterface() {
-    final Runnable runnable = new Runnable() {
-      @Override public void run() {
-      }
-    };
-
-    @Module(injects = Runnable.class)
-    class TestModule {
-      @Provides Runnable provideRunnable() {
-        return runnable;
-      }
-    }
-
-    ObjectGraph graph = ObjectGraph.createWith(new TestingLoader(), new TestModule());
-    graph.validate();
-    assertThat(graph.get(Runnable.class)).isSameAs(runnable);
-  }
-
-  @Test public void noProvideBindingsForAbstractClasses() {
-    class TestEntryPoint {
-      @Inject AbstractList abstractList;
-    }
-
-    @Module(injects = TestEntryPoint.class)
-    class TestModule {
-    }
-
-    ObjectGraph graph = ObjectGraph.createWith(new TestingLoader(), new TestModule());
-    try {
-      graph.validate();
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-  }
-
-  static class ExtendsParameterizedType extends AbstractList<Integer> {
-    @Inject String string;
-    @Override public Integer get(int i) {
-      throw new AssertionError();
-    }
-    @Override public int size() {
-      throw new AssertionError();
-    }
-  }
-
-  /**
-   * We've had bugs where we look for the wrong keys when a class extends a
-   * parameterized class. Explicitly test that we can inject such classes.
-   */
-  @Test public void extendsParameterizedType() {
-    class TestEntryPoint {
-      @Inject ExtendsParameterizedType extendsParameterizedType;
-    }
-
-    @Module(injects = TestEntryPoint.class)
-    class TestModule {
-      @Provides String provideString() {
-        return "injected";
-      }
-    }
-
-    TestEntryPoint entryPoint = new TestEntryPoint();
-    ObjectGraph.createWith(new TestingLoader(), new TestModule()).inject(entryPoint);
-    assertThat(entryPoint.extendsParameterizedType.string).isEqualTo("injected");
-  }
-
-  @Test public void injectParameterizedType() {
-    class TestEntryPoint {
-      @Inject List<String> listOfStrings;
-    }
-
-    @Module(injects = TestEntryPoint.class)
-    class TestModule {
-      @Provides List<String> provideList() {
-        return Arrays.asList("a", "b");
-      }
-    }
-
-    TestEntryPoint entryPoint = new TestEntryPoint();
-    ObjectGraph.createWith(new TestingLoader(), new TestModule()).inject(entryPoint);
-    assertThat(entryPoint.listOfStrings).isEqualTo(Arrays.asList("a", "b"));
-  }
-
-  @Test public void injectWildcardType() {
-    class TestEntryPoint {
-      @Inject List<? extends Number> listOfNumbers;
-    }
-
-    @Module(injects = TestEntryPoint.class)
-    class TestModule {
-      @Provides List<? extends Number> provideList() {
-        return Arrays.asList(1, 2);
-      }
-    }
-
-    try {
-      ObjectGraph.createWith(new TestingLoader(), new TestModule());
-      fail();
-    } catch (UnsupportedOperationException expected) {
-    }
-  }
-
-  static class Parameterized<T> {
-      @Inject String string;
-    }
-
-  @Test public void noConstructorInjectionsForClassesWithTypeParameters() {
-
-    class TestEntryPoint {
-      @Inject Parameterized<Long> parameterized;
-    }
-
-    @Module(injects = TestEntryPoint.class)
-    class TestModule {
-      @Provides String provideString() {
-        return "injected";
-      }
-    }
-
-    ObjectGraph graph = ObjectGraph.createWith(new TestingLoader(), new TestModule());
-    try {
-      graph.validate();
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-  }
-
-  @Test public void moduleWithNoProvidesMethods() {
-    @Module
-    class TestModule {
-    }
-
-    ObjectGraph.createWith(new TestingLoader(), new TestModule());
-  }
-
-  @Test public void getInstance() {
-    final AtomicInteger next = new AtomicInteger(0);
-
-    @Module(injects = Integer.class)
-    class TestModule {
-      @Provides Integer provideInteger() {
-        return next.getAndIncrement();
-      }
-    }
-
-    ObjectGraph graph = ObjectGraph.createWith(new TestingLoader(), new TestModule());
-    assertThat((int) graph.get(Integer.class)).isEqualTo(0);
-    assertThat((int) graph.get(Integer.class)).isEqualTo(1);
-  }
-
-  @Test public void getInstanceRequiresEntryPoint() {
-    @Module
-    class TestModule {
-      @Provides Integer provideInteger() {
-        throw new AssertionError();
-      }
-    }
-
-    ObjectGraph graph = ObjectGraph.createWith(new TestingLoader(), new TestModule());
-    try {
-      graph.get(Integer.class);
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void getInstanceOfPrimitive() {
-    @Module(injects = int.class)
-    class TestModule {
-      @Provides int provideInt() {
-        return 1;
-      }
-    }
-
-    ObjectGraph graph = ObjectGraph.createWith(new TestingLoader(), new TestModule());
-    assertEquals(1, (int) graph.get(int.class));
-  }
-
-  @Test public void getInstanceOfArray() {
-    @Module(injects = int[].class)
-    class TestModule {
-      @Provides int[] provideIntArray() {
-        return new int[] { 1, 2, 3 };
-      }
-    }
-
-    ObjectGraph graph = ObjectGraph.createWith(new TestingLoader(), new TestModule());
-    assertEquals("[1, 2, 3]", Arrays.toString(graph.get(int[].class)));
-  }
-
-  @Test public void getInstanceAndInjectMembersUseDifferentKeys() {
-    class BoundTwoWays {
-      @Inject String s;
-    }
-
-    @Module(injects = BoundTwoWays.class)
-    class TestModule {
-      @Provides
-      BoundTwoWays provideBoundTwoWays() {
-        BoundTwoWays result = new BoundTwoWays();
-        result.s = "Pepsi";
-        return result;
-      }
-
-      @Provides String provideString() {
-        return "Coke";
-      }
-    }
-
-    ObjectGraph graph = ObjectGraph.createWith(new TestingLoader(), new TestModule());
-    BoundTwoWays provided = graph.get(BoundTwoWays.class);
-    assertEquals("Pepsi", provided.s);
-
-    BoundTwoWays membersInjected = new BoundTwoWays();
-    graph.inject(membersInjected);
-    assertEquals("Coke", membersInjected.s);
-  }
-
-  static class NoInjections {
-    NoInjections(Void noDefaultConstructorEither) {
-    }
-  }
-
-  @Test public void entryPointNeedsNoInjectAnnotation() {
-    @Module(injects = NoInjections.class)
-    class TestModule {
-    }
-
-    ObjectGraph.createWith(new TestingLoader(), new TestModule()).validate();
-  }
-
-  static class InjectMembersOnly {
-    InjectMembersOnly(Void noInjectableConstructor) {
-    }
-    @Inject String string;
-  }
-
-  @Test public void cannotGetOnMembersOnlyInjectionPoint() {
-    @Module(injects = InjectMembersOnly.class)
-    class TestModule {
-      @Provides String provideString() {
-        return "injected";
-      }
-    }
-
-    ObjectGraph graph = ObjectGraph.createWith(new TestingLoader(), new TestModule());
-    try {
-      graph.get(InjectMembersOnly.class);
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-
-    InjectMembersOnly instance = new InjectMembersOnly(null);
-    graph.inject(instance);
-    assertThat(instance.string).isEqualTo("injected");
-  }
-
-  @Test public void nonEntryPointNeedsInjectAnnotation() {
-    @Module
-    class TestModule {
-      @Provides String provideString(NoInjections noInjections) {
-        throw new AssertionError();
-      }
-    }
-
-    ObjectGraph graph = ObjectGraph.createWith(new TestingLoader(), new TestModule());
-    try {
-      graph.validate();
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-  }
-
-  static class TwoAtInjectConstructors {
-    @Inject TwoAtInjectConstructors() {
-    }
-    @Inject TwoAtInjectConstructors(String s) {
-    }
-  }
-
-  @Test public void twoAtInjectConstructorsIsRejected() {
-    @Module(injects = TwoAtInjectConstructors.class)
-    class TestModule {
-      @Provides String provideString() {
-        throw new AssertionError();
-      }
-    }
-
-    ObjectGraph graph = ObjectGraph.createWith(new TestingLoader(), new TestModule());
-    try {
-      graph.validate();
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-  }
-
-  @Test public void runtimeProvidesMethodsExceptionsAreNotWrapped() {
-    class TestEntryPoint {
-      @Inject String string;
-    }
-
-    @Module(injects = TestEntryPoint.class)
-    class TestModule {
-      @Provides String provideString() {
-        throw new ClassCastException("foo");
-      }
-    }
-
-    try {
-      ObjectGraph.createWith(new TestingLoader(), new TestModule()).inject(new TestEntryPoint());
-      fail();
-    } catch (ClassCastException e) {
-      assertThat(e.getMessage()).isEqualTo("foo");
-    }
-  }
-
-  static class ThrowsOnConstruction {
-    @Inject ThrowsOnConstruction() {
-      throw new ClassCastException("foo");
-    }
-  }
-
-  @Test public void runtimeConstructorExceptionsAreNotWrapped() {
-    @Module(injects = ThrowsOnConstruction.class)
-    class TestModule {
-    }
-
-    try {
-      ObjectGraph.createWith(new TestingLoader(), new TestModule()).get(ThrowsOnConstruction.class);
-      fail();
-    } catch (ClassCastException e) {
-      assertThat(e.getMessage()).isEqualTo("foo");
-    }
-  }
-
-  static class SingletonLinkedFromExtension {
-    @Inject C c; // Singleton.
-  }
-
-  @Module(complete = false, injects = C.class)
-  static class RootModule { }
-
-  @Module(addsTo = RootModule.class, injects = SingletonLinkedFromExtension.class)
-  static class ExtensionModule { }
-
-  @Test public void testSingletonLinkingThroughExtensionGraph() {
-    ObjectGraph root = ObjectGraph.createWith(new TestingLoader(), new RootModule());
-    // DO NOT CALL root.get(C.class)) HERE to get forced-linking behaviour from plus();
-    ObjectGraph extension = root.plus(new ExtensionModule());
-    assertThat(extension.get(SingletonLinkedFromExtension.class).c).isSameAs(root.get(C.class));
-  }
-
-  @Test public void privateFieldsFail() {
-    class Test {
-      @Inject private Object nope;
-    }
-
-    @Module(injects = Test.class)
-    class TestModule {
-      @Provides Object provideObject() {
-        return null;
-      }
-    }
-
-    try {
-      ObjectGraph.createWith(new TestingLoader(), new TestModule()).inject(new Test());
-      fail();
-    } catch (IllegalStateException e) {
-      assertThat(e.getMessage()).contains("Can't inject private field: ");
-    }
-  }
-
-  @Test public void privateConstructorsFail() {
-    class Test {
-      @Inject private Test() {
-      }
-    }
-
-    @Module(injects = Test.class)
-    class TestModule {
-    }
-
-    try {
-      ObjectGraph.createWith(new TestingLoader(), new TestModule()).get(Test.class);
-      fail();
-    } catch (IllegalStateException e) {
-      assertThat(e.getMessage()).contains("Can't inject private constructor: ");
-    }
-  }
-
-  /** https://github.com/square/dagger/issues/231 */
-  @Test public void atInjectAlwaysRequiredForConstruction() {
-    @Module(injects = ArrayList.class)
-    class TestModule {
-    }
-
-    ObjectGraph objectGraph = ObjectGraph.createWith(new TestingLoader(), new TestModule());
-    objectGraph.validate();
-    try {
-      objectGraph.get(ArrayList.class);
-      fail();
-    } catch (IllegalStateException e) {
-      assertThat(e.getMessage()).contains("Unable to create binding for java.util.ArrayList");
-    }
-  }
-}
diff --git a/core/src/test/java/dagger/LazyInjectionTest.java b/core/src/test/java/dagger/LazyInjectionTest.java
deleted file mode 100644
index 849a43128..000000000
--- a/core/src/test/java/dagger/LazyInjectionTest.java
+++ /dev/null
@@ -1,118 +0,0 @@
-/*
- * Copyright (C) 2012 Square Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger;
-
-import dagger.internal.TestingLoader;
-import javax.inject.Inject;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-import static org.fest.assertions.Assertions.assertThat;
-
-@RunWith(JUnit4.class)
-public final class LazyInjectionTest {
-  @Test public void getLazyDoesNotCauseInjectedTypesToBeLoaded() {
-    @Module(injects = LazyEntryPoint.class)
-    class TestModule {
-    }
-
-    ObjectGraph.createWith(new TestingLoader(), new TestModule());
-    assertThat(lazyEntryPointLoaded).isFalse();
-  }
-
-  private static boolean lazyEntryPointLoaded = false;
-  static class LazyEntryPoint {
-    static {
-      lazyEntryPointLoaded = true;
-    }
-  }
-
-  @Test public void getLazyDoesNotCauseProvidesParametersToBeLoaded() {
-    @Module
-    class TestModule {
-      @Provides Object provideObject(LazyProvidesParameter parameter) {
-        throw new AssertionError();
-      }
-    }
-
-    ObjectGraph.createWith(new TestingLoader(), new TestModule());
-    assertThat(lazyProvidesParameterLoaded).isFalse();
-  }
-
-  private static boolean lazyProvidesParameterLoaded = false;
-  static class LazyProvidesParameter {
-    static {
-      lazyProvidesParameterLoaded = true;
-    }
-  }
-
-  @Test public void getLazyDoesNotCauseProvidesResultToBeLoaded() {
-    @Module
-    class TestModule {
-      @Provides LazyProvidesResult provideLazy() {
-        throw new AssertionError();
-      }
-    }
-
-    ObjectGraph.createWith(new TestingLoader(), new TestModule());
-    assertThat(lazyProvidesResultLoaded).isFalse();
-  }
-
-  private static boolean lazyProvidesResultLoaded = false;
-  static class LazyProvidesResult {
-    static {
-      lazyProvidesResultLoaded = true;
-    }
-  }
-
-  @Test public void getLazyDoesNotCauseStaticsToBeLoaded() {
-    @Module(staticInjections = LazyInjectStatics.class)
-    class TestModule {
-    }
-
-    ObjectGraph.createWith(new TestingLoader(), new TestModule());
-    assertThat(LazyInjectStaticsLoaded).isFalse();
-  }
-
-  private static boolean LazyInjectStaticsLoaded = false;
-  static class LazyInjectStatics {
-    static {
-      LazyInjectStaticsLoaded = true;
-    }
-  }
-
-  @Test public void lazyInjectionRequiresProvidesMethod() {
-    class TestEntryPoint {
-      @Inject String injected;
-    }
-
-    @Module(injects = TestEntryPoint.class)
-    class TestModule {
-      @Provides String provideString(Integer integer) {
-        return integer.toString();
-      }
-      @Provides Integer provideInteger() {
-        return 5;
-      }
-    }
-
-    ObjectGraph objectGraph = ObjectGraph.createWith(new TestingLoader(), new TestModule());
-    TestEntryPoint entryPoint = new TestEntryPoint();
-    objectGraph.inject(entryPoint);
-    assertThat(entryPoint.injected).isEqualTo("5");
-  }
-}
diff --git a/core/src/test/java/dagger/MembersInjectorTest.java b/core/src/test/java/dagger/MembersInjectorTest.java
deleted file mode 100644
index f8abe0de9..000000000
--- a/core/src/test/java/dagger/MembersInjectorTest.java
+++ /dev/null
@@ -1,218 +0,0 @@
-/*
- * Copyright (C) 2012 Square Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger;
-
-import dagger.internal.TestingLoader;
-import javax.inject.Inject;
-import javax.inject.Provider;
-import javax.inject.Singleton;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-import static org.fest.assertions.Assertions.assertThat;
-import static org.junit.Assert.fail;
-
-/**
- * Tests MembersInjector injection, and how object graph features interact with
- * types unconstructable types (types that support members injection only).
- */
-@RunWith(JUnit4.class)
-public final class MembersInjectorTest {
-  @Test public void injectMembers() {
-    class TestEntryPoint {
-      @Inject MembersInjector<Injectable> membersInjector;
-    }
-
-    @Module(injects = TestEntryPoint.class)
-    class StringModule {
-      @Provides String provideString() {
-        return "injected";
-      }
-    }
-
-    TestEntryPoint entryPoint = new TestEntryPoint();
-    ObjectGraph.createWith(new TestingLoader(), new StringModule()).inject(entryPoint);
-    Injectable injectable = new Injectable();
-    entryPoint.membersInjector.injectMembers(injectable);
-    assertThat(injectable.injected).isEqualTo("injected");
-  }
-
-  static class Injectable {
-    @Inject String injected;
-  }
-
-  static class Unconstructable {
-    final String constructor;
-    @Inject String injected;
-    Unconstructable(String constructor) {
-      this.constructor = constructor;
-    }
-  }
-
-  @Test public void membersInjectorOfUnconstructableIsOkay() {
-    class TestEntryPoint {
-      @Inject MembersInjector<Unconstructable> membersInjector;
-    }
-
-    @Module(injects = TestEntryPoint.class)
-    class StringModule {
-      @Provides String provideString() {
-        return "injected";
-      }
-    }
-
-    TestEntryPoint entryPoint = new TestEntryPoint();
-    ObjectGraph.createWith(new TestingLoader(), new StringModule()).inject(entryPoint);
-    Unconstructable object = new Unconstructable("constructor");
-    entryPoint.membersInjector.injectMembers(object);
-    assertThat(object.constructor).isEqualTo("constructor");
-    assertThat(object.injected).isEqualTo("injected");
-  }
-
-  @Test public void injectionOfUnconstructableFails() {
-    class TestEntryPoint {
-      @Inject Unconstructable unconstructable;
-    }
-
-    @Module(injects = TestEntryPoint.class)
-    class TestModule {
-    }
-
-    ObjectGraph graph = ObjectGraph.createWith(new TestingLoader(), new TestModule());
-    try {
-      graph.get(TestEntryPoint.class);
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-  }
-
-  @Test public void instanceInjectionOfMembersOnlyType() {
-    class TestEntryPoint {
-      @Inject Provider<Unconstructable> provider;
-    }
-
-    @Module(injects = TestEntryPoint.class)
-    class TestModule {
-    }
-
-    ObjectGraph graph = ObjectGraph.createWith(new TestingLoader(), new TestModule());
-    try {
-      graph.get(TestEntryPoint.class);
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-  }
-
-  @Test public void rejectUnconstructableSingleton() {
-    class TestEntryPoint {
-      @Inject MembersInjector<UnconstructableSingleton> membersInjector;
-    }
-
-    @Module(injects = TestEntryPoint.class)
-    class TestModule {
-    }
-
-    ObjectGraph graph = ObjectGraph.createWith(new TestingLoader(), new TestModule());
-    try {
-      graph.get(TestEntryPoint.class);
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-  }
-
-  @Singleton
-  static class UnconstructableSingleton {
-    final String constructor;
-    @Inject String injected;
-    UnconstructableSingleton(String constructor) {
-      this.constructor = constructor;
-    }
-  }
-
-  class NonStaticInner {
-    @Inject String injected;
-  }
-
-  @Test public void membersInjectorOfNonStaticInnerIsOkay() {
-    class TestEntryPoint {
-      @Inject MembersInjector<NonStaticInner> membersInjector;
-    }
-
-    @Module(injects = TestEntryPoint.class)
-    class TestModule {
-      @Provides String provideString() {
-        return "injected";
-      }
-    }
-
-    TestEntryPoint entryPoint = new TestEntryPoint();
-    ObjectGraph.createWith(new TestingLoader(), new TestModule()).inject(entryPoint);
-    NonStaticInner nonStaticInner = new NonStaticInner();
-    entryPoint.membersInjector.injectMembers(nonStaticInner);
-    assertThat(nonStaticInner.injected).isEqualTo("injected");
-  }
-
-  @Test public void instanceInjectionOfNonStaticInnerFailsEarly() {
-    class TestEntryPoint {
-      @Inject NonStaticInner nonStaticInner;
-    }
-
-    @Module(injects = TestEntryPoint.class)
-    class TestModule {
-    }
-
-    ObjectGraph graph = ObjectGraph.createWith(new TestingLoader(), new TestModule());
-    try {
-      graph.get(TestEntryPoint.class);
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-  }
-
-  @Test public void providesMethodsAndMembersInjectionDoNotConflict() {
-    class InjectsString {
-      @Inject String value;
-    }
-
-    class TestEntryPoint {
-      @Inject Provider<InjectsString> provider;
-      @Inject MembersInjector<InjectsString> membersInjector;
-    }
-
-    @Module(injects = TestEntryPoint.class)
-    class TestModule {
-      @Provides InjectsString provideInjectsString() {
-        InjectsString result = new InjectsString();
-        result.value = "provides";
-        return result;
-      }
-      @Provides String provideString() {
-        return "members";
-      }
-    }
-
-    TestEntryPoint entryPoint = new TestEntryPoint();
-    ObjectGraph.createWith(new TestingLoader(), new TestModule()).inject(entryPoint);
-
-    InjectsString provided = entryPoint.provider.get();
-    assertThat(provided.value).isEqualTo("provides");
-
-    InjectsString membersInjected = new InjectsString();
-    entryPoint.membersInjector.injectMembers(membersInjected);
-    assertThat(membersInjected.value).isEqualTo("members");
-  }
-}
\ No newline at end of file
diff --git a/core/src/test/java/dagger/ModuleTest.java b/core/src/test/java/dagger/ModuleTest.java
deleted file mode 100644
index ffe818aed..000000000
--- a/core/src/test/java/dagger/ModuleTest.java
+++ /dev/null
@@ -1,273 +0,0 @@
-/*
- * Copyright (C) 2012 Square Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger;
-
-import dagger.internal.TestingLoader;
-import javax.inject.Inject;
-import javax.inject.Provider;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-import static org.fest.assertions.Assertions.assertThat;
-import static org.junit.Assert.fail;
-
-//TODO: Migrate to compiler.
-
-@RunWith(JUnit4.class)
-public final class ModuleTest {
-  static class TestEntryPoint {
-    @Inject String s;
-  }
-
-  @Module(injects = TestEntryPoint.class)
-  static class ModuleWithEntryPoint {
-  }
-
-  @Test public void childModuleWithEntryPoint() {
-    @Module(includes = ModuleWithEntryPoint.class)
-    class TestModule {
-      @Provides String provideString() {
-        return "injected";
-      }
-    }
-
-    ObjectGraph objectGraph = ObjectGraph.createWith(new TestingLoader(), new TestModule());
-    TestEntryPoint entryPoint = objectGraph.get(TestEntryPoint.class);
-    assertThat(entryPoint.s).isEqualTo("injected");
-  }
-
-  static class TestStaticInjection {
-    @Inject static String s;
-  }
-
-  @Module(staticInjections = TestStaticInjection.class)
-  static class ModuleWithStaticInjection {
-  }
-
-  @Test public void childModuleWithStaticInjection() {
-    @Module(includes = ModuleWithStaticInjection.class)
-    class TestModule {
-      @Provides String provideString() {
-        return "injected";
-      }
-    }
-
-    ObjectGraph objectGraph = ObjectGraph.createWith(new TestingLoader(), new TestModule());
-    TestStaticInjection.s = null;
-    objectGraph.injectStatics();
-    assertThat(TestStaticInjection.s).isEqualTo("injected");
-  }
-
-  @Module
-  static class ModuleWithBinding {
-    @Provides String provideString() {
-      return "injected";
-    }
-  }
-
-  @Test public void childModuleWithBinding() {
-
-    @Module(
-        injects = TestEntryPoint.class,
-        includes = ModuleWithBinding.class
-    )
-    class TestModule {
-    }
-
-    ObjectGraph objectGraph = ObjectGraph.createWith(new TestingLoader(), new TestModule());
-    TestEntryPoint entryPoint = new TestEntryPoint();
-    objectGraph.inject(entryPoint);
-    assertThat(entryPoint.s).isEqualTo("injected");
-  }
-
-  @Module(includes = ModuleWithBinding.class)
-  static class ModuleWithChildModule {
-  }
-
-  @Test public void childModuleWithChildModule() {
-
-    @Module(
-        injects = TestEntryPoint.class,
-        includes = ModuleWithChildModule.class
-    )
-    class TestModule {
-    }
-
-    ObjectGraph objectGraph = ObjectGraph.createWith(new TestingLoader(), new TestModule());
-    TestEntryPoint entryPoint = new TestEntryPoint();
-    objectGraph.inject(entryPoint);
-    assertThat(entryPoint.s).isEqualTo("injected");
-  }
-
-  @Module
-  static class ModuleWithConstructor {
-    private final String value;
-
-    ModuleWithConstructor(String value) {
-      this.value = value;
-    }
-
-    @Provides String provideString() {
-      return value;
-    }
-  }
-
-  @Test public void childModuleMissingManualConstruction() {
-    @Module(includes = ModuleWithConstructor.class)
-    class TestModule {
-    }
-
-    try {
-      ObjectGraph.createWith(new TestingLoader(), new TestModule());
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void childModuleWithManualConstruction() {
-
-    @Module(
-        injects = TestEntryPoint.class,
-        includes = ModuleWithConstructor.class
-    )
-    class TestModule {
-    }
-
-    ObjectGraph objectGraph = ObjectGraph.createWith(new TestingLoader(), new ModuleWithConstructor("a"), new TestModule());
-    TestEntryPoint entryPoint = new TestEntryPoint();
-    objectGraph.inject(entryPoint);
-    assertThat(entryPoint.s).isEqualTo("a");
-  }
-
-  static class A {}
-
-  static class B { @Inject A a; }
-
-  @Module(injects = A.class) public static class TestModuleA {
-    @Provides A a() { return new A(); }
-  }
-
-  @Module(includes = TestModuleA.class, injects = B.class) public static class TestModuleB {}
-
-  @Test public void autoInstantiationOfModules() {
-    // Have to make these non-method-scoped or instantiation errors occur.
-    ObjectGraph objectGraph = ObjectGraph.createWith(new TestingLoader(), TestModuleA.class);
-    assertThat(objectGraph.get(A.class)).isNotNull();
-  }
-
-  @Test public void autoInstantiationOfIncludedModules() {
-    // Have to make these non-method-scoped or instantiation errors occur.
-    ObjectGraph objectGraph = ObjectGraph.createWith(new TestingLoader(), new TestModuleB()); // TestModuleA auto-created.
-    assertThat(objectGraph.get(A.class)).isNotNull();
-    assertThat(objectGraph.get(B.class).a).isNotNull();
-  }
-
-  static class ModuleMissingModuleAnnotation {}
-
-  @Module(includes = ModuleMissingModuleAnnotation.class)
-  static class ChildModuleMissingModuleAnnotation {}
-
-  @Test
-  public void childModuleMissingModuleAnnotation() {
-    try {
-      ObjectGraph.createWith(new TestingLoader(), new ChildModuleMissingModuleAnnotation());
-    } catch (IllegalArgumentException e) {
-      assertThat(e.getMessage())
-          .contains("No @Module on dagger.ModuleTest$ModuleMissingModuleAnnotation");
-    }
-  }
-
-  @Module
-  static class ThreadModule extends Thread {}
-
-  @Test public void moduleExtendingClassThrowsException() {
-    try {
-      ObjectGraph.createWith(new TestingLoader(), new ThreadModule());
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e.getMessage()).startsWith("Modules must not extend from other classes: ");
-    }
-  }
-
-  @Test public void provideProviderFails() {
-    @Module
-    class ProvidesProviderModule {
-      @Provides Provider<Object> provideObject() {
-        return null;
-      }
-    }
-    try {
-      ObjectGraph.createWith(new TestingLoader(), new ProvidesProviderModule());
-      fail();
-    } catch (IllegalStateException e) {
-      assertThat(e.getMessage()) //
-          .startsWith("@Provides method must not return Provider directly: ")
-          .endsWith("ProvidesProviderModule.provideObject");
-    }
-  }
-
-  @Test public void provideRawProviderFails() {
-    @Module
-    class ProvidesRawProviderModule {
-      @Provides Provider provideObject() {
-        return null;
-      }
-    }
-    try {
-      ObjectGraph.createWith(new TestingLoader(), new ProvidesRawProviderModule());
-      fail();
-    } catch (IllegalStateException e) {
-      assertThat(e.getMessage()) //
-          .startsWith("@Provides method must not return Provider directly: ")
-          .endsWith("ProvidesRawProviderModule.provideObject");
-    }
-  }
-
-  @Test public void provideLazyFails() {
-    @Module
-    class ProvidesLazyModule {
-      @Provides Lazy<Object> provideObject() {
-        return null;
-      }
-    }
-    try {
-      ObjectGraph.createWith(new TestingLoader(), new ProvidesLazyModule());
-      fail();
-    } catch (IllegalStateException e) {
-      assertThat(e.getMessage()) //
-          .startsWith("@Provides method must not return Lazy directly: ")
-          .endsWith("ProvidesLazyModule.provideObject");
-    }
-  }
-
-  @Test public void provideRawLazyFails() {
-    @Module
-    class ProvidesRawLazyModule {
-      @Provides Lazy provideObject() {
-        return null;
-      }
-    }
-    try {
-      ObjectGraph.createWith(new TestingLoader(), new ProvidesRawLazyModule());
-      fail();
-    } catch (IllegalStateException e) {
-      assertThat(e.getMessage()) //
-          .startsWith("@Provides method must not return Lazy directly: ")
-          .endsWith("ProvidesRawLazyModule.provideObject");
-    }
-  }
-}
diff --git a/core/src/test/java/dagger/ProblemDetectorTest.java b/core/src/test/java/dagger/ProblemDetectorTest.java
deleted file mode 100644
index a6b7c43c1..000000000
--- a/core/src/test/java/dagger/ProblemDetectorTest.java
+++ /dev/null
@@ -1,90 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger;
-
-import dagger.internal.TestingLoader;
-import javax.inject.Inject;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-import static org.junit.Assert.fail;
-
-@RunWith(JUnit4.class)
-public final class ProblemDetectorTest {
-  @Test public void atInjectCircularDependenciesDetected() {
-    class TestEntryPoint {
-      @Inject Rock rock;
-    }
-
-    @Module(injects = TestEntryPoint.class)
-    class TestModule {
-    }
-
-    ObjectGraph graph = ObjectGraph.createWith(new TestingLoader(), new TestModule());
-    try {
-      graph.validate();
-      fail();
-    } catch (RuntimeException expected) {
-    }
-  }
-
-  @Test public void providesCircularDependenciesDetected() {
-    @Module
-    class TestModule {
-      @Provides Integer provideInteger(String s) {
-        throw new AssertionError();
-      }
-      @Provides String provideString(Integer i) {
-        throw new AssertionError();
-      }
-    }
-
-    ObjectGraph graph = ObjectGraph.createWith(new TestingLoader(), new TestModule());
-    try {
-      graph.validate();
-      fail();
-    } catch (RuntimeException expected) {
-    }
-  }
-
-  @Test public void validateLazy() {
-    @Module(library = true)
-    class TestModule {
-      @Provides Integer dependOnLazy(Lazy<String> lazyString) {
-        throw new AssertionError();
-      }
-      @Provides String provideLazyValue() {
-        throw new AssertionError();
-      }
-    }
-
-    ObjectGraph graph = ObjectGraph.createWith(new TestingLoader(), new TestModule());
-    graph.validate();
-  }
-
-  static class Rock {
-    @Inject Scissors scissors;
-  }
-
-  static class Scissors {
-    @Inject Paper paper;
-  }
-
-  static class Paper {
-    @Inject Rock rock;
-  }
-}
diff --git a/core/src/test/java/dagger/ReflectiveLoaderTest.java b/core/src/test/java/dagger/ReflectiveLoaderTest.java
deleted file mode 100644
index c15d0e623..000000000
--- a/core/src/test/java/dagger/ReflectiveLoaderTest.java
+++ /dev/null
@@ -1,279 +0,0 @@
-/*
- * Copyright (C) 2012 Square Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger;
-
-import dagger.internal.Loader;
-import dagger.internal.ReflectiveLoader;
-import javax.inject.Inject;
-import javax.inject.Provider;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-import static org.fest.assertions.Assertions.assertThat;
-import static org.junit.Assert.fail;
-
-/**
- * @deprecated This exists to test ReflectiveLoader which is obsolete but needed to work around
- *     proguard obfuscation.
- */
-@Deprecated
-@RunWith(JUnit4.class)
-public final class ReflectiveLoaderTest {
-  private static final Loader LOADER = new ReflectiveLoader();
-
-  static class TestEntryPoint {
-    @Inject String s;
-  }
-
-  @Module(injects = TestEntryPoint.class)
-  static class ModuleWithEntryPoint {
-  }
-
-  @Test public void childModuleWithEntryPoint() {
-    @Module(includes = ModuleWithEntryPoint.class)
-    class TestModule {
-      @Provides String provideString() {
-        return "injected";
-      }
-    }
-
-    ObjectGraph objectGraph = ObjectGraph.createWith(LOADER, new TestModule());
-    TestEntryPoint entryPoint = objectGraph.get(TestEntryPoint.class);
-    assertThat(entryPoint.s).isEqualTo("injected");
-  }
-
-  static class TestStaticInjection {
-    @Inject static String s;
-  }
-
-  @Module(staticInjections = TestStaticInjection.class)
-  static class ModuleWithStaticInjection {
-  }
-
-  @Test public void childModuleWithStaticInjection() {
-    @Module(includes = ModuleWithStaticInjection.class)
-    class TestModule {
-      @Provides String provideString() {
-        return "injected";
-      }
-    }
-
-    ObjectGraph objectGraph = ObjectGraph.createWith(LOADER, new TestModule());
-    TestStaticInjection.s = null;
-    objectGraph.injectStatics();
-    assertThat(TestStaticInjection.s).isEqualTo("injected");
-  }
-
-  @Module
-  static class ModuleWithBinding {
-    @Provides String provideString() {
-      return "injected";
-    }
-  }
-
-  @Test public void childModuleWithBinding() {
-
-    @Module(
-        injects = TestEntryPoint.class,
-        includes = ModuleWithBinding.class
-    )
-    class TestModule {
-    }
-
-    ObjectGraph objectGraph = ObjectGraph.createWith(LOADER, new TestModule());
-    TestEntryPoint entryPoint = new TestEntryPoint();
-    objectGraph.inject(entryPoint);
-    assertThat(entryPoint.s).isEqualTo("injected");
-  }
-
-  @Module(includes = ModuleWithBinding.class)
-  static class ModuleWithChildModule {
-  }
-
-  @Test public void childModuleWithChildModule() {
-
-    @Module(
-        injects = TestEntryPoint.class,
-        includes = ModuleWithChildModule.class
-    )
-    class TestModule {
-    }
-
-    ObjectGraph objectGraph = ObjectGraph.createWith(LOADER, new TestModule());
-    TestEntryPoint entryPoint = new TestEntryPoint();
-    objectGraph.inject(entryPoint);
-    assertThat(entryPoint.s).isEqualTo("injected");
-  }
-
-  @Module
-  static class ModuleWithConstructor {
-    private final String value;
-
-    ModuleWithConstructor(String value) {
-      this.value = value;
-    }
-
-    @Provides String provideString() {
-      return value;
-    }
-  }
-
-  @Test public void childModuleMissingManualConstruction() {
-    @Module(includes = ModuleWithConstructor.class)
-    class TestModule {
-    }
-
-    try {
-      ObjectGraph.createWith(LOADER, new TestModule());
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void childModuleWithManualConstruction() {
-
-    @Module(
-        injects = TestEntryPoint.class,
-        includes = ModuleWithConstructor.class
-    )
-    class TestModule {
-    }
-
-    ObjectGraph objectGraph = ObjectGraph.createWith(LOADER, new ModuleWithConstructor("a"), new TestModule());
-    TestEntryPoint entryPoint = new TestEntryPoint();
-    objectGraph.inject(entryPoint);
-    assertThat(entryPoint.s).isEqualTo("a");
-  }
-
-  static class A {}
-
-  static class B { @Inject A a; }
-
-  @Module(injects = A.class) public static class TestModuleA {
-    @Provides A a() { return new A(); }
-  }
-
-  @Module(includes = TestModuleA.class, injects = B.class) public static class TestModuleB {}
-
-  @Test public void autoInstantiationOfModules() {
-    // Have to make these non-method-scoped or instantiation errors occur.
-    ObjectGraph objectGraph = ObjectGraph.createWith(LOADER, TestModuleA.class);
-    assertThat(objectGraph.get(A.class)).isNotNull();
-  }
-
-  @Test public void autoInstantiationOfIncludedModules() {
-    // Have to make these non-method-scoped or instantiation errors occur.
-    ObjectGraph objectGraph = ObjectGraph.createWith(LOADER, new TestModuleB()); // TestModuleA auto-created.
-    assertThat(objectGraph.get(A.class)).isNotNull();
-    assertThat(objectGraph.get(B.class).a).isNotNull();
-  }
-
-  static class ModuleMissingModuleAnnotation {}
-
-  @Module(includes = ModuleMissingModuleAnnotation.class)
-  static class ChildModuleMissingModuleAnnotation {}
-
-  @Test
-  public void childModuleMissingModuleAnnotation() {
-    try {
-      ObjectGraph.createWith(LOADER, new ChildModuleMissingModuleAnnotation());
-    } catch (IllegalArgumentException e) {
-      assertThat(e.getMessage())
-          .contains("No @Module on ").contains("ModuleMissingModuleAnnotation");
-    }
-  }
-
-  @Module
-  static class ThreadModule extends Thread {}
-
-  @Test public void moduleExtendingClassThrowsException() {
-    try {
-      ObjectGraph.createWith(LOADER, new ThreadModule());
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e.getMessage()).startsWith("Modules must not extend from other classes: ");
-    }
-  }
-
-  @Test public void provideProviderFails() {
-    @Module
-    class ProvidesProviderModule {
-      @Provides Provider<Object> provideObject() {
-        return null;
-      }
-    }
-    try {
-      ObjectGraph.createWith(LOADER, new ProvidesProviderModule());
-      fail();
-    } catch (IllegalStateException e) {
-      assertThat(e.getMessage()) //
-          .startsWith("@Provides method must not return Provider directly: ")
-          .endsWith("ProvidesProviderModule.provideObject");
-    }
-  }
-
-  @Test public void provideRawProviderFails() {
-    @Module
-    class ProvidesRawProviderModule {
-      @Provides Provider provideObject() {
-        return null;
-      }
-    }
-    try {
-      ObjectGraph.createWith(LOADER, new ProvidesRawProviderModule());
-      fail();
-    } catch (IllegalStateException e) {
-      assertThat(e.getMessage()) //
-          .startsWith("@Provides method must not return Provider directly: ")
-          .endsWith("ProvidesRawProviderModule.provideObject");
-    }
-  }
-
-  @Test public void provideLazyFails() {
-    @Module
-    class ProvidesLazyModule {
-      @Provides Lazy<Object> provideObject() {
-        return null;
-      }
-    }
-    try {
-      ObjectGraph.createWith(LOADER, new ProvidesLazyModule());
-      fail();
-    } catch (IllegalStateException e) {
-      assertThat(e.getMessage()) //
-          .startsWith("@Provides method must not return Lazy directly: ")
-          .endsWith("ProvidesLazyModule.provideObject");
-    }
-  }
-
-  @Test public void provideRawLazyFails() {
-    @Module
-    class ProvidesRawLazyModule {
-      @Provides Lazy provideObject() {
-        return null;
-      }
-    }
-    try {
-      ObjectGraph.createWith(LOADER, new ProvidesRawLazyModule());
-      fail();
-    } catch (IllegalStateException e) {
-      assertThat(e.getMessage()) //
-          .startsWith("@Provides method must not return Lazy directly: ")
-          .endsWith("ProvidesRawLazyModule.provideObject");
-    }
-  }
-}
diff --git a/core/src/test/java/dagger/SetBindingTest.java b/core/src/test/java/dagger/SetBindingTest.java
deleted file mode 100644
index 268c1162b..000000000
--- a/core/src/test/java/dagger/SetBindingTest.java
+++ /dev/null
@@ -1,339 +0,0 @@
-/*
- * Copyright (C) 2012 Google Inc.
- * Copyright (C) 2012 Square Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger;
-
-import dagger.internal.TestingLoader;
-import java.io.PrintWriter;
-import java.io.StringWriter;
-import java.util.Arrays;
-import java.util.LinkedHashSet;
-import java.util.Set;
-import java.util.concurrent.atomic.AtomicInteger;
-import java.util.concurrent.atomic.AtomicReference;
-import javax.inject.Inject;
-import javax.inject.Named;
-import javax.inject.Singleton;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-import static dagger.Provides.Type.SET;
-import static dagger.Provides.Type.SET_VALUES;
-import static java.util.Collections.emptySet;
-import static org.fest.assertions.Assertions.assertThat;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.fail;
-
-@RunWith(JUnit4.class)
-public final class SetBindingTest {
-  @Test public void multiValueBindings_SingleModule() {
-    class TestEntryPoint {
-      @Inject Set<String> strings;
-    }
-
-    @Module(injects = TestEntryPoint.class)
-    class TestModule {
-      @Provides(type=SET) String provideFirstString() { return "string1"; }
-      @Provides(type=SET) String provideSecondString() { return "string2"; }
-    }
-
-    TestEntryPoint ep = injectWithModule(new TestEntryPoint(), new TestModule());
-    assertEquals(set("string1", "string2"), ep.strings);
-  }
-
-  @Test public void multiValueBindings_MultiModule() {
-    class TestEntryPoint {
-      @Inject Set<String> strings;
-    }
-
-    @Module
-    class TestIncludesModule {
-      @Provides(type=SET) String provideSecondString() { return "string2"; }
-    }
-
-    @Module(injects = TestEntryPoint.class, includes = TestIncludesModule.class)
-    class TestModule {
-      @Provides(type=SET) String provideFirstString() { return "string1"; }
-
-      @Provides(type=SET_VALUES) Set<String> provideDefaultStrings() {
-        return emptySet();
-      }
-    }
-
-    TestEntryPoint ep = injectWithModule(new TestEntryPoint(),
-        new TestModule(), new TestIncludesModule());
-    assertEquals(set("string1", "string2"), ep.strings);
-  }
-
-  @Test public void multiValueBindings_MultiModule_NestedSet() {
-    class TestEntryPoint {
-      @Inject Set<Set<String>> stringses;
-    }
-
-    @Module
-    class TestIncludesModule {
-      @Provides(type=SET) Set<String> provideSecondStrings() { return set("string2"); }
-    }
-
-    @Module(injects = TestEntryPoint.class, includes = TestIncludesModule.class)
-    class TestModule {
-      @Provides(type=SET) Set<String> provideFirstStrings() { return set("string1"); }
-
-      @Provides(type=SET_VALUES) Set<Set<String>> provideDefaultStringeses() {
-        return set(set("string3"));
-      }
-    }
-
-    TestEntryPoint ep = injectWithModule(new TestEntryPoint(),
-        new TestModule(), new TestIncludesModule());
-    assertEquals(set(set("string1"),set("string2"), set("string3")), ep.stringses);
-  }
-
-  @Test public void multiValueBindings_WithSingletonAndDefaultValues() {
-    final AtomicInteger singletonCounter = new AtomicInteger(100);
-    final AtomicInteger defaultCounter = new AtomicInteger(200);
-    class TestEntryPoint {
-      @Inject Set<Integer> objects1;
-      @Inject Set<Integer> objects2;
-    }
-
-    @Module(injects = TestEntryPoint.class)
-    class TestModule {
-      @Provides(type=SET) @Singleton Integer a() { return singletonCounter.getAndIncrement(); }
-      @Provides(type=SET) Integer b() { return defaultCounter.getAndIncrement(); }
-    }
-
-    TestEntryPoint ep = injectWithModule(new TestEntryPoint(), new TestModule());
-    assertEquals(set(100, 200), ep.objects1);
-    assertEquals(set(100, 201), ep.objects2);
-  }
-
-  @Test public void multiValueBindings_WithSingletonsAcrossMultipleInjectableTypes() {
-    final AtomicInteger singletonCounter = new AtomicInteger(100);
-    final AtomicInteger defaultCounter = new AtomicInteger(200);
-    class TestEntryPoint1 {
-      @Inject Set<Integer> objects1;
-    }
-    class TestEntryPoint2 {
-      @Inject Set<Integer> objects2;
-    }
-
-    @Module(injects = { TestEntryPoint1.class, TestEntryPoint2.class })
-    class TestModule {
-      @Provides(type=SET) @Singleton Integer a() { return singletonCounter.getAndIncrement(); }
-      @Provides(type=SET) Integer b() { return defaultCounter.getAndIncrement(); }
-    }
-
-    ObjectGraph graph = ObjectGraph.createWith(new TestingLoader(), new TestModule());
-    TestEntryPoint1 ep1 = graph.inject(new TestEntryPoint1());
-    TestEntryPoint2 ep2 = graph.inject(new TestEntryPoint2());
-    assertEquals(set(100, 200), ep1.objects1);
-    assertEquals(set(100, 201), ep2.objects2);
-
- }
-
-  @Test public void multiValueBindings_WithQualifiers() {
-    class TestEntryPoint {
-      @Inject Set<String> strings;
-      @Inject @Named("foo") Set<String> fooStrings;
-    }
-
-    @Module(injects = TestEntryPoint.class)
-    class TestModule {
-      @Provides(type=SET_VALUES) Set<String> provideString1() {
-        return set("string1");
-      }
-      @Provides(type=SET) String provideString2() { return "string2"; }
-      @Provides(type=SET) @Named("foo") String provideString3() { return "string3"; }
-      @Provides(type=SET_VALUES) @Named("foo") Set<String> provideString4() {
-        return set("string4");
-      }
-    }
-
-    TestEntryPoint ep = injectWithModule(new TestEntryPoint(), new TestModule());
-    assertEquals(set("string1", "string2"), ep.strings);
-    assertEquals(set("string4", "string3"), ep.fooStrings);
-  }
-
-  // TODO(user): Move this into an example project.
-  @Test public void sampleMultiBindingLogger() {
-    class TestEntryPoint {
-      @Inject Logger logger;
-      public void doStuff() {
-        Throwable t = new NullPointerException("Naughty Naughty");
-        this.logger.log("Logging an error", t);
-      }
-    }
-
-    final AtomicReference<String> logoutput = new AtomicReference<String>();
-    @Module
-    class LogModule {
-      @Provides(type=SET) LogSink outputtingLogSink() {
-        return new LogSink() {
-          @Override public void log(LogMessage message) {
-            StringWriter sw = new StringWriter();
-            message.error.printStackTrace(new PrintWriter(sw));
-            logoutput.set(message.message + "\n" + sw.getBuffer().toString());
-          }
-        };
-      }
-    }
-    @Module(injects = TestEntryPoint.class)
-    class TestModule {
-      @Provides(type=SET) LogSink nullLogger() {
-        return new LogSink() { @Override public void log(LogMessage message) {} };
-      }
-    }
-
-    TestEntryPoint ep = injectWithModule(new TestEntryPoint(),new TestModule(), new LogModule());
-    assertNull(logoutput.get());
-    ep.doStuff();
-    assertNotNull(logoutput.get());
-    assertThat(logoutput.get()).contains("Naughty Naughty");
-    assertThat(logoutput.get()).contains("NullPointerException");
-  }
-
-  @Test public void duplicateValuesContributed() {
-    class TestEntryPoint {
-      @Inject Set<String> strings;
-    }
-
-    @Module(injects = TestEntryPoint.class)
-    class TestModule {
-      @Provides(type=SET) String provideString1() { return "a"; }
-      @Provides(type=SET) String provideString2() { return "a"; }
-      @Provides(type=SET) String provideString3() { return "b"; }
-    }
-
-    TestEntryPoint ep = injectWithModule(new TestEntryPoint(), new TestModule());
-    assertThat(ep.strings).containsOnly("a", "b");
-  }
-
-  @Test public void validateSetBinding() {
-    class TestEntryPoint {
-      @Inject Set<String> strings;
-    }
-
-    @Module(injects = TestEntryPoint.class)
-    class TestModule {
-      @Provides(type=SET) String provideString1() { return "string1"; }
-      @Provides(type=SET) String provideString2() { return "string2"; }
-    }
-
-    ObjectGraph graph = ObjectGraph.createWith(new TestingLoader(), new TestModule());
-    graph.validate();
-  }
-
-  @Test public void validateEmptySetBinding() {
-    class TestEntryPoint {
-      @Inject Set<String> strings;
-    }
-
-    @Module(injects = TestEntryPoint.class)
-    class TestModule {
-      @Provides(type=SET_VALUES) Set<String> provideDefault() {
-        return emptySet();
-      }
-    }
-
-    ObjectGraph graph = ObjectGraph.createWith(new TestingLoader(), new TestModule());
-    graph.validate();
-  }
-
-  @Test public void validateLibraryModules() {
-    class TestEntryPoint {}
-
-    @Module(library = true)
-    class SetModule {
-      @Provides(type = SET)
-      public String provideString() {
-        return "";
-      }
-    }
-
-    @Module(injects = TestEntryPoint.class, includes = SetModule.class)
-    class TestModule {}
-
-    ObjectGraph graph = ObjectGraph.createWith(new TestingLoader(),
-        new TestModule(), new SetModule());
-    graph.validate();
-  }
-
-  @Test public void validateLibraryModules_nonLibraryContributors() {
-    class TestEntryPoint {}
-
-    @Module(library = true)
-    class SetModule1 {
-      @Provides(type = SET)
-      public String provideString() {
-        return "a";
-      }
-    }
-
-    @Module(library = false)
-    class SetModule2 {
-      @Provides(type = SET)
-      public String provideString() {
-        return "b";
-      }
-    }
-
-    @Module(injects = TestEntryPoint.class, includes = { SetModule1.class, SetModule2.class })
-    class TestModule {}
-
-    ObjectGraph graph = ObjectGraph.createWith(new TestingLoader(),
-        new TestModule(), new SetModule1(), new SetModule2());
-    try {
-      graph.validate();
-      fail("Should have failed validation.");
-    } catch (IllegalStateException expected) {}
-  }
-
-  static class Logger {
-    @Inject Set<LogSink> loggers;
-    public void log(String text, Throwable error) {
-      LogMessage m = new LogMessage(text, error);
-      for (LogSink sink : loggers) {
-        sink.log(m);
-      }
-    }
-  }
-
-  static class LogMessage {
-    public final String message;
-    public final Throwable error;
-    public LogMessage (String message, Throwable error) {
-      this.message = message;
-      this.error = error;
-    }
-  }
-
-  static interface LogSink {
-    void log(LogMessage message);
-  }
-
-  private <T> T injectWithModule(T ep, Object ... modules) {
-    return ObjectGraph.createWith(new TestingLoader(), modules).inject(ep);
-  }
-
-  private <T> Set<T> set(T... ts) {
-    return new LinkedHashSet<T>(Arrays.asList(ts));
-  }
-
-}
diff --git a/core/src/test/java/dagger/ThreadSafetyTest.java b/core/src/test/java/dagger/ThreadSafetyTest.java
deleted file mode 100644
index a92d4c51a..000000000
--- a/core/src/test/java/dagger/ThreadSafetyTest.java
+++ /dev/null
@@ -1,114 +0,0 @@
-/*
- * Copyright (C) 2013 Google Inc.
- * Copyright (C) 2013 Square Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger;
-
-import dagger.internal.TestingLoader;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.concurrent.Callable;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-import java.util.concurrent.Future;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicInteger;
-import javax.inject.Inject;
-import javax.inject.Singleton;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-import static org.fest.assertions.Assertions.assertThat;
-
-/**
- * Test Singleton and Lazy bindings for thread-safety.
- */
-@RunWith(JUnit4.class)
-public final class ThreadSafetyTest {
-  private static final Integer FIRST_VALUE = 0;
-  private static final int THREAD_COUNT = 100;
-
-  private final ExecutorService es = Executors.newFixedThreadPool(THREAD_COUNT);
-  private final CountDownLatch latch = new CountDownLatch(THREAD_COUNT + 1);
-
-  static class LazyEntryPoint {
-    @Inject Lazy<Integer> lazy;
-  }
-
-  @Module(injects = { Long.class, LazyEntryPoint.class })
-  static class LatchingModule {
-    private final AtomicInteger count = new AtomicInteger(FIRST_VALUE);
-    private final CountDownLatch latch;
-    LatchingModule(CountDownLatch latch) {
-      this.latch = latch;
-    }
-
-    @Provides @Singleton Long provideLong() {
-      return Long.valueOf(provideInteger());
-    }
-
-    @Provides Integer provideInteger() {
-      try {
-        latch.await();
-      } catch (InterruptedException e) {
-        throw new AssertionError("Interrupted Thread!!");
-      }
-      return count.getAndIncrement();
-    }
-  }
-
-  @Test public void concurrentSingletonAccess() throws Exception {
-    final List<Future<Long>> futures = new ArrayList<Future<Long>>();
-    final ObjectGraph graph =
-        ObjectGraph.createWith(new TestingLoader(), new LatchingModule(latch));
-    for (int i = 0; i < THREAD_COUNT; i++) {
-      futures.add(es.submit(new Callable<Long>() {
-        @Override public Long call() {
-          latch.countDown();
-          return graph.get(Long.class);
-        }
-      }));
-    }
-    latch.countDown();
-    for (Future<Long> future : futures) {
-      assertThat(future.get(1, TimeUnit.SECONDS))
-          .overridingErrorMessage("Lock failure - count should never increment")
-          .isEqualTo(0);
-    }
-  }
-
-  @Test public void concurrentLazyAccess() throws Exception {
-    final List<Future<Integer>> futures = new ArrayList<Future<Integer>>();
-    final ObjectGraph graph =
-        ObjectGraph.createWith(new TestingLoader(), new LatchingModule(latch));
-    final LazyEntryPoint lep = graph.get(LazyEntryPoint.class);
-    for (int i = 0; i < THREAD_COUNT; i++) {
-      futures.add(es.submit(new Callable<Integer>() {
-        @Override public Integer call() {
-          latch.countDown();
-          return lep.lazy.get();
-        }
-      }));
-    }
-    latch.countDown();
-    for (Future<Integer> future : futures) {
-      assertThat(future.get(1, TimeUnit.SECONDS))
-          .overridingErrorMessage("Lock failure - count should never increment")
-          .isEqualTo(0);
-    }
-  }
-}
diff --git a/core/src/test/java/dagger/UnusedProviderTest.java b/core/src/test/java/dagger/UnusedProviderTest.java
deleted file mode 100644
index 377eec46b..000000000
--- a/core/src/test/java/dagger/UnusedProviderTest.java
+++ /dev/null
@@ -1,116 +0,0 @@
-/*
- * Copyright (C) 2013 Square Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger;
-
-import dagger.internal.TestingLoader;
-import java.util.Set;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-import static org.junit.Assert.fail;
-
-@RunWith(JUnit4.class)
-public class UnusedProviderTest {
-
-  @Test public void unusedProvidesMethod_whenModuleLibrary_passes() throws Exception {
-    class EntryPoint {
-    }
-    class BagOfMoney {
-    }
-    @Module(injects = EntryPoint.class, library = true) class TestModule {
-      @Provides BagOfMoney providesMoney() {
-        return new BagOfMoney();
-      }
-    }
-
-    ObjectGraph graph = ObjectGraph.createWith(new TestingLoader(), new TestModule());
-    graph.validate();
-  }
-
-  @Test public void unusedProviderMethod_whenNotLibraryModule_fails() throws Exception {
-    class EntryPoint {
-    }
-    class BagOfMoney {
-    }
-
-    @Module(injects = EntryPoint.class, library = false) class TestModule {
-      @Provides BagOfMoney providesMoney() {
-        return new BagOfMoney();
-      }
-    }
-
-    try {
-      ObjectGraph graph = ObjectGraph.createWith(new TestingLoader(), new TestModule());
-      graph.validate();
-      fail("Validation should have exploded!");
-    } catch (IllegalStateException expected) {
-    }
-  }
-
-  @Test public void whenLibraryModulePlussedToNecessaryModule_shouldNotFailOnUnusedLibraryModule()
-      throws Exception {
-    class EntryPoint {
-    }
-    class BagOfMoney {
-    }
-
-    @Module(injects = EntryPoint.class, library = true) class ExampleLibraryModule {
-      @Provides BagOfMoney providesMoney() {
-        return new BagOfMoney();
-      }
-    }
-
-    @Module(injects = EntryPoint.class) class TestModule {
-    }
-
-    ObjectGraph graph = ObjectGraph.createWith(new TestingLoader(), new TestModule());
-    graph = graph.plus(new ExampleLibraryModule());
-    graph.validate();
-  }
-
-  @Test public void unusedSetBinding() throws Exception {
-    @Module(library = false)
-    class TestModule {
-      @Provides(type = Provides.Type.SET) String provideA() {
-        throw new AssertionError();
-      }
-    }
-
-    ObjectGraph graph = ObjectGraph.createWith(new TestingLoader(), new TestModule());
-    try {
-      graph.validate();
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-  }
-
-  @Test public void unusedSetValuesBinding() throws Exception {
-    @Module(library = false)
-    class TestModule {
-      @Provides(type = Provides.Type.SET_VALUES) Set<String> provideA() {
-        throw new AssertionError();
-      }
-    }
-
-    ObjectGraph graph = ObjectGraph.createWith(new TestingLoader(), new TestModule());
-    try {
-      graph.validate();
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-  }
-}
diff --git a/core/src/test/java/dagger/internal/FailoverLoaderTest.java b/core/src/test/java/dagger/internal/FailoverLoaderTest.java
deleted file mode 100644
index e48198d74..000000000
--- a/core/src/test/java/dagger/internal/FailoverLoaderTest.java
+++ /dev/null
@@ -1,57 +0,0 @@
-/*
- * Copyright (C) 2013 Google Inc.
- * Copyright (C) 2013 Square Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal;
-
-import dagger.Module;
-import dagger.ObjectGraph;
-import dagger.Provides;
-import javax.inject.Inject;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-import static org.fest.assertions.Assertions.assertThat;
-
-/**
- * A test case to deal with fall-back to reflection where an inject adapter has not
- * been generated.
- */
-@RunWith(JUnit4.class)
-public final class FailoverLoaderTest {
-
-  @Module(injects = EntryPoint.class)
-  static class TestModule {
-    @Provides String aString() { return "a"; }
-  }
-
-  /** A reflective module that will be loaded in place of a generated module for this test. */
-  static final class TestModule$$ModuleAdapter extends TestingModuleAdapter<TestModule> {
-    public TestModule$$ModuleAdapter() {
-      super(TestModule.class, TestModule.class.getAnnotation(Module.class));
-    }
-  }
-
-  static class EntryPoint {
-    @Inject String a;
-  }
-
-  @Test public void simpleInjectionWithUnGeneratedCode() {
-    EntryPoint entryPoint = new EntryPoint();
-    ObjectGraph.create(new TestModule()).inject(entryPoint);
-    assertThat(entryPoint.a).isEqualTo("a");
-  }
-}
diff --git a/core/src/test/java/dagger/internal/KeysTest.java b/core/src/test/java/dagger/internal/KeysTest.java
deleted file mode 100644
index d01256055..000000000
--- a/core/src/test/java/dagger/internal/KeysTest.java
+++ /dev/null
@@ -1,153 +0,0 @@
-/**
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal;
-
-import dagger.Lazy;
-import dagger.MembersInjector;
-import dagger.Provides;
-import java.lang.reflect.Field;
-import java.lang.reflect.Method;
-import java.util.List;
-import java.util.Map;
-import javax.inject.Named;
-import javax.inject.Provider;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-import static dagger.Provides.Type.SET;
-import static org.fest.assertions.Assertions.assertThat;
-
-@RunWith(JUnit4.class)
-public final class KeysTest {
-  int primitive;
-  @Test public void lonePrimitiveGetsBoxed() throws NoSuchFieldException {
-    assertThat(fieldKey("primitive"))
-        .isEqualTo("java.lang.Integer");
-  }
-
-  Map<String, List<Integer>> mapStringListInteger;
-  @Test public void parameterizedTypes() throws NoSuchFieldException {
-    assertThat(fieldKey("mapStringListInteger"))
-        .isEqualTo("java.util.Map<java.lang.String, java.util.List<java.lang.Integer>>");
-  }
-
-  Map<String, int[]> mapStringArrayInt;
-  @Test public void parameterizedTypeOfPrimitiveArray() throws NoSuchFieldException {
-    assertThat(fieldKey("mapStringArrayInt"))
-        .isEqualTo("java.util.Map<java.lang.String, int[]>");
-  }
-
-  @Named("foo") String annotatedType;
-  @Test public void annotatedType() throws NoSuchFieldException {
-    assertThat(fieldKey("annotatedType"))
-        .isEqualTo("@javax.inject.Named(value=foo)/java.lang.String");
-  }
-
-  String className;
-  @Test public void testGetClassName() throws NoSuchFieldException {
-    assertThat(Keys.getClassName(fieldKey("className")))
-        .isEqualTo("java.lang.String");
-  }
-
-  @Named("foo") String classNameWithAnnotation;
-  @Test public void testGetClassNameWithoutAnnotation() throws NoSuchFieldException {
-    assertThat(Keys.getClassName(fieldKey("classNameWithAnnotation")))
-        .isEqualTo("java.lang.String");
-  }
-
-  String[] classNameArray;
-  @Test public void testGetClassNameArray() throws NoSuchFieldException {
-    assertThat(Keys.getClassName(fieldKey("classNameArray"))).isNull();
-  }
-
-  List<String> classNameParameterized;
-  @Test public void testGetClassParameterized() throws NoSuchFieldException {
-    assertThat(Keys.getClassName(fieldKey("classNameParameterized"))).isNull();
-  }
-
-  @Named("foo") String annotated;
-  @Test public void testAnnotated() throws NoSuchFieldException {
-    assertThat(fieldKey("annotated")).isEqualTo("@javax.inject.Named(value=foo)/java.lang.String");
-    assertThat(Keys.isAnnotated(fieldKey("annotated"))).isTrue();
-  }
-
-  String notAnnotated;
-  @Test public void testIsAnnotatedFalse() throws NoSuchFieldException {
-    assertThat(Keys.isAnnotated(fieldKey("notAnnotated"))).isFalse();
-  }
-
-  Provider<String> providerOfType;
-  String providedType;
-  @Test public void testGetDelegateKey() throws NoSuchFieldException {
-    assertThat(Keys.getBuiltInBindingsKey(fieldKey("providerOfType")))
-        .isEqualTo(fieldKey("providedType"));
-  }
-
-  @Named("/@") Provider<String> providerOfTypeAnnotated;
-  @Named("/@") String providedTypeAnnotated;
-  @Test public void testGetDelegateKeyWithAnnotation() throws NoSuchFieldException {
-    assertThat(Keys.getBuiltInBindingsKey(fieldKey("providerOfTypeAnnotated")))
-        .isEqualTo(fieldKey("providedTypeAnnotated"));
-  }
-
-  @Named("/@") MembersInjector<String> membersInjectorOfType;
-  @Named("/@") String injectedType;
-  @Test public void testGetDelegateKeyWithMembersInjector() throws NoSuchFieldException {
-    assertThat(Keys.getBuiltInBindingsKey(fieldKey("membersInjectorOfType")))
-        .isEqualTo("members/java.lang.String");
-  }
-
-  @Named("/@") Lazy<String> lazyAnnotatedString;
-  @Named("/@") String eagerAnnotatedString;
-  @Test public void testAnnotatedGetLazyKey() throws NoSuchFieldException {
-    assertThat(Keys.getLazyKey(fieldKey("lazyAnnotatedString")))
-        .isEqualTo(fieldKey("eagerAnnotatedString"));
-  }
-
-  Lazy<String> lazyString;
-  String eagerString;
-  @Test public void testGetLazyKey() throws NoSuchFieldException {
-    assertThat(Keys.getLazyKey(fieldKey("lazyString"))).isEqualTo(fieldKey("eagerString"));
-  }
-
-  @Test public void testGetLazyKey_WrongKeyType() throws NoSuchFieldException {
-    assertThat(Keys.getLazyKey(fieldKey("providerOfTypeAnnotated"))).isNull();
-  }
-
-  @Provides(type=SET) String elementProvides() { return "foo"; }
-
-  @Test public void testGetElementKey_NoQualifier() throws NoSuchMethodException {
-    Method method = KeysTest.class.getDeclaredMethod("elementProvides", new Class<?>[]{});
-    assertThat(Keys.getSetKey(method.getGenericReturnType(), method.getAnnotations(), method))
-        .isEqualTo("java.util.Set<java.lang.String>");
-  }
-
-  @Named("foo")
-  @Provides(type=SET) String qualifiedElementProvides() { return "foo"; }
-
-  @Test public void testGetElementKey_WithQualifier() throws NoSuchMethodException {
-    Method method = KeysTest.class.getDeclaredMethod("qualifiedElementProvides", new Class<?>[]{});
-    assertThat(Keys.getSetKey(method.getGenericReturnType(), method.getAnnotations(), method))
-        .isEqualTo("@javax.inject.Named(value=foo)/java.util.Set<java.lang.String>");
-  }
-
-  private String fieldKey(String fieldName) throws NoSuchFieldException {
-    Field field = KeysTest.class.getDeclaredField(fieldName);
-    return Keys.get(field.getGenericType(), field.getAnnotations(), field);
-  }
-
-}
diff --git a/core/src/test/java/dagger/internal/MapProviderFactoryTest.java b/core/src/test/java/dagger/internal/MapProviderFactoryTest.java
index e14402172..337ebc112 100644
--- a/core/src/test/java/dagger/internal/MapProviderFactoryTest.java
+++ b/core/src/test/java/dagger/internal/MapProviderFactoryTest.java
@@ -69,7 +69,10 @@ public void iterationOrder() {
     expectedMap.put("three", p3);
     expectedMap.put("one", p5);
     expectedMap.put("four", p4);
-    assert_().that(factory.get().entrySet()).iteratesAs(expectedMap.entrySet());
+    assert_()
+        .that(factory.get().entrySet())
+        .containsExactlyElementsIn(expectedMap.entrySet())
+        .inOrder();
   }
 
   private static Provider<Integer> incrementingIntegerProvider(int seed) {
diff --git a/core/src/test/java/dagger/internal/SingletonBindingTest.java b/core/src/test/java/dagger/internal/SingletonBindingTest.java
deleted file mode 100644
index 85f736509..000000000
--- a/core/src/test/java/dagger/internal/SingletonBindingTest.java
+++ /dev/null
@@ -1,77 +0,0 @@
-/**
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-import static org.fest.assertions.Assertions.assertThat;
-
-@RunWith(JUnit4.class)
-public final class SingletonBindingTest {
-  private Binding<String> wrappedBinding;
-  private Binding<String> singletonBinding;
-
-  @Before public void setUp() {
-    wrappedBinding = new StringBinding();
-    singletonBinding = Linker.scope(wrappedBinding);
-  }
-
-  @Test public void testSingletonBindingIsSingleton() {
-    assertThat(singletonBinding.isSingleton()).isTrue();
-  }
-
-  // This next batch of tests validates that SingletonBinding consistently delegates to the wrapped binding for state.
-  @Test public void testSingletonBindingDelegatesSetLinked() {
-    singletonBinding.setLinked();
-    assertThat(wrappedBinding.isLinked()).isTrue();
-  }
-
-  @Test public void testSingletonBindingDelegatesIsLinked() {
-    wrappedBinding.setLinked();
-    assertThat(singletonBinding.isLinked()).isTrue();
-  }
-
-  @Test public void testSingletonBindingDelegatesSetVisiting() {
-    singletonBinding.setVisiting(true);
-    assertThat(wrappedBinding.isVisiting()).isTrue();
-  }
-
-  @Test public void testSingletonBindingDelegatesIsVisiting() {
-    wrappedBinding.setVisiting(true);
-    assertThat(singletonBinding.isVisiting()).isTrue();
-  }
-
-  @Test public void testSingletonBindingDelegatesSetCycleFree() {
-    singletonBinding.setCycleFree(true);
-    assertThat(wrappedBinding.isCycleFree()).isTrue();
-  }
-
-  @Test public void testSingletonBindingDelegatesIsCycleFree() {
-    wrappedBinding.setCycleFree(true);
-    assertThat(singletonBinding.isCycleFree()).isTrue();
-  }
-
-  private static class StringBinding extends Binding<String> {
-    private StringBinding() {
-      super("dummy", "dummy", true, "dummy"); // 3rd arg true => singleton
-    }
-
-  }
-}
diff --git a/core/src/test/java/dagger/internal/TestingLoader.java b/core/src/test/java/dagger/internal/TestingLoader.java
deleted file mode 100644
index fd2996d1e..000000000
--- a/core/src/test/java/dagger/internal/TestingLoader.java
+++ /dev/null
@@ -1,49 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- * Copyright (C) 2013 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal;
-
-import dagger.internal.loaders.ReflectiveAtInjectBinding;
-import dagger.internal.loaders.ReflectiveStaticInjection;
-
-/**
- * A test-only loader that merely uses reflection to test internals.
- */
-public final class TestingLoader extends Loader {
-
-  @Override public <T> ModuleAdapter<T> getModuleAdapter(Class<T> type) {
-    ModuleAdapter<T> adapter = TestingModuleAdapter.create(type);
-    return adapter;
-  }
-
-  @Override public Binding<?> getAtInjectBinding(String key, String className, ClassLoader ignored,
-      boolean mustHaveInjections) {
-     try {
-      Class<?> type = getClass().getClassLoader().loadClass(className);
-      if (type.isInterface()) {
-        return null; // Short-circuit since we can't build reflective bindings for interfaces.
-      }
-      return ReflectiveAtInjectBinding.createFactory(type).create(mustHaveInjections);
-    } catch (ClassNotFoundException e) {
-      throw new TypeNotPresentException(
-          String.format("Could not find %s needed for binding %s", className, key), e);
-    }
-  }
-
-  @Override public StaticInjection getStaticInjection(Class<?> injectedClass) {
-    return ReflectiveStaticInjection.create(injectedClass);
-  }
-}
diff --git a/core/src/test/java/dagger/internal/TestingModuleAdapter.java b/core/src/test/java/dagger/internal/TestingModuleAdapter.java
deleted file mode 100644
index b5d54f095..000000000
--- a/core/src/test/java/dagger/internal/TestingModuleAdapter.java
+++ /dev/null
@@ -1,204 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal;
-
-import dagger.Lazy;
-import dagger.Module;
-import dagger.Provides;
-import java.lang.annotation.Annotation;
-import java.lang.reflect.Constructor;
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
-import java.lang.reflect.ParameterizedType;
-import java.lang.reflect.Type;
-import java.util.Set;
-import javax.inject.Provider;
-import javax.inject.Singleton;
-
-//TODO: Reduce the complexity of this and/or replace with a mock or fake.
-public class TestingModuleAdapter<M> extends ModuleAdapter<M> {
-  public TestingModuleAdapter(Class<M> moduleClass, Module annotation) {
-    super(
-        moduleClass,
-        injectableTypesToKeys(annotation.injects()),
-        annotation.staticInjections(),
-        annotation.overrides(),
-        annotation.includes(),
-        annotation.complete(),
-        annotation.library());
-  }
-
-  private static String[] injectableTypesToKeys(Class<?>[] injectableTypes) {
-    String[] result = new String[injectableTypes.length];
-    for (int i = 0; i < injectableTypes.length; i++) {
-      Class<?> injectableType = injectableTypes[i];
-      result[i] = injectableType.isInterface()
-          ? Keys.get(injectableType)
-          : Keys.getMembersKey(injectableType);
-    }
-    return result;
-  }
-
-  @Override public void getBindings(BindingsGroup bindings, M module) {
-    for (Class<?> c = moduleClass; !c.equals(Object.class); c = c.getSuperclass()) {
-      for (Method method : c.getDeclaredMethods()) {
-        Provides provides = method.getAnnotation(Provides.class);
-        if (provides != null) {
-          Type genericReturnType = method.getGenericReturnType();
-
-          Type typeToCheck = genericReturnType;
-          if (genericReturnType instanceof ParameterizedType) {
-            typeToCheck = ((ParameterizedType) genericReturnType).getRawType();
-          }
-          if (Provider.class.equals(typeToCheck)) {
-            throw new IllegalStateException("@Provides method must not return Provider directly: "
-                + c.getName()
-                + "."
-                + method.getName());
-          }
-          if (Lazy.class.equals(typeToCheck)) {
-            throw new IllegalStateException("@Provides method must not return Lazy directly: "
-                + c.getName()
-                + "."
-                + method.getName());
-          }
-
-          String key = Keys.get(genericReturnType, method.getAnnotations(), method);
-          switch (provides.type()) {
-            case UNIQUE:
-              handleBindings(bindings, module, method, key, library);
-              break;
-            case SET:
-              String setKey = Keys.getSetKey(method.getGenericReturnType(),
-                  method.getAnnotations(), method);
-              handleSetBindings(bindings, module, method, setKey, key, library);
-              break;
-            case SET_VALUES:
-              handleSetBindings(bindings, module, method, key, key, library);
-              break;
-            default:
-              throw new AssertionError("Unknown @Provides type " + provides.type());
-          }
-        }
-      }
-    }
-  }
-
-  private void handleBindings(BindingsGroup bindings, M module, Method method, String key,
-      boolean library) {
-    bindings.contributeProvidesBinding(key,
-        new ReflectiveProvidesBinding<M>(method, key, moduleClass.getName(), module, library));
-  }
-
-  private void handleSetBindings(BindingsGroup bindings, M module, Method method,
-      String setKey, String providerKey, boolean library) {
-    SetBinding.<M>add(bindings, setKey,
-        new ReflectiveProvidesBinding<M>(
-            method, providerKey, moduleClass.getName(), module, library));
-  }
-
-  @Override public M newModule() {
-    try {
-      Constructor<?> constructor = moduleClass.getDeclaredConstructor();
-      constructor.setAccessible(true);
-      return (M)constructor.newInstance();
-    } catch (InvocationTargetException e) {
-      throw new IllegalArgumentException(e.getCause());
-    } catch (NoSuchMethodException e) {
-      throw new IllegalArgumentException("Could not construct " + moduleClass.getName()
-          + " as it lacks an accessible no-args constructor. This module must be passed"
-          + " in as an instance, or an accessible no-args constructor must be added.", e);
-    } catch (InstantiationException e) {
-      throw new IllegalArgumentException("Failed to construct " + moduleClass.getName(), e);
-    } catch (IllegalAccessException e) {
-      throw new AssertionError();
-    }
-  }
-
-  @Override public String toString() {
-    return "TestingModuleAdapter[" + this.moduleClass.getName() + "]";
-  }
-
-  /**
-   * Creates a TestingModuleAdapter or throws an {@code IllegalArgumentException}.
-   */
-  public static <M> ModuleAdapter<M> create(Class<M> moduleClass) {
-    Module annotation = moduleClass.getAnnotation(Module.class);
-    if (annotation == null) {
-      throw new IllegalArgumentException("No @Module on " + moduleClass.getName());
-    }
-    if (!moduleClass.getSuperclass().equals(Object.class)) {
-      throw new IllegalArgumentException(
-          "Modules must not extend from other classes: " + moduleClass.getName());
-    }
-    return new TestingModuleAdapter<M>(moduleClass, annotation);
-  }
-
-  /**
-   * Invokes a method to provide a value. The method's parameters are injected.
-   */
-  private static final class ReflectiveProvidesBinding<T> extends ProvidesBinding<T> {
-    private Binding<?>[] parameters;
-    private final Method method;
-    private final Object instance;
-
-    public ReflectiveProvidesBinding(Method method, String key, String moduleClass,
-        Object instance, boolean library) {
-      super(key, method.isAnnotationPresent(Singleton.class), moduleClass, method.getName());
-      this.method = method;
-      this.instance = instance;
-      method.setAccessible(true);
-      setLibrary(library);
-    }
-
-    @Override public void attach(Linker linker) {
-      Type[] types = method.getGenericParameterTypes();
-      Annotation[][] annotations = method.getParameterAnnotations();
-      parameters = new Binding[types.length];
-      for (int i = 0; i < parameters.length; i++) {
-        String key = Keys.get(types[i], annotations[i], method + " parameter " + i);
-        parameters[i] = linker.requestBinding(key, method, instance.getClass().getClassLoader());
-      }
-    }
-
-    @Override public T get() {
-      Object[] args = new Object[parameters.length];
-      for (int i = 0; i < parameters.length; i++) {
-        args[i] = parameters[i].get();
-      }
-      try {
-        return (T) method.invoke(instance, args);
-      } catch (InvocationTargetException e) {
-        Throwable cause = e.getCause();
-        throw cause instanceof RuntimeException
-            ? (RuntimeException) cause
-            : new RuntimeException(cause);
-      } catch (IllegalAccessException e) {
-        throw new RuntimeException(e);
-      }
-    }
-
-    @Override public void getDependencies(Set<Binding<?>> get, Set<Binding<?>> injectMembers) {
-      for (Binding<?> binding : parameters) {
-        get.add(binding);
-      }
-    }
-
-    @Override public void injectMembers(T t) {
-      throw new AssertionError("Provides method bindings are not MembersInjectors");
-    }
-  }
-}
diff --git a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/DemoBaseFragment.java b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/AbstractActivityComponent.java
similarity index 56%
rename from examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/DemoBaseFragment.java
rename to examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/AbstractActivityComponent.java
index f2e1fda4e..71afde188 100644
--- a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/DemoBaseFragment.java
+++ b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/AbstractActivityComponent.java
@@ -1,5 +1,6 @@
 /*
  * Copyright (C) 2013 Square, Inc.
+ * Copyright (C) 2014 Google, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -15,13 +16,15 @@
  */
 package com.example.dagger.activitygraphs;
 
-import android.os.Bundle;
-import android.support.v4.app.Fragment;
+import android.app.Activity;
+import dagger.Component;
 
-/** Base fragment which performs injection using the activity object graph of its parent. */
-public class DemoBaseFragment extends Fragment {
-  @Override public void onActivityCreated(Bundle savedInstanceState) {
-    super.onActivityCreated(savedInstanceState);
-    ((DemoBaseActivity) getActivity()).inject(this);
-  }
+/**
+ * A base component upon which fragment's components may depend.  Activity-level components
+ * should extend this component.
+ */
+// @PerActivity - Subtypes of ActivityComponent should be decorated with @PerActivity
+@Component(dependencies = ApplicationComponent.class, modules = ActivityModule.class)
+public interface AbstractDemoActivityComponent {
+  Activity activity(); // Expose the activity to sub-graphs.
 }
diff --git a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ActivityModule.java b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ActivityModule.java
index 2f9587c05..cf5462e50 100644
--- a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ActivityModule.java
+++ b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ActivityModule.java
@@ -15,43 +15,25 @@
  */
 package com.example.dagger.activitygraphs;
 
-import android.content.Context;
-import com.example.dagger.activitygraphs.ui.ActivityTitleController;
-import com.example.dagger.activitygraphs.ui.HomeActivity;
-import com.example.dagger.activitygraphs.ui.HomeFragment;
+import android.app.Activity;
 import dagger.Module;
 import dagger.Provides;
-import javax.inject.Singleton;
 
 /**
- * This module represents objects which exist only for the scope of a single activity. We can
- * safely create singletons using the activity instance because ths entire object graph will only
- * ever exist inside of that activity.
+ * A module to wrap the Activity state and expose it to the graph.
  */
-@Module(
-    injects = {
-        HomeActivity.class,
-        HomeFragment.class
-    },
-    addsTo = AndroidModule.class,
-    library = true
-)
+@Module
 public class ActivityModule {
-  private final DemoBaseActivity activity;
+  private final Activity activity;
 
-  public ActivityModule(DemoBaseActivity activity) {
+  public ActivityModule(Activity activity) {
     this.activity = activity;
   }
 
   /**
-   * Allow the activity context to be injected but require that it be annotated with
-   * {@link ForActivity @ForActivity} to explicitly differentiate it from application context.
+   * Expose the activity to dependents in the graph.
    */
-  @Provides @Singleton @ForActivity Context provideActivityContext() {
+  @Provides @PerActivity Activity activity() {
     return activity;
   }
-
-  @Provides @Singleton ActivityTitleController provideTitleController() {
-    return new ActivityTitleController(activity);
-  }
 }
diff --git a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ForApplication.java b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ApplicationComponent.java
similarity index 52%
rename from examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ForApplication.java
rename to examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ApplicationComponent.java
index 585d46b1c..04c206225 100644
--- a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ForApplication.java
+++ b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ApplicationComponent.java
@@ -15,11 +15,21 @@
  */
 package com.example.dagger.activitygraphs;
 
-import java.lang.annotation.Retention;
-import javax.inject.Qualifier;
+import android.app.Application;
+import android.location.LocationManager;
+import dagger.Component;
+import javax.inject.Singleton;
 
-import static java.lang.annotation.RetentionPolicy.RUNTIME;
+/**
+ * A component whose lifetime is the life of the application.
+ */
+@Singleton // Constraints this component to one-per-application or unscoped bindings.
+@Component(modules = DemoApplicationModule.class)
+public interface ApplicationComponent {
+  // Field injections of any dependencies of the DemoApplication
+  void inject(DemoApplication application);
 
-@Qualifier @Retention(RUNTIME)
-public @interface ForApplication {
+  // Exported for child-components.
+  Application application();
+  LocationManager locationManager();
 }
diff --git a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/DemoApplication.java b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/DemoApplication.java
index 56e1ab440..2b65da692 100644
--- a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/DemoApplication.java
+++ b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/DemoApplication.java
@@ -16,28 +16,23 @@
 package com.example.dagger.activitygraphs;
 
 import android.app.Application;
-import dagger.ObjectGraph;
-import java.util.Arrays;
-import java.util.List;
+import android.location.LocationManager;
+import javax.inject.Inject;
 
 public class DemoApplication extends Application {
-  private ObjectGraph applicationGraph;
+  private ApplicationComponent applicationComponent;
+
+  // TODO(user): Figure out a better example of something one might inject into the app.
+  @Inject LocationManager locationManager; // to illustrate injecting somethign into the app.
 
   @Override public void onCreate() {
     super.onCreate();
-
-    applicationGraph = ObjectGraph.create(getModules().toArray());
-  }
-
-  /**
-   * A list of modules to use for the application graph. Subclasses can override this method to
-   * provide additional modules provided they call {@code super.getModules()}.
-   */
-  protected List<Object> getModules() {
-    return Arrays.<Object>asList(new AndroidModule(this));
+    applicationComponent = Dagger_ApplicationComponent.builder()
+        .androidModule(new DemoApplicationModule(this))
+        .build();
   }
 
-  ObjectGraph getApplicationGraph() {
-    return applicationGraph;
+  ApplicationComponent component() {
+    return applicationComponent;
   }
 }
diff --git a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/AndroidModule.java b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/DemoApplicationModule.java
similarity index 72%
rename from examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/AndroidModule.java
rename to examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/DemoApplicationModule.java
index d31f738b6..070d2c79d 100644
--- a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/AndroidModule.java
+++ b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/DemoApplicationModule.java
@@ -15,7 +15,7 @@
  */
 package com.example.dagger.activitygraphs;
 
-import android.content.Context;
+import android.app.Application;
 import android.location.LocationManager;
 import dagger.Module;
 import dagger.Provides;
@@ -27,19 +27,18 @@
  * A module for Android-specific dependencies which require a {@link Context} or
  * {@link android.app.Application} to create.
  */
-@Module(library = true)
-public class AndroidModule {
-  private final DemoApplication application;
+@Module
+public class DemoApplicationModule {
+  private final Application application;
 
-  public AndroidModule(DemoApplication application) {
+  public DemoApplicationModule(Application application) {
     this.application = application;
   }
 
   /**
-   * Allow the application context to be injected but require that it be annotated with
-   * {@link ForApplication @ForApplication} to explicitly differentiate it from an activity context.
+   * Expose the application to the graph.
    */
-  @Provides @Singleton @ForApplication Context provideApplicationContext() {
+  @Provides @Singleton Application application() {
     return application;
   }
 
diff --git a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/DemoBaseActivity.java b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/DemoBaseActivity.java
deleted file mode 100644
index 44693dcc6..000000000
--- a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/DemoBaseActivity.java
+++ /dev/null
@@ -1,60 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.example.dagger.activitygraphs;
-
-import android.os.Bundle;
-import android.support.v4.app.FragmentActivity;
-import dagger.ObjectGraph;
-import java.util.Arrays;
-import java.util.List;
-
-/** Base activity which sets up a per-activity object graph and performs injection. */
-public abstract class DemoBaseActivity extends FragmentActivity {
-  private ObjectGraph activityGraph;
-
-  @Override protected void onCreate(Bundle savedInstanceState) {
-    super.onCreate(savedInstanceState);
-
-    // Create the activity graph by .plus-ing our modules onto the application graph.
-    DemoApplication application = (DemoApplication) getApplication();
-    activityGraph = application.getApplicationGraph().plus(getModules().toArray());
-
-    // Inject ourselves so subclasses will have dependencies fulfilled when this method returns.
-    activityGraph.inject(this);
-  }
-
-  @Override protected void onDestroy() {
-    // Eagerly clear the reference to the activity graph to allow it to be garbage collected as
-    // soon as possible.
-    activityGraph = null;
-
-    super.onDestroy();
-  }
-
-  /**
-   * A list of modules to use for the individual activity graph. Subclasses can override this
-   * method to provide additional modules provided they call and include the modules returned by
-   * calling {@code super.getModules()}.
-   */
-  protected List<Object> getModules() {
-    return Arrays.<Object>asList(new ActivityModule(this));
-  }
-
-  /** Inject the supplied {@code object} using the activity-specific graph. */
-  public void inject(Object object) {
-    activityGraph.inject(object);
-  }
-}
diff --git a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ForActivity.java b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/PerActivity.java
similarity index 75%
rename from examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ForActivity.java
rename to examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/PerActivity.java
index abd423b03..d54b193e3 100644
--- a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ForActivity.java
+++ b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/PerActivity.java
@@ -16,10 +16,16 @@
 package com.example.dagger.activitygraphs;
 
 import java.lang.annotation.Retention;
-import javax.inject.Qualifier;
+import javax.inject.Scope;
 
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
-@Qualifier @Retention(RUNTIME)
-public @interface ForActivity {
+/**
+ * A scoping annotation to permit objects whose lifetime should
+ * conform to the life of the activity to be memoized in the
+ * correct component.
+ */
+@Scope
+@Retention(RUNTIME)
+public @interface PerActivity {
 }
diff --git a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ui/ActivityTitleController.java b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ui/ActivityTitleController.java
index f42dbee70..c416c75b3 100644
--- a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ui/ActivityTitleController.java
+++ b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ui/ActivityTitleController.java
@@ -16,6 +16,8 @@
 package com.example.dagger.activitygraphs.ui;
 
 import android.app.Activity;
+import com.example.dagger.activitygraphs.PerActivity;
+import javax.inject.Inject;
 
 /**
  * A simple abstraction which provides the ability to set the title on an activity.
@@ -25,10 +27,11 @@
  * control of the activity title. While not exceedingly useful in practice, this concept could be
  * expanded to things like facilitating control over the action bar, dialogs, notifications, etc.
  */
+@PerActivity
 public class ActivityTitleController {
   private final Activity activity;
 
-  public ActivityTitleController(Activity activity) {
+  @Inject public ActivityTitleController(Activity activity) {
     this.activity = activity;
   }
 
diff --git a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ui/HomeActivity.java b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ui/HomeActivity.java
index 36125cf66..dd939d311 100644
--- a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ui/HomeActivity.java
+++ b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ui/HomeActivity.java
@@ -17,19 +17,26 @@
 
 import android.location.LocationManager;
 import android.os.Bundle;
-import com.example.dagger.activitygraphs.DemoBaseActivity;
 import javax.inject.Inject;
 
-public class HomeActivity extends DemoBaseActivity {
+public class HomeActivity extends Activity {
   @Inject LocationManager locationManager;
 
+  @Override HomeComponent initComponent() {
+    return component;
+  }
+
   @Override protected void onCreate(Bundle savedInstanceState) {
     super.onCreate(savedInstanceState);
-    // After the super.onCreate call returns we are guaranteed our injections are available.
+    Dagger_HomeActivity$HomeComponent.builder()
+        .applicationComponent(((DemoApplication) getApplication()).component())
+        .activityModule(new ActivityModule(this))
+        .build()
+        .inject(this);
 
     if (savedInstanceState == null) {
       getSupportFragmentManager().beginTransaction()
-          .add(android.R.id.content, HomeFragment.newInstance())
+          .add(android.R.id.content, new HomeFragment())
           .commit();
     }
 
diff --git a/compiler/src/it/inject-parameterized-type/src/main/java/test/TestApp.java b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ui/HomeComponent.java
similarity index 51%
rename from compiler/src/it/inject-parameterized-type/src/main/java/test/TestApp.java
rename to examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ui/HomeComponent.java
index b22dd6f62..84d2a427c 100644
--- a/compiler/src/it/inject-parameterized-type/src/main/java/test/TestApp.java
+++ b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ui/HomeComponent.java
@@ -13,29 +13,17 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package test;
+package com.example.dagger.activitygraphs.ui;
 
-import dagger.Module;
-import dagger.ObjectGraph;
-import dagger.Provides;
-import javax.inject.Inject;
+import com.example.dagger.activitygraphs.AbstractActivityComponent;
+import com.example.dagger.activitygraphs.ActivityModule;
+import com.example.dagger.activitygraphs.ApplicationComponent;
+import com.example.dagger.activitygraphs.PerActivity;
+import dagger.Component;
 
-class TestApp {
-  public static void main(String[] args) {
-    Subtype subtype = ObjectGraph.create(new TestModule()).get(Subtype.class);
-  }
-
-  static class Supertype<T> {
-    @Inject String s;
-  }
-
-  static class Subtype extends Supertype<Integer> {
-  }
-
-  @Module(injects = Subtype.class)
-  static class TestModule {
-    @Provides String provideString() {
-      return "a";
-    }
-  }
+@PerActivity
+@Component(dependencies = ApplicationComponent.class, modules = ActivityModule.class)
+public interface HomeComponent extends AbstractActivityComponent {
+  void inject(HomeActivity homeActivity);
+  void inject(HomeFragment homeFragment);
 }
diff --git a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ui/HomeFragment.java b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ui/HomeFragment.java
index 56bbd583c..0cef1a004 100644
--- a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ui/HomeFragment.java
+++ b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ui/HomeFragment.java
@@ -16,22 +16,23 @@
 package com.example.dagger.activitygraphs.ui;
 
 import android.os.Bundle;
+import android.support.v4.app.Fragment;
 import android.view.LayoutInflater;
 import android.view.View;
 import android.view.ViewGroup;
 import android.widget.TextView;
-import com.example.dagger.activitygraphs.DemoBaseFragment;
 import javax.inject.Inject;
 
 import static android.view.Gravity.CENTER;
 
-public class HomeFragment extends DemoBaseFragment {
-  public static HomeFragment newInstance() {
-    return new HomeFragment();
-  }
-
+public class HomeFragment extends Fragment {
   @Inject ActivityTitleController titleController;
 
+  @Override public void onActivityCreated(Bundle savedInstanceState) {
+    super.onActivityCreated(savedInstanceState);
+    ((AbstractDemoActivity) getActivity()).inject(this);
+  }
+
   @Override public View onCreateView(LayoutInflater inflater, ViewGroup container,
       Bundle savedInstanceState) {
     TextView tv = new TextView(getActivity());
diff --git a/examples/android-simple/src/main/java/com/example/dagger/simple/AndroidModule.java b/examples/android-simple/src/main/java/com/example/dagger/simple/AndroidModule.java
index e6b8aa57c..18184d164 100644
--- a/examples/android-simple/src/main/java/com/example/dagger/simple/AndroidModule.java
+++ b/examples/android-simple/src/main/java/com/example/dagger/simple/AndroidModule.java
@@ -27,7 +27,7 @@
  * A module for Android-specific dependencies which require a {@link Context} or
  * {@link android.app.Application} to create.
  */
-@Module(library = true)
+@Module
 public class AndroidModule {
   private final DemoApplication application;
 
diff --git a/examples/android-simple/src/main/java/com/example/dagger/simple/DemoBaseActivity.java b/examples/android-simple/src/main/java/com/example/dagger/simple/DemoActivity.java
similarity index 88%
rename from examples/android-simple/src/main/java/com/example/dagger/simple/DemoBaseActivity.java
rename to examples/android-simple/src/main/java/com/example/dagger/simple/DemoActivity.java
index c037ac02b..aa09f2d0a 100644
--- a/examples/android-simple/src/main/java/com/example/dagger/simple/DemoBaseActivity.java
+++ b/examples/android-simple/src/main/java/com/example/dagger/simple/DemoActivity.java
@@ -18,11 +18,10 @@
 import android.app.Activity;
 import android.os.Bundle;
 
-public abstract class DemoBaseActivity extends Activity {
+public abstract class DemoActivity extends Activity {
   @Override protected void onCreate(Bundle savedInstanceState) {
     super.onCreate(savedInstanceState);
-
     // Perform injection so that when this call returns all dependencies will be available for use.
-    ((DemoApplication) getApplication()).inject(this);
+    ((DemoApplication) getApplication()).component().inject(this);
   }
 }
diff --git a/examples/android-simple/src/main/java/com/example/dagger/simple/DemoApplication.java b/examples/android-simple/src/main/java/com/example/dagger/simple/DemoApplication.java
index e082c0f6f..6771f06cb 100644
--- a/examples/android-simple/src/main/java/com/example/dagger/simple/DemoApplication.java
+++ b/examples/android-simple/src/main/java/com/example/dagger/simple/DemoApplication.java
@@ -16,27 +16,34 @@
 package com.example.dagger.simple;
 
 import android.app.Application;
-import dagger.ObjectGraph;
+import android.location.LocationManager;
+import com.example.dagger.simple.ui.HomeActivity;
+import dagger.Component;
 import java.util.Arrays;
 import java.util.List;
+import javax.inject.Inject;
 
 public class DemoApplication extends Application {
-  private ObjectGraph graph;
+  
+  @Component(modules = AndroidModule.class) interface ApplicationComponent {
+    void inject(DemoApplication application);
+    void inject(HomeActivity homeActivity);
+    void inject(DemoActivity demoActivity);
+  }
+  
+  @Inject LocationManager locationManager; // for some reason.
+  
+  private ApplicationComponent component;
 
   @Override public void onCreate() {
     super.onCreate();
-
-    graph = ObjectGraph.create(getModules().toArray());
-  }
-
-  protected List<Object> getModules() {
-    return Arrays.asList(
-        new AndroidModule(this),
-        new DemoModule()
-    );
+    component = Dagger_DemoApplication$ApplicationComponent.builder()
+        .androidModule(new AndroidModule(this))
+        .build();
+    component().inject(this); // As of now, LocationManager should be injected into this.
   }
 
-  public void inject(Object object) {
-    graph.inject(object);
+  public ApplicationComponent component() {
+    return component;
   }
 }
diff --git a/examples/android-simple/src/main/java/com/example/dagger/simple/DemoModule.java b/examples/android-simple/src/main/java/com/example/dagger/simple/DemoModule.java
deleted file mode 100644
index 33d7278ac..000000000
--- a/examples/android-simple/src/main/java/com/example/dagger/simple/DemoModule.java
+++ /dev/null
@@ -1,27 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.example.dagger.simple;
-
-import com.example.dagger.simple.ui.HomeActivity;
-import dagger.Module;
-
-@Module(
-    injects = HomeActivity.class,
-    complete = false
-)
-public class DemoModule {
-  // TODO put your application-specific providers here!
-}
diff --git a/examples/android-simple/src/main/java/com/example/dagger/simple/ui/HomeActivity.java b/examples/android-simple/src/main/java/com/example/dagger/simple/ui/HomeActivity.java
index 5c2212725..dfdcbd895 100644
--- a/examples/android-simple/src/main/java/com/example/dagger/simple/ui/HomeActivity.java
+++ b/examples/android-simple/src/main/java/com/example/dagger/simple/ui/HomeActivity.java
@@ -17,10 +17,10 @@
 
 import android.location.LocationManager;
 import android.os.Bundle;
-import com.example.dagger.simple.DemoBaseActivity;
+import com.example.dagger.simple.DemoActivity;
 import javax.inject.Inject;
 
-public class HomeActivity extends DemoBaseActivity {
+public class HomeActivity extends DemoActivity {
   @Inject LocationManager locationManager;
 
   @Override protected void onCreate(Bundle savedInstanceState) {
diff --git a/examples/pom.xml b/examples/pom.xml
index 41da7c584..ebcd423c8 100644
--- a/examples/pom.xml
+++ b/examples/pom.xml
@@ -67,6 +67,13 @@
   <build>
     <pluginManagement>
       <plugins>
+       <plugin>
+          <artifactId>maven-compiler-plugin</artifactId>
+          <configuration>
+            <source>1.6</source>
+            <target>1.6</target>
+          </configuration>
+        </plugin>
         <plugin>
           <groupId>com.jayway.maven.plugins.android.generation2</groupId>
           <artifactId>android-maven-plugin</artifactId>
diff --git a/examples/simple/src/main/java/coffee/CoffeeApp.java b/examples/simple/src/main/java/coffee/CoffeeApp.java
index b6be33a31..32358063c 100644
--- a/examples/simple/src/main/java/coffee/CoffeeApp.java
+++ b/examples/simple/src/main/java/coffee/CoffeeApp.java
@@ -1,19 +1,15 @@
 package coffee;
 
-import javax.inject.Inject;
+import dagger.Component;
 
-import dagger.ObjectGraph;
-
-public class CoffeeApp implements Runnable {
-  @Inject CoffeeMaker coffeeMaker;
-
-  @Override public void run() {
-    coffeeMaker.brew();
+public class CoffeeApp {
+  @Component(modules = { DripCoffeeModule.class })
+  public interface Coffee {
+    CoffeeMaker maker();
   }
 
   public static void main(String[] args) {
-    ObjectGraph objectGraph = ObjectGraph.create(new DripCoffeeModule());
-    CoffeeApp coffeeApp = objectGraph.get(CoffeeApp.class);
-    coffeeApp.run();
+    Coffee coffee = Dagger_CoffeeApp$Coffee.builder().build();
+    coffee.maker().brew();
   }
 }
diff --git a/examples/simple/src/main/java/coffee/CoffeeMaker.java b/examples/simple/src/main/java/coffee/CoffeeMaker.java
index a4e818012..372bb3409 100644
--- a/examples/simple/src/main/java/coffee/CoffeeMaker.java
+++ b/examples/simple/src/main/java/coffee/CoffeeMaker.java
@@ -1,11 +1,17 @@
 package coffee;
 
 import dagger.Lazy;
+
 import javax.inject.Inject;
 
 class CoffeeMaker {
-  @Inject Lazy<Heater> heater; // Don't want to create a possibly costly heater until we need it.
-  @Inject Pump pump;
+  private final Lazy<Heater> heater; // Create a possibly costly heater only when we use it.
+  private final Pump pump;
+
+  @Inject CoffeeMaker(Lazy<Heater> heater, Pump pump) {
+    this.heater = heater;
+    this.pump = pump;
+  }
 
   public void brew() {
     heater.get().on();
diff --git a/examples/simple/src/main/java/coffee/DripCoffeeModule.java b/examples/simple/src/main/java/coffee/DripCoffeeModule.java
index da0bbaafa..e50d249e1 100644
--- a/examples/simple/src/main/java/coffee/DripCoffeeModule.java
+++ b/examples/simple/src/main/java/coffee/DripCoffeeModule.java
@@ -4,10 +4,7 @@
 import dagger.Provides;
 import javax.inject.Singleton;
 
-@Module(
-    injects = CoffeeApp.class,
-    includes = PumpModule.class
-)
+@Module(includes = PumpModule.class)
 class DripCoffeeModule {
   @Provides @Singleton Heater provideHeater() {
     return new ElectricHeater();
diff --git a/pom.xml b/pom.xml
index b40512682..9db58a1f4 100644
--- a/pom.xml
+++ b/pom.xml
@@ -50,7 +50,6 @@
 
     <!-- Test Dependencies -->
     <compile-testing.version>1.0-SNAPSHOT</compile-testing.version>
-    <fest.version>1.4</fest.version>
     <junit.version>4.11</junit.version>
     <mockito.version>1.9.5</mockito.version>
     <truth.version>1.0-SNAPSHOT</truth.version>
@@ -122,11 +121,6 @@
         <artifactId>junit</artifactId>
         <version>${junit.version}</version>
       </dependency>
-      <dependency>
-        <groupId>org.easytesting</groupId>
-        <artifactId>fest-assert</artifactId>
-        <version>${fest.version}</version>
-      </dependency>
       <dependency>
         <groupId>com.google.testing.compile</groupId>
         <artifactId>compile-testing</artifactId>
