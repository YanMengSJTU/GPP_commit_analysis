diff --git a/compiler/src/it/guava-functional-tests/src/main/java/test/optional/OptionalBindingComponents.java b/compiler/src/it/guava-functional-tests/src/main/java/test/optional/OptionalBindingComponents.java
index c57b0cab3..fcebac6fb 100644
--- a/compiler/src/it/guava-functional-tests/src/main/java/test/optional/OptionalBindingComponents.java
+++ b/compiler/src/it/guava-functional-tests/src/main/java/test/optional/OptionalBindingComponents.java
@@ -32,8 +32,9 @@
 import javax.inject.Qualifier;
 
 /**
- * Classes to support {@link OptionalBindingComponentsTest} and
- * {@link test.optional.a.OptionalBindingComponentsWithInaccessibleTypesTest}.
+ * Classes to support {@link OptionalBindingComponentsPresentTest}, {@link
+ * OptionalBindingComponentsAbsentTest} and {@link
+ * test.optional.a.OptionalBindingComponentsWithInaccessibleTypesTest}.
  */
 public final class OptionalBindingComponents {
 
diff --git a/compiler/src/it/guava-functional-tests/src/test/java/test/optional/OptionalBindingComponentsAbsentTest.java b/compiler/src/it/guava-functional-tests/src/test/java/test/optional/OptionalBindingComponentsAbsentTest.java
new file mode 100644
index 000000000..cd74d09e7
--- /dev/null
+++ b/compiler/src/it/guava-functional-tests/src/test/java/test/optional/OptionalBindingComponentsAbsentTest.java
@@ -0,0 +1,76 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package test.optional;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import test.optional.OptionalBindingComponents.AbsentOptionalBindingComponent;
+
+/** Tests for absent optional bindings. */
+@RunWith(JUnit4.class)
+public final class OptionalBindingComponentsAbsentTest {
+  private AbsentOptionalBindingComponent absent;
+
+  @Before
+  public void setUp() {
+    absent = DaggerOptionalBindingComponents_AbsentOptionalBindingComponent.create();
+  }
+
+  @Test
+  public void optional() {
+    assertThat(absent.optionalInstance()).isAbsent();
+  }
+
+  @Test
+  public void optionalProvider() {
+    assertThat(absent.optionalProvider()).isAbsent();
+  }
+
+  @Test
+  public void optionalLazy() {
+    assertThat(absent.optionalLazy()).isAbsent();
+  }
+
+  @Test
+  public void optionalLazyProvider() {
+    assertThat(absent.optionalLazyProvider()).isAbsent();
+  }
+
+  @Test
+  public void qualifiedOptional() {
+    assertThat(absent.qualifiedOptionalInstance()).isAbsent();
+  }
+
+  @Test
+  public void qualifiedOptionalProvider() {
+    assertThat(absent.qualifiedOptionalProvider()).isAbsent();
+  }
+
+  @Test
+  public void qualifiedOptionalLazy() {
+    assertThat(absent.qualifiedOptionalLazy()).isAbsent();
+  }
+
+  @Test
+  public void qualifiedOptionalLazyProvider() {
+    assertThat(absent.qualifiedOptionalLazyProvider()).isAbsent();
+  }
+}
diff --git a/compiler/src/it/guava-functional-tests/src/test/java/test/optional/OptionalBindingComponentsPresentTest.java b/compiler/src/it/guava-functional-tests/src/test/java/test/optional/OptionalBindingComponentsPresentTest.java
new file mode 100644
index 000000000..c10853120
--- /dev/null
+++ b/compiler/src/it/guava-functional-tests/src/test/java/test/optional/OptionalBindingComponentsPresentTest.java
@@ -0,0 +1,84 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package test.optional;
+
+import static com.google.common.truth.Truth.assertThat;
+import static test.optional.OptionalBindingComponents.Value.QUALIFIED_VALUE;
+import static test.optional.OptionalBindingComponents.Value.VALUE;
+
+import com.google.common.collect.ImmutableList;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+import org.junit.runners.Parameterized.Parameters;
+import test.optional.OptionalBindingComponents.OptionalBindingComponent;
+
+/** Tests for present optional bindings. */
+@RunWith(Parameterized.class)
+public final class OptionalBindingComponentsPresentTest {
+
+  @Parameters(name = "{0}")
+  public static Iterable<Object[]> parameters() {
+    return ImmutableList.copyOf(
+        new Object[][] {
+          {DaggerOptionalBindingComponents_PresentOptionalBindingComponent.create()},
+          {DaggerOptionalBindingComponents_AbsentOptionalBindingComponent.create().presentChild()},
+        });
+  }
+
+  private final OptionalBindingComponent component;
+
+  public OptionalBindingComponentsPresentTest(OptionalBindingComponent component) {
+    this.component = component;
+  }
+
+  @Test
+  public void optionalProvider() {
+    assertThat(component.optionalProvider().get().get()).isEqualTo(VALUE);
+  }
+
+  @Test
+  public void optionalLazy() {
+    assertThat(component.optionalLazy().get().get()).isEqualTo(VALUE);
+  }
+
+  @Test
+  public void optionalLazyProvider() {
+    assertThat(component.optionalLazyProvider().get().get().get()).isEqualTo(VALUE);
+  }
+
+  @Test
+  public void qualifiedOptional() {
+    assertThat(component.qualifiedOptionalInstance()).hasValue(QUALIFIED_VALUE);
+  }
+
+  @Test
+  public void qualifiedOptionalProvider() {
+    assertThat(component.qualifiedOptionalProvider().get().get()).isEqualTo(QUALIFIED_VALUE);
+  }
+
+  @Test
+  public void qualifiedOptionalLazy() {
+    assertThat(component.qualifiedOptionalLazy().get().get()).isEqualTo(QUALIFIED_VALUE);
+  }
+
+  @Test
+  public void qualifiedOptionalLazyProvider() {
+    assertThat(component.qualifiedOptionalLazyProvider().get().get().get())
+        .isEqualTo(QUALIFIED_VALUE);
+  }
+}
diff --git a/compiler/src/it/guava-functional-tests/src/test/java/test/optional/OptionalBindingComponentsTest.java b/compiler/src/it/guava-functional-tests/src/test/java/test/optional/OptionalBindingComponentsTest.java
deleted file mode 100644
index ef437cf84..000000000
--- a/compiler/src/it/guava-functional-tests/src/test/java/test/optional/OptionalBindingComponentsTest.java
+++ /dev/null
@@ -1,166 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.optional;
-
-import static com.google.common.truth.Truth.assertThat;
-import static test.optional.OptionalBindingComponents.Value.QUALIFIED_VALUE;
-import static test.optional.OptionalBindingComponents.Value.VALUE;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-import test.optional.OptionalBindingComponents.AbsentOptionalBindingComponent;
-import test.optional.OptionalBindingComponents.PresentOptionalBindingComponent;
-import test.optional.OptionalBindingComponents.PresentOptionalBindingSubcomponent;
-
-/** Tests for optional bindings. */
-@RunWith(JUnit4.class)
-public final class OptionalBindingComponentsTest {
-  private AbsentOptionalBindingComponent absent;
-  private PresentOptionalBindingComponent present;
-  private PresentOptionalBindingSubcomponent presentChild;
-
-  @Before
-  public void setUp() {
-    absent = DaggerOptionalBindingComponents_AbsentOptionalBindingComponent.create();
-    present = DaggerOptionalBindingComponents_PresentOptionalBindingComponent.create();
-    presentChild = absent.presentChild();
-  }
-
-  @Test
-  public void absentOptional() {
-    assertThat(absent.optionalInstance()).isAbsent();
-  }
-
-  @Test
-  public void absentOptionalProvider() {
-    assertThat(absent.optionalProvider()).isAbsent();
-  }
-
-  @Test
-  public void absentOptionalLazy() {
-    assertThat(absent.optionalLazy()).isAbsent();
-  }
-
-  @Test
-  public void absentOptionalLazyProvider() {
-    assertThat(absent.optionalLazyProvider()).isAbsent();
-  }
-
-  @Test
-  public void absentQualifiedOptional() {
-    assertThat(absent.qualifiedOptionalInstance()).isAbsent();
-  }
-
-  @Test
-  public void absentQualifiedOptionalProvider() {
-    assertThat(absent.qualifiedOptionalProvider()).isAbsent();
-  }
-
-  @Test
-  public void absentQualifiedOptionalLazy() {
-    assertThat(absent.qualifiedOptionalLazy()).isAbsent();
-  }
-
-  @Test
-  public void absentQualifiedOptionalLazyProvider() {
-    assertThat(absent.qualifiedOptionalLazyProvider()).isAbsent();
-  }
-
-  @Test
-  public void presentOptional() {
-    assertThat(present.optionalInstance()).hasValue(VALUE);
-  }
-
-  @Test
-  public void presentOptionalProvider() {
-    assertThat(present.optionalProvider().get().get()).isEqualTo(VALUE);
-  }
-
-  @Test
-  public void presentOptionalLazy() {
-    assertThat(present.optionalLazy().get().get()).isEqualTo(VALUE);
-  }
-
-  @Test
-  public void presentOptionalLazyProvider() {
-    assertThat(present.optionalLazyProvider().get().get().get()).isEqualTo(VALUE);
-  }
-
-  @Test
-  public void presentQualifiedOptional() {
-    assertThat(present.qualifiedOptionalInstance()).hasValue(QUALIFIED_VALUE);
-  }
-
-  @Test
-  public void presentQualifiedOptionalProvider() {
-    assertThat(present.qualifiedOptionalProvider().get().get()).isEqualTo(QUALIFIED_VALUE);
-  }
-
-  @Test
-  public void presentQualifiedOptionalLazy() {
-    assertThat(present.qualifiedOptionalLazy().get().get()).isEqualTo(QUALIFIED_VALUE);
-  }
-
-  @Test
-  public void presentQualifiedOptionalLazyProvider() {
-    assertThat(present.qualifiedOptionalLazyProvider().get().get().get())
-        .isEqualTo(QUALIFIED_VALUE);
-  }
-
-  @Test
-  public void presentChildOptional() {
-    assertThat(presentChild.optionalInstance()).hasValue(VALUE);
-  }
-
-  @Test
-  public void presentChildOptionalProvider() {
-    assertThat(presentChild.optionalProvider().get().get()).isEqualTo(VALUE);
-  }
-
-  @Test
-  public void presentChildOptionalLazy() {
-    assertThat(presentChild.optionalLazy().get().get()).isEqualTo(VALUE);
-  }
-
-  @Test
-  public void presentChildOptionalLazyProvider() {
-    assertThat(presentChild.optionalLazyProvider().get().get().get()).isEqualTo(VALUE);
-  }
-
-  @Test
-  public void presentChildQualifiedOptional() {
-    assertThat(presentChild.qualifiedOptionalInstance()).hasValue(QUALIFIED_VALUE);
-  }
-
-  @Test
-  public void presentChildQualifiedOptionalProvider() {
-    assertThat(presentChild.qualifiedOptionalProvider().get().get()).isEqualTo(QUALIFIED_VALUE);
-  }
-
-  @Test
-  public void presentChildQualifiedOptionalLazy() {
-    assertThat(presentChild.qualifiedOptionalLazy().get().get()).isEqualTo(QUALIFIED_VALUE);
-  }
-
-  @Test
-  public void presentChildQualifiedOptionalLazyProvider() {
-    assertThat(presentChild.qualifiedOptionalLazyProvider().get().get().get())
-        .isEqualTo(QUALIFIED_VALUE);
-  }
-}
diff --git a/compiler/src/it/producers-functional-tests/pom.xml b/compiler/src/it/producers-functional-tests/pom.xml
index bcf80437f..a36759e8d 100644
--- a/compiler/src/it/producers-functional-tests/pom.xml
+++ b/compiler/src/it/producers-functional-tests/pom.xml
@@ -48,7 +48,12 @@ limitations under the License.
       <version>${project.version}</version>
       <optional>true</optional>
     </dependency>
-
+    <dependency>
+      <groupId>com.google.auto.value</groupId>
+      <artifactId>auto-value</artifactId>
+      <version>${auto.value.version}</version>
+      <scope>provided</scope> <!-- to leave out of the all-deps jar -->
+    </dependency>
     <dependency>
       <groupId>junit</groupId>
       <artifactId>junit</artifactId>
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/optional/OptionalBindingComponents.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/optional/OptionalBindingComponents.java
new file mode 100644
index 000000000..60d31bb20
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/optional/OptionalBindingComponents.java
@@ -0,0 +1,177 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package producerstest.optional;
+
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+import com.google.auto.value.AutoValue;
+import com.google.common.base.Optional;
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.BindsOptionalOf;
+import dagger.Module;
+import dagger.Provides;
+import dagger.producers.Produced;
+import dagger.producers.Producer;
+import dagger.producers.ProducerModule;
+import dagger.producers.Produces;
+import dagger.producers.Production;
+import dagger.producers.ProductionComponent;
+import dagger.producers.ProductionSubcomponent;
+import java.lang.annotation.Retention;
+import java.util.concurrent.Executor;
+import java.util.concurrent.Executors;
+import javax.inject.Qualifier;
+
+/**
+ * Classes to support {@link OptionalBindingComponentsAbsentTest} and {@link
+ * OptionalBindingComponentsPresentTest}.
+ */
+final class OptionalBindingComponents {
+
+  /** A qualifier. */
+  @Qualifier
+  @Retention(RUNTIME)
+  @interface SomeQualifier {}
+
+  /** A value object that contains various optionally-bound objects. */
+  @AutoValue
+  abstract static class Values {
+    abstract Optional<Value> optionalInstance();
+
+    abstract Optional<Producer<Value>> optionalProducer();
+
+    abstract Optional<Produced<Value>> optionalProduced();
+  }
+
+  enum Value {
+    VALUE,
+    QUALIFIED_VALUE
+  }
+
+  @Module
+  static final class ExecutorModule {
+    @Provides
+    @Production
+    static Executor executor() {
+      return Executors.newSingleThreadExecutor();
+    }
+  }
+
+  /** Binds optionals and {@link Values}. */
+  @ProducerModule
+  abstract static class OptionalBindingModule {
+    @BindsOptionalOf
+    abstract Value value();
+
+    @BindsOptionalOf
+    @SomeQualifier
+    abstract Value qualifiedValue();
+
+    @Produces
+    static Values values(
+        Optional<Value> optionalInstance,
+        Optional<Producer<Value>> optionalProducer,
+        Optional<Produced<Value>> optionalProduced) {
+      return new AutoValue_OptionalBindingComponents_Values(
+          optionalInstance, optionalProducer, optionalProduced);
+    }
+
+    @Produces
+    @SomeQualifier
+    static Values qualifiedValues(
+        Optional<Value> optionalInstance,
+        Optional<Producer<Value>> optionalProducer,
+        Optional<Produced<Value>> optionalProduced) {
+      return new AutoValue_OptionalBindingComponents_Values(
+          optionalInstance, optionalProducer, optionalProduced);
+    }
+  }
+
+  /** Binds {@link Value} using {@link Producer}s. */
+  @ProducerModule
+  abstract static class ConcreteBindingProducerModule {
+    @Produces
+    static Value value() {
+      return Value.VALUE;
+    }
+
+    @Produces
+    @SomeQualifier
+    static Value qualifiedValue() {
+      return Value.QUALIFIED_VALUE;
+    }
+  }
+
+  /** Binds {@link Value} using {@link Provider}s. */
+  @Module
+  abstract static class ConcreteBindingModule {
+    @Provides
+    static Value value() {
+      return Value.VALUE;
+    }
+
+    @Provides
+    @SomeQualifier
+    static Value qualifiedValue() {
+      return Value.QUALIFIED_VALUE;
+    }
+  }
+
+  interface OptionalBindingComponent {
+    ListenableFuture<Values> values();
+
+    ListenableFuture<Optional<Value>> optionalInstance();
+
+    ListenableFuture<Optional<Producer<Value>>> optionalProducer();
+
+    ListenableFuture<Optional<Produced<Value>>> optionalProduced();
+
+    @SomeQualifier
+    ListenableFuture<Values> qualifiedValues();
+
+    @SomeQualifier
+    ListenableFuture<Optional<Value>> qualifiedOptionalInstance();
+
+    @SomeQualifier
+    ListenableFuture<Optional<Producer<Value>>> qualifiedOptionalProducer();
+
+    @SomeQualifier
+    ListenableFuture<Optional<Produced<Value>>> qualifiedOptionalProduced();
+  }
+
+  @ProductionComponent(modules = {ExecutorModule.class, OptionalBindingModule.class})
+  interface AbsentOptionalBindingComponent extends OptionalBindingComponent {
+    PresentOptionalBindingSubcomponent presentChild();
+  }
+
+  @ProductionComponent(
+    modules = {
+      ExecutorModule.class,
+      OptionalBindingModule.class,
+      ConcreteBindingProducerModule.class
+    }
+  )
+  interface PresentOptionalBindingComponent extends OptionalBindingComponent {}
+
+  @ProductionSubcomponent(modules = ConcreteBindingProducerModule.class)
+  interface PresentOptionalBindingSubcomponent extends OptionalBindingComponent {}
+
+  @ProductionComponent(
+    modules = {ExecutorModule.class, OptionalBindingModule.class, ConcreteBindingModule.class}
+  )
+  interface PresentOptionalProvisionBindingComponent extends OptionalBindingComponent {}
+}
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/optional/OptionalBindingComponentsAbsentTest.java b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/optional/OptionalBindingComponentsAbsentTest.java
new file mode 100644
index 000000000..c2d5ce530
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/optional/OptionalBindingComponentsAbsentTest.java
@@ -0,0 +1,66 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package producerstest.optional;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import producerstest.optional.OptionalBindingComponents.AbsentOptionalBindingComponent;
+
+/** Tests for absent optional bindings. */
+@RunWith(JUnit4.class)
+public final class OptionalBindingComponentsAbsentTest {
+  private AbsentOptionalBindingComponent absent;
+
+  @Before
+  public void setUp() {
+    absent = DaggerOptionalBindingComponents_AbsentOptionalBindingComponent.create();
+  }
+
+  @Test
+  public void optional() throws Exception {
+    assertThat(absent.optionalInstance().get()).isAbsent();
+  }
+
+  @Test
+  public void optionalProducer() throws Exception {
+    assertThat(absent.optionalProducer().get()).isAbsent();
+  }
+
+  @Test
+  public void optionalProduced() throws Exception {
+    assertThat(absent.optionalProduced().get()).isAbsent();
+  }
+
+  @Test
+  public void qualifiedOptional() throws Exception {
+    assertThat(absent.qualifiedOptionalInstance().get()).isAbsent();
+  }
+
+  @Test
+  public void qualifiedOptionalProducer() throws Exception {
+    assertThat(absent.qualifiedOptionalProducer().get()).isAbsent();
+  }
+
+  @Test
+  public void qualifiedOptionalProduced() throws Exception {
+    assertThat(absent.qualifiedOptionalProduced().get()).isAbsent();
+  }
+}
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/optional/OptionalBindingComponentsPresentTest.java b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/optional/OptionalBindingComponentsPresentTest.java
new file mode 100644
index 000000000..8788e5236
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/optional/OptionalBindingComponentsPresentTest.java
@@ -0,0 +1,80 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package producerstest.optional;
+
+import static com.google.common.truth.Truth.assertThat;
+import static producerstest.optional.OptionalBindingComponents.Value.QUALIFIED_VALUE;
+import static producerstest.optional.OptionalBindingComponents.Value.VALUE;
+
+import com.google.common.collect.ImmutableList;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+import org.junit.runners.Parameterized.Parameters;
+import producerstest.optional.OptionalBindingComponents.OptionalBindingComponent;
+
+/** Tests for present optional bindings. */
+@RunWith(Parameterized.class)
+public final class OptionalBindingComponentsPresentTest {
+
+  @Parameters(name = "{0}")
+  public static Iterable<Object[]> parameters() {
+    return ImmutableList.copyOf(
+        new Object[][] {
+          {DaggerOptionalBindingComponents_PresentOptionalBindingComponent.create()},
+          {DaggerOptionalBindingComponents_AbsentOptionalBindingComponent.create().presentChild()},
+          {DaggerOptionalBindingComponents_PresentOptionalProvisionBindingComponent.create()}
+        });
+  }
+  
+  private final OptionalBindingComponent component;
+
+  public OptionalBindingComponentsPresentTest(OptionalBindingComponent component) {
+    this.component = component;
+  }
+
+  @Test
+  public void optional() throws Exception {
+    assertThat(component.optionalInstance().get()).hasValue(VALUE);
+  }
+
+  @Test
+  public void optionalProducer() throws Exception {
+    assertThat(component.optionalProducer().get().get().get().get()).isEqualTo(VALUE);
+  }
+
+  @Test
+  public void optionalProduced() throws Exception {
+    assertThat(component.optionalProduced().get().get().get()).isEqualTo(VALUE);
+  }
+
+  @Test
+  public void qualifiedOptional() throws Exception {
+    assertThat(component.qualifiedOptionalInstance().get()).hasValue(QUALIFIED_VALUE);
+  }
+
+  @Test
+  public void qualifiedOptionalProducer() throws Exception {
+    assertThat(component.qualifiedOptionalProducer().get().get().get().get())
+        .isEqualTo(QUALIFIED_VALUE);
+  }
+
+  @Test
+  public void qualifiedOptionalProduced() throws Exception {
+    assertThat(component.qualifiedOptionalProduced().get().get().get()).isEqualTo(QUALIFIED_VALUE);
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
index d9923a91f..aa0b91f63 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -28,6 +28,7 @@
 import static dagger.internal.codegen.AbstractComponentWriter.InitializationState.INITIALIZED;
 import static dagger.internal.codegen.AbstractComponentWriter.InitializationState.UNINITIALIZED;
 import static dagger.internal.codegen.AnnotationSpecs.SUPPRESS_WARNINGS_UNCHECKED;
+import static dagger.internal.codegen.BindingKey.contribution;
 import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
 import static dagger.internal.codegen.ContributionBinding.FactoryCreationStrategy.ENUM_INSTANCE;
 import static dagger.internal.codegen.ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD;
@@ -488,6 +489,10 @@ private void addBuilderMethodReturnStatementForSpec(
    */
   protected abstract void addFactoryMethods();
 
+  private boolean graphHasContributionBinding(Key key) {
+    return graph.resolvedBindings().containsKey(contribution(key));
+  }
+
   private void addFrameworkFields() {
     for (ResolvedBindings resolvedBindings : graph.resolvedBindings().values()) {
       addField(resolvedBindings);
@@ -1289,22 +1294,20 @@ private CodeBlock potentiallyCast(boolean shouldCast, Class<?> classToCast, Code
     return CodeBlock.of("($T) $L", classToCast, notCasted);
   }
 
-  /** Returns an expression that initializes a {@link Provider} for an optional binding. */
+  /**
+   * Returns an expression that initializes a {@link Provider} or {@link Producer} for an optional
+   * binding.
+   */
   private CodeBlock initializeFactoryForSyntheticOptionalBinding(ContributionBinding binding) {
-    if (binding.bindingType().equals(BindingType.PRODUCTION)) {
-      throw new UnsupportedOperationException("optional producers are not supported yet");
-    }
-
     if (binding.dependencies().isEmpty()) {
+      verify(
+          binding.bindingType().equals(BindingType.PROVISION),
+          "Absent optional bindings should be provisions: %s",
+          binding);
       return optionalFactories.absentOptionalProvider();
     } else {
-      TypeMirror valueType = OptionalType.from(binding.key()).valueType();
-      DependencyRequest.Kind valueKind = DependencyRequest.extractKindAndType(valueType).kind();
-      FrameworkDependency frameworkDependency =
-          getOnlyElement(frameworkDependenciesForBinding(binding));
-      CodeBlock dependencyArgument =
-          getDependencyArgument(frameworkDependency).getExpressionFor(name);
-      return optionalFactories.presentOptionalProvider(valueKind, dependencyArgument);
+      return optionalFactories.presentOptionalFactory(
+          binding, getOnlyElement(getDependencyArguments(binding)));
     }
   }
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
index 9b5810e39..196486780 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
@@ -23,8 +23,8 @@
 import static com.google.common.base.Predicates.in;
 import static com.google.common.base.Predicates.not;
 import static com.google.common.base.Verify.verify;
-import static com.google.common.collect.Iterables.getOnlyElement;
 import static com.google.common.collect.Iterables.isEmpty;
+import static dagger.internal.codegen.BindingKey.contribution;
 import static dagger.internal.codegen.BindingType.isOfType;
 import static dagger.internal.codegen.ComponentDescriptor.Kind.PRODUCTION_COMPONENT;
 import static dagger.internal.codegen.ComponentDescriptor.isComponentContributionMethod;
@@ -589,20 +589,26 @@ private boolean multibindingsRequireProduction(
       /**
        * Returns a synthetic binding for {@code @Qualifier Optional<Type>} if there are any {@code
        * optionalBindingDeclarations}.
+       *
+       * <p>If there are no bindings for the underlying key (the key for dependency requests for
+       * {@code Type}), returns a provision binding that always returns {@link Optional#absent()}.
+       *
+       * <p>If there are any production bindings for the underlying key, returns a production
+       * binding. Otherwise returns a provision binding.
        */
       private Optional<? extends ContributionBinding> syntheticOptionalBinding(
           Key key, ImmutableSet<OptionalBindingDeclaration> optionalBindingDeclarations) {
         if (optionalBindingDeclarations.isEmpty()) {
           return Optional.absent();
         }
-        ContributionBinding syntheticPresentBinding =
-            provisionBindingFactory.syntheticPresentBinding(key);
-        ResolvedBindings bindings =
-            lookUpBindings(getOnlyElement(syntheticPresentBinding.dependencies()).bindingKey());
-        if (bindings.isEmpty()) {
+        ResolvedBindings underlyingKeyBindings =
+            lookUpBindings(contribution(keyFactory.unwrapOptional(key).get()));
+        if (underlyingKeyBindings.isEmpty()) {
           return Optional.of(provisionBindingFactory.syntheticAbsentBinding(key));
-        } else { // TODO(dpb): Support producers.
-          return Optional.of(syntheticPresentBinding);
+        } else if (underlyingKeyBindings.bindingTypes().contains(BindingType.PRODUCTION)) {
+          return Optional.of(productionBindingFactory.syntheticPresentBinding(key));
+        } else {
+          return Optional.of(provisionBindingFactory.syntheticPresentBinding(key));
         }
       }
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
index d44498a05..cf744ecff 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -41,7 +41,6 @@
 import static dagger.internal.codegen.ErrorMessages.CANNOT_INJECT_WILDCARD_TYPE;
 import static dagger.internal.codegen.ErrorMessages.CONTAINS_DEPENDENCY_CYCLE_FORMAT;
 import static dagger.internal.codegen.ErrorMessages.DEPENDS_ON_PRODUCTION_EXECUTOR_FORMAT;
-import static dagger.internal.codegen.ErrorMessages.DOUBLE_INDENT;
 import static dagger.internal.codegen.ErrorMessages.DUPLICATE_BINDINGS_FOR_KEY_FORMAT;
 import static dagger.internal.codegen.ErrorMessages.DUPLICATE_SIZE_LIMIT;
 import static dagger.internal.codegen.ErrorMessages.INDENT;
@@ -981,29 +980,12 @@ private void reportProviderMayNotDependOnProducer(DependencyPath path) {
       } else {
         FluentIterable<ContributionBinding> dependentProvisions =
             provisionsDependingOnLatestRequest(path);
-        if (dependentProvisions
-            .transform(ContributionBinding.KIND)
-            .contains(SYNTHETIC_OPTIONAL_BINDING)) {
-          // TODO(dpb): Implement @BindsOptionalOf for producers.
-          errorMessage
-              .append("Using optional bindings with @Produces bindings is not yet supported.\n")
-              .append(INDENT)
-              .append(formatCurrentDependencyRequestKey(path))
-              .append(" is produced at\n")
-              .append(DOUBLE_INDENT)
-              .append(
-                  bindingDeclarationFormatter.format(
-                      path.currentResolvedBindings().contributionBinding()))
-              .append('\n')
-              .append(dependencyRequestFormatter.toDependencyTrace(path));
-        } else {
-          // TODO(beder): Consider displaying all dependent provisions in the error message. If we
-          // do that, should we display all productions that depend on them also?
-          new Formatter(errorMessage)
-              .format(
-                  PROVIDER_MAY_NOT_DEPEND_ON_PRODUCER_FORMAT,
-                  dependentProvisions.iterator().next().key());
-        }
+        // TODO(beder): Consider displaying all dependent provisions in the error message. If we
+        // do that, should we display all productions that depend on them also?
+        new Formatter(errorMessage)
+            .format(
+                PROVIDER_MAY_NOT_DEPEND_ON_PRODUCER_FORMAT,
+                dependentProvisions.iterator().next().key());
       }
       reportBuilder.addError(errorMessage.toString(), path.entryPointElement());
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingType.java b/compiler/src/main/java/dagger/internal/codegen/BindingType.java
index 50220094d..06baa23b2 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingType.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingType.java
@@ -21,6 +21,9 @@
 import com.google.common.base.Predicates;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Sets;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.ParameterizedTypeName;
+import com.squareup.javapoet.TypeName;
 import dagger.MembersInjector;
 import dagger.producers.Producer;
 import javax.inject.Provider;
@@ -59,13 +62,18 @@
     return frameworkClass;
   }
 
+  /** Returns the {@link #frameworkClass()} parameterized with a type. */
+  ParameterizedTypeName frameworkClassOf(TypeName valueType) {
+    return ParameterizedTypeName.get(ClassName.get(frameworkClass()), valueType);
+  }
+
   /** A predicate that passes for {@link HasBindingType}s with a given type. */
   static Predicate<HasBindingType> isOfType(BindingType type) {
     return Predicates.compose(Predicates.equalTo(type), BINDING_TYPE);
   }
 
   /** A function that returns {@link HasBindingType#bindingType()}. */
-  static Function<HasBindingType, BindingType> BINDING_TYPE =
+  static final Function<HasBindingType, BindingType> BINDING_TYPE =
       new Function<HasBindingType, BindingType>() {
         @Override
         public BindingType apply(HasBindingType hasBindingType) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
index 9ca87cf2f..0adc85b8f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -26,6 +26,7 @@
 import javax.annotation.processing.Filer;
 import javax.annotation.processing.Messager;
 import javax.annotation.processing.Processor;
+import javax.annotation.processing.RoundEnvironment;
 import javax.lang.model.SourceVersion;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
@@ -170,6 +171,7 @@ public SourceVersion getSupportedSourceVersion() {
         new AnnotationCreatorGenerator(filer, elements);
     UnwrappedMapKeyGenerator unwrappedMapKeyGenerator =
         new UnwrappedMapKeyGenerator(filer, elements);
+
     ComponentHierarchyValidator componentHierarchyValidator = new ComponentHierarchyValidator();
     BindingGraphValidator bindingGraphValidator =
         new BindingGraphValidator(
@@ -238,12 +240,14 @@ public SourceVersion getSupportedSourceVersion() {
   }
 
   @Override
-  protected void postProcess() {
-    try {
-      injectBindingRegistry.generateSourcesForRequiredBindings(
-          factoryGenerator, membersInjectorGenerator);
-    } catch (SourceFileGenerationException e) {
-      e.printMessageTo(processingEnv.getMessager());
+  protected void postRound(RoundEnvironment roundEnv) {
+    if (!roundEnv.processingOver()) {
+      try {
+        injectBindingRegistry.generateSourcesForRequiredBindings(
+            factoryGenerator, membersInjectorGenerator);
+      } catch (SourceFileGenerationException e) {
+        e.printMessageTo(processingEnv.getMessager());
+      }
     }
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
index f4d1d9f91..fea0f29cc 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
@@ -24,6 +24,11 @@
 import static com.google.common.base.Preconditions.checkState;
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static dagger.internal.codegen.ConfigurationAnnotations.getNullableType;
+import static dagger.internal.codegen.TypeNames.lazyOf;
+import static dagger.internal.codegen.TypeNames.listenableFutureOf;
+import static dagger.internal.codegen.TypeNames.producedOf;
+import static dagger.internal.codegen.TypeNames.producerOf;
+import static dagger.internal.codegen.TypeNames.providerOf;
 
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
@@ -33,6 +38,7 @@
 import com.google.common.collect.Iterables;
 import com.google.common.util.concurrent.ListenableFuture;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
+import com.squareup.javapoet.TypeName;
 import dagger.Lazy;
 import dagger.MembersInjector;
 import dagger.Provides;
@@ -128,11 +134,40 @@
     KindAndType ofType(TypeMirror type) {
       return new AutoValue_DependencyRequest_KindAndType(this, type);
     }
+
+    /** Returns the type of a request of this kind for a key with a given type. */
+    TypeName typeName(TypeName keyType) {
+      switch (this) {
+        case INSTANCE:
+          return keyType;
+
+        case PROVIDER:
+          return providerOf(keyType);
+
+        case LAZY:
+          return lazyOf(keyType);
+
+        case PROVIDER_OF_LAZY:
+          return providerOf(lazyOf(keyType));
+
+        case PRODUCER:
+          return producerOf(keyType);
+
+        case PRODUCED:
+          return producedOf(keyType);
+
+        case FUTURE:
+          return listenableFutureOf(keyType);
+
+        default:
+          throw new AssertionError(this);
+      }
+    }
   }
 
   abstract Kind kind();
   abstract Key key();
-
+  
   BindingKey bindingKey() {
     switch (kind()) {
       case INSTANCE:
diff --git a/compiler/src/main/java/dagger/internal/codegen/Key.java b/compiler/src/main/java/dagger/internal/codegen/Key.java
index dd37e9c07..a05ae0bc9 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Key.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Key.java
@@ -18,9 +18,12 @@
 
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static com.google.auto.common.MoreTypes.asExecutable;
+import static com.google.auto.common.MoreTypes.isType;
+import static com.google.auto.common.MoreTypes.isTypeOf;
 import static com.google.common.base.Optional.presentInstances;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.collect.Iterables.getOnlyElement;
 import static dagger.internal.codegen.InjectionAnnotations.getQualifier;
 import static dagger.internal.codegen.MapKeys.getMapKey;
 import static dagger.internal.codegen.MapKeys.getUnwrappedMapKeyType;
@@ -39,7 +42,6 @@
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSetMultimap;
-import com.google.common.collect.Iterables;
 import com.google.common.collect.Multimaps;
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.Binds;
@@ -116,6 +118,46 @@
    */
   abstract Optional<MultibindingContributionIdentifier> multibindingContributionIdentifier();
 
+  abstract Builder toBuilder();
+
+  static Builder builder(TypeMirror type) {
+    return new AutoValue_Key.Builder().type(type);
+  }
+
+  @AutoValue.Builder
+  abstract static class Builder {
+    abstract Builder wrappedType(Equivalence.Wrapper<TypeMirror> wrappedType);
+
+    Builder type(TypeMirror type) {
+      return wrappedType(MoreTypes.equivalence().wrap(checkNotNull(type)));
+    }
+
+    abstract Builder wrappedQualifier(
+        Optional<Equivalence.Wrapper<AnnotationMirror>> wrappedQualifier);
+
+    abstract Builder wrappedQualifier(Equivalence.Wrapper<AnnotationMirror> wrappedQualifier);
+
+    Builder qualifier(AnnotationMirror qualifier) {
+      return wrappedQualifier(AnnotationMirrors.equivalence().wrap(checkNotNull(qualifier)));
+    }
+
+    Builder qualifier(Optional<AnnotationMirror> qualifier) {
+      return wrappedQualifier(wrapOptionalInEquivalence(checkNotNull(qualifier)));
+    }
+
+    Builder qualifier(TypeElement annotationType) {
+      return qualifier(SimpleAnnotationMirror.of(annotationType));
+    }
+
+    abstract Builder multibindingContributionIdentifier(
+        Optional<MultibindingContributionIdentifier> identifier);
+
+    abstract Builder multibindingContributionIdentifier(
+        MultibindingContributionIdentifier identifier);
+
+    abstract Key build();
+  }
+
   /**
    * An object that identifies a multibinding contribution method and the module class that
    * contributes it to the graph.
@@ -171,38 +213,14 @@ TypeMirror type() {
     return wrappedType().get();
   }
 
-  private static TypeMirror normalize(Types types, TypeMirror type) {
-    TypeKind kind = type.getKind();
-    return kind.isPrimitive() ? types.boxedClass((PrimitiveType) type).asType() : type;
-  }
-
-  /**
-   * A key whose {@link #qualifier()} and {@link #multibindingContributionIdentifier()} are
-   * equivalent to this one's, but with {@code newType} (normalized) as its {@link #type()}.
-   */
-  private Key withType(Types types, TypeMirror newType) {
-    return new AutoValue_Key(
-        wrappedQualifier(),
-        MoreTypes.equivalence().wrap(normalize(types, newType)),
-        multibindingContributionIdentifier());
-  }
-
-  /**
-   * A key whose {@link #qualifier()} and {@link #type()} are equivalent to this one's, but with
-   * {@code identifier} as its {@link #multibindingContributionIdentifier()}.
-   */
-  private Key withMultibindingContributionIdentifier(
-      MultibindingContributionIdentifier identifier) {
-    return new AutoValue_Key(wrappedQualifier(), wrappedType(), Optional.of(identifier));
-  }
-
   /**
    * A key whose {@link #qualifier()} and {@link #type()} are equivalent to this one's, but without
    * a {@link #multibindingContributionIdentifier()}.
    */
   Key withoutMultibindingContributionIdentifier() {
-    return new AutoValue_Key(
-        wrappedQualifier(), wrappedType(), Optional.<MultibindingContributionIdentifier>absent());
+    return toBuilder()
+        .multibindingContributionIdentifier(Optional.<MultibindingContributionIdentifier>absent())
+        .build();
   }
 
   boolean isValidMembersInjectionKey() {
@@ -297,70 +315,64 @@ public Key apply(HasKey hasKey) {
       this.elements = checkNotNull(elements);
     }
 
-    private DeclaredType setOf(TypeMirror elementType) {
-      return types.getDeclaredType(
-          elements.getTypeElement(Set.class.getCanonicalName()), elementType);
+    private TypeElement getClassElement(Class<?> cls) {
+      return elements.getTypeElement(cls.getCanonicalName());
     }
 
-    private DeclaredType mapOf(TypeMirror keyType, TypeMirror valueType) {
-      return types.getDeclaredType(
-          elements.getTypeElement(Map.class.getCanonicalName()), keyType, valueType);
+    private TypeMirror boxPrimitives(TypeMirror type) {
+      return type.getKind().isPrimitive() ? types.boxedClass((PrimitiveType) type).asType() : type;
     }
 
-    private TypeElement getProviderElement() {
-      return elements.getTypeElement(Provider.class.getCanonicalName());
+    private DeclaredType setOf(TypeMirror elementType) {
+      return types.getDeclaredType(getClassElement(Set.class), boxPrimitives(elementType));
     }
 
-    private TypeElement getProducerElement() {
-      return elements.getTypeElement(Producer.class.getCanonicalName());
+    private DeclaredType mapOf(TypeMirror keyType, TypeMirror valueType) {
+      return types.getDeclaredType(
+          getClassElement(Map.class), boxPrimitives(keyType), boxPrimitives(valueType));
     }
 
-    private TypeElement getClassElement(Class<?> cls) {
-      return elements.getTypeElement(cls.getName());
+    /** Returns {@code Map<KeyType, FrameworkType<ValueType>>}. */
+    private TypeMirror mapOfFrameworkType(
+        TypeMirror keyType, TypeElement frameworkType, TypeMirror valueType) {
+      return mapOf(keyType, types.getDeclaredType(frameworkType, boxPrimitives(valueType)));
     }
 
     Key forComponentMethod(ExecutableElement componentMethod) {
-      checkNotNull(componentMethod);
       checkArgument(componentMethod.getKind().equals(METHOD));
-      TypeMirror returnType = normalize(types, componentMethod.getReturnType());
-      return forMethod(componentMethod, returnType);
+      return forMethod(componentMethod, componentMethod.getReturnType());
     }
 
     Key forProductionComponentMethod(ExecutableElement componentMethod) {
-      checkNotNull(componentMethod);
       checkArgument(componentMethod.getKind().equals(METHOD));
-      TypeMirror returnType = normalize(types, componentMethod.getReturnType());
-      TypeMirror keyType = returnType;
-      if (MoreTypes.isTypeOf(ListenableFuture.class, returnType)) {
-        keyType = Iterables.getOnlyElement(MoreTypes.asDeclared(returnType).getTypeArguments());
-      }
+      TypeMirror returnType = componentMethod.getReturnType();
+      TypeMirror keyType =
+          isTypeOf(ListenableFuture.class, returnType)
+              ? getOnlyElement(MoreTypes.asDeclared(returnType).getTypeArguments())
+              : returnType;
       return forMethod(componentMethod, keyType);
     }
 
     Key forSubcomponentBuilderMethod(
         ExecutableElement subcomponentBuilderMethod, DeclaredType declaredContainer) {
-      checkNotNull(subcomponentBuilderMethod);
       checkArgument(subcomponentBuilderMethod.getKind().equals(METHOD));
       ExecutableType resolvedMethod =
           asExecutable(types.asMemberOf(declaredContainer, subcomponentBuilderMethod));
-      TypeMirror returnType = normalize(types, resolvedMethod.getReturnType());
-      return forMethod(subcomponentBuilderMethod, returnType);
+      return builder(resolvedMethod.getReturnType()).build();
     }
 
     Key forSubcomponentBuilder(TypeMirror builderType) {
-      checkNotNull(builderType);
-      return new AutoValue_Key(
-          Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
-          MoreTypes.equivalence().wrap(builderType),
-          Optional.<MultibindingContributionIdentifier>absent());
+      return builder(builderType).build();
     }
 
     Key forProvidesMethod(ExecutableElement method, TypeElement contributingModule) {
-      return forBindingMethod(method, contributingModule, Optional.of(getProviderElement()));
+      return forBindingMethod(
+          method, contributingModule, Optional.of(getClassElement(Provider.class)));
     }
 
     Key forProducesMethod(ExecutableElement method, TypeElement contributingModule) {
-      return forBindingMethod(method, contributingModule, Optional.of(getProducerElement()));
+      return forBindingMethod(
+          method, contributingModule, Optional.of(getClassElement(Producer.class)));
     }
 
     /** Returns the key bound by a {@link Binds} method. */
@@ -384,19 +396,22 @@ private Key forBindingMethod(
           MoreTypes.asExecutable(
               types.asMemberOf(MoreTypes.asDeclared(contributingModule.asType()), method));
       ContributionType contributionType = ContributionType.fromBindingMethod(method);
-      TypeMirror returnType = normalize(types, methodType.getReturnType());
+      TypeMirror returnType = methodType.getReturnType();
       if (frameworkType.isPresent()
-          && frameworkType.get().equals(getProducerElement())
-          && MoreTypes.isTypeOf(ListenableFuture.class, returnType)) {
-        returnType = Iterables.getOnlyElement(MoreTypes.asDeclared(returnType).getTypeArguments());
+          && frameworkType.get().equals(getClassElement(Producer.class))
+          && isType(returnType)
+          && isTypeOf(ListenableFuture.class, returnType)) {
+        returnType = getOnlyElement(MoreTypes.asDeclared(returnType).getTypeArguments());
       }
       TypeMirror keyType =
           bindingMethodKeyType(returnType, method, contributionType, frameworkType);
       Key key = forMethod(method, keyType);
       return contributionType.equals(ContributionType.UNIQUE)
           ? key
-          : key.withMultibindingContributionIdentifier(
-              new MultibindingContributionIdentifier(method, contributingModule));
+          : key.toBuilder()
+              .multibindingContributionIdentifier(
+                  new MultibindingContributionIdentifier(method, contributingModule))
+              .build();
     }
 
     /**
@@ -411,7 +426,7 @@ Key forMultibindsMethod(
       checkArgument(method.getKind().equals(METHOD), "%s must be a method", method);
       TypeElement factoryType =
           elements.getTypeElement(bindingType.frameworkClass().getCanonicalName());
-      TypeMirror returnType = normalize(types, executableType.getReturnType());
+      TypeMirror returnType = executableType.getReturnType();
       TypeMirror keyType =
           MapType.isMap(returnType)
               ? mapOfFrameworkType(
@@ -461,14 +476,6 @@ Key forDelegateBinding(
           : delegateDeclaration.key();
     }
 
-    /**
-     * Returns {@code Map<KeyType, FrameworkType<ValueType>>}.
-     */
-    private TypeMirror mapOfFrameworkType(
-        TypeMirror keyType, TypeElement frameworkType, TypeMirror valueType) {
-      return mapOf(keyType, types.getDeclaredType(frameworkType, valueType));
-    }
-
     private TypeMirror mapKeyType(ExecutableElement method) {
       AnnotationMirror mapKeyAnnotation = getMapKey(method).get();
       return MapKeys.unwrapValue(mapKeyAnnotation).isPresent()
@@ -477,56 +484,39 @@ private TypeMirror mapKeyType(ExecutableElement method) {
     }
 
     private Key forMethod(ExecutableElement method, TypeMirror keyType) {
-      return new AutoValue_Key(
-          wrapOptionalInEquivalence(getQualifier(method)),
-          MoreTypes.equivalence().wrap(keyType),
-          Optional.<MultibindingContributionIdentifier>absent());
+      return forQualifiedType(getQualifier(method), keyType);
     }
 
     Key forInjectConstructorWithResolvedType(TypeMirror type) {
-      return new AutoValue_Key(
-          Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
-          MoreTypes.equivalence().wrap(type),
-          Optional.<MultibindingContributionIdentifier>absent());
+      return builder(type).build();
     }
 
     Key forComponent(TypeMirror type) {
-      return new AutoValue_Key(
-          Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
-          MoreTypes.equivalence().wrap(normalize(types, type)),
-          Optional.<MultibindingContributionIdentifier>absent());
+      return builder(type).build();
     }
 
     Key forMembersInjectedType(TypeMirror type) {
-      return new AutoValue_Key(
-          Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
-          MoreTypes.equivalence().wrap(normalize(types, type)),
-          Optional.<MultibindingContributionIdentifier>absent());
+      return builder(type).build();
     }
 
     Key forQualifiedType(Optional<AnnotationMirror> qualifier, TypeMirror type) {
-      return new AutoValue_Key(
-          wrapOptionalInEquivalence(qualifier),
-          MoreTypes.equivalence().wrap(normalize(types, type)),
-          Optional.<MultibindingContributionIdentifier>absent());
+      return builder(boxPrimitives(type)).qualifier(qualifier).build();
     }
 
     Key forProductionExecutor() {
-      return forQualifiedType(
-          Optional.of(SimpleAnnotationMirror.of(getClassElement(Production.class))),
-          getClassElement(Executor.class).asType());
+      return builder(getClassElement(Executor.class).asType())
+          .qualifier(getClassElement(Production.class))
+          .build();
     }
 
     Key forProductionImplementationExecutor() {
-      return forQualifiedType(
-          Optional.of(SimpleAnnotationMirror.of(getClassElement(ProductionImplementation.class))),
-          getClassElement(Executor.class).asType());
+      return builder(getClassElement(Executor.class).asType())
+          .qualifier(getClassElement(ProductionImplementation.class))
+          .build();
     }
 
     Key forProductionComponentMonitor() {
-      return forQualifiedType(
-          Optional.<AnnotationMirror>absent(),
-          getClassElement(ProductionComponentMonitor.class).asType());
+      return builder(getClassElement(ProductionComponentMonitor.class).asType()).build();
     }
 
     /**
@@ -582,7 +572,7 @@ Key convertToDelegateKey(Key possibleMapKey) {
       } else {
         return possibleMapKey;
       }
-      return possibleMapKey.withType(types, mapOf(mapType.keyType(), wrappedValueType));
+      return possibleMapKey.toBuilder().type(mapOf(mapType.keyType(), wrappedValueType)).build();
     }
 
     /**
@@ -621,7 +611,7 @@ private Key wrapMapValue(Key key, Class<?> newWrappingClass) {
               types.getDeclaredType(
                   wrappingElement, mapType.unwrappedValueType(currentWrappingClass));
           return Optional.of(
-              possibleMapKey.withType(types, mapOf(mapType.keyType(), wrappedValueType)));
+              possibleMapKey.toBuilder().type(mapOf(mapType.keyType(), wrappedValueType)).build());
         }
       }
       return Optional.absent();
@@ -647,7 +637,7 @@ private Key wrapMapValue(Key key, Class<?> newWrappingClass) {
           DeclaredType wrappedValueType =
               types.getDeclaredType(wrappingElement, mapType.valueType());
           return Optional.of(
-              possibleMapKey.withType(types, mapOf(mapType.keyType(), wrappedValueType)));
+              possibleMapKey.toBuilder().type(mapOf(mapType.keyType(), wrappedValueType)).build());
         }
       }
       return Optional.absent();
@@ -662,7 +652,7 @@ private Key wrapMapValue(Key key, Class<?> newWrappingClass) {
         SetType setType = SetType.from(key);
         if (setType.elementsAreTypeOf(wrappingClass)) {
           return Optional.of(
-              key.withType(types, setOf(setType.unwrappedElementType(wrappingClass))));
+              key.toBuilder().type(setOf(setType.unwrappedElementType(wrappingClass))).build());
         }
       }
       return Optional.absent();
@@ -679,7 +669,7 @@ private Key wrapMapValue(Key key, Class<?> newWrappingClass) {
       }
       TypeMirror underlyingType =
           DependencyRequest.extractKindAndType(OptionalType.from(key).valueType()).type();
-      return Optional.of(key.withType(types, underlyingType));
+      return Optional.of(key.toBuilder().type(underlyingType).build());
     }
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/OptionalFactories.java b/compiler/src/main/java/dagger/internal/codegen/OptionalFactories.java
index d9a03cbc2..fea103f09 100644
--- a/compiler/src/main/java/dagger/internal/codegen/OptionalFactories.java
+++ b/compiler/src/main/java/dagger/internal/codegen/OptionalFactories.java
@@ -20,11 +20,12 @@
 import static com.google.common.base.CaseFormat.UPPER_UNDERSCORE;
 import static com.squareup.javapoet.MethodSpec.constructorBuilder;
 import static com.squareup.javapoet.MethodSpec.methodBuilder;
+import static com.squareup.javapoet.TypeSpec.anonymousClassBuilder;
 import static com.squareup.javapoet.TypeSpec.classBuilder;
 import static dagger.internal.codegen.AnnotationSpecs.SUPPRESS_WARNINGS_RAWTYPES;
 import static dagger.internal.codegen.AnnotationSpecs.SUPPRESS_WARNINGS_UNCHECKED;
 import static dagger.internal.codegen.TypeNames.PROVIDER;
-import static dagger.internal.codegen.TypeNames.lazyOf;
+import static dagger.internal.codegen.TypeNames.listenableFutureOf;
 import static dagger.internal.codegen.TypeNames.optionalOf;
 import static dagger.internal.codegen.TypeNames.providerOf;
 import static javax.lang.model.element.Modifier.FINAL;
@@ -32,7 +33,13 @@
 import static javax.lang.model.element.Modifier.PUBLIC;
 import static javax.lang.model.element.Modifier.STATIC;
 
+import com.google.common.base.Function;
 import com.google.common.base.Optional;
+import com.google.common.collect.HashBasedTable;
+import com.google.common.collect.Table;
+import com.google.common.util.concurrent.Futures;
+import com.google.common.util.concurrent.ListenableFuture;
+import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
 import com.squareup.javapoet.FieldSpec;
 import com.squareup.javapoet.MethodSpec;
@@ -43,13 +50,12 @@
 import com.squareup.javapoet.TypeVariableName;
 import dagger.internal.InstanceFactory;
 import dagger.internal.Preconditions;
-import java.util.EnumMap;
-import java.util.Map;
+import dagger.producers.Producer;
+import dagger.producers.internal.Producers;
 import javax.inject.Provider;
+import javax.lang.model.type.TypeMirror;
 
-/**
- * The nested class and static methods required by the component to implement optional bindings.
- */
+/** The nested class and static methods required by the component to implement optional bindings. */
 // TODO(dpb): Name classes correctly if a component uses both Guava and JDK Optional.
 final class OptionalFactories {
 
@@ -87,11 +93,15 @@
           .build();
 
   /**
-   * The factory classes that implement present optional bindings for a given kind of dependency
-   * request within the component.
+   * The factory classes that implement {@code Provider<Optional<T>>} or {@code
+   * Producer<Optional<T>>} for present optional bindings for a given kind of dependency request
+   * within the component.
+   *
+   * <p>The row key specifies whether the class implements {@link Provider} or {@link Producer}, and
+   * the column key specifies the kind of dependency request represented by {@code T}.
    */
-  private final Map<DependencyRequest.Kind, TypeSpec> presentFactoryClasses =
-      new EnumMap<>(DependencyRequest.Kind.class);
+  private final Table<BindingType, DependencyRequest.Kind, TypeSpec> presentFactoryClasses =
+      HashBasedTable.create();
 
   /**
    * If the component contains any absent optional bindings, this will be the member select for a
@@ -111,34 +121,42 @@ CodeBlock absentOptionalProvider() {
     }
     return absentOptionalProviderMethod.get();
   }
-
+  
   /**
    * Returns an expression for an instance of a nested class that implements {@code
-   * Provider<Optional<T>>} for a present optional binding, where {@code T} represents dependency
-   * requests of that kind.
+   * Provider<Optional<T>>} or {@code Producer<Optional<T>>} for a present optional binding, where
+   * {@code T} represents dependency requests of that kind.
    *
    * <ul>
    * <li>If {@code optionalRequestKind} is {@link DependencyRequest.Kind#INSTANCE}, the class
-   *     implements {@code Provider<Optional<T>>}.
+   *     implements {@code ProviderOrProducer<Optional<T>>}.
    * <li>If {@code optionalRequestKind} is {@link DependencyRequest.Kind#PROVIDER}, the class
    *     implements {@code Provider<Optional<Provider<T>>>}.
    * <li>If {@code optionalRequestKind} is {@link DependencyRequest.Kind#LAZY}, the class implements
    *     {@code Provider<Optional<Lazy<T>>>}.
    * <li>If {@code optionalRequestKind} is {@link DependencyRequest.Kind#PROVIDER_OF_LAZY}, the
    *     class implements {@code Provider<Optional<Provider<Lazy<T>>>>}.
+   * <li>If {@code optionalRequestKind} is {@link DependencyRequest.Kind#PRODUCER}, the class
+   *     implements {@code Producer<Optional<Producer<T>>>}.
+   * <li>If {@code optionalRequestKind} is {@link DependencyRequest.Kind#PRODUCED}, the class
+   *     implements {@code Producer<Optional<Produced<T>>>}.
    * </ul>
    *
-   * <p>Production requests are not yet supported.
-   *
-   * @param delegateProvider an expression for a {@link Provider} of the underlying type
+   * @param delegateFactory an expression for a {@link Provider} or {@link Producer} of the
+   *     underlying type
    */
-  CodeBlock presentOptionalProvider(DependencyRequest.Kind valueKind, CodeBlock delegateProvider) {
-    if (!presentFactoryClasses.containsKey(valueKind)) {
-      presentFactoryClasses.put(valueKind, createPresentFactoryClass(valueKind));
+  CodeBlock presentOptionalFactory(ContributionBinding binding, CodeBlock delegateFactory) {
+    TypeMirror valueType = OptionalType.from(binding.key()).valueType();
+    DependencyRequest.Kind valueKind = DependencyRequest.extractKindAndType(valueType).kind();
+    if (!presentFactoryClasses.contains(binding.bindingType(), valueKind)) {
+      presentFactoryClasses.put(
+          binding.bindingType(),
+          valueKind,
+          createPresentFactoryClass(binding.bindingType(), valueKind));
     }
-    return CodeBlock.of("$N.of($L)", presentFactoryClasses.get(valueKind), delegateProvider);
+    return CodeBlock.of(
+        "$N.of($L)", presentFactoryClasses.get(binding.bindingType(), valueKind), delegateFactory);
   }
-  
   /**
    * Adds classes and methods required by previous calls to {@link #absentOptionalProvider()} and
    * {@link #presentOptionalProvider(DependencyRequest.Kind, CodeBlock)} to the top-level {@code
@@ -153,77 +171,126 @@ void addMembers(TypeSpec.Builder component) {
     }
   }
 
-  private TypeSpec createPresentFactoryClass(DependencyRequest.Kind valueKind) {
-    String factoryClassName =
-        String.format(
-            "PresentOptional%sFactory", UPPER_UNDERSCORE.to(UPPER_CAMEL, valueKind.toString()));
-
+  private TypeSpec createPresentFactoryClass(
+      BindingType bindingType, DependencyRequest.Kind valueKind) {
     TypeVariableName typeVariable = TypeVariableName.get("T");
+    TypeName valueType = valueKind.typeName(typeVariable);
+    ParameterizedTypeName factoryType = bindingType.frameworkClassOf(optionalOf(valueType));
 
-    FieldSpec providerField =
-        FieldSpec.builder(providerOf(typeVariable), "provider", PRIVATE, FINAL).build();
+    FieldSpec delegateField =
+        FieldSpec.builder(bindingType.frameworkClassOf(typeVariable), "delegate", PRIVATE, FINAL)
+            .build();
+    ParameterSpec delegateParameter = ParameterSpec.builder(delegateField.type, "delegate").build();
 
-    ParameterSpec providerParameter =
-        ParameterSpec.builder(providerOf(typeVariable), "provider").build();
+    MethodSpec.Builder getMethodBuilder =
+        methodBuilder("get").addAnnotation(Override.class).addModifiers(PUBLIC);
+    switch (bindingType) {
+      case PROVISION:
+        getMethodBuilder
+            .returns(optionalOf(valueType))
+            .addCode(
+                "return $T.of($L);",
+                Optional.class,
+                FrameworkType.PROVIDER.to(valueKind, CodeBlock.of("$N", delegateField)));
+        break;
+
+      case PRODUCTION:
+        getMethodBuilder.returns(listenableFutureOf(optionalOf(valueType)));
+
+        switch (valueKind) {
+          case FUTURE: // return a ListenableFuture<Optional<ListenableFuture<T>>>
+          case PRODUCER: // return a ListenableFuture<Optional<Producer<T>>>
+            getMethodBuilder.addCode(
+                "return $T.immediateFuture($T.of($L));",
+                Futures.class,
+                Optional.class,
+                FrameworkType.PRODUCER.to(valueKind, CodeBlock.of("$N", delegateField)));
+            break;
+
+          case INSTANCE: // return a ListenableFuture<Optional<T>>
+            getMethodBuilder.addCode(
+                "return $L;",
+                transformFutureToOptional(typeVariable, CodeBlock.of("$N.get()", delegateField)));
+            break;
+
+          case PRODUCED: // return a ListenableFuture<Optional<Produced<T>>>
+            getMethodBuilder.addCode(
+                "return $L;",
+                transformFutureToOptional(
+                    valueType,
+                    CodeBlock.of(
+                        "$T.createFutureProduced($N.get())", Producers.class, delegateField)));
+            break;
+
+          default:
+            throw new UnsupportedOperationException(factoryType + " objects are not supported");
+        }
+        break;
+
+      default:
+        throw new AssertionError(bindingType);
+    }
+    MethodSpec getMethod = getMethodBuilder.build();
+
+    String factoryClassName =
+        String.format(
+            "PresentOptional%s%s",
+            UPPER_UNDERSCORE.to(UPPER_CAMEL, valueKind.toString()),
+            bindingType.frameworkClass().getSimpleName());
 
-    ParameterizedTypeName optionalType = optionalType(valueKind, typeVariable);
     return classBuilder(factoryClassName)
         .addTypeVariable(typeVariable)
         .addModifiers(PRIVATE, STATIC, FINAL)
-        .addSuperinterface(providerOf(optionalType))
+        .addSuperinterface(factoryType)
         .addJavadoc(
-            "A {@link $T} that returns an {@code $T} using a {@code Provider<T>}.",
-            Provider.class,
-            optionalType)
-        .addField(providerField)
+            "A {@link $T} that uses a delegate {@code $T}.", factoryType, delegateField.type)
+        .addField(delegateField)
         .addMethod(
             constructorBuilder()
                 .addModifiers(PRIVATE)
-                .addParameter(providerParameter)
+                .addParameter(delegateParameter)
                 .addCode(
                     "this.$N = $T.checkNotNull($N);",
-                    FieldSpec.builder(providerOf(typeVariable), "provider", PRIVATE, FINAL).build(),
+                    delegateField,
                     Preconditions.class,
-                    providerParameter)
-                .build())
-        .addMethod(
-            methodBuilder("get")
-                .addAnnotation(Override.class)
-                .addModifiers(PUBLIC)
-                .returns(optionalType)
-                .addCode(
-                    "return $T.of($L);",
-                    Optional.class,
-                    FrameworkType.PROVIDER.to(valueKind, CodeBlock.of("$N", providerField)))
+                    delegateParameter)
                 .build())
+        .addMethod(getMethod)
         .addMethod(
             methodBuilder("of")
                 .addModifiers(PRIVATE, STATIC)
                 .addTypeVariable(typeVariable)
-                .returns(providerOf(optionalType))
-                .addParameter(providerParameter)
-                .addCode("return new $L<T>($N);", factoryClassName, providerParameter)
+                .returns(factoryType)
+                .addParameter(delegateParameter)
+                .addCode(
+                    "return new $L<$T>($N);", factoryClassName, typeVariable, delegateParameter)
                 .build())
         .build();
   }
 
-  private ParameterizedTypeName optionalType(
-      DependencyRequest.Kind optionalValueKind, TypeName valueType) {
-    switch (optionalValueKind) {
-      case INSTANCE:
-        return optionalOf(valueType);
-
-      case LAZY:
-        return optionalOf(lazyOf(valueType));
-
-      case PROVIDER:
-        return optionalOf(providerOf(valueType));
-
-      case PROVIDER_OF_LAZY:
-        return optionalOf(providerOf(lazyOf(valueType)));
-
-      default:
-        throw new AssertionError(optionalValueKind);
-    }
+  /**
+   * An expression that uses {@link Futures#transform(ListenableFuture, Function)} to transform a
+   * {@code ListenableFuture<inputType>} into a {@code ListenableFuture<Optional<inputType>>}.
+   *
+   * @param inputFuture an expression of type {@code ListenableFuture<inputType>}
+   */
+  private static CodeBlock transformFutureToOptional(TypeName inputType, CodeBlock inputFuture) {
+    return CodeBlock.of(
+        "$T.transform($L, $L)",
+        Futures.class,
+        inputFuture,
+        anonymousClassBuilder("")
+            .addSuperinterface(
+                ParameterizedTypeName.get(
+                    ClassName.get(Function.class), inputType, optionalOf(inputType)))
+            .addMethod(
+                methodBuilder("apply")
+                    .addAnnotation(Override.class)
+                    .addModifiers(PUBLIC)
+                    .returns(optionalOf(inputType))
+                    .addParameter(inputType, "input")
+                    .addCode("return $T.of(input);", Optional.class)
+                    .build())
+            .build());
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
index 22efe9bbc..ed3dcba16 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
@@ -213,5 +213,20 @@ ProductionBinding delegate(
           .bindingKind(Kind.SYNTHETIC_DELEGATE_BINDING)
           .build();
     }
+
+    /**
+     * Returns a synthetic binding for an {@linkplain dagger.BindsOptionalOf optional binding} in a
+     * component with a binding for the underlying key.
+     */
+    ProductionBinding syntheticPresentBinding(Key key) {
+      return ProductionBinding.builder()
+          .contributionType(ContributionType.UNIQUE)
+          .key(key)
+          .bindingKind(Kind.SYNTHETIC_OPTIONAL_BINDING)
+          .dependencies(
+              dependencyRequestFactory.forSyntheticPresentOptionalBinding(
+                  key, DependencyRequest.Kind.PRODUCER))
+          .build();
+    }
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java b/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
index d146fe5d9..f372858a4 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
@@ -302,12 +302,16 @@ public BindingType bindingType() {
       // Only multibinding declarations, so assume provision.
       return BindingType.PROVISION;
     }
-    ImmutableSet<BindingType> bindingTypes =
-        FluentIterable.from(bindings()).transform(BindingType.BINDING_TYPE).toSet();
+    ImmutableSet<BindingType> bindingTypes = bindingTypes();
     checkState(bindingTypes.size() == 1, "conflicting binding types: %s", bindings());
     return getOnlyElement(bindingTypes);
   }
 
+  /** The binding types for {@link #bindings()}. */
+  ImmutableSet<BindingType> bindingTypes() {
+    return FluentIterable.from(bindings()).transform(BindingType.BINDING_TYPE).toSet();
+  }
+
   /**
    * The contribution type for these bindings.
    *
diff --git a/compiler/src/main/java/dagger/internal/codegen/Scope.java b/compiler/src/main/java/dagger/internal/codegen/Scope.java
index a76585853..49c1e01a0 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Scope.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Scope.java
@@ -16,12 +16,15 @@
 
 package dagger.internal.codegen;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
+import static com.google.common.base.Preconditions.checkArgument;
 import static dagger.internal.codegen.ErrorMessages.stripCommonTypePrefixes;
 import static dagger.internal.codegen.InjectionAnnotations.getScopes;
 
 import com.google.auto.common.AnnotationMirrors;
 import com.google.auto.common.MoreTypes;
+import com.google.auto.value.AutoValue;
+import com.google.common.base.Equivalence;
 import com.google.common.base.Function;
 import com.google.common.base.Optional;
 import com.google.common.collect.FluentIterable;
@@ -36,28 +39,45 @@
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.util.Elements;
 
-/**
- * A representation of the scope (or lack of it) associated with a component, providing method
- * or injection location.
- */
-final class Scope {
+/** A javax.inject.Scope. */
+@AutoValue
+abstract class Scope {
+
+  /** The underlying {@link AnnotationMirror} that represents the scope annotation. */
+  abstract Equivalence.Wrapper<AnnotationMirror> scopeAnnotation();
+
   /**
-   * The underlying {@link AnnotationMirror} that represents the scope annotation.
+   * Creates a {@link Scope} object from the {@link javax.inject.Scope}-annotated annotation type.
    */
-  private final AnnotationMirror annotationMirror;
+  static Scope scope(AnnotationMirror scopeAnnotation) {
+    checkArgument(
+        isAnnotationPresent(
+            scopeAnnotation.getAnnotationType().asElement(), javax.inject.Scope.class));
+    return new AutoValue_Scope(AnnotationMirrors.equivalence().wrap(scopeAnnotation));
+  }
 
-  private Scope(AnnotationMirror annotationMirror) {
-    this.annotationMirror = checkNotNull(annotationMirror);
+  /**
+   * Creates a {@link Scope} object from the {@link javax.inject.Scope}-annotated annotation type.
+   */
+  static Scope scope(TypeElement scopeType) {
+    return scope(SimpleAnnotationMirror.of(scopeType));
   }
 
-  /** Returns all of the associated scoped annotations from the source code element. */
+  private static Scope scope(Elements elements, Class<? extends Annotation> scopeAnnotationClass) {
+    return scope(elements.getTypeElement(scopeAnnotationClass.getCanonicalName()));
+  }
+
+  /** Returns all of the associated scopes for a source code element. */
   static ImmutableSet<Scope> scopesOf(Element element) {
-    return FluentIterable.from(getScopes(element)).
-        transform(new Function<AnnotationMirror, Scope>() {
-          @Override public Scope apply(AnnotationMirror annotationMirror) {
-            return new Scope(annotationMirror);
-          }
-        }).toSet();
+    return FluentIterable.from(getScopes(element))
+        .transform(
+            new Function<AnnotationMirror, Scope>() {
+              @Override
+              public Scope apply(AnnotationMirror annotationMirror) {
+                return scope(annotationMirror);
+              }
+            })
+        .toSet();
   }
 
   /**
@@ -69,7 +89,7 @@ private Scope(AnnotationMirror annotationMirror) {
     if (scopeAnnotations.isEmpty()) {
       return Optional.absent();
     }
-    return Optional.of(new Scope(Iterables.getOnlyElement(scopeAnnotations)));
+    return Optional.of(scope(Iterables.getOnlyElement(scopeAnnotations)));
   }
 
   /**
@@ -93,12 +113,6 @@ static Scope reusableScope(Elements elements) {
     return scope(elements, Reusable.class);
   }
 
-  private static Scope scope(Elements elements, Class<? extends Annotation> scopeAnnotationClass) {
-    return new Scope(
-        SimpleAnnotationMirror.of(
-            elements.getTypeElement(scopeAnnotationClass.getCanonicalName())));
-  }
-
   /**
    * Returns the readable source representation (name with @ prefix) of the annotation type.
    *
@@ -123,29 +137,7 @@ public String getQualifiedName() {
    * The scope annotation element.
    */
   public TypeElement scopeAnnotationElement() {
-    return MoreTypes.asTypeElement(annotationMirror.getAnnotationType());
-  }
-
-  /**
-   * Scopes are equal if the underlying {@link AnnotationMirror} are equivalent according to
-   * {@link AnnotationMirrors#equivalence()}.
-   */
-  @Override
-  public boolean equals(Object obj) {
-    if (this == obj) {
-      return true;
-    } else if (obj instanceof Scope) {
-      Scope that = (Scope) obj;
-      return AnnotationMirrors.equivalence()
-        .equivalent(this.annotationMirror, that.annotationMirror);
-    } else {
-      return false;
-    }
-  }
-
-  @Override
-  public int hashCode() {
-    return AnnotationMirrors.equivalence().hash(annotationMirror);
+    return MoreTypes.asTypeElement(scopeAnnotation().get().getAnnotationType());
   }
 
   /**
@@ -153,6 +145,6 @@ public int hashCode() {
    */
   @Override
   public String toString() {
-    return annotationMirror.toString();
+    return scopeAnnotation().get().toString();
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/SetType.java b/compiler/src/main/java/dagger/internal/codegen/SetType.java
index 0c59583fb..180fc66fb 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SetType.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SetType.java
@@ -17,7 +17,6 @@
 package dagger.internal.codegen;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkState;
 
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
@@ -77,7 +76,11 @@ TypeMirror unwrappedElementType(Class<?> wrappingClass) {
         wrappingClass.getTypeParameters().length == 1,
         "%s must have exactly one type parameter",
         wrappingClass);
-    checkState(elementsAreTypeOf(wrappingClass));
+    checkArgument(
+        elementsAreTypeOf(wrappingClass),
+        "expected elements to be %s, but this type is %s",
+        wrappingClass,
+        declaredSetType());
     return MoreTypes.asDeclared(elementType()).getTypeArguments().get(0);
   }
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/TypeNames.java b/compiler/src/main/java/dagger/internal/codegen/TypeNames.java
index 1e3cb30ba..c1e7883c0 100644
--- a/compiler/src/main/java/dagger/internal/codegen/TypeNames.java
+++ b/compiler/src/main/java/dagger/internal/codegen/TypeNames.java
@@ -80,12 +80,14 @@
   static final ClassName PRODUCERS = ClassName.get(Producers.class);
   static final ClassName PROVIDER = ClassName.get(Provider.class);
   static final ClassName PROVIDER_OF_LAZY = ClassName.get(ProviderOfLazy.class);
+
   static final ClassName SET = ClassName.get(Set.class);
   static final ClassName SET_FACTORY = ClassName.get(SetFactory.class);
   static final ClassName SET_OF_PRODUCED_PRODUCER = ClassName.get(SetOfProducedProducer.class);
   static final ClassName SET_PRODUCER = ClassName.get(SetProducer.class);
   static final ClassName SINGLE_CHECK = ClassName.get(SingleCheck.class);
   static final ClassName STRING = ClassName.get(String.class);
+
   static final ClassName UNSUPPORTED_OPERATION_EXCEPTION =
       ClassName.get(UnsupportedOperationException.class);
 
diff --git a/compiler/src/test/java/dagger/internal/codegen/DaggerModuleMethodSubject.java b/compiler/src/test/java/dagger/internal/codegen/DaggerModuleMethodSubject.java
index 61a54d8ea..7814c82f5 100644
--- a/compiler/src/test/java/dagger/internal/codegen/DaggerModuleMethodSubject.java
+++ b/compiler/src/test/java/dagger/internal/codegen/DaggerModuleMethodSubject.java
@@ -159,7 +159,7 @@ void hasError(String errorSubstring) {
   }
 
   private int methodLine(String source) {
-    String beforeMethod = source.substring(0, source.indexOf(getSubject()));
+    String beforeMethod = source.substring(0, source.indexOf(actual()));
     int methodLine = 1;
     for (int nextNewlineIndex = beforeMethod.indexOf('\n');
         nextNewlineIndex >= 0;
@@ -178,7 +178,7 @@ private String moduleSource() {
       writer.println(importLine);
     }
     writer.println();
-    writer.printf(declaration, "TestModule", "\n" + getSubject() + "\n");
+    writer.printf(declaration, "TestModule", "\n" + actual() + "\n");
     writer.println();
     return stringWriter.toString();
   }
diff --git a/compiler/src/test/java/dagger/internal/codegen/KeyTest.java b/compiler/src/test/java/dagger/internal/codegen/KeyTest.java
index 80a1bc3e3..930a52183 100644
--- a/compiler/src/test/java/dagger/internal/codegen/KeyTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/KeyTest.java
@@ -19,8 +19,6 @@
 import static com.google.common.truth.Truth.assertThat;
 
 import com.google.auto.common.MoreTypes;
-import com.google.common.base.Equivalence;
-import com.google.common.base.Optional;
 import com.google.common.collect.Iterables;
 import com.google.common.util.concurrent.ListenableFuture;
 import com.google.testing.compile.CompilationRule;
@@ -72,12 +70,7 @@
         Iterables.getOnlyElement(ElementFilter.constructorsIn(typeElement.getEnclosedElements()));
     Key key =
         keyFactory.forInjectConstructorWithResolvedType(constructor.getEnclosingElement().asType());
-    assertThat(key)
-        .isEqualTo(
-            new AutoValue_Key(
-                Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
-                MoreTypes.equivalence().wrap(typeElement.asType()),
-                Optional.<MultibindingContributionIdentifier>absent()));
+    assertThat(key).isEqualTo(Key.builder(typeElement.asType()).build());
     assertThat(key.toString()).isEqualTo("dagger.internal.codegen.KeyTest.InjectedClass");
   }
 
@@ -93,12 +86,7 @@
     ExecutableElement providesMethod =
         Iterables.getOnlyElement(ElementFilter.methodsIn(moduleElement.getEnclosedElements()));
     Key key = keyFactory.forProvidesMethod(providesMethod, moduleElement);
-    assertThat(key)
-        .isEqualTo(
-            new AutoValue_Key(
-                Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
-                MoreTypes.equivalence().wrap(stringType),
-                Optional.<MultibindingContributionIdentifier>absent()));
+    assertThat(key).isEqualTo(Key.builder(stringType).build());
     assertThat(key.toString()).isEqualTo("java.lang.String");
   }
 
@@ -140,7 +128,7 @@
     Element injectionField =
         Iterables.getOnlyElement(ElementFilter.fieldsIn(injectableElement.getEnclosedElements()));
     AnnotationMirror qualifier = Iterables.getOnlyElement(injectionField.getAnnotationMirrors());
-    Key injectionKey = keyFactory.forQualifiedType(Optional.<AnnotationMirror>of(qualifier), type);
+    Key injectionKey = Key.builder(type).qualifier(qualifier).build();
 
     assertThat(provisionKey).isEqualTo(injectionKey);
     assertThat(injectionKey.toString())
@@ -180,11 +168,10 @@ String provideQualifiedString() {
       Key key = keyFactory.forProvidesMethod(providesMethod, moduleElement);
       assertThat(key)
           .isEqualTo(
-              new AutoValue_Key(
-                  Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
-                  MoreTypes.equivalence().wrap(setOfStringsType),
-                  Optional.of(
-                      new MultibindingContributionIdentifier(providesMethod, moduleElement))));
+              Key.builder(setOfStringsType)
+                  .multibindingContributionIdentifier(
+                      new MultibindingContributionIdentifier(providesMethod, moduleElement))
+                  .build());
       assertThat(key.toString())
           .isEqualTo(
               String.format(
@@ -248,12 +235,7 @@ String provideQualifiedString() {
     for (ExecutableElement producesMethod
         : ElementFilter.methodsIn(moduleElement.getEnclosedElements())) {
       Key key = keyFactory.forProducesMethod(producesMethod, moduleElement);
-      assertThat(key)
-          .isEqualTo(
-              new AutoValue_Key(
-                  Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
-                  MoreTypes.equivalence().wrap(stringType),
-                  Optional.<MultibindingContributionIdentifier>absent()));
+      assertThat(key).isEqualTo(Key.builder(stringType).build());
       assertThat(key.toString()).isEqualTo("java.lang.String");
     }
   }
@@ -280,11 +262,10 @@ String provideQualifiedString() {
       Key key = keyFactory.forProducesMethod(producesMethod, moduleElement);
       assertThat(key)
           .isEqualTo(
-              new AutoValue_Key(
-                  Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
-                  MoreTypes.equivalence().wrap(setOfStringsType),
-                  Optional.of(
-                      new MultibindingContributionIdentifier(producesMethod, moduleElement))));
+              Key.builder(setOfStringsType)
+                  .multibindingContributionIdentifier(
+                      new MultibindingContributionIdentifier(producesMethod, moduleElement))
+                  .build());
       assertThat(key.toString())
           .isEqualTo(
               String.format(
diff --git a/compiler/src/test/java/dagger/internal/codegen/SubcomponentValidationTest.java b/compiler/src/test/java/dagger/internal/codegen/SubcomponentValidationTest.java
index 9c011f882..c1ed888f4 100644
--- a/compiler/src/test/java/dagger/internal/codegen/SubcomponentValidationTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/SubcomponentValidationTest.java
@@ -17,7 +17,6 @@
 package dagger.internal.codegen;
 
 import static com.google.common.truth.Truth.assertAbout;
-import static com.google.common.truth.Truth.assertThat;
 import static com.google.testing.compile.JavaSourcesSubject.assertThat;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
 import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
diff --git a/core/src/main/java/dagger/BindsOptionalOf.java b/core/src/main/java/dagger/BindsOptionalOf.java
index 481453615..a104cb916 100644
--- a/core/src/main/java/dagger/BindsOptionalOf.java
+++ b/core/src/main/java/dagger/BindsOptionalOf.java
@@ -22,7 +22,6 @@
 import java.lang.annotation.Documented;
 import java.lang.annotation.Target;
 import javax.inject.Inject;
-import javax.inject.Provider;
 import javax.inject.Qualifier;
 
 /**
@@ -60,9 +59,16 @@
  * <li>{@code Optional<Provider<Lazy<Foo>>>}
  * </ul>
  *
- * or a {@link Provider}, {@link Lazy}, or {@link Provider} of {@link Lazy} of any of the above.
- *
  * <p>Explicit bindings for any of the above will conflict with a {@code @BindsOptionalOf} binding.
+ *
+ * <p>If the binding for {@code Foo} is a {@code @Produces} binding, then another {@code @Produces}
+ * binding can depend on any of:
+ *
+ * <ul>
+ * <li>{@code Optional<Foo>}
+ * <li>{@code Optional<Producer<Foo>>}
+ * <li>{@code Optional<Produced<Foo>>}
+ * </ul>
  */
 @Documented
 @Beta
diff --git a/pom.xml b/pom.xml
index d95579bdc..ba8f0ea23 100644
--- a/pom.xml
+++ b/pom.xml
@@ -47,11 +47,11 @@
     <java.version>1.7</java.version>
     <javax.inject.version>1</javax.inject.version>
     <javax.annotation.version>3.0.1</javax.annotation.version>
-    <auto.common.version>0.6</auto.common.version>
+    <auto.common.version>0.7</auto.common.version>
     <auto.factory.version>1.0-beta3</auto.factory.version>
     <auto.service.version>1.0-rc2</auto.service.version>
-    <auto.value.version>1.3-rc2</auto.value.version>
-    <errorprone.version>2.0.8</errorprone.version>
+    <auto.value.version>1.3</auto.value.version>
+    <errorprone.version>2.0.12</errorprone.version>
     <guava.version>19.0</guava.version>
     <google.java.format.version>1.0</google.java.format.version>
 
@@ -60,7 +60,7 @@
     <compile-testing.version>0.9</compile-testing.version>
     <junit.version>4.11</junit.version>
     <mockito.version>1.9.5</mockito.version>
-    <truth.version>0.28</truth.version>
+    <truth.version>0.30</truth.version>
   </properties>
 
   <scm>
