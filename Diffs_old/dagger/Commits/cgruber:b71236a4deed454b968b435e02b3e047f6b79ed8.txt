diff --git a/core/src/main/java/dagger/internal/FailoverLoader.java b/core/src/main/java/dagger/internal/FailoverLoader.java
index 350bd8fd6..a9fb26031 100644
--- a/core/src/main/java/dagger/internal/FailoverLoader.java
+++ b/core/src/main/java/dagger/internal/FailoverLoader.java
@@ -36,18 +36,18 @@
    * be wasteful in terms of both CPU and memory allocated.
    */
 
-  private final LruCache<Class<?>, ModuleAdapter<?>> loadedAdapters =
-      new LruCache<Class<?>, ModuleAdapter<?>>(Integer.MAX_VALUE) {
-    @Override protected ModuleAdapter<?> create(Class<?> type) {
-      ModuleAdapter<?> result =
-          instantiate(type.getName().concat(MODULE_ADAPTER_SUFFIX), type.getClassLoader());
-      if (result == null) {
-        throw new IllegalStateException("Module adapter for " + type + " could not be loaded. "
-            + "Please ensure that code generation was run for this module.");
-      }
-      return result;
-    }
-  };
+  private final Memoizer<Class<?>, ModuleAdapter<?>> loadedAdapters =
+      new Memoizer<Class<?>, ModuleAdapter<?>>() {
+        @Override protected ModuleAdapter<?> create(Class<?> type) {
+          ModuleAdapter<?> result =
+              instantiate(type.getName().concat(MODULE_ADAPTER_SUFFIX), type.getClassLoader());
+          if (result == null) {
+            throw new IllegalStateException("Module adapter for " + type + " could not be loaded. "
+                + "Please ensure that code generation was run for this module.");
+          }
+          return result;
+        }
+      };
 
   /**
    * Obtains a module adapter for {@code module} from the first responding resolver.
diff --git a/core/src/main/java/dagger/internal/Keys.java b/core/src/main/java/dagger/internal/Keys.java
index da7eeb206..53a4d7af0 100644
--- a/core/src/main/java/dagger/internal/Keys.java
+++ b/core/src/main/java/dagger/internal/Keys.java
@@ -46,12 +46,12 @@
   private static final String LAZY_PREFIX = Lazy.class.getCanonicalName() + "<";
   private static final String SET_PREFIX = Set.class.getCanonicalName() + "<";
 
-  private static final LruCache<Class<? extends Annotation>, Boolean> IS_QUALIFIER_ANNOTATION
-      = new LruCache<Class<? extends Annotation>, Boolean>(Integer.MAX_VALUE) {
-    @Override protected Boolean create(Class<? extends Annotation> annotationType) {
-      return annotationType.isAnnotationPresent(Qualifier.class);
-    }
-  };
+  private static final Memoizer<Class<? extends Annotation>, Boolean> IS_QUALIFIER_ANNOTATION =
+      new Memoizer<Class<? extends Annotation>, Boolean>() {
+        @Override protected Boolean create(Class<? extends Annotation> annotationType) {
+          return annotationType.isAnnotationPresent(Qualifier.class);
+        }
+      };
 
   Keys() {
   }
diff --git a/core/src/main/java/dagger/internal/Loader.java b/core/src/main/java/dagger/internal/Loader.java
index c367a5314..ed81edec6 100644
--- a/core/src/main/java/dagger/internal/Loader.java
+++ b/core/src/main/java/dagger/internal/Loader.java
@@ -25,21 +25,20 @@
  * provide all resolution methods
  */
 public abstract class Loader {
-
-  private final LruCache<ClassLoader, LruCache<String, Class<?>>> caches =
-      new LruCache<ClassLoader, LruCache<String, Class<?>>>(Integer.MAX_VALUE) {
-    @Override protected LruCache<String, Class<?>> create(final ClassLoader classLoader) {
-      return new LruCache<String, Class<?>>(Integer.MAX_VALUE) {
-        @Override protected Class<?> create(String className) {
-          try {
-            return classLoader.loadClass(className);
-          } catch (ClassNotFoundException e) {
-            return Void.class; // Cache the failure (negative case).
-          }
+  private final Memoizer<ClassLoader, Memoizer<String, Class<?>>> caches =
+      new Memoizer<ClassLoader, Memoizer<String, Class<?>>>() {
+        @Override protected Memoizer<String, Class<?>> create(final ClassLoader classLoader) {
+          return new Memoizer<String, Class<?>>() {
+            @Override protected Class<?> create(String className) {
+              try {
+                return classLoader.loadClass(className);
+              } catch (ClassNotFoundException e) {
+                return Void.class; // Cache the failure (negative case).
+              }
+            }
+          };
         }
       };
-    }
-  };
 
   /**
    * Returns a binding that uses {@code @Inject} annotations, or null if no valid binding can
diff --git a/core/src/main/java/dagger/internal/LruCache.java b/core/src/main/java/dagger/internal/LruCache.java
deleted file mode 100644
index 6ca506247..000000000
--- a/core/src/main/java/dagger/internal/LruCache.java
+++ /dev/null
@@ -1,319 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal;
-
-import java.util.LinkedHashMap;
-import java.util.Map;
-
-/**
- * Private copy of {@code android.util.LruCache}.
- */
-class LruCache<K, V> {
-  private final LinkedHashMap<K, V> map;
-
-  /** Size of this cache in units. Not necessarily the number of elements. */
-  private int size;
-  private int maxSize;
-
-  private int putCount;
-  private int createCount;
-  private int evictionCount;
-  private int hitCount;
-  private int missCount;
-
-  /**
-   * @param maxSize for caches that do not override {@link #sizeOf}, this is
-   *     the maximum number of entries in the cache. For all other caches,
-   *     this is the maximum sum of the sizes of the entries in this cache.
-   */
-  public LruCache(int maxSize) {
-    if (maxSize <= 0) {
-      throw new IllegalArgumentException("maxSize <= 0");
-    }
-    this.maxSize = maxSize;
-    this.map = new LinkedHashMap<K, V>(0, 0.75f, true);
-  }
-
-  /**
-   * Returns the value for {@code key} if it exists in the cache or can be
-   * created by {@code #create}. If a value was returned, it is moved to the
-   * head of the queue. This returns null if a value is not cached and cannot
-   * be created.
-   */
-  public final V get(K key) {
-    if (key == null) {
-      throw new NullPointerException("key == null");
-    }
-
-    V mapValue;
-    synchronized (this) {
-      mapValue = map.get(key);
-      if (mapValue != null) {
-        hitCount++;
-        return mapValue;
-      }
-      missCount++;
-    }
-
-    /*
-    * Attempt to create a value. This may take a long time, and the map
-    * may be different when create() returns. If a conflicting value was
-    * added to the map while create() was working, we leave that value in
-    * the map and release the created value.
-    */
-
-    V createdValue = create(key);
-    if (createdValue == null) {
-      return null;
-    }
-
-    synchronized (this) {
-      createCount++;
-      mapValue = map.put(key, createdValue);
-
-      if (mapValue != null) {
-        // There was a conflict so undo that last put
-        map.put(key, mapValue);
-      } else {
-        size += safeSizeOf(key, createdValue);
-      }
-    }
-
-    if (mapValue != null) {
-      entryRemoved(false, key, createdValue, mapValue);
-      return mapValue;
-    } else {
-      trimToSize(maxSize);
-      return createdValue;
-    }
-  }
-
-  /**
-   * Caches {@code value} for {@code key}. The value is moved to the head of
-   * the queue.
-   *
-   * @return the previous value mapped by {@code key}.
-   */
-  public final V put(K key, V value) {
-    if (key == null || value == null) {
-      throw new NullPointerException("key == null || value == null");
-    }
-
-    V previous;
-    synchronized (this) {
-      putCount++;
-      size += safeSizeOf(key, value);
-      previous = map.put(key, value);
-      if (previous != null) {
-        size -= safeSizeOf(key, previous);
-      }
-    }
-
-    if (previous != null) {
-      entryRemoved(false, key, previous, value);
-    }
-
-    trimToSize(maxSize);
-    return previous;
-  }
-
-  /**
-   * @param maxSize the maximum size of the cache before returning. May be -1
-   *     to evict even 0-sized elements.
-   */
-  private void trimToSize(int maxSize) {
-    while (true) {
-      K key;
-      V value;
-      synchronized (this) {
-        if (size < 0 || (map.isEmpty() && size != 0)) {
-          throw new IllegalStateException(getClass().getName()
-              + ".sizeOf() is reporting inconsistent results!");
-        }
-
-        if (size <= maxSize || map.isEmpty()) {
-          break;
-        }
-
-        Map.Entry<K, V> toEvict = map.entrySet().iterator().next();
-        key = toEvict.getKey();
-        value = toEvict.getValue();
-        map.remove(key);
-        size -= safeSizeOf(key, value);
-        evictionCount++;
-      }
-
-      entryRemoved(true, key, value, null);
-    }
-  }
-
-  /**
-   * Removes the entry for {@code key} if it exists.
-   *
-   * @return the previous value mapped by {@code key}.
-   */
-  public final V remove(K key) {
-    if (key == null) {
-      throw new NullPointerException("key == null");
-    }
-
-    V previous;
-    synchronized (this) {
-      previous = map.remove(key);
-      if (previous != null) {
-        size -= safeSizeOf(key, previous);
-      }
-    }
-
-    if (previous != null) {
-      entryRemoved(false, key, previous, null);
-    }
-
-    return previous;
-  }
-
-  /**
-   * Called for entries that have been evicted or removed. This method is
-   * invoked when a value is evicted to make space, removed by a call to
-   * {@link #remove}, or replaced by a call to {@link #put}. The default
-   * implementation does nothing.
-   *
-   * <p>The method is called without synchronization: other threads may
-   * access the cache while this method is executing.
-   *
-   * @param evicted true if the entry is being removed to make space, false
-   *     if the removal was caused by a {@link #put} or {@link #remove}.
-   * @param newValue the new value for {@code key}, if it exists. If non-null,
-   *     this removal was caused by a {@link #put}. Otherwise it was caused by
-   *     an eviction or a {@link #remove}.
-   */
-  protected void entryRemoved(boolean evicted, K key, V oldValue, V newValue) {
-  }
-
-  /**
-   * Called after a cache miss to compute a value for the corresponding key.
-   * Returns the computed value or null if no value can be computed. The
-   * default implementation returns null.
-   *
-   * <p>The method is called without synchronization: other threads may
-   * access the cache while this method is executing.
-   *
-   * <p>If a value for {@code key} exists in the cache when this method
-   * returns, the created value will be released with {@link #entryRemoved}
-   * and discarded. This can occur when multiple threads request the same key
-   * at the same time (causing multiple values to be created), or when one
-   * thread calls {@link #put} while another is creating a value for the same
-   * key.
-   */
-  protected V create(K key) {
-    return null;
-  }
-
-  private int safeSizeOf(K key, V value) {
-    int result = sizeOf(key, value);
-    if (result < 0) {
-      throw new IllegalStateException("Negative size: " + key + "=" + value);
-    }
-    return result;
-  }
-
-  /**
-   * Returns the size of the entry for {@code key} and {@code value} in
-   * user-defined units.  The default implementation returns 1 so that size
-   * is the number of entries and max size is the maximum number of entries.
-   *
-   * <p>An entry's size must not change while it is in the cache.
-   */
-  protected int sizeOf(K key, V value) {
-    return 1;
-  }
-
-  /**
-   * Clear the cache, calling {@link #entryRemoved} on each removed entry.
-   */
-  public final void evictAll() {
-    trimToSize(-1); // -1 will evict 0-sized elements
-  }
-
-  /**
-   * For caches that do not override {@link #sizeOf}, this returns the number
-   * of entries in the cache. For all other caches, this returns the sum of
-   * the sizes of the entries in this cache.
-   */
-  public synchronized final int size() {
-    return size;
-  }
-
-  /**
-   * For caches that do not override {@link #sizeOf}, this returns the maximum
-   * number of entries in the cache. For all other caches, this returns the
-   * maximum sum of the sizes of the entries in this cache.
-   */
-  public synchronized final int maxSize() {
-    return maxSize;
-  }
-
-  /**
-   * Returns the number of times {@link #get} returned a value.
-   */
-  public synchronized final int hitCount() {
-    return hitCount;
-  }
-
-  /**
-   * Returns the number of times {@link #get} returned null or required a new
-   * value to be created.
-   */
-  public synchronized final int missCount() {
-    return missCount;
-  }
-
-  /**
-   * Returns the number of times {@link #create(Object)} returned a value.
-   */
-  public synchronized final int createCount() {
-    return createCount;
-  }
-
-  /**
-   * Returns the number of times {@link #put} was called.
-   */
-  public synchronized final int putCount() {
-    return putCount;
-  }
-
-  /**
-   * Returns the number of values that have been evicted.
-   */
-  public synchronized final int evictionCount() {
-    return evictionCount;
-  }
-
-  /**
-   * Returns a copy of the current contents of the cache, ordered from least
-   * recently accessed to most recently accessed.
-   */
-  public synchronized final Map<K, V> snapshot() {
-    return new LinkedHashMap<K, V>(map);
-  }
-
-  @Override public synchronized final String toString() {
-    int accesses = hitCount + missCount;
-    int hitPercent = accesses != 0 ? (100 * hitCount / accesses) : 0;
-    return String.format("LruCache[maxSize=%d,hits=%d,misses=%d,hitRate=%d%%]",
-        maxSize, hitCount, missCount, hitPercent);
-  }
-}
\ No newline at end of file
diff --git a/core/src/main/java/dagger/internal/Memoizer.java b/core/src/main/java/dagger/internal/Memoizer.java
new file mode 100644
index 000000000..300cb9a94
--- /dev/null
+++ b/core/src/main/java/dagger/internal/Memoizer.java
@@ -0,0 +1,81 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.concurrent.locks.Lock;
+import java.util.concurrent.locks.ReadWriteLock;
+import java.util.concurrent.locks.ReentrantReadWriteLock;
+
+/**
+ * Represents an operation to be
+ */
+abstract class Memoizer<K, V> {
+  private final Map<K, V> map;
+  private final Lock readLock;
+  private final Lock writeLock;
+
+  public Memoizer() {
+    this.map = new HashMap<K, V>();
+    ReadWriteLock lock = new ReentrantReadWriteLock();
+    this.readLock = lock.readLock();
+    this.writeLock = lock.writeLock();
+  }
+
+  public final V get(K key) {
+    if (key == null) {
+      throw new NullPointerException("key == null");
+    }
+
+    // check to see if we already have a value
+    readLock.lock();
+    try {
+      V value = map.get(key);
+      if (value != null) {
+        return value;
+      }
+    } finally {
+      readLock.unlock();
+    }
+
+    // create a new value.  this may race and we might create more than one instance, but that's ok
+    V newValue = create(key);
+    if (newValue == null) {
+      throw new NullPointerException("create returned null");
+    }
+
+    // write the new value and return it
+    writeLock.lock();
+    try {
+      map.put(key, newValue);
+      return newValue;
+    } finally {
+      writeLock.unlock();
+    }
+  }
+
+  protected abstract V create(K key);
+
+  @Override public synchronized final String toString() {
+    readLock.lock();
+    try {
+      return map.toString();
+    } finally {
+      readLock.unlock();
+    }
+  }
+}
\ No newline at end of file
