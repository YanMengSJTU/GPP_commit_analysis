diff --git a/compiler/src/it/functional-tests/src/main/java/test/MultibindingComponent.java b/compiler/src/it/functional-tests/src/main/java/test/MultibindingComponent.java
index 731df3f57..7db102e22 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/MultibindingComponent.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/MultibindingComponent.java
@@ -28,4 +28,5 @@
   Set<String> mapKeys();
   Collection<String> mapValues();
   Set<Integer> set();
+  Map<TestKey.NestedWrappedKey, String> nestedKeyMap();
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/MultibindingModule.java b/compiler/src/it/functional-tests/src/main/java/test/MultibindingModule.java
index 2b9b441ac..1e2e2968e 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/MultibindingModule.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/MultibindingModule.java
@@ -50,4 +50,12 @@
   @Provides Collection<String> provideMapValues(Map<String, String> map) {
     return map.values();
   }
+
+  @Provides(type = MAP) @TestKey.NestedWrappedKey(Integer.class) String valueForInteger() {
+    return "integer";
+  }
+
+  @Provides(type = MAP) @TestKey.NestedWrappedKey(Long.class) String valueForLong() {
+    return "long";
+  }
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/TestKey.java b/compiler/src/it/functional-tests/src/main/java/test/TestKey.java
index 549eb3fa7..645af788a 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/TestKey.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/TestKey.java
@@ -20,4 +20,9 @@
 @MapKey(unwrapValue = true)
 @interface TestKey {
   String value();
+
+  @MapKey(unwrapValue = false)
+  @interface NestedWrappedKey {
+    Class<?> value();
+  }
 }
diff --git a/compiler/src/it/functional-tests/src/test/java/test/MultibindingTest.java b/compiler/src/it/functional-tests/src/test/java/test/MultibindingTest.java
index 04235b68b..1f6a8cd76 100644
--- a/compiler/src/it/functional-tests/src/test/java/test/MultibindingTest.java
+++ b/compiler/src/it/functional-tests/src/test/java/test/MultibindingTest.java
@@ -1,20 +1,20 @@
 /*
-* Copyright (C) 2015 Google, Inc.
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
-*
-* http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS,
-* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-* See the License for the specific language governing permissions and
-* limitations under the License.
-*/
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
+ * in compliance with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
 package test;
 
+import com.google.auto.value.AutoAnnotation;
+import com.google.common.collect.ImmutableMap;
 import java.util.Map;
 import javax.inject.Provider;
 import org.junit.Test;
@@ -25,7 +25,8 @@
 
 @RunWith(JUnit4.class)
 public class MultibindingTest {
-  @Test public void testMultibindings() {
+  @Test
+  public void testMultibindings() {
     MultibindingComponent multibindingComponent = DaggerMultibindingComponent.create();
     Map<String, String> map = multibindingComponent.map();
     assertThat(map).hasSize(2);
@@ -38,5 +39,14 @@
     assertThat(multibindingComponent.mapKeys()).containsExactly("foo", "bar");
     assertThat(multibindingComponent.mapValues()).containsExactly("foo value", "bar value");
     assertThat(multibindingComponent.set()).containsExactly(5, 6);
+    assertThat(multibindingComponent.nestedKeyMap()).isEqualTo(
+        ImmutableMap.of(
+            nestedWrappedKey(Integer.class), "integer",
+            nestedWrappedKey(Long.class), "long"));
+  }
+
+  @AutoAnnotation
+  static TestKey.NestedWrappedKey nestedWrappedKey(Class<?> value) {
+    return new AutoAnnotation_MultibindingTest_nestedWrappedKey(value);
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
index c6c376c2a..a581eea24 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
@@ -1426,8 +1426,9 @@ public Snippet apply(AnnotationValue value) {
       for (Snippet snippet : annotationValueNames) {
         snippets.add(snippet);
       }
-      argsBuilder.add(Snippet.format("%sCreator.create(%s)",
-          TypeNames.forTypeMirror(mapKeyAnnotationMirror.getAnnotationType()),
+      argsBuilder.add(Snippet.format("%s.create(%s)",
+          Util.getMapKeyCreatorClassName(
+              MoreTypes.asTypeElement(mapKeyAnnotationMirror.getAnnotationType())),
           Snippet.makeParametersSnippet(snippets.build())));
       argsBuilder.add(factory);
     } else { // unwrapped key case
diff --git a/compiler/src/main/java/dagger/internal/codegen/MapKeyGenerator.java b/compiler/src/main/java/dagger/internal/codegen/MapKeyGenerator.java
index b11eeec9a..e0be1493a 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MapKeyGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MapKeyGenerator.java
@@ -38,7 +38,7 @@
 import static javax.lang.model.element.Modifier.STATIC;
 
 /**
- * Generates implementations to create{@link MapKey} instances
+ * Generates implementations to create {@link MapKey} instances
  *
  * @author Chenying Hou
  * @since 2.0
@@ -50,9 +50,7 @@
 
   @Override
   ClassName nameGeneratedType(Element e) {
-    ClassName enclosingClassName = ClassName.fromTypeElement((TypeElement)e);
-    return enclosingClassName.topLevelClassName().peerNamed(
-        enclosingClassName.classFileName() + "Creator");
+    return Util.getMapKeyCreatorClassName((TypeElement) e);
   }
 
   @Override
diff --git a/compiler/src/main/java/dagger/internal/codegen/Util.java b/compiler/src/main/java/dagger/internal/codegen/Util.java
index 7acb9d759..3adf6f6bd 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Util.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Util.java
@@ -26,6 +26,7 @@
 import com.google.common.collect.ImmutableSet.Builder;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Lists;
+import dagger.internal.codegen.writer.ClassName;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
@@ -111,6 +112,16 @@ protected TypeElement defaultAction(Object o, Void v) {
     return keyTypeElement;
   }
 
+  /**
+   * Returns the name of the generated class that contains the static {@code create} method for a
+   * {@code @MapKey} annotation type.
+   */
+  public static ClassName getMapKeyCreatorClassName(TypeElement mapKeyType) {
+    ClassName enclosingClassName = ClassName.fromTypeElement(mapKeyType);
+    return enclosingClassName.topLevelClassName().peerNamed(
+        enclosingClassName.classFileName() + "Creator");
+  }
+
   /**
    * Wraps an {@link Optional} of a type in an {@code Optional} of a {@link Wrapper} for that type.
    */
diff --git a/compiler/src/test/java/dagger/internal/codegen/MapKeyProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/MapKeyProcessorTest.java
index 6025b738b..b003a4fef 100644
--- a/compiler/src/test/java/dagger/internal/codegen/MapKeyProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/MapKeyProcessorTest.java
@@ -71,6 +71,53 @@ public void mapKeyCreatorFile() {
     .generatesSources(generatedKeyCreator);
   }
 
+  @Test
+  public void nestedMapKeyCreatorFile() {
+    JavaFileObject enumKeyFile = JavaFileObjects.forSourceLines("test.Container",
+        "package test;",
+        "import dagger.MapKey;",
+        "import java.lang.annotation.Retention;",
+        "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
+        "",
+        "public interface Container {",
+        "@MapKey(unwrapValue = false)",
+        "@Retention(RUNTIME)",
+        "public @interface PathKey {",
+        "  PathEnum value();",
+        "  String relativePath() default \"Defaultpath\";",
+        "}",
+        "}");
+    JavaFileObject pathEnumFile = JavaFileObjects.forSourceLines("test.PathEnum",
+        "package test;",
+        "",
+        "public enum PathEnum {",
+        "    ADMIN,",
+        "    LOGIN;",
+        "}");
+    JavaFileObject generatedKeyCreator =
+        JavaFileObjects.forSourceLines("test.Container$PathKeyCreator",
+            "package test;",
+            "",
+            "import javax.annotation.Generated;",
+            "import test.Container.PathKey",
+            "",
+            "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+            "public class Container$PathKeyCreator {",
+            "  @com.google.auto.value.AutoAnnotation",
+            "  public static PathKey create(PathEnum value, String relativePath) {",
+            "    return new AutoAnnotation_Container$PathKeyCreator_create(value, relativePath);",
+            "  }",
+            "}");
+    assert_().about(javaSources())
+    .that(ImmutableList.of(
+        enumKeyFile,
+        pathEnumFile))
+    .processedWith(new ComponentProcessor(), new AutoAnnotationProcessor())
+    .compilesWithoutError()
+    .and()
+    .generatesSources(generatedKeyCreator);
+  }
+
   @Test
   public void mapKeyComponentFileWithDisorderedKeyField() {
     JavaFileObject mapModuleOneFile = JavaFileObjects.forSourceLines("test.MapModuleOne",
