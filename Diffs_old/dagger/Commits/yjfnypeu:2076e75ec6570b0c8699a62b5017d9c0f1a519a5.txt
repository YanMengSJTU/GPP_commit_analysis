diff --git a/.gitignore b/.gitignore
index f05f56746..74bd27df1 100644
--- a/.gitignore
+++ b/.gitignore
@@ -27,3 +27,13 @@ obj
 .DS_Store
 
 dependency-reduced-pom.xml
+
+gen-external-apklibs
+
+bazel-bin
+bazel-genfiles
+bazel-out
+bazel-testlogs
+bazel-dagger
+
+*.pyc
diff --git a/.travis.yml b/.travis.yml
index c9880c178..e7626a7f5 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -1,15 +1,31 @@
 language: android
 
+os: linux
+dist: precise
+sudo: required
+addons:
+  apt:
+    sources:
+      # https://github.com/bazelbuild/bazel/issues/1821#issuecomment-262870638
+      - sourceline: "deb [arch=amd64] http://storage.googleapis.com/bazel-apt stable jdk1.8"
+        key_url: "https://storage.googleapis.com/bazel-apt/doc/apt-key.pub.gpg"
+      - ubuntu-toolchain-r-test
+    packages:
+      - oracle-java8-installer
+      - libstdc++-4.9-dev # https://github.com/nodegit/nodegit/issues/853
+      - bazel=0.4.4
+
 jdk:
-  - oraclejdk7
-  - openjdk7
+  - &jdk_for_publishing oraclejdk8
 
 android:
   components:
-    - build-tools-23.0.0
-    - android-23
-  licenses:
-    - android-sdk-license-5be876d5
+    - tools
+    - tools # Duplicated as per https://github.com/travis-ci/travis-ci/issues/6040#issuecomment-219367943
+    - build-tools-25.0.2
+    - android-25
+    - platform-tools
+    - extra-android-m2repository
 
 before_install:
   - sudo rm -f /etc/mavenrc
@@ -20,18 +36,19 @@ before_install:
   - export PATH=$M2_HOME/bin:$PATH
   - mvn --version
 
-install: mvn -B -P!standard-with-extra-repos -U install clean --fail-never --quiet -DskipTests=true -Dinvoker.skip=true
-
-script: mvn -B -P!standard-with-extra-repos -U verify --fail-at-end -Dsource.skip=true -Dmaven.javadoc.skip=true
+install:
+  - mvn -B -P!standard-with-extra-repos -U install clean --fail-never --quiet -DskipTests=true -Dinvoker.skip=true
 
-notifications:
-  email: dagger-firehose@googlegroups.com
+script:
+  - bazel test --test_output errors //...
+  - mvn -B -P!standard-with-extra-repos -U verify --fail-at-end -Dsource.skip=true -Dmaven.javadoc.skip=true
 
 env:
   global:
     - secure: eGc3LHBRIPmTnXLM1YoIqG1do9BkpFI2pJm3fz5Cd8UaXtf7Oefa+Ts3rcn4ipee5A+lf8kEouPshSoaQs81KZ2/qf8rSTCIqeFjHR8hzmOVYo/0zRfS/VSUT0yqN+jeRhuNk3+A49RTPlcfJqPv3tyddtrM1vF7axhCJPQIRJM=
     - secure: LTzrlqcSNeZTOV52D3ibY9RBdxY4Yu8dUOYhAonrWLE+eDTzuoyCzcPw8pEcYVNUi1rG6Q7v3QBDTnBztsPoCbcN5tEGjw5cQEbfEzSTkWaNCFjncWn36cLwx9lgbF+5Db/L0mYJ36unDKUpKVC8AgOtxQibfv/ffugfxxj8ohY=
     - secure: PEdRiHTy+xVFPnlBwOhr7RVW/QIFSgd4hO0LESRBeF7KGIjxTZWtKPjnYrysZFm6tozMk6WBVJO6avOss0v7L64nemwpCnSspNYBa6pRGPgQ3rv/wgdPSzqDDmABmpPC18EHbUtF94KVdRX3Cr4kmwKQyD+YUKNRCY11Txt+xfo=
+    - JDK_FOR_PUBLISHING: *jdk_for_publishing
 
 after_success:
   - util/generate-latest-docs.sh
@@ -41,3 +58,7 @@ branches:
   only:
     - master
     - /^release.*$/
+
+cache:
+  directories:
+    - $HOME/.m2
diff --git a/AUTHORS b/AUTHORS
new file mode 100644
index 000000000..f4a0fdd77
--- /dev/null
+++ b/AUTHORS
@@ -0,0 +1,8 @@
+# This is the list of Dagger authors for copyright purposes.
+#
+# This does not necessarily list everyone who has contributed code, since in
+# some cases, their employer may be the copyright holder.  To see the full list
+# of contributors, see the revision history in source control.
+Google Inc.
+Square Inc.
+and other contributors
\ No newline at end of file
diff --git a/BUILD b/BUILD
new file mode 100644
index 000000000..a04bf43ca
--- /dev/null
+++ b/BUILD
@@ -0,0 +1,84 @@
+# Copyright (C) 2017 The Dagger Authors.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+package(default_visibility = ["//visibility:public"])
+
+package_group(
+    name = "src",
+    packages = ["//..."],
+)
+
+py_test(
+    name = "maven_sha1_test",
+    srcs = ["maven_sha1_test.py"],
+    data = ["WORKSPACE"],
+)
+
+java_library(
+    name = "dagger_with_compiler",
+    exported_plugins = ["//compiler:component-codegen"],
+    exports = ["//core"],
+)
+
+java_library(
+    name = "producers_with_compiler",
+    exports = [
+        ":dagger_with_compiler",
+        "//producers",
+    ],
+)
+
+load("//tools:jarjar.bzl", "jarjar_library")
+
+genrule(
+    name = "rules_file",
+    outs = ["rules_file.txt"],
+    cmd = "echo \"rule com.google.auto.common.** dagger.shaded.auto.common.@1\" > $@",
+)
+
+jarjar_library(
+    name = "shaded_compiler",
+    rules_file = ":rules_file.txt",
+    deps = [
+        "//compiler",
+        "@com_google_auto_auto_common//jar",
+    ],
+)
+
+load("//tools:javadoc.bzl", "javadoc_library")
+
+# coalesced javadocs used for the gh-pages site
+javadoc_library(
+    name = "user-docs",
+    srcs = [
+        "//core/src/main/java/dagger:javadoc-srcs",
+        "//java/dagger/android:android-srcs",
+        "//java/dagger/android/support:support-srcs",
+        "//producers:producers-srcs",
+    ],
+    android_api_level = 25,
+    # TODO(ronshapiro): figure out how to specify the version number for release builds
+    doctitle = "Dagger Dependency Injection API",
+    exclude_packages = [
+        "dagger.internal",
+        "dagger.producers.internal",
+        "dagger.producers.monitoring.internal",
+    ],
+    root_packages = ["dagger"],
+    deps = [
+        "//core/src/main/java/dagger:core",
+        "//java/dagger/android",
+        "//producers",
+    ],
+)
diff --git a/CHANGELOG.md b/CHANGELOG.md
index 42bd6272f..09c428253 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,137 +1,6 @@
 Change Log
 ==========
 
-Dagger 2 (Components)
----------------------
-
-### Version 2.5 *(2016-06-14)*
-  * Enables `@Binds` usage with multibinding annotations (`@IntoSet`, `@ElementsIntoSet`, and `@IntoMap`)
-  * Adds [`@Multibinds`](http://google.github.io/dagger/api/latest/dagger/multibindings/Multibinds.html) API to replace `@Multibindings` interfaces
-  * `@Component.Builder` methods for abstract modules are no longer allowed
-  * Performance improvements for `@IntoSet` usage. Provided objects are no longer wrapped in a wasteful `Collections.singleton()`
-  * Compilation speed improvements for large graphs
-  * `@Scope`s are no longer allowed on `@Produces` methods
-  * Adds state checking to scoped providers to make sure a circular dependency does not create multiple instances
-  * Producers optimizations: Each `@Produces` method now generates 1 class instead of 2
-  * Fix: Requests for Map<K, V> now include both `@Provides @IntoMap` and `@Produces @IntoMap` values
-
-### Version 2.4 *(2016-04-21)*
-  * Adds [`@Binds`](http://google.github.io/dagger/api/latest/dagger/Binds.html) API for delegating
-    one binding to another
-  * Adds `@IntoSet`, `@ElementsIntoSet` and `@IntoMap` to replace `@Provides(type = ...)` and `@Produces(type = ...)`
-  * Allow injection of `Provider<Lazy<Foo>>`
-  * Report an error if a `@Scope` annotation is applied to an `@Inject` constructor
-  * Remove the ability to set the production executor on a component builder.
-  * Ensure that no binding methods are binding framework types.
-  * New format of dependency traces in error messages
-  * Fixed bug: Exception when a binding in a parent that is used only in a subcomponent depends on a binding in the subcomponent
-  * Update to JavaPoet 1.6.1 and Google Java Format 1.0
-    * Fixes `NoSuchMethodError` from [Issue #356](https://github.com/google/dagger/issues/356)
-
-### Version 2.3 *(2016-04-08)*
-  * Adds [`@Reusable`]
-  (http://google.github.io/dagger/users-guide.html#reusable-scope) scope
-  [(javadoc)](http://google.github.io/dagger/api/latest/dagger/Reusable.html)
-
-### Version 2.2 *(2016-03-22)*
-  * `dagger.mapkeys` moved to `dagger.multibindings` and all `@MapKey`
-    implementations now correctly have `@Beta` applied
-  * Better error messages for multibindings
-  * Compiler bug fixes!
-
-### Version 2.1 *(2016-03-10)*
-
-  * Correctly handle `@Component`s that inject generated types
-  * Adds `@ProductionSubcomponent` and `@ProductionScope`
-  * Allow the production `Executor` to be bound with `@Production`
-  * Allow multiple scope annotations on components
-  * A component's subcomponents’ (and their subcomponents’) simple names no longer need to be unique
-  * Adds the ability to depend on subcomponent builders
-  * GWT Integration
-  * Producers monitoring
-  * Multibindings for producers
-  * Add common `@MapKey` annotations to `dagger.mapkeys`.  These annotations are
-    not, but should be marked `@Beta` (since the `@MapKey` itself is beta).
-  * Lots of bug fixes!
-
-### Version 2.0.2 *(2015-11-03)*
-
-A patch release, most crucially including:
-
-  * A fix to the way processor validation of types is done that permits dagger to play
-    more nicely with other processors, avoiding over-validating aspects that it doesn't
-    need, which may yet not have been generated by other processors in a different round
-    of processing.
-  * Some improved error reporting for edge-cases
-  * Fix to prevent incompatible versions of Guava on the classpath from blowing up processing
-  * Support a more robust set of types for map keys in map bindings (primitive types, etc.)
-
-### Version 2.0.1 *(2015-05-28)*
-
-A maintenance release fixing immediate issues following the Dagger 2.0 release, including:
-
-  * Speed up Graph Validation (reduce build times by 10s of seconds on sampled large projects)
-  * Generate correct code for `@MapKey` annotation types (beta)
-  * Fix to properly emit code for class literal values in `@MapKey` annotations.
-  * Fix for injecting component dependencies
-  * Fixes to generated code to account for differences in generics handling in ecg vs. javac.
-  * Subcomponents can now be abstract classes.
-  * Subcomponents now properly build the object graph in some cases involving explicit bindings
-    and (sub)components without scope.
-  * Improve runtime performance of SetFactory (set multibindings)
-  * Other smaller fixes, refactorings, etc.
-
-### Version 2.0.0 *(2015-04-21)*
-
-The initial release of the 2.0 code-line, supporting:
-
-  * `@Component` interfaces representing a custom API to access a graph of objects
-  * JSR-330 injection automation using `@Inject` signals, `@Qualifiers`
-  * Simple bindings of implementations to interfaces, custom provision of objects, and set-bindings
-  * Compile-time validation of graph structure (cycles, missing bindings, duplicate bindings)
-  * Generation of 
-    - backing implementations for components
-    - factories for `@Inject` constructors and modules
-    - members-injectors for `@Inject` methods and fields
-  * Beta support for
-    - Map bindings
-    - [Producers](http://google.github.io/dagger/api/latest/dagger/producers/Producer.html)
-
-==============================================================
-
-Dagger 1 (ObjectGraph)
-----------------------
-
-### Version 1.2.0 *(2013-12-13)*
-
- * Numerous performance improvements in both the compiler and runtime.
-   * Use more efficient `String` concatenation.
-   * Module adapters are now stateless.
-   * Use read/write locks over global locks.
-   * Reflective constructor invocation is now cached with `Class.newInstance`.
-   * Avoid re-linking all bindings when calling `.plus()`.
- * Set bindings are now unioned when calling `.plus()`.
- * Fix: Tolerate missing type information during compilation by deferring writing
-   module adapters.
-
-
-### Version 1.1.0 *(2013-08-05)*
-
- * Module loading now requires code generation via the 'dagger-compiler' artifact.
- * Allow multiple contributions to Set binding via `Provides.Type.SET_VALUES`.
- * Request classloading from the classloader of the requesting object, not the current thread's
-   context classloader.
- * Cache class loading at the root injector to reduce costs of loading adapters.
- * Fix: Primitive array types are no longer incorrectly changed to their boxed type.
- * Update JavaWriter to 2.1.1.
-
-
-### Version 1.0.1 *(2013-06-03)*
-
- * Explicitly forbid declaring `@Inject` on a class type (e.g., `@Inject class Foo {}`).
- * Update JavaWriter to 1.0.5.
-
-
-### Version 1.0.0 *(2013-05-07)*
-
-Initial release.
+-   For Dagger 2 releases, please see https://github.com/google/dagger/releases
+-   For Dagger 1 (`ObjectGraph`) releases, see
+    https://github.com/square/dagger/blob/master/CHANGELOG.md
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 087af22cd..79d185a60 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -1,37 +1,25 @@
-Contributing
-============
+# How to contribute
 
-If you would like to contribute code to Dagger you can do so through GitHub by
-forking the repository and sending a pull request.
+We'd love to accept your patches and contributions to this project. There are
+just a few small guidelines you need to follow.
 
-When submitting code, please make every effort to follow existing conventions
-and style in order to keep the code as readable as possible.  
+## Contributor License Agreement
 
-Where appropriate, please provide unit tests or integration tests. Unit tests
-should be JUnit based tests and can use either standard JUnit assertions or
-FEST assertions and be added to `<project>/src/test/java`.  Changes to build-time
-behaviour (such as changes to code generation or graph validation) should go into
-small maven projects using the `maven-invoker-plugin`.  Examples of this are in
-`core/src/it` and can include bean-shell verification scripts and other
-facilities provided by `maven-invoker-plugin`.
+Contributions to any Google project must be accompanied by a Contributor License
+Agreement. This is necessary because you own the copyright to your changes, even
+after your contribution becomes part of this project. So this agreement simply
+gives us permission to use and redistribute your contributions as part of the
+project. Head over to <https://cla.developers.google.com/> to see your current
+agreements on file or to sign a new one.
 
-Please make sure your code compiles by running `mvn clean verify` which will
-execute both unit and integration test phases.  Additionally, consider using 
-http://travis-ci.org to validate your branches before you even put them into
-pull requests.  All pull requests will be validated by Travis-ci in any case
-and must pass before being merged.
+You generally only need to submit a CLA once, so if you've already submitted one
+(even if it was for a different project), you probably don't need to do it
+again.
 
-If you are adding or modifying files you may add your own copyright line, but
-please ensure that the form is consistent with the existing files, and please
-note that a Square, Inc. copyright line must appear in every copyright notice.
-All files are released with the Apache 2.0 license.
+## Code reviews
 
-Checkstyle failures during compilation indicate errors in your style and will
-be displayed in the console output of the build (including in Travis-CI output),
-or can be viewed in the `checkstyle-result.xml` file.
+All submissions, including submissions by project members, require review. We
+use GitHub pull requests for this purpose. Consult [GitHub Help] for more
+information on using pull requests.
 
-Before your code can be accepted into the project you must sign the
-[Individual Contributor License Agreement (CLA)][1].
-
-
- [1]: https://spreadsheets.google.com/spreadsheet/viewform?formkey=dDViT2xzUHAwRkI3X3k5Z0lQM091OGc6MQ&ndplr=1
+[GitHub Help]: https://help.github.com/articles/about-pull-requests/
diff --git a/README.md b/README.md
index b035cc66e..e918767a0 100644
--- a/README.md
+++ b/README.md
@@ -1,5 +1,7 @@
 # Dagger 2
 
+[![Maven Central][mavenbadge-svg]][mavenbadge]
+
 A fast dependency injector for Android and Java.
 
 ## About Google's Fork
@@ -15,17 +17,12 @@ This github project represents the Dagger 2 development stream.  The earlier
 development stream. Both versions have benefitted from strong involvement from
 Square, Google, and other contributors.
 
-> [Dagger 2's main documentation website can be found here.][website]
-
-## Status
-
-  - ***Release Version:* 2.2**
-  - ***Snapshot Version:* 2.3-SNAPSHOT**
-
 Dagger is currently in active development, primarily internally at Google,
 with regular pushes to the open-source community. Snapshot releases are
-auto-deployed to sonatype's central maven repository on a clean build with
-the version `2.3-SNAPSHOT`.
+auto-deployed to sonatype's central maven repository on every clean build with
+the version `HEAD-SNAPSHOT`.
+
+> [Dagger 2's main documentation website can be found here.][website]
 
 ## Documentation
 
@@ -39,11 +36,13 @@ mailing list.
 
 ## Installation
 
-You will need to include the `dagger-2.1.jar` in your application's runtime.
+You will need to include the `dagger-2.x.jar` in your application's runtime.
 In order to activate code generation and generate implementations to manage
-your graph you will need to include `dagger-compiler-2.1.jar` in your build
+your graph you will need to include `dagger-compiler-2.x.jar` in your build
 at compile time.
 
+### Maven
+
 In a Maven project, include the `dagger` artifact in the dependencies section
 of your `pom.xml` and the `dagger-compiler` artifact as either an `optional` or
 `provided` dependency:
@@ -53,12 +52,12 @@ of your `pom.xml` and the `dagger-compiler` artifact as either an `optional` or
   <dependency>
     <groupId>com.google.dagger</groupId>
     <artifactId>dagger</artifactId>
-    <version>2.2</version>
+    <version>2.x</version>
   </dependency>
   <dependency>
     <groupId>com.google.dagger</groupId>
     <artifactId>dagger-compiler</artifactId>
-    <version>2.2</version>
+    <version>2.x</version>
     <optional>true</optional>
   </dependency>
 </dependencies>
@@ -72,11 +71,49 @@ parallelizable execution graphs), then add this to your maven configuration:
   <dependency>
     <groupId>com.google.dagger</groupId>
     <artifactId>dagger-producers</artifactId>
-    <version>2.2</version>
+    <version>2.x</version>
   </dependency>
 </dependencies>
 ```
 
+### Java Gradle
+```groovy
+// Add plugin https://plugins.gradle.org/plugin/net.ltgt.apt
+plugins {
+  id "net.ltgt.apt" version "0.5"
+}
+
+// Add Dagger dependencies
+dependencies {
+  compile 'com.google.dagger:dagger:2.x'
+  apt 'com.google.dagger:dagger-compiler:2.x'
+}
+```
+
+### Android Gradle
+```groovy
+// Add Dagger dependencies
+dependencies {
+  compile 'com.google.dagger:dagger:2.x'
+  annotationProcessor 'com.google.dagger:dagger-compiler:2.x'
+}
+```
+
+If you're using a version of the Android gradle plugin below `2.2`, see
+https://bitbucket.org/hvisser/android-apt.
+
+If you're using the [Android Databinding library][databinding], you may want to
+increase the number of errors that `javac` will print. When Dagger prints an
+error, databinding compilation will halt and sometimes print more than 100
+errors, which is the default amount for `javac`. For more information, see #306.
+
+```groovy
+gradle.projectsEvaluated {
+  tasks.withType(JavaCompile) {
+    options.compilerArgs << "-Xmaxerrs" << "500" // or whatever number you want
+  }
+}
+```
 
 ### Download
 
@@ -104,8 +141,7 @@ the GitHub project's master branch.
 
 ## License
 
-    Copyright 2012 Square, Inc.
-    Copyright 2012 Google, Inc.
+    Copyright 2012 The Dagger Authors
 
     Licensed under the Apache License, Version 2.0 (the "License");
     you may not use this file except in compliance with the License.
@@ -120,16 +156,17 @@ the GitHub project's master branch.
     limitations under the License.
 
 
-
- [mavensearch]: http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.google.dagger%22
- [dagger-snap]: https://oss.sonatype.org/content/repositories/snapshots/com/google/dagger/
- [website]: http://google.github.io/dagger
- [latestapi]: http://google.github.io/dagger/api/latest/
- [20api]: http://google.github.io/dagger/api/2.0/
- [gaktalk]: https://www.youtube.com/watch?v=oK_XtfXPkqw
- [proposal]: https://github.com/square/dagger/issues/366
- [project]: http://github.com/google/dagger/
- [community]: https://plus.google.com/communities/111933036769103367883
- [square]: http://github.com/square/dagger/
- [squarecommunity]: https://plus.google.com/communities/109244258569782858265
-
+[20api]: http://google.github.io/dagger/api/2.0/
+[community]: https://plus.google.com/communities/111933036769103367883
+[dagger-snap]: https://oss.sonatype.org/content/repositories/snapshots/com/google/dagger/
+[databinding]: https://developer.android.com/topic/libraries/data-binding/index.html
+[gaktalk]: https://www.youtube.com/watch?v=oK_XtfXPkqw
+[latestapi]: http://google.github.io/dagger/api/latest/
+[mavenbadge-svg]: https://maven-badges.herokuapp.com/maven-central/com.google.dagger/dagger/badge.svg
+[mavenbadge]: https://maven-badges.herokuapp.com/maven-central/com.google.dagger/dagger
+[mavensearch]: http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.google.dagger%22
+[project]: http://github.com/google/dagger/
+[proposal]: https://github.com/square/dagger/issues/366
+[square]: http://github.com/square/dagger/
+[squarecommunity]: https://plus.google.com/communities/109244258569782858265
+[website]: http://google.github.io/dagger
diff --git a/WORKSPACE b/WORKSPACE
new file mode 100644
index 000000000..00f3bf368
--- /dev/null
+++ b/WORKSPACE
@@ -0,0 +1,154 @@
+# Copyright (C) 2017 The Dagger Authors.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+android_sdk_repository(
+    name = "androidsdk",
+    api_level = 25,
+    build_tools_version = "25.0.2",
+)
+
+bind(
+    name = "android_sdk_for_testing",
+    actual = "@androidsdk//:files",
+)
+
+maven_jar(
+    name = "javax_annotation_jsr250_api",
+    artifact = "javax.annotation:jsr250-api:1.0",
+    sha1 = "5025422767732a1ab45d93abfea846513d742dcf",
+)
+
+maven_jar(
+    name = "com_google_code_findbugs_jsr305",
+    artifact = "com.google.code.findbugs:jsr305:3.0.1",
+    sha1 = "f7be08ec23c21485b9b5a1cf1654c2ec8c58168d",
+)
+
+maven_jar(
+    name = "javax_inject_javax_inject",
+    artifact = "javax.inject:javax.inject:1",
+    sha1 = "6975da39a7040257bd51d21a231b76c915872d38",
+)
+
+maven_jar(
+    name = "javax_inject_javax_inject_tck",
+    artifact = "javax.inject:javax.inject-tck:1",
+    sha1 = "bb0090d50219c265be40fcc8e034dae37fa7be99",
+)
+
+maven_jar(
+    name = "com_google_guava_guava",
+    artifact = "com.google.guava:guava:21.0-rc1",
+    sha1 = "ea4681eb116c7335370adaad583010e0681cc53b",
+)
+
+maven_jar(
+    name = "com_google_guava_guava_testlib",
+    artifact = "com.google.guava:guava-testlib:21.0-rc1",
+    sha1 = "13f0f0dce4e710bb0bb791bd07f6e9858670a865",
+)
+
+maven_jar(
+    name = "com_google_errorprone_javac",
+    artifact = "com.google.errorprone:javac:9-dev-r3297-1-shaded",
+    sha1 = "0f6d4998965282068a3feecddc21578d23f17275",
+)
+
+maven_jar(
+    name = "com_google_googlejavaformat_google_java_format",
+    artifact = "com.google.googlejavaformat:google-java-format:1.3",
+    sha1 = "949e85e75b3160ce1446aa99d806d5b509631b02",
+)
+
+maven_jar(
+    name = "com_google_auto_auto_common",
+    artifact = "com.google.auto:auto-common:0.8",
+    sha1 = "c6f7af0e57b9d69d81b05434ef9f3c5610d498c4",
+)
+
+maven_jar(
+    name = "com_google_auto_factory_auto_factory",
+    artifact = "com.google.auto.factory:auto-factory:1.0-beta3",
+    sha1 = "99b2ffe0e41abbd4cc42bf3836276e7174c4929d",
+)
+
+maven_jar(
+    name = "com_squareup_javawriter",
+    artifact = "com.squareup:javawriter:2.5.1",
+    sha1 = "54c87b3d91238e5b58e1a436d4916eee680ec959",
+)
+
+maven_jar(
+    name = "com_google_auto_service_auto_service",
+    artifact = "com.google.auto.service:auto-service:1.0-rc2",
+    sha1 = "51033a5b8fcf7039159e35b6878f106ccd5fb35f",
+)
+
+maven_jar(
+    name = "com_google_auto_value_auto_value",
+    artifact = "com.google.auto.value:auto-value:1.4-rc1",
+    sha1 = "9347939002003a7a3c3af48271fc2c18734528a4",
+)
+
+maven_jar(
+    name = "com_google_errorprone_error_prone_annotations",
+    artifact = "com.google.errorprone:error_prone_annotations:2.0.12",
+    sha1 = "8530d22d4ae8419e799d5a5234e0d2c0dcf15d4b",
+)
+
+maven_jar(
+    name = "junit_junit",
+    artifact = "junit:junit:4.11",
+    sha1 = "4e031bb61df09069aeb2bffb4019e7a5034a4ee0",
+)
+
+maven_jar(
+    name = "com_google_testing_compile_compile_testing",
+    artifact = "com.google.testing.compile:compile-testing:0.10",
+    sha1 = "51e6189be9d2861d1eb22b4009c8f3430319490c",
+)
+
+maven_jar(
+    name = "org_mockito_mockito_core",
+    artifact = "org.mockito:mockito-core:1.9.5",
+    sha1 = "c3264abeea62c4d2f367e21484fbb40c7e256393",
+)
+
+maven_jar(
+    name = "org_hamcrest_hamcrest_core",
+    artifact = "org.hamcrest:hamcrest-core:1.3",
+    sha1 = "42a25dc3219429f0e5d060061f71acb49bf010a0",
+)
+
+maven_jar(
+    name = "org_objenesis_objenesis",
+    artifact = "org.objenesis:objenesis:1.0",
+    sha1 = "9b473564e792c2bdf1449da1f0b1b5bff9805704",
+)
+
+maven_jar(
+    name = "com_google_truth_truth",
+    artifact = "com.google.truth:truth:0.30",
+    sha1 = "9d591b5a66eda81f0b88cf1c748ab8853d99b18b",
+)
+
+maven_jar(
+    name = "com_squareup_javapoet",
+    artifact = "com.squareup:javapoet:1.7.0",
+    sha1 = "4fdcf1fc27c1a8f55d1109df986c923152f07759",
+)
+
+load("//tools:jarjar.bzl", "jarjar_deps")
+
+jarjar_deps()
diff --git a/build_defs.bzl b/build_defs.bzl
new file mode 100644
index 000000000..cf3d288d0
--- /dev/null
+++ b/build_defs.bzl
@@ -0,0 +1,29 @@
+# Copyright (C) 2017 The Dagger Authors.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+"""This file defines constants useful across the Dagger build."""
+
+DOCLINT_HTML_AND_SYNTAX = ["-Xdoclint:html,syntax"]
+
+DOCLINT_REFERENCES = ["-Xdoclint:reference"]
+
+SOURCE_7_TARGET_7 = ["-source 1.7 -target 1.7"]
+
+JAVA_7_SOURCE_LEVEL = ["-source 1.7"]
+
+PRE_JAVA_8_INFERENCE_OPTS = [
+    "-XDusePolyAttribution=false",
+    "-XDuseStrictMethodClashCheck=false",
+    "-XDuseGraphInference=false",
+]
diff --git a/checkstyle.xml b/checkstyle.xml
deleted file mode 100644
index e7ffbc0d5..000000000
--- a/checkstyle.xml
+++ /dev/null
@@ -1,137 +0,0 @@
-<?xml version="1.0"?>
-<!DOCTYPE module PUBLIC
-    "-//Puppy Crawl//DTD Check Configuration 1.2//EN"
-    "http://www.puppycrawl.com/dtds/configuration_1_2.dtd">
-
-<module name="Checker">
-    <!--module name="NewlineAtEndOfFile"/-->
-    <module name="FileLength"/>
-    <module name="FileTabCharacter"/>
-
-    <!-- Trailing spaces -->
-    <module name="RegexpSingleline">
-        <property name="format" value="\s+$"/>
-        <property name="message" value="Line has trailing spaces."/>
-    </module>
-
-    <!-- Space after 'for' and 'if' -->
-    <module name="RegexpSingleline">
-        <property name="format" value="^\s*(for|if)[^ ]"/>
-        <property name="message" value="Space needed before opening parenthesis."/>
-    </module>
-
-    <!-- For each spacing -->
-    <module name="RegexpSingleline">
-        <property name="format" value="^\s*for \(.*?([^ ]:|:[^ ])"/>
-        <property name="message" value="Space needed around ':' character."/>
-    </module>
-
-    <module name="TreeWalker">
-        <property name="cacheFile" value="${checkstyle.cache.file}"/>
-
-        <!-- Checks for Javadoc comments.                     -->
-        <!-- See http://checkstyle.sf.net/config_javadoc.html -->
-        <!--module name="JavadocMethod"/-->
-        <!--module name="JavadocType"/-->
-        <!--module name="JavadocVariable"/-->
-        <!--module name="JavadocStyle"/-->
-
-
-        <!-- Checks for Naming Conventions.                  -->
-        <!-- See http://checkstyle.sf.net/config_naming.html -->
-        <!--<module name="ConstantName"/>-->
-        <module name="LocalFinalVariableName"/>
-        <module name="LocalVariableName"/>
-        <module name="MemberName"/>
-        <module name="MethodName"/>
-        <module name="PackageName"/>
-        <module name="ParameterName"/>
-        <module name="StaticVariableName"/>
-        <module name="TypeName"/>
-
-
-        <!-- Checks for imports                              -->
-        <!-- See http://checkstyle.sf.net/config_import.html -->
-        <module name="AvoidStarImport"/>
-        <module name="IllegalImport"/> <!-- defaults to sun.* packages -->
-        <module name="RedundantImport"/>
-        <module name="UnusedImports">
-            <property name="processJavadoc" value="true"/>
-        </module>
-
-        <!-- Checks for Size Violations.                    -->
-        <!-- See http://checkstyle.sf.net/config_sizes.html -->
-        <module name="LineLength">
-            <property name="max" value="100"/>
-        </module>
-        <module name="MethodLength">
-            <property name="max" value="200"/>
-        </module>
-        <!--module name="ParameterNumber"/-->
-
-
-        <!-- Checks for whitespace                               -->
-        <!-- See http://checkstyle.sf.net/config_whitespace.html -->
-        <module name="GenericWhitespace"/>
-        <module name="EmptyForIteratorPad"/>
-        <module name="MethodParamPad"/>
-        <module name="NoWhitespaceAfter"/>
-        <module name="NoWhitespaceBefore"/>
-        <module name="OperatorWrap"/>
-        <module name="ParenPad"/>
-        <module name="TypecastParenPad"/>
-        <module name="WhitespaceAfter"/>
-        <module name="WhitespaceAround">
-          <property name="allowEmptyConstructors" value="true" />
-          <property name="allowEmptyMethods" value="true" />
-        </module>
-
-
-        <!-- Modifier Checks                                    -->
-        <!-- See http://checkstyle.sf.net/config_modifiers.html -->
-        <!--module name="ModifierOrder"/-->
-        <module name="RedundantModifier"/>
-
-
-        <!-- Checks for blocks. You know, those {}'s         -->
-        <!-- See http://checkstyle.sf.net/config_blocks.html -->
-        <!--module name="AvoidNestedBlocks"/-->
-        <!--module name="EmptyBlock"/-->
-        <module name="LeftCurly"/>
-        <!--module name="NeedBraces"/-->
-        <module name="RightCurly"/>
-
-
-        <!-- Checks for common coding problems               -->
-        <!-- See http://checkstyle.sf.net/config_coding.html -->
-        <!--module name="AvoidInlineConditionals"/-->
-        <module name="CovariantEquals"/>
-        <module name="EmptyStatement"/>
-        <!--<module name="EqualsAvoidNull"/>-->
-        <module name="EqualsHashCode"/>
-        <!--module name="HiddenField"/-->
-        <module name="IllegalInstantiation"/>
-        <!--<module name="InnerAssignment"/>-->
-        <!--module name="MagicNumber"/-->
-        <module name="MissingSwitchDefault"/>
-        <module name="RedundantThrows"/>
-        <module name="SimplifyBooleanExpression"/>
-        <module name="SimplifyBooleanReturn"/>
-
-        <!-- Checks for class design                         -->
-        <!-- See http://checkstyle.sf.net/config_design.html -->
-        <!--module name="DesignForExtension"/-->
-        <!--module name="FinalClass"/-->
-        <!--module name="HideUtilityClassConstructor"/-->
-        <!--module name="InterfaceIsType"/-->
-        <!--module name="VisibilityModifier"/-->
-
-
-        <!-- Miscellaneous other checks.                   -->
-        <!-- See http://checkstyle.sf.net/config_misc.html -->
-        <!--module name="ArrayTypeStyle"/-->
-        <!--module name="FinalParameters"/-->
-        <!--module name="TodoComment"/-->
-        <module name="UpperEll"/>
-    </module>
-</module>
diff --git a/compiler/BUILD b/compiler/BUILD
new file mode 100644
index 000000000..5297ac105
--- /dev/null
+++ b/compiler/BUILD
@@ -0,0 +1,103 @@
+# Copyright (C) 2017 The Dagger Authors.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+# Description:
+#   A JSR-330 compliant dependency injection system for android and java
+
+package(default_visibility = ["//:src"])
+
+load("//:build_defs.bzl", "DOCLINT_HTML_AND_SYNTAX", "DOCLINT_REFERENCES")
+
+COMPILER_SRCS = glob(
+    ["src/main/java/**/*.java"],
+)
+
+COMPILER_PLUGINS = [
+    # TODO(cgruber): Enable Beta checker.
+]
+
+COMPILER_SHARED_DEPS = [
+    "//third_party:auto_service",
+    "//third_party:auto_value",
+    "//third_party:auto_common",
+    "//third_party:error_prone_annotations",
+    "//third_party:google_java_format",
+    "//third_party:javapoet",
+    "@local_jdk//:lib/tools.jar",
+    "//third_party:jsr305_annotations",
+    "//third_party:jsr330_inject",
+    "//core",
+    "//producers",
+]
+
+java_library(
+    name = "compiler",
+    srcs = COMPILER_SRCS,
+    javacopts = DOCLINT_HTML_AND_SYNTAX + DOCLINT_REFERENCES,
+    plugins = COMPILER_PLUGINS,
+    deps = COMPILER_SHARED_DEPS + [
+        "//third_party:guava",
+    ],
+)
+
+load("//tools:javadoc.bzl", "javadoc_library")
+
+javadoc_library(
+    name = "compiler-javadoc",
+    srcs = COMPILER_SRCS,
+    root_packages = ["dagger.internal.codegen"],
+    deps = [":compiler"],
+)
+
+java_plugin(
+    name = "component-codegen",
+    generates_api = 1,
+    processor_class = "dagger.internal.codegen.ComponentProcessor",
+    deps = [":compiler"],
+)
+
+load("//:test_defs.bzl", "GenJavaTests")
+
+GenJavaTests(
+    name = "compiler_tests",
+    srcs = glob(["src/test/java/**/*.java"]),
+    javacopts = DOCLINT_HTML_AND_SYNTAX,
+    plugins = [":component-codegen"],
+    deps = [
+        ":compiler",
+        "//core",
+        "//producers",
+        "//third_party:auto_common",
+        "//third_party:auto_value",
+        "//third_party:compile_testing",
+        "//third_party:guava",
+        "//third_party:javapoet",
+        "//third_party:jsr330_inject",
+        "//third_party:junit",
+        "//third_party:mockito",
+        "//third_party:truth",
+    ],
+)
+
+test_suite(name = "AllTests")
+
+test_suite(
+    name = "UnitAndFunctionalTests",
+    tests = [
+        ":AllTests",
+        "//compiler/src/it/functional-tests:AllTests",
+        "//compiler/src/it/producers-functional-tests:AllTests",
+        "//compiler/src/it/tck:AllTests",
+    ],
+)
diff --git a/compiler/pom.xml b/compiler/pom.xml
index 3411d1fc0..1a7ab7df3 100644
--- a/compiler/pom.xml
+++ b/compiler/pom.xml
@@ -1,7 +1,6 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <!--
- Copyright (C) 2012 Square, Inc.
- Copyright (C) 2012 Google, Inc.
+ Copyright (C) 2012 The Dagger Authors.
 
   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
@@ -21,7 +20,7 @@
   <parent>
     <groupId>com.google.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>2.5-SNAPSHOT</version>
+    <version>HEAD-SNAPSHOT</version>
   </parent>
 
   <artifactId>dagger-compiler</artifactId>
@@ -65,15 +64,13 @@
     <dependency>
       <groupId>com.google.auto.service</groupId>
       <artifactId>auto-service</artifactId>
-      <scope>provided</scope> <!-- to leave out of the all-deps jar -->
+      <scope>provided</scope>
     </dependency>
     <dependency>
       <groupId>com.google.auto.value</groupId>
       <artifactId>auto-value</artifactId>
-      <version>1.1</version>
-      <scope>provided</scope> <!-- to leave out of the all-deps jar -->
+      <scope>provided</scope>
     </dependency>
-
     <dependency>
       <groupId>junit</groupId>
       <artifactId>junit</artifactId>
@@ -82,9 +79,9 @@
     <dependency>
       <groupId>${project.groupId}</groupId>
       <artifactId>dagger</artifactId>
+      <classifier>tests</classifier>
       <version>${project.version}</version>
       <scope>test</scope>
-      <classifier>tests</classifier>
     </dependency>
     <dependency>
       <groupId>com.google.testing.compile</groupId>
@@ -99,7 +96,6 @@
     <dependency>
       <groupId>com.squareup</groupId>
       <artifactId>javapoet</artifactId>
-      <version>1.7.0</version>
     </dependency>
     <dependency>
       <groupId>org.mockito</groupId>
@@ -117,6 +113,13 @@
     <plugins>
       <plugin>
         <artifactId>maven-compiler-plugin</artifactId>
+        <configuration>
+          <source>1.8</source>
+          <target>1.8</target>
+          <compilerArgument>-Xlint:all</compilerArgument>
+          <showWarnings>true</showWarnings>
+          <showDeprecation>true</showDeprecation>
+        </configuration>
         <executions>
           <execution>
             <id>default-compile</id>
@@ -152,10 +155,6 @@
             <pomInclude>*/pom.xml</pomInclude>
           </pomIncludes>
           <localRepositoryPath>${project.build.directory}/it-repo</localRepositoryPath>
-          <filterProperties>
-            <dagger.version>${project.version}</dagger.version>
-            <dagger.groupId>${project.groupId}</dagger.groupId>
-          </filterProperties>
           <streamLogs>true</streamLogs>
         </configuration>
         <executions>
@@ -171,7 +170,7 @@
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-shade-plugin</artifactId>
-        <version>2.3</version>
+        <version>2.4.3</version>
         <executions>
           <execution>
             <phase>package</phase>
@@ -208,6 +207,13 @@
                     <exclude>META-INF/*.RSA</exclude>
                   </excludes>
                 </filter>
+                <!-- https://github.com/google/google-java-format/issues/114 -->
+                <filter>
+                  <artifact>com.google.errorprone:javac</artifact>
+                  <includes>
+                    <include>**</include>
+                  </includes>
+                </filter>
               </filters>
             </configuration>
           </execution>
diff --git a/compiler/src/it/functional-tests/BUILD b/compiler/src/it/functional-tests/BUILD
new file mode 100644
index 000000000..1e705697e
--- /dev/null
+++ b/compiler/src/it/functional-tests/BUILD
@@ -0,0 +1,66 @@
+# Copyright (C) 2017 The Dagger Authors.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+# Description:
+#   Functional tests for Dagger
+
+package(default_visibility = ["//:src"])
+
+load(
+    "//:build_defs.bzl",
+    "DOCLINT_HTML_AND_SYNTAX",
+    "DOCLINT_REFERENCES",
+    "PRE_JAVA_8_INFERENCE_OPTS",
+)
+
+# Sample code to be tested in functional tests.
+java_library(
+    name = "code_under_test",
+    testonly = 1,
+    srcs = glob(
+        ["src/main/java/**/*.java"],
+    ),
+    javacopts = PRE_JAVA_8_INFERENCE_OPTS + DOCLINT_HTML_AND_SYNTAX,
+    # NOTE: This should not depend on Guava or jsr305 to ensure that Dagger can be
+    # used without a Guava and jsr305 deps.
+    deps = [
+        "//:dagger_with_compiler",
+        "//third_party:auto_factory",
+        "//third_party:auto_value",
+        "//third_party:jsr330_inject",
+        "//third_party:junit",
+    ],
+)
+
+load("//:test_defs.bzl", "GenJavaTests")
+
+GenJavaTests(
+    name = "test_lib",
+    srcs = glob(
+        ["src/test/java/**/*.java"],
+    ),
+    javacopts = PRE_JAVA_8_INFERENCE_OPTS + DOCLINT_HTML_AND_SYNTAX + DOCLINT_REFERENCES,
+    deps = [
+        ":code_under_test",
+        "//:dagger_with_compiler",
+        "//third_party:auto_value",
+        "//third_party:guava",
+        "//third_party:guava_testlib",
+        "//third_party:jsr330_inject",
+        "//third_party:junit",
+        "//third_party:truth",
+    ],
+)
+
+test_suite(name = "AllTests")
diff --git a/compiler/src/it/functional-tests/pom.xml b/compiler/src/it/functional-tests/pom.xml
index bf298f26e..9bf20565a 100644
--- a/compiler/src/it/functional-tests/pom.xml
+++ b/compiler/src/it/functional-tests/pom.xml
@@ -1,6 +1,6 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <!--
-Copyright (C) 2014 Google, Inc.
+Copyright (C) 2014 The Dagger Authors.
 
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
@@ -22,7 +22,7 @@ limitations under the License.
   <parent>
     <groupId>com.google.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>2.5-SNAPSHOT</version>
+    <version>HEAD-SNAPSHOT</version>
   </parent>
   <groupId>dagger.tests</groupId>
   <artifactId>functional-tests</artifactId>
@@ -46,14 +46,12 @@ limitations under the License.
     <dependency>
       <groupId>com.google.auto.value</groupId>
       <artifactId>auto-value</artifactId>
-      <version>${auto.value.version}</version>
-      <scope>provided</scope> <!-- to leave out of the all-deps jar -->
+      <scope>provided</scope>
     </dependency>
     <dependency>
       <groupId>com.google.auto.factory</groupId>
       <artifactId>auto-factory</artifactId>
-      <version>${auto.factory.version}</version>
-      <scope>provided</scope> <!-- to leave out of the all-deps jar -->
+      <scope>provided</scope>
     </dependency>
 
     <dependency>
@@ -66,6 +64,11 @@ limitations under the License.
       <artifactId>truth</artifactId>
       <scope>test</scope>
     </dependency>
+    <dependency>
+      <groupId>com.google.guava</groupId>
+      <artifactId>guava-testlib</artifactId>
+      <scope>test</scope>
+    </dependency>
   </dependencies>
   <build>
     <plugins>
@@ -77,24 +80,6 @@ limitations under the License.
           <target>1.7</target>
         </configuration>
       </plugin>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-checkstyle-plugin</artifactId>
-        <version>2.10</version>
-        <configuration>
-          <failsOnError>false</failsOnError>
-          <consoleOutput>true</consoleOutput>
-          <configLocation>../../../../checkstyle.xml</configLocation>
-        </configuration>
-        <executions>
-          <execution>
-            <phase>compile</phase>
-            <goals>
-              <goal>checkstyle</goal>
-            </goals>
-          </execution>
-        </executions>
-      </plugin>
     </plugins>
   </build>
 </project>
diff --git a/compiler/src/it/functional-tests/src/main/java/test/A.java b/compiler/src/it/functional-tests/src/main/java/test/A.java
index 030f8556c..b6c27338b 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/A.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/A.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test;
 
 import javax.inject.Inject;
diff --git a/compiler/src/it/functional-tests/src/main/java/test/AbstractMembersInjectingBaseClass.java b/compiler/src/it/functional-tests/src/main/java/test/AbstractMembersInjectingBaseClass.java
index 4fb0f7832..7e9676888 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/AbstractMembersInjectingBaseClass.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/AbstractMembersInjectingBaseClass.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test;
 
 import javax.inject.Inject;
diff --git a/compiler/src/it/functional-tests/src/main/java/test/AbstractMiddleClassWithoutMembers.java b/compiler/src/it/functional-tests/src/main/java/test/AbstractMiddleClassWithoutMembers.java
index 89e94bd2f..41bcddbdc 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/AbstractMiddleClassWithoutMembers.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/AbstractMiddleClassWithoutMembers.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test;
 
 abstract class AbstractMiddleClassWithoutMembers extends AbstractMembersInjectingBaseClass {
diff --git a/compiler/src/it/functional-tests/src/main/java/test/B.java b/compiler/src/it/functional-tests/src/main/java/test/B.java
index dec8e2e58..844f9d7cb 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/B.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/B.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test;
 
 import javax.inject.Inject;
diff --git a/compiler/src/it/functional-tests/src/main/java/test/BasicAbstractClassComponent.java b/compiler/src/it/functional-tests/src/main/java/test/BasicAbstractClassComponent.java
index ad32e2a42..473c085c4 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/BasicAbstractClassComponent.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/BasicAbstractClassComponent.java
@@ -1,5 +1,5 @@
 /*
-* Copyright (C) 2015 Google, Inc.
+* Copyright (C) 2015 The Dagger Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
+
 package test;
 
 import dagger.Component;
diff --git a/compiler/src/it/functional-tests/src/main/java/test/BasicComponent.java b/compiler/src/it/functional-tests/src/main/java/test/BasicComponent.java
index 5629a0f09..6f068c51e 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/BasicComponent.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/BasicComponent.java
@@ -1,5 +1,5 @@
 /*
-* Copyright (C) 2014 Google, Inc.
+* Copyright (C) 2014 The Dagger Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
+
 package test;
 
 import dagger.Component;
diff --git a/compiler/src/it/functional-tests/src/main/java/test/BooleanKey.java b/compiler/src/it/functional-tests/src/main/java/test/BooleanKey.java
index 4cef79e02..78fab2e45 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/BooleanKey.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/BooleanKey.java
@@ -1,5 +1,5 @@
 /*
-* Copyright (C) 2015 Google, Inc.
+* Copyright (C) 2015 The Dagger Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
+
 package test;
 
 import dagger.MapKey;
diff --git a/compiler/src/it/functional-tests/src/main/java/test/BoundedGenericComponent.java b/compiler/src/it/functional-tests/src/main/java/test/BoundedGenericComponent.java
index b30522f57..605bf0ae5 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/BoundedGenericComponent.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/BoundedGenericComponent.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test;
 
 import dagger.Component;
diff --git a/compiler/src/it/functional-tests/src/main/java/test/BoundedGenericModule.java b/compiler/src/it/functional-tests/src/main/java/test/BoundedGenericModule.java
index 6bd7be4fb..f24f46166 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/BoundedGenericModule.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/BoundedGenericModule.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test;
 
 import dagger.Module;
diff --git a/compiler/src/it/functional-tests/src/main/java/test/BoundedGenerics.java b/compiler/src/it/functional-tests/src/main/java/test/BoundedGenerics.java
index e26d64351..d433728aa 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/BoundedGenerics.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/BoundedGenerics.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test;
 
 import java.util.List;
diff --git a/compiler/src/it/functional-tests/src/main/java/test/ByteKey.java b/compiler/src/it/functional-tests/src/main/java/test/ByteKey.java
index 8e739bd4a..e04ee33dd 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/ByteKey.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/ByteKey.java
@@ -1,5 +1,5 @@
 /*
-* Copyright (C) 2015 Google, Inc.
+* Copyright (C) 2015 The Dagger Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
+
 package test;
 
 import dagger.MapKey;
diff --git a/compiler/src/it/functional-tests/src/main/java/test/CharKey.java b/compiler/src/it/functional-tests/src/main/java/test/CharKey.java
index a4f4e29c8..276ee6153 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/CharKey.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/CharKey.java
@@ -1,5 +1,5 @@
 /*
-* Copyright (C) 2015 Google, Inc.
+* Copyright (C) 2015 The Dagger Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
+
 package test;
 
 import dagger.MapKey;
diff --git a/compiler/src/it/functional-tests/src/main/java/test/ComplexGenerics.java b/compiler/src/it/functional-tests/src/main/java/test/ComplexGenerics.java
index e2e327494..272b29bec 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/ComplexGenerics.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/ComplexGenerics.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test;
 
 import dagger.Lazy;
diff --git a/compiler/src/it/functional-tests/src/main/java/test/ComponentDependsOnGeneratedCode.java b/compiler/src/it/functional-tests/src/main/java/test/ComponentDependsOnGeneratedCode.java
index 6ffe1e07d..cdc693d0b 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/ComponentDependsOnGeneratedCode.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/ComponentDependsOnGeneratedCode.java
@@ -1,5 +1,5 @@
 /*
-* Copyright (C) 2015 Google, Inc.
+* Copyright (C) 2015 The Dagger Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
@@ -13,10 +13,18 @@
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
+
 package test;
 
 import dagger.Component;
 
+/**
+ * A component that indirectly depends on code generated by another processor, in this case
+ * {@link com.google.auto.factory.AutoFactory}. Neither this type nor its immediately referenced
+ * types are generated, but {@link NeedsFactory} depends on the generated
+ * {@link NeedsFactory_SomethingFactory}.
+ *
+ */
 @Component
 interface ComponentDependsOnGeneratedCode {
   NeedsFactory needsFactory();
diff --git a/compiler/src/it/functional-tests/src/main/java/test/ComponentSupertypeDependsOnGeneratedCode.java b/compiler/src/it/functional-tests/src/main/java/test/ComponentSupertypeDependsOnGeneratedCode.java
index f7460c989..28fcf5fc8 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/ComponentSupertypeDependsOnGeneratedCode.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/ComponentSupertypeDependsOnGeneratedCode.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,10 +13,16 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test;
 
 import dagger.Component;
 
+/**
+ * A component whose supertype depends on code generated by another processor, in this case
+ * {@link com.google.auto.factory.AutoFactory}.
+ *
+ */
 @Component
 interface ComponentSupertypeDependsOnGeneratedCode
     extends ComponentSupertypeDependsOnGeneratedCodeInterface {}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/ComponentSupertypeDependsOnGeneratedCodeInterface.java b/compiler/src/it/functional-tests/src/main/java/test/ComponentSupertypeDependsOnGeneratedCodeInterface.java
index fca90e0f3..325c44970 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/ComponentSupertypeDependsOnGeneratedCodeInterface.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/ComponentSupertypeDependsOnGeneratedCodeInterface.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test;
 
 interface ComponentSupertypeDependsOnGeneratedCodeInterface {
diff --git a/compiler/src/it/functional-tests/src/main/java/test/ComponentWithReusableBindings.java b/compiler/src/it/functional-tests/src/main/java/test/ComponentWithReusableBindings.java
index 059794257..ad1e4c881 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/ComponentWithReusableBindings.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/ComponentWithReusableBindings.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 Google, Inc.
+ * Copyright (C) 2016 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test;
 
 import dagger.Component;
diff --git a/compiler/src/it/functional-tests/src/main/java/test/ComponentsWithNestedModules.java b/compiler/src/it/functional-tests/src/main/java/test/ComponentsWithNestedModules.java
index 56491a1e2..48faad190 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/ComponentsWithNestedModules.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/ComponentsWithNestedModules.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 Google, Inc.
+ * Copyright (C) 2016 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test;
 
 import dagger.Component;
diff --git a/compiler/src/it/functional-tests/src/main/java/test/Generic.java b/compiler/src/it/functional-tests/src/main/java/test/Generic.java
index ee1aa0992..72e8f1c5d 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/Generic.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/Generic.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test;
 
 import javax.inject.Inject;
diff --git a/compiler/src/it/functional-tests/src/main/java/test/Generic2.java b/compiler/src/it/functional-tests/src/main/java/test/Generic2.java
index 4a56df3ec..0d353bf6b 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/Generic2.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/Generic2.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test;
 
 import javax.inject.Inject;
diff --git a/compiler/src/it/functional-tests/src/main/java/test/GenericChild.java b/compiler/src/it/functional-tests/src/main/java/test/GenericChild.java
index 5c65dc03e..3c42bc885 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/GenericChild.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/GenericChild.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test;
 
 import javax.inject.Inject;
diff --git a/compiler/src/it/functional-tests/src/main/java/test/GenericComponent.java b/compiler/src/it/functional-tests/src/main/java/test/GenericComponent.java
index da5b9b530..6ce8d89ac 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/GenericComponent.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/GenericComponent.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test;
 
 import dagger.Component;
diff --git a/compiler/src/it/functional-tests/src/main/java/test/GenericDoubleReferences.java b/compiler/src/it/functional-tests/src/main/java/test/GenericDoubleReferences.java
index 6785c7c5f..d70f9e25c 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/GenericDoubleReferences.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/GenericDoubleReferences.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test;
 
 import javax.inject.Inject;
diff --git a/compiler/src/it/functional-tests/src/main/java/test/GenericNoDeps.java b/compiler/src/it/functional-tests/src/main/java/test/GenericNoDeps.java
index e065f7926..b569ecb3e 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/GenericNoDeps.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/GenericNoDeps.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test;
 
 import javax.inject.Inject;
diff --git a/compiler/src/it/functional-tests/src/main/java/test/GenericParent.java b/compiler/src/it/functional-tests/src/main/java/test/GenericParent.java
index c50e3451b..1f7a322f3 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/GenericParent.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/GenericParent.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test;
 
 import javax.inject.Inject;
diff --git a/compiler/src/it/functional-tests/src/main/java/test/InjectedThing.java b/compiler/src/it/functional-tests/src/main/java/test/InjectedThing.java
index 438b69f16..a262e87ae 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/InjectedThing.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/InjectedThing.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test;
 
 import dagger.Lazy;
diff --git a/compiler/src/it/functional-tests/src/main/java/test/Injector.java b/compiler/src/it/functional-tests/src/main/java/test/Injector.java
index 2a5798a03..e890640a2 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/Injector.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/Injector.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Google, Inc.
+ * Copyright (C) 2014 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test;
 
 import dagger.Lazy;
diff --git a/compiler/src/it/functional-tests/src/main/java/test/ModuleIncludesCollectedFromModuleSuperclasses.java b/compiler/src/it/functional-tests/src/main/java/test/ModuleIncludesCollectedFromModuleSuperclasses.java
new file mode 100644
index 000000000..0b330a1f9
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/ModuleIncludesCollectedFromModuleSuperclasses.java
@@ -0,0 +1,65 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package test;
+
+import dagger.Component;
+import dagger.Module;
+import dagger.Provides;
+
+/**
+ * This tests that @Module.includes are traversed for supertypes of a module.
+ */
+final class ModuleIncludesCollectedFromModuleSuperclasses {
+  @Component(modules = TopLevelModule.class)
+  interface C {
+    Foo<String> foo();
+    int includedInTopLevelModule();
+    String includedFromModuleInheritance();
+  }
+
+  @Module(includes = IncludedTopLevel.class)
+  static class TopLevelModule extends FooModule<String> {}
+
+  static class Foo<T> {}
+
+  @Module(includes = IncludedFromModuleInheritance.class)
+  abstract static class FooModule<T> extends FooCreator {
+    @Provides Foo<T> fooOfT() {
+      return createFoo();
+    }
+  }
+
+  static class FooCreator {
+    <T> Foo<T> createFoo() {
+      return new Foo<T>();
+    }
+  }
+
+  @Module
+  static class IncludedTopLevel {
+    @Provides int i() {
+      return 123;
+    }
+  }
+
+  @Module
+  static class IncludedFromModuleInheritance {
+    @Provides String inheritedProvision() {
+      return "inherited";
+    }
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/ModuleWithConflictingNames.java b/compiler/src/it/functional-tests/src/main/java/test/ModuleWithConflictingNames.java
new file mode 100644
index 000000000..2ec4f387d
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/ModuleWithConflictingNames.java
@@ -0,0 +1,48 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package test;
+
+import dagger.Module;
+import dagger.Provides;
+import javax.inject.Inject;
+import javax.inject.Provider;
+
+/**
+ * Module with bindings that might result in generated factories with conflicting field and
+ * parameter names.
+ */
+@Module
+final class ModuleWithConflictingNames {
+  @Provides
+  static Object object(int foo, Provider<String> fooProvider) {
+    return foo + fooProvider.get();
+  }
+
+  /**
+   * A class that might result in a generated factory with conflicting field and parameter names.
+   */
+  static class InjectedClassWithConflictingNames {
+    final int foo;
+    final Provider<String> fooProvider;
+
+    @Inject
+    InjectedClassWithConflictingNames(int foo, Provider<String> fooProvider) {
+      this.foo = foo;
+      this.fooProvider = fooProvider;
+    }
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/MultibindingComponent.java b/compiler/src/it/functional-tests/src/main/java/test/MultibindingComponent.java
index 8be16eb25..cd9aba794 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/MultibindingComponent.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/MultibindingComponent.java
@@ -1,5 +1,5 @@
 /*
-* Copyright (C) 2015 Google, Inc.
+* Copyright (C) 2015 The Dagger Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
+
 package test;
 
 import dagger.Component;
diff --git a/compiler/src/it/functional-tests/src/main/java/test/MultibindingComponentWithMultibindingsInterface.java b/compiler/src/it/functional-tests/src/main/java/test/MultibindingComponentWithMultibindingsInterface.java
index 37f59b10b..c711bb257 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/MultibindingComponentWithMultibindingsInterface.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/MultibindingComponentWithMultibindingsInterface.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 Google, Inc.
+ * Copyright (C) 2016 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test;
 
 import dagger.Component;
diff --git a/compiler/src/it/functional-tests/src/main/java/test/MultibindingDependency.java b/compiler/src/it/functional-tests/src/main/java/test/MultibindingDependency.java
index a92e029e2..d4dca4f32 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/MultibindingDependency.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/MultibindingDependency.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test;
 
 interface MultibindingDependency {
diff --git a/compiler/src/it/functional-tests/src/main/java/test/MultibindingModule.java b/compiler/src/it/functional-tests/src/main/java/test/MultibindingModule.java
index 8562983a0..8bb18db55 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/MultibindingModule.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/MultibindingModule.java
@@ -1,5 +1,5 @@
 /*
-* Copyright (C) 2015 Google, Inc.
+* Copyright (C) 2015 The Dagger Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
+
 package test;
 
 import dagger.Module;
@@ -42,13 +43,6 @@ static String provideFooKey(@SuppressWarnings("unused") double doubleDependency)
     return "foo value";
   }
 
-  @Provides
-  @IntoMap
-  @StringKey("foo @Provides(type)")
-  static String provideFooProvidesTypeKey(@SuppressWarnings("unused") double doubleDependency) {
-    return "foo @Provides(type) value";
-  }
-
   @Provides
   @IntoMap
   @StringKey("bar")
@@ -82,15 +76,9 @@ static int provideSixToSet() {
     return 6;
   }
 
-  @Provides
-  @IntoSet
-  static int provideIntoSetWithProvidesType() {
-    return -100;
-  }
-
   @Provides
   @ElementsIntoSet
-  static Set<Integer> provideElementsIntoSetWithProvidesType() {
+  static Set<Integer> provideElementsIntoSet() {
     Set<Integer> set = new HashSet<>();
     set.add(-101);
     set.add(-102);
diff --git a/compiler/src/it/functional-tests/src/main/java/test/MultibindingsInterfaceModule.java b/compiler/src/it/functional-tests/src/main/java/test/MultibindingsInterfaceModule.java
index b9219ff1f..cc58830a9 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/MultibindingsInterfaceModule.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/MultibindingsInterfaceModule.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 Google, Inc.
+ * Copyright (C) 2016 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test;
 
 import dagger.Module;
diff --git a/compiler/src/it/functional-tests/src/main/java/test/MultibindsModule.java b/compiler/src/it/functional-tests/src/main/java/test/MultibindsModule.java
index 8b193c96d..7e213e61b 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/MultibindsModule.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/MultibindsModule.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 Google, Inc.
+ * Copyright (C) 2016 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test;
 
 import dagger.Module;
diff --git a/compiler/src/it/functional-tests/src/main/java/test/NeedsFactory.java b/compiler/src/it/functional-tests/src/main/java/test/NeedsFactory.java
index cfe7cec03..a60345f31 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/NeedsFactory.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/NeedsFactory.java
@@ -1,5 +1,5 @@
 /*
-* Copyright (C) 2015 Google, Inc.
+* Copyright (C) 2015 The Dagger Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
+
 package test;
 
 import com.google.auto.factory.AutoFactory;
diff --git a/compiler/src/it/functional-tests/src/main/java/test/NestedAnnotationContainer.java b/compiler/src/it/functional-tests/src/main/java/test/NestedAnnotationContainer.java
index c57b4ecf4..e5d3b6499 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/NestedAnnotationContainer.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/NestedAnnotationContainer.java
@@ -1,5 +1,5 @@
 /*
-* Copyright (C) 2015 Google, Inc.
+* Copyright (C) 2015 The Dagger Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
+
 package test;
 
 import dagger.MapKey;
diff --git a/compiler/src/it/functional-tests/src/main/java/test/NonComponentDependencyComponent.java b/compiler/src/it/functional-tests/src/main/java/test/NonComponentDependencyComponent.java
index 43a088cdc..f9f68ced5 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/NonComponentDependencyComponent.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/NonComponentDependencyComponent.java
@@ -1,5 +1,5 @@
 /*
-* Copyright (C) 2015 Google, Inc.
+* Copyright (C) 2015 The Dagger Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
+
 package test;
 
 import dagger.Component;
diff --git a/compiler/src/it/functional-tests/src/main/java/test/NullableModule.java b/compiler/src/it/functional-tests/src/main/java/test/NullableModule.java
index 326401d00..f1545e47c 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/NullableModule.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/NullableModule.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 Google, Inc.
+ * Copyright (C) 2016 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test;
 
 import dagger.Module;
diff --git a/compiler/src/it/functional-tests/src/main/java/test/NumberClassKey.java b/compiler/src/it/functional-tests/src/main/java/test/NumberClassKey.java
index 4164ae5cc..3980260ed 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/NumberClassKey.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/NumberClassKey.java
@@ -1,5 +1,5 @@
 /*
-* Copyright (C) 2015 Google, Inc.
+* Copyright (C) 2015 The Dagger Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
+
 package test;
 
 import dagger.MapKey;
diff --git a/compiler/src/it/functional-tests/src/main/java/test/OuterClassBar.java b/compiler/src/it/functional-tests/src/main/java/test/OuterClassBar.java
index c7fabdb2b..80106e7af 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/OuterClassBar.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/OuterClassBar.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test;
 
 import dagger.Component;
diff --git a/compiler/src/it/functional-tests/src/main/java/test/OuterClassFoo.java b/compiler/src/it/functional-tests/src/main/java/test/OuterClassFoo.java
index 86f963f5c..73c68c2aa 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/OuterClassFoo.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/OuterClassFoo.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test;
 
 import dagger.Component;
diff --git a/compiler/src/it/functional-tests/src/main/java/test/ParentModule.java b/compiler/src/it/functional-tests/src/main/java/test/ParentModule.java
index f550f2f21..4d0f56266 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/ParentModule.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/ParentModule.java
@@ -25,5 +25,4 @@
   static List<Set<String>> provideStaticGenericTypeWithNoTypeParametersInParameterizedModule() {
     return new ArrayList<>();
   }
-
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/ReferencesGeneric.java b/compiler/src/it/functional-tests/src/main/java/test/ReferencesGeneric.java
index 812c45d35..453bdfb7e 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/ReferencesGeneric.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/ReferencesGeneric.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test;
 
 import javax.inject.Inject;
diff --git a/compiler/src/it/functional-tests/src/main/java/test/ReleasableReferencesComponents.java b/compiler/src/it/functional-tests/src/main/java/test/ReleasableReferencesComponents.java
new file mode 100644
index 000000000..84b1bb1e4
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/ReleasableReferencesComponents.java
@@ -0,0 +1,227 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package test;
+
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+import static test.ReleasableReferencesComponents.Thing.thing;
+
+import dagger.Component;
+import dagger.Module;
+import dagger.Provides;
+import dagger.Subcomponent;
+import dagger.multibindings.ClassKey;
+import dagger.multibindings.IntoMap;
+import dagger.releasablereferences.CanReleaseReferences;
+import dagger.releasablereferences.ForReleasableReferences;
+import dagger.releasablereferences.ReleasableReferenceManager;
+import dagger.releasablereferences.TypedReleasableReferenceManager;
+import java.lang.annotation.Retention;
+import java.util.Map;
+import java.util.Set;
+import javax.inject.Scope;
+
+final class ReleasableReferencesComponents {
+
+  interface ThingComponent {
+    /**
+     * A map whose keys are the scope annotations for each value. For unscoped values, the key is
+     * the module that contains the unscoped binding. So for {@link Parent}, the unscoped {@link
+     * Thing}'s key is {@link ParentModule ParentModule.class}; for {@link Child}, it is {@link
+     * ChildModule ChildModule.class}.
+     */
+    Map<Class<?>, Thing> things();
+  }
+
+  @ParentRegularScope
+  @ParentReleasableScope1
+  @ParentReleasableScope2
+  @Component(modules = ParentModule.class)
+  interface Parent extends ThingComponent {
+
+    Set<ReleasableReferenceManager> managers();
+
+    Set<TypedReleasableReferenceManager<Metadata1>> typedReleasableReferenceManagers1();
+
+    Set<TypedReleasableReferenceManager<Metadata2>> typedReleasableReferenceManagers2();
+
+    @ForReleasableReferences(ParentReleasableScope1.class)
+    ReleasableReferenceManager parentReleasableScope1Manager();
+
+    @ForReleasableReferences(ParentReleasableScope2.class)
+    ReleasableReferenceManager parentReleasableScope2Manager();
+
+    @ForReleasableReferences(ParentReleasableScope2.class)
+    TypedReleasableReferenceManager<Metadata1> parentReleasableScope2TypedReferenceManager();
+
+    @ForReleasableReferences(ChildReleasableScope1.class)
+    ReleasableReferenceManager childReleasableScope1Manager();
+
+    @ForReleasableReferences(ChildReleasableScope2.class)
+    ReleasableReferenceManager childReleasableScope2Manager();
+
+    @ForReleasableReferences(ChildReleasableScope2.class)
+    TypedReleasableReferenceManager<Metadata1> childReleasableScope2TypedReferenceManager1();
+
+    @ForReleasableReferences(ChildReleasableScope2.class)
+    TypedReleasableReferenceManager<Metadata2> childReleasableScope2TypedReferenceManager2();
+
+    Child child();
+  }
+
+  // TODO(ronshapiro): investigate the maven-compiler-plugin bug that is blocking javac from
+  // recognizing @AutoValue when it is imported instead of fully-qualified
+  // http://bugs.java.com/view_bug.do?bug_id=7101822
+  @com.google.auto.value.AutoValue
+  abstract static class Thing {
+    abstract int count();
+
+    static Thing thing(int count) {
+      return new AutoValue_ReleasableReferencesComponents_Thing(count);
+    }
+  }
+
+  @ChildRegularScope
+  @ChildReleasableScope1
+  @ChildReleasableScope2
+  @ChildReleasableScope3
+  @Subcomponent(modules = ChildModule.class)
+  interface Child extends ThingComponent {}
+
+  @CanReleaseReferences
+  @interface Metadata1 {
+    String value();
+  }
+
+  @CanReleaseReferences
+  @interface Metadata2 {
+    String value();
+  }
+
+  @Retention(RUNTIME)
+  @Scope
+  @interface ParentRegularScope {}
+
+  @Retention(RUNTIME)
+  @Scope
+  @interface ChildRegularScope {}
+
+  @Retention(RUNTIME)
+  @CanReleaseReferences
+  @Scope
+  @interface ParentReleasableScope1 {}
+
+  @Retention(RUNTIME)
+  @Metadata1("ParentReleasableScope2")
+  @Scope
+  @interface ParentReleasableScope2 {}
+
+  @Retention(RUNTIME)
+  @Metadata2("ChildReleasableScope1")
+  @Scope
+  @interface ChildReleasableScope1 {}
+
+  @Retention(RUNTIME)
+  @Metadata1("ChildReleasableScope2.1")
+  @Metadata2("ChildReleasableScope2.2")
+  @Scope
+  @interface ChildReleasableScope2 {}
+
+  @Retention(RUNTIME)
+  @Metadata1("ChildReleasableScope3.1")
+  @Metadata2("ChildReleasableScope3.2")
+  @CanReleaseReferences
+  @Scope
+  @interface ChildReleasableScope3 {}
+
+  @Module
+  static final class ParentModule {
+    private int unscopedCount;
+    private int regularScopeCount;
+    private int releasableScope1Count;
+    private int releasableScope2Count;
+
+    @Provides
+    @IntoMap
+    @ClassKey(ParentModule.class)
+    Thing parentUnscopedThing() {
+      return thing(++unscopedCount);
+    }
+
+    @Provides
+    @IntoMap
+    @ClassKey(ParentRegularScope.class)
+    @ParentRegularScope
+    Thing regularScopedThing() {
+      return thing(++regularScopeCount);
+    }
+
+    @Provides
+    @IntoMap
+    @ClassKey(ParentReleasableScope1.class)
+    @ParentReleasableScope1
+    Thing releasableScope1Thing() {
+      return thing(++releasableScope1Count);
+    }
+
+    @Provides
+    @IntoMap
+    @ClassKey(ParentReleasableScope2.class)
+    @ParentReleasableScope2
+    Thing releasableScope2Thing() {
+      return thing(++releasableScope2Count);
+    }
+  }
+
+  @Module
+  static final class ChildModule {
+    private int unscopedCount;
+    private int regularScopeCount;
+    private int releasableScope1Count;
+    private int releasableScope2Count;
+
+    @Provides
+    @IntoMap
+    @ClassKey(ChildModule.class)
+    Thing childUnscopedThing() {
+      return thing(++unscopedCount);
+    }
+
+    @Provides
+    @IntoMap
+    @ClassKey(ChildRegularScope.class)
+    @ChildRegularScope
+    Thing regularScopedThing() {
+      return thing(++regularScopeCount);
+    }
+
+    @Provides
+    @IntoMap
+    @ClassKey(ChildReleasableScope1.class)
+    @ChildReleasableScope1
+    Thing releasableScope1Thing() {
+      return thing(++releasableScope1Count);
+    }
+
+    @Provides
+    @IntoMap
+    @ClassKey(ChildReleasableScope2.class)
+    @ChildReleasableScope2
+    Thing releasableScope2Thing() {
+      return thing(++releasableScope2Count);
+    }
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/ShortKey.java b/compiler/src/it/functional-tests/src/main/java/test/ShortKey.java
index 01b3aa99d..9cb8f3e86 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/ShortKey.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/ShortKey.java
@@ -1,5 +1,5 @@
 /*
-* Copyright (C) 2015 Google, Inc.
+* Copyright (C) 2015 The Dagger Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
+
 package test;
 
 import dagger.MapKey;
diff --git a/compiler/src/it/functional-tests/src/main/java/test/SomeQualifier.java b/compiler/src/it/functional-tests/src/main/java/test/SomeQualifier.java
index cf68c3056..9ead648b3 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/SomeQualifier.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/SomeQualifier.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 Google, Inc.
+ * Copyright (C) 2016 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,14 +13,15 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test;
 
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import javax.inject.Qualifier;
 
-import static java.lang.annotation.RetentionPolicy.RUNTIME;
-
 @Documented
 @Retention(RUNTIME)
 @Qualifier
diff --git a/compiler/src/it/functional-tests/src/main/java/test/Thing.java b/compiler/src/it/functional-tests/src/main/java/test/Thing.java
index 46cbdc999..2099eba6c 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/Thing.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/Thing.java
@@ -1,5 +1,5 @@
 /*
-* Copyright (C) 2014 Google, Inc.
+* Copyright (C) 2014 The Dagger Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
+
 package test;
 
 import javax.inject.Inject;
diff --git a/compiler/src/it/functional-tests/src/main/java/test/TypeWithInheritedMembersInjection.java b/compiler/src/it/functional-tests/src/main/java/test/TypeWithInheritedMembersInjection.java
index 587baade1..8bb6fcac4 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/TypeWithInheritedMembersInjection.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/TypeWithInheritedMembersInjection.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test;
 
 import javax.inject.Inject;
diff --git a/compiler/src/it/functional-tests/src/main/java/test/UnwrappedAnnotationKey.java b/compiler/src/it/functional-tests/src/main/java/test/UnwrappedAnnotationKey.java
index d1a3b4863..96d2cb289 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/UnwrappedAnnotationKey.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/UnwrappedAnnotationKey.java
@@ -1,5 +1,5 @@
 /*
-* Copyright (C) 2015 Google, Inc.
+* Copyright (C) 2015 The Dagger Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
+
 package test;
 
 import dagger.MapKey;
diff --git a/compiler/src/it/functional-tests/src/main/java/test/WrappedAnnotationKey.java b/compiler/src/it/functional-tests/src/main/java/test/WrappedAnnotationKey.java
index 7f0dbafab..50306d032 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/WrappedAnnotationKey.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/WrappedAnnotationKey.java
@@ -1,5 +1,5 @@
 /*
-* Copyright (C) 2015 Google, Inc.
+* Copyright (C) 2015 The Dagger Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
+
 package test;
 
 import dagger.MapKey;
diff --git a/compiler/src/it/functional-tests/src/main/java/test/binds/Foo.java b/compiler/src/it/functional-tests/src/main/java/test/binds/Foo.java
index 86122f9b4..6835ebbba 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/binds/Foo.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/binds/Foo.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 Google, Inc.
+ * Copyright (C) 2016 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test.binds;
 
 /**
diff --git a/compiler/src/it/functional-tests/src/main/java/test/binds/FooOfObjects.java b/compiler/src/it/functional-tests/src/main/java/test/binds/FooOfObjects.java
index 730e70211..bd3950c7b 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/binds/FooOfObjects.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/binds/FooOfObjects.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 Google, Inc.
+ * Copyright (C) 2016 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
diff --git a/compiler/src/it/functional-tests/src/main/java/test/binds/FooOfStrings.java b/compiler/src/it/functional-tests/src/main/java/test/binds/FooOfStrings.java
index c5a23f92f..0243e3a18 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/binds/FooOfStrings.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/binds/FooOfStrings.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 Google, Inc.
+ * Copyright (C) 2016 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test.binds;
 
 import javax.inject.Inject;
diff --git a/compiler/src/it/functional-tests/src/main/java/test/binds/InterfaceModule.java b/compiler/src/it/functional-tests/src/main/java/test/binds/InterfaceModule.java
index 84814a6f6..732c040c5 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/binds/InterfaceModule.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/binds/InterfaceModule.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 Google, Inc.
+ * Copyright (C) 2016 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test.binds;
 
 import dagger.Binds;
diff --git a/compiler/src/it/functional-tests/src/main/java/test/binds/SimpleBindingModule.java b/compiler/src/it/functional-tests/src/main/java/test/binds/SimpleBindingModule.java
index b760eca58..ab0288e64 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/binds/SimpleBindingModule.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/binds/SimpleBindingModule.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 Google, Inc.
+ * Copyright (C) 2016 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,11 +13,13 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test.binds;
 
 import dagger.Binds;
 import dagger.Module;
 import dagger.Provides;
+import dagger.Reusable;
 import dagger.multibindings.ElementsIntoSet;
 import dagger.multibindings.IntKey;
 import dagger.multibindings.IntoMap;
@@ -36,6 +38,11 @@
   @Binds
   abstract Object bindObject(FooOfStrings impl);
 
+  @Binds
+  @Reusable
+  @SomeQualifier
+  abstract Object bindReusableObject(FooOfStrings impl);
+
   @Binds
   abstract Foo<String> bindFooOfStrings(FooOfStrings impl);
 
@@ -117,6 +124,24 @@ static Object provide789ForMap() {
     return "789-string";
   }
 
+  @Binds
+  @SomeQualifier
+  abstract int primitiveToPrimitive(int intValue);
+
+  @Binds
+  @IntoSet
+  abstract int intValueIntoSet(int intValue);
+
+  @Binds
+  @IntoMap
+  @IntKey(10)
+  abstract int intValueIntoMap(int intValue);
+
+  @Provides
+  static int intValue() {
+    return 100;
+  }
+
   @Binds
   @IntoMap
   @IntKey(123)
diff --git a/compiler/src/it/functional-tests/src/main/java/test/binds/TestComponent.java b/compiler/src/it/functional-tests/src/main/java/test/binds/TestComponent.java
index 08866ed22..9379dff12 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/binds/TestComponent.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/binds/TestComponent.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 Google, Inc.
+ * Copyright (C) 2016 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test.binds;
 
 import dagger.Component;
@@ -27,6 +28,9 @@
 public interface TestComponent {
   Object object();
 
+  @SomeQualifier
+  Object reusableObject();
+
   Foo<String> fooOfStrings();
 
   Foo<Object> fooOfObjects();
@@ -47,4 +51,10 @@
   Map<Integer, Provider<Object>> integerProviderOfObjectMap();
 
   @SomeQualifier Map<Integer, Object> qualifiedIntegerObjectMap();
+
+  @SomeQualifier int uniquePrimitive();
+
+  Set<Integer> primitiveSet();
+
+  Map<Integer, Integer> primitiveValueMap();
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builder/BuildMethodCovariantReturn.java b/compiler/src/it/functional-tests/src/main/java/test/builder/BuildMethodCovariantReturn.java
new file mode 100644
index 000000000..be522f5fa
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/builder/BuildMethodCovariantReturn.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package test.builder;
+
+import dagger.Component;
+
+@Component
+interface BuildMethodCovariantReturn {
+
+  @Component.Builder
+  interface Builder {
+    Object build();
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builder/BuildMethodCovariantReturnInherited.java b/compiler/src/it/functional-tests/src/main/java/test/builder/BuildMethodCovariantReturnInherited.java
new file mode 100644
index 000000000..a02ddf75a
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/builder/BuildMethodCovariantReturnInherited.java
@@ -0,0 +1,57 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package test.builder;
+
+import dagger.Component;
+
+interface BuildMethodCovariantReturnInherited {
+  @Component
+  interface Simple {
+    interface BuilderSupertype {
+      Object build();
+    }
+
+    @Component.Builder
+    interface Builder extends BuilderSupertype {}
+  }
+
+  interface ComponentSupertype {}
+
+  @Component
+  interface GenericBuilderType extends ComponentSupertype {
+    interface GenericBuilderSupertype<T> {
+      T build();
+    }
+
+    @Component.Builder
+    interface Builder extends GenericBuilderSupertype<ComponentSupertype> {}
+  }
+
+  interface ParameterizedComponentSupertype<T> {}
+
+  @Component
+  interface GenericComponentSupertypeAndBuilderSupertype
+      extends ParameterizedComponentSupertype<Object> {
+
+    interface GenericBuilderSupertype<T> {
+      ParameterizedComponentSupertype<T> build();
+    }
+
+    @Component.Builder
+    interface Builder extends GenericBuilderSupertype<Object> {}
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builder/ByteModule.java b/compiler/src/it/functional-tests/src/main/java/test/builder/ByteModule.java
index 8b85d606c..feafdd0d6 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/builder/ByteModule.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/builder/ByteModule.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test.builder;
 
 import dagger.Module;
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builder/DepComponent.java b/compiler/src/it/functional-tests/src/main/java/test/builder/DepComponent.java
index 93fd59def..1d18341f4 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/builder/DepComponent.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/builder/DepComponent.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test.builder;
 
 import dagger.Component;
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builder/DoubleModule.java b/compiler/src/it/functional-tests/src/main/java/test/builder/DoubleModule.java
index 2dec4a7a2..8cf226bef 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/builder/DoubleModule.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/builder/DoubleModule.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test.builder;
 
 import dagger.Module;
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builder/FloatModule.java b/compiler/src/it/functional-tests/src/main/java/test/builder/FloatModule.java
index 309e7ee98..0d3af1d31 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/builder/FloatModule.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/builder/FloatModule.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test.builder;
 
 import dagger.Module;
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builder/GenericParent.java b/compiler/src/it/functional-tests/src/main/java/test/builder/GenericParent.java
index af196eeda..beffe27a6 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/builder/GenericParent.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/builder/GenericParent.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test.builder;
 
 interface GenericParent<B> {  
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builder/Grandchild.java b/compiler/src/it/functional-tests/src/main/java/test/builder/Grandchild.java
index 8cbf67b19..759b470df 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/builder/Grandchild.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/builder/Grandchild.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test.builder;
 
 import dagger.Subcomponent;
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builder/IntModuleIncludingDoubleAndFloat.java b/compiler/src/it/functional-tests/src/main/java/test/builder/IntModuleIncludingDoubleAndFloat.java
index 5e3a92827..69c12259d 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/builder/IntModuleIncludingDoubleAndFloat.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/builder/IntModuleIncludingDoubleAndFloat.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test.builder;
 
 import dagger.Module;
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builder/LongModule.java b/compiler/src/it/functional-tests/src/main/java/test/builder/LongModule.java
index c16c9c79f..cb848a707 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/builder/LongModule.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/builder/LongModule.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test.builder;
 
 import dagger.Module;
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builder/MiddleChild.java b/compiler/src/it/functional-tests/src/main/java/test/builder/MiddleChild.java
index 690c91ad7..b606b7986 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/builder/MiddleChild.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/builder/MiddleChild.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test.builder;
 
 import dagger.Subcomponent;
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builder/MiddleScope.java b/compiler/src/it/functional-tests/src/main/java/test/builder/MiddleScope.java
index e2fbcaa42..8f0c8bb67 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/builder/MiddleScope.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/builder/MiddleScope.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,13 +13,14 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test.builder;
 
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
 import java.lang.annotation.Retention;
 import javax.inject.Scope;
 
-import static java.lang.annotation.RetentionPolicy.RUNTIME;
-
 @Scope
 @Retention(RUNTIME)
 @interface MiddleScope {
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builder/OtherMiddleChild.java b/compiler/src/it/functional-tests/src/main/java/test/builder/OtherMiddleChild.java
index 28e43bafe..a5871c6e8 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/builder/OtherMiddleChild.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/builder/OtherMiddleChild.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test.builder;
 
 import dagger.Subcomponent;
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builder/ParentComponent.java b/compiler/src/it/functional-tests/src/main/java/test/builder/ParentComponent.java
index 584eff6ef..a9b8fc723 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/builder/ParentComponent.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/builder/ParentComponent.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test.builder;
 
 import dagger.Component;
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builder/ParentOfGenericComponent.java b/compiler/src/it/functional-tests/src/main/java/test/builder/ParentOfGenericComponent.java
index 474c61701..ad0c49193 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/builder/ParentOfGenericComponent.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/builder/ParentOfGenericComponent.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test.builder;
 
 import dagger.Component;
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builder/RequiresSubcomponentBuilder.java b/compiler/src/it/functional-tests/src/main/java/test/builder/RequiresSubcomponentBuilder.java
index ee9963227..23bbaa904 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/builder/RequiresSubcomponentBuilder.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/builder/RequiresSubcomponentBuilder.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test.builder;
 
 import javax.inject.Inject;
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builder/StringModule.java b/compiler/src/it/functional-tests/src/main/java/test/builder/StringModule.java
index 3b979a5ab..c1fb723fb 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/builder/StringModule.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/builder/StringModule.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test.builder;
 
 import dagger.Module;
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builder/TestChildComponentWithBuilderAbstractClass.java b/compiler/src/it/functional-tests/src/main/java/test/builder/TestChildComponentWithBuilderAbstractClass.java
index 8f39c1401..21d1ddd59 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/builder/TestChildComponentWithBuilderAbstractClass.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/builder/TestChildComponentWithBuilderAbstractClass.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test.builder;
 
 import dagger.Subcomponent;
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builder/TestChildComponentWithBuilderInterface.java b/compiler/src/it/functional-tests/src/main/java/test/builder/TestChildComponentWithBuilderInterface.java
index 2add34ed5..59e39e543 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/builder/TestChildComponentWithBuilderInterface.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/builder/TestChildComponentWithBuilderInterface.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test.builder;
 
 import dagger.Subcomponent;
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builder/TestComponentWithBuilderAbstractClass.java b/compiler/src/it/functional-tests/src/main/java/test/builder/TestComponentWithBuilderAbstractClass.java
index 5eef53fe5..da966cc6d 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/builder/TestComponentWithBuilderAbstractClass.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/builder/TestComponentWithBuilderAbstractClass.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test.builder;
 
 import dagger.Component;
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builder/TestComponentWithBuilderInterface.java b/compiler/src/it/functional-tests/src/main/java/test/builder/TestComponentWithBuilderInterface.java
index 55214f836..6cd556199 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/builder/TestComponentWithBuilderInterface.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/builder/TestComponentWithBuilderInterface.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test.builder;
 
 import dagger.Component;
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builder/TestComponentWithGenericBuilderAbstractClass.java b/compiler/src/it/functional-tests/src/main/java/test/builder/TestComponentWithGenericBuilderAbstractClass.java
index 8032185b2..d7603e9c8 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/builder/TestComponentWithGenericBuilderAbstractClass.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/builder/TestComponentWithGenericBuilderAbstractClass.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test.builder;
 
 import dagger.Component;
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builder/TestComponentWithGenericBuilderInterface.java b/compiler/src/it/functional-tests/src/main/java/test/builder/TestComponentWithGenericBuilderInterface.java
index f63e3ec90..5e8ca2400 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/builder/TestComponentWithGenericBuilderInterface.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/builder/TestComponentWithGenericBuilderInterface.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test.builder;
 
 import dagger.Component;
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builderbinds/BuilderSupertype.java b/compiler/src/it/functional-tests/src/main/java/test/builderbinds/BuilderSupertype.java
new file mode 100644
index 000000000..c965bc224
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/builderbinds/BuilderSupertype.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package test.builderbinds;
+
+import dagger.BindsInstance;
+import javax.inject.Named;
+
+interface BuilderSupertype {
+  @BindsInstance
+  void boundInSubtype(@Named("subtype") int subtype);
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builderbinds/Nullable.java b/compiler/src/it/functional-tests/src/main/java/test/builderbinds/Nullable.java
new file mode 100644
index 000000000..971eb0620
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/builderbinds/Nullable.java
@@ -0,0 +1,19 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package test.builderbinds;
+
+@interface Nullable {}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builderbinds/TestComponent.java b/compiler/src/it/functional-tests/src/main/java/test/builderbinds/TestComponent.java
new file mode 100644
index 000000000..75d470b9a
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/builderbinds/TestComponent.java
@@ -0,0 +1,61 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package test.builderbinds;
+
+import dagger.BindsInstance;
+import dagger.Component;
+import java.util.List;
+import javax.inject.Named;
+
+@Component
+interface TestComponent {
+  int count();
+
+  long l();
+
+  @Named("input")
+  String input();
+
+  @Nullable
+  @Named("nullable input")
+  String nullableInput();
+
+  List<String> listOfString();
+
+  @Named("subtype")
+  int boundInSubtype();
+
+  @Component.Builder
+  interface Builder extends BuilderSupertype {
+    @BindsInstance
+    Builder count(int count);
+
+    @BindsInstance
+    Builder l(long l);
+
+    @BindsInstance
+    Builder input(@Named("input") String input);
+
+    @BindsInstance
+    Builder nullableInput(@Nullable @Named("nullable input") String nullableInput);
+
+    @BindsInstance
+    Builder listOfString(List<String> listOfString);
+
+    TestComponent build();
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/cycle/Cycles.java b/compiler/src/it/functional-tests/src/main/java/test/cycle/Cycles.java
index 63bf45c87..b78c4e76a 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/cycle/Cycles.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/cycle/Cycles.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,8 +13,10 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test.cycle;
 
+import dagger.Binds;
 import dagger.Component;
 import dagger.Lazy;
 import dagger.Module;
@@ -28,13 +30,15 @@
 
 /**
  * Cycle classes used for testing cyclic dependencies.
- * A <- (E <- D <- B <- C <- Provider<A>, Lazy<A>), (B <- C <- Provider<A>, Lazy<A>)
- * S <- Provider<S>, Lazy<S>
+ *
+ * <pre>
+ * {@literal A ← (E ← D ← B ← C ← Provider<A>, Lazy<A>), (B ← C ← Provider<A>, Lazy<A>)}
+ * {@literal S ← Provider<S>, Lazy<S>}
+ * </pre>
  *
  * @author Tony Bentancur
  * @since 2.0
  */
-
 final class Cycles {
   private Cycles() {}
 
@@ -61,6 +65,7 @@ private Cycles() {}
   static class C {
     public final Provider<A> aProvider;
     @Inject public Lazy<A> aLazy;
+    @Inject public Provider<Lazy<A>> aLazyProvider;
 
     @Inject
     C(Provider<A> aProvider) {
@@ -117,20 +122,16 @@ private Cycles() {}
   }
 
   @Module
-  static class CycleMapModule {
-    @Provides
+  abstract static class CycleMapModule {
+    @Binds
     @IntoMap
     @StringKey("X")
-    static X x(X x) {
-      return x;
-    }
+    abstract X x(X x);
 
-    @Provides
+    @Binds
     @IntoMap
     @StringKey("Y")
-    static Y y(Y y) {
-      return y;
-    }
+    abstract Y y(Y y);
   }
 
   @SuppressWarnings("dependency-cycle")
diff --git a/compiler/src/it/functional-tests/src/main/java/test/cycle/LongCycle.java b/compiler/src/it/functional-tests/src/main/java/test/cycle/LongCycle.java
index 0562ad610..ed1518b35 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/cycle/LongCycle.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/cycle/LongCycle.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,12 +13,18 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test.cycle;
 
 import dagger.Component;
 import javax.inject.Inject;
 import javax.inject.Provider;
 
+/**
+ * Component with a long enough cycle such that the initialization of a provider happens in a
+ * separate {@code initialize} method from the one where it is used as a delegated factory.
+ *
+ */
 // Each nested class's constructor has an intentionally unused parameter.
 @SuppressWarnings("unused")
 final class LongCycle {
diff --git a/compiler/src/it/functional-tests/src/main/java/test/membersinject/ChildOfArrayOfParentOfStringArray.java b/compiler/src/it/functional-tests/src/main/java/test/membersinject/ChildOfArrayOfParentOfStringArray.java
index 22efcf12e..de07ef9f8 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/membersinject/ChildOfArrayOfParentOfStringArray.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/membersinject/ChildOfArrayOfParentOfStringArray.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test.membersinject;
 
 class ChildOfArrayOfParentOfStringArray extends
diff --git a/compiler/src/it/functional-tests/src/main/java/test/membersinject/ChildOfPrimitiveIntArray.java b/compiler/src/it/functional-tests/src/main/java/test/membersinject/ChildOfPrimitiveIntArray.java
index e01c1c266..9ba1ca349 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/membersinject/ChildOfPrimitiveIntArray.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/membersinject/ChildOfPrimitiveIntArray.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test.membersinject;
 
 class ChildOfPrimitiveIntArray extends MembersInjectGenericParent<int[]> {
diff --git a/compiler/src/it/functional-tests/src/main/java/test/membersinject/ChildOfStringArray.java b/compiler/src/it/functional-tests/src/main/java/test/membersinject/ChildOfStringArray.java
index 8ec943b96..e11dad1cd 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/membersinject/ChildOfStringArray.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/membersinject/ChildOfStringArray.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test.membersinject;
 
 class ChildOfStringArray extends MembersInjectGenericParent<String[]> {
diff --git a/compiler/src/it/functional-tests/src/main/java/test/membersinject/MembersInjectComponent.java b/compiler/src/it/functional-tests/src/main/java/test/membersinject/MembersInjectComponent.java
index 9ab8c1928..9fe099f33 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/membersinject/MembersInjectComponent.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/membersinject/MembersInjectComponent.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test.membersinject;
 
 import dagger.Component;
@@ -23,5 +24,6 @@
   void inject(ChildOfStringArray subfoo);
   void inject(ChildOfArrayOfParentOfStringArray subfoo);
   void inject(ChildOfPrimitiveIntArray subfoo);
+  void inject(RawFrameworkTypes rawFrameworkTypes);
 
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/membersinject/MembersInjectGenericParent.java b/compiler/src/it/functional-tests/src/main/java/test/membersinject/MembersInjectGenericParent.java
index 064b88642..674da5052 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/membersinject/MembersInjectGenericParent.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/membersinject/MembersInjectGenericParent.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test.membersinject;
 
 import javax.inject.Inject;
diff --git a/compiler/src/it/functional-tests/src/main/java/test/membersinject/MembersInjectModule.java b/compiler/src/it/functional-tests/src/main/java/test/membersinject/MembersInjectModule.java
index a6c1fadb9..fc31c772e 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/membersinject/MembersInjectModule.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/membersinject/MembersInjectModule.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test.membersinject;
 
 import dagger.Module;
diff --git a/compiler/src/it/functional-tests/src/main/java/test/membersinject/NonRequestedChild.java b/compiler/src/it/functional-tests/src/main/java/test/membersinject/NonRequestedChild.java
index 108a1b58f..448c37df1 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/membersinject/NonRequestedChild.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/membersinject/NonRequestedChild.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test.membersinject;
 
 import javax.inject.Inject;
diff --git a/compiler/src/it/functional-tests/src/main/java/test/membersinject/RawFrameworkTypes.java b/compiler/src/it/functional-tests/src/main/java/test/membersinject/RawFrameworkTypes.java
new file mode 100644
index 000000000..88a473177
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/membersinject/RawFrameworkTypes.java
@@ -0,0 +1,29 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package test.membersinject;
+
+import dagger.Lazy;
+import dagger.MembersInjector;
+import javax.inject.Provider;
+
+// https://github.com/google/dagger/issues/419
+@SuppressWarnings({"rawtypes", "unused"})
+class RawFrameworkTypes {
+  void nonInjectMethodWithARawProvider(Provider rawProvider) {}
+  void nonInjectMethodWithARawLazy(Lazy rawLazy) {}
+  void nonInjectMethodWithARawMembersInjector(MembersInjector rawMembersInjector) {}
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/multipackage/FooComponent.java b/compiler/src/it/functional-tests/src/main/java/test/multipackage/FooComponent.java
index 62da35da5..afbc3f05f 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/multipackage/FooComponent.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/multipackage/FooComponent.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -20,6 +20,7 @@
 import java.util.Set;
 import test.multipackage.a.AModule;
 import test.multipackage.a.UsesInaccessible;
+import test.multipackage.a.UsesInaccessibleInGenericsOnly;
 import test.multipackage.sub.FooChildComponent;
 
 /**
@@ -42,4 +43,6 @@
   FooChildComponent fooChildComponent();
 
   UsesInaccessible usesInaccessible();
+
+  UsesInaccessibleInGenericsOnly accessibleConstructorUsesInaccessibleInGenericsOnly();
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/multipackage/MembersInjectionVisibilityComponent.java b/compiler/src/it/functional-tests/src/main/java/test/multipackage/MembersInjectionVisibilityComponent.java
index 85ce40aac..608255b9d 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/multipackage/MembersInjectionVisibilityComponent.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/multipackage/MembersInjectionVisibilityComponent.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test.multipackage;
 
 import dagger.Component;
diff --git a/compiler/src/it/functional-tests/src/main/java/test/multipackage/MultibindsComponent.java b/compiler/src/it/functional-tests/src/main/java/test/multipackage/MultibindsComponent.java
new file mode 100644
index 000000000..b4ef7475b
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/multipackage/MultibindsComponent.java
@@ -0,0 +1,36 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package test.multipackage;
+
+import dagger.Component;
+import test.multipackage.a.AMultibindsModule;
+import test.multipackage.a.UsesInaccessible;
+
+/**
+ * A component that tests the interaction between multiple packages and {@code @Multibinding}s.
+ * Specifically, we want:
+ *
+ * <ul>
+ * <li>A {@code @Multibinding} for an empty set of a type not accessible from this package.
+ * <li>A {@code @Multibinding} for an empty map of a type not accessible from this package.
+ * <li>A public type that injects the empty set and map of inaccessible objects.
+ * </ul>
+ */
+@Component(modules = {AMultibindsModule.class})
+interface MultibindsComponent {
+  UsesInaccessible usesInaccessible();
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/AGrandchild.java b/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/AGrandchild.java
index 8f0f1f39c..0aa46faed 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/AGrandchild.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/AGrandchild.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test.multipackage.a;
 
 import javax.inject.Inject;
@@ -35,6 +36,7 @@ protected void aParentMethod(APublicObject aParentMethod) {
     super.aParentMethod(aParentMethod);
   }
 
+  @SuppressWarnings("OverridesJavaxInjectableMethod")
   @Override
   protected void aChildMethod(APublicObject aChildMethod) {
     super.aChildMethod(aChildMethod);
diff --git a/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/AModule.java b/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/AModule.java
index cede7c36a..7095d98df 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/AModule.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/AModule.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,6 +16,7 @@
 
 package test.multipackage.a;
 
+import dagger.Binds;
 import dagger.Module;
 import dagger.Provides;
 import dagger.multibindings.ElementsIntoSet;
@@ -24,21 +25,18 @@
 import dagger.multibindings.StringKey;
 import java.util.HashSet;
 import java.util.Set;
-import javax.inject.Inject;
 
 @Module
-public final class AModule {
+public abstract class AModule {
   @Provides
   @IntoSet
   static String provideString() {
     return "a";
   }
 
-  @Provides
+  @Binds
   @IntoSet
-  static Inaccessible provideInaccessible(Inaccessible inaccessible) {
-    return inaccessible;
-  }
+  abstract Inaccessible provideInaccessible(Inaccessible inaccessible);
 
   @Provides
   @ElementsIntoSet
@@ -46,15 +44,8 @@ static Inaccessible provideInaccessible(Inaccessible inaccessible) {
     return new HashSet<>();
   }
 
-  @Provides
+  @Binds
   @IntoMap
   @StringKey("inaccessible")
-  static Inaccessible provideInaccessibleToMap(Inaccessible inaccessible) {
-    return inaccessible;
-  }
-
-  static class Inaccessible {
-    @Inject Inaccessible() {}
-  }
-
+  abstract Inaccessible provideInaccessibleToMap(Inaccessible inaccessible);
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/AMultibindsModule.java b/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/AMultibindsModule.java
new file mode 100644
index 000000000..2ddd0d8e3
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/AMultibindsModule.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package test.multipackage.a;
+
+import dagger.Module;
+import dagger.multibindings.Multibinds;
+import java.util.Map;
+import java.util.Set;
+
+/** A module that {@code @Multibinds} a set and a map of {@link Inaccessible}. */
+@Module
+public abstract class AMultibindsModule {
+  @Multibinds
+  abstract Set<Inaccessible> inaccessibleSet();
+
+  @Multibinds
+  abstract Map<String, Inaccessible> inaccessibleMap();
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/APackagePrivateObject.java b/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/APackagePrivateObject.java
index d60413331..3e67bb088 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/APackagePrivateObject.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/APackagePrivateObject.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test.multipackage.a;
 
 import javax.inject.Inject;
diff --git a/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/AParent.java b/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/AParent.java
index 4c91a6f26..647ebdeda 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/AParent.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/AParent.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test.multipackage.a;
 
 import javax.inject.Inject;
diff --git a/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/APublicObject.java b/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/APublicObject.java
index 90357f661..5262ec40e 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/APublicObject.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/APublicObject.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test.multipackage.a;
 
 import javax.inject.Inject;
diff --git a/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/Inaccessible.java b/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/Inaccessible.java
new file mode 100644
index 000000000..e20d74f0e
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/Inaccessible.java
@@ -0,0 +1,23 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package test.multipackage.a;
+
+import javax.inject.Inject;
+
+final class Inaccessible {
+  @Inject Inaccessible() {}
+}
\ No newline at end of file
diff --git a/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/UsesInaccessible.java b/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/UsesInaccessible.java
index 8dab62c78..3ee3a5e06 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/UsesInaccessible.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/UsesInaccessible.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 Google, Inc.
+ * Copyright (C) 2016 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,19 +13,17 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test.multipackage.a;
 
 import java.util.Map;
 import java.util.Set;
-
 import javax.inject.Inject;
 
-import test.multipackage.a.AModule.Inaccessible;
-
 @SuppressWarnings("unused")
 public class UsesInaccessible {
   @Inject
-  UsesInaccessible(
+  public UsesInaccessible(
       Inaccessible inaccessible,
       Set<Inaccessible> inaccessibleSet,
       Map<String, Inaccessible> inaccessibleMap) {}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/UsesInaccessibleInGenericsOnly.java b/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/UsesInaccessibleInGenericsOnly.java
new file mode 100644
index 000000000..f212a0c66
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/UsesInaccessibleInGenericsOnly.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package test.multipackage.a;
+
+import java.util.Map;
+import java.util.Set;
+import javax.inject.Inject;
+
+@SuppressWarnings("unused")
+public class UsesInaccessibleInGenericsOnly {
+  @Inject
+  public UsesInaccessibleInGenericsOnly(
+      Set<Inaccessible> inaccessibleSet, Map<String, Inaccessible> inaccessibleMap) {}
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/multipackage/b/BChild.java b/compiler/src/it/functional-tests/src/main/java/test/multipackage/b/BChild.java
index 188d1201f..6a62006b9 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/multipackage/b/BChild.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/multipackage/b/BChild.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test.multipackage.b;
 
 import javax.inject.Inject;
@@ -30,6 +31,7 @@ protected void aChildMethod(APublicObject aChildMethod) {
     this.aChildMethod = aChildMethod;
   }
 
+  @SuppressWarnings("OverridesJavaxInjectableMethod")
   @Override
   protected void aParentMethod(APublicObject aParentMethod) {
     super.aParentMethod(aParentMethod);
diff --git a/compiler/src/it/functional-tests/src/main/java/test/multipackage/b/BModule.java b/compiler/src/it/functional-tests/src/main/java/test/multipackage/b/BModule.java
index 6217bf830..e9c5482fa 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/multipackage/b/BModule.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/multipackage/b/BModule.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
diff --git a/compiler/src/it/functional-tests/src/main/java/test/multipackage/b/BPackagePrivateObject.java b/compiler/src/it/functional-tests/src/main/java/test/multipackage/b/BPackagePrivateObject.java
index c397a02c8..bce3e4c71 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/multipackage/b/BPackagePrivateObject.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/multipackage/b/BPackagePrivateObject.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test.multipackage.b;
 
 import javax.inject.Inject;
diff --git a/compiler/src/it/functional-tests/src/main/java/test/multipackage/c/CModule.java b/compiler/src/it/functional-tests/src/main/java/test/multipackage/c/CModule.java
index edfb9233d..b137cee2f 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/multipackage/c/CModule.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/multipackage/c/CModule.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
diff --git a/compiler/src/it/functional-tests/src/main/java/test/multipackage/d/DModule.java b/compiler/src/it/functional-tests/src/main/java/test/multipackage/d/DModule.java
index 7c9f4343e..b638c84b2 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/multipackage/d/DModule.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/multipackage/d/DModule.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
diff --git a/compiler/src/it/functional-tests/src/main/java/test/multipackage/foo/Foo.java b/compiler/src/it/functional-tests/src/main/java/test/multipackage/foo/Foo.java
index 35f5862ad..f028f39b3 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/multipackage/foo/Foo.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/multipackage/foo/Foo.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
diff --git a/compiler/src/it/functional-tests/src/main/java/test/multipackage/grandsub/FooGrandchildComponent.java b/compiler/src/it/functional-tests/src/main/java/test/multipackage/grandsub/FooGrandchildComponent.java
index 16a61dd54..36c9b180f 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/multipackage/grandsub/FooGrandchildComponent.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/multipackage/grandsub/FooGrandchildComponent.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
diff --git a/compiler/src/it/functional-tests/src/main/java/test/multipackage/sub/FooChildComponent.java b/compiler/src/it/functional-tests/src/main/java/test/multipackage/sub/FooChildComponent.java
index 9050fcd72..56cf422bc 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/multipackage/sub/FooChildComponent.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/multipackage/sub/FooChildComponent.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
diff --git a/compiler/src/it/functional-tests/src/main/java/test/nullables/NullComponent.java b/compiler/src/it/functional-tests/src/main/java/test/nullables/NullComponent.java
index a8a572473..464b5a2a0 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/nullables/NullComponent.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/nullables/NullComponent.java
@@ -1,5 +1,5 @@
 /*
-* Copyright (C) 2015 Google, Inc.
+* Copyright (C) 2015 The Dagger Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
@@ -13,11 +13,11 @@
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
-package test.nullables;
 
-import javax.inject.Provider;
+package test.nullables;
 
 import dagger.Component;
+import javax.inject.Provider;
 
 @Component(modules = NullModule.class)
 interface NullComponent {
diff --git a/compiler/src/it/functional-tests/src/main/java/test/nullables/NullComponentWithDependency.java b/compiler/src/it/functional-tests/src/main/java/test/nullables/NullComponentWithDependency.java
index 05093ed60..b250af6f9 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/nullables/NullComponentWithDependency.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/nullables/NullComponentWithDependency.java
@@ -1,5 +1,5 @@
 /*
-* Copyright (C) 2015 Google, Inc.
+* Copyright (C) 2015 The Dagger Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
@@ -13,11 +13,11 @@
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
-package test.nullables;
 
-import javax.inject.Provider;
+package test.nullables;
 
 import dagger.Component;
+import javax.inject.Provider;
 
 @Component(dependencies = NullComponent.class)
 interface NullComponentWithDependency {
diff --git a/compiler/src/it/functional-tests/src/main/java/test/nullables/NullFoo.java b/compiler/src/it/functional-tests/src/main/java/test/nullables/NullFoo.java
index 9ed4b5dea..13f60fe78 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/nullables/NullFoo.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/nullables/NullFoo.java
@@ -1,5 +1,5 @@
 /*
-* Copyright (C) 2015 Google, Inc.
+* Copyright (C) 2015 The Dagger Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
+
 package test.nullables;
 
 import javax.inject.Inject;
diff --git a/compiler/src/it/functional-tests/src/main/java/test/nullables/NullModule.java b/compiler/src/it/functional-tests/src/main/java/test/nullables/NullModule.java
index 652d5ebbb..dc827adfe 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/nullables/NullModule.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/nullables/NullModule.java
@@ -1,5 +1,5 @@
 /*
-* Copyright (C) 2015 Google, Inc.
+* Copyright (C) 2015 The Dagger Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
+
 package test.nullables;
 
 import dagger.Module;
diff --git a/compiler/src/it/functional-tests/src/main/java/test/scope/BlueModule.java b/compiler/src/it/functional-tests/src/main/java/test/scope/BlueModule.java
index f80824118..ff4703152 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/scope/BlueModule.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/scope/BlueModule.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 Google, Inc.
+ * Copyright (C) 2016 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test.scope;
 
 import dagger.Module;
diff --git a/compiler/src/it/functional-tests/src/main/java/test/scope/BlueScope.java b/compiler/src/it/functional-tests/src/main/java/test/scope/BlueScope.java
index 1bf133794..969a51ebd 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/scope/BlueScope.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/scope/BlueScope.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 Google, Inc.
+ * Copyright (C) 2016 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,14 +13,15 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test.scope;
 
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import javax.inject.Scope;
 
-import static java.lang.annotation.RetentionPolicy.RUNTIME;
-
 @Documented
 @Retention(RUNTIME)
 @Scope
diff --git a/compiler/src/it/functional-tests/src/main/java/test/scope/GreenModule.java b/compiler/src/it/functional-tests/src/main/java/test/scope/GreenModule.java
index 919a9a178..a8d96057d 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/scope/GreenModule.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/scope/GreenModule.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 Google, Inc.
+ * Copyright (C) 2016 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test.scope;
 
 import dagger.Module;
diff --git a/compiler/src/it/functional-tests/src/main/java/test/scope/GreenScope.java b/compiler/src/it/functional-tests/src/main/java/test/scope/GreenScope.java
index 57bb5ae7c..485b06bc3 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/scope/GreenScope.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/scope/GreenScope.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 Google, Inc.
+ * Copyright (C) 2016 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,14 +13,15 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test.scope;
 
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import javax.inject.Scope;
 
-import static java.lang.annotation.RetentionPolicy.RUNTIME;
-
 @Documented
 @Retention(RUNTIME)
 @Scope
diff --git a/compiler/src/it/functional-tests/src/main/java/test/scope/ScopedComponent.java b/compiler/src/it/functional-tests/src/main/java/test/scope/ScopedComponent.java
index 8e5e03ee3..8ea281108 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/scope/ScopedComponent.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/scope/ScopedComponent.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 Google, Inc.
+ * Copyright (C) 2016 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test.scope;
 
 import dagger.Component;
diff --git a/compiler/src/it/functional-tests/src/main/java/test/scope/TurquoiseModule.java b/compiler/src/it/functional-tests/src/main/java/test/scope/TurquoiseModule.java
index 77af9e76a..ef6fb5455 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/scope/TurquoiseModule.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/scope/TurquoiseModule.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 Google, Inc.
+ * Copyright (C) 2016 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test.scope;
 
 import dagger.Module;
diff --git a/compiler/src/it/functional-tests/src/main/java/test/staticprovides/AllStaticModule.java b/compiler/src/it/functional-tests/src/main/java/test/staticprovides/AllStaticModule.java
index 4844e0563..89b3f0eb3 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/staticprovides/AllStaticModule.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/staticprovides/AllStaticModule.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test.staticprovides;
 
 import static java.util.Collections.emptySet;
@@ -21,7 +22,6 @@
 import dagger.Provides;
 import dagger.multibindings.ElementsIntoSet;
 import dagger.multibindings.IntoSet;
-
 import java.util.Set;
 
 @Module
diff --git a/compiler/src/it/functional-tests/src/main/java/test/staticprovides/SomeStaticModule.java b/compiler/src/it/functional-tests/src/main/java/test/staticprovides/SomeStaticModule.java
index 05219de36..56d10f9a6 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/staticprovides/SomeStaticModule.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/staticprovides/SomeStaticModule.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test.staticprovides;
 
 import dagger.Module;
diff --git a/compiler/src/it/functional-tests/src/main/java/test/staticprovides/StaticTestComponent.java b/compiler/src/it/functional-tests/src/main/java/test/staticprovides/StaticTestComponent.java
index 4be51ed7b..1a3e67799 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/staticprovides/StaticTestComponent.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/staticprovides/StaticTestComponent.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test.staticprovides;
 
 import dagger.Component;
diff --git a/compiler/src/it/functional-tests/src/main/java/test/staticprovides/StaticTestComponentWithBuilder.java b/compiler/src/it/functional-tests/src/main/java/test/staticprovides/StaticTestComponentWithBuilder.java
index d778fc5c5..8ae132d39 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/staticprovides/StaticTestComponentWithBuilder.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/staticprovides/StaticTestComponentWithBuilder.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test.staticprovides;
 
 import dagger.Component;
diff --git a/compiler/src/it/functional-tests/src/main/java/test/sub/ContributionsModule.java b/compiler/src/it/functional-tests/src/main/java/test/sub/ContributionsModule.java
index d0b7b64c0..a72ab14aa 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/sub/ContributionsModule.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/sub/ContributionsModule.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test.sub;
 
 import dagger.Module;
diff --git a/compiler/src/it/functional-tests/src/main/java/test/sub/OtherThing.java b/compiler/src/it/functional-tests/src/main/java/test/sub/OtherThing.java
index 1abea0f11..9597f570c 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/sub/OtherThing.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/sub/OtherThing.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test.sub;
 
 import javax.inject.Inject;
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/AnInterface.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/AnInterface.java
index 8aaa015d1..325bbb421 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/AnInterface.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/AnInterface.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test.subcomponent;
 
 interface AnInterface {
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/BoundAsSingleton.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/BoundAsSingleton.java
index 8ae147415..b11cadf7d 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/BoundAsSingleton.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/BoundAsSingleton.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,14 +13,15 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test.subcomponent;
 
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import javax.inject.Qualifier;
 
-import static java.lang.annotation.RetentionPolicy.RUNTIME;
-
 @Documented
 @Retention(RUNTIME)
 @Qualifier
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildAbstractClassComponent.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildAbstractClassComponent.java
index 2529433ae..b7abe9408 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildAbstractClassComponent.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildAbstractClassComponent.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test.subcomponent;
 
 import dagger.Subcomponent;
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildComponent.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildComponent.java
index d3c28f2b4..3353cf091 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildComponent.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildComponent.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test.subcomponent;
 
 import dagger.Subcomponent;
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildComponentRequiringModules.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildComponentRequiringModules.java
index 905c68990..78a5c4a73 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildComponentRequiringModules.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildComponentRequiringModules.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test.subcomponent;
 
 import dagger.Subcomponent;
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildModule.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildModule.java
index 9ad2b5439..a86093a36 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildModule.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildModule.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test.subcomponent;
 
 import dagger.Module;
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildModuleWithParameters.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildModuleWithParameters.java
index e18b4a6da..fd6b7fddd 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildModuleWithParameters.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildModuleWithParameters.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test.subcomponent;
 
 import dagger.Module;
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildModuleWithState.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildModuleWithState.java
index 5908a005b..1952a27a1 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildModuleWithState.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildModuleWithState.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test.subcomponent;
 
 import dagger.Module;
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/GenericParentComponent.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/GenericParentComponent.java
index 5580ab8d4..5b8414cea 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/GenericParentComponent.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/GenericParentComponent.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test.subcomponent;
 
 interface GenericParentComponent<B> {  
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/GrandchildComponent.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/GrandchildComponent.java
index 9f724edfc..0fc79f979 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/GrandchildComponent.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/GrandchildComponent.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test.subcomponent;
 
 import dagger.Subcomponent;
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/GrandchildModule.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/GrandchildModule.java
index b74ad8beb..a261117a5 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/GrandchildModule.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/GrandchildModule.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,14 +13,16 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test.subcomponent;
 
+import dagger.Binds;
 import dagger.Module;
 import dagger.Provides;
 import dagger.multibindings.IntoSet;
 
 @Module
-final class GrandchildModule {
+abstract class GrandchildModule {
   @Provides
   @IntoSet
   static Object provideUnscopedObject() {
@@ -31,10 +33,8 @@ static Object provideUnscopedObject() {
     };
   }
 
-  @Provides
-  static AnInterface provideAnInterface(ImplementsAnInterface implementsAnInterface) {
-    return implementsAnInterface;
-  }
+  @Binds
+  abstract AnInterface provideAnInterface(ImplementsAnInterface implementsAnInterface);
 
   @Provides
   static NeedsAnInterface provideNeedsAnInterface(AnInterface anInterface) {
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ImplementsAnInterface.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ImplementsAnInterface.java
index ff3170cba..8be798f42 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ImplementsAnInterface.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ImplementsAnInterface.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test.subcomponent;
 
 import javax.inject.Inject;
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/MultibindingSubcomponents.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/MultibindingSubcomponents.java
index 14abce625..fa53807cb 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/MultibindingSubcomponents.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/MultibindingSubcomponents.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,8 +13,10 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test.subcomponent;
 
+import dagger.Binds;
 import dagger.Component;
 import dagger.Module;
 import dagger.Provides;
@@ -83,7 +85,7 @@ public String toString() {
   }
 
   @Module
-  static final class ParentMultibindingModule {
+  abstract static class ParentMultibindingModule {
 
     @Provides
     @IntoSet
@@ -113,13 +115,11 @@ static BoundInParentAndChild inParentAndChildEntry() {
 
     /* This is not static because otherwise we have no tests that cover the case where a
      * subcomponent uses a module instance installed onto a parent component. */
-    @Provides
+    @Binds
     @IntoSet
-    static RequiresMultibindings<BoundInParentAndChild>
+    abstract RequiresMultibindings<BoundInParentAndChild>
         requiresMultibindingsInParentAndChildElement(
-            RequiresMultibindings<BoundInParentAndChild> requiresMultibindingsInParentAndChild) {
-      return requiresMultibindingsInParentAndChild;
-    }
+            RequiresMultibindings<BoundInParentAndChild> requiresMultibindingsInParentAndChild);
   }
 
   @Module
@@ -152,6 +152,37 @@ static BoundInChild onlyInChildEntry() {
     }
   }
 
+  @Module
+  abstract static class ChildMultibindingModuleWithOnlyBindsMultibindings {
+    @Provides
+    static BoundInParentAndChild provideBoundInParentAndChildForBinds() {
+      return BoundInParentAndChild.IN_CHILD;
+    }
+
+    @Binds
+    @IntoSet
+    abstract BoundInParentAndChild bindsLocalContribution(BoundInParentAndChild instance);
+
+    @Binds
+    @IntoMap
+    @StringKey("child key")
+    abstract BoundInParentAndChild inParentAndChildEntry(BoundInParentAndChild instance);
+
+    @Provides
+    static BoundInChild provideBoundInChildForBinds() {
+      return BoundInChild.INSTANCE;
+    }
+
+    @Binds
+    @IntoSet
+    abstract BoundInChild inChild(BoundInChild instance);
+
+    @Binds
+    @IntoMap
+    @StringKey("child key")
+    abstract BoundInChild inChildEntry(BoundInChild instance);
+  }
+
   interface ProvidesBoundInParent {
     RequiresMultibindings<BoundInParent> requiresMultibindingsBoundInParent();
   }
@@ -211,4 +242,13 @@ static BoundInChild onlyInChildEntry() {
   interface Grandchild
       extends ProvidesBoundInParent, ProvidesBoundInParentAndChild, ProvidesBoundInChild,
           ProvidesSetOfRequiresMultibindings {}
+
+  @Component(modules = ParentMultibindingModule.class)
+  interface ParentWithProvisionHasChildWithBinds extends ParentWithProvision {
+    ChildWithBinds childWithBinds();
+  }
+
+  @Subcomponent(modules = ChildMultibindingModuleWithOnlyBindsMultibindings.class)
+  interface ChildWithBinds extends ChildWithProvision {}
+
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/NeedsAnInterface.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/NeedsAnInterface.java
index 7a5acb048..e1d983180 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/NeedsAnInterface.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/NeedsAnInterface.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test.subcomponent;
 
 class NeedsAnInterface {
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentComponent.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentComponent.java
index 2e5316e43..38f298adf 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentComponent.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentComponent.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test.subcomponent;
 
 import dagger.Component;
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentGetters.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentGetters.java
index 3ff855a9d..6614ddfe5 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentGetters.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentGetters.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test.subcomponent;
 
 import java.util.Set;
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentModule.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentModule.java
index 748db15b0..dce3eadfa 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentModule.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentModule.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,15 +13,17 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test.subcomponent;
 
+import dagger.Binds;
 import dagger.Module;
 import dagger.Provides;
 import dagger.multibindings.IntoSet;
 import javax.inject.Singleton;
 
 @Module
-final class ParentModule {
+abstract class ParentModule {
   @Provides
   @IntoSet
   static Object provideUnscopedObject() {
@@ -43,10 +45,8 @@ static Object provideSingletonObject() {
     };
   }
 
-  @Provides
+  @Binds
   @Singleton
   @BoundAsSingleton
-  static UnscopedType provideUnscopedTypeBoundAsSingleton(UnscopedType unscopedType) {
-    return unscopedType;
-  }
+  abstract UnscopedType provideUnscopedTypeBoundAsSingleton(UnscopedType unscopedType);
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentOfGenericComponent.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentOfGenericComponent.java
index bf8553772..edd3095cb 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentOfGenericComponent.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentOfGenericComponent.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test.subcomponent;
 
 import dagger.Component;
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/RequiresSingletons.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/RequiresSingletons.java
index 2d4053824..2e9cadb57 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/RequiresSingletons.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/RequiresSingletons.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test.subcomponent;
 
 import javax.inject.Inject;
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/SingletonType.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/SingletonType.java
index 663e858a9..68a063600 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/SingletonType.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/SingletonType.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test.subcomponent;
 
 import javax.inject.Inject;
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/StaticChildModule.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/StaticChildModule.java
index f7fd49058..4896dd67a 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/StaticChildModule.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/StaticChildModule.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test.subcomponent;
 
 import dagger.Module;
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/SubcomponentFromModuleAndFactoryMethod.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/SubcomponentFromModuleAndFactoryMethod.java
new file mode 100644
index 000000000..8a04944ab
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/SubcomponentFromModuleAndFactoryMethod.java
@@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package test.subcomponent;
+
+import dagger.Component;
+import dagger.Module;
+import dagger.Subcomponent;
+
+/**
+ * Tests for {@link Subcomponent}s which are defined with {@link Module#subcomponents()} and are
+ * also requested as component factory methods.
+ */
+public class SubcomponentFromModuleAndFactoryMethod {
+  @Subcomponent
+  interface Sub {
+    @Subcomponent.Builder
+    interface Builder {
+      Sub sub();
+    }
+  }
+
+  @Module(subcomponents = Sub.class)
+  class ModuleWithSubcomponent {}
+
+  @Component(modules = ModuleWithSubcomponent.class)
+  interface ExposesBuilder {
+    Sub.Builder subcomponentBuilder();
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/Unbound.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/Unbound.java
index c4cb79a5f..e4c2338d5 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/Unbound.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/Unbound.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 Google, Inc.
+ * Copyright (C) 2016 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,14 +13,15 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test.subcomponent;
 
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import javax.inject.Qualifier;
 
-import static java.lang.annotation.RetentionPolicy.RUNTIME;
-
 /**
  * A qualifier representing an unbound type, to verify that the compiler does not attempt to
  * generate code depending on it.
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/UnresolvableChildComponent.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/UnresolvableChildComponent.java
index 8e19b5e86..a7d470212 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/UnresolvableChildComponent.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/UnresolvableChildComponent.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 Google, Inc.
+ * Copyright (C) 2016 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test.subcomponent;
 
 import dagger.Subcomponent;
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/UnresolvableChildComponentModule.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/UnresolvableChildComponentModule.java
index c36fe316a..34aa73e95 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/UnresolvableChildComponentModule.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/UnresolvableChildComponentModule.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 Google, Inc.
+ * Copyright (C) 2016 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test.subcomponent;
 
 import dagger.Module;
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/UnscopedType.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/UnscopedType.java
index 89c00855f..620df47b5 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/UnscopedType.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/UnscopedType.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test.subcomponent;
 
 import javax.inject.Inject;
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/UsesModuleSubcomponents.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/UsesModuleSubcomponents.java
new file mode 100644
index 000000000..9c7ba3111
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/UsesModuleSubcomponents.java
@@ -0,0 +1,80 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package test.subcomponent;
+
+import dagger.Component;
+import dagger.Module;
+import dagger.Provides;
+import dagger.Subcomponent;
+import dagger.multibindings.IntoSet;
+import java.util.Set;
+import javax.inject.Inject;
+
+/** Supporting types for {@link ModuleWithSubcomponentsTest}. */
+@Component(modules = UsesModuleSubcomponents.ModuleWithSubcomponents.class)
+public interface UsesModuleSubcomponents {
+  UsesChild usesChild();
+
+  Set<String> strings();
+
+  @Module(subcomponents = Child.class, includes = AlsoIncludesSubcomponents.class)
+  class ModuleWithSubcomponents {
+    @Provides
+    @IntoSet
+    static String provideStringInParent() {
+      return "from parent";
+    }
+  }
+
+  @Module(subcomponents = Child.class)
+  class AlsoIncludesSubcomponents {}
+
+  @Subcomponent(modules = ChildModule.class)
+  interface Child {
+    Set<String> strings();
+
+    @Subcomponent.Builder
+    interface Builder {
+      Child build();
+    }
+  }
+
+  @Module
+  class ChildModule {
+    @Provides
+    @IntoSet
+    static String provideStringInChild() {
+      return "from child";
+    }
+  }
+
+  class UsesChild {
+    Set<String> strings;
+
+    @Inject
+    UsesChild(Child.Builder childBuilder) {
+      this.strings = childBuilder.build().strings();
+    }
+  }
+
+  @Module(includes = ModuleWithSubcomponents.class)
+  class OnlyIncludesModuleWithSubcomponents {}
+
+  @Component(modules = OnlyIncludesModuleWithSubcomponents.class)
+  interface ParentIncludesSubcomponentTransitively extends UsesModuleSubcomponents {}
+
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/hiding/ChildComponent.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/hiding/ChildComponent.java
index b95502cf8..5f7c0258a 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/hiding/ChildComponent.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/hiding/ChildComponent.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test.subcomponent.hiding;
 
 import dagger.Subcomponent;
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/hiding/ParentComponent.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/hiding/ParentComponent.java
index d7c66a679..ffbea8fe4 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/hiding/ParentComponent.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/hiding/ParentComponent.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test.subcomponent.hiding;
 
 import dagger.Component;
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/hiding/a/CommonModuleName.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/hiding/a/CommonModuleName.java
index ad692896f..8fbbd6f15 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/hiding/a/CommonModuleName.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/hiding/a/CommonModuleName.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test.subcomponent.hiding.a;
 
 import dagger.Module;
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/hiding/a/CommonName.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/hiding/a/CommonName.java
index b2aefda06..864799f30 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/hiding/a/CommonName.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/hiding/a/CommonName.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test.subcomponent.hiding.a;
 
 import javax.inject.Inject;
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/hiding/b/CommonModuleName.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/hiding/b/CommonModuleName.java
index 66deab5aa..10f5a1f32 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/hiding/b/CommonModuleName.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/hiding/b/CommonModuleName.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test.subcomponent.hiding.b;
 
 import dagger.Module;
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/hiding/b/CommonName.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/hiding/b/CommonName.java
index 023cbdbf2..21c1a115c 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/hiding/b/CommonName.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/hiding/b/CommonName.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test.subcomponent.hiding.b;
 
 import javax.inject.Inject;
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/pruning/ParentDoesntUseSubcomponent.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/pruning/ParentDoesntUseSubcomponent.java
new file mode 100644
index 000000000..3126f13f3
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/pruning/ParentDoesntUseSubcomponent.java
@@ -0,0 +1,95 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package test.subcomponent.pruning;
+
+import dagger.Component;
+import dagger.Module;
+import dagger.Provides;
+import dagger.Subcomponent;
+import dagger.multibindings.IntoSet;
+import java.util.Set;
+import javax.inject.Qualifier;
+
+/**
+ * Supporting types for {@link SubcomponentOnlyRequestedBySiblingTest}. {@link ChildA} is a direct
+ * child of the top level component, but is only requested within its sibling, not directly from its
+ * parent.
+ */
+@Component(modules = ParentDoesntUseSubcomponent.ParentModule.class)
+interface ParentDoesntUseSubcomponent {
+
+  ChildB.Builder childBBuilder();
+
+  @Subcomponent(modules = ChildAModule.class)
+  interface ChildA {
+    @Subcomponent.Builder
+    interface Builder {
+      ChildA build();
+    }
+
+    Set<Class<?>> componentHierarchy();
+  }
+
+  @Subcomponent(modules = ChildBModule.class)
+  interface ChildB {
+    @Subcomponent.Builder
+    interface Builder {
+      ChildB build();
+    }
+
+    Set<Class<?>> componentHierarchy();
+
+    @FromChildA
+    Set<Class<?>> componentHierarchyFromChildA();
+  }
+
+  @Module(subcomponents = {ChildA.class, ChildB.class})
+  class ParentModule {
+    @Provides
+    @IntoSet
+    static Class<?> provideComponentType() {
+      return ParentDoesntUseSubcomponent.class;
+    }
+  }
+
+  @Module
+  class ChildAModule {
+    @Provides
+    @IntoSet
+    static Class<?> provideComponentType() {
+      return ChildA.class;
+    }
+  }
+
+  @Module
+  class ChildBModule {
+    @Provides
+    @IntoSet
+    static Class<?> provideComponentType() {
+      return ChildB.class;
+    }
+
+    @Provides
+    @FromChildA
+    Set<Class<?>> fromChildA(ChildA.Builder childABuilder) {
+      return childABuilder.build().componentHierarchy();
+    }
+  }
+
+  @Qualifier
+  @interface FromChildA {}
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/OtherSubcomponentWithRepeatedModule.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/OtherSubcomponentWithRepeatedModule.java
new file mode 100644
index 000000000..31844a5ed
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/OtherSubcomponentWithRepeatedModule.java
@@ -0,0 +1,30 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package test.subcomponent.repeat;
+
+import dagger.Subcomponent;
+
+@Subcomponent(modules = RepeatedModule.class)
+interface OtherSubcomponentWithRepeatedModule extends SubcomponentWithRepeatedModule {
+
+  @Subcomponent.Builder
+  interface Builder {
+    Builder repeatedModule(RepeatedModule repeatedModule);
+
+    OtherSubcomponentWithRepeatedModule build();
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/ParentComponent.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/ParentComponent.java
index f0af00237..6ecfd17cc 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/ParentComponent.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/ParentComponent.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test.subcomponent.repeat;
 
 import dagger.Component;
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/RepeatedModule.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/RepeatedModule.java
index e3da28032..f4635e55e 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/RepeatedModule.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/RepeatedModule.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test.subcomponent.repeat;
 
 import dagger.Module;
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/SubcomponentWithRepeatedModule.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/SubcomponentWithRepeatedModule.java
index 279bc954c..4a3dd061e 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/SubcomponentWithRepeatedModule.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/SubcomponentWithRepeatedModule.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test.subcomponent.repeat;
 
 import dagger.Subcomponent;
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/SubcomponentWithoutRepeatedModule.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/SubcomponentWithoutRepeatedModule.java
index e63c9a0ae..e7829a025 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/SubcomponentWithoutRepeatedModule.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/SubcomponentWithoutRepeatedModule.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,11 +13,12 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test.subcomponent.repeat;
 
 import dagger.Subcomponent;
 
 @Subcomponent
 interface SubcomponentWithoutRepeatedModule {
-  SubcomponentWithRepeatedModule.Builder newGrandchildBuilder();
+  OtherSubcomponentWithRepeatedModule.Builder newGrandchildBuilder();
 }
diff --git a/compiler/src/it/functional-tests/src/test/java/test/BasicTest.java b/compiler/src/it/functional-tests/src/test/java/test/BasicTest.java
index ba2f38391..5b298e620 100644
--- a/compiler/src/it/functional-tests/src/test/java/test/BasicTest.java
+++ b/compiler/src/it/functional-tests/src/test/java/test/BasicTest.java
@@ -1,5 +1,5 @@
 /*
-* Copyright (C) 2014 Google, Inc.
+* Copyright (C) 2014 The Dagger Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
@@ -13,14 +13,8 @@
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
-package test;
 
-import dagger.Lazy;
-import javax.inject.Provider;
-import org.junit.experimental.theories.DataPoint;
-import org.junit.experimental.theories.Theories;
-import org.junit.experimental.theories.Theory;
-import org.junit.runner.RunWith;
+package test;
 
 import static com.google.common.truth.Truth.assertThat;
 import static test.PrimitivesModule.BOUND_BOOLEAN;
@@ -40,6 +34,13 @@
 import static test.PrimitivesModule.BOUND_SHORT;
 import static test.PrimitivesModule.BOUND_SHORT_ARRAY;
 
+import dagger.Lazy;
+import javax.inject.Provider;
+import org.junit.experimental.theories.DataPoint;
+import org.junit.experimental.theories.Theories;
+import org.junit.experimental.theories.Theory;
+import org.junit.runner.RunWith;
+
 @RunWith(Theories.class)
 public class BasicTest {
   @DataPoint
diff --git a/compiler/src/it/functional-tests/src/test/java/test/DependsOnGeneratedCodeTest.java b/compiler/src/it/functional-tests/src/test/java/test/DependsOnGeneratedCodeTest.java
index 0310df6ef..418f9f9fb 100644
--- a/compiler/src/it/functional-tests/src/test/java/test/DependsOnGeneratedCodeTest.java
+++ b/compiler/src/it/functional-tests/src/test/java/test/DependsOnGeneratedCodeTest.java
@@ -1,5 +1,5 @@
 /*
-* Copyright (C) 2015 Google, Inc.
+* Copyright (C) 2015 The Dagger Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
@@ -13,14 +13,18 @@
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
+
 package test;
 
+import static com.google.common.truth.Truth.assertThat;
+
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import static com.google.common.truth.Truth.assertThat;
-
+/**
+ * @see <a href="http://b/19435358">Bug 19435358</a>
+ */
 @RunWith(JUnit4.class)
 public class DependsOnGeneratedCodeTest {
   @Test public void testComponentDependsOnGeneratedCode() {
diff --git a/compiler/src/it/functional-tests/src/test/java/test/GenericTest.java b/compiler/src/it/functional-tests/src/test/java/test/GenericTest.java
index f1c981f25..0bb10b20b 100644
--- a/compiler/src/it/functional-tests/src/test/java/test/GenericTest.java
+++ b/compiler/src/it/functional-tests/src/test/java/test/GenericTest.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,8 +13,12 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test;
 
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertEquals;
+
 import java.util.ArrayList;
 import java.util.LinkedList;
 import java.util.List;
@@ -25,9 +29,6 @@
 import test.sub.Exposed;
 import test.sub.PublicSubclass;
 
-import static com.google.common.truth.Truth.assertThat;
-import static org.junit.Assert.assertEquals;
-
 @RunWith(JUnit4.class)
 public class GenericTest {
 
@@ -143,6 +144,5 @@
     GenericComponent component = DaggerGenericComponent.create();
     assertThat(component.iterableInt()).containsExactly(1, 2).inOrder();
     assertThat(component.iterableDouble()).containsExactly(3d, 4d).inOrder();
-    
   }
 }
diff --git a/compiler/src/it/functional-tests/src/test/java/test/MultibindingTest.java b/compiler/src/it/functional-tests/src/test/java/test/MultibindingTest.java
index c17260ad9..89b75cb13 100644
--- a/compiler/src/it/functional-tests/src/test/java/test/MultibindingTest.java
+++ b/compiler/src/it/functional-tests/src/test/java/test/MultibindingTest.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
  * in compliance with the License. You may obtain a copy of the License at
@@ -11,11 +11,13 @@
  * or implied. See the License for the specific language governing permissions and limitations under
  * the License.
  */
+
 package test;
 
+import static com.google.common.truth.Truth.assertThat;
+
 import com.google.auto.value.AutoAnnotation;
 import com.google.common.collect.ImmutableList;
-import com.google.common.collect.ImmutableMap;
 import dagger.multibindings.ClassKey;
 import dagger.multibindings.StringKey;
 import java.math.BigDecimal;
@@ -27,8 +29,6 @@
 import org.junit.runners.Parameterized;
 import org.junit.runners.Parameterized.Parameters;
 
-import static com.google.common.truth.Truth.assertThat;
-
 @RunWith(Parameterized.class)
 public class MultibindingTest {
 
@@ -65,10 +65,9 @@ public MultibindingTest(MultibindingComponent multibindingComponent) {
 
   @Test public void map() {
     Map<String, String> map = multibindingComponent.map();
-    assertThat(map).hasSize(3);
+    assertThat(map).hasSize(2);
     assertThat(map).containsEntry("foo", "foo value");
     assertThat(map).containsEntry("bar", "bar value");
-    assertThat(map).containsEntry("foo @Provides(type)", "foo @Provides(type) value");
   }
 
   @Test public void mapOfArrays() {
@@ -82,31 +81,28 @@ public MultibindingTest(MultibindingComponent multibindingComponent) {
 
   @Test public void mapOfProviders() {
     Map<String, Provider<String>> mapOfProviders = multibindingComponent.mapOfProviders();
-    assertThat(mapOfProviders).hasSize(3);
+    assertThat(mapOfProviders).hasSize(2);
     assertThat(mapOfProviders.get("foo").get()).isEqualTo("foo value");
     assertThat(mapOfProviders.get("bar").get()).isEqualTo("bar value");
-    assertThat(mapOfProviders.get("foo @Provides(type)").get())
-        .isEqualTo("foo @Provides(type) value");
   }
 
   @Test public void mapKeysAndValues() {
     assertThat(multibindingComponent.mapKeys())
-        .containsExactly("foo", "bar", "foo @Provides(type)");
+        .containsExactly("foo", "bar");
     assertThat(multibindingComponent.mapValues())
-        .containsExactly("foo value", "bar value", "foo @Provides(type) value");
+        .containsExactly("foo value", "bar value");
   }
 
   @Test public void nestedKeyMap() {
-    assertThat(multibindingComponent.nestedKeyMap()).isEqualTo(
-        ImmutableMap.of(
-            nestedWrappedKey(Integer.class), "integer",
-            nestedWrappedKey(Long.class), "long"));
+    assertThat(multibindingComponent.nestedKeyMap())
+        .containsExactly(
+            nestedWrappedKey(Integer.class), "integer", nestedWrappedKey(Long.class), "long");
   }
 
   @Test
   public void unwrappedAnnotationKeyMap() {
     assertThat(multibindingComponent.unwrappedAnnotationKeyMap())
-        .isEqualTo(ImmutableMap.of(testStringKey("foo\n"), "foo annotation"));
+        .containsExactly(testStringKey("foo\n"), "foo annotation");
   }
 
   @Test
@@ -114,68 +110,58 @@ public void wrappedAnnotationKeyMap() {
     @SuppressWarnings("unchecked")
     Class<? extends Number>[] classes = new Class[] {Long.class, Integer.class};
     assertThat(multibindingComponent.wrappedAnnotationKeyMap())
-        .isEqualTo(
-            ImmutableMap.of(
-                testWrappedAnnotationKey(
-                    testStringKey("foo"), new int[] {1, 2, 3}, new ClassKey[] {}, classes),
-                "wrapped foo annotation"));
+        .containsExactly(
+            testWrappedAnnotationKey(
+                testStringKey("foo"), new int[] {1, 2, 3}, new ClassKey[] {}, classes),
+            "wrapped foo annotation");
   }
 
   @Test
   public void booleanKeyMap() {
-    assertThat(multibindingComponent.booleanKeyMap()).isEqualTo(ImmutableMap.of(true, "true"));
+    assertThat(multibindingComponent.booleanKeyMap()).containsExactly(true, "true");
   }
 
   @Test
   public void byteKeyMap() {
-    assertThat(multibindingComponent.byteKeyMap())
-        .isEqualTo(ImmutableMap.of((byte) 100, "100 byte"));
+    assertThat(multibindingComponent.byteKeyMap()).containsExactly((byte) 100, "100 byte");
   }
 
   @Test
   public void charKeyMap() {
     assertThat(multibindingComponent.characterKeyMap())
-        .isEqualTo(ImmutableMap.of('a', "a char", '\n', "newline char"));
+        .containsExactly('a', "a char", '\n', "newline char");
   }
 
   @Test
   public void classKeyMap() {
     assertThat(multibindingComponent.classKeyMap())
-        .isEqualTo(
-            ImmutableMap.of(
-                Integer.class, "integer",
-                Long.class, "long"));
+        .containsExactly(Integer.class, "integer", Long.class, "long");
   }
 
   @Test
   public void numberClassKeyMap() {
     assertThat(multibindingComponent.numberClassKeyMap())
-        .isEqualTo(
-            ImmutableMap.of(
-                BigDecimal.class, "bigdecimal",
-                BigInteger.class, "biginteger"));
+        .containsExactly(BigDecimal.class, "bigdecimal", BigInteger.class, "biginteger");
   }
 
   @Test
   public void intKeyMap() {
-    assertThat(multibindingComponent.integerKeyMap()).isEqualTo(ImmutableMap.of(100, "100 int"));
+    assertThat(multibindingComponent.integerKeyMap()).containsExactly(100, "100 int");
   }
 
   @Test
   public void longKeyMap() {
-    assertThat(multibindingComponent.longKeyMap())
-        .isEqualTo(ImmutableMap.of((long) 100, "100 long"));
+    assertThat(multibindingComponent.longKeyMap()).containsExactly((long) 100, "100 long");
   }
 
   @Test
   public void shortKeyMap() {
-    assertThat(multibindingComponent.shortKeyMap())
-        .isEqualTo(ImmutableMap.of((short) 100, "100 short"));
+    assertThat(multibindingComponent.shortKeyMap()).containsExactly((short) 100, "100 short");
   }
 
   @Test public void setBindings() {
     assertThat(multibindingComponent.set())
-        .containsExactly(-90, -17, -1, 5, 6, 832, 1742, -100, -101, -102);
+        .containsExactly(-90, -17, -1, 5, 6, 832, 1742, -101, -102);
   }
 
   @Test
diff --git a/compiler/src/it/functional-tests/src/test/java/test/NestedTest.java b/compiler/src/it/functional-tests/src/test/java/test/NestedTest.java
index 14c3e5385..09d2cbedf 100644
--- a/compiler/src/it/functional-tests/src/test/java/test/NestedTest.java
+++ b/compiler/src/it/functional-tests/src/test/java/test/NestedTest.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,14 +13,15 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test;
 
+import static com.google.common.truth.Truth.assertThat;
+
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import static com.google.common.truth.Truth.assertThat;
-
 @RunWith(JUnit4.class)
 public class NestedTest {
   @Test public void nestedFoo() {
diff --git a/compiler/src/it/functional-tests/src/test/java/test/NonComponentDependencyTest.java b/compiler/src/it/functional-tests/src/test/java/test/NonComponentDependencyTest.java
index 37d3f7aec..6ed6691a2 100644
--- a/compiler/src/it/functional-tests/src/test/java/test/NonComponentDependencyTest.java
+++ b/compiler/src/it/functional-tests/src/test/java/test/NonComponentDependencyTest.java
@@ -1,5 +1,5 @@
 /*
-* Copyright (C) 2015 Google, Inc.
+* Copyright (C) 2015 The Dagger Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
@@ -13,14 +13,15 @@
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
+
 package test;
 
+import static com.google.common.truth.Truth.assertThat;
+
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import static com.google.common.truth.Truth.assertThat;
-
 @RunWith(JUnit4.class)
 public class NonComponentDependencyTest {
   @Test public void testThing() {
diff --git a/compiler/src/it/functional-tests/src/test/java/test/ReleasableReferencesComponentsTest.java b/compiler/src/it/functional-tests/src/test/java/test/ReleasableReferencesComponentsTest.java
new file mode 100644
index 000000000..5d46da763
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/test/java/test/ReleasableReferencesComponentsTest.java
@@ -0,0 +1,381 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package test;
+
+import static com.google.common.truth.Truth.assertThat;
+import static test.ReleasableReferencesComponents.Thing.thing;
+
+import com.google.auto.value.AutoAnnotation;
+import com.google.common.base.Function;
+import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.ListMultimap;
+import com.google.common.collect.Maps;
+import com.google.common.collect.Multimaps;
+import com.google.common.testing.GcFinalization;
+import com.google.common.testing.GcFinalization.FinalizationPredicate;
+import dagger.releasablereferences.ReleasableReferenceManager;
+import dagger.releasablereferences.TypedReleasableReferenceManager;
+import java.lang.annotation.Annotation;
+import java.lang.ref.WeakReference;
+import java.util.Map;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import test.ReleasableReferencesComponents.Child;
+import test.ReleasableReferencesComponents.ChildModule;
+import test.ReleasableReferencesComponents.ChildRegularScope;
+import test.ReleasableReferencesComponents.ChildReleasableScope1;
+import test.ReleasableReferencesComponents.ChildReleasableScope2;
+import test.ReleasableReferencesComponents.ChildReleasableScope3;
+import test.ReleasableReferencesComponents.Metadata1;
+import test.ReleasableReferencesComponents.Parent;
+import test.ReleasableReferencesComponents.ParentModule;
+import test.ReleasableReferencesComponents.ParentRegularScope;
+import test.ReleasableReferencesComponents.ParentReleasableScope1;
+import test.ReleasableReferencesComponents.ParentReleasableScope2;
+import test.ReleasableReferencesComponents.Thing;
+import test.ReleasableReferencesComponents.ThingComponent;
+
+@RunWith(JUnit4.class)
+public final class ReleasableReferencesComponentsTest {
+
+  private Parent component;
+  private ParentAsserts parentAsserts;
+  private ChildAsserts childAsserts;
+
+  @Before
+  public void setUp() {
+    component = DaggerReleasableReferencesComponents_Parent.create();
+    parentAsserts = new ParentAsserts(component);
+    childAsserts = parentAsserts.newChildAsserts();
+  }
+
+  @Test
+  public void releasableReferenceManagers() {
+    ImmutableMap<Class<? extends Annotation>, ReleasableReferenceManager> managers =
+        Maps.uniqueIndex(
+            component.managers(),
+            new Function<ReleasableReferenceManager, Class<? extends Annotation>>() {
+              @Override
+              public Class<? extends Annotation> apply(
+                  ReleasableReferenceManager releasableReferenceManager) {
+                return releasableReferenceManager.scope();
+              }
+            });
+    assertThat(managers)
+        .containsEntry(ParentReleasableScope1.class, component.parentReleasableScope1Manager());
+    assertThat(managers)
+        .containsEntry(ParentReleasableScope2.class, component.parentReleasableScope2Manager());
+    assertThat(managers)
+        .containsEntry(ChildReleasableScope1.class, component.childReleasableScope1Manager());
+    assertThat(managers)
+        .containsEntry(ChildReleasableScope2.class, component.childReleasableScope2Manager());
+    // Should contain a manager for ChildReleasableScope3 even though
+    // @ForReleasableReferences(Scope5.class) isn't needed.
+    assertThat(managers).containsKey(ChildReleasableScope3.class);
+  }
+
+  @Test
+  public void setOfTypedReleasableReferenceManagers() {
+    ListMultimap<Class<? extends Annotation>, Metadata1> managers =
+        Multimaps.transformValues(
+            Multimaps.index(
+                component.typedReleasableReferenceManagers1(),
+                new Function<TypedReleasableReferenceManager<?>, Class<? extends Annotation>>() {
+                  @Override
+                  public Class<? extends Annotation> apply(
+                      TypedReleasableReferenceManager<?> releasableReferenceManager) {
+                    return releasableReferenceManager.scope();
+                  }
+                }),
+            new Function<TypedReleasableReferenceManager<Metadata1>, Metadata1>() {
+              @Override
+              public Metadata1 apply(TypedReleasableReferenceManager<Metadata1> manager) {
+                return manager.metadata();
+              }
+            });
+    assertThat(managers)
+        .containsEntry(ParentReleasableScope2.class, metadata1("ParentReleasableScope2"));
+    assertThat(managers)
+        .containsEntry(ChildReleasableScope2.class, metadata1("ChildReleasableScope2.1"));
+    assertThat(managers)
+        .containsEntry(ChildReleasableScope3.class, metadata1("ChildReleasableScope3.1"));
+  }
+
+  @AutoAnnotation
+  static Metadata1 metadata1(String value) {
+    return new AutoAnnotation_ReleasableReferencesComponentsTest_metadata1(value);
+  }
+
+  @Test
+  public void basicScopingWorks() {
+    assertBindingCallCounts();
+    // assert again to make sure that the scoped bindings aren't called again
+    assertBindingCallCounts();
+  }
+
+  @Test
+  public void releaseThenGc() {
+    assertBindingCallCounts();
+    component.parentReleasableScope1Manager().releaseStrongReferences(); // release scope 1
+    assertBindingCallCounts(); // no change to scoped bindings
+    gcAndWaitUntilWeakReferencesCleared(
+        ParentModule.class, ChildModule.class, ParentReleasableScope1.class); // GC
+    parentAsserts.expectedCallsForParentReleasableScope1Thing++; // expect scope 1 bindings again
+    assertBindingCallCounts();
+  }
+
+  @Test
+  public void releaseThenRestoreThenGcThenRelease() {
+    assertBindingCallCounts();
+    component.parentReleasableScope2Manager().releaseStrongReferences(); // release scope 2
+    assertBindingCallCounts(); // no change to scoped bindings
+    component.parentReleasableScope2Manager().restoreStrongReferences(); // restore scope 2
+    assertBindingCallCounts(); // no change to scoped bindings
+    gcAndWaitUntilWeakReferencesCleared(ParentModule.class, ChildModule.class); // GC
+    assertBindingCallCounts(); // no change to scoped bindings
+
+    // Releasing again and GCing again means the binding is executed again.
+    component.parentReleasableScope2Manager().releaseStrongReferences(); // release scope 2
+    assertBindingCallCounts(); // no change to scoped bindings
+    gcAndWaitUntilWeakReferencesCleared(
+        ParentModule.class, ChildModule.class, ParentReleasableScope2.class); // GC
+    parentAsserts.expectedCallsForParentReleasableScope2Thing++; // expect scope 2 bindings again
+    assertBindingCallCounts();
+  }
+
+  @Test
+  public void subcomponentReleaseThenGc() {
+    assertBindingCallCounts();
+    component.childReleasableScope1Manager().releaseStrongReferences(); // release scope 3
+    assertBindingCallCounts(); // no change to scoped bindings
+    gcAndWaitUntilWeakReferencesCleared(
+        ParentModule.class, ChildModule.class, ChildReleasableScope1.class); // GC
+    childAsserts.expectedCallsForChildReleasableScope1Thing++; // expect scope 3 bindings again
+    assertBindingCallCounts();
+  }
+
+  @Test
+  public void subcomponentReleaseThenRestoreThenGcThenRelease() {
+    assertBindingCallCounts();
+    component.childReleasableScope2Manager().releaseStrongReferences(); // release scope 4
+    assertBindingCallCounts(); // no change to scoped bindings
+    component.childReleasableScope2Manager().restoreStrongReferences(); // restore scope 4
+    gcAndWaitUntilWeakReferencesCleared(ParentModule.class, ChildModule.class); // GC
+    assertBindingCallCounts(); // no change to scoped bindings
+    component.childReleasableScope2Manager().releaseStrongReferences(); // release scope 4
+    gcAndWaitUntilWeakReferencesCleared(
+        ParentModule.class, ChildModule.class, ChildReleasableScope2.class); // GC
+    childAsserts.expectedCallsForChildReleasableScope2Thing++; // expect scope 4 bindings again
+    assertBindingCallCounts();
+  }
+
+  @Test
+  public void twoInstancesOfSameSubcomponent() {
+    // Two instances of the same subcomponent.
+    ChildAsserts child2Asserts = parentAsserts.newChildAsserts();
+    childAsserts.assertBindingCallCounts();
+    child2Asserts.assertBindingCallCounts();
+
+    component.childReleasableScope1Manager().releaseStrongReferences(); // release scope 3
+    childAsserts.assertBindingCallCounts(); // no change to scoped bindings in child 1
+    child2Asserts.assertBindingCallCounts(); // no change to scoped bindings in child 2
+    gcAndWaitUntilWeakReferencesCleared(
+        ParentModule.class, ChildModule.class, ChildReleasableScope1.class); // GC
+    childAsserts.expectedCallsForChildReleasableScope1Thing++; // expect scope 3 bindings again
+    childAsserts.assertBindingCallCounts(); // when calling child.things()
+    child2Asserts.expectedCallsForChildReleasableScope1Thing++; // expect scope 3 bindings yet again
+    child2Asserts.assertBindingCallCounts(); // when calling child2.things()
+  }
+
+  private void assertBindingCallCounts() {
+    parentAsserts.assertBindingCallCounts();
+    childAsserts.assertBindingCallCounts();
+  }
+
+  /**
+   * Tries to run garbage collection, and waits for the {@link WeakReference}s to the {@link Thing}s
+   * in the maps last returned by {@link Parent#things()} and {@link Child#things()} for {@code
+   * keys} to be cleared.
+   */
+  void gcAndWaitUntilWeakReferencesCleared(final Class<?>... keys) {
+    GcFinalization.awaitDone(
+        new FinalizationPredicate() {
+          @Override
+          public boolean isDone() {
+            for (Class<?> key : keys) {
+              if (parentAsserts.weakThingReferenceUncollected(key)
+                  || childAsserts.weakThingReferenceUncollected(key)) {
+                return false;
+              }
+            }
+            return true;
+          }
+        });
+  }
+
+  /**
+   * Asserts that the map of {@link Thing}s in a {@link ThingComponent} matches expected values. Can
+   * also tell when certain values in the map have been finalized.
+   */
+  private abstract static class ThingAsserts {
+
+    private final ThingComponent component;
+    private ImmutableMap<Class<?>, WeakReference<Thing>> weakThings = ImmutableMap.of();
+
+    protected ThingAsserts(ThingComponent component) {
+      this.component = component;
+    }
+
+    /**
+     * Asserts that {@code component.things()} returns an expected map. Each time this is called,
+     * the current values in the map are wrapped in {@link WeakReference}s so we can {@linkplain
+     * #weakThingReferenceUncollected(Object) check whether they've been cleared} later.
+     */
+    final void assertBindingCallCounts() {
+      Map<Class<?>, Thing> things = component.things();
+      assertThat(things).containsExactlyEntriesIn(expectedThingMap());
+      weakThings =
+          ImmutableMap.copyOf(
+              Maps.transformValues(
+                  things,
+                  new Function<Thing, WeakReference<Thing>>() {
+                    @Override
+                    public WeakReference<Thing> apply(Thing thing) {
+                      return new WeakReference<>(thing);
+                    }
+                  }));
+    }
+
+    /** Returns the expected map. */
+    protected abstract ImmutableMap<Class<?>, Thing> expectedThingMap();
+
+    /**
+     * Returns {@code true} if the {@link WeakReference} to the {@link Thing} in the map returned by
+     * the last call to {@link #assertBindingCallCounts()} for the given key has not been cleared.
+     */
+    boolean weakThingReferenceUncollected(Object key) {
+      WeakReference<Thing> weakThing = weakThings.get(key);
+      return weakThing != null && weakThing.get() != null;
+    }
+  }
+
+  /** Asserts for the {@link Thing}s returned by {@link Parent#things()}. */
+  private static final class ParentAsserts extends ThingAsserts {
+    final Parent parent;
+
+    /**
+     * The number of times we expect the {@code @Provides @IntoMap @ClassKey(ParentModule.class)
+     * Thing} provider to have been called.
+     */
+    int expectedCallsForParentUnscopedThing;
+
+    /**
+     * The number of times we expect the
+     * {@code @Provides @IntoMap @ClassKey(ParentRegularScope.class) Thing} provider to have been
+     * called.
+     */
+    int expectedCallsForParentRegularScopeThing = 1;
+
+    /**
+     * The number of times we expect the
+     * {@code @Provides @IntoMap @ClassKey(ParentReleasableScope1.class) Thing} provider to have
+     * been called.
+     */
+    int expectedCallsForParentReleasableScope1Thing = 1;
+
+    /**
+     * The number of times we expect the
+     * {@code @Provides @IntoMap @ClassKey(ParentReleasableScope2.class) Thing} provider to have
+     * been called.
+     */
+    int expectedCallsForParentReleasableScope2Thing = 1;
+
+    ParentAsserts(Parent parent) {
+      super(parent);
+      this.parent = parent;
+    }
+
+    /**
+     * Returns an object that can make assertions for the {@link Thing}s returned by {@link
+     * Child#things()}.
+     */
+    ChildAsserts newChildAsserts() {
+      return new ChildAsserts(this, parent.child());
+    }
+
+    @Override
+    protected ImmutableMap<Class<?>, Thing> expectedThingMap() {
+      ++expectedCallsForParentUnscopedThing; // unscoped Thing @Provides method is always called
+      return ImmutableMap.of(
+          ParentModule.class, thing(expectedCallsForParentUnscopedThing),
+          ParentRegularScope.class, thing(expectedCallsForParentRegularScopeThing),
+          ParentReleasableScope1.class, thing(expectedCallsForParentReleasableScope1Thing),
+          ParentReleasableScope2.class, thing(expectedCallsForParentReleasableScope2Thing));
+    }
+  }
+
+  /** Asserts for the {@link Thing}s returned by {@link Child#things()}. */
+  private static final class ChildAsserts extends ThingAsserts {
+    final ParentAsserts parentAsserts;
+
+    /**
+     * The number of times we expect the {@code @Provides @IntoMap @ClassKey(ChildModule.class)
+     * Thing} provider to have been called.
+     */
+    int expectedCallsForChildUnscopedThing;
+
+    /**
+     * The number of times we expect the
+     * {@code @Provides @IntoMap @ClassKey(ChildRegularScope.class) Thing} provider to have been
+     * called.
+     */
+    int expectedCallsForChildRegularScopeThing = 1;
+
+    /**
+     * The number of times we expect the
+     * {@code @Provides @IntoMap @ClassKey(ChildReleasableScope1.class) Thing} provider to have been
+     * called.
+     */
+    int expectedCallsForChildReleasableScope1Thing = 1;
+
+    /**
+     * The number of times we expect the
+     * {@code @Provides @IntoMap @ClassKey(ChildReleasableScope2.class) Thing} provider to have been
+     * called.
+     */
+    int expectedCallsForChildReleasableScope2Thing = 1;
+
+    ChildAsserts(ParentAsserts parentAsserts, Child child) {
+      super(child);
+      this.parentAsserts = parentAsserts;
+    }
+
+    @Override
+    protected ImmutableMap<Class<?>, Thing> expectedThingMap() {
+      ++expectedCallsForChildUnscopedThing; // unscoped Thing @Provides method is always called
+      return new ImmutableMap.Builder<Class<?>, Thing>()
+          .putAll(parentAsserts.expectedThingMap())
+          .put(ChildModule.class, thing(expectedCallsForChildUnscopedThing))
+          .put(ChildRegularScope.class, thing(expectedCallsForChildRegularScopeThing))
+          .put(ChildReleasableScope1.class, thing(expectedCallsForChildReleasableScope1Thing))
+          .put(ChildReleasableScope2.class, thing(expectedCallsForChildReleasableScope2Thing))
+          .build();
+    }
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/test/java/test/ReusableTest.java b/compiler/src/it/functional-tests/src/test/java/test/ReusableTest.java
index acc212ddc..27aa425b6 100644
--- a/compiler/src/it/functional-tests/src/test/java/test/ReusableTest.java
+++ b/compiler/src/it/functional-tests/src/test/java/test/ReusableTest.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 Google, Inc.
+ * Copyright (C) 2016 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,16 +13,17 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test;
 
+import static com.google.common.truth.Truth.assertThat;
+
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 import test.ComponentWithReusableBindings.ChildOne;
 import test.ComponentWithReusableBindings.ChildTwo;
 
-import static com.google.common.truth.Truth.assertThat;
-
 @RunWith(JUnit4.class)
 public class ReusableTest {
   @Test
diff --git a/compiler/src/it/functional-tests/src/test/java/test/binds/BindsCollectionsWithoutMultibindingsTest.java b/compiler/src/it/functional-tests/src/test/java/test/binds/BindsCollectionsWithoutMultibindingsTest.java
index 3e0c47fe7..c9f5e93f6 100644
--- a/compiler/src/it/functional-tests/src/test/java/test/binds/BindsCollectionsWithoutMultibindingsTest.java
+++ b/compiler/src/it/functional-tests/src/test/java/test/binds/BindsCollectionsWithoutMultibindingsTest.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 Google, Inc.
+ * Copyright (C) 2016 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,8 +13,11 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test.binds;
 
+import static com.google.common.truth.Truth.assertThat;
+
 import com.google.common.collect.ImmutableMap;
 import dagger.Binds;
 import dagger.Component;
@@ -28,8 +31,6 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import static com.google.common.truth.Truth.assertThat;
-
 @RunWith(JUnit4.class)
 public class BindsCollectionsWithoutMultibindingsTest {
   @Module
diff --git a/compiler/src/it/functional-tests/src/test/java/test/binds/BindsTest.java b/compiler/src/it/functional-tests/src/test/java/test/binds/BindsTest.java
index c06512124..5835b361e 100644
--- a/compiler/src/it/functional-tests/src/test/java/test/binds/BindsTest.java
+++ b/compiler/src/it/functional-tests/src/test/java/test/binds/BindsTest.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 Google, Inc.
+ * Copyright (C) 2016 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,16 +13,17 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test.binds;
 
+import static com.google.common.truth.Truth.assertThat;
+
 import com.google.common.collect.ImmutableMap;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import static com.google.common.truth.Truth.assertThat;
-
 @RunWith(JUnit4.class)
 public class BindsTest {
 
@@ -62,5 +63,8 @@ public void multibindings() {
     assertThat(component.integerProviderOfObjectMap().get(789).get()).isEqualTo("789-string");
 
     assertThat(component.qualifiedIntegerObjectMap()).hasSize(1);
+
+    assertThat(component.primitiveSet()).containsExactly(100);
+    assertThat(component.primitiveValueMap()).containsExactly(10, 100);
   }
 }
diff --git a/compiler/src/it/functional-tests/src/test/java/test/builder/BuilderTest.java b/compiler/src/it/functional-tests/src/test/java/test/builder/BuilderTest.java
index af7233a0e..02ce6e43f 100644
--- a/compiler/src/it/functional-tests/src/test/java/test/builder/BuilderTest.java
+++ b/compiler/src/it/functional-tests/src/test/java/test/builder/BuilderTest.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,15 +13,16 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test.builder;
 
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import static com.google.common.truth.Truth.assertThat;
-import static org.junit.Assert.fail;
-
 @RunWith(JUnit4.class)
 public class BuilderTest {
 
diff --git a/compiler/src/it/functional-tests/src/test/java/test/builderbinds/BuilderBindsTest.java b/compiler/src/it/functional-tests/src/test/java/test/builderbinds/BuilderBindsTest.java
new file mode 100644
index 000000000..01c73842e
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/test/java/test/builderbinds/BuilderBindsTest.java
@@ -0,0 +1,123 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package test.builderbinds;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+
+import java.util.Arrays;
+import java.util.Collections;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import test.builderbinds.TestComponent.Builder;
+
+@RunWith(JUnit4.class)
+public final class BuilderBindsTest {
+
+  @Test
+  public void builderBinds() {
+    TestComponent.Builder builder =
+        DaggerTestComponent.builder()
+            .count(5)
+            .l(10L)
+            .input("foo")
+            .nullableInput("bar")
+            .listOfString(Arrays.asList("x", "y", "z"));
+    builder.boundInSubtype(20);
+    TestComponent component = builder.build();
+    assertThat(component.count()).isEqualTo(5);
+    assertThat(component.input()).isEqualTo("foo");
+    assertThat(component.nullableInput()).isEqualTo("bar");
+    assertThat(component.listOfString()).containsExactly("x", "y", "z").inOrder();
+  }
+
+  @Test
+  public void builderBindsNullableWithNull() {
+    Builder builder =
+        DaggerTestComponent.builder()
+            .count(5)
+            .l(10L)
+            .input("foo")
+            .nullableInput(null)
+            .listOfString(Collections.<String>emptyList());
+    builder.boundInSubtype(20);
+    TestComponent component = builder.build();
+
+    assertThat(component.count()).isEqualTo(5);
+    assertThat(component.input()).isEqualTo("foo");
+    assertThat(component.nullableInput()).isNull();
+    assertThat(component.listOfString()).isEmpty();
+  }
+
+  @Test
+  public void builderBindsNonNullableWithNull() {
+    try {
+      DaggerTestComponent.builder().count(5).l(10L).input(null);
+      fail("expected NullPointerException");
+    } catch (NullPointerException expected) {
+    }
+  }
+
+  @Test
+  public void builderBindsPrimitiveNotSet() {
+    try {
+      TestComponent.Builder builder =
+          DaggerTestComponent.builder()
+              .l(10L)
+              .input("foo")
+              .nullableInput("bar")
+              .listOfString(Collections.<String>emptyList());
+      builder.boundInSubtype(20);
+      builder.build();
+      fail("expected IllegalStateException");
+    } catch (IllegalStateException expected) {
+    }
+  }
+
+  @Test
+  public void builderBindsNonNullableNotSet() {
+    try {
+      TestComponent.Builder builder =
+          DaggerTestComponent.builder()
+              .count(5)
+              .l(10L)
+              .nullableInput("foo")
+              .listOfString(Collections.<String>emptyList());
+      builder.boundInSubtype(20);
+      builder.build();
+      fail("expected IllegalStateException");
+    } catch (IllegalStateException expected) {
+    }
+  }
+
+  @Test
+  public void builderBindsNullableNotSet() {
+    Builder builder =
+        DaggerTestComponent.builder()
+            .count(5)
+            .l(10L)
+            .input("foo")
+            .listOfString(Collections.<String>emptyList());
+    builder.boundInSubtype(20);
+    TestComponent component = builder.build();
+    assertThat(component.count()).isEqualTo(5);
+    assertThat(component.input()).isEqualTo("foo");
+    assertThat(component.nullableInput()).isNull();
+    assertThat(component.listOfString()).isEmpty();
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/test/java/test/cycle/CycleTest.java b/compiler/src/it/functional-tests/src/test/java/test/cycle/CycleTest.java
index d3bc2cbad..1a62597dd 100644
--- a/compiler/src/it/functional-tests/src/test/java/test/cycle/CycleTest.java
+++ b/compiler/src/it/functional-tests/src/test/java/test/cycle/CycleTest.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,8 +13,11 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test.cycle;
 
+import static com.google.common.truth.Truth.assertThat;
+
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
@@ -26,8 +29,6 @@
 import test.cycle.Cycles.S;
 import test.cycle.Cycles.SelfCycleComponent;
 
-import static com.google.common.truth.Truth.assertThat;
-
 @RunWith(JUnit4.class)
 public class CycleTest {
   @Test
diff --git a/compiler/src/it/functional-tests/src/test/java/test/cycle/LongCycleTest.java b/compiler/src/it/functional-tests/src/test/java/test/cycle/LongCycleTest.java
index b205e9d43..ce6293f93 100644
--- a/compiler/src/it/functional-tests/src/test/java/test/cycle/LongCycleTest.java
+++ b/compiler/src/it/functional-tests/src/test/java/test/cycle/LongCycleTest.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,15 +13,16 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test.cycle;
 
+import static com.google.common.truth.Truth.assertThat;
+
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 import test.cycle.LongCycle.LongCycleComponent;
 
-import static com.google.common.truth.Truth.assertThat;
-
 @RunWith(JUnit4.class)
 public class LongCycleTest {
   
diff --git a/compiler/src/it/functional-tests/src/test/java/test/membersinject/MembersInjectTest.java b/compiler/src/it/functional-tests/src/test/java/test/membersinject/MembersInjectTest.java
index 411ecb177..e6e42c142 100644
--- a/compiler/src/it/functional-tests/src/test/java/test/membersinject/MembersInjectTest.java
+++ b/compiler/src/it/functional-tests/src/test/java/test/membersinject/MembersInjectTest.java
@@ -1,11 +1,11 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *  http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
@@ -13,8 +13,11 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test.membersinject;
 
+import static com.google.common.truth.Truth.assertThat;
+
 import dagger.MembersInjector;
 import javax.inject.Provider;
 import org.junit.Test;
@@ -26,8 +29,6 @@
 import test.multipackage.a.AParent;
 import test.multipackage.b.BChild;
 
-import static com.google.common.truth.Truth.assertThat;
-
 @RunWith(JUnit4.class)
 public class MembersInjectTest {
   @Test public void testMembersInject_arrays() {
diff --git a/compiler/src/it/functional-tests/src/test/java/test/nullables/NullabilityTest.java b/compiler/src/it/functional-tests/src/test/java/test/nullables/NullabilityTest.java
index a0e1e22f5..0bc859d09 100644
--- a/compiler/src/it/functional-tests/src/test/java/test/nullables/NullabilityTest.java
+++ b/compiler/src/it/functional-tests/src/test/java/test/nullables/NullabilityTest.java
@@ -1,5 +1,5 @@
 /*
-* Copyright (C) 2015 Google, Inc.
+* Copyright (C) 2015 The Dagger Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
@@ -13,14 +13,16 @@
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
+
 package test.nullables;
 
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+
 import javax.inject.Provider;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
-import static com.google.common.truth.Truth.assertThat;
-import static org.junit.Assert.fail;
 
 @RunWith(JUnit4.class)
 public class NullabilityTest {
diff --git a/compiler/src/it/functional-tests/src/test/java/test/scope/ScopeTest.java b/compiler/src/it/functional-tests/src/test/java/test/scope/ScopeTest.java
index aa289b12c..7a3b1d94c 100644
--- a/compiler/src/it/functional-tests/src/test/java/test/scope/ScopeTest.java
+++ b/compiler/src/it/functional-tests/src/test/java/test/scope/ScopeTest.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 Google, Inc.
+ * Copyright (C) 2016 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test.scope;
 
 import static com.google.common.truth.Truth.assertThat;
diff --git a/compiler/src/it/functional-tests/src/test/java/test/staticprovides/StaticProvidesTest.java b/compiler/src/it/functional-tests/src/test/java/test/staticprovides/StaticProvidesTest.java
index 397259403..76f3ba485 100644
--- a/compiler/src/it/functional-tests/src/test/java/test/staticprovides/StaticProvidesTest.java
+++ b/compiler/src/it/functional-tests/src/test/java/test/staticprovides/StaticProvidesTest.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,8 +13,12 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test.staticprovides;
 
+import static com.google.common.truth.Truth.assertThat;
+import static com.google.common.truth.Truth.assertWithMessage;
+
 import com.google.common.collect.ImmutableSet;
 import java.lang.reflect.Field;
 import java.lang.reflect.Method;
@@ -26,9 +30,6 @@
 import org.junit.runners.Parameterized.Parameter;
 import org.junit.runners.Parameterized.Parameters;
 
-import static com.google.common.truth.Truth.assertThat;
-import static com.google.common.truth.Truth.assertWithMessage;
-
 @RunWith(Parameterized.class)
 public class StaticProvidesTest {
   @Parameters
diff --git a/compiler/src/it/functional-tests/src/test/java/test/subcomponent/ModuleWithSubcomponentsTest.java b/compiler/src/it/functional-tests/src/test/java/test/subcomponent/ModuleWithSubcomponentsTest.java
new file mode 100644
index 000000000..34dbf8825
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/test/java/test/subcomponent/ModuleWithSubcomponentsTest.java
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package test.subcomponent;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import dagger.Module;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import test.subcomponent.UsesModuleSubcomponents.ParentIncludesSubcomponentTransitively;
+
+/** Tests for {@link Module#subcomponents()}. */
+@RunWith(JUnit4.class)
+public class ModuleWithSubcomponentsTest {
+
+  @Test
+  public void subcomponentFromModules() {
+    UsesModuleSubcomponents parent = DaggerUsesModuleSubcomponents.create();
+    assertThat(parent.strings()).containsExactly("from parent");
+    assertThat(parent.usesChild().strings).containsExactly("from parent", "from child");
+  }
+
+  @Test
+  public void subcomponentFromModules_transitively() {
+    ParentIncludesSubcomponentTransitively parent =
+        DaggerUsesModuleSubcomponents_ParentIncludesSubcomponentTransitively.create();
+    assertThat(parent.strings()).containsExactly("from parent");
+    assertThat(parent.usesChild().strings).containsExactly("from parent", "from child");
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/test/java/test/subcomponent/SubcomponentMultibindingsTest.java b/compiler/src/it/functional-tests/src/test/java/test/subcomponent/SubcomponentMultibindingsTest.java
index 99ca1cd44..3e0e52702 100644
--- a/compiler/src/it/functional-tests/src/test/java/test/subcomponent/SubcomponentMultibindingsTest.java
+++ b/compiler/src/it/functional-tests/src/test/java/test/subcomponent/SubcomponentMultibindingsTest.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,8 +13,11 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test.subcomponent;
 
+import static com.google.common.truth.Truth.assertThat;
+
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
 import org.junit.Before;
@@ -30,8 +33,6 @@
 import test.subcomponent.MultibindingSubcomponents.ParentWithoutProvisionHasChildWithoutProvision;
 import test.subcomponent.MultibindingSubcomponents.RequiresMultibindings;
 
-import static com.google.common.truth.Truth.assertThat;
-
 @RunWith(JUnit4.class)
 public class SubcomponentMultibindingsTest {
 
@@ -100,6 +101,13 @@ public void testParentWithoutProvisionHasChildWithoutProvision() {
                 .requiresMultibindingsBoundInChild())
         .isEqualTo(BOUND_IN_CHILD);
 
+    /*
+     * Even though the multibinding for Set<RequiresMultiboundObjects> does not itself have a
+     * contribution from the child, it must be pushed down to (not duplicated in) the child because
+     * its contribution depends on multibindings that have one contribution from the parent and one
+     * from the child.
+     *
+     */
     assertThat(
             parentWithoutProvisionHasChildWithoutProvision
                 .childWithoutProvision()
@@ -132,6 +140,13 @@ public void testParentWithoutProvisionHasChildWithProvision() {
                 .requiresMultibindingsBoundInChild())
         .isEqualTo(BOUND_IN_CHILD);
 
+    /*
+     * Even though the multibinding for Set<RequiresMultiboundObjects> does not itself have a
+     * contribution from the child, it must be pushed down to (not duplicated in) the child because
+     * its contribution depends on multibindings that have one contribution from the parent and one
+     * from the child.
+     *
+     */
     assertThat(
             parentWithoutProvisionHasChildWithProvision
                 .childWithProvision()
@@ -172,6 +187,13 @@ public void testParentWithProvisionHasChildWithoutProvision() {
                 .requiresMultibindingsBoundInParentAndChild())
         .isEqualTo(BOUND_IN_PARENT_AND_CHILD);
 
+    /*
+     * Even though the multibinding for Set<RequiresMultiboundObjects> does not itself have a
+     * contribution from the child, it must be pushed down to (not duplicated in) the child because
+     * its contribution depends on multibindings that have one contribution from the parent and one
+     * from the child.
+     *
+     */
     assertThat(
             parentWithProvisionHasChildWithoutProvision
                 .childWithoutProvision()
@@ -203,6 +225,20 @@ public void testParentWithProvisionHasChildWithProvision() {
                 .requiresMultibindingsBoundInParentAndChild())
         .isEqualTo(BOUND_IN_PARENT_AND_CHILD);
 
+    // https://github.com/google/dagger/issues/401
+    assertThat(
+        DaggerMultibindingSubcomponents_ParentWithProvisionHasChildWithBinds.create()
+            .childWithBinds()
+            .requiresMultibindingsBoundInParentAndChild())
+        .isEqualTo(BOUND_IN_PARENT_AND_CHILD);
+
+    /*
+     * Even though the multibinding for Set<RequiresMultiboundObjects> does not itself have a
+     * contribution from the child, it must be pushed down to (not duplicated in) the child because
+     * its contribution depends on multibindings that have one contribution from the parent and one
+     * from the child.
+     *
+     */
     assertThat(
             parentWithProvisionHasChildWithProvision
                 .childWithProvision()
@@ -229,6 +265,13 @@ public void testParentWithProvisionHasChildWithProvision() {
                 .requiresMultibindingsBoundInParentAndChild())
         .isEqualTo(BOUND_IN_PARENT_AND_CHILD);
 
+    /*
+     * Even though the multibinding for Set<RequiresMultiboundObjects> does not itself have a
+     * contribution from the child, it must be pushed down to (not duplicated in) the child because
+     * its contribution depends on multibindings that have one contribution from the parent and one
+     * from the child.
+     *
+     */
     assertThat(
             parentWithProvisionHasChildWithProvision
                 .childWithProvision()
diff --git a/compiler/src/it/functional-tests/src/test/java/test/subcomponent/SubcomponentTest.java b/compiler/src/it/functional-tests/src/test/java/test/subcomponent/SubcomponentTest.java
index ee89254b0..9c7b2118c 100644
--- a/compiler/src/it/functional-tests/src/test/java/test/subcomponent/SubcomponentTest.java
+++ b/compiler/src/it/functional-tests/src/test/java/test/subcomponent/SubcomponentTest.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,8 +13,12 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test.subcomponent;
 
+import static com.google.common.collect.Sets.intersection;
+import static com.google.common.truth.Truth.assertThat;
+
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.Set;
@@ -23,9 +27,6 @@
 import org.junit.runners.Parameterized;
 import org.junit.runners.Parameterized.Parameters;
 
-import static com.google.common.collect.Sets.intersection;
-import static com.google.common.truth.Truth.assertThat;
-
 @RunWith(Parameterized.class)
 public class SubcomponentTest {
   private static final ParentComponent parentComponent = DaggerParentComponent.create();
diff --git a/compiler/src/it/functional-tests/src/test/java/test/subcomponent/hiding/SubcomponentHidingTest.java b/compiler/src/it/functional-tests/src/test/java/test/subcomponent/hiding/SubcomponentHidingTest.java
index 27dcbb690..8b141fac0 100644
--- a/compiler/src/it/functional-tests/src/test/java/test/subcomponent/hiding/SubcomponentHidingTest.java
+++ b/compiler/src/it/functional-tests/src/test/java/test/subcomponent/hiding/SubcomponentHidingTest.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,14 +13,15 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test.subcomponent.hiding;
 
+import static com.google.common.truth.Truth.assertThat;
+
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import static com.google.common.truth.Truth.assertThat;
-
 @RunWith(JUnit4.class)
 public class SubcomponentHidingTest {
   @Test public void moduleNameHiding() {
diff --git a/compiler/src/it/functional-tests/src/test/java/test/subcomponent/pruning/SubcomponentOnlyRequestedBySiblingTest.java b/compiler/src/it/functional-tests/src/test/java/test/subcomponent/pruning/SubcomponentOnlyRequestedBySiblingTest.java
new file mode 100644
index 000000000..fb856a73d
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/test/java/test/subcomponent/pruning/SubcomponentOnlyRequestedBySiblingTest.java
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package test.subcomponent.pruning;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import dagger.Module;
+import dagger.Subcomponent;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import test.subcomponent.pruning.ParentDoesntUseSubcomponent.ChildA;
+import test.subcomponent.pruning.ParentDoesntUseSubcomponent.ChildB;
+
+/**
+ * Tests for {@link Subcomponent}s which are included with {@link Module#subcomponents()} but not
+ * used directly within the component which adds them.
+ *
+ * <p>This tests to make sure that while resolving one subcomponent (A), another subcomponent (B)
+ * can be requested if they have a shared ancestor component. If that shared ancestor did not
+ * resolve B directly via any of its entry points, B will still be generated since it is requested
+ * by a descendant.
+ */
+@RunWith(JUnit4.class)
+public class SubcomponentOnlyRequestedBySiblingTest {
+  @Test
+  public void subcomponentAddedInParent_onlyUsedInSibling() {
+    ParentDoesntUseSubcomponent parent = DaggerParentDoesntUseSubcomponent.create();
+    ChildB childB = parent.childBBuilder().build();
+    assertThat(childB.componentHierarchy())
+        .containsExactly(ParentDoesntUseSubcomponent.class, ChildB.class);
+    assertThat(childB.componentHierarchyFromChildA())
+        .containsExactly(ParentDoesntUseSubcomponent.class, ChildA.class);
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/test/java/test/subcomponent/repeat/RepeatedModuleTest.java b/compiler/src/it/functional-tests/src/test/java/test/subcomponent/repeat/RepeatedModuleTest.java
index 7e92371bf..e4b21c1ba 100644
--- a/compiler/src/it/functional-tests/src/test/java/test/subcomponent/repeat/RepeatedModuleTest.java
+++ b/compiler/src/it/functional-tests/src/test/java/test/subcomponent/repeat/RepeatedModuleTest.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,16 +13,17 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test.subcomponent.repeat;
 
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import static com.google.common.truth.Truth.assertThat;
-import static org.junit.Assert.fail;
-
 @RunWith(JUnit4.class)
 public final class RepeatedModuleTest {
   private ParentComponent parentComponent;
@@ -67,7 +68,7 @@ public void repeatedModuleBuilderThrowsInSubcomponent() {
   public void repeatedModuleBuilderThrowsInGrandchildSubcomponent() {
     SubcomponentWithoutRepeatedModule childComponent =
         parentComponent.newChildComponentWithoutRepeatedModule();
-    SubcomponentWithRepeatedModule.Builder grandchildComponentBuilder =
+    OtherSubcomponentWithRepeatedModule.Builder grandchildComponentBuilder =
         childComponent.newGrandchildBuilder();
     try {
       grandchildComponentBuilder.repeatedModule(new RepeatedModule());
diff --git a/compiler/src/it/guava-functional-tests/BUILD b/compiler/src/it/guava-functional-tests/BUILD
new file mode 100644
index 000000000..a94af72b1
--- /dev/null
+++ b/compiler/src/it/guava-functional-tests/BUILD
@@ -0,0 +1,53 @@
+# Copyright (C) 2017 The Dagger Authors.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+# Description:
+#   Functional tests for Dagger that depend on Guava
+
+package(default_visibility = ["//:src"])
+
+load("//:build_defs.bzl", "DOCLINT_HTML_AND_SYNTAX", "PRE_JAVA_8_INFERENCE_OPTS")
+
+java_library(
+    name = "code_under_test",
+    testonly = 1,
+    srcs = glob(["src/main/java/**/*.java"]),
+    javacopts = PRE_JAVA_8_INFERENCE_OPTS + DOCLINT_HTML_AND_SYNTAX,
+    deps = [
+        "//:dagger_with_compiler",
+        "//third_party:auto_value",
+        "//third_party:guava",
+        "//third_party:jsr330_inject",
+        "//third_party:junit",
+    ],
+)
+
+load("//:test_defs.bzl", "GenJavaTests")
+
+GenJavaTests(
+    name = "guava_functional_tests",
+    srcs = glob(["src/test/java/**/*.java"]),
+    javacopts = PRE_JAVA_8_INFERENCE_OPTS + DOCLINT_HTML_AND_SYNTAX,
+    deps = [
+        ":code_under_test",
+        "//:dagger_with_compiler",
+        "//third_party:auto_value",
+        "//third_party:guava",
+        "//third_party:jsr330_inject",
+        "//third_party:junit",
+        "//third_party:truth",
+    ],
+)
+
+test_suite(name = "AllTests")
diff --git a/compiler/src/it/guava-functional-tests/pom.xml b/compiler/src/it/guava-functional-tests/pom.xml
new file mode 100644
index 000000000..6bf0fc074
--- /dev/null
+++ b/compiler/src/it/guava-functional-tests/pom.xml
@@ -0,0 +1,76 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+Copyright (C) 2016 The Dagger Authors.
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+-->
+<project
+    xmlns="http://maven.apache.org/POM/4.0.0"
+    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+  <parent>
+    <groupId>com.google.dagger</groupId>
+    <artifactId>dagger-parent</artifactId>
+    <version>HEAD-SNAPSHOT</version>
+  </parent>
+  <groupId>dagger.tests</groupId>
+  <artifactId>guava-functional-tests</artifactId>
+  <name>Guava Functional Tests</name>
+  <dependencies>
+    <dependency>
+      <groupId>com.google.dagger</groupId>
+      <artifactId>dagger</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>com.google.dagger</groupId>
+      <artifactId>dagger-compiler</artifactId>
+      <version>${project.version}</version>
+      <optional>true</optional>
+    </dependency>
+    <dependency>
+      <groupId>com.google.auto.value</groupId>
+      <artifactId>auto-value</artifactId>
+      <scope>provided</scope>
+    </dependency>
+    <dependency>
+      <groupId>com.google.auto.factory</groupId>
+      <artifactId>auto-factory</artifactId>
+      <scope>provided</scope>
+    </dependency>
+
+    <dependency>
+      <groupId>junit</groupId>
+      <artifactId>junit</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>com.google.truth</groupId>
+      <artifactId>truth</artifactId>
+      <scope>test</scope>
+    </dependency>
+  </dependencies>
+  <build>
+    <plugins>
+      <plugin>
+        <artifactId>maven-compiler-plugin</artifactId>
+        <version>3.1</version>
+        <configuration>
+          <source>1.7</source>
+          <target>1.7</target>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
+</project>
diff --git a/compiler/src/it/guava-functional-tests/src/main/java/test/optional/OptionalBindingComponents.java b/compiler/src/it/guava-functional-tests/src/main/java/test/optional/OptionalBindingComponents.java
new file mode 100644
index 000000000..33d6918b9
--- /dev/null
+++ b/compiler/src/it/guava-functional-tests/src/main/java/test/optional/OptionalBindingComponents.java
@@ -0,0 +1,133 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package test.optional;
+
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+import com.google.auto.value.AutoValue;
+import com.google.common.base.Optional;
+import dagger.BindsOptionalOf;
+import dagger.Component;
+import dagger.Lazy;
+import dagger.Module;
+import dagger.Provides;
+import dagger.Subcomponent;
+import java.lang.annotation.Retention;
+import javax.inject.Inject;
+import javax.inject.Provider;
+import javax.inject.Qualifier;
+
+/** Classes to support testing {@code BindsOptionalOf} functionality. */
+public final class OptionalBindingComponents {
+
+  /** A qualifier. */
+  @Qualifier
+  @Retention(RUNTIME)
+  public @interface SomeQualifier {}
+
+  /** A value object that contains various optionally-bound objects. */
+  @AutoValue
+  public abstract static class Values {
+    abstract Optional<Value> optionalInstance();
+
+    abstract Optional<Provider<Value>> optionalProvider();
+
+    abstract Optional<Lazy<Value>> optionalLazy();
+
+    abstract Optional<Provider<Lazy<Value>>> optionalLazyProvider();
+  }
+
+  // Default access so that it's inaccessible to OptionalBindingComponentsWithInaccessibleTypes.
+  enum Value {
+    VALUE,
+    QUALIFIED_VALUE
+  }
+
+  static final class InjectedThing {
+    @Inject
+    InjectedThing() {}
+  }
+
+  /** Binds optionals and {@link Values}. */
+  @Module
+  public abstract static class OptionalBindingModule {
+    @BindsOptionalOf
+    abstract Value value();
+
+    @BindsOptionalOf
+    @SomeQualifier abstract Value qualifiedValue();
+
+    // Valid because it's qualified.
+    @BindsOptionalOf
+    @SomeQualifier abstract InjectedThing qualifiedInjectedThing();
+
+    @Provides
+    static Values values(
+        Optional<Value> optionalInstance,
+        Optional<Provider<Value>> optionalProvider,
+        Optional<Lazy<Value>> optionalLazy,
+        Optional<Provider<Lazy<Value>>> optionalLazyProvider) {
+      return new AutoValue_OptionalBindingComponents_Values(
+          optionalInstance, optionalProvider, optionalLazy, optionalLazyProvider);
+    }
+
+    @Provides
+    @SomeQualifier
+    static Values qualifiedValues(
+        @SomeQualifier Optional<Value> optionalInstance,
+        @SomeQualifier Optional<Provider<Value>> optionalProvider,
+        @SomeQualifier Optional<Lazy<Value>> optionalLazy,
+        @SomeQualifier Optional<Provider<Lazy<Value>>> optionalLazyProvider) {
+      return new AutoValue_OptionalBindingComponents_Values(
+          optionalInstance, optionalProvider, optionalLazy, optionalLazyProvider);
+    }
+  }
+
+  /** Binds {@link Value}. */
+  @Module
+  public abstract static class ConcreteBindingModule {
+    /** @param cycle to demonstrate that optional {@link Provider} injection can break cycles */
+    @Provides
+    static Value value(Optional<Provider<Value>> cycle) {
+      return Value.VALUE;
+    }
+
+    @Provides
+    @SomeQualifier static Value qualifiedValue() {
+      return Value.QUALIFIED_VALUE;
+    }
+  }
+
+  /** Interface for components used to test optional bindings. */
+  public interface OptionalBindingComponent {
+    Values values();
+
+    @SomeQualifier
+    Values qualifiedValues();
+  }
+
+  @Component(modules = OptionalBindingModule.class)
+  interface AbsentOptionalBindingComponent extends OptionalBindingComponent {
+    PresentOptionalBindingSubcomponent presentChild();
+  }
+
+  @Component(modules = {OptionalBindingModule.class, ConcreteBindingModule.class})
+  interface PresentOptionalBindingComponent extends OptionalBindingComponent {}
+
+  @Subcomponent(modules = ConcreteBindingModule.class)
+  interface PresentOptionalBindingSubcomponent extends OptionalBindingComponent {}
+}
diff --git a/compiler/src/it/guava-functional-tests/src/main/java/test/optional/a/OptionalBindingComponentsWithInaccessibleTypes.java b/compiler/src/it/guava-functional-tests/src/main/java/test/optional/a/OptionalBindingComponentsWithInaccessibleTypes.java
new file mode 100644
index 000000000..c3beaef79
--- /dev/null
+++ b/compiler/src/it/guava-functional-tests/src/main/java/test/optional/a/OptionalBindingComponentsWithInaccessibleTypes.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package test.optional.a;
+
+import dagger.Component;
+import test.optional.OptionalBindingComponents.ConcreteBindingModule;
+import test.optional.OptionalBindingComponents.OptionalBindingComponent;
+import test.optional.OptionalBindingComponents.OptionalBindingModule;
+
+final class OptionalBindingComponentsWithInaccessibleTypes {
+
+  @Component(modules = OptionalBindingModule.class)
+  interface AbsentOptionalBindingComponent extends OptionalBindingComponent {}
+
+  @Component(modules = {OptionalBindingModule.class, ConcreteBindingModule.class})
+  interface PresentOptionalBindingComponent extends OptionalBindingComponent {}
+}
diff --git a/compiler/src/it/guava-functional-tests/src/test/java/test/optional/OptionalBindingComponentsAbsentTest.java b/compiler/src/it/guava-functional-tests/src/test/java/test/optional/OptionalBindingComponentsAbsentTest.java
new file mode 100644
index 000000000..491cf85e7
--- /dev/null
+++ b/compiler/src/it/guava-functional-tests/src/test/java/test/optional/OptionalBindingComponentsAbsentTest.java
@@ -0,0 +1,76 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package test.optional;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import test.optional.OptionalBindingComponents.AbsentOptionalBindingComponent;
+
+/** Tests for absent optional bindings. */
+@RunWith(JUnit4.class)
+public final class OptionalBindingComponentsAbsentTest {
+  private AbsentOptionalBindingComponent absent;
+
+  @Before
+  public void setUp() {
+    absent = DaggerOptionalBindingComponents_AbsentOptionalBindingComponent.create();
+  }
+
+  @Test
+  public void optional() {
+    assertThat(absent.values().optionalInstance()).isAbsent();
+  }
+
+  @Test
+  public void optionalProvider() {
+    assertThat(absent.values().optionalProvider()).isAbsent();
+  }
+
+  @Test
+  public void optionalLazy() {
+    assertThat(absent.values().optionalLazy()).isAbsent();
+  }
+
+  @Test
+  public void optionalLazyProvider() {
+    assertThat(absent.values().optionalLazyProvider()).isAbsent();
+  }
+
+  @Test
+  public void qualifiedOptional() {
+    assertThat(absent.qualifiedValues().optionalInstance()).isAbsent();
+  }
+
+  @Test
+  public void qualifiedOptionalProvider() {
+    assertThat(absent.qualifiedValues().optionalProvider()).isAbsent();
+  }
+
+  @Test
+  public void qualifiedOptionalLazy() {
+    assertThat(absent.qualifiedValues().optionalLazy()).isAbsent();
+  }
+
+  @Test
+  public void qualifiedOptionalLazyProvider() {
+    assertThat(absent.qualifiedValues().optionalLazyProvider()).isAbsent();
+  }
+}
diff --git a/compiler/src/it/guava-functional-tests/src/test/java/test/optional/OptionalBindingComponentsPresentTest.java b/compiler/src/it/guava-functional-tests/src/test/java/test/optional/OptionalBindingComponentsPresentTest.java
new file mode 100644
index 000000000..448329092
--- /dev/null
+++ b/compiler/src/it/guava-functional-tests/src/test/java/test/optional/OptionalBindingComponentsPresentTest.java
@@ -0,0 +1,85 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package test.optional;
+
+import static com.google.common.truth.Truth.assertThat;
+import static test.optional.OptionalBindingComponents.Value.QUALIFIED_VALUE;
+import static test.optional.OptionalBindingComponents.Value.VALUE;
+
+import com.google.common.collect.ImmutableList;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+import org.junit.runners.Parameterized.Parameters;
+import test.optional.OptionalBindingComponents.OptionalBindingComponent;
+
+/** Tests for present optional bindings. */
+@RunWith(Parameterized.class)
+public final class OptionalBindingComponentsPresentTest {
+
+  @Parameters(name = "{0}")
+  public static Iterable<Object[]> parameters() {
+    return ImmutableList.copyOf(
+        new Object[][] {
+          {DaggerOptionalBindingComponents_PresentOptionalBindingComponent.create()},
+          {DaggerOptionalBindingComponents_AbsentOptionalBindingComponent.create().presentChild()},
+        });
+  }
+
+  private final OptionalBindingComponent component;
+
+  public OptionalBindingComponentsPresentTest(OptionalBindingComponent component) {
+    this.component = component;
+  }
+
+  @Test
+  public void optionalProvider() {
+    assertThat(component.values().optionalProvider().get().get()).isEqualTo(VALUE);
+  }
+
+  @Test
+  public void optionalLazy() {
+    assertThat(component.values().optionalLazy().get().get()).isEqualTo(VALUE);
+  }
+
+  @Test
+  public void optionalLazyProvider() {
+    assertThat(component.values().optionalLazyProvider().get().get().get()).isEqualTo(VALUE);
+  }
+
+  @Test
+  public void qualifiedOptional() {
+    assertThat(component.qualifiedValues().optionalInstance()).hasValue(QUALIFIED_VALUE);
+  }
+
+  @Test
+  public void qualifiedOptionalProvider() {
+    assertThat(component.qualifiedValues().optionalProvider().get().get())
+        .isEqualTo(QUALIFIED_VALUE);
+  }
+
+  @Test
+  public void qualifiedOptionalLazy() {
+    assertThat(component.qualifiedValues().optionalLazy().get().get()).isEqualTo(QUALIFIED_VALUE);
+  }
+
+  @Test
+  public void qualifiedOptionalLazyProvider() {
+    assertThat(component.qualifiedValues().optionalLazyProvider().get().get().get())
+        .isEqualTo(QUALIFIED_VALUE);
+  }
+}
diff --git a/compiler/src/it/guava-functional-tests/src/test/java/test/optional/a/OptionalBindingComponentsWithInaccessibleTypesTest.java b/compiler/src/it/guava-functional-tests/src/test/java/test/optional/a/OptionalBindingComponentsWithInaccessibleTypesTest.java
new file mode 100644
index 000000000..ed655022f
--- /dev/null
+++ b/compiler/src/it/guava-functional-tests/src/test/java/test/optional/a/OptionalBindingComponentsWithInaccessibleTypesTest.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package test.optional.a;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/** Tests for optional bindings that include types inaccessible to the component. */
+@RunWith(JUnit4.class)
+public class OptionalBindingComponentsWithInaccessibleTypesTest {
+  @Test
+  public void components() {
+    DaggerOptionalBindingComponentsWithInaccessibleTypes_AbsentOptionalBindingComponent.create();
+    DaggerOptionalBindingComponentsWithInaccessibleTypes_PresentOptionalBindingComponent.create();
+  }
+}
diff --git a/compiler/src/it/producers-functional-tests/BUILD b/compiler/src/it/producers-functional-tests/BUILD
new file mode 100644
index 000000000..79e137ce1
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/BUILD
@@ -0,0 +1,58 @@
+# Copyright (C) 2017 The Dagger Authors.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+# Description:
+#   Functional tests for Dagger Producers
+
+package(default_visibility = ["//:src"])
+
+load(
+    "//:build_defs.bzl",
+    "DOCLINT_HTML_AND_SYNTAX",
+    "DOCLINT_REFERENCES",
+    "JAVA_7_SOURCE_LEVEL",
+    "PRE_JAVA_8_INFERENCE_OPTS",
+)
+
+# Sample code to be tested in functional tests.
+java_library(
+    name = "code_under_test",
+    srcs = glob(["src/main/java/**/*.java"]),
+    javacopts = PRE_JAVA_8_INFERENCE_OPTS + JAVA_7_SOURCE_LEVEL + DOCLINT_HTML_AND_SYNTAX,
+    deps = [
+        "//:producers_with_compiler",
+        "//third_party:auto_value",
+        "//third_party:guava",
+        "//third_party:jsr330_inject",
+    ],
+)
+
+load("//:test_defs.bzl", "GenJavaTests")
+
+GenJavaTests(
+    name = "producers-functional-tests",
+    srcs = glob(["src/test/java/**/*.java"]),
+    javacopts = PRE_JAVA_8_INFERENCE_OPTS + JAVA_7_SOURCE_LEVEL + DOCLINT_HTML_AND_SYNTAX + DOCLINT_REFERENCES,
+    deps = [
+        ":code_under_test",
+        "//:producers_with_compiler",
+        "//third_party:guava",
+        "//third_party:jsr330_inject",
+        "//third_party:junit",
+        "//third_party:mockito",
+        "//third_party:truth",
+    ],
+)
+
+test_suite(name = "AllTests")
diff --git a/compiler/src/it/producers-functional-tests/pom.xml b/compiler/src/it/producers-functional-tests/pom.xml
index 2051b22b0..0bf75f6a7 100644
--- a/compiler/src/it/producers-functional-tests/pom.xml
+++ b/compiler/src/it/producers-functional-tests/pom.xml
@@ -1,6 +1,6 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <!--
-Copyright (C) 2014 Google, Inc.
+Copyright (C) 2014 The Dagger Authors.
 
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
@@ -22,7 +22,7 @@ limitations under the License.
   <parent>
     <groupId>com.google.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>2.5-SNAPSHOT</version>
+    <version>HEAD-SNAPSHOT</version>
   </parent>
   <groupId>dagger.tests</groupId>
   <artifactId>producers-functional-tests</artifactId>
@@ -48,7 +48,11 @@ limitations under the License.
       <version>${project.version}</version>
       <optional>true</optional>
     </dependency>
-
+    <dependency>
+      <groupId>com.google.auto.value</groupId>
+      <artifactId>auto-value</artifactId>
+      <scope>provided</scope>
+    </dependency>
     <dependency>
       <groupId>junit</groupId>
       <artifactId>junit</artifactId>
@@ -75,24 +79,6 @@ limitations under the License.
           <target>1.7</target>
         </configuration>
       </plugin>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-checkstyle-plugin</artifactId>
-        <version>2.10</version>
-        <configuration>
-          <failsOnError>false</failsOnError>
-          <consoleOutput>true</consoleOutput>
-          <configLocation>../../../../checkstyle.xml</configLocation>
-        </configuration>
-        <executions>
-          <execution>
-            <phase>compile</phase>
-            <goals>
-              <goal>checkstyle</goal>
-            </goals>
-          </execution>
-        </executions>
-      </plugin>
     </plugins>
   </build>
 </project>
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/DependedComponent.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/DependedComponent.java
index 0d4dc13fd..81306c002 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/DependedComponent.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/DependedComponent.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package producerstest;
 
 import dagger.Component;
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/DependedModule.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/DependedModule.java
index dc62612cd..47b722d34 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/DependedModule.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/DependedModule.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package producerstest;
 
 import dagger.Module;
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/DependedProducerModule.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/DependedProducerModule.java
index bd1bc7a6b..b352c6bd3 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/DependedProducerModule.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/DependedProducerModule.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package producerstest;
 
 import dagger.producers.ProducerModule;
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/DependedProductionComponent.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/DependedProductionComponent.java
index 50b466da5..8fd6761c9 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/DependedProductionComponent.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/DependedProductionComponent.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package producerstest;
 
 import com.google.common.util.concurrent.ListenableFuture;
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/DependentComponent.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/DependentComponent.java
index f467178c6..0c8508eee 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/DependentComponent.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/DependentComponent.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,11 +13,11 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package producerstest;
 
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.producers.ProductionComponent;
-
 import java.util.List;
 
 @ProductionComponent(
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/DependentProducerModule.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/DependentProducerModule.java
index e16c82212..8467ee144 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/DependentProducerModule.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/DependentProducerModule.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package producerstest;
 
 import com.google.common.base.Ascii;
@@ -21,7 +22,6 @@
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.producers.ProducerModule;
 import dagger.producers.Produces;
-
 import java.util.List;
 
 @ProducerModule
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/ExecutorModule.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/ExecutorModule.java
index f37eac5c4..92492471f 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/ExecutorModule.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/ExecutorModule.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 Google, Inc.
+ * Copyright (C) 2016 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package producerstest;
 
 import com.google.common.util.concurrent.MoreExecutors;
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/ProvidesInProducerModule.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/ProvidesInProducerModule.java
new file mode 100644
index 000000000..70617127d
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/ProvidesInProducerModule.java
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package producerstest;
+
+import com.google.common.util.concurrent.ListenableFuture;
+import com.google.common.util.concurrent.MoreExecutors;
+import dagger.Provides;
+import dagger.producers.ProducerModule;
+import dagger.producers.Produces;
+import dagger.producers.Production;
+import dagger.producers.ProductionComponent;
+import java.util.concurrent.Executor;
+
+final class ProvidesInProducerModule {
+  @ProducerModule
+  static class OnlyModule {
+    @Provides
+    @Production
+    static Executor provideExecutor() {
+      return MoreExecutors.directExecutor();
+    }
+
+    @Produces
+    static String produceString() {
+      return "produced";
+    }
+  }
+
+  @ProductionComponent(modules = OnlyModule.class)
+  interface C {
+    ListenableFuture<String> string();
+  }
+}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/Request.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/Request.java
index 0227be6bd..6a6cbba20 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/Request.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/Request.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package producerstest;
 
 import javax.inject.Inject;
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/Response.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/Response.java
index 8618ff5e1..2e87cc440 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/Response.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/Response.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package producerstest;
 
 final class Response {
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/ResponseModule.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/ResponseModule.java
index 1edbe8aa6..3252ce36d 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/ResponseModule.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/ResponseModule.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package producerstest;
 
 import dagger.Module;
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/ResponseProducerModule.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/ResponseProducerModule.java
index b250a53ba..0b75e881c 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/ResponseProducerModule.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/ResponseProducerModule.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package producerstest;
 
 import com.google.common.util.concurrent.Futures;
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/SimpleComponent.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/SimpleComponent.java
index ea793fd4d..0ac75a476 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/SimpleComponent.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/SimpleComponent.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package producerstest;
 
 import com.google.common.util.concurrent.ListenableFuture;
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/SimpleProducerModule.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/SimpleProducerModule.java
index da58db06c..a06c059a9 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/SimpleProducerModule.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/SimpleProducerModule.java
@@ -1,5 +1,5 @@
 /*
-* Copyright (C) 2015 Google, Inc.
+* Copyright (C) 2015 The Dagger Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
+
 package producerstest;
 
 import com.google.common.collect.ImmutableSet;
@@ -268,4 +269,13 @@ static String setOfStrElementWithArgThrowingException(int i) throws IOException
     return Futures.<Set<String>>immediateFuture(
         ImmutableSet.of("set of str with arg 1", "set of str with arg 2 throwing exception"));
   }
+
+  /**
+   * A binding method that might result in a generated factory with conflicting field and parameter
+   * names.
+   */
+  @Produces
+  static Object object(int foo, Provider<String> fooProvider) {
+    return foo + fooProvider.get();
+  }
 }
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/badexecutor/ComponentDependency.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/badexecutor/ComponentDependency.java
index 7bba4ea4e..0844b0cbf 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/badexecutor/ComponentDependency.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/badexecutor/ComponentDependency.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package producerstest.badexecutor;
 
 import com.google.common.util.concurrent.ListenableFuture;
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/badexecutor/SimpleComponent.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/badexecutor/SimpleComponent.java
index efeb1d003..e13c47024 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/badexecutor/SimpleComponent.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/badexecutor/SimpleComponent.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package producerstest.badexecutor;
 
 import com.google.common.util.concurrent.ListenableFuture;
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/badexecutor/SimpleProducerModule.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/badexecutor/SimpleProducerModule.java
index 00ab037bd..24a5ae52b 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/badexecutor/SimpleProducerModule.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/badexecutor/SimpleProducerModule.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package producerstest.badexecutor;
 
 import dagger.producers.ProducerModule;
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/binds/Foo.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/binds/Foo.java
index 147284caa..343e90ecb 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/binds/Foo.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/binds/Foo.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 Google, Inc.
+ * Copyright (C) 2016 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package producerstest.binds;
 
 /**
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/binds/FooOfStrings.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/binds/FooOfStrings.java
index 256041290..1c0377b23 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/binds/FooOfStrings.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/binds/FooOfStrings.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 Google, Inc.
+ * Copyright (C) 2016 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,15 +13,15 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package producerstest.binds;
 
 /**
- * This is not marked with {@link javax.inject.Inject @Inject} (like the {@link dagger.Provides
- * @Provides} version in {@link test.bind.FooOfStrings}), to test that {@link dagger.Binds @Binds}
- * properly translate to {@link dagger.internal.codegen.ProductionBinding}s when the right-hand-side
- * of the method is also a production binding. We force this by adding a {@link
- * dagger.producers.Produces @Produces} method to add it to the graph instead of relying on the
- * {@link dagger.internal.codegen.ProvisionBinding} that would be created by default with an {@code
- * @Inject} constructor.
+ * This is not marked with {@link javax.inject.Inject @Inject} in order to test that {@link
+ * dagger.Binds @Binds} properly translate to {@link dagger.internal.codegen.ProductionBinding}s
+ * when the right-hand-side of the method is also a production binding. We force this by adding a
+ * {@link dagger.producers.Produces @Produces} method to add it to the graph instead of relying on
+ * the {@link dagger.internal.codegen.ProvisionBinding} that would be created by default with an
+ * {@code @Inject} constructor.
  */
 final class FooOfStrings implements Foo<String> {}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/binds/SimpleBindingModule.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/binds/SimpleBindingModule.java
index 5538ce60b..84b09689a 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/binds/SimpleBindingModule.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/binds/SimpleBindingModule.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 Google, Inc.
+ * Copyright (C) 2016 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package producerstest.binds;
 
 import com.google.common.util.concurrent.MoreExecutors;
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/binds/SimpleBindsProductionComponent.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/binds/SimpleBindsProductionComponent.java
index 2c8c8130d..db72ca8b5 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/binds/SimpleBindsProductionComponent.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/binds/SimpleBindsProductionComponent.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 Google, Inc.
+ * Copyright (C) 2016 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package producerstest.binds;
 
 import com.google.common.util.concurrent.ListenableFuture;
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/builder/DepComponent.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/builder/DepComponent.java
index dadde7b05..1c72cdb66 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/builder/DepComponent.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/builder/DepComponent.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package producerstest.builder;
 
 import com.google.common.util.concurrent.ListenableFuture;
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/builder/IntModule.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/builder/IntModule.java
index 7f99836d3..be7fb16ff 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/builder/IntModule.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/builder/IntModule.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package producerstest.builder;
 
 import dagger.Module;
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/builder/StringModule.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/builder/StringModule.java
index cdf0793da..30e6eb9a1 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/builder/StringModule.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/builder/StringModule.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package producerstest.builder;
 
 import dagger.producers.ProducerModule;
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/builder/TestComponentWithBuilder.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/builder/TestComponentWithBuilder.java
index 1e4973fc1..2705a6573 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/builder/TestComponentWithBuilder.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/builder/TestComponentWithBuilder.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package producerstest.builder;
 
 import com.google.common.util.concurrent.ListenableFuture;
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/MonitoredComponent.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/MonitoredComponent.java
index d46c88fa9..27df6fb52 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/MonitoredComponent.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/MonitoredComponent.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package producerstest.monitoring;
 
 import com.google.common.util.concurrent.ListenableFuture;
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/MonitoringModule.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/MonitoringModule.java
index 4b99c7a12..489b89a88 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/MonitoringModule.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/MonitoringModule.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package producerstest.monitoring;
 
 import dagger.Module;
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/ServingModule.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/ServingModule.java
index d5bec22ce..caaefa60b 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/ServingModule.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/ServingModule.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package producerstest.monitoring;
 
 import com.google.common.util.concurrent.ListenableFuture;
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/StringStub.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/StringStub.java
index 195dd283d..9503a74f4 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/StringStub.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/StringStub.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package producerstest.monitoring;
 
 import com.google.common.util.concurrent.ListenableFuture;
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/StubModule.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/StubModule.java
index dc8ab6260..0bc3bd681 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/StubModule.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/StubModule.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package producerstest.monitoring;
 
 import dagger.Module;
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/ThreadAccumulator.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/ThreadAccumulator.java
new file mode 100644
index 000000000..2eb4abda7
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/ThreadAccumulator.java
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package producerstest.monitoring;
+
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+import javax.inject.Inject;
+import javax.inject.Singleton;
+
+@Singleton
+final class ThreadAccumulator {
+  private final Map<String, Long> threadIds = new ConcurrentHashMap<>();
+
+  @Inject
+  ThreadAccumulator() {}
+
+  void markThread(String name) {
+    threadIds.put(name, Thread.currentThread().getId());
+  }
+
+  long threadId(String name) {
+    return threadIds.get(name);
+  }
+}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/ThreadModule.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/ThreadModule.java
new file mode 100644
index 000000000..829d6c4a8
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/ThreadModule.java
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package producerstest.monitoring;
+
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.producers.Producer;
+import dagger.producers.ProducerModule;
+import dagger.producers.Produces;
+import producerstest.monitoring.ThreadQualifiers.Deferred;
+import producerstest.monitoring.ThreadQualifiers.EntryPoint;
+import producerstest.monitoring.ThreadQualifiers.Required;
+
+@ProducerModule
+final class ThreadModule {
+  @Produces
+  @Deferred
+  Object deferred(ThreadAccumulator acc) {
+    acc.markThread("deferred");
+    return new Object();
+  }
+
+  @Produces
+  @Required
+  ListenableFuture<Object> required(@Deferred Producer<Object> o, ThreadAccumulator acc) {
+    acc.markThread("required");
+    return o.get();
+  }
+
+  @Produces
+  @EntryPoint
+  ThreadAccumulator entryPoint(@Required Object o, ThreadAccumulator acc) {
+    acc.markThread("entryPoint");
+    return acc;
+  }
+}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/ThreadMonitoredComponent.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/ThreadMonitoredComponent.java
new file mode 100644
index 000000000..bc565feaa
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/ThreadMonitoredComponent.java
@@ -0,0 +1,30 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package producerstest.monitoring;
+
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.producers.ProductionComponent;
+import javax.inject.Singleton;
+import producerstest.ExecutorModule;
+import producerstest.monitoring.ThreadQualifiers.EntryPoint;
+
+@Singleton
+@ProductionComponent(modules = {ExecutorModule.class, MonitoringModule.class, ThreadModule.class})
+interface ThreadMonitoredComponent {
+  @EntryPoint
+  ListenableFuture<ThreadAccumulator> threadAccumulator();
+}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/ThreadQualifiers.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/ThreadQualifiers.java
new file mode 100644
index 000000000..bfd415094
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/ThreadQualifiers.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package producerstest.monitoring;
+
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import javax.inject.Qualifier;
+
+final class ThreadQualifiers {
+  private ThreadQualifiers() {}
+
+  @Qualifier
+  @Retention(RUNTIME)
+  @Documented
+  @interface EntryPoint {}
+
+  @Qualifier
+  @Retention(RUNTIME)
+  @Documented
+  @interface Required {}
+
+  @Qualifier
+  @Retention(RUNTIME)
+  @Documented
+  @interface Deferred {}
+}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/MultibindingComponent.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/MultibindingComponent.java
index a9c9360bf..e858bed68 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/MultibindingComponent.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/MultibindingComponent.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 Google, Inc.
+ * Copyright (C) 2016 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package producerstest.multibindings;
 
 import com.google.common.util.concurrent.ListenableFuture;
@@ -22,7 +23,10 @@
 import java.util.Map;
 import java.util.Set;
 import producerstest.ExecutorModule;
+import producerstest.multibindings.Qualifiers.EmptyButDeclaredInModule;
+import producerstest.multibindings.Qualifiers.EmptyButDeclaredInModuleAndProducerModule;
 import producerstest.multibindings.Qualifiers.ObjCount;
+import producerstest.multibindings.Qualifiers.OnlyProvisionMultibindings;
 import producerstest.multibindings.Qualifiers.PossiblyThrowingMap;
 import producerstest.multibindings.Qualifiers.PossiblyThrowingSet;
 
@@ -65,4 +69,13 @@
 
   @ObjCount
   ListenableFuture<Integer> objCount();
+
+  @EmptyButDeclaredInModuleAndProducerModule
+  ListenableFuture<Map<String, Object>> emptyButDeclaredInModuleAndProducerModule();
+
+  @EmptyButDeclaredInModule
+  ListenableFuture<Map<String, Object>> emptyButDeclaredInModule();
+
+  @OnlyProvisionMultibindings
+  ListenableFuture<Map<String, Object>> onlyProvisionMultibindings();
 }
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/MultibindingModule.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/MultibindingModule.java
index 5c5834f54..969cb9fad 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/MultibindingModule.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/MultibindingModule.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 Google, Inc.
+ * Copyright (C) 2016 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package producerstest.multibindings;
 
 import com.google.common.collect.ImmutableSet;
@@ -22,10 +23,16 @@
 import dagger.multibindings.IntKey;
 import dagger.multibindings.IntoMap;
 import dagger.multibindings.IntoSet;
+import dagger.multibindings.Multibinds;
+import dagger.multibindings.StringKey;
+import java.util.Map;
 import java.util.Set;
+import producerstest.multibindings.Qualifiers.EmptyButDeclaredInModule;
+import producerstest.multibindings.Qualifiers.EmptyButDeclaredInModuleAndProducerModule;
+import producerstest.multibindings.Qualifiers.OnlyProvisionMultibindings;
 
 @Module
-final class MultibindingModule {
+abstract class MultibindingModule {
   @Provides
   @IntoSet
   static String providedStr() {
@@ -44,4 +51,20 @@ static String providedStr() {
   static String providedValueFor3() {
     return "provided three";
   }
+  
+  @Multibinds
+  @EmptyButDeclaredInModuleAndProducerModule
+  abstract Map<String, Object> emptyButDeclaredInModuleAndProducerModule();
+
+  @Multibinds
+  @EmptyButDeclaredInModule
+  abstract Map<String, Object> emptyButDeclaredInModule();
+
+  @Provides
+  @IntoMap
+  @StringKey("a")
+  @OnlyProvisionMultibindings
+  static Object onlyProvisionMultibindings() {
+    return "only multibinding";
+  }
 }
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/MultibindingProducerModule.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/MultibindingProducerModule.java
index 8532686f8..ee23fa206 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/MultibindingProducerModule.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/MultibindingProducerModule.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 Google, Inc.
+ * Copyright (C) 2016 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,12 +13,12 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package producerstest.multibindings;
 
 import com.google.common.collect.ImmutableSet;
 import com.google.common.util.concurrent.Futures;
 import com.google.common.util.concurrent.ListenableFuture;
-
 import dagger.multibindings.ElementsIntoSet;
 import dagger.multibindings.IntKey;
 import dagger.multibindings.IntoMap;
@@ -27,14 +27,13 @@
 import dagger.producers.Produced;
 import dagger.producers.ProducerModule;
 import dagger.producers.Produces;
-
+import java.util.Map;
+import java.util.Set;
+import producerstest.multibindings.Qualifiers.EmptyButDeclaredInModuleAndProducerModule;
 import producerstest.multibindings.Qualifiers.ObjCount;
 import producerstest.multibindings.Qualifiers.PossiblyThrowingMap;
 import producerstest.multibindings.Qualifiers.PossiblyThrowingSet;
 
-import java.util.Map;
-import java.util.Set;
-
 @ProducerModule
 abstract class MultibindingProducerModule {
   @Produces
@@ -55,6 +54,12 @@ static String str() {
     return Futures.<Set<String>>immediateFuture(ImmutableSet.of("foo1", "foo2"));
   }
 
+  @Produces
+  @ElementsIntoSet
+  static Set<ListenableFuture<String>> strFutures() {
+    return ImmutableSet.of(Futures.immediateFuture("baz1"), Futures.immediateFuture("baz2"));
+  }
+
   @Produces
   @ElementsIntoSet
   static Set<String> strs() {
@@ -128,4 +133,8 @@ static String throwingValueFor15() {
   static int objCount(Set<Produced<Object>> objs, Map<Object, Produced<Object>> objMap) {
     return objs.size() + objMap.size();
   }
+  
+  @Multibinds
+  @EmptyButDeclaredInModuleAndProducerModule
+  abstract Map<String, Object> emptyButDeclaredInModuleAndProducerModule();
 }
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/Qualifiers.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/Qualifiers.java
index c638270ed..3a2f359e9 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/Qualifiers.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/Qualifiers.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 Google, Inc.
+ * Copyright (C) 2016 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,14 +13,15 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package producerstest.multibindings;
 
-import java.lang.annotation.Retention;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
 import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
 import javax.inject.Qualifier;
 
-import static java.lang.annotation.RetentionPolicy.RUNTIME;
-
 final class Qualifiers {
   @Documented
   @Retention(RUNTIME)
@@ -37,5 +38,20 @@
   @Qualifier
   @interface ObjCount {}
 
+  @Documented
+  @Retention(RUNTIME)
+  @Qualifier
+  @interface EmptyButDeclaredInModule {}
+
+  @Documented
+  @Retention(RUNTIME)
+  @Qualifier
+  @interface EmptyButDeclaredInModuleAndProducerModule {}
+
+  @Documented
+  @Retention(RUNTIME)
+  @Qualifier
+  @interface OnlyProvisionMultibindings {}
+
   private Qualifiers() {}
 }
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/optional/OptionalBindingComponents.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/optional/OptionalBindingComponents.java
new file mode 100644
index 000000000..743b033e1
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/optional/OptionalBindingComponents.java
@@ -0,0 +1,175 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package producerstest.optional;
+
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+import com.google.auto.value.AutoValue;
+import com.google.common.base.Optional;
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.BindsOptionalOf;
+import dagger.Module;
+import dagger.Provides;
+import dagger.producers.Produced;
+import dagger.producers.Producer;
+import dagger.producers.ProducerModule;
+import dagger.producers.Produces;
+import dagger.producers.Production;
+import dagger.producers.ProductionComponent;
+import dagger.producers.ProductionSubcomponent;
+import java.lang.annotation.Retention;
+import java.util.concurrent.Executor;
+import java.util.concurrent.Executors;
+import javax.inject.Provider;
+import javax.inject.Qualifier;
+
+/** Classes to support testing {@code BindsOptionalOf} functionality. */
+final class OptionalBindingComponents {
+
+  /** A qualifier. */
+  @Qualifier
+  @Retention(RUNTIME)
+  @interface SomeQualifier {}
+
+  /** A value object that contains various optionally-bound objects. */
+  @AutoValue
+  abstract static class Values {
+    abstract Optional<Value> optionalInstance();
+
+    abstract Optional<Producer<Value>> optionalProducer();
+
+    abstract Optional<Produced<Value>> optionalProduced();
+  }
+
+  enum Value {
+    VALUE,
+    QUALIFIED_VALUE
+  }
+
+  @Module
+  static final class ExecutorModule {
+    @Provides
+    @Production
+    static Executor executor() {
+      return Executors.newSingleThreadExecutor();
+    }
+  }
+
+  /** Binds optionals and {@link Values}. */
+  @ProducerModule
+  abstract static class OptionalBindingModule {
+    @BindsOptionalOf
+    abstract Value value();
+
+    @BindsOptionalOf
+    @SomeQualifier
+    abstract Value qualifiedValue();
+
+    @Produces
+    static Values values(
+        Optional<Value> optionalInstance,
+        Optional<Producer<Value>> optionalProducer,
+        Optional<Produced<Value>> optionalProduced) {
+      return new AutoValue_OptionalBindingComponents_Values(
+          optionalInstance, optionalProducer, optionalProduced);
+    }
+
+    @Produces
+    @SomeQualifier
+    static Values qualifiedValues(
+        Optional<Value> optionalInstance,
+        Optional<Producer<Value>> optionalProducer,
+        Optional<Produced<Value>> optionalProduced) {
+      return new AutoValue_OptionalBindingComponents_Values(
+          optionalInstance, optionalProducer, optionalProduced);
+    }
+  }
+
+  /** Binds {@link Value} using {@link Producer}s. */
+  @ProducerModule
+  abstract static class ConcreteBindingProducerModule {
+    @Produces
+    static Value value() {
+      return Value.VALUE;
+    }
+
+    @Produces
+    @SomeQualifier
+    static Value qualifiedValue() {
+      return Value.QUALIFIED_VALUE;
+    }
+  }
+
+  /** Binds {@link Value} using {@link Provider}s. */
+  @Module
+  abstract static class ConcreteBindingModule {
+    @Provides
+    static Value value() {
+      return Value.VALUE;
+    }
+
+    @Provides
+    @SomeQualifier
+    static Value qualifiedValue() {
+      return Value.QUALIFIED_VALUE;
+    }
+  }
+
+  interface OptionalBindingComponent {
+    ListenableFuture<Values> values();
+
+    ListenableFuture<Optional<Value>> optionalInstance();
+
+    ListenableFuture<Optional<Producer<Value>>> optionalProducer();
+
+    ListenableFuture<Optional<Produced<Value>>> optionalProduced();
+
+    @SomeQualifier
+    ListenableFuture<Values> qualifiedValues();
+
+    @SomeQualifier
+    ListenableFuture<Optional<Value>> qualifiedOptionalInstance();
+
+    @SomeQualifier
+    ListenableFuture<Optional<Producer<Value>>> qualifiedOptionalProducer();
+
+    @SomeQualifier
+    ListenableFuture<Optional<Produced<Value>>> qualifiedOptionalProduced();
+  }
+
+  @ProductionComponent(modules = {ExecutorModule.class, OptionalBindingModule.class})
+  interface AbsentOptionalBindingComponent extends OptionalBindingComponent {
+    PresentOptionalBindingSubcomponent presentChild();
+  }
+
+  @ProductionComponent(
+    modules = {
+      ExecutorModule.class,
+      OptionalBindingModule.class,
+      ConcreteBindingProducerModule.class
+    }
+  )
+  interface PresentOptionalBindingComponent extends OptionalBindingComponent {}
+
+  @ProductionSubcomponent(modules = ConcreteBindingProducerModule.class)
+  interface PresentOptionalBindingSubcomponent extends OptionalBindingComponent {}
+
+  @ProductionComponent(
+    modules = {ExecutorModule.class, OptionalBindingModule.class, ConcreteBindingModule.class}
+  )
+  interface PresentOptionalProvisionBindingComponent extends OptionalBindingComponent {}
+}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/provisions/Provisions.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/provisions/Provisions.java
index 0833995ce..779c7277e 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/provisions/Provisions.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/provisions/Provisions.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 Google, Inc.
+ * Copyright (C) 2016 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package producerstest.provisions;
 
 import com.google.common.util.concurrent.ListenableFuture;
@@ -21,9 +22,8 @@
 import dagger.producers.Produces;
 import dagger.producers.ProductionComponent;
 import javax.inject.Inject;
-import producerstest.ExecutorModule;
-
 import javax.inject.Qualifier;
+import producerstest.ExecutorModule;
 
 /** Tests for requesting provisions from producers. */
 final class Provisions {
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/scope/ScopedModule.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/scope/ScopedModule.java
index da1c7b257..5027a7b57 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/scope/ScopedModule.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/scope/ScopedModule.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 Google, Inc.
+ * Copyright (C) 2016 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package producerstest.scope;
 
 import dagger.Module;
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/scope/ScopedObject.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/scope/ScopedObject.java
index 646eda45e..cdb72d8d8 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/scope/ScopedObject.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/scope/ScopedObject.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 Google, Inc.
+ * Copyright (C) 2016 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package producerstest.scope;
 
 import dagger.producers.ProductionScope;
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/scope/SetComponent.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/scope/SetComponent.java
index 75a05fa3f..a4bde48e8 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/scope/SetComponent.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/scope/SetComponent.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 Google, Inc.
+ * Copyright (C) 2016 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package producerstest.scope;
 
 import com.google.common.util.concurrent.ListenableFuture;
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/scope/SetProducerModule.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/scope/SetProducerModule.java
index e930e2749..23a441815 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/scope/SetProducerModule.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/scope/SetProducerModule.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 Google, Inc.
+ * Copyright (C) 2016 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package producerstest.scope;
 
 import dagger.multibindings.IntoSet;
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/subcomponent/ModuleSubcomponentsInterop.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/subcomponent/ModuleSubcomponentsInterop.java
new file mode 100644
index 000000000..7c0c02f73
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/subcomponent/ModuleSubcomponentsInterop.java
@@ -0,0 +1,58 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package producerstest.subcomponent;
+
+import dagger.Component;
+import dagger.Module;
+import dagger.Subcomponent;
+import dagger.producers.ProducerModule;
+import dagger.producers.ProductionComponent;
+import dagger.producers.ProductionSubcomponent;
+
+final class ModuleSubcomponentsInterop {
+  @Component(modules = ProvisionTestModule.class)
+  interface ProvisionParent {
+    ProductionChild.Builder productionChild();
+  }
+
+  @Module(subcomponents = ProductionChild.class)
+  static class ProvisionTestModule {}
+
+  @ProductionSubcomponent
+  interface ProductionChild {
+    @ProductionSubcomponent.Builder
+    interface Builder {
+      ProductionChild build();
+    }
+  }
+
+  @ProductionComponent(modules = ProductionTestModule.class)
+  interface ProductionParent {
+    ProvisionChild.Builder provisionBuilder();
+  }
+
+  @ProducerModule(subcomponents = ProvisionChild.class)
+  static class ProductionTestModule {}
+
+  @Subcomponent
+  interface ProvisionChild {
+    @Subcomponent.Builder
+    interface Builder {
+      ProvisionChild build();
+    }
+  }
+}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/subcomponent/MultiPackageSubcomponents.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/subcomponent/MultiPackageSubcomponents.java
index b44e4e21d..afef85d1a 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/subcomponent/MultiPackageSubcomponents.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/subcomponent/MultiPackageSubcomponents.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 Google, Inc.
+ * Copyright (C) 2016 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package producerstest.subcomponent;
 
 import dagger.Component;
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/subcomponent/ProductionSubcomponentFromModuleAndFactoryMethod.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/subcomponent/ProductionSubcomponentFromModuleAndFactoryMethod.java
new file mode 100644
index 000000000..c9c067aba
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/subcomponent/ProductionSubcomponentFromModuleAndFactoryMethod.java
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package producerstest.subcomponent;
+
+import dagger.Module;
+import dagger.Subcomponent;
+import dagger.producers.ProducerModule;
+import dagger.producers.ProductionComponent;
+import dagger.producers.ProductionSubcomponent;
+import producerstest.ExecutorModule;
+
+/**
+ * Tests for {@link Subcomponent}s which are defined with {@link Module#subcomponents()} and are
+ * also requested as component factory methods.
+ */
+public class ProductionSubcomponentFromModuleAndFactoryMethod {
+  @ProductionSubcomponent
+  interface Sub {
+    @ProductionSubcomponent.Builder
+    interface Builder {
+      Sub sub();
+    }
+  }
+
+  @ProducerModule(subcomponents = Sub.class)
+  static class ModuleWithSubcomponent {}
+
+  @ProductionComponent(modules = {ModuleWithSubcomponent.class, ExecutorModule.class})
+  interface ExposesBuilder {
+    Sub.Builder subcomponentBuilder();
+  }
+}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/subcomponent/SubcomponentsWithBoundExecutor.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/subcomponent/SubcomponentsWithBoundExecutor.java
index 138791826..bbd418a58 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/subcomponent/SubcomponentsWithBoundExecutor.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/subcomponent/SubcomponentsWithBoundExecutor.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 Google, Inc.
+ * Copyright (C) 2016 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package producerstest.subcomponent;
 
 import com.google.common.util.concurrent.ListenableFuture;
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/subcomponent/UsesProducerModuleSubcomponents.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/subcomponent/UsesProducerModuleSubcomponents.java
new file mode 100644
index 000000000..07502ffeb
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/subcomponent/UsesProducerModuleSubcomponents.java
@@ -0,0 +1,89 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package producerstest.subcomponent;
+
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.multibindings.IntoSet;
+import dagger.producers.ProducerModule;
+import dagger.producers.Produces;
+import dagger.producers.ProductionComponent;
+import dagger.producers.ProductionSubcomponent;
+import java.util.Set;
+import javax.inject.Qualifier;
+import producerstest.ExecutorModule;
+
+/** Supporting types for {@link ProducerModuleWithSubcomponentsTest}. */
+@ProductionComponent(
+  modules = UsesProducerModuleSubcomponents.ProducerModuleWithSubcomponents.class
+)
+public interface UsesProducerModuleSubcomponents {
+
+  ListenableFuture<Set<String>> strings();
+
+  @FromChild
+  ListenableFuture<Set<String>> stringsFromChild();
+
+  @ProducerModule(
+    subcomponents = Child.class,
+    includes = {AlsoIncludesSubcomponents.class, ExecutorModule.class}
+  )
+  class ProducerModuleWithSubcomponents {
+    @Produces
+    @IntoSet
+    static String produceStringInParent() {
+      return "from parent";
+    }
+
+    @Produces
+    @FromChild
+    static Set<String> stringsFromChild(Child.Builder childBuilder) throws Exception {
+      return childBuilder.build().strings().get();
+    }
+  }
+
+  @ProducerModule(subcomponents = Child.class)
+  class AlsoIncludesSubcomponents {}
+
+  @ProductionSubcomponent(modules = ChildModule.class)
+  interface Child {
+    ListenableFuture<Set<String>> strings();
+
+    @ProductionSubcomponent.Builder
+    interface Builder {
+      Child build();
+    }
+  }
+
+  @ProducerModule
+  class ChildModule {
+    @Produces
+    @IntoSet
+    static String produceStringInChild() {
+      return "from child";
+    }
+  }
+
+  @Qualifier
+  @interface FromChild {}
+
+  @ProducerModule(includes = ProducerModuleWithSubcomponents.class)
+  class OnlyIncludesProducerModuleWithSubcomponents {}
+
+  @ProductionComponent(modules = OnlyIncludesProducerModuleWithSubcomponents.class)
+  interface ParentIncludesProductionSubcomponentTransitively
+      extends UsesProducerModuleSubcomponents {}
+}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/subcomponent/pruning/ParentDoesntUseProductionSubcomponent.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/subcomponent/pruning/ParentDoesntUseProductionSubcomponent.java
new file mode 100644
index 000000000..d16b1d063
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/subcomponent/pruning/ParentDoesntUseProductionSubcomponent.java
@@ -0,0 +1,101 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package producerstest.subcomponent.pruning;
+
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.multibindings.IntoSet;
+import dagger.producers.ProducerModule;
+import dagger.producers.Produces;
+import dagger.producers.ProductionComponent;
+import dagger.producers.ProductionSubcomponent;
+import java.util.Set;
+import javax.inject.Qualifier;
+
+/**
+ * Supporting types for {@link ProductionSubcomponentOnlyRequestedBySiblingTest}. {@link ChildA} is
+ * a direct child of the top level component, but is only requested within its sibling, not directly
+ * from its parent.
+ */
+@ProductionComponent(
+  modules = {
+    ParentDoesntUseProductionSubcomponent.ParentModule.class,
+    producerstest.ExecutorModule.class
+  }
+)
+interface ParentDoesntUseProductionSubcomponent {
+
+  ChildB.Builder childBBuilder();
+
+  @ProductionSubcomponent(modules = ChildAModule.class)
+  interface ChildA {
+    @ProductionSubcomponent.Builder
+    interface Builder {
+      ChildA build();
+    }
+
+    ListenableFuture<Set<Class<?>>> componentHierarchy();
+  }
+
+  @ProductionSubcomponent(modules = ChildBModule.class)
+  interface ChildB {
+    @ProductionSubcomponent.Builder
+    interface Builder {
+      ChildB build();
+    }
+
+    ListenableFuture<Set<Class<?>>> componentHierarchy();
+
+    @FromChildA
+    ListenableFuture<Set<Class<?>>> componentHierarchyFromChildA();
+  }
+
+  @ProducerModule(subcomponents = {ChildA.class, ChildB.class})
+  class ParentModule {
+    @Produces
+    @IntoSet
+    static Class<?> produceComponentType() {
+      return ParentDoesntUseProductionSubcomponent.class;
+    }
+  }
+
+  @ProducerModule
+  class ChildAModule {
+    @Produces
+    @IntoSet
+    static Class<?> produceComponentType() {
+      return ChildA.class;
+    }
+  }
+
+  @ProducerModule
+  class ChildBModule {
+    @Produces
+    @IntoSet
+    static Class<?> produceComponentType() {
+      return ChildB.class;
+    }
+
+    @Produces
+    @FromChildA
+    Set<Class<?>> fromChildA(ChildA.Builder childABuilder) throws Exception {
+      return childABuilder.build().componentHierarchy().get();
+    }
+  }
+
+  @Qualifier
+  @interface FromChildA {}
+}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/subcomponent/sub/ChildComponent.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/subcomponent/sub/ChildComponent.java
index 0059631b8..c49e1c08a 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/subcomponent/sub/ChildComponent.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/subcomponent/sub/ChildComponent.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 Google, Inc.
+ * Copyright (C) 2016 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package producerstest.subcomponent.sub;
 
 import com.google.common.util.concurrent.ListenableFuture;
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/subcomponent/sub/ChildModule.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/subcomponent/sub/ChildModule.java
index 43b79f4b5..c8d730f75 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/subcomponent/sub/ChildModule.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/subcomponent/sub/ChildModule.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 Google, Inc.
+ * Copyright (C) 2016 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package producerstest.subcomponent.sub;
 
 import dagger.producers.ProducerModule;
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/DependentTest.java b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/DependentTest.java
index e4812b823..7298a4258 100644
--- a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/DependentTest.java
+++ b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/DependentTest.java
@@ -1,5 +1,5 @@
 /*
-* Copyright (C) 2015 Google, Inc.
+* Copyright (C) 2015 The Dagger Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
@@ -13,16 +13,17 @@
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
+
 package producerstest;
 
+import static com.google.common.truth.Truth.assertThat;
+
 import com.google.common.util.concurrent.Futures;
 import com.google.common.util.concurrent.ListenableFuture;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import static com.google.common.truth.Truth.assertThat;
-
 @RunWith(JUnit4.class)
 public class DependentTest {
   @Test public void dependentComponent() throws Exception {
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/ProducerFactoryTest.java b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/ProducerFactoryTest.java
index 67d47ead5..6da997702 100644
--- a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/ProducerFactoryTest.java
+++ b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/ProducerFactoryTest.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,8 +13,15 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package producerstest;
 
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.inOrder;
+import static org.mockito.Mockito.when;
+
 import com.google.common.util.concurrent.ListenableFuture;
 import com.google.common.util.concurrent.MoreExecutors;
 import com.google.common.util.concurrent.SettableFuture;
@@ -34,12 +41,6 @@
 import org.mockito.Mockito;
 import org.mockito.MockitoAnnotations;
 
-import static com.google.common.truth.Truth.assertThat;
-import static org.junit.Assert.fail;
-import static org.mockito.Matchers.any;
-import static org.mockito.Mockito.inOrder;
-import static org.mockito.Mockito.when;
-
 @RunWith(JUnit4.class)
 public class ProducerFactoryTest {
   @Mock private ProductionComponentMonitor componentMonitor;
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/SimpleTest.java b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/SimpleTest.java
index e4812ab9a..5c52e0382 100644
--- a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/SimpleTest.java
+++ b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/SimpleTest.java
@@ -1,5 +1,5 @@
 /*
-* Copyright (C) 2015 Google, Inc.
+* Copyright (C) 2015 The Dagger Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
@@ -13,14 +13,15 @@
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
+
 package producerstest;
 
+import static com.google.common.truth.Truth.assertThat;
+
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import static com.google.common.truth.Truth.assertThat;
-
 @RunWith(JUnit4.class)
 public class SimpleTest {
   @Test public void testSimpleComponent() throws Exception {
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/badexecutor/BadExecutorTest.java b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/badexecutor/BadExecutorTest.java
index 1f0db70b2..39ff83e12 100644
--- a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/badexecutor/BadExecutorTest.java
+++ b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/badexecutor/BadExecutorTest.java
@@ -1,5 +1,8 @@
 package producerstest.badexecutor;
 
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+
 import com.google.common.util.concurrent.Futures;
 import com.google.common.util.concurrent.ListenableFuture;
 import com.google.common.util.concurrent.ListeningExecutorService;
@@ -12,9 +15,6 @@
 import org.junit.runners.JUnit4;
 import producerstest.ExecutorModule;
 
-import static com.google.common.truth.Truth.assertThat;
-import static org.junit.Assert.fail;
-
 /** This test verifies behavior when the executor throws {@link RejectedExecutionException}. */
 @RunWith(JUnit4.class)
 public final class BadExecutorTest {
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/binds/BindsProducersTest.java b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/binds/BindsProducersTest.java
index 1c6b0faf4..42ebe6889 100644
--- a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/binds/BindsProducersTest.java
+++ b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/binds/BindsProducersTest.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 Google, Inc.
+ * Copyright (C) 2016 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,8 +13,11 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package producerstest.binds;
 
+import static com.google.common.truth.Truth.assertThat;
+
 import com.google.common.collect.ImmutableMap;
 import dagger.producers.Produced;
 import dagger.producers.Producer;
@@ -24,8 +27,6 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import static com.google.common.truth.Truth.assertThat;
-
 @RunWith(JUnit4.class)
 public class BindsProducersTest {
 
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/builder/ProductionComponentBuilderTest.java b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/builder/ProductionComponentBuilderTest.java
index 396bef65f..ece750fc7 100644
--- a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/builder/ProductionComponentBuilderTest.java
+++ b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/builder/ProductionComponentBuilderTest.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,16 +13,17 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package producerstest.builder;
 
+import static com.google.common.truth.Truth.assertThat;
+
 import com.google.common.util.concurrent.Futures;
 import com.google.common.util.concurrent.ListenableFuture;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import static com.google.common.truth.Truth.assertThat;
-
 /** Tests for {@link dagger.producers.ProductionComponent.Builder}. */
 @RunWith(JUnit4.class)
 public final class ProductionComponentBuilderTest {
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/monitoring/MonitoringTest.java b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/monitoring/MonitoringTest.java
index e36f35886..921464a47 100644
--- a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/monitoring/MonitoringTest.java
+++ b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/monitoring/MonitoringTest.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,10 +13,20 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package producerstest.monitoring;
 
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+import static org.mockito.Mockito.any;
+import static org.mockito.Mockito.inOrder;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verifyNoMoreInteractions;
+import static org.mockito.Mockito.when;
+
 import com.google.common.base.Throwables;
 import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
 import com.google.common.util.concurrent.ListenableFuture;
 import com.google.common.util.concurrent.SettableFuture;
 import dagger.producers.monitoring.ProducerMonitor;
@@ -25,6 +35,7 @@
 import java.util.LinkedHashMap;
 import java.util.Map;
 import java.util.concurrent.ExecutionException;
+import java.util.concurrent.Executors;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -32,14 +43,7 @@
 import org.mockito.InOrder;
 import org.mockito.Mock;
 import org.mockito.MockitoAnnotations;
-
-import static com.google.common.truth.Truth.assertThat;
-import static org.junit.Assert.fail;
-import static org.mockito.Mockito.any;
-import static org.mockito.Mockito.inOrder;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verifyNoMoreInteractions;
-import static org.mockito.Mockito.when;
+import producerstest.ExecutorModule;
 
 /** Tests for production components using monitoring. */
 @RunWith(JUnit4.class)
@@ -85,15 +89,18 @@ public void basicMonitoring() throws Exception {
     inOrder.verify(callServer2Monitor).requested();
     inOrder.verify(callServer1Monitor).requested();
     inOrder.verify(requestDataMonitor).requested();
+    inOrder.verify(requestDataMonitor).ready();
     inOrder.verify(requestDataMonitor).methodStarting();
     inOrder.verify(requestDataMonitor).methodFinished();
     inOrder.verify(requestDataMonitor).succeeded("Hello, World!");
+    inOrder.verify(callServer1Monitor).ready();
     inOrder.verify(callServer1Monitor).methodStarting();
     inOrder.verify(callServer1Monitor).methodFinished();
     verifyNoMoreInteractions(requestDataMonitor, callServer1Monitor, callServer2Monitor);
 
     server1Future.set("server 1 response");
     inOrder.verify(callServer1Monitor).succeeded("server 1 response");
+    inOrder.verify(callServer2Monitor).ready();
     inOrder.verify(callServer2Monitor).methodStarting();
     inOrder.verify(callServer2Monitor).methodFinished();
     verifyNoMoreInteractions(requestDataMonitor, callServer1Monitor, callServer2Monitor);
@@ -127,9 +134,11 @@ public void basicMonitoringWithFailure() throws Exception {
     inOrder.verify(callServer2Monitor).requested();
     inOrder.verify(callServer1Monitor).requested();
     inOrder.verify(requestDataMonitor).requested();
+    inOrder.verify(requestDataMonitor).ready();
     inOrder.verify(requestDataMonitor).methodStarting();
     inOrder.verify(requestDataMonitor).methodFinished();
     inOrder.verify(requestDataMonitor).succeeded("Hello, World!");
+    inOrder.verify(callServer1Monitor).ready();
     inOrder.verify(callServer1Monitor).methodStarting();
     inOrder.verify(callServer1Monitor).methodFinished();
     verifyNoMoreInteractions(requestDataMonitor, callServer1Monitor, callServer2Monitor);
@@ -137,6 +146,7 @@ public void basicMonitoringWithFailure() throws Exception {
     RuntimeException cause = new RuntimeException("monkey");
     server1Future.setException(cause);
     inOrder.verify(callServer1Monitor).failed(cause);
+    inOrder.verify(callServer2Monitor).ready();
     inOrder.verify(callServer2Monitor).failed(any(Throwable.class));
     verifyNoMoreInteractions(requestDataMonitor, callServer1Monitor, callServer2Monitor);
     try {
@@ -157,4 +167,88 @@ public ProducerMonitor producerMonitorFor(ProducerToken token) {
       return monitor;
     }
   }
+
+  @Test
+  public void monitoringWithThreads() throws Exception {
+    ThreadRecordingProductionComponentMonitor componentMonitor =
+        new ThreadRecordingProductionComponentMonitor();
+    when(componentMonitorFactory.create(any())).thenReturn(componentMonitor);
+
+    ThreadMonitoredComponent component =
+        DaggerThreadMonitoredComponent.builder()
+            .monitoringModule(new MonitoringModule(componentMonitorFactory))
+            .executorModule(new ExecutorModule(Executors.newFixedThreadPool(10)))
+            .build();
+    ThreadAccumulator threadAccumulator = component.threadAccumulator().get();
+
+    assertThat(componentMonitor.monitors).hasSize(3);
+    ImmutableList<Map.Entry<ProducerToken, ThreadRecordingProducerMonitor>> entries =
+        ImmutableList.copyOf(componentMonitor.monitors.entrySet());
+
+    assertThat(entries.get(0).getKey().toString()).contains("EntryPoint");
+    ThreadRecordingProducerMonitor entryPointMonitor = entries.get(0).getValue();
+    assertThat(entries.get(1).getKey().toString()).contains("Required");
+    ThreadRecordingProducerMonitor requiredMonitor = entries.get(1).getValue();
+    assertThat(entries.get(2).getKey().toString()).contains("Deferred");
+    ThreadRecordingProducerMonitor deferredMonitor = entries.get(2).getValue();
+
+    // The entry point producer was requested from the main thread, then ran in its own thread.
+    assertThat(entryPointMonitor.requestedThreadId).isEqualTo(Thread.currentThread().getId());
+    assertThat(entryPointMonitor.startingThreadId)
+        .isEqualTo(threadAccumulator.threadId("entryPoint"));
+    assertThat(entryPointMonitor.finishedThreadId)
+        .isEqualTo(threadAccumulator.threadId("entryPoint"));
+
+    // The deferred producer was requested by the required producer, then ran in its own thread.
+    assertThat(deferredMonitor.requestedThreadId).isEqualTo(threadAccumulator.threadId("required"));
+    assertThat(deferredMonitor.startingThreadId).isEqualTo(threadAccumulator.threadId("deferred"));
+    assertThat(deferredMonitor.finishedThreadId).isEqualTo(threadAccumulator.threadId("deferred"));
+
+    // The required producer was requested by the entry point producer, then ran in its own thread.
+    assertThat(requiredMonitor.requestedThreadId).isEqualTo(entryPointMonitor.requestedThreadId);
+    assertThat(requiredMonitor.startingThreadId).isEqualTo(threadAccumulator.threadId("required"));
+    assertThat(requiredMonitor.finishedThreadId).isEqualTo(threadAccumulator.threadId("required"));
+
+    // Each producer ran in a distinct thread.
+    ImmutableSet<Long> threadIds =
+        ImmutableSet.of(
+            Thread.currentThread().getId(),
+            threadAccumulator.threadId("required"),
+            threadAccumulator.threadId("deferred"),
+            threadAccumulator.threadId("entryPoint"));
+    assertThat(threadIds).hasSize(4);
+  }
+
+  private static final class ThreadRecordingProductionComponentMonitor
+      extends ProductionComponentMonitor {
+    final Map<ProducerToken, ThreadRecordingProducerMonitor> monitors = new LinkedHashMap<>();
+
+    @Override
+    public ProducerMonitor producerMonitorFor(ProducerToken token) {
+      ThreadRecordingProducerMonitor monitor = new ThreadRecordingProducerMonitor();
+      monitors.put(token, monitor);
+      return monitor;
+    }
+  }
+
+  private static final class ThreadRecordingProducerMonitor extends ProducerMonitor {
+    private long requestedThreadId;
+    private long startingThreadId;
+    private long finishedThreadId;
+
+    @Override
+    public void requested() {
+      requestedThreadId = Thread.currentThread().getId();
+    }
+
+    @Override
+    public void methodStarting() {
+      startingThreadId = Thread.currentThread().getId();
+    }
+
+    @Override
+    public void methodFinished() {
+      finishedThreadId = Thread.currentThread().getId();
+    }
+  }
 }
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/multibindings/MultibindingTest.java b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/multibindings/MultibindingTest.java
index 3d9c4677c..79f58fdce 100644
--- a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/multibindings/MultibindingTest.java
+++ b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/multibindings/MultibindingTest.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 Google, Inc.
+ * Copyright (C) 2016 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,8 +13,12 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package producerstest.multibindings;
 
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+
 import com.google.common.collect.Iterables;
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.producers.Produced;
@@ -27,9 +31,6 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import static com.google.common.truth.Truth.assertThat;
-import static org.junit.Assert.fail;
-
 @RunWith(JUnit4.class)
 public class MultibindingTest {
   @Test
@@ -40,13 +41,15 @@ public void setBinding() throws Exception {
             "foo",
             "foo1",
             "foo2",
+            "baz1",
+            "baz2",
             "bar",
             "bar1",
             "bar2",
             "providedStr",
             "providedStr1",
             "providedStr2");
-    assertThat(multibindingComponent.strCount().get()).isEqualTo(9);
+    assertThat(multibindingComponent.strCount().get()).isEqualTo(11);
   }
 
   @Test
@@ -57,6 +60,8 @@ public void setBindingOfProduced() throws Exception {
             Produced.successful("foo"),
             Produced.successful("foo1"),
             Produced.successful("foo2"),
+            Produced.successful("baz1"),
+            Produced.successful("baz2"),
             Produced.successful("bar"),
             Produced.successful("bar1"),
             Produced.successful("bar2"),
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/optional/OptionalBindingComponentsAbsentTest.java b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/optional/OptionalBindingComponentsAbsentTest.java
new file mode 100644
index 000000000..c2d5ce530
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/optional/OptionalBindingComponentsAbsentTest.java
@@ -0,0 +1,66 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package producerstest.optional;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import producerstest.optional.OptionalBindingComponents.AbsentOptionalBindingComponent;
+
+/** Tests for absent optional bindings. */
+@RunWith(JUnit4.class)
+public final class OptionalBindingComponentsAbsentTest {
+  private AbsentOptionalBindingComponent absent;
+
+  @Before
+  public void setUp() {
+    absent = DaggerOptionalBindingComponents_AbsentOptionalBindingComponent.create();
+  }
+
+  @Test
+  public void optional() throws Exception {
+    assertThat(absent.optionalInstance().get()).isAbsent();
+  }
+
+  @Test
+  public void optionalProducer() throws Exception {
+    assertThat(absent.optionalProducer().get()).isAbsent();
+  }
+
+  @Test
+  public void optionalProduced() throws Exception {
+    assertThat(absent.optionalProduced().get()).isAbsent();
+  }
+
+  @Test
+  public void qualifiedOptional() throws Exception {
+    assertThat(absent.qualifiedOptionalInstance().get()).isAbsent();
+  }
+
+  @Test
+  public void qualifiedOptionalProducer() throws Exception {
+    assertThat(absent.qualifiedOptionalProducer().get()).isAbsent();
+  }
+
+  @Test
+  public void qualifiedOptionalProduced() throws Exception {
+    assertThat(absent.qualifiedOptionalProduced().get()).isAbsent();
+  }
+}
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/optional/OptionalBindingComponentsPresentTest.java b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/optional/OptionalBindingComponentsPresentTest.java
new file mode 100644
index 000000000..8788e5236
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/optional/OptionalBindingComponentsPresentTest.java
@@ -0,0 +1,80 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package producerstest.optional;
+
+import static com.google.common.truth.Truth.assertThat;
+import static producerstest.optional.OptionalBindingComponents.Value.QUALIFIED_VALUE;
+import static producerstest.optional.OptionalBindingComponents.Value.VALUE;
+
+import com.google.common.collect.ImmutableList;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+import org.junit.runners.Parameterized.Parameters;
+import producerstest.optional.OptionalBindingComponents.OptionalBindingComponent;
+
+/** Tests for present optional bindings. */
+@RunWith(Parameterized.class)
+public final class OptionalBindingComponentsPresentTest {
+
+  @Parameters(name = "{0}")
+  public static Iterable<Object[]> parameters() {
+    return ImmutableList.copyOf(
+        new Object[][] {
+          {DaggerOptionalBindingComponents_PresentOptionalBindingComponent.create()},
+          {DaggerOptionalBindingComponents_AbsentOptionalBindingComponent.create().presentChild()},
+          {DaggerOptionalBindingComponents_PresentOptionalProvisionBindingComponent.create()}
+        });
+  }
+  
+  private final OptionalBindingComponent component;
+
+  public OptionalBindingComponentsPresentTest(OptionalBindingComponent component) {
+    this.component = component;
+  }
+
+  @Test
+  public void optional() throws Exception {
+    assertThat(component.optionalInstance().get()).hasValue(VALUE);
+  }
+
+  @Test
+  public void optionalProducer() throws Exception {
+    assertThat(component.optionalProducer().get().get().get().get()).isEqualTo(VALUE);
+  }
+
+  @Test
+  public void optionalProduced() throws Exception {
+    assertThat(component.optionalProduced().get().get().get()).isEqualTo(VALUE);
+  }
+
+  @Test
+  public void qualifiedOptional() throws Exception {
+    assertThat(component.qualifiedOptionalInstance().get()).hasValue(QUALIFIED_VALUE);
+  }
+
+  @Test
+  public void qualifiedOptionalProducer() throws Exception {
+    assertThat(component.qualifiedOptionalProducer().get().get().get().get())
+        .isEqualTo(QUALIFIED_VALUE);
+  }
+
+  @Test
+  public void qualifiedOptionalProduced() throws Exception {
+    assertThat(component.qualifiedOptionalProduced().get().get().get()).isEqualTo(QUALIFIED_VALUE);
+  }
+}
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/provisions/ProvisionsTest.java b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/provisions/ProvisionsTest.java
index e4371cbf4..53543f962 100644
--- a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/provisions/ProvisionsTest.java
+++ b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/provisions/ProvisionsTest.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 Google, Inc.
+ * Copyright (C) 2016 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,8 +13,11 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package producerstest.provisions;
 
+import static com.google.common.truth.Truth.assertThat;
+
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
@@ -22,8 +25,6 @@
 import producerstest.provisions.Provisions.Output;
 import producerstest.provisions.Provisions.TestComponent;
 
-import static com.google.common.truth.Truth.assertThat;
-
 @RunWith(JUnit4.class)
 public final class ProvisionsTest {
 
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/scope/ScopeTest.java b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/scope/ScopeTest.java
index 6af6d8af6..1cffdd306 100644
--- a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/scope/ScopeTest.java
+++ b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/scope/ScopeTest.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 Google, Inc.
+ * Copyright (C) 2016 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,14 +13,15 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package producerstest.scope;
 
+import static com.google.common.truth.Truth.assertThat;
+
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import static com.google.common.truth.Truth.assertThat;
-
 @RunWith(JUnit4.class)
 public final class ScopeTest {
 
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/subcomponent/MultiPackageSubcomponentTest.java b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/subcomponent/MultiPackageSubcomponentTest.java
index 313202172..aca8ea165 100644
--- a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/subcomponent/MultiPackageSubcomponentTest.java
+++ b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/subcomponent/MultiPackageSubcomponentTest.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 Google, Inc.
+ * Copyright (C) 2016 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,15 +13,16 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package producerstest.subcomponent;
 
 import static com.google.common.truth.Truth.assertThat;
 
-import producerstest.subcomponent.MultiPackageSubcomponents.ParentComponent;
-import producerstest.subcomponent.sub.ChildComponent;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
+import producerstest.subcomponent.MultiPackageSubcomponents.ParentComponent;
+import producerstest.subcomponent.sub.ChildComponent;
 
 @RunWith(JUnit4.class)
 public final class MultiPackageSubcomponentTest {
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/subcomponent/ProducerModuleWithSubcomponentsTest.java b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/subcomponent/ProducerModuleWithSubcomponentsTest.java
new file mode 100644
index 000000000..24d43e5b6
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/subcomponent/ProducerModuleWithSubcomponentsTest.java
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package producerstest.subcomponent;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import dagger.producers.ProducerModule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import producerstest.subcomponent.UsesProducerModuleSubcomponents.ParentIncludesProductionSubcomponentTransitively;
+
+/** Tests for {@link ProducerModule#subcomponents()}. */
+@RunWith(JUnit4.class)
+public class ProducerModuleWithSubcomponentsTest {
+
+  @Test
+  public void subcomponentFromModules() throws Exception {
+    UsesProducerModuleSubcomponents parent = DaggerUsesProducerModuleSubcomponents.create();
+    assertThat(parent.strings().get()).containsExactly("from parent");
+    assertThat(parent.stringsFromChild().get()).containsExactly("from parent", "from child");
+  }
+
+  @Test
+  public void subcomponentFromModules_transitively() throws Exception {
+    ParentIncludesProductionSubcomponentTransitively parent =
+        DaggerUsesProducerModuleSubcomponents_ParentIncludesProductionSubcomponentTransitively
+            .create();
+    assertThat(parent.strings().get()).containsExactly("from parent");
+    assertThat(parent.stringsFromChild().get()).containsExactly("from parent", "from child");
+  }
+}
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/subcomponent/SubcomponentWithBoundExecutorTest.java b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/subcomponent/SubcomponentWithBoundExecutorTest.java
index 78cbadade..14ae444c8 100644
--- a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/subcomponent/SubcomponentWithBoundExecutorTest.java
+++ b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/subcomponent/SubcomponentWithBoundExecutorTest.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 Google, Inc.
+ * Copyright (C) 2016 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,8 +13,11 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package producerstest.subcomponent;
 
+import static com.google.common.truth.Truth.assertThat;
+
 import java.util.concurrent.atomic.AtomicInteger;
 import org.junit.Before;
 import org.junit.Test;
@@ -27,8 +30,6 @@
 import producerstest.subcomponent.SubcomponentsWithBoundExecutor.ParentComponent;
 import producerstest.subcomponent.SubcomponentsWithBoundExecutor.ParentProductionComponent;
 
-import static com.google.common.truth.Truth.assertThat;
-
 @RunWith(JUnit4.class)
 public final class SubcomponentWithBoundExecutorTest {
   private ParentComponent parentComponent;
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/subcomponent/pruning/ProductionSubcomponentOnlyRequestedBySiblingTest.java b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/subcomponent/pruning/ProductionSubcomponentOnlyRequestedBySiblingTest.java
new file mode 100644
index 000000000..c579fb171
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/subcomponent/pruning/ProductionSubcomponentOnlyRequestedBySiblingTest.java
@@ -0,0 +1,50 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package producerstest.subcomponent.pruning;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import dagger.producers.ProducerModule;
+import dagger.producers.ProductionSubcomponent;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import producerstest.subcomponent.pruning.ParentDoesntUseProductionSubcomponent.ChildA;
+import producerstest.subcomponent.pruning.ParentDoesntUseProductionSubcomponent.ChildB;
+
+/**
+ * Tests for {@link ProductionSubcomponent}s which are included with {@link
+ * ProducerModule#subcomponents()} but not used directly within the component which adds them.
+ *
+ * <p>This tests to make sure that while resolving one subcomponent (A), another subcomponent (B)
+ * can be requested if they have a shared ancestor component. If that shared ancestor did not
+ * resolve B directly via any of its entry points, B will still be generated since it is requested
+ * by a descendant.
+ */
+@RunWith(JUnit4.class)
+public class ProductionSubcomponentOnlyRequestedBySiblingTest {
+  @Test
+  public void subcomponentAddedInParent_onlyUsedInSibling() throws Exception {
+    ParentDoesntUseProductionSubcomponent parent =
+        DaggerParentDoesntUseProductionSubcomponent.create();
+    ChildB childB = parent.childBBuilder().build();
+    assertThat(childB.componentHierarchy().get())
+        .containsExactly(ParentDoesntUseProductionSubcomponent.class, ChildB.class);
+    assertThat(childB.componentHierarchyFromChildA().get())
+        .containsExactly(ParentDoesntUseProductionSubcomponent.class, ChildA.class);
+  }
+}
diff --git a/compiler/src/it/tck/BUILD b/compiler/src/it/tck/BUILD
new file mode 100644
index 000000000..c0979488c
--- /dev/null
+++ b/compiler/src/it/tck/BUILD
@@ -0,0 +1,60 @@
+# Copyright (C) 2017 The Dagger Authors.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+# Description:
+#  TCK tests for Dagger
+
+package(default_visibility = ["//:src"])
+
+load(
+    "//:build_defs.bzl",
+    "DOCLINT_HTML_AND_SYNTAX",
+    "DOCLINT_REFERENCES",
+    "PRE_JAVA_8_INFERENCE_OPTS",
+)
+
+# Sample code to be tested in functional tests.
+java_library(
+    name = "code_under_test",
+    testonly = 1,
+    srcs = glob(["src/main/java/**/*.java"]),
+    javacopts = PRE_JAVA_8_INFERENCE_OPTS + DOCLINT_HTML_AND_SYNTAX + [
+        "-Adagger.privateMemberValidation=warning",
+        "-Adagger.staticMemberValidation=warning",
+        "-Adagger.ignorePrivateAndStaticInjectionForComponent=enabled",
+    ],
+    deps = [
+        "//:dagger_with_compiler",
+        "//third_party:jsr330_inject",
+        "//third_party:jsr330_inject_tck",
+        "//third_party:junit",
+    ],
+)
+
+load("//:test_defs.bzl", "GenJavaTests")
+
+GenJavaTests(
+    name = "tck_tests",
+    srcs = glob(["src/test/java/**/*.java"]),
+    javacopts = PRE_JAVA_8_INFERENCE_OPTS + DOCLINT_HTML_AND_SYNTAX + DOCLINT_REFERENCES,
+    deps = [
+        ":code_under_test",
+        "//:dagger_with_compiler",
+        "//third_party:jsr330_inject",
+        "//third_party:jsr330_inject_tck",
+        "//third_party:junit",
+    ],
+)
+
+test_suite(name = "AllTests")
diff --git a/compiler/src/it/tck/pom.xml b/compiler/src/it/tck/pom.xml
index 3bf297956..0bc1b455f 100644
--- a/compiler/src/it/tck/pom.xml
+++ b/compiler/src/it/tck/pom.xml
@@ -1,6 +1,6 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <!--
-Copyright (C) 2014 Google, Inc.
+Copyright (C) 2014 The Dagger Authors.
 
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
@@ -22,7 +22,7 @@ limitations under the License.
   <parent>
     <groupId>com.google.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>2.5-SNAPSHOT</version>
+    <version>HEAD-SNAPSHOT</version>
   </parent>
   <groupId>dagger.tests</groupId>
   <artifactId>tck</artifactId>
@@ -65,24 +65,6 @@ limitations under the License.
           </compilerArgs>
         </configuration>
       </plugin>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-checkstyle-plugin</artifactId>
-        <version>2.10</version>
-        <configuration>
-          <failsOnError>false</failsOnError>
-          <consoleOutput>true</consoleOutput>
-          <configLocation>../../../../checkstyle.xml</configLocation>
-        </configuration>
-        <executions>
-          <execution>
-            <phase>compile</phase>
-            <goals>
-              <goal>checkstyle</goal>
-            </goals>
-          </execution>
-        </executions>
-      </plugin>
     </plugins>
   </build>
 </project>
diff --git a/compiler/src/it/tck/src/main/java/test/tck/CarModule.java b/compiler/src/it/tck/src/main/java/test/tck/CarModule.java
index 31a8006e1..6ef5d3811 100644
--- a/compiler/src/it/tck/src/main/java/test/tck/CarModule.java
+++ b/compiler/src/it/tck/src/main/java/test/tck/CarModule.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,17 +13,16 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test.tck;
 
+import dagger.Binds;
 import dagger.Module;
-import dagger.Provides;
 import org.atinject.tck.auto.Car;
 import org.atinject.tck.auto.Convertible;
 
 @Module
-class CarModule {
-  @Provides
-  static Car provideConvertible(Convertible convertible) {
-    return convertible;
-  }
+abstract class CarModule {
+  @Binds
+  abstract Car provideConvertible(Convertible convertible);
 }
diff --git a/compiler/src/it/tck/src/main/java/test/tck/CarShop.java b/compiler/src/it/tck/src/main/java/test/tck/CarShop.java
index e42532e9d..73f326d67 100644
--- a/compiler/src/it/tck/src/main/java/test/tck/CarShop.java
+++ b/compiler/src/it/tck/src/main/java/test/tck/CarShop.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,11 +13,12 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test.tck;
 
 import dagger.Component;
-import org.atinject.tck.auto.Car;
 import javax.inject.Singleton;
+import org.atinject.tck.auto.Car;
 
 @Singleton
 @Component(
diff --git a/compiler/src/it/tck/src/main/java/test/tck/EngineModule.java b/compiler/src/it/tck/src/main/java/test/tck/EngineModule.java
index 61c100bae..dd27dcb40 100644
--- a/compiler/src/it/tck/src/main/java/test/tck/EngineModule.java
+++ b/compiler/src/it/tck/src/main/java/test/tck/EngineModule.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test.tck;
 
 import dagger.MembersInjector;
diff --git a/compiler/src/it/tck/src/main/java/test/tck/FuelTankModule.java b/compiler/src/it/tck/src/main/java/test/tck/FuelTankModule.java
index f412e664e..77f6a4172 100644
--- a/compiler/src/it/tck/src/main/java/test/tck/FuelTankModule.java
+++ b/compiler/src/it/tck/src/main/java/test/tck/FuelTankModule.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test.tck;
 
 import dagger.Module;
diff --git a/compiler/src/it/tck/src/main/java/test/tck/SeatModule.java b/compiler/src/it/tck/src/main/java/test/tck/SeatModule.java
index b02f218bb..e5a90c08e 100644
--- a/compiler/src/it/tck/src/main/java/test/tck/SeatModule.java
+++ b/compiler/src/it/tck/src/main/java/test/tck/SeatModule.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,19 +13,18 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test.tck;
 
+import dagger.Binds;
 import dagger.Module;
-import dagger.Provides;
 import org.atinject.tck.auto.Drivers;
 import org.atinject.tck.auto.DriversSeat;
 import org.atinject.tck.auto.Seat;
 
 @Module
-class SeatModule {
-  @Provides
+abstract class SeatModule {
+  @Binds
   @Drivers
-  static Seat provideSeat(DriversSeat seat) {
-    return seat;
-  }
+  abstract Seat provideSeat(DriversSeat seat);
 }
diff --git a/compiler/src/it/tck/src/main/java/test/tck/TireModule.java b/compiler/src/it/tck/src/main/java/test/tck/TireModule.java
index f41852025..8b668eda2 100644
--- a/compiler/src/it/tck/src/main/java/test/tck/TireModule.java
+++ b/compiler/src/it/tck/src/main/java/test/tck/TireModule.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,19 +13,18 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test.tck;
 
+import dagger.Binds;
 import dagger.Module;
-import dagger.Provides;
+import javax.inject.Named;
 import org.atinject.tck.auto.Tire;
 import org.atinject.tck.auto.accessories.SpareTire;
-import javax.inject.Named;
 
 @Module
-class TireModule {
-  @Provides
+abstract class TireModule {
+  @Binds
   @Named("spare")
-  static Tire provideTire(SpareTire sparetire) {
-    return sparetire;
-  }
+  abstract Tire provideTire(SpareTire sparetire);
 }
diff --git a/compiler/src/it/tck/src/test/java/test/tck/TckTest.java b/compiler/src/it/tck/src/test/java/test/tck/TckTest.java
index d79b06b6a..e6d6301a0 100644
--- a/compiler/src/it/tck/src/test/java/test/tck/TckTest.java
+++ b/compiler/src/it/tck/src/test/java/test/tck/TckTest.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package test.tck;
 
 import junit.framework.Test;
diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
index 703ebb384..795a5e185 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,12 +13,70 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal.codegen;
 
+import static com.google.common.base.CaseFormat.LOWER_CAMEL;
+import static com.google.common.base.CaseFormat.UPPER_CAMEL;
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkState;
+import static com.google.common.base.Verify.verify;
+import static com.google.common.collect.Iterables.getOnlyElement;
+import static com.squareup.javapoet.MethodSpec.constructorBuilder;
+import static com.squareup.javapoet.MethodSpec.methodBuilder;
+import static com.squareup.javapoet.TypeSpec.anonymousClassBuilder;
+import static com.squareup.javapoet.TypeSpec.classBuilder;
+import static dagger.internal.codegen.AbstractComponentWriter.InitializationState.DELEGATED;
+import static dagger.internal.codegen.AbstractComponentWriter.InitializationState.INITIALIZED;
+import static dagger.internal.codegen.AbstractComponentWriter.InitializationState.UNINITIALIZED;
+import static dagger.internal.codegen.AnnotationSpecs.Suppression.RAWTYPES;
+import static dagger.internal.codegen.AnnotationSpecs.Suppression.UNCHECKED;
+import static dagger.internal.codegen.BindingKey.contribution;
+import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
+import static dagger.internal.codegen.ContributionBinding.FactoryCreationStrategy.SINGLETON_INSTANCE;
+import static dagger.internal.codegen.ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD;
+import static dagger.internal.codegen.MapKeys.getMapKeyExpression;
+import static dagger.internal.codegen.MemberSelect.emptyFrameworkMapFactory;
+import static dagger.internal.codegen.MemberSelect.emptySetProvider;
+import static dagger.internal.codegen.MemberSelect.localField;
+import static dagger.internal.codegen.MemberSelect.noOpMembersInjector;
+import static dagger.internal.codegen.MemberSelect.staticMethod;
+import static dagger.internal.codegen.MoreAnnotationMirrors.getTypeValue;
+import static dagger.internal.codegen.Scope.reusableScope;
+import static dagger.internal.codegen.SourceFiles.bindingTypeElementTypeVariableNames;
+import static dagger.internal.codegen.SourceFiles.generatedClassNameForBinding;
+import static dagger.internal.codegen.SourceFiles.membersInjectorNameForType;
+import static dagger.internal.codegen.SourceFiles.simpleVariableName;
+import static dagger.internal.codegen.TypeNames.DELEGATE_FACTORY;
+import static dagger.internal.codegen.TypeNames.DOUBLE_CHECK;
+import static dagger.internal.codegen.TypeNames.INSTANCE_FACTORY;
+import static dagger.internal.codegen.TypeNames.LISTENABLE_FUTURE;
+import static dagger.internal.codegen.TypeNames.MAP_FACTORY;
+import static dagger.internal.codegen.TypeNames.MAP_OF_PRODUCED_PRODUCER;
+import static dagger.internal.codegen.TypeNames.MAP_OF_PRODUCER_PRODUCER;
+import static dagger.internal.codegen.TypeNames.MAP_PRODUCER;
+import static dagger.internal.codegen.TypeNames.MAP_PROVIDER_FACTORY;
+import static dagger.internal.codegen.TypeNames.MEMBERS_INJECTORS;
+import static dagger.internal.codegen.TypeNames.PRODUCER;
+import static dagger.internal.codegen.TypeNames.REFERENCE_RELEASING_PROVIDER;
+import static dagger.internal.codegen.TypeNames.REFERENCE_RELEASING_PROVIDER_MANAGER;
+import static dagger.internal.codegen.TypeNames.SET_FACTORY;
+import static dagger.internal.codegen.TypeNames.SET_OF_PRODUCED_PRODUCER;
+import static dagger.internal.codegen.TypeNames.SET_PRODUCER;
+import static dagger.internal.codegen.TypeNames.SINGLE_CHECK;
+import static dagger.internal.codegen.TypeNames.TYPED_RELEASABLE_REFERENCE_MANAGER_DECORATOR;
+import static dagger.internal.codegen.TypeNames.providerOf;
+import static dagger.internal.codegen.TypeSpecs.addSupertype;
+import static javax.lang.model.element.Modifier.ABSTRACT;
+import static javax.lang.model.element.Modifier.FINAL;
+import static javax.lang.model.element.Modifier.PRIVATE;
+import static javax.lang.model.element.Modifier.PUBLIC;
+import static javax.lang.model.type.TypeKind.DECLARED;
+import static javax.lang.model.type.TypeKind.VOID;
+
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.common.base.Joiner;
-import com.google.common.base.Optional;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
@@ -31,14 +89,19 @@
 import com.squareup.javapoet.CodeBlock;
 import com.squareup.javapoet.FieldSpec;
 import com.squareup.javapoet.MethodSpec;
+import com.squareup.javapoet.ParameterSpec;
+import com.squareup.javapoet.ParameterizedTypeName;
 import com.squareup.javapoet.TypeName;
 import com.squareup.javapoet.TypeSpec;
 import com.squareup.javapoet.TypeVariableName;
 import dagger.internal.DelegateFactory;
+import dagger.internal.InstanceFactory;
 import dagger.internal.MapFactory;
 import dagger.internal.MapProviderFactory;
 import dagger.internal.Preconditions;
 import dagger.internal.SetFactory;
+import dagger.internal.TypedReleasableReferenceManagerDecorator;
+import dagger.internal.codegen.ComponentDescriptor.BuilderRequirementMethod;
 import dagger.internal.codegen.ComponentDescriptor.BuilderSpec;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
 import dagger.producers.Produced;
@@ -47,12 +110,22 @@
 import dagger.producers.internal.MapProducer;
 import dagger.producers.internal.SetOfProducedProducer;
 import dagger.producers.internal.SetProducer;
+import dagger.releasablereferences.CanReleaseReferences;
+import dagger.releasablereferences.ForReleasableReferences;
+import dagger.releasablereferences.ReleasableReferenceManager;
+import dagger.releasablereferences.TypedReleasableReferenceManager;
+import java.util.Arrays;
+import java.util.EnumSet;
 import java.util.HashMap;
+import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
+import java.util.Optional;
 import java.util.Set;
 import javax.inject.Provider;
+import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.Modifier;
 import javax.lang.model.element.Name;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
@@ -64,67 +137,8 @@
 import javax.lang.model.util.Types;
 import javax.tools.Diagnostic;
 
-import static com.google.common.base.CaseFormat.LOWER_CAMEL;
-import static com.google.common.base.CaseFormat.UPPER_CAMEL;
-import static com.google.common.base.Preconditions.checkState;
-import static com.google.common.collect.Iterables.getOnlyElement;
-import static com.squareup.javapoet.MethodSpec.constructorBuilder;
-import static com.squareup.javapoet.MethodSpec.methodBuilder;
-import static dagger.internal.codegen.AbstractComponentWriter.InitializationState.DELEGATED;
-import static dagger.internal.codegen.AbstractComponentWriter.InitializationState.INITIALIZED;
-import static dagger.internal.codegen.AbstractComponentWriter.InitializationState.UNINITIALIZED;
-import static dagger.internal.codegen.AnnotationSpecs.SUPPRESS_WARNINGS_UNCHECKED;
-import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
-import static dagger.internal.codegen.ContributionBinding.FactoryCreationStrategy.ENUM_INSTANCE;
-import static dagger.internal.codegen.ContributionBinding.Kind.PROVISION;
-import static dagger.internal.codegen.ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD;
-import static dagger.internal.codegen.FrameworkDependency.frameworkDependenciesForBinding;
-import static dagger.internal.codegen.MapKeys.getMapKeyExpression;
-import static dagger.internal.codegen.MemberSelect.emptyFrameworkMapFactory;
-import static dagger.internal.codegen.MemberSelect.emptySetProvider;
-import static dagger.internal.codegen.MemberSelect.localField;
-import static dagger.internal.codegen.MemberSelect.noOpMembersInjector;
-import static dagger.internal.codegen.MemberSelect.staticMethod;
-import static dagger.internal.codegen.MembersInjectionBinding.Strategy.NO_OP;
-import static dagger.internal.codegen.Scope.reusableScope;
-import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
-import static dagger.internal.codegen.SourceFiles.generatedClassNameForBinding;
-import static dagger.internal.codegen.SourceFiles.membersInjectorNameForType;
-import static dagger.internal.codegen.TypeNames.DELEGATE_FACTORY;
-import static dagger.internal.codegen.TypeNames.DOUBLE_CHECK;
-import static dagger.internal.codegen.TypeNames.FACTORY;
-import static dagger.internal.codegen.TypeNames.ILLEGAL_STATE_EXCEPTION;
-import static dagger.internal.codegen.TypeNames.INSTANCE_FACTORY;
-import static dagger.internal.codegen.TypeNames.LISTENABLE_FUTURE;
-import static dagger.internal.codegen.TypeNames.MAP_FACTORY;
-import static dagger.internal.codegen.TypeNames.MAP_OF_PRODUCED_PRODUCER;
-import static dagger.internal.codegen.TypeNames.MAP_OF_PRODUCER_PRODUCER;
-import static dagger.internal.codegen.TypeNames.MAP_PRODUCER;
-import static dagger.internal.codegen.TypeNames.MAP_PROVIDER_FACTORY;
-import static dagger.internal.codegen.TypeNames.MEMBERS_INJECTORS;
-import static dagger.internal.codegen.TypeNames.PRODUCER;
-import static dagger.internal.codegen.TypeNames.PRODUCERS;
-import static dagger.internal.codegen.TypeNames.SET_FACTORY;
-import static dagger.internal.codegen.TypeNames.SET_OF_PRODUCED_PRODUCER;
-import static dagger.internal.codegen.TypeNames.SET_PRODUCER;
-import static dagger.internal.codegen.TypeNames.SINGLE_CHECK;
-import static dagger.internal.codegen.TypeNames.STRING;
-import static dagger.internal.codegen.TypeNames.UNSUPPORTED_OPERATION_EXCEPTION;
-import static dagger.internal.codegen.TypeSpecs.addSupertype;
-import static dagger.internal.codegen.Util.componentCanMakeNewInstances;
-import static dagger.internal.codegen.Util.requiresAPassedInstance;
-import static javax.lang.model.element.Modifier.ABSTRACT;
-import static javax.lang.model.element.Modifier.FINAL;
-import static javax.lang.model.element.Modifier.PRIVATE;
-import static javax.lang.model.element.Modifier.PUBLIC;
-import static javax.lang.model.element.Modifier.STATIC;
-import static javax.lang.model.type.TypeKind.DECLARED;
-import static javax.lang.model.type.TypeKind.VOID;
-
-/**
- * Creates the implementation class for a component or subcomponent.
- */
-abstract class AbstractComponentWriter {
+/** Creates the implementation class for a component or subcomponent. */
+abstract class AbstractComponentWriter implements HasBindingMembers {
   private static final String NOOP_BUILDER_METHOD_JAVADOC =
       "This module is declared, but an instance is not used in the component. This method is a "
           + "no-op. For more, see https://google.github.io/dagger/unused-modules.\n";
@@ -138,18 +152,21 @@
   protected final BindingGraph graph;
   protected final ImmutableMap<ComponentDescriptor, String> subcomponentNames;
   private final Map<BindingKey, InitializationState> initializationStates = new HashMap<>();
-  protected TypeSpec.Builder component;
+  protected final TypeSpec.Builder component;
   private final UniqueNameSet componentFieldNames = new UniqueNameSet();
   private final Map<BindingKey, MemberSelect> memberSelects = new HashMap<>();
   private final Map<BindingKey, MemberSelect> producerFromProviderMemberSelects = new HashMap<>();
+  private final RequestFulfillmentRegistry requestFulfillmentRegistry;
   protected final MethodSpec.Builder constructor = constructorBuilder().addModifiers(PRIVATE);
-  protected Optional<ClassName> builderName = Optional.absent();
+  protected Optional<ClassName> builderName = Optional.empty();
+  private final OptionalFactories optionalFactories;
+  private boolean done;
 
   /**
    * For each component requirement, the builder field. This map is empty for subcomponents that do
    * not use a builder.
    */
-  private ImmutableMap<TypeElement, FieldSpec> builderFields = ImmutableMap.of();
+  private ImmutableMap<ComponentRequirement, FieldSpec> builderFields = ImmutableMap.of();
 
   /**
    * For each component requirement, the member select for the component field that holds it.
@@ -157,7 +174,14 @@
    * <p>Fields are written for all requirements for subcomponents that do not use a builder, and for
    * any requirement that is reused from a subcomponent of this component.
    */
-  protected final Map<TypeElement, MemberSelect> componentContributionFields = Maps.newHashMap();
+  protected final Map<ComponentRequirement, MemberSelect> componentContributionFields =
+      Maps.newHashMap();
+
+  /**
+   * The member-selects for {@link dagger.internal.ReferenceReleasingProviderManager} fields,
+   * indexed by their {@link CanReleaseReferences @CanReleaseReferences} scope.
+   */
+  private ImmutableMap<Scope, MemberSelect> referenceReleasingProviderManagerFields;
 
   AbstractComponentWriter(
       Types types,
@@ -166,59 +190,76 @@
       CompilerOptions compilerOptions,
       ClassName name,
       BindingGraph graph,
-      ImmutableMap<ComponentDescriptor, String> subcomponentNames) {
+      ImmutableMap<ComponentDescriptor, String> subcomponentNames,
+      OptionalFactories optionalFactories) {
     this.types = types;
     this.elements = elements;
     this.keyFactory = keyFactory;
     this.compilerOptions = compilerOptions;
+    this.component = classBuilder(name);
     this.name = name;
     this.graph = graph;
     this.subcomponentNames = subcomponentNames;
+    this.optionalFactories = optionalFactories;
+    this.requestFulfillmentRegistry =
+        new RequestFulfillmentRegistry(graph.resolvedBindings(), this);
   }
 
-  protected final TypeElement componentDefinitionType() {
-    return graph.componentDescriptor().componentDefinitionType();
+  protected AbstractComponentWriter(
+      AbstractComponentWriter parent, ClassName name, BindingGraph graph) {
+    this(
+        parent.types,
+        parent.elements,
+        parent.keyFactory,
+        parent.compilerOptions,
+        name,
+        graph,
+        parent.subcomponentNames,
+        parent.optionalFactories);
   }
 
   protected final ClassName componentDefinitionTypeName() {
-    return ClassName.get(componentDefinitionType());
+    return ClassName.get(graph.componentType());
   }
 
   /**
-   * Returns an expression that evaluates to an instance of the contribution, looking for either a
+   * Returns an expression that evaluates to an instance of the requirement, looking for either a
    * builder field or a component field.
    */
-  private CodeBlock getComponentContributionExpression(TypeElement contributionType) {
-    if (builderFields.containsKey(contributionType)) {
-      return CodeBlock.of("builder.$N", builderFields.get(contributionType));
+  private CodeBlock getComponentContributionExpression(ComponentRequirement componentRequirement) {
+    if (builderFields.containsKey(componentRequirement)) {
+      return CodeBlock.of("builder.$N", builderFields.get(componentRequirement));
     } else {
       Optional<CodeBlock> codeBlock =
-          getOrCreateComponentContributionFieldExpression(contributionType);
-      checkState(codeBlock.isPresent(), "no builder or component field for %s", contributionType);
+          getOrCreateComponentRequirementFieldExpression(componentRequirement);
+      checkState(
+          codeBlock.isPresent(), "no builder or component field for %s", componentRequirement);
       return codeBlock.get();
     }
   }
 
   /**
-   * Returns an expression for a component contribution field. Adds a field the first time one is
-   * requested for a contribution type if this component's builder has a field for it.
+   * Returns an expression for a component requirement field. Adds a field the first time one is
+   * requested for a requirement if this component's builder has a field for it.
    */
-  protected Optional<CodeBlock> getOrCreateComponentContributionFieldExpression(
-      TypeElement contributionType) {
-    MemberSelect fieldSelect = componentContributionFields.get(contributionType);
+  protected Optional<CodeBlock> getOrCreateComponentRequirementFieldExpression(
+      ComponentRequirement componentRequirement) {
+    MemberSelect fieldSelect = componentContributionFields.get(componentRequirement);
     if (fieldSelect == null) {
-      if (!builderFields.containsKey(contributionType)) {
-        return Optional.absent();
+      if (!builderFields.containsKey(componentRequirement)) {
+        return Optional.empty();
       }
       FieldSpec componentField =
-          componentField(ClassName.get(contributionType), simpleVariableName(contributionType))
+          componentField(
+                  TypeName.get(componentRequirement.type()),
+                  simpleVariableName(componentRequirement.typeElement()))
               .addModifiers(PRIVATE, FINAL)
               .build();
       component.addField(componentField);
       constructor.addCode(
-          "this.$N = builder.$N;", componentField, builderFields.get(contributionType));
+          "this.$N = builder.$N;", componentField, builderFields.get(componentRequirement));
       fieldSelect = localField(name, componentField.name);
-      componentContributionFields.put(contributionType, fieldSelect);
+      componentContributionFields.put(componentRequirement, fieldSelect);
     }
     return Optional.of(fieldSelect.getExpressionFor(name));
   }
@@ -234,7 +275,8 @@ private CodeBlock getMemberSelectExpression(BindingKey key) {
     return getMemberSelect(key).getExpressionFor(name);
   }
 
-  protected MemberSelect getMemberSelect(BindingKey key) {
+  @Override
+  public MemberSelect getMemberSelect(BindingKey key) {
     return memberSelects.get(key);
   }
 
@@ -251,28 +293,42 @@ private void setInitializationState(BindingKey bindingKey, InitializationState s
     initializationStates.put(bindingKey, state);
   }
 
+  /**
+   * The member-select expression for the {@link dagger.internal.ReferenceReleasingProviderManager}
+   * object for a scope.
+   */
+  protected CodeBlock getReferenceReleasingProviderManagerExpression(Scope scope) {
+    return referenceReleasingProviderManagerFields.get(scope).getExpressionFor(name);
+  }
+
   /**
    * Constructs a {@link TypeSpec.Builder} that models the {@link BindingGraph} for this component.
    * This is only intended to be called once (and will throw on successive invocations). If the
    * component must be regenerated, use a new instance.
    */
   final TypeSpec.Builder write() {
-    checkState(component == null, "ComponentWriter has already been generated.");
-    component = createComponentClass();
+    checkState(!done, "ComponentWriter has already been generated.");
+    decorateComponent();
     addBuilder();
     addFactoryMethods();
-    addFields();
+    addReferenceReleasingProviderManagerFields();
+    addFrameworkFields();
     initializeFrameworkTypes();
     implementInterfaceMethods();
     addSubcomponents();
     component.addMethod(constructor.build());
+    if (graph.componentDescriptor().kind().isTopLevel()) {
+      optionalFactories.addMembers(component);
+    }
+    done = true;
     return component;
   }
 
   /**
-   * Creates the component implementation class.
+   * Adds Javadoc, modifiers, supertypes, and annotations to the component implementation class
+   * declaration.
    */
-  protected abstract TypeSpec.Builder createComponentClass();
+  protected abstract void decorateComponent();
 
   /**
    * Adds a builder type.
@@ -311,16 +367,18 @@ protected void addBuilder() {
    * Adds fields for each of the {@linkplain BindingGraph#componentRequirements component
    * requirements}. Regardless of builder spec, there is always one field per requirement.
    */
-  private ImmutableMap<TypeElement, FieldSpec> addBuilderFields(TypeSpec.Builder componentBuilder) {
+  private ImmutableMap<ComponentRequirement, FieldSpec> addBuilderFields(
+      TypeSpec.Builder componentBuilder) {
     UniqueNameSet builderFieldNames = new UniqueNameSet();
-    ImmutableMap.Builder<TypeElement, FieldSpec> builderFields = ImmutableMap.builder();
-    for (TypeElement contributionElement : graph.componentRequirements()) {
+    ImmutableMap.Builder<ComponentRequirement, FieldSpec> builderFields = ImmutableMap.builder();
+    for (ComponentRequirement componentRequirement : graph.componentRequirements()) {
       String contributionName =
-          builderFieldNames.getUniqueName(simpleVariableName(contributionElement));
+          builderFieldNames.getUniqueName(componentRequirement.variableName());
       FieldSpec builderField =
-          FieldSpec.builder(ClassName.get(contributionElement), contributionName, PRIVATE).build();
+          FieldSpec.builder(TypeName.get(componentRequirement.type()), contributionName, PRIVATE)
+              .build();
       componentBuilder.addField(builderField);
-      builderFields.put(contributionElement, builderField);
+      builderFields.put(componentRequirement, builderField);
     }
     return builderFields.build();
   }
@@ -341,18 +399,25 @@ private void addBuildMethod(
     }
     buildMethod.returns(componentDefinitionTypeName()).addModifiers(PUBLIC);
 
-    for (Map.Entry<TypeElement, FieldSpec> builderFieldEntry : builderFields.entrySet()) {
+    for (Map.Entry<ComponentRequirement, FieldSpec> builderFieldEntry : builderFields.entrySet()) {
       FieldSpec builderField = builderFieldEntry.getValue();
-      if (componentCanMakeNewInstances(builderFieldEntry.getKey())) {
-        buildMethod.addCode(
-            "if ($1N == null) { this.$1N = new $2T(); }", builderField, builderField.type);
-      } else if (requiresAPassedInstance(elements, builderFieldEntry.getKey())) {
-        buildMethod.addCode(
-            "if ($N == null) { throw new $T($T.class.getCanonicalName() + $S); }",
-            builderField,
-            ILLEGAL_STATE_EXCEPTION,
-            builderField.type,
-            " must be set");
+      switch (builderFieldEntry.getKey().nullPolicy(elements, types)) {
+        case NEW:
+          buildMethod.addCode(
+              "if ($1N == null) { this.$1N = new $2T(); }", builderField, builderField.type);
+          break;
+        case THROW:
+          buildMethod.addCode(
+              "if ($N == null) { throw new $T($T.class.getCanonicalName() + $S); }",
+              builderField,
+              IllegalStateException.class,
+              TypeNames.rawTypeName(builderField.type),
+              " must be set");
+          break;
+        case ALLOW:
+          break;
+        default:
+          throw new AssertionError(builderFieldEntry.getKey());
       }
     }
     buildMethod.addStatement("return new $T(this)", name);
@@ -365,27 +430,36 @@ private void addBuildMethod(
    */
   private void addBuilderMethods(
       TypeSpec.Builder componentBuilder, Optional<BuilderSpec> builderSpec) {
-    ImmutableSet<TypeElement> componentRequirements = graph.componentRequirements();
+    ImmutableSet<ComponentRequirement> componentRequirements = graph.componentRequirements();
     if (builderSpec.isPresent()) {
       UniqueNameSet parameterNames = new UniqueNameSet();
-      for (Map.Entry<TypeElement, ExecutableElement> builderMethodEntry :
-          builderSpec.get().methodMap().entrySet()) {
-        TypeElement builderMethodType = builderMethodEntry.getKey();
-        ExecutableElement specMethod = builderMethodEntry.getValue();
+      for (BuilderRequirementMethod requirementMethod : builderSpec.get().requirementMethods()) {
+        ComponentRequirement builderRequirement = requirementMethod.requirement();
+        ExecutableElement specMethod = requirementMethod.method();
         MethodSpec.Builder builderMethod = addBuilderMethodFromSpec(specMethod);
-        String parameterName =
-            parameterNames.getUniqueName(
-                Iterables.getOnlyElement(specMethod.getParameters()).getSimpleName());
-        builderMethod.addParameter(ClassName.get(builderMethodType), parameterName);
-        if (componentRequirements.contains(builderMethodType)) {
+        VariableElement parameterElement = Iterables.getOnlyElement(specMethod.getParameters());
+        String parameterName = parameterNames.getUniqueName(parameterElement.getSimpleName());
+
+        TypeName argType =
+            parameterElement.asType().getKind().isPrimitive()
+                // Primitives need to use the original (unresolved) type to avoid boxing.
+                ? TypeName.get(parameterElement.asType())
+                // Otherwise we use the full resolved type.
+                : TypeName.get(builderRequirement.type());
+
+        builderMethod.addParameter(argType, parameterName);
+        if (componentRequirements.contains(builderRequirement)) {
           // required type
           builderMethod.addStatement(
-              "this.$N = $T.checkNotNull($L)",
-              builderFields.get(builderMethodType),
-              Preconditions.class,
-              parameterName);
+              "this.$N = $L",
+              builderFields.get(builderRequirement),
+              builderRequirement
+                      .nullPolicy(elements, types)
+                      .equals(ComponentRequirement.NullPolicy.ALLOW)
+                  ? parameterName
+                  : CodeBlock.of("$T.checkNotNull($L)", Preconditions.class, parameterName));
           addBuilderMethodReturnStatementForSpec(specMethod, builderMethod);
-        } else if (graph.ownedModuleTypes().contains(builderMethodType)) {
+        } else if (graph.ownedModuleTypes().contains(builderRequirement.typeElement())) {
           // owned, but not required
           builderMethod.addJavadoc(NOOP_BUILDER_METHOD_JAVADOC);
           addBuilderMethodReturnStatementForSpec(specMethod, builderMethod);
@@ -393,21 +467,21 @@ private void addBuilderMethods(
           // neither owned nor required, so it must be an inherited module
           builderMethod.addStatement(
               "throw new $T($T.format($S, $T.class.getCanonicalName()))",
-              UNSUPPORTED_OPERATION_EXCEPTION,
-              STRING,
+              UnsupportedOperationException.class,
+              String.class,
               "%s cannot be set because it is inherited from the enclosing component",
-              ClassName.get(builderMethodType));
+              TypeNames.rawTypeName(TypeName.get(builderRequirement.type())));
         }
         componentBuilder.addMethod(builderMethod.build());
       }
     } else {
-      for (TypeElement componentRequirement : graph.availableDependencies()) {
-        String componentRequirementName = simpleVariableName(componentRequirement);
+      for (ComponentRequirement componentRequirement : graph.availableDependencies()) {
+        String componentRequirementName = simpleVariableName(componentRequirement.typeElement());
         MethodSpec.Builder builderMethod =
             methodBuilder(componentRequirementName)
                 .returns(builderName.get())
                 .addModifiers(PUBLIC)
-                .addParameter(ClassName.get(componentRequirement), componentRequirementName);
+                .addParameter(ClassName.get(componentRequirement.type()), componentRequirementName);
         if (componentRequirements.contains(componentRequirement)) {
           builderMethod.addStatement(
               "this.$N = $T.checkNotNull($L)",
@@ -461,10 +535,80 @@ private void addBuilderMethodReturnStatementForSpec(
    */
   protected abstract void addFactoryMethods();
 
-  private void addFields() {
-    for (ResolvedBindings resolvedBindings : graph.resolvedBindings().values()) {
-      addField(resolvedBindings);
+  /**
+   * Adds a {@link dagger.internal.ReferenceReleasingProviderManager} field for every {@link
+   * CanReleaseReferences @ReleasableReferences} scope for which {@linkplain
+   * #requiresReleasableReferences(Scope) one is required}.
+   */
+  private void addReferenceReleasingProviderManagerFields() {
+    ImmutableMap.Builder<Scope, MemberSelect> fields = ImmutableMap.builder();
+    for (Scope scope : graph.componentDescriptor().releasableReferencesScopes()) {
+      if (requiresReleasableReferences(scope)) {
+        FieldSpec field = referenceReleasingProxyManagerField(scope);
+        component.addField(field);
+        fields.put(scope, localField(name, field.name));
+      }
+    }
+    referenceReleasingProviderManagerFields = fields.build();
+  }
+
+  /**
+   * Returns {@code true} if {@code scope} {@linkplain CanReleaseReferences can release its
+   * references} and there is a dependency request in the component for any of
+   *
+   * <ul>
+   * <li>{@code @ForReleasableReferences(scope)} {@link ReleasableReferenceManager}
+   * <li>{@code @ForReleasableReferences(scope)} {@code TypedReleasableReferenceManager<M>}, where
+   *     {@code M} is the releasable-references metatadata type for {@code scope}
+   * <li>{@code Set<ReleasableReferenceManager>}
+   * <li>{@code Set<TypedReleasableReferenceManager<M>>}, where {@code M} is the metadata type for
+   *     the scope
+   * </ul>
+   */
+  private boolean requiresReleasableReferences(Scope scope) {
+    if (!scope.canReleaseReferences()) {
+      return false;
+    }
+
+    if (graphHasContributionBinding(keyFactory.forReleasableReferenceManager(scope))
+        || graphHasContributionBinding(keyFactory.forSetOfReleasableReferenceManagers())) {
+      return true;
+    }
+
+    for (AnnotationMirror metadata : scope.releasableReferencesMetadata()) {
+      if (graphHasContributionBinding(
+              keyFactory.forTypedReleasableReferenceManager(scope, metadata.getAnnotationType()))
+          || graphHasContributionBinding(
+              keyFactory.forSetOfTypedReleasableReferenceManagers(metadata.getAnnotationType()))) {
+        return true;
+      }
     }
+
+    return false;
+  }
+
+  private boolean graphHasContributionBinding(Key key) {
+    return graph.resolvedBindings().containsKey(contribution(key));
+  }
+
+  private FieldSpec referenceReleasingProxyManagerField(Scope scope) {
+    return componentField(
+            REFERENCE_RELEASING_PROVIDER_MANAGER,
+            UPPER_CAMEL.to(
+                LOWER_CAMEL, scope.scopeAnnotationElement().getSimpleName() + "References"))
+        .addModifiers(PRIVATE, FINAL)
+        .initializer(
+            "new $T($T.class)",
+            REFERENCE_RELEASING_PROVIDER_MANAGER,
+            scope.scopeAnnotationElement())
+        .addJavadoc(
+            "The manager that releases references for the {@link $T} scope.\n",
+            scope.scopeAnnotationElement())
+        .build();
+  }
+
+  private void addFrameworkFields() {
+    graph.resolvedBindings().values().forEach(this::addField);
   }
 
   private void addField(ResolvedBindings resolvedBindings) {
@@ -485,7 +629,7 @@ private void addField(ResolvedBindings resolvedBindings) {
 
     // TODO(gak): get rid of the field for unscoped delegated bindings
 
-    FieldSpec frameworkField = addFrameworkField(resolvedBindings, Optional.<ClassName>absent());
+    FieldSpec frameworkField = addFrameworkField(resolvedBindings, Optional.empty());
     memberSelects.put(bindingKey, localField(name, frameworkField.name));
   }
 
@@ -507,7 +651,7 @@ private FieldSpec addFrameworkField(
             contributionBindingField.name());
     contributionField.addModifiers(PRIVATE);
     if (useRawType) {
-      contributionField.addAnnotation(AnnotationSpecs.SUPPRESS_WARNINGS_RAWTYPES);
+      contributionField.addAnnotation(AnnotationSpecs.suppressWarnings(RAWTYPES));
     }
 
     FieldSpec field = contributionField.build();
@@ -533,12 +677,12 @@ private boolean useRawType(Optional<String> bindingPackage) {
    * this method returns the static member select that returns the factory or no-op members
    * injector.
    */
-  private Optional<MemberSelect> staticMemberSelect(ResolvedBindings resolvedBindings) {
+  private static Optional<MemberSelect> staticMemberSelect(ResolvedBindings resolvedBindings) {
     BindingKey bindingKey = resolvedBindings.bindingKey();
     switch (bindingKey.kind()) {
       case CONTRIBUTION:
         ContributionBinding contributionBinding = resolvedBindings.contributionBinding();
-        if (contributionBinding.factoryCreationStrategy().equals(ENUM_INSTANCE)
+        if (contributionBinding.factoryCreationStrategy().equals(SINGLETON_INSTANCE)
             && !contributionBinding.scope().isPresent()) {
           switch (contributionBinding.bindingKind()) {
             case SYNTHETIC_MULTIBOUND_MAP:
@@ -546,7 +690,7 @@ private boolean useRawType(Optional<String> bindingPackage) {
               MapType mapType = MapType.from(contributionBinding.key());
               return Optional.of(
                   emptyFrameworkMapFactory(
-                      frameworkMapFactoryClassName(bindingType),
+                      bindingType,
                       mapType.keyType(),
                       mapType.unwrappedValueType(bindingType.frameworkClass())));
 
@@ -559,7 +703,7 @@ private boolean useRawType(Optional<String> bindingPackage) {
             case PROVISION:
               if (bindingKey.key().type().getKind().equals(DECLARED)) {
                 ImmutableList<TypeVariableName> typeVariables =
-                    SourceFiles.bindingTypeElementTypeVariableNames(contributionBinding);
+                    bindingTypeElementTypeVariableNames(contributionBinding);
                 if (!typeVariables.isEmpty()) {
                   List<? extends TypeMirror> typeArguments =
                       ((DeclaredType) bindingKey.key().type()).getTypeArguments();
@@ -567,12 +711,12 @@ private boolean useRawType(Optional<String> bindingPackage) {
                       generatedClassNameForBinding(contributionBinding), typeArguments));
                 }
               }
+              // fall through
 
             default:
               return Optional.of(
                   staticMethod(
-                      generatedClassNameForBinding(contributionBinding),
-                      CodeBlock.of("create()")));
+                      generatedClassNameForBinding(contributionBinding), CodeBlock.of("create()")));
           }
         }
         break;
@@ -581,7 +725,7 @@ private boolean useRawType(Optional<String> bindingPackage) {
         Optional<MembersInjectionBinding> membersInjectionBinding =
             resolvedBindings.membersInjectionBinding();
         if (membersInjectionBinding.isPresent()
-            && membersInjectionBinding.get().injectionStrategy().equals(NO_OP)) {
+            && membersInjectionBinding.get().injectionSites().isEmpty()) {
           return Optional.of(noOpMembersInjector(membersInjectionBinding.get().key().type()));
         }
         break;
@@ -589,7 +733,7 @@ private boolean useRawType(Optional<String> bindingPackage) {
       default:
         throw new AssertionError();
     }
-    return Optional.absent();
+    return Optional.empty();
   }
 
   /**
@@ -661,53 +805,38 @@ private void implementInterfaceMethods() {
         graph.componentDescriptor().componentMethods()) {
       if (componentMethod.dependencyRequest().isPresent()) {
         DependencyRequest interfaceRequest = componentMethod.dependencyRequest().get();
-        ExecutableElement requestElement =
-            MoreElements.asExecutable(interfaceRequest.requestElement());
-        ExecutableType requestType = MoreTypes.asExecutable(types.asMemberOf(
-            MoreTypes.asDeclared(componentDefinitionType().asType()), requestElement));
-        MethodSignature signature = MethodSignature.fromExecutableType(
-            requestElement.getSimpleName().toString(), requestType);
+        ExecutableElement methodElement =
+            MoreElements.asExecutable(componentMethod.methodElement());
+        ExecutableType requestType =
+            MoreTypes.asExecutable(
+                types.asMemberOf(
+                    MoreTypes.asDeclared(graph.componentType().asType()), methodElement));
+        MethodSignature signature =
+            MethodSignature.fromExecutableType(
+                methodElement.getSimpleName().toString(), requestType);
         if (!interfaceMethods.contains(signature)) {
           interfaceMethods.add(signature);
           MethodSpec.Builder interfaceMethod =
-              methodBuilder(requestElement.getSimpleName().toString())
-                  .addAnnotation(Override.class)
-                  .addModifiers(PUBLIC)
-                  .returns(TypeName.get(requestType.getReturnType()));
-          BindingKey bindingKey = interfaceRequest.bindingKey();
-          MemberSelect memberSelect = getMemberSelect(bindingKey);
-          CodeBlock memberSelectCodeBlock = memberSelect.getExpressionFor(name);
+              methodSpecForComponentMethod(methodElement, requestType);
+          RequestFulfillment fulfillment =
+              requestFulfillmentRegistry.getRequestFulfillment(interfaceRequest.bindingKey());
+          CodeBlock codeBlock = fulfillment.getSnippetForDependencyRequest(interfaceRequest, name);
           switch (interfaceRequest.kind()) {
             case MEMBERS_INJECTOR:
-              List<? extends VariableElement> parameters = requestElement.getParameters();
-              if (parameters.isEmpty()) {
-                // we're returning the framework type
-                interfaceMethod.addStatement("return $L", memberSelectCodeBlock);
-              } else {
-                Name parameterName = Iterables.getOnlyElement(parameters).getSimpleName();
-                interfaceMethod.addParameter(
-                    TypeName.get(Iterables.getOnlyElement(requestType.getParameterTypes())),
-                    parameterName.toString());
-                interfaceMethod.addStatement(
-                    "$L.injectMembers($L)", memberSelectCodeBlock, parameterName);
+              List<? extends VariableElement> parameters = methodElement.getParameters();
+              if (!parameters.isEmpty()) {
+                Name parameterName =
+                    Iterables.getOnlyElement(methodElement.getParameters()).getSimpleName();
+                interfaceMethod.addStatement("$L.injectMembers($L)", codeBlock, parameterName);
                 if (!requestType.getReturnType().getKind().equals(VOID)) {
                   interfaceMethod.addStatement("return $L", parameterName);
                 }
+                break;
               }
-              break;
-            case INSTANCE:
-            case LAZY:
-            case PRODUCED:
-            case PRODUCER:
-            case PROVIDER:
-            case PROVIDER_OF_LAZY:
-            case FUTURE:
-              interfaceMethod.addStatement(
-                  "return $L",
-                  frameworkTypeUsageStatement(memberSelectCodeBlock, interfaceRequest.kind()));
-              break;
+              // fall through
             default:
-              throw new AssertionError();
+              interfaceMethod.addStatement("return $L", codeBlock);
+              break;
           }
           component.addMethod(interfaceMethod.build());
         }
@@ -715,10 +844,47 @@ private void implementInterfaceMethods() {
     }
   }
 
+  private MethodSpec.Builder methodSpecForComponentMethod(
+      ExecutableElement method, ExecutableType methodType) {
+    String methodName = method.getSimpleName().toString();
+    MethodSpec.Builder methodBuilder = MethodSpec.methodBuilder(methodName);
+
+    methodBuilder.addAnnotation(Override.class);
+
+    Set<Modifier> modifiers = EnumSet.copyOf(method.getModifiers());
+    modifiers.remove(Modifier.ABSTRACT);
+    methodBuilder.addModifiers(modifiers);
+
+    methodBuilder.returns(TypeName.get(methodType.getReturnType()));
+
+    List<? extends VariableElement> parameters = method.getParameters();
+    List<? extends TypeMirror> resolvedParameterTypes = methodType.getParameterTypes();
+    verify(parameters.size() == resolvedParameterTypes.size());
+    for (int i = 0; i < parameters.size(); i++) {
+      VariableElement parameter = parameters.get(i);
+      TypeName type = TypeName.get(resolvedParameterTypes.get(i));
+      String name = parameter.getSimpleName().toString();
+      Set<Modifier> parameterModifiers = parameter.getModifiers();
+      ParameterSpec.Builder parameterBuilder =
+          ParameterSpec.builder(type, name)
+              .addModifiers(parameterModifiers.toArray(new Modifier[0]));
+      methodBuilder.addParameter(parameterBuilder.build());
+    }
+    for (TypeMirror thrownType : method.getThrownTypes()) {
+      methodBuilder.addException(TypeName.get(thrownType));
+    }
+    return methodBuilder;
+  }
+
   private void addSubcomponents() {
-    for (Map.Entry<ExecutableElement, BindingGraph> subgraphEntry : graph.subgraphs().entrySet()) {
+    for (BindingGraph subgraph : graph.subgraphs()) {
+      ComponentMethodDescriptor componentMethodDescriptor =
+          graph.componentDescriptor()
+              .subcomponentsByFactoryMethod()
+              .inverse()
+              .get(subgraph.componentDescriptor());
       SubcomponentWriter subcomponent =
-          new SubcomponentWriter(this, subgraphEntry.getKey(), subgraphEntry.getValue());
+          new SubcomponentWriter(this, Optional.ofNullable(componentMethodDescriptor), subgraph);
       component.addType(subcomponent.write().build());
     }
   }
@@ -728,7 +894,7 @@ private void addSubcomponents() {
   private void initializeFrameworkTypes() {
     ImmutableList.Builder<CodeBlock> codeBlocks = ImmutableList.builder();
     for (BindingKey bindingKey : graph.resolvedBindings().keySet()) {
-      codeBlocks.addAll(initializeFrameworkType(bindingKey).asSet());
+      initializeFrameworkType(bindingKey).ifPresent(codeBlocks::add);
     }
     List<List<CodeBlock>> partitions =
         Lists.partition(codeBlocks.build(), INITIALIZATIONS_PER_INITIALIZE_METHOD);
@@ -743,7 +909,7 @@ private void initializeFrameworkTypes() {
                * initializing a raw field in this method, but the structure of this code makes it
                * awkward to pass that bit through.  This will be cleaned up when we no longer
                * separate fields and initilization as we do now. */
-              .addAnnotation(SUPPRESS_WARNINGS_UNCHECKED)
+              .addAnnotation(AnnotationSpecs.suppressWarnings(UNCHECKED))
               .addCode(CodeBlocks.concat(partition));
       if (builderName.isPresent()) {
         initializeMethod.addParameter(builderName.get(), "builder", FINAL);
@@ -767,7 +933,7 @@ private void initializeFrameworkTypes() {
     // If the field is inherited or the member select is static, don't initialize.
     MemberSelect memberSelect = getMemberSelect(bindingKey);
     if (memberSelect.staticMember() || !memberSelect.owningClass().equals(name)) {
-      return Optional.absent();
+      return Optional.empty();
     }
 
     switch (bindingKey.kind()) {
@@ -788,11 +954,12 @@ private void initializeFrameworkTypes() {
      * called before we get the code block that initializes the member. */
     switch (binding.factoryCreationStrategy()) {
       case DELEGATE:
-        CodeBlock delegatingCodeBlock = CodeBlock.of(
-            "($T) $L",
-            binding.frameworkClass(),
-            getMemberSelect(
-                Iterables.getOnlyElement(binding.dependencies()).bindingKey())
+        CodeBlock delegatingCodeBlock =
+            CodeBlock.of(
+                "($T) $L",
+                binding.bindingType().frameworkClass(),
+                getMemberSelect(
+                        Iterables.getOnlyElement(binding.explicitDependencies()).bindingKey())
                     .getExpressionFor(name));
         return Optional.of(
             CodeBlocks.concat(
@@ -803,9 +970,9 @@ private void initializeFrameworkTypes() {
                         binding.scope().isPresent()
                             ? decorateForScope(delegatingCodeBlock, binding.scope().get())
                             : delegatingCodeBlock))));
-      case ENUM_INSTANCE:
+      case SINGLETON_INSTANCE:
         if (!binding.scope().isPresent()) {
-          return Optional.absent();
+          return Optional.empty();
         }
         // fall through
       case CLASS_CONSTRUCTOR:
@@ -824,8 +991,8 @@ private void initializeFrameworkTypes() {
     MembersInjectionBinding binding =
         graph.resolvedBindings().get(bindingKey).membersInjectionBinding().get();
 
-    if (binding.injectionStrategy().equals(MembersInjectionBinding.Strategy.NO_OP)) {
-      return Optional.absent();
+    if (binding.injectionSites().isEmpty()) {
+      return Optional.empty();
     }
 
     return Optional.of(
@@ -854,8 +1021,8 @@ private CodeBlock initializeDelegateFactoriesForUninitializedDependencies(Bindin
     ImmutableList.Builder<CodeBlock> initializations = ImmutableList.builder();
 
     for (BindingKey dependencyKey :
-        FluentIterable.from(binding.implicitDependencies())
-            .transform(DependencyRequest.BINDING_KEY_FUNCTION)
+        FluentIterable.from(binding.dependencies())
+            .transform(DependencyRequest::bindingKey)
             .toSet()) {
       if (!getMemberSelect(dependencyKey).staticMember()
           && getInitializationState(dependencyKey).equals(UNINITIALIZED)) {
@@ -871,7 +1038,7 @@ private CodeBlock initializeDelegateFactoriesForUninitializedDependencies(Bindin
 
   private CodeBlock initializeProducersFromProviderDependencies(Binding binding) {
     ImmutableList.Builder<CodeBlock> initializations = ImmutableList.builder();
-    for (FrameworkDependency frameworkDependency : frameworkDependenciesForBinding(binding)) {
+    for (FrameworkDependency frameworkDependency : binding.frameworkDependencies()) {
       ResolvedBindings resolvedBindings =
           graph.resolvedBindings().get(frameworkDependency.bindingKey());
       if (resolvedBindings.frameworkClass().equals(Provider.class)
@@ -887,10 +1054,11 @@ private CodeBlock initializeProducersFromProviderDependencies(Binding binding) {
         producerFromProviderMemberSelects.put(frameworkDependency.bindingKey(), memberSelect);
         initializations.add(
             CodeBlock.of(
-                "this.$L = $T.producerFromProvider($L);",
+                "this.$L = $L;",
                 memberSelect.getExpressionFor(name),
-                PRODUCERS,
-                getMemberSelectExpression(frameworkDependency.bindingKey())));
+                requestFulfillmentRegistry
+                    .getRequestFulfillment(frameworkDependency.bindingKey())
+                    .getSnippetForFrameworkDependency(frameworkDependency, name)));
       }
     }
     return CodeBlocks.concat(initializations.build());
@@ -932,18 +1100,15 @@ private CodeBlock initializeFactoryForContributionBinding(ContributionBinding bi
             bindingKeyTypeName.equals(componentDefinitionTypeName())
                 ? "this"
                 : getComponentContributionExpression(
-                    MoreTypes.asTypeElement(binding.key().type())));
+                    ComponentRequirement.forDependency(binding.key().type())));
 
       case COMPONENT_PROVISION:
         {
-          TypeElement bindingTypeElement =
-              graph.componentDescriptor().dependencyMethodIndex().get(binding.bindingElement());
-          String localFactoryVariable = simpleVariableName(bindingTypeElement);
+          TypeElement dependencyType = dependencyTypeForBinding(binding);
+          String dependencyVariable = simpleVariableName(dependencyType);
           CodeBlock callFactoryMethod =
               CodeBlock.of(
-                  "$L.$L()",
-                  localFactoryVariable,
-                  binding.bindingElement().getSimpleName().toString());
+                  "$L.$L()", dependencyVariable, binding.bindingElement().get().getSimpleName());
           // TODO(sameb): This throws a very vague NPE right now.  The stack trace doesn't
           // help to figure out what the method or return type is.  If we include a string
           // of the return type or method name in the error message, that can defeat obfuscation.
@@ -954,49 +1119,69 @@ private CodeBlock initializeFactoryForContributionBinding(ContributionBinding bi
               binding.nullableType().isPresent()
                       || compilerOptions.nullableValidationKind().equals(Diagnostic.Kind.WARNING)
                   ? CodeBlock.of("return $L;", callFactoryMethod)
-                  : CodeBlock.of("return $T.checkNotNull($L, $S);",
+                  : CodeBlock.of(
+                      "return $T.checkNotNull($L, $S);",
                       Preconditions.class,
                       callFactoryMethod,
                       CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD);
           return CodeBlock.of(
               Joiner.on('\n')
                   .join(
-                      "new $1T<$2T>() {",
+                      "new $1L<$2T>() {",
                       "  private final $5T $6L = $3L;",
                       "  $4L@Override public $2T get() {",
                       "    $7L",
                       "  }",
                       "}"),
-              /* 1 */ FACTORY,
+              // TODO(ronshapiro): Until we remove Factory, fully qualify the import so it doesn't
+              // conflict with anyone that has Factory as an inner type of a component (like
+              // AndroidInjector.Factory
+              /* 1 */ "dagger.internal.Factory",
               /* 2 */ bindingKeyTypeName,
-              /* 3 */ getComponentContributionExpression(bindingTypeElement),
+              /* 3 */ getComponentContributionExpression(
+                  ComponentRequirement.forDependency(dependencyType.asType())),
               /* 4 */ nullableAnnotation(binding.nullableType()),
-              /* 5 */ TypeName.get(bindingTypeElement.asType()),
-              /* 6 */ localFactoryVariable,
+              /* 5 */ TypeName.get(dependencyType.asType()),
+              /* 6 */ dependencyVariable,
               /* 7 */ getMethodBody);
         }
 
       case SUBCOMPONENT_BUILDER:
+        String subcomponentName =
+            subcomponentNames.get(
+                graph.componentDescriptor()
+                    .subcomponentsByBuilderType()
+                    .get(MoreTypes.asTypeElement(binding.key().type())));
         return CodeBlock.of(
             Joiner.on('\n')
                 .join(
-                    "new $1T<$2T>() {",
+                    "new $1L<$2T>() {",
                     "  @Override public $2T get() {",
-                    "    return $3L();",
+                    "    return new $3LBuilder();",
                     "  }",
                     "}"),
-            /* 1 */ FACTORY,
+            // TODO(ronshapiro): Until we remove Factory, fully qualify the import so it doesn't
+            // conflict with dagger.android.ActivityInjector.Factory
+            /* 1 */ "dagger.internal.Factory",
             /* 2 */ bindingKeyTypeName,
-            /* 3 */ binding.bindingElement().getSimpleName().toString());
+            /* 3 */ subcomponentName);
+
+      case BUILDER_BINDING:
+        return CodeBlock.of(
+            "$T.$L($L)",
+            InstanceFactory.class,
+            binding.nullableType().isPresent() ? "createNullable" : "create",
+            getComponentContributionExpression(ComponentRequirement.forBinding(binding)));
 
       case INJECTION:
       case PROVISION:
         {
           List<CodeBlock> arguments =
-              Lists.newArrayListWithCapacity(binding.dependencies().size() + 1);
-          if (binding.bindingKind().equals(PROVISION)
-              && !binding.bindingElement().getModifiers().contains(STATIC)) {
-            arguments.add(getComponentContributionExpression(binding.contributingModule().get()));
+              Lists.newArrayListWithCapacity(binding.explicitDependencies().size() + 1);
+          if (binding.requiresModuleInstance()) {
+            arguments.add(
+                getComponentContributionExpression(
+                    ComponentRequirement.forModule(binding.contributingModule().get().asType())));
           }
           arguments.addAll(getDependencyArguments(binding));
 
@@ -1012,8 +1197,7 @@ private CodeBlock initializeFactoryForContributionBinding(ContributionBinding bi
 
       case COMPONENT_PRODUCTION:
         {
-          TypeElement bindingTypeElement =
-              graph.componentDescriptor().dependencyMethodIndex().get(binding.bindingElement());
+          TypeElement dependencyType = dependencyTypeForBinding(binding);
           return CodeBlock.of(
               Joiner.on('\n')
                   .join(
@@ -1026,19 +1210,21 @@ private CodeBlock initializeFactoryForContributionBinding(ContributionBinding bi
               /* 1 */ PRODUCER,
               /* 2 */ TypeName.get(binding.key().type()),
               /* 3 */ LISTENABLE_FUTURE,
-              /* 4 */ getComponentContributionExpression(bindingTypeElement),
-              /* 5 */ binding.bindingElement().getSimpleName().toString(),
-              /* 6 */ TypeName.get(bindingTypeElement.asType()),
-              /* 7 */ simpleVariableName(bindingTypeElement));
+              /* 4 */ getComponentContributionExpression(
+                  ComponentRequirement.forDependency(dependencyType.asType())),
+              /* 5 */ binding.bindingElement().get().getSimpleName(),
+              /* 6 */ TypeName.get(dependencyType.asType()),
+              /* 7 */ simpleVariableName(dependencyType));
         }
 
-      case IMMEDIATE:
-      case FUTURE_PRODUCTION:
+      case PRODUCTION:
         {
           List<CodeBlock> arguments =
-              Lists.newArrayListWithCapacity(binding.implicitDependencies().size() + 2);
-          if (!binding.bindingElement().getModifiers().contains(STATIC)) {
-            arguments.add(getComponentContributionExpression(binding.bindingTypeElement()));
+              Lists.newArrayListWithCapacity(binding.dependencies().size() + 2);
+          if (binding.requiresModuleInstance()) {
+            arguments.add(
+                getComponentContributionExpression(
+                    ComponentRequirement.forModule(binding.contributingModule().get().asType())));
           }
           arguments.addAll(getDependencyArguments(binding));
 
@@ -1049,10 +1235,13 @@ private CodeBlock initializeFactoryForContributionBinding(ContributionBinding bi
         }
 
       case SYNTHETIC_MAP:
+        FrameworkDependency frameworkDependency = getOnlyElement(binding.frameworkDependencies());
         return CodeBlock.of(
             "$T.create($L)",
             mapFactoryClassName(binding),
-            getMemberSelectExpression(getOnlyElement(binding.dependencies()).bindingKey()));
+            requestFulfillmentRegistry
+                .getRequestFulfillment(frameworkDependency.bindingKey())
+                .getSnippetForFrameworkDependency(frameworkDependency, name));
 
       case SYNTHETIC_MULTIBOUND_SET:
         return initializeFactoryForSetMultibinding(binding);
@@ -1060,16 +1249,37 @@ private CodeBlock initializeFactoryForContributionBinding(ContributionBinding bi
       case SYNTHETIC_MULTIBOUND_MAP:
         return initializeFactoryForMapMultibinding(binding);
 
+      case SYNTHETIC_RELEASABLE_REFERENCE_MANAGER:
+        return initializeFactoryForSyntheticReleasableReferenceManagerBinding(binding);
+
+      case SYNTHETIC_RELEASABLE_REFERENCE_MANAGERS:
+        return initializeFactoryForSyntheticSetOfReleasableReferenceManagers(binding);
+
+      case SYNTHETIC_OPTIONAL_BINDING:
+        return initializeFactoryForSyntheticOptionalBinding(binding);
+
       default:
-        throw new AssertionError(binding.toString());
+        throw new AssertionError(binding);
     }
   }
 
+  private TypeElement dependencyTypeForBinding(ContributionBinding binding) {
+    return graph.componentDescriptor().dependencyMethodIndex().get(binding.bindingElement().get());
+  }
+
   private CodeBlock decorateForScope(CodeBlock factoryCreate, Scope scope) {
-    return CodeBlock.of(
-        "$T.provider($L)",
-        scope.equals(reusableScope(elements)) ? SINGLE_CHECK : DOUBLE_CHECK,
-        factoryCreate);
+    if (requiresReleasableReferences(scope)) {
+      return CodeBlock.of(
+          "$T.create($L, $L)",
+          REFERENCE_RELEASING_PROVIDER,
+          factoryCreate,
+          getReferenceReleasingProviderManagerExpression(scope));
+    } else {
+      return CodeBlock.of(
+          "$T.provider($L)",
+          scope.equals(reusableScope(elements)) ? SINGLE_CHECK : DOUBLE_CHECK,
+          factoryCreate);
+    }
   }
 
   private CodeBlock nullableAnnotation(Optional<DeclaredType> nullableType) {
@@ -1079,17 +1289,12 @@ private CodeBlock nullableAnnotation(Optional<DeclaredType> nullableType) {
   }
 
   private CodeBlock initializeMembersInjectorForBinding(MembersInjectionBinding binding) {
-    switch (binding.injectionStrategy()) {
-      case NO_OP:
-        return CodeBlock.of("$T.noOp()", MEMBERS_INJECTORS);
-      case INJECT_MEMBERS:
-        return CodeBlock.of(
+    return binding.injectionSites().isEmpty()
+        ? CodeBlock.of("$T.noOp()", MEMBERS_INJECTORS)
+        : CodeBlock.of(
             "$T.create($L)",
             membersInjectorNameForType(binding.membersInjectedType()),
             makeParametersCodeBlock(getDependencyArguments(binding)));
-      default:
-        throw new AssertionError();
-    }
   }
 
   /**
@@ -1097,15 +1302,13 @@ private CodeBlock initializeMembersInjectorForBinding(MembersInjectionBinding bi
    */
   private ImmutableList<CodeBlock> getDependencyArguments(Binding binding) {
     ImmutableList.Builder<CodeBlock> parameters = ImmutableList.builder();
-    for (FrameworkDependency frameworkDependency : frameworkDependenciesForBinding(binding)) {
+    for (FrameworkDependency frameworkDependency : binding.frameworkDependencies()) {
       parameters.add(getDependencyArgument(frameworkDependency));
     }
     return parameters.build();
   }
 
-  /**
-   * The expression to use as an argument for a dependency.
-   */
+  /** Returns the expression to use as an argument for a dependency. */
   private CodeBlock getDependencyArgument(FrameworkDependency frameworkDependency) {
     BindingKey requestedKey = frameworkDependency.bindingKey();
     ResolvedBindings resolvedBindings = graph.resolvedBindings().get(requestedKey);
@@ -1113,7 +1316,9 @@ private CodeBlock getDependencyArgument(FrameworkDependency frameworkDependency)
         && frameworkDependency.frameworkClass().equals(Producer.class)) {
       return producerFromProviderMemberSelects.get(requestedKey).getExpressionFor(name);
     } else {
-      return getMemberSelectExpression(requestedKey);
+      RequestFulfillment requestFulfillment =
+          requestFulfillmentRegistry.getRequestFulfillment(requestedKey);
+      return requestFulfillment.getSnippetForFrameworkDependency(frameworkDependency, name);
     }
   }
 
@@ -1132,7 +1337,7 @@ private CodeBlock initializeFactoryForSetMultibinding(ContributionBinding bindin
     int individualProviders = 0;
     int setProviders = 0;
     CodeBlock.Builder builderMethodCalls = CodeBlock.builder();
-    for (FrameworkDependency frameworkDependency : frameworkDependenciesForBinding(binding)) {
+    for (FrameworkDependency frameworkDependency : binding.frameworkDependencies()) {
       ContributionType contributionType =
           graph.resolvedBindings().get(frameworkDependency.bindingKey()).contributionType();
       String methodName;
@@ -1164,8 +1369,7 @@ private CodeBlock initializeFactoryForSetMultibinding(ContributionBinding bindin
   }
 
   private CodeBlock initializeFactoryForMapMultibinding(ContributionBinding binding) {
-    ImmutableSet<FrameworkDependency> frameworkDependencies =
-        FrameworkDependency.frameworkDependenciesForBinding(binding);
+    ImmutableList<FrameworkDependency> frameworkDependencies = binding.frameworkDependencies();
 
     ImmutableList.Builder<CodeBlock> codeBlocks = ImmutableList.builder();
     MapType mapType = MapType.from(binding.key().type());
@@ -1188,10 +1392,6 @@ private CodeBlock initializeFactoryForMapMultibinding(ContributionBinding bindin
               useRawTypes,
               frameworkDependency.frameworkClass(),
               getDependencyArgument(frameworkDependency));
-      if (binding.bindingType().frameworkClass().equals(Producer.class)
-          && frameworkDependency.frameworkClass().equals(Provider.class)) {
-        value = CodeBlock.of("$T.producerFromProvider($L)", PRODUCERS, value);
-      }
       codeBlocks.add(
           CodeBlock.of(
               ".put($L, $L)", getMapKeyExpression(contributionBinding.mapKey().get()), value));
@@ -1208,8 +1408,137 @@ private CodeBlock potentiallyCast(boolean shouldCast, Class<?> classToCast, Code
     return CodeBlock.of("($T) $L", classToCast, notCasted);
   }
 
-  private static String simpleVariableName(TypeElement typeElement) {
-    return UPPER_CAMEL.to(LOWER_CAMEL, typeElement.getSimpleName().toString());
+  /**
+   * Initializes the factory for a {@link
+   * ContributionBinding.Kind#SYNTHETIC_RELEASABLE_REFERENCE_MANAGER} binding.
+   *
+   * <p>The {@code get()} method just returns the component field with the {@link
+   * dagger.internal.ReferenceReleasingProviderManager} object.
+   */
+  private CodeBlock initializeFactoryForSyntheticReleasableReferenceManagerBinding(
+      ContributionBinding binding) {
+    // The scope is the value of the @ForReleasableReferences annotation.
+    Scope scope = forReleasableReferencesAnnotationValue(binding.key().qualifier().get());
+
+    CodeBlock managerExpression;
+    if (MoreTypes.isTypeOf(TypedReleasableReferenceManager.class, binding.key().type())) {
+      /* The key's type is TypedReleasableReferenceManager<M>, so return
+       * new TypedReleasableReferenceManager(field, metadata). */
+      TypeMirror metadataType =
+          MoreTypes.asDeclared(binding.key().type()).getTypeArguments().get(0);
+      managerExpression =
+          typedReleasableReferenceManagerDecoratorExpression(
+              getReferenceReleasingProviderManagerExpression(scope),
+              scope.releasableReferencesMetadata(metadataType).get());
+    } else {
+      // The key's type is ReleasableReferenceManager, so return the field as is.
+      managerExpression = getReferenceReleasingProviderManagerExpression(scope);
+    }
+
+    TypeName keyType = TypeName.get(binding.key().type());
+    return CodeBlock.of(
+        "$L",
+        anonymousClassBuilder("")
+            .addSuperinterface(providerOf(keyType))
+            .addMethod(
+                methodBuilder("get")
+                    .addAnnotation(Override.class)
+                    .addModifiers(PUBLIC)
+                    .returns(keyType)
+                    .addCode("return $L;", managerExpression)
+                    .build())
+            .build());
+  }
+
+  /**
+   * Initializes the factory for a {@link
+   * ContributionBinding.Kind#SYNTHETIC_RELEASABLE_REFERENCE_MANAGERS} binding.
+   *
+   * <p>A binding for {@code Set<ReleasableReferenceManager>} will include managers for all
+   * reference-releasing scopes. A binding for {@code Set<TypedReleasableReferenceManager<M>>} will
+   * include managers for all reference-releasing scopes whose metadata type is {@code M}.
+   */
+  private CodeBlock initializeFactoryForSyntheticSetOfReleasableReferenceManagers(
+      ContributionBinding binding) {
+    Key key = binding.key();
+    SetType keyType = SetType.from(key);
+    ImmutableList.Builder<CodeBlock> managerExpressions = ImmutableList.builder();
+    for (Map.Entry<Scope, MemberSelect> entry :
+        referenceReleasingProviderManagerFields.entrySet()) {
+      Scope scope = entry.getKey();
+      CodeBlock releasableReferenceManagerExpression = entry.getValue().getExpressionFor(name);
+
+      if (keyType.elementsAreTypeOf(ReleasableReferenceManager.class)) {
+        managerExpressions.add(releasableReferenceManagerExpression);
+      } else if (keyType.elementsAreTypeOf(TypedReleasableReferenceManager.class)) {
+        TypeMirror metadataType =
+            keyType.unwrappedElementType(TypedReleasableReferenceManager.class);
+        Optional<AnnotationMirror> metadata = scope.releasableReferencesMetadata(metadataType);
+        if (metadata.isPresent()) {
+          managerExpressions.add(
+              typedReleasableReferenceManagerDecoratorExpression(
+                  releasableReferenceManagerExpression, metadata.get()));
+        }
+      } else {
+        throw new IllegalArgumentException("inappropriate key: " + binding);
+      }
+    }
+    TypeName keyTypeName = TypeName.get(key.type());
+    return CodeBlock.of(
+        "$L",
+        anonymousClassBuilder("")
+            .addSuperinterface(providerOf(keyTypeName))
+            .addMethod(
+                methodBuilder("get")
+                    .addAnnotation(Override.class)
+                    .addModifiers(PUBLIC)
+                    .returns(keyTypeName)
+                    .addCode(
+                        "return new $T($T.asList($L));",
+                        HashSet.class,
+                        Arrays.class,
+                        makeParametersCodeBlock(managerExpressions.build()))
+                    .build())
+            .build());
+  }
+
+  /**
+   * Returns an expression that evaluates to a {@link TypedReleasableReferenceManagerDecorator} that
+   * decorates the {@code managerExpression} to supply {@code metadata}.
+   */
+  private CodeBlock typedReleasableReferenceManagerDecoratorExpression(
+      CodeBlock managerExpression, AnnotationMirror metadata) {
+    return CodeBlock.of(
+        "new $T($L, $L)",
+        ParameterizedTypeName.get(
+            TYPED_RELEASABLE_REFERENCE_MANAGER_DECORATOR,
+            TypeName.get(metadata.getAnnotationType())),
+        managerExpression,
+        new AnnotationExpression(metadata).getAnnotationInstanceExpression());
+  }
+
+  private Scope forReleasableReferencesAnnotationValue(AnnotationMirror annotation) {
+    checkArgument(
+        MoreTypes.isTypeOf(ForReleasableReferences.class, annotation.getAnnotationType()));
+    return Scope.scope(
+        MoreElements.asType(MoreTypes.asDeclared(getTypeValue(annotation, "value")).asElement()));
+  }
+
+  /**
+   * Returns an expression that initializes a {@link Provider} or {@link Producer} for an optional
+   * binding.
+   */
+  private CodeBlock initializeFactoryForSyntheticOptionalBinding(ContributionBinding binding) {
+    if (binding.explicitDependencies().isEmpty()) {
+      verify(
+          binding.bindingType().equals(BindingType.PROVISION),
+          "Absent optional bindings should be provisions: %s",
+          binding);
+      return optionalFactories.absentOptionalProvider(binding);
+    } else {
+      return optionalFactories.presentOptionalFactory(
+          binding, getOnlyElement(getDependencyArguments(binding)));
+    }
   }
 
   /**
diff --git a/compiler/src/main/java/dagger/internal/codegen/Accessibility.java b/compiler/src/main/java/dagger/internal/codegen/Accessibility.java
index 0ce9230b0..558b58f12 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Accessibility.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Accessibility.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,9 +13,16 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal.codegen;
 
+import static com.google.auto.common.MoreElements.getPackage;
+import static com.google.common.base.Preconditions.checkArgument;
+import static javax.lang.model.element.Modifier.PRIVATE;
+import static javax.lang.model.element.Modifier.PUBLIC;
+
 import com.google.auto.common.MoreElements;
+import java.util.Optional;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ElementKind;
 import javax.lang.model.element.ExecutableElement;
@@ -30,14 +37,11 @@
 import javax.lang.model.type.PrimitiveType;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.type.TypeVariable;
+import javax.lang.model.type.TypeVisitor;
 import javax.lang.model.type.WildcardType;
 import javax.lang.model.util.SimpleElementVisitor6;
 import javax.lang.model.util.SimpleTypeVisitor6;
-
-import static com.google.auto.common.MoreElements.getPackage;
-import static com.google.common.base.Preconditions.checkArgument;
-import static javax.lang.model.element.Modifier.PRIVATE;
-import static javax.lang.model.element.Modifier.PUBLIC;
+import javax.lang.model.util.SimpleTypeVisitor8;
 
 /**
  * Utility methods for determining whether a {@linkplain TypeMirror type} or an {@linkplain Element
@@ -55,17 +59,35 @@
  * preferable for {@code javac}.
  */
 final class Accessibility {
+
   /**
    * Returns true if the given type can be referenced from code in the given package.
    */
   static boolean isTypeAccessibleFrom(TypeMirror type, String packageName) {
-    return type.accept(new TypeAccessiblityVisitor(packageName), null);
+    return type.accept(new TypeAccessibilityVisitor(packageName), null);
+  }
+
+  /** Returns true if the given type can be referenced from any package. */
+  static boolean isTypePubliclyAccessible(TypeMirror type) {
+    return type.accept(new TypeAccessibilityVisitor(), null);
+  }
+
+  private static boolean isTypeAccessibleFrom(TypeMirror type, Optional<String> packageName) {
+    return type.accept(new TypeAccessibilityVisitor(packageName), null);
   }
 
-  private static final class TypeAccessiblityVisitor extends SimpleTypeVisitor6<Boolean, Void> {
-    final String packageName;
+  private static final class TypeAccessibilityVisitor extends SimpleTypeVisitor6<Boolean, Void> {
+    final Optional<String> packageName;
+
+    TypeAccessibilityVisitor() {
+      this(Optional.empty());
+    }
+
+    TypeAccessibilityVisitor(String packageName) {
+      this(Optional.of(packageName));
+    }
 
-    TypeAccessiblityVisitor(String packageName) {
+    TypeAccessibilityVisitor(Optional<String> packageName) {
       this.packageName = packageName;
     }
 
@@ -134,11 +156,18 @@ protected Boolean defaultAction(TypeMirror type, Void p) {
     }
   }
 
-  /**
-   * Returns true if the given element can be referenced from code in the given package.
-   */
+  /** Returns true if the given element can be referenced from code in the given package. */
   //TODO(gak): account for protected
-  static boolean isElementAccessibleFrom(Element element, final String packageName) {
+  static boolean isElementAccessibleFrom(Element element, String packageName) {
+    return element.accept(new ElementAccessibilityVisitor(packageName), null);
+  }
+
+  /** Returns true if the given element can be referenced from any package. */
+  static boolean isElementPubliclyAccessible(Element element) {
+    return element.accept(new ElementAccessibilityVisitor(), null);
+  }
+
+  private static boolean isElementAccessibleFrom(Element element, Optional<String> packageName) {
     return element.accept(new ElementAccessibilityVisitor(packageName), null);
   }
 
@@ -150,9 +179,17 @@ static boolean isElementAccessibleFromOwnPackage(Element element) {
 
   private static final class ElementAccessibilityVisitor
       extends SimpleElementVisitor6<Boolean, Void> {
-    final String packageName;
+    final Optional<String> packageName;
+
+    ElementAccessibilityVisitor() {
+      this(Optional.empty());
+    }
 
     ElementAccessibilityVisitor(String packageName) {
+      this(Optional.of(packageName));
+    }
+
+    ElementAccessibilityVisitor(Optional<String> packageName) {
       this.packageName = packageName;
     }
 
@@ -188,7 +225,8 @@ boolean accessibleModifiers(Element element) {
         return true;
       } else if (element.getModifiers().contains(PRIVATE)) {
         return false;
-      } else if (getPackage(element).getQualifiedName().contentEquals(packageName)) {
+      } else if (packageName.isPresent()
+          && getPackage(element).getQualifiedName().contentEquals(packageName.get())) {
         return true;
       } else {
         return false;
@@ -214,6 +252,29 @@ public Boolean visitVariable(VariableElement element, Void p) {
     }
   }
 
+  private static final TypeVisitor<Boolean, Optional<String>> RAW_TYPE_ACCESSIBILITY_VISITOR =
+      new SimpleTypeVisitor8<Boolean, Optional<String>>() {
+        @Override
+        protected Boolean defaultAction(TypeMirror e, Optional<String> requestingPackage) {
+          return isTypeAccessibleFrom(e, requestingPackage);
+        }
+
+        @Override
+        public Boolean visitDeclared(DeclaredType t, Optional<String> requestingPackage) {
+          return isElementAccessibleFrom(t.asElement(), requestingPackage);
+        }
+      };
+
+  /** Returns true if the raw type of {@code type} is accessible from the given package. */
+  static boolean isRawTypeAccessible(TypeMirror type, String requestingPackage) {
+    return type.accept(RAW_TYPE_ACCESSIBILITY_VISITOR, Optional.of(requestingPackage));
+  }
+
+  /** Returns true if the raw type of {@code type} is accessible from any package. */
+  static boolean isRawTypePubliclyAccessible(TypeMirror type) {
+    return type.accept(RAW_TYPE_ACCESSIBILITY_VISITOR, Optional.empty());
+  }
+
   private Accessibility() {}
 }
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/MapKeyGenerator.java b/compiler/src/main/java/dagger/internal/codegen/AnnotationCreatorGenerator.java
similarity index 55%
rename from compiler/src/main/java/dagger/internal/codegen/MapKeyGenerator.java
rename to compiler/src/main/java/dagger/internal/codegen/AnnotationCreatorGenerator.java
index 1f3195e04..c5051bc12 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MapKeyGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AnnotationCreatorGenerator.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Google, Inc.
+ * Copyright (C) 2014 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,12 +13,22 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal.codegen;
 
+import static com.squareup.javapoet.MethodSpec.constructorBuilder;
+import static com.squareup.javapoet.MethodSpec.methodBuilder;
+import static com.squareup.javapoet.TypeSpec.classBuilder;
+import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
+import static dagger.internal.codegen.SourceFiles.classFileName;
+import static javax.lang.model.element.Modifier.FINAL;
+import static javax.lang.model.element.Modifier.PRIVATE;
+import static javax.lang.model.element.Modifier.PUBLIC;
+import static javax.lang.model.element.Modifier.STATIC;
+import static javax.lang.model.util.ElementFilter.methodsIn;
+
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoAnnotation;
-import com.google.auto.value.AutoValue;
-import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableList;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import com.squareup.javapoet.ClassName;
@@ -26,9 +36,8 @@
 import com.squareup.javapoet.MethodSpec;
 import com.squareup.javapoet.TypeName;
 import com.squareup.javapoet.TypeSpec;
-import dagger.MapKey;
-import dagger.internal.codegen.MapKeyGenerator.MapKeyCreatorSpecification;
 import java.util.LinkedHashSet;
+import java.util.Optional;
 import java.util.Set;
 import javax.annotation.processing.Filer;
 import javax.lang.model.element.Element;
@@ -39,93 +48,76 @@
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.SimpleTypeVisitor6;
 
-import static com.squareup.javapoet.MethodSpec.constructorBuilder;
-import static com.squareup.javapoet.MethodSpec.methodBuilder;
-import static com.squareup.javapoet.TypeSpec.classBuilder;
-import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
-import static dagger.internal.codegen.MapKeys.getMapKeyCreatorClassName;
-import static javax.lang.model.element.Modifier.FINAL;
-import static javax.lang.model.element.Modifier.PRIVATE;
-import static javax.lang.model.element.Modifier.PUBLIC;
-import static javax.lang.model.element.Modifier.STATIC;
-import static javax.lang.model.util.ElementFilter.methodsIn;
-
 /**
- * Generates classes that create annotations required to instantiate {@link MapKey}s.
+ * Generates classes that create annotation instances for an annotation type. The generated class
+ * will have a private empty constructor, a static method that creates the annotation type itself,
+ * and a static method that creates each annotation type that is nested in the top-level annotation
+ * type.
+ *
+ * <p>So for an example annotation:
  *
- * @since 2.0
+ * <pre>
+ *   {@literal @interface} Foo {
+ *     String s();
+ *     int i();
+ *     Bar bar(); // an annotation defined elsewhere
+ *   }
+ * </pre>
+ *
+ * the generated class will look like:
+ *
+ * <pre>
+ *   public final class FooCreator {
+ *     private FooCreator() {}
+ *
+ *     public static Foo createFoo(String s, int i, Bar bar) { … }
+ *     public static Bar createBar(…) { … }
+ *   }
+ * </pre>
  */
-final class MapKeyGenerator extends SourceFileGenerator<MapKeyCreatorSpecification> {
+class AnnotationCreatorGenerator extends SourceFileGenerator<TypeElement> {
 
   /**
-   * Specification of the {@link MapKey} annotation and the annotation type to generate.
+   * Returns the name of the generated class that contains the static {@code create} methods for an
+   * annotation type.
    */
-  @AutoValue
-  abstract static class MapKeyCreatorSpecification {
-    /**
-     * The {@link MapKey}-annotated annotation.
-     */
-    abstract TypeElement mapKeyElement();
-
-    /**
-     * The annotation type to write create methods for. For wrapped {@link MapKey}s, this is
-     * {@link #mapKeyElement()}. For unwrapped {@code MapKey}s whose single element is an
-     * annotation, this is that annotation element.
-     */
-    abstract TypeElement annotationElement();
-
-    /**
-     * Returns a specification for a wrapped {@link MapKey}-annotated annotation.
-     */
-    static MapKeyCreatorSpecification wrappedMapKey(TypeElement mapKeyElement) {
-      return new AutoValue_MapKeyGenerator_MapKeyCreatorSpecification(mapKeyElement, mapKeyElement);
-    }
-
-    /**
-     * Returns a specification for an unwrapped {@link MapKey}-annotated annotation whose single
-     * element is a nested annotation.
-     */
-    static MapKeyCreatorSpecification unwrappedMapKeyWithAnnotationValue(
-        TypeElement mapKeyElement, TypeElement annotationElement) {
-      return new AutoValue_MapKeyGenerator_MapKeyCreatorSpecification(
-          mapKeyElement, annotationElement);
-    }
+  static ClassName getAnnotationCreatorClassName(TypeElement annotationType) {
+    ClassName annotationTypeName = ClassName.get(annotationType);
+    return annotationTypeName
+        .topLevelClassName()
+        .peerClass(classFileName(annotationTypeName) + "Creator");
   }
 
-  MapKeyGenerator(Filer filer, Elements elements) {
+  AnnotationCreatorGenerator(Filer filer, Elements elements) {
     super(filer, elements);
   }
 
   @Override
-  ClassName nameGeneratedType(MapKeyCreatorSpecification mapKeyCreatorType) {
-    return getMapKeyCreatorClassName(mapKeyCreatorType.mapKeyElement());
+  ClassName nameGeneratedType(TypeElement annotationType) {
+    return getAnnotationCreatorClassName(annotationType);
   }
 
   @Override
-  Optional<? extends Element> getElementForErrorReporting(
-      MapKeyCreatorSpecification mapKeyCreatorType) {
-    return Optional.of(mapKeyCreatorType.mapKeyElement());
+  Optional<? extends Element> getElementForErrorReporting(TypeElement annotationType) {
+    return Optional.of(annotationType);
   }
 
   @Override
-  Optional<TypeSpec.Builder> write(
-      ClassName generatedTypeName, MapKeyCreatorSpecification mapKeyCreatorType) {
-    TypeSpec.Builder mapKeyCreatorBuilder =
-        classBuilder(generatedTypeName).addModifiers(PUBLIC, FINAL);
-
-    mapKeyCreatorBuilder.addMethod(constructorBuilder().addModifiers(PRIVATE).build());
-
-    for (TypeElement annotationElement :
-        nestedAnnotationElements(mapKeyCreatorType.annotationElement())) {
-      mapKeyCreatorBuilder.addMethod(buildCreateMethod(generatedTypeName, annotationElement));
+  Optional<TypeSpec.Builder> write(ClassName generatedTypeName, TypeElement annotationType) {
+    TypeSpec.Builder annotationCreatorBuilder =
+        classBuilder(generatedTypeName)
+            .addModifiers(PUBLIC, FINAL)
+            .addMethod(constructorBuilder().addModifiers(PRIVATE).build());
+
+    for (TypeElement annotationElement : annotationsToCreate(annotationType)) {
+      annotationCreatorBuilder.addMethod(buildCreateMethod(generatedTypeName, annotationElement));
     }
 
-    return Optional.of(mapKeyCreatorBuilder);
+    return Optional.of(annotationCreatorBuilder);
   }
 
-  private MethodSpec buildCreateMethod(
-      ClassName mapKeyGeneratedTypeName, TypeElement annotationElement) {
-    String createMethodName = "create" + annotationElement.getSimpleName();
+  private MethodSpec buildCreateMethod(ClassName generatedTypeName, TypeElement annotationElement) {
+    String createMethodName = createMethodName(annotationElement);
     MethodSpec.Builder createMethod =
         methodBuilder(createMethodName)
             .addAnnotation(AutoAnnotation.class)
@@ -140,15 +132,24 @@ private MethodSpec buildCreateMethod(
       parameters.add(CodeBlock.of("$L", parameterName));
     }
 
-    ClassName autoAnnotationClass = mapKeyGeneratedTypeName.peerClass(
-        "AutoAnnotation_" + mapKeyGeneratedTypeName.simpleName() + "_" + createMethodName);
+    ClassName autoAnnotationClass =
+        generatedTypeName.peerClass(
+            "AutoAnnotation_" + generatedTypeName.simpleName() + "_" + createMethodName);
     createMethod.addStatement(
         "return new $T($L)", autoAnnotationClass, makeParametersCodeBlock(parameters.build()));
     return createMethod.build();
   }
 
-  private static Set<TypeElement> nestedAnnotationElements(TypeElement annotationElement) {
-    return nestedAnnotationElements(annotationElement, new LinkedHashSet<TypeElement>());
+  static String createMethodName(TypeElement annotationType) {
+    return "create" + annotationType.getSimpleName();
+  }
+
+  /**
+   * Returns the annotation types for which {@code @AutoAnnotation static Foo createFoo(…)} methods
+   * should be written.
+   */
+  protected Set<TypeElement> annotationsToCreate(TypeElement annotationElement) {
+    return nestedAnnotationElements(annotationElement, new LinkedHashSet<>());
   }
 
   @CanIgnoreReturnValue
diff --git a/compiler/src/main/java/dagger/internal/codegen/AnnotationExpression.java b/compiler/src/main/java/dagger/internal/codegen/AnnotationExpression.java
new file mode 100644
index 000000000..6d3692636
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/AnnotationExpression.java
@@ -0,0 +1,190 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.auto.common.AnnotationMirrors.getAnnotationValuesWithDefaults;
+import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
+import static java.util.stream.Collectors.toList;
+
+import com.google.auto.common.MoreElements;
+import com.google.auto.common.MoreTypes;
+import com.google.common.collect.ImmutableList;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.TypeName;
+import java.util.List;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.AnnotationValue;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.ArrayType;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.SimpleAnnotationValueVisitor6;
+import javax.lang.model.util.SimpleTypeVisitor6;
+
+/**
+ * Returns an expression creating an instance of the visited annotation type. Its parameter must be
+ * a class as generated by {@link AnnotationCreatorGenerator}.
+ *
+ * <p>Note that {@link AnnotationValue#toString()} is the source-code representation of the value
+ * <em>when used in an annotation</em>, which is not always the same as the representation needed
+ * when creating the value in a method body.
+ *
+ * <p>For example, inside an annotation, a nested array of {@code int}s is simply {@code {1, 2, 3}},
+ * but in code it would have to be {@code new int[] {1, 2, 3}}.
+ */
+class AnnotationExpression extends SimpleAnnotationValueVisitor6<CodeBlock, AnnotationValue> {
+
+  private final AnnotationMirror annotation;
+  private final ClassName creatorClass;
+
+  AnnotationExpression(AnnotationMirror annotation) {
+    this.annotation = annotation;
+    this.creatorClass =
+        AnnotationCreatorGenerator.getAnnotationCreatorClassName(
+            MoreTypes.asTypeElement(annotation.getAnnotationType()));
+  }
+
+  /**
+   * Returns an expression that calls static methods on the annotation's creator class to create an
+   * annotation instance equivalent the annotation passed to the constructor.
+   */
+  CodeBlock getAnnotationInstanceExpression() {
+    return getAnnotationInstanceExpression(annotation);
+  }
+
+  private CodeBlock getAnnotationInstanceExpression(AnnotationMirror annotation) {
+    return CodeBlock.of(
+        "$T.$L($L)",
+        creatorClass,
+        AnnotationCreatorGenerator.createMethodName(
+            MoreElements.asType(annotation.getAnnotationType().asElement())),
+        makeParametersCodeBlock(
+            getAnnotationValuesWithDefaults(annotation)
+                .entrySet()
+                .stream()
+                .map(entry -> getValueExpression(entry.getKey().getReturnType(), entry.getValue()))
+                .collect(toList())));
+  }
+
+  /**
+   * Returns an expression that evaluates to a {@code value} of a given type on an {@code
+   * annotation}.
+   */
+  CodeBlock getValueExpression(TypeMirror valueType, AnnotationValue value) {
+    return ARRAY_LITERAL_PREFIX.visit(valueType, this.visit(value, value));
+  }
+
+  @Override
+  public CodeBlock visitEnumConstant(VariableElement c, AnnotationValue p) {
+    return CodeBlock.of("$T.$L", TypeName.get(c.getEnclosingElement().asType()), c.getSimpleName());
+  }
+
+  @Override
+  public CodeBlock visitAnnotation(AnnotationMirror a, AnnotationValue p) {
+    return getAnnotationInstanceExpression(a);
+  }
+
+  @Override
+  public CodeBlock visitType(TypeMirror t, AnnotationValue p) {
+    return CodeBlock.of("$T.class", TypeName.get(t));
+  }
+
+  @Override
+  public CodeBlock visitString(String s, AnnotationValue p) {
+    return CodeBlock.of("$S", s);
+  }
+
+  @Override
+  public CodeBlock visitByte(byte b, AnnotationValue p) {
+    return CodeBlock.of("(byte) $L", b);
+  }
+
+  @Override
+  public CodeBlock visitChar(char c, AnnotationValue p) {
+    return CodeBlock.of("$L", p);
+  }
+
+  @Override
+  public CodeBlock visitDouble(double d, AnnotationValue p) {
+    return CodeBlock.of("$LD", d);
+  }
+
+  @Override
+  public CodeBlock visitFloat(float f, AnnotationValue p) {
+    return CodeBlock.of("$LF", f);
+  }
+
+  @Override
+  public CodeBlock visitLong(long i, AnnotationValue p) {
+    return CodeBlock.of("$LL", i);
+  }
+
+  @Override
+  public CodeBlock visitShort(short s, AnnotationValue p) {
+    return CodeBlock.of("(short) $L", s);
+  }
+
+  @Override
+  protected CodeBlock defaultAction(Object o, AnnotationValue p) {
+    return CodeBlock.of("$L", o);
+  }
+
+  @Override
+  public CodeBlock visitArray(List<? extends AnnotationValue> values, AnnotationValue p) {
+    ImmutableList.Builder<CodeBlock> codeBlocks = ImmutableList.builder();
+    for (AnnotationValue value : values) {
+      codeBlocks.add(this.visit(value, p));
+    }
+    return CodeBlock.of("{$L}", makeParametersCodeBlock(codeBlocks.build()));
+  }
+
+  /**
+   * If the visited type is an array, prefixes the parameter code block with {@code new T[]}, where
+   * {@code T} is the raw array component type.
+   */
+  private static final SimpleTypeVisitor6<CodeBlock, CodeBlock> ARRAY_LITERAL_PREFIX =
+      new SimpleTypeVisitor6<CodeBlock, CodeBlock>() {
+
+        @Override
+        public CodeBlock visitArray(ArrayType t, CodeBlock p) {
+          return CodeBlock.of("new $T[] $L", RAW_TYPE_NAME.visit(t.getComponentType()), p);
+        }
+
+        @Override
+        protected CodeBlock defaultAction(TypeMirror e, CodeBlock p) {
+          return p;
+        }
+      };
+
+  /**
+   * If the visited type is an array, returns the name of its raw component type; otherwise returns
+   * the name of the type itself.
+   */
+  private static final SimpleTypeVisitor6<TypeName, Void> RAW_TYPE_NAME =
+      new SimpleTypeVisitor6<TypeName, Void>() {
+        @Override
+        public TypeName visitDeclared(DeclaredType t, Void p) {
+          return ClassName.get(MoreTypes.asTypeElement(t));
+        }
+
+        @Override
+        protected TypeName defaultAction(TypeMirror e, Void p) {
+          return TypeName.get(e);
+        }
+      };
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/AnnotationSpecs.java b/compiler/src/main/java/dagger/internal/codegen/AnnotationSpecs.java
index db7b9cf2f..06416f953 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AnnotationSpecs.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AnnotationSpecs.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 Google, Inc.
+ * Copyright (C) 2016 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,17 +13,35 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal.codegen;
 
+import static com.google.common.base.Preconditions.checkNotNull;
+
+import com.google.common.base.Ascii;
+import com.google.common.base.Preconditions;
+import com.google.common.collect.Lists;
 import com.squareup.javapoet.AnnotationSpec;
+import java.util.Arrays;
 
 final class AnnotationSpecs {
+  enum Suppression {
+    RAWTYPES,
+    UNCHECKED,
+    ;
 
-  static final AnnotationSpec SUPPRESS_WARNINGS_UNCHECKED = suppressWarnings("unchecked");
-  static final AnnotationSpec SUPPRESS_WARNINGS_RAWTYPES = suppressWarnings("rawtypes");
+    @Override
+    public String toString() {
+      return Ascii.toLowerCase(name());
+    }
+  }
 
-  private static AnnotationSpec suppressWarnings(String value) {
-    return AnnotationSpec.builder(SuppressWarnings.class).addMember("value", "$S", value).build();
+  static AnnotationSpec suppressWarnings(Suppression first, Suppression... rest) {
+    checkNotNull(first);
+    Arrays.stream(rest).forEach(Preconditions::checkNotNull);
+    AnnotationSpec.Builder builder = AnnotationSpec.builder(SuppressWarnings.class);
+    Lists.asList(first, rest).forEach(suppression -> builder.addMember("value", "$S", suppression));
+    return builder.build();
   }
 
   private AnnotationSpecs() {}
diff --git a/compiler/src/main/java/dagger/internal/codegen/AnyBindingMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/AnyBindingMethodValidator.java
new file mode 100644
index 000000000..a8a483e11
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/AnyBindingMethodValidator.java
@@ -0,0 +1,106 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
+import static com.google.common.collect.Iterables.getOnlyElement;
+import static com.google.common.collect.Maps.uniqueIndex;
+import static dagger.internal.codegen.DaggerElements.isAnyAnnotationPresent;
+import static dagger.internal.codegen.ErrorMessages.tooManyBindingMethodAnnotations;
+import static dagger.internal.codegen.Util.toImmutableSet;
+import static java.util.Arrays.asList;
+
+import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.ImmutableSet;
+import java.lang.annotation.Annotation;
+import java.util.HashMap;
+import java.util.Map;
+import javax.lang.model.element.ExecutableElement;
+
+/** Validates any binding method. */
+final class AnyBindingMethodValidator {
+
+  private final ImmutableMap<Class<? extends Annotation>, BindingMethodValidator> validators;
+  private final Map<ExecutableElement, ValidationReport<ExecutableElement>> reports =
+      new HashMap<>();
+
+  AnyBindingMethodValidator(BindingMethodValidator... validators) {
+    this.validators = uniqueIndex(asList(validators), BindingMethodValidator::methodAnnotation);
+  }
+
+  /** Returns the binding method annotations considered by this validator. */
+  ImmutableSet<Class<? extends Annotation>> methodAnnotations() {
+    return validators.keySet();
+  }
+
+  /**
+   * Returns {@code true} if {@code method} is annotated with at least one of {@link
+   * #methodAnnotations()}.
+   */
+  boolean isBindingMethod(ExecutableElement method) {
+    return isAnyAnnotationPresent(method, methodAnnotations());
+  }
+
+  /**
+   * Returns a validation report for a method.
+   *
+   * <ul>
+   *   <li>Reports an error if {@code method} is annotated with more than one {@linkplain
+   *       #methodAnnotations() binding method annotation}.
+   *   <li>Validates {@code method} with the {@link BindingMethodValidator} for the single
+   *       {@linkplain #methodAnnotations() binding method annotation}.
+   * </ul>
+   *
+   * @throws IllegalArgumentException if {@code method} is not annotated by any {@linkplain
+   *     #methodAnnotations() binding method annotation}
+   */
+  ValidationReport<ExecutableElement> validate(ExecutableElement method) {
+    return reports.computeIfAbsent(method, this::validateUncached);
+  }
+
+  /**
+   * Returns {@code true} if {@code method} was already {@linkplain #validate(ExecutableElement)
+   * validated}.
+   */
+  boolean wasAlreadyValidated(ExecutableElement method) {
+    return reports.containsKey(method);
+  }
+
+  private ValidationReport<ExecutableElement> validateUncached(ExecutableElement method) {
+    ValidationReport.Builder<ExecutableElement> report = ValidationReport.about(method);
+    ImmutableSet<? extends Class<? extends Annotation>> bindingMethodAnnotations =
+        methodAnnotations()
+            .stream()
+            .filter(annotation -> isAnnotationPresent(method, annotation))
+            .collect(toImmutableSet());
+    switch (bindingMethodAnnotations.size()) {
+      case 0:
+        throw new IllegalArgumentException(
+            String.format("%s has no binding method annotation", method));
+
+      case 1:
+        report.addSubreport(
+            validators.get(getOnlyElement(bindingMethodAnnotations)).validate(method));
+        break;
+
+      default:
+        report.addError(tooManyBindingMethodAnnotations(method, methodAnnotations()), method);
+        break;
+    }
+    return report.build();
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/Binding.java b/compiler/src/main/java/dagger/internal/codegen/Binding.java
index 47e343604..5e1d385ac 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Binding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Binding.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Google, Inc.
+ * Copyright (C) 2014 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,15 +13,29 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal.codegen;
 
+import static com.google.common.collect.Iterables.getOnlyElement;
+import static java.util.stream.Collectors.toList;
+import static javax.lang.model.element.Modifier.PUBLIC;
+
 import com.google.auto.common.MoreElements;
-import com.google.common.base.Optional;
+import com.google.auto.value.AutoValue;
+import com.google.auto.value.extension.memoized.Memoized;
+import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.ImmutableSetMultimap;
 import com.google.common.collect.Lists;
+import com.google.common.collect.Sets;
 import dagger.internal.codegen.BindingType.HasBindingType;
+import java.util.Collection;
+import java.util.Iterator;
 import java.util.List;
+import java.util.Map;
+import java.util.Optional;
 import java.util.Set;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.Name;
@@ -35,8 +49,6 @@
 import javax.lang.model.util.SimpleTypeVisitor6;
 import javax.lang.model.util.Types;
 
-import static javax.lang.model.element.Modifier.PUBLIC;
-
 /**
  * An abstract type for classes representing a Dagger binding.  Particularly, contains the
  * {@link Element} that generated the binding and the {@link DependencyRequest} instances that are
@@ -48,27 +60,160 @@
  */
 abstract class Binding extends BindingDeclaration implements HasBindingType {
 
+  /** The {@link Key} that is provided by this binding. */
+  @Override
+  public abstract Key key();
+
+  /**
+   * The explicit set of {@link DependencyRequest dependencies} required to satisfy this binding as
+   * defined by the user-defined injection sites.
+   */
+  abstract ImmutableSet<DependencyRequest> explicitDependencies();
+
   /**
-   * Returns the framework class associated with this binding.
+   * The set of {@link DependencyRequest dependencies} that are added by the framework rather than a
+   * user-defined injection site. This returns an unmodifiable set.
    */
-  Class<?> frameworkClass() {
-    return bindingType().frameworkClass();
+  // TODO(gak): this will eventually get changed to return a set of FrameworkDependency
+  Set<DependencyRequest> implicitDependencies() {
+    return ImmutableSet.of();
   }
 
-  /** The {@link Key} that is provided by this binding. */
-  @Override
-  public abstract Key key();
+  /**
+   * The set of {@link DependencyRequest dependencies} required to satisfy this binding. This is the
+   * union of {@link #explicitDependencies()} and {@link #implicitDependencies()}. This returns an
+   * unmodifiable set.
+   */
+  final Set<DependencyRequest> dependencies() {
+    Set<DependencyRequest> implicitDependencies = implicitDependencies();
+    return implicitDependencies.isEmpty()
+        ? explicitDependencies()
+        : Sets.union(implicitDependencies, explicitDependencies());
+  }
 
   /**
-   * The explicit set of {@link DependencyRequest dependencies} required to satisfy this binding.
+   * The framework dependencies of {@code binding}. There will be one element for each different
+   * binding key in the <em>{@linkplain Binding#unresolved() unresolved}</em> version of {@code
+   * binding}.
+   *
+   * <p>For example, given the following modules:
+   *
+   * <pre><code>
+   *   {@literal @Module} abstract class {@literal BaseModule<T>} {
+   *     {@literal @Provides} Foo provideFoo(T t, String string) {
+   *       return …;
+   *     }
+   *   }
+   *
+   *   {@literal @Module} class StringModule extends {@literal BaseModule<String>} {}
+   * </code></pre>
+   *
+   * Both dependencies of {@code StringModule.provideFoo} have the same binding key: {@code String}.
+   * But there are still two dependencies, because in the unresolved binding they have different
+   * binding keys:
+   *
+   * <dl>
+   *   <dt>{@code T}
+   *   <dd>{@code String t}
+   *   <dt>{@code String}
+   *   <dd>{@code String string}
+   * </dl>
+   *
+   * <p>Note that the sets returned by this method when called on the same binding will be equal,
+   * and their elements will be in the same order.
    */
-  abstract ImmutableSet<DependencyRequest> dependencies();
+  /* TODO(dpb): The stable-order postcondition is actually hard to verify in code for two equal
+   * instances of Binding, because it really depends on the order of the binding's dependencies,
+   * and two equal instances of Binding may have the same dependencies in a different order. */
+  @Memoized
+  ImmutableList<FrameworkDependency> frameworkDependencies() {
+    return ImmutableList.copyOf(
+        dependencyAssociations()
+            .stream()
+            .map(DependencyAssociation::frameworkDependency)
+            .collect(toList()));
+  }
 
   /**
-   * The set of {@link DependencyRequest dependencies} required to satisfy this binding. This is a
-   * superset of {@link #dependencies()}.  This returns an unmodifiable set.
+   * Associates a {@link FrameworkDependency} with the set of {@link DependencyRequest} instances
+   * that correlate for a binding.
    */
-  abstract Set<DependencyRequest> implicitDependencies();
+  @AutoValue
+  abstract static class DependencyAssociation {
+    abstract FrameworkDependency frameworkDependency();
+
+    abstract ImmutableSet<DependencyRequest> dependencyRequests();
+
+    static DependencyAssociation create(
+        FrameworkDependency frameworkDependency, Iterable<DependencyRequest> dependencyRequests) {
+      return new AutoValue_Binding_DependencyAssociation(
+          frameworkDependency, ImmutableSet.copyOf(dependencyRequests));
+    }
+  }
+
+  /**
+   * Returns the same {@link FrameworkDependency} instances from {@link #frameworkDependencies}, but
+   * with the set of {@link DependencyRequest} instances with which each is associated.
+   *
+   * <p>Ths method returns a list of {@link Map.Entry entries} rather than a {@link Map} or {@link
+   * com.google.common.collect.Multimap} because any given {@link FrameworkDependency} may appear
+   * multiple times if the {@linkplain Binding#unresolved() unresolved} binding requires it. If that
+   * distinction is not important, the entries can be merged into a single mapping.
+   */
+  @Memoized
+  ImmutableList<DependencyAssociation> dependencyAssociations() {
+    BindingTypeMapper bindingTypeMapper = BindingTypeMapper.forBindingType(bindingType());
+    ImmutableList.Builder<DependencyAssociation> frameworkDependencies = ImmutableList.builder();
+    for (Collection<DependencyRequest> requests : groupByUnresolvedKey()) {
+      frameworkDependencies.add(
+          DependencyAssociation.create(
+              FrameworkDependency.create(
+                  getOnlyElement(
+                      FluentIterable.from(requests)
+                          .transform(DependencyRequest::bindingKey)
+                          .toSet()),
+                  bindingTypeMapper.getBindingType(requests)),
+              requests));
+    }
+    return frameworkDependencies.build();
+  }
+
+  /**
+   * Returns the mapping from each {@linkplain #dependencies dependency} to its associated {@link
+   * FrameworkDependency}.
+   */
+  @Memoized
+  ImmutableMap<DependencyRequest, FrameworkDependency> dependenciesToFrameworkDependenciesMap() {
+    ImmutableMap.Builder<DependencyRequest, FrameworkDependency> frameworkDependencyMap =
+        ImmutableMap.builder();
+    for (DependencyAssociation dependencyAssociation : dependencyAssociations()) {
+      for (DependencyRequest dependencyRequest : dependencyAssociation.dependencyRequests()) {
+        frameworkDependencyMap.put(dependencyRequest, dependencyAssociation.frameworkDependency());
+      }
+    }
+    return frameworkDependencyMap.build();
+  }
+
+  /**
+   * Groups {@code binding}'s implicit dependencies by their binding key, using the dependency keys
+   * from the {@link Binding#unresolved()} binding if it exists.
+   */
+  private ImmutableList<Collection<DependencyRequest>> groupByUnresolvedKey() {
+    ImmutableSetMultimap.Builder<BindingKey, DependencyRequest> dependenciesByKeyBuilder =
+        ImmutableSetMultimap.builder();
+    Iterator<DependencyRequest> dependencies = dependencies().iterator();
+    Binding unresolved = unresolved().isPresent() ? unresolved().get() : this;
+    Iterator<DependencyRequest> unresolvedDependencies = unresolved.dependencies().iterator();
+    while (dependencies.hasNext()) {
+      dependenciesByKeyBuilder.put(unresolvedDependencies.next().bindingKey(), dependencies.next());
+    }
+    return ImmutableList.copyOf(
+        dependenciesByKeyBuilder
+            .orderValuesBy(SourceFiles.DEPENDENCY_ORDERING)
+            .build()
+            .asMap()
+            .values());
+  }
 
   /**
    * Returns the name of the package in which this binding must be managed. E.g.: a binding
@@ -78,7 +223,7 @@
     Set<String> packages = nonPublicPackageUse(key().type());
     switch (packages.size()) {
       case 0:
-        return Optional.absent();
+        return Optional.empty();
       case 1:
         return Optional.of(packages.iterator().next());
       default:
@@ -128,7 +273,7 @@ public Void visitWildcard(WildcardType t, ImmutableSet.Builder<String> p) {
   }
 
   /**
-   * if this binding's key's type parameters are different from those of the
+   * If this binding's key's type parameters are different from those of the
    * {@link #bindingTypeElement()}, this is the binding for the {@link #bindingTypeElement()}'s
    * unresolved type.
    */
@@ -138,7 +283,7 @@ public Void visitWildcard(WildcardType t, ImmutableSet.Builder<String> p) {
    * The scope of this binding.
    */
   Optional<Scope> scope() {
-    return Optional.absent();
+    return Optional.empty();
   }
 
   // TODO(sameb): Remove the TypeElement parameter and pull it from the TypeMirror.
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingDeclaration.java b/compiler/src/main/java/dagger/internal/codegen/BindingDeclaration.java
index c58e0dbd6..09aa53b58 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingDeclaration.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingDeclaration.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,75 +13,37 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal.codegen;
 
-import com.google.auto.common.MoreElements;
-import com.google.common.base.Function;
-import com.google.common.base.Optional;
-import com.google.common.base.Predicate;
+import static dagger.internal.codegen.DaggerElements.ENCLOSING_TYPE_ELEMENT;
+
 import dagger.internal.codegen.Key.HasKey;
-import java.util.Set;
+import java.util.Optional;
 import javax.lang.model.element.Element;
-import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.Modifier;
 import javax.lang.model.element.TypeElement;
-import javax.lang.model.type.DeclaredType;
-
-import static dagger.internal.codegen.Util.AS_DECLARED_TYPE;
-import static dagger.internal.codegen.Util.ENCLOSING_TYPE_ELEMENT;
 
 /** An object that declares or specifies a binding. */
 abstract class BindingDeclaration implements HasKey {
 
-  /** The {@link Element} that declares the binding. */
-  abstract Element bindingElement();
-
   /**
-   * The {@link ExecutableElement} that declares the binding. Equivalent to
-   * {@code MoreElements.asExecutable(bindingElement())}.
-   *
-   * @throws IllegalStateException if {@link #bindingElement()} is not an executable element
+   * The {@link Element} that declares the binding. Absent for bindings without identifying
+   * declarations.
    */
-  ExecutableElement bindingElementAsExecutable() {
-    try {
-      return MoreElements.asExecutable(bindingElement());
-    } catch (IllegalArgumentException e) {
-      throw new IllegalStateException(e);
-    }
-  }
-
-  /** The type enclosing the {@link #bindingElement()}. */
-  TypeElement bindingTypeElement() {
-    return ENCLOSING_TYPE_ELEMENT.visit(bindingElement());
-  }
+  abstract Optional<? extends Element> bindingElement();
 
   /**
-   * The installed module class that contributed the {@link #bindingElement()}. May be a subclass
-   * of the class that contains {@link #bindingElement()}.
+   * The type enclosing the {@link #bindingElement()}, or {@link Optional#empty()} if {@link
+   * #bindingElement()} is empty.
    */
-  abstract Optional<TypeElement> contributingModule();
-
+  Optional<TypeElement> bindingTypeElement() {
+    return bindingElement().map(element -> element.accept(ENCLOSING_TYPE_ELEMENT, null));
+  }
+  
   /**
-   * The type of {@link #contributingModule()}.
+   * The installed module class that contributed the {@link #bindingElement()}. May be a subclass of
+   * the class that contains {@link #bindingElement()}. Absent if {@link #bindingElement()} is
+   * empty.
    */
-  Optional<DeclaredType> contributingModuleType() {
-    return contributingModule().transform(AS_DECLARED_TYPE);
-  }
-
-  static final Function<BindingDeclaration, Set<TypeElement>> CONTRIBUTING_MODULE =
-      new Function<BindingDeclaration, Set<TypeElement>>() {
-        @Override
-        public Set<TypeElement> apply(BindingDeclaration bindingDeclaration) {
-          return bindingDeclaration.contributingModule().asSet();
-        }
-      };
-
-  static Predicate<BindingDeclaration> bindingElementHasModifier(final Modifier modifier) {
-    return new Predicate<BindingDeclaration>() {
-      @Override
-      public boolean apply(BindingDeclaration bindingDeclaration) {
-        return bindingDeclaration.bindingElement().getModifiers().contains(modifier);
-      }
-    };
-  }
+  abstract Optional<TypeElement> contributingModule();
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingDeclarationFormatter.java b/compiler/src/main/java/dagger/internal/codegen/BindingDeclarationFormatter.java
index ba6f1fde7..0652b4d3c 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingDeclarationFormatter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingDeclarationFormatter.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,32 +13,141 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal.codegen;
 
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.collect.Sets.immutableEnumSet;
+import static dagger.internal.codegen.ConfigurationAnnotations.getModuleSubcomponents;
+import static dagger.internal.codegen.ContributionBinding.Kind.SYNTHETIC_RELEASABLE_REFERENCE_MANAGER;
+import static dagger.internal.codegen.ContributionBinding.Kind.SYNTHETIC_RELEASABLE_REFERENCE_MANAGERS;
 import static dagger.internal.codegen.ErrorMessages.stripCommonTypePrefixes;
+import static dagger.internal.codegen.MoreAnnotationMirrors.simpleName;
+import static javax.lang.model.type.TypeKind.DECLARED;
+import static javax.lang.model.type.TypeKind.EXECUTABLE;
+
+import com.google.auto.common.MoreElements;
+import com.google.auto.common.MoreTypes;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Iterables;
+import javax.lang.model.element.Element;
+import javax.lang.model.type.TypeKind;
+import javax.lang.model.type.TypeMirror;
 
 /**
  * Formats a {@link BindingDeclaration} into a {@link String} suitable for use in error messages.
  */
 final class BindingDeclarationFormatter extends Formatter<BindingDeclaration> {
+  private static final ImmutableSet<TypeKind> FORMATTABLE_ELEMENT_TYPE_KINDS =
+      immutableEnumSet(EXECUTABLE, DECLARED);
+
+  private static final ImmutableSet<ContributionBinding.Kind>
+      FORMATTABLE_ELEMENTLESS_BINDING_KINDS =
+          immutableEnumSet(
+              SYNTHETIC_RELEASABLE_REFERENCE_MANAGER, SYNTHETIC_RELEASABLE_REFERENCE_MANAGERS);
+
   private final MethodSignatureFormatter methodSignatureFormatter;
+  private final KeyFormatter keyFormatter;
 
-  BindingDeclarationFormatter(MethodSignatureFormatter methodSignatureFormatter) {
+  BindingDeclarationFormatter(
+      MethodSignatureFormatter methodSignatureFormatter, KeyFormatter keyFormatter) {
     this.methodSignatureFormatter = methodSignatureFormatter;
+    this.keyFormatter = keyFormatter;
+  }
+
+  /**
+   * Returns {@code true} for declarations that this formatter can format. Specifically:
+   *
+   * <ul>
+   * <li>Those with {@linkplain BindingDeclaration#bindingElement() binding elements} that are
+   *     methods, constructors, or types.
+   * <li>{@link ContributionBinding.Kind#SYNTHETIC_RELEASABLE_REFERENCE_MANAGER} bindings.
+   * <li>{@link ContributionBinding.Kind#SYNTHETIC_RELEASABLE_REFERENCE_MANAGERS} bindings.
+   * </ul>
+   */
+  boolean canFormat(BindingDeclaration bindingDeclaration) {
+    if (bindingDeclaration instanceof SubcomponentDeclaration) {
+      return true;
+    }
+    if (bindingDeclaration.bindingElement().isPresent()) {
+      return FORMATTABLE_ELEMENT_TYPE_KINDS.contains(
+          bindingDeclaration.bindingElement().get().asType().getKind());
+    }
+    if (bindingDeclaration instanceof ContributionBinding) {
+      ContributionBinding contributionBinding = (ContributionBinding) bindingDeclaration;
+      return FORMATTABLE_ELEMENTLESS_BINDING_KINDS.contains(contributionBinding.bindingKind());
+    }
+    return false;
   }
 
   @Override
   public String format(BindingDeclaration bindingDeclaration) {
-    switch (bindingDeclaration.bindingElement().asType().getKind()) {
+    if (bindingDeclaration instanceof SubcomponentDeclaration) {
+      return formatSubcomponentDeclaration((SubcomponentDeclaration) bindingDeclaration);
+    }
+
+    if (bindingDeclaration instanceof ContributionBinding) {
+      ContributionBinding binding = (ContributionBinding) bindingDeclaration;
+      switch (binding.bindingKind()) {
+        case SYNTHETIC_RELEASABLE_REFERENCE_MANAGER:
+          return String.format(
+              "binding for %s from the scope declaration",
+              stripCommonTypePrefixes(keyFormatter.format(binding.key())));
+        case SYNTHETIC_RELEASABLE_REFERENCE_MANAGERS:
+          return String.format(
+              "Dagger-generated binding for %s",
+              stripCommonTypePrefixes(keyFormatter.format(binding.key())));
+        default:
+          break;
+      }
+    }
+
+    checkArgument(
+        bindingDeclaration.bindingElement().isPresent(),
+        "Cannot format bindings without source elements: %s",
+        bindingDeclaration);
+
+    Element bindingElement = bindingDeclaration.bindingElement().get();
+    switch (bindingElement.asType().getKind()) {
       case EXECUTABLE:
         return methodSignatureFormatter.format(
-            bindingDeclaration.bindingElementAsExecutable(),
-            bindingDeclaration.contributingModuleType());
+            MoreElements.asExecutable(bindingElement),
+            bindingDeclaration
+                .contributingModule()
+                .map(module -> MoreTypes.asDeclared(module.asType())));
       case DECLARED:
-        return stripCommonTypePrefixes(bindingDeclaration.bindingElement().asType().toString());
+        return stripCommonTypePrefixes(bindingElement.asType().toString());
       default:
-        throw new IllegalArgumentException(
-            "Formatting unsupported for element: " + bindingDeclaration.bindingElement());
+        throw new IllegalArgumentException("Formatting unsupported for element: " + bindingElement);
     }
   }
+
+  private String formatSubcomponentDeclaration(SubcomponentDeclaration subcomponentDeclaration) {
+    ImmutableList<TypeMirror> moduleSubcomponents =
+        getModuleSubcomponents(subcomponentDeclaration.moduleAnnotation());
+    int index =
+        Iterables.indexOf(
+            moduleSubcomponents,
+            MoreTypes.equivalence()
+                .equivalentTo(subcomponentDeclaration.subcomponentType().asType()));
+    StringBuilder annotationValue = new StringBuilder();
+    if (moduleSubcomponents.size() != 1) {
+      annotationValue.append("{");
+    }
+    annotationValue.append(
+        formatArgumentInList(
+            index,
+            moduleSubcomponents.size(),
+            subcomponentDeclaration.subcomponentType().getQualifiedName() + ".class"));
+    if (moduleSubcomponents.size() != 1) {
+      annotationValue.append("}");
+    }
+
+    return String.format(
+        "@%s(subcomponents = %s) for %s",
+        simpleName(subcomponentDeclaration.moduleAnnotation()),
+        annotationValue,
+        subcomponentDeclaration.contributingModule().get());
+  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
index 233ab5511..8b695fda3 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Google, Inc.
+ * Copyright (C) 2014 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,12 +13,29 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal.codegen;
 
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.base.Verify.verify;
+import static com.google.common.collect.Iterables.isEmpty;
+import static dagger.internal.codegen.BindingKey.contribution;
+import static dagger.internal.codegen.ComponentDescriptor.Kind.PRODUCTION_COMPONENT;
+import static dagger.internal.codegen.ComponentDescriptor.isComponentContributionMethod;
+import static dagger.internal.codegen.ComponentDescriptor.isComponentProductionMethod;
+import static dagger.internal.codegen.ContributionBinding.Kind.SYNTHETIC_MULTIBOUND_KINDS;
+import static dagger.internal.codegen.ContributionBinding.Kind.SYNTHETIC_OPTIONAL_BINDING;
+import static dagger.internal.codegen.Key.indexByKey;
+import static dagger.internal.codegen.Scope.reusableScope;
+import static dagger.internal.codegen.Util.toImmutableSet;
+import static java.util.function.Predicate.isEqual;
+import static javax.lang.model.element.Modifier.ABSTRACT;
+
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
-import com.google.common.base.Function;
-import com.google.common.base.Optional;
+import com.google.auto.value.extension.memoized.Memoized;
+import com.google.common.base.VerifyException;
 import com.google.common.cache.Cache;
 import com.google.common.cache.CacheBuilder;
 import com.google.common.collect.FluentIterable;
@@ -31,13 +48,14 @@
 import com.google.common.collect.Maps;
 import com.google.common.collect.Sets;
 import com.google.common.collect.TreeTraverser;
-import dagger.Component;
 import dagger.Reusable;
 import dagger.Subcomponent;
-import dagger.internal.codegen.BindingType.HasBindingType;
+import dagger.internal.codegen.ComponentDescriptor.BuilderRequirementMethod;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
+import dagger.internal.codegen.ContributionBinding.Kind;
 import dagger.internal.codegen.Key.HasKey;
-import dagger.producers.ProductionComponent;
+import dagger.producers.Produced;
+import dagger.producers.Producer;
 import java.util.ArrayDeque;
 import java.util.Collection;
 import java.util.Deque;
@@ -45,37 +63,20 @@
 import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Map;
-import java.util.Map.Entry;
+import java.util.Optional;
+import java.util.Queue;
 import java.util.Set;
-import java.util.concurrent.Callable;
 import java.util.concurrent.ExecutionException;
+import java.util.stream.Stream;
+import java.util.stream.StreamSupport;
 import javax.inject.Inject;
+import javax.inject.Provider;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.util.ElementFilter;
 import javax.lang.model.util.Elements;
 
-import static com.google.auto.common.MoreElements.getAnnotationMirror;
-import static com.google.auto.common.MoreElements.hasModifiers;
-import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Predicates.in;
-import static com.google.common.base.Predicates.not;
-import static com.google.common.base.Verify.verify;
-import static dagger.internal.codegen.BindingKey.Kind.CONTRIBUTION;
-import static dagger.internal.codegen.ComponentDescriptor.isComponentContributionMethod;
-import static dagger.internal.codegen.ComponentDescriptor.isComponentProductionMethod;
-import static dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor.isOfKind;
-import static dagger.internal.codegen.ComponentDescriptor.ComponentMethodKind.PRODUCTION_SUBCOMPONENT_BUILDER;
-import static dagger.internal.codegen.ComponentDescriptor.ComponentMethodKind.SUBCOMPONENT_BUILDER;
-import static dagger.internal.codegen.ComponentDescriptor.Kind.PRODUCTION_COMPONENT;
-import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
-import static dagger.internal.codegen.ContributionBinding.Kind.IS_SYNTHETIC_MULTIBINDING_KIND;
-import static dagger.internal.codegen.Key.indexByKey;
-import static dagger.internal.codegen.Scope.reusableScope;
-import static javax.lang.model.element.Modifier.ABSTRACT;
-import static javax.lang.model.element.Modifier.STATIC;
-
 /**
  * The canonical representation of a full-resolved graph.
  *
@@ -85,12 +86,35 @@
 abstract class BindingGraph {
   abstract ComponentDescriptor componentDescriptor();
   abstract ImmutableMap<BindingKey, ResolvedBindings> resolvedBindings();
-  abstract ImmutableMap<ExecutableElement, BindingGraph> subgraphs();
+  abstract ImmutableSet<BindingGraph> subgraphs();
+
+  /** Returns the resolved bindings for the dependencies of {@code binding}. */
+  ImmutableSet<ResolvedBindings> resolvedDependencies(ContributionBinding binding) {
+    return binding
+        .dependencies()
+        .stream()
+        .map(
+            dependencyRequest ->
+                resolvedBindings()
+                    .getOrDefault(
+                        dependencyRequest.bindingKey(),
+                        ResolvedBindings.noBindings(
+                            dependencyRequest.bindingKey(), componentDescriptor())))
+        .collect(toImmutableSet());
+  }
+  /**
+   * The type that defines the component for this graph.
+   *
+   * @see ComponentDescriptor#componentDefinitionType()
+   */
+  TypeElement componentType() {
+    return componentDescriptor().componentDefinitionType();
+  }
 
   /**
    * Returns the set of modules that are owned by this graph regardless of whether or not any of
-   * their bindings are used in this graph. For graphs representing top-level {@link Component
-   * components}, this set will be the same as
+   * their bindings are used in this graph. For graphs representing top-level {@link
+   * dagger.Component components}, this set will be the same as
    * {@linkplain ComponentDescriptor#transitiveModules the component's transitive modules}. For
    * {@linkplain Subcomponent subcomponents}, this set will be the transitive modules that are not
    * owned by any of their ancestors.
@@ -98,69 +122,77 @@
   abstract ImmutableSet<ModuleDescriptor> ownedModules();
 
   ImmutableSet<TypeElement> ownedModuleTypes() {
-    return FluentIterable.from(ownedModules())
-        .transform(ModuleDescriptor.getModuleElement())
-        .toSet();
+    return FluentIterable.from(ownedModules()).transform(ModuleDescriptor::moduleElement).toSet();
   }
 
   private static final TreeTraverser<BindingGraph> SUBGRAPH_TRAVERSER =
       new TreeTraverser<BindingGraph>() {
         @Override
         public Iterable<BindingGraph> children(BindingGraph node) {
-          return node.subgraphs().values();
+          return node.subgraphs();
         }
       };
 
   /**
    * The types for which the component needs instances.
+   *
    * <ul>
-   * <li>component dependencies
-   * <li>{@linkplain #ownedModules() owned modules} with concrete instance bindings that are used in
-   *     the graph
+   *   <li>component dependencies
+   *   <li>{@linkplain #ownedModules() owned modules} with concrete instance bindings that are used
+   *       in the graph
+   *   <li>bound instances
    * </ul>
    */
-  ImmutableSet<TypeElement> componentRequirements() {
-    return SUBGRAPH_TRAVERSER
-        .preOrderTraversal(this)
-        .transformAndConcat(RESOLVED_BINDINGS)
-        .transformAndConcat(ResolvedBindings.CONTRIBUTION_BINDINGS)
-        .filter(not(BindingDeclaration.bindingElementHasModifier(STATIC)))
-        .filter(not(BindingDeclaration.bindingElementHasModifier(ABSTRACT)))
-        .transformAndConcat(BindingDeclaration.CONTRIBUTING_MODULE)
-        .filter(in(ownedModuleTypes()))
-        .append(componentDescriptor().dependencies())
-        .toSet();
+  @Memoized
+  ImmutableSet<ComponentRequirement> componentRequirements() {
+    ImmutableSet.Builder<ComponentRequirement> requirements = ImmutableSet.builder();
+    StreamSupport.stream(SUBGRAPH_TRAVERSER.preOrderTraversal(this).spliterator(), false)
+        .flatMap(graph -> graph.resolvedBindings().values().stream())
+        .flatMap(bindings -> bindings.contributionBindings().stream())
+        .filter(ContributionBinding::requiresModuleInstance)
+        .map(bindingDeclaration -> bindingDeclaration.contributingModule())
+        .filter(Optional::isPresent)
+        .map(Optional::get)
+        .filter(module -> ownedModuleTypes().contains(module))
+        .map(module -> ComponentRequirement.forModule(module.asType()))
+        .forEach(requirements::add);
+    componentDescriptor()
+        .dependencies()
+        .stream()
+        .map(dep -> ComponentRequirement.forDependency(dep.asType()))
+        .forEach(requirements::add);
+    if (componentDescriptor().builderSpec().isPresent()) {
+      componentDescriptor()
+          .builderSpec()
+          .get()
+          .requirementMethods()
+          .stream()
+          .map(BuilderRequirementMethod::requirement)
+          .filter(req -> req.kind().equals(ComponentRequirement.Kind.BINDING))
+          .forEach(requirements::add);
+    }
+    return requirements.build();
   }
-
-  private static final Function<BindingGraph, Iterable<ResolvedBindings>> RESOLVED_BINDINGS =
-      new Function<BindingGraph, Iterable<ResolvedBindings>>() {
-        @Override
-        public Iterable<ResolvedBindings> apply(BindingGraph graph) {
-          return graph.resolvedBindings().values();
-        }
-      };
-
-  /**
-   * Returns the {@link ComponentDescriptor}s for this component and its subcomponents.
-   */
+  /** Returns the {@link ComponentDescriptor}s for this component and its subcomponents. */
   ImmutableSet<ComponentDescriptor> componentDescriptors() {
     return SUBGRAPH_TRAVERSER
         .preOrderTraversal(this)
-        .transform(
-            new Function<BindingGraph, ComponentDescriptor>() {
-              @Override
-              public ComponentDescriptor apply(BindingGraph graph) {
-                return graph.componentDescriptor();
-              }
-            })
+        .transform(BindingGraph::componentDescriptor)
         .toSet();
   }
 
-  ImmutableSet<TypeElement> availableDependencies() {
-    return FluentIterable.from(componentDescriptor().transitiveModuleTypes())
-        .filter(not(hasModifiers(ABSTRACT)))
-        .append(componentDescriptor().dependencies())
-        .toSet();
+  ImmutableSet<ComponentRequirement> availableDependencies() {
+    return Stream.concat(
+            componentDescriptor()
+                .transitiveModuleTypes()
+                .stream()
+                .filter(dep -> !dep.getModifiers().contains(ABSTRACT))
+                .map(module -> ComponentRequirement.forModule(module.asType())),
+            componentDescriptor()
+                .dependencies()
+                .stream()
+                .map(dep -> ComponentRequirement.forDependency(dep.asType())))
+        .collect(toImmutableSet());
   }
 
   static final class Factory {
@@ -170,7 +202,8 @@ public ComponentDescriptor apply(BindingGraph graph) {
     private final ProvisionBinding.Factory provisionBindingFactory;
     private final ProductionBinding.Factory productionBindingFactory;
 
-    Factory(Elements elements,
+    Factory(
+        Elements elements,
         InjectBindingRegistry injectBindingRegistry,
         Key.Factory keyFactory,
         ProvisionBinding.Factory provisionBindingFactory,
@@ -183,26 +216,21 @@ public ComponentDescriptor apply(BindingGraph graph) {
     }
 
     BindingGraph create(ComponentDescriptor componentDescriptor) {
-      return create(Optional.<Resolver>absent(), componentDescriptor);
+      return create(Optional.empty(), componentDescriptor);
     }
 
     private BindingGraph create(
         Optional<Resolver> parentResolver, ComponentDescriptor componentDescriptor) {
       ImmutableSet.Builder<ContributionBinding> explicitBindingsBuilder = ImmutableSet.builder();
       ImmutableSet.Builder<DelegateDeclaration> delegatesBuilder = ImmutableSet.builder();
+      ImmutableSet.Builder<OptionalBindingDeclaration> optionalsBuilder = ImmutableSet.builder();
 
       // binding for the component itself
-      TypeElement componentDefinitionType = componentDescriptor.componentDefinitionType();
-      explicitBindingsBuilder.add(provisionBindingFactory.forComponent(componentDefinitionType));
+      explicitBindingsBuilder.add(
+          provisionBindingFactory.forComponent(componentDescriptor.componentDefinitionType()));
 
       // Collect Component dependencies.
-      Optional<AnnotationMirror> componentMirror =
-          getAnnotationMirror(componentDefinitionType, Component.class)
-              .or(getAnnotationMirror(componentDefinitionType, ProductionComponent.class));
-      ImmutableSet<TypeElement> componentDependencyTypes = componentMirror.isPresent()
-          ? MoreTypes.asTypeElements(getComponentDependencies(componentMirror.get()))
-          : ImmutableSet.<TypeElement>of();
-      for (TypeElement componentDependency : componentDependencyTypes) {
+      for (TypeElement componentDependency : componentDescriptor.dependencies()) {
         explicitBindingsBuilder.add(provisionBindingFactory.forComponent(componentDependency));
         List<ExecutableElement> dependencyMethods =
             ElementFilter.methodsIn(elements.getAllMembers(componentDependency));
@@ -218,48 +246,99 @@ private BindingGraph create(
         }
       }
 
-      // Bindings for subcomponent builders.
-      for (ComponentMethodDescriptor subcomponentMethodDescriptor :
-          Iterables.filter(
-              componentDescriptor.subcomponents().keySet(),
-              isOfKind(SUBCOMPONENT_BUILDER, PRODUCTION_SUBCOMPONENT_BUILDER))) {
-        explicitBindingsBuilder.add(
-            provisionBindingFactory.forSubcomponentBuilderMethod(
-                subcomponentMethodDescriptor.methodElement(),
-                componentDescriptor.componentDefinitionType()));
+      // Collect bindings on the builder.
+      if (componentDescriptor.builderSpec().isPresent()) {
+        for (BuilderRequirementMethod method :
+            componentDescriptor.builderSpec().get().requirementMethods()) {
+          if (method.requirement().kind().equals(ComponentRequirement.Kind.BINDING)) {
+            explicitBindingsBuilder.add(provisionBindingFactory.forBuilderBinding(method));
+          }
+        }
+      }
+
+      for (Map.Entry<ComponentMethodDescriptor, ComponentDescriptor>
+          componentMethodAndSubcomponent :
+              componentDescriptor.subcomponentsByBuilderMethod().entrySet()) {
+        ComponentMethodDescriptor componentMethod = componentMethodAndSubcomponent.getKey();
+        ComponentDescriptor subcomponentDescriptor = componentMethodAndSubcomponent.getValue();
+        if (!componentDescriptor.subcomponentsFromModules().contains(subcomponentDescriptor)) {
+          explicitBindingsBuilder.add(
+              provisionBindingFactory.forSubcomponentBuilderMethod(
+                  componentMethod.methodElement(),
+                  componentDescriptor.componentDefinitionType()));
+        }
       }
 
       ImmutableSet.Builder<MultibindingDeclaration> multibindingDeclarations =
           ImmutableSet.builder();
+      ImmutableSet.Builder<SubcomponentDeclaration> subcomponentDeclarations =
+          ImmutableSet.builder();
 
       // Collect transitive module bindings and multibinding declarations.
       for (ModuleDescriptor moduleDescriptor : componentDescriptor.transitiveModules()) {
         explicitBindingsBuilder.addAll(moduleDescriptor.bindings());
         multibindingDeclarations.addAll(moduleDescriptor.multibindingDeclarations());
+        subcomponentDeclarations.addAll(moduleDescriptor.subcomponentDeclarations());
         delegatesBuilder.addAll(moduleDescriptor.delegateDeclarations());
+        optionalsBuilder.addAll(moduleDescriptor.optionalDeclarations());
+      }
+
+      // TODO(dpb,gak): Do we need to bind an empty Set<ReleasableReferenceManager> if there are
+      // none?
+      for (Scope scope : componentDescriptor.releasableReferencesScopes()) {
+        // Add a binding for @ForReleasableReferences(scope) ReleasableReferenceManager.
+        explicitBindingsBuilder.add(
+            provisionBindingFactory.provideReleasableReferenceManager(scope));
+
+        /* Add a binding for Set<ReleasableReferenceManager>. Even if these are added more than
+         * once, each instance will be equal to the rest. Since they're being added to a set, there
+         * will be only one instance. */
+        explicitBindingsBuilder.add(
+            provisionBindingFactory.provideSetOfReleasableReferenceManagers());
+
+        for (AnnotationMirror metadata : scope.releasableReferencesMetadata()) {
+          // Add a binding for @ForReleasableReferences(scope) TypedReleasableReferenceManager<M>.
+          explicitBindingsBuilder.add(
+              provisionBindingFactory.provideTypedReleasableReferenceManager(
+                  scope, metadata.getAnnotationType()));
+
+          /* Add a binding for Set<TypedReleasableReferenceManager<M>>. Even if these are added more
+           * than once, each instance will be equal to the rest. Since they're being added to a set,
+           * there will be only one instance. */
+          explicitBindingsBuilder.add(
+              provisionBindingFactory.provideSetOfTypedReleasableReferenceManagers(
+                  metadata.getAnnotationType()));
+        }
       }
 
-      Resolver requestResolver =
+      final Resolver requestResolver =
           new Resolver(
               parentResolver,
               componentDescriptor,
               indexByKey(explicitBindingsBuilder.build()),
               indexByKey(multibindingDeclarations.build()),
-              indexByKey(delegatesBuilder.build()));
+              indexByKey(subcomponentDeclarations.build()),
+              indexByKey(delegatesBuilder.build()),
+              indexByKey(optionalsBuilder.build()));
       for (ComponentMethodDescriptor componentMethod : componentDescriptor.componentMethods()) {
         Optional<DependencyRequest> componentMethodRequest = componentMethod.dependencyRequest();
         if (componentMethodRequest.isPresent()) {
-          requestResolver.resolve(componentMethodRequest.get());
+          requestResolver.resolve(componentMethodRequest.get().bindingKey());
         }
       }
 
-      ImmutableMap.Builder<ExecutableElement, BindingGraph> subgraphsBuilder =
-          ImmutableMap.builder();
-      for (Entry<ComponentMethodDescriptor, ComponentDescriptor> subcomponentEntry :
-          componentDescriptor.subcomponents().entrySet()) {
-        subgraphsBuilder.put(
-            subcomponentEntry.getKey().methodElement(),
-            create(Optional.of(requestResolver), subcomponentEntry.getValue()));
+      // Resolve all bindings for subcomponents, creating subgraphs for all subcomponents that have
+      // been detected during binding resolution. If a binding for a subcomponent is never resolved,
+      // no BindingGraph will be created for it and no implementation will be generated. This is
+      // done in a queue since resolving one subcomponent might resolve a key for a subcomponent
+      // from a parent graph. This is done until no more new subcomponents are resolved.
+      Set<ComponentDescriptor> resolvedSubcomponents = new HashSet<>();
+      ImmutableSet.Builder<BindingGraph> subgraphs = ImmutableSet.builder();
+      for (ComponentDescriptor subcomponent :
+          Iterables.consumingIterable(requestResolver.subcomponentsToResolve)) {
+        if (resolvedSubcomponents.add(subcomponent)) {
+          subgraphs.add(create(Optional.of(requestResolver), subcomponent));
+        }
       }
 
       for (ResolvedBindings resolvedBindings : requestResolver.getResolvedBindings().values()) {
@@ -273,7 +352,7 @@ private BindingGraph create(
       return new AutoValue_BindingGraph(
           componentDescriptor,
           requestResolver.getResolvedBindings(),
-          subgraphsBuilder.build(),
+          subgraphs.build(),
           requestResolver.getOwnedModules());
     }
 
@@ -284,136 +363,139 @@ private BindingGraph create(
       final ImmutableSet<ContributionBinding> explicitBindingsSet;
       final ImmutableSetMultimap<Key, ContributionBinding> explicitMultibindings;
       final ImmutableSetMultimap<Key, MultibindingDeclaration> multibindingDeclarations;
+      final ImmutableSetMultimap<Key, SubcomponentDeclaration> subcomponentDeclarations;
       final ImmutableSetMultimap<Key, DelegateDeclaration> delegateDeclarations;
+      final ImmutableSetMultimap<Key, OptionalBindingDeclaration> optionalBindingDeclarations;
       final ImmutableSetMultimap<Key, DelegateDeclaration> delegateMultibindingDeclarations;
       final Map<BindingKey, ResolvedBindings> resolvedBindings;
       final Deque<BindingKey> cycleStack = new ArrayDeque<>();
-      final Cache<BindingKey, Boolean> dependsOnLocalMultibindingsCache =
-          CacheBuilder.newBuilder().<BindingKey, Boolean>build();
-      final Cache<Binding, Boolean> bindingDependsOnLocalMultibindingsCache =
-          CacheBuilder.newBuilder().<Binding, Boolean>build();
+      final Cache<BindingKey, Boolean> bindingKeyDependsOnLocalBindingsCache =
+          CacheBuilder.newBuilder().build();
+      final Cache<Binding, Boolean> bindingDependsOnLocalBindingsCache =
+          CacheBuilder.newBuilder().build();
+      final Queue<ComponentDescriptor> subcomponentsToResolve = new ArrayDeque<>();
 
       Resolver(
           Optional<Resolver> parentResolver,
           ComponentDescriptor componentDescriptor,
           ImmutableSetMultimap<Key, ContributionBinding> explicitBindings,
           ImmutableSetMultimap<Key, MultibindingDeclaration> multibindingDeclarations,
-          ImmutableSetMultimap<Key, DelegateDeclaration> delegateDeclarations) {
-        assert parentResolver != null;
-        this.parentResolver = parentResolver;
-        assert componentDescriptor != null;
-        this.componentDescriptor = componentDescriptor;
-        assert explicitBindings != null;
-        this.explicitBindings = explicitBindings;
+          ImmutableSetMultimap<Key, SubcomponentDeclaration> subcomponentDeclarations,
+          ImmutableSetMultimap<Key, DelegateDeclaration> delegateDeclarations,
+          ImmutableSetMultimap<Key, OptionalBindingDeclaration> optionalBindingDeclarations) {
+        this.parentResolver = checkNotNull(parentResolver);
+        this.componentDescriptor = checkNotNull(componentDescriptor);
+        this.explicitBindings = checkNotNull(explicitBindings);
         this.explicitBindingsSet = ImmutableSet.copyOf(explicitBindings.values());
-        assert multibindingDeclarations != null;
-        this.multibindingDeclarations = multibindingDeclarations;
-        assert delegateDeclarations != null;
-        this.delegateDeclarations = delegateDeclarations;
+        this.multibindingDeclarations = checkNotNull(multibindingDeclarations);
+        this.subcomponentDeclarations = checkNotNull(subcomponentDeclarations);
+        this.delegateDeclarations = checkNotNull(delegateDeclarations);
+        this.optionalBindingDeclarations = checkNotNull(optionalBindingDeclarations);
         this.resolvedBindings = Maps.newLinkedHashMap();
         this.explicitMultibindings =
-            multibindingsKeyedWithoutBindingIdentifiers(explicitBindingsSet);
+            multibindingContributionsByMultibindingKey(explicitBindingsSet);
         this.delegateMultibindingDeclarations =
-            multibindingsKeyedWithoutBindingIdentifiers(delegateDeclarations.values());
+            multibindingContributionsByMultibindingKey(delegateDeclarations.values());
+        subcomponentsToResolve.addAll(componentDescriptor.subcomponentsFromEntryPoints());
       }
 
       /**
-       * Returns the bindings that satisfy a given dependency request.
+       * Returns the bindings for the given {@link BindingKey}.
        *
        * <p>For {@link BindingKey.Kind#CONTRIBUTION} requests, returns all of:
+       *
        * <ul>
        * <li>All explicit bindings for:
        *     <ul>
        *     <li>the requested key
        *     <li>{@code Set<T>} if the requested key's type is {@code Set<Produced<T>>}
-       *     <li>{@code Map<K, Provider<V>>} if the requested key's type is
-       *         {@code Map<K, Producer<V>>}.
+       *     <li>{@code Map<K, Provider<V>>} if the requested key's type is {@code Map<K,
+       *         Producer<V>>}.
        *     </ul>
        *
        * <li>A synthetic binding that depends on {@code Map<K, Producer<V>>} if the requested key's
-       *     type is {@code Map<K, V>} and there are some explicit bindings for
-       *     {@code Map<K, Producer<V>>}.
-       *
+       *     type is {@code Map<K, V>} and there are some explicit bindings for {@code Map<K,
+       *     Producer<V>>}.
        * <li>A synthetic binding that depends on {@code Map<K, Provider<V>>} if the requested key's
-       *     type is {@code Map<K, V>} and there are some explicit bindings for
-       *     {@code Map<K, Provider<V>>} but no explicit bindings for {@code Map<K, Producer<V>>}.
-       *
+       *     type is {@code Map<K, V>} and there are some explicit bindings for {@code Map<K,
+       *     Provider<V>>} but no explicit bindings for {@code Map<K, Producer<V>>}.
        * <li>An implicit {@link Inject @Inject}-annotated constructor binding if there is one and
        *     there are no explicit bindings or synthetic bindings.
        * </ul>
        *
-       * <p>For {@link BindingKey.Kind#MEMBERS_INJECTION} requests, returns the
-       * {@link MembersInjectionBinding} for the type.
+       * <p>For {@link BindingKey.Kind#MEMBERS_INJECTION} requests, returns the {@link
+       * MembersInjectionBinding} for the type.
        */
-      ResolvedBindings lookUpBindings(DependencyRequest request) {
-        BindingKey bindingKey = request.bindingKey();
+      ResolvedBindings lookUpBindings(BindingKey bindingKey) {
         Key requestKey = bindingKey.key();
         switch (bindingKey.kind()) {
           case CONTRIBUTION:
             Set<ContributionBinding> contributionBindings = new LinkedHashSet<>();
-            ImmutableSet.Builder<ContributionBinding> multibindingsBuilder = ImmutableSet.builder();
+            ImmutableSet.Builder<ContributionBinding> multibindingContributionsBuilder =
+                ImmutableSet.builder();
             ImmutableSet.Builder<MultibindingDeclaration> multibindingDeclarationsBuilder =
                 ImmutableSet.builder();
+            ImmutableSet.Builder<SubcomponentDeclaration> subcomponentDeclarationsBuilder =
+                ImmutableSet.builder();
+            ImmutableSet.Builder<OptionalBindingDeclaration> optionalBindingDeclarationsBuilder =
+                ImmutableSet.builder();
 
             for (Key key : keysMatchingRequest(requestKey)) {
               contributionBindings.addAll(getExplicitBindings(key));
-              contributionBindings.addAll(getDelegateBindings(key));
-
-              multibindingsBuilder.addAll(getExplicitMultibindings(key));
-              multibindingsBuilder.addAll(getDelegateMultibindings(key));
-
+              multibindingContributionsBuilder.addAll(getExplicitMultibindings(key));
               multibindingDeclarationsBuilder.addAll(getMultibindingDeclarations(key));
+              subcomponentDeclarationsBuilder.addAll(getSubcomponentDeclarations(key));
+              optionalBindingDeclarationsBuilder.addAll(getOptionalBindingDeclarations(key));
             }
 
-            if (shouldCreateSyntheticMapOfValuesBinding(
-                keyFactory.implicitMapProducerKeyFrom(requestKey))) {
-              /* If the binding key is Map<K, V> or Map<K, Produced<V>> and there are some explicit
-               * Map<K, Producer<V>> bindings or multibinding declarations, then add the synthetic
-               * binding that depends on Map<K, Producer<V>>. */
-              contributionBindings.add(
-                  productionBindingFactory.syntheticMapOfValuesOrProducedBinding(request));
-            } else if (shouldCreateSyntheticMapOfValuesBinding(
-                keyFactory.implicitMapProviderKeyFrom(requestKey))) {
-              /* If the binding key is Map<K, V> and there are some explicit Map<K, Provider<V>>
-               * bindings or multibinding declarations but no explicit Map<K, Producer<V>> bindings
-               * or multibinding declarations, then add the synthetic binding that depends on
-               * Map<K, Provider<V>>. */
-              contributionBindings.add(
-                  provisionBindingFactory.syntheticMapOfValuesBinding(request));
-            }
-
-            ImmutableSet<ContributionBinding> multibindings = multibindingsBuilder.build();
+            ImmutableSet<ContributionBinding> multibindingContributions =
+                multibindingContributionsBuilder.build();
             ImmutableSet<MultibindingDeclaration> multibindingDeclarations =
                 multibindingDeclarationsBuilder.build();
+            ImmutableSet<SubcomponentDeclaration> subcomponentDeclarations =
+                subcomponentDeclarationsBuilder.build();
+            ImmutableSet<OptionalBindingDeclaration> optionalBindingDeclarations =
+                optionalBindingDeclarationsBuilder.build();
 
-            Iterable<? extends HasBindingType> multibindingsAndDeclarations =
-                Iterables.concat(multibindings, multibindingDeclarations);
-            if (Iterables.any(
-                multibindingsAndDeclarations, BindingType.isOfType(BindingType.PRODUCTION))) {
-              /* If there are production multibindings, add a synthetic binding that depends on each
-               * individual multibinding. */
-              contributionBindings.add(
-                  productionBindingFactory.syntheticMultibinding(request, multibindings));
-            } else if (Iterables.any(
-                multibindingsAndDeclarations, BindingType.isOfType(BindingType.PROVISION))) {
-              /* If there are provision multibindings but not production ones, add a synthetic
-               * binding that depends on each individual multibinding. */
-              contributionBindings.add(
-                  provisionBindingFactory.syntheticMultibinding(request, multibindings));
-            }
-
-            /* If there are still no bindings, look for an implicit @Inject- constructed binding if
-             * there is one. */
+            ImmutableSet.Builder<Optional<ContributionBinding>> maybeContributionBindings =
+                ImmutableSet.builder();
+            maybeContributionBindings.add(syntheticMapOfValuesBinding(requestKey));
+            maybeContributionBindings.add(
+                syntheticMultibinding(
+                    requestKey, multibindingContributions, multibindingDeclarations));
+            syntheticSubcomponentBuilderBinding(subcomponentDeclarations)
+                .ifPresent(
+                    binding -> {
+                      contributionBindings.add(binding);
+                      addSubcomponentToOwningResolver(binding);
+                    });
+            maybeContributionBindings.add(
+                syntheticOptionalBinding(requestKey, optionalBindingDeclarations));
+
+            /* If there are no bindings, add the implicit @Inject-constructed binding if there is
+             * one. */
             if (contributionBindings.isEmpty()) {
-              contributionBindings.addAll(
-                  injectBindingRegistry.getOrFindProvisionBinding(requestKey).asSet());
+              maybeContributionBindings.add(
+                  injectBindingRegistry
+                      .getOrFindProvisionBinding(requestKey)
+                      .map((ContributionBinding b) -> b));
             }
 
+            maybeContributionBindings
+                .build()
+                .stream()
+                .filter(Optional::isPresent)
+                .map(Optional::get)
+                .forEach(contributionBindings::add);
+
             return ResolvedBindings.forContributionBindings(
                 bindingKey,
                 componentDescriptor,
-                indexBindingsByOwningComponent(request, ImmutableSet.copyOf(contributionBindings)),
-                multibindingDeclarations);
+                indexBindingsByOwningComponent(
+                    bindingKey, ImmutableSet.copyOf(contributionBindings)),
+                multibindingDeclarations,
+                subcomponentDeclarations,
+                optionalBindingDeclarations);
 
           case MEMBERS_INJECTION:
             // no explicit deps for members injection, so just look it up
@@ -423,71 +505,236 @@ ResolvedBindings lookUpBindings(DependencyRequest request) {
                 ? ResolvedBindings.forMembersInjectionBinding(
                     bindingKey, componentDescriptor, binding.get())
                 : ResolvedBindings.noBindings(bindingKey, componentDescriptor);
+
           default:
             throw new AssertionError();
         }
       }
 
+      /**
+       * When a binding is resolved for a {@link SubcomponentDeclaration}, adds corresponding
+       * {@link ComponentDescriptor subcomponent} to a queue in the owning component's resolver.
+       * The queue will be used to detect which subcomponents need to be resolved.
+       */
+      private void addSubcomponentToOwningResolver(ProvisionBinding subcomponentBuilderBinding) {
+        checkArgument(subcomponentBuilderBinding.bindingKind().equals(Kind.SUBCOMPONENT_BUILDER));
+        Resolver owningResolver = getOwningResolver(subcomponentBuilderBinding).get();
+
+        TypeElement builderType = MoreTypes.asTypeElement(subcomponentBuilderBinding.key().type());
+        owningResolver.subcomponentsToResolve.add(
+            owningResolver.componentDescriptor.subcomponentsByBuilderType().get(builderType));
+      }
+
       private Iterable<Key> keysMatchingRequest(Key requestKey) {
-        return ImmutableSet.<Key>builder()
-            .add(requestKey)
-            .addAll(keyFactory.implicitSetKeyFromProduced(requestKey).asSet())
-            .addAll(keyFactory.implicitProviderMapKeyFromProducer(requestKey).asSet())
-            .build();
+        ImmutableSet.Builder<Key> keys = ImmutableSet.builder();
+        keys.add(requestKey);
+        keyFactory.unwrapSetKey(requestKey, Produced.class).ifPresent(keys::add);
+        keyFactory.rewrapMapKey(requestKey, Producer.class, Provider.class).ifPresent(keys::add);
+        keyFactory.rewrapMapKey(requestKey, Provider.class, Producer.class).ifPresent(keys::add);
+        return keys.build();
       }
 
-      private boolean shouldCreateSyntheticMapOfValuesBinding(Optional<Key> maybeKey) {
-        if (!maybeKey.isPresent()) {
-          return false;
-        }
+      /**
+       * If {@code key} is a {@code Map<K, V>} or {@code Map<K, Produced<V>>}, and there are any
+       * multibinding contributions or declarations that apply to that map, returns a synthetic
+       * binding for the {@code key} that depends on an {@linkplain #syntheticMultibinding(Key,
+       * Iterable, Iterable) underlying synthetic multibinding}.
+       *
+       * <p>The returned binding has the same {@link BindingType} as the underlying synthetic
+       * multibinding.
+       */
+      private Optional<ContributionBinding> syntheticMapOfValuesBinding(final Key key) {
+        return syntheticMultibinding(
+                key,
+                multibindingContributionsForValueMap(key),
+                multibindingDeclarationsForValueMap(key))
+            .map(
+                syntheticMultibinding -> {
+                  switch (syntheticMultibinding.bindingType()) {
+                    case PROVISION:
+                      return provisionBindingFactory.syntheticMapOfValuesBinding(key);
+
+                    case PRODUCTION:
+                      return productionBindingFactory.syntheticMapOfValuesOrProducedBinding(key);
+
+                    default:
+                      throw new VerifyException(syntheticMultibinding.toString());
+                  }
+                });
+      }
 
-        Key key = maybeKey.get();
-        if (!getExplicitMultibindings(key).isEmpty()
-            || !getMultibindingDeclarations(key).isEmpty()) {
-          return true;
+      /**
+       * If {@code key} is for {@code Map<K, V>} or {@code Map<K, Produced<V>>}, returns all
+       * multibinding contributions whose key is for {@code Map<K, Provider<V>>} or {@code Map<K,
+       * Producer<V>>} with the same qualifier and {@code K} and {@code V}.
+       */
+      private ImmutableSet<ContributionBinding> multibindingContributionsForValueMap(Key key) {
+        return keyFactory
+            .implicitFrameworkMapKeys(key)
+            .stream()
+            .flatMap(mapKey -> getExplicitMultibindings(mapKey).stream())
+            .collect(toImmutableSet());
+      }
+
+      /**
+       * If {@code key} is for {@code Map<K, V>} or {@code Map<K, Produced<V>>}, returns all
+       * multibinding declarations whose key is for {@code Map<K, Provider<V>>} or {@code Map<K,
+       * Producer<V>>} with the same qualifier and {@code K} and {@code V}.
+       */
+      private ImmutableSet<MultibindingDeclaration> multibindingDeclarationsForValueMap(Key key) {
+        return keyFactory
+            .implicitFrameworkMapKeys(key)
+            .stream()
+            .flatMap(mapKey -> getMultibindingDeclarations(mapKey).stream())
+            .collect(toImmutableSet());
+      }
+
+      /**
+       * Returns a synthetic binding that depends on individual multibinding contributions.
+       *
+       * <p>If there are no {@code multibindingContributions} or {@code multibindingDeclarations},
+       * returns {@link Optional#empty()}.
+       *
+       * <p>If there are production {@code multibindingContributions} or the request is for any of
+       * the following types, returns a {@link ProductionBinding}.
+       *
+       * <ul>
+       *   <li>{@code Set<Produced<T>>}
+       *   <li>{@code Map<K, Producer<V>>}
+       *   <li>{@code Map<K, Produced<V>>}
+       * </ul>
+       *
+       * Otherwise, returns a {@link ProvisionBinding}.
+       */
+      private Optional<ContributionBinding> syntheticMultibinding(
+          Key key,
+          Iterable<ContributionBinding> multibindingContributions,
+          Iterable<MultibindingDeclaration> multibindingDeclarations) {
+        if (isEmpty(multibindingContributions) && isEmpty(multibindingDeclarations)) {
+          return Optional.empty();
+        } else if (multibindingsRequireProduction(multibindingContributions, key)) {
+          return Optional.of(
+              productionBindingFactory.syntheticMultibinding(key, multibindingContributions));
+        } else {
+          return Optional.of(
+              provisionBindingFactory.syntheticMultibinding(key, multibindingContributions));
         }
+      }
 
-        for (ContributionBinding delegateMultibinding : getDelegateMultibindings(key)) {
-          if (delegateMultibinding.key().withoutBindingMethodIdentifier().equals(key)) {
+      private boolean multibindingsRequireProduction(
+          Iterable<ContributionBinding> multibindingContributions, Key key) {
+        if (MapType.isMap(key)) {
+          MapType mapType = MapType.from(key);
+          if (mapType.valuesAreTypeOf(Producer.class) || mapType.valuesAreTypeOf(Produced.class)) {
             return true;
           }
+        } else if (SetType.isSet(key) && SetType.from(key).elementsAreTypeOf(Produced.class)) {
+          return true;
+        }
+        return Iterables.any(multibindingContributions,
+            hasBindingType -> hasBindingType.bindingType().equals(BindingType.PRODUCTION));
+      }
+
+      private Optional<ProvisionBinding> syntheticSubcomponentBuilderBinding(
+          ImmutableSet<SubcomponentDeclaration> subcomponentDeclarations) {
+        return subcomponentDeclarations.isEmpty()
+            ? Optional.empty()
+            : Optional.of(
+                provisionBindingFactory.syntheticSubcomponentBuilder(subcomponentDeclarations));
+      }
+
+      /**
+       * Returns a synthetic binding for {@code @Qualifier Optional<Type>} if there are any {@code
+       * optionalBindingDeclarations}.
+       *
+       * <p>If there are no bindings for the underlying key (the key for dependency requests for
+       * {@code Type}), returns a provision binding that always returns {@link Optional#empty()}.
+       *
+       * <p>If there are any production bindings for the underlying key, returns a production
+       * binding. Otherwise returns a provision binding.
+       */
+      private Optional<ContributionBinding> syntheticOptionalBinding(
+          Key key, ImmutableSet<OptionalBindingDeclaration> optionalBindingDeclarations) {
+        if (optionalBindingDeclarations.isEmpty()) {
+          return Optional.empty();
+        }
+        ResolvedBindings underlyingKeyBindings =
+            lookUpBindings(contribution(keyFactory.unwrapOptional(key).get()));
+        if (underlyingKeyBindings.isEmpty()) {
+          return Optional.of(provisionBindingFactory.syntheticAbsentBinding(key));
+        } else if (underlyingKeyBindings.bindingTypes().contains(BindingType.PRODUCTION)) {
+          return Optional.of(productionBindingFactory.syntheticPresentBinding(key));
+        } else {
+          return Optional.of(provisionBindingFactory.syntheticPresentBinding(key));
         }
-        return false;
       }
 
       private ImmutableSet<ContributionBinding> createDelegateBindings(
           ImmutableSet<DelegateDeclaration> delegateDeclarations) {
         ImmutableSet.Builder<ContributionBinding> builder = ImmutableSet.builder();
         for (DelegateDeclaration delegateDeclaration : delegateDeclarations) {
-          DependencyRequest delegateRequest = delegateDeclaration.delegateRequest();
-          ResolvedBindings resolvedDelegate = lookUpBindings(delegateRequest);
-          for (ContributionBinding explicitDelegate : resolvedDelegate.contributionBindings()) {
-            switch (explicitDelegate.bindingType()) {
-              case PRODUCTION:
-                builder.add(
-                    productionBindingFactory.delegate(
-                        delegateDeclaration, (ProductionBinding) explicitDelegate));
-                break;
-              case PROVISION:
-                builder.add(
-                    provisionBindingFactory.delegate(
-                        delegateDeclaration, (ProvisionBinding) explicitDelegate));
-                break;
-              default:
-                throw new AssertionError();
-            }
-          }
+          builder.add(createDelegateBinding(delegateDeclaration));
         }
         return builder.build();
       }
 
+      /**
+       * Creates one (and only one) delegate binding for a delegate declaration, based on the
+       * resolved bindings of the right-hand-side of a {@link dagger.Binds} method. If there are
+       * duplicate bindings for the dependency key, there should still be only one binding for the
+       * delegate key.
+       */
+      private ContributionBinding createDelegateBinding(DelegateDeclaration delegateDeclaration) {
+        BindingKey delegateBindingKey = delegateDeclaration.delegateRequest().bindingKey();
+
+        if (cycleStack.contains(delegateBindingKey)) {
+          return provisionBindingFactory.missingDelegate(delegateDeclaration);
+        }
+
+        ResolvedBindings resolvedDelegate;
+        try {
+          cycleStack.push(delegateBindingKey);
+          resolvedDelegate = lookUpBindings(delegateBindingKey);
+        } finally {
+          cycleStack.pop();
+        }
+        if (resolvedDelegate.contributionBindings().isEmpty()) {
+          // This is guaranteed to result in a missing binding error, so it doesn't matter if the
+          // binding is a Provision or Production, except if it is a @IntoMap method, in which
+          // case the key will be of type Map<K, Provider<V>>, which will be "upgraded" into a
+          // Map<K, Producer<V>> if it's requested in a ProductionComponent. This may result in a
+          // strange error, that the RHS needs to be provided with an @Inject or @Provides
+          // annotated method, but a user should be able to figure out if a @Produces annotation
+          // is needed.
+          // TODO(gak): revisit how we model missing delegates if/when we clean up how we model
+          // binding declarations
+          return provisionBindingFactory.missingDelegate(delegateDeclaration);
+        }
+        // It doesn't matter which of these is selected, since they will later on produce a
+        // duplicate binding error.
+        // TODO(ronshapiro): Once compile-testing has a CompilationResult, add a test which asserts
+        // that a duplicate binding for the RHS does not result in a duplicate binding for the LHS.
+        ContributionBinding explicitDelegate =
+            resolvedDelegate.contributionBindings().iterator().next();
+        switch (explicitDelegate.bindingType()) {
+          case PRODUCTION:
+            return productionBindingFactory.delegate(
+                delegateDeclaration, (ProductionBinding) explicitDelegate);
+          case PROVISION:
+            return provisionBindingFactory.delegate(
+                delegateDeclaration, (ProvisionBinding) explicitDelegate);
+          default:
+            throw new AssertionError("bindingType: " + explicitDelegate);
+        }
+      }
+
       private ImmutableSetMultimap<ComponentDescriptor, ContributionBinding>
           indexBindingsByOwningComponent(
-              DependencyRequest request, Iterable<? extends ContributionBinding> bindings) {
+              BindingKey bindingKey, Iterable<? extends ContributionBinding> bindings) {
         ImmutableSetMultimap.Builder<ComponentDescriptor, ContributionBinding> index =
             ImmutableSetMultimap.builder();
         for (ContributionBinding binding : bindings) {
-          index.put(getOwningComponent(request, binding), binding);
+          index.put(getOwningComponent(bindingKey, binding), binding);
         }
         return index.build();
       }
@@ -495,19 +742,19 @@ private boolean shouldCreateSyntheticMapOfValuesBinding(Optional<Key> maybeKey)
       /**
        * Returns the component that should contain the framework field for {@code binding}.
        *
-       * <p>If {@code binding} is either not bound in an ancestor component or depends on
-       * multibinding contributions in this component, returns this component.
+       * <p>If {@code binding} is either not bound in an ancestor component or depends transitively
+       * on bindings in this component, returns this component.
        *
        * <p>Otherwise, resolves {@code request} in this component's parent in order to resolve any
-       * multibinding contributions in the parent, and returns the parent-resolved
-       * {@link ResolvedBindings#owningComponent(ContributionBinding)}.
+       * multibinding contributions in the parent, and returns the parent-resolved {@link
+       * ResolvedBindings#owningComponent(ContributionBinding)}.
        */
       private ComponentDescriptor getOwningComponent(
-          DependencyRequest request, ContributionBinding binding) {
-        if (isResolvedInParent(request, binding)
-            && !new MultibindingDependencies().dependsOnLocalMultibindings(binding)) {
+          BindingKey bindingKey, ContributionBinding binding) {
+        if (isResolvedInParent(bindingKey, binding)
+            && !new LocalDependencyChecker().dependsOnLocalBindings(binding)) {
           ResolvedBindings parentResolvedBindings =
-              parentResolver.get().resolvedBindings.get(request.bindingKey());
+              parentResolver.get().resolvedBindings.get(bindingKey);
           return parentResolvedBindings.owningComponent(binding);
         } else {
           return componentDescriptor;
@@ -515,15 +762,15 @@ private ComponentDescriptor getOwningComponent(
       }
 
       /**
-       * Returns {@code true} if {@code binding} is owned by an ancestor. If so,
-       * {@linkplain #resolve(DependencyRequest) resolves} the request in this component's parent.
-       * Don't resolve directly in the owning component in case it depends on multibindings in any
-       * of its descendants.
+       * Returns {@code true} if {@code binding} is owned by an ancestor. If so, {@linkplain
+       * #resolve resolves} the {@link BindingKey} in this component's parent. Don't resolve
+       * directly in the owning component in case it depends on multibindings in any of its
+       * descendants.
        */
-      private boolean isResolvedInParent(DependencyRequest request, ContributionBinding binding) {
+      private boolean isResolvedInParent(BindingKey bindingKey, ContributionBinding binding) {
         Optional<Resolver> owningResolver = getOwningResolver(binding);
         if (owningResolver.isPresent() && !owningResolver.get().equals(this)) {
-          parentResolver.get().resolve(request);
+          parentResolver.get().resolve(bindingKey);
           return true;
         } else {
           return false;
@@ -535,16 +782,17 @@ private boolean isResolvedInParent(DependencyRequest request, ContributionBindin
           for (Resolver requestResolver : getResolverLineage().reverse()) {
             // If a @Reusable binding was resolved in an ancestor, use that component.
             if (requestResolver.resolvedBindings.containsKey(
-                BindingKey.create(CONTRIBUTION, binding.key()))) {
+                BindingKey.contribution(binding.key()))) {
               return Optional.of(requestResolver);
             }
           }
           // If a @Reusable binding was not resolved in any ancestor, resolve it here.
-          return Optional.absent();
+          return Optional.empty();
         }
 
         for (Resolver requestResolver : getResolverLineage().reverse()) {
-          if (requestResolver.explicitBindingsSet.contains(binding)) {
+          if (requestResolver.explicitBindingsSet.contains(binding)
+              || requestResolver.subcomponentDeclarations.containsKey(binding.key())) {
             return Optional.of(requestResolver);
           }
         }
@@ -559,7 +807,7 @@ private boolean isResolvedInParent(DependencyRequest request, ContributionBindin
             }
           }
         }
-        return Optional.absent();
+        return Optional.empty();
       }
 
       /** Returns the resolver lineage from parent to child. */
@@ -574,29 +822,57 @@ private boolean isResolvedInParent(DependencyRequest request, ContributionBindin
       }
 
       /**
-       * Returns the explicit {@link ContributionBinding}s that match the {@code requestKey} from
-       * this and all ancestor resolvers.
+       * Returns the explicit {@link ContributionBinding}s that match the {@code key} from this and
+       * all ancestor resolvers.
        */
-      private ImmutableSet<ContributionBinding> getExplicitBindings(Key requestKey) {
-        ImmutableSet.Builder<ContributionBinding> explicitBindingsForKey = ImmutableSet.builder();
+      private ImmutableSet<ContributionBinding> getExplicitBindings(Key key) {
+        ImmutableSet.Builder<ContributionBinding> bindings = ImmutableSet.builder();
         for (Resolver resolver : getResolverLineage()) {
-          explicitBindingsForKey.addAll(resolver.explicitBindings.get(requestKey));
+          bindings.addAll(resolver.getLocalExplicitBindings(key));
         }
-        return explicitBindingsForKey.build();
+        return bindings.build();
       }
 
       /**
-       * Returns the explicit multibindings whose key (minus its
-       * {@link Key#bindingMethodIdentifier()}) matches the {@code requestKey} from this and all
-       * ancestor resolvers.
+       * Returns the explicit {@link ContributionBinding}s that match the {@code key} from this
+       * resolver.
        */
-      private ImmutableSet<ContributionBinding> getExplicitMultibindings(Key requestKey) {
-        ImmutableSet.Builder<ContributionBinding> explicitMultibindingsForKey =
-            ImmutableSet.builder();
+      private ImmutableSet<ContributionBinding> getLocalExplicitBindings(Key key) {
+        return new ImmutableSet.Builder<ContributionBinding>()
+            .addAll(explicitBindings.get(key))
+            .addAll(
+                createDelegateBindings(
+                    delegateDeclarations.get(keyFactory.convertToDelegateKey(key))))
+            .build();
+      }
+
+      /**
+       * Returns the explicit multibinding contributions that contribute to the map or set requested
+       * by {@code key} from this and all ancestor resolvers.
+       */
+      private ImmutableSet<ContributionBinding> getExplicitMultibindings(Key key) {
+        ImmutableSet.Builder<ContributionBinding> multibindings = ImmutableSet.builder();
         for (Resolver resolver : getResolverLineage()) {
-          explicitMultibindingsForKey.addAll(resolver.explicitMultibindings.get(requestKey));
+          multibindings.addAll(resolver.getLocalExplicitMultibindings(key));
+        }
+        return multibindings.build();
+      }
+
+      /**
+       * Returns the explicit multibinding contributions that contribute to the map or set requested
+       * by {@code key} from this resolver.
+       */
+      private ImmutableSet<ContributionBinding> getLocalExplicitMultibindings(Key key) {
+        ImmutableSet.Builder<ContributionBinding> multibindings = ImmutableSet.builder();
+        multibindings.addAll(explicitMultibindings.get(key));
+        if (!MapType.isMap(key) || MapType.from(key).valuesAreFrameworkType()) {
+          // There are no @Binds @IntoMap delegate declarations for Map<K, V> requests. All
+          // @IntoMap requests must be for Map<K, Framework<V>>.
+          multibindings.addAll(
+              createDelegateBindings(
+                  delegateMultibindingDeclarations.get(keyFactory.convertToDelegateKey(key))));
         }
-        return explicitMultibindingsForKey.build();
+        return multibindings.build();
       }
 
       /**
@@ -612,47 +888,47 @@ private boolean isResolvedInParent(DependencyRequest request, ContributionBindin
         return multibindingDeclarations.build();
       }
 
-      private ImmutableSet<ContributionBinding> getDelegateBindings(Key requestKey) {
-        Key delegateDeclarationKey = keyFactory.convertToDelegateKey(requestKey);
-        ImmutableSet.Builder<ContributionBinding> delegateBindings = ImmutableSet.builder();
+      /**
+       * Returns the {@link SubcomponentDeclaration}s that match the {@code key} from this and all
+       * ancestor resolvers.
+       */
+      private ImmutableSet<SubcomponentDeclaration> getSubcomponentDeclarations(Key key) {
+        ImmutableSet.Builder<SubcomponentDeclaration> subcomponentDeclarations =
+            ImmutableSet.builder();
         for (Resolver resolver : getResolverLineage()) {
-          delegateBindings.addAll(
-              createDelegateBindings(resolver.delegateDeclarations.get(delegateDeclarationKey)));
+          subcomponentDeclarations.addAll(resolver.subcomponentDeclarations.get(key));
         }
-        return delegateBindings.build();
+        return subcomponentDeclarations.build();
       }
-
-      private ImmutableSet<ContributionBinding> getDelegateMultibindings(Key requestKey) {
-        if (MapType.isMap(requestKey) && !MapType.from(requestKey).valuesAreFrameworkType()) {
-          // There are no @Binds @IntoMap delegate declarations for Map<K, V> requests. All @IntoMap
-          // requests must be for Map<K, Framework<V>>.
+      /**
+       * Returns the {@link OptionalBindingDeclaration}s that match the {@code key} from this and
+       * all ancestor resolvers.
+       */
+      private ImmutableSet<OptionalBindingDeclaration> getOptionalBindingDeclarations(Key key) {
+        Optional<Key> unwrapped = keyFactory.unwrapOptional(key);
+        if (!unwrapped.isPresent()) {
           return ImmutableSet.of();
         }
-        Key delegateDeclarationKey = keyFactory.convertToDelegateKey(requestKey);
-        ImmutableSet.Builder<ContributionBinding> delegateMultibindings = ImmutableSet.builder();
+        ImmutableSet.Builder<OptionalBindingDeclaration> declarations = ImmutableSet.builder();
         for (Resolver resolver : getResolverLineage()) {
-          delegateMultibindings.addAll(
-              createDelegateBindings(
-                  resolver.delegateMultibindingDeclarations.get(delegateDeclarationKey)));
+          declarations.addAll(resolver.optionalBindingDeclarations.get(unwrapped.get()));
         }
-        return delegateMultibindings.build();
+        return declarations.build();
       }
 
       private Optional<ResolvedBindings> getPreviouslyResolvedBindings(
           final BindingKey bindingKey) {
-        Optional<ResolvedBindings> result = Optional.fromNullable(resolvedBindings.get(bindingKey));
+        Optional<ResolvedBindings> result = Optional.ofNullable(resolvedBindings.get(bindingKey));
         if (result.isPresent()) {
           return result;
         } else if (parentResolver.isPresent()) {
           return parentResolver.get().getPreviouslyResolvedBindings(bindingKey);
         } else {
-          return Optional.absent();
+          return Optional.empty();
         }
       }
 
-      void resolve(DependencyRequest request) {
-        BindingKey bindingKey = request.bindingKey();
-
+      void resolve(BindingKey bindingKey) {
         // If we find a cycle, stop resolving. The original request will add it with all of the
         // other resolved deps.
         if (cycleStack.contains(bindingKey)) {
@@ -667,8 +943,9 @@ void resolve(DependencyRequest request) {
         /* If the binding was previously resolved in a supercomponent, then we may be able to avoid
          * resolving it here and just depend on the supercomponent resolution.
          *
-         * 1. If it depends on multibindings with contributions from this subcomponent, then we have
-         *    to resolve it in this subcomponent so that it sees the local contributions.
+         * 1. If it depends transitively on multibinding contributions or optional bindings with
+         *    bindings from this subcomponent, then we have to resolve it in this subcomponent so
+         *    that it sees the local bindings.
          *
          * 2. If there are any explicit bindings in this component, they may conflict with those in
          *    the supercomponent, so resolve them here so that conflicts can be caught.
@@ -676,9 +953,9 @@ void resolve(DependencyRequest request) {
         if (getPreviouslyResolvedBindings(bindingKey).isPresent()) {
           /* Resolve in the parent in case there are multibinding contributions or conflicts in some
            * component between this one and the previously-resolved one. */
-          parentResolver.get().resolve(request);
-          if (!new MultibindingDependencies().dependsOnLocalMultibindings(bindingKey)
-              && getExplicitBindings(bindingKey.key()).isEmpty()) {
+          parentResolver.get().resolve(bindingKey);
+          if (!new LocalDependencyChecker().dependsOnLocalBindings(bindingKey)
+              && getLocalExplicitBindings(bindingKey.key()).isEmpty()) {
             /* Cache the inherited parent component's bindings in case resolving at the parent found
              * bindings in some component between this one and the previously-resolved one. */
             ResolvedBindings inheritedBindings =
@@ -690,10 +967,10 @@ void resolve(DependencyRequest request) {
 
         cycleStack.push(bindingKey);
         try {
-          ResolvedBindings bindings = lookUpBindings(request);
+          ResolvedBindings bindings = lookUpBindings(bindingKey);
           for (Binding binding : bindings.ownedBindings()) {
-            for (DependencyRequest dependency : binding.implicitDependencies()) {
-              resolve(dependency);
+            for (DependencyRequest dependency : binding.dependencies()) {
+              resolve(dependency.bindingKey());
             }
           }
           resolvedBindings.put(bindingKey, bindings);
@@ -734,49 +1011,49 @@ void resolve(DependencyRequest request) {
             .immutableCopy();
       }
 
-      private final class MultibindingDependencies {
+      private final class LocalDependencyChecker {
         private final Set<Object> cycleChecker = new HashSet<>();
 
         /**
-         * Returns {@code true} if {@code bindingKey} previously resolved to multibindings with
-         * contributions declared within this component's modules, or if any of its unscoped
-         * dependencies depend on such local multibindings.
+         * Returns {@code true} if any of the bindings resolved for {@code bindingKey} are
+         * multibindings with contributions declared within this component's modules or optional
+         * bindings with present values declared within this component's modules, or if any of its
+         * unscoped dependencies depend on such bindings.
          *
-         * <p>We don't care about scoped dependencies because they will never depend on
-         * multibindings with contributions from subcomponents.
+         * <p>We don't care about scoped dependencies because they will never depend on bindings
+         * from subcomponents.
          *
          * @throws IllegalArgumentException if {@link #getPreviouslyResolvedBindings(BindingKey)} is
-         *     absent
+         *     empty
          */
-        boolean dependsOnLocalMultibindings(final BindingKey bindingKey) {
+        boolean dependsOnLocalBindings(BindingKey bindingKey) {
           checkArgument(
               getPreviouslyResolvedBindings(bindingKey).isPresent(),
               "no previously resolved bindings in %s for %s",
               Resolver.this,
               bindingKey);
           // Don't recur infinitely if there are valid cycles in the dependency graph.
+          // http://b/23032377
           if (!cycleChecker.add(bindingKey)) {
             return false;
           }
           try {
-            return dependsOnLocalMultibindingsCache.get(
+            return bindingKeyDependsOnLocalBindingsCache.get(
                 bindingKey,
-                new Callable<Boolean>() {
-                  @Override
-                  public Boolean call() {
-                    ResolvedBindings previouslyResolvedBindings =
-                        getPreviouslyResolvedBindings(bindingKey).get();
-                    if (isMultibindingsWithLocalContributions(previouslyResolvedBindings)) {
-                      return true;
-                    }
+                () -> {
+                  ResolvedBindings previouslyResolvedBindings =
+                      getPreviouslyResolvedBindings(bindingKey).get();
+                  if (hasLocalMultibindingContributions(previouslyResolvedBindings)
+                      || hasLocallyPresentOptionalBinding(previouslyResolvedBindings)) {
+                    return true;
+                  }
 
-                    for (Binding binding : previouslyResolvedBindings.bindings()) {
-                      if (dependsOnLocalMultibindings(binding)) {
-                        return true;
-                      }
+                  for (Binding binding : previouslyResolvedBindings.bindings()) {
+                    if (dependsOnLocalBindings(binding)) {
+                      return true;
                     }
-                    return false;
                   }
+                  return false;
                 });
           } catch (ExecutionException e) {
             throw new AssertionError(e);
@@ -792,54 +1069,71 @@ public Boolean call() {
          * <p>We don't care about non-reusable scoped dependencies because they will never depend on
          * multibindings with contributions from subcomponents.
          */
-        boolean dependsOnLocalMultibindings(final Binding binding) {
+        boolean dependsOnLocalBindings(Binding binding) {
           if (!cycleChecker.add(binding)) {
             return false;
           }
           try {
-            return bindingDependsOnLocalMultibindingsCache.get(
+            return bindingDependsOnLocalBindingsCache.get(
                 binding,
-                new Callable<Boolean>() {
-                  @Override
-                  public Boolean call() {
-                    if ((!binding.scope().isPresent()
-                            || binding.scope().get().equals(reusableScope(elements)))
-                        // TODO(beder): Figure out what happens with production subcomponents.
-                        && !binding.bindingType().equals(BindingType.PRODUCTION)) {
-                      for (DependencyRequest dependency : binding.implicitDependencies()) {
-                        if (dependsOnLocalMultibindings(dependency.bindingKey())) {
-                          return true;
-                        }
+                () -> {
+                  if ((!binding.scope().isPresent()
+                          || binding.scope().get().equals(reusableScope(elements)))
+                      // TODO(beder): Figure out what happens with production subcomponents.
+                      && !binding.bindingType().equals(BindingType.PRODUCTION)) {
+                    for (DependencyRequest dependency : binding.dependencies()) {
+                      if (dependsOnLocalBindings(dependency.bindingKey())) {
+                        return true;
                       }
                     }
-                    return false;
                   }
+                  return false;
                 });
           } catch (ExecutionException e) {
             throw new AssertionError(e);
           }
         }
 
-        private boolean isMultibindingsWithLocalContributions(ResolvedBindings resolvedBindings) {
-          return FluentIterable.from(resolvedBindings.contributionBindings())
-                  .transform(ContributionBinding.KIND)
-                  .anyMatch(IS_SYNTHETIC_MULTIBINDING_KIND)
-              && explicitMultibindings.containsKey(resolvedBindings.key());
+        /**
+         * Returns {@code true} if {@code resolvedBindings} contains a synthetic multibinding with
+         * at least one contribution declared within this component's modules.
+         */
+        private boolean hasLocalMultibindingContributions(ResolvedBindings resolvedBindings) {
+          return resolvedBindings
+                  .contributionBindings()
+                  .stream()
+                  .map(ContributionBinding::bindingKind)
+                  .anyMatch(SYNTHETIC_MULTIBOUND_KINDS::contains)
+              && !getLocalExplicitMultibindings(resolvedBindings.key()).isEmpty();
+        }
+
+        /**
+         * Returns {@code true} if {@code resolvedBindings} contains a synthetic optional binding
+         * for which there is an explicit present binding in this component.
+         */
+        private boolean hasLocallyPresentOptionalBinding(ResolvedBindings resolvedBindings) {
+          return resolvedBindings
+                  .contributionBindings()
+                  .stream()
+                  .map(ContributionBinding::bindingKind)
+                  .anyMatch(isEqual(SYNTHETIC_OPTIONAL_BINDING))
+              && !getLocalExplicitBindings(keyFactory.unwrapOptional(resolvedBindings.key()).get())
+                  .isEmpty();
         }
       }
     }
 
     /**
-     * Selects each item in {@code haveKeys} that has a {@link Key#bindingMethodIdentifier()} and
-     * indexes them by its {@link HasKey#key()}, where each key has its {@link
-     * dagger.internal.codegen.Key.BindingMethodIdentifier} removed.
+     * A multimap of those {@code declarations} that are multibinding contribution declarations,
+     * indexed by the key of the set or map to which they contribute.
      */
-    static <T extends HasKey> ImmutableSetMultimap<Key, T>
-        multibindingsKeyedWithoutBindingIdentifiers(Iterable<T> haveKeys) {
+    static <T extends HasKey>
+        ImmutableSetMultimap<Key, T> multibindingContributionsByMultibindingKey(
+            Iterable<T> declarations) {
       ImmutableSetMultimap.Builder<Key, T> builder = ImmutableSetMultimap.builder();
-      for (T hasKey : haveKeys) {
-        if (hasKey.key().bindingMethodIdentifier().isPresent()) {
-          builder.put(hasKey.key().withoutBindingMethodIdentifier(), hasKey);
+      for (T declaration : declarations) {
+        if (declaration.key().multibindingContributionIdentifier().isPresent()) {
+          builder.put(declaration.key().withoutMultibindingContributionIdentifier(), declaration);
         }
       }
       return builder.build();
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
index 7eb4663ad..26c5d8755 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,48 +13,102 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal.codegen;
 
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
+import static com.google.auto.common.MoreTypes.asDeclared;
+import static com.google.auto.common.MoreTypes.asExecutable;
+import static com.google.auto.common.MoreTypes.asTypeElements;
+import static com.google.auto.common.MoreTypes.isType;
+import static com.google.auto.common.MoreTypes.isTypeOf;
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Verify.verify;
+import static com.google.common.collect.Iterables.getOnlyElement;
+import static dagger.internal.codegen.BindingType.PRODUCTION;
+import static dagger.internal.codegen.BindingType.PROVISION;
+import static dagger.internal.codegen.ConfigurationAnnotations.getComponentAnnotation;
+import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
+import static dagger.internal.codegen.ContributionBinding.Kind.INJECTION;
+import static dagger.internal.codegen.ContributionBinding.Kind.SYNTHETIC_MAP;
+import static dagger.internal.codegen.ContributionBinding.Kind.SYNTHETIC_MULTIBOUND_KINDS;
+import static dagger.internal.codegen.ContributionBinding.Kind.SYNTHETIC_MULTIBOUND_MAP;
+import static dagger.internal.codegen.ContributionBinding.indexMapBindingsByAnnotationType;
+import static dagger.internal.codegen.ContributionBinding.indexMapBindingsByMapKey;
+import static dagger.internal.codegen.DaggerElements.getAnnotationMirror;
+import static dagger.internal.codegen.DaggerElements.isAnnotationPresent;
+import static dagger.internal.codegen.ErrorMessages.CANNOT_INJECT_WILDCARD_TYPE;
+import static dagger.internal.codegen.ErrorMessages.CONTAINS_DEPENDENCY_CYCLE_FORMAT;
+import static dagger.internal.codegen.ErrorMessages.DEPENDS_ON_PRODUCTION_EXECUTOR_FORMAT;
+import static dagger.internal.codegen.ErrorMessages.DUPLICATE_BINDINGS_FOR_KEY_FORMAT;
+import static dagger.internal.codegen.ErrorMessages.DUPLICATE_SIZE_LIMIT;
+import static dagger.internal.codegen.ErrorMessages.INDENT;
+import static dagger.internal.codegen.ErrorMessages.MEMBERS_INJECTION_WITH_RAW_TYPE;
+import static dagger.internal.codegen.ErrorMessages.MEMBERS_INJECTION_WITH_UNBOUNDED_TYPE;
+import static dagger.internal.codegen.ErrorMessages.MULTIPLE_CONTRIBUTION_TYPES_FOR_KEY_FORMAT;
+import static dagger.internal.codegen.ErrorMessages.PROVIDER_ENTRY_POINT_MAY_NOT_DEPEND_ON_PRODUCER_FORMAT;
+import static dagger.internal.codegen.ErrorMessages.PROVIDER_MAY_NOT_DEPEND_ON_PRODUCER_FORMAT;
+import static dagger.internal.codegen.ErrorMessages.REQUIRES_AT_INJECT_CONSTRUCTOR_OR_PROVIDER_FORMAT;
+import static dagger.internal.codegen.ErrorMessages.REQUIRES_AT_INJECT_CONSTRUCTOR_OR_PROVIDER_OR_PRODUCER_FORMAT;
+import static dagger.internal.codegen.ErrorMessages.REQUIRES_PROVIDER_FORMAT;
+import static dagger.internal.codegen.ErrorMessages.REQUIRES_PROVIDER_OR_PRODUCER_FORMAT;
+import static dagger.internal.codegen.ErrorMessages.duplicateMapKeysError;
+import static dagger.internal.codegen.ErrorMessages.inconsistentMapKeyAnnotationsError;
+import static dagger.internal.codegen.ErrorMessages.nullableToNonNullable;
+import static dagger.internal.codegen.ErrorMessages.referenceReleasingScopeMetadataMissingCanReleaseReferences;
+import static dagger.internal.codegen.ErrorMessages.referenceReleasingScopeNotAnnotatedWithMetadata;
+import static dagger.internal.codegen.ErrorMessages.referenceReleasingScopeNotInComponentHierarchy;
+import static dagger.internal.codegen.ErrorMessages.stripCommonTypePrefixes;
+import static dagger.internal.codegen.MoreAnnotationMirrors.getTypeValue;
+import static dagger.internal.codegen.Scope.reusableScope;
+import static dagger.internal.codegen.Scope.scopesOf;
+import static dagger.internal.codegen.Util.componentCanMakeNewInstances;
+import static dagger.internal.codegen.Util.toImmutableSet;
+import static java.util.stream.Collectors.groupingBy;
+import static java.util.stream.Collectors.joining;
+import static java.util.stream.Collectors.mapping;
+import static java.util.stream.Collectors.toList;
+import static java.util.stream.Collectors.toSet;
+
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
-import com.google.auto.value.AutoValue;
 import com.google.common.base.Equivalence;
-import com.google.common.base.Function;
-import com.google.common.base.Joiner;
-import com.google.common.base.Optional;
-import com.google.common.base.Predicate;
-import com.google.common.base.Predicates;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableListMultimap;
-import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ImmutableSetMultimap;
-import com.google.common.collect.Iterables;
-import com.google.common.collect.Iterators;
-import com.google.common.collect.LinkedHashMultiset;
-import com.google.common.collect.Maps;
+import com.google.common.collect.ImmutableSortedMap;
+import com.google.common.collect.LinkedHashMultimap;
 import com.google.common.collect.Multimap;
-import com.google.common.collect.Ordering;
+import com.google.common.collect.Multimaps;
+import com.google.common.collect.SetMultimap;
 import com.google.common.collect.Sets;
 import com.squareup.javapoet.TypeName;
+import dagger.BindsOptionalOf;
 import dagger.Component;
 import dagger.Lazy;
 import dagger.MapKey;
+import dagger.internal.codegen.ComponentDescriptor.BuilderRequirementMethod;
 import dagger.internal.codegen.ComponentDescriptor.BuilderSpec;
-import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
-import dagger.producers.ProductionComponent;
+import dagger.internal.codegen.ContributionType.HasContributionType;
+import dagger.releasablereferences.CanReleaseReferences;
+import dagger.releasablereferences.ForReleasableReferences;
+import dagger.releasablereferences.ReleasableReferenceManager;
+import dagger.releasablereferences.TypedReleasableReferenceManager;
 import java.util.ArrayDeque;
 import java.util.Collection;
 import java.util.Deque;
 import java.util.Formatter;
-import java.util.HashSet;
+import java.util.LinkedHashMap;
+import java.util.List;
 import java.util.Map;
+import java.util.Optional;
 import java.util.Queue;
 import java.util.Set;
+import java.util.concurrent.atomic.AtomicBoolean;
 import javax.inject.Provider;
 import javax.lang.model.element.AnnotationMirror;
-import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.ArrayType;
@@ -63,49 +117,11 @@
 import javax.lang.model.type.PrimitiveType;
 import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
+import javax.lang.model.type.TypeVisitor;
 import javax.lang.model.util.Elements;
-import javax.lang.model.util.SimpleTypeVisitor6;
+import javax.lang.model.util.SimpleTypeVisitor8;
 import javax.lang.model.util.Types;
 
-import static com.google.auto.common.MoreElements.getAnnotationMirror;
-import static com.google.auto.common.MoreTypes.asDeclared;
-import static com.google.auto.common.MoreTypes.asExecutable;
-import static com.google.auto.common.MoreTypes.asTypeElements;
-import static com.google.common.base.Preconditions.checkState;
-import static com.google.common.base.Predicates.in;
-import static com.google.common.base.Predicates.not;
-import static com.google.common.base.Verify.verify;
-import static com.google.common.collect.Iterables.getOnlyElement;
-import static com.google.common.collect.Iterables.indexOf;
-import static com.google.common.collect.Maps.filterKeys;
-import static dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor.isOfKind;
-import static dagger.internal.codegen.ComponentDescriptor.ComponentMethodKind.PRODUCTION_SUBCOMPONENT;
-import static dagger.internal.codegen.ComponentDescriptor.ComponentMethodKind.SUBCOMPONENT;
-import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
-import static dagger.internal.codegen.ContributionBinding.Kind.SYNTHETIC_DELEGATE_BINDING;
-import static dagger.internal.codegen.ContributionBinding.indexMapBindingsByAnnotationType;
-import static dagger.internal.codegen.ContributionBinding.indexMapBindingsByMapKey;
-import static dagger.internal.codegen.ContributionBinding.Kind.INJECTION;
-import static dagger.internal.codegen.ContributionBinding.Kind.IS_SYNTHETIC_KIND;
-import static dagger.internal.codegen.ContributionBinding.Kind.SYNTHETIC_MULTIBOUND_MAP;
-import static dagger.internal.codegen.ContributionType.indexByContributionType;
-import static dagger.internal.codegen.ErrorMessages.CANNOT_INJECT_WILDCARD_TYPE;
-import static dagger.internal.codegen.ErrorMessages.CONTAINS_DEPENDENCY_CYCLE_FORMAT;
-import static dagger.internal.codegen.ErrorMessages.DUPLICATE_SIZE_LIMIT;
-import static dagger.internal.codegen.ErrorMessages.INDENT;
-import static dagger.internal.codegen.ErrorMessages.MEMBERS_INJECTION_WITH_UNBOUNDED_TYPE;
-import static dagger.internal.codegen.ErrorMessages.REQUIRES_AT_INJECT_CONSTRUCTOR_OR_PROVIDER_FORMAT;
-import static dagger.internal.codegen.ErrorMessages.REQUIRES_AT_INJECT_CONSTRUCTOR_OR_PROVIDER_OR_PRODUCER_FORMAT;
-import static dagger.internal.codegen.ErrorMessages.REQUIRES_PROVIDER_FORMAT;
-import static dagger.internal.codegen.ErrorMessages.REQUIRES_PROVIDER_OR_PRODUCER_FORMAT;
-import static dagger.internal.codegen.ErrorMessages.duplicateMapKeysError;
-import static dagger.internal.codegen.ErrorMessages.inconsistentMapKeyAnnotationsError;
-import static dagger.internal.codegen.ErrorMessages.nullableToNonNullable;
-import static dagger.internal.codegen.ErrorMessages.stripCommonTypePrefixes;
-import static dagger.internal.codegen.Scope.reusableScope;
-import static dagger.internal.codegen.Util.componentCanMakeNewInstances;
-import static javax.tools.Diagnostic.Kind.ERROR;
-
 /** Reports errors in the shape of the binding graph. */
 final class BindingGraphValidator {
 
@@ -143,590 +159,130 @@
     this.keyFactory = keyFactory;
   }
 
-  /** A dependency path from an entry point. */
-  static final class DependencyPath {
-    private final Deque<ResolvedRequest> requestPath = new ArrayDeque<>();
-    private final LinkedHashMultiset<BindingKey> keyPath = LinkedHashMultiset.create();
-    private final Set<DependencyRequest> resolvedRequests = new HashSet<>();
+  private final class ComponentValidation extends ComponentTreeTraverser {
+    final BindingGraph rootGraph;
+    final Map<ComponentDescriptor, ValidationReport.Builder<TypeElement>> reports =
+        new LinkedHashMap<>();
 
-    /** The entry point. */
-    Element entryPointElement() {
-      return requestPath.getFirst().request().requestElement();
-    }
+    /** Bindings whose scopes are not compatible with the component that owns them. */
+    private final SetMultimap<ComponentDescriptor, ContributionBinding> incompatiblyScopedBindings =
+        LinkedHashMultimap.create();
 
-    /** The current dependency request, which is a transitive dependency of the entry point. */
-    DependencyRequest currentDependencyRequest() {
-      return requestPath.getLast().request();
+    ComponentValidation(BindingGraph rootGraph) {
+      super(rootGraph);
+      this.rootGraph = rootGraph;
     }
 
-    /**
-     * The resolved bindings for the {@linkplain #currentDependencyRequest() current dependency
-     * request.
-     */
-    ResolvedBindings currentBinding() {
-      return requestPath.getLast().binding();
-    }
-
-    /**
-     * The binding that depends on the {@linkplain #currentDependencyRequest() current request}.
-     *
-     * @throws IllegalStateException if there are fewer than two requests in the path
-     */
-    ResolvedBindings previousBinding() {
-      checkState(size() > 1);
-      return Iterators.get(requestPath.descendingIterator(), 1).binding();
-    }
-
-    /**
-     * {@code true} if there is a dependency cycle, which means that the
-     * {@linkplain #currentDependencyRequest() current request}'s binding key occurs earlier in the
-     * path.
-     */
-    boolean hasCycle() {
-      return keyPath.count(currentDependencyRequest().bindingKey()) > 1;
-    }
-
-    /**
-     * If there is a cycle, the segment of the path that represents the cycle. The first request's
-     * and the last request's binding keys are equal. The last request is the
-     * {@linkplain #currentDependencyRequest() current request}.
-     *
-     * @throws IllegalStateException if {@link #hasCycle()} is {@code false}
-     */
-    ImmutableList<ResolvedRequest> cycle() {
-      checkState(hasCycle(), "no cycle");
-      return FluentIterable.from(requestPath)
-          .skip(indexOf(keyPath, Predicates.equalTo(currentDependencyRequest().bindingKey())))
-          .toList();
-    }
-
-    /**
-     * Makes {@code request} the current request. Be sure to call {@link #pop()} to back up to the
-     * previous request in the path.
-     */
-    void push(ResolvedRequest request) {
-      requestPath.addLast(request);
-      keyPath.add(request.request().bindingKey());
-    }
-
-    /** Makes the previous request the current request. */
-    void pop() {
-      verify(keyPath.remove(requestPath.removeLast().request().bindingKey()));
-    }
-
-    /**
-     * Adds the {@linkplain #currentDependencyRequest() current request} to a set of visited
-     * requests, and returns {@code true} if the set didn't already contain it.
-     */
-    boolean visitCurrentRequest() {
-      return resolvedRequests.add(currentDependencyRequest());
-    }
-
-    int size() {
-      return requestPath.size();
-    }
-
-    /** The dependency requests in this path, starting with the entry point. */
-    FluentIterable<DependencyRequest> requests() {
-      return FluentIterable.from(requestPath).transform(REQUEST_FROM_RESOLVED_REQUEST);
-    }
-
-    private static final Function<ResolvedRequest, DependencyRequest>
-        REQUEST_FROM_RESOLVED_REQUEST =
-            new Function<ResolvedRequest, DependencyRequest>() {
-              @Override
-              public DependencyRequest apply(ResolvedRequest resolvedRequest) {
-                return resolvedRequest.request();
-              }
-            };
-  }
-
-  private final class Validation {
-    final BindingGraph subject;
-    final ValidationReport.Builder<TypeElement> reportBuilder;
-    final Optional<Validation> parent;
-
-    Validation(BindingGraph subject, Optional<Validation> parent) {
-      this.subject = subject;
-      this.reportBuilder =
-          ValidationReport.about(subject.componentDescriptor().componentDefinitionType());
-      this.parent = parent;
-    }
-
-    Validation(BindingGraph topLevelGraph) {
-      this(topLevelGraph, Optional.<Validation>absent());
-    }
-
-    BindingGraph topLevelGraph() {
-      return parent.isPresent() ? parent.get().topLevelGraph() : subject;
+    @Override
+    protected BindingGraphTraverser bindingGraphTraverser(
+        ComponentTreePath componentPath, DependencyRequest entryPoint) {
+      return new BindingGraphValidation(componentPath, entryPoint);
     }
 
+    /** Returns a report that contains all validation messages found during traversal. */
     ValidationReport<TypeElement> buildReport() {
-      return reportBuilder.build();
+      ValidationReport.Builder<TypeElement> report =
+          ValidationReport.about(rootGraph.componentType());
+      reports.values().forEach(subreport -> report.addSubreport(subreport.build()));
+      return report.build();
     }
 
-    void validateSubgraph() {
-      validateComponentScope();
-      validateDependencyScopes();
-      validateComponentHierarchy();
-      validateBuilders();
-
-      for (ComponentMethodDescriptor componentMethod :
-           subject.componentDescriptor().componentMethods()) {
-        Optional<DependencyRequest> entryPoint = componentMethod.dependencyRequest();
-        if (entryPoint.isPresent()) {
-          traverseRequest(entryPoint.get(), new DependencyPath());
-        }
-      }
-
-      for (Map.Entry<ComponentMethodDescriptor, ComponentDescriptor> entry :
-          filterKeys(
-                  subject.componentDescriptor().subcomponents(),
-                  isOfKind(SUBCOMPONENT, PRODUCTION_SUBCOMPONENT))
-              .entrySet()) {
-        validateSubcomponentFactoryMethod(
-            entry.getKey().methodElement(), entry.getValue().componentDefinitionType());
-      }
+    /** Returns the report builder for a (sub)component. */
+    private ValidationReport.Builder<TypeElement> report(BindingGraph graph) {
+      return reports.computeIfAbsent(
+          graph.componentDescriptor(),
+          descriptor -> ValidationReport.about(descriptor.componentDefinitionType()));
+    }
 
-      for (BindingGraph subgraph : subject.subgraphs().values()) {
-        Validation subgraphValidation = new Validation(subgraph, Optional.of(this));
-        subgraphValidation.validateSubgraph();
-        reportBuilder.addSubreport(subgraphValidation.buildReport());
-      }
+    @Override
+    protected void visitComponent(BindingGraph graph) {
+      validateDependencyScopes(graph);
+      validateComponentDependencyHierarchy(graph);
+      validateBuilders(graph);
+      super.visitComponent(graph);
+      checkScopedBindings(graph);
     }
 
-    private void validateSubcomponentFactoryMethod(
-        ExecutableElement factoryMethod, TypeElement subcomponentType) {
-      BindingGraph subgraph = subject.subgraphs().get(factoryMethod);
-      FluentIterable<TypeElement> missingModules =
-          FluentIterable.from(subgraph.componentRequirements())
-              .filter(not(in(subgraphFactoryMethodParameters(factoryMethod))))
+    @Override
+    protected void visitSubcomponentFactoryMethod(
+        BindingGraph graph, BindingGraph parent, ExecutableElement factoryMethod) {
+      Set<TypeElement> missingModules =
+          graph
+              .componentRequirements()
+              .stream()
               .filter(
-                  new Predicate<TypeElement>() {
-                    @Override
-                    public boolean apply(TypeElement moduleType) {
-                      return !componentCanMakeNewInstances(moduleType);
-                    }
-                  });
+                  componentRequirement ->
+                      componentRequirement.kind().equals(ComponentRequirement.Kind.MODULE))
+              .map(ComponentRequirement::typeElement)
+              .filter(
+                  moduleType ->
+                      !subgraphFactoryMethodParameters(parent, factoryMethod).contains(moduleType))
+              .filter(moduleType -> !componentCanMakeNewInstances(moduleType))
+              .collect(toSet());
       if (!missingModules.isEmpty()) {
-        reportBuilder.addError(
-            String.format(
-                "%s requires modules which have no visible default constructors. "
-                    + "Add the following modules as parameters to this method: %s",
-                subcomponentType.getQualifiedName(),
-                Joiner.on(", ").join(missingModules.toSet())),
-            factoryMethod);
+        report(parent)
+            .addError(
+                String.format(
+                    "%s requires modules which have no visible default constructors. "
+                        + "Add the following modules as parameters to this method: %s",
+                    graph.componentType().getQualifiedName(),
+                    missingModules.stream().map(Object::toString).collect(joining(", "))),
+                factoryMethod);
       }
     }
 
     private ImmutableSet<TypeElement> subgraphFactoryMethodParameters(
-        ExecutableElement factoryMethod) {
-      DeclaredType componentType =
-          asDeclared(subject.componentDescriptor().componentDefinitionType().asType());
+        BindingGraph parent, ExecutableElement childFactoryMethod) {
+      DeclaredType componentType = asDeclared(parent.componentType().asType());
       ExecutableType factoryMethodType =
-          asExecutable(types.asMemberOf(componentType, factoryMethod));
+          asExecutable(types.asMemberOf(componentType, childFactoryMethod));
       return asTypeElements(factoryMethodType.getParameterTypes());
     }
 
-    /**
-     * Traverse the resolved dependency requests, validating resolved bindings, and reporting any
-     * cycles found.
-     *
-     * @param request the current dependency request
-     */
-    private void traverseRequest(DependencyRequest request, DependencyPath path) {
-      path.push(ResolvedRequest.create(request, subject));
-      try {
-        if (path.hasCycle()) {
-          reportCycle(path);
-          return;
-        }
-
-        if (path.visitCurrentRequest()) {
-          validateResolvedBinding(path);
-
-          // Validate all dependencies within the component that owns the binding.
-          for (Map.Entry<ComponentDescriptor, ? extends Binding> entry :
-              path.currentBinding().bindingsByComponent()) {
-            Validation validation = validationForComponent(entry.getKey());
-            Binding binding = entry.getValue();
-            for (DependencyRequest nextRequest : binding.implicitDependencies()) {
-              validation.traverseRequest(nextRequest, path);
-            }
-          }
-        }
-      } finally {
-        path.pop();
-      }
-    }
-
-    private Validation validationForComponent(ComponentDescriptor component) {
-      if (component.equals(subject.componentDescriptor())) {
-        return this;
-      } else if (parent.isPresent()) {
-        return parent.get().validationForComponent(component);
-      } else {
-        throw new IllegalArgumentException(
-            String.format(
-                "unknown component %s within %s",
-                component.componentDefinitionType(),
-                subject.componentDescriptor().componentDefinitionType()));
-      }
-    }
-
-    /**
-     * Reports errors if the set of bindings resolved is inconsistent with the type of the binding.
-     */
-    private void validateResolvedBinding(DependencyPath path) {
-      ResolvedBindings resolvedBinding = path.currentBinding();
-      if (resolvedBinding.isEmpty()) {
-        reportMissingBinding(path);
-        return;
-      }
-
-      switch (resolvedBinding.bindingKey().kind()) {
-        case CONTRIBUTION:
-          if (Iterables.any(
-              resolvedBinding.bindings(), BindingType.isOfType(BindingType.MEMBERS_INJECTION))) {
-            // TODO(dpb): How could this ever happen, even in an invalid graph?
-            throw new AssertionError(
-                "contribution binding keys should never have members injection bindings");
-          }
-          validateNullability(
-              path.currentDependencyRequest(), resolvedBinding.contributionBindings());
-          if (resolvedBinding.contributionBindings().size() > 1) {
-            reportDuplicateBindings(path);
-            return;
-          }
-          ContributionBinding binding =
-              Iterables.getOnlyElement(resolvedBinding.contributionBindings());
-          if (binding.bindingKind().equals(INJECTION)) {
-            TypeMirror type = resolvedBinding.bindingKey().key().type();
-            ValidationReport<TypeElement> report =
-                injectValidator.validateType(MoreTypes.asTypeElement(type));
-            if (!report.isClean()) {
-              reportBuilder.addSubreport(report);
-              return;
-            }
-          }
-          ContributionBinding contributionBinding = resolvedBinding.contributionBinding();
-          if (contributionBinding.bindingType().equals(BindingType.PRODUCTION)
-              && doesPathRequireProvisionOnly(path)) {
-            reportProviderMayNotDependOnProducer(path);
-            return;
-          }
-          if (compilerOptions.usesProducers()) {
-            Key productionImplementationExecutorKey =
-                keyFactory.forProductionImplementationExecutor();
-            // only forbid depending on the production executor if it's not the Dagger-specific
-            // binding to the implementation
-            if (!contributionBinding.key().equals(productionImplementationExecutorKey)) {
-              Key productionExecutorKey = keyFactory.forProductionExecutor();
-              for (DependencyRequest request : contributionBinding.dependencies()) {
-                if (request.key().equals(productionExecutorKey)
-                    || request.key().equals(productionImplementationExecutorKey)) {
-                  reportDependsOnProductionExecutor(path);
-                  return;
-                }
-              }
-            }
-          }
-          if (contributionBinding.bindingKind().equals(SYNTHETIC_MULTIBOUND_MAP)) {
-            ImmutableSet<ContributionBinding> multibindings =
-                inlineSyntheticNondelegateContributions(resolvedBinding).contributionBindings();
-            validateMapKeySet(path, multibindings);
-            validateMapKeyAnnotationTypes(path, multibindings);
-          }
-          break;
-        case MEMBERS_INJECTION:
-          if (!Iterables.all(
-              resolvedBinding.bindings(), BindingType.isOfType(BindingType.MEMBERS_INJECTION))) {
-            // TODO(dpb): How could this ever happen, even in an invalid graph?
-            throw new AssertionError(
-                "members injection binding keys should never have contribution bindings");
-          }
-          if (resolvedBinding.bindings().size() > 1) {
-            reportDuplicateBindings(path);
-            return;
-          }
-          validateMembersInjectionBinding(getOnlyElement(resolvedBinding.bindings()), path);
-          return;
-        default:
-          throw new AssertionError();
-      }
-    }
-
-    /**
-     * Returns an object that contains all the same bindings as {@code resolvedBindings}, except
-     * that any synthetic {@link ContributionBinding}s are replaced by the contribution bindings and
-     * multibinding declarations of their dependencies.
-     *
-     * <p>For example, if:
-     *
-     * <ul>
-     * <li>The bindings for {@code key1} are {@code A} and {@code B}, with multibinding declaration
-     *     {@code X}.
-     * <li>{@code B} is a synthetic binding with a dependency on {@code key2}.
-     * <li>The bindings for {@code key2} are {@code C} and {@code D}, with multibinding declaration
-     *     {@code Y}.
-     * </ul>
-     *
-     * then {@code inlineSyntheticNondelegateContributions(bindingsForKey1)} has bindings {@code A},
-     * {@code C}, and {@code D}, with multibinding declarations {@code X} and {@code Y}.
-     *
-     * <p>The replacement is repeated until none of the bindings are synthetic.
-     */
-    // TODO(dpb): The actual operation we want is to inline bindings without real binding elements.
-    // Delegate bindings are the first example of synthetic bindings that have real binding elements
-    // and nonsynthetic dependencies.
-    private ResolvedBindings inlineSyntheticNondelegateContributions(
-        ResolvedBindings resolvedBinding) {
-      if (!FluentIterable.from(resolvedBinding.contributionBindings())
-          .transform(ContributionBinding.KIND)
-          .anyMatch(IS_SYNTHETIC_KIND)) {
-        return resolvedBinding;
-      }
-
-      ImmutableSetMultimap.Builder<ComponentDescriptor, ContributionBinding> contributions =
-          ImmutableSetMultimap.builder();
-      ImmutableSet.Builder<MultibindingDeclaration> multibindingDeclarations =
-          ImmutableSet.builder();
-
-      Queue<ResolvedBindings> queue = new ArrayDeque<>();
-      queue.add(resolvedBinding);
-
-      for (ResolvedBindings queued = queue.poll(); queued != null; queued = queue.poll()) {
-        multibindingDeclarations.addAll(queued.multibindingDeclarations());
-        for (Map.Entry<ComponentDescriptor, ContributionBinding> bindingEntry :
-            queued.allContributionBindings().entries()) {
-          BindingGraph owningGraph = validationForComponent(bindingEntry.getKey()).subject;
-          ContributionBinding binding = bindingEntry.getValue();
-          if (binding.isSyntheticBinding()
-              && !binding.bindingKind().equals(SYNTHETIC_DELEGATE_BINDING)) {
-            for (DependencyRequest dependency : binding.dependencies()) {
-              queue.add(owningGraph.resolvedBindings().get(dependency.bindingKey()));
-            }
-          } else {
-            contributions.put(bindingEntry);
-          }
-        }
-      }
-      return ResolvedBindings.forContributionBindings(
-          resolvedBinding.bindingKey(),
-          resolvedBinding.owningComponent(),
-          contributions.build(),
-          multibindingDeclarations.build());
-    }
-
-    private ImmutableListMultimap<ContributionType, BindingDeclaration> declarationsByType(
-        ResolvedBindings resolvedBinding) {
-      ResolvedBindings inlined = inlineSyntheticNondelegateContributions(resolvedBinding);
-      return new ImmutableListMultimap.Builder<ContributionType, BindingDeclaration>()
-          .putAll(indexByContributionType(inlined.contributionBindings()))
-          .putAll(indexByContributionType(inlined.multibindingDeclarations()))
-          .build();
-    }
-
-    /** Ensures that if the request isn't nullable, then each contribution is also not nullable. */
-    private void validateNullability(DependencyRequest request, Set<ContributionBinding> bindings) {
-      if (request.isNullable()) {
-        return;
-      }
-
-      // Note: the method signature will include the @Nullable in it!
-      /* TODO(sameb): Sometimes javac doesn't include the Element in its output.
-       * (Maybe this happens if the code was already compiled before this point?)
-       * ... we manually print out the request in that case, otherwise the error
-       * message is kind of useless. */
-      String typeName = TypeName.get(request.key().type()).toString();
-
-      for (ContributionBinding binding : bindings) {
-        if (binding.nullableType().isPresent()) {
-          reportBuilder.addItem(
-              nullableToNonNullable(typeName, bindingDeclarationFormatter.format(binding))
-                  + "\n at: "
-                  + dependencyRequestFormatter.format(request),
-              compilerOptions.nullableValidationKind(),
-              request.requestElement());
-        }
-      }
-    }
-
-    /**
-     * Reports errors if {@code mapBindings} has more than one binding for the same map key.
-     */
-    private void validateMapKeySet(DependencyPath path, Set<ContributionBinding> mapBindings) {
-      for (Collection<ContributionBinding> mapBindingsForMapKey :
-          indexMapBindingsByMapKey(mapBindings).asMap().values()) {
-        if (mapBindingsForMapKey.size() > 1) {
-          reportDuplicateMapKeys(path, mapBindingsForMapKey);
-        }
-      }
-    }
-
-    /**
-     * Reports errors if {@code mapBindings} uses more than one {@link MapKey} annotation type.
-     */
-    private void validateMapKeyAnnotationTypes(
-        DependencyPath path, Set<ContributionBinding> contributionBindings) {
-      ImmutableSetMultimap<Equivalence.Wrapper<DeclaredType>, ContributionBinding>
-          mapBindingsByAnnotationType = indexMapBindingsByAnnotationType(contributionBindings);
-      if (mapBindingsByAnnotationType.keySet().size() > 1) {
-        reportInconsistentMapKeyAnnotations(path, mapBindingsByAnnotationType);
-      }
-    }
-
-    /**
-     * Reports errors if a members injection binding is invalid.
-     */
-    private void validateMembersInjectionBinding(Binding binding, final DependencyPath path) {
-      binding
-          .key()
-          .type()
-          .accept(
-              new SimpleTypeVisitor6<Void, Void>() {
-                @Override
-                protected Void defaultAction(TypeMirror e, Void p) {
-                  reportBuilder.addError(
-                      "Invalid members injection request.",
-                      path.currentDependencyRequest().requestElement());
-                  return null;
-                }
-
-                @Override
-                public Void visitDeclared(DeclaredType type, Void ignored) {
-                  // If the key has type arguments, validate that each type argument is declared.
-                  // Otherwise the type argument may be a wildcard (or other type), and we can't
-                  // resolve that to actual types.  If the arg was an array, validate the type
-                  // of the array.
-                  for (TypeMirror arg : type.getTypeArguments()) {
-                    boolean declared;
-                    switch (arg.getKind()) {
-                      case ARRAY:
-                        declared =
-                            MoreTypes.asArray(arg)
-                                .getComponentType()
-                                .accept(
-                                    new SimpleTypeVisitor6<Boolean, Void>() {
-                                      @Override
-                                      protected Boolean defaultAction(TypeMirror e, Void p) {
-                                        return false;
-                                      }
-
-                                      @Override
-                                      public Boolean visitDeclared(DeclaredType t, Void p) {
-                                        for (TypeMirror arg : t.getTypeArguments()) {
-                                          if (!arg.accept(this, null)) {
-                                            return false;
-                                          }
-                                        }
-                                        return true;
-                                      }
-
-                                      @Override
-                                      public Boolean visitArray(ArrayType t, Void p) {
-                                        return t.getComponentType().accept(this, null);
-                                      }
-
-                                      @Override
-                                      public Boolean visitPrimitive(PrimitiveType t, Void p) {
-                                        return true;
-                                      }
-                                    },
-                                    null);
-                        break;
-                      case DECLARED:
-                        declared = true;
-                        break;
-                      default:
-                        declared = false;
-                    }
-                    if (!declared) {
-                      reportBuilder.addError(
-                          String.format(
-                              MEMBERS_INJECTION_WITH_UNBOUNDED_TYPE,
-                              arg.toString(),
-                              type.toString(),
-                              dependencyRequestFormatter.toDependencyTrace(path)),
-                          path.entryPointElement());
-                      return null;
-                    }
-                  }
-
-                  TypeElement element = MoreElements.asType(type.asElement());
-                  // Also validate that the key is not the erasure of a generic type.
-                  // If it is, that means the user referred to Foo<T> as just 'Foo',
-                  // which we don't allow.  (This is a judgement call -- we *could*
-                  // allow it and instantiate the type bounds... but we don't.)
-                  if (!MoreTypes.asDeclared(element.asType()).getTypeArguments().isEmpty()
-                      && types.isSameType(types.erasure(element.asType()), type)) {
-                    reportBuilder.addError(
-                        String.format(
-                            ErrorMessages.MEMBERS_INJECTION_WITH_RAW_TYPE,
-                            type.toString(),
-                            dependencyRequestFormatter.toDependencyTrace(path)),
-                        path.entryPointElement());
-                  }
-                  return null;
-                }
-              },
-              null);
-    }
-
-    /**
-     * Validates that component dependencies do not form a cycle.
-     */
-    private void validateComponentHierarchy() {
-      ComponentDescriptor descriptor = subject.componentDescriptor();
-      TypeElement componentType = descriptor.componentDefinitionType();
-      validateComponentHierarchy(componentType, componentType, new ArrayDeque<TypeElement>());
+    /** Validates that component dependencies do not form a cycle. */
+    private void validateComponentDependencyHierarchy(BindingGraph graph) {
+      validateComponentDependencyHierarchy(graph, graph.componentType(), new ArrayDeque<>());
     }
 
-    /**
-     * Recursive method to validate that component dependencies do not form a cycle.
-     */
-    private void validateComponentHierarchy(
-        TypeElement rootComponent,
-        TypeElement componentType,
-        Deque<TypeElement> componentStack) {
-
-      if (componentStack.contains(componentType)) {
+    /** Recursive method to validate that component dependencies do not form a cycle. */
+    private void validateComponentDependencyHierarchy(
+        BindingGraph graph, TypeElement dependency, Deque<TypeElement> dependencyStack) {
+      if (dependencyStack.contains(dependency)) {
         // Current component has already appeared in the component chain.
         StringBuilder message = new StringBuilder();
-        message.append(rootComponent.getQualifiedName());
+        message.append(graph.componentType().getQualifiedName());
         message.append(" contains a cycle in its component dependencies:\n");
-        componentStack.push(componentType);
-        appendIndentedComponentsList(message, componentStack);
-        componentStack.pop();
-        reportBuilder.addItem(
-            message.toString(),
-            compilerOptions.scopeCycleValidationType().diagnosticKind().get(),
-            rootComponent,
-            getAnnotationMirror(rootComponent, Component.class).get());
+        dependencyStack.push(dependency);
+        appendIndentedComponentsList(message, dependencyStack);
+        dependencyStack.pop();
+        report(graph)
+            .addItem(
+                message.toString(),
+                compilerOptions.scopeCycleValidationType().diagnosticKind().get(),
+                graph.componentType(),
+                getComponentAnnotation(graph.componentType()).get());
       } else {
-        Optional<AnnotationMirror> componentAnnotation =
-            getAnnotationMirror(componentType, Component.class);
+        Optional<AnnotationMirror> componentAnnotation = getComponentAnnotation(dependency);
         if (componentAnnotation.isPresent()) {
-          componentStack.push(componentType);
+          dependencyStack.push(dependency);
 
           ImmutableSet<TypeElement> dependencies =
               MoreTypes.asTypeElements(getComponentDependencies(componentAnnotation.get()));
-          for (TypeElement dependency : dependencies) {
-            validateComponentHierarchy(rootComponent, dependency, componentStack);
+          for (TypeElement nextDependency : dependencies) {
+            validateComponentDependencyHierarchy(graph, nextDependency, dependencyStack);
           }
 
-          componentStack.pop();
+          dependencyStack.pop();
         }
       }
     }
 
     /**
-     * Validates that among the dependencies are at most one scoped dependency,
-     * that there are no cycles within the scoping chain, and that singleton
-     * components have no scoped dependencies.
+     * Validates that among the dependencies are at most one scoped dependency, that there are no
+     * cycles within the scoping chain, and that singleton components have no scoped dependencies.
      */
-    private void validateDependencyScopes() {
-      ComponentDescriptor descriptor = subject.componentDescriptor();
+    private void validateDependencyScopes(BindingGraph graph) {
+      ComponentDescriptor descriptor = graph.componentDescriptor();
       ImmutableSet<Scope> scopes = descriptor.scopes();
       ImmutableSet<TypeElement> scopedDependencies = scopedTypesIn(descriptor.dependencies());
       if (!scopes.isEmpty()) {
@@ -740,11 +296,12 @@ private void validateDependencyScopes() {
             StringBuilder message = new StringBuilder(
                 "This @Singleton component cannot depend on scoped components:\n");
             appendIndentedComponentsList(message, scopedDependencies);
-            reportBuilder.addItem(
-                message.toString(),
-                compilerOptions.scopeCycleValidationType().diagnosticKind().get(),
-                descriptor.componentDefinitionType(),
-                descriptor.componentAnnotation());
+            report(graph)
+                .addItem(
+                    message.toString(),
+                    compilerOptions.scopeCycleValidationType().diagnosticKind().get(),
+                    descriptor.componentDefinitionType(),
+                    descriptor.componentAnnotation());
           }
         } else if (scopedDependencies.size() > 1) {
           // Scoped components may depend on at most one scoped component.
@@ -756,14 +313,16 @@ private void validateDependencyScopes() {
               .append(descriptor.componentDefinitionType().getQualifiedName())
               .append(" depends on more than one scoped component:\n");
           appendIndentedComponentsList(message, scopedDependencies);
-          reportBuilder.addError(
-              message.toString(),
-              descriptor.componentDefinitionType(),
-              descriptor.componentAnnotation());
+          report(graph)
+              .addError(
+                  message.toString(),
+                  descriptor.componentDefinitionType(),
+                  descriptor.componentAnnotation());
         } else {
           // Dagger 1.x scope compatibility requires this be suppress-able.
           if (!compilerOptions.scopeCycleValidationType().equals(ValidationType.NONE)) {
-            validateScopeHierarchy(descriptor.componentDefinitionType(),
+            validateDependencyScopeHierarchy(
+                graph,
                 descriptor.componentDefinitionType(),
                 new ArrayDeque<ImmutableSet<Scope>>(),
                 new ArrayDeque<TypeElement>());
@@ -776,54 +335,91 @@ private void validateDependencyScopes() {
               new StringBuilder(descriptor.componentDefinitionType().getQualifiedName())
                   .append(" (unscoped) cannot depend on scoped components:\n");
           appendIndentedComponentsList(message, scopedDependencies);
-          reportBuilder.addError(
-              message.toString(),
-              descriptor.componentDefinitionType(),
-              descriptor.componentAnnotation());
+          report(graph)
+              .addError(
+                  message.toString(),
+                  descriptor.componentDefinitionType(),
+                  descriptor.componentAnnotation());
         }
       }
     }
 
-    private void validateBuilders() {
-      ComponentDescriptor componentDesc = subject.componentDescriptor();
+    private void validateBuilders(BindingGraph graph) {
+      ComponentDescriptor componentDesc = graph.componentDescriptor();
       if (!componentDesc.builderSpec().isPresent()) {
         // If no builder, nothing to validate.
         return;
       }
 
-      Set<TypeElement> availableDependencies = subject.availableDependencies();
-      Set<TypeElement> requiredDependencies =
+      Set<ComponentRequirement> availableDependencies = graph.availableDependencies();
+      Set<ComponentRequirement> requiredDependencies =
           Sets.filter(
-              availableDependencies,
-              new Predicate<TypeElement>() {
-                @Override
-                public boolean apply(TypeElement input) {
-                  return !Util.componentCanMakeNewInstances(input);
-                }
-              });
+              availableDependencies, input -> !componentCanMakeNewInstances(input.typeElement()));
       final BuilderSpec spec = componentDesc.builderSpec().get();
-      Map<TypeElement, ExecutableElement> allSetters = spec.methodMap();
+      ImmutableSet<BuilderRequirementMethod> declaredSetters =
+          spec.requirementMethods()
+              .stream()
+              .filter(
+                  method -> !method.requirement().kind().equals(ComponentRequirement.Kind.BINDING))
+              .collect(toImmutableSet());
+      ImmutableSet<ComponentRequirement> declaredRequirements =
+          declaredSetters
+              .stream()
+              .map(BuilderRequirementMethod::requirement)
+              .collect(toImmutableSet());
 
       ErrorMessages.ComponentBuilderMessages msgs =
-          ErrorMessages.builderMsgsFor(subject.componentDescriptor().kind());
-      Set<TypeElement> extraSetters = Sets.difference(allSetters.keySet(), availableDependencies);
+          ErrorMessages.builderMsgsFor(graph.componentDescriptor().kind());
+      Set<ComponentRequirement> extraSetters =
+          Sets.difference(declaredRequirements, availableDependencies);
       if (!extraSetters.isEmpty()) {
-        Collection<ExecutableElement> excessMethods =
-            Maps.filterKeys(allSetters, Predicates.in(extraSetters)).values();
-        Iterable<String> formatted = FluentIterable.from(excessMethods).transform(
-            new Function<ExecutableElement, String>() {
-              @Override public String apply(ExecutableElement input) {
-                return methodSignatureFormatter.format(input,
-                    Optional.of(MoreTypes.asDeclared(spec.builderDefinitionType().asType())));
-              }});
-        reportBuilder.addError(
-            String.format(msgs.extraSetters(), formatted), spec.builderDefinitionType());
+        List<ExecutableElement> excessMethods =
+            declaredSetters
+                .stream()
+                .filter(method -> extraSetters.contains(method.requirement()))
+                .map(BuilderRequirementMethod::method)
+                .collect(toList());
+        Optional<DeclaredType> container =
+            Optional.of(MoreTypes.asDeclared(spec.builderDefinitionType().asType()));
+        String formatted =
+            excessMethods
+                .stream()
+                .map(method -> methodSignatureFormatter.format(method, container))
+                .collect(joining(", ", "[", "]"));
+        report(graph)
+            .addError(String.format(msgs.extraSetters(), formatted), spec.builderDefinitionType());
       }
 
-      Set<TypeElement> missingSetters = Sets.difference(requiredDependencies, allSetters.keySet());
+      Set<ComponentRequirement> missingSetters =
+          Sets.difference(requiredDependencies, declaredRequirements);
       if (!missingSetters.isEmpty()) {
-        reportBuilder.addError(
-            String.format(msgs.missingSetters(), missingSetters), spec.builderDefinitionType());
+        report(graph)
+            .addError(
+                String.format(
+                    msgs.missingSetters(),
+                    missingSetters.stream().map(ComponentRequirement::type).collect(toList())),
+                spec.builderDefinitionType());
+      }
+
+      // Validate that declared builder requirements (modules, dependencies) have unique types.
+      Map<Equivalence.Wrapper<TypeMirror>, List<ExecutableElement>> declaredRequirementsByType =
+          spec.requirementMethods()
+              .stream()
+              .filter(
+                  method -> !method.requirement().kind().equals(ComponentRequirement.Kind.BINDING))
+              .collect(
+                  groupingBy(
+                      method -> method.requirement().wrappedType(),
+                      mapping(method -> method.method(), toList())));
+      for (Map.Entry<Equivalence.Wrapper<TypeMirror>, List<ExecutableElement>> entry :
+          declaredRequirementsByType.entrySet()) {
+        if (entry.getValue().size() > 1) {
+          TypeMirror type = entry.getKey().get();
+          report(graph)
+              .addError(
+                  String.format(msgs.manyMethodsForType(), type, entry.getValue()),
+                  spec.builderDefinitionType());
+        }
       }
     }
 
@@ -833,48 +429,52 @@ public boolean apply(TypeElement input) {
      *
      * <p>As a side-effect, this means scoped components cannot have a dependency cycle between
      * themselves, since a component's presence within its own dependency path implies a cyclical
-     * relationship between scopes. However, cycles in component dependencies are explicitly
-     * checked in {@link #validateComponentHierarchy()}.
+     * relationship between scopes. However, cycles in component dependencies are explicitly checked
+     * in {@link #validateComponentDependencyHierarchy(BindingGraph)}.
      */
-    private void validateScopeHierarchy(TypeElement rootComponent,
-        TypeElement componentType,
+    private void validateDependencyScopeHierarchy(
+        BindingGraph graph,
+        TypeElement dependency,
         Deque<ImmutableSet<Scope>> scopeStack,
         Deque<TypeElement> scopedDependencyStack) {
-      ImmutableSet<Scope> scopes = Scope.scopesOf(componentType);
+      ImmutableSet<Scope> scopes = Scope.scopesOf(dependency);
       if (stackOverlaps(scopeStack, scopes)) {
-        scopedDependencyStack.push(componentType);
+        scopedDependencyStack.push(dependency);
         // Current scope has already appeared in the component chain.
         StringBuilder message = new StringBuilder();
-        message.append(rootComponent.getQualifiedName());
+        message.append(graph.componentType().getQualifiedName());
         message.append(" depends on scoped components in a non-hierarchical scope ordering:\n");
         appendIndentedComponentsList(message, scopedDependencyStack);
         if (compilerOptions.scopeCycleValidationType().diagnosticKind().isPresent()) {
-          reportBuilder.addItem(
-              message.toString(),
-              compilerOptions.scopeCycleValidationType().diagnosticKind().get(),
-              rootComponent,
-              getAnnotationMirror(rootComponent, Component.class)
-                  .or(getAnnotationMirror(rootComponent, ProductionComponent.class))
-                  .get());
+          report(graph)
+              .addItem(
+                  message.toString(),
+                  compilerOptions.scopeCycleValidationType().diagnosticKind().get(),
+                  graph.componentType(),
+                  getComponentAnnotation(graph.componentType()).get());
         }
         scopedDependencyStack.pop();
       } else {
         // TODO(beder): transitively check scopes of production components too.
-        Optional<AnnotationMirror> componentAnnotation =
-            getAnnotationMirror(componentType, Component.class);
-        if (componentAnnotation.isPresent()) {
-          ImmutableSet<TypeElement> scopedDependencies = scopedTypesIn(
-              MoreTypes.asTypeElements(getComponentDependencies(componentAnnotation.get())));
-          if (scopedDependencies.size() == 1) {
-            // empty can be ignored (base-case), and > 1 is a different error reported separately.
-            scopeStack.push(scopes);
-            scopedDependencyStack.push(componentType);
-            validateScopeHierarchy(rootComponent, getOnlyElement(scopedDependencies),
-                scopeStack, scopedDependencyStack);
-            scopedDependencyStack.pop();
-            scopeStack.pop();
-          }
-        } // else: we skip component dependencies which are not components
+        getAnnotationMirror(dependency, Component.class)
+            .ifPresent(
+                componentAnnotation -> {
+                  ImmutableSet<TypeElement> scopedDependencies =
+                      scopedTypesIn(
+                          MoreTypes.asTypeElements(getComponentDependencies(componentAnnotation)));
+                  if (scopedDependencies.size() == 1) {
+                    // empty can be ignored (base-case), and > 1 is a separately-reported error.
+                    scopeStack.push(scopes);
+                    scopedDependencyStack.push(dependency);
+                    validateDependencyScopeHierarchy(
+                        graph,
+                        getOnlyElement(scopedDependencies),
+                        scopeStack,
+                        scopedDependencyStack);
+                    scopedDependencyStack.pop();
+                    scopeStack.pop();
+                  }
+                }); // else: we skip component dependencies which are not components
       }
     }
 
@@ -888,330 +488,689 @@ private void validateScopeHierarchy(TypeElement rootComponent,
     }
 
     /**
-     * Validates that the scope (if any) of this component are compatible with the scopes of the
-     * bindings available in this component
+     * Collects scoped bindings that are not compatible with their owning component for later
+     * reporting by {@link #checkScopedBindings(BindingGraph)}.
+     */
+    private void checkBindingScope(
+        ContributionBinding binding, ComponentDescriptor owningComponent) {
+      if (binding.scope().isPresent()
+          && !binding.scope().get().equals(reusableScope(elements))
+          && !owningComponent.scopes().contains(binding.scope().get())) {
+        incompatiblyScopedBindings.put(owningComponent, binding);
+      }
+    }
+
+    /**
+     * Reports an error if any of the scoped bindings owned by a given component are incompatible
+     * with the component. Must be called after all bindings owned by the given component have been
+     * {@linkplain #checkBindingScope(ContributionBinding, ComponentDescriptor) visited}.
      */
-    void validateComponentScope() {
-      ImmutableMap<BindingKey, ResolvedBindings> resolvedBindings = subject.resolvedBindings();
-      ImmutableSet<Scope> componentScopes = subject.componentDescriptor().scopes();
-      ImmutableSet.Builder<String> incompatiblyScopedMethodsBuilder = ImmutableSet.builder();
-      Scope reusableScope = reusableScope(elements);
-      for (ResolvedBindings bindings : resolvedBindings.values()) {
-        for (ContributionBinding contributionBinding : bindings.ownedContributionBindings()) {
-          Optional<Scope> bindingScope = contributionBinding.scope();
-          if (bindingScope.isPresent()
-              && !bindingScope.get().equals(reusableScope)
-              && !componentScopes.contains(bindingScope.get())) {
-            // Scoped components cannot reference bindings to @Provides methods or @Inject
-            // types decorated by a different scope annotation. Unscoped components cannot
-            // reference to scoped @Provides methods or @Inject types decorated by any
-            // scope annotation.
-            switch (contributionBinding.bindingKind()) {
-              case SYNTHETIC_DELEGATE_BINDING:
-              case PROVISION:
-                incompatiblyScopedMethodsBuilder.add(
-                    methodSignatureFormatter.format(
-                        contributionBinding.bindingElementAsExecutable()));
-                break;
-              case INJECTION:
-                incompatiblyScopedMethodsBuilder.add(
-                    bindingScope.get().getReadableSource()
-                        + " class "
-                        + contributionBinding.bindingTypeElement().getQualifiedName());
-                break;
-              default:
-                throw new IllegalStateException();
+    private void checkScopedBindings(BindingGraph graph) {
+      if (!incompatiblyScopedBindings.containsKey(graph.componentDescriptor())) {
+        return;
+      }
+
+      StringBuilder message = new StringBuilder(graph.componentType().getQualifiedName());
+      if (!graph.componentDescriptor().scopes().isEmpty()) {
+        message.append(" scoped with ");
+        for (Scope scope : graph.componentDescriptor().scopes()) {
+          message.append(scope.getReadableSource()).append(' ');
+        }
+        message.append("may not reference bindings with different scopes:\n");
+      } else {
+        message.append(" (unscoped) may not reference scoped bindings:\n");
+      }
+      for (ContributionBinding binding :
+          incompatiblyScopedBindings.get(graph.componentDescriptor())) {
+        message.append(ErrorMessages.INDENT);
+
+        switch (binding.bindingKind()) {
+          case SYNTHETIC_DELEGATE_BINDING:
+          case PROVISION:
+            message.append(
+                methodSignatureFormatter.format(
+                    MoreElements.asExecutable(binding.bindingElement().get())));
+            break;
+
+          case INJECTION:
+            message
+                .append(binding.scope().get().getReadableSource())
+                .append(" class ")
+                .append(binding.bindingTypeElement().get().getQualifiedName());
+            break;
+
+          default:
+            throw new AssertionError(binding);
+        }
+
+        message.append("\n");
+      }
+      report(graph)
+          .addError(
+              message.toString(),
+              graph.componentType(),
+              graph.componentDescriptor().componentAnnotation());
+    }
+
+    final class BindingGraphValidation extends BindingGraphTraverser {
+
+      BindingGraphValidation(ComponentTreePath componentPath, DependencyRequest entryPoint) {
+        super(componentPath, entryPoint);
+      }
+
+      /** Reports an error for the current component at the entry point. */
+      private void reportErrorAtEntryPoint(String format, Object... args) {
+        reportErrorAtEntryPoint(currentGraph(), format, args);
+      }
+
+      /** Reports an error for the given component at the entry point. */
+      private void reportErrorAtEntryPoint(BindingGraph graph, String format, Object... args) {
+        String message = args.length == 0 ? format : String.format(format, args);
+        report(graph).addError(message, entryPointElement());
+      }
+
+      private String formatDependencyTrace() {
+        return dependencyRequestFormatter.format(dependencyTrace());
+      }
+
+      @Override
+      protected void visitDependencyRequest(DependencyRequest dependencyRequest) {
+        if (atDependencyCycle()) {
+          reportDependencyCycle();
+        }
+        super.visitDependencyRequest(dependencyRequest);
+      }
+
+      @Override
+      protected void visitResolvedBindings(ResolvedBindings resolvedBindings) {
+        if (resolvedBindings.isEmpty()) {
+          reportMissingBinding();
+        } else if (resolvedBindings.bindings().size() > 1) {
+          reportDuplicateBindings();
+        }
+        super.visitResolvedBindings(resolvedBindings);
+      }
+
+      @Override
+      protected void visitContributionBinding(
+          ContributionBinding binding, ComponentDescriptor owningComponent) {
+        checkBindingScope(binding, owningComponent);
+        if (!dependencyRequest().isNullable() && binding.nullableType().isPresent()) {
+          reportNullableBindingForNonNullableRequest(binding);
+        }
+        if (binding.bindingKind().equals(INJECTION)) {
+          TypeMirror type = binding.key().type();
+          ValidationReport<TypeElement> report =
+              injectValidator.validateType(MoreTypes.asTypeElement(type));
+          if (!report.isClean()) {
+            report(currentGraph()).addSubreport(report);
+          }
+        }
+        if (binding.bindingType().equals(PRODUCTION) && doesPathRequireProvisionOnly()) {
+          reportProviderMayNotDependOnProducer(binding);
+        }
+        if (compilerOptions.usesProducers()) {
+          // TODO(dpb,beder): Validate this during @Inject/@Provides/@Produces validation.
+          // Only the Dagger-specific binding may depend on the production executor.
+          Key productionImplementationExecutorKey =
+              keyFactory.forProductionImplementationExecutor();
+          if (!binding.key().equals(productionImplementationExecutorKey)) {
+            Key productionExecutorKey = keyFactory.forProductionExecutor();
+            for (DependencyRequest request : binding.explicitDependencies()) {
+              if (request.key().equals(productionExecutorKey)
+                  || request.key().equals(productionImplementationExecutorKey)) {
+                reportDependsOnProductionExecutor();
+              }
             }
           }
         }
+        if (binding.bindingKind().equals(SYNTHETIC_MULTIBOUND_MAP)) {
+          validateMapKeys(binding, owningComponent);
+        }
+        super.visitContributionBinding(binding, owningComponent);
       }
 
-      ImmutableSet<String> incompatiblyScopedMethods = incompatiblyScopedMethodsBuilder.build();
-      if (!incompatiblyScopedMethods.isEmpty()) {
-        TypeElement componentType = subject.componentDescriptor().componentDefinitionType();
-        StringBuilder message = new StringBuilder(componentType.getQualifiedName());
-        if (!componentScopes.isEmpty()) {
-          message.append(" scoped with ");
-          for (Scope scope : componentScopes) {
-            message.append(scope.getReadableSource()).append(' ');
+      @Override
+      protected void visitMembersInjectionBinding(
+          MembersInjectionBinding binding, ComponentDescriptor owningComponent) {
+        validateMembersInjectionBinding(binding);
+        super.visitMembersInjectionBinding(binding, owningComponent);
+      }
+
+      /**
+       * Returns the binding declarations that can be reported for {@code resolvedBindings}, indexed
+       * by the component that owns each declaration.
+       *
+       * <p>Contains all {@link MultibindingDeclaration}s, {@link SubcomponentDeclaration}s, and
+       * {@link OptionalBindingDeclaration}s within {@code resolvedBindings}, as well as all {@link
+       * ContributionBinding}s with present {@linkplain BindingDeclaration#bindingElement() binding
+       * elements}.
+       *
+       *
+       * <p>For other bindings without binding elements, such as the {@link
+       * ContributionBinding.Kind#SYNTHETIC_MULTIBOUND_KINDS}, includes the conflicting declarations
+       * in their resolved dependencies.
+       */
+      private ImmutableSetMultimap<ComponentDescriptor, BindingDeclaration>
+          reportableDeclarations() {
+        ImmutableSetMultimap.Builder<ComponentDescriptor, BindingDeclaration> declarations =
+            ImmutableSetMultimap.builder();
+
+        Queue<ResolvedBindings> queue = new ArrayDeque<>();
+        queue.add(resolvedBindings());
+
+        while (!queue.isEmpty()) {
+          ResolvedBindings queued = queue.remove();
+          declarations
+              .putAll(queued.owningComponent(), queued.multibindingDeclarations())
+              .putAll(queued.owningComponent(), queued.subcomponentDeclarations())
+              .putAll(queued.owningComponent(), queued.optionalBindingDeclarations());
+          queued
+              .allContributionBindings()
+              .asMap()
+              .forEach(
+                  (owningComponent, bindings) -> {
+                    BindingGraph owningGraph =
+                        componentTreePath().graphForComponent(owningComponent);
+                    for (ContributionBinding binding : bindings) {
+                      if (bindingDeclarationFormatter.canFormat(binding)) {
+                        declarations.put(owningComponent, binding);
+                      } else {
+                        queue.addAll(owningGraph.resolvedDependencies(binding));
+                      }
+                    }
+                  });
+        }
+
+        return declarations.build();
+      }
+
+      private void reportNullableBindingForNonNullableRequest(ContributionBinding binding) {
+        // Note: the method signature will include the @Nullable in it!
+        /* TODO(sameb): Sometimes javac doesn't include the Element in its output.
+         * (Maybe this happens if the code was already compiled before this point?)
+         * ... we manually print out the request in that case, otherwise the error
+         * message is kind of useless. */
+        FluentIterable<ContributionBinding> dependentContributions =
+            FluentIterable.from(dependentBindings()).filter(ContributionBinding.class);
+        report(owningGraph(dependentContributions.append(binding)))
+            .addItem(
+                nullableToNonNullable(
+                        TypeName.get(dependencyRequest().key().type()).toString(),
+                        bindingDeclarationFormatter.format(binding))
+                    + "\n at: "
+                    + formatDependencyTrace(),
+                compilerOptions.nullableValidationKind(),
+                entryPointElement());
+      }
+
+      private void validateMapKeys(
+          ContributionBinding binding, ComponentDescriptor owningComponent) {
+        checkArgument(
+            binding.bindingKind().equals(SYNTHETIC_MULTIBOUND_MAP),
+            "binding must be a synthetic multibound map: %s",
+            binding);
+        ImmutableSet<ContributionBinding> multibindingContributions =
+            componentTreePath()
+                .graphForComponent(owningComponent)
+                .resolvedDependencies(binding)
+                .stream()
+                .map(ResolvedBindings::contributionBinding)
+                .collect(toImmutableSet());
+        validateMapKeySet(multibindingContributions);
+        validateMapKeyAnnotationTypes(multibindingContributions);
+      }
+
+      /**
+       * Reports errors if there is more than one map binding contribution with the same map key.
+       */
+      private void validateMapKeySet(Set<ContributionBinding> mapBindingContributions) {
+        for (Collection<ContributionBinding> mapBindingsForMapKey :
+            indexMapBindingsByMapKey(mapBindingContributions).asMap().values()) {
+          if (mapBindingsForMapKey.size() > 1) {
+            reportDuplicateMapKeys(mapBindingsForMapKey);
           }
-          message.append("may not reference bindings with different scopes:\n");
-        } else {
-          message.append(" (unscoped) may not reference scoped bindings:\n");
         }
-        for (String method : incompatiblyScopedMethods) {
-          message.append(ErrorMessages.INDENT).append(method).append("\n");
+      }
+
+      /**
+       * Reports errors if there is more than one {@link MapKey} annotation type within the map
+       * binding contributions' map keys.
+       */
+      private void validateMapKeyAnnotationTypes(Set<ContributionBinding> mapBindingContributions) {
+        ImmutableSetMultimap<Equivalence.Wrapper<DeclaredType>, ContributionBinding>
+            mapBindingsByAnnotationType = indexMapBindingsByAnnotationType(mapBindingContributions);
+        if (mapBindingsByAnnotationType.keySet().size() > 1) {
+          reportInconsistentMapKeyAnnotations(mapBindingsByAnnotationType);
         }
-        reportBuilder.addError(
-            message.toString(), componentType, subject.componentDescriptor().componentAnnotation());
       }
-    }
 
-    @SuppressWarnings("resource") // Appendable is a StringBuilder.
-    private void reportProviderMayNotDependOnProducer(DependencyPath path) {
-      StringBuilder errorMessage = new StringBuilder();
-      if (path.size() == 1) {
-        new Formatter(errorMessage)
-            .format(
-                ErrorMessages.PROVIDER_ENTRY_POINT_MAY_NOT_DEPEND_ON_PRODUCER_FORMAT,
-                formatRootRequestKey(path));
-      } else {
-        ImmutableSet<? extends Binding> dependentProvisions =
-            provisionsDependingOnLatestRequest(path);
-        // TODO(beder): Consider displaying all dependent provisions in the error message. If we do
-        // that, should we display all productions that depend on them also?
-        new Formatter(errorMessage).format(ErrorMessages.PROVIDER_MAY_NOT_DEPEND_ON_PRODUCER_FORMAT,
-            keyFormatter.format(dependentProvisions.iterator().next().key()));
+      /** Reports errors if a members injection binding is invalid. */
+      // TODO(dpb): Can this be done while validating @Inject?
+      private void validateMembersInjectionBinding(MembersInjectionBinding binding) {
+        binding.key().type().accept(membersInjectionBindingValidator, binding);
       }
-      reportBuilder.addError(errorMessage.toString(), path.entryPointElement());
-    }
 
-    /**
-     * Descriptive portion of the error message for when the given request has no binding.
-     * Currently, the only other portions of the message are the dependency path, line number and
-     * filename. Not static because it uses the instance field types.
-     */
-    private StringBuilder requiresErrorMessageBase(DependencyPath path) {
-      Key key = path.currentDependencyRequest().key();
-      String requiresErrorMessageFormat;
-      // TODO(dpb): Check for wildcard injection somewhere else first?
-      if (key.type().getKind().equals(TypeKind.WILDCARD)) {
-        requiresErrorMessageFormat = CANNOT_INJECT_WILDCARD_TYPE;
-      } else {
-        boolean requiresProvision = doesPathRequireProvisionOnly(path);
-        if (!key.isValidImplicitProvisionKey(types)) {
-          requiresErrorMessageFormat = requiresProvision
-              ? REQUIRES_PROVIDER_FORMAT
-              : REQUIRES_PROVIDER_OR_PRODUCER_FORMAT;
+      private final TypeVisitor<Void, MembersInjectionBinding> membersInjectionBindingValidator =
+          new SimpleTypeVisitor8<Void, MembersInjectionBinding>() {
+            @Override
+            protected Void defaultAction(TypeMirror e, MembersInjectionBinding p) {
+              report(currentGraph())
+                  .addError("Invalid members injection request.", p.membersInjectedType());
+              return null;
+            }
+
+            @Override
+            public Void visitDeclared(DeclaredType type, MembersInjectionBinding binding) {
+              // If the key has type arguments, validate that each type argument is declared.
+              // Otherwise the type argument may be a wildcard (or other type), and we can't
+              // resolve that to actual types.  If the arg was an array, validate the type
+              // of the array.
+              for (TypeMirror arg : type.getTypeArguments()) {
+                boolean declared =
+                    arg.accept(
+                        new SimpleTypeVisitor8<Boolean, Void>(false) {
+                          @Override
+                          public Boolean visitArray(ArrayType t, Void p) {
+                            return t.getComponentType()
+                                .accept(
+                                    new SimpleTypeVisitor8<Boolean, Void>(false) {
+                                      @Override
+                                      public Boolean visitDeclared(DeclaredType t, Void p) {
+                                        for (TypeMirror arg : t.getTypeArguments()) {
+                                          if (!arg.accept(this, null)) {
+                                            return false;
+                                          }
+                                        }
+                                        return true;
+                                      }
+
+                                      @Override
+                                      public Boolean visitArray(ArrayType t, Void p) {
+                                        return t.getComponentType().accept(this, null);
+                                      }
+
+                                      @Override
+                                      public Boolean visitPrimitive(PrimitiveType t, Void p) {
+                                        return true;
+                                      }
+                                    },
+                                    null);
+                          }
+
+                          @Override
+                          public Boolean visitDeclared(DeclaredType t, Void p) {
+                            return true;
+                          }
+                        },
+                        null);
+                if (!declared) {
+                  reportErrorAtEntryPoint(
+                      MEMBERS_INJECTION_WITH_UNBOUNDED_TYPE,
+                      arg.toString(),
+                      type.toString(),
+                      formatDependencyTrace());
+                  return null;
+                }
+              }
+
+              TypeElement element = MoreElements.asType(type.asElement());
+              // Also validate that the key is not the erasure of a generic type.
+              // If it is, that means the user referred to Foo<T> as just 'Foo',
+              // which we don't allow.  (This is a judgement call -- we *could*
+              // allow it and instantiate the type bounds... but we don't.)
+              if (!MoreTypes.asDeclared(element.asType()).getTypeArguments().isEmpty()
+                  && types.isSameType(types.erasure(element.asType()), type)) {
+                reportErrorAtEntryPoint(
+                    MEMBERS_INJECTION_WITH_RAW_TYPE, type.toString(), formatDependencyTrace());
+              }
+              return null;
+            }
+          };
+
+      // TODO(b/29509141): Clarify the error.
+      private void reportProviderMayNotDependOnProducer(ContributionBinding productionBinding) {
+        if (atEntryPoint()) {
+          reportErrorAtEntryPoint(
+              PROVIDER_ENTRY_POINT_MAY_NOT_DEPEND_ON_PRODUCER_FORMAT,
+              formatCurrentDependencyRequestKey());
         } else {
-          requiresErrorMessageFormat = requiresProvision
-              ? REQUIRES_AT_INJECT_CONSTRUCTOR_OR_PROVIDER_FORMAT
-              : REQUIRES_AT_INJECT_CONSTRUCTOR_OR_PROVIDER_OR_PRODUCER_FORMAT;
+          // TODO(beder): Consider displaying all dependent provisions in the error message. If we
+          // do that, should we display all productions that depend on them also?
+          reportErrorAtEntryPoint(
+              owningGraph(provisionsDependingOnLatestRequest().append(productionBinding)),
+              PROVIDER_MAY_NOT_DEPEND_ON_PRODUCER_FORMAT,
+              provisionsDependingOnLatestRequest().iterator().next().key());
         }
       }
-      StringBuilder errorMessage = new StringBuilder(
-          String.format(requiresErrorMessageFormat, keyFormatter.format(key)));
-      if (key.isValidMembersInjectionKey()) {
-        Optional<MembersInjectionBinding> membersInjectionBinding =
-            injectBindingRegistry.getOrFindMembersInjectionBinding(key);
-        if (membersInjectionBinding.isPresent()
-            && !membersInjectionBinding.get().injectionSites().isEmpty()) {
-          errorMessage.append(" ");
-          errorMessage.append(ErrorMessages.MEMBERS_INJECTION_DOES_NOT_IMPLY_PROVISION);
+
+      /**
+       * Descriptive portion of the error message for when the given request has no binding.
+       * Currently, the only other portions of the message are the dependency path, line number and
+       * filename.
+       */
+      private StringBuilder requiresErrorMessageBase() {
+        Key key = dependencyRequest().key();
+        String requiresErrorMessageFormat;
+        // TODO(dpb): Check for wildcard injection somewhere else first?
+        if (key.type().getKind().equals(TypeKind.WILDCARD)) {
+          requiresErrorMessageFormat = CANNOT_INJECT_WILDCARD_TYPE;
+        } else {
+          boolean requiresProvision = doesPathRequireProvisionOnly();
+          if (!key.isValidImplicitProvisionKey(types)) {
+            requiresErrorMessageFormat =
+                requiresProvision ? REQUIRES_PROVIDER_FORMAT : REQUIRES_PROVIDER_OR_PRODUCER_FORMAT;
+          } else {
+            requiresErrorMessageFormat =
+                requiresProvision
+                    ? REQUIRES_AT_INJECT_CONSTRUCTOR_OR_PROVIDER_FORMAT
+                    : REQUIRES_AT_INJECT_CONSTRUCTOR_OR_PROVIDER_OR_PRODUCER_FORMAT;
+          }
+        }
+        StringBuilder errorMessage =
+            new StringBuilder(
+                String.format(requiresErrorMessageFormat, formatCurrentDependencyRequestKey()));
+        if (key.isValidMembersInjectionKey()) {
+          Optional<MembersInjectionBinding> membersInjectionBinding =
+              injectBindingRegistry.getOrFindMembersInjectionBinding(key);
+          if (membersInjectionBinding.isPresent()
+              && !membersInjectionBinding.get().injectionSites().isEmpty()) {
+            errorMessage.append(" ");
+            errorMessage.append(ErrorMessages.MEMBERS_INJECTION_DOES_NOT_IMPLY_PROVISION);
+          }
         }
+        return errorMessage.append('\n');
       }
-      return errorMessage.append('\n');
-    }
 
-    private void reportMissingBinding(DependencyPath path) {
-      StringBuilder errorMessage =
-          requiresErrorMessageBase(path).append(dependencyRequestFormatter.toDependencyTrace(path));
-      for (String suggestion :
-          MissingBindingSuggestions.forKey(
-              topLevelGraph(), path.currentDependencyRequest().bindingKey())) {
-        errorMessage.append('\n').append(suggestion);
+      private void reportMissingBinding() {
+        if (reportMissingReleasableReferenceManager()) {
+          return;
+        }
+        StringBuilder errorMessage = requiresErrorMessageBase().append(formatDependencyTrace());
+        for (String suggestion :
+            MissingBindingSuggestions.forKey(rootGraph, dependencyRequest().bindingKey())) {
+          errorMessage.append('\n').append(suggestion);
+        }
+        reportErrorAtEntryPoint(rootGraph, errorMessage.toString());
       }
-      reportBuilder.addError(errorMessage.toString(), path.entryPointElement());
-    }
 
-    @SuppressWarnings("resource") // Appendable is a StringBuilder.
-    private void reportDependsOnProductionExecutor(DependencyPath path) {
-      StringBuilder builder = new StringBuilder();
-      new Formatter(builder)
-          .format(ErrorMessages.DEPENDS_ON_PRODUCTION_EXECUTOR_FORMAT, formatRootRequestKey(path));
-      reportBuilder.addError(builder.toString(), path.entryPointElement());
-    }
+      /**
+       * If the current dependency request is missing a binding because it's an invalid
+       * {@code @ForReleasableReferences} request, reports that.
+       *
+       * <p>An invalid request is one whose type is either {@link ReleasableReferenceManager} or
+       * {@link TypedReleasableReferenceManager}, and whose scope:
+       *
+       * <ul>
+       *   <li>does not annotate any component in the hierarchy, or
+       *   <li>is not annotated with the metadata annotation type that is the {@link
+       *       TypedReleasableReferenceManager}'s type argument
+       * </ul>
+       *
+       * @return {@code true} if the request was invalid and an error was reported
+       */
+      private boolean reportMissingReleasableReferenceManager() {
+        Key key = dependencyRequest().key();
+        if (!key.qualifier().isPresent()
+            || !isTypeOf(ForReleasableReferences.class, key.qualifier().get().getAnnotationType())
+            || !isType(key.type())) {
+          return false;
+        }
 
-    @SuppressWarnings("resource") // Appendable is a StringBuilder.
-    private void reportDuplicateBindings(DependencyPath path) {
-      ResolvedBindings resolvedBinding = path.currentBinding();
-      if (FluentIterable.from(resolvedBinding.contributionBindings())
-          .transform(ContributionBinding.KIND)
-          .anyMatch(IS_SYNTHETIC_KIND)) {
-        reportMultipleBindingTypes(path);
-        return;
+        Optional<DeclaredType> metadataType;
+        if (isTypeOf(ReleasableReferenceManager.class, key.type())) {
+          metadataType = Optional.empty();
+        } else if (isTypeOf(TypedReleasableReferenceManager.class, key.type())) {
+          List<? extends TypeMirror> typeArguments =
+              MoreTypes.asDeclared(key.type()).getTypeArguments();
+          if (typeArguments.size() != 1
+              || !typeArguments.get(0).getKind().equals(TypeKind.DECLARED)) {
+            return false;
+          }
+          metadataType = Optional.of(MoreTypes.asDeclared(typeArguments.get(0)));
+        } else {
+          return false;
+        }
+
+        Scope scope =
+            Scope.scope(MoreTypes.asTypeElement(getTypeValue(key.qualifier().get(), "value")));
+        String missingRequestKey = formatCurrentDependencyRequestKey();
+        if (!rootGraph.componentDescriptor().releasableReferencesScopes().contains(scope)) {
+          reportErrorAtEntryPoint(
+              rootGraph,
+              referenceReleasingScopeNotInComponentHierarchy(missingRequestKey, scope, rootGraph));
+          return true;
+        }
+        if (metadataType.isPresent()) {
+          if (!isAnnotationPresent(scope.scopeAnnotationElement(), metadataType.get())) {
+            reportErrorAtEntryPoint(
+                rootGraph,
+                referenceReleasingScopeNotAnnotatedWithMetadata(
+                    missingRequestKey, scope, metadataType.get()));
+          }
+          if (!isAnnotationPresent(metadataType.get().asElement(), CanReleaseReferences.class)) {
+            reportErrorAtEntryPoint(
+                rootGraph,
+                referenceReleasingScopeMetadataMissingCanReleaseReferences(
+                    missingRequestKey, metadataType.get()));
+          }
+        }
+        return false;
       }
-      StringBuilder builder = new StringBuilder();
-      new Formatter(builder)
-          .format(ErrorMessages.DUPLICATE_BINDINGS_FOR_KEY_FORMAT, formatRootRequestKey(path));
-      ImmutableSet<ContributionBinding> duplicateBindings =
-          inlineSyntheticNondelegateContributions(resolvedBinding).contributionBindings();
-      bindingDeclarationFormatter.formatIndentedList(
-          builder, duplicateBindings, 1, DUPLICATE_SIZE_LIMIT);
-      owningReportBuilder(duplicateBindings).addError(builder.toString(), path.entryPointElement());
-    }
 
-    /**
-     * Returns the report builder for the rootmost component that contains any of the duplicate
-     * bindings.
-     */
-    private ValidationReport.Builder<TypeElement> owningReportBuilder(
-        Iterable<ContributionBinding> duplicateBindings) {
-      ImmutableSet.Builder<ComponentDescriptor> owningComponentsBuilder = ImmutableSet.builder();
-      for (ContributionBinding binding : duplicateBindings) {
-        BindingKey bindingKey = BindingKey.create(BindingKey.Kind.CONTRIBUTION, binding.key());
-        ResolvedBindings resolvedBindings = subject.resolvedBindings().get(bindingKey);
-        owningComponentsBuilder.addAll(
-            resolvedBindings.allContributionBindings().inverse().get(binding));
+      @SuppressWarnings("resource") // Appendable is a StringBuilder.
+      private void reportDependsOnProductionExecutor() {
+        reportErrorAtEntryPoint(
+            DEPENDS_ON_PRODUCTION_EXECUTOR_FORMAT, formatCurrentDependencyRequestKey());
       }
-      ImmutableSet<ComponentDescriptor> owningComponents = owningComponentsBuilder.build();
-      for (Validation validation : validationPath()) {
-        if (owningComponents.contains(validation.subject.componentDescriptor())) {
-          return validation.reportBuilder;
+
+      @SuppressWarnings("resource") // Appendable is a StringBuilder.
+      private void reportDuplicateBindings() {
+        // If any of the duplicate bindings results from multibinding contributions or declarations,
+        // report the conflict using those contributions and declarations.
+        if (resolvedBindings()
+            .contributionBindings()
+            .stream()
+            .map(ContributionBinding::bindingKind)
+            // TODO(dpb): Kill with fire.
+            .anyMatch(
+                kind -> SYNTHETIC_MULTIBOUND_KINDS.contains(kind) || SYNTHETIC_MAP.equals(kind))) {
+          reportMultipleContributionTypes();
+          return;
         }
+        StringBuilder builder = new StringBuilder();
+        new Formatter(builder)
+            .format(DUPLICATE_BINDINGS_FOR_KEY_FORMAT, formatCurrentDependencyRequestKey());
+        ImmutableSetMultimap<ComponentDescriptor, BindingDeclaration> duplicateDeclarations =
+            reportableDeclarations();
+        bindingDeclarationFormatter.formatIndentedList(
+            builder, duplicateDeclarations.values(), 1, DUPLICATE_SIZE_LIMIT);
+        reportErrorAtEntryPoint(
+            componentTreePath().rootmostGraph(duplicateDeclarations.keySet()), builder.toString());
       }
-      throw new AssertionError(
-          "cannot find owning component for duplicate bindings: " + duplicateBindings);
-    }
 
-    /**
-     * The path from the {@link Validation} of the root graph down to this {@link Validation}.
-     */
-    private ImmutableList<Validation> validationPath() {
-      ImmutableList.Builder<Validation> validationPath = ImmutableList.builder();
-      for (Optional<Validation> validation = Optional.of(this);
-          validation.isPresent();
-          validation = validation.get().parent) {
-        validationPath.add(validation.get());
+      @SuppressWarnings("resource") // Appendable is a StringBuilder.
+      private void reportMultipleContributionTypes() {
+        StringBuilder builder = new StringBuilder();
+        new Formatter(builder)
+            .format(
+                MULTIPLE_CONTRIBUTION_TYPES_FOR_KEY_FORMAT, formatCurrentDependencyRequestKey());
+        ImmutableSetMultimap<ComponentDescriptor, BindingDeclaration> duplicateDeclarations =
+            reportableDeclarations();
+        ImmutableListMultimap<ContributionType, BindingDeclaration> duplicateDeclarationsByType =
+            Multimaps.index(
+                duplicateDeclarations.values(),
+                declaration ->
+                    declaration instanceof HasContributionType
+                        ? ((HasContributionType) declaration).contributionType()
+                        : ContributionType.UNIQUE);
+        verify(
+            duplicateDeclarationsByType.keySet().size() > 1,
+            "expected multiple contribution types for %s: %s",
+            dependencyRequest().bindingKey(),
+            duplicateDeclarationsByType);
+        ImmutableSortedMap.copyOf(Multimaps.asMap(duplicateDeclarationsByType))
+            .forEach(
+                (contributionType, declarations) -> {
+                  builder.append(INDENT);
+                  builder.append(formatContributionType(contributionType));
+                  builder.append(" bindings and declarations:");
+                  bindingDeclarationFormatter.formatIndentedList(
+                      builder, declarations, 2, DUPLICATE_SIZE_LIMIT);
+                  builder.append('\n');
+                });
+        reportErrorAtEntryPoint(
+            componentTreePath().rootmostGraph(duplicateDeclarations.keySet()), builder.toString());
       }
-      return validationPath.build().reverse();
-    }
 
-    @SuppressWarnings("resource") // Appendable is a StringBuilder.
-    private void reportMultipleBindingTypes(DependencyPath path) {
-      StringBuilder builder = new StringBuilder();
-      new Formatter(builder)
-          .format(ErrorMessages.MULTIPLE_BINDING_TYPES_FOR_KEY_FORMAT, formatRootRequestKey(path));
-      ResolvedBindings resolvedBinding = path.currentBinding();
-      ImmutableListMultimap<ContributionType, BindingDeclaration> declarationsByType =
-          declarationsByType(resolvedBinding);
-      verify(
-          declarationsByType.keySet().size() > 1,
-          "expected multiple binding types for %s: %s",
-          resolvedBinding.bindingKey(),
-          declarationsByType);
-      for (ContributionType type :
-          Ordering.natural().immutableSortedCopy(declarationsByType.keySet())) {
-        builder.append(INDENT);
-        builder.append(formatContributionType(type));
-        builder.append(" bindings and declarations:");
+      private void reportDuplicateMapKeys(Collection<ContributionBinding> mapBindings) {
+        StringBuilder builder = new StringBuilder();
+        builder.append(duplicateMapKeysError(formatCurrentDependencyRequestKey()));
         bindingDeclarationFormatter.formatIndentedList(
-            builder, declarationsByType.get(type), 2, DUPLICATE_SIZE_LIMIT);
-        builder.append('\n');
+            builder, mapBindings, 1, DUPLICATE_SIZE_LIMIT);
+        reportErrorAtEntryPoint(owningGraph(mapBindings), builder.toString());
       }
-      reportBuilder.addError(builder.toString(), path.entryPointElement());
-    }
 
-    private void reportDuplicateMapKeys(
-        DependencyPath path, Collection<ContributionBinding> mapBindings) {
-      StringBuilder builder = new StringBuilder();
-      builder.append(duplicateMapKeysError(formatRootRequestKey(path)));
-      bindingDeclarationFormatter.formatIndentedList(builder, mapBindings, 1, DUPLICATE_SIZE_LIMIT);
-      reportBuilder.addError(builder.toString(), path.entryPointElement());
-    }
+      private void reportInconsistentMapKeyAnnotations(
+          Multimap<Equivalence.Wrapper<DeclaredType>, ContributionBinding>
+              mapBindingsByAnnotationType) {
+        StringBuilder builder =
+            new StringBuilder(
+                inconsistentMapKeyAnnotationsError(formatCurrentDependencyRequestKey()));
+        for (Map.Entry<Equivalence.Wrapper<DeclaredType>, Collection<ContributionBinding>> entry :
+            mapBindingsByAnnotationType.asMap().entrySet()) {
+          DeclaredType annotationType = entry.getKey().get();
+          Collection<ContributionBinding> bindings = entry.getValue();
+
+          builder.append('\n').append(INDENT).append(annotationType).append(':');
+
+          bindingDeclarationFormatter.formatIndentedList(
+              builder, bindings, 2, DUPLICATE_SIZE_LIMIT);
+        }
+        reportErrorAtEntryPoint(
+            owningGraph(mapBindingsByAnnotationType.values()), builder.toString());
+      }
 
-    private void reportInconsistentMapKeyAnnotations(
-        DependencyPath path,
-        Multimap<Equivalence.Wrapper<DeclaredType>, ContributionBinding>
-            mapBindingsByAnnotationType) {
-      StringBuilder builder =
-          new StringBuilder(inconsistentMapKeyAnnotationsError(formatRootRequestKey(path)));
-      for (Map.Entry<Equivalence.Wrapper<DeclaredType>, Collection<ContributionBinding>> entry :
-          mapBindingsByAnnotationType.asMap().entrySet()) {
-        DeclaredType annotationType = entry.getKey().get();
-        Collection<ContributionBinding> bindings = entry.getValue();
-
-        builder
-            .append('\n')
-            .append(INDENT)
-            .append(annotationType)
-            .append(':');
-
-        bindingDeclarationFormatter.formatIndentedList(builder, bindings, 2, DUPLICATE_SIZE_LIMIT);
+      // TODO(cgruber): Provide a hint for the start and end of the cycle.
+      private void reportDependencyCycle() {
+        if (!providersBreakingCycle().isEmpty()) {
+          return;
+        }
+        ImmutableList.Builder<ContributionBinding> cycleBindings = ImmutableList.builder();
+        cycleDependencyTrace()
+            .forEach(
+                (dependencyRequest, resolvedBindings) ->
+                    cycleBindings.addAll(resolvedBindings.contributionBindings()));
+        reportErrorAtEntryPoint(
+            owningGraph(cycleBindings.build()),
+            CONTAINS_DEPENDENCY_CYCLE_FORMAT,
+            formatDependencyTrace());
       }
-      reportBuilder.addError(builder.toString(), path.entryPointElement());
-    }
 
-    private void reportCycle(DependencyPath path) {
-      if (!providersBreakingCycle(path.cycle()).isEmpty()) {
-        return;
+      /**
+       * Returns any steps in a dependency cycle that "break" the cycle. These are any nonsynthetic
+       * {@link Provider}, {@link Lazy}, or {@code Map<K, Provider<V>>} requests after the first
+       * request in the cycle.
+       *
+       * <p>The synthetic request for a {@code Map<K, Provider<V>>} as a dependency of a multibound
+       * {@code Map<K, V>} does not break cycles because the map's {@link Provider}s' {@link
+       * Provider#get() get()} methods are called during provision.
+       *
+       * <p>A request for an instance of {@code Optional} breaks the cycle if it is resolved to a
+       * {@link BindsOptionalOf} binding and a request for the {@code Optional}'s type parameter
+       * would.
+       */
+      private ImmutableSet<DependencyRequest> providersBreakingCycle() {
+        ImmutableSet.Builder<DependencyRequest> providers = ImmutableSet.builder();
+        AtomicBoolean first = new AtomicBoolean(true);
+        cycleDependencyTrace()
+            .forEach(
+                (dependencyRequest, resolvedBindings) -> {
+                  // Skip the first request in the cycle and any synthetic requests.
+                  if (first.getAndSet(false) || !dependencyRequest.requestElement().isPresent()) {
+                    return;
+                  }
+
+                  if (breaksCycle(dependencyRequest.key().type(), dependencyRequest.kind())) {
+                    providers.add(dependencyRequest);
+                  } else if (!resolvedBindings.optionalBindingDeclarations().isEmpty()) {
+                    /* Request resolved to a @BindsOptionalOf binding, so test the type inside the
+                     * Optional. Optional<Provider or Lazy or Provider of Lazy or Map of Provider>
+                     * breaks the cycle. */
+                    DependencyRequest.KindAndType kindAndType =
+                        DependencyRequest.extractKindAndType(
+                            OptionalType.from(dependencyRequest.key()).valueType());
+                    if (breaksCycle(kindAndType.type(), kindAndType.kind())) {
+                      providers.add(dependencyRequest);
+                    }
+                  }
+                });
+        return providers.build();
       }
-      // TODO(cgruber): Provide a hint for the start and end of the cycle.
-      TypeElement componentType =
-          MoreElements.asType(path.entryPointElement().getEnclosingElement());
-      reportBuilder.addItem(
-          String.format(
-              CONTAINS_DEPENDENCY_CYCLE_FORMAT,
-              componentType.getQualifiedName(),
-              path.entryPointElement().getSimpleName(),
-              dependencyRequestFormatter.toDependencyTrace(path)),
-          ERROR,
-          path.entryPointElement());
-    }
 
-    /**
-     * Returns any steps in a dependency cycle that "break" the cycle. These are any
-     * {@link Provider}, {@link Lazy}, or {@code Map<K, Provider<V>>} requests after the first
-     * request in the cycle.
-     *
-     * <p>If an implicit {@link Provider} dependency on {@code Map<K, Provider<V>>} is immediately
-     * preceded by a dependency on {@code Map<K, V>}, which means that the map's {@link Provider}s'
-     * {@link Provider#get() get()} methods are called during provision and so the cycle is not
-     * really broken.
-     */
-    private ImmutableSet<DependencyRequest> providersBreakingCycle(
-        ImmutableList<ResolvedRequest> cycle) {
-      ImmutableSet.Builder<DependencyRequest> providers = ImmutableSet.builder();
-      for (int i = 1; i < cycle.size(); i++) {
-        DependencyRequest dependencyRequest = cycle.get(i).request();
-        switch (dependencyRequest.kind()) {
+      private boolean breaksCycle(TypeMirror requestedType, DependencyRequest.Kind requestKind) {
+        switch (requestKind) {
           case PROVIDER:
-            // TODO(dpb): Just exclude requests from synthetic bindings.
-            if (isDependencyOfSyntheticMap(dependencyRequest, cycle.get(i - 1).request())) {
-              i++; // Skip the Provider requests in the Map<K, Provider<V>> too.
-            } else {
-              providers.add(dependencyRequest);
-            }
-            break;
-
           case LAZY:
-            providers.add(dependencyRequest);
-            break;
+          case PROVIDER_OF_LAZY:
+            return true;
 
           case INSTANCE:
-            TypeMirror type = dependencyRequest.key().type();
-            if (MapType.isMap(type) && MapType.from(type).valuesAreTypeOf(Provider.class)) {
-              providers.add(dependencyRequest);
-            }
-            break;
+            return MapType.isMap(requestedType)
+                && MapType.from(requestedType).valuesAreTypeOf(Provider.class);
 
           default:
-            break;
+            return false;
         }
       }
-      return providers.build();
-    }
 
-    /**
-     * Returns {@code true} if {@code request} is a request for {@code Map<K, Provider<V>>} or
-     * {@code Map<K, Producer<V>>} from a synthetic binding for {@code Map<K, V>} or
-     * {@code Map<K, Produced<V>>}.
-     */
-    // TODO(dpb): Make this check more explicit.
-    private boolean isDependencyOfSyntheticMap(
-        DependencyRequest request, DependencyRequest requestForPreviousBinding) {
-      // Synthetic map dependencies share the same request element as the previous request.
-      return request.requestElement().equals(requestForPreviousBinding.requestElement())
-          && Sets.union(
-                  keyFactory.implicitMapProviderKeyFrom(requestForPreviousBinding.key()).asSet(),
-                  keyFactory.implicitMapProducerKeyFrom(requestForPreviousBinding.key()).asSet())
-              .contains(request.key());
+      /**
+       * Returns whether the given dependency path would require the most recent request to be
+       * resolved by only provision bindings.
+       */
+      private boolean doesPathRequireProvisionOnly() {
+        // The second-most-recent bindings determine whether the most recent one must be a
+        // provision.
+        if (!atEntryPoint()) {
+          return !provisionsDependingOnLatestRequest().isEmpty();
+        }
+
+        // Check the request kind for entry points.
+        switch (dependencyRequest().kind()) {
+          case INSTANCE:
+          case PROVIDER:
+          case LAZY:
+          case MEMBERS_INJECTOR:
+            return true;
+          case PRODUCER:
+          case PRODUCED:
+          case FUTURE:
+            return false;
+          default:
+            throw new AssertionError();
+        }
+      }
+
+      /**
+       * Returns any provision bindings resolved for the second-most-recent request in the given
+       * path; that is, returns those provision bindings that depend on the latest request in the
+       * path.
+       */
+      private FluentIterable<ContributionBinding> provisionsDependingOnLatestRequest() {
+        return FluentIterable.from(dependentBindings())
+            .filter(ContributionBinding.class)
+            .filter(PROVISION::isOfType);
+      }
+
+      private String formatCurrentDependencyRequestKey() {
+        return keyFormatter.format(dependencyRequest().key());
+      }
     }
   }
 
-  ValidationReport<TypeElement> validate(BindingGraph subject) {
-    Validation validation = new Validation(subject);
-    validation.validateSubgraph();
+  ValidationReport<TypeElement> validate(BindingGraph graph) {
+    ComponentValidation validation = new ComponentValidation(graph);
+    validation.traverseComponents();
     return validation.buildReport();
   }
 
@@ -1234,55 +1193,7 @@ private void appendIndentedComponentsList(StringBuilder message, Iterable<TypeEl
    * a scoping annotation.
    */
   private ImmutableSet<TypeElement> scopedTypesIn(Set<TypeElement> types) {
-    return FluentIterable.from(types).filter(new Predicate<TypeElement>() {
-      @Override public boolean apply(TypeElement input) {
-        return !Scope.scopesOf(input).isEmpty();
-      }
-    }).toSet();
-  }
-
-  /**
-   * Returns whether the given dependency path would require the most recent request to be resolved
-   * by only provision bindings.
-   */
-  private boolean doesPathRequireProvisionOnly(DependencyPath path) {
-    if (path.size() == 1) {
-      // if this is an entry-point, then we check the request
-      switch (path.currentDependencyRequest().kind()) {
-        case INSTANCE:
-        case PROVIDER:
-        case LAZY:
-        case MEMBERS_INJECTOR:
-          return true;
-        case PRODUCER:
-        case PRODUCED:
-        case FUTURE:
-          return false;
-        default:
-          throw new AssertionError();
-      }
-    }
-    // otherwise, the second-most-recent bindings determine whether the most recent one must be a
-    // provision
-    return !provisionsDependingOnLatestRequest(path).isEmpty();
-  }
-
-  /**
-   * Returns any provision bindings resolved for the second-most-recent request in the given path;
-   * that is, returns those provision bindings that depend on the latest request in the path.
-   */
-  private ImmutableSet<? extends Binding> provisionsDependingOnLatestRequest(
-      final DependencyPath path) {
-    return FluentIterable.from(path.previousBinding().bindings())
-        .filter(BindingType.isOfType(BindingType.PROVISION))
-        .filter(
-            new Predicate<Binding>() {
-              @Override
-              public boolean apply(Binding binding) {
-                return binding.implicitDependencies().contains(path.currentDependencyRequest());
-              }
-            })
-        .toSet();
+    return types.stream().filter(type -> !scopesOf(type).isEmpty()).collect(toImmutableSet());
   }
 
   private String formatContributionType(ContributionType type) {
@@ -1298,24 +1209,4 @@ private String formatContributionType(ContributionType type) {
         throw new IllegalStateException("Unknown binding type: " + type);
     }
   }
-
-  private String formatRootRequestKey(DependencyPath path) {
-    return keyFormatter.format(path.currentDependencyRequest().key());
-  }
-
-  @AutoValue
-  abstract static class ResolvedRequest {
-    abstract DependencyRequest request();
-    abstract ResolvedBindings binding();
-
-    static ResolvedRequest create(DependencyRequest request, BindingGraph graph) {
-      BindingKey bindingKey = request.bindingKey();
-      ResolvedBindings resolvedBindings = graph.resolvedBindings().get(bindingKey);
-      return new AutoValue_BindingGraphValidator_ResolvedRequest(
-          request,
-          resolvedBindings == null
-              ? ResolvedBindings.noBindings(bindingKey, graph.componentDescriptor())
-              : resolvedBindings);
-    }
-  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingKey.java b/compiler/src/main/java/dagger/internal/codegen/BindingKey.java
index cd29d8d69..59e1d1aea 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingKey.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingKey.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Google, Inc.
+ * Copyright (C) 2014 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal.codegen;
 
 import com.google.auto.value.AutoValue;
@@ -31,8 +32,12 @@
     CONTRIBUTION, MEMBERS_INJECTION;
   }
 
-  static BindingKey create(Kind kind, Key key) {
-    return new AutoValue_BindingKey(kind, key);
+  static BindingKey contribution(Key key) {
+    return new AutoValue_BindingKey(Kind.CONTRIBUTION, key);
+  }
+
+  static BindingKey membersInjection(Key key) {
+    return new AutoValue_BindingKey(Kind.MEMBERS_INJECTION, key);
   }
 
   abstract Kind kind();
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingMethodProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/BindingMethodProcessingStep.java
new file mode 100644
index 000000000..cc1e164db
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingMethodProcessingStep.java
@@ -0,0 +1,63 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.base.Preconditions.checkArgument;
+import static javax.lang.model.util.ElementFilter.methodsIn;
+
+import com.google.auto.common.BasicAnnotationProcessor.ProcessingStep;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.SetMultimap;
+import java.lang.annotation.Annotation;
+import java.util.Set;
+import javax.annotation.processing.Messager;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ExecutableElement;
+
+/** A step that validates all binding methods that were not validated while processing modules. */
+final class BindingMethodProcessingStep implements ProcessingStep {
+
+  private final Messager messager;
+  private final AnyBindingMethodValidator anyBindingMethodValidator;
+
+  BindingMethodProcessingStep(
+      Messager messager, AnyBindingMethodValidator anyBindingMethodValidator) {
+    this.messager = messager;
+    this.anyBindingMethodValidator = anyBindingMethodValidator;
+  }
+
+  @Override
+  public Set<? extends Class<? extends Annotation>> annotations() {
+    return anyBindingMethodValidator.methodAnnotations();
+  }
+
+  @Override
+  public Set<Element> process(
+      SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
+    for (ExecutableElement method : methodsIn(elementsByAnnotation.values())) {
+      checkArgument(
+          anyBindingMethodValidator.isBindingMethod(method),
+          "%s is not annotated with any of %s",
+          method,
+          annotations());
+      if (!anyBindingMethodValidator.wasAlreadyValidated(method)) {
+        anyBindingMethodValidator.validate(method).printMessagesTo(messager);
+      }
+    }
+    return ImmutableSet.of();
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingMethodValidator.java
index 0afbdd09e..084224540 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingMethodValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingMethodValidator.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 Google, Inc.
+ * Copyright (C) 2016 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,33 +13,11 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package dagger.internal.codegen;
 
-import com.google.common.base.Function;
-import com.google.common.base.Joiner;
-import com.google.common.cache.CacheBuilder;
-import com.google.common.cache.CacheLoader;
-import com.google.common.cache.LoadingCache;
-import com.google.common.collect.FluentIterable;
-import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.Lists;
-import dagger.MapKey;
-import dagger.Provides;
-import dagger.multibindings.ElementsIntoSet;
-import dagger.multibindings.IntoMap;
-import dagger.producers.Produces;
-import java.lang.annotation.Annotation;
-import javax.annotation.OverridingMethodsMustInvokeSuper;
-import javax.annotation.processing.Messager;
-import javax.inject.Qualifier;
-import javax.lang.model.element.AnnotationMirror;
-import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.type.TypeKind;
-import javax.lang.model.type.TypeMirror;
-import javax.lang.model.util.Elements;
-import javax.lang.model.util.Types;
+package dagger.internal.codegen;
 
-import static com.google.auto.common.MoreElements.getAnnotationMirror;
+import static dagger.internal.codegen.DaggerElements.getAnnotationMirror;
+import static dagger.internal.codegen.DaggerElements.isAnyAnnotationPresent;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_ABSTRACT;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_MULTIPLE_QUALIFIERS;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES;
@@ -55,13 +33,12 @@
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_THROWS_ANY;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_THROWS_CHECKED;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_TYPE_PARAMETER;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_WITH_MULTIPLE_MAP_KEY;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_WITH_MULTIPLE_MAP_KEYS;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_WITH_NO_MAP_KEY;
 import static dagger.internal.codegen.ErrorMessages.MULTIBINDING_ANNOTATION_CONFLICTS_WITH_BINDING_ANNOTATION_ENUM;
 import static dagger.internal.codegen.ErrorMessages.MULTIPLE_MULTIBINDING_ANNOTATIONS_ON_METHOD;
 import static dagger.internal.codegen.InjectionAnnotations.getQualifiers;
 import static dagger.internal.codegen.MapKeys.getMapKeys;
-import static dagger.internal.codegen.Util.isAnyAnnotationPresent;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.type.TypeKind.ARRAY;
@@ -69,27 +46,38 @@
 import static javax.lang.model.type.TypeKind.TYPEVAR;
 import static javax.lang.model.type.TypeKind.VOID;
 
+import com.google.common.base.Joiner;
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Lists;
+import dagger.MapKey;
+import dagger.Provides;
+import dagger.multibindings.ElementsIntoSet;
+import dagger.multibindings.IntoMap;
+import dagger.producers.Produces;
+import java.lang.annotation.Annotation;
+import java.util.HashMap;
+import java.util.Map;
+import javax.annotation.OverridingMethodsMustInvokeSuper;
+import javax.inject.Qualifier;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.type.TypeKind;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
+
 /** A validator for methods that represent binding declarations. */
 abstract class BindingMethodValidator {
 
   private final Elements elements;
   private final Types types;
   private final Class<? extends Annotation> methodAnnotation;
-  private final ImmutableSet<Class<? extends Annotation>> enclosingElementAnnotations;
+  private final ImmutableSet<? extends Class<? extends Annotation>> enclosingElementAnnotations;
   private final Abstractness abstractness;
   private final ExceptionSuperclass exceptionSuperclass;
-  private final LoadingCache<ExecutableElement, ValidationReport<ExecutableElement>> cache =
-      CacheBuilder.newBuilder()
-          .build(
-              new CacheLoader<ExecutableElement, ValidationReport<ExecutableElement>>() {
-                @Override
-                public ValidationReport<ExecutableElement> load(ExecutableElement method) {
-                  ValidationReport.Builder<ExecutableElement> builder =
-                      ValidationReport.about(method);
-                  checkMethod(builder);
-                  return builder.build();
-                }
-              });
+  private final Map<ExecutableElement, ValidationReport<ExecutableElement>> cache = new HashMap<>();
+  private final AllowsMultibindings allowsMultibindings;
 
   /**
    * Creates a validator object.
@@ -104,14 +92,16 @@ protected BindingMethodValidator(
       Class<? extends Annotation> methodAnnotation,
       Class<? extends Annotation> enclosingElementAnnotation,
       Abstractness abstractness,
-      ExceptionSuperclass exceptionSuperclass) {
+      ExceptionSuperclass exceptionSuperclass,
+      AllowsMultibindings allowsMultibindings) {
     this(
         elements,
         types,
         methodAnnotation,
         ImmutableSet.of(enclosingElementAnnotation),
         abstractness,
-        exceptionSuperclass);
+        exceptionSuperclass,
+        allowsMultibindings);
   }
 
   /**
@@ -127,14 +117,15 @@ protected BindingMethodValidator(
       Class<? extends Annotation> methodAnnotation,
       Iterable<? extends Class<? extends Annotation>> enclosingElementAnnotations,
       Abstractness abstractness,
-      ExceptionSuperclass exceptionSuperclass) {
+      ExceptionSuperclass exceptionSuperclass,
+      AllowsMultibindings allowsMultibindings) {
     this.elements = elements;
     this.types = types;
     this.methodAnnotation = methodAnnotation;
-    this.enclosingElementAnnotations =
-        ImmutableSet.<Class<? extends Annotation>>copyOf(enclosingElementAnnotations);
+    this.enclosingElementAnnotations = ImmutableSet.copyOf(enclosingElementAnnotations);
     this.abstractness = abstractness;
     this.exceptionSuperclass = exceptionSuperclass;
+    this.allowsMultibindings = allowsMultibindings;
   }
   
   /** The annotation that identifies methods validated by this object. */
@@ -144,21 +135,13 @@ protected BindingMethodValidator(
 
   /** Returns a {@link ValidationReport} for {@code method}. */
   final ValidationReport<ExecutableElement> validate(ExecutableElement method) {
-    return cache.getUnchecked(method);
+    return cache.computeIfAbsent(method, this::validateUncached);
   }
 
-  /** Prints validation reports to {@code messager}, and returns valid methods. */
-  final ImmutableSet<ExecutableElement> validate(
-      Messager messager, Iterable<? extends ExecutableElement> methods) {
-    ImmutableSet.Builder<ExecutableElement> validMethods = ImmutableSet.builder();
-    for (ExecutableElement method : methods) {
-      ValidationReport<ExecutableElement> report = validate(method);
-      report.printMessagesTo(messager);
-      if (report.isClean()) {
-        validMethods.add(method);
-      }
-    }
-    return validMethods.build();
+  private ValidationReport<ExecutableElement> validateUncached(ExecutableElement m) {
+    ValidationReport.Builder<ExecutableElement> report = ValidationReport.about(m);
+    checkMethod(report);
+    return report.build();
   }
 
   /** Checks the method for validity. Adds errors to {@code builder}. */
@@ -187,13 +170,7 @@ protected void checkEnclosingElement(ValidationReport.Builder<ExecutableElement>
           formatErrorMessage(
               BINDING_METHOD_NOT_IN_MODULE,
               FluentIterable.from(enclosingElementAnnotations)
-                  .transform(
-                      new Function<Class<?>, String>() {
-                        @Override
-                        public String apply(Class<?> clazz) {
-                          return clazz.getSimpleName();
-                        }
-                      })
+                  .transform(Class::getSimpleName)
                   .join(Joiner.on(" or @"))));
     }
   }
@@ -337,6 +314,9 @@ protected void checkQualifiers(ValidationReport.Builder<ExecutableElement> build
    * {@code MAP} has any.
    */
   protected void checkMapKeys(ValidationReport.Builder<ExecutableElement> builder) {
+    if (!allowsMultibindings.allowsMultibindings()) {
+      return;
+    }
     ImmutableSet<? extends AnnotationMirror> mapKeys = getMapKeys(builder.getSubject());
     if (ContributionType.fromBindingMethod(builder.getSubject()).equals(ContributionType.MAP)) {
       switch (mapKeys.size()) {
@@ -346,7 +326,7 @@ protected void checkMapKeys(ValidationReport.Builder<ExecutableElement> builder)
         case 1:
           break;
         default:
-          builder.addError(formatErrorMessage(BINDING_METHOD_WITH_MULTIPLE_MAP_KEY));
+          builder.addError(formatErrorMessage(BINDING_METHOD_WITH_MULTIPLE_MAP_KEYS));
           break;
       }
     } else if (!mapKeys.isEmpty()) {
@@ -360,6 +340,9 @@ protected void checkMapKeys(ValidationReport.Builder<ExecutableElement> builder)
    * annotation has a {@code type} parameter.
    */
   protected void checkMultibindings(ValidationReport.Builder<ExecutableElement> builder) {
+    if (!allowsMultibindings.allowsMultibindings()) {
+      return;
+    }
     ImmutableSet<AnnotationMirror> multibindingAnnotations =
         MultibindingAnnotations.forMethod(builder.getSubject());
     if (multibindingAnnotations.size() > 1) {
@@ -422,7 +405,7 @@ protected String badSetValuesTypeMessage() {
    */
   protected enum ExceptionSuperclass {
     /** Methods may not declare any throwable types. */
-    NONE {
+    NO_EXCEPTIONS {
       @Override
       protected void checkThrows(
           BindingMethodValidator validator, ValidationReport.Builder<ExecutableElement> builder) {
@@ -456,7 +439,7 @@ private ExceptionSuperclass(Class<? extends Exception> superclass, String errorM
      * Adds an error if the method declares throws anything but an {@link Error} or an appropriate
      * subtype of {@link Exception}.
      *
-     * <p>This method is overridden in {@link #NONE}.
+     * <p>This method is overridden in {@link #NO_EXCEPTIONS}.
      */
     protected void checkThrows(
         BindingMethodValidator validator, ValidationReport.Builder<ExecutableElement> builder) {
@@ -473,4 +456,22 @@ protected void checkThrows(
       }
     }
   }
+
+  /** Whether to check multibinding annotations. */
+  protected enum AllowsMultibindings {
+    /**
+     * This method disallows multibinding annotations, so don't bother checking for their validity.
+     * {@link MultibindingAnnotationsProcessingStep} will add errors if the method has any
+     * multibinding annotations.
+     */
+    NO_MULTIBINDINGS,
+
+    /** This method allows multibinding annotations, so validate them. */
+    ALLOWS_MULTIBINDINGS,
+    ;
+
+    private boolean allowsMultibindings() {
+      return this == ALLOWS_MULTIBINDINGS;
+    }
+  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingType.java b/compiler/src/main/java/dagger/internal/codegen/BindingType.java
index 8d2a1d6c5..e654b04a4 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingType.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingType.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,11 +13,14 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal.codegen;
 
-import com.google.common.base.Function;
-import com.google.common.base.Predicate;
-import com.google.common.base.Predicates;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Sets;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.ParameterizedTypeName;
+import com.squareup.javapoet.TypeName;
 import dagger.MembersInjector;
 import dagger.producers.Producer;
 import javax.inject.Provider;
@@ -36,6 +39,13 @@
   PRODUCTION(Producer.class),
   ;
 
+  boolean isOfType(HasBindingType hasBindingType) {
+    return this.equals(hasBindingType.bindingType());
+  }
+
+  static final ImmutableSet<BindingType> CONTRIBUTION_TYPES =
+      Sets.immutableEnumSet(PROVISION, PRODUCTION);
+
   /** An object that is associated with a {@link BindingType}. */
   interface HasBindingType {
     /** The binding type of this object. */
@@ -44,7 +54,7 @@
 
   private final Class<?> frameworkClass;
 
-  private BindingType(Class<?> frameworkClass) {
+  BindingType(Class<?> frameworkClass) {
     this.frameworkClass = frameworkClass;
   }
 
@@ -53,17 +63,8 @@ private BindingType(Class<?> frameworkClass) {
     return frameworkClass;
   }
 
-  /** A predicate that passes for {@link HasBindingType}s with a given type. */
-  static Predicate<HasBindingType> isOfType(BindingType type) {
-    return Predicates.compose(Predicates.equalTo(type), BINDING_TYPE);
+  /** Returns the {@link #frameworkClass()} parameterized with a type. */
+  ParameterizedTypeName frameworkClassOf(TypeName valueType) {
+    return ParameterizedTypeName.get(ClassName.get(frameworkClass()), valueType);
   }
-
-  /** A function that returns {@link HasBindingType#bindingType()}. */
-  static Function<HasBindingType, BindingType> BINDING_TYPE =
-      new Function<HasBindingType, BindingType>() {
-        @Override
-        public BindingType apply(HasBindingType hasBindingType) {
-          return hasBindingType.bindingType();
-        }
-      };
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingTypeMapper.java b/compiler/src/main/java/dagger/internal/codegen/BindingTypeMapper.java
new file mode 100644
index 000000000..d40881a96
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingTypeMapper.java
@@ -0,0 +1,94 @@
+/*
+ * Copyright (C) 2014 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.collect.Iterables.getOnlyElement;
+import static dagger.internal.codegen.BindingType.CONTRIBUTION_TYPES;
+import static dagger.internal.codegen.BindingType.MEMBERS_INJECTION;
+import static dagger.internal.codegen.BindingType.PRODUCTION;
+import static dagger.internal.codegen.BindingType.PROVISION;
+
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableSet;
+import dagger.producers.Producer;
+import javax.inject.Provider;
+
+/**
+ * A mapper for associating a {@link DependencyRequest.Kind} to a {@link BindingType}, dependent on
+ * the type of code to be generated (e.g., for {@link Provider} or {@link Producer}).
+ */
+enum BindingTypeMapper {
+  FOR_PROVIDER() {
+    @Override public BindingType getBindingType(DependencyRequest.Kind requestKind) {
+      switch (requestKind) {
+        case INSTANCE:
+        case PROVIDER:
+        case PROVIDER_OF_LAZY:
+        case LAZY:
+          return PROVISION;
+        case MEMBERS_INJECTOR:
+          return MEMBERS_INJECTION;
+        case PRODUCED:
+        case PRODUCER:
+          throw new IllegalArgumentException(requestKind.toString());
+        default:
+          throw new AssertionError(requestKind);
+      }
+    }
+  },
+  FOR_PRODUCER() {
+    @Override public BindingType getBindingType(DependencyRequest.Kind requestKind) {
+      switch (requestKind) {
+        case INSTANCE:
+        case PRODUCED:
+        case PRODUCER:
+          return PRODUCTION;
+        case PROVIDER:
+        case PROVIDER_OF_LAZY:
+        case LAZY:
+          return PROVISION;
+        case MEMBERS_INJECTOR:
+          return MEMBERS_INJECTION;
+        default:
+          throw new AssertionError(requestKind);
+      }
+    }
+  };
+
+  static BindingTypeMapper forBindingType(BindingType bindingType) {
+    return bindingType.equals(PRODUCTION) ? FOR_PRODUCER : FOR_PROVIDER;
+  }
+
+  abstract BindingType getBindingType(DependencyRequest.Kind requestKind);
+
+  /**
+   * Returns the {@link BindingType} to use for a collection of requests of the same
+   * {@link BindingKey}. This allows factories to only take a single argument for multiple requests
+   * of the same key.
+   */
+  BindingType getBindingType(Iterable<DependencyRequest> requests) {
+    ImmutableSet<BindingType> classes =
+        FluentIterable.from(requests).transform(request -> getBindingType(request.kind())).toSet();
+    if (classes.size() == 1) {
+      return getOnlyElement(classes);
+    } else if (classes.equals(CONTRIBUTION_TYPES)) {
+      return PROVISION;
+    } else {
+      throw new IllegalArgumentException("Bad set of framework classes: " + classes);
+    }
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingVariableNamer.java b/compiler/src/main/java/dagger/internal/codegen/BindingVariableNamer.java
index 4ed87ebc5..36db21ab6 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingVariableNamer.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingVariableNamer.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Google, Inc.
+ * Copyright (C) 2014 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,16 +13,19 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal.codegen;
 
+import static com.google.common.base.CaseFormat.LOWER_CAMEL;
+import static com.google.common.base.CaseFormat.UPPER_CAMEL;
+import static dagger.internal.codegen.ConfigurationAnnotations.isSubcomponentBuilder;
+
 import java.util.Iterator;
+import javax.lang.model.element.Element;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.SimpleTypeVisitor6;
 
-import static com.google.common.base.CaseFormat.LOWER_CAMEL;
-import static com.google.common.base.CaseFormat.UPPER_CAMEL;
-
 /**
  * Suggests a variable name for a type based on a {@link Binding}. Prefer
  * {@link DependencyVariableNamer} for cases where a specific {@link DependencyRequest} is present.
@@ -47,9 +50,16 @@ static String name(Binding binding) {
     type.accept(
         new SimpleTypeVisitor6<Void, StringBuilder>() {
           @Override
-          public Void visitDeclared(DeclaredType t, StringBuilder builder) {
-            builder.append(t.asElement().getSimpleName());
-            Iterator<? extends TypeMirror> argumentIterator = t.getTypeArguments().iterator();
+          public Void visitDeclared(DeclaredType declaredType, StringBuilder builder) {
+            Element element = declaredType.asElement();
+            if (isSubcomponentBuilder(element)) {
+              // Most Subcomponent builders are named "Builder", so add their associated
+              // Subcomponent type so that they're not all "builderProvider{N}"
+              builder.append(element.getEnclosingElement().getSimpleName());
+            }
+            builder.append(element.getSimpleName());
+            Iterator<? extends TypeMirror> argumentIterator =
+                declaredType.getTypeArguments().iterator();
             if (argumentIterator.hasNext()) {
               builder.append("Of");
               TypeMirror first = argumentIterator.next();
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindsInstanceProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/BindsInstanceProcessingStep.java
new file mode 100644
index 000000000..8165da85e
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/BindsInstanceProcessingStep.java
@@ -0,0 +1,104 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.collect.Iterables.getOnlyElement;
+import static dagger.internal.codegen.ConfigurationAnnotations.getComponentOrSubcomponentAnnotation;
+import static dagger.internal.codegen.ConfigurationAnnotations.getModuleAnnotation;
+import static dagger.internal.codegen.DaggerElements.isAnyAnnotationPresent;
+import static dagger.internal.codegen.ErrorMessages.BINDS_INSTANCE_IN_INVALID_COMPONENT;
+import static dagger.internal.codegen.ErrorMessages.BINDS_INSTANCE_IN_MODULE;
+import static dagger.internal.codegen.ErrorMessages.BINDS_INSTANCE_ONE_PARAMETER;
+import static dagger.internal.codegen.MoreAnnotationMirrors.simpleName;
+import static dagger.internal.codegen.Util.toImmutableSet;
+import static javax.lang.model.element.Modifier.ABSTRACT;
+
+import com.google.auto.common.BasicAnnotationProcessor.ProcessingStep;
+import com.google.auto.common.MoreElements;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.SetMultimap;
+import dagger.BindsInstance;
+import java.lang.annotation.Annotation;
+import java.util.Set;
+import java.util.stream.Stream;
+import javax.annotation.processing.Messager;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.VariableElement;
+
+/**
+ * Processing step that validates that the {@code BindsInstance} annotation is applied to the
+ * correct elements.
+ */
+final class BindsInstanceProcessingStep implements ProcessingStep {
+
+  private static final ImmutableSet<Class<? extends Annotation>> COMPONENT_ANNOTATIONS =
+      Stream.of(ComponentDescriptor.Kind.values())
+          .map(ComponentDescriptor.Kind::annotationType)
+          .collect(toImmutableSet());
+  private static final ImmutableSet<Class<? extends Annotation>> MODULE_ANNOTATIONS =
+      Stream.of(ModuleDescriptor.Kind.values())
+          .map(ModuleDescriptor.Kind::moduleAnnotation)
+          .collect(toImmutableSet());
+
+  private final Messager messager;
+
+  BindsInstanceProcessingStep(Messager messager) {
+    this.messager = messager;
+  }
+
+  @Override
+  public Set<? extends Class<? extends Annotation>> annotations() {
+    return ImmutableSet.of(BindsInstance.class);
+  }
+
+  @Override
+  public Set<Element> process(
+      SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
+    for (Element element : elementsByAnnotation.get(BindsInstance.class)) {
+      ExecutableElement method = MoreElements.asExecutable(element);
+      ValidationReport.Builder<ExecutableElement> report = ValidationReport.about(method);
+      if (!method.getModifiers().contains(ABSTRACT)) {
+        report.addError("@BindsInstance methods must be abstract");
+      }
+      if (method.getParameters().size() != 1) {
+        report.addError(BINDS_INSTANCE_ONE_PARAMETER);
+      } else {
+        VariableElement parameter = getOnlyElement(method.getParameters());
+        if (FrameworkTypes.isFrameworkType(parameter.asType())) {
+          report.addError("@BindsInstance parameters may not be framework types", parameter);
+        }
+      }
+      TypeElement enclosingType = MoreElements.asType(method.getEnclosingElement());
+      if (isAnyAnnotationPresent(enclosingType, MODULE_ANNOTATIONS)) {
+        report.addError(
+            String.format(
+                BINDS_INSTANCE_IN_MODULE, simpleName(getModuleAnnotation(enclosingType).get())));
+      }
+      if (isAnyAnnotationPresent(enclosingType, COMPONENT_ANNOTATIONS)) {
+        AnnotationMirror componentAnnotation =
+            getComponentOrSubcomponentAnnotation(enclosingType).get();
+        report.addError(
+            String.format(BINDS_INSTANCE_IN_INVALID_COMPONENT, simpleName(componentAnnotation)));
+      }
+      report.build().printMessagesTo(messager);
+    }
+    return ImmutableSet.of();
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindsMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindsMethodValidator.java
index dd97aa422..780963820 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindsMethodValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindsMethodValidator.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 Google, Inc.
+ * Copyright (C) 2016 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,38 +13,35 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal.codegen;
 
+import static com.google.common.collect.Iterables.getOnlyElement;
+import static dagger.internal.codegen.BindingMethodValidator.Abstractness.MUST_BE_ABSTRACT;
+import static dagger.internal.codegen.BindingMethodValidator.AllowsMultibindings.ALLOWS_MULTIBINDINGS;
+import static dagger.internal.codegen.BindingMethodValidator.ExceptionSuperclass.RUNTIME_EXCEPTION;
+import static dagger.internal.codegen.ErrorMessages.BINDS_ELEMENTS_INTO_SET_METHOD_RETURN_SET;
+import static dagger.internal.codegen.ErrorMessages.BINDS_METHOD_ONE_ASSIGNABLE_PARAMETER;
+
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import dagger.Binds;
 import dagger.Module;
-import dagger.multibindings.IntoMap;
 import dagger.producers.ProducerModule;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
-import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
-import javax.lang.model.type.TypeMirror;
 import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.ElementFilter;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 
-import static com.google.auto.common.MoreElements.isAnnotationPresent;
-import static com.google.common.collect.Iterables.getOnlyElement;
-import static dagger.internal.codegen.BindingMethodValidator.Abstractness.MUST_BE_ABSTRACT;
-import static dagger.internal.codegen.BindingMethodValidator.ExceptionSuperclass.RUNTIME_EXCEPTION;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_NOT_MAP_HAS_MAP_KEY;
-import static dagger.internal.codegen.ErrorMessages.BINDS_ELEMENTS_INTO_SET_METHOD_RETURN_SET;
-import static dagger.internal.codegen.ErrorMessages.BINDS_METHOD_ONE_ASSIGNABLE_PARAMETER;
-import static dagger.internal.codegen.MapKeys.getMapKeys;
-
 /**
  * A validator for {@link Binds} methods.
  */
@@ -59,7 +56,8 @@
         Binds.class,
         ImmutableSet.of(Module.class, ProducerModule.class),
         MUST_BE_ABSTRACT,
-        RUNTIME_EXCEPTION);
+        RUNTIME_EXCEPTION,
+        ALLOWS_MULTIBINDINGS);
     this.types = types;
     this.elements = elements;
   }
@@ -70,21 +68,12 @@ protected void checkMethod(ValidationReport.Builder<ExecutableElement> builder)
     checkParameters(builder);
   }
 
-  @Override // TODO(dpb, ronshapiro): When @Binds methods support @IntoMap, stop overriding.
-  protected void checkMapKeys(ValidationReport.Builder<ExecutableElement> builder) {
-    if (!isAnnotationPresent(builder.getSubject(), IntoMap.class)) {
-      for (AnnotationMirror mapKey : getMapKeys(builder.getSubject())) {
-        builder.addError(BINDING_METHOD_NOT_MAP_HAS_MAP_KEY, builder.getSubject(), mapKey);
-      }
-    }
-  }
-
   private void checkParameters(ValidationReport.Builder<ExecutableElement> builder) {
     ExecutableElement method = builder.getSubject();
     List<? extends VariableElement> parameters = method.getParameters();
     if (parameters.size() == 1) {
       VariableElement parameter = getOnlyElement(parameters);
-      TypeMirror leftHandSide = method.getReturnType();
+      TypeMirror leftHandSide = boxIfNecessary(method.getReturnType());
       TypeMirror rightHandSide = parameter.asType();
       ContributionType contributionType = ContributionType.fromBindingMethod(method);
       switch (contributionType) {
@@ -163,4 +152,11 @@ private TypeElement mapElement() {
   private TypeMirror unboundedWildcard() {
     return types.getWildcardType(null, null);
   }
+
+  private TypeMirror boxIfNecessary(TypeMirror maybePrimitive) {
+    if (maybePrimitive.getKind().isPrimitive()) {
+      return types.boxedClass(MoreTypes.asPrimitiveType(maybePrimitive)).asType();
+    }
+    return maybePrimitive;
+  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindsOptionalOfMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindsOptionalOfMethodValidator.java
new file mode 100644
index 000000000..e60744de6
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/BindsOptionalOfMethodValidator.java
@@ -0,0 +1,79 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static dagger.internal.codegen.BindingMethodValidator.Abstractness.MUST_BE_ABSTRACT;
+import static dagger.internal.codegen.BindingMethodValidator.AllowsMultibindings.NO_MULTIBINDINGS;
+import static dagger.internal.codegen.BindingMethodValidator.ExceptionSuperclass.NO_EXCEPTIONS;
+import static dagger.internal.codegen.ErrorMessages.BINDS_OPTIONAL_OF_METHOD_HAS_PARAMETER;
+import static dagger.internal.codegen.ErrorMessages.BINDS_OPTIONAL_OF_METHOD_RETURNS_IMPLICITLY_PROVIDED_TYPE;
+import static dagger.internal.codegen.InjectionAnnotations.getQualifiers;
+import static dagger.internal.codegen.InjectionAnnotations.injectedConstructors;
+import static dagger.internal.codegen.Key.isValidImplicitProvisionKey;
+
+import com.google.auto.common.MoreElements;
+import com.google.auto.common.MoreTypes;
+import com.google.common.collect.ImmutableSet;
+import dagger.BindsOptionalOf;
+import dagger.Module;
+import dagger.producers.ProducerModule;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
+
+/** A validator for {@link BindsOptionalOf} methods. */
+final class BindsOptionalOfMethodValidator extends BindingMethodValidator {
+
+  private final Types types;
+
+  BindsOptionalOfMethodValidator(Elements elements, Types types) {
+    super(
+        elements,
+        types,
+        BindsOptionalOf.class,
+        ImmutableSet.of(Module.class, ProducerModule.class),
+        MUST_BE_ABSTRACT,
+        NO_EXCEPTIONS,
+        NO_MULTIBINDINGS);
+    this.types = types;
+  }
+
+  @Override
+  protected void checkMethod(ValidationReport.Builder<ExecutableElement> builder) {
+    super.checkMethod(builder);
+    checkParameters(builder);
+  }
+
+  @Override
+  protected void checkKeyType(
+      ValidationReport.Builder<ExecutableElement> builder, TypeMirror keyType) {
+    super.checkKeyType(builder, keyType);
+    if (isValidImplicitProvisionKey(
+            getQualifiers(builder.getSubject()).stream().findFirst(), keyType, types)
+        && !injectedConstructors(MoreElements.asType(MoreTypes.asDeclared(keyType).asElement()))
+            .isEmpty()) {
+      builder.addError(BINDS_OPTIONAL_OF_METHOD_RETURNS_IMPLICITLY_PROVIDED_TYPE);
+    }
+  }
+
+  private void checkParameters(ValidationReport.Builder<ExecutableElement> builder) {
+    if (!builder.getSubject().getParameters().isEmpty()) {
+      builder.addError(BINDS_OPTIONAL_OF_METHOD_HAS_PARAMETER);
+    }
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/BuilderValidator.java b/compiler/src/main/java/dagger/internal/codegen/BuilderValidator.java
index e50bc2018..72df34e5c 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BuilderValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BuilderValidator.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,17 +13,26 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal.codegen;
 
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.collect.Iterables.getOnlyElement;
+import static dagger.internal.codegen.DaggerElements.getUnimplementedMethods;
+import static javax.lang.model.element.Modifier.ABSTRACT;
+import static javax.lang.model.element.Modifier.PRIVATE;
+import static javax.lang.model.element.Modifier.STATIC;
+import static javax.lang.model.util.ElementFilter.methodsIn;
+
+import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
-import com.google.common.base.Equivalence;
-import com.google.common.collect.Iterables;
-import com.google.common.collect.LinkedHashMultimap;
-import com.google.common.collect.Multimap;
+import com.google.common.collect.ImmutableSet;
+import dagger.internal.codegen.ErrorMessages.ComponentBuilderMessages;
+import dagger.internal.codegen.ValidationReport.Builder;
 import java.lang.annotation.Annotation;
-import java.util.Collection;
+import java.util.Arrays;
 import java.util.List;
-import java.util.Map;
 import java.util.Set;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
@@ -36,19 +45,13 @@
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 
-import static com.google.auto.common.MoreElements.isAnnotationPresent;
-import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.collect.Iterables.getOnlyElement;
-import static javax.lang.model.element.Modifier.ABSTRACT;
-import static javax.lang.model.element.Modifier.PRIVATE;
-import static javax.lang.model.element.Modifier.STATIC;
-
 /**
  * Validates {@link dagger.Component.Builder} annotations.
  *
  * @author sameb@google.com (Sam Berlin)
  */
 class BuilderValidator {
+
   private final Elements elements;
   private final Types types;
 
@@ -106,22 +109,34 @@
     }
 
     ExecutableElement buildMethod = null;
-    Multimap<Equivalence.Wrapper<TypeMirror>, ExecutableElement> methodsPerParam =
-        LinkedHashMultimap.create();
-    for (ExecutableElement method : Util.getUnimplementedMethods(elements, subject)) {
+    for (ExecutableElement method : getUnimplementedMethods(subject, types, elements)) {
       ExecutableType resolvedMethodType =
           MoreTypes.asExecutable(types.asMemberOf(MoreTypes.asDeclared(subject.asType()), method));
       TypeMirror returnType = resolvedMethodType.getReturnType();
       if (method.getParameters().size() == 0) {
         // If this is potentially a build() method, validate it returns the correct type.
-        if (types.isSameType(returnType, componentElement.asType())) {
+        if (types.isSubtype(componentElement.asType(), returnType)) {
+          validateBuildMethodReturnType(
+              builder,
+              // since types.isSubtype() passed, componentElement cannot be a PackageElement
+              MoreElements.asType(componentElement),
+              msgs,
+              method,
+              returnType);
           if (buildMethod != null) {
             // If we found more than one build-like method, fail.
-            error(builder, method, msgs.twoBuildMethods(), msgs.inheritedTwoBuildMethods(),
+            error(
+                builder,
+                method,
+                msgs.twoBuildMethods(),
+                msgs.inheritedTwoBuildMethods(),
                 buildMethod);
           }
         } else {
-          error(builder, method, msgs.buildMustReturnComponentType(),
+          error(
+              builder,
+              method,
+              msgs.buildMustReturnComponentType(),
               msgs.inheritedBuildMustReturnComponentType());
         }
         // We set the buildMethod regardless of the return type to reduce error spam.
@@ -132,18 +147,16 @@
       } else if (returnType.getKind() != TypeKind.VOID
           && !types.isSubtype(subject.asType(), returnType)) {
         // If this correctly had one arg, make sure the return types are valid.
-        error(builder, method, msgs.methodsMustReturnVoidOrBuilder(),
+        error(
+            builder,
+            method,
+            msgs.methodsMustReturnVoidOrBuilder(),
             msgs.inheritedMethodsMustReturnVoidOrBuilder());
-      } else {
-        // If the return types are valid, record the method.
-        methodsPerParam.put(
-            MoreTypes.equivalence().<TypeMirror>wrap(
-                Iterables.getOnlyElement(resolvedMethodType.getParameterTypes())),
-            method);
-      }
-
-      if (!method.getTypeParameters().isEmpty()) {
-        error(builder, method, msgs.methodsMayNotHaveTypeParameters(),
+      } else if (!method.getTypeParameters().isEmpty()) {
+        error(
+            builder,
+            method,
+            msgs.methodsMayNotHaveTypeParameters(),
             msgs.inheritedMethodsMayNotHaveTypeParameters());
       }
     }
@@ -152,22 +165,32 @@
       builder.addError(msgs.missingBuildMethod(), subject);
     }
 
-    // Go back through each recorded method per param type.  If we had more than one method
-    // for a given param, fail.
-    for (Map.Entry<Equivalence.Wrapper<TypeMirror>, Collection<ExecutableElement>> entry :
-        methodsPerParam.asMap().entrySet()) {
-      if (entry.getValue().size() > 1) {
-        TypeMirror type = entry.getKey().get();
-        builder.addError(String.format(msgs.manyMethodsForType(), type, entry.getValue()), subject);
-      }
-    }
-
-    // Note: there's more validation in BindingGraphValidator,
-    // specifically to make sure the setter methods mirror the deps.
+    // Note: there's more validation in BindingGraphValidator:
+    // - to make sure the setter methods mirror the deps
+    // - to make sure each type or key is set by only one method
 
     return builder.build();
   }
 
+  private void validateBuildMethodReturnType(
+      ValidationReport.Builder<TypeElement> builder,
+      TypeElement componentElement,
+      ComponentBuilderMessages msgs,
+      ExecutableElement method,
+      TypeMirror returnType) {
+    if (types.isSameType(componentElement.asType(), returnType)) {
+      return;
+    }
+    ImmutableSet<ExecutableElement> methodsOnlyInComponent =
+        methodsOnlyInComponent(componentElement);
+    if (!methodsOnlyInComponent.isEmpty()) {
+      builder.addWarning(
+          msgs.buildMethodReturnsSupertypeWithMissingMethods(
+              componentElement, builder.getSubject(), returnType, method, methodsOnlyInComponent),
+          method);
+    }
+  }
+
   /**
    * Generates one of two error messages. If the method is enclosed in the subject, we target the
    * error to the method itself. Otherwise we target the error to the subject and list the method as
@@ -186,7 +209,7 @@
    * This check is a little more strict than necessary -- ideally we'd check if method's enclosing
    * class was included in this compile run.  But that's hard, and this is close enough.
    */
-  private void error(
+  private static void error(
       ValidationReport.Builder<TypeElement> builder,
       ExecutableElement method,
       String enclosedError,
@@ -195,10 +218,37 @@ private void error(
     if (method.getEnclosingElement().equals(builder.getSubject())) {
       builder.addError(String.format(enclosedError, extraArgs), method);
     } else {
-      Object[] newArgs = new Object[extraArgs.length + 1];
-      newArgs[0] = method;
-      System.arraycopy(extraArgs, 0, newArgs, 1, extraArgs.length);
-      builder.addError(String.format(inheritedError, newArgs));
+      builder.addError(String.format(inheritedError, append(extraArgs, method)));
+    }
+  }
+
+  /** @see #error(Builder, ExecutableElement, String, String, Object...) */
+  private static void warning(
+      ValidationReport.Builder<TypeElement> builder,
+      ExecutableElement method,
+      String enclosedWarning,
+      String inheritedWarning,
+      Object... extraArgs) {
+    if (method.getEnclosingElement().equals(builder.getSubject())) {
+      builder.addWarning(String.format(enclosedWarning, extraArgs), method);
+    } else {
+      builder.addWarning(String.format(inheritedWarning, append(extraArgs, method)), method);
     }
   }
+
+  private static Object[] append(Object[] initial, Object additional) {
+    Object[] newArray = Arrays.copyOf(initial, initial.length + 1);
+    newArray[initial.length] = additional;
+    return newArray;
+  }
+
+  /**
+   * Returns all methods defind in {@code componentType} which are not inherited from a supertype.
+   */
+  private ImmutableSet<ExecutableElement> methodsOnlyInComponent(TypeElement componentType) {
+    // TODO(ronshapiro): Ideally this shouldn't return methods which are redeclared from a
+    // supertype, but do not change the return type. We don't have a good/simple way of checking
+    // that, and it doesn't seem likely, so the warning won't be too bad.
+    return ImmutableSet.copyOf(methodsIn(componentType.getEnclosedElements()));
+  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/CanReleaseReferencesProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/CanReleaseReferencesProcessingStep.java
new file mode 100644
index 000000000..52a31c166
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/CanReleaseReferencesProcessingStep.java
@@ -0,0 +1,71 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
+import static javax.lang.model.util.ElementFilter.typesIn;
+
+import com.google.auto.common.BasicAnnotationProcessor.ProcessingStep;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.SetMultimap;
+import dagger.releasablereferences.CanReleaseReferences;
+import java.lang.annotation.Annotation;
+import java.util.Set;
+import javax.annotation.processing.Messager;
+import javax.inject.Scope;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.TypeElement;
+
+/**
+ * Processes annotations annotated with {@link CanReleaseReferences}. For each one that is not also
+ * a {@link Scope}, generates a class that can create instances at runtime.
+ */
+final class CanReleaseReferencesProcessingStep implements ProcessingStep {
+
+  private final Messager messager;
+  private final CanReleaseReferencesValidator canReleaseReferencesValidator;
+  private final AnnotationCreatorGenerator annotationCreatorGenerator;
+
+  CanReleaseReferencesProcessingStep(
+      Messager messager,
+      CanReleaseReferencesValidator canReleaseReferencesValidator,
+      AnnotationCreatorGenerator annotationCreatorGenerator) {
+    this.messager = messager;
+    this.canReleaseReferencesValidator = canReleaseReferencesValidator;
+    this.annotationCreatorGenerator = annotationCreatorGenerator;
+  }
+
+  @Override
+  public Set<? extends Class<? extends Annotation>> annotations() {
+    return ImmutableSet.of(CanReleaseReferences.class);
+  }
+
+  @Override
+  public Set<Element> process(
+      SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
+    for (TypeElement annotatedElement :
+        typesIn(elementsByAnnotation.get(CanReleaseReferences.class))) {
+      ValidationReport<TypeElement> report =
+          canReleaseReferencesValidator.validate(annotatedElement);
+      report.printMessagesTo(messager);
+      if (report.isClean() && !isAnnotationPresent(annotatedElement, Scope.class)) {
+        annotationCreatorGenerator.generate(annotatedElement, messager);
+      }
+    }
+    return ImmutableSet.of();
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/CanReleaseReferencesValidator.java b/compiler/src/main/java/dagger/internal/codegen/CanReleaseReferencesValidator.java
new file mode 100644
index 000000000..7c97cb468
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/CanReleaseReferencesValidator.java
@@ -0,0 +1,71 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.auto.common.AnnotationMirrors.getAnnotationValue;
+import static dagger.internal.codegen.DaggerElements.getAnnotationMirror;
+import static dagger.internal.codegen.ErrorMessages.CAN_RELEASE_REFERENCES_ANNOTATIONS_MUST_NOT_HAVE_SOURCE_RETENTION;
+import static java.lang.annotation.RetentionPolicy.SOURCE;
+
+import dagger.releasablereferences.CanReleaseReferences;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.util.SimpleAnnotationValueVisitor7;
+
+/**
+ * Validates that {@link CanReleaseReferences} are applied only to valid annotations.
+ *
+ * <p>They must not annotate annotations that have {@link RetentionPolicy#SOURCE}-level retention.
+ */
+final class CanReleaseReferencesValidator {
+
+  ValidationReport<TypeElement> validate(TypeElement annotatedElement) {
+    ValidationReport.Builder<TypeElement> report = ValidationReport.about(annotatedElement);
+    checkNoSourceRetention(annotatedElement, report);
+    return report.build();
+  }
+
+  private void checkNoSourceRetention(
+      TypeElement annotatedElement, ValidationReport.Builder<TypeElement> report) {
+    getAnnotationMirror(annotatedElement, Retention.class)
+        .ifPresent(
+            retention -> {
+              if (getRetentionPolicy(retention).equals(SOURCE)) {
+                report.addError(
+                    CAN_RELEASE_REFERENCES_ANNOTATIONS_MUST_NOT_HAVE_SOURCE_RETENTION,
+                    report.getSubject(),
+                    retention);
+              }
+            });
+  }
+
+  // TODO(dpb): Move the ability to get an annotation type's retention policy somewhere common.
+  private RetentionPolicy getRetentionPolicy(AnnotationMirror retention) {
+    return getAnnotationValue(retention, "value")
+        .accept(
+            new SimpleAnnotationValueVisitor7<RetentionPolicy, Void>() {
+              @Override
+              public RetentionPolicy visitEnumConstant(VariableElement element, Void p) {
+                return RetentionPolicy.valueOf(element.getSimpleName().toString());
+              }
+            },
+            null);
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/CodeBlocks.java b/compiler/src/main/java/dagger/internal/codegen/CodeBlocks.java
index dc2bf6ed2..c8f06405c 100644
--- a/compiler/src/main/java/dagger/internal/codegen/CodeBlocks.java
+++ b/compiler/src/main/java/dagger/internal/codegen/CodeBlocks.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 Google, Inc.
+ * Copyright (C) 2016 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,67 +13,159 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal.codegen;
 
-import com.google.common.base.Function;
-import com.google.common.collect.FluentIterable;
+import static dagger.internal.codegen.TypeNames.rawTypeName;
+import static java.util.stream.StreamSupport.stream;
+
+import com.google.auto.common.MoreElements;
+import com.google.errorprone.annotations.CanIgnoreReturnValue;
+import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
-import com.squareup.javapoet.ParameterSpec;
-import java.util.Iterator;
-import javax.lang.model.type.TypeMirror;
+import com.squareup.javapoet.CodeBlock.Builder;
+import com.squareup.javapoet.TypeName;
+import java.util.stream.Collector;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.VariableElement;
 
 final class CodeBlocks {
+  /**
+   * A {@link Collector} implementation that joins {@link CodeBlock} instances together into one
+   * separated by {@code delimiter}. For example, joining {@code String s}, {@code Object o} and
+   * {@code int i} using {@code ", "} would produce {@code String s, Object o, int i}.
+   */
+  static Collector<CodeBlock, ?, CodeBlock> joiningCodeBlocks(String delimiter) {
+    return Collector.of(
+        () -> new CodeBlockJoiner(delimiter, CodeBlock.builder()),
+        CodeBlockJoiner::add,
+        CodeBlockJoiner::merge,
+        CodeBlockJoiner::join);
+  }
 
   /**
-   * Returns a comma-separated version of {@code codeBlocks} as one unified {@link CodeBlock}.
+   * Joins {@link CodeBlock} instances in a manner suitable for use as method parameters (or
+   * arguments). This is equivalent to {@code joiningCodeBlocks(", ")}.
    */
-  static CodeBlock makeParametersCodeBlock(Iterable<CodeBlock> codeBlocks) {
-    return join(codeBlocks, ", ");
+  static Collector<CodeBlock, ?, CodeBlock> toParametersCodeBlock() {
+    return joiningCodeBlocks(", ");
   }
 
   /**
-   * Returns one unified {@link CodeBlock} which joins each item in {@code codeBlocks} with a
-   * newline.
+   * Joins {@link TypeName} instances into a {@link CodeBlock} that is a comma-separated list for
+   * use as type parameters or javadoc method arguments.
    */
-  static CodeBlock concat(Iterable<CodeBlock> codeBlocks) {
-    return join(codeBlocks, "\n");
+  static Collector<TypeName, ?, CodeBlock> toTypeNamesCodeBlock() {
+    return Collector.of(
+        () -> new CodeBlockJoiner(", ", CodeBlock.builder()),
+        CodeBlockJoiner::addTypeName,
+        CodeBlockJoiner::merge,
+        CodeBlockJoiner::join);
   }
 
-  static CodeBlock join(Iterable<CodeBlock> codeBlocks, String delimiter) {
-    CodeBlock.Builder builder = CodeBlock.builder();
-    Iterator<CodeBlock> iterator = codeBlocks.iterator();
-    while (iterator.hasNext()) {
-      builder.add(iterator.next());
-      if (iterator.hasNext()) {
+  /**
+   * Concatenates {@link CodeBlock} instances separated by newlines for readability. This is
+   * equivalent to {@code joiningCodeBlocks("\n")}.
+   */
+  static Collector<CodeBlock, ?, CodeBlock> toConcatenatedCodeBlock() {
+    return joiningCodeBlocks("\n");
+  }
+
+  /** Returns a comma-separated version of {@code codeBlocks} as one unified {@link CodeBlock}. */
+  static CodeBlock makeParametersCodeBlock(Iterable<CodeBlock> codeBlocks) {
+    return stream(codeBlocks.spliterator(), false).collect(toParametersCodeBlock());
+  }
+
+  private static final class CodeBlockJoiner {
+    private final String delimiter;
+    private final CodeBlock.Builder builder;
+    private boolean first = true;
+
+    CodeBlockJoiner(String delimiter, Builder builder) {
+      this.delimiter = delimiter;
+      this.builder = builder;
+    }
+
+    @CanIgnoreReturnValue
+    CodeBlockJoiner add(CodeBlock codeBlock) {
+      maybeAddDelimiter();
+      builder.add(codeBlock);
+      return this;
+    }
+
+    @CanIgnoreReturnValue
+    CodeBlockJoiner addTypeName(TypeName typeName) {
+      maybeAddDelimiter();
+      builder.add("$T", typeName);
+      return this;
+    }
+
+    private void maybeAddDelimiter() {
+      if (!first) {
         builder.add(delimiter);
       }
+      first = false;
+    }
+
+    @CanIgnoreReturnValue
+    CodeBlockJoiner merge(CodeBlockJoiner other) {
+      CodeBlock otherBlock = other.builder.build();
+      if (!otherBlock.isEmpty()) {
+        add(otherBlock);
+      }
+      return this;
+    }
+
+    CodeBlock join() {
+      return builder.build();
     }
-    return builder.build();
   }
 
-  static FluentIterable<CodeBlock> toCodeBlocks(Iterable<? extends TypeMirror> typeMirrors) {
-    return FluentIterable.from(typeMirrors).transform(TYPE_MIRROR_TO_CODE_BLOCK);
+  /**
+   * Returns one unified {@link CodeBlock} which joins each item in {@code codeBlocks} with a
+   * newline.
+   */
+  static CodeBlock concat(Iterable<CodeBlock> codeBlocks) {
+    return stream(codeBlocks.spliterator(), false).collect(toConcatenatedCodeBlock());
   }
 
   static CodeBlock stringLiteral(String toWrap) {
     return CodeBlock.of("$S", toWrap);
   }
 
-  private static final Function<TypeMirror, CodeBlock> TYPE_MIRROR_TO_CODE_BLOCK =
-      new Function<TypeMirror, CodeBlock>() {
-        @Override
-        public CodeBlock apply(TypeMirror typeMirror) {
-          return CodeBlock.of("$T", typeMirror);
-        }
-      };
-
-  static Function<ParameterSpec, CodeBlock> PARAMETER_NAME =
-      new Function<ParameterSpec, CodeBlock>() {
-          @Override
-          public CodeBlock apply(ParameterSpec input) {
-            return CodeBlock.of("$N", input);
-          }
-      };
+  /** Returns a javadoc {@literal @link} tag that poins to the given {@link ExecutableElement}. */
+  static CodeBlock javadocLinkTo(ExecutableElement executableElement) {
+    CodeBlock.Builder builder =
+        CodeBlock.builder()
+            .add(
+                "{@link $T#",
+                rawTypeName(
+                    ClassName.get(MoreElements.asType(executableElement.getEnclosingElement()))));
+    switch (executableElement.getKind()) {
+      case METHOD:
+        builder.add("$L", executableElement.getSimpleName());
+        break;
+      case CONSTRUCTOR:
+        builder.add("$L", executableElement.getEnclosingElement().getSimpleName());
+        break;
+      case STATIC_INIT:
+      case INSTANCE_INIT:
+        throw new IllegalArgumentException(
+            "cannot create a javadoc link to an initializer: " + executableElement);
+      default:
+        throw new AssertionError(executableElement.toString());
+    }
+    builder.add("(");
+    builder.add(
+        executableElement
+            .getParameters()
+            .stream()
+            .map(VariableElement::asType)
+            .map(TypeName::get)
+            .map(TypeNames::rawTypeName)
+            .collect(toTypeNamesCodeBlock()));
+    return builder.add(")}").build();
+  }
 
   private CodeBlocks() {}
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/CompilerOptions.java b/compiler/src/main/java/dagger/internal/codegen/CompilerOptions.java
index a57092df7..b979128ac 100644
--- a/compiler/src/main/java/dagger/internal/codegen/CompilerOptions.java
+++ b/compiler/src/main/java/dagger/internal/codegen/CompilerOptions.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 Google, Inc.
+ * Copyright (C) 2016 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal.codegen;
 
 import com.google.auto.value.AutoValue;
@@ -36,6 +37,7 @@
   abstract Diagnostic.Kind staticMemberValidationKind();
   abstract boolean ignorePrivateAndStaticInjectionForComponent();
   abstract ValidationType scopeCycleValidationType();
+  abstract boolean warnIfInjectionFactoryNotGeneratedUpstream();
 
   static Builder builder() {
     return new AutoValue_CompilerOptions.Builder();
@@ -55,6 +57,8 @@ static CompilerOptions create(ProcessingEnvironment processingEnv, Elements elem
             ignorePrivateAndStaticInjectionForComponent(processingEnv)
                 .equals(FeatureStatus.DISABLED))
         .scopeCycleValidationType(scopeValidationType(processingEnv))
+        .warnIfInjectionFactoryNotGeneratedUpstream(
+            warnIfInjectionFactoryNotGeneratedUpstream(processingEnv).equals(FeatureStatus.ENABLED))
         .build();
   }
 
@@ -68,6 +72,8 @@ static CompilerOptions create(ProcessingEnvironment processingEnv, Elements elem
     Builder ignorePrivateAndStaticInjectionForComponent(
         boolean ignorePrivateAndStaticInjectionForComponent);
     Builder scopeCycleValidationType(ValidationType type);
+    Builder warnIfInjectionFactoryNotGeneratedUpstream(
+        boolean warnIfInjectionFactoryNotGeneratedUpstream);
     CompilerOptions build();
   }
 
@@ -82,6 +88,9 @@ Builder ignorePrivateAndStaticInjectionForComponent(
 
   static final String STATIC_MEMBER_VALIDATION_TYPE_KEY = "dagger.staticMemberValidation";
 
+  static final String WARN_IF_INJECTION_FACTORY_NOT_GENERATED_UPSTREAM_KEY =
+      "dagger.warnIfInjectionFactoryNotGeneratedUpstream";
+
   /**
    * If true, Dagger will generate factories and components even if some members-injected types
    * have private or static {@code @Inject}-annotated members.
@@ -98,6 +107,7 @@ Builder ignorePrivateAndStaticInjectionForComponent(
         NULLABLE_VALIDATION_KEY,
         PRIVATE_MEMBER_VALIDATION_TYPE_KEY,
         STATIC_MEMBER_VALIDATION_TYPE_KEY,
+        WARN_IF_INJECTION_FACTORY_NOT_GENERATED_UPSTREAM_KEY,
         IGNORE_PRIVATE_AND_STATIC_INJECTION_FOR_COMPONENT);
 
   private static FeatureStatus writeProducerNameInToken(ProcessingEnvironment processingEnv) {
@@ -149,6 +159,15 @@ private static FeatureStatus ignorePrivateAndStaticInjectionForComponent(
         EnumSet.allOf(FeatureStatus.class));
   }
 
+  private static FeatureStatus warnIfInjectionFactoryNotGeneratedUpstream(
+      ProcessingEnvironment processingEnv) {
+    return valueOf(
+        processingEnv,
+        WARN_IF_INJECTION_FACTORY_NOT_GENERATED_UPSTREAM_KEY,
+        FeatureStatus.DISABLED,
+        EnumSet.allOf(FeatureStatus.class));
+  }
+
   private static <T extends Enum<T>> T valueOf(
       ProcessingEnvironment processingEnv, String key, T defaultValue, Set<T> validValues) {
     Map<String, String> options = processingEnv.getOptions();
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
index fa3e8e30e..2a58dcecb 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Google, Inc.
+ * Copyright (C) 2014 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,22 +13,39 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal.codegen;
 
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Verify.verify;
+import static com.google.common.collect.Iterables.getOnlyElement;
+import static dagger.internal.codegen.ConfigurationAnnotations.enclosedBuilders;
+import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
+import static dagger.internal.codegen.ConfigurationAnnotations.getComponentModules;
+import static dagger.internal.codegen.ConfigurationAnnotations.isSubcomponent;
+import static dagger.internal.codegen.ConfigurationAnnotations.isSubcomponentBuilder;
+import static dagger.internal.codegen.DaggerElements.getAnnotationMirror;
+import static dagger.internal.codegen.DaggerElements.getUnimplementedMethods;
+import static dagger.internal.codegen.InjectionAnnotations.getQualifier;
+import static dagger.internal.codegen.Util.toImmutableSet;
+import static javax.lang.model.type.TypeKind.DECLARED;
+import static javax.lang.model.type.TypeKind.VOID;
+
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
-import com.google.common.base.Function;
-import com.google.common.base.Optional;
-import com.google.common.base.Predicate;
+import com.google.auto.value.extension.memoized.Memoized;
 import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableBiMap;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Sets;
+import com.google.common.collect.TreeTraverser;
 import com.google.common.util.concurrent.ListenableFuture;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import com.squareup.javapoet.ClassName;
+import dagger.BindsInstance;
 import dagger.Component;
 import dagger.Lazy;
 import dagger.MembersInjector;
@@ -36,14 +53,16 @@
 import dagger.Subcomponent;
 import dagger.producers.ProductionComponent;
 import dagger.producers.ProductionSubcomponent;
+import dagger.releasablereferences.CanReleaseReferences;
 import java.lang.annotation.Annotation;
 import java.util.EnumSet;
 import java.util.LinkedHashSet;
 import java.util.List;
-import java.util.Map;
+import java.util.Optional;
 import java.util.Set;
 import javax.inject.Provider;
 import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.DeclaredType;
@@ -53,18 +72,6 @@
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 
-import static com.google.auto.common.MoreElements.getAnnotationMirror;
-import static com.google.auto.common.MoreElements.isAnnotationPresent;
-import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Verify.verify;
-import static com.google.common.collect.Iterables.getOnlyElement;
-import static dagger.internal.codegen.ConfigurationAnnotations.enclosedBuilders;
-import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
-import static dagger.internal.codegen.ConfigurationAnnotations.getComponentModules;
-import static dagger.internal.codegen.InjectionAnnotations.getQualifier;
-import static javax.lang.model.type.TypeKind.DECLARED;
-import static javax.lang.model.type.TypeKind.VOID;
-
 /**
  * The logical representation of a {@link Component} or {@link ProductionComponent} definition.
  *
@@ -96,13 +103,13 @@
     static Optional<Kind> forAnnotatedElement(TypeElement element) {
       Set<Kind> kinds = EnumSet.noneOf(Kind.class);
       for (Kind kind : values()) {
-        if (MoreElements.isAnnotationPresent(element, kind.annotationType())) {
+        if (isAnnotationPresent(element, kind.annotationType())) {
           kinds.add(kind);
         }
       }
       checkArgument(
           kinds.size() <= 1, "%s cannot be annotated with more than one of %s", element, kinds);
-      return Optional.fromNullable(getOnlyElement(kinds, null));
+      return Optional.ofNullable(getOnlyElement(kinds, null));
     }
 
     /**
@@ -115,13 +122,13 @@
     static Optional<Kind> forAnnotatedBuilderElement(TypeElement element) {
       Set<Kind> kinds = EnumSet.noneOf(Kind.class);
       for (Kind kind : values()) {
-        if (MoreElements.isAnnotationPresent(element, kind.builderAnnotationType())) {
+        if (isAnnotationPresent(element, kind.builderAnnotationType())) {
           kinds.add(kind);
         }
       }
       checkArgument(
           kinds.size() <= 1, "%s cannot be annotated with more than one of %s", element, kinds);
-      return Optional.fromNullable(getOnlyElement(kinds, null));
+      return Optional.ofNullable(getOnlyElement(kinds, null));
     }
 
     Kind(
@@ -184,30 +191,6 @@ boolean isProducer() {
           throw new AssertionError();
       }
     }
-
-    private static final Function<Kind, Class<? extends Annotation>> TO_ANNOTATION_TYPE =
-        new Function<Kind, Class<? extends Annotation>>() {
-          @Override
-          public Class<? extends Annotation> apply(Kind kind) {
-            return kind.annotationType();
-          }
-        };
-
-    static Function<Kind, Class<? extends Annotation>> toAnnotationType() {
-      return TO_ANNOTATION_TYPE;
-    }
-
-    private static final Function<Kind, Class<? extends Annotation>> TO_BUILDER_ANNOTATION_TYPE =
-        new Function<Kind, Class<? extends Annotation>>() {
-          @Override
-          public Class<? extends Annotation> apply(Kind kind) {
-            return kind.builderAnnotationType();
-          }
-        };
-
-    static Function<Kind, Class<? extends Annotation>> toBuilderAnnotationType() {
-      return TO_BUILDER_ANNOTATION_TYPE;
-    }
   }
 
   abstract Kind kind();
@@ -239,29 +222,30 @@ boolean isProducer() {
    * <p>Note that for subcomponents this <em>will not</em> include descriptors for any modules that
    * are declared in parent components.
    */
-  ImmutableSet<ModuleDescriptor> transitiveModules() {
-    Set<ModuleDescriptor> transitiveModules = new LinkedHashSet<>();
-    for (ModuleDescriptor module : modules()) {
-      addTransitiveModules(transitiveModules, module);
-    }
-    return ImmutableSet.copyOf(transitiveModules);
-  }
+  abstract ImmutableSet<ModuleDescriptor> transitiveModules();
 
   ImmutableSet<TypeElement> transitiveModuleTypes() {
     return FluentIterable.from(transitiveModules())
-        .transform(ModuleDescriptor.getModuleElement())
+        .transform(ModuleDescriptor::moduleElement)
         .toSet();
   }
 
-  @CanIgnoreReturnValue
-  private static Set<ModuleDescriptor> addTransitiveModules(
+  private static ImmutableSet<ModuleDescriptor> transitiveModules(
+      Iterable<ModuleDescriptor> topLevelModules) {
+    Set<ModuleDescriptor> transitiveModules = new LinkedHashSet<>();
+    for (ModuleDescriptor module : topLevelModules) {
+      addTransitiveModules(transitiveModules, module);
+    }
+    return ImmutableSet.copyOf(transitiveModules);
+  }
+
+  private static void addTransitiveModules(
       Set<ModuleDescriptor> transitiveModules, ModuleDescriptor module) {
     if (transitiveModules.add(module)) {
       for (ModuleDescriptor includedModule : module.includedModules()) {
         addTransitiveModules(transitiveModules, includedModule);
       }
     }
-    return transitiveModules;
   }
 
   /**
@@ -276,32 +260,110 @@ boolean isProducer() {
    */
   abstract ImmutableSet<Scope> scopes();
 
-  abstract ImmutableMap<ComponentMethodDescriptor, ComponentDescriptor> subcomponents();
+  /**
+   * All {@link Subcomponent}s which are direct children of this component. This includes
+   * subcomponents installed from {@link Module#subcomponents()} as well as subcomponent {@linkplain
+   * #subcomponentsByFactoryMethod() factory methods} and {@linkplain
+   * #subcomponentsByBuilderMethod() builder methods}.
+   */
+  ImmutableSet<ComponentDescriptor> subcomponents() {
+    return ImmutableSet.<ComponentDescriptor>builder()
+        .addAll(subcomponentsByFactoryMethod().values())
+        .addAll(subcomponentsByBuilderMethod().values())
+        .addAll(subcomponentsFromModules())
+        .build();
+  }
+
+  /**
+   * All {@linkplain Subcomponent direct child} components that are declared by a {@linkplain
+   * Module#subcomponents() module's subcomponents}.
+   */
+  abstract ImmutableSet<ComponentDescriptor> subcomponentsFromModules();
+
+  /**
+   * All {@linkplain Subcomponent direct child} components that are declared by a subcomponent
+   * factory method.
+   */
+  abstract ImmutableBiMap<ComponentMethodDescriptor, ComponentDescriptor>
+      subcomponentsByFactoryMethod();
+
+  /**
+   * All {@linkplain Subcomponent direct child} components that are declared by a subcomponent
+   * builder method.
+   */
+  abstract ImmutableBiMap<ComponentMethodDescriptor, ComponentDescriptor>
+    subcomponentsByBuilderMethod();
+
+  /**
+   * All {@linkplain Subcomponent direct child} components that are declared by an entry point
+   * method. This is equivalent to the set of values from {@link #subcomponentsByFactoryMethod()}
+   * and {@link #subcomponentsByBuilderMethod()}.
+   */
+  ImmutableSet<ComponentDescriptor> subcomponentsFromEntryPoints() {
+    return ImmutableSet.<ComponentDescriptor>builder()
+        .addAll(subcomponentsByFactoryMethod().values())
+        .addAll(subcomponentsByBuilderMethod().values())
+        .build();
+  }
+
+  @Memoized
+  ImmutableBiMap<TypeElement, ComponentDescriptor> subcomponentsByBuilderType() {
+    ImmutableBiMap.Builder<TypeElement, ComponentDescriptor> subcomponentsByBuilderType =
+        ImmutableBiMap.builder();
+    for (ComponentDescriptor subcomponent : subcomponents()) {
+      if (subcomponent.builderSpec().isPresent()) {
+        subcomponentsByBuilderType.put(
+            subcomponent.builderSpec().get().builderDefinitionType(), subcomponent);
+      }
+    }
+    return subcomponentsByBuilderType.build();
+  }
 
   abstract ImmutableSet<ComponentMethodDescriptor> componentMethods();
 
+  /** The dependency requests defined by methods on the component type. */
+  ImmutableSet<DependencyRequest> entryPoints() {
+    return componentMethods()
+        .stream()
+        .map(ComponentMethodDescriptor::dependencyRequest)
+        .filter(Optional::isPresent)
+        .map(Optional::get)
+        .collect(toImmutableSet());
+  }
+
   // TODO(gak): Consider making this non-optional and revising the
   // interaction between the spec & generation
   abstract Optional<BuilderSpec> builderSpec();
 
-  @AutoValue
-  static abstract class ComponentMethodDescriptor {
-    abstract ComponentMethodKind kind();
-    abstract Optional<DependencyRequest> dependencyRequest();
-    abstract ExecutableElement methodElement();
+  /**
+   * For {@link Component @Component}s, all {@link CanReleaseReferences @CanReleaseReferences}
+   * scopes associated with this component or any subcomponent. Otherwise empty.
+   */
+  ImmutableSet<Scope> releasableReferencesScopes() {
+    return kind().equals(Kind.COMPONENT)
+        ? SUBCOMPONENT_TRAVERSER
+            .breadthFirstTraversal(this)
+            .transformAndConcat(ComponentDescriptor::scopes)
+            .filter(Scope::canReleaseReferences)
+            .toSet()
+        : ImmutableSet.<Scope>of();
+  }
 
-    /**
-     * A predicate that passes for {@link ComponentMethodDescriptor}s of one of the given kinds.
-     */
-    static Predicate<ComponentMethodDescriptor> isOfKind(ComponentMethodKind... kinds) {
-      final ImmutableSet<ComponentMethodKind> kindSet = ImmutableSet.copyOf(kinds);
-      return new Predicate<ComponentMethodDescriptor>() {
+  /** {@link TreeTraverser} for the subcomponent tree. */
+  private static final TreeTraverser<ComponentDescriptor> SUBCOMPONENT_TRAVERSER =
+      new TreeTraverser<ComponentDescriptor>() {
         @Override
-        public boolean apply(ComponentMethodDescriptor descriptor) {
-          return kindSet.contains(descriptor.kind());
+        public Iterable<ComponentDescriptor> children(ComponentDescriptor node) {
+          return node.subcomponents();
         }
       };
-    }
+
+  /** A function that returns all {@link #scopes()} of its input. */
+  @AutoValue
+  abstract static class ComponentMethodDescriptor {
+    abstract ComponentMethodKind kind();
+    abstract Optional<DependencyRequest> dependencyRequest();
+    abstract ExecutableElement methodElement();
 
     static ComponentMethodDescriptor create(
         ComponentMethodKind kind,
@@ -324,7 +386,14 @@ static ComponentMethodDescriptor forMembersInjection(
 
     static ComponentMethodDescriptor forSubcomponent(
         ComponentMethodKind kind, ExecutableElement methodElement) {
-      return create(kind, Optional.<DependencyRequest>absent(), methodElement);
+      return create(kind, Optional.empty(), methodElement);
+    }
+
+    static ComponentMethodDescriptor forSubcomponentBuilder(
+        ComponentMethodKind kind,
+        DependencyRequest dependencyRequestForBuilder,
+        ExecutableElement methodElement) {
+      return create(kind, Optional.of(dependencyRequestForBuilder), methodElement);
     }
   }
 
@@ -337,6 +406,10 @@ static ComponentMethodDescriptor forSubcomponent(
     PRODUCTION_SUBCOMPONENT,
     PRODUCTION_SUBCOMPONENT_BUILDER;
 
+    boolean isSubcomponentKind() {
+      return this == SUBCOMPONENT || this == PRODUCTION_SUBCOMPONENT;
+    }
+
     /**
      * Returns the component kind associated with this component method, if it exists. Otherwise,
      * throws.
@@ -356,9 +429,16 @@ Kind componentKind() {
   }
 
   @AutoValue
-  static abstract class BuilderSpec {
+  abstract static class BuilderRequirementMethod {
+    abstract ExecutableElement method();
+
+    abstract ComponentRequirement requirement();
+  }
+
+  @AutoValue
+  abstract static class BuilderSpec {
     abstract TypeElement builderDefinitionType();
-    abstract Map<TypeElement, ExecutableElement> methodMap();
+    abstract ImmutableSet<BuilderRequirementMethod> requirementMethods();
     abstract ExecutableElement buildMethod();
     abstract TypeMirror componentType();
   }
@@ -390,7 +470,7 @@ ComponentDescriptor forComponent(TypeElement componentDefinitionType) {
           kind.isPresent() && kind.get().isTopLevel(),
           "%s must be annotated with @Component or @ProductionComponent",
           componentDefinitionType);
-      return create(componentDefinitionType, kind.get(), Optional.<Kind>absent());
+      return create(componentDefinitionType, kind.get(), Optional.empty());
     }
 
     private ComponentDescriptor create(
@@ -416,27 +496,40 @@ private ComponentDescriptor create(
         }
       }
 
-      ImmutableSet.Builder<ModuleDescriptor> modules = ImmutableSet.builder();
-      for (TypeMirror moduleIncludesType : getComponentModules(componentMirror)) {
-        modules.add(moduleDescriptorFactory.create(MoreTypes.asTypeElement(moduleIncludesType)));
+      ImmutableSet.Builder<ModuleDescriptor> modulesBuilder = ImmutableSet.builder();
+      for (TypeMirror componentModulesType : getComponentModules(componentMirror)) {
+        modulesBuilder.add(
+            moduleDescriptorFactory.create(MoreTypes.asTypeElement(componentModulesType)));
       }
       if (kind.equals(Kind.PRODUCTION_COMPONENT)
           || (kind.equals(Kind.PRODUCTION_SUBCOMPONENT)
               && parentKind.isPresent()
               && (parentKind.get().equals(Kind.COMPONENT)
                   || parentKind.get().equals(Kind.SUBCOMPONENT)))) {
-        modules.add(descriptorForMonitoringModule(componentDefinitionType));
-        modules.add(descriptorForProductionExecutorModule(componentDefinitionType));
+        modulesBuilder.add(descriptorForMonitoringModule(componentDefinitionType));
+        modulesBuilder.add(descriptorForProductionExecutorModule(componentDefinitionType));
+      }
+      ImmutableSet<ModuleDescriptor> modules = modulesBuilder.build();
+      ImmutableSet<ModuleDescriptor> transitiveModules = transitiveModules(modules);
+      ImmutableSet.Builder<ComponentDescriptor> subcomponentsFromModules = ImmutableSet.builder();
+      for (ModuleDescriptor module : transitiveModules) {
+        for (SubcomponentDeclaration subcomponentDeclaration : module.subcomponentDeclarations()) {
+          TypeElement subcomponent = subcomponentDeclaration.subcomponentType();
+          subcomponentsFromModules.add(
+              create(
+                  subcomponent, Kind.forAnnotatedElement(subcomponent).get(), Optional.of(kind)));
+        }
       }
-
       ImmutableSet<ExecutableElement> unimplementedMethods =
-          Util.getUnimplementedMethods(elements, componentDefinitionType);
+          getUnimplementedMethods(componentDefinitionType, types, elements);
 
       ImmutableSet.Builder<ComponentMethodDescriptor> componentMethodsBuilder =
           ImmutableSet.builder();
 
-      ImmutableMap.Builder<ComponentMethodDescriptor, ComponentDescriptor> subcomponentDescriptors =
-          ImmutableMap.builder();
+      ImmutableBiMap.Builder<ComponentMethodDescriptor, ComponentDescriptor>
+          subcomponentsByFactoryMethod = ImmutableBiMap.builder();
+      ImmutableBiMap.Builder<ComponentMethodDescriptor, ComponentDescriptor>
+          subcomponentsByBuilderMethod = ImmutableBiMap.builder();
       for (ExecutableElement componentMethod : unimplementedMethods) {
         ExecutableType resolvedMethod =
             MoreTypes.asExecutable(types.asMemberOf(declaredComponentType, componentMethod));
@@ -446,7 +539,7 @@ private ComponentDescriptor create(
         switch (componentMethodDescriptor.kind()) {
           case SUBCOMPONENT:
           case PRODUCTION_SUBCOMPONENT:
-            subcomponentDescriptors.put(
+            subcomponentsByFactoryMethod.put(
                 componentMethodDescriptor,
                 create(
                     MoreElements.asType(MoreTypes.asElement(resolvedMethod.getReturnType())),
@@ -455,7 +548,7 @@ private ComponentDescriptor create(
             break;
           case SUBCOMPONENT_BUILDER:
           case PRODUCTION_SUBCOMPONENT_BUILDER:
-            subcomponentDescriptors.put(
+            subcomponentsByBuilderMethod.put(
                 componentMethodDescriptor,
                 create(
                     MoreElements.asType(
@@ -465,14 +558,13 @@ private ComponentDescriptor create(
             break;
           default: // nothing special to do for other methods.
         }
-
       }
 
       ImmutableList<DeclaredType> enclosedBuilders = kind.builderAnnotationType() == null
           ? ImmutableList.<DeclaredType>of()
           : enclosedBuilders(componentDefinitionType, kind.builderAnnotationType());
       Optional<DeclaredType> builderType =
-          Optional.fromNullable(getOnlyElement(enclosedBuilders, null));
+          Optional.ofNullable(getOnlyElement(enclosedBuilders, null));
       Optional<BuilderSpec> builderSpec = createBuilderSpec(builderType);
 
       ImmutableSet<Scope> scopes = Scope.scopesOf(componentDefinitionType);
@@ -485,10 +577,13 @@ private ComponentDescriptor create(
           componentMirror,
           componentDefinitionType,
           componentDependencyTypes,
-          modules.build(),
+          modules,
+          transitiveModules,
           dependencyMethodIndex.build(),
           scopes,
-          subcomponentDescriptors.build(),
+          subcomponentsFromModules.build(),
+          subcomponentsByFactoryMethod.build(),
+          subcomponentsByBuilderMethod.build(),
           componentMethodsBuilder.build(),
           builderSpec);
     }
@@ -512,21 +607,23 @@ private ComponentMethodDescriptor getDescriptorForComponentMethod(
               dependencyRequestFactory.forComponentMembersInjectionMethod(
                   componentMethod, resolvedComponentMethod));
         } else if (!getQualifier(componentMethod).isPresent()) {
-          if (isAnnotationPresent(MoreTypes.asElement(returnType), Subcomponent.class)) {
-            return ComponentMethodDescriptor.forSubcomponent(
-                ComponentMethodKind.SUBCOMPONENT, componentMethod);
-          } else if (isAnnotationPresent(
-              MoreTypes.asElement(returnType), ProductionSubcomponent.class)) {
-            return ComponentMethodDescriptor.forSubcomponent(
-                ComponentMethodKind.PRODUCTION_SUBCOMPONENT, componentMethod);
-          } else if (isAnnotationPresent(
-              MoreTypes.asElement(returnType), Subcomponent.Builder.class)) {
+          Element returnTypeElement = MoreTypes.asElement(returnType);
+          if (isSubcomponent(returnTypeElement)) {
             return ComponentMethodDescriptor.forSubcomponent(
-                ComponentMethodKind.SUBCOMPONENT_BUILDER, componentMethod);
-          } else if (isAnnotationPresent(
-              MoreTypes.asElement(returnType), ProductionSubcomponent.Builder.class)) {
-            return ComponentMethodDescriptor.forSubcomponent(
-                ComponentMethodKind.PRODUCTION_SUBCOMPONENT_BUILDER, componentMethod);
+                isAnnotationPresent(returnTypeElement, Subcomponent.class)
+                    ? ComponentMethodKind.SUBCOMPONENT
+                    : ComponentMethodKind.PRODUCTION_SUBCOMPONENT,
+                componentMethod);
+          } else if (isSubcomponentBuilder(returnTypeElement)) {
+            DependencyRequest dependencyRequest =
+                dependencyRequestFactory.forComponentProvisionMethod(
+                    componentMethod, resolvedComponentMethod);
+            return ComponentMethodDescriptor.forSubcomponentBuilder(
+                isAnnotationPresent(returnTypeElement, Subcomponent.Builder.class)
+                    ? ComponentMethodKind.SUBCOMPONENT_BUILDER
+                    : ComponentMethodKind.PRODUCTION_SUBCOMPONENT_BUILDER,
+                dependencyRequest,
+                componentMethod);
           }
         }
       }
@@ -567,11 +664,11 @@ private ComponentMethodDescriptor getDescriptorForComponentMethod(
 
     private Optional<BuilderSpec> createBuilderSpec(Optional<DeclaredType> builderType) {
       if (!builderType.isPresent()) {
-        return Optional.absent();
+        return Optional.empty();
       }
       TypeElement element = MoreTypes.asTypeElement(builderType.get());
-      ImmutableSet<ExecutableElement> methods = Util.getUnimplementedMethods(elements, element);
-      ImmutableMap.Builder<TypeElement, ExecutableElement> map = ImmutableMap.builder();
+      ImmutableSet<ExecutableElement> methods = getUnimplementedMethods(element, types, elements);
+      ImmutableSet.Builder<BuilderRequirementMethod> requirementMethods = ImmutableSet.builder();
       ExecutableElement buildMethod = null;
       for (ExecutableElement method : methods) {
         if (method.getParameters().isEmpty()) {
@@ -579,12 +676,36 @@ private ComponentMethodDescriptor getDescriptorForComponentMethod(
         } else {
           ExecutableType resolved =
               MoreTypes.asExecutable(types.asMemberOf(builderType.get(), method));
-          map.put(MoreTypes.asTypeElement(getOnlyElement(resolved.getParameterTypes())), method);
+          requirementMethods.add(
+              new AutoValue_ComponentDescriptor_BuilderRequirementMethod(
+                  method, requirementForBuilderMethod(method, resolved)));
         }
       }
       verify(buildMethod != null); // validation should have ensured this.
-      return Optional.<BuilderSpec>of(new AutoValue_ComponentDescriptor_BuilderSpec(element,
-          map.build(), buildMethod, element.getEnclosingElement().asType()));
+      return Optional.of(
+          new AutoValue_ComponentDescriptor_BuilderSpec(
+              element,
+              requirementMethods.build(),
+              buildMethod,
+              element.getEnclosingElement().asType()));
+    }
+
+    private ComponentRequirement requirementForBuilderMethod(
+        ExecutableElement method, ExecutableType resolvedType) {
+      checkArgument(method.getParameters().size() == 1);
+      if (isAnnotationPresent(method, BindsInstance.class)) {
+        DependencyRequest request =
+            dependencyRequestFactory.forRequiredResolvedVariable(
+                getOnlyElement(method.getParameters()),
+                getOnlyElement(resolvedType.getParameterTypes()));
+        return ComponentRequirement.forBinding(
+            request.key(), request.isNullable(), method.getSimpleName().toString());
+      }
+
+      TypeMirror type = getOnlyElement(resolvedType.getParameterTypes());
+      return ConfigurationAnnotations.getModuleAnnotation(MoreTypes.asTypeElement(type)).isPresent()
+          ? ComponentRequirement.forModule(type)
+          : ComponentRequirement.forDependency(type);
     }
 
     /**
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
index 146ddbce5..dadb44639 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Google, Inc.
+ * Copyright (C) 2014 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,13 +13,14 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal.codegen;
 
 import com.google.common.base.Joiner;
-import com.google.common.base.Optional;
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.TypeSpec;
 import dagger.Component;
+import java.util.Optional;
 import javax.annotation.processing.Filer;
 import javax.lang.model.element.Element;
 import javax.lang.model.util.Elements;
@@ -52,8 +53,7 @@
 
   @Override
   ClassName nameGeneratedType(BindingGraph input) {
-    ClassName componentDefinitionClassName =
-        ClassName.get(input.componentDescriptor().componentDefinitionType());
+    ClassName componentDefinitionClassName = ClassName.get(input.componentType());
     String componentName =
         "Dagger" + Joiner.on('_').join(componentDefinitionClassName.simpleNames());
     return componentDefinitionClassName.topLevelClassName().peerClass(componentName);
@@ -61,7 +61,7 @@ ClassName nameGeneratedType(BindingGraph input) {
 
   @Override
   Optional<? extends Element> getElementForErrorReporting(BindingGraph input) {
-    return Optional.of(input.componentDescriptor().componentDefinitionType());
+    return Optional.of(input.componentType());
   }
 
   @Override
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentHierarchyValidator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentHierarchyValidator.java
index 99b8ce49c..936b4d35f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentHierarchyValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentHierarchyValidator.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,85 +13,133 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal.codegen;
 
+import static com.google.common.base.Functions.constant;
+import static com.google.common.base.Predicates.and;
+import static com.google.common.base.Predicates.equalTo;
+import static com.google.common.base.Predicates.in;
+import static com.google.common.base.Predicates.not;
+
 import com.google.auto.common.MoreTypes;
+import com.google.common.base.Predicate;
 import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.LinkedHashMultimap;
 import com.google.common.collect.Maps;
+import com.google.common.collect.Multimaps;
+import com.google.common.collect.SetMultimap;
 import com.google.common.collect.Sets;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
 import java.util.Map;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
+import javax.lang.model.util.Elements;
 
-import static com.google.common.base.Functions.constant;
-
-/**
- * Validates the relationships between parent components and subcomponents.
- */
+/** Validates the relationships between parent components and subcomponents. */
 final class ComponentHierarchyValidator {
+  private final CompilerOptions compilerOptions;
+  private final Elements elements;
+
+  ComponentHierarchyValidator(CompilerOptions compilerOptions, Elements elements) {
+    this.compilerOptions = compilerOptions;
+    this.elements = elements;
+  }
+
   ValidationReport<TypeElement> validate(ComponentDescriptor componentDescriptor) {
-    return validateSubcomponentMethods(
+    ValidationReport.Builder<TypeElement> report =
+        ValidationReport.about(componentDescriptor.componentDefinitionType());
+    validateSubcomponentMethods(
+        report,
         componentDescriptor,
         Maps.toMap(
             componentDescriptor.transitiveModuleTypes(),
             constant(componentDescriptor.componentDefinitionType())));
+
+    if (compilerOptions.scopeCycleValidationType().diagnosticKind().isPresent()) {
+      validateScopeHierarchy(
+          report, componentDescriptor, LinkedHashMultimap.<ComponentDescriptor, Scope>create());
+    }
+    return report.build();
   }
 
-  private ValidationReport<TypeElement> validateSubcomponentMethods(
+  private void validateSubcomponentMethods(
+      ValidationReport.Builder<?> report,
       ComponentDescriptor componentDescriptor,
       ImmutableMap<TypeElement, TypeElement> existingModuleToOwners) {
-    ValidationReport.Builder<TypeElement> reportBuilder =
-        ValidationReport.about(componentDescriptor.componentDefinitionType());
     for (Map.Entry<ComponentMethodDescriptor, ComponentDescriptor> subcomponentEntry :
-        componentDescriptor.subcomponents().entrySet()) {
+        componentDescriptor.subcomponentsByFactoryMethod().entrySet()) {
       ComponentMethodDescriptor subcomponentMethodDescriptor = subcomponentEntry.getKey();
       ComponentDescriptor subcomponentDescriptor = subcomponentEntry.getValue();
       // validate the way that we create subcomponents
-      switch (subcomponentMethodDescriptor.kind()) {
-        case SUBCOMPONENT:
-        case PRODUCTION_SUBCOMPONENT:
-          for (VariableElement factoryMethodParameter :
-              subcomponentMethodDescriptor.methodElement().getParameters()) {
-            TypeElement moduleType = MoreTypes.asTypeElement(factoryMethodParameter.asType());
-            TypeElement originatingComponent = existingModuleToOwners.get(moduleType);
-            if (originatingComponent != null) {
-              /* Factory method tries to pass a module that is already present in the parent.
-               * This is an error. */
-              reportBuilder.addError(
-                  String.format(
-                      "%s is present in %s. A subcomponent cannot use an instance of a "
-                          + "module that differs from its parent.",
-                      moduleType.getSimpleName(),
-                      originatingComponent.getQualifiedName()),
-                  factoryMethodParameter);
-            }
-          }
-          break;
-          
-        case SUBCOMPONENT_BUILDER:
-        case PRODUCTION_SUBCOMPONENT_BUILDER:
-          /* A subcomponent builder allows you to pass a module that is already present in the
-           * parent.  This can't be an error because it might be valid in _other_ components. Don't
-           * bother warning, because there's nothing to do except suppress the warning. */
-          break;
-          
-        default:
-          throw new AssertionError();
+      for (VariableElement factoryMethodParameter :
+          subcomponentMethodDescriptor.methodElement().getParameters()) {
+        TypeElement moduleType = MoreTypes.asTypeElement(factoryMethodParameter.asType());
+        TypeElement originatingComponent = existingModuleToOwners.get(moduleType);
+        if (originatingComponent != null) {
+          /* Factory method tries to pass a module that is already present in the parent.
+           * This is an error. */
+          report.addError(
+              String.format(
+                  "%s is present in %s. A subcomponent cannot use an instance of a "
+                      + "module that differs from its parent.",
+                  moduleType.getSimpleName(), originatingComponent.getQualifiedName()),
+              factoryMethodParameter);
+        }
+      }
+      validateSubcomponentMethods(
+          report,
+          subcomponentDescriptor,
+          new ImmutableMap.Builder<TypeElement, TypeElement>()
+              .putAll(existingModuleToOwners)
+              .putAll(
+                  Maps.toMap(
+                      Sets.difference(
+                          subcomponentDescriptor.transitiveModuleTypes(),
+                          existingModuleToOwners.keySet()),
+                      constant(subcomponentDescriptor.componentDefinitionType())))
+              .build());
+    }
+  }
+
+  /**
+   * Checks that components do not have any scopes that are also applied on any of their ancestors.
+   */
+  private void validateScopeHierarchy(
+      ValidationReport.Builder<TypeElement> report,
+      ComponentDescriptor subject,
+      SetMultimap<ComponentDescriptor, Scope> scopesByComponent) {
+    scopesByComponent.putAll(subject, subject.scopes());
+
+    for (ComponentDescriptor child : subject.subcomponents()) {
+      validateScopeHierarchy(report, child, scopesByComponent);
+    }
+
+    scopesByComponent.removeAll(subject);
+
+    Predicate<Scope> subjectScopes =
+        subject.kind().isProducer()
+            // TODO(beder): validate that @ProductionScope is only applied on production components
+            ? and(in(subject.scopes()), not(equalTo(Scope.productionScope(elements))))
+            : in(subject.scopes());
+    SetMultimap<ComponentDescriptor, Scope> overlappingScopes =
+        Multimaps.filterValues(scopesByComponent, subjectScopes);
+    if (!overlappingScopes.isEmpty()) {
+      StringBuilder error =
+          new StringBuilder()
+              .append(subject.componentDefinitionType().getQualifiedName())
+              .append(" has conflicting scopes:");
+      for (Map.Entry<ComponentDescriptor, Scope> entry : overlappingScopes.entries()) {
+        Scope scope = entry.getValue();
+        error.append("\n  ")
+            .append(entry.getKey().componentDefinitionType().getQualifiedName())
+            .append(" also has ")
+            .append(scope.getReadableSource());
       }
-      reportBuilder.addSubreport(
-          validateSubcomponentMethods(
-              subcomponentDescriptor,
-              new ImmutableMap.Builder<TypeElement, TypeElement>()
-                  .putAll(existingModuleToOwners)
-                  .putAll(
-                      Maps.toMap(
-                          Sets.difference(
-                              subcomponentDescriptor.transitiveModuleTypes(),
-                              existingModuleToOwners.keySet()),
-                          constant(subcomponentDescriptor.componentDefinitionType())))
-                  .build()));
+      report.addItem(
+          error.toString(),
+          compilerOptions.scopeCycleValidationType().diagnosticKind().get(),
+          subject.componentDefinitionType());
     }
-    return reportBuilder.build();
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java
index 8a4feddac..46b07dce3 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Google, Inc.
+ * Copyright (C) 2014 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal.codegen;
 
 import com.google.auto.common.BasicAnnotationProcessor.ProcessingStep;
@@ -102,7 +103,7 @@
         getElementsFromAnnotations(
             elementsByAnnotation,
             FluentIterable.from(componentKind.subcomponentKinds())
-                .transform(ComponentDescriptor.Kind.toBuilderAnnotationType())
+                .transform(ComponentDescriptor.Kind::builderAnnotationType)
                 .toSet());
     Map<Element, ValidationReport<TypeElement>> builderReportsBySubcomponent =
         processBuilders(subcomponentBuilderElements);
@@ -110,7 +111,7 @@
         getElementsFromAnnotations(
             elementsByAnnotation,
             FluentIterable.from(componentKind.subcomponentKinds())
-                .transform(ComponentDescriptor.Kind.toAnnotationType())
+                .transform(ComponentDescriptor.Kind::annotationType)
                 .toSet());
     Map<Element, ValidationReport<TypeElement>> reportsBySubcomponent =
         processSubcomponents(subcomponentElements, subcomponentBuilderElements);
@@ -150,16 +151,12 @@
   }
 
   private void generateComponent(BindingGraph bindingGraph) {
-    try {
-      componentGenerator.generate(bindingGraph);
-    } catch (SourceFileGenerationException e) {
-      e.printMessageTo(messager);
-    }
+    componentGenerator.generate(bindingGraph, messager);
   }
 
   private ImmutableSet<Element> getElementsFromAnnotations(
       final SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation,
-      ImmutableSet<Class<? extends Annotation>> annotations) {
+      ImmutableSet<? extends Class<? extends Annotation>> annotations) {
     return ImmutableSet.copyOf(
         Multimaps.filterKeys(elementsByAnnotation, Predicates.in(annotations)).values());
   }
@@ -191,9 +188,10 @@ private void generateComponent(BindingGraph bindingGraph) {
 
   /**
    * Returns true if the component's report is clean, its builder report is clean, and all
-   * referenced subcomponent reports & subcomponent builder reports are clean.
+   * referenced subcomponent reports and subcomponent builder reports are clean.
    */
-  private boolean isClean(ComponentValidationReport report,
+  private boolean isClean(
+      ComponentValidationReport report,
       Map<Element, ValidationReport<TypeElement>> builderReportsByComponent,
       Map<Element, ValidationReport<TypeElement>> reportsBySubcomponent,
       Map<Element, ValidationReport<TypeElement>> builderReportsBySubcomponent) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
index 5fae068e6..b47fbf983 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Google, Inc.
+ * Copyright (C) 2014 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,22 +13,25 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal.codegen;
 
+import static dagger.internal.codegen.ModuleProcessingStep.moduleProcessingStep;
+import static dagger.internal.codegen.ModuleProcessingStep.producerModuleProcessingStep;
+
 import com.google.auto.common.BasicAnnotationProcessor;
 import com.google.auto.service.AutoService;
 import com.google.common.collect.ImmutableList;
+import com.google.googlejavaformat.java.filer.FormattingFiler;
 import java.util.Set;
 import javax.annotation.processing.Filer;
 import javax.annotation.processing.Messager;
 import javax.annotation.processing.Processor;
+import javax.annotation.processing.RoundEnvironment;
 import javax.lang.model.SourceVersion;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 
-import static dagger.internal.codegen.ModuleProcessingStep.moduleProcessingStep;
-import static dagger.internal.codegen.ModuleProcessingStep.producerModuleProcessingStep;
-
 /**
  * The annotation processor responsible for generating the classes that drive the Dagger 2.0
  * implementation.
@@ -59,29 +62,20 @@ public SourceVersion getSupportedSourceVersion() {
     Messager messager = processingEnv.getMessager();
     Types types = processingEnv.getTypeUtils();
     Elements elements = processingEnv.getElementUtils();
-    Filer filer = processingEnv.getFiler();
-
     CompilerOptions compilerOptions = CompilerOptions.create(processingEnv, elements);
+    Filer filer =  new FormattingFiler(processingEnv.getFiler());
 
+    KeyFormatter keyFormatter = new KeyFormatter();
     MethodSignatureFormatter methodSignatureFormatter = new MethodSignatureFormatter(types);
     BindingDeclarationFormatter bindingDeclarationFormatter =
-        new BindingDeclarationFormatter(methodSignatureFormatter);
+        new BindingDeclarationFormatter(methodSignatureFormatter, keyFormatter);
     DependencyRequestFormatter dependencyRequestFormatter =
         new DependencyRequestFormatter(types, elements);
-    KeyFormatter keyFormatter = new KeyFormatter(methodSignatureFormatter);
+
+    Key.Factory keyFactory = new Key.Factory(types, elements);
 
     InjectValidator injectValidator = new InjectValidator(types, elements, compilerOptions);
     InjectValidator injectValidatorWhenGeneratingCode = injectValidator.whenGeneratingCode();
-    ModuleValidator moduleValidator =
-        new ModuleValidator(types, elements, methodSignatureFormatter);
-    BuilderValidator builderValidator = new BuilderValidator(elements, types);
-    ComponentValidator subcomponentValidator =
-        ComponentValidator.createForSubcomponent(
-            elements, types, moduleValidator, builderValidator);
-    ComponentValidator componentValidator =
-        ComponentValidator.createForComponent(
-            elements, types, moduleValidator, subcomponentValidator, builderValidator);
-    MapKeyValidator mapKeyValidator = new MapKeyValidator();
     ProvidesMethodValidator providesMethodValidator = new ProvidesMethodValidator(elements, types);
     ProducesMethodValidator producesMethodValidator = new ProducesMethodValidator(elements, types);
     BindsMethodValidator bindsMethodValidator = new BindsMethodValidator(elements, types);
@@ -89,16 +83,38 @@ public SourceVersion getSupportedSourceVersion() {
         new MultibindsMethodValidator(elements, types);
     MultibindingsMethodValidator multibindingsMethodValidator =
         new MultibindingsMethodValidator(elements, types);
-
-    Key.Factory keyFactory = new Key.Factory(types, elements);
-
+    BindsOptionalOfMethodValidator bindsOptionalOfMethodValidator =
+        new BindsOptionalOfMethodValidator(elements, types);
+    AnyBindingMethodValidator anyBindingMethodValidator =
+        new AnyBindingMethodValidator(
+            providesMethodValidator,
+            producesMethodValidator,
+            bindsMethodValidator,
+            multibindsMethodValidator,
+            bindsOptionalOfMethodValidator);
     MultibindingsValidator multibindingsValidator =
         new MultibindingsValidator(
             elements,
+            types,
             keyFactory,
             keyFormatter,
             methodSignatureFormatter,
             multibindingsMethodValidator);
+    ModuleValidator moduleValidator =
+        new ModuleValidator(
+            types,
+            elements,
+            anyBindingMethodValidator,
+            multibindingsValidator,
+            methodSignatureFormatter);
+    BuilderValidator builderValidator = new BuilderValidator(elements, types);
+    ComponentValidator subcomponentValidator =
+        ComponentValidator.createForSubcomponent(
+            elements, types, moduleValidator, builderValidator);
+    ComponentValidator componentValidator =
+        ComponentValidator.createForComponent(
+            elements, types, moduleValidator, subcomponentValidator, builderValidator);
+    MapKeyValidator mapKeyValidator = new MapKeyValidator();
 
     this.factoryGenerator =
         new FactoryGenerator(filer, elements, compilerOptions, injectValidatorWhenGeneratingCode);
@@ -114,19 +130,23 @@ public SourceVersion getSupportedSourceVersion() {
         new ProductionExecutorModuleGenerator(filer, elements);
 
     DependencyRequest.Factory dependencyRequestFactory =
-        new DependencyRequest.Factory(elements, keyFactory);
+        new DependencyRequest.Factory(keyFactory);
     ProvisionBinding.Factory provisionBindingFactory =
         new ProvisionBinding.Factory(elements, types, keyFactory, dependencyRequestFactory);
     ProductionBinding.Factory productionBindingFactory =
         new ProductionBinding.Factory(types, keyFactory, dependencyRequestFactory);
     MultibindingDeclaration.Factory multibindingDeclarationFactory =
         new MultibindingDeclaration.Factory(elements, types, keyFactory);
+    SubcomponentDeclaration.Factory subcomponentDeclarationFactory =
+        new SubcomponentDeclaration.Factory(keyFactory);
 
     MembersInjectionBinding.Factory membersInjectionBindingFactory =
         new MembersInjectionBinding.Factory(elements, types, keyFactory, dependencyRequestFactory);
 
     DelegateDeclaration.Factory bindingDelegateDeclarationFactory =
         new DelegateDeclaration.Factory(types, keyFactory, dependencyRequestFactory);
+    OptionalBindingDeclaration.Factory optionalBindingDeclarationFactory =
+        new OptionalBindingDeclaration.Factory(keyFactory);
 
     this.injectBindingRegistry =
         new InjectBindingRegistry(
@@ -136,7 +156,8 @@ public SourceVersion getSupportedSourceVersion() {
             injectValidator,
             keyFactory,
             provisionBindingFactory,
-            membersInjectionBindingFactory);
+            membersInjectionBindingFactory,
+            compilerOptions);
 
     ModuleDescriptor.Factory moduleDescriptorFactory =
         new ModuleDescriptor.Factory(
@@ -144,7 +165,9 @@ public SourceVersion getSupportedSourceVersion() {
             provisionBindingFactory,
             productionBindingFactory,
             multibindingDeclarationFactory,
-            bindingDelegateDeclarationFactory);
+            bindingDelegateDeclarationFactory,
+            subcomponentDeclarationFactory,
+            optionalBindingDeclarationFactory);
 
     ComponentDescriptor.Factory componentDescriptorFactory = new ComponentDescriptor.Factory(
         elements, types, dependencyRequestFactory, moduleDescriptorFactory);
@@ -157,8 +180,14 @@ public SourceVersion getSupportedSourceVersion() {
             provisionBindingFactory,
             productionBindingFactory);
 
-    MapKeyGenerator mapKeyGenerator = new MapKeyGenerator(filer, elements);
-    ComponentHierarchyValidator componentHierarchyValidator = new ComponentHierarchyValidator();
+    AnnotationCreatorGenerator annotationCreatorGenerator =
+        new AnnotationCreatorGenerator(filer, elements);
+    UnwrappedMapKeyGenerator unwrappedMapKeyGenerator =
+        new UnwrappedMapKeyGenerator(filer, elements);
+    CanReleaseReferencesValidator canReleaseReferencesValidator =
+        new CanReleaseReferencesValidator();
+    ComponentHierarchyValidator componentHierarchyValidator =
+        new ComponentHierarchyValidator(compilerOptions, elements);
     BindingGraphValidator bindingGraphValidator =
         new BindingGraphValidator(
             elements,
@@ -173,20 +202,17 @@ public SourceVersion getSupportedSourceVersion() {
             keyFactory);
 
     return ImmutableList.of(
-        new MapKeyProcessingStep(messager, types, mapKeyValidator, mapKeyGenerator),
+        new MapKeyProcessingStep(
+            messager, types, mapKeyValidator, annotationCreatorGenerator, unwrappedMapKeyGenerator),
+        new ForReleasableReferencesValidator(messager),
+        new CanReleaseReferencesProcessingStep(
+            messager, canReleaseReferencesValidator, annotationCreatorGenerator),
         new InjectProcessingStep(injectBindingRegistry),
         new MonitoringModuleProcessingStep(messager, monitoringModuleGenerator),
         new ProductionExecutorModuleProcessingStep(messager, productionExecutorModuleGenerator),
-        new MultibindingsProcessingStep(messager, multibindingsValidator),
         new MultibindingAnnotationsProcessingStep(messager),
-        moduleProcessingStep(
-            messager,
-            moduleValidator,
-            provisionBindingFactory,
-            factoryGenerator,
-            providesMethodValidator,
-            bindsMethodValidator,
-            multibindsMethodValidator),
+        new BindsInstanceProcessingStep(messager),
+        moduleProcessingStep(messager, moduleValidator, provisionBindingFactory, factoryGenerator),
         new ComponentProcessingStep(
             ComponentDescriptor.Kind.COMPONENT,
             messager,
@@ -201,11 +227,10 @@ public SourceVersion getSupportedSourceVersion() {
         producerModuleProcessingStep(
             messager,
             moduleValidator,
+            provisionBindingFactory,
+            factoryGenerator,
             productionBindingFactory,
-            producerFactoryGenerator,
-            producesMethodValidator,
-            bindsMethodValidator,
-            multibindsMethodValidator),
+            producerFactoryGenerator),
         new ComponentProcessingStep(
             ComponentDescriptor.Kind.PRODUCTION_COMPONENT,
             messager,
@@ -216,16 +241,20 @@ public SourceVersion getSupportedSourceVersion() {
             bindingGraphValidator,
             componentDescriptorFactory,
             bindingGraphFactory,
-            componentGenerator));
+            componentGenerator),
+        new MultibindingsProcessingStep(messager, multibindingsValidator),
+        new BindingMethodProcessingStep(messager, anyBindingMethodValidator));
   }
 
   @Override
-  protected void postProcess() {
-    try {
-      injectBindingRegistry.generateSourcesForRequiredBindings(
-          factoryGenerator, membersInjectorGenerator);
-    } catch (SourceFileGenerationException e) {
-      e.printMessageTo(processingEnv.getMessager());
+  protected void postRound(RoundEnvironment roundEnv) {
+    if (!roundEnv.processingOver()) {
+      try {
+        injectBindingRegistry.generateSourcesForRequiredBindings(
+            factoryGenerator, membersInjectorGenerator);
+      } catch (SourceFileGenerationException e) {
+        e.printMessageTo(processingEnv.getMessager());
+      }
     }
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentRequirement.java b/compiler/src/main/java/dagger/internal/codegen/ComponentRequirement.java
new file mode 100644
index 000000000..428deef86
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentRequirement.java
@@ -0,0 +1,145 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkNotNull;
+import static dagger.internal.codegen.SourceFiles.simpleVariableName;
+import static dagger.internal.codegen.Util.componentCanMakeNewInstances;
+import static dagger.internal.codegen.Util.requiresAPassedInstance;
+
+import com.google.auto.common.MoreTypes;
+import com.google.auto.value.AutoValue;
+import com.google.common.base.Equivalence;
+import java.util.Optional;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
+
+/** A type that a component needs an instance of. */
+@AutoValue
+abstract class ComponentRequirement {
+  enum Kind {
+    /** A type listed in the component's {@code dependencies} attribute. */
+    DEPENDENCY,
+    /** A type listed in the component or subcomponent's {@code modules} attribute. */
+    MODULE,
+    /** An object key that can be bound to an instance provided to the builder. */
+    BINDING,
+  }
+
+  /** The kind of requirement. */
+  abstract Kind kind();
+
+  /**
+   * The type of the instance the component must have, wrapped so that requirements can be used as
+   * value types.
+   */
+  abstract Equivalence.Wrapper<TypeMirror> wrappedType();
+
+  /** The type of the instance the component must have. */
+  TypeMirror type() {
+    return wrappedType().get();
+  }
+
+  /** The element associated with the type of this requirement. */
+  TypeElement typeElement() {
+    return MoreTypes.asTypeElement(type());
+  }
+
+  /** The action a component builder should take if it {@code null} is passed. */
+  enum NullPolicy {
+    /** Make a new instance. */
+    NEW,
+    /** Throw an exception. */
+    THROW,
+    /** Allow use of null values. */
+    ALLOW,
+  }
+
+  /**
+   * An override for the requirement's null policy. If set, this is used as the null policy instead
+   * of the default behavior in {@link #nullPolicy}.
+   *
+   * <p>Some implementations' null policy can be determined upon construction (e.g., for binding
+   * instances), but others' require Elements and Types, which must wait until {@link #nullPolicy}
+   * is called.
+   */
+  abstract Optional<NullPolicy> overrideNullPolicy();
+
+  /** The requirement's null policy. */
+  NullPolicy nullPolicy(Elements elements, Types types) {
+    if (overrideNullPolicy().isPresent()) {
+      return overrideNullPolicy().get();
+    }
+    switch (kind()) {
+      case DEPENDENCY:
+        return NullPolicy.THROW;
+      case MODULE:
+        return componentCanMakeNewInstances(typeElement())
+            ? NullPolicy.NEW
+            : requiresAPassedInstance(elements, types, typeElement())
+                ? NullPolicy.THROW
+                : NullPolicy.ALLOW;
+      case BINDING:
+        return NullPolicy.THROW;
+    }
+    throw new AssertionError();
+  }
+
+  /** The key for this requirement, if one is available. */
+  abstract Optional<Key> key();
+
+  /** Returns the name for this requirement that could be used as a variable. */
+  abstract String variableName();
+
+  static ComponentRequirement forDependency(TypeMirror type) {
+    return new AutoValue_ComponentRequirement(
+        Kind.DEPENDENCY,
+        MoreTypes.equivalence().wrap(checkNotNull(type)),
+        Optional.empty(),
+        Optional.empty(),
+        simpleVariableName(MoreTypes.asTypeElement(type)));
+  }
+
+  static ComponentRequirement forModule(TypeMirror type) {
+    return new AutoValue_ComponentRequirement(
+        Kind.MODULE,
+        MoreTypes.equivalence().wrap(checkNotNull(type)),
+        Optional.empty(),
+        Optional.empty(),
+        simpleVariableName(MoreTypes.asTypeElement(type)));
+  }
+
+  static ComponentRequirement forBinding(Key key, boolean nullable, String variableName) {
+    return new AutoValue_ComponentRequirement(
+        Kind.BINDING,
+        key.wrappedType(),
+        nullable ? Optional.of(NullPolicy.ALLOW) : Optional.empty(),
+        Optional.of(key),
+        variableName);
+  }
+
+  static ComponentRequirement forBinding(ContributionBinding binding) {
+    checkArgument(binding.bindingKind().equals(ContributionBinding.Kind.BUILDER_BINDING));
+    return forBinding(
+        binding.key(),
+        binding.nullableType().isPresent(),
+        binding.bindingElement().get().getSimpleName().toString());
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentTreeTraverser.java b/compiler/src/main/java/dagger/internal/codegen/ComponentTreeTraverser.java
new file mode 100644
index 000000000..93dd1e538
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentTreeTraverser.java
@@ -0,0 +1,650 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkState;
+import static com.google.common.base.Predicates.equalTo;
+import static com.google.common.base.Verify.verify;
+import static com.google.common.collect.Iterables.getOnlyElement;
+import static com.google.common.collect.Iterables.indexOf;
+import static com.google.common.collect.Iterables.skip;
+import static com.google.common.collect.Multimaps.asMap;
+import static dagger.internal.codegen.BindingKey.contribution;
+import static dagger.internal.codegen.Util.toImmutableSet;
+import static java.util.Spliterator.ORDERED;
+import static java.util.Spliterator.SIZED;
+
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Iterables;
+import com.google.common.collect.Iterators;
+import com.google.common.collect.LinkedHashMultiset;
+import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
+import java.util.ArrayDeque;
+import java.util.Deque;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.Set;
+import java.util.Spliterators.AbstractSpliterator;
+import java.util.function.BiConsumer;
+import java.util.function.BiFunction;
+import java.util.function.Consumer;
+import java.util.function.Predicate;
+import java.util.stream.Stream;
+import java.util.stream.StreamSupport;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ExecutableElement;
+
+/**
+ * An object that traverses the entire component hierarchy, starting from the root component.
+ *
+ * <p>Subclasses can override {@link #visitComponent(BindingGraph)} to perform custom logic at each
+ * component in the tree, and {@link #visitSubcomponentFactoryMethod(BindingGraph, BindingGraph,
+ * ExecutableElement)} to perform custom logic at each subcomponent factory method.
+ *
+ * <p>Subclasses can override {@link #bindingGraphTraverser(ComponentTreePath, DependencyRequest)}
+ * to traverse each entry point within each component in the tree.
+ */
+public class ComponentTreeTraverser {
+
+  /** The path from the root graph to the currently visited graph. */
+  private final Deque<BindingGraph> bindingGraphPath = new ArrayDeque<>();
+
+  /** Constructs a traverser for a root (component, not subcomponent) binding graph. */
+  public ComponentTreeTraverser(BindingGraph rootGraph) {
+    checkArgument(
+        rootGraph.componentDescriptor().kind().isTopLevel(),
+        "only top-level graphs can be traversed, not %s",
+        rootGraph.componentDescriptor().componentDefinitionType().getQualifiedName());
+    bindingGraphPath.add(rootGraph);
+  }
+
+  /**
+   * Calls {@link #visitComponent(BindingGraph)} for the root component.
+   *
+   * @throws IllegalStateException if a traversal is in progress
+   */
+  public final void traverseComponents() {
+    checkState(bindingGraphPath.size() == 1);
+    visitComponent(bindingGraphPath.getFirst());
+  }
+
+  /**
+   * Called once for each component in a component hierarchy.
+   *
+   * <p>Subclasses can override this method to perform whatever logic is required per component.
+   * They should call the {@code super} implementation if they want to continue the traversal in the
+   * standard order.
+   *
+   * <p>This implementation does the following:
+   *
+   * <ol>
+   *   <li>If this component is installed in its parent by a subcomponent factory method, calls
+   *       {@link #visitSubcomponentFactoryMethod(BindingGraph, BindingGraph, ExecutableElement)}.
+   *   <li>For each entry point in the component, calls {@link #visitEntryPoint(DependencyRequest,
+   *       BindingGraph)}.
+   *   <li>For each child component, calls {@link #visitComponent(BindingGraph)}, updating the
+   *       traversal state.
+   * </ol>
+   *
+   * @param graph the currently visited graph
+   */
+  protected void visitComponent(BindingGraph graph) {
+    if (bindingGraphPath.size() > 1) {
+      BindingGraph parent = Iterators.get(bindingGraphPath.descendingIterator(), 1);
+      ComponentMethodDescriptor childFactoryMethod =
+          parent
+              .componentDescriptor()
+              .subcomponentsByFactoryMethod()
+              .inverse()
+              .get(graph.componentDescriptor());
+      if (childFactoryMethod != null) {
+        visitSubcomponentFactoryMethod(graph, parent, childFactoryMethod.methodElement());
+      }
+    }
+
+    for (DependencyRequest entryPoint : graph.componentDescriptor().entryPoints()) {
+      visitEntryPoint(entryPoint, graph);
+    }
+
+    for (BindingGraph child : graph.subgraphs()) {
+      bindingGraphPath.addLast(child);
+      try {
+        visitComponent(child);
+      } finally {
+        verify(bindingGraphPath.removeLast().equals(child));
+      }
+    }
+  }
+
+  /**
+   * Called if this component was installed in its parent by a subcomponent factory method.
+   *
+   * <p>This implementation does nothing.
+   *
+   * @param graph the currently visited graph
+   * @param parent the parent graph
+   * @param factoryMethod the factory method in the parent component that declares that the current
+   *     component is a child
+   */
+  protected void visitSubcomponentFactoryMethod(
+      BindingGraph graph, BindingGraph parent, ExecutableElement factoryMethod) {}
+
+  /**
+   * Called once for each entry point in a component.
+   *
+   * <p>Subclasses can override this method to perform whatever logic is required per entry point.
+   * They should call the {@code super} implementation if they want to continue the traversal in the
+   * standard order.
+   *
+   * <p>This implementation passes the entry point and the current component tree path to {@link
+   * #bindingGraphTraverser(ComponentTreePath, DependencyRequest)}, and calls {@link
+   * BindingGraphTraverser#traverseDependencies()} on the returned object.
+   *
+   * @param graph the graph for the component that contains the entry point
+   */
+  protected void visitEntryPoint(DependencyRequest entryPoint, BindingGraph graph) {
+    bindingGraphTraverser(componentTreePath(), entryPoint).traverseDependencies();
+  }
+
+  /**
+   * Returns an object that traverses the binding graph starting from an entry point.
+   *
+   * <p>This implementation returns a no-op object that does nothing. Subclasses should override in
+   * order to perform custom logic within the binding graph.
+   *
+   * @param componentPath the path from the root component to the component that includes the entry
+   *     point
+   * @param entryPoint the entry point
+   */
+  protected BindingGraphTraverser bindingGraphTraverser(
+      ComponentTreePath componentPath, DependencyRequest entryPoint) {
+    return new NoOpBindingGraphTraverser(componentPath, entryPoint);
+  }
+
+  /**
+   * Returns an immutable snapshot of the path from the root component to the currently visited
+   * component.
+   */
+  protected final ComponentTreePath componentTreePath() {
+    return new ComponentTreePath(bindingGraphPath);
+  }
+
+  /** An object that traverses the binding graph starting from an entry point. */
+  public static class BindingGraphTraverser {
+
+    private final ComponentTreePath componentTreePath;
+    private final DependencyRequest entryPoint;
+    private final Deque<DependencyRequest> dependencyRequestPath = new ArrayDeque<>();
+    private final Deque<ResolvedBindings> resolvedBindingsPath = new ArrayDeque<>();
+    private final LinkedHashMultiset<BindingKey> bindingKeysInPath = LinkedHashMultiset.create();
+    private final Set<DependencyRequest> visitedDependencyRequests = new HashSet<>();
+
+    /**
+     * Constructs a traverser for an entry point.
+     *
+     * @param componentPath the path from the root component to the component that includes the
+     *     entry point to be traversed
+     * @param entryPoint the entry point to be traversed
+     */
+    public BindingGraphTraverser(ComponentTreePath componentPath, DependencyRequest entryPoint) {
+      this.componentTreePath = componentPath;
+      this.entryPoint = entryPoint;
+    }
+
+    /**
+     * Calls {@link #visitDependencyRequest(DependencyRequest)} for the {@linkplain
+     * #entryPointElement() entry point}.
+     *
+     * @throws IllegalStateException if a traversal is in progress
+     */
+    public void traverseDependencies() {
+      checkState(dependencyRequestPath.isEmpty());
+      checkState(resolvedBindingsPath.isEmpty());
+      checkState(bindingKeysInPath.isEmpty());
+      checkState(visitedDependencyRequests.isEmpty());
+      nextDependencyRequest(entryPoint, currentGraph());
+    }
+
+    /**
+     * Called once for each dependency request that is reachable from an entry point.
+     *
+     * <p>Subclasses can override this method to perform whatever logic is required per dependency
+     * request. They should call the {@code super} implementation if they want to continue the
+     * traversal in the standard order.
+     *
+     * <p>This implementation calls {@link #visitResolvedBindings(ResolvedBindings)} unless the
+     * dependency request introduces a cycle.
+     *
+     * @param dependencyRequest the object returned by {@link #dependencyRequest()}
+     */
+    protected void visitDependencyRequest(DependencyRequest dependencyRequest) {
+      if (!atDependencyCycle()) {
+        visitResolvedBindings(resolvedBindingsPath.getLast());
+      }
+    }
+
+    /**
+     * Called once for each dependency request that is reachable from an entry point.
+     *
+     * <p>Subclasses can override this method to perform whatever logic is required per resolved
+     * bindings. They should call the {@code super} implementation if they want to continue the
+     * traversal in the standard order.
+     *
+     * <p>This implementation calls either {@link #visitMembersInjectionBindings(ResolvedBindings)}
+     * or {@link #visitContributionBindings(ResolvedBindings)}, depending on the binding key kind.
+     *
+     * @param resolvedBindings the object returned by {@link #resolvedBindings()}
+     */
+    protected void visitResolvedBindings(ResolvedBindings resolvedBindings) {
+      switch (resolvedBindings.bindingKey().kind()) {
+        case MEMBERS_INJECTION:
+          visitMembersInjectionBindings(resolvedBindings);
+          break;
+
+        case CONTRIBUTION:
+          visitContributionBindings(resolvedBindings);
+          break;
+      }
+    }
+
+    /**
+     * Called once for each dependency request for a members injector that is reachable from an
+     * entry point.
+     *
+     * <p>Subclasses can override this method to perform whatever logic is required per resolved
+     * members injection bindings. They should call the {@code super} implementation if they want to
+     * continue the traversal in the standard order.
+     *
+     * <p>This implementation calls {@link #visitMembersInjectionBinding(MembersInjectionBinding,
+     * ComponentDescriptor)}.
+     *
+     * @param resolvedBindings the object returned by {@link #resolvedBindings()}
+     */
+    protected void visitMembersInjectionBindings(ResolvedBindings resolvedBindings) {
+      if (!resolvedBindings.contributionBindings().isEmpty()) {
+        // TODO(dpb): How could this ever happen, even in an invalid graph?
+        throw new AssertionError(
+            "members injection binding keys should never have contribution bindings");
+      }
+      if (resolvedBindings.membersInjectionBinding().isPresent()) {
+        visitMembersInjectionBinding(
+            resolvedBindings.membersInjectionBinding().get(),
+            getOnlyElement(resolvedBindings.allMembersInjectionBindings().keySet()));
+      }
+    }
+
+    /**
+     * Called once for each members injection binding that is reachable from an entry point.
+     *
+     * <p>Subclasses can override this method to perform whatever logic is required per members
+     * injection binding. They should call the {@code super} implementation if they want to continue
+     * the traversal in the standard order.
+     *
+     * <p>This implementation calls {@link #visitBinding(Binding, ComponentDescriptor)}.
+     *
+     * @param binding the only value of {@code resolvedBindings().allMembersInjectionBindings()}
+     * @param owningComponent the only key of {@code
+     *     resolvedBindings().allMembersInjectionBindings()}. The binding's dependencies should be
+     *     resolved within this component.
+     */
+    protected void visitMembersInjectionBinding(
+        MembersInjectionBinding binding, ComponentDescriptor owningComponent) {
+      visitBinding(binding, owningComponent);
+    }
+
+    /**
+     * Called once for each dependency request for a contribution that is reachable from an entry
+     * point.
+     *
+     * <p>Subclasses can override this method to perform whatever logic is required per resolved
+     * contribution bindings. They should call the {@code super} implementation if they want to
+     * continue the traversal in the standard order.
+     *
+     * <p>This implementation calls {@link #visitContributionBinding(ContributionBinding,
+     * ComponentDescriptor)} for each contribution binding.
+     *
+     * @param resolvedBindings the object returned by {@link #resolvedBindings()}
+     */
+    protected void visitContributionBindings(ResolvedBindings resolvedBindings) {
+      if (resolvedBindings.membersInjectionBinding().isPresent()) {
+        throw new AssertionError(
+            "contribution binding keys should never have members injection bindings");
+      }
+      asMap(resolvedBindings.allContributionBindings())
+          .forEach(
+              (owningComponent, bindings) -> {
+                bindings.forEach(binding -> visitContributionBinding(binding, owningComponent));
+              });
+    }
+
+    /**
+     * Called once for each contribution binding that is reachable from an entry point.
+     *
+     * <p>Subclasses can override this method to perform whatever logic is required per contribution
+     * binding. They should call the {@code super} implementation if they want to continue the
+     * traversal in the standard order.
+     *
+     * <p>This implementation calls {@link #visitBinding(Binding, ComponentDescriptor)}.
+     *
+     * @param binding a value of {@code resolvedBindings().allContributionBindings()}
+     * @param owningComponent the key of {@code resolvedBindings().allContributionBindings()} for
+     *     {@code binding}. The binding's dependencies should be resolved within this component.
+     */
+    protected void visitContributionBinding(
+        ContributionBinding binding, ComponentDescriptor owningComponent) {
+      visitBinding(binding, owningComponent);
+    }
+
+    /**
+     * Called once for each binding that is reachable from an entry point.
+     *
+     * <p>Subclasses can override this method to perform whatever logic is required per binding.
+     * They should call the {@code super} implementation if they want to continue the traversal in
+     * the standard order.
+     *
+     * <p>This implementation calls {@link #visitDependencyRequest(DependencyRequest)} for each
+     * dependency of the binding, resolved within {@code owningComponent}, that has not already been
+     * visited while traversing the current entry point.
+     *
+     * @param binding a value of {@code resolvedBindings().allBindings()}
+     * @param owningComponent the key of {@code resolvedBindings().allBindings()} for {@code
+     *     binding}. The binding's dependencies should be resolved within this component.
+     */
+    protected void visitBinding(Binding binding, ComponentDescriptor owningComponent) {
+      BindingGraph owningGraph = componentTreePath.graphForComponent(owningComponent);
+      for (DependencyRequest dependency : binding.dependencies()) {
+        nextDependencyRequest(dependency, owningGraph);
+      }
+    }
+
+    private void nextDependencyRequest(
+        DependencyRequest dependencyRequest, BindingGraph bindingGraph) {
+      if (!visitedDependencyRequests.add(dependencyRequest)) {
+        return;
+      }
+
+      ResolvedBindings resolvedBindings =
+          bindingGraph.resolvedBindings().get(dependencyRequest.bindingKey());
+      dependencyRequestPath.addLast(dependencyRequest);
+      resolvedBindingsPath.addLast(resolvedBindings);
+      bindingKeysInPath.add(dependencyRequest.bindingKey());
+      try {
+        visitDependencyRequest(dependencyRequest);
+      } finally {
+        verify(dependencyRequestPath.removeLast().equals(dependencyRequest));
+        verify(resolvedBindingsPath.removeLast().equals(resolvedBindings));
+        verify(bindingKeysInPath.remove(dependencyRequest.bindingKey()));
+      }
+    }
+
+    /**
+     * Returns the path from the root component to the component that includes the {@linkplain
+     * #entryPointElement()} entry point.
+     */
+    protected final ComponentTreePath componentTreePath() {
+      return componentTreePath;
+    }
+
+    /**
+     * Returns the rootmost of the binding graphs in the component path that own each binding.
+     *
+     * <p>For arguments {@code [x, y]}, if binding {@code x} is owned by component {@code A} and
+     * binding {@code y} is owned by component {@code B}, and {@code A} is an ancestor of {@code B},
+     * then this method returns the binding graph for {@code A}.
+     */
+    public BindingGraph owningGraph(Iterable<ContributionBinding> bindings) {
+      ImmutableSet.Builder<ComponentDescriptor> owningComponents = ImmutableSet.builder();
+      for (ContributionBinding binding : bindings) {
+        ResolvedBindings resolvedBindings =
+            currentGraph().resolvedBindings().get(contribution(binding.key()));
+        owningComponents.add(resolvedBindings.owningComponent(binding));
+      }
+      return componentTreePath.rootmostGraph(owningComponents.build());
+    }
+
+    /**
+     * Returns {@code true} if the {@linkplain #dependencyRequest() current dependency request} is
+     * also higher in the dependency path.
+     *
+     * @throws IllegalStateException if this object is not currently traversing dependencies
+     */
+    protected final boolean atDependencyCycle() {
+      checkState(!dependencyRequestPath.isEmpty());
+      return bindingKeysInPath.count(dependencyRequest().bindingKey()) > 1;
+    }
+
+    /**
+     * Returns the dependency request currently being visited.
+     *
+     * @throws IllegalStateException if this object is not currently traversing dependencies
+     */
+    protected final DependencyRequest dependencyRequest() {
+      return dependencyRequestPath.getLast();
+    }
+
+    /**
+     * Returns the resolved bindings for the {@linkplain #dependencyRequest() current dependency
+     * request}.
+     *
+     * @throws IllegalStateException if this object is not currently traversing dependencies
+     */
+    protected final ResolvedBindings resolvedBindings() {
+      return resolvedBindingsPath.getLast();
+    }
+
+    /**
+     * Returns the bindings that depend directly on the {@linkplain #dependencyRequest() current
+     * dependency request}.
+     */
+    protected final ImmutableSet<? extends Binding> dependentBindings() {
+      if (atEntryPoint()) {
+        return ImmutableSet.of();
+      }
+      ResolvedBindings dependentResolvedBindings =
+          Iterators.get(resolvedBindingsPath.descendingIterator(), 1);
+      return dependentResolvedBindings
+          .bindings()
+          .stream()
+          .filter(binding -> binding.dependencies().contains(dependencyRequest()))
+          .collect(toImmutableSet());
+    }
+
+    /**
+     * Returns the entry point whose dependencies are currently being traversed.
+     *
+     * @throws IllegalStateException if this object is not currently traversing dependencies
+     */
+    protected final Element entryPointElement() {
+      return entryPoint.requestElement().get();
+    }
+
+    /**
+     * Returns {@code true} if the {@linkplain #dependencyRequest() current dependency request} is
+     * an entry point.
+     */
+    protected final boolean atEntryPoint() {
+      return dependencyRequestPath.size() == 1;
+    }
+
+    /** Returns the binding graph for the component that is currently being visited. */
+    protected final BindingGraph currentGraph() {
+      return componentTreePath.currentGraph();
+    }
+
+    /**
+     * Returns the dependency requests and resolved bindings starting with the entry point and
+     * ending with the {@linkplain #dependencyRequest() current dependency request}.
+     */
+    protected final DependencyTrace dependencyTrace() {
+      checkState(!dependencyRequestPath.isEmpty());
+      return new DependencyTrace(dependencyRequestPath, resolvedBindingsPath);
+    }
+
+    /**
+     * Returns the dependency requests and resolved bindings in the {@linkplain #atDependencyCycle()
+     * dependency cycle}, starting with the request closest to the entry point and ending with the
+     * {@linkplain #dependencyRequest() current dependency request}.
+     *
+     * <p>The first request and the last request in the trace will have the same {@linkplain
+     * DependencyRequest#bindingKey() binding key}.
+     */
+    protected final DependencyTrace cycleDependencyTrace() {
+      checkState(atDependencyCycle(), "no cycle");
+      int skip = indexOf(bindingKeysInPath, equalTo(dependencyRequest().bindingKey()));
+      return new DependencyTrace(
+          skip(dependencyRequestPath, skip), skip(resolvedBindingsPath, skip));
+    }
+  }
+
+  /** A traverser that does nothing. */
+  private static final class NoOpBindingGraphTraverser extends BindingGraphTraverser {
+    private NoOpBindingGraphTraverser(
+        ComponentTreePath componentPath, DependencyRequest entryPoint) {
+      super(componentPath, entryPoint);
+    }
+
+    @Override
+    public void traverseDependencies() {}
+  }
+
+  /**
+   * A path from the root component to a component within the component tree during a {@linkplain
+   * ComponentTreeTraverser traversal}.
+   */
+  public static final class ComponentTreePath {
+    /** The binding graph path from the root graph to the currently visited graph. */
+    private final ImmutableList<BindingGraph> bindingGraphPath;
+
+    private ComponentTreePath(Iterable<BindingGraph> path) {
+      this.bindingGraphPath = ImmutableList.copyOf(path);
+    }
+
+    /**
+     * Returns the binding graphs in the path, starting from the {@linkplain #rootGraph() root
+     * graph} and ending with the {@linkplain #currentGraph() current graph}.
+     */
+    public ImmutableList<BindingGraph> graphsInPath() {
+      return bindingGraphPath;
+    }
+
+    /** Returns the binding graph for the component at the end of the path. */
+    public BindingGraph currentGraph() {
+      return Iterables.getLast(bindingGraphPath);
+    }
+
+    // TODO(dpb): Do we also want methods that return ComponentDescriptors, like currentComponent()?
+
+    /**
+     * Returns the binding graph for the parent of the {@linkplain #currentGraph() current
+     * component}.
+     *
+     * @throws IllegalStateException if the current graph is the {@linkplain #atRoot() root graph}
+     */
+    public BindingGraph parentGraph() {
+      checkState(!atRoot());
+      return bindingGraphPath.reverse().get(1);
+    }
+
+    /** Returns the binding graph for the root component. */
+    public BindingGraph rootGraph() {
+      return bindingGraphPath.get(0);
+    }
+
+    /**
+     * Returns {@code true} if the {@linkplain #currentGraph() current graph} is the {@linkplain
+     * #rootGraph() root graph}.
+     */
+    public boolean atRoot() {
+      return bindingGraphPath.size() == 1;
+    }
+
+    /** Returns the rootmost binding graph in the component path among the given components. */
+    public BindingGraph rootmostGraph(Iterable<ComponentDescriptor> components) {
+      ImmutableSet<ComponentDescriptor> set = ImmutableSet.copyOf(components);
+      return rootmostGraph(graph -> set.contains(graph.componentDescriptor()));
+    }
+
+    /** Returns the binding graph within this path that represents the given component. */
+    public BindingGraph graphForComponent(ComponentDescriptor component) {
+      return rootmostGraph(graph -> graph.componentDescriptor().equals(component));
+    }
+
+    private BindingGraph rootmostGraph(Predicate<? super BindingGraph> predicate) {
+      return bindingGraphPath.stream().filter(predicate).findFirst().get();
+    }
+  }
+
+  /**
+   * An immutable snapshot of a path through the binding graph.
+   *
+   * <p>The path contains pairs of a dependency request and the bindings resolved for it. At each
+   * step after the first the dependency request is contained by one of the bindings resolved for
+   * the previous dependency request.
+   */
+  public static final class DependencyTrace {
+    private final ImmutableList<DependencyRequest> dependencyRequests;
+    private final ImmutableList<ResolvedBindings> resolvedBindings;
+
+    private DependencyTrace(
+        Iterable<DependencyRequest> dependencyRequests,
+        Iterable<ResolvedBindings> resolvedBindings) {
+      this.dependencyRequests = ImmutableList.copyOf(dependencyRequests);
+      this.resolvedBindings = ImmutableList.copyOf(resolvedBindings);
+      checkArgument(
+          this.dependencyRequests.size() == this.resolvedBindings.size(),
+          "dependency requests and resolved bindings must have the same size: %s vs. %s",
+          this.dependencyRequests,
+          this.resolvedBindings);
+    }
+
+    /** Calls {@code consumer} for every dependency request and the bindings resolved for it. */
+    protected final void forEach(
+        BiConsumer<? super DependencyRequest, ? super ResolvedBindings> consumer) {
+      Iterator<DependencyRequest> dependencyRequestIterator = dependencyRequests.iterator();
+      Iterator<ResolvedBindings> resolvedBindingsIterator = resolvedBindings.iterator();
+      while (dependencyRequestIterator.hasNext()) {
+        consumer.accept(dependencyRequestIterator.next(), resolvedBindingsIterator.next());
+      }
+    }
+
+    /**
+     * Returns an ordered stream of the results of calling {@code function} on every dependency
+     * request and the bindings resolved for it.
+     */
+    protected final <T> Stream<T> transform(
+        BiFunction<? super DependencyRequest, ? super ResolvedBindings, T> function) {
+      Iterator<DependencyRequest> dependencyRequestIterator = dependencyRequests.iterator();
+      Iterator<ResolvedBindings> resolvedBindingsIterator = resolvedBindings.iterator();
+      return StreamSupport.stream(
+          new AbstractSpliterator<T>(dependencyRequests.size(), ORDERED | SIZED) {
+            @Override
+            public boolean tryAdvance(Consumer<? super T> action) {
+              if (!dependencyRequestIterator.hasNext()) {
+                return false;
+              }
+              action.accept(
+                  function.apply(
+                      dependencyRequestIterator.next(), resolvedBindingsIterator.next()));
+              return true;
+            }
+          },
+          false);
+    }
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
index f20bc8db6..d2401056b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Google, Inc.
+ * Copyright (C) 2014 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,26 +13,42 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal.codegen;
 
+import static com.google.auto.common.MoreElements.getLocalAndInheritedMethods;
+import static com.google.auto.common.MoreTypes.asExecutable;
+import static dagger.internal.codegen.ConfigurationAnnotations.enclosedBuilders;
+import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
+import static dagger.internal.codegen.ConfigurationAnnotations.getComponentModules;
+import static dagger.internal.codegen.ConfigurationAnnotations.getTransitiveModules;
+import static dagger.internal.codegen.ConfigurationAnnotations.validateComponentDependencies;
+import static dagger.internal.codegen.DaggerElements.getAnnotationMirror;
+import static dagger.internal.codegen.DaggerElements.getAnyAnnotation;
+import static dagger.internal.codegen.ErrorMessages.COMPONENT_ANNOTATED_REUSABLE;
+import static javax.lang.model.element.ElementKind.CLASS;
+import static javax.lang.model.element.ElementKind.INTERFACE;
+import static javax.lang.model.element.Modifier.ABSTRACT;
+import static javax.lang.model.type.TypeKind.VOID;
+
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
-import com.google.common.base.Optional;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.LinkedHashMultimap;
-import com.google.common.collect.Multimap;
+import com.google.common.collect.Maps;
+import com.google.common.collect.SetMultimap;
 import com.google.common.collect.Sets;
 import dagger.Component;
 import dagger.Reusable;
+import dagger.internal.codegen.ComponentDescriptor.Kind;
 import dagger.producers.ProductionComponent;
 import java.lang.annotation.Annotation;
-import java.util.Collection;
 import java.util.List;
-import java.util.Map;
+import java.util.Optional;
 import java.util.Set;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
@@ -42,24 +58,13 @@
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.ExecutableType;
 import javax.lang.model.type.TypeMirror;
-import javax.lang.model.util.ElementFilter;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.SimpleTypeVisitor6;
 import javax.lang.model.util.Types;
 
-import static com.google.auto.common.MoreElements.getAnnotationMirror;
-import static dagger.internal.codegen.ConfigurationAnnotations.enclosedBuilders;
-import static dagger.internal.codegen.ConfigurationAnnotations.getComponentModules;
-import static dagger.internal.codegen.ConfigurationAnnotations.getTransitiveModules;
-import static dagger.internal.codegen.ErrorMessages.COMPONENT_ANNOTATED_REUSABLE;
-import static javax.lang.model.element.ElementKind.CLASS;
-import static javax.lang.model.element.ElementKind.INTERFACE;
-import static javax.lang.model.element.Modifier.ABSTRACT;
-import static javax.lang.model.type.TypeKind.VOID;
-
 /**
- * Performs superficial validation of the contract of the {@link Component} and
- * {@link ProductionComponent} annotations.
+ * Performs superficial validation of the contract of the {@link Component} and {@link
+ * ProductionComponent} annotations.
  *
  * @author Gregory Kick
  */
@@ -70,7 +75,8 @@
   private final ComponentValidator subcomponentValidator;
   private final BuilderValidator subcomponentBuilderValidator;
 
-  private ComponentValidator(Elements elements,
+  private ComponentValidator(
+      Elements elements,
       Types types,
       ModuleValidator moduleValidator,
       BuilderValidator subcomponentBuilderValidator) {
@@ -81,7 +87,8 @@ private ComponentValidator(Elements elements,
     this.subcomponentBuilderValidator = subcomponentBuilderValidator;
   }
 
-  private ComponentValidator(Elements elements,
+  private ComponentValidator(
+      Elements elements,
       Types types,
       ModuleValidator moduleValidator,
       ComponentValidator subcomponentValidator,
@@ -93,7 +100,8 @@ private ComponentValidator(Elements elements,
     this.subcomponentBuilderValidator = subcomponentBuilderValidator;
   }
 
-  static ComponentValidator createForComponent(Elements elements,
+  static ComponentValidator createForComponent(
+      Elements elements,
       Types types,
       ModuleValidator moduleValidator,
       ComponentValidator subcomponentValidator,
@@ -102,7 +110,8 @@ static ComponentValidator createForComponent(Elements elements,
         elements, types, moduleValidator, subcomponentValidator, subcomponentBuilderValidator);
   }
 
-  static ComponentValidator createForSubcomponent(Elements elements,
+  static ComponentValidator createForSubcomponent(
+      Elements elements,
       Types types,
       ModuleValidator moduleValidator,
       BuilderValidator subcomponentBuilderValidator) {
@@ -110,8 +119,9 @@ static ComponentValidator createForSubcomponent(Elements elements,
   }
 
   @AutoValue
-  static abstract class ComponentValidationReport {
+  abstract static class ComponentValidationReport {
     abstract Set<Element> referencedSubcomponents();
+
     abstract ValidationReport<TypeElement> report();
   }
 
@@ -119,7 +129,8 @@ static ComponentValidator createForSubcomponent(Elements elements,
    * Validates the given component subject. Also validates any referenced subcomponents that aren't
    * already included in the {@code validatedSubcomponents} set.
    */
-  public ComponentValidationReport validate(final TypeElement subject,
+  public ComponentValidationReport validate(
+      final TypeElement subject,
       Set<? extends Element> validatedSubcomponents,
       Set<? extends Element> validatedSubcomponentBuilders) {
     ValidationReport.Builder<TypeElement> builder = ValidationReport.about(subject);
@@ -151,96 +162,95 @@ public ComponentValidationReport validate(final TypeElement subject,
 
     DeclaredType subjectType = MoreTypes.asDeclared(subject.asType());
 
-    // TODO(gak): This should use Util.findLocalAndInheritedMethods, otherwise
-    // it can return a logical method multiple times (including overrides, etc.)
-    List<? extends Element> members = elements.getAllMembers(subject);
-    Multimap<Element, ExecutableElement> referencedSubcomponents = LinkedHashMultimap.create();
-    for (ExecutableElement method : ElementFilter.methodsIn(members)) {
-      if (method.getModifiers().contains(ABSTRACT)) {
-        ExecutableType resolvedMethod =
-            MoreTypes.asExecutable(types.asMemberOf(subjectType, method));
-        List<? extends TypeMirror> parameterTypes = resolvedMethod.getParameterTypes();
-        List<? extends VariableElement> parameters = method.getParameters();
-        TypeMirror returnType = resolvedMethod.getReturnType();
+    SetMultimap<Element, ExecutableElement> referencedSubcomponents = LinkedHashMultimap.create();
+    getLocalAndInheritedMethods(subject, types, elements)
+        .stream()
+        .filter(method -> method.getModifiers().contains(ABSTRACT))
+        .forEachOrdered(
+            method -> {
+              ExecutableType resolvedMethod = asExecutable(types.asMemberOf(subjectType, method));
+              List<? extends TypeMirror> parameterTypes = resolvedMethod.getParameterTypes();
+              List<? extends VariableElement> parameters = method.getParameters();
+              TypeMirror returnType = resolvedMethod.getReturnType();
 
-        // abstract methods are ones we have to implement, so they each need to be validated
-        // first, check the return type.  if it's a subcomponent, validate that method as such.
-        Optional<AnnotationMirror> subcomponentAnnotation =
-            checkForAnnotations(
-                returnType,
-                FluentIterable.from(componentKind.subcomponentKinds())
-                    .transform(ComponentDescriptor.Kind.toAnnotationType())
-                    .toSet());
-        Optional<AnnotationMirror> subcomponentBuilderAnnotation =
-            checkForAnnotations(
-                returnType,
-                FluentIterable.from(componentKind.subcomponentKinds())
-                    .transform(ComponentDescriptor.Kind.toBuilderAnnotationType())
-                    .toSet());
-        if (subcomponentAnnotation.isPresent()) {
-          referencedSubcomponents.put(MoreTypes.asElement(returnType), method);
-          validateSubcomponentMethod(
-              builder,
-              ComponentDescriptor.Kind.forAnnotatedElement(MoreTypes.asTypeElement(returnType))
-                  .get(),
-              method,
-              parameters,
-              parameterTypes,
-              returnType,
-              subcomponentAnnotation);
-        } else if (subcomponentBuilderAnnotation.isPresent()) {
-          referencedSubcomponents.put(MoreTypes.asElement(returnType).getEnclosingElement(),
-              method);
-          validateSubcomponentBuilderMethod(builder,
-              method,
-              parameters,
-              returnType,
-              validatedSubcomponentBuilders);
-        } else {
-          // if it's not a subcomponent...
-          switch (parameters.size()) {
-            case 0:
-              // no parameters means that it is a provision method
-              // basically, there are no restrictions here.  \o/
-              break;
-            case 1:
-              // one parameter means that it's a members injection method
-              TypeMirror onlyParameter = Iterables.getOnlyElement(parameterTypes);
-              if (!(returnType.getKind().equals(VOID)
-                  || types.isSameType(returnType, onlyParameter))) {
-                builder.addError(
-                    "Members injection methods may only return the injected type or void.", method);
+              // abstract methods are ones we have to implement, so they each need to be validated
+              // first, check the return type. if it's a subcomponent, validate that method as such.
+              Optional<AnnotationMirror> subcomponentAnnotation =
+                  checkForAnnotations(
+                      returnType,
+                      FluentIterable.from(componentKind.subcomponentKinds())
+                          .transform(Kind::annotationType)
+                          .toSet());
+              Optional<AnnotationMirror> subcomponentBuilderAnnotation =
+                  checkForAnnotations(
+                      returnType,
+                      FluentIterable.from(componentKind.subcomponentKinds())
+                          .transform(Kind::builderAnnotationType)
+                          .toSet());
+              if (subcomponentAnnotation.isPresent()) {
+                referencedSubcomponents.put(MoreTypes.asElement(returnType), method);
+                validateSubcomponentMethod(
+                    builder,
+                    ComponentDescriptor.Kind.forAnnotatedElement(
+                            MoreTypes.asTypeElement(returnType))
+                        .get(),
+                    method,
+                    parameters,
+                    parameterTypes,
+                    returnType,
+                    subcomponentAnnotation);
+              } else if (subcomponentBuilderAnnotation.isPresent()) {
+                referencedSubcomponents.put(
+                    MoreTypes.asElement(returnType).getEnclosingElement(), method);
+                validateSubcomponentBuilderMethod(
+                    builder, method, parameters, returnType, validatedSubcomponentBuilders);
+              } else {
+                // if it's not a subcomponent...
+                switch (parameters.size()) {
+                  case 0:
+                    // no parameters means that it is a provision method
+                    // basically, there are no restrictions here.  \o/
+                    break;
+                  case 1:
+                    // one parameter means that it's a members injection method
+                    TypeMirror onlyParameter = Iterables.getOnlyElement(parameterTypes);
+                    if (!(returnType.getKind().equals(VOID)
+                        || types.isSameType(returnType, onlyParameter))) {
+                      builder.addError(
+                          "Members injection methods may only return the injected type or void.",
+                          method);
+                    }
+                    break;
+                  default:
+                    // this isn't any method that we know how to implement...
+                    builder.addError(
+                        "This method isn't a valid provision method, members injection method or "
+                            + "subcomponent factory method. Dagger cannot implement this method",
+                        method);
+                    break;
+                }
               }
-              break;
-            default:
-              // this isn't any method that we know how to implement...
-              builder.addError(
-                  "This method isn't a valid provision method, members injection method or "
-                      + "subcomponent factory method. Dagger cannot implement this method",
-                  method);
-              break;
-          }
-        }
-      }
-    }
+            });
 
-    for (Map.Entry<Element, Collection<ExecutableElement>> entry :
-        referencedSubcomponents.asMap().entrySet()) {
-      if (entry.getValue().size() > 1) {
-        builder.addError(
-            String.format(
-                ErrorMessages.SubcomponentBuilderMessages.INSTANCE.moreThanOneRefToSubcomponent(),
-                entry.getKey(),
-                entry.getValue()),
-            subject);
-      }
-    }
+    Maps.filterValues(referencedSubcomponents.asMap(), methods -> methods.size() > 1)
+        .forEach(
+            (subcomponent, methods) ->
+                builder.addError(
+                    String.format(
+                        ErrorMessages.SubcomponentBuilderMessages.INSTANCE
+                            .moreThanOneRefToSubcomponent(),
+                        subcomponent,
+                        methods),
+                    subject));
 
     AnnotationMirror componentMirror =
         getAnnotationMirror(subject, componentKind.annotationType()).get();
-    ImmutableList<TypeMirror> moduleTypes = getComponentModules(componentMirror);
-    moduleValidator.validateReferencedModules(
-        subject, builder, moduleTypes, componentKind.moduleKinds());
+    if (componentKind.isTopLevel()) {
+      validateComponentDependencies(builder, getComponentDependencies(componentMirror));
+    }
+    builder.addSubreport(
+        moduleValidator.validateReferencedModules(
+            subject, componentMirror, componentKind.moduleKinds()));
 
     // Make sure we validate any subcomponents we're referencing, unless we know we validated
     // them already in this pass.
@@ -251,14 +261,17 @@ public ComponentValidationReport validate(final TypeElement subject,
         ImmutableSet.<Element>builder().addAll(referencedSubcomponents.keySet());
     for (Element subcomponent :
         Sets.difference(referencedSubcomponents.keySet(), validatedSubcomponents)) {
-      ComponentValidationReport subreport = subcomponentValidator.validate(
-          MoreElements.asType(subcomponent), validatedSubcomponents, validatedSubcomponentBuilders);
+      ComponentValidationReport subreport =
+          subcomponentValidator.validate(
+              MoreElements.asType(subcomponent),
+              validatedSubcomponents,
+              validatedSubcomponentBuilders);
       builder.addItems(subreport.report().items());
       allSubcomponents.addAll(subreport.referencedSubcomponents());
     }
 
-    return new AutoValue_ComponentValidator_ComponentValidationReport(allSubcomponents.build(),
-        builder.build());
+    return new AutoValue_ComponentValidator_ComponentValidationReport(
+        allSubcomponents.build(), builder.build());
   }
 
   private void validateSubcomponentMethod(
@@ -289,7 +302,7 @@ private void validateSubcomponentMethod(
               new SimpleTypeVisitor6<Optional<TypeElement>, Void>() {
                 @Override
                 protected Optional<TypeElement> defaultAction(TypeMirror e, Void p) {
-                  return Optional.absent();
+                  return Optional.empty();
                 }
 
                 @Override
@@ -300,7 +313,7 @@ private void validateSubcomponentMethod(
                       return Optional.of(MoreTypes.asTypeElement(t));
                     }
                   }
-                  return Optional.absent();
+                  return Optional.empty();
                 }
               },
               null);
@@ -333,8 +346,11 @@ private void validateSubcomponentMethod(
     }
   }
 
-  private void validateSubcomponentBuilderMethod(ValidationReport.Builder<TypeElement> builder,
-      ExecutableElement method, List<? extends VariableElement> parameters, TypeMirror returnType,
+  private void validateSubcomponentBuilderMethod(
+      ValidationReport.Builder<TypeElement> builder,
+      ExecutableElement method,
+      List<? extends VariableElement> parameters,
+      TypeMirror returnType,
       Set<? extends Element> validatedSubcomponentBuilders) {
 
     if (!parameters.isEmpty()) {
@@ -352,25 +368,13 @@ private void validateSubcomponentBuilderMethod(ValidationReport.Builder<TypeElem
     }
   }
 
-  private Optional<AnnotationMirror> checkForAnnotations(
-      TypeMirror type, final Set<Class<? extends Annotation>> annotations) {
+  private static Optional<AnnotationMirror> checkForAnnotations(
+      TypeMirror type, final Set<? extends Class<? extends Annotation>> annotations) {
     return type.accept(
-        new SimpleTypeVisitor6<Optional<AnnotationMirror>, Void>() {
-          @Override
-          protected Optional<AnnotationMirror> defaultAction(TypeMirror e, Void p) {
-            return Optional.absent();
-          }
-
+        new SimpleTypeVisitor6<Optional<AnnotationMirror>, Void>(Optional.empty()) {
           @Override
           public Optional<AnnotationMirror> visitDeclared(DeclaredType t, Void p) {
-            for (Class<? extends Annotation> annotation : annotations) {
-              Optional<AnnotationMirror> mirror =
-                  MoreElements.getAnnotationMirror(t.asElement(), annotation);
-              if (mirror.isPresent()) {
-                return mirror;
-              }
-            }
-            return Optional.absent();
+            return getAnyAnnotation(t.asElement(), annotations);
           }
         },
         null);
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java
index ccccf9032..577362213 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,11 +13,18 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal.codegen;
 
-import com.google.common.base.Function;
+import static com.squareup.javapoet.MethodSpec.methodBuilder;
+import static com.squareup.javapoet.TypeSpec.classBuilder;
+import static dagger.internal.codegen.TypeSpecs.addSupertype;
+import static dagger.internal.codegen.Util.requiresAPassedInstance;
+import static javax.lang.model.element.Modifier.FINAL;
+import static javax.lang.model.element.Modifier.PUBLIC;
+import static javax.lang.model.element.Modifier.STATIC;
+
 import com.google.common.base.Joiner;
-import com.google.common.base.Predicate;
 import com.google.common.base.Splitter;
 import com.google.common.collect.ImmutableBiMap;
 import com.google.common.collect.ImmutableListMultimap;
@@ -32,18 +39,9 @@
 import java.util.Map;
 import java.util.Map.Entry;
 import javax.lang.model.element.Name;
-import javax.lang.model.element.TypeElement;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 
-import static com.squareup.javapoet.MethodSpec.methodBuilder;
-import static com.squareup.javapoet.TypeSpec.classBuilder;
-import static dagger.internal.codegen.TypeSpecs.addSupertype;
-import static dagger.internal.codegen.Util.requiresAPassedInstance;
-import static javax.lang.model.element.Modifier.FINAL;
-import static javax.lang.model.element.Modifier.PUBLIC;
-import static javax.lang.model.element.Modifier.STATIC;
-
 /**
  * Creates the implementation class for a component.
  */
@@ -63,7 +61,8 @@
         compilerOptions,
         name,
         graph,
-        new UniqueSubcomponentNamesGenerator(graph).generate());
+        new UniqueSubcomponentNamesGenerator(graph).generate(),
+        new OptionalFactories());
   }
 
   /**
@@ -85,12 +84,8 @@ private UniqueSubcomponentNamesGenerator(BindingGraph graph) {
       componentDescriptorsBySimpleName =
           Multimaps.index(
               graph.componentDescriptors(),
-              new Function<ComponentDescriptor, String>() {
-                @Override
-                public String apply(ComponentDescriptor componentDescriptor) {
-                  return componentDescriptor.componentDefinitionType().getSimpleName().toString();
-                }
-              });
+              componentDescriptor ->
+                  componentDescriptor.componentDefinitionType().getSimpleName().toString());
       componentQualifiedNamePieces = qualifiedNames(graph.componentDescriptors());
     }
 
@@ -141,10 +136,9 @@ public String apply(ComponentDescriptor componentDescriptor) {
   }
 
   @Override
-  protected TypeSpec.Builder createComponentClass() {
-    TypeSpec.Builder component = classBuilder(name).addModifiers(PUBLIC, FINAL);
-    addSupertype(component, componentDefinitionType());
-    return component;
+  protected void decorateComponent() {
+    component.addModifiers(PUBLIC, FINAL);
+    addSupertype(component, graph.componentType());
   }
 
   @Override
@@ -188,7 +182,7 @@ protected void addFactoryMethods() {
           methodBuilder("create")
               .returns(componentDefinitionTypeName())
               .addModifiers(PUBLIC, STATIC)
-              .addStatement("return builder().$L()", buildMethodName)
+              .addStatement("return new Builder().$L()", buildMethodName)
               .build());
     }
   }
@@ -197,11 +191,6 @@ protected void addFactoryMethods() {
   private boolean canInstantiateAllRequirements() {
     return !Iterables.any(
         graph.componentRequirements(),
-        new Predicate<TypeElement>() {
-          @Override
-          public boolean apply(TypeElement dependency) {
-            return requiresAPassedInstance(elements, dependency);
-          }
-        });
+        dependency -> requiresAPassedInstance(elements, types, dependency.typeElement()));
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java b/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
index 76e8c0d64..d5e7c9b5a 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Google, Inc.
+ * Copyright (C) 2014 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,42 +13,47 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal.codegen;
 
+import static com.google.auto.common.AnnotationMirrors.getAnnotationValue;
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkNotNull;
+import static dagger.internal.codegen.DaggerElements.getAnyAnnotation;
+import static dagger.internal.codegen.DaggerElements.isAnyAnnotationPresent;
+import static dagger.internal.codegen.MoreAnnotationMirrors.getTypeListValue;
+import static dagger.internal.codegen.MoreAnnotationValues.asAnnotationValues;
+import static javax.lang.model.util.ElementFilter.typesIn;
+
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
-import com.google.common.base.Function;
-import com.google.common.base.Optional;
-import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Sets;
 import dagger.Component;
 import dagger.Module;
+import dagger.Subcomponent;
 import dagger.producers.ProducerModule;
+import dagger.producers.ProductionComponent;
+import dagger.producers.ProductionSubcomponent;
 import java.lang.annotation.Annotation;
 import java.util.ArrayDeque;
 import java.util.List;
+import java.util.Optional;
 import java.util.Queue;
 import java.util.Set;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.AnnotationValue;
-import javax.lang.model.element.AnnotationValueVisitor;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
-import javax.lang.model.util.ElementFilter;
 import javax.lang.model.util.Elements;
-import javax.lang.model.util.SimpleAnnotationValueVisitor6;
+import javax.lang.model.util.SimpleTypeVisitor6;
 import javax.lang.model.util.Types;
 
-import static com.google.auto.common.AnnotationMirrors.getAnnotationValue;
-import static com.google.auto.common.MoreElements.getAnnotationMirror;
-import static com.google.common.base.Preconditions.checkNotNull;
-
 /**
  * Utility methods related to dagger configuration annotations (e.g.: {@link Component}
  * and {@link Module}).
@@ -57,35 +62,99 @@
  */
 final class ConfigurationAnnotations {
 
+  static Optional<AnnotationMirror> getComponentAnnotation(TypeElement component) {
+    return getAnyAnnotation(component, Component.class, ProductionComponent.class);
+  }
+
+  static Optional<AnnotationMirror> getSubcomponentAnnotation(TypeElement subcomponent) {
+    return getAnyAnnotation(subcomponent, Subcomponent.class, ProductionSubcomponent.class);
+  }
+
+  static Optional<AnnotationMirror> getComponentOrSubcomponentAnnotation(TypeElement type) {
+    Optional<AnnotationMirror> componentAnnotation = getComponentAnnotation(type);
+    if (componentAnnotation.isPresent()) {
+      return componentAnnotation;
+    }
+    return getSubcomponentAnnotation(type);
+  }
+
+  static boolean isSubcomponent(Element element) {
+    return isAnyAnnotationPresent(element, Subcomponent.class, ProductionSubcomponent.class);
+  }
+
+  static Optional<TypeElement> getSubcomponentBuilder(TypeElement subcomponent) {
+    checkArgument(isSubcomponent(subcomponent));
+    for (TypeElement nestedType : typesIn(subcomponent.getEnclosedElements())) {
+      if (isSubcomponentBuilder(nestedType)) {
+        return Optional.of(nestedType);
+      }
+    }
+    return Optional.empty();
+  }
+
+  static boolean isSubcomponentBuilder(Element element) {
+    return isAnyAnnotationPresent(
+        element, Subcomponent.Builder.class, ProductionSubcomponent.Builder.class);
+  }
+
+  /**
+   * Returns the annotation values for the modules directly installed into a component or included
+   * in a module.
+   *
+   * @param annotatedType the component or module type
+   * @param annotation the component or module annotation
+   */
+  static ImmutableList<AnnotationValue> getModules(
+      TypeElement annotatedType, AnnotationMirror annotation) {
+    if (ComponentDescriptor.Kind.forAnnotatedElement(annotatedType).isPresent()) {
+      return asAnnotationValues(getAnnotationValue(annotation, MODULES_ATTRIBUTE));
+    }
+    if (ModuleDescriptor.Kind.forAnnotatedElement(annotatedType).isPresent()) {
+      return asAnnotationValues(getAnnotationValue(annotation, INCLUDES_ATTRIBUTE));
+    }
+    throw new IllegalArgumentException(String.format("unsupported annotation: %s", annotation));
+  }
+
   private static final String MODULES_ATTRIBUTE = "modules";
 
   static ImmutableList<TypeMirror> getComponentModules(AnnotationMirror componentAnnotation) {
     checkNotNull(componentAnnotation);
-    return convertClassArrayToListOfTypes(componentAnnotation, MODULES_ATTRIBUTE);
+    return getTypeListValue(componentAnnotation, MODULES_ATTRIBUTE);
   }
 
   private static final String DEPENDENCIES_ATTRIBUTE = "dependencies";
 
   static ImmutableList<TypeMirror> getComponentDependencies(AnnotationMirror componentAnnotation) {
     checkNotNull(componentAnnotation);
-    return convertClassArrayToListOfTypes(componentAnnotation, DEPENDENCIES_ATTRIBUTE);
+    return getTypeListValue(componentAnnotation, DEPENDENCIES_ATTRIBUTE);
+  }
+
+  static Optional<AnnotationMirror> getModuleAnnotation(TypeElement moduleElement) {
+    return getAnyAnnotation(moduleElement, Module.class, ProducerModule.class);
   }
 
   private static final String INCLUDES_ATTRIBUTE = "includes";
 
   static ImmutableList<TypeMirror> getModuleIncludes(AnnotationMirror moduleAnnotation) {
     checkNotNull(moduleAnnotation);
-    return convertClassArrayToListOfTypes(moduleAnnotation, INCLUDES_ATTRIBUTE);
+    return getTypeListValue(moduleAnnotation, INCLUDES_ATTRIBUTE);
+  }
+
+  private static final String SUBCOMPONENTS_ATTRIBUTE = "subcomponents";
+
+  static ImmutableList<TypeMirror> getModuleSubcomponents(AnnotationMirror moduleAnnotation) {
+    checkNotNull(moduleAnnotation);
+    return getTypeListValue(moduleAnnotation, SUBCOMPONENTS_ATTRIBUTE);
   }
 
   private static final String INJECTS_ATTRIBUTE = "injects";
 
   static ImmutableList<TypeMirror> getModuleInjects(AnnotationMirror moduleAnnotation) {
     checkNotNull(moduleAnnotation);
-    return convertClassArrayToListOfTypes(moduleAnnotation, INJECTS_ATTRIBUTE);
+    return getTypeListValue(moduleAnnotation, INJECTS_ATTRIBUTE);
   }
 
-  /** Returns the first type that specifies this' nullability, or absent if none. */
+  /** Returns the first type that specifies this' nullability, or empty if none. */
   static Optional<DeclaredType> getNullableType(Element element) {
     List<? extends AnnotationMirror> mirrors = element.getAnnotationMirrors();
     for (AnnotationMirror mirror : mirrors) {
@@ -93,56 +162,38 @@
         return Optional.of(mirror.getAnnotationType());
       }
     }
-    return Optional.absent();
+    return Optional.empty();
   }
 
-  /**
-   * Extracts the list of types that is the value of the annotation member {@code elementName} of
-   * {@code annotationMirror}.
-   *
-   * @throws IllegalArgumentException if no such member exists on {@code annotationMirror}, or it
-   *     exists but is not an array
-   * @throws TypeNotPresentException if any of the values cannot be converted to a type
-   */
-  static ImmutableList<TypeMirror> convertClassArrayToListOfTypes(
-      AnnotationMirror annotationMirror, String elementName) {
-    return TO_LIST_OF_TYPES.visit(getAnnotationValue(annotationMirror, elementName), elementName);
+  static <T extends Element> void validateComponentDependencies(
+      ValidationReport.Builder<T> report, Iterable<TypeMirror> types) {
+    validateTypesAreDeclared(report, types, "component dependency");
+    for (TypeMirror type : types) {
+      if (getModuleAnnotation(MoreTypes.asTypeElement(type)).isPresent()) {
+        report.addError(
+            String.format("%s is a module, which cannot be a component dependency", type));
+      }
+    }
   }
 
-  private static final AnnotationValueVisitor<ImmutableList<TypeMirror>, String> TO_LIST_OF_TYPES =
-      new SimpleAnnotationValueVisitor6<ImmutableList<TypeMirror>, String>() {
-        @Override
-        public ImmutableList<TypeMirror> visitArray(
-            List<? extends AnnotationValue> vals, String elementName) {
-          return FluentIterable.from(vals)
-              .transform(
-                  new Function<AnnotationValue, TypeMirror>() {
-                    @Override
-                    public TypeMirror apply(AnnotationValue typeValue) {
-                      return TO_TYPE.visit(typeValue);
-                    }
-                  })
-              .toList();
-        }
-
-        @Override
-        protected ImmutableList<TypeMirror> defaultAction(Object o, String elementName) {
-          throw new IllegalArgumentException(elementName + " is not an array: " + o);
-        }
-      };
-
-  private static final AnnotationValueVisitor<TypeMirror, Void> TO_TYPE =
-      new SimpleAnnotationValueVisitor6<TypeMirror, Void>() {
+  private static <T extends Element> void validateTypesAreDeclared(
+      final ValidationReport.Builder<T> report, Iterable<TypeMirror> types, final String typeName) {
+    for (TypeMirror type : types) {
+      type.accept(new SimpleTypeVisitor6<Void, Void>(){
         @Override
-        public TypeMirror visitType(TypeMirror t, Void p) {
-          return t;
+        protected Void defaultAction(TypeMirror e, Void aVoid) {
+          report.addError(String.format("%s is not a valid %s type", e, typeName));
+          return null;
         }
 
         @Override
-        protected TypeMirror defaultAction(Object o, Void p) {
-          throw new TypeNotPresentException(o.toString(), null);
+        public Void visitDeclared(DeclaredType t, Void aVoid) {
+          // Declared types are valid
+          return null;
         }
-      };
+      }, null);
+    }
+  }
 
   /**
    * Returns the full set of modules transitively {@linkplain Module#includes included} from the
@@ -161,8 +212,7 @@ protected TypeMirror defaultAction(Object o, Void p) {
     for (TypeElement moduleElement = moduleQueue.poll();
         moduleElement != null;
         moduleElement = moduleQueue.poll()) {
-      Optional<AnnotationMirror> moduleMirror = getAnnotationMirror(moduleElement, Module.class)
-          .or(getAnnotationMirror(moduleElement, ProducerModule.class));
+      Optional<AnnotationMirror> moduleMirror = getModuleAnnotation(moduleElement);
       if (moduleMirror.isPresent()) {
         ImmutableSet.Builder<TypeElement> moduleDependenciesBuilder = ImmutableSet.builder();
         moduleDependenciesBuilder.addAll(
@@ -187,7 +237,7 @@ protected TypeMirror defaultAction(Object o, Void p) {
   static ImmutableList<DeclaredType> enclosedBuilders(TypeElement typeElement,
       final Class<? extends Annotation> annotation) {
     final ImmutableList.Builder<DeclaredType> builders = ImmutableList.builder();
-    for (TypeElement element : ElementFilter.typesIn(typeElement.getEnclosedElements())) {
+    for (TypeElement element : typesIn(typeElement.getEnclosedElements())) {
       if (MoreElements.isAnnotationPresent(element, annotation)) {
         builders.add(MoreTypes.asDeclared(element.asType()));
       }
@@ -203,11 +253,11 @@ private static void addIncludesFromSuperclasses(Types types, TypeElement element
     while (!types.isSameType(objectType, superclass)
         && superclass.getKind().equals(TypeKind.DECLARED)) {
       element = MoreElements.asType(types.asElement(superclass));
-      Optional<AnnotationMirror> moduleMirror = getAnnotationMirror(element, Module.class)
-          .or(getAnnotationMirror(element, ProducerModule.class));
-      if (moduleMirror.isPresent()) {
-        builder.addAll(MoreTypes.asTypeElements(getModuleIncludes(moduleMirror.get())));
-      }
+      getModuleAnnotation(element)
+          .ifPresent(
+              moduleMirror -> {
+                builder.addAll(MoreTypes.asTypeElements(getModuleIncludes(moduleMirror)));
+              });
       superclass = element.getSuperclass();
     }
   }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
index fe22d2b11..ee6edd717 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Google, Inc.
+ * Copyright (C) 2014 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,38 +13,42 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal.codegen;
 
+import static com.google.common.collect.Sets.immutableEnumSet;
+import static dagger.internal.codegen.ContributionBinding.FactoryCreationStrategy.CLASS_CONSTRUCTOR;
+import static dagger.internal.codegen.ContributionBinding.FactoryCreationStrategy.DELEGATE;
+import static dagger.internal.codegen.ContributionBinding.FactoryCreationStrategy.SINGLETON_INSTANCE;
+import static dagger.internal.codegen.MapKeys.unwrapValue;
+import static dagger.internal.codegen.MoreAnnotationMirrors.unwrapOptionalEquivalence;
+import static javax.lang.model.element.Modifier.ABSTRACT;
+import static javax.lang.model.element.Modifier.STATIC;
+
 import com.google.auto.common.MoreTypes;
 import com.google.common.base.Equivalence;
 import com.google.common.base.Equivalence.Wrapper;
-import com.google.common.base.Function;
-import com.google.common.base.Optional;
-import com.google.common.base.Predicate;
-import com.google.common.base.Predicates;
+import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ImmutableSetMultimap;
 import com.google.common.collect.Multimaps;
-import com.google.common.collect.Sets;
 import com.google.common.util.concurrent.ListenableFuture;
+import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import dagger.Component;
 import dagger.MapKey;
 import dagger.Provides;
 import dagger.internal.codegen.ContributionType.HasContributionType;
 import dagger.producers.Produces;
-import dagger.producers.ProductionComponent;
+import java.util.Optional;
 import java.util.Set;
 import javax.inject.Inject;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.AnnotationValue;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeMirror;
 
-import static com.google.common.collect.Sets.immutableEnumSet;
-import static dagger.internal.codegen.ContributionBinding.Kind.IS_SYNTHETIC_KIND;
-import static dagger.internal.codegen.MapKeys.unwrapValue;
-import static dagger.internal.codegen.MoreAnnotationMirrors.unwrapOptionalEquivalence;
-import static javax.lang.model.element.Modifier.STATIC;
-
 /**
  * An abstract class for a value object representing the mechanism by which a {@link Key} can be
  * contributed to a dependency graph.
@@ -54,42 +58,9 @@
  */
 abstract class ContributionBinding extends Binding implements HasContributionType {
 
-  @Override
-  Set<DependencyRequest> implicitDependencies() {
-    // Optimization: If we don't need the memberInjectionRequest, don't create more objects.
-    if (!membersInjectionRequest().isPresent()) {
-      return dependencies();
-    } else {
-      // Optimization: Avoid creating an ImmutableSet+Builder just to union two things together.
-      return Sets.union(membersInjectionRequest().asSet(), dependencies());
-    }
-  }
-
   /** Returns the type that specifies this' nullability, absent if not nullable. */
   abstract Optional<DeclaredType> nullableType();
 
-  /**
-   * Returns whether this binding is synthetic, i.e., not explicitly tied to code, but generated
-   * implicitly by the framework.
-   */
-  boolean isSyntheticBinding() {
-    return IS_SYNTHETIC_KIND.apply(bindingKind());
-  }
-
-  /**
-   * A function that returns the kind of a binding.
-   */
-  static final Function<ContributionBinding, Kind> KIND =
-      new Function<ContributionBinding, Kind>() {
-        @Override
-        public Kind apply(ContributionBinding binding) {
-          return binding.bindingKind();
-        }
-      };
-
-  /** If this provision requires members injection, this will be the corresponding request. */
-  abstract Optional<DependencyRequest> membersInjectionRequest();
-
   abstract Optional<Equivalence.Wrapper<AnnotationMirror>> wrappedMapKey();
 
   final Optional<AnnotationMirror> mapKey() {
@@ -125,6 +96,25 @@ public Kind apply(ContributionBinding binding) {
      */
     SYNTHETIC_DELEGATE_BINDING,
 
+    /**
+     * A binding for a {@link dagger.releasablereferences.ReleasableReferenceManager} or {@link
+     * dagger.releasablereferences.TypedReleasableReferenceManager} object for a scope.
+     */
+    SYNTHETIC_RELEASABLE_REFERENCE_MANAGER,
+
+    /**
+     * A binding for a set of {@link dagger.releasablereferences.ReleasableReferenceManager} or
+     * {@link dagger.releasablereferences.TypedReleasableReferenceManager} objects.
+     */
+    SYNTHETIC_RELEASABLE_REFERENCE_MANAGERS,
+
+    /**
+     * A synthetic binding for {@code Optional} of a type or a {@link javax.inject.Provider}, {@link
+     * dagger.Lazy}, or {@code Provider} of {@code Lazy} of a type. Generated by a {@link
+     * dagger.BindsOptionalOf} declaration.
+     */
+    SYNTHETIC_OPTIONAL_BINDING,
+
     // Provision kinds
 
     /** An {@link Inject}-annotated constructor. */
@@ -144,53 +134,36 @@ public Kind apply(ContributionBinding binding) {
      */
     SUBCOMPONENT_BUILDER,
 
-    // Production kinds
+    /** A builder binding method. */
+    BUILDER_BINDING,
 
-    /** A {@link Produces}-annotated method that doesn't return a {@link ListenableFuture}. */
-    IMMEDIATE,
+    // Production kinds
 
-    /** A {@link Produces}-annotated method that returns a {@link ListenableFuture}. */
-    FUTURE_PRODUCTION,
+    /** A {@link Produces}-annotated method. */
+    PRODUCTION,
 
     /**
-     * A production method on a production component's
-     * {@linkplain ProductionComponent#dependencies() dependency} that returns a
+     * A production method on a production component's {@linkplain
+     * dagger.producers.ProductionComponent#dependencies()} dependency} that returns a
      * {@link ListenableFuture}. Methods on production component dependencies that don't return a
      * {@link ListenableFuture} are considered {@linkplain #PROVISION provision bindings}.
      */
     COMPONENT_PRODUCTION,
     ;
 
-    /**
-     * A predicate that tests whether a kind is for synthetic bindings.
-     */
-    static final Predicate<Kind> IS_SYNTHETIC_KIND =
-        Predicates.in(
-            immutableEnumSet(
-                SYNTHETIC_MAP,
-                SYNTHETIC_MULTIBOUND_SET,
-                SYNTHETIC_MULTIBOUND_MAP,
-                SYNTHETIC_DELEGATE_BINDING));
-
-    /**
-     * A predicate that tests whether a kind is for synthetic multibindings.
-     */
-    static final Predicate<Kind> IS_SYNTHETIC_MULTIBINDING_KIND =
-        Predicates.in(immutableEnumSet(SYNTHETIC_MULTIBOUND_SET, SYNTHETIC_MULTIBOUND_MAP));
+    static final ImmutableSet<Kind> SYNTHETIC_MULTIBOUND_KINDS =
+        immutableEnumSet(SYNTHETIC_MULTIBOUND_SET, SYNTHETIC_MULTIBOUND_MAP);
 
     /**
-     * {@link #SYNTHETIC_MULTIBOUND_SET} or {@link #SYNTHETIC_MULTIBOUND_MAP}, depending on the
-     * request's key.
+     * {@link #SYNTHETIC_MULTIBOUND_SET} or {@link #SYNTHETIC_MULTIBOUND_MAP}, depending on the key.
      */
-    static Kind forMultibindingRequest(DependencyRequest request) {
-      Key key = request.key();
+    static Kind forMultibindingKey(Key key) {
       if (SetType.isSet(key)) {
         return SYNTHETIC_MULTIBOUND_SET;
       } else if (MapType.isMap(key)) {
         return SYNTHETIC_MULTIBOUND_MAP;
       } else {
-        throw new IllegalArgumentException(
-            String.format("request is not for a set or map: %s", request));
+        throw new IllegalArgumentException(String.format("key is not for a set or map: %s", key));
       }
     }
   }
@@ -200,12 +173,24 @@ static Kind forMultibindingRequest(DependencyRequest request) {
    */
   protected abstract Kind bindingKind();
 
+  /**
+   * {@code true} if {@link #contributingModule()} is present and this is a nonabstract instance
+   * method.
+   */
+  boolean requiresModuleInstance() {
+    if (!bindingElement().isPresent() || !contributingModule().isPresent()) {
+      return false;
+    }
+    Set<Modifier> modifiers = bindingElement().get().getModifiers();
+    return !modifiers.contains(ABSTRACT) && !modifiers.contains(STATIC);
+  }
+
   /**
    * The strategy for getting an instance of a factory for a {@link ContributionBinding}.
    */
   enum FactoryCreationStrategy {
-    /** The factory class is an enum with one value named {@code INSTANCE}. */
-    ENUM_INSTANCE,
+    /** The factory class is a single instance. */
+    SINGLETON_INSTANCE,
     /** The factory must be created by calling the constructor. */
     CLASS_CONSTRUCTOR,
     /** The factory is simply delegated to another. */
@@ -213,26 +198,29 @@ static Kind forMultibindingRequest(DependencyRequest request) {
   }
 
   /**
-   * Returns {@link FactoryCreationStrategy#ENUM_INSTANCE} if the binding has no dependencies and
-   * is a static provision binding or an {@link Inject @Inject} constructor binding. Otherwise
-   * returns {@link FactoryCreationStrategy#CLASS_CONSTRUCTOR}.
+   * Returns the {@link FactoryCreationStrategy} appropriate for a binding.
+   *
+   * <p>Delegate bindings use the {@link FactoryCreationStrategy#DELEGATE} strategy.
+   *
+   * <p>Bindings without dependencies that don't require a module instance use the {@link
+   * FactoryCreationStrategy#SINGLETON_INSTANCE} strategy.
+   *
+   * <p>All other bindings use the {@link FactoryCreationStrategy#CLASS_CONSTRUCTOR} strategy.
    */
   FactoryCreationStrategy factoryCreationStrategy() {
     switch (bindingKind()) {
       case SYNTHETIC_DELEGATE_BINDING:
-        return FactoryCreationStrategy.DELEGATE;
+        return DELEGATE;
       case PROVISION:
-        return implicitDependencies().isEmpty() && bindingElement().getModifiers().contains(STATIC)
-            ? FactoryCreationStrategy.ENUM_INSTANCE
-            : FactoryCreationStrategy.CLASS_CONSTRUCTOR;
+        return dependencies().isEmpty() && !requiresModuleInstance()
+            ? SINGLETON_INSTANCE
+            : CLASS_CONSTRUCTOR;
       case INJECTION:
       case SYNTHETIC_MULTIBOUND_SET:
       case SYNTHETIC_MULTIBOUND_MAP:
-        return implicitDependencies().isEmpty()
-            ? FactoryCreationStrategy.ENUM_INSTANCE
-            : FactoryCreationStrategy.CLASS_CONSTRUCTOR;
+        return dependencies().isEmpty() ? SINGLETON_INSTANCE : CLASS_CONSTRUCTOR;
       default:
-        return FactoryCreationStrategy.CLASS_CONSTRUCTOR;
+        return CLASS_CONSTRUCTOR;
     }
   }
 
@@ -241,10 +229,10 @@ FactoryCreationStrategy factoryCreationStrategy() {
    * for this binding. Uses the binding's key, V in the came of {@code Map<K, FrameworkClass<V>>>},
    * and E {@code Set<E>} for {@link dagger.multibindings.IntoSet @IntoSet} methods.
    */
-  final TypeMirror factoryType() {
+  final TypeMirror contributedType() {
     switch (contributionType()) {
       case MAP:
-        return MapType.from(key()).unwrappedValueType(frameworkClass());
+        return MapType.from(key()).unwrappedValueType(bindingType().frameworkClass());
       case SET:
         return SetType.from(key()).elementType();
       case SET_VALUES:
@@ -265,13 +253,9 @@ final TypeMirror factoryType() {
     return ImmutableSetMultimap.copyOf(
         Multimaps.index(
             mapBindings,
-            new Function<ContributionBinding, Object>() {
-              @Override
-              public Object apply(ContributionBinding mapBinding) {
-                AnnotationMirror mapKey = mapBinding.mapKey().get();
-                Optional<? extends AnnotationValue> unwrappedValue = unwrapValue(mapKey);
-                return unwrappedValue.isPresent() ? unwrappedValue.get().getValue() : mapKey;
-              }
+            mapBinding -> {
+              AnnotationMirror mapKey = mapBinding.mapKey().get();
+              return unwrapValue(mapKey).map(AnnotationValue::getValue).orElse(mapKey);
             }));
   }
 
@@ -283,12 +267,32 @@ public Object apply(ContributionBinding mapBinding) {
     return ImmutableSetMultimap.copyOf(
         Multimaps.index(
             mapBindings,
-            new Function<ContributionBinding, Equivalence.Wrapper<DeclaredType>>() {
-              @Override
-              public Equivalence.Wrapper<DeclaredType> apply(ContributionBinding mapBinding) {
-                return MoreTypes.equivalence()
-                    .wrap(mapBinding.mapKey().get().getAnnotationType());
-              }
-            }));
+            mapBinding ->
+                MoreTypes.equivalence().wrap(mapBinding.mapKey().get().getAnnotationType())));
+  }
+
+  /**
+   * Base builder for {@link com.google.auto.value.AutoValue @AutoValue} subclasses of
+   * {@link ContributionBinding}.
+   */
+  @CanIgnoreReturnValue
+  abstract static class Builder<B extends Builder<B>> {
+    abstract B contributionType(ContributionType contributionType);
+
+    abstract B bindingElement(Element bindingElement);
+
+    abstract B contributingModule(TypeElement contributingModule);
+
+    abstract B key(Key key);
+
+    abstract B explicitDependencies(Iterable<DependencyRequest> dependencies);
+
+    abstract B explicitDependencies(DependencyRequest... dependencies);
+
+    abstract B nullableType(Optional<DeclaredType> nullableType);
+
+    abstract B wrappedMapKey(Optional<Equivalence.Wrapper<AnnotationMirror>> wrappedMapKey);
+
+    abstract B bindingKind(ContributionBinding.Kind kind);
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ContributionType.java b/compiler/src/main/java/dagger/internal/codegen/ContributionType.java
index 98c363560..e3f8e37a3 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ContributionType.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ContributionType.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,23 +13,18 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal.codegen;
 
-import com.google.common.base.Function;
-import com.google.common.collect.ImmutableListMultimap;
-import com.google.common.collect.Multimaps;
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
+
 import dagger.Provides;
 import dagger.multibindings.ElementsIntoSet;
 import dagger.multibindings.IntoMap;
 import dagger.multibindings.IntoSet;
-import dagger.producers.Produces;
 import javax.lang.model.element.ExecutableElement;
 
-import static com.google.auto.common.MoreElements.isAnnotationPresent;
-
-/**
- * Whether a binding or declaration is for a unique contribution or a map or set multibinding.
- */
+/** Whether a binding or declaration is for a unique contribution or a map or set multibinding. */
 enum ContributionType {
   /** Represents map bindings. */
   MAP,
@@ -41,56 +36,21 @@
   UNIQUE,
   ;
 
-  /**
-   * An object that is associated with a {@link ContributionType}.
-   */
+  /** An object that is associated with a {@link ContributionType}. */
   interface HasContributionType {
 
     /** The contribution type of this object. */
     ContributionType contributionType();
   }
 
-  /**
-   * {@code true} if this is for a multibinding.
-   */
+  /** {@code true} if this is for a multibinding. */
   boolean isMultibinding() {
     return !this.equals(UNIQUE);
   }
 
-  /** The contribution type for a given provision type. */
-  private static ContributionType forProvisionType(Provides.Type provisionType) {
-    switch (provisionType) {
-      case SET:
-        return SET;
-      case SET_VALUES:
-        return SET_VALUES;
-      case MAP:
-        return MAP;
-      case UNIQUE:
-        return UNIQUE;
-      default:
-        throw new AssertionError("Unknown provision type: " + provisionType);
-    }
-  }
-
-  private static ContributionType forProductionType(Produces.Type productionType) {
-    switch (productionType) {
-      case SET:
-        return SET;
-      case SET_VALUES:
-        return SET_VALUES;
-      case MAP:
-        return MAP;
-      case UNIQUE:
-        return UNIQUE;
-      default:
-        throw new AssertionError("Unknown production type: " + productionType);
-    }
-  }
-
   /**
    * The contribution type from a binding method annotations. Presumes a well-formed binding method
-   * (only one of @IntoSet, @IntoMap, @ElementsIntoSet, @Provides.type or @Produces.type. {@link
+   * (at most one of @IntoSet, @IntoMap, @ElementsIntoSet and @Provides.type). {@link
    * ProvidesMethodValidator} and {@link ProducesMethodValidator} validate correctness on their own.
    */
   static ContributionType fromBindingMethod(ExecutableElement method) {
@@ -101,27 +61,6 @@ static ContributionType fromBindingMethod(ExecutableElement method) {
     } else if (isAnnotationPresent(method, ElementsIntoSet.class)) {
       return ContributionType.SET_VALUES;
     }
-
-    if (isAnnotationPresent(method, Provides.class)) {
-      return forProvisionType(method.getAnnotation(Provides.class).type());
-    } else if (isAnnotationPresent(method, Produces.class)) {
-      return forProductionType(method.getAnnotation(Produces.class).type());
-    } else {
-      return ContributionType.UNIQUE;
-    }
-  }
-
-  /** Indexes objects by their contribution type. */
-  static <T extends HasContributionType>
-      ImmutableListMultimap<ContributionType, T> indexByContributionType(
-          Iterable<T> haveContributionTypes) {
-    return Multimaps.index(
-        haveContributionTypes,
-        new Function<HasContributionType, ContributionType>() {
-          @Override
-          public ContributionType apply(HasContributionType hasContributionType) {
-            return hasContributionType.contributionType();
-          }
-        });
+    return ContributionType.UNIQUE;
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/DaggerElements.java b/compiler/src/main/java/dagger/internal/codegen/DaggerElements.java
new file mode 100644
index 000000000..8c8e0952f
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/DaggerElements.java
@@ -0,0 +1,172 @@
+/*
+ * Copyright (C) 2013 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.auto.common.MoreElements.getLocalAndInheritedMethods;
+import static com.google.auto.common.MoreElements.hasModifiers;
+import static com.google.common.collect.Lists.asList;
+import static dagger.internal.codegen.Util.toImmutableSet;
+import static java.util.stream.Collectors.toSet;
+import static javax.lang.model.element.Modifier.ABSTRACT;
+
+import com.google.auto.common.MoreElements;
+import com.google.auto.common.MoreTypes;
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableSet;
+import java.lang.annotation.Annotation;
+import java.util.Collection;
+import java.util.Optional;
+import java.util.Set;
+import java.util.function.Predicate;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ElementVisitor;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.SimpleElementVisitor6;
+import javax.lang.model.util.Types;
+
+/**
+ * Utilities for working with {@link Element} objects. Each is a candidate to move to {@link
+ * MoreElements}.
+ */
+final class DaggerElements {
+
+  static ImmutableSet<ExecutableElement> getUnimplementedMethods(
+      TypeElement type, Types types, Elements elements) {
+    return FluentIterable.from(getLocalAndInheritedMethods(type, types, elements))
+        .filter(hasModifiers(ABSTRACT))
+        .toSet();
+  }
+
+  /**
+   * A visitor that returns the input or the closest enclosing element that is a
+   * {@link TypeElement}.
+   */
+  static final ElementVisitor<TypeElement, Void> ENCLOSING_TYPE_ELEMENT =
+      new SimpleElementVisitor6<TypeElement, Void>() {
+        @Override
+        protected TypeElement defaultAction(Element e, Void p) {
+          return visit(e.getEnclosingElement());
+        }
+  
+        @Override
+        public TypeElement visitType(TypeElement e, Void p) {
+          return e;
+        }
+      };
+      
+  /**
+   * Returns {@code true} iff the given element has an {@link AnnotationMirror} whose
+   * {@linkplain AnnotationMirror#getAnnotationType() annotation type} has the same canonical name
+   * as any of that of {@code annotationClasses}.
+   */
+  static boolean isAnyAnnotationPresent(
+      Element element, Iterable<? extends Class<? extends Annotation>> annotationClasses) {
+    for (Class<? extends Annotation> annotation : annotationClasses) {
+      if (MoreElements.isAnnotationPresent(element, annotation)) {
+        return true;
+      }
+    }
+    return false;
+  }
+
+  @SafeVarargs
+  static boolean isAnyAnnotationPresent(
+      Element element,
+      Class<? extends Annotation> first,
+      Class<? extends Annotation>... otherAnnotations) {
+    return isAnyAnnotationPresent(element, asList(first, otherAnnotations));
+  }
+
+  /**
+   * Returns {@code true} iff the given element has an {@link AnnotationMirror} whose {@linkplain
+   * AnnotationMirror#getAnnotationType() annotation type} is equivalent to {@code annotationType}.
+   */
+  static boolean isAnnotationPresent(Element element, TypeMirror annotationType) {
+    return element
+        .getAnnotationMirrors()
+        .stream()
+        .map(AnnotationMirror::getAnnotationType)
+        .anyMatch(candidate -> MoreTypes.equivalence().equivalent(candidate, annotationType));
+  }
+
+  /**
+   * Returns the annotation present on {@code element} whose type is {@code first} or within {@code
+   * rest}, checking each annotation type in order.
+   */
+  @SafeVarargs
+  static Optional<AnnotationMirror> getAnyAnnotation(
+      Element element, Class<? extends Annotation> first, Class<? extends Annotation>... rest) {
+    return getAnyAnnotation(element, asList(first, rest));
+  }
+
+  /**
+   * Returns the annotation present on {@code element} whose type is in {@code annotations},
+   * checking each annotation type in order.
+   */
+  static Optional<AnnotationMirror> getAnyAnnotation(
+      Element element, Collection<? extends Class<? extends Annotation>> annotations) {
+    return element
+        .getAnnotationMirrors()
+        .stream()
+        .filter(hasAnnotationTypeIn(annotations))
+        .map((AnnotationMirror a) -> a) // Avoid returning Optional<? extends AnnotationMirror>.
+        .findFirst();
+  }
+
+  /** Returns the annotations present on {@code element} of all types. */
+  @SafeVarargs
+  static ImmutableSet<AnnotationMirror> getAllAnnotations(
+      Element element, Class<? extends Annotation> first, Class<? extends Annotation>... rest) {
+    return element
+        .getAnnotationMirrors()
+        .stream()
+        .filter(hasAnnotationTypeIn(asList(first, rest)))
+        .collect(toImmutableSet());
+  }
+
+  /**
+   * Returns an {@link AnnotationMirror} for the annotation of type {@code annotationClass} on
+   * {@code element}, or {@link Optional#empty()} if no such annotation exists. This method is a
+   * safer alternative to calling {@link Element#getAnnotation} as it avoids any interaction with
+   * annotation proxies.
+   */
+  static Optional<AnnotationMirror> getAnnotationMirror(
+      Element element, Class<? extends Annotation> annotationClass) {
+    return Optional.ofNullable(MoreElements.getAnnotationMirror(element, annotationClass).orNull());
+  }
+
+  private static Predicate<AnnotationMirror> hasAnnotationTypeIn(
+      Collection<? extends Class<? extends Annotation>> annotations) {
+    Set<String> annotationClassNames =
+        annotations.stream().map(Class::getCanonicalName).collect(toSet());
+    return annotation ->
+        annotationClassNames.contains(
+            MoreTypes.asTypeElement(annotation.getAnnotationType()).getQualifiedName().toString());
+  }
+
+  static ImmutableSet<String> suppressedWarnings(Element element) {
+    SuppressWarnings suppressedWarnings = element.getAnnotation(SuppressWarnings.class);
+    if (suppressedWarnings == null) {
+      return ImmutableSet.of();
+    }
+    return ImmutableSet.copyOf(suppressedWarnings.value());
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/DaggerTypes.java b/compiler/src/main/java/dagger/internal/codegen/DaggerTypes.java
new file mode 100644
index 000000000..b000e1353
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/DaggerTypes.java
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import com.google.auto.common.MoreTypes;
+import java.util.Optional;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
+
+/**
+ * Utilities for working with {@link TypeMirror} objects. Each is a candidate to move to {@link
+ * MoreTypes}.
+ */
+final class DaggerTypes {
+  /**
+   * Returns the non-{@link Object} superclass of the type with the proper type parameters. An empty
+   * {@link Optional} is returned if there is no non-{@link Object} superclass.
+   */
+  static Optional<DeclaredType> nonObjectSuperclass(
+      Types types, Elements elements, DeclaredType type) {
+    return Optional.ofNullable(MoreTypes.nonObjectSuperclass(types, elements, type).orNull());
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/DelegateDeclaration.java b/compiler/src/main/java/dagger/internal/codegen/DelegateDeclaration.java
index e2bf84705..c2d3e8d9f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DelegateDeclaration.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DelegateDeclaration.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 Google, Inc.
+ * Copyright (C) 2016 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,31 +13,35 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal.codegen;
 
+import static com.google.common.base.Preconditions.checkArgument;
+import static dagger.internal.codegen.MapKeys.getMapKey;
+import static dagger.internal.codegen.MoreAnnotationMirrors.wrapOptionalInEquivalence;
+
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Equivalence;
-import com.google.common.base.Optional;
 import com.google.common.collect.Iterables;
 import dagger.Binds;
 import dagger.internal.codegen.ContributionType.HasContributionType;
+import java.util.Optional;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.ExecutableType;
 import javax.lang.model.util.Types;
 
-import static com.google.common.base.Preconditions.checkArgument;
-import static dagger.internal.codegen.MapKeys.getMapKey;
-import static dagger.internal.codegen.MoreAnnotationMirrors.wrapOptionalInEquivalence;
-
 /**
  * The declaration for a delegate binding established by a {@link Binds} method.
  */
 @AutoValue
 abstract class DelegateDeclaration extends BindingDeclaration implements HasContributionType {
+  @Override
+  abstract Optional<ExecutableElement> bindingElement();
+
   abstract DependencyRequest delegateRequest();
 
   abstract Optional<Equivalence.Wrapper<AnnotationMirror>> wrappedMapKey();
@@ -55,20 +59,20 @@
     }
 
     DelegateDeclaration create(
-        ExecutableElement bindsMethod, TypeElement contributingElement) {
+        ExecutableElement bindsMethod, TypeElement contributingModule) {
       checkArgument(MoreElements.isAnnotationPresent(bindsMethod, Binds.class));
       ExecutableType resolvedMethod =
           MoreTypes.asExecutable(
-              types.asMemberOf(MoreTypes.asDeclared(contributingElement.asType()), bindsMethod));
+              types.asMemberOf(MoreTypes.asDeclared(contributingModule.asType()), bindsMethod));
       DependencyRequest delegateRequest =
           dependencyRequestFactory.forRequiredResolvedVariable(
               Iterables.getOnlyElement(bindsMethod.getParameters()),
               Iterables.getOnlyElement(resolvedMethod.getParameterTypes()));
       return new AutoValue_DelegateDeclaration(
           ContributionType.fromBindingMethod(bindsMethod),
-          keyFactory.forBindsMethod(bindsMethod, resolvedMethod),
-          bindsMethod,
-          Optional.of(contributingElement),
+          keyFactory.forBindsMethod(bindsMethod, contributingModule),
+          Optional.of(contributingModule),
+          Optional.of(bindsMethod),
           delegateRequest,
           wrapOptionalInEquivalence(getMapKey(bindsMethod)));
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
index 84434fcdd..fb0420218 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Google, Inc.
+ * Copyright (C) 2014 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,48 +13,52 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal.codegen;
 
+import static com.google.auto.common.MoreTypes.asDeclared;
+import static com.google.auto.common.MoreTypes.isType;
+import static com.google.auto.common.MoreTypes.isTypeOf;
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.base.Preconditions.checkState;
+import static com.google.common.collect.Iterables.getOnlyElement;
+import static dagger.internal.codegen.ConfigurationAnnotations.getNullableType;
+import static dagger.internal.codegen.Optionals.firstPresent;
+import static dagger.internal.codegen.TypeNames.lazyOf;
+import static dagger.internal.codegen.TypeNames.listenableFutureOf;
+import static dagger.internal.codegen.TypeNames.producedOf;
+import static dagger.internal.codegen.TypeNames.producerOf;
+import static dagger.internal.codegen.TypeNames.providerOf;
+
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
-import com.google.common.base.Function;
-import com.google.common.base.Optional;
-import com.google.common.base.Predicate;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
 import com.google.common.util.concurrent.ListenableFuture;
+import com.google.errorprone.annotations.CanIgnoreReturnValue;
+import com.squareup.javapoet.TypeName;
 import dagger.Lazy;
 import dagger.MembersInjector;
 import dagger.Provides;
-import dagger.internal.codegen.DependencyRequest.Factory.KindAndType;
 import dagger.producers.Produced;
 import dagger.producers.Producer;
-import dagger.producers.internal.AbstractProducer;
 import java.util.List;
+import java.util.Optional;
+import javax.annotation.CheckReturnValue;
 import javax.inject.Inject;
 import javax.inject.Provider;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.ErrorType;
 import javax.lang.model.type.ExecutableType;
 import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
-import javax.lang.model.util.Elements;
 import javax.lang.model.util.SimpleTypeVisitor7;
 
-import static com.google.auto.common.MoreTypes.asDeclared;
-import static com.google.auto.common.MoreTypes.isType;
-import static com.google.auto.common.MoreTypes.isTypeOf;
-import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
-import static com.google.common.base.Preconditions.checkState;
-import static com.google.common.collect.Iterables.getOnlyElement;
-import static javax.lang.model.util.ElementFilter.constructorsIn;
-
 /**
  * Represents a request for a key at an injection point. Parameters to {@link Inject} constructors
  * or {@link Provides} methods are examples of key requests.
@@ -65,12 +69,6 @@
 // TODO(gak): Set bindings and the permutations thereof need to be addressed
 @AutoValue
 abstract class DependencyRequest {
-  static final Function<DependencyRequest, BindingKey> BINDING_KEY_FUNCTION =
-      new Function<DependencyRequest, BindingKey>() {
-        @Override public BindingKey apply(DependencyRequest request) {
-          return request.bindingKey();
-        }
-      };
 
   enum Kind {
     /** A default request for an instance.  E.g.: {@code Blah} */
@@ -108,24 +106,56 @@
     }
 
     Kind() {
-      this.frameworkClass = Optional.absent();
+      this.frameworkClass = Optional.empty();
     }
-    
+
     /**
      * If {@code type}'s raw type is {@link #frameworkClass}, returns a {@link KindAndType} with
      * this kind that represents the dependency request.
      */
     Optional<KindAndType> from(TypeMirror type) {
-      return frameworkClass.isPresent() && isType(type) && isTypeOf(frameworkClass.get(), type)
-          ? Optional.of(this.ofType(getOnlyElement(asDeclared(type).getTypeArguments())))
-          : Optional.<KindAndType>absent();
+      if (frameworkClass.isPresent() && isType(type) && isTypeOf(frameworkClass.get(), type)) {
+        List<? extends TypeMirror> typeArguments = asDeclared(type).getTypeArguments();
+        if (typeArguments.isEmpty()) {
+          return Optional.empty();
+        }
+        return Optional.of(this.ofType(getOnlyElement(typeArguments)));
+      }
+      return Optional.empty();
     }
 
-    /**
-     * Returns a {@link KindAndType} with this kind and {@code type} type.
-     */
+    /** Returns a {@link KindAndType} with this kind and {@code type} type. */
     KindAndType ofType(TypeMirror type) {
-      return new AutoValue_DependencyRequest_Factory_KindAndType(this, type);
+      return new AutoValue_DependencyRequest_KindAndType(this, type);
+    }
+
+    /** Returns the type of a request of this kind for a key with a given type. */
+    TypeName typeName(TypeName keyType) {
+      switch (this) {
+        case INSTANCE:
+          return keyType;
+
+        case PROVIDER:
+          return providerOf(keyType);
+
+        case LAZY:
+          return lazyOf(keyType);
+
+        case PROVIDER_OF_LAZY:
+          return providerOf(lazyOf(keyType));
+
+        case PRODUCER:
+          return producerOf(keyType);
+
+        case PRODUCED:
+          return producedOf(keyType);
+
+        case FUTURE:
+          return listenableFutureOf(keyType);
+
+        default:
+          throw new AssertionError(this);
+      }
     }
   }
 
@@ -141,36 +171,111 @@ BindingKey bindingKey() {
       case PRODUCER:
       case PRODUCED:
       case FUTURE:
-        return BindingKey.create(BindingKey.Kind.CONTRIBUTION, key());
+        return BindingKey.contribution(key());
       case MEMBERS_INJECTOR:
-        return BindingKey.create(BindingKey.Kind.MEMBERS_INJECTION, key());
+        return BindingKey.membersInjection(key());
       default:
-        throw new AssertionError();
+        throw new AssertionError(this);
     }
   }
 
-  abstract Element requestElement();
+  /** The element that declares this dependency request. Absent for synthetic requests. */
+  abstract Optional<Element> requestElement();
 
   /** Returns true if this request allows null objects. */
   abstract boolean isNullable();
 
   /**
-   * An optional name for this request when it's referred to in generated code. If absent, it will
+   * An optional name for this request when it's referred to in generated code. If empty, it will
    * use a name derived from {@link #requestElement}.
    */
   abstract Optional<String> overriddenVariableName();
-  
-  /** {@code true} if this is a synthetic request, which should not appear in dependency traces. */
-  abstract boolean isSynthetic();
-
-  /** A predicate that passes for synthetic requests. */
-  static final Predicate<DependencyRequest> IS_SYNTHETIC =
-      new Predicate<DependencyRequest>() {
-        @Override
-        public boolean apply(DependencyRequest request) {
-          return request.isSynthetic();
+
+  private static DependencyRequest.Builder builder() {
+    return new AutoValue_DependencyRequest.Builder().isNullable(false);
+  }
+
+  /**
+   * Extracts the dependency request type and kind from the type of a dependency request element.
+   * For example, if a user requests {@code Provider<Foo>}, this will return ({@link Kind#PROVIDER},
+   * {@code Foo}).
+   *
+   * @throws TypeNotPresentException if {@code type}'s kind is {@link TypeKind#ERROR}, which may
+   *     mean that the type will be generated in a later round of processing
+   */
+  static KindAndType extractKindAndType(TypeMirror type) {
+    return type.accept(
+        new SimpleTypeVisitor7<KindAndType, Void>() {
+          @Override
+          public KindAndType visitError(ErrorType errorType, Void p) {
+            throw new TypeNotPresentException(errorType.toString(), null);
+          }
+
+          @Override
+          public KindAndType visitExecutable(ExecutableType executableType, Void p) {
+            return executableType.getReturnType().accept(this, null);
+          }
+
+          @Override
+          public KindAndType visitDeclared(DeclaredType declaredType, Void p) {
+            return KindAndType.from(declaredType).orElse(defaultAction(declaredType, p));
+          }
+
+          @Override
+          protected KindAndType defaultAction(TypeMirror otherType, Void p) {
+            return Kind.INSTANCE.ofType(otherType);
+          }
+        },
+        null);
+  }
+
+  @AutoValue
+  abstract static class KindAndType {
+    abstract Kind kind();
+
+    abstract TypeMirror type();
+
+    static Optional<KindAndType> from(TypeMirror type) {
+      for (Kind kind : Kind.values()) {
+        Optional<KindAndType> kindAndType = kind.from(type);
+        if (kindAndType.isPresent()) {
+          return firstPresent(kindAndType.get().maybeProviderOfLazy(), kindAndType);
+        }
+      }
+      return Optional.empty();
+    }
+
+    /**
+     * If {@code kindAndType} represents a {@link Kind#PROVIDER} of a {@code Lazy<T>} for some type
+     * {@code T}, then this method returns ({@link Kind#PROVIDER_OF_LAZY}, {@code T}).
+     */
+    private Optional<KindAndType> maybeProviderOfLazy() {
+      if (kind().equals(Kind.PROVIDER)) {
+        Optional<KindAndType> providedKindAndType = from(type());
+        if (providedKindAndType.isPresent() && providedKindAndType.get().kind().equals(Kind.LAZY)) {
+          return Optional.of(Kind.PROVIDER_OF_LAZY.ofType(providedKindAndType.get().type()));
         }
-      };
+      }
+      return Optional.empty();
+    }
+  }
+
+  @CanIgnoreReturnValue
+  @AutoValue.Builder
+  abstract static class Builder {
+    abstract Builder kind(Kind kind);
+
+    abstract Builder key(Key key);
+
+    abstract Builder requestElement(Element element);
+
+    abstract Builder isNullable(boolean isNullable);
+
+    abstract Builder overriddenVariableName(Optional<String> overriddenVariableName);
+
+    @CheckReturnValue
+    abstract DependencyRequest build();
+  }
 
   /**
    * Factory for {@link DependencyRequest}s.
@@ -179,11 +284,9 @@ public boolean apply(DependencyRequest request) {
    * which may mean that the type will be generated in a later round of processing.
    */
   static final class Factory {
-    private final Elements elements;
     private final Key.Factory keyFactory;
 
-    Factory(Elements elements, Key.Factory keyFactory) {
-      this.elements = elements;
+    Factory(Key.Factory keyFactory) {
       this.keyFactory = keyFactory;
     }
 
@@ -198,42 +301,43 @@ public boolean apply(DependencyRequest request) {
     }
 
     /**
-     * Creates a implicit {@link DependencyRequest} for {@code mapOfFactoryKey}, which will be used
-     * to satisfy the {@code mapOfValueRequest}.
-     * 
-     * @param mapOfValueRequest a request for {@code Map<K, V>}
+     * Creates a implicit {@link DependencyRequest} for a {@link Provider} of {@code
+     * mapOfFactoryKey}.
+     *
      * @param mapOfFactoryKey a key equivalent to {@code mapOfValueRequest}'s key, whose type is
      *     {@code Map<K, Provider<V>>} or {@code Map<K, Producer<V>>}
      */
-    DependencyRequest forImplicitMapBinding(
-        DependencyRequest mapOfValueRequest, Key mapOfFactoryKey) {
-      checkNotNull(mapOfValueRequest);
-      return new AutoValue_DependencyRequest(
-          Kind.PROVIDER,
-          mapOfFactoryKey,
-          mapOfValueRequest.requestElement(),
-          false /* doesn't allow null */,
-          Optional.<String>absent(),
-          true /* synthetic */);
+    DependencyRequest providerForImplicitMapBinding(Key mapOfFactoryKey) {
+      return DependencyRequest.builder()
+          .kind(Kind.PROVIDER)
+          .key(mapOfFactoryKey)
+          .build();
     }
 
     /**
-     * Creates a dependency request, with the same element as {@code request}, for one individual
-     * {@code multibindingContribution}.
+     * Creates a implicit {@link DependencyRequest} for a {@link Producer} of {@code
+     * mapOfFactoryKey}.
+     *
+     * @param mapOfFactoryKey a key equivalent to {@code mapOfValueRequest}'s key, whose type is
+     *     {@code Map<K, Provider<V>>} or {@code Map<K, Producer<V>>}
+     */
+    DependencyRequest producerForImplicitMapBinding(Key mapOfFactoryKey) {
+      return DependencyRequest.builder().kind(Kind.PRODUCER).key(mapOfFactoryKey).build();
+    }
+
+    /**
+     * Creates a synthetic dependency request for one individual {@code multibindingContribution}.
      */
-    DependencyRequest forMultibindingContribution(
-        DependencyRequest request, ContributionBinding multibindingContribution) {
+    private DependencyRequest forMultibindingContribution(
+        ContributionBinding multibindingContribution) {
       checkArgument(
-          multibindingContribution.key().bindingMethodIdentifier().isPresent(),
-          "multibindingContribution's key must have a binding method identifier: %s",
+          multibindingContribution.key().multibindingContributionIdentifier().isPresent(),
+          "multibindingContribution's key must have a multibinding contribution identifier: %s",
           multibindingContribution);
-      return new AutoValue_DependencyRequest(
-          multibindingContributionRequestKind(multibindingContribution),
-          multibindingContribution.key(),
-          request.requestElement(),
-          false /* doesn't allow null */,
-          Optional.<String>absent(),
-          true /* synthetic */);
+      return DependencyRequest.builder()
+          .kind(multibindingContributionRequestKind(multibindingContribution))
+          .key(multibindingContribution.key())
+          .build();
     }
 
     private Kind multibindingContributionRequestKind(ContributionBinding multibindingContribution) {
@@ -254,20 +358,20 @@ private Kind multibindingContributionRequestKind(ContributionBinding multibindin
     }
 
     /**
-     * Creates dependency requests, with the same element as {@code request}, for each individual
-     * multibinding contribution in {@code multibindingContributions}.
+     * Creates synthetic dependency requests for each individual multibinding contribution in {@code
+     * multibindingContributions}.
      */
     ImmutableSet<DependencyRequest> forMultibindingContributions(
-        DependencyRequest request, Iterable<ContributionBinding> multibindingContributions) {
+        Iterable<ContributionBinding> multibindingContributions) {
       ImmutableSet.Builder<DependencyRequest> requests = ImmutableSet.builder();
       for (ContributionBinding multibindingContribution : multibindingContributions) {
-        requests.add(forMultibindingContribution(request, multibindingContribution));
+        requests.add(forMultibindingContribution(multibindingContribution));
       }
       return requests.build();
     }
 
     DependencyRequest forRequiredVariable(VariableElement variableElement) {
-      return forRequiredVariable(variableElement, Optional.<String>absent());
+      return forRequiredVariable(variableElement, Optional.empty());
     }
 
     DependencyRequest forRequiredVariable(VariableElement variableElement, Optional<String> name) {
@@ -282,8 +386,7 @@ DependencyRequest forRequiredResolvedVariable(
       checkNotNull(variableElement);
       checkNotNull(resolvedType);
       Optional<AnnotationMirror> qualifier = InjectionAnnotations.getQualifier(variableElement);
-      return newDependencyRequest(
-          variableElement, resolvedType, qualifier, Optional.<String>absent());
+      return newDependencyRequest(variableElement, resolvedType, qualifier, Optional.empty());
     }
 
     DependencyRequest forComponentProvisionMethod(ExecutableElement provisionMethod,
@@ -296,10 +399,7 @@ DependencyRequest forComponentProvisionMethod(ExecutableElement provisionMethod,
           provisionMethod);
       Optional<AnnotationMirror> qualifier = InjectionAnnotations.getQualifier(provisionMethod);
       return newDependencyRequest(
-          provisionMethod,
-          provisionMethodType.getReturnType(),
-          qualifier,
-          Optional.<String>absent());
+          provisionMethod, provisionMethodType.getReturnType(), qualifier, Optional.empty());
     }
 
     DependencyRequest forComponentProductionMethod(ExecutableElement productionMethod,
@@ -313,16 +413,14 @@ DependencyRequest forComponentProductionMethod(ExecutableElement productionMetho
       // Only a component production method can be a request for a ListenableFuture, so we
       // special-case it here.
       if (isTypeOf(ListenableFuture.class, type)) {
-        return new AutoValue_DependencyRequest(
-            Kind.FUTURE,
-            keyFactory.forQualifiedType(
-                qualifier, Iterables.getOnlyElement(((DeclaredType) type).getTypeArguments())),
-            productionMethod,
-            false /* doesn't allow null */,
-            Optional.<String>absent(),
-            false /* not synthetic */);
+        return DependencyRequest.builder()
+            .kind(Kind.FUTURE)
+            .key(keyFactory.forQualifiedType(
+                qualifier, Iterables.getOnlyElement(((DeclaredType) type).getTypeArguments())))
+            .requestElement(productionMethod)
+            .build();
       } else {
-        return newDependencyRequest(productionMethod, type, qualifier, Optional.<String>absent());
+        return newDependencyRequest(productionMethod, type, qualifier, Optional.empty());
       }
     }
 
@@ -338,45 +436,55 @@ DependencyRequest forComponentMembersInjectionMethod(ExecutableElement membersIn
           MoreTypes.isType(returnType) && MoreTypes.isTypeOf(MembersInjector.class, returnType)
               ? getOnlyElement(MoreTypes.asDeclared(returnType).getTypeArguments())
               : getOnlyElement(membersInjectionMethodType.getParameterTypes());
-      return new AutoValue_DependencyRequest(
-          Kind.MEMBERS_INJECTOR,
-          keyFactory.forMembersInjectedType(membersInjectedType),
-          membersInjectionMethod,
-          false /* doesn't allow null */,
-          Optional.<String>absent(),
-          false /* not synthetic */);
+      return DependencyRequest.builder()
+          .kind(Kind.MEMBERS_INJECTOR)
+          .key(keyFactory.forMembersInjectedType(membersInjectedType))
+          .requestElement(membersInjectionMethod)
+          .build();
     }
 
     DependencyRequest forMembersInjectedType(DeclaredType type) {
-      return new AutoValue_DependencyRequest(
-          Kind.MEMBERS_INJECTOR,
-          keyFactory.forMembersInjectedType(type),
-          type.asElement(),
-          false /* doesn't allow null */,
-          Optional.<String>absent(),
-          false /* not synthetic */);
+      return DependencyRequest.builder()
+          .kind(Kind.MEMBERS_INJECTOR)
+          .key(keyFactory.forMembersInjectedType(type))
+          .requestElement(type.asElement())
+          .build();
     }
 
     DependencyRequest forProductionImplementationExecutor() {
       Key key = keyFactory.forProductionImplementationExecutor();
-      return new AutoValue_DependencyRequest(
-          Kind.PROVIDER,
-          key,
-          MoreTypes.asElement(key.type()),
-          false /* doesn't allow null */,
-          Optional.<String>absent(),
-          false /* not synthetic */);
+      return DependencyRequest.builder()
+          .kind(Kind.PROVIDER)
+          .key(key)
+          .requestElement(MoreTypes.asElement(key.type()))
+          .build();
     }
 
-    DependencyRequest forProductionComponentMonitorProvider() {
-      TypeElement element = elements.getTypeElement(AbstractProducer.class.getCanonicalName());
-      for (ExecutableElement constructor : constructorsIn(element.getEnclosedElements())) {
-        if (constructor.getParameters().size() == 2) {
-          // the 2-arg constructor has the appropriate dependency as its first arg
-          return forRequiredVariable(constructor.getParameters().get(0), Optional.of("monitor"));
-        }
-      }
-      throw new AssertionError("expected 2-arg constructor in AbstractProducer");
+    DependencyRequest forProductionComponentMonitor() {
+      Key key = keyFactory.forProductionComponentMonitor();
+      return DependencyRequest.builder()
+          .kind(Kind.PROVIDER)
+          .key(key)
+          .requestElement(MoreTypes.asElement(key.type()))
+          .overriddenVariableName(Optional.of("monitor"))
+          .build();
+    }
+
+    /**
+     * Returns a synthetic request for the present value of an optional binding generated from a
+     * {@link dagger.BindsOptionalOf} declaration.
+     */
+    DependencyRequest forSyntheticPresentOptionalBinding(Key requestKey, Kind kind) {
+      Optional<Key> key = keyFactory.unwrapOptional(requestKey);
+      checkArgument(key.isPresent(), "not a request for optional: %s", requestKey);
+      return builder()
+          .kind(kind)
+          .key(key.get())
+          .isNullable(
+              allowsNull(
+                  extractKindAndType(OptionalType.from(requestKey).valueType()).kind(),
+                  Optional.empty()))
+          .build();
     }
 
     private DependencyRequest newDependencyRequest(
@@ -388,83 +496,24 @@ private DependencyRequest newDependencyRequest(
       if (kindAndType.kind().equals(Kind.MEMBERS_INJECTOR)) {
         checkArgument(!qualifier.isPresent());
       }
-      // Only instance types can be non-null -- all other requests are wrapped
-      // inside something (e.g, Provider, Lazy, etc..).
-      // TODO(sameb): should Produced/Producer always require non-nullable?
-      boolean allowsNull = !kindAndType.kind().equals(Kind.INSTANCE)
-          || ConfigurationAnnotations.getNullableType(requestElement).isPresent();
-      return new AutoValue_DependencyRequest(
-          kindAndType.kind(),
-          keyFactory.forQualifiedType(qualifier, kindAndType.type()),
-          requestElement,
-          allowsNull,
-          name,
-          false /* not synthetic */);
-    }
-
-    @AutoValue
-    abstract static class KindAndType {
-      abstract Kind kind();
-      abstract TypeMirror type();
-
-      static Optional<KindAndType> from(TypeMirror type) {
-        for (Kind kind : Kind.values()) {
-          Optional<KindAndType> kindAndType = kind.from(type);
-          if (kindAndType.isPresent()) {
-            return kindAndType.get().maybeProviderOfLazy().or(kindAndType);
-          }
-        }
-        return Optional.absent();
-      }
-
-      /**
-       * If {@code kindAndType} represents a {@link Kind#PROVIDER} of a {@code Lazy<T>} for some
-       * type {@code T}, then this method returns ({@link Kind#PROVIDER_OF_LAZY}, {@code T}).
-       */
-      private Optional<KindAndType> maybeProviderOfLazy() {
-        if (kind().equals(Kind.PROVIDER)) {
-          Optional<KindAndType> providedKindAndType = from(type());
-          if (providedKindAndType.isPresent()
-              && providedKindAndType.get().kind().equals(Kind.LAZY)) {
-            return Optional.of(Kind.PROVIDER_OF_LAZY.ofType(providedKindAndType.get().type()));
-          }
-        }
-        return Optional.absent();
-      }
+      return DependencyRequest.builder()
+          .kind(kindAndType.kind())
+          .key(keyFactory.forQualifiedType(qualifier, kindAndType.type()))
+          .requestElement(requestElement)
+          .isNullable(allowsNull(kindAndType.kind(), getNullableType(requestElement)))
+          .overriddenVariableName(name)
+          .build();
     }
 
     /**
-     * Extracts the dependency request type and kind from the type of a dependency request element.
-     * For example, if a user requests {@code Provider<Foo>}, this will return
-     * ({@link Kind#PROVIDER}, {@code Foo}).
-     *
-     * @throws TypeNotPresentException if {@code type}'s kind is {@link TypeKind#ERROR}, which may
-     *     mean that the type will be generated in a later round of processing
+     * Returns {@code true} if a given request element allows null values. {@link Kind#INSTANCE}
+     * requests must be annotated with {@code @Nullable} in order to allow null values. All other
+     * request kinds implicitly allow null values because they are are wrapped inside {@link
+     * Provider}, {@link Lazy}, etc.
      */
-    static KindAndType extractKindAndType(TypeMirror type) {
-      return type.accept(
-          new SimpleTypeVisitor7<KindAndType, Void>() {
-            @Override
-            public KindAndType visitError(ErrorType errorType, Void p) {
-              throw new TypeNotPresentException(errorType.toString(), null);
-            }
-
-            @Override
-            public KindAndType visitExecutable(ExecutableType executableType, Void p) {
-              return executableType.getReturnType().accept(this, null);
-            }
-
-            @Override
-            public KindAndType visitDeclared(DeclaredType declaredType, Void p) {
-              return KindAndType.from(declaredType).or(defaultAction(declaredType, p));
-            }
-
-            @Override
-            protected KindAndType defaultAction(TypeMirror otherType, Void p) {
-              return new AutoValue_DependencyRequest_Factory_KindAndType(Kind.INSTANCE, otherType);
-            }
-          },
-          null);
+    // TODO(sameb): should Produced/Producer always require non-nullable?
+    private boolean allowsNull(Kind kind, Optional<DeclaredType> nullableType) {
+      return kind.equals(Kind.INSTANCE) ? nullableType.isPresent() : true;
     }
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyRequestFormatter.java b/compiler/src/main/java/dagger/internal/codegen/DependencyRequestFormatter.java
index 9c3c65b92..176d97a68 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DependencyRequestFormatter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyRequestFormatter.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Google, Inc.
+ * Copyright (C) 2014 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,30 +13,39 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal.codegen;
 
+import static com.google.auto.common.MoreElements.asExecutable;
+import static dagger.internal.codegen.ErrorMessages.DOUBLE_INDENT;
+import static dagger.internal.codegen.ErrorMessages.INDENT;
+import static dagger.internal.codegen.Util.toImmutableList;
+
 import com.google.auto.common.MoreElements;
 import com.google.common.base.Joiner;
-import com.google.common.base.Optional;
-import com.google.common.base.Predicates;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.util.concurrent.ListenableFuture;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
+import dagger.Lazy;
 import dagger.Provides;
-import dagger.internal.codegen.BindingGraphValidator.DependencyPath;
+import dagger.internal.codegen.ComponentTreeTraverser.DependencyTrace;
 import dagger.producers.Produces;
+import java.util.List;
+import java.util.Optional;
+import java.util.concurrent.atomic.AtomicReference;
 import javax.inject.Inject;
+import javax.inject.Provider;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.ElementKindVisitor7;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 
-import static com.google.auto.common.MoreElements.asExecutable;
-import static dagger.internal.codegen.ErrorMessages.INDENT;
-
 /**
  * Formats a {@link DependencyRequest} into a {@link String} suitable for an error message listing
  * a chain of dependencies.
@@ -69,20 +78,24 @@
     this.elements = elements;
   }
 
-  /**
-   * A string representation of the dependency trace, starting with the
-   * {@linkplain DependencyPath#currentDependencyRequest() current request} and ending with the
-   * entry point, excluding {@linkplain DependencyRequest#isSynthetic() synthetic} requests.
-   */
-  String toDependencyTrace(DependencyPath dependencyPath) {
+  /** Returns a representation of the dependency trace, with the entry point at the bottom. */
+  String format(DependencyTrace dependencyTrace) {
+    AtomicReference<ImmutableSet<OptionalBindingDeclaration>> dependentOptionalBindingDeclarations =
+        new AtomicReference<>(ImmutableSet.of());
     return Joiner.on('\n')
         .join(
-            dependencyPath
-                .requests()
-                .filter(Predicates.not(DependencyRequest.IS_SYNTHETIC))
-                .transform(this)
-                .filter(Predicates.not(Predicates.equalTo("")))
-                .toList()
+            dependencyTrace
+                .transform(
+                    (dependencyRequest, resolvedBindings) -> {
+                      ImmutableSet<OptionalBindingDeclaration> optionalBindingDeclarations =
+                          dependentOptionalBindingDeclarations.getAndSet(
+                              resolvedBindings.optionalBindingDeclarations());
+                      return optionalBindingDeclarations.isEmpty()
+                          ? format(dependencyRequest)
+                          : formatSyntheticOptionalBindingDependency(optionalBindingDeclarations);
+                    })
+                .filter(f -> !f.isEmpty())
+                .collect(toImmutableList())
                 .reverse());
   }
 
@@ -90,8 +103,12 @@ String toDependencyTrace(DependencyPath dependencyPath) {
   // TODO(cgruber): consider returning a small structure containing strings to be indented later.
   @Override
   public String format(DependencyRequest request) {
+    if (!request.requestElement().isPresent()) {
+      return "";
+    }
     return request
         .requestElement()
+        .get()
         .accept(
             new ElementKindVisitor7<String, DependencyRequest>() {
 
@@ -99,12 +116,14 @@ public String format(DependencyRequest request) {
               @Override
               public String visitExecutableAsMethod(
                   ExecutableElement method, DependencyRequest request) {
-                StringBuilder builder = new StringBuilder(INDENT);
-                appendRequestedKeyAndVerb(
-                    builder,
-                    request.key().qualifier(),
-                    request.key().type(),
-                    componentMethodRequestVerb(request));
+                StringBuilder builder = new StringBuilder();
+                builder
+                    .append(INDENT)
+                    .append(formatKey(request.key()))
+                    .append(" is ")
+                    .append(componentMethodRequestVerb(request))
+                    .append(" at\n")
+                    .append(DOUBLE_INDENT);
                 appendEnclosingTypeAndMemberName(method, builder);
                 builder.append('(');
                 for (VariableElement parameter : method.getParameters()) {
@@ -116,26 +135,23 @@ public String visitExecutableAsMethod(
 
               /**
                * Returns the description for {@link javax.inject.Inject @Inject} constructor and
-               * method parameters and for {@link dagger.Provides @Provides} and
-               * {@link dagger.producers.Produces @Produces} method parameters.
+               * method parameters and for {@link dagger.Provides @Provides} and {@link
+               * dagger.producers.Produces @Produces} method parameters.
                */
               @Override
               public String visitVariableAsParameter(
-                  final VariableElement variable, DependencyRequest request) {
-                StringBuilder builder = new StringBuilder(INDENT);
-                appendRequestedKeyAndVerb(request, builder);
+                  VariableElement variable, DependencyRequest request) {
+                StringBuilder builder = new StringBuilder();
+                appendRequestedTypeIsInjectedAt(builder, request);
 
                 ExecutableElement methodOrConstructor =
                     asExecutable(variable.getEnclosingElement());
                 appendEnclosingTypeAndMemberName(methodOrConstructor, builder).append('(');
-                int parameterIndex = methodOrConstructor.getParameters().indexOf(variable);
-                if (parameterIndex > 0) {
-                  builder.append("…, ");
-                }
-                builder.append(variable.getSimpleName());
-                if (parameterIndex < methodOrConstructor.getParameters().size() - 1) {
-                  builder.append(", …");
-                }
+                List<? extends VariableElement> parameters = methodOrConstructor.getParameters();
+                int parameterIndex = parameters.indexOf(variable);
+                builder.append(
+                    formatArgumentInList(
+                        parameterIndex, parameters.size(), variable.getSimpleName()));
                 builder.append(')');
                 return builder.toString();
               }
@@ -144,8 +160,8 @@ public String visitVariableAsParameter(
               @Override
               public String visitVariableAsField(
                   VariableElement variable, DependencyRequest request) {
-                StringBuilder builder = new StringBuilder(INDENT);
-                appendRequestedKeyAndVerb(request, builder);
+                StringBuilder builder = new StringBuilder();
+                appendRequestedTypeIsInjectedAt(builder, request);
                 appendEnclosingTypeAndMemberName(variable, builder);
                 return builder.toString();
               }
@@ -164,36 +180,50 @@ protected String defaultAction(Element element, DependencyRequest request) {
             request);
   }
 
-  private void appendRequestedKeyAndVerb(DependencyRequest request, StringBuilder builder) {
-    appendRequestedKeyAndVerb(
-        builder, request.key().qualifier(), requestedTypeWithFrameworkClass(request), "injected");
+  @CanIgnoreReturnValue
+  private StringBuilder appendRequestedTypeIsInjectedAt(
+      StringBuilder builder, DependencyRequest request) {
+    return builder
+        .append(INDENT)
+        .append(formatKey(request.key().qualifier(), requestedType(request)))
+        .append(" is injected at\n")
+        .append(DOUBLE_INDENT);
   }
 
-  private void appendRequestedKeyAndVerb(
-      StringBuilder builder,
-      Optional<AnnotationMirror> qualifier,
-      TypeMirror requestedType,
-      String verb) {
-    appendQualifiedType(builder, qualifier, requestedType);
-    builder.append(" is ").append(verb).append(" at\n    ").append(INDENT);
-  }
+  private TypeMirror requestedType(DependencyRequest request) {
+    TypeMirror keyType = request.key().type();
+    switch (request.kind()) {
+      case FUTURE:
+        return wrapType(ListenableFuture.class, keyType);
 
-  private TypeMirror requestedTypeWithFrameworkClass(DependencyRequest request) {
-    Optional<Class<?>> requestFrameworkClass = request.kind().frameworkClass;
-    if (requestFrameworkClass.isPresent()) {
-      return types.getDeclaredType(
-          elements.getTypeElement(requestFrameworkClass.get().getCanonicalName()),
-          request.key().type());
+      case PROVIDER_OF_LAZY:
+        return wrapType(Provider.class, wrapType(Lazy.class, keyType));
+
+      default:
+        if (request.kind().frameworkClass.isPresent()) {
+          return wrapType(request.kind().frameworkClass.get(), keyType);
+        } else {
+          return keyType;
+        }
     }
-    return request.key().type();
   }
 
-  private void appendQualifiedType(
-      StringBuilder builder, Optional<AnnotationMirror> qualifier, TypeMirror type) {
+  private DeclaredType wrapType(Class<?> wrapperType, TypeMirror wrappedType) {
+    return types.getDeclaredType(
+        elements.getTypeElement(wrapperType.getCanonicalName()), wrappedType);
+  }
+
+  private String formatKey(Key key) {
+    return formatKey(key.qualifier(), key.type());
+  }
+
+  private String formatKey(Optional<AnnotationMirror> qualifier, TypeMirror type) {
+    StringBuilder builder = new StringBuilder();
     if (qualifier.isPresent()) {
       builder.append(qualifier.get()).append(' ');
     }
     builder.append(type);
+    return builder.toString();
   }
 
   /**
@@ -209,6 +239,7 @@ private String componentMethodRequestVerb(DependencyRequest request) {
       case INSTANCE:
       case LAZY:
       case PROVIDER:
+      case PROVIDER_OF_LAZY:
         return "provided";
 
       case MEMBERS_INJECTOR:
@@ -228,4 +259,30 @@ private StringBuilder appendEnclosingTypeAndMemberName(Element member, StringBui
         .append('.')
         .append(member.getSimpleName());
   }
+
+  /**
+   * Returns a string of the form "{@code @BindsOptionalOf SomeKey is declared at Module.method()}",
+   * where {@code Module.method()} is the declaration. If there is more than one such declaration,
+   * one is chosen arbitrarily, and ", among others" is appended.
+   */
+  private String formatSyntheticOptionalBindingDependency(
+      ImmutableSet<OptionalBindingDeclaration> optionalBindingDeclarations) {
+    OptionalBindingDeclaration optionalBindingDeclaration =
+        optionalBindingDeclarations.iterator().next();
+    StringBuilder builder = new StringBuilder();
+    builder
+        .append(INDENT)
+        .append("@BindsOptionalOf ")
+        .append(formatKey(optionalBindingDeclaration.key()))
+        .append(" is declared at\n")
+        .append(DOUBLE_INDENT);
+
+    appendEnclosingTypeAndMemberName(optionalBindingDeclaration.bindingElement().get(), builder);
+    builder.append("()");
+    if (optionalBindingDeclarations.size() > 1) {
+      builder.append(", among others");
+    }
+
+    return builder.toString();
+  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyRequestMapper.java b/compiler/src/main/java/dagger/internal/codegen/DependencyRequestMapper.java
deleted file mode 100644
index c57bed0b0..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/DependencyRequestMapper.java
+++ /dev/null
@@ -1,103 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen;
-
-import com.google.common.base.Function;
-import com.google.common.collect.FluentIterable;
-import com.google.common.collect.ImmutableSet;
-import dagger.MembersInjector;
-import dagger.producers.Producer;
-import javax.inject.Provider;
-
-import static com.google.common.collect.Iterables.getOnlyElement;
-
-/**
- * A mapper for associating a {@link DependencyRequest} to a framework class, dependent on
- * the type of code to be generated (e.g., for {@link Provider} or {@link Producer}).
- *
- *  @author Jesse Beder
- *  @since 2.0
- */
-abstract class DependencyRequestMapper {
-  abstract Class<?> getFrameworkClass(DependencyRequest request);
-
-  /**
-   * Returns the framework class to use for a collection of requests of the same {@link BindingKey}.
-   * This allows factories to only take a single argument for multiple requests of the same key.
-   */
-  Class<?> getFrameworkClass(Iterable<DependencyRequest> requests) {
-    ImmutableSet<Class<?>> classes = FluentIterable.from(requests)
-        .transform(new Function<DependencyRequest, Class<?>>() {
-          @Override public Class<?> apply(DependencyRequest request) {
-            return getFrameworkClass(request);
-          }
-        })
-        .toSet();
-    if (classes.size() == 1) {
-      return getOnlyElement(classes);
-    } else if (classes.equals(ImmutableSet.of(Producer.class, Provider.class))) {
-      return Provider.class;
-    } else {
-      throw new IllegalStateException("Bad set of framework classes: " + classes);
-    }
-  }
-
-  private static final class MapperForProvider extends DependencyRequestMapper {
-    @Override public Class<?> getFrameworkClass(DependencyRequest request) {
-      switch (request.kind()) {
-        case INSTANCE:
-        case PROVIDER:
-        case PROVIDER_OF_LAZY:
-        case LAZY:
-          return Provider.class;
-        case MEMBERS_INJECTOR:
-          return MembersInjector.class;
-        case PRODUCED:
-        case PRODUCER:
-          throw new IllegalArgumentException();
-        default:
-          throw new AssertionError();
-      }
-    }
-  }
-
-  static final DependencyRequestMapper FOR_PROVIDER = new MapperForProvider();
-
-  private static final class MapperForProducer extends DependencyRequestMapper {
-    @Override public Class<?> getFrameworkClass(DependencyRequest request) {
-      switch (request.kind()) {
-        case INSTANCE:
-        case PRODUCED:
-        case PRODUCER:
-          return Producer.class;
-        case PROVIDER:
-        case PROVIDER_OF_LAZY:
-        case LAZY:
-          return Provider.class;
-        case MEMBERS_INJECTOR:
-          return MembersInjector.class;
-        default:
-          throw new AssertionError();
-      }
-    }
-  }
-
-  static final DependencyRequestMapper FOR_PRODUCER = new MapperForProducer();
-
-  static DependencyRequestMapper forBindingType(BindingType bindingType) {
-    return bindingType.equals(BindingType.PRODUCTION) ? FOR_PRODUCER : FOR_PROVIDER;
-  }
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyVariableNamer.java b/compiler/src/main/java/dagger/internal/codegen/DependencyVariableNamer.java
index 81a2d13eb..b84d338db 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DependencyVariableNamer.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyVariableNamer.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Google, Inc.
+ * Copyright (C) 2014 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,8 +13,11 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal.codegen;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 import com.google.common.base.Ascii;
 import com.google.common.base.CaseFormat;
 import com.google.common.base.Function;
@@ -41,7 +44,8 @@ public String apply(DependencyRequest dependency) {
     if (dependency.overriddenVariableName().isPresent()) {
       return dependency.overriddenVariableName().get();
     }
-    String variableName = dependency.requestElement().getSimpleName().toString();
+    checkArgument(dependency.requestElement().isPresent());
+    String variableName = dependency.requestElement().get().getSimpleName().toString();
     if (Ascii.isUpperCase(variableName.charAt(0))) {
       variableName = toLowerCamel(variableName);
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
index cbb82fc58..0168e112a 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Google, Inc.
+ * Copyright (C) 2014 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,15 +13,30 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal.codegen;
 
+import static dagger.internal.codegen.ConfigurationAnnotations.getSubcomponentAnnotation;
+import static dagger.internal.codegen.MoreAnnotationMirrors.simpleName;
+import static java.util.stream.Collectors.joining;
+import static java.util.stream.Collectors.toList;
+
+import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
+import com.google.common.base.Joiner;
 import dagger.Multibindings;
-import dagger.Provides;
 import dagger.multibindings.Multibinds;
+import dagger.releasablereferences.CanReleaseReferences;
+import dagger.releasablereferences.ForReleasableReferences;
+import java.lang.annotation.Annotation;
+import java.util.Collection;
+import java.util.Set;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeMirror;
 
 /**
@@ -35,6 +50,7 @@
    * Common constants.
    */
   static final String INDENT = "    ";
+  static final String DOUBLE_INDENT = INDENT + INDENT;
   static final int DUPLICATE_SIZE_LIMIT = 10;
 
   /*
@@ -180,8 +196,15 @@ static String inconsistentMapKeyAnnotationsError(String key) {
   static final String BINDS_METHOD_ONE_ASSIGNABLE_PARAMETER =
       "@Binds methods must have only one parameter whose type is assignable to the return type";
 
-  static final String BINDING_METHOD_NOT_IN_MODULE =
-      "@%s methods can only be present within a @%s";
+  static final String BINDS_OPTIONAL_OF_METHOD_HAS_PARAMETER =
+      "@BindsOptionalOf methods must not have parameters";
+
+  static final String BINDS_OPTIONAL_OF_METHOD_RETURNS_IMPLICITLY_PROVIDED_TYPE =
+      "@BindsOptionalOf methods cannot "
+          + "return unqualified types that have an @Inject-annotated constructor because those are "
+          + "always present";
+
+  static final String BINDING_METHOD_NOT_IN_MODULE = "@%s methods can only be present within a @%s";
 
   static final String BINDS_ELEMENTS_INTO_SET_METHOD_RETURN_SET =
       "@Binds @ElementsIntoSet methods must return a Set and take a Set parameter";
@@ -192,7 +215,7 @@ static String inconsistentMapKeyAnnotationsError(String key) {
   static final String BINDING_METHOD_WITH_NO_MAP_KEY =
       "@%s methods of type map must declare a map key";
 
-  static final String BINDING_METHOD_WITH_MULTIPLE_MAP_KEY =
+  static final String BINDING_METHOD_WITH_MULTIPLE_MAP_KEYS =
       "@%s methods may not have more than one @MapKey-marked annotation";
 
   static final String BINDING_METHOD_WITH_SAME_NAME =
@@ -231,7 +254,7 @@ static String inconsistentMapKeyAnnotationsError(String key) {
       "Map key annotations with unwrapped values cannot use arrays";
 
   /* collection binding errors */
-  static final String MULTIPLE_BINDING_TYPES_FOR_KEY_FORMAT =
+  static final String MULTIPLE_CONTRIBUTION_TYPES_FOR_KEY_FORMAT =
       "%s has incompatible bindings or declarations:\n";
 
   static final String PROVIDER_ENTRY_POINT_MAY_NOT_DEPEND_ON_PRODUCER_FORMAT =
@@ -274,7 +297,7 @@ static String provisionMayNotDependOnProducerType(TypeMirror type) {
   static final String MEMBERS_INJECTION_WITH_UNBOUNDED_TYPE =
       "Type parameters must be bounded for members injection. %s required by %s, via:\n%s";
 
-  static final String CONTAINS_DEPENDENCY_CYCLE_FORMAT = "%s.%s() contains a dependency cycle:\n%s";
+  static final String CONTAINS_DEPENDENCY_CYCLE_FORMAT = "Found a dependency cycle:\n%s";
 
   static String nullableToNonNullable(String typeName, String bindingString) {
     return String.format(
@@ -299,6 +322,17 @@ static String nullableToNonNullable(String typeName, String bindingString) {
   static final String MULTIBINDING_ANNOTATION_CONFLICTS_WITH_BINDING_ANNOTATION_ENUM =
       "@%s.type cannot be used with multibinding annotations";
 
+  /* BindsInstance messages. */
+  static final String BINDS_INSTANCE_IN_MODULE =
+      "@BindsInstance methods should not be included in @%ss. Did you mean @Binds?";
+
+  static final String BINDS_INSTANCE_IN_INVALID_COMPONENT =
+      "@BindsInstance methods should not be included in @%1$ss. "
+          + "Did you mean to put it in a @%1$s.Builder?";
+
+  static final String BINDS_INSTANCE_ONE_PARAMETER =
+      "@BindsInstance methods should have exactly one parameter for the bound type";
+
   static ComponentBuilderMessages builderMsgsFor(ComponentDescriptor.Kind kind) {
     switch(kind) {
       case COMPONENT:
@@ -314,6 +348,75 @@ static ComponentBuilderMessages builderMsgsFor(ComponentDescriptor.Kind kind) {
     }
   }
 
+  static final String CAN_RELEASE_REFERENCES_ANNOTATIONS_MUST_NOT_HAVE_SOURCE_RETENTION =
+      "@CanReleaseReferences annotations must not have SOURCE retention";
+
+  static String forReleasableReferencesValueNotAScope(TypeElement scopeType) {
+    return forReleasableReferencesValueNeedsAnnotation(
+        scopeType,
+        String.format(
+            "@%s and @%s",
+            javax.inject.Scope.class.getCanonicalName(),
+            CanReleaseReferences.class.getCanonicalName()));
+  }
+
+  static String forReleasableReferencesValueCannotReleaseReferences(TypeElement scopeType) {
+    return forReleasableReferencesValueNeedsAnnotation(
+        scopeType, "@" + CanReleaseReferences.class.getCanonicalName());
+  }
+
+  private static String forReleasableReferencesValueNeedsAnnotation(
+      TypeElement scopeType, String annotations) {
+    return String.format(
+        "The value of @%s must be a reference-releasing scope. "
+            + "Did you mean to annotate %s with %s? Or did you mean to use a different class here?",
+        ForReleasableReferences.class.getSimpleName(), scopeType.getQualifiedName(), annotations);
+  }
+
+  static String referenceReleasingScopeNotInComponentHierarchy(
+      String formattedKey, Scope scope, BindingGraph topLevelGraph) {
+    return String.format(
+        "There is no binding for %s because no component in %s's component hierarchy is "
+            + "annotated with %s. The available reference-releasing scopes are %s.",
+        formattedKey,
+        topLevelGraph.componentType().getQualifiedName(),
+        scope.getReadableSource(),
+        topLevelGraph
+            .componentDescriptor()
+            .releasableReferencesScopes()
+            .stream()
+            .map(Scope::getReadableSource)
+            .collect(toList()));
+  }
+
+  static String referenceReleasingScopeMetadataMissingCanReleaseReferences(
+      String formattedKey, DeclaredType metadataType) {
+    return String.format(
+        "There is no binding for %s because %s is not annotated with @%s.",
+        formattedKey, metadataType, CanReleaseReferences.class.getCanonicalName());
+  }
+
+  static String referenceReleasingScopeNotAnnotatedWithMetadata(
+      String formattedKey, Scope scope, TypeMirror metadataType) {
+    return String.format(
+        "There is no binding for %s because %s is not annotated with @%s.",
+        formattedKey, scope.getQualifiedName(), metadataType);
+  }
+
+  /**
+   * Returns an error message for a method that has more than one binding method annotation.
+   *
+   * @param methodAnnotations the valid method annotations, only one of which may annotate the
+   *     method
+   */
+  static String tooManyBindingMethodAnnotations(
+      ExecutableElement method, Collection<Class<? extends Annotation>> methodAnnotations) {
+    return String.format(
+        "%s is annotated with more than one of (%s)",
+        method.getSimpleName(),
+        methodAnnotations.stream().map(Class::getCanonicalName).collect(joining(", ")));
+  }
+
   static class ComponentBuilderMessages {
     static final ComponentBuilderMessages INSTANCE = new ComponentBuilderMessages();
 
@@ -385,13 +488,12 @@ final String inheritedTwoBuildMethods() {
 
     final String buildMustReturnComponentType() {
       return process(
-          "@Component.Builder methods that have no arguments must return the @Component type");
+          "@Component.Builder methods that have no arguments must return the @Component type or a "
+              + "supertype of the @Component");
     }
 
     final String inheritedBuildMustReturnComponentType() {
-      return process(
-          "@Component.Builder methods that have no arguments must return the @Component type"
-          + " Inherited method: %s");
+      return process(buildMustReturnComponentType() + ". Inherited method: %s");
     }
 
     final String methodsMustTakeOneArg() {
@@ -421,6 +523,23 @@ final String inheritedMethodsMayNotHaveTypeParameters() {
       return process(
           "@Component.Builder methods must not have type parameters. Inherited method: %s");
     }
+
+    final String buildMethodReturnsSupertypeWithMissingMethods(
+        TypeElement component,
+        TypeElement componentBuilder,
+        TypeMirror returnType,
+        ExecutableElement buildMethod,
+        Set<ExecutableElement> additionalMethods) {
+      return String.format(
+          "%1$s.%2$s() returns %3$s, but %4$s declares additional component method(s): %5$s. In "
+              + "order to provide type-safe access to these methods, override %2$s() to return "
+              + "%4$s",
+          componentBuilder.getQualifiedName(),
+          buildMethod.getSimpleName(),
+          returnType,
+          component.getQualifiedName(),
+          Joiner.on(", ").join(additionalMethods));
+    }
   }
 
   static final class SubcomponentBuilderMessages extends ComponentBuilderMessages {
@@ -490,13 +609,38 @@ private MultibindingsMessages() {}
     static final String METHOD_MUST_RETURN_MAP_OR_SET =
         "@%s methods must return Map<K, V> or Set<T>";
 
-    static final String NO_MAP_KEY = "@%s methods must not have a @MapKey annotation";
-
     static final String PARAMETERS = "@%s methods cannot have parameters";
 
     private MultibindsMessages() {}
   }
 
+  static class ModuleMessages {
+    static String moduleSubcomponentsIncludesBuilder(TypeElement moduleSubcomponentsAttribute) {
+      TypeElement subcomponentType =
+          MoreElements.asType(moduleSubcomponentsAttribute.getEnclosingElement());
+      return String.format(
+          "%s is a @%s.Builder. Did you mean to use %s?",
+          moduleSubcomponentsAttribute.getQualifiedName(),
+          simpleName(getSubcomponentAnnotation(subcomponentType).get()),
+          subcomponentType.getQualifiedName());
+    }
+
+    static String moduleSubcomponentsIncludesNonSubcomponent(
+        TypeElement moduleSubcomponentsAttribute) {
+      return moduleSubcomponentsAttribute.getQualifiedName()
+          + " is not a @Subcomponent or @ProductionSubcomponent";
+    }
+
+    static String moduleSubcomponentsDoesntHaveBuilder(
+        TypeElement subcomponent, AnnotationMirror moduleAnnotation) {
+      return String.format(
+          "%s doesn't have a @%s.Builder, which is required when used with @%s.subcomponents",
+          subcomponent.getQualifiedName(),
+          simpleName(getSubcomponentAnnotation(subcomponent).get()),
+          simpleName(moduleAnnotation));
+    }
+  }
+
   /**
    * A regular expression to match a small list of specific packages deemed to
    * be unhelpful to display in fully qualified types in error messages.
@@ -528,9 +672,6 @@ private MultibindsMessages() {}
    *     through this method.
    */
   static String stripCommonTypePrefixes(String type) {
-    // Special case this enum's constants since they will be incredibly common.
-    type = type.replace(Provides.Type.class.getCanonicalName() + ".", "");
-
     // Do regex magic to remove common packages we care to shorten.
     Matcher matcher = COMMON_PACKAGE_PATTERN.matcher(type);
     StringBuilder result = new StringBuilder();
diff --git a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
index 9817dd052..95024f4d5 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Google, Inc.
+ * Copyright (C) 2014 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,12 +13,38 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal.codegen;
 
-import com.google.common.base.Optional;
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.squareup.javapoet.MethodSpec.constructorBuilder;
+import static com.squareup.javapoet.MethodSpec.methodBuilder;
+import static com.squareup.javapoet.TypeSpec.classBuilder;
+import static dagger.internal.codegen.AnnotationSpecs.Suppression.RAWTYPES;
+import static dagger.internal.codegen.AnnotationSpecs.Suppression.UNCHECKED;
+import static dagger.internal.codegen.AnnotationSpecs.suppressWarnings;
+import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
+import static dagger.internal.codegen.ContributionBinding.Kind.INJECTION;
+import static dagger.internal.codegen.ContributionBinding.Kind.PROVISION;
+import static dagger.internal.codegen.ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_PROVIDES_METHOD;
+import static dagger.internal.codegen.Proxies.createProxy;
+import static dagger.internal.codegen.Proxies.shouldGenerateProxy;
+import static dagger.internal.codegen.SourceFiles.bindingTypeElementTypeVariableNames;
+import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
+import static dagger.internal.codegen.SourceFiles.generateBindingFieldsForDependencies;
+import static dagger.internal.codegen.SourceFiles.generatedClassNameForBinding;
+import static dagger.internal.codegen.SourceFiles.parameterizedGeneratedTypeNameForBinding;
+import static dagger.internal.codegen.TypeNames.factoryOf;
+import static javax.lang.model.element.Modifier.FINAL;
+import static javax.lang.model.element.Modifier.PRIVATE;
+import static javax.lang.model.element.Modifier.PUBLIC;
+import static javax.lang.model.element.Modifier.STATIC;
+
+import com.google.auto.common.MoreElements;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.Lists;
+import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
 import com.squareup.javapoet.FieldSpec;
@@ -32,35 +58,15 @@
 import dagger.internal.MembersInjectors;
 import dagger.internal.Preconditions;
 import java.util.List;
+import java.util.Map;
+import java.util.Optional;
 import javax.annotation.processing.Filer;
 import javax.inject.Inject;
 import javax.lang.model.element.Element;
+import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.util.Elements;
 import javax.tools.Diagnostic;
 
-import static com.google.common.base.Preconditions.checkState;
-import static com.squareup.javapoet.MethodSpec.constructorBuilder;
-import static com.squareup.javapoet.MethodSpec.methodBuilder;
-import static com.squareup.javapoet.TypeSpec.classBuilder;
-import static com.squareup.javapoet.TypeSpec.enumBuilder;
-import static dagger.internal.codegen.AnnotationSpecs.SUPPRESS_WARNINGS_RAWTYPES;
-import static dagger.internal.codegen.AnnotationSpecs.SUPPRESS_WARNINGS_UNCHECKED;
-import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
-import static dagger.internal.codegen.ContributionBinding.FactoryCreationStrategy.ENUM_INSTANCE;
-import static dagger.internal.codegen.ContributionBinding.Kind.INJECTION;
-import static dagger.internal.codegen.ContributionBinding.Kind.PROVISION;
-import static dagger.internal.codegen.ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_PROVIDES_METHOD;
-import static dagger.internal.codegen.SourceFiles.bindingTypeElementTypeVariableNames;
-import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
-import static dagger.internal.codegen.SourceFiles.generateBindingFieldsForDependencies;
-import static dagger.internal.codegen.SourceFiles.generatedClassNameForBinding;
-import static dagger.internal.codegen.SourceFiles.parameterizedGeneratedTypeNameForBinding;
-import static dagger.internal.codegen.TypeNames.factoryOf;
-import static javax.lang.model.element.Modifier.FINAL;
-import static javax.lang.model.element.Modifier.PRIVATE;
-import static javax.lang.model.element.Modifier.PUBLIC;
-import static javax.lang.model.element.Modifier.STATIC;
-
 /**
  * Generates {@link Factory} implementations from {@link ProvisionBinding} instances for
  * {@link Inject} constructors.
@@ -90,73 +96,78 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
 
   @Override
   Optional<? extends Element> getElementForErrorReporting(ProvisionBinding binding) {
-    return Optional.of(binding.bindingElement());
+    return binding.bindingElement();
   }
 
   @Override
   Optional<TypeSpec.Builder> write(ClassName generatedTypeName, ProvisionBinding binding) {
     // We don't want to write out resolved bindings -- we want to write out the generic version.
-    checkState(!binding.unresolved().isPresent());
+    checkArgument(!binding.unresolved().isPresent());
+    checkArgument(binding.bindingElement().isPresent());
 
     if (binding.bindingKind().equals(INJECTION)
-        && !injectValidator.isValidType(binding.factoryType())) {
-      return Optional.absent();
+        && !injectValidator.isValidType(binding.contributedType())) {
+      return Optional.empty();
     }
 
-    TypeName providedTypeName = TypeName.get(binding.factoryType());
-    ParameterizedTypeName parameterizedFactoryName = factoryOf(providedTypeName);
-    Optional<ParameterizedTypeName> factoryOfRawTypeName = Optional.absent();
-    TypeSpec.Builder factoryBuilder;
-    Optional<MethodSpec.Builder> constructorBuilder = Optional.absent();
+    TypeName providedTypeName = TypeName.get(binding.contributedType());
+    ParameterizedTypeName factoryTypeName = factoryOf(providedTypeName);
     ImmutableList<TypeVariableName> typeParameters = bindingTypeElementTypeVariableNames(binding);
-    ImmutableMap<BindingKey, FrameworkField> fields = generateBindingFieldsForDependencies(binding);
-    boolean useRawType =
-        binding.factoryCreationStrategy() == ENUM_INSTANCE
-            && binding.bindingKind() == INJECTION
+    TypeSpec.Builder factoryBuilder = classBuilder(generatedTypeName).addModifiers(FINAL);
+    // Use type parameters from the injected type or the module instance *only* if we require it.
+    boolean factoryHasTypeParameters =
+        (binding.bindingKind().equals(INJECTION) || binding.requiresModuleInstance())
             && !typeParameters.isEmpty();
+    if (factoryHasTypeParameters) {
+      factoryBuilder.addTypeVariables(typeParameters);
+    }
+    Optional<MethodSpec.Builder> constructorBuilder = Optional.empty();
+    UniqueNameSet uniqueFieldNames = new UniqueNameSet();
+    ImmutableMap.Builder<BindingKey, FieldSpec> fieldsBuilder = ImmutableMap.builder();
+
     switch (binding.factoryCreationStrategy()) {
-      case ENUM_INSTANCE:
-        factoryBuilder = enumBuilder(generatedTypeName.simpleName()).addEnumConstant("INSTANCE");
-        // If we have type parameters, then remove the parameters from our providedTypeName,
-        // since we'll be implementing an erased version of it.
-        if (useRawType) {
-          factoryBuilder.addAnnotation(SUPPRESS_WARNINGS_RAWTYPES);
-          // TODO(ronshapiro): instead of reassigning, introduce an optional/second parameter
-          providedTypeName = ((ParameterizedTypeName) providedTypeName).rawType;
-          factoryOfRawTypeName = Optional.of(factoryOf(providedTypeName));
+      case SINGLETON_INSTANCE:
+        FieldSpec.Builder instanceFieldBuilder =
+            FieldSpec.builder(generatedTypeName, "INSTANCE", PRIVATE, STATIC, FINAL)
+                .initializer("new $T()", generatedTypeName);
+
+        // if the factory has type parameters, we're ignoring them in the initializer
+        if (factoryHasTypeParameters) {
+          instanceFieldBuilder.addAnnotation(suppressWarnings(RAWTYPES));
         }
+
+        factoryBuilder.addField(instanceFieldBuilder.build());
         break;
       case CLASS_CONSTRUCTOR:
-        factoryBuilder =
-            classBuilder(generatedTypeName)
-                .addTypeVariables(typeParameters)
-                .addModifiers(FINAL);
         constructorBuilder = Optional.of(constructorBuilder().addModifiers(PUBLIC));
-        if (binding.bindingKind().equals(PROVISION)
-            && !binding.bindingElement().getModifiers().contains(STATIC)) {
+        if (binding.requiresModuleInstance()) {
           addConstructorParameterAndTypeField(
-              TypeName.get(binding.bindingTypeElement().asType()),
+              TypeName.get(binding.bindingTypeElement().get().asType()),
               "module",
               factoryBuilder,
               constructorBuilder.get());
         }
-        for (FrameworkField bindingField : fields.values()) {
-          addConstructorParameterAndTypeField(
-              bindingField.type(),
-              bindingField.name(),
-              factoryBuilder,
-              constructorBuilder.get());
+        for (Map.Entry<BindingKey, FrameworkField> entry :
+            generateBindingFieldsForDependencies(binding).entrySet()) {
+          BindingKey bindingKey = entry.getKey();
+          FrameworkField bindingField = entry.getValue();
+          FieldSpec field =
+              addConstructorParameterAndTypeField(
+                  bindingField.type(),
+                  uniqueFieldNames.getUniqueName(bindingField.name()),
+                  factoryBuilder,
+                  constructorBuilder.get());
+          fieldsBuilder.put(bindingKey, field);
         }
         break;
       case DELEGATE:
-        return Optional.absent();
+        return Optional.empty();
       default:
         throw new AssertionError();
     }
+    ImmutableMap<BindingKey, FieldSpec> fields = fieldsBuilder.build();
 
-    factoryBuilder
-        .addModifiers(PUBLIC)
-        .addSuperinterface(factoryOfRawTypeName.or(parameterizedFactoryName));
+    factoryBuilder.addModifiers(PUBLIC).addSuperinterface(factoryTypeName);
 
     // If constructing a factory for @Inject or @Provides bindings, we use a static create method
     // so that generated components can avoid having to refer to the generic types
@@ -168,26 +179,24 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
         // The return type is usually the same as the implementing type, except in the case
         // of enums with type variables (where we cast).
         MethodSpec.Builder createMethodBuilder =
-            methodBuilder("create")
-                .addModifiers(PUBLIC, STATIC)
-                .returns(parameterizedFactoryName);
-        if (binding.factoryCreationStrategy() != ENUM_INSTANCE
-            || binding.bindingKind() == INJECTION) {
+            methodBuilder("create").addModifiers(PUBLIC, STATIC).returns(factoryTypeName);
+        if (factoryHasTypeParameters) {
           createMethodBuilder.addTypeVariables(typeParameters);
         }
         List<ParameterSpec> params =
             constructorBuilder.isPresent()
-                ? constructorBuilder.get().build().parameters : ImmutableList.<ParameterSpec>of();
+                ? constructorBuilder.get().build().parameters
+                : ImmutableList.of();
         createMethodBuilder.addParameters(params);
         switch (binding.factoryCreationStrategy()) {
-          case ENUM_INSTANCE:
-            if (!useRawType) {
-              createMethodBuilder.addStatement("return INSTANCE");
-            } else {
+          case SINGLETON_INSTANCE:
+            if (factoryHasTypeParameters) {
               // We use an unsafe cast here because the types are different.
               // It's safe because the type is never referenced anywhere.
               createMethodBuilder.addStatement("return ($T) INSTANCE", TypeNames.FACTORY);
-              createMethodBuilder.addAnnotation(SUPPRESS_WARNINGS_UNCHECKED);
+              createMethodBuilder.addAnnotation(suppressWarnings(RAWTYPES, UNCHECKED));
+            } else {
+              createMethodBuilder.addStatement("return INSTANCE");
             }
             break;
 
@@ -196,7 +205,7 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
                 "return new $T($L)",
                 parameterizedGeneratedTypeNameForBinding(binding),
                 makeParametersCodeBlock(
-                    Lists.transform(params, CodeBlocks.PARAMETER_NAME)));
+                    Lists.transform(params, input -> CodeBlock.of("$N", input))));
             break;
           default:
             throw new AssertionError();
@@ -204,7 +213,7 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
         createMethod = Optional.of(createMethodBuilder.build());
         break;
       default:
-        createMethod = Optional.absent();
+        createMethod = Optional.empty();
     }
 
     if (constructorBuilder.isPresent()) {
@@ -212,11 +221,10 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
     }
 
     List<CodeBlock> parameters = Lists.newArrayList();
-    for (DependencyRequest dependency : binding.dependencies()) {
+    for (DependencyRequest dependency : binding.explicitDependencies()) {
       parameters.add(
           frameworkTypeUsageStatement(
-              CodeBlock.of("$L", fields.get(dependency.bindingKey()).name()),
-              dependency.kind()));
+              CodeBlock.of("$N", fields.get(dependency.bindingKey())), dependency.kind()));
     }
     CodeBlock parametersCodeBlock = makeParametersCodeBlock(parameters);
 
@@ -228,13 +236,14 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
 
     if (binding.bindingKind().equals(PROVISION)) {
       CodeBlock.Builder providesMethodInvocationBuilder = CodeBlock.builder();
-      if (binding.bindingElement().getModifiers().contains(STATIC)) {
-        providesMethodInvocationBuilder.add("$T", ClassName.get(binding.bindingTypeElement()));
-      } else {
+      if (binding.requiresModuleInstance()) {
         providesMethodInvocationBuilder.add("module");
+      } else {
+        providesMethodInvocationBuilder.add(
+            "$T", ClassName.get(binding.bindingTypeElement().get()));
       }
       providesMethodInvocationBuilder.add(
-          ".$L($L)", binding.bindingElement().getSimpleName(), parametersCodeBlock);
+          ".$L($L)", binding.bindingElement().get().getSimpleName(), parametersCodeBlock);
       CodeBlock providesMethodInvocation = providesMethodInvocationBuilder.build();
 
       if (binding.nullableType().isPresent()
@@ -250,9 +259,10 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
             CANNOT_RETURN_NULL_FROM_NON_NULLABLE_PROVIDES_METHOD);
       }
     } else if (binding.membersInjectionRequest().isPresent()) {
-      getMethodBuilder.addStatement("return $T.injectMembers($L, new $T($L))",
+      getMethodBuilder.addStatement(
+          "return $T.injectMembers($N, new $T($L))",
           MembersInjectors.class,
-          fields.get(binding.membersInjectionRequest().get().bindingKey()).name(),
+          fields.get(binding.membersInjectionRequest().get().bindingKey()),
           providedTypeName,
           parametersCodeBlock);
     } else {
@@ -264,11 +274,28 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
       factoryBuilder.addMethod(createMethod.get());
     }
 
-    // TODO(gak): write a sensible toString
+    proxyMethodFor(binding).ifPresent(factoryBuilder::addMethod);
+
     return Optional.of(factoryBuilder);
   }
 
-  private void addConstructorParameterAndTypeField(
+  /**
+   * Returns a method to proxy access to the binding's {@link Binding#bindingElement()}, which
+   * behaves according to the description in {@link Proxies}. Use here is further restricted by
+   * whether or not members injection is required, since that is not yet implemented for proxy
+   * methods, but will be added.
+   */
+  // TODO(gak): support accessibility proxies for types with injected members as well
+  private static Optional<MethodSpec> proxyMethodFor(ProvisionBinding binding) {
+    ExecutableElement executableElement = MoreElements.asExecutable(binding.bindingElement().get());
+    if (binding.membersInjectionRequest().isPresent() || !shouldGenerateProxy(executableElement)) {
+      return Optional.empty();
+    }
+    return Optional.of(createProxy(executableElement));
+  }
+
+  @CanIgnoreReturnValue
+  private FieldSpec addConstructorParameterAndTypeField(
       TypeName typeName,
       String variableName,
       TypeSpec.Builder factoryBuilder,
@@ -278,5 +305,6 @@ private void addConstructorParameterAndTypeField(
     ParameterSpec parameter = ParameterSpec.builder(typeName, variableName).build();
     constructorBuilder.addParameter(parameter);
     constructorBuilder.addCode("assert $1N != null; this.$2N = $1N;", parameter, field);
+    return field;
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/FeatureStatus.java b/compiler/src/main/java/dagger/internal/codegen/FeatureStatus.java
index 792d67e53..9ff254e2c 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FeatureStatus.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FeatureStatus.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 Google, Inc.
+ * Copyright (C) 2016 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal.codegen;
 
 /** Allows options to control how features in component processing are enabled. */
diff --git a/compiler/src/main/java/dagger/internal/codegen/ForReleasableReferencesValidator.java b/compiler/src/main/java/dagger/internal/codegen/ForReleasableReferencesValidator.java
new file mode 100644
index 000000000..b21b5e09e
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/ForReleasableReferencesValidator.java
@@ -0,0 +1,82 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
+import static com.google.common.base.Preconditions.checkArgument;
+import static dagger.internal.codegen.DaggerElements.getAnnotationMirror;
+import static dagger.internal.codegen.ErrorMessages.forReleasableReferencesValueCannotReleaseReferences;
+import static dagger.internal.codegen.ErrorMessages.forReleasableReferencesValueNotAScope;
+import static dagger.internal.codegen.MoreAnnotationMirrors.getTypeValue;
+import static dagger.internal.codegen.Scope.isScope;
+import static dagger.internal.codegen.Scope.scope;
+
+import com.google.auto.common.BasicAnnotationProcessor.ProcessingStep;
+import com.google.auto.common.MoreTypes;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.SetMultimap;
+import dagger.releasablereferences.ForReleasableReferences;
+import java.lang.annotation.Annotation;
+import java.util.Set;
+import javax.annotation.processing.Messager;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.TypeElement;
+
+/** Validates uses of {@link ForReleasableReferences @ForReleasableReferences}. */
+final class ForReleasableReferencesValidator implements ProcessingStep {
+
+  private final Messager messager;
+
+  ForReleasableReferencesValidator(Messager messager) {
+    this.messager = messager;
+  }
+
+  ValidationReport<Element> validateAnnotatedElement(Element annotatedElement) {
+    checkArgument(isAnnotationPresent(annotatedElement, ForReleasableReferences.class));
+    ValidationReport.Builder<Element> report = ValidationReport.about(annotatedElement);
+    AnnotationMirror annotation =
+        getAnnotationMirror(annotatedElement, ForReleasableReferences.class).get();
+    TypeElement scopeType = MoreTypes.asTypeElement(getTypeValue(annotation, "value"));
+    if (!isScope(scopeType)) {
+      report.addError(
+          forReleasableReferencesValueNotAScope(scopeType), annotatedElement, annotation);
+    } else if (!scope(scopeType).canReleaseReferences()) {
+      report.addError(
+          forReleasableReferencesValueCannotReleaseReferences(scopeType),
+          annotatedElement,
+          annotation);
+    }
+    return report.build();
+  }
+
+  @Override
+  public Set<? extends Class<? extends Annotation>> annotations() {
+    return ImmutableSet.of(ForReleasableReferences.class);
+  }
+
+  @Override
+  public Set<Element> process(
+      SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
+    elementsByAnnotation
+        .get(ForReleasableReferences.class)
+        .stream()
+        .map(this::validateAnnotatedElement)
+        .forEach(report -> report.printMessagesTo(messager));
+    return ImmutableSet.of();
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/Formatter.java b/compiler/src/main/java/dagger/internal/codegen/Formatter.java
index 8eb4a2006..ce1a292f8 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Formatter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Formatter.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Google, Inc.
+ * Copyright (C) 2014 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,13 +13,15 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal.codegen;
 
+import static com.google.common.base.Preconditions.checkElementIndex;
+import static dagger.internal.codegen.ErrorMessages.INDENT;
+
 import com.google.common.base.Function;
 import com.google.common.collect.Iterables;
 
-import static dagger.internal.codegen.ErrorMessages.INDENT;
-
 /**
  * A formatter which transforms an instance of a particular type into a string
  * representation.
@@ -36,16 +38,16 @@
   public abstract String format(T object);
 
   /**
-   * Performs the transformation of an object into a string representation in
-   * conformity with the {@link Function}{@code <T, String>} contract, delegating
-   * to {@link #format(Object)}.
+   * Performs the transformation of an object into a string representation in conformity with the
+   * {@link Function}{@code <T, String>} contract, delegating to {@link #format(Object)}.
    *
-   * @deprecated Call {@link #format(T)} instead.  This method exists to make
-   * formatters easy to use when functions are required, but shouldn't be called directly.
+   * @deprecated Call {@link #format(Object)} instead. This method exists to make formatters easy to
+   *     use when functions are required, but shouldn't be called directly.
    */
   @SuppressWarnings("javadoc")
   @Deprecated
-  @Override final public String apply(T object) {
+  @Override
+  public final String apply(T object) {
     return format(object);
   }
 
@@ -84,4 +86,17 @@ private void appendIndent(StringBuilder builder, int indentLevel) {
       builder.append(INDENT);
     }
   }
+
+  protected String formatArgumentInList(int index, int size, CharSequence name) {
+    checkElementIndex(index, size);
+    StringBuilder builder = new StringBuilder();
+    if (index > 0) {
+      builder.append("…, ");
+    }
+    builder.append(name);
+    if (index < size - 1) {
+      builder.append(", …");
+    }
+    return builder.toString();
+  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/FrameworkDependency.java b/compiler/src/main/java/dagger/internal/codegen/FrameworkDependency.java
index 1b941e475..0cd593d6b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FrameworkDependency.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FrameworkDependency.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 Google, Inc.
+ * Copyright (C) 2016 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,22 +13,11 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal.codegen;
 
 import com.google.auto.value.AutoValue;
-import com.google.common.base.Function;
-import com.google.common.base.Functions;
-import com.google.common.collect.FluentIterable;
-import com.google.common.collect.ImmutableList;
-import com.google.common.collect.ImmutableMap;
-import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.ImmutableSetMultimap;
-import com.google.common.collect.Maps;
-import java.util.Collection;
 import javax.inject.Provider;
-import javax.lang.model.element.Element;
-
-import static com.google.common.collect.Iterables.getOnlyElement;
 
 /**
  * The framework class and binding key for a resolved dependency of a binding. If a binding has
@@ -59,126 +48,16 @@
    */
   abstract BindingKey bindingKey();
 
-  /**
-   * The framework class to use for these requests.
-   */
-  abstract Class<?> frameworkClass();
-
-  /**
-   * The dependency requests that are all satisfied by one framework instance.
-   */
-  abstract ImmutableSet<DependencyRequest> dependencyRequests();
-
-  /**
-   * The framework dependencies of {@code binding}. There will be one element for each
-   * different binding key in the <em>{@linkplain Binding#unresolved() unresolved}</em> version of
-   * {@code binding}.
-   *
-   * <p>For example, given the following modules:
-   * <pre><code>
-   *   {@literal @Module} abstract class {@literal BaseModule<T>} {
-   *     {@literal @Provides} Foo provideFoo(T t, String string) {
-   *       return …;
-   *     }
-   *   }
-   *
-   *   {@literal @Module} class StringModule extends {@literal BaseModule<String>} {}
-   * </code></pre>
-   *
-   * Both dependencies of {@code StringModule.provideFoo} have the same binding key:
-   * {@code String}. But there are still two dependencies, because in the unresolved binding they
-   * have different binding keys:
-   *
-   * <dl>
-   * <dt>{@code T} <dd>{@code String t}
-   * <dt>{@code String} <dd>{@code String string}
-   * </dl>
-   * 
-   * <p>Note that the sets returned by this method when called on the same binding will be equal,
-   * and their elements will be in the same order.
-   */
-  /* TODO(dpb): The stable-order postcondition is actually hard to verify in code for two equal
-   * instances of Binding, because it really depends on the order of the binding's dependencies,
-   * and two equal instances of Binding may have the same dependencies in a different order. */
-  static ImmutableSet<FrameworkDependency> frameworkDependenciesForBinding(Binding binding) {
-    DependencyRequestMapper dependencyRequestMapper =
-        DependencyRequestMapper.forBindingType(binding.bindingType());
-    ImmutableSet.Builder<FrameworkDependency> frameworkDependencies = ImmutableSet.builder();
-    for (Collection<DependencyRequest> requests : groupByUnresolvedKey(binding)) {
-      frameworkDependencies.add(
-          new AutoValue_FrameworkDependency(
-              getOnlyElement(
-                  FluentIterable.from(requests)
-                      .transform(DependencyRequest.BINDING_KEY_FUNCTION)
-                      .toSet()),
-              dependencyRequestMapper.getFrameworkClass(requests),
-              ImmutableSet.copyOf(requests)));
-    }
-    return frameworkDependencies.build();
-  }
-
-  /** Indexes {@code dependencies} by their {@link #dependencyRequests()}. */
-  static ImmutableMap<DependencyRequest, FrameworkDependency> indexByDependencyRequest(
-      Iterable<FrameworkDependency> dependencies) {
-    ImmutableMap.Builder<DependencyRequest, FrameworkDependency> frameworkDependencyMap =
-        ImmutableMap.builder();
-    for (FrameworkDependency dependency : dependencies) {
-      for (DependencyRequest request : dependency.dependencyRequests()) {
-        frameworkDependencyMap.put(request, dependency);
-      }
-    }
-    return frameworkDependencyMap.build();
-  }
+  /** The binding type of the framework dependency. */
+  abstract BindingType bindingType();
 
-  /**
-   * Groups {@code binding}'s implicit dependencies by their binding key, using the dependency keys
-   * from the {@link Binding#unresolved()} binding if it exists.
-   */
-  private static ImmutableList<Collection<DependencyRequest>> groupByUnresolvedKey(
-      Binding binding) {
-    // If the binding has no unresolved version, just group the dependencies by binding key.
-    if (!binding.unresolved().isPresent()) {
-      return groupByKey(binding, Functions.<DependencyRequest>identity());
-    }
-
-    // Group the unresolved dependencies, replacing each one with its resolved version by looking it
-    // up by request element.
-    final ImmutableMap<Element, DependencyRequest> resolvedDependencies =
-        Maps.uniqueIndex(
-            binding.implicitDependencies(),
-            new Function<DependencyRequest, Element>() {
-              @Override
-              public Element apply(DependencyRequest dependencyRequest) {
-                return dependencyRequest.requestElement();
-              }
-            });
-    return groupByKey(
-        binding.unresolved().get(),
-        new Function<DependencyRequest, DependencyRequest>() {
-          @Override
-          public DependencyRequest apply(DependencyRequest unresolvedRequest) {
-            return resolvedDependencies.get(unresolvedRequest.requestElement());
-          }
-        });
+  /** The framework class to use for these requests. */
+  final Class<?> frameworkClass() {
+    return bindingType().frameworkClass();
   }
 
-  /**
-   * Groups a binding's dependency requests by their binding key.
-   *
-   * @param transformer applied to each dependency before inserting into the group
-   */
-  private static ImmutableList<Collection<DependencyRequest>> groupByKey(
-      Binding binding, Function<DependencyRequest, DependencyRequest> transformer) {
-    ImmutableSetMultimap.Builder<BindingKey, DependencyRequest> dependenciesByKeyBuilder =
-        ImmutableSetMultimap.builder();
-    for (DependencyRequest dependency : binding.implicitDependencies()) {
-      dependenciesByKeyBuilder.put(dependency.bindingKey(), transformer.apply(dependency));
-    }
-    return ImmutableList.copyOf(
-        dependenciesByKeyBuilder
-            .orderValuesBy(SourceFiles.DEPENDENCY_ORDERING)
-            .build()
-            .asMap()
-            .values());
+  /** Returns a new instance with the given key and type. */
+  static FrameworkDependency create(BindingKey bindingKey, BindingType bindingType) {
+    return new AutoValue_FrameworkDependency(bindingKey, bindingType);
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java b/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java
index a508eded3..18c1126dd 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Google, Inc.
+ * Copyright (C) 2014 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,14 +13,15 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal.codegen;
 
 import com.google.auto.value.AutoValue;
 import com.google.common.base.CaseFormat;
-import com.google.common.base.Optional;
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.ParameterizedTypeName;
 import com.squareup.javapoet.TypeName;
+import java.util.Optional;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ElementVisitor;
 import javax.lang.model.element.ExecutableElement;
@@ -68,7 +69,8 @@ static FrameworkField create(
    */
   static FrameworkField forResolvedBindings(
       ResolvedBindings resolvedBindings, Optional<ClassName> frameworkClass) {
-    return create(frameworkClass.or(ClassName.get(resolvedBindings.frameworkClass())),
+    return create(
+        frameworkClass.orElse(ClassName.get(resolvedBindings.frameworkClass())),
         TypeName.get(fieldValueType(resolvedBindings)),
         frameworkFieldName(resolvedBindings));
   }
@@ -91,8 +93,8 @@ private static TypeMirror fieldValueType(ResolvedBindings resolvedBindings) {
   private static String frameworkFieldName(ResolvedBindings resolvedBindings) {
     if (resolvedBindings.bindingKey().kind().equals(BindingKey.Kind.CONTRIBUTION)) {
       ContributionBinding binding = resolvedBindings.contributionBinding();
-      if (!binding.isSyntheticBinding()) {
-        return BINDING_ELEMENT_NAME.visit(binding.bindingElement(), binding);
+      if (binding.bindingElement().isPresent()) {
+        return BINDING_ELEMENT_NAME.visit(binding.bindingElement().get(), binding);
       }
     }
     return BindingVariableNamer.name(resolvedBindings.binding());
diff --git a/compiler/src/main/java/dagger/internal/codegen/FrameworkType.java b/compiler/src/main/java/dagger/internal/codegen/FrameworkType.java
new file mode 100644
index 000000000..15cb4fccf
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/FrameworkType.java
@@ -0,0 +1,118 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.base.CaseFormat.UPPER_CAMEL;
+import static com.google.common.base.CaseFormat.UPPER_UNDERSCORE;
+import static dagger.internal.codegen.DependencyRequest.Kind.INSTANCE;
+
+import com.google.common.util.concurrent.Futures;
+import com.squareup.javapoet.CodeBlock;
+import dagger.MembersInjector;
+import dagger.internal.DoubleCheck;
+import dagger.internal.ProviderOfLazy;
+import dagger.producers.Produced;
+import dagger.producers.Producer;
+import dagger.producers.internal.Producers;
+import javax.inject.Provider;
+
+/** One of the core types initialized as fields in a generated component. */
+enum FrameworkType {
+  /** A {@link Provider}. */
+  PROVIDER {
+    @Override
+    CodeBlock to(DependencyRequest.Kind requestKind, CodeBlock from) {
+      switch (requestKind) {
+        case INSTANCE:
+          return CodeBlock.of("$L.get()", from);
+
+        case LAZY:
+          return CodeBlock.of("$T.lazy($L)", DoubleCheck.class, from);
+
+        case PROVIDER:
+          return from;
+
+        case PROVIDER_OF_LAZY:
+          return CodeBlock.of("$T.create($L)", ProviderOfLazy.class, from);
+
+        case PRODUCER:
+          return CodeBlock.of("$T.producerFromProvider($L)", Producers.class, from);
+
+        case FUTURE:
+          return CodeBlock.of("$T.immediateFuture($L)", Futures.class, to(INSTANCE, from));
+
+        case PRODUCED:
+          return CodeBlock.of("$T.successful($L)", Produced.class, to(INSTANCE, from));
+
+        default:
+          throw new IllegalArgumentException(
+              String.format("Cannot request a %s from a %s", requestKind, this));
+      }
+    }
+  },
+
+  /** A {@link Producer}. */
+  PRODUCER {
+    @Override
+    CodeBlock to(DependencyRequest.Kind requestKind, CodeBlock from) {
+      switch (requestKind) {
+        case FUTURE:
+          return CodeBlock.of("$L.get()", from);
+
+        case PRODUCER:
+          return from;
+
+        default:
+          throw new IllegalArgumentException(
+              String.format("Cannot request a %s from a %s", requestKind, this));
+      }
+    }
+  },
+
+  /** A {@link MembersInjector}. */
+  MEMBERS_INJECTOR {
+    @Override
+    CodeBlock to(DependencyRequest.Kind requestKind, CodeBlock from) {
+      switch (requestKind) {
+        case MEMBERS_INJECTOR:
+          return from;
+
+        default:
+          throw new IllegalArgumentException(
+              String.format("Cannot request a %s from a %s", requestKind, this));
+      }
+    }
+  },
+  ;
+
+  /**
+   * Returns an expression that evaluates to a requested object given an expression that evaluates
+   * to an instance of this framework type.
+   *
+   * @param requestKind the kind of {@link DependencyRequest} that the returned expression can
+   *     satisfy
+   * @param from an expression that evaluates to an instance of this framework type
+   * @throws IllegalArgumentException if a valid expression cannot be generated for {@code
+   *     requestKind}
+   */
+  abstract CodeBlock to(DependencyRequest.Kind requestKind, CodeBlock from);
+
+  @Override
+  public String toString() {
+    return UPPER_UNDERSCORE.to(UPPER_CAMEL, super.toString());
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/FrameworkTypes.java b/compiler/src/main/java/dagger/internal/codegen/FrameworkTypes.java
index 84aca3bb7..19d2eda2d 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FrameworkTypes.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FrameworkTypes.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,8 +13,11 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal.codegen;
 
+import static com.google.auto.common.MoreTypes.isType;
+
 import com.google.auto.common.MoreTypes;
 import com.google.common.collect.ImmutableSet;
 import dagger.Lazy;
@@ -25,8 +28,6 @@
 import javax.inject.Provider;
 import javax.lang.model.type.TypeMirror;
 
-import static com.google.auto.common.MoreTypes.isType;
-
 /**
  * A collection of utility methods for dealing with Dagger framework types. A framework type is any
  * type that the framework itself defines.
diff --git a/compiler/src/main/java/dagger/internal/codegen/HasBindingMembers.java b/compiler/src/main/java/dagger/internal/codegen/HasBindingMembers.java
new file mode 100644
index 000000000..bc260d65d
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/HasBindingMembers.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import javax.annotation.Nullable;
+
+/** An object which associates a {@link MemberSelect} instance with a {@link BindingKey}. */
+// TODO(gak): this isn't a particularly good abstraction. This should go away when MS is reworked.
+interface HasBindingMembers {
+
+  /**
+   * Returns the {@link MemberSelect} associated with the given {@link BindingKey} or {@code null}
+   * if no association exists.
+   */
+  @Nullable
+  MemberSelect getMemberSelect(BindingKey bindingKey);
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java b/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
index 77f52af40..2169c4ba5 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Google, Inc.
+ * Copyright (C) 2014 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,13 +13,17 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal.codegen;
 
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.base.Preconditions.checkState;
+import static dagger.internal.codegen.InjectionAnnotations.injectedConstructors;
+import static dagger.internal.codegen.SourceFiles.generatedClassNameForBinding;
+
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
-import com.google.common.base.Optional;
-import com.google.common.base.Predicate;
-import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Maps;
@@ -31,6 +35,7 @@
 import java.util.ArrayDeque;
 import java.util.Deque;
 import java.util.Map;
+import java.util.Optional;
 import java.util.Set;
 import javax.annotation.processing.Messager;
 import javax.inject.Inject;
@@ -42,14 +47,6 @@
 import javax.lang.model.util.Types;
 import javax.tools.Diagnostic.Kind;
 
-import static com.google.auto.common.MoreElements.isAnnotationPresent;
-import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
-import static com.google.common.base.Preconditions.checkState;
-import static dagger.internal.codegen.MembersInjectionBinding.Strategy.INJECT_MEMBERS;
-import static dagger.internal.codegen.SourceFiles.generatedClassNameForBinding;
-import static javax.lang.model.util.ElementFilter.constructorsIn;
-
 /**
  * Maintains the collection of provision bindings from {@link Inject} constructors and members
  * injection bindings from {@link Inject} fields and methods known to the annotation processor.
@@ -66,6 +63,7 @@
   private final Key.Factory keyFactory;
   private final ProvisionBinding.Factory provisionBindingFactory;
   private final MembersInjectionBinding.Factory membersInjectionBindingFactory;
+  private final CompilerOptions compilerOptions;
 
   final class BindingsCollection<B extends Binding> {
     private final BindingType bindingType;
@@ -108,7 +106,8 @@ void tryRegisterBinding(B binding, boolean warnIfNotAlreadyGenerated) {
     void tryToGenerateBinding(B binding, boolean warnIfNotAlreadyGenerated) {
       if (shouldGenerateBinding(binding, generatedClassNameForBinding(binding))) {
         bindingsRequiringGeneration.offer(binding);
-        if (warnIfNotAlreadyGenerated) {
+        if (compilerOptions.warnIfInjectionFactoryNotGeneratedUpstream()
+            && warnIfNotAlreadyGenerated) {
           messager.printMessage(
               Kind.NOTE,
               String.format(
@@ -133,7 +132,7 @@ private void tryToCacheBinding(B binding) {
       // We only cache resolved bindings or unresolved bindings w/o type arguments.
       // Unresolved bindings w/ type arguments aren't valid for the object graph.
       if (binding.unresolved().isPresent()
-          || binding.bindingTypeElement().getTypeParameters().isEmpty()) {
+          || binding.bindingTypeElement().get().getTypeParameters().isEmpty()) {
         Key key = binding.key();
         Binding previousValue = bindingsByKey.put(key, binding);
         checkState(previousValue == null || binding.equals(previousValue),
@@ -155,7 +154,8 @@ private void tryToCacheBinding(B binding) {
       InjectValidator injectValidator,
       Key.Factory keyFactory,
       ProvisionBinding.Factory provisionBindingFactory,
-      MembersInjectionBinding.Factory membersInjectionBindingFactory) {
+      MembersInjectionBinding.Factory membersInjectionBindingFactory,
+      CompilerOptions compilerOptions) {
     this.elements = elements;
     this.types = types;
     this.messager = messager;
@@ -163,6 +163,7 @@ private void tryToCacheBinding(B binding) {
     this.keyFactory = keyFactory;
     this.provisionBindingFactory = provisionBindingFactory;
     this.membersInjectionBindingFactory = membersInjectionBindingFactory;
+    this.compilerOptions = compilerOptions;
   }
 
   /**
@@ -215,7 +216,7 @@ private void registerBinding(MembersInjectionBinding binding, boolean warnIfNotA
 
   @CanIgnoreReturnValue
   Optional<ProvisionBinding> tryRegisterConstructor(ExecutableElement constructorElement) {
-    return tryRegisterConstructor(constructorElement, Optional.<TypeMirror>absent(), false);
+    return tryRegisterConstructor(constructorElement, Optional.empty(), false);
   }
 
   @CanIgnoreReturnValue
@@ -237,17 +238,17 @@ private void registerBinding(MembersInjectionBinding binding, boolean warnIfNotA
       ProvisionBinding binding =
           provisionBindingFactory.forInjectConstructor(constructorElement, resolvedType);
       registerBinding(binding, warnIfNotAlreadyGenerated);
-      if (membersInjectionBindingFactory.hasInjectedMembers(type)) {
+      if (membersInjectionBindingFactory.hasInjectedMembersIn(type)) {
         tryRegisterMembersInjectedType(typeElement, resolvedType, warnIfNotAlreadyGenerated);
       }
       return Optional.of(binding);
     }
-    return Optional.absent();
+    return Optional.empty();
   }
 
   @CanIgnoreReturnValue
   Optional<MembersInjectionBinding> tryRegisterMembersInjectedType(TypeElement typeElement) {
-    return tryRegisterMembersInjectedType(typeElement, Optional.<TypeMirror>absent(), false);
+    return tryRegisterMembersInjectedType(typeElement, Optional.empty(), false);
   }
 
   @CanIgnoreReturnValue
@@ -269,19 +270,19 @@ private void registerBinding(MembersInjectionBinding binding, boolean warnIfNotA
       MembersInjectionBinding binding =
           membersInjectionBindingFactory.forInjectedType(type, resolvedType);
       registerBinding(binding, warnIfNotAlreadyGenerated);
-      if (binding.parentKey().isPresent() && binding.injectionStrategy().equals(INJECT_MEMBERS)) {
+      if (binding.parentKey().isPresent() && !binding.injectionSites().isEmpty()) {
         getOrFindMembersInjectionBinding(binding.parentKey().get());
       }
       return Optional.of(binding);
     }
-    return Optional.absent();
+    return Optional.empty();
   }
 
   @CanIgnoreReturnValue
   Optional<ProvisionBinding> getOrFindProvisionBinding(Key key) {
     checkNotNull(key);
     if (!key.isValidImplicitProvisionKey(types)) {
-      return Optional.absent();
+      return Optional.empty();
     }
     ProvisionBinding binding = provisionBindings.getBinding(key);
     if (binding != null) {
@@ -294,7 +295,7 @@ private void registerBinding(MembersInjectionBinding binding, boolean warnIfNotA
     switch (injectConstructors.size()) {
       case 0:
         // No constructor found.
-        return Optional.absent();
+        return Optional.empty();
       case 1:
         return tryRegisterConstructor(
             Iterables.getOnlyElement(injectConstructors), Optional.of(key.type()), true);
@@ -304,18 +305,6 @@ private void registerBinding(MembersInjectionBinding binding, boolean warnIfNotA
     }
   }
 
-  private ImmutableSet<ExecutableElement> injectedConstructors(TypeElement element) {
-    return FluentIterable.from(constructorsIn(element.getEnclosedElements()))
-        .filter(
-            new Predicate<ExecutableElement>() {
-              @Override
-              public boolean apply(ExecutableElement constructor) {
-                return isAnnotationPresent(constructor, Inject.class);
-              }
-            })
-        .toSet();
-  }
-
   /**
    * Returns a {@link MembersInjectionBinding} for {@code key}. If none has been registered yet,
    * registers one, along with all necessary members injection bindings for superclasses.
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/InjectProcessingStep.java
index 77f64ed12..2343589f0 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectProcessingStep.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Google, Inc.
+ * Copyright (C) 2014 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,16 +13,15 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal.codegen;
 
 import com.google.auto.common.BasicAnnotationProcessor;
 import com.google.auto.common.MoreElements;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.SetMultimap;
-
 import java.lang.annotation.Annotation;
 import java.util.Set;
-
 import javax.inject.Inject;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectValidator.java b/compiler/src/main/java/dagger/internal/codegen/InjectValidator.java
index a6b4f0e0c..4230e3d2f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectValidator.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Google, Inc.
+ * Copyright (C) 2014 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,27 +13,8 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package dagger.internal.codegen;
 
-import com.google.auto.common.MoreElements;
-import com.google.auto.common.MoreTypes;
-import com.google.common.base.Optional;
-import com.google.common.base.Predicate;
-import com.google.common.collect.FluentIterable;
-import com.google.common.collect.ImmutableSet;
-import java.util.Set;
-import javax.inject.Inject;
-import javax.lang.model.element.AnnotationMirror;
-import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.Modifier;
-import javax.lang.model.element.TypeElement;
-import javax.lang.model.element.VariableElement;
-import javax.lang.model.type.TypeKind;
-import javax.lang.model.type.TypeMirror;
-import javax.lang.model.util.ElementFilter;
-import javax.lang.model.util.Elements;
-import javax.lang.model.util.Types;
-import javax.tools.Diagnostic;
+package dagger.internal.codegen;
 
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static dagger.internal.codegen.Accessibility.isElementAccessibleFromOwnPackage;
@@ -50,19 +31,38 @@
 import static dagger.internal.codegen.ErrorMessages.MULTIPLE_SCOPES;
 import static dagger.internal.codegen.ErrorMessages.PRIVATE_INJECT_FIELD;
 import static dagger.internal.codegen.ErrorMessages.PRIVATE_INJECT_METHOD;
-import static dagger.internal.codegen.ErrorMessages.provisionMayNotDependOnProducerType;
 import static dagger.internal.codegen.ErrorMessages.QUALIFIER_ON_INJECT_CONSTRUCTOR;
 import static dagger.internal.codegen.ErrorMessages.SCOPE_ON_INJECT_CONSTRUCTOR;
 import static dagger.internal.codegen.ErrorMessages.STATIC_INJECT_FIELD;
 import static dagger.internal.codegen.ErrorMessages.STATIC_INJECT_METHOD;
+import static dagger.internal.codegen.ErrorMessages.provisionMayNotDependOnProducerType;
 import static dagger.internal.codegen.InjectionAnnotations.getQualifiers;
 import static dagger.internal.codegen.InjectionAnnotations.getScopes;
+import static dagger.internal.codegen.InjectionAnnotations.injectedConstructors;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.STATIC;
 import static javax.lang.model.type.TypeKind.DECLARED;
 
+import com.google.auto.common.MoreElements;
+import com.google.auto.common.MoreTypes;
+import com.google.common.collect.ImmutableSet;
+import java.util.Optional;
+import java.util.Set;
+import javax.inject.Inject;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.TypeKind;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.ElementFilter;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
+import javax.tools.Diagnostic;
+
 /**
  * A {@linkplain ValidationReport validator} for {@link Inject}-annotated elements and the types
  * that contain them.
@@ -77,7 +77,7 @@
   private final Optional<Diagnostic.Kind> privateAndStaticInjectionDiagnosticKind;
 
   InjectValidator(Types types, Elements elements, CompilerOptions compilerOptions) {
-    this(types, elements, compilerOptions, Optional.<Diagnostic.Kind>absent());
+    this(types, elements, compilerOptions, Optional.empty());
   }
 
   private InjectValidator(
@@ -131,7 +131,8 @@ InjectValidator whenGeneratingCode() {
     if (throwsCheckedExceptions(constructorElement)) {
       builder.addItem(
           CHECKED_EXCEPTIONS_ON_CONSTRUCTORS,
-          privateAndStaticInjectionDiagnosticKind.or(compilerOptions.privateMemberValidationKind()),
+          privateAndStaticInjectionDiagnosticKind.orElse(
+              compilerOptions.privateMemberValidationKind()),
           constructorElement);
     }
 
@@ -142,7 +143,8 @@ InjectValidator whenGeneratingCode() {
     if (!Accessibility.isElementAccessibleFromOwnPackage(enclosingElement)) {
       builder.addItem(
           INJECT_INTO_PRIVATE_CLASS,
-          privateAndStaticInjectionDiagnosticKind.or(compilerOptions.privateMemberValidationKind()),
+          privateAndStaticInjectionDiagnosticKind.orElse(
+              compilerOptions.privateMemberValidationKind()),
           constructorElement);
     }
 
@@ -156,13 +158,7 @@ InjectValidator whenGeneratingCode() {
     }
 
     // This is computationally expensive, but probably preferable to a giant index
-    FluentIterable<ExecutableElement> injectConstructors = FluentIterable.from(
-        ElementFilter.constructorsIn(enclosingElement.getEnclosedElements()))
-            .filter(new Predicate<ExecutableElement>() {
-              @Override public boolean apply(ExecutableElement input) {
-                return isAnnotationPresent(input, Inject.class);
-              }
-            });
+    ImmutableSet<ExecutableElement> injectConstructors = injectedConstructors(enclosingElement);
 
     if (injectConstructors.size() > 1) {
       builder.addError(MULTIPLE_INJECT_CONSTRUCTORS, constructorElement);
@@ -188,14 +184,16 @@ InjectValidator whenGeneratingCode() {
     if (modifiers.contains(PRIVATE)) {
       builder.addItem(
           PRIVATE_INJECT_FIELD,
-          privateAndStaticInjectionDiagnosticKind.or(compilerOptions.privateMemberValidationKind()),
+          privateAndStaticInjectionDiagnosticKind.orElse(
+              compilerOptions.privateMemberValidationKind()),
           fieldElement);
     }
 
     if (modifiers.contains(STATIC)) {
       builder.addItem(
           STATIC_INJECT_FIELD,
-          privateAndStaticInjectionDiagnosticKind.or(compilerOptions.staticMemberValidationKind()),
+          privateAndStaticInjectionDiagnosticKind.orElse(
+              compilerOptions.staticMemberValidationKind()),
           fieldElement);
     }
 
@@ -223,14 +221,16 @@ InjectValidator whenGeneratingCode() {
     if (modifiers.contains(PRIVATE)) {
       builder.addItem(
           PRIVATE_INJECT_METHOD,
-          privateAndStaticInjectionDiagnosticKind.or(compilerOptions.privateMemberValidationKind()),
+          privateAndStaticInjectionDiagnosticKind.orElse(
+              compilerOptions.privateMemberValidationKind()),
           methodElement);
     }
 
     if (modifiers.contains(STATIC)) {
       builder.addItem(
           STATIC_INJECT_METHOD,
-          privateAndStaticInjectionDiagnosticKind.or(compilerOptions.staticMemberValidationKind()),
+          privateAndStaticInjectionDiagnosticKind.orElse(
+              compilerOptions.staticMemberValidationKind()),
           methodElement);
     }
 
@@ -276,12 +276,13 @@ InjectValidator whenGeneratingCode() {
         }
       }
     }
-    // We can't use MembersInjectionBinding.Factory#hasInjectedMembers because that assumes this
+    // We can't use MembersInjectionBinding.Factory#hasInjectedMembersIn because that assumes this
     // binding already validates, so we just check it again here.
     if (hasInjectedMembers && !isElementAccessibleFromOwnPackage(typeElement)) {
       builder.addItem(
           INJECT_INTO_PRIVATE_CLASS,
-          privateAndStaticInjectionDiagnosticKind.or(compilerOptions.privateMemberValidationKind()),
+          privateAndStaticInjectionDiagnosticKind.orElse(
+              compilerOptions.privateMemberValidationKind()),
           typeElement);
     }
     TypeMirror superclass = typeElement.getSuperclass();
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectionAnnotations.java b/compiler/src/main/java/dagger/internal/codegen/InjectionAnnotations.java
index c911fda7e..c1d31bacc 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectionAnnotations.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectionAnnotations.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Google, Inc.
+ * Copyright (C) 2014 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,17 +13,24 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal.codegen;
 
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
+import static com.google.common.base.Preconditions.checkNotNull;
+import static javax.lang.model.util.ElementFilter.constructorsIn;
+
 import com.google.auto.common.AnnotationMirrors;
-import com.google.common.base.Optional;
+import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableSet;
+import java.util.Optional;
+import javax.inject.Inject;
 import javax.inject.Qualifier;
 import javax.inject.Scope;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
-
-import static com.google.common.base.Preconditions.checkNotNull;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
 
 /**
  * Utilities relating to annotations defined in the {@code javax.inject} package.
@@ -37,7 +44,7 @@
     ImmutableSet<? extends AnnotationMirror> qualifierAnnotations = getQualifiers(e);
     switch (qualifierAnnotations.size()) {
       case 0:
-        return Optional.absent();
+        return Optional.empty();
       case 1:
         return Optional.<AnnotationMirror>of(qualifierAnnotations.iterator().next());
       default:
@@ -54,5 +61,12 @@
     return AnnotationMirrors.getAnnotatedAnnotations(element, Scope.class);
   }
 
+  /** Returns the constructors in {@code type} that are annotated with {@link Inject}. */
+  static ImmutableSet<ExecutableElement> injectedConstructors(TypeElement type) {
+    return FluentIterable.from(constructorsIn(type.getEnclosedElements()))
+        .filter(constructor -> isAnnotationPresent(constructor, Inject.class))
+        .toSet();
+  }
+
   private InjectionAnnotations() {}
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/Key.java b/compiler/src/main/java/dagger/internal/codegen/Key.java
index 9ca9ef07f..058c09f60 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Key.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Key.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Google, Inc.
+ * Copyright (C) 2014 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,30 +13,54 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal.codegen;
 
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
+import static com.google.auto.common.MoreTypes.asExecutable;
+import static com.google.auto.common.MoreTypes.isType;
+import static com.google.auto.common.MoreTypes.isTypeOf;
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.collect.Iterables.getOnlyElement;
+import static dagger.internal.codegen.InjectionAnnotations.getQualifier;
+import static dagger.internal.codegen.MapKeys.getMapKey;
+import static dagger.internal.codegen.MapKeys.getUnwrappedMapKeyType;
+import static dagger.internal.codegen.MoreAnnotationMirrors.unwrapOptionalEquivalence;
+import static dagger.internal.codegen.MoreAnnotationMirrors.wrapOptionalInEquivalence;
+import static dagger.internal.codegen.Optionals.firstPresent;
+import static dagger.internal.codegen.Util.toImmutableSet;
+import static javax.lang.model.element.ElementKind.METHOD;
+
 import com.google.auto.common.AnnotationMirrors;
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
+import com.google.auto.value.extension.memoized.Memoized;
 import com.google.common.base.Equivalence;
-import com.google.common.base.Function;
-import com.google.common.base.MoreObjects;
-import com.google.common.base.Optional;
+import com.google.common.base.Joiner;
+import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ImmutableSetMultimap;
-import com.google.common.collect.Iterables;
 import com.google.common.collect.Multimaps;
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.Binds;
+import dagger.BindsOptionalOf;
 import dagger.Multibindings;
 import dagger.multibindings.Multibinds;
 import dagger.producers.Produced;
 import dagger.producers.Producer;
 import dagger.producers.Production;
 import dagger.producers.internal.ProductionImplementation;
+import dagger.producers.monitoring.ProductionComponentMonitor;
+import dagger.releasablereferences.ForReleasableReferences;
+import dagger.releasablereferences.ReleasableReferenceManager;
+import dagger.releasablereferences.TypedReleasableReferenceManager;
 import java.util.Map;
+import java.util.Optional;
 import java.util.Set;
 import java.util.concurrent.Executor;
+import java.util.stream.Stream;
 import javax.inject.Provider;
 import javax.inject.Qualifier;
 import javax.lang.model.element.AnnotationMirror;
@@ -53,17 +77,6 @@
 import javax.lang.model.util.SimpleTypeVisitor6;
 import javax.lang.model.util.Types;
 
-import static com.google.auto.common.MoreElements.isAnnotationPresent;
-import static com.google.auto.common.MoreTypes.asExecutable;
-import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
-import static dagger.internal.codegen.InjectionAnnotations.getQualifier;
-import static dagger.internal.codegen.MapKeys.getMapKey;
-import static dagger.internal.codegen.MapKeys.getUnwrappedMapKeyType;
-import static dagger.internal.codegen.MoreAnnotationMirrors.unwrapOptionalEquivalence;
-import static dagger.internal.codegen.MoreAnnotationMirrors.wrapOptionalInEquivalence;
-import static javax.lang.model.element.ElementKind.METHOD;
-
 /**
  * Represents a unique combination of {@linkplain TypeMirror type} and
  * {@linkplain Qualifier qualifier} to which binding can occur.
@@ -98,32 +111,102 @@
   abstract Equivalence.Wrapper<TypeMirror> wrappedType();
 
   /**
-   * Absent except for multibinding contributions. Each multibound map and set is represented by a
-   * {@linkplain ProvisionBinding.Factory#syntheticMultibinding(DependencyRequest, Iterable)
-   * synthetic binding} that depends on the specific contributions to that map or set. Each such
-   * contribution binding therefore needs a key that identifies the specific binding, and not only
-   * the qualified type that is bound. For those bindings, this is the binding method element.
+   * Distinguishes keys for multibinding contributions that share a {@link #type()} and {@link
+   * #qualifier()}.
+   *
+   * <p>Each multibound map and set has a {@linkplain
+   * ProvisionBinding.Factory#syntheticMultibinding(Key, Iterable) synthetic multibinding} that
+   * depends on the specific contributions to that map or set using keys that identify those
+   * multibinding contributions.
+   *
+   * <p>Absent except for multibinding contributions.
    */
-  abstract Optional<BindingMethodIdentifier> bindingMethodIdentifier();
+  abstract Optional<MultibindingContributionIdentifier> multibindingContributionIdentifier();
+  
+  abstract Builder toBuilder();
+
+  @Memoized
+  @Override
+  public abstract int hashCode();
+
+  static Builder builder(TypeMirror type) {
+    return new AutoValue_Key.Builder().type(type);
+  }
+
+  @AutoValue.Builder
+  abstract static class Builder {
+    abstract Builder wrappedType(Equivalence.Wrapper<TypeMirror> wrappedType);
+
+    Builder type(TypeMirror type) {
+      return wrappedType(MoreTypes.equivalence().wrap(checkNotNull(type)));
+    }
+
+    abstract Builder wrappedQualifier(
+        Optional<Equivalence.Wrapper<AnnotationMirror>> wrappedQualifier);
+
+    abstract Builder wrappedQualifier(Equivalence.Wrapper<AnnotationMirror> wrappedQualifier);
+
+    Builder qualifier(AnnotationMirror qualifier) {
+      return wrappedQualifier(AnnotationMirrors.equivalence().wrap(checkNotNull(qualifier)));
+    }
+
+    Builder qualifier(Optional<AnnotationMirror> qualifier) {
+      return wrappedQualifier(wrapOptionalInEquivalence(checkNotNull(qualifier)));
+    }
+
+    Builder qualifier(TypeElement annotationType) {
+      return qualifier(SimpleAnnotationMirror.of(annotationType));
+    }
+
+    abstract Builder multibindingContributionIdentifier(
+        Optional<MultibindingContributionIdentifier> identifier);
+
+    abstract Builder multibindingContributionIdentifier(
+        MultibindingContributionIdentifier identifier);
+
+    abstract Key build();
+  }
+  
+  /**
+   * An object that identifies a multibinding contribution method and the module class that
+   * contributes it to the graph.
+   *
+   * @see Key#multibindingContributionIdentifier()
+   */
+  static final class MultibindingContributionIdentifier {
+    private final String identifierString;
+
+    MultibindingContributionIdentifier(
+        ExecutableElement bindingMethod, TypeElement contributingModule) {
+      this.identifierString =
+          String.format(
+              "%s#%s", contributingModule.getQualifiedName(), bindingMethod.getSimpleName());
+    }
 
-  /** An object that uniquely identifies a multibinding contribution binding. */
-  @AutoValue
-  abstract static class BindingMethodIdentifier {
     /**
-     * The {@link dagger.Provides} or {@link dagger.producers.Produces} method that contributes to
-     * the multibinding.
+     * {@inheritDoc}
+     *
+     * <p>The returned string is human-readable and distinguishes the keys in the same way as the
+     * whole object.
      */
-    abstract ExecutableElement bindingMethod();
+    @Override
+    public String toString() {
+      return identifierString;
+    }
 
-    /** The installed module that contains or inherits the {@link #bindingMethod()}. */
-    abstract TypeElement contributingModule();
+    @Override
+    public boolean equals(Object obj) {
+      return obj instanceof MultibindingContributionIdentifier
+          && ((MultibindingContributionIdentifier) obj)
+              .identifierString.equals(this.identifierString);
+    }
 
-    static BindingMethodIdentifier create(
-        ExecutableElement bindingMethod, TypeElement contributingModule) {
-      return new AutoValue_Key_BindingMethodIdentifier(bindingMethod, contributingModule);
+    @Override
+    public int hashCode() {
+      return identifierString.hashCode();
     }
   }
-  
+
   /**
    * A {@link javax.inject.Qualifier} annotation that provides a unique namespace prefix
    * for the type of this key.
@@ -139,195 +222,210 @@ TypeMirror type() {
     return wrappedType().get();
   }
 
-  private static TypeMirror normalize(Types types, TypeMirror type) {
-    TypeKind kind = type.getKind();
-    return kind.isPrimitive() ? types.boxedClass((PrimitiveType) type).asType() : type;
-  }
-
   /**
-   * A key whose {@link #qualifier()} and {@link #bindingMethodIdentifier()} are equivalent to this
-   * one's, but with {@code newType} (normalized) as its {@link #type()}.
+   * A key whose {@link #qualifier()} and {@link #type()} are equivalent to this one's, but without
+   * a {@link #multibindingContributionIdentifier()}.
    */
-  private Key withType(Types types, TypeMirror newType) {
-    return new AutoValue_Key(
-        wrappedQualifier(),
-        MoreTypes.equivalence().wrap(normalize(types, newType)),
-        bindingMethodIdentifier());
+  Key withoutMultibindingContributionIdentifier() {
+    return toBuilder().multibindingContributionIdentifier(Optional.empty()).build();
   }
 
-  /**
-   * A key whose {@link #qualifier()} and {@link #type()} are equivalent to this one's, but with
-   * {@code bindingDeclaration} as its {@link #bindingMethodIdentifier()}.
-   */
-  private Key withBindingMethodIdentifier(BindingMethodIdentifier bindingMethodIdentifier) {
-    return new AutoValue_Key(
-        wrappedQualifier(), wrappedType(), Optional.of(bindingMethodIdentifier));
+  boolean isValidMembersInjectionKey() {
+    return !qualifier().isPresent() && !type().getKind().equals(TypeKind.WILDCARD);
   }
 
   /**
-   * A key whose {@link #qualifier()} and {@link #type()} are equivalent to this one's, but with an
-   * absent {@link #bindingMethodIdentifier()}.
+   * Returns {@code true} if this is valid as an implicit key (that is, if it's valid for a
+   * just-in-time binding by discovering an {@code @Inject} constructor).
    */
-  Key withoutBindingMethodIdentifier() {
-    return new AutoValue_Key(
-        wrappedQualifier(), wrappedType(), Optional.<BindingMethodIdentifier>absent());
-  }
-
-  boolean isValidMembersInjectionKey() {
-    return !qualifier().isPresent() && !type().getKind().equals(TypeKind.WILDCARD);
+  boolean isValidImplicitProvisionKey(Types types) {
+    return isValidImplicitProvisionKey(qualifier(), type(), types);
   }
 
   /**
-   * Returns true if the key is valid as an implicit key (that is, if it's valid for a just-in-time
-   * binding by discovering an {@code @Inject} constructor).
+   * Returns {@code true} if a key with {@code qualifier} and {@code type} is valid as an implicit
+   * key (that is, if it's valid for a just-in-time binding by discovering an {@code @Inject}
+   * constructor).
    */
-  boolean isValidImplicitProvisionKey(final Types types) {
+  static boolean isValidImplicitProvisionKey(
+      Optional<? extends AnnotationMirror> qualifier, TypeMirror type, final Types types) {
     // Qualifiers disqualify implicit provisioning.
-    if (qualifier().isPresent()) {
+    if (qualifier.isPresent()) {
       return false;
     }
 
-    return type().accept(new SimpleTypeVisitor6<Boolean, Void>() {
-      @Override protected Boolean defaultAction(TypeMirror e, Void p) {
-        return false; // Only declared types are allowed.
-      }
-
-      @Override public Boolean visitDeclared(DeclaredType type, Void ignored) {
-        // Non-classes or abstract classes aren't allowed.
-        TypeElement element = MoreElements.asType(type.asElement());
-        if (!element.getKind().equals(ElementKind.CLASS)
-            || element.getModifiers().contains(Modifier.ABSTRACT)) {
-          return false;
-        }
-
-        // If the key has type arguments, validate that each type argument is declared.
-        // Otherwise the type argument may be a wildcard (or other type), and we can't
-        // resolve that to actual types.
-        for (TypeMirror arg : type.getTypeArguments()) {
-          if (arg.getKind() != TypeKind.DECLARED) {
-            return false;
+    return type.accept(
+        new SimpleTypeVisitor6<Boolean, Void>(false) {
+          @Override
+          public Boolean visitDeclared(DeclaredType type, Void ignored) {
+            // Non-classes or abstract classes aren't allowed.
+            TypeElement element = MoreElements.asType(type.asElement());
+            if (!element.getKind().equals(ElementKind.CLASS)
+                || element.getModifiers().contains(Modifier.ABSTRACT)) {
+              return false;
+            }
+
+            // If the key has type arguments, validate that each type argument is declared.
+            // Otherwise the type argument may be a wildcard (or other type), and we can't
+            // resolve that to actual types.
+            for (TypeMirror arg : type.getTypeArguments()) {
+              if (arg.getKind() != TypeKind.DECLARED) {
+                return false;
+              }
+            }
+
+            // Also validate that the key is not the erasure of a generic type.
+            // If it is, that means the user referred to Foo<T> as just 'Foo',
+            // which we don't allow.  (This is a judgement call -- we *could*
+            // allow it and instantiate the type bounds... but we don't.)
+            return MoreTypes.asDeclared(element.asType()).getTypeArguments().isEmpty()
+                || !types.isSameType(types.erasure(element.asType()), type);
           }
-        }
-
-        // Also validate that the key is not the erasure of a generic type.
-        // If it is, that means the user referred to Foo<T> as just 'Foo',
-        // which we don't allow.  (This is a judgement call -- we *could*
-        // allow it and instantiate the type bounds... but we don't.)
-        return MoreTypes.asDeclared(element.asType()).getTypeArguments().isEmpty()
-            || !types.isSameType(types.erasure(element.asType()), type());
-      }
-    }, null);
+        },
+        null);
   }
 
+  /**
+   * {@inheritDoc}
+   *
+   * <p>The returned string is equal to another key's if and only if this key is {@link
+   * #equals(Object)} to it.
+   */
   @Override
   public String toString() {
-    return MoreObjects.toStringHelper(Key.class)
-        .omitNullValues()
-        .add("qualifier", qualifier().orNull())
-        .add("type", type())
-        .add("bindingMethodIdentifier", bindingMethodIdentifier().orNull())
-        .toString();
+    return Joiner.on(' ')
+        .skipNulls()
+        .join(qualifier().orElse(null), type(), multibindingContributionIdentifier().orElse(null));
   }
 
   /**
    * Indexes {@code haveKeys} by {@link HasKey#key()}.
    */
   static <T extends HasKey> ImmutableSetMultimap<Key, T> indexByKey(Iterable<T> haveKeys) {
-    return ImmutableSetMultimap.copyOf(
-        Multimaps.index(
-            haveKeys,
-            new Function<HasKey, Key>() {
-              @Override
-              public Key apply(HasKey hasKey) {
-                return hasKey.key();
-              }
-            }));
+    return ImmutableSetMultimap.copyOf(Multimaps.index(haveKeys, HasKey::key));
   }
 
   static final class Factory {
     private final Types types;
     private final Elements elements;
-
+    
     Factory(Types types, Elements elements) {
       this.types = checkNotNull(types);
       this.elements = checkNotNull(elements);
     }
 
-    private TypeElement getSetElement() {
-      return elements.getTypeElement(Set.class.getCanonicalName());
+    private TypeElement getClassElement(Class<?> cls) {
+      return elements.getTypeElement(cls.getCanonicalName());
     }
 
-    private TypeElement getMapElement() {
-      return elements.getTypeElement(Map.class.getCanonicalName());
+    private TypeMirror boxPrimitives(TypeMirror type) {
+      return type.getKind().isPrimitive() ? types.boxedClass((PrimitiveType) type).asType() : type;
     }
 
-    private TypeElement getProviderElement() {
-      return elements.getTypeElement(Provider.class.getCanonicalName());
+    private DeclaredType setOf(TypeMirror elementType) {
+      return types.getDeclaredType(getClassElement(Set.class), boxPrimitives(elementType));
     }
 
-    private TypeElement getProducerElement() {
-      return elements.getTypeElement(Producer.class.getCanonicalName());
+    private DeclaredType mapOf(TypeMirror keyType, TypeMirror valueType) {
+      return types.getDeclaredType(
+          getClassElement(Map.class), boxPrimitives(keyType), boxPrimitives(valueType));
     }
 
-    private TypeElement getClassElement(Class<?> cls) {
-      return elements.getTypeElement(cls.getName());
+    /** Returns {@code Map<KeyType, FrameworkType<ValueType>>}. */
+    private TypeMirror mapOfFrameworkType(
+        TypeMirror keyType, TypeElement frameworkType, TypeMirror valueType) {
+      return mapOf(keyType, types.getDeclaredType(frameworkType, boxPrimitives(valueType)));
+    }
+
+    private DeclaredType typedReleasableReferenceManagerOf(DeclaredType metadataType) {
+      return types.getDeclaredType(
+          getClassElement(TypedReleasableReferenceManager.class), metadataType);
     }
 
     Key forComponentMethod(ExecutableElement componentMethod) {
-      checkNotNull(componentMethod);
       checkArgument(componentMethod.getKind().equals(METHOD));
-      TypeMirror returnType = normalize(types, componentMethod.getReturnType());
-      return forMethod(componentMethod, returnType);
+      return forMethod(componentMethod, componentMethod.getReturnType());
     }
 
     Key forProductionComponentMethod(ExecutableElement componentMethod) {
-      checkNotNull(componentMethod);
       checkArgument(componentMethod.getKind().equals(METHOD));
-      TypeMirror returnType = normalize(types, componentMethod.getReturnType());
-      TypeMirror keyType = returnType;
-      if (MoreTypes.isTypeOf(ListenableFuture.class, returnType)) {
-        keyType = Iterables.getOnlyElement(MoreTypes.asDeclared(returnType).getTypeArguments());
-      }
+      TypeMirror returnType = componentMethod.getReturnType();
+      TypeMirror keyType =
+          isTypeOf(ListenableFuture.class, returnType)
+              ? getOnlyElement(MoreTypes.asDeclared(returnType).getTypeArguments())
+              : returnType;
       return forMethod(componentMethod, keyType);
     }
 
     Key forSubcomponentBuilderMethod(
         ExecutableElement subcomponentBuilderMethod, DeclaredType declaredContainer) {
-      checkNotNull(subcomponentBuilderMethod);
       checkArgument(subcomponentBuilderMethod.getKind().equals(METHOD));
       ExecutableType resolvedMethod =
           asExecutable(types.asMemberOf(declaredContainer, subcomponentBuilderMethod));
-      TypeMirror returnType = normalize(types, resolvedMethod.getReturnType());
-      return forMethod(subcomponentBuilderMethod, returnType);
+      return builder(resolvedMethod.getReturnType()).build();
+    }
+
+    Key forSubcomponentBuilder(TypeMirror builderType) {
+      return builder(builderType).build();
     }
 
     Key forProvidesMethod(ExecutableElement method, TypeElement contributingModule) {
-      return forProvidesOrProducesMethod(method, contributingModule, getProviderElement());
+      return forBindingMethod(
+          method, contributingModule, Optional.of(getClassElement(Provider.class)));
     }
 
     Key forProducesMethod(ExecutableElement method, TypeElement contributingModule) {
-      return forProvidesOrProducesMethod(method, contributingModule, getProducerElement());
+      return forBindingMethod(
+          method, contributingModule, Optional.of(getClassElement(Producer.class)));
     }
 
-    private Key forProvidesOrProducesMethod(
-        ExecutableElement method, TypeElement contributingModule, TypeElement frameworkType) {
+    /** Returns the key bound by a {@link Binds} method. */
+    Key forBindsMethod(ExecutableElement method, TypeElement contributingModule) {
+      checkArgument(isAnnotationPresent(method, Binds.class));
+      return forBindingMethod(method, contributingModule, Optional.empty());
+    }
+
+    /** Returns the base key bound by a {@link BindsOptionalOf} method. */
+    Key forBindsOptionalOfMethod(ExecutableElement method, TypeElement contributingModule) {
+      checkArgument(isAnnotationPresent(method, BindsOptionalOf.class));
+      return forBindingMethod(method, contributingModule, Optional.empty());
+    }
+
+    private Key forBindingMethod(
+        ExecutableElement method,
+        TypeElement contributingModule,
+        Optional<TypeElement> frameworkType) {
       checkArgument(method.getKind().equals(METHOD));
       ExecutableType methodType =
           MoreTypes.asExecutable(
               types.asMemberOf(MoreTypes.asDeclared(contributingModule.asType()), method));
       ContributionType contributionType = ContributionType.fromBindingMethod(method);
-      TypeMirror returnType = normalize(types, methodType.getReturnType());
-      if (frameworkType.equals(getProducerElement())
-          && MoreTypes.isTypeOf(ListenableFuture.class, returnType)) {
-        returnType = Iterables.getOnlyElement(MoreTypes.asDeclared(returnType).getTypeArguments());
+      TypeMirror returnType = methodType.getReturnType();
+      if (frameworkType.isPresent()
+          && frameworkType.get().equals(getClassElement(Producer.class))
+          && isType(returnType)) {
+        if (isTypeOf(ListenableFuture.class, returnType)) {
+          returnType = getOnlyElement(MoreTypes.asDeclared(returnType).getTypeArguments());
+        } else if (contributionType.equals(ContributionType.SET_VALUES)
+            && SetType.isSet(returnType)) {
+          SetType setType = SetType.from(returnType);
+          if (setType.elementsAreTypeOf(ListenableFuture.class)) {
+            returnType =
+                types.getDeclaredType(
+                    getClassElement(Set.class),
+                    setType.unwrappedElementType(ListenableFuture.class));
+          }
+        }
       }
       TypeMirror keyType =
-          bindingMethodKeyType(returnType, method, contributionType, Optional.of(frameworkType));
+          bindingMethodKeyType(returnType, method, contributionType, frameworkType);
       Key key = forMethod(method, keyType);
       return contributionType.equals(ContributionType.UNIQUE)
           ? key
-          : key.withBindingMethodIdentifier(
-              BindingMethodIdentifier.create(method, contributingModule));
+          : key.toBuilder()
+              .multibindingContributionIdentifier(
+                  new MultibindingContributionIdentifier(method, contributingModule))
+              .build();
     }
 
     /**
@@ -342,7 +440,7 @@ Key forMultibindsMethod(
       checkArgument(method.getKind().equals(METHOD), "%s must be a method", method);
       TypeElement factoryType =
           elements.getTypeElement(bindingType.frameworkClass().getCanonicalName());
-      TypeMirror returnType = normalize(types, executableType.getReturnType());
+      TypeMirror returnType = executableType.getReturnType();
       TypeMirror keyType =
           MapType.isMap(returnType)
               ? mapOfFrameworkType(
@@ -353,22 +451,6 @@ Key forMultibindsMethod(
       return forMethod(method, keyType);
     }
 
-    /** Returns the key bound by a {@link Binds} method. */
-    Key forBindsMethod(ExecutableElement method, ExecutableType methodType) {
-      checkArgument(isAnnotationPresent(method, Binds.class));
-      ContributionType contributionType = ContributionType.fromBindingMethod(method);
-      TypeMirror returnType = normalize(types, methodType.getReturnType());
-      TypeMirror keyType =
-          bindingMethodKeyType(
-              returnType, method, contributionType, Optional.<TypeElement>absent());
-      Key key = forMethod(method, keyType);
-      return contributionType.equals(ContributionType.UNIQUE)
-          ? key
-          : key.withBindingMethodIdentifier(
-              BindingMethodIdentifier.create(
-                  method, MoreElements.asType(method.getEnclosingElement())));
-    }
-
     private TypeMirror bindingMethodKeyType(
         TypeMirror returnType,
         ExecutableElement method,
@@ -378,12 +460,12 @@ private TypeMirror bindingMethodKeyType(
         case UNIQUE:
           return returnType;
         case SET:
-          return types.getDeclaredType(getSetElement(), returnType);
+          return setOf(returnType);
         case MAP:
           if (frameworkType.isPresent()) {
             return mapOfFrameworkType(mapKeyType(method), frameworkType.get(), returnType);
           } else {
-            return types.getDeclaredType(getMapElement(), mapKeyType(method), returnType);
+            return mapOf(mapKeyType(method), returnType);
           }
         case SET_VALUES:
           // TODO(gak): do we want to allow people to use "covariant return" here?
@@ -408,15 +490,6 @@ Key forDelegateBinding(
           : delegateDeclaration.key();
     }
 
-    /**
-     * Returns {@code Map<KeyType, FrameworkType<ValueType>>}.
-     */
-    private TypeMirror mapOfFrameworkType(
-        TypeMirror keyType, TypeElement frameworkType, TypeMirror valueType) {
-      return types.getDeclaredType(
-          getMapElement(), keyType, types.getDeclaredType(frameworkType, valueType));
-    }
-
     private TypeMirror mapKeyType(ExecutableElement method) {
       AnnotationMirror mapKeyAnnotation = getMapKey(method).get();
       return MapKeys.unwrapValue(mapKeyAnnotation).isPresent()
@@ -425,50 +498,52 @@ private TypeMirror mapKeyType(ExecutableElement method) {
     }
 
     private Key forMethod(ExecutableElement method, TypeMirror keyType) {
-      return new AutoValue_Key(
-          wrapOptionalInEquivalence(getQualifier(method)),
-          MoreTypes.equivalence().wrap(keyType),
-          Optional.<BindingMethodIdentifier>absent());
+      return forQualifiedType(getQualifier(method), keyType);
     }
 
     Key forInjectConstructorWithResolvedType(TypeMirror type) {
-      return new AutoValue_Key(
-          Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
-          MoreTypes.equivalence().wrap(type),
-          Optional.<BindingMethodIdentifier>absent());
+      return builder(type).build();
     }
 
     Key forComponent(TypeMirror type) {
-      return new AutoValue_Key(
-          Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
-          MoreTypes.equivalence().wrap(normalize(types, type)),
-          Optional.<BindingMethodIdentifier>absent());
+      return builder(type).build();
     }
 
     Key forMembersInjectedType(TypeMirror type) {
-      return new AutoValue_Key(
-          Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
-          MoreTypes.equivalence().wrap(normalize(types, type)),
-          Optional.<BindingMethodIdentifier>absent());
+      return builder(type).build();
     }
 
     Key forQualifiedType(Optional<AnnotationMirror> qualifier, TypeMirror type) {
-      return new AutoValue_Key(
-          wrapOptionalInEquivalence(qualifier),
-          MoreTypes.equivalence().wrap(normalize(types, type)),
-          Optional.<BindingMethodIdentifier>absent());
+      return builder(boxPrimitives(type)).qualifier(qualifier).build();
     }
 
     Key forProductionExecutor() {
-      return forQualifiedType(
-          Optional.of(SimpleAnnotationMirror.of(getClassElement(Production.class))),
-          getClassElement(Executor.class).asType());
+      return builder(getClassElement(Executor.class).asType())
+          .qualifier(getClassElement(Production.class))
+          .build();
     }
 
     Key forProductionImplementationExecutor() {
-      return forQualifiedType(
-          Optional.of(SimpleAnnotationMirror.of(getClassElement(ProductionImplementation.class))),
-          getClassElement(Executor.class).asType());
+      return builder(getClassElement(Executor.class).asType())
+          .qualifier(getClassElement(ProductionImplementation.class))
+          .build();
+    }
+
+    Key forProductionComponentMonitor() {
+      return builder(getClassElement(ProductionComponentMonitor.class).asType()).build();
+    }
+
+    /**
+     * If {@code requestKey} is for a {@code Map<K, V>} or {@code Map<K, Produced<V>>}, returns keys
+     * for {@code Map<K, Provider<V>>} and {@code Map<K, Producer<V>>} (if Dagger-Producers is on
+     * the classpath).
+     */
+    ImmutableSet<Key> implicitFrameworkMapKeys(Key requestKey) {
+      return Stream.of(
+              implicitMapProviderKeyFrom(requestKey), implicitMapProducerKeyFrom(requestKey))
+          .filter(Optional::isPresent)
+          .map(Optional::get)
+          .collect(toImmutableSet());
     }
 
     /**
@@ -477,7 +552,7 @@ Key forProductionImplementationExecutor() {
      * {@link Map}{@code <K, V>}, a key of {@code Map<K, Provider<V>>} will be returned.
      */
     Optional<Key> implicitMapProviderKeyFrom(Key possibleMapKey) {
-      return maybeWrapMapValue(possibleMapKey, Provider.class);
+      return wrapMapKey(possibleMapKey, Provider.class);
     }
 
     /**
@@ -487,8 +562,9 @@ Key forProductionImplementationExecutor() {
      * {@code Map<K, Producer<V>>} will be returned.
      */
     Optional<Key> implicitMapProducerKeyFrom(Key possibleMapKey) {
-      return maybeRewrapMapValue(possibleMapKey, Produced.class, Producer.class)
-          .or(maybeWrapMapValue(possibleMapKey, Producer.class));
+      return firstPresent(
+          rewrapMapKey(possibleMapKey, Produced.class, Producer.class),
+          wrapMapKey(possibleMapKey, Producer.class));
     }
 
     /**
@@ -512,8 +588,7 @@ Key convertToDelegateKey(Key possibleMapKey) {
       } else {
         return possibleMapKey;
       }
-      return possibleMapKey.withType(
-          types, types.getDeclaredType(getMapElement(), mapType.keyType(), wrappedValueType));
+      return possibleMapKey.toBuilder().type(mapOf(mapType.keyType(), wrappedValueType)).build();
     }
 
     /**
@@ -523,14 +598,20 @@ private Key wrapMapValue(Key key, Class<?> newWrappingClass) {
       checkArgument(
           FrameworkTypes.isFrameworkType(
               elements.getTypeElement(newWrappingClass.getName()).asType()));
-      return maybeWrapMapValue(key, newWrappingClass).get();
+      return wrapMapKey(key, newWrappingClass).get();
     }
 
     /**
-     * Returns a key of {@link Map}{@code <K, NewWrappingClass<V>>} if the input key represents a
-     * {@code Map<K, CurrentWrappingClass<V>>}.
+     * If {@code key}'s type is {@code Map<K, CurrentWrappingClass<Bar>>}, returns a key with type
+     * {@code Map<K, NewWrappingClass<Bar>>} with the same qualifier. Otherwise returns {@link
+     * Optional#empty()}.
+     *
+     * <p>Returns {@link Optional#empty()} if {@code newWrappingClass} is not in the classpath.
+     *
+     * @throws IllegalArgumentException if {@code newWrappingClass} is the same as {@code
+     *     currentWrappingClass}
      */
-    private Optional<Key> maybeRewrapMapValue(
+    Optional<Key> rewrapMapKey(
         Key possibleMapKey, Class<?> currentWrappingClass, Class<?> newWrappingClass) {
       checkArgument(!currentWrappingClass.equals(newWrappingClass));
       if (MapType.isMap(possibleMapKey)) {
@@ -540,24 +621,26 @@ private Key wrapMapValue(Key key, Class<?> newWrappingClass) {
           if (wrappingElement == null) {
             // This target might not be compiled with Producers, so wrappingClass might not have an
             // associated element.
-            return Optional.absent();
+            return Optional.empty();
           }
           DeclaredType wrappedValueType =
               types.getDeclaredType(
                   wrappingElement, mapType.unwrappedValueType(currentWrappingClass));
-          TypeMirror wrappedMapType =
-              types.getDeclaredType(getMapElement(), mapType.keyType(), wrappedValueType);
-          return Optional.of(possibleMapKey.withType(types, wrappedMapType));
+          return Optional.of(
+              possibleMapKey.toBuilder().type(mapOf(mapType.keyType(), wrappedValueType)).build());
         }
       }
-      return Optional.absent();
+      return Optional.empty();
     }
 
     /**
-     * Returns a key of {@link Map}{@code <K, WrappingClass<V>>} if the input key represents a
-     * {@code Map<K, V>}.
+     * If {@code key}'s type is {@code Map<K, Foo>} and {@code Foo} is not {@code WrappingClass
+     * <Bar>}, returns a key with type {@code Map<K, WrappingClass<Foo>>} with the same qualifier.
+     * Otherwise returns {@link Optional#empty()}.
+     *
+     * <p>Returns {@link Optional#empty()} if {@code WrappingClass} is not in the classpath.
      */
-    private Optional<Key> maybeWrapMapValue(Key possibleMapKey, Class<?> wrappingClass) {
+    private Optional<Key> wrapMapKey(Key possibleMapKey, Class<?> wrappingClass) {
       if (MapType.isMap(possibleMapKey)) {
         MapType mapType = MapType.from(possibleMapKey);
         if (!mapType.valuesAreTypeOf(wrappingClass)) {
@@ -565,42 +648,79 @@ private Key wrapMapValue(Key key, Class<?> newWrappingClass) {
           if (wrappingElement == null) {
             // This target might not be compiled with Producers, so wrappingClass might not have an
             // associated element.
-            return Optional.absent();
+            return Optional.empty();
           }
           DeclaredType wrappedValueType =
               types.getDeclaredType(wrappingElement, mapType.valueType());
-          TypeMirror wrappedMapType =
-              types.getDeclaredType(getMapElement(), mapType.keyType(), wrappedValueType);
-          return Optional.of(possibleMapKey.withType(types, wrappedMapType));
+          return Optional.of(
+              possibleMapKey.toBuilder().type(mapOf(mapType.keyType(), wrappedValueType)).build());
         }
       }
-      return Optional.absent();
+      return Optional.empty();
     }
 
     /**
-     * Optionally extract a {@link Key} for a {@code Set<T>} if the given key is for
-     * {@code Set<Produced<T>>}.
+     * If {@code key}'s type is {@code Set<WrappingClass<Bar>>}, returns a key with type {@code Set
+     * <Bar>} with the same qualifier. Otherwise returns {@link Optional#empty()}.
      */
-    Optional<Key> implicitSetKeyFromProduced(Key possibleSetOfProducedKey) {
-      if (MoreTypes.isType(possibleSetOfProducedKey.type())
-          && MoreTypes.isTypeOf(Set.class, possibleSetOfProducedKey.type())) {
-        TypeMirror argType =
-            MoreTypes.asDeclared(possibleSetOfProducedKey.type()).getTypeArguments().get(0);
-        if (MoreTypes.isType(argType) && MoreTypes.isTypeOf(Produced.class, argType)) {
-          TypeMirror producedArgType = MoreTypes.asDeclared(argType).getTypeArguments().get(0);
-          TypeMirror setType = types.getDeclaredType(getSetElement(), producedArgType);
-          return Optional.of(possibleSetOfProducedKey.withType(types, setType));
+    Optional<Key> unwrapSetKey(Key key, Class<?> wrappingClass) {
+      if (SetType.isSet(key)) {
+        SetType setType = SetType.from(key);
+        if (setType.elementsAreTypeOf(wrappingClass)) {
+          return Optional.of(
+              key.toBuilder().type(setOf(setType.unwrappedElementType(wrappingClass))).build());
         }
       }
-      return Optional.absent();
+      return Optional.empty();
+    }
+
+    /**
+     * If {@code key}'s type is {@code Optional<T>} for some {@code T}, returns a key with the same
+     * qualifier whose type is {@linkplain DependencyRequest#extractKindAndType(TypeMirror)
+     * extracted} from {@code T}.
+     */
+    Optional<Key> unwrapOptional(Key key) {
+      if (!OptionalType.isOptional(key)) {
+        return Optional.empty();
+      }
+      TypeMirror underlyingType =
+          DependencyRequest.extractKindAndType(OptionalType.from(key).valueType()).type();
+      return Optional.of(key.toBuilder().type(underlyingType).build());
+    }
+
+    /** Returns a key for a {@code @ForReleasableReferences(scope) ReleasableReferenceManager}. */
+    Key forReleasableReferenceManager(Scope scope) {
+      return forQualifiedType(
+          Optional.of(forReleasableReferencesAnnotationMirror(scope)),
+          getClassElement(ReleasableReferenceManager.class).asType());
     }
 
     /**
-     * Optionally extract a {@link Key} for a {@code Map<K, Provider<V>>} if the given key is for
-     * {@code Map<K, Producer<V>>}.
+     * Returns a key for a {@code @ForReleasableReferences(scope)
+     * TypedReleasableReferenceManager<metadataType>}
      */
-    Optional<Key> implicitProviderMapKeyFromProducer(Key possibleMapOfProducerKey) {
-      return maybeRewrapMapValue(possibleMapOfProducerKey, Producer.class, Provider.class);
+    Key forTypedReleasableReferenceManager(Scope scope, DeclaredType metadataType) {
+      return builder(typedReleasableReferenceManagerOf(metadataType))
+          .qualifier(forReleasableReferencesAnnotationMirror(scope))
+          .build();
+    }
+
+    /** Returns a key for a {@code Set<ReleasableReferenceManager>}. */
+    Key forSetOfReleasableReferenceManagers() {
+      return builder(setOf(getClassElement(ReleasableReferenceManager.class).asType())).build();
+    }
+
+    /** Returns a key for a {@code Set<TypedReleasableReferenceManager<metadataType>}. */
+    Key forSetOfTypedReleasableReferenceManagers(DeclaredType metadataType) {
+      return forQualifiedType(
+          Optional.empty(), setOf(typedReleasableReferenceManagerOf(metadataType)));
+    }
+
+    private AnnotationMirror forReleasableReferencesAnnotationMirror(Scope scope) {
+      return SimpleAnnotationMirror.of(
+          getClassElement(ForReleasableReferences.class),
+          ImmutableMap.of(
+              "value", new SimpleTypeAnnotationValue(scope.scopeAnnotationElement().asType())));
     }
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/KeyFormatter.java b/compiler/src/main/java/dagger/internal/codegen/KeyFormatter.java
index d329627a0..e5d391f63 100644
--- a/compiler/src/main/java/dagger/internal/codegen/KeyFormatter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/KeyFormatter.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Google, Inc.
+ * Copyright (C) 2014 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,34 +13,13 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal.codegen;
 
-/**
- * Formats a {@link Key} into a {@link String} suitable for use in error messages and JSON keys.
- *
- * @author Christian Gruber
- * @since 2.0
- */
+/** Formats a {@link Key} into a {@link String} suitable for use in error messages. */
 final class KeyFormatter extends Formatter<Key> {
-  
-  final MethodSignatureFormatter methodSignatureFormatter;
-
-  KeyFormatter(MethodSignatureFormatter methodSignatureFormatter) {
-    this.methodSignatureFormatter = methodSignatureFormatter;
-  }
-
   @Override
   public String format(Key key) {
-    if (key.bindingMethodIdentifier().isPresent()) {
-      // If there's a binding method, its signature is enough.
-      return methodSignatureFormatter.format(key.bindingMethodIdentifier().get());
-    }
-    StringBuilder builder = new StringBuilder();
-    if (key.qualifier().isPresent()) {
-      builder.append(key.qualifier().get());
-      builder.append(' ');
-    }
-    builder.append(key.type());
-    return builder.toString();
+    return key.toString();
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/MapKeyProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/MapKeyProcessingStep.java
index 41c6a16f1..241e61771 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MapKeyProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MapKeyProcessingStep.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Google, Inc.
+ * Copyright (C) 2014 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,27 +13,27 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal.codegen;
 
+import static dagger.internal.codegen.MapKeys.getUnwrappedMapKeyType;
+import static javax.lang.model.element.ElementKind.ANNOTATION_TYPE;
+import static javax.lang.model.util.ElementFilter.typesIn;
+
 import com.google.auto.common.BasicAnnotationProcessor;
-import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.SetMultimap;
 import dagger.MapKey;
-import dagger.internal.codegen.MapKeyGenerator.MapKeyCreatorSpecification;
 import java.lang.annotation.Annotation;
 import java.util.Set;
 import javax.annotation.processing.Messager;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ElementKind;
+import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.util.Types;
 
-import static dagger.internal.codegen.MapKeyGenerator.MapKeyCreatorSpecification.unwrappedMapKeyWithAnnotationValue;
-import static dagger.internal.codegen.MapKeyGenerator.MapKeyCreatorSpecification.wrappedMapKey;
-import static dagger.internal.codegen.MapKeys.getUnwrappedMapKeyType;
-
 /**
  * The annotation processor responsible for validating the mapKey annotation and auto-generate
  * implementation of annotations marked with {@link MapKey @MapKey} where necessary.
@@ -45,17 +45,20 @@
   private final Messager messager;
   private final Types types;
   private final MapKeyValidator mapKeyValidator;
-  private final MapKeyGenerator mapKeyGenerator;
+  private final AnnotationCreatorGenerator annotationCreatorGenerator;
+  private final UnwrappedMapKeyGenerator unwrappedMapKeyGenerator;
 
   MapKeyProcessingStep(
       Messager messager,
       Types types,
       MapKeyValidator mapKeyValidator,
-      MapKeyGenerator mapKeyGenerator) {
+      AnnotationCreatorGenerator annotationCreatorGenerator,
+      UnwrappedMapKeyGenerator unwrappedMapKeyGenerator) {
     this.messager = messager;
     this.types = types;
     this.mapKeyValidator = mapKeyValidator;
-    this.mapKeyGenerator = mapKeyGenerator;
+    this.annotationCreatorGenerator = annotationCreatorGenerator;
+    this.unwrappedMapKeyGenerator = unwrappedMapKeyGenerator;
   }
 
   @Override
@@ -66,33 +69,25 @@
   @Override
   public Set<Element> process(
       SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
-    for (Element element : elementsByAnnotation.get(MapKey.class)) {
-      ValidationReport<Element> mapKeyReport = mapKeyValidator.validate(element);
+    for (TypeElement mapKeyAnnotationType : typesIn(elementsByAnnotation.get(MapKey.class))) {
+      ValidationReport<Element> mapKeyReport = mapKeyValidator.validate(mapKeyAnnotationType);
       mapKeyReport.printMessagesTo(messager);
 
       if (mapKeyReport.isClean()) {
-        MapKey mapkey = element.getAnnotation(MapKey.class);
-        if (mapkey.unwrapValue()) {
-          DeclaredType keyType =
-              getUnwrappedMapKeyType(MoreTypes.asDeclared(element.asType()), types);
-          if (keyType.asElement().getKind() == ElementKind.ANNOTATION_TYPE) {
-            writeCreatorClass(
-                unwrappedMapKeyWithAnnotationValue(
-                    MoreElements.asType(element), MoreTypes.asTypeElement(keyType)));
-          }
-        } else {
-          writeCreatorClass(wrappedMapKey(MoreElements.asType(element)));
+        MapKey mapkey = mapKeyAnnotationType.getAnnotation(MapKey.class);
+        if (!mapkey.unwrapValue()) {
+          annotationCreatorGenerator.generate(mapKeyAnnotationType, messager);
+        } else if (unwrappedValueKind(mapKeyAnnotationType).equals(ANNOTATION_TYPE)) {
+          unwrappedMapKeyGenerator.generate(mapKeyAnnotationType, messager);
         }
       }
     }
     return ImmutableSet.of();
   }
 
-  private void writeCreatorClass(MapKeyCreatorSpecification mapKeyCreatorType) {
-    try {
-      mapKeyGenerator.generate(mapKeyCreatorType);
-    } catch (SourceFileGenerationException e) {
-      e.printMessageTo(messager);
-    }
+  private ElementKind unwrappedValueKind(TypeElement mapKeyAnnotationType) {
+    DeclaredType unwrappedMapKeyType =
+        getUnwrappedMapKeyType(MoreTypes.asDeclared(mapKeyAnnotationType.asType()), types);
+    return unwrappedMapKeyType.asElement().getKind();
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/MapKeyValidator.java b/compiler/src/main/java/dagger/internal/codegen/MapKeyValidator.java
index 586a1e935..5d565dd14 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MapKeyValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MapKeyValidator.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Google, Inc.
+ * Copyright (C) 2014 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,8 +13,14 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal.codegen;
 
+import static dagger.internal.codegen.ErrorMessages.MAPKEY_WITHOUT_MEMBERS;
+import static dagger.internal.codegen.ErrorMessages.UNWRAPPED_MAP_KEY_WITH_ARRAY_MEMBER;
+import static dagger.internal.codegen.ErrorMessages.UNWRAPPED_MAP_KEY_WITH_TOO_MANY_MEMBERS;
+import static javax.lang.model.util.ElementFilter.methodsIn;
+
 import dagger.MapKey;
 import java.util.List;
 import javax.lang.model.element.Element;
@@ -22,11 +28,6 @@
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.TypeKind;
 
-import static dagger.internal.codegen.ErrorMessages.MAPKEY_WITHOUT_MEMBERS;
-import static dagger.internal.codegen.ErrorMessages.UNWRAPPED_MAP_KEY_WITH_ARRAY_MEMBER;
-import static dagger.internal.codegen.ErrorMessages.UNWRAPPED_MAP_KEY_WITH_TOO_MANY_MEMBERS;
-import static javax.lang.model.util.ElementFilter.methodsIn;
-
 /**
  * A validator for {@link MapKey} annotations.
  *
diff --git a/compiler/src/main/java/dagger/internal/codegen/MapKeys.java b/compiler/src/main/java/dagger/internal/codegen/MapKeys.java
index 00ae1d337..3db146551 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MapKeys.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MapKeys.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,44 +13,33 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal.codegen;
 
+import static com.google.auto.common.AnnotationMirrors.getAnnotatedAnnotations;
+import static com.google.auto.common.AnnotationMirrors.getAnnotationValuesWithDefaults;
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.collect.Iterables.getOnlyElement;
+import static javax.lang.model.util.ElementFilter.methodsIn;
+
 import com.google.auto.common.MoreTypes;
-import com.google.common.base.Function;
-import com.google.common.base.Optional;
-import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
-import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
-import com.squareup.javapoet.TypeName;
 import dagger.MapKey;
-import java.util.List;
-import java.util.Map;
 import java.util.NoSuchElementException;
+import java.util.Optional;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.AnnotationValue;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ElementKind;
 import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.TypeElement;
-import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.ArrayType;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.PrimitiveType;
 import javax.lang.model.type.TypeMirror;
-import javax.lang.model.util.SimpleAnnotationValueVisitor6;
 import javax.lang.model.util.SimpleTypeVisitor6;
 import javax.lang.model.util.Types;
 
-import static com.google.auto.common.AnnotationMirrors.getAnnotatedAnnotations;
-import static com.google.auto.common.AnnotationMirrors.getAnnotationValuesWithDefaults;
-import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.collect.Iterables.getOnlyElement;
-import static com.google.common.collect.Iterables.transform;
-import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
-import static dagger.internal.codegen.SourceFiles.classFileName;
-import static javax.lang.model.util.ElementFilter.methodsIn;
-
 /**
  * Methods for extracting {@link MapKey} annotations and key code blocks from binding elements.
  */
@@ -65,7 +54,7 @@
   static Optional<AnnotationMirror> getMapKey(Element bindingElement) {
     ImmutableSet<? extends AnnotationMirror> mapKeys = getMapKeys(bindingElement);
     return mapKeys.isEmpty()
-        ? Optional.<AnnotationMirror>absent()
+        ? Optional.empty()
         : Optional.<AnnotationMirror>of(getOnlyElement(mapKeys));
   }
 
@@ -89,7 +78,7 @@
         mapKeyAnnotation != null, "%s is not annotated with @MapKey", mapKey.getAnnotationType());
     return mapKeyAnnotation.unwrapValue()
         ? Optional.of(getOnlyElement(getAnnotationValuesWithDefaults(mapKey).values()))
-        : Optional.<AnnotationValue>absent();
+        : Optional.empty();
   }
 
   /**
@@ -132,15 +121,6 @@ public DeclaredType visitDeclared(DeclaredType t, Void p) {
     return keyTypeElementVisitor.visit(onlyElement.getReturnType());
   }
 
-  /**
-   * Returns the name of the generated class that contains the static {@code create} methods for a
-   * {@link MapKey} annotation type.
-   */
-  public static ClassName getMapKeyCreatorClassName(TypeElement mapKeyType) {
-    ClassName mapKeyTypeName = ClassName.get(mapKeyType);
-    return mapKeyTypeName.topLevelClassName().peerClass(classFileName(mapKeyTypeName) + "Creator");
-  }
-
   /**
    * Returns a code block for the map key specified by the {@link MapKey} annotation on
    * {@code bindingElement}.
@@ -151,183 +131,16 @@ public static ClassName getMapKeyCreatorClassName(TypeElement mapKeyType) {
    *     annotation
    */
   static CodeBlock getMapKeyExpression(AnnotationMirror mapKey) {
-    ClassName mapKeyCreator =
-        getMapKeyCreatorClassName(MoreTypes.asTypeElement(mapKey.getAnnotationType()));
     Optional<? extends AnnotationValue> unwrappedValue = unwrapValue(mapKey);
+    AnnotationExpression annotationExpression = new AnnotationExpression(mapKey);
     if (unwrappedValue.isPresent()) {
-      return new MapKeyExpressionExceptArrays(mapKeyCreator)
-          .visit(unwrappedValue.get(), unwrappedValue.get());
+      TypeMirror unwrappedValueType =
+          getOnlyElement(getAnnotationValuesWithDefaults(mapKey).keySet()).getReturnType();
+      return annotationExpression.getValueExpression(unwrappedValueType, unwrappedValue.get());
     } else {
-      return annotationExpression(mapKey, new MapKeyExpression(mapKeyCreator));
-    }
-  }
-
-  /**
-   * Returns a code block to create the visited value in code. Expects its parameter to be a class
-   * with static creation methods for all nested annotation types.
-   *
-   * <p>Note that {@link AnnotationValue#toString()} is the source-code representation of the value
-   * <em>when used in an annotation</em>, which is not always the same as the representation needed
-   * when creating the value in a method body.
-   *
-   * <p>For example, inside an annotation, a nested array of {@code int}s is simply
-   * {@code {1, 2, 3}}, but in code it would have to be {@code new int[] {1, 2, 3}}.
-   */
-  private static class MapKeyExpression
-      extends SimpleAnnotationValueVisitor6<CodeBlock, AnnotationValue> {
-
-    final ClassName mapKeyCreator;
-
-    MapKeyExpression(ClassName mapKeyCreator) {
-      this.mapKeyCreator = mapKeyCreator;
-    }
-
-    @Override
-    public CodeBlock visitEnumConstant(VariableElement c, AnnotationValue p) {
-      return CodeBlock.of(
-          "$T.$L", TypeName.get(c.getEnclosingElement().asType()), c.getSimpleName());
-    }
-
-    @Override
-    public CodeBlock visitAnnotation(AnnotationMirror a, AnnotationValue p) {
-      return annotationExpression(a, this);
-    }
-
-    @Override
-    public CodeBlock visitType(TypeMirror t, AnnotationValue p) {
-      return CodeBlock.of("$T.class", TypeName.get(t));
-    }
-
-    @Override
-    public CodeBlock visitString(String s, AnnotationValue p) {
-      return CodeBlock.of("$S", s);
-    }
-
-    @Override
-    public CodeBlock visitByte(byte b, AnnotationValue p) {
-      return CodeBlock.of("(byte) $L", b);
-    }
-
-    @Override
-    public CodeBlock visitChar(char c, AnnotationValue p) {
-      return CodeBlock.of("$L", p);
-    }
-
-    @Override
-    public CodeBlock visitDouble(double d, AnnotationValue p) {
-      return CodeBlock.of("$LD", d);
-    }
-
-    @Override
-    public CodeBlock visitFloat(float f, AnnotationValue p) {
-      return CodeBlock.of("$LF", f);
-    }
-
-    @Override
-    public CodeBlock visitInt(int i, AnnotationValue p) {
-      return CodeBlock.of("(int) $L", i);
-    }
-
-    @Override
-    public CodeBlock visitLong(long i, AnnotationValue p) {
-      return CodeBlock.of("$LL", i);
-    }
-
-    @Override
-    public CodeBlock visitShort(short s, AnnotationValue p) {
-      return CodeBlock.of("(short) $L", s);
-    }
-
-    @Override
-    protected CodeBlock defaultAction(Object o, AnnotationValue p) {
-      return CodeBlock.of("$L", o);
-    }
-
-    @Override
-    public CodeBlock visitArray(List<? extends AnnotationValue> values, AnnotationValue p) {
-      ImmutableList.Builder<CodeBlock> codeBlocks = ImmutableList.builder();
-      for (int i = 0; i < values.size(); i++) {
-        codeBlocks.add(this.visit(values.get(i), p));
-      }
-      return CodeBlock.of("{$L}", makeParametersCodeBlock(codeBlocks.build()));
+      return annotationExpression.getAnnotationInstanceExpression();
     }
   }
 
-  /**
-   * Returns a code block for the visited value. Expects its parameter to be a class with static
-   * creation methods for all nested annotation types.
-   *
-   * <p>Throws {@link IllegalArgumentException} if the visited value is an array.
-   */
-  private static class MapKeyExpressionExceptArrays extends MapKeyExpression {
-
-    MapKeyExpressionExceptArrays(ClassName mapKeyCreator) {
-      super(mapKeyCreator);
-    }
-
-    @Override
-    public CodeBlock visitArray(List<? extends AnnotationValue> values, AnnotationValue p) {
-      throw new IllegalArgumentException("Cannot unwrap arrays");
-    }
-  }
-
-  /**
-   * Returns a code block that calls a static method on {@code mapKeyCodeBlock.mapKeyCreator} to
-   * create an annotation from {@code mapKeyAnnotation}.
-   */
-  private static CodeBlock annotationExpression(
-      AnnotationMirror mapKeyAnnotation, final MapKeyExpression mapKeyExpression) {
-    return CodeBlock.of(
-        "$T.create$L($L)",
-        mapKeyExpression.mapKeyCreator,
-        mapKeyAnnotation.getAnnotationType().asElement().getSimpleName(),
-        makeParametersCodeBlock(
-            transform(
-                getAnnotationValuesWithDefaults(mapKeyAnnotation).entrySet(),
-                new Function<Map.Entry<ExecutableElement, AnnotationValue>, CodeBlock>() {
-                  @Override
-                  public CodeBlock apply(Map.Entry<ExecutableElement, AnnotationValue> entry) {
-                    return ARRAY_LITERAL_PREFIX.visit(
-                        entry.getKey().getReturnType(),
-                        mapKeyExpression.visit(entry.getValue(), entry.getValue()));
-                  }
-                })));
-  }
-
-  /**
-   * If the visited type is an array, prefixes the parameter code block with {@code new T[]}, where
-   * {@code T} is the raw array component type.
-   */
-  private static final SimpleTypeVisitor6<CodeBlock, CodeBlock> ARRAY_LITERAL_PREFIX =
-      new SimpleTypeVisitor6<CodeBlock, CodeBlock>() {
-
-        @Override
-        public CodeBlock visitArray(ArrayType t, CodeBlock p) {
-          return CodeBlock.of("new $T[] $L", RAW_TYPE_NAME.visit(t.getComponentType()), p);
-        }
-
-        @Override
-        protected CodeBlock defaultAction(TypeMirror e, CodeBlock p) {
-          return p;
-        }
-      };
-
-  /**
-   * If the visited type is an array, returns the name of its raw component type; otherwise returns
-   * the name of the type itself.
-   */
-  private static final SimpleTypeVisitor6<TypeName, Void> RAW_TYPE_NAME =
-      new SimpleTypeVisitor6<TypeName, Void>() {
-        @Override
-        public TypeName visitDeclared(DeclaredType t, Void p) {
-          return ClassName.get(MoreTypes.asTypeElement(t));
-        }
-
-        @Override
-        protected TypeName defaultAction(TypeMirror e, Void p) {
-          return TypeName.get(e);
-        }
-      };
-
   private MapKeys() {}
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/MapType.java b/compiler/src/main/java/dagger/internal/codegen/MapType.java
index 70cc61fde..55c55eb1f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MapType.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MapType.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,8 +13,12 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal.codegen;
 
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkState;
+
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Equivalence;
@@ -22,9 +26,6 @@
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeMirror;
 
-import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkState;
-
 /**
  * Information about a {@link Map} {@link TypeMirror}.
  */
@@ -100,7 +101,7 @@ TypeMirror unwrappedValueType(Class<?> wrappingClass) {
         wrappingClass.getTypeParameters().length == 1,
         "%s must have exactly one type parameter",
         wrappingClass);
-    checkState(valuesAreTypeOf(wrappingClass));
+    checkState(valuesAreTypeOf(wrappingClass), "expected values to be %s: %s", wrappingClass, this);
     return MoreTypes.asDeclared(valueType()).getTypeArguments().get(0);
   }
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/MemberSelect.java b/compiler/src/main/java/dagger/internal/codegen/MemberSelect.java
index 777dabe3b..97ee9845a 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MemberSelect.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MemberSelect.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,29 +13,26 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package dagger.internal.codegen;
 
-import com.google.common.collect.ImmutableList;
-import com.squareup.javapoet.ClassName;
-import com.squareup.javapoet.CodeBlock;
-import dagger.MembersInjector;
-import dagger.internal.MapProviderFactory;
-import dagger.producers.internal.MapOfProducerProducer;
-import java.util.List;
-import java.util.Set;
-import javax.lang.model.type.TypeMirror;
+package dagger.internal.codegen;
 
-import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static dagger.internal.codegen.Accessibility.isTypeAccessibleFrom;
-import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
-import static dagger.internal.codegen.CodeBlocks.toCodeBlocks;
+import static dagger.internal.codegen.CodeBlocks.toTypeNamesCodeBlock;
 import static dagger.internal.codegen.TypeNames.FACTORY;
 import static dagger.internal.codegen.TypeNames.MAP_OF_PRODUCER_PRODUCER;
 import static dagger.internal.codegen.TypeNames.MAP_PROVIDER_FACTORY;
 import static dagger.internal.codegen.TypeNames.MEMBERS_INJECTOR;
 import static dagger.internal.codegen.TypeNames.MEMBERS_INJECTORS;
-import static dagger.internal.codegen.TypeNames.SET;
+
+import com.google.common.collect.ImmutableList;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.TypeName;
+import dagger.MembersInjector;
+import java.util.List;
+import java.util.Set;
+import javax.lang.model.type.TypeMirror;
 
 /**
  * Represents a {@link com.sun.source.tree.MemberSelectTree} as a {@link CodeBlock}.
@@ -83,10 +80,7 @@ static MemberSelect staticMethod(ClassName owningClass, CodeBlock methodInvocati
   static MemberSelect parameterizedFactoryCreateMethod(
       ClassName owningClass, List<? extends TypeMirror> parameters) {
     return new ParameterizedStaticMethod(
-        owningClass,
-        ImmutableList.<TypeMirror>copyOf(parameters),
-        CodeBlock.of("create()"),
-        FACTORY);
+        owningClass, ImmutableList.copyOf(parameters), CodeBlock.of("create()"), FACTORY);
   }
 
   private static final class StaticMethod extends MemberSelect {
@@ -116,24 +110,31 @@ static MemberSelect noOpMembersInjector(TypeMirror type) {
         MEMBERS_INJECTOR);
   }
 
-  /**
+   /**
    * A {@link MemberSelect} for an empty map of framework types.
    *
-   * @param frameworkMapFactoryClass either {@link MapProviderFactory}
-   *     or {@link MapOfProducerProducer}
+   * @param bindingType the type of the binding of the empty map
    */
   static MemberSelect emptyFrameworkMapFactory(
-      ClassName frameworkMapFactoryClass, TypeMirror keyType, TypeMirror unwrappedValueType) {
-    checkArgument(
-        frameworkMapFactoryClass.equals(MAP_PROVIDER_FACTORY)
-            || frameworkMapFactoryClass.equals(MAP_OF_PRODUCER_PRODUCER),
-        "frameworkMapFactoryClass must be MapProviderFactory or MapOfProducerProducer: %s",
-        frameworkMapFactoryClass);
+      BindingType bindingType, TypeMirror keyType, TypeMirror unwrappedValueType) {
+    final ClassName frameworkMapFactoryClass;
+    switch (bindingType) {
+      case PROVISION:
+        frameworkMapFactoryClass = MAP_PROVIDER_FACTORY;
+        break;
+      case PRODUCTION:
+        frameworkMapFactoryClass = MAP_OF_PRODUCER_PRODUCER;
+        break;
+      case MEMBERS_INJECTION:
+        throw new IllegalArgumentException();
+      default:
+        throw new AssertionError();
+    }
     return new ParameterizedStaticMethod(
         frameworkMapFactoryClass,
         ImmutableList.of(keyType, unwrappedValueType),
         CodeBlock.of("empty()"),
-        frameworkMapFactoryClass);
+        ClassName.get(bindingType.frameworkClass()));
   }
 
   /**
@@ -143,10 +144,7 @@ static MemberSelect emptyFrameworkMapFactory(
    */
   static MemberSelect emptySetProvider(ClassName setFactoryType, SetType setType) {
     return new ParameterizedStaticMethod(
-        setFactoryType,
-        ImmutableList.of(setType.elementType()),
-        CodeBlock.of("empty()"),
-        SET);
+        setFactoryType, ImmutableList.of(setType.elementType()), CodeBlock.of("empty()"), FACTORY);
   }
 
   private static final class ParameterizedStaticMethod extends MemberSelect {
@@ -176,7 +174,7 @@ CodeBlock getExpressionFor(ClassName usingClass) {
         return CodeBlock.of(
             "$T.<$L>$L",
             owningClass(),
-            makeParametersCodeBlock(toCodeBlocks(typeParameters)),
+            typeParameters.stream().map(TypeName::get).collect(toTypeNamesCodeBlock()),
             methodCodeBlock);
       } else {
         return CodeBlock.of("(($T) $T.$L)", rawReturnType, owningClass(), methodCodeBlock);
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
index 2429870e6..507519966 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Google, Inc.
+ * Copyright (C) 2014 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,15 +13,20 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal.codegen;
 
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.base.Preconditions.checkState;
+import static dagger.internal.codegen.DaggerTypes.nonObjectSuperclass;
+import static javax.lang.model.element.Modifier.PRIVATE;
+import static javax.lang.model.element.Modifier.STATIC;
+
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
-import com.google.common.base.Function;
-import com.google.common.base.Optional;
-import com.google.common.base.Predicate;
-import com.google.common.collect.ComparisonChain;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ImmutableSortedSet;
@@ -31,6 +36,7 @@
 import java.util.Comparator;
 import java.util.HashSet;
 import java.util.List;
+import java.util.Optional;
 import java.util.Set;
 import javax.inject.Inject;
 import javax.lang.model.element.Element;
@@ -46,13 +52,6 @@
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 
-import static com.google.auto.common.MoreElements.isAnnotationPresent;
-import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
-import static com.google.common.base.Preconditions.checkState;
-import static javax.lang.model.element.Modifier.PRIVATE;
-import static javax.lang.model.element.Modifier.STATIC;
-
 /**
  * Represents the full members injection of a particular type.
  *
@@ -62,15 +61,18 @@
 @AutoValue
 abstract class MembersInjectionBinding extends Binding {
   @Override
-  abstract Optional<MembersInjectionBinding> unresolved();
-
-  TypeElement membersInjectedType() {
-    return MoreElements.asType(bindingElement());
+  Optional<? extends Element> bindingElement() {
+    return Optional.of(membersInjectedType());
   }
 
+  abstract TypeElement membersInjectedType();
+
+  @Override
+  abstract Optional<MembersInjectionBinding> unresolved();
+
   @Override
-  Set<DependencyRequest> implicitDependencies() {
-    return dependencies();
+  Optional<TypeElement> contributingModule() {
+    return Optional.empty();
   }
 
   /** The set of individual sites where {@link Inject} is applied. */
@@ -82,15 +84,6 @@ TypeElement membersInjectedType() {
    */
   abstract Optional<Key> parentKey();
 
-  enum Strategy {
-    NO_OP,
-    INJECT_MEMBERS,
-  }
-
-  Strategy injectionStrategy() {
-    return injectionSites().isEmpty() ? Strategy.NO_OP : Strategy.INJECT_MEMBERS;
-  }
-
   @Override
   public BindingType bindingType() {
     return BindingType.MEMBERS_INJECTION;
@@ -100,14 +93,11 @@ public BindingType bindingType() {
    * Returns {@code true} if any of this binding's injection sites are directly on the bound type.
    */
   boolean hasLocalInjectionSites() {
-    return FluentIterable.from(injectionSites())
+    return injectionSites()
+        .stream()
         .anyMatch(
-            new Predicate<InjectionSite>() {
-              @Override
-              public boolean apply(InjectionSite injectionSite) {
-                return injectionSite.element().getEnclosingElement().equals(membersInjectedType());
-              }
-            });
+            injectionSite ->
+                injectionSite.element().getEnclosingElement().equals(membersInjectedType()));
   }
 
   @AutoValue
@@ -123,7 +113,7 @@ public boolean apply(InjectionSite injectionSite) {
 
     abstract ImmutableSet<DependencyRequest> dependencies();
     
-    protected int indexAmongSiblingMembers(InjectionSite injectionSite) {
+    static int indexAmongSiblingMembers(InjectionSite injectionSite) {
       return injectionSite
           .element()
           .getEnclosingElement()
@@ -173,13 +163,13 @@ private InjectionSite injectionSiteForInjectField(
     }
 
     /** Returns true if the type has some injected members in itself or any of its super classes. */
-    boolean hasInjectedMembers(DeclaredType declaredType) {
+    boolean hasInjectedMembersIn(DeclaredType declaredType) {
       return !getInjectionSites(declaredType).isEmpty();
     }
 
     /**
      * Returns a MembersInjectionBinding for the given type. If {@code resolvedType} is present,
-     * this will return a resolved binding, with the key & type resolved to the given type (using
+     * this will return a resolved binding, with the key and type resolved to the given type (using
      * {@link Types#asMemberOf(DeclaredType, Element)}).
      */
     MembersInjectionBinding forInjectedType(
@@ -198,37 +188,23 @@ MembersInjectionBinding forInjectedType(
       ImmutableSortedSet<InjectionSite> injectionSites = getInjectionSites(declaredType);
       ImmutableSet<DependencyRequest> dependencies =
           FluentIterable.from(injectionSites)
-              .transformAndConcat(
-                  new Function<InjectionSite, Set<DependencyRequest>>() {
-                    @Override
-                    public Set<DependencyRequest> apply(InjectionSite input) {
-                      return input.dependencies();
-                    }
-                  })
+              .transformAndConcat(InjectionSite::dependencies)
               .toSet();
 
       Optional<Key> parentKey =
-          MoreTypes.nonObjectSuperclass(types, elements, declaredType)
-              .transform(
-                  new Function<DeclaredType, Key>() {
-                    @Override
-                    public Key apply(DeclaredType superclass) {
-                      return keyFactory.forMembersInjectedType(superclass);
-                    }
-                  });
+          nonObjectSuperclass(types, elements, declaredType)
+              .map(keyFactory::forMembersInjectedType);
 
       Key key = keyFactory.forMembersInjectedType(declaredType);
       TypeElement typeElement = MoreElements.asType(declaredType.asElement());
       return new AutoValue_MembersInjectionBinding(
-          typeElement,
-          Optional.<TypeElement>absent(),
           key,
           dependencies,
+          typeElement,
           hasNonDefaultTypeParameters(typeElement, key.type(), types)
               ? Optional.of(
-                  forInjectedType(
-                      MoreTypes.asDeclared(typeElement.asType()), Optional.<TypeMirror>absent()))
-              : Optional.<MembersInjectionBinding>absent(),
+                  forInjectedType(MoreTypes.asDeclared(typeElement.asType()), Optional.empty()))
+              : Optional.empty(),
           injectionSites,
           parentKey);
     }
@@ -239,7 +215,7 @@ public Key apply(DeclaredType superclass) {
       SetMultimap<String, ExecutableElement> overriddenMethodMap = LinkedHashMultimap.create();
       for (Optional<DeclaredType> currentType = Optional.of(declaredType);
           currentType.isPresent();
-          currentType = MoreTypes.nonObjectSuperclass(types, elements, currentType.get())) {
+          currentType = nonObjectSuperclass(types, elements, currentType.get())) {
         final DeclaredType type = currentType.get();
         ancestors.add(MoreElements.asType(type.asElement()));
         for (Element enclosedElement : type.asElement().getEnclosedElements()) {
@@ -250,7 +226,7 @@ public Key apply(DeclaredType superclass) {
             if (shouldBeInjected(injectionSite.element(), overriddenMethodMap)) {
               injectionSites.add(injectionSite);
             }
-            if (injectionSite.kind() == InjectionSite.Kind.METHOD) {
+            if (injectionSite.kind().equals(InjectionSite.Kind.METHOD)) {
               ExecutableElement injectionSiteMethod =
                   MoreElements.asExecutable(injectionSite.element());
               overriddenMethodMap.put(
@@ -260,23 +236,16 @@ public Key apply(DeclaredType superclass) {
         }
       }
       return ImmutableSortedSet.copyOf(
-          new Comparator<InjectionSite>() {
-            @Override
-            public int compare(InjectionSite left, InjectionSite right) {
-              return ComparisonChain.start()
-                  // supertypes before subtypes
-                  .compare(
-                      ancestors.indexOf(right.element().getEnclosingElement()),
-                      ancestors.indexOf(left.element().getEnclosingElement()))
-                  // fields before methods
-                  .compare(left.element().getKind(), right.element().getKind())
-                  // then sort by whichever element comes first in the parent
-                  // this isn't necessary, but makes the processor nice and predictable
-                  .compare(
-                      left.indexAmongSiblingMembers(left), right.indexAmongSiblingMembers(right))
-                  .result();
-            }
-          },
+          // supertypes before subtypes
+          Comparator.comparing(
+                  (InjectionSite injectionSite) ->
+                      ancestors.indexOf(injectionSite.element().getEnclosingElement()))
+              .reversed()
+              // fields before methods
+              .thenComparing(injectionSite -> injectionSite.element().getKind())
+              // then sort by whichever element comes first in the parent
+              // this isn't necessary, but makes the processor nice and predictable
+              .thenComparing(InjectionSite::indexAmongSiblingMembers),
           injectionSites);
     }
 
@@ -308,8 +277,7 @@ private boolean shouldBeInjected(
     }
 
     private final ElementVisitor<Optional<InjectionSite>, DeclaredType> injectionSiteVisitor =
-        new ElementKindVisitor6<Optional<InjectionSite>, DeclaredType>(
-            Optional.<InjectionSite>absent()) {
+        new ElementKindVisitor6<Optional<InjectionSite>, DeclaredType>(Optional.empty()) {
           @Override
           public Optional<InjectionSite> visitExecutableAsMethod(
               ExecutableElement e, DeclaredType type) {
@@ -323,7 +291,7 @@ private boolean shouldBeInjected(
                     && !e.getModifiers().contains(PRIVATE)
                     && !e.getModifiers().contains(STATIC))
                 ? Optional.of(injectionSiteForInjectField(e, type))
-                : Optional.<InjectionSite>absent();
+                : Optional.empty();
           }
         };
   }
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
index dc2c28ee8..3cf636764 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Google, Inc.
+ * Copyright (C) 2014 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,11 +13,35 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal.codegen;
 
+import static com.google.common.base.Preconditions.checkState;
+import static com.google.common.collect.Iterables.getOnlyElement;
+import static com.squareup.javapoet.MethodSpec.constructorBuilder;
+import static com.squareup.javapoet.MethodSpec.methodBuilder;
+import static com.squareup.javapoet.TypeName.VOID;
+import static com.squareup.javapoet.TypeSpec.classBuilder;
+import static dagger.internal.codegen.Accessibility.isElementAccessibleFrom;
+import static dagger.internal.codegen.Accessibility.isTypeAccessibleFrom;
+import static dagger.internal.codegen.AnnotationSpecs.Suppression.RAWTYPES;
+import static dagger.internal.codegen.AnnotationSpecs.Suppression.UNCHECKED;
+import static dagger.internal.codegen.AnnotationSpecs.suppressWarnings;
+import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
+import static dagger.internal.codegen.CodeBlocks.toParametersCodeBlock;
+import static dagger.internal.codegen.SourceFiles.bindingTypeElementTypeVariableNames;
+import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
+import static dagger.internal.codegen.SourceFiles.generateBindingFieldsForDependencies;
+import static dagger.internal.codegen.SourceFiles.membersInjectorNameForType;
+import static dagger.internal.codegen.SourceFiles.parameterizedGeneratedTypeNameForBinding;
+import static dagger.internal.codegen.TypeNames.membersInjectorOf;
+import static javax.lang.model.element.Modifier.FINAL;
+import static javax.lang.model.element.Modifier.PRIVATE;
+import static javax.lang.model.element.Modifier.PUBLIC;
+import static javax.lang.model.element.Modifier.STATIC;
+
 import com.google.auto.common.MoreElements;
 import com.google.common.base.CaseFormat;
-import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
@@ -37,35 +61,12 @@
 import java.util.HashSet;
 import java.util.List;
 import java.util.Map.Entry;
+import java.util.Optional;
 import java.util.Set;
 import javax.annotation.processing.Filer;
 import javax.inject.Provider;
 import javax.lang.model.element.Element;
-import javax.lang.model.element.Modifier;
-import javax.lang.model.type.ArrayType;
-import javax.lang.model.type.DeclaredType;
-import javax.lang.model.type.TypeVisitor;
 import javax.lang.model.util.Elements;
-import javax.lang.model.util.SimpleTypeVisitor7;
-
-import static com.google.auto.common.MoreElements.getPackage;
-import static com.google.common.base.Preconditions.checkState;
-import static com.google.common.collect.Iterables.getOnlyElement;
-import static com.squareup.javapoet.MethodSpec.constructorBuilder;
-import static com.squareup.javapoet.MethodSpec.methodBuilder;
-import static com.squareup.javapoet.TypeSpec.classBuilder;
-import static dagger.internal.codegen.AnnotationSpecs.SUPPRESS_WARNINGS_RAWTYPES;
-import static dagger.internal.codegen.AnnotationSpecs.SUPPRESS_WARNINGS_UNCHECKED;
-import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
-import static dagger.internal.codegen.SourceFiles.bindingTypeElementTypeVariableNames;
-import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
-import static dagger.internal.codegen.SourceFiles.membersInjectorNameForType;
-import static dagger.internal.codegen.SourceFiles.parameterizedGeneratedTypeNameForBinding;
-import static dagger.internal.codegen.TypeNames.membersInjectorOf;
-import static javax.lang.model.element.Modifier.FINAL;
-import static javax.lang.model.element.Modifier.PRIVATE;
-import static javax.lang.model.element.Modifier.PUBLIC;
-import static javax.lang.model.element.Modifier.STATIC;
 
 /**
  * Generates {@link MembersInjector} implementations from {@link MembersInjectionBinding} instances.
@@ -95,13 +96,16 @@ ClassName nameGeneratedType(MembersInjectionBinding binding) {
   Optional<TypeSpec.Builder> write(ClassName generatedTypeName, MembersInjectionBinding binding) {
     // Empty members injection bindings are special and don't need source files.
     if (binding.injectionSites().isEmpty()) {
-      return Optional.absent();
+      return Optional.empty();
     }
     if (!injectValidator.isValidType(binding.key().type())) {
-      return Optional.absent();
+      return Optional.empty();
     }
     // We don't want to write out resolved bindings -- we want to write out the generic version.
-    checkState(!binding.unresolved().isPresent());
+    checkState(
+        !binding.unresolved().isPresent(),
+        "tried to generate a MembersInjector for a binding of a resolved generic type: %s",
+        binding);
 
     ImmutableList<TypeVariableName> typeParameters = bindingTypeElementTypeVariableNames(binding);
     TypeSpec.Builder injectorTypeBuilder =
@@ -115,7 +119,7 @@ ClassName nameGeneratedType(MembersInjectionBinding binding) {
 
     MethodSpec.Builder injectMembersBuilder =
         methodBuilder("injectMembers")
-            .returns(TypeName.VOID)
+            .returns(VOID)
             .addModifiers(PUBLIC)
             .addAnnotation(Override.class)
             .addParameter(injectedTypeName, "instance")
@@ -126,8 +130,7 @@ ClassName nameGeneratedType(MembersInjectionBinding binding) {
                 "Cannot inject members into a null reference")
             .addCode("}");
 
-    ImmutableMap<BindingKey, FrameworkField> fields =
-        SourceFiles.generateBindingFieldsForDependencies(binding);
+    ImmutableMap<BindingKey, FrameworkField> fields = generateBindingFieldsForDependencies(binding);
 
     ImmutableMap.Builder<BindingKey, FieldSpec> dependencyFieldsBuilder = ImmutableMap.builder();
 
@@ -139,7 +142,7 @@ ClassName nameGeneratedType(MembersInjectionBinding binding) {
     MethodSpec.Builder createMethodBuilder =
         methodBuilder("create")
             .returns(implementedType)
-            .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
+            .addModifiers(PUBLIC, STATIC)
             .addTypeVariables(typeParameters);
 
     createMethodBuilder.addCode(
@@ -149,19 +152,16 @@ ClassName nameGeneratedType(MembersInjectionBinding binding) {
     boolean usesRawFrameworkTypes = false;
     UniqueNameSet fieldNames = new UniqueNameSet();
     for (Entry<BindingKey, FrameworkField> fieldEntry : fields.entrySet()) {
-      BindingKey bindingKey = fieldEntry.getKey();
+      BindingKey dependencyBindingKey = fieldEntry.getKey();
       FrameworkField bindingField = fieldEntry.getValue();
 
       // If the dependency type is not visible to this members injector, then use the raw framework
       // type for the field.
       boolean useRawFrameworkType =
-          !VISIBLE_TO_MEMBERS_INJECTOR.visit(bindingKey.key().type(), binding);
+          !isTypeAccessibleFrom(dependencyBindingKey.key().type(), generatedTypeName.packageName());
 
       String fieldName = fieldNames.getUniqueName(bindingField.name());
-      TypeName fieldType =
-          useRawFrameworkType
-              ? bindingField.type().rawType
-              : bindingField.type();
+      TypeName fieldType = useRawFrameworkType ? bindingField.type().rawType : bindingField.type();
       FieldSpec.Builder fieldBuilder = FieldSpec.builder(fieldType, fieldName, PRIVATE, FINAL);
       ParameterSpec.Builder parameterBuilder = ParameterSpec.builder(fieldType, fieldName);
 
@@ -170,8 +170,8 @@ ClassName nameGeneratedType(MembersInjectionBinding binding) {
       // parameters' raw-type warnings.
       if (useRawFrameworkType) {
         usesRawFrameworkTypes = true;
-        fieldBuilder.addAnnotation(SUPPRESS_WARNINGS_RAWTYPES);
-        parameterBuilder.addAnnotation(SUPPRESS_WARNINGS_RAWTYPES);
+        fieldBuilder.addAnnotation(suppressWarnings(RAWTYPES));
+        parameterBuilder.addAnnotation(suppressWarnings(RAWTYPES));
       }
       constructorBuilder.addParameter(parameterBuilder.build());
       createMethodBuilder.addParameter(parameterBuilder.build());
@@ -180,10 +180,12 @@ ClassName nameGeneratedType(MembersInjectionBinding binding) {
       injectorTypeBuilder.addField(field);
       constructorBuilder.addStatement("assert $N != null", field);
       constructorBuilder.addStatement("this.$N = $N", field, field);
-      dependencyFieldsBuilder.put(bindingKey, field);
+      dependencyFieldsBuilder.put(dependencyBindingKey, field);
       constructorInvocationParameters.add(CodeBlock.of("$N", field));
     }
-    createMethodBuilder.addCode(CodeBlocks.join(constructorInvocationParameters.build(), ", "));
+
+    createMethodBuilder.addCode(
+        constructorInvocationParameters.build().stream().collect(toParametersCodeBlock()));
     createMethodBuilder.addCode(");");
 
     injectorTypeBuilder.addMethod(constructorBuilder.build());
@@ -194,7 +196,7 @@ ClassName nameGeneratedType(MembersInjectionBinding binding) {
     List<MethodSpec> injectMethodsForSubclasses = new ArrayList<>();
     for (InjectionSite injectionSite : binding.injectionSites()) {
       injectMembersBuilder.addCode(
-          visibleToMembersInjector(binding, injectionSite.element())
+          isElementAccessibleFrom(injectionSite.element(), generatedTypeName.packageName())
               ? directInjectMemberCodeBlock(binding, dependencyFields, injectionSite)
               : delegateInjectMemberCodeBlock(dependencyFields, injectionSite));
       if (!injectionSite.element().getModifiers().contains(PUBLIC)
@@ -211,31 +213,16 @@ ClassName nameGeneratedType(MembersInjectionBinding binding) {
     }
 
     if (usesRawFrameworkTypes) {
-      injectMembersBuilder.addAnnotation(SUPPRESS_WARNINGS_UNCHECKED);
+      injectMembersBuilder.addAnnotation(suppressWarnings(UNCHECKED));
     }
 
     injectorTypeBuilder.addMethod(injectMembersBuilder.build());
-    for (MethodSpec methodSpec : injectMethodsForSubclasses) {
-      injectorTypeBuilder.addMethod(methodSpec);
-    }
+    injectMethodsForSubclasses.forEach(injectorTypeBuilder::addMethod);
 
     return Optional.of(injectorTypeBuilder);
   }
 
-  /**
-   * Returns {@code true} if {@code element} is visible to the members injector for {@code binding}.
-   */
-  // TODO(dpb,gak): Make sure that all cases are covered here. E.g., what if element is public but
-  // enclosed in a package-private element?
-  private static boolean visibleToMembersInjector(
-      MembersInjectionBinding binding, Element element) {
-    return getPackage(element).equals(getPackage(binding.membersInjectedType()))
-        || element.getModifiers().contains(PUBLIC);
-  }
-
-  /**
-   * Returns a code block that directly injects the instance's field or method.
-   */
+  /** Returns a code block that directly injects the instance's field or method. */
   private CodeBlock directInjectMemberCodeBlock(
       MembersInjectionBinding binding,
       ImmutableMap<BindingKey, FieldSpec> dependencyFields,
@@ -302,7 +289,7 @@ private CodeBlock getInstanceCodeBlockWithPotentialCast(
     return CodeBlock.of("(($T) instance)", injectionSiteName);
   }
 
-  private String injectionSiteDelegateMethodName(Element injectionSiteElement) {
+  private static String injectionSiteDelegateMethodName(Element injectionSiteElement) {
     return "inject"
         + CaseFormat.LOWER_CAMEL.to(
             CaseFormat.UPPER_CAMEL, injectionSiteElement.getSimpleName().toString());
@@ -356,7 +343,7 @@ private MethodSpec injectorMethodForSubclasses(
   private String staticInjectMethodDependencyParameterName(
       Set<String> parameterNames, DependencyRequest dependency, FieldSpec field) {
     StringBuilder parameterName =
-        new StringBuilder(dependency.requestElement().getSimpleName().toString());
+        new StringBuilder(dependency.requestElement().get().getSimpleName().toString());
     switch (dependency.kind()) {
       case LAZY:
       case INSTANCE:
@@ -377,17 +364,4 @@ private String staticInjectMethodDependencyParameterName(
     }
     return parameterName.toString();
   }
-
-  private static final TypeVisitor<Boolean, MembersInjectionBinding> VISIBLE_TO_MEMBERS_INJECTOR =
-      new SimpleTypeVisitor7<Boolean, MembersInjectionBinding>(true) {
-        @Override
-        public Boolean visitArray(ArrayType t, MembersInjectionBinding p) {
-          return visit(t.getComponentType(), p);
-        }
-
-        @Override
-        public Boolean visitDeclared(DeclaredType t, MembersInjectionBinding p) {
-          return visibleToMembersInjector(p, t.asElement());
-        }
-      };
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorRequestFulfillment.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorRequestFulfillment.java
new file mode 100644
index 000000000..4f9e9550c
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorRequestFulfillment.java
@@ -0,0 +1,50 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.base.Preconditions.checkArgument;
+import static dagger.internal.codegen.BindingKey.Kind.MEMBERS_INJECTION;
+
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+import dagger.internal.codegen.DependencyRequest.Kind;
+
+/** Fulfills requests for {@link MembersInjectionBinding} instances. */
+final class MembersInjectorRequestFulfillment extends RequestFulfillment {
+  private final MemberSelect membersInjectorFieldSelect;
+
+  MembersInjectorRequestFulfillment(
+      BindingKey bindingKey, MemberSelect membersInjectorFieldSelect) {
+    super(bindingKey);
+    checkArgument(bindingKey.kind().equals(MEMBERS_INJECTION));
+    this.membersInjectorFieldSelect = membersInjectorFieldSelect;
+  }
+
+  @Override
+  public CodeBlock getSnippetForDependencyRequest(
+      DependencyRequest request, ClassName requestingClass) {
+    checkArgument(request.kind().equals(Kind.MEMBERS_INJECTOR));
+    return membersInjectorFieldSelect.getExpressionFor(requestingClass);
+  }
+
+  @Override
+  CodeBlock getSnippetForFrameworkDependency(
+      FrameworkDependency frameworkDependency, ClassName requestingClass) {
+    checkArgument(frameworkDependency.bindingType().equals(BindingType.MEMBERS_INJECTION));
+    return membersInjectorFieldSelect.getExpressionFor(requestingClass);
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/MethodSignature.java b/compiler/src/main/java/dagger/internal/codegen/MethodSignature.java
index 447ed24ef..c510e091c 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MethodSignature.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MethodSignature.java
@@ -1,5 +1,7 @@
 package dagger.internal.codegen;
 
+import static com.google.common.base.Preconditions.checkNotNull;
+
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Equivalence;
@@ -7,8 +9,6 @@
 import javax.lang.model.type.ExecutableType;
 import javax.lang.model.type.TypeMirror;
 
-import static com.google.common.base.Preconditions.checkNotNull;
-
 @AutoValue
 abstract class MethodSignature {
   abstract String name();
diff --git a/compiler/src/main/java/dagger/internal/codegen/MethodSignatureFormatter.java b/compiler/src/main/java/dagger/internal/codegen/MethodSignatureFormatter.java
index fa2e55555..45bb9ef15 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MethodSignatureFormatter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MethodSignatureFormatter.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Google, Inc.
+ * Copyright (C) 2014 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,14 +13,18 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal.codegen;
 
+import static com.google.common.base.Preconditions.checkState;
+import static dagger.internal.codegen.ErrorMessages.stripCommonTypePrefixes;
+import static dagger.internal.codegen.InjectionAnnotations.getQualifier;
+
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
-import com.google.common.base.Optional;
-import dagger.internal.codegen.Key.BindingMethodIdentifier;
 import java.util.Iterator;
 import java.util.List;
+import java.util.Optional;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
@@ -30,9 +34,6 @@
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Types;
 
-import static com.google.common.base.Preconditions.checkState;
-import static dagger.internal.codegen.ErrorMessages.stripCommonTypePrefixes;
-
 /**
  * Formats the signature of an {@link ExecutableElement} suitable for use in error messages.
  *
@@ -47,7 +48,7 @@
   }
 
   @Override public String format(ExecutableElement method) {
-    return format(method, Optional.<DeclaredType>absent());
+    return format(method, Optional.empty());
   }
 
   /**
@@ -94,18 +95,13 @@ public String format(ExecutableElement method, Optional<DeclaredType> container)
     return builder.toString();
   }
 
-  String format(BindingMethodIdentifier bindingMethodIdentifier) {
-    return format(
-        MoreElements.asExecutable(bindingMethodIdentifier.bindingMethod()),
-        Optional.of(MoreTypes.asDeclared(bindingMethodIdentifier.contributingModule().asType())));
-  }
-
   private static void appendParameter(StringBuilder builder, VariableElement parameter,
       TypeMirror type) {
-    Optional<AnnotationMirror> qualifier = InjectionAnnotations.getQualifier(parameter);
-    if (qualifier.isPresent()) {
-      builder.append(ErrorMessages.format(qualifier.get())).append(' ');
-    }
+    getQualifier(parameter)
+        .ifPresent(
+            qualifier -> {
+              builder.append(ErrorMessages.format(qualifier)).append(' ');
+            });
     builder.append(nameOfType(type));
   }
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/MissingBindingSuggestions.java b/compiler/src/main/java/dagger/internal/codegen/MissingBindingSuggestions.java
index 4b6f0c33c..a5311b80b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MissingBindingSuggestions.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MissingBindingSuggestions.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal.codegen;
 
 import com.google.common.collect.ImmutableList;
@@ -39,10 +40,11 @@
       BindingGraph graph = graphsToTry.removeLast();
       ResolvedBindings bindings = graph.resolvedBindings().get(key);
       if ((bindings == null) || bindings.bindings().isEmpty()) {
-        graphsToTry.addAll(graph.subgraphs().values());
+        graphsToTry.addAll(graph.subgraphs());
       } else {
-        resolutions.add("A binding with matching key exists in component: "
-            + graph.componentDescriptor().componentDefinitionType().getQualifiedName());
+        resolutions.add(
+            "A binding with matching key exists in component: "
+                + graph.componentType().getQualifiedName());
       }
     } while (!graphsToTry.isEmpty());
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java
index bfb655672..ec665409f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,17 +13,28 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal.codegen;
 
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Verify.verify;
+import static dagger.internal.codegen.ConfigurationAnnotations.getModuleAnnotation;
+import static dagger.internal.codegen.ConfigurationAnnotations.getModuleIncludes;
+import static dagger.internal.codegen.DaggerElements.getAnnotationMirror;
+import static javax.lang.model.type.TypeKind.DECLARED;
+import static javax.lang.model.type.TypeKind.NONE;
+import static javax.lang.model.util.ElementFilter.methodsIn;
+import static javax.lang.model.util.ElementFilter.typesIn;
+
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
-import com.google.common.base.Function;
-import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.Iterables;
+import com.google.common.collect.Sets;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import dagger.Binds;
+import dagger.BindsOptionalOf;
 import dagger.Module;
 import dagger.Multibindings;
 import dagger.Provides;
@@ -33,6 +44,7 @@
 import java.lang.annotation.Annotation;
 import java.util.EnumSet;
 import java.util.LinkedHashSet;
+import java.util.Optional;
 import java.util.Set;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.ExecutableElement;
@@ -40,26 +52,8 @@
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
 
-import static com.google.auto.common.MoreElements.getAnnotationMirror;
-import static com.google.auto.common.MoreElements.isAnnotationPresent;
-import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkState;
-import static com.google.common.base.Verify.verify;
-import static dagger.internal.codegen.ConfigurationAnnotations.getModuleIncludes;
-import static javax.lang.model.type.TypeKind.DECLARED;
-import static javax.lang.model.type.TypeKind.NONE;
-import static javax.lang.model.util.ElementFilter.methodsIn;
-import static javax.lang.model.util.ElementFilter.typesIn;
-
 @AutoValue
 abstract class ModuleDescriptor {
-  static final Function<ModuleDescriptor, TypeElement> getModuleElement() {
-    return new Function<ModuleDescriptor, TypeElement>() {
-      @Override public TypeElement apply(ModuleDescriptor input) {
-        return input.moduleElement();
-      }
-    };
-  }
 
   abstract TypeElement moduleElement();
 
@@ -67,27 +61,24 @@
 
   abstract ImmutableSet<ContributionBinding> bindings();
 
-  /**
-   * The multibinding declarations contained in this module.
-   */
+  /** The multibinding declarations contained in this module. */
   abstract ImmutableSet<MultibindingDeclaration> multibindingDeclarations();
 
-  /**
-   * The {@link Binds} method declarations that define delegate bindings.
-   */
+  /** The {@link Module#subcomponents() subcomponent declarations} contained in this module. */
+  abstract ImmutableSet<SubcomponentDeclaration> subcomponentDeclarations();
+
+  /** The {@link Binds} method declarations that define delegate bindings. */
   abstract ImmutableSet<DelegateDeclaration> delegateDeclarations();
 
+  /** The {@link BindsOptionalOf} method declarations that define optional bindings. */
+  abstract ImmutableSet<OptionalBindingDeclaration> optionalDeclarations();
+
   enum Kind {
-    MODULE(
-        Module.class, Provides.class, ImmutableSet.of(Module.class)),
-    PRODUCER_MODULE(
-        ProducerModule.class,
-        Produces.class,
-        ImmutableSet.of(Module.class, ProducerModule.class));
+    MODULE(Module.class, Provides.class),
+    PRODUCER_MODULE(ProducerModule.class, Produces.class);
 
     private final Class<? extends Annotation> moduleAnnotation;
     private final Class<? extends Annotation> methodAnnotation;
-    private final ImmutableSet<? extends Class<? extends Annotation>> includesTypes;
 
     /**
      * Returns the kind of an annotated element if it is annotated with one of the
@@ -105,16 +96,18 @@
       }
       checkArgument(
           kinds.size() <= 1, "%s cannot be annotated with more than one of %s", element, kinds);
-      return Optional.fromNullable(Iterables.getOnlyElement(kinds, null));
+      return kinds.stream().findFirst();
     }
 
     Kind(
         Class<? extends Annotation> moduleAnnotation,
-        Class<? extends Annotation> methodAnnotation,
-        ImmutableSet<? extends Class<? extends Annotation>> includesTypes) {
+        Class<? extends Annotation> methodAnnotation) {
       this.moduleAnnotation = moduleAnnotation;
       this.methodAnnotation = methodAnnotation;
-      this.includesTypes = includesTypes;
+    }
+
+    Optional<AnnotationMirror> getModuleAnnotationMirror(TypeElement element) {
+      return getAnnotationMirror(element, moduleAnnotation);
     }
 
     Class<? extends Annotation> moduleAnnotation() {
@@ -125,8 +118,15 @@
       return methodAnnotation;
     }
 
-    ImmutableSet<? extends Class<? extends Annotation>> includesTypes() {
-      return includesTypes;
+    ImmutableSet<Kind> includesKinds() {
+      switch (this) {
+        case MODULE:
+          return Sets.immutableEnumSet(MODULE);
+        case PRODUCER_MODULE:
+          return Sets.immutableEnumSet(MODULE, PRODUCER_MODULE);
+        default:
+          throw new AssertionError(this);
+      }
     }
   }
 
@@ -136,29 +136,34 @@
     private final ProductionBinding.Factory productionBindingFactory;
     private final MultibindingDeclaration.Factory multibindingDeclarationFactory;
     private final DelegateDeclaration.Factory bindingDelegateDeclarationFactory;
+    private final SubcomponentDeclaration.Factory subcomponentDeclarationFactory;
+    private final OptionalBindingDeclaration.Factory optionalBindingDeclarationFactory;
 
     Factory(
         Elements elements,
         ProvisionBinding.Factory provisionBindingFactory,
         ProductionBinding.Factory productionBindingFactory,
         MultibindingDeclaration.Factory multibindingDeclarationFactory,
-        DelegateDeclaration.Factory bindingDelegateDeclarationFactory) {
+        DelegateDeclaration.Factory bindingDelegateDeclarationFactory,
+        SubcomponentDeclaration.Factory subcomponentDeclarationFactory,
+        OptionalBindingDeclaration.Factory optionalBindingDeclarationFactory) {
       this.elements = elements;
       this.provisionBindingFactory = provisionBindingFactory;
       this.productionBindingFactory = productionBindingFactory;
       this.multibindingDeclarationFactory = multibindingDeclarationFactory;
       this.bindingDelegateDeclarationFactory = bindingDelegateDeclarationFactory;
+      this.subcomponentDeclarationFactory = subcomponentDeclarationFactory;
+      this.optionalBindingDeclarationFactory = optionalBindingDeclarationFactory;
     }
 
     ModuleDescriptor create(TypeElement moduleElement) {
-      checkState(getModuleAnnotation(moduleElement).isPresent(),
-          "%s did not have an AnnotationMirror for @Module",
-          moduleElement.getQualifiedName());
-
       ImmutableSet.Builder<ContributionBinding> bindings = ImmutableSet.builder();
       ImmutableSet.Builder<DelegateDeclaration> delegates = ImmutableSet.builder();
       ImmutableSet.Builder<MultibindingDeclaration> multibindingDeclarations =
           ImmutableSet.builder();
+      ImmutableSet.Builder<OptionalBindingDeclaration> optionalDeclarations =
+          ImmutableSet.builder();
+
       for (ExecutableElement moduleMethod : methodsIn(elements.getAllMembers(moduleElement))) {
         if (isAnnotationPresent(moduleMethod, Provides.class)) {
           bindings.add(provisionBindingFactory.forProvidesMethod(moduleMethod, moduleElement));
@@ -173,6 +178,10 @@ ModuleDescriptor create(TypeElement moduleElement) {
           multibindingDeclarations.add(
               multibindingDeclarationFactory.forMultibindsMethod(moduleMethod, moduleElement));
         }
+        if (isAnnotationPresent(moduleMethod, BindsOptionalOf.class)) {
+          optionalDeclarations.add(
+              optionalBindingDeclarationFactory.forMethod(moduleMethod, moduleElement));
+        }
       }
 
       for (TypeElement memberType : typesIn(elements.getAllMembers(moduleElement))) {
@@ -184,16 +193,12 @@ ModuleDescriptor create(TypeElement moduleElement) {
 
       return new AutoValue_ModuleDescriptor(
           moduleElement,
-          ImmutableSet.copyOf(
-              collectIncludedModules(new LinkedHashSet<ModuleDescriptor>(), moduleElement)),
+          ImmutableSet.copyOf(collectIncludedModules(new LinkedHashSet<>(), moduleElement)),
           bindings.build(),
           multibindingDeclarations.build(),
-          delegates.build());
-    }
-
-    private static Optional<AnnotationMirror> getModuleAnnotation(TypeElement moduleElement) {
-      return getAnnotationMirror(moduleElement, Module.class)
-          .or(getAnnotationMirror(moduleElement, ProducerModule.class));
+          subcomponentDeclarationFactory.forModule(moduleElement),
+          delegates.build(),
+          optionalDeclarations.build());
     }
 
     @CanIgnoreReturnValue
@@ -209,9 +214,11 @@ ModuleDescriptor create(TypeElement moduleElement) {
       }
       Optional<AnnotationMirror> moduleAnnotation = getModuleAnnotation(moduleElement);
       if (moduleAnnotation.isPresent()) {
-        for (TypeMirror moduleIncludesType : getModuleIncludes(moduleAnnotation.get())) {
-          includedModules.add(create(MoreTypes.asTypeElement(moduleIncludesType)));
-        }
+        getModuleIncludes(moduleAnnotation.get())
+            .stream()
+            .map(MoreTypes::asTypeElement)
+            .map(this::create)
+            .forEach(includedModules::add);
       }
       return includedModules;
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/ModuleProcessingStep.java
index 33fd0b82b..28bac6826 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleProcessingStep.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Google, Inc.
+ * Copyright (C) 2014 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,8 +13,13 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal.codegen;
 
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
+import static javax.lang.model.util.ElementFilter.methodsIn;
+import static javax.lang.model.util.ElementFilter.typesIn;
+
 import com.google.auto.common.BasicAnnotationProcessor.ProcessingStep;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.SetMultimap;
@@ -31,184 +36,158 @@
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 
-import static com.google.auto.common.MoreElements.isAnnotationPresent;
-import static dagger.internal.codegen.Util.elementsWithAnnotation;
-import static javax.lang.model.util.ElementFilter.methodsIn;
-import static javax.lang.model.util.ElementFilter.typesIn;
-
 /**
  * A {@link ProcessingStep} that validates module classes and generates factories for binding
  * methods.
- *
- * @param <B> the type of binding created from methods
  */
-final class ModuleProcessingStep<B extends Binding> implements ProcessingStep {
+final class ModuleProcessingStep implements ProcessingStep {
 
   /**
-   * A {@link ProcessingStep} for {@link Module @Module} classes that generates factories for
-   * {@link Provides @Provides} methods.
+   * A {@link ProcessingStep} for {@code @Module} classes that generates factories for
+   * {@code @Provides} methods.
    */
-  static ModuleProcessingStep<ProvisionBinding> moduleProcessingStep(
+  static ModuleProcessingStep moduleProcessingStep(
       Messager messager,
       ModuleValidator moduleValidator,
-      final ProvisionBinding.Factory provisionBindingFactory,
-      FactoryGenerator factoryGenerator,
-      ProvidesMethodValidator providesMethodValidator,
-      BindsMethodValidator bindsMethodValidator,
-      MultibindsMethodValidator multibindsMethodValidator) {
-    return new ModuleProcessingStep<>(
+      ProvisionBinding.Factory provisionBindingFactory,
+      FactoryGenerator factoryGenerator) {
+    return new ModuleProcessingStep(
         messager,
         Module.class,
         moduleValidator,
-        Provides.class,
-        new ModuleMethodBindingFactory<ProvisionBinding>() {
-          @Override
-          public ProvisionBinding bindingForModuleMethod(
-              ExecutableElement method, TypeElement module) {
-            return provisionBindingFactory.forProvidesMethod(method, module);
-          }
-        },
-        factoryGenerator,
-        ImmutableSet.of(providesMethodValidator, bindsMethodValidator, multibindsMethodValidator));
+        ImmutableSet.of(
+            new ProvisionModuleMethodFactoryGenerator(provisionBindingFactory, factoryGenerator)));
   }
 
   /**
-   * A {@link ProcessingStep} for {@link ProducerModule @ProducerModule} classes that generates
-   * factories for {@link Produces @Produces} methods.
+   * A {@link ProcessingStep} for {@code @ProducerModule} classes that generates factories for
+   * {@code @Provides} and {@code @Produces} methods.
    */
-  static ModuleProcessingStep<ProductionBinding> producerModuleProcessingStep(
+  static ModuleProcessingStep producerModuleProcessingStep(
       Messager messager,
       ModuleValidator moduleValidator,
-      final ProductionBinding.Factory productionBindingFactory,
-      ProducerFactoryGenerator producerFactoryGenerator,
-      ProducesMethodValidator producesMethodValidator,
-      BindsMethodValidator bindsMethodValidator,
-      MultibindsMethodValidator multibindsMethodValidator) {
-    return new ModuleProcessingStep<>(
+      ProvisionBinding.Factory provisionBindingFactory,
+      FactoryGenerator factoryGenerator,
+      ProductionBinding.Factory productionBindingFactory,
+      ProducerFactoryGenerator producerFactoryGenerator) {
+    return new ModuleProcessingStep(
         messager,
         ProducerModule.class,
         moduleValidator,
-        Produces.class,
-        new ModuleMethodBindingFactory<ProductionBinding>() {
-          @Override
-          public ProductionBinding bindingForModuleMethod(
-              ExecutableElement method, TypeElement module) {
-            return productionBindingFactory.forProducesMethod(method, module);
-          }
-        },
-        producerFactoryGenerator,
-        ImmutableSet.of(producesMethodValidator, bindsMethodValidator, multibindsMethodValidator));
+        ImmutableSet.of(
+            new ProvisionModuleMethodFactoryGenerator(provisionBindingFactory, factoryGenerator),
+            new ProductionModuleMethodFactoryGenerator(
+                productionBindingFactory, producerFactoryGenerator)));
   }
 
   private final Messager messager;
   private final Class<? extends Annotation> moduleAnnotation;
   private final ModuleValidator moduleValidator;
-  private final Class<? extends Annotation> factoryMethodAnnotation;
-  private final ModuleMethodBindingFactory<B> moduleMethodBindingFactory;
-  private final SourceFileGenerator<B> factoryGenerator;
-  private final ImmutableSet<? extends BindingMethodValidator> methodValidators;
+  private final ImmutableSet<ModuleMethodFactoryGenerator> moduleMethodFactoryGenerators;
   private final Set<TypeElement> processedModuleElements = Sets.newLinkedHashSet();
 
   /**
    * Creates a new processing step.
    *
    * @param moduleAnnotation the annotation on the module class
-   * @param factoryMethodAnnotation the annotation on methods that need factories
-   * @param methodValidators validators for binding methods
    */
   ModuleProcessingStep(
       Messager messager,
       Class<? extends Annotation> moduleAnnotation,
       ModuleValidator moduleValidator,
-      Class<? extends Annotation> factoryMethodAnnotation,
-      ModuleMethodBindingFactory<B> moduleMethodBindingFactory,
-      SourceFileGenerator<B> factoryGenerator,
-      Iterable<? extends BindingMethodValidator> methodValidators) {
+      ImmutableSet<ModuleMethodFactoryGenerator> moduleMethodFactoryGenerators) {
     this.messager = messager;
     this.moduleAnnotation = moduleAnnotation;
     this.moduleValidator = moduleValidator;
-    this.factoryMethodAnnotation = factoryMethodAnnotation;
-    this.moduleMethodBindingFactory = moduleMethodBindingFactory;
-    this.factoryGenerator = factoryGenerator;
-    this.methodValidators = ImmutableSet.copyOf(methodValidators);
+    this.moduleMethodFactoryGenerators = moduleMethodFactoryGenerators;
   }
 
   @Override
   public Set<? extends Class<? extends Annotation>> annotations() {
-    ImmutableSet.Builder<Class<? extends Annotation>> annotations = ImmutableSet.builder();
-    annotations.add(moduleAnnotation);
-    for (BindingMethodValidator validator : methodValidators) {
-      annotations.add(validator.methodAnnotation());
-    }
-    return annotations.build();
+    return ImmutableSet.of(moduleAnnotation);
   }
 
   @Override
   public Set<Element> process(
       SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
-    ImmutableSet<ExecutableElement> validMethods = validMethods(elementsByAnnotation);
-
-    // process each module
-    for (TypeElement moduleElement :
-        Sets.difference(
-            typesIn(elementsByAnnotation.get(moduleAnnotation)), processedModuleElements)) {
-      ValidationReport<TypeElement> report = moduleValidator.validate(moduleElement);
-      report.printMessagesTo(messager);
-
-      if (report.isClean()) {
-        List<ExecutableElement> moduleMethods = methodsIn(moduleElement.getEnclosedElements());
-        if (moduleMethodsAreValid(validMethods, moduleMethods)) {
-          for (ExecutableElement method :
-              elementsWithAnnotation(moduleMethods, factoryMethodAnnotation)) {
-            generateFactory(
-                moduleMethodBindingFactory.bindingForModuleMethod(method, moduleElement));
-          }
-        }
+    List<TypeElement> modules = typesIn(elementsByAnnotation.values());
+    moduleValidator.addKnownModules(modules);
+    for (TypeElement module : modules) {
+      if (processedModuleElements.add(module)) {
+        processModule(module);
       }
-      processedModuleElements.add(moduleElement);
     }
     return ImmutableSet.of();
   }
 
-  /** The binding methods that are valid according to their validator. */
-  private ImmutableSet<ExecutableElement> validMethods(
-      SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
-    ImmutableSet.Builder<ExecutableElement> validMethods = ImmutableSet.builder();
-    for (BindingMethodValidator validator : methodValidators) {
-      validMethods.addAll(
-          validator.validate(
-              messager, methodsIn(elementsByAnnotation.get(validator.methodAnnotation()))));
-    }
-    return validMethods.build();
-  }
-
-  /**
-   * {@code true} if all {@code moduleMethods} that are annotated with a binding method annotation
-   * are in {@code validMethods}.
-   */
-  private boolean moduleMethodsAreValid(
-      ImmutableSet<ExecutableElement> validMethods, Iterable<ExecutableElement> moduleMethods) {
-    for (ExecutableElement methodElement : moduleMethods) {
-      if (!validMethods.contains(methodElement)) {
-        for (BindingMethodValidator validator : methodValidators) {
-          if (isAnnotationPresent(methodElement, validator.methodAnnotation())) {
-            return false;
+  private void processModule(TypeElement module) {
+    ValidationReport<TypeElement> report = moduleValidator.validate(module);
+    report.printMessagesTo(messager);
+    if (report.isClean()) {
+      for (ExecutableElement method : methodsIn(module.getEnclosedElements())) {
+        for (ModuleMethodFactoryGenerator generator : moduleMethodFactoryGenerators) {
+          if (isAnnotationPresent(method, generator.factoryMethodAnnotation())) {
+            generator.generate(method, module, messager);
           }
         }
       }
     }
-    return true;
   }
 
-  private void generateFactory(B binding) {
-    try {
-      factoryGenerator.generate(binding);
-    } catch (SourceFileGenerationException e) {
-      e.printMessageTo(messager);
+  interface ModuleMethodFactoryGenerator {
+    /** Binding method annotation for which factories should be generated. */
+    Class<? extends Annotation> factoryMethodAnnotation();
+
+    /** Generates the factory source file for the given method and module. */
+    void generate(ExecutableElement method, TypeElement moduleElement, Messager messager);
+  }
+
+  private static final class ProvisionModuleMethodFactoryGenerator
+      implements ModuleMethodFactoryGenerator {
+
+    private final ProvisionBinding.Factory provisionBindingFactory;
+    private final FactoryGenerator factoryGenerator;
+
+    ProvisionModuleMethodFactoryGenerator(
+        ProvisionBinding.Factory provisionBindingFactory, FactoryGenerator factoryGenerator) {
+      this.provisionBindingFactory = provisionBindingFactory;
+      this.factoryGenerator = factoryGenerator;
+    }
+
+    @Override
+    public Class<? extends Annotation> factoryMethodAnnotation() {
+      return Provides.class;
+    }
+
+    @Override
+    public void generate(ExecutableElement method, TypeElement moduleElement, Messager messager) {
+      factoryGenerator.generate(
+          provisionBindingFactory.forProvidesMethod(method, moduleElement), messager);
     }
   }
 
-  private interface ModuleMethodBindingFactory<B extends Binding> {
-    B bindingForModuleMethod(ExecutableElement method, TypeElement module);
+  private static final class ProductionModuleMethodFactoryGenerator
+      implements ModuleMethodFactoryGenerator {
+
+    private final ProductionBinding.Factory productionBindingFactory;
+    private final ProducerFactoryGenerator producerFactoryGenerator;
+
+    ProductionModuleMethodFactoryGenerator(
+        ProductionBinding.Factory productionBindingFactory,
+        ProducerFactoryGenerator productionFactoryGenerator) {
+      this.productionBindingFactory = productionBindingFactory;
+      this.producerFactoryGenerator = productionFactoryGenerator;
+    }
+
+    @Override
+    public Class<? extends Annotation> factoryMethodAnnotation() {
+      return Produces.class;
+    }
+
+    @Override
+    public void generate(ExecutableElement method, TypeElement moduleElement, Messager messager) {
+      producerFactoryGenerator.generate(
+          productionBindingFactory.forProducesMethod(method, moduleElement), messager);
+    }
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java b/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java
index b11da4c46..6d24a5c9e 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Google, Inc.
+ * Copyright (C) 2014 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,30 +13,65 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal.codegen;
 
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
+import static com.google.auto.common.Visibility.PRIVATE;
+import static com.google.auto.common.Visibility.PUBLIC;
+import static com.google.auto.common.Visibility.effectiveVisibilityOfElement;
+import static dagger.internal.codegen.ConfigurationAnnotations.getModuleIncludes;
+import static dagger.internal.codegen.ConfigurationAnnotations.getModuleSubcomponents;
+import static dagger.internal.codegen.ConfigurationAnnotations.getModules;
+import static dagger.internal.codegen.ConfigurationAnnotations.getSubcomponentBuilder;
+import static dagger.internal.codegen.DaggerElements.getAnnotationMirror;
+import static dagger.internal.codegen.DaggerElements.isAnyAnnotationPresent;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_WITH_SAME_NAME;
+import static dagger.internal.codegen.ErrorMessages.INCOMPATIBLE_MODULE_METHODS;
+import static dagger.internal.codegen.ErrorMessages.METHOD_OVERRIDES_PROVIDES_METHOD;
+import static dagger.internal.codegen.ErrorMessages.MODULES_WITH_TYPE_PARAMS_MUST_BE_ABSTRACT;
+import static dagger.internal.codegen.ErrorMessages.ModuleMessages.moduleSubcomponentsDoesntHaveBuilder;
+import static dagger.internal.codegen.ErrorMessages.ModuleMessages.moduleSubcomponentsIncludesBuilder;
+import static dagger.internal.codegen.ErrorMessages.ModuleMessages.moduleSubcomponentsIncludesNonSubcomponent;
+import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_OVERRIDES_ANOTHER;
+import static dagger.internal.codegen.ErrorMessages.REFERENCED_MODULE_MUST_NOT_HAVE_TYPE_PARAMS;
+import static dagger.internal.codegen.ErrorMessages.REFERENCED_MODULE_NOT_ANNOTATED;
+import static dagger.internal.codegen.MoreAnnotationValues.asType;
+import static dagger.internal.codegen.Util.toImmutableSet;
+import static java.util.EnumSet.noneOf;
+import static java.util.stream.Collectors.joining;
+import static javax.lang.model.element.Modifier.ABSTRACT;
+import static javax.lang.model.element.Modifier.STATIC;
+import static javax.lang.model.util.ElementFilter.methodsIn;
+import static javax.lang.model.util.ElementFilter.typesIn;
+
 import com.google.auto.common.MoreElements;
+import com.google.auto.common.MoreTypes;
 import com.google.auto.common.Visibility;
-import com.google.common.base.Function;
 import com.google.common.base.Joiner;
-import com.google.common.base.Predicate;
 import com.google.common.collect.ArrayListMultimap;
 import com.google.common.collect.FluentIterable;
-import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ListMultimap;
 import com.google.common.collect.Sets;
 import dagger.Binds;
 import dagger.Module;
+import dagger.Multibindings;
+import dagger.Subcomponent;
 import dagger.multibindings.Multibinds;
 import dagger.producers.ProducerModule;
+import dagger.producers.ProductionSubcomponent;
 import java.lang.annotation.Annotation;
 import java.util.Collection;
 import java.util.EnumSet;
+import java.util.HashMap;
+import java.util.HashSet;
 import java.util.List;
+import java.util.Map;
 import java.util.Map.Entry;
 import java.util.Set;
 import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.AnnotationValue;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ElementKind;
 import javax.lang.model.element.ExecutableElement;
@@ -46,26 +81,9 @@
 import javax.lang.model.util.ElementFilter;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.SimpleTypeVisitor6;
+import javax.lang.model.util.SimpleTypeVisitor8;
 import javax.lang.model.util.Types;
 
-import static com.google.auto.common.MoreElements.getAnnotationMirror;
-import static com.google.auto.common.MoreElements.isAnnotationPresent;
-import static com.google.auto.common.Visibility.PRIVATE;
-import static com.google.auto.common.Visibility.PUBLIC;
-import static com.google.auto.common.Visibility.effectiveVisibilityOfElement;
-import static com.google.common.collect.Iterables.any;
-import static dagger.internal.codegen.ConfigurationAnnotations.getModuleIncludes;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_WITH_SAME_NAME;
-import static dagger.internal.codegen.ErrorMessages.INCOMPATIBLE_MODULE_METHODS;
-import static dagger.internal.codegen.ErrorMessages.METHOD_OVERRIDES_PROVIDES_METHOD;
-import static dagger.internal.codegen.ErrorMessages.MODULES_WITH_TYPE_PARAMS_MUST_BE_ABSTRACT;
-import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_OVERRIDES_ANOTHER;
-import static dagger.internal.codegen.ErrorMessages.REFERENCED_MODULE_MUST_NOT_HAVE_TYPE_PARAMS;
-import static dagger.internal.codegen.ErrorMessages.REFERENCED_MODULE_NOT_ANNOTATED;
-import static dagger.internal.codegen.Util.isAnyAnnotationPresent;
-import static javax.lang.model.element.Modifier.ABSTRACT;
-import static javax.lang.model.element.Modifier.STATIC;
-
 /**
  * A {@linkplain ValidationReport validator} for {@link Module}s or {@link ProducerModule}s.
  *
@@ -73,27 +91,63 @@
  * @since 2.0
  */
 final class ModuleValidator {
+  private static final ImmutableSet<Class<? extends Annotation>> SUBCOMPONENT_TYPES =
+      ImmutableSet.of(Subcomponent.class, ProductionSubcomponent.class);
+  private static final ImmutableSet<Class<? extends Annotation>> SUBCOMPONENT_BUILDER_TYPES =
+      ImmutableSet.of(Subcomponent.Builder.class, ProductionSubcomponent.Builder.class);
+
   private final Types types;
   private final Elements elements;
+  private final AnyBindingMethodValidator anyBindingMethodValidator;
+  private final MultibindingsValidator multibindingsValidator;
   private final MethodSignatureFormatter methodSignatureFormatter;
+  private final Map<TypeElement, ValidationReport<TypeElement>> cache = new HashMap<>();
+  private final Set<TypeElement> knownModules = new HashSet<>();
 
   ModuleValidator(
-      Types types, Elements elements, MethodSignatureFormatter methodSignatureFormatter) {
+      Types types,
+      Elements elements,
+      AnyBindingMethodValidator anyBindingMethodValidator,
+      MultibindingsValidator multibindingsValidator,
+      MethodSignatureFormatter methodSignatureFormatter) {
     this.types = types;
     this.elements = elements;
+    this.anyBindingMethodValidator = anyBindingMethodValidator;
+    this.multibindingsValidator = multibindingsValidator;
     this.methodSignatureFormatter = methodSignatureFormatter;
   }
 
-  ValidationReport<TypeElement> validate(final TypeElement subject) {
-    final ValidationReport.Builder<TypeElement> builder = ValidationReport.about(subject);
-    ModuleDescriptor.Kind moduleKind = ModuleDescriptor.Kind.forAnnotatedElement(subject).get();
+  /**
+   * Adds {@code modules} to the set of module types that will be validated during this compilation
+   * step. If a component or module includes a module that is not in this set, that included module
+   * is assumed to be valid because it was processed in a previous compilation step. If it were
+   * invalid, that previous compilation step would have failed and blocked this one.
+   *
+   * <p>This logic depends on this method being called before {@linkplain #validate(TypeElement)
+   * validating} any module or {@linkplain #validateReferencedModules(TypeElement, AnnotationMirror,
+   * ImmutableSet) component}.
+   */
+  void addKnownModules(Collection<TypeElement> modules) {
+    knownModules.addAll(modules);
+  }
+
+  /** Returns a validation report for a module type. */
+  ValidationReport<TypeElement> validate(TypeElement module) {
+    return cache.computeIfAbsent(module, this::validateUncached);
+  }
+
+  private ValidationReport<TypeElement> validateUncached(TypeElement module) {
+    ValidationReport.Builder<TypeElement> builder = ValidationReport.about(module);
+    ModuleDescriptor.Kind moduleKind = ModuleDescriptor.Kind.forAnnotatedElement(module).get();
 
-    List<ExecutableElement> moduleMethods = ElementFilter.methodsIn(subject.getEnclosedElements());
     ListMultimap<String, ExecutableElement> allMethodsByName = ArrayListMultimap.create();
     ListMultimap<String, ExecutableElement> bindingMethodsByName = ArrayListMultimap.create();
 
-    Set<ModuleMethodKind> methodKinds = EnumSet.noneOf(ModuleMethodKind.class);
-    for (ExecutableElement moduleMethod : moduleMethods) {
+    Set<ModuleMethodKind> methodKinds = noneOf(ModuleMethodKind.class);
+    for (ExecutableElement moduleMethod : methodsIn(module.getEnclosedElements())) {
+      if (anyBindingMethodValidator.isBindingMethod(moduleMethod)) {
+        builder.addSubreport(anyBindingMethodValidator.validate(moduleMethod));
+      }
       if (isAnyAnnotationPresent(
           moduleMethod,
           ImmutableSet.of(moduleKind.methodAnnotation(), Binds.class, Multibinds.class))) {
@@ -112,19 +166,78 @@
               moduleKind.methodAnnotation().getSimpleName()));
     }
 
-    validateModuleVisibility(subject, moduleKind, builder);
+    validateModuleVisibility(module, moduleKind, builder);
     validateMethodsWithSameName(moduleKind, builder, bindingMethodsByName);
-    if (subject.getKind() != ElementKind.INTERFACE) {
+    if (module.getKind() != ElementKind.INTERFACE) {
       validateProvidesOverrides(
-          subject, moduleKind, builder, allMethodsByName, bindingMethodsByName);
+          module, moduleKind, builder, allMethodsByName, bindingMethodsByName);
     }
-    validateModifiers(subject, builder);
-    validateReferencedModules(subject, moduleKind, builder);
+    validateModifiers(module, builder);
+    validateReferencedModules(module, moduleKind, builder);
+    validateReferencedSubcomponents(module, moduleKind, builder);
+    validateNestedMultibindingsTypes(module, builder);
 
-    // TODO(gak): port the dagger 1 module validation?
     return builder.build();
   }
 
+  private void validateNestedMultibindingsTypes(
+      TypeElement module, ValidationReport.Builder<TypeElement> builder) {
+    for (TypeElement nestedType : typesIn(elements.getAllMembers(module))) {
+      if (isAnnotationPresent(nestedType, Multibindings.class)) {
+        builder.addSubreport(multibindingsValidator.validate(nestedType));
+      }
+    }
+  }
+
+  private void validateReferencedSubcomponents(
+      final TypeElement subject,
+      ModuleDescriptor.Kind moduleKind,
+      final ValidationReport.Builder<TypeElement> builder) {
+    final AnnotationMirror moduleAnnotation = moduleKind.getModuleAnnotationMirror(subject).get();
+    // TODO(ronshapiro): use validateTypesAreDeclared when it is checked in
+    for (TypeMirror subcomponentAttribute : getModuleSubcomponents(moduleAnnotation)) {
+      subcomponentAttribute.accept(
+          new SimpleTypeVisitor6<Void, Void>() {
+            @Override
+            protected Void defaultAction(TypeMirror e, Void aVoid) {
+              builder.addError(e + " is not a valid subcomponent type", subject, moduleAnnotation);
+              return null;
+            }
+
+            @Override
+            public Void visitDeclared(DeclaredType declaredType, Void aVoid) {
+              TypeElement attributeType = MoreTypes.asTypeElement(declaredType);
+              if (isAnyAnnotationPresent(attributeType, SUBCOMPONENT_TYPES)) {
+                validateSubcomponentHasBuilder(attributeType, moduleAnnotation, builder);
+              } else {
+                builder.addError(
+                    isAnyAnnotationPresent(attributeType, SUBCOMPONENT_BUILDER_TYPES)
+                        ? moduleSubcomponentsIncludesBuilder(attributeType)
+                        : moduleSubcomponentsIncludesNonSubcomponent(attributeType),
+                    subject,
+                    moduleAnnotation);
+              }
+
+              return null;
+            }
+          },
+          null);
+    }
+  }
+
+  private static void validateSubcomponentHasBuilder(
+      TypeElement subcomponentAttribute,
+      AnnotationMirror moduleAnnotation,
+      ValidationReport.Builder<TypeElement> builder) {
+    if (getSubcomponentBuilder(subcomponentAttribute).isPresent()) {
+      return;
+    }
+    builder.addError(
+        moduleSubcomponentsDoesntHaveBuilder(subcomponentAttribute, moduleAnnotation),
+        builder.getSubject(),
+        moduleAnnotation);
+  }
+
   enum ModuleMethodKind {
     ABSTRACT_DECLARATION,
     INSTANCE_BINDING,
@@ -173,87 +286,76 @@ private void validateReferencedModules(
       ModuleDescriptor.Kind moduleKind,
       ValidationReport.Builder<TypeElement> builder) {
     // Validate that all the modules we include are valid for inclusion.
-    AnnotationMirror mirror = getAnnotationMirror(subject, moduleKind.moduleAnnotation()).get();
-    ImmutableList<TypeMirror> includes = getModuleIncludes(mirror);
-    validateReferencedModules(subject, builder, includes, ImmutableSet.of(moduleKind));
-  }
-
-  private static ImmutableSet<? extends Class<? extends Annotation>> includedModuleClasses(
-      ImmutableSet<ModuleDescriptor.Kind> validModuleKinds) {
-    return FluentIterable.from(validModuleKinds)
-        .transformAndConcat(
-            new Function<ModuleDescriptor.Kind, Set<? extends Class<? extends Annotation>>>() {
-              @Override
-              public Set<? extends Class<? extends Annotation>> apply(
-                  ModuleDescriptor.Kind moduleKind) {
-                return moduleKind.includesTypes();
-              }
-            })
-        .toSet();
+    AnnotationMirror mirror = moduleKind.getModuleAnnotationMirror(subject).get();
+    builder.addSubreport(validateReferencedModules(subject, mirror, moduleKind.includesKinds()));
   }
 
   /**
-   * Used by {@link ModuleValidator} & {@link ComponentValidator} to validate referenced modules.
+   * Validates modules included in a given module or installed in a given component.
+   *
+   * <p>Checks that the referenced modules are non-generic types annotated with {@code @Module} or
+   * {@code @ProducerModule}.
+   *
+   * <p>If the referenced module is in the {@linkplain #addKnownModules(Collection) known modules
+   * set} and has errors, reports an error at that module's inclusion.
+   *
+   * @param annotatedType the annotated module or component
+   * @param annotation the annotation specifying the referenced modules ({@code @Component},
+   *     {@code @ProductionComponent}, {@code @Subcomponent}, {@code @ProductionSubcomponent},
+   *     {@code @Module}, or {@code @ProducerModule})
+   * @param validModuleKinds the module kinds that the annotated type is permitted to include
    */
-  void validateReferencedModules(
-      final TypeElement subject,
-      final ValidationReport.Builder<TypeElement> builder,
-      ImmutableList<TypeMirror> includes,
+  ValidationReport<TypeElement> validateReferencedModules(
+      TypeElement annotatedType,
+      AnnotationMirror annotation,
       ImmutableSet<ModuleDescriptor.Kind> validModuleKinds) {
-    final ImmutableSet<? extends Class<? extends Annotation>> includedModuleClasses =
-        includedModuleClasses(validModuleKinds);
+    ValidationReport.Builder<TypeElement> subreport = ValidationReport.about(annotatedType);
+    ImmutableSet<? extends Class<? extends Annotation>> validModuleAnnotations =
+        validModuleKinds
+            .stream()
+            .map(ModuleDescriptor.Kind::moduleAnnotation)
+            .collect(toImmutableSet());
 
-    for (TypeMirror includesType : includes) {
-      includesType.accept(
-          new SimpleTypeVisitor6<Void, Void>() {
-            @Override
-            protected Void defaultAction(TypeMirror mirror, Void p) {
-              builder.addError(mirror + " is not a valid module type.", subject);
-              return null;
-            }
+    for (AnnotationValue includedModule : getModules(annotatedType, annotation)) {
+      asType(includedModule)
+          .accept(
+              new SimpleTypeVisitor8<Void, Void>() {
+                @Override
+                protected Void defaultAction(TypeMirror mirror, Void p) {
+                  reportError("%s is not a valid module type.", mirror);
+                  return null;
+                }
 
-            @Override
-            public Void visitDeclared(DeclaredType t, Void p) {
-              final TypeElement element = MoreElements.asType(t.asElement());
-              if (!t.getTypeArguments().isEmpty()) {
-                builder.addError(
-                    String.format(
-                        REFERENCED_MODULE_MUST_NOT_HAVE_TYPE_PARAMS, element.getQualifiedName()),
-                    subject);
-              }
-              boolean isIncludedModule =
-                  any(
-                      includedModuleClasses,
-                      new Predicate<Class<? extends Annotation>>() {
-                        @Override
-                        public boolean apply(Class<? extends Annotation> otherClass) {
-                          return MoreElements.isAnnotationPresent(element, otherClass);
-                        }
-                      });
-              if (!isIncludedModule) {
-                builder.addError(
-                    String.format(
+                @Override
+                public Void visitDeclared(DeclaredType t, Void p) {
+                  TypeElement module = MoreElements.asType(t.asElement());
+                  if (!t.getTypeArguments().isEmpty()) {
+                    reportError(
+                        REFERENCED_MODULE_MUST_NOT_HAVE_TYPE_PARAMS, module.getQualifiedName());
+                  }
+                  if (!isAnyAnnotationPresent(module, validModuleAnnotations)) {
+                    reportError(
                         REFERENCED_MODULE_NOT_ANNOTATED,
-                        element.getQualifiedName(),
-                        (includedModuleClasses.size() > 1 ? "one of " : "")
-                            + Joiner.on(", ")
-                                .join(
-                                    FluentIterable.from(includedModuleClasses)
-                                        .transform(
-                                            new Function<Class<? extends Annotation>, String>() {
-                                              @Override
-                                              public String apply(
-                                                  Class<? extends Annotation> otherClass) {
-                                                return "@" + otherClass.getSimpleName();
-                                              }
-                                            }))),
-                    subject);
-              }
-              return null;
-            }
-          },
-          null);
+                        module.getQualifiedName(),
+                        (validModuleAnnotations.size() > 1 ? "one of " : "")
+                            + validModuleAnnotations
+                                .stream()
+                                .map(otherClass -> "@" + otherClass.getSimpleName())
+                                .collect(joining(", ")));
+                  } else if (knownModules.contains(module) && !validate(module).isClean()) {
+                    reportError("%s has errors", module.getQualifiedName());
+                  }
+                  return null;
+                }
+
+                private void reportError(String format, Object... args) {
+                  subreport.addError(
+                      String.format(format, args), annotatedType, annotation, includedModule);
+                }
+              },
+              null);
     }
+    return subreport.build();
   }
 
   private void validateProvidesOverrides(
@@ -343,20 +445,8 @@ private void validateModuleVisibility(
               FluentIterable.from(
                       getModuleIncludes(
                           getAnnotationMirror(moduleElement, moduleKind.moduleAnnotation()).get()))
-                  .transform(
-                      new Function<TypeMirror, Element>() {
-                        @Override
-                        public Element apply(TypeMirror input) {
-                          return types.asElement(input);
-                        }
-                      })
-                  .filter(
-                      new Predicate<Element>() {
-                        @Override
-                        public boolean apply(Element input) {
-                          return effectiveVisibilityOfElement(input).compareTo(PUBLIC) < 0;
-                        }
-                      })
+                  .transform(types::asElement)
+                  .filter(element -> effectiveVisibilityOfElement(element).compareTo(PUBLIC) < 0)
                   .toSet();
           if (!nonPublicModules.isEmpty()) {
             reportBuilder.addError(
diff --git a/compiler/src/main/java/dagger/internal/codegen/MonitoringModuleGenerator.java b/compiler/src/main/java/dagger/internal/codegen/MonitoringModuleGenerator.java
index 438631580..5f2603e14 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MonitoringModuleGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MonitoringModuleGenerator.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,33 +13,34 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal.codegen;
 
-import com.google.common.base.Optional;
-import com.squareup.javapoet.AnnotationSpec;
+import static com.squareup.javapoet.MethodSpec.constructorBuilder;
+import static com.squareup.javapoet.MethodSpec.methodBuilder;
+import static com.squareup.javapoet.TypeSpec.classBuilder;
+import static dagger.internal.codegen.TypeNames.PRODUCTION_COMPONENT_MONITOR_FACTORY;
+import static dagger.internal.codegen.TypeNames.providerOf;
+import static dagger.internal.codegen.TypeNames.setOf;
+import static javax.lang.model.element.Modifier.ABSTRACT;
+import static javax.lang.model.element.Modifier.PRIVATE;
+import static javax.lang.model.element.Modifier.STATIC;
+
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.MethodSpec;
 import com.squareup.javapoet.TypeSpec;
 import dagger.Module;
-import dagger.Multibindings;
 import dagger.Provides;
+import dagger.multibindings.Multibinds;
 import dagger.producers.ProductionScope;
 import dagger.producers.monitoring.ProductionComponentMonitor;
 import dagger.producers.monitoring.internal.Monitors;
+import java.util.Optional;
 import javax.annotation.processing.Filer;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.util.Elements;
 
-import static com.squareup.javapoet.MethodSpec.methodBuilder;
-import static com.squareup.javapoet.TypeSpec.classBuilder;
-import static dagger.internal.codegen.TypeNames.SET_OF_FACTORIES;
-import static dagger.internal.codegen.TypeNames.providerOf;
-import static javax.lang.model.element.Modifier.ABSTRACT;
-import static javax.lang.model.element.Modifier.FINAL;
-import static javax.lang.model.element.Modifier.PUBLIC;
-import static javax.lang.model.element.Modifier.STATIC;
-
 /** Generates a monitoring module for use with production components. */
 final class MonitoringModuleGenerator extends SourceFileGenerator<TypeElement> {
 
@@ -61,29 +62,36 @@ ClassName nameGeneratedType(TypeElement componentElement) {
   Optional<TypeSpec.Builder> write(ClassName generatedTypeName, TypeElement componentElement) {
     return Optional.of(
         classBuilder(generatedTypeName)
-            .addAnnotation(
-                AnnotationSpec.builder(Module.class)
-                    .build())
-            .addModifiers(FINAL)
-            .addType(
-                TypeSpec.interfaceBuilder("DefaultSetOfFactories")
-                    .addAnnotation(Multibindings.class)
-                    .addMethod(
-                        MethodSpec.methodBuilder("setOfFactories")
-                            .addModifiers(PUBLIC, ABSTRACT)
-                            .returns(SET_OF_FACTORIES)
-                            .build())
-                    .build())
-            .addMethod(
-                methodBuilder("monitor")
-                    .returns(ProductionComponentMonitor.class)
-                    .addModifiers(STATIC)
-                    .addAnnotation(Provides.class)
-                    .addAnnotation(ProductionScope.class)
-                    .addParameter(providerOf(ClassName.get(componentElement.asType())), "component")
-                    .addParameter(providerOf(SET_OF_FACTORIES), "factories")
-                    .addStatement(
-                        "return $T.createMonitorForComponent(component, factories)", Monitors.class)
-                    .build()));
+            .addAnnotation(Module.class)
+            .addModifiers(ABSTRACT)
+            .addMethod(privateConstructor())
+            .addMethod(setOfFactories())
+            .addMethod(monitor(componentElement)));
+  }
+
+  private MethodSpec privateConstructor() {
+    return constructorBuilder().addModifiers(PRIVATE).build();
+  }
+
+  private MethodSpec setOfFactories() {
+    return methodBuilder("setOfFactories")
+        .addAnnotation(Multibinds.class)
+        .addModifiers(ABSTRACT)
+        .returns(setOf(PRODUCTION_COMPONENT_MONITOR_FACTORY))
+        .build();
+  }
+
+  private MethodSpec monitor(TypeElement componentElement) {
+    return methodBuilder("monitor")
+        .returns(ProductionComponentMonitor.class)
+        .addModifiers(STATIC)
+        .addAnnotation(Provides.class)
+        .addAnnotation(ProductionScope.class)
+        .addParameter(providerOf(ClassName.get(componentElement.asType())), "component")
+        .addParameter(
+            providerOf(setOf(PRODUCTION_COMPONENT_MONITOR_FACTORY)), "factories")
+        .addStatement(
+            "return $T.createMonitorForComponent(component, factories)", Monitors.class)
+        .build();
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/MonitoringModuleProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/MonitoringModuleProcessingStep.java
index 45e5e835c..1bd095e29 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MonitoringModuleProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MonitoringModuleProcessingStep.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal.codegen;
 
 import com.google.auto.common.BasicAnnotationProcessor.ProcessingStep;
@@ -49,11 +50,7 @@
   public Set<Element> process(
       SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
     for (Element element : elementsByAnnotation.values()) {
-      try {
-        monitoringModuleGenerator.generate(MoreElements.asType(element));
-      } catch (SourceFileGenerationException e) {
-        e.printMessageTo(messager);
-      }
+      monitoringModuleGenerator.generate(MoreElements.asType(element), messager);
     }
     return ImmutableSet.of();
   }
diff --git a/compiler/src/main/java/dagger/internal/codegen/MoreAnnotationMirrors.java b/compiler/src/main/java/dagger/internal/codegen/MoreAnnotationMirrors.java
index e81076af4..c9ab5cfcc 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MoreAnnotationMirrors.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MoreAnnotationMirrors.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 Google, Inc.
+ * Copyright (C) 2016 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,12 +13,20 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal.codegen;
 
+import static com.google.auto.common.AnnotationMirrors.getAnnotationValue;
+import static dagger.internal.codegen.MoreAnnotationValues.asAnnotationValues;
+import static dagger.internal.codegen.Util.toImmutableList;
+
 import com.google.auto.common.AnnotationMirrors;
 import com.google.common.base.Equivalence;
-import com.google.common.base.Optional;
+import com.google.common.collect.ImmutableList;
+import java.util.Optional;
 import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.Name;
+import javax.lang.model.type.TypeMirror;
 
 /**
  * A utility class for working with {@link AnnotationMirror} instances, similar to {@link
@@ -34,9 +42,7 @@ private MoreAnnotationMirrors() {}
    */
   static Optional<Equivalence.Wrapper<AnnotationMirror>> wrapOptionalInEquivalence(
       Optional<AnnotationMirror> optional) {
-    return optional.isPresent()
-        ? Optional.of(AnnotationMirrors.equivalence().wrap(optional.get()))
-        : Optional.<Equivalence.Wrapper<AnnotationMirror>>absent();
+    return optional.map(AnnotationMirrors.equivalence()::wrap);
   }
 
   /**
@@ -45,8 +51,32 @@ private MoreAnnotationMirrors() {}
    */
   static Optional<AnnotationMirror> unwrapOptionalEquivalence(
       Optional<Equivalence.Wrapper<AnnotationMirror>> wrappedOptional) {
-    return wrappedOptional.isPresent()
-        ? Optional.of(wrappedOptional.get().get())
-        : Optional.<AnnotationMirror>absent();
+    return wrappedOptional.map(Equivalence.Wrapper::get);
+  }
+
+  static Name simpleName(AnnotationMirror annotationMirror) {
+    return annotationMirror.getAnnotationType().asElement().getSimpleName();
+  }
+
+  /**
+   * Returns the value named {@code name} from {@code annotation}.
+   *
+   * @throws IllegalArgumentException unless that member represents a single type
+   */
+  static TypeMirror getTypeValue(AnnotationMirror annotation, String name) {
+    return MoreAnnotationValues.asType(getAnnotationValue(annotation, name));
+  }
+
+  /**
+   * Returns the list of types that is the value named {@code name} from {@code annotationMirror}.
+   *
+   * @throws IllegalArgumentException unless that member represents an array of types
+   */
+  static ImmutableList<TypeMirror> getTypeListValue(
+      AnnotationMirror annotationMirror, String name) {
+    return asAnnotationValues(getAnnotationValue(annotationMirror, name))
+        .stream()
+        .map(MoreAnnotationValues::asType)
+        .collect(toImmutableList());
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/MoreAnnotationValues.java b/compiler/src/main/java/dagger/internal/codegen/MoreAnnotationValues.java
new file mode 100644
index 000000000..84a4d94b0
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/MoreAnnotationValues.java
@@ -0,0 +1,75 @@
+/*
+ * Copyright (C) 2013 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import com.google.common.collect.ImmutableList;
+import java.util.List;
+import javax.lang.model.element.AnnotationValue;
+import javax.lang.model.element.AnnotationValueVisitor;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.SimpleAnnotationValueVisitor8;
+
+/** Utility methods for working with {@link AnnotationValue} instances. */
+final class MoreAnnotationValues {
+  /**
+   * Returns the list of values represented by an array annotation value.
+   *
+   * @throws IllegalArgumentException unless {@code annotationValue} represents an array
+   */
+  static ImmutableList<AnnotationValue> asAnnotationValues(AnnotationValue annotationValue) {
+    return annotationValue.accept(AS_ANNOTATION_VALUES, null);
+  }
+
+  private static final AnnotationValueVisitor<ImmutableList<AnnotationValue>, String>
+      AS_ANNOTATION_VALUES =
+          new SimpleAnnotationValueVisitor8<ImmutableList<AnnotationValue>, String>() {
+            @Override
+            public ImmutableList<AnnotationValue> visitArray(
+                List<? extends AnnotationValue> vals, String elementName) {
+              return ImmutableList.copyOf(vals);
+            }
+
+            @Override
+            protected ImmutableList<AnnotationValue> defaultAction(Object o, String elementName) {
+              throw new IllegalArgumentException(elementName + " is not an array: " + o);
+            }
+          };
+
+  /**
+   * Returns the type represented by an annotation value.
+   *
+   * @throws IllegalArgumentException unless {@code annotationValue} represents a single type
+   */
+  static TypeMirror asType(AnnotationValue annotationValue) {
+    return AS_TYPE.visit(annotationValue);
+  }
+
+  private static final AnnotationValueVisitor<TypeMirror, Void> AS_TYPE =
+      new SimpleAnnotationValueVisitor8<TypeMirror, Void>() {
+        @Override
+        public TypeMirror visitType(TypeMirror t, Void p) {
+          return t;
+        }
+
+        @Override
+        protected TypeMirror defaultAction(Object o, Void p) {
+          throw new TypeNotPresentException(o.toString(), null);
+        }
+      };
+
+  private MoreAnnotationValues() {}
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/MultibindingAnnotations.java b/compiler/src/main/java/dagger/internal/codegen/MultibindingAnnotations.java
index b2ab200b7..eaf7a1713 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MultibindingAnnotations.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MultibindingAnnotations.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 Google, Inc.
+ * Copyright (C) 2016 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,8 +13,11 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal.codegen;
 
+import static dagger.internal.codegen.DaggerElements.getAllAnnotations;
+
 import com.google.common.collect.ImmutableSet;
 import dagger.multibindings.ElementsIntoSet;
 import dagger.multibindings.IntoMap;
@@ -22,18 +25,12 @@
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.ExecutableElement;
 
-import static com.google.auto.common.MoreElements.getAnnotationMirror;
-
 /**
  * Utility methods related to processing {@link IntoSet}, {@link ElementsIntoSet}, and {@link
  * IntoMap}.
  */
 final class MultibindingAnnotations {
   static ImmutableSet<AnnotationMirror> forMethod(ExecutableElement method) {
-    return ImmutableSet.<AnnotationMirror>builder()
-        .addAll(getAnnotationMirror(method, IntoSet.class).asSet())
-        .addAll(getAnnotationMirror(method, ElementsIntoSet.class).asSet())
-        .addAll(getAnnotationMirror(method, IntoMap.class).asSet())
-        .build();
+    return getAllAnnotations(method, IntoSet.class, ElementsIntoSet.class, IntoMap.class);
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/MultibindingAnnotationsProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/MultibindingAnnotationsProcessingStep.java
index 6da60c38c..df977c235 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MultibindingAnnotationsProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MultibindingAnnotationsProcessingStep.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 Google, Inc.
+ * Copyright (C) 2016 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,8 +13,13 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal.codegen;
 
+import static dagger.internal.codegen.DaggerElements.getAnnotationMirror;
+import static dagger.internal.codegen.DaggerElements.isAnyAnnotationPresent;
+import static dagger.internal.codegen.ErrorMessages.MULTIBINDING_ANNOTATION_NOT_ON_BINDING_METHOD;
+
 import com.google.auto.common.BasicAnnotationProcessor.ProcessingStep;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.SetMultimap;
@@ -32,13 +37,9 @@
 import javax.lang.model.element.Element;
 import javax.tools.Diagnostic.Kind;
 
-import static com.google.auto.common.MoreElements.getAnnotationMirror;
-import static dagger.internal.codegen.ErrorMessages.MULTIBINDING_ANNOTATION_NOT_ON_BINDING_METHOD;
-import static dagger.internal.codegen.Util.isAnyAnnotationPresent;
-
 /**
- * Processing step which verifies that {@link IntoSet @IntoSet}, {@link ElementsIntoSet
- * @ElementsIntoSet} and {@link IntoMap @IntoMap} are not present on invalid elements.
+ * Processing step that verifies that {@link IntoSet}, {@link ElementsIntoSet} and {@link IntoMap}
+ * are not present on invalid elements.
  */
 final class MultibindingAnnotationsProcessingStep implements ProcessingStep {
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/MultibindingDeclaration.java b/compiler/src/main/java/dagger/internal/codegen/MultibindingDeclaration.java
index d41b71663..5be39a059 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MultibindingDeclaration.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MultibindingDeclaration.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,11 +13,16 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal.codegen;
 
+import static com.google.auto.common.MoreElements.getLocalAndInheritedMethods;
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
+import static com.google.common.base.Preconditions.checkArgument;
+import static javax.lang.model.element.ElementKind.INTERFACE;
+
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
-import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableSet;
 import dagger.Module;
 import dagger.Multibindings;
@@ -27,6 +32,7 @@
 import dagger.producers.Producer;
 import dagger.producers.ProducerModule;
 import java.util.Map;
+import java.util.Optional;
 import java.util.Set;
 import javax.inject.Provider;
 import javax.lang.model.element.Element;
@@ -38,11 +44,6 @@
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 
-import static com.google.auto.common.MoreElements.getLocalAndInheritedMethods;
-import static com.google.auto.common.MoreElements.isAnnotationPresent;
-import static com.google.common.base.Preconditions.checkArgument;
-import static javax.lang.model.element.ElementKind.INTERFACE;
-
 /**
  * A declaration that a multibinding with a certain key is available to be injected in a component
  * even if the component has no multibindings for that key. Identified by a map- or set-returning
@@ -102,7 +103,8 @@
       DeclaredType interfaceType = MoreTypes.asDeclared(interfaceElement.asType());
 
       ImmutableSet.Builder<MultibindingDeclaration> declarations = ImmutableSet.builder();
-      for (ExecutableElement method : getLocalAndInheritedMethods(interfaceElement, elements)) {
+      for (ExecutableElement method :
+          getLocalAndInheritedMethods(interfaceElement, types, elements)) {
         if (!method.getEnclosingElement().equals(objectElement)) {
           ExecutableType methodType =
               MoreTypes.asExecutable(types.asMemberOf(interfaceType, method));
@@ -146,7 +148,7 @@ private MultibindingDeclaration forDeclaredMethod(
           "%s must return a set or map",
           method);
       return new AutoValue_MultibindingDeclaration(
-          method,
+          Optional.<Element>of(method),
           Optional.of(contributingType),
           keyFactory.forMultibindsMethod(bindingType, methodType, method),
           contributionType(returnType),
diff --git a/compiler/src/main/java/dagger/internal/codegen/MultibindingsMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/MultibindingsMethodValidator.java
index b32338e93..fed327ff1 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MultibindingsMethodValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MultibindingsMethodValidator.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 Google, Inc.
+ * Copyright (C) 2016 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal.codegen;
 
 import com.google.common.collect.ImmutableSet;
diff --git a/compiler/src/main/java/dagger/internal/codegen/MultibindingsProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/MultibindingsProcessingStep.java
index db14a695b..a52d5cd7b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MultibindingsProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MultibindingsProcessingStep.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,8 +13,11 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal.codegen;
 
+import static javax.lang.model.util.ElementFilter.typesIn;
+
 import com.google.auto.common.BasicAnnotationProcessor.ProcessingStep;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.SetMultimap;
@@ -25,10 +28,9 @@
 import javax.lang.model.element.Element;
 import javax.lang.model.element.TypeElement;
 
-import static javax.lang.model.util.ElementFilter.typesIn;
-
 /**
- * Processes elements annotated with {@link Multibindings @Multibindings}.
+ * Valdiates types annotated with {@link Multibindings @Multibindings} that haven't already been
+ * validated while processing their enclosing modules.
  */
 class MultibindingsProcessingStep implements ProcessingStep {
   private final Messager messager;
@@ -48,7 +50,9 @@
   public Set<Element> process(
       SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
     for (TypeElement element : typesIn(elementsByAnnotation.values())) {
-      multibindingsValidator.validate(element).printMessagesTo(messager);
+      if (!multibindingsValidator.wasAlreadyValidated(element)) {
+        multibindingsValidator.validate(element).printMessagesTo(messager);
+      }
     }
     return ImmutableSet.of();
   }
diff --git a/compiler/src/main/java/dagger/internal/codegen/MultibindingsValidator.java b/compiler/src/main/java/dagger/internal/codegen/MultibindingsValidator.java
index 664029937..4785b64cb 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MultibindingsValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MultibindingsValidator.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,18 +13,8 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package dagger.internal.codegen;
 
-import com.google.common.base.Optional;
-import com.google.common.collect.ImmutableListMultimap;
-import dagger.Module;
-import dagger.Multibindings;
-import dagger.producers.ProducerModule;
-import java.util.Collection;
-import java.util.Map;
-import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.TypeElement;
-import javax.lang.model.util.Elements;
+package dagger.internal.codegen;
 
 import static com.google.auto.common.MoreElements.getLocalAndInheritedMethods;
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
@@ -36,37 +26,66 @@
 import static dagger.internal.codegen.ErrorMessages.MultibindingsMessages.tooManyMethodsForKey;
 import static javax.lang.model.element.ElementKind.INTERFACE;
 
+import com.google.common.collect.ImmutableListMultimap;
+import dagger.Module;
+import dagger.Multibindings;
+import dagger.producers.ProducerModule;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Optional;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
+
 /**
  * A {@linkplain ValidationReport validator} for {@link Multibindings @Multibindings}-annotated
  * types.
  */
 final class MultibindingsValidator {
   private final Elements elements;
+  private final Types types;
   private final Key.Factory keyFactory;
   private final KeyFormatter keyFormatter;
   private final MethodSignatureFormatter methodSignatureFormatter;
   private final TypeElement objectElement;
   private final MultibindingsMethodValidator multibindingsMethodValidator;
+  private final Map<TypeElement, ValidationReport<TypeElement>> reports = new HashMap<>();
 
   MultibindingsValidator(
       Elements elements,
+      Types types,
       Key.Factory keyFactory,
       KeyFormatter keyFormatter,
       MethodSignatureFormatter methodSignatureFormatter,
       MultibindingsMethodValidator multibindingsMethodValidator) {
     this.elements = elements;
+    this.types = types;
     this.keyFactory = keyFactory;
     this.keyFormatter = keyFormatter;
     this.methodSignatureFormatter = methodSignatureFormatter;
     this.multibindingsMethodValidator = multibindingsMethodValidator;
     this.objectElement = elements.getTypeElement(Object.class.getCanonicalName());
   }
-
+  
   /**
-   * Returns a report containing validation errors for a
-   * {@link Multibindings @Multibindings}-annotated type.
+   * Returns a report containing validation errors for a {@link
+   * Multibindings @Multibindings}-annotated type.
    */
   public ValidationReport<TypeElement> validate(TypeElement multibindingsType) {
+    return reports.computeIfAbsent(multibindingsType, this::validateUncached);
+  }
+
+  /**
+   * Returns {@code true} if {@code multibindingsType} was already {@linkplain
+   * #validate(TypeElement) validated}.
+   */
+  boolean wasAlreadyValidated(TypeElement multibindingsType) {
+    return reports.containsKey(multibindingsType);
+  }
+
+  private ValidationReport<TypeElement> validateUncached(TypeElement multibindingsType) {
     ValidationReport.Builder<TypeElement> validation = ValidationReport.about(multibindingsType);
     if (!multibindingsType.getKind().equals(INTERFACE)) {
       validation.addError(MUST_BE_INTERFACE, multibindingsType);
@@ -81,7 +100,8 @@
 
     ImmutableListMultimap.Builder<Key, ExecutableElement> methodsByKey =
         ImmutableListMultimap.builder();
-    for (ExecutableElement method : getLocalAndInheritedMethods(multibindingsType, elements)) {
+    for (ExecutableElement method :
+        getLocalAndInheritedMethods(multibindingsType, types, elements)) {
       // Skip methods in Object.
       if (method.getEnclosingElement().equals(objectElement)) {
         continue;
@@ -116,13 +136,13 @@ private String tooManyMultibindingsMethodsForKey(Key key, Collection<ExecutableE
     return builder.toString();
   }
 
-  private Optional<BindingType> bindingType(TypeElement multibindingsType) {
+  private static Optional<BindingType> bindingType(TypeElement multibindingsType) {
     if (isAnnotationPresent(multibindingsType.getEnclosingElement(), Module.class)) {
       return Optional.of(BindingType.PROVISION);
     } else if (isAnnotationPresent(multibindingsType.getEnclosingElement(), ProducerModule.class)) {
       return Optional.of(BindingType.PRODUCTION);
     } else {
-      return Optional.<BindingType>absent();
+      return Optional.empty();
     }
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/MultibindsMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/MultibindsMethodValidator.java
index d31a7d990..35ae26c00 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MultibindsMethodValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MultibindsMethodValidator.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 Google, Inc.
+ * Copyright (C) 2016 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,36 +13,29 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal.codegen;
 
+import static dagger.internal.codegen.BindingMethodValidator.Abstractness.MUST_BE_ABSTRACT;
+import static dagger.internal.codegen.BindingMethodValidator.AllowsMultibindings.NO_MULTIBINDINGS;
+import static dagger.internal.codegen.BindingMethodValidator.ExceptionSuperclass.NO_EXCEPTIONS;
+import static dagger.internal.codegen.ErrorMessages.MultibindsMessages.METHOD_MUST_RETURN_MAP_OR_SET;
+import static dagger.internal.codegen.ErrorMessages.MultibindsMessages.PARAMETERS;
+import static dagger.internal.codegen.FrameworkTypes.isFrameworkType;
+
 import com.google.auto.common.MoreTypes;
 import com.google.common.collect.ImmutableSet;
-import dagger.MapKey;
 import dagger.Module;
 import dagger.Multibindings;
-import dagger.multibindings.ElementsIntoSet;
-import dagger.multibindings.IntoMap;
-import dagger.multibindings.IntoSet;
 import dagger.multibindings.Multibinds;
 import dagger.producers.ProducerModule;
 import java.lang.annotation.Annotation;
-import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 
-import static dagger.internal.codegen.BindingMethodValidator.Abstractness.MUST_BE_ABSTRACT;
-import static dagger.internal.codegen.ErrorMessages.MultibindsMessages.METHOD_MUST_RETURN_MAP_OR_SET;
-import static dagger.internal.codegen.ErrorMessages.MultibindsMessages.NO_MAP_KEY;
-import static dagger.internal.codegen.ErrorMessages.MultibindsMessages.PARAMETERS;
-import static dagger.internal.codegen.FrameworkTypes.isFrameworkType;
-import static dagger.internal.codegen.MapKeys.getMapKeys;
-
-/**
- * A validator for {@link Multibinds @Multibinds} methods or methods in {@link Multibindings
- * @Multibindings} interfaces.
- */
+/** A validator for {@link Multibinds} methods or methods in {@link Multibindings} interfaces. */
 class MultibindsMethodValidator extends BindingMethodValidator {
 
   /** Creates a validator for {@link Multibinds @Multibinds} methods. */
@@ -61,7 +54,8 @@ protected MultibindsMethodValidator(
         methodAnnotation,
         enclosingElementAnnotations,
         MUST_BE_ABSTRACT,
-        ExceptionSuperclass.NONE);
+        NO_EXCEPTIONS,
+        NO_MULTIBINDINGS);
   }
   
   @Override
@@ -86,25 +80,6 @@ protected void checkReturnType(ValidationReport.Builder<ExecutableElement> build
     }
   }
 
-  /** Adds an error if the method has any {@link MapKey @MapKey} annotations. */
-  @Override
-  protected void checkMapKeys(ValidationReport.Builder<ExecutableElement> builder) {
-    ImmutableSet<? extends AnnotationMirror> mapKeys = getMapKeys(builder.getSubject());
-    if (!mapKeys.isEmpty()) {
-      builder.addError(formatErrorMessage(NO_MAP_KEY));
-    }
-  }
-
-  /**
-   * {@link MultibindingAnnotationsProcessingStep} reports an error if {@link IntoMap @IntoMap},
-   * {@link IntoSet @IntoSet}, or {@link ElementsIntoSet @ElementsIntoSet} are applied to the method
-   * at all, so no need to check again.
-   */
-  @Override
-  protected void checkMultibindings(ValidationReport.Builder<ExecutableElement> builder) {
-    // no-op
-  }
-
   private boolean isPlainMap(TypeMirror returnType) {
     if (!MapType.isMap(returnType)) {
       return false;
diff --git a/compiler/src/main/java/dagger/internal/codegen/OptionalBindingDeclaration.java b/compiler/src/main/java/dagger/internal/codegen/OptionalBindingDeclaration.java
new file mode 100644
index 000000000..357e621d7
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/OptionalBindingDeclaration.java
@@ -0,0 +1,57 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
+import static com.google.common.base.Preconditions.checkArgument;
+
+import com.google.auto.value.AutoValue;
+import dagger.BindsOptionalOf;
+import java.util.Optional;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
+
+/** A {@link BindsOptionalOf} declaration. */
+@AutoValue
+abstract class OptionalBindingDeclaration extends BindingDeclaration {
+
+  /**
+   * {@inheritDoc}
+   *
+   * <p>The key's type is the method's return type, even though the synthetic bindings will be for
+   * {@code Optional} of derived types.
+   */
+  @Override
+  public abstract Key key();
+
+  static class Factory {
+    private final Key.Factory keyFactory;
+
+    Factory(Key.Factory keyFactory) {
+      this.keyFactory = keyFactory;
+    }
+
+    OptionalBindingDeclaration forMethod(ExecutableElement method, TypeElement contributingModule) {
+      checkArgument(isAnnotationPresent(method, BindsOptionalOf.class));
+      return new AutoValue_OptionalBindingDeclaration(
+          Optional.<Element>of(method),
+          Optional.of(contributingModule),
+          keyFactory.forBindsOptionalOfMethod(method, contributingModule));
+    }
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/OptionalFactories.java b/compiler/src/main/java/dagger/internal/codegen/OptionalFactories.java
new file mode 100644
index 000000000..4d608f8c7
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/OptionalFactories.java
@@ -0,0 +1,367 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.base.CaseFormat.UPPER_CAMEL;
+import static com.google.common.base.CaseFormat.UPPER_UNDERSCORE;
+import static com.squareup.javapoet.MethodSpec.constructorBuilder;
+import static com.squareup.javapoet.MethodSpec.methodBuilder;
+import static com.squareup.javapoet.TypeSpec.anonymousClassBuilder;
+import static com.squareup.javapoet.TypeSpec.classBuilder;
+import static dagger.internal.codegen.AnnotationSpecs.Suppression.RAWTYPES;
+import static dagger.internal.codegen.AnnotationSpecs.Suppression.UNCHECKED;
+import static dagger.internal.codegen.TypeNames.PROVIDER;
+import static dagger.internal.codegen.TypeNames.listenableFutureOf;
+import static dagger.internal.codegen.TypeNames.providerOf;
+import static javax.lang.model.element.Modifier.FINAL;
+import static javax.lang.model.element.Modifier.PRIVATE;
+import static javax.lang.model.element.Modifier.PUBLIC;
+import static javax.lang.model.element.Modifier.STATIC;
+
+import com.google.auto.value.AutoValue;
+import com.google.common.base.Function;
+import com.google.common.util.concurrent.Futures;
+import com.google.common.util.concurrent.ListenableFuture;
+import com.google.common.util.concurrent.MoreExecutors;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.FieldSpec;
+import com.squareup.javapoet.MethodSpec;
+import com.squareup.javapoet.ParameterSpec;
+import com.squareup.javapoet.ParameterizedTypeName;
+import com.squareup.javapoet.TypeName;
+import com.squareup.javapoet.TypeSpec;
+import com.squareup.javapoet.TypeVariableName;
+import dagger.internal.InstanceFactory;
+import dagger.internal.Preconditions;
+import dagger.internal.codegen.OptionalType.OptionalKind;
+import dagger.producers.Producer;
+import dagger.producers.internal.Producers;
+import java.util.Comparator;
+import java.util.Map;
+import java.util.TreeMap;
+import java.util.concurrent.Executor;
+import javax.inject.Provider;
+
+/** The nested class and static methods required by the component to implement optional bindings. */
+// TODO(dpb): Name members simply if a component uses only one of Guava or JDK Optional.
+final class OptionalFactories {
+
+  /**
+   * The factory classes that implement {@code Provider<Optional<T>>} or {@code
+   * Producer<Optional<T>>} for present optional bindings for a given kind of dependency request
+   * within the component.
+   *
+   * <p>The key is the {@code Provider<Optional<T>>} type.
+   */
+  private final Map<PresentFactorySpec, TypeSpec> presentFactoryClasses =
+      new TreeMap<>(
+          Comparator.comparing(PresentFactorySpec::valueKind)
+              .thenComparing(PresentFactorySpec::bindingType)
+              .thenComparing(PresentFactorySpec::optionalKind));
+
+  /**
+   * The static methods that return a {@code Provider<Optional<T>>} that always returns an absent
+   * value.
+   */
+  private final Map<OptionalKind, MethodSpec> absentOptionalProviderMethods = new TreeMap<>();
+
+  /**
+   * The static fields for {@code Provider<Optional<T>>} objects that always return an absent value.
+   */
+  private final Map<OptionalKind, FieldSpec> absentOptionalProviderFields = new TreeMap<>();
+
+  /**
+   * Returns an expression that calls a static method that returns a {@code Provider<Optional<T>>}
+   * for absent optional bindings.
+   */
+  CodeBlock absentOptionalProvider(ContributionBinding binding) {
+    OptionalKind optionalKind = OptionalType.from(binding.key()).kind();
+    return CodeBlock.of(
+        "$N()",
+        absentOptionalProviderMethods.computeIfAbsent(
+            optionalKind, this::absentOptionalProviderMethod));
+  }
+
+  /**
+   * Creates a method specification for a {@code Provider<Optional<T>>} that always returns an
+   * absent value.
+   */
+  private MethodSpec absentOptionalProviderMethod(OptionalKind optionalKind) {
+    TypeVariableName typeVariable = TypeVariableName.get("T");
+    return methodBuilder(
+            String.format(
+                "absent%sProvider", UPPER_UNDERSCORE.to(UPPER_CAMEL, optionalKind.name())))
+        .addModifiers(PRIVATE, STATIC)
+        .addTypeVariable(typeVariable)
+        .returns(providerOf(optionalKind.of(typeVariable)))
+        .addJavadoc(
+            "Returns a {@link $T} that returns {@code $L}.",
+            Provider.class,
+            optionalKind.absentValueExpression())
+        .addCode("$L // safe covariant cast\n", AnnotationSpecs.suppressWarnings(UNCHECKED))
+        .addCode(
+            "$1T provider = ($1T) $2N;",
+            providerOf(optionalKind.of(typeVariable)),
+            absentOptionalProviderFields.computeIfAbsent(
+                optionalKind, this::absentOptionalProviderField))
+        .addCode("return provider;")
+        .build();
+  }
+
+  /**
+   * Creates a field specification for a {@code Provider<Optional<T>>} that always returns an absent
+   * value.
+   */
+  private FieldSpec absentOptionalProviderField(OptionalKind optionalKind) {
+    return FieldSpec.builder(
+            PROVIDER,
+            String.format("ABSENT_%s_PROVIDER", optionalKind.name()),
+            PRIVATE,
+            STATIC,
+            FINAL)
+        .addAnnotation(AnnotationSpecs.suppressWarnings(RAWTYPES))
+        .initializer("$T.create($L)", InstanceFactory.class, optionalKind.absentValueExpression())
+        .addJavadoc(
+            "A {@link $T} that returns {@code $L}.",
+            Provider.class,
+            optionalKind.absentValueExpression())
+        .build();
+  }
+
+  /** Information about the type of a factory for present bindings. */
+  @AutoValue
+  abstract static class PresentFactorySpec {
+    /** Whether the factory is a {@link Provider} or a {@link Producer}. */
+    abstract BindingType bindingType();
+
+    /** What kind of {@code Optional} is returned. */
+    abstract OptionalKind optionalKind();
+
+    /** The kind of request satisfied by the value of the {@code Optional}. */
+    abstract DependencyRequest.Kind valueKind();
+
+    /** The type variable for the factory class. */
+    TypeVariableName typeVariable() {
+      return TypeVariableName.get("T");
+    }
+
+    /** The type contained by the {@code Optional}. */
+    TypeName valueType() {
+      return valueKind().typeName(typeVariable());
+    }
+
+    /** The type provided or produced by the factory. */
+    ParameterizedTypeName optionalType() {
+      return optionalKind().of(valueType());
+    }
+
+    /** The type of the factory. */
+    ParameterizedTypeName factoryType() {
+      return bindingType().frameworkClassOf(optionalType());
+    }
+
+    /** The type of the delegate provider or producer. */
+    ParameterizedTypeName delegateType() {
+      return bindingType().frameworkClassOf(typeVariable());
+    }
+
+    /** The name of the factory class. */
+    String factoryClassName() {
+      return new StringBuilder("Present")
+          .append(UPPER_UNDERSCORE.to(UPPER_CAMEL, optionalKind().name()))
+          .append(UPPER_UNDERSCORE.to(UPPER_CAMEL, valueKind().toString()))
+          .append(bindingType().frameworkClass().getSimpleName())
+          .toString();
+    }
+
+    private static PresentFactorySpec of(ContributionBinding binding) {
+      OptionalKind optionalKind = OptionalType.from(binding.key()).kind();
+      DependencyRequest.Kind valueKind =
+          DependencyRequest.extractKindAndType(OptionalType.from(binding.key()).valueType()).kind();
+      return new AutoValue_OptionalFactories_PresentFactorySpec(
+          binding.bindingType(), optionalKind, valueKind);
+    }
+  }
+  
+  /**
+   * Returns an expression for an instance of a nested class that implements {@code
+   * Provider<Optional<T>>} or {@code Producer<Optional<T>>} for a present optional binding, where
+   * {@code T} represents dependency requests of that kind.
+   *
+   * <ul>
+   * <li>If {@code optionalRequestKind} is {@link DependencyRequest.Kind#INSTANCE}, the class
+   *     implements {@code ProviderOrProducer<Optional<T>>}.
+   * <li>If {@code optionalRequestKind} is {@link DependencyRequest.Kind#PROVIDER}, the class
+   *     implements {@code Provider<Optional<Provider<T>>>}.
+   * <li>If {@code optionalRequestKind} is {@link DependencyRequest.Kind#LAZY}, the class implements
+   *     {@code Provider<Optional<Lazy<T>>>}.
+   * <li>If {@code optionalRequestKind} is {@link DependencyRequest.Kind#PROVIDER_OF_LAZY}, the
+   *     class implements {@code Provider<Optional<Provider<Lazy<T>>>>}.
+   * <li>If {@code optionalRequestKind} is {@link DependencyRequest.Kind#PRODUCER}, the class
+   *     implements {@code Producer<Optional<Producer<T>>>}.
+   * <li>If {@code optionalRequestKind} is {@link DependencyRequest.Kind#PRODUCED}, the class
+   *     implements {@code Producer<Optional<Produced<T>>>}.
+   * </ul>
+   *
+   * @param delegateFactory an expression for a {@link Provider} or {@link Producer} of the
+   *     underlying type
+   */
+  CodeBlock presentOptionalFactory(ContributionBinding binding, CodeBlock delegateFactory) {
+    return CodeBlock.of(
+        "$N.of($L)",
+        presentFactoryClasses.computeIfAbsent(
+            PresentFactorySpec.of(binding), this::presentOptionalFactoryClass),
+        delegateFactory);
+  }
+
+  private TypeSpec presentOptionalFactoryClass(PresentFactorySpec spec) {
+    FieldSpec delegateField =
+        FieldSpec.builder(spec.delegateType(), "delegate", PRIVATE, FINAL).build();
+    ParameterSpec delegateParameter = ParameterSpec.builder(delegateField.type, "delegate").build();
+
+    MethodSpec.Builder getMethodBuilder =
+        methodBuilder("get").addAnnotation(Override.class).addModifiers(PUBLIC);
+    switch (spec.bindingType()) {
+      case PROVISION:
+        getMethodBuilder
+            .returns(spec.optionalType())
+            .addCode(
+                "return $L;",
+                spec.optionalKind()
+                    .presentExpression(
+                        FrameworkType.PROVIDER.to(
+                            spec.valueKind(), CodeBlock.of("$N", delegateField))));
+        break;
+
+      case PRODUCTION:
+        getMethodBuilder.returns(listenableFutureOf(spec.optionalType()));
+
+        switch (spec.valueKind()) {
+          case FUTURE: // return a ListenableFuture<Optional<ListenableFuture<T>>>
+          case PRODUCER: // return a ListenableFuture<Optional<Producer<T>>>
+            getMethodBuilder.addCode(
+                "return $T.immediateFuture($L);",
+                Futures.class,
+                spec.optionalKind()
+                    .presentExpression(
+                        FrameworkType.PRODUCER.to(
+                            spec.valueKind(), CodeBlock.of("$N", delegateField))));
+            break;
+
+          case INSTANCE: // return a ListenableFuture<Optional<T>>
+            getMethodBuilder.addCode(
+                "return $L;",
+                transformFutureToOptional(
+                    spec.optionalKind(),
+                    spec.typeVariable(),
+                    CodeBlock.of("$N.get()", delegateField)));
+            break;
+
+          case PRODUCED: // return a ListenableFuture<Optional<Produced<T>>>
+            getMethodBuilder.addCode(
+                "return $L;",
+                transformFutureToOptional(
+                    spec.optionalKind(),
+                    spec.valueType(),
+                    CodeBlock.of(
+                        "$T.createFutureProduced($N.get())", Producers.class, delegateField)));
+            break;
+
+          default:
+            throw new UnsupportedOperationException(
+                spec.factoryType() + " objects are not supported");
+        }
+        break;
+
+      default:
+        throw new AssertionError(spec.bindingType());
+    }
+
+    return classBuilder(spec.factoryClassName())
+        .addTypeVariable(spec.typeVariable())
+        .addModifiers(PRIVATE, STATIC, FINAL)
+        .addSuperinterface(spec.factoryType())
+        .addJavadoc(
+            "A {@code $T} that uses a delegate {@code $T}.", spec.factoryType(), delegateField.type)
+        .addField(delegateField)
+        .addMethod(
+            constructorBuilder()
+                .addModifiers(PRIVATE)
+                .addParameter(delegateParameter)
+                .addCode(
+                    "this.$N = $T.checkNotNull($N);",
+                    delegateField,
+                    Preconditions.class,
+                    delegateParameter)
+                .build())
+        .addMethod(getMethodBuilder.build())
+        .addMethod(
+            methodBuilder("of")
+                .addModifiers(PRIVATE, STATIC)
+                .addTypeVariable(spec.typeVariable())
+                .returns(spec.factoryType())
+                .addParameter(delegateParameter)
+                .addCode(
+                    "return new $L<$T>($N);",
+                    spec.factoryClassName(),
+                    spec.typeVariable(),
+                    delegateParameter)
+                .build())
+        .build();
+  }
+
+  /**
+   * An expression that uses {@link Futures#transform(ListenableFuture, Function, Executor)} to
+   * transform a {@code ListenableFuture<inputType>} into a {@code
+   * ListenableFuture<Optional<inputType>>}.
+   *
+   * @param inputFuture an expression of type {@code ListenableFuture<inputType>}
+   */
+  private static CodeBlock transformFutureToOptional(
+      OptionalKind optionalKind, TypeName inputType, CodeBlock inputFuture) {
+    return CodeBlock.of(
+        "$T.transform($L, $L, $T.directExecutor())",
+        Futures.class,
+        inputFuture,
+        anonymousClassBuilder("")
+            .addSuperinterface(
+                ParameterizedTypeName.get(
+                    ClassName.get(Function.class), inputType, optionalKind.of(inputType)))
+            .addMethod(
+                methodBuilder("apply")
+                    .addAnnotation(Override.class)
+                    .addModifiers(PUBLIC)
+                    .returns(optionalKind.of(inputType))
+                    .addParameter(inputType, "input")
+                    .addCode("return $L;", optionalKind.presentExpression(CodeBlock.of("input")))
+                    .build())
+            .build(),
+        MoreExecutors.class);
+  }
+
+  /**
+   * Adds classes and methods required by previous calls to {@link
+   * #absentOptionalProvider(ContributionBinding)} and {@link
+   * #presentOptionalFactory(ContributionBinding, CodeBlock)} to the top-level {@code component}.
+   */
+  void addMembers(TypeSpec.Builder component) {
+    component.addTypes(presentFactoryClasses.values());
+    component.addMethods(absentOptionalProviderMethods.values());
+    component.addFields(absentOptionalProviderFields.values());
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/OptionalType.java b/compiler/src/main/java/dagger/internal/codegen/OptionalType.java
new file mode 100644
index 000000000..f154ab2d1
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/OptionalType.java
@@ -0,0 +1,143 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.base.Preconditions.checkArgument;
+
+import com.google.auto.common.MoreElements;
+import com.google.auto.common.MoreTypes;
+import com.google.auto.value.AutoValue;
+import com.google.common.base.Equivalence;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.ParameterizedTypeName;
+import com.squareup.javapoet.TypeName;
+import java.util.Optional;
+import javax.lang.model.element.Name;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.type.TypeVisitor;
+import javax.lang.model.util.SimpleTypeVisitor8;
+
+/**
+ * Information about an {@code Optional} {@link TypeMirror}.
+ *
+ * <p>{@link com.google.common.base.Optional} and {@link java.util.Optional} are supported.
+ */
+@AutoValue
+abstract class OptionalType {
+
+  /** A variant of {@code Optional}. */
+  enum OptionalKind {
+    /** {@link com.google.common.base.Optional}. */
+    GUAVA_OPTIONAL(com.google.common.base.Optional.class, "absent"),
+
+    /** {@link java.util.Optional}. */
+    JDK_OPTIONAL(java.util.Optional.class, "empty"),
+    ;
+
+    private final Class<?> clazz;
+    private final String absentFactoryMethodName;
+
+    OptionalKind(Class<?> clazz, String absentFactoryMethodName) {
+      this.clazz = clazz;
+      this.absentFactoryMethodName = absentFactoryMethodName;
+    }
+
+    /** Returns {@code valueType} wrapped in the correct class. */
+    ParameterizedTypeName of(TypeName valueType) {
+      return ParameterizedTypeName.get(ClassName.get(clazz), valueType);
+    }
+
+    /** Returns an expression for the absent/empty value. */
+    CodeBlock absentValueExpression() {
+      return CodeBlock.of("$T.$L()", clazz, absentFactoryMethodName);
+    }
+
+    /** Returns an expression for the present {@code value}. */
+    CodeBlock presentExpression(CodeBlock value) {
+      return CodeBlock.of("$T.of($L)", clazz, value);
+    }
+  }
+
+  private static final TypeVisitor<Optional<OptionalKind>, Void> OPTIONAL_KIND =
+      new SimpleTypeVisitor8<Optional<OptionalKind>, Void>(Optional.empty()) {
+        @Override
+        public Optional<OptionalKind> visitDeclared(DeclaredType t, Void p) {
+          for (OptionalKind optionalKind : OptionalKind.values()) {
+            Name qualifiedName = MoreElements.asType(t.asElement()).getQualifiedName();
+            if (qualifiedName.contentEquals(optionalKind.clazz.getCanonicalName())) {
+              return Optional.of(optionalKind);
+            }
+          }
+          return Optional.empty();
+        }
+      };
+
+  /**
+   * The optional type itself, wrapped using {@link MoreTypes#equivalence()}.
+   *
+   * @deprecated Use {@link #declaredOptionalType()} instead.
+   */
+  @Deprecated
+  protected abstract Equivalence.Wrapper<DeclaredType> wrappedDeclaredOptionalType();
+
+  /** The optional type itself. */
+  @SuppressWarnings("deprecation")
+  DeclaredType declaredOptionalType() {
+    return wrappedDeclaredOptionalType().get();
+  }
+  
+  /** Which {@code Optional} type is used. */
+  OptionalKind kind() {
+    return declaredOptionalType().accept(OPTIONAL_KIND, null).get();
+  }
+
+  /** The value type. */
+  TypeMirror valueType() {
+    return declaredOptionalType().getTypeArguments().get(0);
+  }
+
+  /** Returns {@code true} if {@code type} is an {@code Optional} type. */
+  static boolean isOptional(TypeMirror type) {
+    return type.accept(OPTIONAL_KIND, null).isPresent();
+  }
+
+  /** Returns {@code true} if {@code key.type()} is an {@code Optional} type. */
+  static boolean isOptional(Key key) {
+    return isOptional(key.type());
+  }
+
+  /**
+   * Returns a {@link OptionalType} for {@code type}.
+   *
+   * @throws IllegalArgumentException if {@code type} is not an {@code Optional} type
+   */
+  static OptionalType from(TypeMirror type) {
+    checkArgument(isOptional(type), "%s must be an Optional", type);
+    return new AutoValue_OptionalType(MoreTypes.equivalence().wrap(MoreTypes.asDeclared(type)));
+  }
+
+  /**
+   * Returns a {@link OptionalType} for {@code key}'s {@link Key#type() type}.
+   *
+   * @throws IllegalArgumentException if {@code key.type()} is not an {@code Optional} type
+   */
+  static OptionalType from(Key key) {
+    return from(key.type());
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/Optionals.java b/compiler/src/main/java/dagger/internal/codegen/Optionals.java
new file mode 100644
index 000000000..e74be14e4
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/Optionals.java
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.collect.Lists.asList;
+
+import java.util.Comparator;
+import java.util.Optional;
+
+/** Utilities for {@link Optional}s. */
+final class Optionals {
+  /**
+   * A {@link Comparator} that puts empty {@link Optional}s before present ones, and compares
+   * present {@link Optional}s by their values.
+   */
+  static <C extends Comparable<C>> Comparator<Optional<C>> optionalComparator() {
+    return Comparator.comparing((Optional<C> optional) -> optional.isPresent())
+        .thenComparing(Optional::get);
+  }
+
+  /** Returns the first argument that is present, or empty if none are. */
+  @SafeVarargs
+  static <T> Optional<T> firstPresent(Optional<T> first, Optional<T> second, Optional<T>... rest) {
+    return asList(first, second, rest)
+        .stream()
+        .filter(Optional::isPresent)
+        .findFirst()
+        .orElse(Optional.empty());
+  }
+
+  private Optionals() {}
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
index 22613b440..7a2c2c586 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Google, Inc.
+ * Copyright (C) 2014 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,50 +13,55 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package dagger.internal.codegen;
 
-import com.google.common.base.Function;
-import com.google.common.base.Joiner;
-import com.google.common.base.Optional;
-import com.google.common.base.Predicate;
-import com.google.common.collect.FluentIterable;
-import com.google.common.collect.ImmutableList;
-import com.google.common.collect.ImmutableMap;
-import com.google.common.collect.Iterables;
-import com.squareup.javapoet.ClassName;
-import com.squareup.javapoet.CodeBlock;
-import com.squareup.javapoet.MethodSpec;
-import com.squareup.javapoet.ParameterizedTypeName;
-import com.squareup.javapoet.TypeName;
-import com.squareup.javapoet.TypeSpec;
-import dagger.producers.Producer;
-import javax.annotation.processing.Filer;
-import javax.lang.model.element.Element;
-import javax.lang.model.type.TypeMirror;
-import javax.lang.model.util.Elements;
+package dagger.internal.codegen;
 
+import static com.google.common.base.Preconditions.checkArgument;
 import static com.squareup.javapoet.ClassName.OBJECT;
 import static com.squareup.javapoet.MethodSpec.constructorBuilder;
 import static com.squareup.javapoet.MethodSpec.methodBuilder;
 import static com.squareup.javapoet.TypeSpec.classBuilder;
-import static dagger.internal.codegen.AnnotationSpecs.SUPPRESS_WARNINGS_UNCHECKED;
+import static dagger.internal.codegen.AnnotationSpecs.Suppression.UNCHECKED;
 import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
 import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
+import static dagger.internal.codegen.SourceFiles.generateBindingFieldsForDependencies;
 import static dagger.internal.codegen.SourceFiles.generatedClassNameForBinding;
 import static dagger.internal.codegen.TypeNames.ASYNC_FUNCTION;
+import static dagger.internal.codegen.TypeNames.EXECUTOR;
 import static dagger.internal.codegen.TypeNames.FUTURES;
 import static dagger.internal.codegen.TypeNames.PRODUCERS;
 import static dagger.internal.codegen.TypeNames.PRODUCER_TOKEN;
+import static dagger.internal.codegen.TypeNames.RUNNABLE;
 import static dagger.internal.codegen.TypeNames.VOID_CLASS;
 import static dagger.internal.codegen.TypeNames.abstractProducerOf;
 import static dagger.internal.codegen.TypeNames.listOf;
 import static dagger.internal.codegen.TypeNames.listenableFutureOf;
 import static dagger.internal.codegen.TypeNames.producedOf;
+import static java.util.stream.Collectors.joining;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.PROTECTED;
 import static javax.lang.model.element.Modifier.PUBLIC;
-import static javax.lang.model.element.Modifier.STATIC;
+
+import com.google.common.base.Joiner;
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.Iterables;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.FieldSpec;
+import com.squareup.javapoet.MethodSpec;
+import com.squareup.javapoet.ParameterizedTypeName;
+import com.squareup.javapoet.TypeName;
+import com.squareup.javapoet.TypeSpec;
+import dagger.producers.Producer;
+import java.util.Map;
+import java.util.Optional;
+import javax.annotation.processing.Filer;
+import javax.lang.model.element.Element;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Elements;
 
 /**
  * Generates {@link Producer} implementations from {@link ProductionBinding} instances.
@@ -79,12 +84,14 @@ ClassName nameGeneratedType(ProductionBinding binding) {
 
   @Override
   Optional<? extends Element> getElementForErrorReporting(ProductionBinding binding) {
-    return Optional.of(binding.bindingElement());
+    return binding.bindingElement();
   }
 
   @Override
   Optional<TypeSpec.Builder> write(ClassName generatedTypeName, ProductionBinding binding) {
-    TypeName providedTypeName = TypeName.get(binding.factoryType());
+    checkArgument(binding.bindingElement().isPresent());
+
+    TypeName providedTypeName = TypeName.get(binding.contributedType());
     TypeName futureTypeName = listenableFutureOf(providedTypeName);
 
     TypeSpec.Builder factoryBuilder =
@@ -92,25 +99,46 @@ ClassName nameGeneratedType(ProductionBinding binding) {
             .addModifiers(PUBLIC, FINAL)
             .superclass(abstractProducerOf(providedTypeName));
 
-    ImmutableMap<BindingKey, FrameworkField> fields =
-        SourceFiles.generateBindingFieldsForDependencies(binding);
+    UniqueNameSet uniqueFieldNames = new UniqueNameSet();
+    ImmutableMap.Builder<BindingKey, FieldSpec> fieldsBuilder = ImmutableMap.builder();
+
+    MethodSpec.Builder constructorBuilder = constructorBuilder().addModifiers(PUBLIC);
+
+    Optional<FieldSpec> moduleField =
+        binding.requiresModuleInstance()
+            ? Optional.of(
+                addFieldAndConstructorParameter(
+                    factoryBuilder,
+                    constructorBuilder,
+                    uniqueFieldNames.getUniqueName("module"),
+                    TypeName.get(binding.bindingTypeElement().get().asType())))
+            : Optional.empty();
+
+    for (Map.Entry<BindingKey, FrameworkField> entry :
+        generateBindingFieldsForDependencies(binding).entrySet()) {
+      BindingKey bindingKey = entry.getKey();
+      FrameworkField bindingField = entry.getValue();
+      FieldSpec field =
+          addFieldAndConstructorParameter(
+              factoryBuilder,
+              constructorBuilder,
+              uniqueFieldNames.getUniqueName(bindingField.name()),
+              bindingField.type());
+      fieldsBuilder.put(bindingKey, field);
+    }
+    ImmutableMap<BindingKey, FieldSpec> fields = fieldsBuilder.build();
 
-    MethodSpec.Builder constructorBuilder =
-        constructorBuilder()
-            .addModifiers(PUBLIC)
-            .addStatement(
-                "super($L, $L)",
-                fields.get(binding.monitorRequest().get().bindingKey()).name(),
-                producerTokenConstruction(generatedTypeName, binding));
+    constructorBuilder.addStatement(
+        "super($N, $L)",
+        fields.get(binding.monitorRequest().get().bindingKey()),
+        producerTokenConstruction(generatedTypeName, binding));
 
-    if (!binding.bindingElement().getModifiers().contains(STATIC)) {
-      TypeName moduleType = TypeName.get(binding.bindingTypeElement().asType());
-      addFieldAndConstructorParameter(factoryBuilder, constructorBuilder, "module", moduleType);
+    if (binding.requiresModuleInstance()) {
+      assignField(constructorBuilder, moduleField.get());
     }
-
-    for (FrameworkField bindingField : fields.values()) {
-      addFieldAndConstructorParameter(
-          factoryBuilder, constructorBuilder, bindingField.name(), bindingField.type());
+    
+    for (FieldSpec field : fields.values()) {
+      assignField(constructorBuilder, field);
     }
 
     MethodSpec.Builder computeMethodBuilder =
@@ -122,8 +150,7 @@ ClassName nameGeneratedType(ProductionBinding binding) {
     ImmutableList<DependencyRequest> asyncDependencies = asyncDependencies(binding);
     for (DependencyRequest dependency : asyncDependencies) {
       TypeName futureType = listenableFutureOf(asyncDependencyType(dependency));
-      CodeBlock futureAccess =
-          CodeBlock.of("$L.get()", fields.get(dependency.bindingKey()).name());
+      CodeBlock futureAccess = CodeBlock.of("$N.get()", fields.get(dependency.bindingKey()));
       computeMethodBuilder.addStatement(
           "$T $L = $L",
           futureType,
@@ -135,13 +162,15 @@ ClassName nameGeneratedType(ProductionBinding binding) {
     FutureTransform futureTransform = FutureTransform.create(fields, binding, asyncDependencies);
 
     computeMethodBuilder.addStatement(
-        "return $T.transformAsync($L, this, executorProvider.get())",
+        "return $T.transformAsync($L, this, this)",
         FUTURES,
         futureTransform.futureCodeBlock());
 
-    factoryBuilder.addSuperinterface(
-        ParameterizedTypeName.get(
-            ASYNC_FUNCTION, futureTransform.applyArgType(), providedTypeName));
+    factoryBuilder
+        .addSuperinterface(
+            ParameterizedTypeName.get(
+                ASYNC_FUNCTION, futureTransform.applyArgType(), providedTypeName))
+        .addSuperinterface(EXECUTOR);
 
     MethodSpec.Builder applyMethodBuilder =
         methodBuilder("apply")
@@ -163,47 +192,62 @@ ClassName nameGeneratedType(ProductionBinding binding) {
                     providedTypeName,
                     futureTransform.parameterCodeBlocks()));
     if (futureTransform.hasUncheckedCast()) {
-      applyMethodBuilder.addAnnotation(SUPPRESS_WARNINGS_UNCHECKED);
+      applyMethodBuilder.addAnnotation(AnnotationSpecs.suppressWarnings(UNCHECKED));
     }
 
+    MethodSpec.Builder executeMethodBuilder =
+        methodBuilder("execute")
+            .addModifiers(PUBLIC)
+            .addJavadoc("@deprecated this may only be called from the internal {@link #compute()}")
+            .addAnnotation(Deprecated.class)
+            .addAnnotation(Override.class)
+            .addParameter(RUNNABLE, "runnable")
+            .addStatement(
+                "assert monitor != null : $S",
+                "execute() may only be called internally from compute(); "
+                    + "if it's called explicitly, the monitor might be null")
+            .addStatement("monitor.ready()")
+            .addStatement("executorProvider.get().execute(runnable)");
+
     factoryBuilder.addMethod(constructorBuilder.build());
     factoryBuilder.addMethod(computeMethodBuilder.build());
     factoryBuilder.addMethod(applyMethodBuilder.build());
+    factoryBuilder.addMethod(executeMethodBuilder.build());
 
     // TODO(gak): write a sensible toString
     return Optional.of(factoryBuilder);
   }
 
   // TODO(ronshapiro): consolidate versions of these
-  private static void addFieldAndConstructorParameter(
+  private static FieldSpec addFieldAndConstructorParameter(
       TypeSpec.Builder typeBuilder,
       MethodSpec.Builder constructorBuilder,
       String variableName,
       TypeName variableType) {
-    typeBuilder.addField(variableType, variableName, PRIVATE, FINAL);
+    FieldSpec field = FieldSpec.builder(variableType, variableName, PRIVATE, FINAL).build();
+    typeBuilder.addField(field);
+    constructorBuilder.addParameter(field.type, field.name);
+    return field;
+  }
+
+  private static void assignField(MethodSpec.Builder constructorBuilder, FieldSpec field) {
     constructorBuilder
-        .addParameter(variableType, variableName)
-        .addStatement("assert $L != null", variableName)
-        .addStatement("this.$1L = $1L", variableName);
+        .addStatement("assert $N != null", field)
+        .addStatement("this.$1N = $1N", field);
   }
 
   /** Returns a list of dependencies that are generated asynchronously. */
   private static ImmutableList<DependencyRequest> asyncDependencies(Binding binding) {
     final ImmutableMap<DependencyRequest, FrameworkDependency> frameworkDependencies =
-        FrameworkDependency.indexByDependencyRequest(
-            FrameworkDependency.frameworkDependenciesForBinding(binding));
-    return FluentIterable.from(binding.implicitDependencies())
+        binding.dependenciesToFrameworkDependenciesMap();
+    return FluentIterable.from(binding.dependencies())
         .filter(
-            new Predicate<DependencyRequest>() {
-              @Override
-              public boolean apply(DependencyRequest dependency) {
-                return isAsyncDependency(dependency)
+            dependency ->
+                isAsyncDependency(dependency)
                     && frameworkDependencies
                         .get(dependency)
                         .frameworkClass()
-                        .equals(Producer.class);
-              }
-            })
+                        .equals(Producer.class))
         .toList();
   }
 
@@ -215,23 +259,23 @@ private CodeBlock producerTokenConstruction(
                 "$S",
                 String.format(
                     "%s#%s",
-                    ClassName.get(binding.bindingTypeElement()),
-                    binding.bindingElement().getSimpleName()))
+                    ClassName.get(binding.bindingTypeElement().get()),
+                    binding.bindingElement().get().getSimpleName()))
             : CodeBlock.of("$T.class", generatedTypeName);
     return CodeBlock.of("$T.create($L)", PRODUCER_TOKEN, producerTokenArgs);
   }
 
   /** Returns a name of the variable representing this dependency's future. */
   private static String dependencyFutureName(DependencyRequest dependency) {
-    return dependency.requestElement().getSimpleName() + "Future";
+    return dependency.requestElement().get().getSimpleName() + "Future";
   }
 
   /** Represents the transformation of an input future by a producer method. */
   abstract static class FutureTransform {
-    protected final ImmutableMap<BindingKey, FrameworkField> fields;
+    protected final ImmutableMap<BindingKey, FieldSpec> fields;
     protected final ProductionBinding binding;
 
-    FutureTransform(ImmutableMap<BindingKey, FrameworkField> fields, ProductionBinding binding) {
+    FutureTransform(ImmutableMap<BindingKey, FieldSpec> fields, ProductionBinding binding) {
       this.fields = fields;
       this.binding = binding;
     }
@@ -254,7 +298,7 @@ boolean hasUncheckedCast() {
     }
 
     static FutureTransform create(
-        ImmutableMap<BindingKey, FrameworkField> fields,
+        ImmutableMap<BindingKey, FieldSpec> fields,
         ProductionBinding binding,
         ImmutableList<DependencyRequest> asyncDependencies) {
       if (asyncDependencies.isEmpty()) {
@@ -269,8 +313,7 @@ static FutureTransform create(
   }
 
   static final class NoArgFutureTransform extends FutureTransform {
-    NoArgFutureTransform(
-        ImmutableMap<BindingKey, FrameworkField> fields, ProductionBinding binding) {
+    NoArgFutureTransform(ImmutableMap<BindingKey, FieldSpec> fields, ProductionBinding binding) {
       super(fields, binding);
     }
 
@@ -292,11 +335,10 @@ String applyArgName() {
     @Override
     ImmutableList<CodeBlock> parameterCodeBlocks() {
       ImmutableList.Builder<CodeBlock> parameterCodeBlocks = ImmutableList.builder();
-      for (DependencyRequest dependency : binding.dependencies()) {
+      for (DependencyRequest dependency : binding.explicitDependencies()) {
         parameterCodeBlocks.add(
             frameworkTypeUsageStatement(
-                CodeBlock.of("$L", fields.get(dependency.bindingKey()).name()),
-                dependency.kind()));
+                CodeBlock.of("$N", fields.get(dependency.bindingKey())), dependency.kind()));
       }
       return parameterCodeBlocks.build();
     }
@@ -306,7 +348,7 @@ String applyArgName() {
     private final DependencyRequest asyncDependency;
 
     SingleArgFutureTransform(
-        ImmutableMap<BindingKey, FrameworkField> fields,
+        ImmutableMap<BindingKey, FieldSpec> fields,
         ProductionBinding binding,
         DependencyRequest asyncDependency) {
       super(fields, binding);
@@ -325,13 +367,13 @@ TypeName applyArgType() {
 
     @Override
     String applyArgName() {
-      return asyncDependency.requestElement().getSimpleName().toString();
+      return asyncDependency.requestElement().get().getSimpleName().toString();
     }
 
     @Override
     ImmutableList<CodeBlock> parameterCodeBlocks() {
       ImmutableList.Builder<CodeBlock> parameterCodeBlocks = ImmutableList.builder();
-      for (DependencyRequest dependency : binding.dependencies()) {
+      for (DependencyRequest dependency : binding.explicitDependencies()) {
         // We really want to compare instances here, because asyncDependency is an element in the
         // set binding.dependencies().
         if (dependency == asyncDependency) {
@@ -340,8 +382,7 @@ String applyArgName() {
           parameterCodeBlocks.add(
               // TODO(ronshapiro) extract this into a method shared by FutureTransform subclasses
               frameworkTypeUsageStatement(
-                  CodeBlock.of("$L", fields.get(dependency.bindingKey()).name()),
-                  dependency.kind()));
+                  CodeBlock.of("$N", fields.get(dependency.bindingKey())), dependency.kind()));
         }
       }
       return parameterCodeBlocks.build();
@@ -352,7 +393,7 @@ String applyArgName() {
     private final ImmutableList<DependencyRequest> asyncDependencies;
 
     MultiArgFutureTransform(
-        ImmutableMap<BindingKey, FrameworkField> fields,
+        ImmutableMap<BindingKey, FieldSpec> fields,
         ProductionBinding binding,
         ImmutableList<DependencyRequest> asyncDependencies) {
       super(fields, binding);
@@ -365,15 +406,10 @@ CodeBlock futureCodeBlock() {
           "$T.<$T>allAsList($L)",
           FUTURES,
           OBJECT,
-          makeParametersCodeBlock(
-              FluentIterable.from(asyncDependencies)
-                  .transform(
-                      new Function<DependencyRequest, CodeBlock>() {
-                        @Override
-                        public CodeBlock apply(DependencyRequest dependency) {
-                          return CodeBlock.of("$L", dependencyFutureName(dependency));
-                        }
-                      })));
+          asyncDependencies
+              .stream()
+              .map(ProducerFactoryGenerator::dependencyFutureName)
+              .collect(joining(", ")));
     }
 
     @Override
@@ -420,12 +456,10 @@ private static TypeName asyncDependencyType(DependencyRequest dependency) {
   }
 
   private static ImmutableList<CodeBlock> getParameterCodeBlocks(
-      ProductionBinding binding,
-      ImmutableMap<BindingKey, FrameworkField> fields,
-      String listArgName) {
+      ProductionBinding binding, ImmutableMap<BindingKey, FieldSpec> fields, String listArgName) {
     int argIndex = 0;
     ImmutableList.Builder<CodeBlock> codeBlocks = ImmutableList.builder();
-    for (DependencyRequest dependency : binding.dependencies()) {
+    for (DependencyRequest dependency : binding.explicitDependencies()) {
       if (isAsyncDependency(dependency)) {
         codeBlocks.add(
             CodeBlock.of(
@@ -434,8 +468,7 @@ private static TypeName asyncDependencyType(DependencyRequest dependency) {
       } else {
         codeBlocks.add(
             frameworkTypeUsageStatement(
-                CodeBlock.of("$L", fields.get(dependency.bindingKey()).name()),
-                dependency.kind()));
+                CodeBlock.of("$N", fields.get(dependency.bindingKey())), dependency.kind()));
       }
     }
     return codeBlocks.build();
@@ -457,10 +490,10 @@ private CodeBlock getInvocationCodeBlock(
     CodeBlock moduleCodeBlock =
         CodeBlock.of(
             "$L.$L($L)",
-            binding.bindingElement().getModifiers().contains(STATIC)
-                ? CodeBlock.of("$T", ClassName.get(binding.bindingTypeElement()))
-                : CodeBlock.of("$T.this.module", generatedTypeName),
-            binding.bindingElement().getSimpleName(),
+            binding.requiresModuleInstance()
+                ? CodeBlock.of("$T.this.module", generatedTypeName)
+                : CodeBlock.of("$T", ClassName.get(binding.bindingTypeElement().get())),
+            binding.bindingElement().get().getSimpleName(),
             makeParametersCodeBlock(parameterCodeBlocks));
 
     // NOTE(beder): We don't worry about catching exceptions from the monitor methods themselves
@@ -469,11 +502,21 @@ private CodeBlock getInvocationCodeBlock(
     ImmutableList.Builder<CodeBlock> codeBlocks = ImmutableList.builder();
     codeBlocks.add(CodeBlock.of("monitor.methodStarting();"));
 
-    CodeBlock returnCodeBlock =
-        binding.bindingKind().equals(ContributionBinding.Kind.FUTURE_PRODUCTION)
-            ? moduleCodeBlock
-            : CodeBlock.of(
-                "$T.<$T>immediateFuture($L)", FUTURES, providedTypeName, moduleCodeBlock);
+    final CodeBlock returnCodeBlock;
+    switch (binding.productionKind().get()) {
+      case IMMEDIATE:
+        returnCodeBlock =
+            CodeBlock.of("$T.<$T>immediateFuture($L)", FUTURES, providedTypeName, moduleCodeBlock);
+        break;
+      case FUTURE:
+        returnCodeBlock = moduleCodeBlock;
+        break;
+      case SET_OF_FUTURE:
+        returnCodeBlock = CodeBlock.of("$T.allAsSet($L)", PRODUCERS, moduleCodeBlock);
+        break;
+      default:
+        throw new AssertionError();
+    }
     return CodeBlock.of(
         Joiner.on('\n')
             .join(
@@ -493,13 +536,6 @@ private CodeBlock getInvocationCodeBlock(
    */
   private FluentIterable<? extends TypeName> getThrownTypeNames(
       Iterable<? extends TypeMirror> thrownTypes) {
-    return FluentIterable.from(thrownTypes)
-        .transform(
-            new Function<TypeMirror, TypeName>() {
-              @Override
-              public TypeName apply(TypeMirror type) {
-                return TypeName.get(type);
-              }
-            });
+    return FluentIterable.from(thrownTypes).transform(TypeName::get);
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProducerFieldRequestFulfillment.java b/compiler/src/main/java/dagger/internal/codegen/ProducerFieldRequestFulfillment.java
new file mode 100644
index 000000000..a0c61c85c
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/ProducerFieldRequestFulfillment.java
@@ -0,0 +1,52 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.base.Preconditions.checkArgument;
+import static dagger.internal.codegen.BindingKey.Kind.CONTRIBUTION;
+import static dagger.internal.codegen.BindingType.PRODUCTION;
+
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+
+/** Fulfills requests for {@link ProductionBinding} instances. */
+final class ProducerFieldRequestFulfillment extends RequestFulfillment {
+  private final MemberSelect producerFieldSelect;
+
+  ProducerFieldRequestFulfillment(BindingKey bindingKey, MemberSelect producerFieldSelect) {
+    super(bindingKey);
+    checkArgument(bindingKey.kind().equals(CONTRIBUTION));
+    this.producerFieldSelect = producerFieldSelect;
+  }
+
+  @Override
+  public CodeBlock getSnippetForDependencyRequest(
+      DependencyRequest request, ClassName requestingClass) {
+    return FrameworkType.PRODUCER.to(
+        request.kind(), producerFieldSelect.getExpressionFor(requestingClass));
+  }
+
+  @Override
+  CodeBlock getSnippetForFrameworkDependency(
+      FrameworkDependency frameworkDependency, ClassName requestingClass) {
+    checkArgument(
+        frameworkDependency.bindingType().equals(PRODUCTION),
+        "%s is not a production dependency",
+        frameworkDependency);
+    return producerFieldSelect.getExpressionFor(requestingClass);
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProducesMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/ProducesMethodValidator.java
index c6468fa6f..bc71b08f1 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProducesMethodValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProducesMethodValidator.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Google, Inc.
+ * Copyright (C) 2014 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,14 +13,25 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal.codegen;
 
+import static com.google.common.collect.Iterables.getOnlyElement;
+import static dagger.internal.codegen.BindingMethodValidator.Abstractness.MUST_BE_CONCRETE;
+import static dagger.internal.codegen.BindingMethodValidator.AllowsMultibindings.ALLOWS_MULTIBINDINGS;
+import static dagger.internal.codegen.BindingMethodValidator.ExceptionSuperclass.EXCEPTION;
+import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_NULLABLE;
+import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_RAW_FUTURE;
+import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_RETURN_TYPE;
+import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_SCOPE;
+import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_SET_VALUES_RETURN_SET;
+
 import com.google.auto.common.MoreTypes;
-import com.google.common.base.Optional;
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.multibindings.ElementsIntoSet;
 import dagger.producers.ProducerModule;
 import dagger.producers.Produces;
+import java.util.Optional;
 import java.util.Set;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.type.DeclaredType;
@@ -28,27 +39,23 @@
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 
-import static com.google.common.collect.Iterables.getOnlyElement;
-import static dagger.internal.codegen.BindingMethodValidator.Abstractness.MUST_BE_CONCRETE;
-import static dagger.internal.codegen.BindingMethodValidator.ExceptionSuperclass.EXCEPTION;
-import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_NULLABLE;
-import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_RAW_FUTURE;
-import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_RETURN_TYPE;
-import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_SCOPE;
-import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_SET_VALUES_RETURN_SET;
-
 /**
  * A validator for {@link Produces} methods.
  *
  * @author Jesse Beder
  * @since 2.0
  */
-// TODO(beder): Consider unifying this with the ProvidesMethodValidator after Provides.Type and
-// Produces.Type are reconciled.
 final class ProducesMethodValidator extends BindingMethodValidator {
 
   ProducesMethodValidator(Elements elements, Types types) {
-    super(elements, types, Produces.class, ProducerModule.class, MUST_BE_CONCRETE, EXCEPTION);
+    super(
+        elements,
+        types,
+        Produces.class,
+        ProducerModule.class,
+        MUST_BE_CONCRETE,
+        EXCEPTION,
+        ALLOWS_MULTIBINDINGS);
   }
   
   @Override
@@ -112,13 +119,13 @@ protected String badSetValuesTypeMessage() {
     return PRODUCES_METHOD_SET_VALUES_RETURN_SET;
   }
 
-  private Optional<TypeMirror> unwrapListenableFuture(
+  private static Optional<TypeMirror> unwrapListenableFuture(
       ValidationReport.Builder<ExecutableElement> reportBuilder, TypeMirror type) {
     if (MoreTypes.isType(type) && MoreTypes.isTypeOf(ListenableFuture.class, type)) {
       DeclaredType declaredType = MoreTypes.asDeclared(type);
       if (declaredType.getTypeArguments().isEmpty()) {
         reportBuilder.addError(PRODUCES_METHOD_RAW_FUTURE);
-        return Optional.absent();
+        return Optional.empty();
       } else {
         return Optional.of((TypeMirror) getOnlyElement(declaredType.getTypeArguments()));
       }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
index b062789dc..dd9f3a18b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Google, Inc.
+ * Copyright (C) 2014 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,32 +13,32 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal.codegen;
 
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkNotNull;
+import static dagger.internal.codegen.MapKeys.getMapKey;
+import static dagger.internal.codegen.MoreAnnotationMirrors.wrapOptionalInEquivalence;
+import static dagger.internal.codegen.Util.toImmutableSet;
+import static javax.lang.model.element.ElementKind.METHOD;
+
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
-import com.google.common.base.Equivalence;
-import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.Sets;
 import com.google.common.util.concurrent.ListenableFuture;
+import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import dagger.producers.Producer;
-import java.util.Set;
-import javax.lang.model.element.AnnotationMirror;
+import java.util.Optional;
+import java.util.stream.Stream;
+import javax.annotation.CheckReturnValue;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
-import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.ExecutableType;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Types;
 
-import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
-import static dagger.internal.codegen.MapKeys.getMapKey;
-import static dagger.internal.codegen.MoreAnnotationMirrors.wrapOptionalInEquivalence;
-import static javax.lang.model.element.ElementKind.METHOD;
-
 /**
  * A value object representing the mechanism by which a {@link Key} can be produced. New instances
  * should be created using an instance of the {@link Factory}.
@@ -56,30 +56,71 @@ public BindingType bindingType() {
 
   @Override
   Optional<ProductionBinding> unresolved() {
-    return Optional.absent();
+    return Optional.empty();
   }
 
   @Override
-  Set<DependencyRequest> implicitDependencies() {
-    // Similar optimizations to ContributionBinding.implicitDependencies().
-    if (!executorRequest().isPresent() && !monitorRequest().isPresent()) {
-      return super.implicitDependencies();
-    } else {
-      return Sets.union(
-          Sets.union(executorRequest().asSet(), monitorRequest().asSet()),
-          super.implicitDependencies());
-    }
+  ImmutableSet<DependencyRequest> implicitDependencies() {
+    return Stream.of(executorRequest(), monitorRequest())
+        .filter(Optional::isPresent)
+        .map(Optional::get)
+        .collect(toImmutableSet());
   }
 
+  /** What kind of object this produces method returns. */
+  enum ProductionKind {
+    /** A value. */
+    IMMEDIATE,
+    /** A {@code ListenableFuture<T>}. */
+    FUTURE,
+    /** A {@code Set<ListenableFuture<T>>}. */
+    SET_OF_FUTURE;
+  }
+
+  /**
+   * Returns the kind of object the produces method returns. All production bindings from
+   * {@code @Produces} methods will have a production kind, but synthetic production bindings may
+   * not.
+   */
+  abstract Optional<ProductionKind> productionKind();
+
   /** Returns the list of types in the throws clause of the method. */
   abstract ImmutableList<? extends TypeMirror> thrownTypes();
 
-  /** If this production requires an executor, this will be the corresponding request. */
+  /**
+   * If this production requires an executor, this will be the corresponding request.  All
+   * production bindings from {@code @Produces} methods will have an executor request, but
+   * synthetic production bindings may not.
+   */
   abstract Optional<DependencyRequest> executorRequest();
 
-  /** If this production requires a monitor, this will be the corresponding request. */
+  /** If this production requires a monitor, this will be the corresponding request.  All
+   * production bindings from {@code @Produces} methods will have a monitor request, but synthetic
+   * production bindings may not.
+   */
   abstract Optional<DependencyRequest> monitorRequest();
 
+  private static Builder builder() {
+    return new AutoValue_ProductionBinding.Builder()
+        .explicitDependencies(ImmutableList.<DependencyRequest>of())
+        .thrownTypes(ImmutableList.<TypeMirror>of());
+  }
+
+  @AutoValue.Builder
+  @CanIgnoreReturnValue
+  abstract static class Builder extends ContributionBinding.Builder<Builder> {
+    abstract Builder productionKind(ProductionKind productionKind);
+
+    abstract Builder thrownTypes(Iterable<? extends TypeMirror> thrownTypes);
+
+    abstract Builder executorRequest(DependencyRequest executorRequest);
+
+    abstract Builder monitorRequest(DependencyRequest monitorRequest);
+
+    @CheckReturnValue
+    abstract ProductionBinding build();
+  }
+
   static final class Factory {
     private final Types types;
     private final Key.Factory keyFactory;
@@ -95,6 +136,7 @@ public BindingType bindingType() {
     ProductionBinding forProducesMethod(
         ExecutableElement producesMethod, TypeElement contributedBy) {
       checkArgument(producesMethod.getKind().equals(METHOD));
+      ContributionType contributionType = ContributionType.fromBindingMethod(producesMethod);
       Key key = keyFactory.forProducesMethod(producesMethod, contributedBy);
       ExecutableType resolvedMethod =
           MoreTypes.asExecutable(
@@ -105,78 +147,70 @@ ProductionBinding forProducesMethod(
               resolvedMethod.getParameterTypes());
       DependencyRequest executorRequest =
           dependencyRequestFactory.forProductionImplementationExecutor();
-      DependencyRequest monitorRequest =
-          dependencyRequestFactory.forProductionComponentMonitorProvider();
-      Kind kind = MoreTypes.isTypeOf(ListenableFuture.class, producesMethod.getReturnType())
-          ? Kind.FUTURE_PRODUCTION
-          : Kind.IMMEDIATE;
-      return new AutoValue_ProductionBinding(
-          ContributionType.fromBindingMethod(producesMethod),
-          producesMethod,
-          Optional.of(contributedBy),
-          key,
-          dependencies,
-          Optional.<DeclaredType>absent(), // TODO(beder): Add nullability checking with Java 8.
-          Optional.<DependencyRequest>absent(),
-          wrapOptionalInEquivalence(getMapKey(producesMethod)),
-          kind,
-          ImmutableList.copyOf(producesMethod.getThrownTypes()),
-          Optional.of(executorRequest),
-          Optional.of(monitorRequest));
+      DependencyRequest monitorRequest = dependencyRequestFactory.forProductionComponentMonitor();
+      final ProductionKind productionKind;
+      if (MoreTypes.isTypeOf(ListenableFuture.class, producesMethod.getReturnType())) {
+        productionKind = ProductionKind.FUTURE;
+      } else if (contributionType.equals(ContributionType.SET_VALUES)
+          && SetType.from(producesMethod.getReturnType())
+              .elementsAreTypeOf(ListenableFuture.class)) {
+        productionKind = ProductionKind.SET_OF_FUTURE;
+      } else {
+        productionKind = ProductionKind.IMMEDIATE;
+      }
+      // TODO(beder): Add nullability checking with Java 8.
+      return ProductionBinding.builder()
+          .contributionType(contributionType)
+          .bindingElement(producesMethod)
+          .contributingModule(contributedBy)
+          .key(key)
+          .explicitDependencies(dependencies)
+          .wrappedMapKey(wrapOptionalInEquivalence(getMapKey(producesMethod)))
+          .bindingKind(Kind.PRODUCTION)
+          .productionKind(productionKind)
+          .thrownTypes(producesMethod.getThrownTypes())
+          .executorRequest(executorRequest)
+          .monitorRequest(monitorRequest)
+          .build();
     }
 
     /**
      * A synthetic binding of {@code Map<K, V>} or {@code Map<K, Produced<V>>} that depends on
      * {@code Map<K, Producer<V>>}.
      */
-    ProductionBinding syntheticMapOfValuesOrProducedBinding(
-        DependencyRequest requestForMapOfValuesOrProduced) {
-      checkNotNull(requestForMapOfValuesOrProduced);
+    ProductionBinding syntheticMapOfValuesOrProducedBinding(Key mapOfValuesOrProducedKey) {
+      checkNotNull(mapOfValuesOrProducedKey);
       Optional<Key> mapOfProducersKey =
-          keyFactory.implicitMapProducerKeyFrom(requestForMapOfValuesOrProduced.key());
+          keyFactory.implicitMapProducerKeyFrom(mapOfValuesOrProducedKey);
       checkArgument(
           mapOfProducersKey.isPresent(),
-          "%s is not for a Map<K, V>",
-          requestForMapOfValuesOrProduced);
+          "%s is not a key for of Map<K, V> or Map<K, Produced<V>>",
+          mapOfValuesOrProducedKey);
       DependencyRequest requestForMapOfProducers =
-          dependencyRequestFactory.forImplicitMapBinding(
-              requestForMapOfValuesOrProduced, mapOfProducersKey.get());
-      return new AutoValue_ProductionBinding(
-          ContributionType.UNIQUE,
-          requestForMapOfProducers.requestElement(),
-          Optional.<TypeElement>absent(),
-          requestForMapOfValuesOrProduced.key(),
-          ImmutableSet.of(requestForMapOfProducers),
-          Optional.<DeclaredType>absent(),
-          Optional.<DependencyRequest>absent(),
-          wrapOptionalInEquivalence(getMapKey(requestForMapOfProducers.requestElement())),
-          Kind.SYNTHETIC_MAP,
-          ImmutableList.<TypeMirror>of(),
-          Optional.<DependencyRequest>absent(),
-          Optional.<DependencyRequest>absent());
+          dependencyRequestFactory.producerForImplicitMapBinding(mapOfProducersKey.get());
+      return ProductionBinding.builder()
+          .contributionType(ContributionType.UNIQUE)
+          .key(mapOfValuesOrProducedKey)
+          .explicitDependencies(requestForMapOfProducers)
+          .bindingKind(Kind.SYNTHETIC_MAP)
+          .build();
     }
 
     /**
      * A synthetic binding that depends explicitly on a set of individual provision or production
      * multibinding contribution methods.
-     * 
+     *
      * <p>Note that these could be set multibindings or map multibindings.
      */
     ProductionBinding syntheticMultibinding(
-        DependencyRequest request, Iterable<ContributionBinding> multibindingContributions) {
-      return new AutoValue_ProductionBinding(
-          ContributionType.UNIQUE,
-          request.requestElement(),
-          Optional.<TypeElement>absent(),
-          request.key(),
-          dependencyRequestFactory.forMultibindingContributions(request, multibindingContributions),
-          Optional.<DeclaredType>absent(),
-          Optional.<DependencyRequest>absent(),
-          Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
-          Kind.forMultibindingRequest(request),
-          ImmutableList.<TypeMirror>of(),
-          Optional.<DependencyRequest>absent(),
-          Optional.<DependencyRequest>absent());
+        Key key, Iterable<ContributionBinding> multibindingContributions) {
+      return ProductionBinding.builder()
+          .contributionType(ContributionType.UNIQUE)
+          .key(key)
+          .explicitDependencies(
+              dependencyRequestFactory.forMultibindingContributions(multibindingContributions))
+          .bindingKind(Kind.forMultibindingKey(key))
+          .build();
     }
 
     ProductionBinding forComponentMethod(ExecutableElement componentMethod) {
@@ -184,37 +218,42 @@ ProductionBinding forComponentMethod(ExecutableElement componentMethod) {
       checkArgument(componentMethod.getKind().equals(METHOD));
       checkArgument(componentMethod.getParameters().isEmpty());
       checkArgument(MoreTypes.isTypeOf(ListenableFuture.class, componentMethod.getReturnType()));
-      return new AutoValue_ProductionBinding(
-          ContributionType.UNIQUE,
-          componentMethod,
-          Optional.<TypeElement>absent(),
-          keyFactory.forProductionComponentMethod(componentMethod),
-          ImmutableSet.<DependencyRequest>of(),
-          Optional.<DeclaredType>absent(),
-          Optional.<DependencyRequest>absent(),
-          Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
-          Kind.COMPONENT_PRODUCTION,
-          ImmutableList.copyOf(componentMethod.getThrownTypes()),
-          Optional.<DependencyRequest>absent(),
-          Optional.<DependencyRequest>absent());
+      return ProductionBinding.builder()
+          .contributionType(ContributionType.UNIQUE)
+          .bindingElement(componentMethod)
+          .key(keyFactory.forProductionComponentMethod(componentMethod))
+          .bindingKind(Kind.COMPONENT_PRODUCTION)
+          .thrownTypes(componentMethod.getThrownTypes())
+          .build();
     }
 
     ProductionBinding delegate(
         DelegateDeclaration delegateDeclaration, ProductionBinding delegateBinding) {
-      Key key = keyFactory.forDelegateBinding(delegateDeclaration, Producer.class);
-      return new AutoValue_ProductionBinding(
-          delegateDeclaration.contributionType(),
-          delegateDeclaration.bindingElement(),
-          delegateDeclaration.contributingModule(),
-          key,
-          ImmutableSet.of(delegateDeclaration.delegateRequest()),
-          delegateBinding.nullableType(),
-          Optional.<DependencyRequest>absent(),
-          delegateDeclaration.wrappedMapKey(),
-          Kind.SYNTHETIC_DELEGATE_BINDING,
-          ImmutableList.<TypeMirror>of(),
-          Optional.<DependencyRequest>absent(),
-          Optional.<DependencyRequest>absent());
+      return ProductionBinding.builder()
+          .contributionType(delegateDeclaration.contributionType())
+          .bindingElement(delegateDeclaration.bindingElement().get())
+          .contributingModule(delegateDeclaration.contributingModule().get())
+          .key(keyFactory.forDelegateBinding(delegateDeclaration, Producer.class))
+          .explicitDependencies(delegateDeclaration.delegateRequest())
+          .nullableType(delegateBinding.nullableType())
+          .wrappedMapKey(delegateDeclaration.wrappedMapKey())
+          .bindingKind(Kind.SYNTHETIC_DELEGATE_BINDING)
+          .build();
+    }
+
+    /**
+     * Returns a synthetic binding for an {@linkplain dagger.BindsOptionalOf optional binding} in a
+     * component with a binding for the underlying key.
+     */
+    ProductionBinding syntheticPresentBinding(Key key) {
+      return ProductionBinding.builder()
+          .contributionType(ContributionType.UNIQUE)
+          .key(key)
+          .bindingKind(Kind.SYNTHETIC_OPTIONAL_BINDING)
+          .explicitDependencies(
+              dependencyRequestFactory.forSyntheticPresentOptionalBinding(
+                  key, DependencyRequest.Kind.PRODUCER))
+          .build();
     }
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProductionExecutorModuleGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ProductionExecutorModuleGenerator.java
index 4a44c0869..5368cd24f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProductionExecutorModuleGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProductionExecutorModuleGenerator.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 Google, Inc.
+ * Copyright (C) 2016 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,9 +13,14 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal.codegen;
 
-import com.google.common.base.Optional;
+import static com.squareup.javapoet.MethodSpec.methodBuilder;
+import static com.squareup.javapoet.TypeSpec.classBuilder;
+import static javax.lang.model.element.Modifier.FINAL;
+import static javax.lang.model.element.Modifier.STATIC;
+
 import com.squareup.javapoet.AnnotationSpec;
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.ParameterSpec;
@@ -25,19 +30,13 @@
 import dagger.producers.Production;
 import dagger.producers.ProductionScope;
 import dagger.producers.internal.ProductionImplementation;
-
+import java.util.Optional;
 import java.util.concurrent.Executor;
-
 import javax.annotation.processing.Filer;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.util.Elements;
 
-import static com.squareup.javapoet.MethodSpec.methodBuilder;
-import static com.squareup.javapoet.TypeSpec.classBuilder;
-import static javax.lang.model.element.Modifier.STATIC;
-import static javax.lang.model.element.Modifier.FINAL;
-
 /** Generates a producer executor module for use with production components. */
 // TODO(beder): Replace this with a single class when the producers client library exists.
 final class ProductionExecutorModuleGenerator extends SourceFileGenerator<TypeElement> {
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProductionExecutorModuleProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/ProductionExecutorModuleProcessingStep.java
index 24a728738..d508a51e8 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProductionExecutorModuleProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProductionExecutorModuleProcessingStep.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 Google, Inc.
+ * Copyright (C) 2016 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal.codegen;
 
 import com.google.auto.common.BasicAnnotationProcessor.ProcessingStep;
@@ -49,11 +50,7 @@
   public Set<Element> process(
       SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
     for (Element element : elementsByAnnotation.values()) {
-      try {
-        productionExecutorModuleGenerator.generate(MoreElements.asType(element));
-      } catch (SourceFileGenerationException e) {
-        e.printMessageTo(messager);
-      }
+      productionExecutorModuleGenerator.generate(MoreElements.asType(element), messager);
     }
     return ImmutableSet.of();
   }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProviderFieldRequestFulfillment.java b/compiler/src/main/java/dagger/internal/codegen/ProviderFieldRequestFulfillment.java
new file mode 100644
index 000000000..d17c2e54a
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/ProviderFieldRequestFulfillment.java
@@ -0,0 +1,60 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.base.Preconditions.checkArgument;
+import static dagger.internal.codegen.BindingKey.Kind.CONTRIBUTION;
+
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+import dagger.producers.internal.Producers;
+
+/** Fulfills requests for {@link ProvisionBinding} instances. */
+final class ProviderFieldRequestFulfillment extends RequestFulfillment {
+  private final MemberSelect providerFieldSelect;
+
+  ProviderFieldRequestFulfillment(BindingKey bindingKey, MemberSelect frameworkFieldSelect) {
+    super(bindingKey);
+    checkArgument(bindingKey.kind().equals(CONTRIBUTION));
+    this.providerFieldSelect = frameworkFieldSelect;
+  }
+
+  @Override
+  public CodeBlock getSnippetForDependencyRequest(
+      DependencyRequest request, ClassName requestingClass) {
+    return FrameworkType.PROVIDER.to(
+        request.kind(), providerFieldSelect.getExpressionFor(requestingClass));
+  }
+
+  @Override
+  CodeBlock getSnippetForFrameworkDependency(
+      FrameworkDependency frameworkDependency, ClassName requestingClass) {
+    switch (frameworkDependency.bindingType()) {
+      case PROVISION:
+        return providerFieldSelect.getExpressionFor(requestingClass);
+      case MEMBERS_INJECTION:
+        throw new IllegalArgumentException();
+      case PRODUCTION:
+        return CodeBlock.of(
+            "$T.producerFromProvider($L)",
+            Producers.class,
+            providerFieldSelect.getExpressionFor(requestingClass));
+      default:
+        throw new AssertionError();
+    }
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java
index 4de6fd673..9feadc7a3 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Google, Inc.
+ * Copyright (C) 2014 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,19 +13,23 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal.codegen;
 
+import static dagger.internal.codegen.BindingMethodValidator.Abstractness.MUST_BE_CONCRETE;
+import static dagger.internal.codegen.BindingMethodValidator.AllowsMultibindings.ALLOWS_MULTIBINDINGS;
+import static dagger.internal.codegen.BindingMethodValidator.ExceptionSuperclass.RUNTIME_EXCEPTION;
+import static dagger.internal.codegen.ErrorMessages.provisionMayNotDependOnProducerType;
+
+import com.google.common.collect.ImmutableSet;
 import dagger.Module;
 import dagger.Provides;
+import dagger.producers.ProducerModule;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.VariableElement;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 
-import static dagger.internal.codegen.BindingMethodValidator.Abstractness.MUST_BE_CONCRETE;
-import static dagger.internal.codegen.BindingMethodValidator.ExceptionSuperclass.RUNTIME_EXCEPTION;
-import static dagger.internal.codegen.ErrorMessages.provisionMayNotDependOnProducerType;
-
 /**
  * A validator for {@link Provides} methods.
  *
@@ -35,7 +39,14 @@
 final class ProvidesMethodValidator extends BindingMethodValidator {
 
   ProvidesMethodValidator(Elements elements, Types types) {
-    super(elements, types, Provides.class, Module.class, MUST_BE_CONCRETE, RUNTIME_EXCEPTION);
+    super(
+        elements,
+        types,
+        Provides.class,
+        ImmutableSet.of(Module.class, ProducerModule.class),
+        MUST_BE_CONCRETE,
+        RUNTIME_EXCEPTION,
+        ALLOWS_MULTIBINDINGS);
   }
 
   @Override
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
index 8a8ac1cfd..5de760e93 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Google, Inc.
+ * Copyright (C) 2014 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,40 +13,44 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal.codegen;
 
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
+import static com.google.auto.common.MoreTypes.asDeclared;
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.base.Preconditions.checkState;
+import static dagger.internal.codegen.InjectionAnnotations.getQualifier;
+import static dagger.internal.codegen.MapKeys.getMapKey;
+import static dagger.internal.codegen.MoreAnnotationMirrors.wrapOptionalInEquivalence;
+import static javax.lang.model.element.ElementKind.CONSTRUCTOR;
+import static javax.lang.model.element.ElementKind.FIELD;
+import static javax.lang.model.element.ElementKind.METHOD;
+
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
-import com.google.common.base.Equivalence;
-import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Iterables;
 import com.google.common.collect.Sets;
+import com.google.errorprone.annotations.CanIgnoreReturnValue;
+import dagger.internal.codegen.ComponentDescriptor.BuilderRequirementMethod;
+import java.util.Optional;
+import javax.annotation.CheckReturnValue;
 import javax.inject.Inject;
 import javax.inject.Provider;
-import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ElementKind;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.ExecutableType;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 
-import static com.google.auto.common.MoreElements.isAnnotationPresent;
-import static com.google.auto.common.MoreTypes.asDeclared;
-import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
-import static com.google.common.base.Preconditions.checkState;
-import static dagger.internal.codegen.InjectionAnnotations.getQualifier;
-import static dagger.internal.codegen.MapKeys.getMapKey;
-import static dagger.internal.codegen.MoreAnnotationMirrors.wrapOptionalInEquivalence;
-import static javax.lang.model.element.ElementKind.CONSTRUCTOR;
-import static javax.lang.model.element.ElementKind.FIELD;
-import static javax.lang.model.element.ElementKind.METHOD;
-
 /**
  * A value object representing the mechanism by which a {@link Key} can be provided. New instances
  * should be created using an instance of the {@link Factory}.
@@ -57,6 +61,16 @@
 @AutoValue
 abstract class ProvisionBinding extends ContributionBinding {
 
+  @Override
+  ImmutableSet<DependencyRequest> implicitDependencies() {
+    return membersInjectionRequest().isPresent()
+        ? ImmutableSet.of(membersInjectionRequest().get())
+        : ImmutableSet.of();
+  }
+
+  /** If this provision requires members injection, this will be the corresponding request. */
+  abstract Optional<DependencyRequest> membersInjectionRequest();
+
   @Override
   public BindingType bindingType() {
     return BindingType.PROVISION;
@@ -68,6 +82,27 @@ public BindingType bindingType() {
   @Override
   abstract Optional<Scope> scope();
 
+  private static Builder builder() {
+    return new AutoValue_ProvisionBinding.Builder()
+        .explicitDependencies(ImmutableSet.<DependencyRequest>of());
+  }
+  
+  abstract Builder toBuilder();
+
+  @AutoValue.Builder
+  @CanIgnoreReturnValue
+  abstract static class Builder extends ContributionBinding.Builder<Builder> {
+
+    abstract Builder membersInjectionRequest(Optional<DependencyRequest> membersInjectionRequest);
+
+    abstract Builder unresolved(ProvisionBinding unresolved);
+
+    abstract Builder scope(Optional<Scope> scope);
+
+    @CheckReturnValue
+    abstract ProvisionBinding build();
+  }
+
   static final class Factory {
     private final Elements elements;
     private final Types types;
@@ -84,11 +119,11 @@ public BindingType bindingType() {
 
     /**
      * Returns a ProvisionBinding for the given element. If {@code resolvedType} is present, this
-     * will return a resolved binding, with the key & type resolved to the given type (using
+     * will return a resolved binding, with the key and type resolved to the given type (using
      * {@link Types#asMemberOf(DeclaredType, Element)}).
      */
-    ProvisionBinding forInjectConstructor(ExecutableElement constructorElement,
-        Optional<TypeMirror> resolvedType) {
+    ProvisionBinding forInjectConstructor(
+        ExecutableElement constructorElement, Optional<TypeMirror> resolvedType) {
       checkNotNull(constructorElement);
       checkArgument(constructorElement.getKind().equals(CONSTRUCTOR));
       checkArgument(isAnnotationPresent(constructorElement, Inject.class));
@@ -115,25 +150,23 @@ ProvisionBinding forInjectConstructor(ExecutableElement constructorElement,
               constructorElement.getParameters(), cxtorType.getParameterTypes());
       Optional<DependencyRequest> membersInjectionRequest =
           membersInjectionRequest(enclosingCxtorType);
-      Optional<Scope> scope = Scope.uniqueScopeOf(constructorElement.getEnclosingElement());
+
+      ProvisionBinding.Builder builder =
+          ProvisionBinding.builder()
+              .contributionType(ContributionType.UNIQUE)
+              .bindingElement(constructorElement)
+              .key(key)
+              .explicitDependencies(dependencies)
+              .membersInjectionRequest(membersInjectionRequest)
+              .bindingKind(Kind.INJECTION)
+              .scope(Scope.uniqueScopeOf(constructorElement.getEnclosingElement()));
 
       TypeElement bindingTypeElement =
           MoreElements.asType(constructorElement.getEnclosingElement());
-
-      return new AutoValue_ProvisionBinding(
-          ContributionType.UNIQUE,
-          constructorElement,
-          Optional.<TypeElement>absent(),
-          key,
-          dependencies,
-          Optional.<DeclaredType>absent(),
-          membersInjectionRequest,
-          Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
-          Kind.INJECTION,
-          hasNonDefaultTypeParameters(bindingTypeElement, key.type(), types)
-              ? Optional.of(forInjectConstructor(constructorElement, Optional.<TypeMirror>absent()))
-              : Optional.<ProvisionBinding>absent(),
-          scope);
+      if (hasNonDefaultTypeParameters(bindingTypeElement, key.type(), types)) {
+        builder.unresolved(forInjectConstructor(constructorElement, Optional.empty()));
+      }
+      return builder.build();
     }
 
     private static final ImmutableSet<ElementKind> MEMBER_KINDS =
@@ -151,7 +184,7 @@ ProvisionBinding forInjectConstructor(ExecutableElement constructorElement,
           return Optional.of(dependencyRequestFactory.forMembersInjectedType(type));
         }
       }
-      return Optional.absent();
+      return Optional.empty();
     }
 
     ProvisionBinding forProvidesMethod(
@@ -165,104 +198,89 @@ ProvisionBinding forProvidesMethod(
           dependencyRequestFactory.forRequiredResolvedVariables(
               providesMethod.getParameters(),
               resolvedMethod.getParameterTypes());
-      Optional<Scope> scope = Scope.uniqueScopeOf(providesMethod);
-      return new AutoValue_ProvisionBinding(
-          ContributionType.fromBindingMethod(providesMethod),
-          providesMethod,
-          Optional.of(contributedBy),
-          key,
-          dependencies,
-          ConfigurationAnnotations.getNullableType(providesMethod),
-          Optional.<DependencyRequest>absent(),
-          wrapOptionalInEquivalence(getMapKey(providesMethod)),
-          Kind.PROVISION,
-          Optional.<ProvisionBinding>absent(),
-          scope);
+      return ProvisionBinding.builder()
+          .contributionType(ContributionType.fromBindingMethod(providesMethod))
+          .bindingElement(providesMethod)
+          .contributingModule(contributedBy)
+          .key(key)
+          .explicitDependencies(dependencies)
+          .nullableType(ConfigurationAnnotations.getNullableType(providesMethod))
+          .wrappedMapKey(wrapOptionalInEquivalence(getMapKey(providesMethod)))
+          .bindingKind(Kind.PROVISION)
+          .scope(Scope.uniqueScopeOf(providesMethod))
+          .build();
     }
 
-    /**
-     * A synthetic binding of {@code Map<K, V>} that depends on {@code Map<K, Provider<V>>}.
-     */
-    ProvisionBinding syntheticMapOfValuesBinding(DependencyRequest requestForMapOfValues) {
-      checkNotNull(requestForMapOfValues);
-      Optional<Key> mapOfProvidersKey =
-          keyFactory.implicitMapProviderKeyFrom(requestForMapOfValues.key());
-      checkArgument(
-          mapOfProvidersKey.isPresent(),
-          "%s is not a request for Map<K, V>",
-          requestForMapOfValues);
+    /** A synthetic binding of {@code Map<K, V>} that depends on {@code Map<K, Provider<V>>}. */
+    ProvisionBinding syntheticMapOfValuesBinding(Key mapOfValuesKey) {
+      checkNotNull(mapOfValuesKey);
+      Optional<Key> mapOfProvidersKey = keyFactory.implicitMapProviderKeyFrom(mapOfValuesKey);
+      checkArgument(mapOfProvidersKey.isPresent(), "%s is not a key for Map<K, V>", mapOfValuesKey);
       DependencyRequest requestForMapOfProviders =
-          dependencyRequestFactory.forImplicitMapBinding(
-              requestForMapOfValues, mapOfProvidersKey.get());
-      return new AutoValue_ProvisionBinding(
-          ContributionType.UNIQUE,
-          requestForMapOfProviders.requestElement(),
-          Optional.<TypeElement>absent(),
-          requestForMapOfValues.key(),
-          ImmutableSet.of(requestForMapOfProviders),
-          Optional.<DeclaredType>absent(),
-          Optional.<DependencyRequest>absent(),
-          wrapOptionalInEquivalence(getMapKey(requestForMapOfProviders.requestElement())),
-          Kind.SYNTHETIC_MAP,
-          Optional.<ProvisionBinding>absent(),
-          Scope.uniqueScopeOf(requestForMapOfProviders.requestElement()));
+          dependencyRequestFactory.providerForImplicitMapBinding(mapOfProvidersKey.get());
+      return ProvisionBinding.builder()
+          .contributionType(ContributionType.UNIQUE)
+          .key(mapOfValuesKey)
+          .explicitDependencies(requestForMapOfProviders)
+          .bindingKind(Kind.SYNTHETIC_MAP)
+          .build();
     }
 
     /**
      * A synthetic binding that depends explicitly on a set of individual provision multibinding
      * contribution methods.
-     * 
+     *
      * <p>Note that these could be set multibindings or map multibindings.
      */
     ProvisionBinding syntheticMultibinding(
-        DependencyRequest request, Iterable<ContributionBinding> multibindingContributions) {
-      return new AutoValue_ProvisionBinding(
-          ContributionType.UNIQUE,
-          request.requestElement(),
-          Optional.<TypeElement>absent(),
-          request.key(),
-          dependencyRequestFactory.forMultibindingContributions(request, multibindingContributions),
-          Optional.<DeclaredType>absent(),
-          Optional.<DependencyRequest>absent(),
-          Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
-          Kind.forMultibindingRequest(request),
-          Optional.<ProvisionBinding>absent(),
-          Scope.uniqueScopeOf(request.requestElement()));
+        Key key, Iterable<ContributionBinding> multibindingContributions) {
+      return ProvisionBinding.builder()
+          .contributionType(ContributionType.UNIQUE)
+          .key(key)
+          .explicitDependencies(
+              dependencyRequestFactory.forMultibindingContributions(multibindingContributions))
+          .bindingKind(Kind.forMultibindingKey(key))
+          .build();
     }
 
     ProvisionBinding forComponent(TypeElement componentDefinitionType) {
       checkNotNull(componentDefinitionType);
-      return new AutoValue_ProvisionBinding(
-          ContributionType.UNIQUE,
-          componentDefinitionType,
-          Optional.<TypeElement>absent(),
-          keyFactory.forComponent(componentDefinitionType.asType()),
-          ImmutableSet.<DependencyRequest>of(),
-          Optional.<DeclaredType>absent(),
-          Optional.<DependencyRequest>absent(),
-          Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
-          Kind.COMPONENT,
-          Optional.<ProvisionBinding>absent(),
-          Optional.<Scope>absent());
+      return ProvisionBinding.builder()
+          .contributionType(ContributionType.UNIQUE)
+          .bindingElement(componentDefinitionType)
+          .key(keyFactory.forComponent(componentDefinitionType.asType()))
+          .bindingKind(Kind.COMPONENT)
+          .build();
     }
 
     ProvisionBinding forComponentMethod(ExecutableElement componentMethod) {
       checkNotNull(componentMethod);
       checkArgument(componentMethod.getKind().equals(METHOD));
       checkArgument(componentMethod.getParameters().isEmpty());
-      Optional<Scope> scope = Scope.uniqueScopeOf(componentMethod);
-      return new AutoValue_ProvisionBinding(
-          ContributionType.UNIQUE,
-          componentMethod,
-          Optional.<TypeElement>absent(),
-          keyFactory.forComponentMethod(componentMethod),
-          ImmutableSet.<DependencyRequest>of(),
-          ConfigurationAnnotations.getNullableType(componentMethod),
-          Optional.<DependencyRequest>absent(),
-          Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
-          Kind.COMPONENT_PROVISION,
-          Optional.<ProvisionBinding>absent(),
-          scope);
+      return ProvisionBinding.builder()
+          .contributionType(ContributionType.UNIQUE)
+          .bindingElement(componentMethod)
+          .key(keyFactory.forComponentMethod(componentMethod))
+          .nullableType(ConfigurationAnnotations.getNullableType(componentMethod))
+          .bindingKind(Kind.COMPONENT_PROVISION)
+          .scope(Scope.uniqueScopeOf(componentMethod))
+          .build();
+    }
+
+    ProvisionBinding forBuilderBinding(BuilderRequirementMethod method) {
+      ExecutableElement builderMethod = method.method();
+
+      checkNotNull(builderMethod);
+      checkArgument(builderMethod.getKind().equals(METHOD));
+      checkArgument(builderMethod.getParameters().size() == 1);
+      VariableElement parameterElement = Iterables.getOnlyElement(builderMethod.getParameters());
+      return ProvisionBinding.builder()
+          .contributionType(ContributionType.UNIQUE)
+          .bindingElement(builderMethod)
+          .key(method.requirement().key().get())
+          .nullableType(ConfigurationAnnotations.getNullableType(parameterElement))
+          .bindingKind(Kind.BUILDER_BINDING)
+          .build();
     }
 
     ProvisionBinding forSubcomponentBuilderMethod(
@@ -271,35 +289,117 @@ ProvisionBinding forSubcomponentBuilderMethod(
       checkArgument(subcomponentBuilderMethod.getKind().equals(METHOD));
       checkArgument(subcomponentBuilderMethod.getParameters().isEmpty());
       DeclaredType declaredContainer = asDeclared(contributedBy.asType());
-      return new AutoValue_ProvisionBinding(
-          ContributionType.UNIQUE,
-          subcomponentBuilderMethod,
-          Optional.<TypeElement>absent(),
-          keyFactory.forSubcomponentBuilderMethod(subcomponentBuilderMethod, declaredContainer),
-          ImmutableSet.<DependencyRequest>of(),
-          Optional.<DeclaredType>absent(),
-          Optional.<DependencyRequest>absent(),
-          Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
-          Kind.SUBCOMPONENT_BUILDER,
-          Optional.<ProvisionBinding>absent(),
-          Optional.<Scope>absent());
+      return ProvisionBinding.builder()
+          .contributionType(ContributionType.UNIQUE)
+          .bindingElement(subcomponentBuilderMethod)
+          .key(
+              keyFactory.forSubcomponentBuilderMethod(subcomponentBuilderMethod, declaredContainer))
+          .bindingKind(Kind.SUBCOMPONENT_BUILDER)
+          .build();
+    }
+
+    ProvisionBinding syntheticSubcomponentBuilder(
+        ImmutableSet<SubcomponentDeclaration> subcomponentDeclarations) {
+      SubcomponentDeclaration subcomponentDeclaration = subcomponentDeclarations.iterator().next();
+      return ProvisionBinding.builder()
+          .contributionType(ContributionType.UNIQUE)
+          .key(subcomponentDeclaration.key())
+          .bindingKind(Kind.SUBCOMPONENT_BUILDER)
+          .build();
     }
 
     ProvisionBinding delegate(
         DelegateDeclaration delegateDeclaration, ProvisionBinding delegate) {
-      Key key = keyFactory.forDelegateBinding(delegateDeclaration, Provider.class);
-      return new AutoValue_ProvisionBinding(
-          delegateDeclaration.contributionType(),
-          delegateDeclaration.bindingElement(),
-          delegateDeclaration.contributingModule(),
-          key,
-          ImmutableSet.of(delegateDeclaration.delegateRequest()),
-          delegate.nullableType(),
-          Optional.<DependencyRequest>absent(),
-          delegateDeclaration.wrappedMapKey(),
-          Kind.SYNTHETIC_DELEGATE_BINDING,
-          Optional.<ProvisionBinding>absent(),
-          Scope.uniqueScopeOf(delegateDeclaration.bindingElement()));
+      return delegateBuilder(delegateDeclaration).nullableType(delegate.nullableType()).build();
+    }
+
+    /**
+     * A form of {@link #delegate(DelegateDeclaration, ProvisionBinding)} when the right-hand-side
+     * of a {@link dagger.Binds} method cannot be resolved.
+     */
+    ProvisionBinding missingDelegate(DelegateDeclaration delegateDeclaration) {
+      return delegateBuilder(delegateDeclaration).build();
+    }
+
+    private ProvisionBinding.Builder delegateBuilder(DelegateDeclaration delegateDeclaration) {
+      return ProvisionBinding.builder()
+          .contributionType(delegateDeclaration.contributionType())
+          .bindingElement(delegateDeclaration.bindingElement().get())
+          .contributingModule(delegateDeclaration.contributingModule().get())
+          .key(keyFactory.forDelegateBinding(delegateDeclaration, Provider.class))
+          .explicitDependencies(delegateDeclaration.delegateRequest())
+          .wrappedMapKey(delegateDeclaration.wrappedMapKey())
+          .bindingKind(Kind.SYNTHETIC_DELEGATE_BINDING)
+          .scope(Scope.uniqueScopeOf(delegateDeclaration.bindingElement().get()));
+    }
+
+    /**
+     * Returns a synthetic binding for a {@code @ForReleasableReferences(scope)
+     * ReleasableReferenceManager} that provides the component-instantiated object.
+     */
+    ProvisionBinding provideReleasableReferenceManager(Scope scope) {
+      return ProvisionBinding.builder()
+          .contributionType(ContributionType.UNIQUE)
+          .key(keyFactory.forReleasableReferenceManager(scope))
+          .bindingKind(Kind.SYNTHETIC_RELEASABLE_REFERENCE_MANAGER)
+          .build();
+    }
+
+    /**
+     * Returns a synthetic binding for a {@code @ForReleasableReferences(scope)
+     * TypedReleasableReferenceManager<metadataType>} that provides the component-instantiated
+     * object.
+     */
+    ContributionBinding provideTypedReleasableReferenceManager(
+        Scope scope, DeclaredType metadataType) {
+      return provideReleasableReferenceManager(scope)
+          .toBuilder()
+          .key(keyFactory.forTypedReleasableReferenceManager(scope, metadataType))
+          .build();
+    }
+
+    /** Returns a synthetic binding for {@code Set<ReleasableReferenceManager>}. */
+    ProvisionBinding provideSetOfReleasableReferenceManagers() {
+      return ProvisionBinding.builder()
+          .contributionType(ContributionType.UNIQUE)
+          .key(keyFactory.forSetOfReleasableReferenceManagers())
+          .bindingKind(Kind.SYNTHETIC_RELEASABLE_REFERENCE_MANAGERS)
+          .build();
+    }
+
+    /**
+     * Returns a synthetic binding for {@code Set<TypedReleasableReferenceManager<metadataType>}.
+     */
+    ContributionBinding provideSetOfTypedReleasableReferenceManagers(DeclaredType metadataType) {
+      return provideSetOfReleasableReferenceManagers()
+          .toBuilder()
+          .key(keyFactory.forSetOfTypedReleasableReferenceManagers(metadataType))
+          .build();
+    }
+
+    /**
+     * Returns a synthetic binding for an {@linkplain dagger.BindsOptionalOf optional binding} in a
+     * component with no binding for the underlying key.
+     */
+    ProvisionBinding syntheticAbsentBinding(Key key) {
+      return ProvisionBinding.builder()
+          .contributionType(ContributionType.UNIQUE)
+          .key(key)
+          .bindingKind(Kind.SYNTHETIC_OPTIONAL_BINDING)
+          .build();
+    }
+
+    /**
+     * Returns a synthetic binding for an {@linkplain dagger.BindsOptionalOf optional binding} in a
+     * component with a binding for the underlying key.
+     */
+    ProvisionBinding syntheticPresentBinding(Key key) {
+      return syntheticAbsentBinding(key)
+          .toBuilder()
+          .explicitDependencies(
+              dependencyRequestFactory.forSyntheticPresentOptionalBinding(
+                  key, DependencyRequest.Kind.PROVIDER))
+          .build();
     }
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/Proxies.java b/compiler/src/main/java/dagger/internal/codegen/Proxies.java
new file mode 100644
index 000000000..800e3272d
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/Proxies.java
@@ -0,0 +1,252 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.base.CaseFormat.LOWER_CAMEL;
+import static com.google.common.base.CaseFormat.UPPER_CAMEL;
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.collect.Iterables.toArray;
+import static com.squareup.javapoet.MethodSpec.methodBuilder;
+import static dagger.internal.codegen.Accessibility.isElementAccessibleFrom;
+import static dagger.internal.codegen.Accessibility.isElementPubliclyAccessible;
+import static dagger.internal.codegen.Accessibility.isRawTypeAccessible;
+import static dagger.internal.codegen.Accessibility.isRawTypePubliclyAccessible;
+import static dagger.internal.codegen.Accessibility.isTypePubliclyAccessible;
+import static dagger.internal.codegen.CodeBlocks.javadocLinkTo;
+import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
+import static dagger.internal.codegen.TypeNames.rawTypeName;
+import static javax.lang.model.element.Modifier.PUBLIC;
+import static javax.lang.model.element.Modifier.STATIC;
+import static javax.lang.model.type.TypeKind.VOID;
+
+import com.google.auto.common.MoreElements;
+import com.google.common.collect.ImmutableList;
+import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.MethodSpec;
+import com.squareup.javapoet.ParameterSpec;
+import com.squareup.javapoet.TypeName;
+import com.squareup.javapoet.TypeVariableName;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.Parameterizable;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.TypeParameterElement;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.TypeMirror;
+
+/**
+ * Proxy methods ("proxies") are generated methods used to give component implementations access to
+ * {@link Element}s that are inaccessible as written in the source code. For example, a component
+ * cannot directly invoke a package-private {@code @Inject} constructor in a different package.
+ *
+ * <p>Since proxies are generated separately from their usages, they cannot make any assumptions
+ * about the types or packages from which methods will be invoked. Thus, any type or element that is
+ * not public is considered to be "inaccessible".
+ *
+ * <p>This class generates proxies for any {@link ExecutableElement}, but the form of the methods
+ * are somewhat tailored to how they are used within components.
+ *
+ * <p>Proxies have the following attributes:
+ *
+ * <ul>
+ *   <li>Proxies are always {@code public}, {@code static} methods.
+ *   <li>The return type of the proxy is always the return type of the method or the constructed
+ *       type regardless of its accessibility. For example, if a proxied method returns {@code
+ *       MyPackagePrivateClass}, the proxy method will also return {@code MyPackagePrivateClass}
+ *       because the accessibility of the return type does not impact callers.
+ *   <li>Proxies for constructors are named "{@code newTypeName}" (where "{@code TypeName}" is the
+ *       name of the type being constructed) and proxies for methods are named "{@code
+ *       proxyMethodName}" (where "{@code methodName}" is the name of the method being proxied).
+ *   <li>If the element being proxied is an instance method, the first parameter will be the
+ *       instance.
+ *   <li>The rest of the parameters of the proxy method are that of the proxied method unless the
+ *       raw type of a parameter is inaccessible, in which case it is {@link Object}. Passing an
+ *       object to this method that is not of the proxied parameter type will result in a {@link
+ *       ClassCastException}.
+ *       <p>While it is not required by the language that a method's parameter types be accessible
+ *       to invoke it, components often hold references to {@link javax.inject.Provider} as raw
+ *       types in order to dodge similar accessibility restrictions. This means that the {@code
+ *       {@link javax.inject.Provider#get()}} method will return {@link Object}. Since it cannot be
+ *       cast to the the more specific type on the calling side, we must accept {@link Object} in
+ *       the proxy method.
+ * </ul>
+ *
+ * <p>Proxies are not generated under the following conditions:
+ *
+ * <ul>
+ *   <li>If an {@link ExecutableElement} is publicly accessible and all of its {@linkplain
+ *       ExecutableElement#getParameters() parameters} are publicly accessible types, no proxy is
+ *       necessary. If the type of a parameter has a type argument that is is inaccessible, but the
+ *       raw type that is accessible, the type is considered to be accessible because callers can
+ *       always hold references to the raw type.
+ *   <li>If an {@link ExecutableElement} or any of its enclosing types are {@code private}, no proxy
+ *       is generated because it is impossible to write Java (without reflection) that accesses the
+ *       element.
+ * </ul>
+ */
+final class Proxies {
+
+  /**
+   * Returns {@code true} if the given method has limited access, thus requiring a proxy for some
+   * cases.
+   */
+  static boolean shouldGenerateProxy(ExecutableElement method) {
+    return !isElementPubliclyAccessible(method)
+        || method
+            .getParameters()
+            .stream()
+            .map(VariableElement::asType)
+            .anyMatch(type -> !isRawTypePubliclyAccessible(type));
+  }
+
+  /** Returns {@code true} if accessing the given method from the given package requires a proxy. */
+  static boolean requiresProxyAccess(ExecutableElement method, String callingPackage) {
+    return !isElementAccessibleFrom(method, callingPackage)
+        || method
+            .getParameters()
+            .stream()
+            .map(VariableElement::asType)
+            .anyMatch(type -> !isRawTypeAccessible(type, callingPackage));
+  }
+
+  /** Returns the name of the method that proxies access to the given method. */
+  static String proxyName(ExecutableElement method) {
+    switch (method.getKind()) {
+      case CONSTRUCTOR:
+        return "new" + method.getEnclosingElement().getSimpleName();
+      case METHOD:
+        return "proxy" + LOWER_CAMEL.to(UPPER_CAMEL, method.getSimpleName().toString());
+      case STATIC_INIT:
+      case INSTANCE_INIT:
+        throw new IllegalArgumentException(
+            "cannot proxy initializers because they cannot be invoked directly: " + method);
+      default:
+        throw new AssertionError(method);
+    }
+  }
+
+  /**
+   * Returns a proxy method implementation for the method.
+   *
+   * @throws IllegalArgumentException if the method is publicly accessible
+   */
+  // TODO(gak): expand support to proxy fields
+  static MethodSpec createProxy(ExecutableElement method) {
+    checkArgument(
+        shouldGenerateProxy(method),
+        "method and all of its arguments are accessible; proxy isn't necessary: %s",
+        method);
+    final MethodSpec.Builder builder;
+    switch (method.getKind()) {
+      case CONSTRUCTOR:
+        builder = forConstructor(method);
+        break;
+      case METHOD:
+        builder = forMethod(method);
+        break;
+      default:
+        throw new AssertionError();
+    }
+    builder.addJavadoc("Proxies $L.", javadocLinkTo(method));
+    builder.addModifiers(PUBLIC, STATIC);
+
+    copyTypeParameters(method, builder);
+    copyThrows(method, builder);
+
+    return builder.build();
+  }
+
+  private static MethodSpec.Builder forConstructor(ExecutableElement constructor) {
+    TypeElement enclosingType = MoreElements.asType(constructor.getEnclosingElement());
+    MethodSpec.Builder methodBuilder = methodBuilder(proxyName(constructor));
+
+    copyTypeParameters(enclosingType, methodBuilder);
+
+    methodBuilder.returns(TypeName.get(enclosingType.asType()));
+
+    CodeBlock arguments =
+        copyParameters(
+            constructor, methodBuilder, new UniqueNameSet(), new ImmutableList.Builder<>());
+
+    methodBuilder.addCode("return new $T($L);", enclosingType, arguments);
+
+    return methodBuilder;
+  }
+
+  private static MethodSpec.Builder forMethod(ExecutableElement method) {
+    TypeElement enclosingType = MoreElements.asType(method.getEnclosingElement());
+    MethodSpec.Builder methodBuilder = methodBuilder(proxyName(method));
+
+    UniqueNameSet nameSet = new UniqueNameSet();
+    ImmutableList.Builder<CodeBlock> argumentsBuilder = new ImmutableList.Builder<>();
+    if (!method.getModifiers().contains(STATIC)) {
+      methodBuilder.addParameter(
+          TypeName.get(enclosingType.asType()), nameSet.getUniqueName("instance"));
+    }
+    CodeBlock arguments = copyParameters(method, methodBuilder, nameSet, argumentsBuilder);
+    if (!method.getReturnType().getKind().equals(VOID)) {
+      methodBuilder.addCode("return ");
+    }
+    if (method.getModifiers().contains(STATIC)) {
+      methodBuilder.addCode("$T", rawTypeName(TypeName.get(enclosingType.asType())));
+    } else {
+      copyTypeParameters(enclosingType, methodBuilder);
+      // "instance" is guaranteed b/c it was the first name into the UniqueNameSet
+      methodBuilder.addCode("instance", method.getSimpleName());
+    }
+    methodBuilder.addCode(".$N($L);", method.getSimpleName(), arguments);
+    methodBuilder.returns(TypeName.get(method.getReturnType()));
+    return methodBuilder;
+  }
+
+  private static void copyThrows(ExecutableElement method, MethodSpec.Builder methodBuilder) {
+    for (TypeMirror thrownType : method.getThrownTypes()) {
+      methodBuilder.addException(TypeName.get(thrownType));
+    }
+  }
+
+  private static CodeBlock copyParameters(
+      ExecutableElement method,
+      MethodSpec.Builder methodBuilder,
+      UniqueNameSet nameSet,
+      ImmutableList.Builder<CodeBlock> argumentsBuilder) {
+    for (VariableElement parameter : method.getParameters()) {
+      TypeMirror parameterType = parameter.asType();
+      boolean useObject = !isTypePubliclyAccessible(parameterType);
+      TypeName typeName = useObject ? TypeName.OBJECT : TypeName.get(parameterType);
+      String name = nameSet.getUniqueName(parameter.getSimpleName().toString());
+      argumentsBuilder.add(
+          useObject ? CodeBlock.of("($T) $L", parameterType, name) : CodeBlock.of(name));
+      ParameterSpec.Builder parameterBuilder =
+          ParameterSpec.builder(typeName, name)
+              .addModifiers(toArray(parameter.getModifiers(), Modifier.class));
+      methodBuilder.addParameter(parameterBuilder.build());
+    }
+    methodBuilder.varargs(method.isVarArgs());
+    return makeParametersCodeBlock(argumentsBuilder.build());
+  }
+
+  private static void copyTypeParameters(
+      Parameterizable parameterizable, MethodSpec.Builder methodBuilder) {
+    for (TypeParameterElement typeParameterElement : parameterizable.getTypeParameters()) {
+      methodBuilder.addTypeVariable(TypeVariableName.get(typeParameterElement));
+    }
+  }
+
+  private Proxies() {}
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/RequestFulfillment.java b/compiler/src/main/java/dagger/internal/codegen/RequestFulfillment.java
new file mode 100644
index 000000000..db296c066
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/RequestFulfillment.java
@@ -0,0 +1,53 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.base.Preconditions.checkNotNull;
+
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+
+/**
+ * A strategy interface for generating a {@link CodeBlock} that represents how a {@link Binding} is
+ * used to satisfy a given {@link DependencyRequest}.
+ */
+abstract class RequestFulfillment {
+  private final BindingKey bindingKey;
+
+  RequestFulfillment(BindingKey bindingKey) {
+    this.bindingKey = checkNotNull(bindingKey);
+  }
+
+  /** The key for which this instance can fulfill requests. */
+  final BindingKey bindingKey() {
+    return bindingKey;
+  }
+
+  /**
+   * Returns the {@link CodeBlock} that implements the operation represented by the {@link
+   * DependencyRequest request} from the {@code requestingClass}.
+   */
+  abstract CodeBlock getSnippetForDependencyRequest(
+      DependencyRequest request, ClassName requestingClass);
+
+  /**
+   * Returns the {@link CodeBlock} that references the {@link FrameworkDependency} as accessed from
+   * the {@code requestingClass}.
+   */
+  abstract CodeBlock getSnippetForFrameworkDependency(
+      FrameworkDependency frameworkDependency, ClassName requestingClass);
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/RequestFulfillmentRegistry.java b/compiler/src/main/java/dagger/internal/codegen/RequestFulfillmentRegistry.java
new file mode 100644
index 000000000..941d314e6
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/RequestFulfillmentRegistry.java
@@ -0,0 +1,81 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.collect.Maps.newLinkedHashMapWithExpectedSize;
+import static dagger.internal.codegen.ContributionBinding.Kind.INJECTION;
+import static dagger.internal.codegen.ContributionBinding.Kind.PROVISION;
+
+import com.google.common.collect.ImmutableMap;
+import java.util.Map;
+
+/**
+ * A registry that associates a {@link BindingKey} with a {@link RequestFulfillment}. The registry
+ * is responsible for choosing the most appropriate {@link RequestFulfillment} implementation based
+ * on the properties of the binding and how it is used throughout the component.
+ */
+final class RequestFulfillmentRegistry {
+  private final ImmutableMap<BindingKey, ResolvedBindings> resolvedBindingsMap;
+  private final HasBindingMembers hasBindingMembers;
+  /** This map is mutated as {@link #getRequestFulfillment} is invoked. */
+  private final Map<BindingKey, RequestFulfillment> requestFulfillments;
+
+  RequestFulfillmentRegistry(
+      ImmutableMap<BindingKey, ResolvedBindings> resolvedBindingsMap,
+      HasBindingMembers hasBindingMembers) {
+    this.resolvedBindingsMap = resolvedBindingsMap;
+    this.hasBindingMembers = hasBindingMembers;
+    this.requestFulfillments = newLinkedHashMapWithExpectedSize(resolvedBindingsMap.size());
+  }
+
+  /** Returns a {@link RequestFulfillment} implementation for the given {@link BindingKey} */
+  RequestFulfillment getRequestFulfillment(BindingKey bindingKey) {
+    return requestFulfillments.computeIfAbsent(bindingKey, this::createRequestFulfillment);
+  }
+
+  private RequestFulfillment createRequestFulfillment(BindingKey bindingKey) {
+    /* TODO(gak): it is super convoluted that we create the member selects separately and then
+     * look them up again this way. Now that we have RequestFulfillment, the next step is to
+     * create it and the MemberSelect and the field on demand rather than in a first pass. */
+    MemberSelect memberSelect = hasBindingMembers.getMemberSelect(bindingKey);
+    ResolvedBindings resolvedBindings = resolvedBindingsMap.get(bindingKey);
+    switch (resolvedBindings.bindingType()) {
+      case MEMBERS_INJECTION:
+        return new MembersInjectorRequestFulfillment(bindingKey, memberSelect);
+      case PRODUCTION:
+        return new ProducerFieldRequestFulfillment(bindingKey, memberSelect);
+      case PROVISION:
+        ProvisionBinding provisionBinding =
+            (ProvisionBinding) resolvedBindings.contributionBinding();
+
+        ProviderFieldRequestFulfillment providerFieldRequestFulfillment =
+            new ProviderFieldRequestFulfillment(bindingKey, memberSelect);
+        if (provisionBinding.implicitDependencies().isEmpty()
+            && !provisionBinding.scope().isPresent()
+            && !provisionBinding.requiresModuleInstance()
+            && provisionBinding.bindingElement().isPresent()
+            && (provisionBinding.bindingKind().equals(INJECTION)
+                || provisionBinding.bindingKind().equals(PROVISION))) {
+          return new SimpleMethodRequestFulfillment(
+              bindingKey, provisionBinding, providerFieldRequestFulfillment, this);
+        }
+        return providerFieldRequestFulfillment;
+      default:
+        throw new AssertionError();
+    }
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java b/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
index 49d465cb3..c6f381a63 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,14 +13,16 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal.codegen;
 
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkState;
+import static com.google.common.collect.Iterables.getOnlyElement;
+import static java.util.stream.Collectors.toSet;
+
 import com.google.auto.value.AutoValue;
-import com.google.common.base.Function;
-import com.google.common.base.Optional;
 import com.google.common.collect.FluentIterable;
-import com.google.common.collect.ImmutableList;
-import com.google.common.collect.ImmutableListMultimap;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ImmutableSetMultimap;
@@ -29,15 +31,9 @@
 import dagger.internal.codegen.BindingType.HasBindingType;
 import dagger.internal.codegen.ContributionType.HasContributionType;
 import dagger.internal.codegen.Key.HasKey;
-import java.util.Map;
+import java.util.Optional;
 import java.util.Set;
 
-import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkState;
-import static com.google.common.collect.Iterables.concat;
-import static com.google.common.collect.Iterables.getOnlyElement;
-import static dagger.internal.codegen.ContributionType.indexByContributionType;
-
 /**
  * The collection of bindings that have been resolved for a binding key. For valid graphs, contains
  * exactly one binding.
@@ -59,18 +55,18 @@
   abstract ComponentDescriptor owningComponent();
 
   /**
-   * The contribution bindings for {@link #bindingKey()} that were resolved in
-   * {@link #owningComponent()} or its ancestor components, keyed by the component in which the
-   * binding was resolved. If {@link #bindingKey()}'s kind is not
-   * {@link BindingKey.Kind#CONTRIBUTION}, this is empty.
+   * The contribution bindings for {@link #bindingKey()} that were resolved in {@link
+   * #owningComponent()} or its ancestor components, indexed by the component in which the binding
+   * was resolved. If {@link #bindingKey()}'s kind is not {@link BindingKey.Kind#CONTRIBUTION}, this
+   * is empty.
    */
   abstract ImmutableSetMultimap<ComponentDescriptor, ContributionBinding> allContributionBindings();
 
   /**
-   * The members-injection bindings for {@link #bindingKey()} that were resolved in
-   * {@link #owningComponent()} or its ancestor components, keyed by the component in which the
-   * binding was resolved. If {@link #bindingKey()}'s kind is not
-   * {@link BindingKey.Kind#MEMBERS_INJECTION}, this is empty.
+   * The members-injection bindings for {@link #bindingKey()} that were resolved in {@link
+   * #owningComponent()} or its ancestor components, indexed by the component in which the binding
+   * was resolved. If {@link #bindingKey()}'s kind is not {@link BindingKey.Kind#MEMBERS_INJECTION},
+   * this is empty.
    */
   abstract ImmutableMap<ComponentDescriptor, MembersInjectionBinding> allMembersInjectionBindings();
 
@@ -84,22 +80,42 @@ public Key key() {
    * {@link BindingKey.Kind#CONTRIBUTION}, this is empty.
    */
   abstract ImmutableSet<MultibindingDeclaration> multibindingDeclarations();
-  
+
   /**
-   * All bindings for {@link #bindingKey()}, regardless of in which component they were resolved.
+   * The subcomponent declarations for {@link #bindingKey()}. If {@link #bindingKey()}'s kind is not
+   * {@link BindingKey.Kind#CONTRIBUTION}, this is empty.
    */
-  ImmutableSet<? extends Binding> bindings() {
+  abstract ImmutableSet<SubcomponentDeclaration> subcomponentDeclarations();
+
+  /**
+   * The optional binding declarations for {@link #bindingKey()}. If {@link #bindingKey()}'s kind is
+   * not {@link BindingKey.Kind#CONTRIBUTION}, this is empty.
+   */
+  abstract ImmutableSet<OptionalBindingDeclaration> optionalBindingDeclarations();
+
+  /**
+   * All bindings for {@link #bindingKey()}, indexed by the component in which the binding was
+   * resolved.
+   */
+  ImmutableSetMultimap<ComponentDescriptor, ? extends Binding> allBindings() {
     switch (bindingKey().kind()) {
       case CONTRIBUTION:
-        return contributionBindings();
+        return allContributionBindings();
 
       case MEMBERS_INJECTION:
-        return ImmutableSet.copyOf(membersInjectionBinding().asSet());
+        return allMembersInjectionBindings().asMultimap();
 
       default:
         throw new AssertionError(bindingKey());
     }
   }
+  
+  /**
+   * All bindings for {@link #bindingKey()}, regardless of in which component they were resolved.
+   */
+  ImmutableSet<? extends Binding> bindings() {
+    return ImmutableSet.copyOf(allBindings().values());
+  }
 
   /**
    * Returns the single binding.
@@ -112,21 +128,13 @@ Binding binding() {
   }
 
   /**
-   * All bindings for {@link #bindingKey()}, together with the component in which they were
-   * resolved.
-   */
-  ImmutableList<Map.Entry<ComponentDescriptor, ? extends Binding>> bindingsByComponent() {
-    return new ImmutableList.Builder<Map.Entry<ComponentDescriptor, ? extends Binding>>()
-        .addAll(allContributionBindings().entries())
-        .addAll(allMembersInjectionBindings().entrySet())
-        .build();
-  }
-
-  /**
-   * {@code true} if there are no {@link #bindings()} or {@link #multibindingDeclarations()}.
+   * {@code true} if there are no {@link #bindings()}, {@link #multibindingDeclarations()}, or
+   * {@link #subcomponentDeclarations()}.
    */
   boolean isEmpty() {
-    return bindings().isEmpty() && multibindingDeclarations().isEmpty();
+    return bindings().isEmpty()
+        && multibindingDeclarations().isEmpty()
+        && subcomponentDeclarations().isEmpty();
   }
 
   /**
@@ -138,7 +146,9 @@ boolean isEmpty() {
         return ownedContributionBindings();
 
       case MEMBERS_INJECTION:
-        return ImmutableSet.copyOf(ownedMembersInjectionBinding().asSet());
+        return ownedMembersInjectionBinding().isPresent()
+            ? ImmutableSet.of(ownedMembersInjectionBinding().get())
+            : ImmutableSet.of();
 
       default:
         throw new AssertionError(bindingKey());
@@ -172,14 +182,14 @@ ComponentDescriptor owningComponent(ContributionBinding binding) {
   }
 
   /**
-   * The members-injection binding, regardless of owning component. Empty if these are contribution
-   * bindings.
+   * The members-injection binding, regardless of owning component. Absent if these are contribution
+   * bindings, or if there is no members-injection binding because the type fails validation.
    */
   Optional<MembersInjectionBinding> membersInjectionBinding() {
     ImmutableSet<MembersInjectionBinding> membersInjectionBindings =
         FluentIterable.from(allMembersInjectionBindings().values()).toSet();
     return membersInjectionBindings.isEmpty()
-        ? Optional.<MembersInjectionBinding>absent()
+        ? Optional.empty()
         : Optional.of(Iterables.getOnlyElement(membersInjectionBindings));
   }
 
@@ -188,24 +198,26 @@ ComponentDescriptor owningComponent(ContributionBinding binding) {
    * are contribution bindings.
    */
   Optional<MembersInjectionBinding> ownedMembersInjectionBinding() {
-    return Optional.fromNullable(allMembersInjectionBindings().get(owningComponent()));
+    return Optional.ofNullable(allMembersInjectionBindings().get(owningComponent()));
   }
 
-  /**
-   * Creates a {@link ResolvedBindings} for contribution bindings.
-   */
+  /** Creates a {@link ResolvedBindings} for contribution bindings. */
   static ResolvedBindings forContributionBindings(
       BindingKey bindingKey,
       ComponentDescriptor owningComponent,
       Multimap<ComponentDescriptor, ? extends ContributionBinding> contributionBindings,
-      Iterable<MultibindingDeclaration> multibindings) {
+      Iterable<MultibindingDeclaration> multibindings,
+      Iterable<SubcomponentDeclaration> subcomponentDeclarations,
+      Iterable<OptionalBindingDeclaration> optionalBindingDeclarations) {
     checkArgument(bindingKey.kind().equals(BindingKey.Kind.CONTRIBUTION));
     return new AutoValue_ResolvedBindings(
         bindingKey,
         owningComponent,
         ImmutableSetMultimap.<ComponentDescriptor, ContributionBinding>copyOf(contributionBindings),
         ImmutableMap.<ComponentDescriptor, MembersInjectionBinding>of(),
-        ImmutableSet.copyOf(multibindings));
+        ImmutableSet.copyOf(multibindings),
+        ImmutableSet.copyOf(subcomponentDeclarations),
+        ImmutableSet.copyOf(optionalBindingDeclarations));
   }
   
   /**
@@ -221,7 +233,9 @@ static ResolvedBindings forMembersInjectionBinding(
         owningComponent,
         ImmutableSetMultimap.<ComponentDescriptor, ContributionBinding>of(),
         ImmutableMap.of(owningComponent, ownedMembersInjectionBinding),
-        ImmutableSet.<MultibindingDeclaration>of());
+        ImmutableSet.<MultibindingDeclaration>of(),
+        ImmutableSet.<SubcomponentDeclaration>of(),
+        ImmutableSet.<OptionalBindingDeclaration>of());
   }
 
   /**
@@ -233,7 +247,9 @@ static ResolvedBindings noBindings(BindingKey bindingKey, ComponentDescriptor ow
         owningComponent,
         ImmutableSetMultimap.<ComponentDescriptor, ContributionBinding>of(),
         ImmutableMap.<ComponentDescriptor, MembersInjectionBinding>of(),
-        ImmutableSet.<MultibindingDeclaration>of());
+        ImmutableSet.<MultibindingDeclaration>of(),
+        ImmutableSet.<SubcomponentDeclaration>of(),
+        ImmutableSet.<OptionalBindingDeclaration>of());
   }
 
   /**
@@ -246,7 +262,9 @@ ResolvedBindings asInheritedIn(ComponentDescriptor owningComponent) {
         owningComponent,
         allContributionBindings(),
         allMembersInjectionBindings(),
-        multibindingDeclarations());
+        multibindingDeclarations(),
+        subcomponentDeclarations(),
+        optionalBindingDeclarations());
   }
 
   /**
@@ -268,56 +286,38 @@ ContributionBinding contributionBinding() {
   }
 
   /**
-   * The binding type for all {@link #bindings()} and {@link #multibindingDeclarations()}.
+   * The binding type for these bindings. If there are {@link #multibindingDeclarations()} or {@link
+   * #subcomponentDeclarations()} but no {@link #bindings()}, returns {@link BindingType#PROVISION}.
    *
    * @throws IllegalStateException if {@link #isEmpty()} or the binding types conflict
    */
   @Override
   public BindingType bindingType() {
     checkState(!isEmpty(), "empty bindings for %s", bindingKey());
-    ImmutableSet<BindingType> bindingTypes =
-        FluentIterable.from(concat(bindings(), multibindingDeclarations()))
-            .transform(BindingType.BINDING_TYPE)
-            .toSet();
-    checkState(bindingTypes.size() == 1, "conflicting binding types: %s", this);
+    if (bindings().isEmpty()
+        && (!multibindingDeclarations().isEmpty() || !subcomponentDeclarations().isEmpty())) {
+      // Only multibinding declarations, so assume provision.
+      return BindingType.PROVISION;
+    }
+    ImmutableSet<BindingType> bindingTypes = bindingTypes();
+    checkState(bindingTypes.size() == 1, "conflicting binding types: %s", bindings());
     return getOnlyElement(bindingTypes);
   }
 
+  /** The binding types for {@link #bindings()}. */
+  ImmutableSet<BindingType> bindingTypes() {
+    return FluentIterable.from(bindings()).transform(HasBindingType::bindingType).toSet();
+  }
+
   /**
    * The contribution type for these bindings.
    *
-   * @throws IllegalStateException if {@link #isEmpty()} or the contribution types conflict
+   * @throws IllegalStateException if there is not exactly one element in {@link
+   *     #contributionBindings()}, which will never happen for contributions in valid graphs
    */
   @Override
   public ContributionType contributionType() {
-    ImmutableSet<ContributionType> types = contributionTypes();
-    checkState(!types.isEmpty(), "no bindings or declarations for %s", bindingKey());
-    checkState(
-        types.size() == 1,
-        "More than one binding present of different types for %s: %s",
-        bindingKey(),
-        bindingsAndDeclarationsByContributionType());
-    return getOnlyElement(types);
-  }
-
-  /**
-   * The contribution types represented by {@link #contributionBindings()} and
-   * {@link #multibindingDeclarations()}.
-   */
-  ImmutableSet<ContributionType> contributionTypes() {
-    return bindingsAndDeclarationsByContributionType().keySet();
-  }
-
-  /**
-   * The {@link #contributionBindings()} and {@link #multibindingDeclarations()}, indexed by
-   * {@link ContributionType}.
-   */
-  ImmutableListMultimap<ContributionType, BindingDeclaration>
-      bindingsAndDeclarationsByContributionType() {
-    return new ImmutableListMultimap.Builder<ContributionType, BindingDeclaration>()
-        .putAll(indexByContributionType(contributionBindings()))
-        .putAll(indexByContributionType(multibindingDeclarations()))
-        .build();
+    return contributionBinding().contributionType();
   }
 
   /**
@@ -327,19 +327,15 @@ public ContributionType contributionType() {
    * @throws IllegalArgumentException if the bindings must be managed in more than one package
    */
   Optional<String> bindingPackage() {
-    ImmutableSet.Builder<String> bindingPackagesBuilder = ImmutableSet.builder();
-    for (Binding binding : bindings()) {
-      bindingPackagesBuilder.addAll(binding.bindingPackage().asSet());
-    }
-    ImmutableSet<String> bindingPackages = bindingPackagesBuilder.build();
-    switch (bindingPackages.size()) {
-      case 0:
-        return Optional.absent();
-      case 1:
-        return Optional.of(bindingPackages.iterator().next());
-      default:
-        throw new IllegalArgumentException();
-    }
+    Set<String> bindingPackages =
+        bindings()
+            .stream()
+            .map(Binding::bindingPackage)
+            .filter(Optional::isPresent)
+            .map(Optional::get)
+            .collect(toSet());
+    checkArgument(bindingPackages.size() <= 1);
+    return bindingPackages.stream().findFirst();
   }
 
   /**
@@ -349,11 +345,12 @@ public ContributionType contributionType() {
     return bindingType().frameworkClass();
   }
 
-  static final Function<ResolvedBindings, Set<ContributionBinding>> CONTRIBUTION_BINDINGS =
-      new Function<ResolvedBindings, Set<ContributionBinding>>() {
-        @Override
-        public Set<ContributionBinding> apply(ResolvedBindings resolvedBindings) {
-          return resolvedBindings.contributionBindings();
-        }
-      };
+  /**
+   * The scope associated with the single binding.
+   *
+   * @throws IllegalStateException if {@link #bindings()} does not have exactly one element
+   */
+  Optional<Scope> scope() {
+    return getOnlyElement(bindings()).scope();
+  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/Scope.java b/compiler/src/main/java/dagger/internal/codegen/Scope.java
index 0c136b3d7..74021aede 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Scope.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Scope.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,51 +13,76 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal.codegen;
 
+import static com.google.auto.common.AnnotationMirrors.getAnnotatedAnnotations;
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
+import static com.google.common.base.Preconditions.checkArgument;
+import static dagger.internal.codegen.ErrorMessages.stripCommonTypePrefixes;
+import static dagger.internal.codegen.InjectionAnnotations.getScopes;
+
 import com.google.auto.common.AnnotationMirrors;
+import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
-import com.google.common.base.Function;
-import com.google.common.base.Optional;
-import com.google.common.base.Preconditions;
+import com.google.auto.value.AutoValue;
+import com.google.common.base.Equivalence;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
 import dagger.Reusable;
 import dagger.producers.ProductionScope;
+import dagger.releasablereferences.CanReleaseReferences;
 import java.lang.annotation.Annotation;
+import java.util.Optional;
 import javax.inject.Singleton;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
 
-import static com.google.common.base.Preconditions.checkNotNull;
-import static dagger.internal.codegen.ErrorMessages.stripCommonTypePrefixes;
-import static dagger.internal.codegen.InjectionAnnotations.getScopes;
+/** A javax.inject.Scope. */
+@AutoValue
+abstract class Scope {
+
+  /** The underlying {@link AnnotationMirror} that represents the scope annotation. */
+  abstract Equivalence.Wrapper<AnnotationMirror> scopeAnnotation();
+
+  /**
+   * Creates a {@link Scope} object from the {@link javax.inject.Scope}-annotated annotation type.
+   */
+  static Scope scope(AnnotationMirror scopeAnnotation) {
+    checkArgument(isScope(scopeAnnotation));
+    return new AutoValue_Scope(AnnotationMirrors.equivalence().wrap(scopeAnnotation));
+  }
+
+  /** Returns {@code true} if {@code scopeAnnotation} is a {@link javax.inject.Scope} annotation. */
+  static boolean isScope(AnnotationMirror scopeAnnotation) {
+    return isScope(MoreElements.asType(scopeAnnotation.getAnnotationType().asElement()));
+  }
 
-/**
- * A representation of the scope (or lack of it) associated with a component, providing method
- * or injection location.
- */
-final class Scope {
   /**
-   * The underlying {@link AnnotationMirror} that represents the scope annotation.
+   * Returns {@code true} if {@code scopeAnnotationType} is a {@link javax.inject.Scope} annotation.
    */
-  private final AnnotationMirror annotationMirror;
+  static boolean isScope(TypeElement scopeAnnotationType) {
+    return isAnnotationPresent(scopeAnnotationType, javax.inject.Scope.class);
+  }
+  
+  /**
+   * Creates a {@link Scope} object from the {@link javax.inject.Scope}-annotated annotation type.
+   */
+  static Scope scope(TypeElement scopeType) {
+    return scope(SimpleAnnotationMirror.of(scopeType));
+  }
 
-  private Scope(AnnotationMirror annotationMirror) {
-    this.annotationMirror = checkNotNull(annotationMirror);
+  private static Scope scope(Elements elements, Class<? extends Annotation> scopeAnnotationClass) {
+    return scope(elements.getTypeElement(scopeAnnotationClass.getCanonicalName()));
   }
 
-  /** Returns all of the associated scoped annotations from the source code element. */
+  /** Returns all of the associated scopes for a source code element. */
   static ImmutableSet<Scope> scopesOf(Element element) {
-    return FluentIterable.from(getScopes(element)).
-        transform(new Function<AnnotationMirror, Scope>() {
-          @Override public Scope apply(AnnotationMirror annotationMirror) {
-            return new Scope(annotationMirror);
-          }
-        }).toSet();
+    return FluentIterable.from(getScopes(element)).transform(Scope::scope).toSet();
   }
 
   /**
@@ -67,9 +92,9 @@ private Scope(AnnotationMirror annotationMirror) {
   static Optional<Scope> uniqueScopeOf(Element element) {
     ImmutableSet<? extends AnnotationMirror> scopeAnnotations = getScopes(element);
     if (scopeAnnotations.isEmpty()) {
-      return Optional.absent();
+      return Optional.empty();
     }
-    return Optional.of(new Scope(Iterables.getOnlyElement(scopeAnnotations)));
+    return Optional.of(scope(Iterables.getOnlyElement(scopeAnnotations)));
   }
 
   /**
@@ -93,10 +118,35 @@ static Scope reusableScope(Elements elements) {
     return scope(elements, Reusable.class);
   }
 
-  private static Scope scope(Elements elements, Class<? extends Annotation> scopeAnnotationClass) {
-    return new Scope(
-        SimpleAnnotationMirror.of(
-            elements.getTypeElement(scopeAnnotationClass.getCanonicalName())));
+  /**
+   * Returns {@code true} for scopes that are annotated with {@link CanReleaseReferences} or some
+   * other annotation that is itself annotated with {@link CanReleaseReferences}.
+   */
+  boolean canReleaseReferences() {
+    return isAnnotationPresent(scopeAnnotationElement(), CanReleaseReferences.class)
+        || !releasableReferencesMetadata().isEmpty();
+  }
+
+  /**
+   * Returns the set of annotations on the scope that are themselves annotated with {@link
+   * CanReleaseReferences}. These annotations are used as metadata for {@link
+   * dagger.releasablereferences.TypedReleasableReferenceManager}.
+   */
+  ImmutableSet<? extends AnnotationMirror> releasableReferencesMetadata() {
+    return getAnnotatedAnnotations(scopeAnnotationElement(), CanReleaseReferences.class);
+  }
+
+  /**
+   * Returns the {@linkplain #releasableReferencesMetadata() releasable references metadata}
+   * annotation of the given type, if there is one for this scope.
+   */
+  Optional<AnnotationMirror> releasableReferencesMetadata(TypeMirror metadataType) {
+    for (AnnotationMirror metadata : releasableReferencesMetadata()) {
+      if (MoreTypes.equivalence().equivalent(metadata.getAnnotationType(), metadataType)) {
+        return Optional.of(metadata);
+      }
+    }
+    return Optional.empty();
   }
 
   /**
@@ -105,8 +155,8 @@ private static Scope scope(Elements elements, Class<? extends Annotation> scopeA
    * <p>It's readable source because it has had common package prefixes removed, e.g.
    * {@code @javax.inject.Singleton} is returned as {@code @Singleton}.
    *
-   * This does not return any annotation values as according to {@link javax.inject.Scope} scope
-   * annotations are not supposed to use them.
+   * <p>Does not return any annotation values, since {@link javax.inject.Scope @Scope}
+   * annotations are not supposed to have any.
    */
   public String getReadableSource() {
     return stripCommonTypePrefixes("@" + getQualifiedName());
@@ -116,32 +166,14 @@ public String getReadableSource() {
    * Returns the fully qualified name of the annotation type.
    */
   public String getQualifiedName() {
-    Preconditions.checkState(annotationMirror != null,
-        "Cannot create a stripped source representation of no annotation");
-    TypeElement typeElement = MoreTypes.asTypeElement(annotationMirror.getAnnotationType());
-    return typeElement.getQualifiedName().toString();
+    return scopeAnnotationElement().getQualifiedName().toString();
   }
 
   /**
-   * Scopes are equal if the underlying {@link AnnotationMirror} are equivalent according to
-   * {@link AnnotationMirrors#equivalence()}.
+   * The scope annotation element.
    */
-  @Override
-  public boolean equals(Object obj) {
-    if (this == obj) {
-      return true;
-    } else if (obj instanceof Scope) {
-      Scope that = (Scope) obj;
-      return AnnotationMirrors.equivalence()
-        .equivalent(this.annotationMirror, that.annotationMirror);
-    } else {
-      return false;
-    }
-  }
-
-  @Override
-  public int hashCode() {
-    return AnnotationMirrors.equivalence().hash(annotationMirror);
+  public TypeElement scopeAnnotationElement() {
+    return MoreTypes.asTypeElement(scopeAnnotation().get().getAnnotationType());
   }
 
   /**
@@ -149,6 +181,6 @@ public int hashCode() {
    */
   @Override
   public String toString() {
-    return annotationMirror.toString();
+    return scopeAnnotation().get().toString();
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/SetType.java b/compiler/src/main/java/dagger/internal/codegen/SetType.java
index 9b55eed87..180fc66fb 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SetType.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SetType.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,8 +13,11 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal.codegen;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Equivalence;
@@ -22,9 +25,6 @@
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeMirror;
 
-import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkState;
-
 /**
  * Information about a {@link Set} {@link TypeMirror}.
  */
@@ -76,7 +76,11 @@ TypeMirror unwrappedElementType(Class<?> wrappingClass) {
         wrappingClass.getTypeParameters().length == 1,
         "%s must have exactly one type parameter",
         wrappingClass);
-    checkState(elementsAreTypeOf(wrappingClass));
+    checkArgument(
+        elementsAreTypeOf(wrappingClass),
+        "expected elements to be %s, but this type is %s",
+        wrappingClass,
+        declaredSetType());
     return MoreTypes.asDeclared(elementType()).getTypeArguments().get(0);
   }
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/SimpleAnnotationMirror.java b/compiler/src/main/java/dagger/internal/codegen/SimpleAnnotationMirror.java
index c94eafea6..505c8eaef 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SimpleAnnotationMirror.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SimpleAnnotationMirror.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 Google, Inc.
+ * Copyright (C) 2016 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,10 +13,18 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal.codegen;
 
+import static com.google.common.base.Preconditions.checkArgument;
+import static javax.lang.model.util.ElementFilter.methodsIn;
+
 import com.google.auto.common.MoreTypes;
+import com.google.common.base.Functions;
+import com.google.common.base.Joiner;
+import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.Maps;
 import java.util.Map;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.AnnotationValue;
@@ -25,34 +33,75 @@
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.DeclaredType;
 
-import static com.google.common.base.Preconditions.checkArgument;
-
-/** A representation of an annotation with no fields. */
+/** A representation of an annotation. */
 final class SimpleAnnotationMirror implements AnnotationMirror {
-  private final DeclaredType type;
+  private final TypeElement annotationType;
+  private final ImmutableMap<String, ? extends AnnotationValue> namedValues;
+  private final ImmutableMap<ExecutableElement, ? extends AnnotationValue> elementValues;
 
-  private SimpleAnnotationMirror(DeclaredType type) {
-    this.type = type;
+  private SimpleAnnotationMirror(
+      TypeElement annotationType, Map<String, ? extends AnnotationValue> namedValues) {
+    checkArgument(
+        annotationType.getKind().equals(ElementKind.ANNOTATION_TYPE),
+        "annotationType must be an annotation: %s",
+        annotationType);
+    checkArgument(
+        FluentIterable.from(methodsIn(annotationType.getEnclosedElements()))
+            .transform(element -> element.getSimpleName().toString())
+            .toSet()
+            .equals(namedValues.keySet()),
+        "namedValues must have values for exactly the members in %s: %s",
+        annotationType,
+        namedValues);
+    this.annotationType = annotationType;
+    this.namedValues = ImmutableMap.copyOf(namedValues);
+    this.elementValues =
+        Maps.toMap(
+            methodsIn(annotationType.getEnclosedElements()),
+            Functions.compose(
+                Functions.forMap(namedValues), element -> element.getSimpleName().toString()));
   }
 
   @Override
   public DeclaredType getAnnotationType() {
-    return type;
+    return MoreTypes.asDeclared(annotationType.asType());
   }
 
   @Override
-  public Map<? extends ExecutableElement, ? extends AnnotationValue> getElementValues() {
-    return ImmutableMap.of();
+  public Map<ExecutableElement, ? extends AnnotationValue> getElementValues() {
+    return elementValues;
   }
 
   @Override
   public String toString() {
-    return "@" + type;
+    StringBuilder builder = new StringBuilder("@").append(annotationType.getQualifiedName());
+    if (!namedValues.isEmpty()) {
+      builder
+          .append('(')
+          .append(Joiner.on(", ").withKeyValueSeparator(" = ").join(namedValues))
+          .append(')');
+    }
+    return builder.toString();
+  }
+
+  /**
+   * An object representing an annotation instance.
+   *
+   * @param annotationType must be an annotation type with no members
+   */
+  static AnnotationMirror of(TypeElement annotationType) {
+    return of(annotationType, ImmutableMap.<String, AnnotationValue>of());
   }
 
-  static AnnotationMirror of(TypeElement element) {
-    checkArgument(element.getKind().equals(ElementKind.ANNOTATION_TYPE));
-    checkArgument(element.getEnclosedElements().isEmpty());
-    return new SimpleAnnotationMirror(MoreTypes.asDeclared(element.asType()));
+  /**
+   * An object representing an annotation instance.
+   *
+   * @param annotationType must be an annotation type
+   * @param namedValues a value for every annotation member, including those with defaults, indexed
+   *     by simple name
+   */
+  static AnnotationMirror of(
+      TypeElement annotationType, Map<String, ? extends AnnotationValue> namedValues) {
+    return new SimpleAnnotationMirror(annotationType, namedValues);
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/SimpleMethodRequestFulfillment.java b/compiler/src/main/java/dagger/internal/codegen/SimpleMethodRequestFulfillment.java
new file mode 100644
index 000000000..8c7fb6dfb
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/SimpleMethodRequestFulfillment.java
@@ -0,0 +1,144 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.auto.common.MoreElements.asExecutable;
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkState;
+import static dagger.internal.codegen.Accessibility.isTypeAccessibleFrom;
+import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
+import static dagger.internal.codegen.Proxies.proxyName;
+import static dagger.internal.codegen.Proxies.requiresProxyAccess;
+import static dagger.internal.codegen.SourceFiles.generatedClassNameForBinding;
+import static dagger.internal.codegen.TypeNames.rawTypeName;
+import static java.util.stream.Collectors.collectingAndThen;
+import static java.util.stream.Collectors.toList;
+import static javax.lang.model.element.Modifier.STATIC;
+
+import com.google.common.util.concurrent.Futures;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.TypeName;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.type.TypeMirror;
+
+/**
+ * A request fulfillment implementation that invokes methods or constructors directly to fulfill
+ * requests whenever possible. In cases where direct invocation is not possible, this implementation
+ * delegates to one that uses a {@link javax.inject.Provider}.
+ */
+final class SimpleMethodRequestFulfillment extends RequestFulfillment {
+
+  private final ProvisionBinding provisionBinding;
+  private final RequestFulfillment providerDelegate;
+  private final RequestFulfillmentRegistry registry;
+
+  SimpleMethodRequestFulfillment(
+      BindingKey bindingKey,
+      ProvisionBinding provisionBinding,
+      RequestFulfillment providerDelegate,
+      RequestFulfillmentRegistry registry) {
+    super(bindingKey);
+    checkArgument(
+        provisionBinding.implicitDependencies().isEmpty(),
+        "framework deps are not currently supported");
+    checkArgument(!provisionBinding.scope().isPresent());
+    checkArgument(!provisionBinding.requiresModuleInstance());
+    checkArgument(provisionBinding.bindingElement().isPresent());
+    this.provisionBinding = provisionBinding;
+    this.providerDelegate = providerDelegate;
+    this.registry = registry;
+  }
+
+  @Override
+  CodeBlock getSnippetForDependencyRequest(DependencyRequest request, ClassName requestingClass) {
+    switch (request.kind()) {
+      case INSTANCE:
+        return invokeMethodOrProxy(requestingClass);
+      case FUTURE:
+        return CodeBlock.of(
+            "$T.immediateFuture($L)", Futures.class, invokeMethodOrProxy(requestingClass));
+      default:
+        return providerDelegate.getSnippetForDependencyRequest(request, requestingClass);
+    }
+  }
+
+  @Override
+  CodeBlock getSnippetForFrameworkDependency(
+      FrameworkDependency frameworkDependency, ClassName requestingClass) {
+    return providerDelegate.getSnippetForFrameworkDependency(frameworkDependency, requestingClass);
+  }
+
+  private CodeBlock invokeMethodOrProxy(ClassName requestingClass) {
+    ExecutableElement bindingElement = asExecutable(provisionBinding.bindingElement().get());
+    return requiresProxyAccess(bindingElement, requestingClass.packageName())
+        ? invokeProxyMethod(requestingClass)
+        : invokeMethod(requestingClass);
+  }
+
+  private CodeBlock invokeMethod(ClassName requestingClass) {
+    CodeBlock parametersCodeBlock =
+        makeParametersCodeBlock(
+            provisionBinding
+                .explicitDependencies()
+                .stream()
+                .map(
+                    request -> {
+                      CodeBlock snippet = getDependencySnippet(requestingClass, request);
+                      TypeMirror requestElementType = request.requestElement().get().asType();
+                      return isTypeAccessibleFrom(requestElementType, requestingClass.packageName())
+                          ? snippet
+                          : CodeBlock.of(
+                              "($T) $L", rawTypeName(TypeName.get(requestElementType)), snippet);
+                    })
+                .collect(toList()));
+    // we use the type from the key to ensure we get the right generics
+    // TODO(gak): use <>?
+    ExecutableElement method = asExecutable(provisionBinding.bindingElement().get());
+    switch (method.getKind()) {
+      case CONSTRUCTOR:
+        return CodeBlock.of("new $T($L)", provisionBinding.key().type(), parametersCodeBlock);
+      case METHOD:
+        checkState(method.getModifiers().contains(STATIC));
+        return CodeBlock.of(
+            "$T.$L($L)",
+            provisionBinding.bindingTypeElement().get(),
+            method.getSimpleName(),
+            parametersCodeBlock);
+      default:
+        throw new IllegalStateException();
+    }
+  }
+
+  private CodeBlock invokeProxyMethod(ClassName requestingClass) {
+    return CodeBlock.of(
+        "$T.$L($L)",
+        generatedClassNameForBinding(provisionBinding),
+        proxyName(asExecutable(provisionBinding.bindingElement().get())),
+        provisionBinding
+            .explicitDependencies()
+            .stream()
+            .map(request -> getDependencySnippet(requestingClass, request))
+            .collect(collectingAndThen(toList(), CodeBlocks::makeParametersCodeBlock)));
+  }
+
+  private CodeBlock getDependencySnippet(ClassName requestingClass, DependencyRequest request) {
+    return registry
+        .getRequestFulfillment(request.bindingKey())
+        .getSnippetForDependencyRequest(request, requestingClass);
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/SimpleTypeAnnotationValue.java b/compiler/src/main/java/dagger/internal/codegen/SimpleTypeAnnotationValue.java
new file mode 100644
index 000000000..7f043db02
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/SimpleTypeAnnotationValue.java
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import javax.lang.model.element.AnnotationValue;
+import javax.lang.model.element.AnnotationValueVisitor;
+import javax.lang.model.type.TypeMirror;
+
+/** An {@link AnnotationValue} that contains a {@link TypeMirror}. */
+final class SimpleTypeAnnotationValue implements AnnotationValue {
+  private final TypeMirror value;
+
+  SimpleTypeAnnotationValue(TypeMirror value) {
+    this.value = value;
+  }
+
+  @Override
+  public TypeMirror getValue() {
+    return value;
+  }
+
+  @Override
+  public String toString() {
+    return value + ".class";
+  }
+
+  @Override
+  public <R, P> R accept(AnnotationValueVisitor<R, P> visitor, P parameter) {
+    return visitor.visitType(getValue(), parameter);
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerationException.java b/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerationException.java
index 46a04d63c..bc3391d00 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerationException.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerationException.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Google, Inc.
+ * Copyright (C) 2014 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,16 +13,17 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal.codegen;
 
-import com.google.common.base.Optional;
+import static com.google.common.base.Preconditions.checkNotNull;
+import static javax.tools.Diagnostic.Kind.ERROR;
+
 import com.squareup.javapoet.ClassName;
+import java.util.Optional;
 import javax.annotation.processing.Messager;
 import javax.lang.model.element.Element;
 
-import static com.google.common.base.Preconditions.checkNotNull;
-import static javax.tools.Diagnostic.Kind.ERROR;
-
 /**
  * An exception thrown to indicate that a source file could not be generated.
  *
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerator.java b/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerator.java
index 928a794ba..436a7484e 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerator.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Google, Inc.
+ * Copyright (C) 2014 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,28 +13,22 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal.codegen;
 
-import com.google.common.base.Optional;
+import static com.google.common.base.Preconditions.checkNotNull;
+
 import com.google.common.base.Throwables;
-import com.google.common.collect.Iterables;
-import com.google.common.io.CharSink;
-import com.google.common.io.CharSource;
-import com.google.googlejavaformat.java.Formatter;
-import com.google.googlejavaformat.java.FormatterException;
 import com.squareup.javapoet.AnnotationSpec;
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.JavaFile;
 import com.squareup.javapoet.TypeSpec;
-import java.io.IOException;
-import java.io.Writer;
+import java.util.Optional;
 import javax.annotation.Generated;
 import javax.annotation.processing.Filer;
+import javax.annotation.processing.Messager;
 import javax.lang.model.element.Element;
 import javax.lang.model.util.Elements;
-import javax.tools.JavaFileObject;
-
-import static com.google.common.base.Preconditions.checkNotNull;
 
 /**
  * A template class that provides a framework for properly handling IO while generating source files
@@ -60,37 +54,33 @@
     generatedAnnotationAvailable = elements.getTypeElement("javax.annotation.Generated") != null;
   }
 
+  /**
+   * Generates a source file to be compiled for {@code T}. Writes any generation exception to {@code
+   * messager} and does not throw.
+   */
+  void generate(T input, Messager messager) {
+    try {
+      generate(input);
+    } catch (SourceFileGenerationException e) {
+      e.printMessageTo(messager);
+    }
+  }
+
   /** Generates a source file to be compiled for {@code T}. */
   void generate(T input) throws SourceFileGenerationException {
     ClassName generatedTypeName = nameGeneratedType(input);
+    Optional<TypeSpec.Builder> type = write(generatedTypeName, input);
+    if (!type.isPresent()) {
+      return;
+    }
     try {
-      Optional<TypeSpec.Builder> type = write(generatedTypeName, input);
-      if (!type.isPresent()) {
-        return;
-      }
-      JavaFile javaFile = buildJavaFile(generatedTypeName, type.get());
-
-      final JavaFileObject sourceFile = filer.createSourceFile(
-          generatedTypeName.toString(),
-          Iterables.toArray(javaFile.typeSpec.originatingElements, Element.class));
-      try {
-        new Formatter().formatSource(
-            CharSource.wrap(javaFile.toString()),
-            new CharSink() {
-              @Override public Writer openStream() throws IOException {
-                return sourceFile.openWriter();
-              }
-            });
-      } catch (FormatterException e) {
-        throw new SourceFileGenerationException(
-            Optional.of(generatedTypeName), e, getElementForErrorReporting(input));
-      }
+      buildJavaFile(generatedTypeName, type.get()).writeTo(filer);
     } catch (Exception e) {
       // if the code above threw a SFGE, use that
       Throwables.propagateIfPossible(e, SourceFileGenerationException.class);
       // otherwise, throw a new one
       throw new SourceFileGenerationException(
-          Optional.<ClassName>absent(), e, getElementForErrorReporting(input));
+          Optional.empty(), e, getElementForErrorReporting(input));
     }
   }
 
@@ -122,7 +112,7 @@ private JavaFile buildJavaFile(
 
   /**
    * Returns a {@link TypeSpec.Builder type} to be generated for {@code T}, or {@link
-   * Optional#absent()} if no file should be generated.
+   * Optional#empty()} if no file should be generated.
    */
   // TODO(ronshapiro): write() makes more sense in JavaWriter where all writers are mutable.
   // consider renaming to something like typeBuilder() which conveys the mutability of the result
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
index c31376055..3a8906faf 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Google, Inc.
+ * Copyright (C) 2014 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
  * in compliance with the License. You may obtain a copy of the License at
@@ -11,33 +11,38 @@
  * or implied. See the License for the specific language governing permissions and limitations under
  * the License.
  */
+
 package dagger.internal.codegen;
 
+import static com.google.common.base.CaseFormat.LOWER_CAMEL;
+import static com.google.common.base.CaseFormat.UPPER_CAMEL;
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Verify.verify;
+import static dagger.internal.codegen.ContributionBinding.Kind.INJECTION;
+import static dagger.internal.codegen.Optionals.optionalComparator;
+import static dagger.internal.codegen.TypeNames.DOUBLE_CHECK;
+import static dagger.internal.codegen.TypeNames.PROVIDER_OF_LAZY;
+import static java.util.Comparator.comparing;
+import static javax.lang.model.SourceVersion.isName;
+
 import com.google.common.base.CaseFormat;
 import com.google.common.base.Joiner;
-import com.google.common.base.Optional;
-import com.google.common.collect.ComparisonChain;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
-import com.google.common.collect.Ordering;
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
 import com.squareup.javapoet.ParameterizedTypeName;
 import com.squareup.javapoet.TypeName;
 import com.squareup.javapoet.TypeVariableName;
+import java.util.Comparator;
 import java.util.Iterator;
+import javax.lang.model.SourceVersion;
+import javax.lang.model.element.Element;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.TypeParameterElement;
-import javax.lang.model.type.TypeMirror;
-
-import static com.google.common.base.CaseFormat.UPPER_CAMEL;
-import static com.google.common.base.Preconditions.checkArgument;
-import static dagger.internal.codegen.FrameworkDependency.frameworkDependenciesForBinding;
-import static dagger.internal.codegen.TypeNames.DOUBLE_CHECK;
-import static dagger.internal.codegen.TypeNames.PROVIDER_OF_LAZY;
 
 /**
  * Utilities for generating files.
@@ -53,19 +58,18 @@
    * Sorts {@link DependencyRequest} instances in an order likely to reflect their logical
    * importance.
    */
-  static final Ordering<DependencyRequest> DEPENDENCY_ORDERING = new Ordering<DependencyRequest>() {
-    @Override
-    public int compare(DependencyRequest left, DependencyRequest right) {
-      return ComparisonChain.start()
+  static final Comparator<DependencyRequest> DEPENDENCY_ORDERING =
       // put fields before parameters
-          .compare(left.requestElement().getKind(), right.requestElement().getKind())
+      comparing(
+              (DependencyRequest request) -> request.requestElement().map(Element::getKind),
+              optionalComparator())
           // order by dependency kind
-          .compare(left.kind(), right.kind())
+          .thenComparing(DependencyRequest::kind)
           // then sort by name
-          .compare(left.requestElement().getSimpleName().toString(),
-              right.requestElement().getSimpleName().toString()).result();
-    }
-  };
+          .thenComparing(
+              request ->
+                  request.requestElement().map(element -> element.getSimpleName().toString()),
+              optionalComparator());
 
   /**
    * Generates names and keys for the factory class fields needed to hold the framework classes for
@@ -76,7 +80,7 @@ public int compare(DependencyRequest left, DependencyRequest right) {
    * <li>is <i>probably</i> associated with the type being bound
    * <li>is unique within the class
    * </ul>
-   * 
+   *
    * @param binding must be an unresolved binding (type parameters must match its type element's)
    */
   static ImmutableMap<BindingKey, FrameworkField> generateBindingFieldsForDependencies(
@@ -84,23 +88,22 @@ public int compare(DependencyRequest left, DependencyRequest right) {
     checkArgument(!binding.unresolved().isPresent(), "binding must be unresolved: %s", binding);
 
     ImmutableMap.Builder<BindingKey, FrameworkField> bindingFields = ImmutableMap.builder();
-    for (FrameworkDependency frameworkDependency : frameworkDependenciesForBinding(binding)) {
+    for (Binding.DependencyAssociation dependencyAssociation : binding.dependencyAssociations()) {
+      FrameworkDependency frameworkDependency = dependencyAssociation.frameworkDependency();
       bindingFields.put(
           frameworkDependency.bindingKey(),
           FrameworkField.create(
               ClassName.get(frameworkDependency.frameworkClass()),
               TypeName.get(frameworkDependency.bindingKey().key().type()),
-              fieldNameForDependency(frameworkDependency)));
+              fieldNameForDependency(dependencyAssociation.dependencyRequests())));
     }
     return bindingFields.build();
   }
 
-  private static String fieldNameForDependency(FrameworkDependency frameworkDependency) {
+  private static String fieldNameForDependency(ImmutableSet<DependencyRequest> dependencyRequests) {
     // collect together all of the names that we would want to call the provider
     ImmutableSet<String> dependencyNames =
-        FluentIterable.from(frameworkDependency.dependencyRequests())
-            .transform(new DependencyVariableNamer())
-            .toSet();
+        FluentIterable.from(dependencyRequests).transform(new DependencyVariableNamer()).toSet();
 
     if (dependencyNames.size() == 1) {
       // if there's only one name, great! use it!
@@ -131,11 +134,11 @@ static CodeBlock frameworkTypeUsageStatement(
       case PROVIDER:
       case PRODUCER:
       case MEMBERS_INJECTOR:
-        return CodeBlock.of("$L", frameworkTypeMemberSelect);
+        return frameworkTypeMemberSelect;
       case PROVIDER_OF_LAZY:
         return CodeBlock.of("$T.create($L)", PROVIDER_OF_LAZY, frameworkTypeMemberSelect);
-      default:
-        throw new AssertionError();
+      default: // including PRODUCED
+        throw new AssertionError(dependencyKind);
     }
   }
 
@@ -147,13 +150,12 @@ static ClassName generatedClassNameForBinding(Binding binding) {
       case PROVISION:
       case PRODUCTION:
         ContributionBinding contribution = (ContributionBinding) binding;
-        checkArgument(!contribution.isSyntheticBinding());
-        ClassName enclosingClassName = ClassName.get(contribution.bindingTypeElement());
+        checkArgument(contribution.bindingTypeElement().isPresent());
+        ClassName enclosingClassName = ClassName.get(contribution.bindingTypeElement().get());
         switch (contribution.bindingKind()) {
           case INJECTION:
           case PROVISION:
-          case IMMEDIATE:
-          case FUTURE_PRODUCTION:
+          case PRODUCTION:
             return enclosingClassName
                 .topLevelClassName()
                 .peerClass(
@@ -175,63 +177,12 @@ static ClassName generatedClassNameForBinding(Binding binding) {
     }
   }
 
-  static TypeName parameterizedGeneratedTypeNameForBinding(
-      Binding binding) {
+  static TypeName parameterizedGeneratedTypeNameForBinding(Binding binding) {
     ClassName className = generatedClassNameForBinding(binding);
-    ImmutableList<TypeName> typeParameters = bindingTypeParameters(binding);
-    if (typeParameters.isEmpty()) {
-      return className;
-    } else {
-      return ParameterizedTypeName.get(
-          className,
-          FluentIterable.from(typeParameters).toArray(TypeName.class));
-    }
-  }
-
-  private static Optional<TypeMirror> typeMirrorForBindingTypeParameters(Binding binding)
-      throws AssertionError {
-    switch (binding.bindingType()) {
-      case PROVISION:
-      case PRODUCTION:
-        ContributionBinding contributionBinding = (ContributionBinding) binding;
-        switch (contributionBinding.bindingKind()) {
-          case INJECTION:
-            return Optional.of(contributionBinding.key().type());
-
-          case PROVISION:
-            // For provision bindings, we parameterize creation on the types of
-            // the module, not the types of the binding.
-            // Consider: Module<A, B, C> { @Provides List<B> provideB(B b) { .. }}
-            // The binding is just parameterized on <B>, but we need all of <A, B, C>.
-            return Optional.of(contributionBinding.bindingTypeElement().asType());
-
-          case IMMEDIATE:
-          case FUTURE_PRODUCTION:
-            // TODO(beder): Can these be treated just like PROVISION?
-            throw new UnsupportedOperationException();
-            
-          default:
-            return Optional.absent();
-        }
-
-      case MEMBERS_INJECTION:
-        return Optional.of(binding.key().type());
-
-      default:
-        throw new AssertionError();
-    }
-  }
-
-  static ImmutableList<TypeName> bindingTypeParameters(
-      Binding binding) {
-    Optional<TypeMirror> typeMirror = typeMirrorForBindingTypeParameters(binding);
-    if (!typeMirror.isPresent()) {
-      return ImmutableList.of();
-    }
-    TypeName bindingTypeName = TypeName.get(typeMirror.get());
-    return bindingTypeName instanceof ParameterizedTypeName
-        ? ImmutableList.copyOf(((ParameterizedTypeName) bindingTypeName).typeArguments)
-        : ImmutableList.<TypeName>of();
+    ImmutableList<TypeVariableName> typeParameters = bindingTypeElementTypeVariableNames(binding);
+    return typeParameters.isEmpty()
+        ? className
+        : ParameterizedTypeName.get(className, Iterables.toArray(typeParameters, TypeName.class));
   }
 
   static ClassName membersInjectorNameForType(TypeElement typeElement) {
@@ -264,10 +215,9 @@ private static String factoryPrefix(ContributionBinding binding) {
         return "";
 
       case PROVISION:
-      case IMMEDIATE:
-      case FUTURE_PRODUCTION:
+      case PRODUCTION:
         return CaseFormat.LOWER_CAMEL.to(
-            UPPER_CAMEL, binding.bindingElement().getSimpleName().toString());
+            UPPER_CAMEL, binding.bindingElement().get().getSimpleName().toString());
 
       default:
         throw new IllegalArgumentException();
@@ -275,12 +225,62 @@ private static String factoryPrefix(ContributionBinding binding) {
   }
 
   static ImmutableList<TypeVariableName> bindingTypeElementTypeVariableNames(Binding binding) {
+    if (binding instanceof ContributionBinding) {
+      ContributionBinding contributionBinding = (ContributionBinding) binding;
+      if (!contributionBinding.bindingKind().equals(INJECTION)
+          && !contributionBinding.requiresModuleInstance()) {
+        return ImmutableList.of();
+      }
+    }
     ImmutableList.Builder<TypeVariableName> builder = ImmutableList.builder();
-    for (TypeParameterElement typeParameter : binding.bindingTypeElement().getTypeParameters()) {
+    for (TypeParameterElement typeParameter :
+        binding.bindingTypeElement().get().getTypeParameters()) {
       builder.add(TypeVariableName.get(typeParameter));
     }
     return builder.build();
   }
 
+  /**
+   * Returns a name to be used for variables of the given {@linkplain TypeElement type}. Prefer
+   * semantically meaningful variable names, but if none can be derived, this will produce something
+   * readable.
+   */
+  // TODO(gak): maybe this should be a function of TypeMirrors instead of Elements?
+  static String simpleVariableName(TypeElement typeElement) {
+    String candidateName = UPPER_CAMEL.to(LOWER_CAMEL, typeElement.getSimpleName().toString());
+    String variableName = protectAgainstKeywords(candidateName);
+    verify(isName(variableName), "'%s' was expected to be a valid variable name");
+    return variableName;
+  }
+
+  private static String protectAgainstKeywords(String candidateName) {
+    switch (candidateName) {
+      case "package":
+        return "pkg";
+      case "boolean":
+        return "b";
+      case "double":
+        return "d";
+      case "byte":
+        return "b";
+      case "int":
+        return "i";
+      case "short":
+        return "s";
+      case "char":
+        return "c";
+      case "void":
+        return "v";
+      case "class":
+        return "clazz";
+      case "float":
+        return "f";
+      case "long":
+        return "l";
+      default:
+        return SourceVersion.isKeyword(candidateName) ? candidateName + '_' : candidateName;
+    }
+  }
+
   private SourceFiles() {}
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/SubcomponentDeclaration.java b/compiler/src/main/java/dagger/internal/codegen/SubcomponentDeclaration.java
new file mode 100644
index 000000000..6de7c5956
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/SubcomponentDeclaration.java
@@ -0,0 +1,82 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.auto.common.AnnotationMirrors.getAnnotationElementAndValue;
+import static dagger.internal.codegen.ConfigurationAnnotations.getModuleAnnotation;
+import static dagger.internal.codegen.ConfigurationAnnotations.getModuleSubcomponents;
+import static dagger.internal.codegen.ConfigurationAnnotations.getSubcomponentBuilder;
+
+import com.google.auto.common.MoreTypes;
+import com.google.auto.value.AutoValue;
+import com.google.common.collect.ImmutableSet;
+import java.util.Optional;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
+
+/**
+ * A declaration for a subcomponent that is included in a module via {@link
+ * dagger.Module#subcomponents()}.
+ */
+@AutoValue
+abstract class SubcomponentDeclaration extends BindingDeclaration {
+  /**
+   * Key for the {@link dagger.Subcomponent.Builder} or {@link
+   * dagger.producers.ProductionSubcomponent.Builder} of {@link #subcomponentType()}.
+   */
+  @Override
+  public abstract Key key();
+
+  @Override
+  abstract Optional<? extends ExecutableElement> bindingElement();
+
+  /**
+   * The type element that defines the {@link dagger.Subcomponent} or {@link
+   * dagger.producers.ProductionSubcomponent} for this declaration.
+   */
+  abstract TypeElement subcomponentType();
+
+  abstract AnnotationMirror moduleAnnotation();
+
+  static class Factory {
+    private final Key.Factory keyFactory;
+
+    public Factory(Key.Factory keyFactory) {
+      this.keyFactory = keyFactory;
+    }
+
+    ImmutableSet<SubcomponentDeclaration> forModule(TypeElement module) {
+      ImmutableSet.Builder<SubcomponentDeclaration> declarations = ImmutableSet.builder();
+      AnnotationMirror moduleAnnotation = getModuleAnnotation(module).get();
+      ExecutableElement subcomponentAttribute =
+          getAnnotationElementAndValue(moduleAnnotation, "subcomponents").getKey();
+      for (TypeElement subcomponent :
+          MoreTypes.asTypeElements(getModuleSubcomponents(moduleAnnotation))) {
+        declarations.add(
+            new AutoValue_SubcomponentDeclaration(
+                Optional.of(module),
+                keyFactory.forSubcomponentBuilder(
+                    getSubcomponentBuilder(subcomponent).get().asType()),
+                Optional.of(subcomponentAttribute),
+                subcomponent,
+                moduleAnnotation));
+      }
+      return declarations.build();
+    }
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/SubcomponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/SubcomponentWriter.java
index af327aa82..8f143819c 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SubcomponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SubcomponentWriter.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,11 +13,25 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal.codegen;
 
+import static com.google.common.base.CaseFormat.LOWER_CAMEL;
+import static com.google.common.base.Preconditions.checkState;
+import static com.google.common.base.Verify.verify;
+import static com.google.common.collect.Sets.difference;
+import static com.squareup.javapoet.MethodSpec.methodBuilder;
+import static com.squareup.javapoet.TypeSpec.classBuilder;
+import static dagger.internal.codegen.AbstractComponentWriter.InitializationState.UNINITIALIZED;
+import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
+import static dagger.internal.codegen.MemberSelect.localField;
+import static dagger.internal.codegen.TypeSpecs.addSupertype;
+import static javax.lang.model.element.Modifier.FINAL;
+import static javax.lang.model.element.Modifier.PRIVATE;
+import static javax.lang.model.element.Modifier.PUBLIC;
+
 import com.google.auto.common.MoreTypes;
 import com.google.common.base.CaseFormat;
-import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableList;
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
@@ -26,48 +40,33 @@
 import com.squareup.javapoet.TypeName;
 import com.squareup.javapoet.TypeSpec;
 import dagger.internal.Preconditions;
-import dagger.internal.codegen.ComponentDescriptor.BuilderSpec;
+import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
 import java.util.List;
+import java.util.Optional;
 import java.util.Set;
-import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.ExecutableType;
 import javax.lang.model.type.TypeMirror;
 
-import static com.google.common.base.CaseFormat.LOWER_CAMEL;
-import static com.google.common.base.Verify.verify;
-import static com.google.common.collect.Sets.difference;
-import static com.squareup.javapoet.MethodSpec.methodBuilder;
-import static com.squareup.javapoet.TypeSpec.classBuilder;
-import static dagger.internal.codegen.AbstractComponentWriter.InitializationState.UNINITIALIZED;
-import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
-import static dagger.internal.codegen.MemberSelect.localField;
-import static dagger.internal.codegen.TypeSpecs.addSupertype;
-import static javax.lang.model.element.Modifier.FINAL;
-import static javax.lang.model.element.Modifier.PRIVATE;
-import static javax.lang.model.element.Modifier.PUBLIC;
-
 /**
  * Creates the nested implementation class for a subcomponent.
  */
 final class SubcomponentWriter extends AbstractComponentWriter {
 
-  private AbstractComponentWriter parent;
-  private ExecutableElement subcomponentFactoryMethod;
+  private final AbstractComponentWriter parent;
 
-  public SubcomponentWriter(
+  /**
+   * The parent's factory method to create this subcomponent, or {@link Optional#empty()} if the
+   * subcomponent was added via {@link dagger.Module#subcomponents()}.
+   */
+  private final Optional<ComponentMethodDescriptor> subcomponentFactoryMethod;
+
+  SubcomponentWriter(
       AbstractComponentWriter parent,
-      ExecutableElement subcomponentFactoryMethod,
+      Optional<ComponentMethodDescriptor> subcomponentFactoryMethod,
       BindingGraph subgraph) {
-    super(
-        parent.types,
-        parent.elements,
-        parent.keyFactory,
-        parent.compilerOptions,
-        subcomponentName(parent, subgraph),
-        subgraph,
-        parent.subcomponentNames);
+    super(parent, subcomponentName(parent, subgraph), subgraph);
     this.parent = parent;
     this.subcomponentFactoryMethod = subcomponentFactoryMethod;
   }
@@ -86,36 +85,47 @@ protected InitializationState getInitializationState(BindingKey bindingKey) {
   }
 
   @Override
-  protected Optional<CodeBlock> getOrCreateComponentContributionFieldExpression(
-      TypeElement contributionType) {
-    return super.getOrCreateComponentContributionFieldExpression(contributionType)
-        .or(parent.getOrCreateComponentContributionFieldExpression(contributionType));
+  protected Optional<CodeBlock> getOrCreateComponentRequirementFieldExpression(
+      ComponentRequirement componentRequirement) {
+    Optional<CodeBlock> expression =
+        super.getOrCreateComponentRequirementFieldExpression(componentRequirement);
+    return expression.isPresent()
+        ? expression
+        : parent.getOrCreateComponentRequirementFieldExpression(componentRequirement);
   }
 
   @Override
-  protected MemberSelect getMemberSelect(BindingKey key) {
+  public MemberSelect getMemberSelect(BindingKey key) {
     MemberSelect memberSelect = super.getMemberSelect(key);
     return memberSelect == null ? parent.getMemberSelect(key) : memberSelect;
   }
 
+  @Override
+  protected CodeBlock getReferenceReleasingProviderManagerExpression(Scope scope) {
+    return parent.getReferenceReleasingProviderManagerExpression(scope);
+  }
+
   private ExecutableType resolvedSubcomponentFactoryMethod() {
+    checkState(
+        subcomponentFactoryMethod.isPresent(),
+        "%s does not have a factory method for %s",
+        parent.graph.componentType(),
+        graph.componentType());
     return MoreTypes.asExecutable(
         types.asMemberOf(
-            MoreTypes.asDeclared(parent.componentDefinitionType().asType()),
-            subcomponentFactoryMethod));
+            MoreTypes.asDeclared(parent.graph.componentType().asType()),
+            subcomponentFactoryMethod.get().methodElement()));
   }
 
   @Override
-  protected TypeSpec.Builder createComponentClass() {
-    TypeSpec.Builder subcomponent = classBuilder(name).addModifiers(PRIVATE, FINAL);
-
+  protected void decorateComponent() {
+    component.addModifiers(PRIVATE, FINAL);
     addSupertype(
-        subcomponent,
+        component,
         MoreTypes.asTypeElement(
             graph.componentDescriptor().builderSpec().isPresent()
                 ? graph.componentDescriptor().builderSpec().get().componentType()
                 : resolvedSubcomponentFactoryMethod().getReturnType()));
-    return subcomponent;
   }
 
   @Override
@@ -145,34 +155,36 @@ protected void addBuilderClass(TypeSpec builder) {
 
   @Override
   protected void addFactoryMethods() {
+    if (!subcomponentFactoryMethod.isPresent()
+        || !subcomponentFactoryMethod.get().kind().isSubcomponentKind()) {
+      // subcomponent builder methods are implemented in
+      // AbstractComponentWriter.implementInterfaceMethods
+      return;
+    }
     MethodSpec.Builder componentMethod =
-        methodBuilder(subcomponentFactoryMethod.getSimpleName().toString())
+        methodBuilder(subcomponentFactoryMethod.get().methodElement().getSimpleName().toString())
             .addModifiers(PUBLIC)
             .addAnnotation(Override.class);
-    if (graph.componentDescriptor().builderSpec().isPresent()) {
-      BuilderSpec spec = graph.componentDescriptor().builderSpec().get();
-      componentMethod
-          .returns(ClassName.get(spec.builderDefinitionType()))
-          .addStatement("return new $T()", builderName.get());
-    } else {
-      ExecutableType resolvedMethod = resolvedSubcomponentFactoryMethod();
-      componentMethod.returns(ClassName.get(resolvedMethod.getReturnType()));
-      writeSubcomponentWithoutBuilder(componentMethod, resolvedMethod);
-    }
+    ExecutableType resolvedMethod = resolvedSubcomponentFactoryMethod();
+    componentMethod.returns(ClassName.get(resolvedMethod.getReturnType()));
+    writeSubcomponentWithoutBuilder(componentMethod, resolvedMethod);
     parent.component.addMethod(componentMethod.build());
   }
 
   private void writeSubcomponentWithoutBuilder(
       MethodSpec.Builder componentMethod, ExecutableType resolvedMethod) {
     ImmutableList.Builder<CodeBlock> subcomponentConstructorParameters = ImmutableList.builder();
-    List<? extends VariableElement> params = subcomponentFactoryMethod.getParameters();
+    List<? extends VariableElement> params =
+        subcomponentFactoryMethod.get().methodElement().getParameters();
     List<? extends TypeMirror> paramTypes = resolvedMethod.getParameterTypes();
     for (int i = 0; i < params.size(); i++) {
       VariableElement moduleVariable = params.get(i);
       TypeElement moduleTypeElement = MoreTypes.asTypeElement(paramTypes.get(i));
+      ComponentRequirement componentRequirement =
+          ComponentRequirement.forModule(moduleTypeElement.asType());
       TypeName moduleType = TypeName.get(paramTypes.get(i));
       componentMethod.addParameter(moduleType, moduleVariable.getSimpleName().toString());
-      if (!componentContributionFields.containsKey(moduleTypeElement)) {
+      if (!componentContributionFields.containsKey(componentRequirement)) {
         String preferredModuleName =
             CaseFormat.UPPER_CAMEL.to(LOWER_CAMEL, moduleTypeElement.getSimpleName().toString());
         FieldSpec contributionField =
@@ -190,16 +202,18 @@ private void writeSubcomponentWithoutBuilder(
                 Preconditions.class);
 
         MemberSelect moduleSelect = localField(name, actualModuleName);
-        componentContributionFields.put(moduleTypeElement, moduleSelect);
+        componentContributionFields.put(componentRequirement, moduleSelect);
         subcomponentConstructorParameters.add(
             CodeBlock.of("$L", moduleVariable.getSimpleName()));
       }
     }
 
-    Set<TypeElement> uninitializedModules =
+    Set<ComponentRequirement> uninitializedModules =
         difference(graph.componentRequirements(), componentContributionFields.keySet());
 
-    for (TypeElement moduleType : uninitializedModules) {
+    for (ComponentRequirement componentRequirement : uninitializedModules) {
+      checkState(componentRequirement.kind().equals(ComponentRequirement.Kind.MODULE));
+      TypeElement moduleType = componentRequirement.typeElement();
       String preferredModuleName =
           CaseFormat.UPPER_CAMEL.to(LOWER_CAMEL, moduleType.getSimpleName().toString());
       FieldSpec contributionField =
@@ -211,7 +225,7 @@ private void writeSubcomponentWithoutBuilder(
       constructor.addStatement(
           "this.$L = new $T()", actualModuleName, ClassName.get(moduleType));
       MemberSelect moduleSelect = localField(name, actualModuleName);
-      componentContributionFields.put(moduleType, moduleSelect);
+      componentContributionFields.put(componentRequirement, moduleSelect);
     }
 
     componentMethod.addStatement("return new $T($L)",
diff --git a/compiler/src/main/java/dagger/internal/codegen/TypeNames.java b/compiler/src/main/java/dagger/internal/codegen/TypeNames.java
index 1b7903c22..771652657 100644
--- a/compiler/src/main/java/dagger/internal/codegen/TypeNames.java
+++ b/compiler/src/main/java/dagger/internal/codegen/TypeNames.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 Google, Inc.
+ * Copyright (C) 2016 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal.codegen;
 
 import com.google.common.util.concurrent.AsyncFunction;
@@ -21,6 +22,7 @@
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.ParameterizedTypeName;
 import com.squareup.javapoet.TypeName;
+import dagger.Lazy;
 import dagger.MembersInjector;
 import dagger.internal.DelegateFactory;
 import dagger.internal.DoubleCheck;
@@ -30,8 +32,11 @@
 import dagger.internal.MapProviderFactory;
 import dagger.internal.MembersInjectors;
 import dagger.internal.ProviderOfLazy;
+import dagger.internal.ReferenceReleasingProvider;
+import dagger.internal.ReferenceReleasingProviderManager;
 import dagger.internal.SetFactory;
 import dagger.internal.SingleCheck;
+import dagger.internal.TypedReleasableReferenceManagerDecorator;
 import dagger.producers.Produced;
 import dagger.producers.Producer;
 import dagger.producers.internal.AbstractProducer;
@@ -43,8 +48,12 @@
 import dagger.producers.internal.SetProducer;
 import dagger.producers.monitoring.ProducerToken;
 import dagger.producers.monitoring.ProductionComponentMonitor;
+import dagger.releasablereferences.ReleasableReferenceManager;
+import dagger.releasablereferences.TypedReleasableReferenceManager;
 import java.util.List;
+import java.util.Optional;
 import java.util.Set;
+import java.util.concurrent.Executor;
 import javax.inject.Provider;
 
 /**
@@ -56,10 +65,12 @@
   static final ClassName ASYNC_FUNCTION = ClassName.get(AsyncFunction.class);
   static final ClassName DELEGATE_FACTORY = ClassName.get(DelegateFactory.class);
   static final ClassName DOUBLE_CHECK = ClassName.get(DoubleCheck.class);
+  static final ClassName EXECUTOR = ClassName.get(Executor.class);
   static final ClassName FACTORY = ClassName.get(Factory.class);
   static final ClassName FUTURES = ClassName.get(Futures.class);
   static final ClassName ILLEGAL_STATE_EXCEPTION = ClassName.get(IllegalStateException.class);
   static final ClassName INSTANCE_FACTORY = ClassName.get(InstanceFactory.class);
+  static final ClassName LAZY = ClassName.get(Lazy.class);
   static final ClassName LIST = ClassName.get(List.class);
   static final ClassName LISTENABLE_FUTURE = ClassName.get(ListenableFuture.class);
   static final ClassName MAP_FACTORY = ClassName.get(MapFactory.class);
@@ -69,18 +80,33 @@
   static final ClassName MAP_PROVIDER_FACTORY = ClassName.get(MapProviderFactory.class);
   static final ClassName MEMBERS_INJECTOR = ClassName.get(MembersInjector.class);
   static final ClassName MEMBERS_INJECTORS = ClassName.get(MembersInjectors.class);
+  static final ClassName OPTIONAL = ClassName.get(Optional.class);
   static final ClassName PRODUCER_TOKEN = ClassName.get(ProducerToken.class);
   static final ClassName PRODUCED = ClassName.get(Produced.class);
   static final ClassName PRODUCER = ClassName.get(Producer.class);
   static final ClassName PRODUCERS = ClassName.get(Producers.class);
+  static final ClassName PRODUCTION_COMPONENT_MONITOR_FACTORY =
+      ClassName.get(ProductionComponentMonitor.Factory.class);
   static final ClassName PROVIDER = ClassName.get(Provider.class);
   static final ClassName PROVIDER_OF_LAZY = ClassName.get(ProviderOfLazy.class);
+  static final ClassName RUNNABLE = ClassName.get(Runnable.class);
+  static final ClassName REFERENCE_RELEASING_PROVIDER =
+      ClassName.get(ReferenceReleasingProvider.class);
+  static final ClassName REFERENCE_RELEASING_PROVIDER_MANAGER =
+      ClassName.get(ReferenceReleasingProviderManager.class);
+  static final ClassName RELEASABLE_REFERENCE_MANAGER =
+      ClassName.get(ReleasableReferenceManager.class);
   static final ClassName SET = ClassName.get(Set.class);
   static final ClassName SET_FACTORY = ClassName.get(SetFactory.class);
   static final ClassName SET_OF_PRODUCED_PRODUCER = ClassName.get(SetOfProducedProducer.class);
   static final ClassName SET_PRODUCER = ClassName.get(SetProducer.class);
   static final ClassName SINGLE_CHECK = ClassName.get(SingleCheck.class);
   static final ClassName STRING = ClassName.get(String.class);
+  static final ClassName TYPED_RELEASABLE_REFERENCE_MANAGER =
+      ClassName.get(TypedReleasableReferenceManager.class);
+  static final ClassName TYPED_RELEASABLE_REFERENCE_MANAGER_DECORATOR =
+      ClassName.get(TypedReleasableReferenceManagerDecorator.class);
+
   static final ClassName UNSUPPORTED_OPERATION_EXCEPTION =
       ClassName.get(UnsupportedOperationException.class);
 
@@ -90,36 +116,58 @@
    */
   static final ClassName VOID_CLASS = ClassName.get(Void.class);
 
-  static final TypeName SET_OF_FACTORIES =
-      ParameterizedTypeName.get(
-          ClassName.get(Set.class), ClassName.get(ProductionComponentMonitor.Factory.class));
+  static ParameterizedTypeName abstractProducerOf(TypeName typeName) {
+    return ParameterizedTypeName.get(ABSTRACT_PRODUCER, typeName);
+  }
+
+  static ParameterizedTypeName factoryOf(TypeName factoryType) {
+    return ParameterizedTypeName.get(FACTORY, factoryType);
+  }
+
+  static ParameterizedTypeName lazyOf(TypeName typeName) {
+    return ParameterizedTypeName.get(LAZY, typeName);
+  }
 
   static ParameterizedTypeName listOf(TypeName typeName) {
     return ParameterizedTypeName.get(LIST, typeName);
   }
 
-  static ParameterizedTypeName abstractProducerOf(TypeName typeName) {
-    return ParameterizedTypeName.get(ABSTRACT_PRODUCER, typeName);
+  static ParameterizedTypeName listenableFutureOf(TypeName typeName) {
+    return ParameterizedTypeName.get(LISTENABLE_FUTURE, typeName);
+  }
+
+  static ParameterizedTypeName membersInjectorOf(TypeName membersInjectorType) {
+    return ParameterizedTypeName.get(MEMBERS_INJECTOR, membersInjectorType);
+  }
+
+  static ParameterizedTypeName optionalOf(TypeName type) {
+    return ParameterizedTypeName.get(OPTIONAL, type);
   }
 
   static ParameterizedTypeName producedOf(TypeName typeName) {
     return ParameterizedTypeName.get(PRODUCED, typeName);
   }
 
-  static ParameterizedTypeName listenableFutureOf(TypeName typeName) {
-    return ParameterizedTypeName.get(LISTENABLE_FUTURE, typeName);
+  static ParameterizedTypeName producerOf(TypeName typeName) {
+    return ParameterizedTypeName.get(PRODUCER, typeName);
   }
 
   static ParameterizedTypeName providerOf(TypeName typeName) {
     return ParameterizedTypeName.get(PROVIDER, typeName);
   }
 
-  static ParameterizedTypeName membersInjectorOf(TypeName membersInjectorType) {
-    return ParameterizedTypeName.get(MEMBERS_INJECTOR, membersInjectorType);
+  static ParameterizedTypeName setOf(TypeName elementType) {
+    return ParameterizedTypeName.get(SET, elementType);
   }
 
-  static ParameterizedTypeName factoryOf(TypeName factoryType) {
-    return ParameterizedTypeName.get(FACTORY, factoryType);
+  /**
+   * Returns the {@link TypeName} for the raw type of the given type name. If the argument isn't a
+   * parameterized type, it returns the argument unchanged.
+   */
+  static TypeName rawTypeName(TypeName typeName) {
+    return (typeName instanceof ParameterizedTypeName)
+        ? ((ParameterizedTypeName) typeName).rawType
+        : typeName;
   }
 
   private TypeNames() {}
diff --git a/compiler/src/main/java/dagger/internal/codegen/TypeSpecs.java b/compiler/src/main/java/dagger/internal/codegen/TypeSpecs.java
index 325436140..92f1a3aed 100644
--- a/compiler/src/main/java/dagger/internal/codegen/TypeSpecs.java
+++ b/compiler/src/main/java/dagger/internal/codegen/TypeSpecs.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 Google, Inc.
+ * Copyright (C) 2016 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,8 +13,10 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal.codegen;
 
+import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.TypeSpec;
 import javax.lang.model.element.TypeElement;
@@ -27,15 +29,16 @@
   /**
    * If {@code supertype} is a class, adds it as a superclass for {@code typeBuilder}; if it is an
    * interface, adds it as a superinterface.
+   *
+   * @return {@code typeBuilder}
    */
-  static void addSupertype(TypeSpec.Builder typeBuilder, TypeElement supertype) {
+  @CanIgnoreReturnValue
+  static TypeSpec.Builder addSupertype(TypeSpec.Builder typeBuilder, TypeElement supertype) {
     switch (supertype.getKind()) {
       case CLASS:
-        typeBuilder.superclass(ClassName.get(supertype));
-        break;
+        return typeBuilder.superclass(ClassName.get(supertype));
       case INTERFACE:
-        typeBuilder.addSuperinterface(ClassName.get(supertype));
-        break;
+        return typeBuilder.addSuperinterface(ClassName.get(supertype));
       default:
         throw new AssertionError(supertype + " is neither a class nor an interface.");
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/UniqueNameSet.java b/compiler/src/main/java/dagger/internal/codegen/UniqueNameSet.java
index b63b203e7..27a275ceb 100644
--- a/compiler/src/main/java/dagger/internal/codegen/UniqueNameSet.java
+++ b/compiler/src/main/java/dagger/internal/codegen/UniqueNameSet.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 Google, Inc.
+ * Copyright (C) 2016 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal.codegen;
 
 import java.util.HashSet;
diff --git a/compiler/src/main/java/dagger/internal/codegen/UnwrappedMapKeyGenerator.java b/compiler/src/main/java/dagger/internal/codegen/UnwrappedMapKeyGenerator.java
new file mode 100644
index 000000000..86f8d84b9
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/UnwrappedMapKeyGenerator.java
@@ -0,0 +1,66 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import dagger.MapKey;
+import java.util.Set;
+import javax.annotation.processing.Filer;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.util.Elements;
+
+/**
+ * Generates classes that create annotation instances for an unwrapped {@link MapKey} annotation
+ * type whose nested value is an annotation. The generated class will have a private empty
+ * constructor and a static method that creates each annotation type that is nested in the top-level
+ * annotation type.
+ *
+ * <p>So for an example {@link MapKey} annotation:
+ *
+ * <pre>
+ *   {@literal @MapKey}(unwrapValue = true)
+ *   {@literal @interface} Foo {
+ *     Bar bar();
+ *   }
+ *
+ *   {@literal @interface} Bar {
+ *     {@literal Class<?> baz();}
+ *   }
+ * </pre>
+ *
+ * the generated class will look like:
+ *
+ * <pre>
+ *   public final class FooCreator {
+ *     private FooCreator() {}
+ *
+ *     public static Bar createBar({@literal Class<?> baz}) { … }
+ *   }
+ * </pre>
+ */
+final class UnwrappedMapKeyGenerator extends AnnotationCreatorGenerator {
+
+  UnwrappedMapKeyGenerator(Filer filer, Elements elements) {
+    super(filer, elements);
+  }
+
+  @Override
+  protected Set<TypeElement> annotationsToCreate(TypeElement annotationElement) {
+    Set<TypeElement> nestedAnnotationElements = super.annotationsToCreate(annotationElement);
+    nestedAnnotationElements.remove(annotationElement);
+    return nestedAnnotationElements;
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/Util.java b/compiler/src/main/java/dagger/internal/codegen/Util.java
index d93fae3d9..0c6046e37 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Util.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Util.java
@@ -1,6 +1,5 @@
 /*
- * Copyright (C) 2013 Google, Inc.
- * Copyright (C) 2013 Square, Inc.
+ * Copyright (C) 2013 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,34 +13,30 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal.codegen;
 
+import static com.google.auto.common.MoreElements.getLocalAndInheritedMethods;
+import static dagger.internal.codegen.DaggerElements.isAnyAnnotationPresent;
+import static java.util.stream.Collectors.collectingAndThen;
+import static java.util.stream.Collectors.toList;
+import static javax.lang.model.element.ElementKind.CONSTRUCTOR;
+import static javax.lang.model.element.Modifier.ABSTRACT;
+import static javax.lang.model.element.Modifier.PRIVATE;
+import static javax.lang.model.element.Modifier.STATIC;
+
 import com.google.auto.common.MoreElements;
-import com.google.auto.common.MoreTypes;
-import com.google.common.base.Function;
-import com.google.common.base.Predicate;
-import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import dagger.Binds;
 import dagger.Provides;
 import dagger.producers.Produces;
-import java.lang.annotation.Annotation;
-import javax.lang.model.element.AnnotationMirror;
+import java.util.stream.Collector;
 import javax.lang.model.element.Element;
-import javax.lang.model.element.ElementVisitor;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
-import javax.lang.model.type.DeclaredType;
 import javax.lang.model.util.Elements;
-import javax.lang.model.util.SimpleElementVisitor6;
-
-import static com.google.auto.common.MoreElements.getLocalAndInheritedMethods;
-import static com.google.auto.common.MoreElements.hasModifiers;
-import static com.google.auto.common.MoreElements.isAnnotationPresent;
-import static javax.lang.model.element.ElementKind.CONSTRUCTOR;
-import static javax.lang.model.element.Modifier.ABSTRACT;
-import static javax.lang.model.element.Modifier.PRIVATE;
-import static javax.lang.model.element.Modifier.STATIC;
+import javax.lang.model.util.Types;
 
 /**
  * Utilities for handling types in annotation processors
@@ -51,18 +46,18 @@
    * Returns true if the passed {@link TypeElement} requires a passed instance in order to be used
    * within a component.
    */
-  static boolean requiresAPassedInstance(Elements elements, TypeElement typeElement) {
+  static boolean requiresAPassedInstance(Elements elements, Types types, TypeElement typeElement) {
     ImmutableSet<ExecutableElement> methods =
-        MoreElements.getLocalAndInheritedMethods(typeElement, elements);
+        getLocalAndInheritedMethods(typeElement, types, elements);
     boolean foundInstanceMethod = false;
     for (ExecutableElement method : methods) {
-      if (method.getModifiers().contains(ABSTRACT) && !isAnnotationPresent(method, Binds.class)) {
+      if (method.getModifiers().contains(ABSTRACT)
+          && !MoreElements.isAnnotationPresent(method, Binds.class)) {
         /* We found an abstract method that isn't a @Binds method.  That automatically means that
          * a user will have to provide an instance because we don't know which subclass to use. */
         return true;
       } else if (!method.getModifiers().contains(STATIC)
-          && (isAnnotationPresent(method, Provides.class)
-              || isAnnotationPresent(method, Produces.class))) {
+          && isAnyAnnotationPresent(method, Provides.class, Produces.class)) {
         foundInstanceMethod = true;
       }
     }
@@ -126,81 +121,20 @@ private static boolean requiresEnclosingInstance(TypeElement typeElement) {
     }
   }
 
-  static ImmutableSet<ExecutableElement> getUnimplementedMethods(
-      Elements elements, TypeElement type) {
-    return FluentIterable.from(getLocalAndInheritedMethods(type, elements))
-        .filter(hasModifiers(ABSTRACT))
-        .toSet();
-  }
-
-  // TODO(ronshapiro): add into auto/common/AnnotationMirrors.java
-  static Predicate<AnnotationMirror> hasAnnotationType(
-      final Class<? extends Annotation> annotation) {
-    return new Predicate<AnnotationMirror>() {
-      @Override
-      public boolean apply(AnnotationMirror input) {
-        return MoreTypes.isTypeOf(annotation, input.getAnnotationType());
-      }
-    };
-  }
-
-  /** A function that returns the input as a {@link DeclaredType}. */
-  static final Function<TypeElement, DeclaredType> AS_DECLARED_TYPE =
-      new Function<TypeElement, DeclaredType>() {
-        @Override
-        public DeclaredType apply(TypeElement typeElement) {
-          return MoreTypes.asDeclared(typeElement.asType());
-        }
-      };
-
   /**
-   * A visitor that returns the input or the closest enclosing element that is a
-   * {@link TypeElement}.
+   * Returns a {@link Collector} that accumulates the input elements into a new {@link
+   * ImmutableList}, in encounter order.
    */
-  static final ElementVisitor<TypeElement, Void> ENCLOSING_TYPE_ELEMENT =
-      new SimpleElementVisitor6<TypeElement, Void>() {
-        @Override
-        protected TypeElement defaultAction(Element e, Void p) {
-          return visit(e.getEnclosingElement());
-        }
-
-        @Override
-        public TypeElement visitType(TypeElement e, Void p) {
-          return e;
-        }
-      };
-
-      
-  /**
-   * Returns {@code true} iff the given element has an {@link AnnotationMirror} whose
-   * {@linkplain AnnotationMirror#getAnnotationType() annotation type} has the same canonical name
-   * as any of that of {@code annotationClasses}.
-   */
-  // TODO(dpb): Move to MoreElements.
-  static boolean isAnyAnnotationPresent(
-      Element element, Iterable<? extends Class<? extends Annotation>> annotationClasses) {
-    for (Class<? extends Annotation> annotation : annotationClasses) {
-      if (isAnnotationPresent(element, annotation)) {
-        return true;
-      }
-    }
-    return false;
+  static <T> Collector<T, ?, ImmutableList<T>> toImmutableList() {
+    return collectingAndThen(toList(), ImmutableList::copyOf);
   }
 
   /**
-   * The elements in {@code elements} that are annotated with an annotation of type
-   * {@code annotation}.
+   * Returns a {@link Collector} that accumulates the input elements into a new {@link
+   * ImmutableSet}, in encounter order.
    */
-  static <E extends Element> FluentIterable<E> elementsWithAnnotation(
-      Iterable<E> elements, final Class<? extends Annotation> annotation) {
-    return FluentIterable.from(elements)
-        .filter(
-            new Predicate<Element>() {
-              @Override
-              public boolean apply(Element element) {
-                return MoreElements.isAnnotationPresent(element, annotation);
-              }
-            });
+  static <T> Collector<T, ?, ImmutableSet<T>> toImmutableSet() {
+    return collectingAndThen(toList(), ImmutableSet::copyOf);
   }
 
   private Util() {}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ValidationReport.java b/compiler/src/main/java/dagger/internal/codegen/ValidationReport.java
index 97f47ecfd..1a26c6a3f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ValidationReport.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ValidationReport.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Google, Inc.
+ * Copyright (C) 2014 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,48 +13,44 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal.codegen;
 
+import static javax.tools.Diagnostic.Kind.ERROR;
+import static javax.tools.Diagnostic.Kind.NOTE;
+import static javax.tools.Diagnostic.Kind.WARNING;
+
 import com.google.auto.value.AutoValue;
-import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableSet;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
+import java.util.Optional;
 import javax.annotation.CheckReturnValue;
 import javax.annotation.processing.Messager;
 import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.AnnotationValue;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.util.SimpleElementVisitor6;
 import javax.tools.Diagnostic;
 import javax.tools.Diagnostic.Kind;
 
-import static javax.tools.Diagnostic.Kind.ERROR;
-import static javax.tools.Diagnostic.Kind.NOTE;
-import static javax.tools.Diagnostic.Kind.WARNING;
-
-/**
- * A collection of items describing contractual issues with the code as presented to an annotation
- * processor.  A "clean" report (i.e. with no issues) is a report with no {@linkplain Item items}
- * and clean subreports. Callers will typically print the results of the report to a
- * {@link Messager} instance using {@link #printMessagesTo}.
- *
- * <p>A report describes a subject {@link Element}.  Callers may choose to add report items about
- * other elements that are contained within or related to the subject. Since {@link Diagnostic}
- * reporting is expected to be associated with elements that are currently being compiled,
- * {@link #printMessagesTo(Messager)} will only associate messages with non-subject elements if they
- * are contained within the subject. Otherwise, they will be associated with the subject and contain
- * a reference to the item's element in the message string. It is the responsibility of the caller
- * to choose subjects that are part of the compilation.
- *
- * @author Gregory Kick
- * @since 2.0
- */
+/** A collection of issues to report for source code. */
 @AutoValue
 abstract class ValidationReport<T extends Element> {
+
+  /**
+   * The subject of the report. Should be an element within a compilation unit being processed by
+   * this compilation task.
+   */
   abstract T subject();
+
+  /** The items to report for the {@linkplain #subject() subject}. */
   abstract ImmutableSet<Item> items();
+
+  /** Other reports associated with this one. */
   abstract ImmutableSet<ValidationReport<?>> subreports();
 
+  /** Returns {@code true} if there are no errors in this report or any subreports. */
   boolean isClean() {
     for (Item item : items()) {
       switch (item.kind()) {
@@ -72,22 +68,35 @@ boolean isClean() {
     return true;
   }
 
+  /**
+   * Prints all {@linkplain #items() messages} to {@code messager} (and recurs for subreports). If a
+   * message's {@linkplain Item#element() element} is contained within the report's {@linkplain
+   * #subject() subject}, associates the message with the message's element. Otherwise, since
+   * {@link Diagnostic} reporting is expected to be associated with elements that are currently
+   * being compiled, associates the message with the subject itself and prepends a reference to the
+   * item's element.
+   */
   void printMessagesTo(Messager messager) {
     for (Item item : items()) {
       if (isEnclosedIn(subject(), item.element())) {
         if (item.annotation().isPresent()) {
-          messager.printMessage(
-              item.kind(), item.message(), item.element(), item.annotation().get());
+          if (item.annotationValue().isPresent()) {
+            messager.printMessage(
+                item.kind(),
+                item.message(),
+                item.element(),
+                item.annotation().get(),
+                item.annotationValue().get());
+          } else {
+            messager.printMessage(
+                item.kind(), item.message(), item.element(), item.annotation().get());
+          }
         } else {
           messager.printMessage(item.kind(), item.message(), item.element());
         }
       } else {
         String message = String.format("[%s] %s", elementString(item.element()), item.message());
-        if (item.annotation().isPresent()) {
-          messager.printMessage(item.kind(), message, subject(), item.annotation().get());
-        } else {
-          messager.printMessage(item.kind(), message, subject());
-        }
+        messager.printMessage(item.kind(), message, subject());
       }
     }
     for (ValidationReport<?> subreport : subreports()) {
@@ -128,10 +137,11 @@ private static boolean isEnclosedIn(Element parent, Element child) {
     abstract Kind kind();
     abstract Element element();
     abstract Optional<AnnotationMirror> annotation();
+    abstract Optional<AnnotationValue> annotationValue();
   }
 
   static <T extends Element> Builder<T> about(T subject) {
-    return new Builder<T>(subject);
+    return new Builder<>(subject);
   }
 
   @CanIgnoreReturnValue
@@ -155,52 +165,90 @@ T getSubject() {
     }
 
     Builder<T> addError(String message) {
-      return addItem(message, ERROR, subject, Optional.<AnnotationMirror>absent());
+      return addError(message, subject);
     }
 
     Builder<T> addError(String message, Element element) {
-      return addItem(message, ERROR, element, Optional.<AnnotationMirror>absent());
+      return addItem(message, ERROR, element);
     }
 
     Builder<T> addError(String message, Element element, AnnotationMirror annotation) {
-      return addItem(message, ERROR, element, Optional.of(annotation));
+      return addItem(message, ERROR, element, annotation);
+    }
+
+    Builder<T> addError(
+        String message,
+        Element element,
+        AnnotationMirror annotation,
+        AnnotationValue annotationValue) {
+      return addItem(message, ERROR, element, annotation, annotationValue);
     }
 
     Builder<T> addWarning(String message) {
-      return addItem(message, WARNING, subject, Optional.<AnnotationMirror>absent());
+      return addWarning(message, subject);
     }
 
     Builder<T> addWarning(String message, Element element) {
-      return addItem(message, WARNING, element, Optional.<AnnotationMirror>absent());
+      return addItem(message, WARNING, element);
     }
 
     Builder<T> addWarning(String message, Element element, AnnotationMirror annotation) {
-      return addItem(message, WARNING, element, Optional.of(annotation));
+      return addItem(message, WARNING, element, annotation);
+    }
+
+    Builder<T> addWarning(
+        String message,
+        Element element,
+        AnnotationMirror annotation,
+        AnnotationValue annotationValue) {
+      return addItem(message, WARNING, element, annotation, annotationValue);
     }
 
     Builder<T> addNote(String message) {
-      return addItem(message, NOTE, subject, Optional.<AnnotationMirror>absent());
+      return addNote(message, subject);
     }
 
     Builder<T> addNote(String message, Element element) {
-      return addItem(message, NOTE, element, Optional.<AnnotationMirror>absent());
+      return addItem(message, NOTE, element);
     }
 
     Builder<T> addNote(String message, Element element, AnnotationMirror annotation) {
-      return addItem(message, NOTE, element, Optional.of(annotation));
+      return addItem(message, NOTE, element, annotation);
+    }
+
+    Builder<T> addNote(
+        String message,
+        Element element,
+        AnnotationMirror annotation,
+        AnnotationValue annotationValue) {
+      return addItem(message, NOTE, element, annotation, annotationValue);
     }
 
     Builder<T> addItem(String message, Kind kind, Element element) {
-      return addItem(message, kind, element, Optional.<AnnotationMirror>absent());
+      return addItem(message, kind, element, Optional.empty(), Optional.empty());
     }
 
     Builder<T> addItem(String message, Kind kind, Element element, AnnotationMirror annotation) {
-      return addItem(message, kind, element, Optional.of(annotation));
+      return addItem(message, kind, element, Optional.of(annotation), Optional.empty());
+    }
+
+    Builder<T> addItem(
+        String message,
+        Kind kind,
+        Element element,
+        AnnotationMirror annotation,
+        AnnotationValue annotationValue) {
+      return addItem(message, kind, element, Optional.of(annotation), Optional.of(annotationValue));
     }
 
-    private Builder<T> addItem(String message, Kind kind, Element element,
-        Optional<AnnotationMirror> annotation) {
-      items.add(new AutoValue_ValidationReport_Item(message, kind, element, annotation));
+    private Builder<T> addItem(
+        String message,
+        Kind kind,
+        Element element,
+        Optional<AnnotationMirror> annotation,
+        Optional<AnnotationValue> annotationValue) {
+      items.add(
+          new AutoValue_ValidationReport_Item(message, kind, element, annotation, annotationValue));
       return this;
     }
 
@@ -211,7 +259,7 @@ T getSubject() {
 
     @CheckReturnValue
     ValidationReport<T> build() {
-      return new AutoValue_ValidationReport<T>(subject, items.build(), subreports.build());
+      return new AutoValue_ValidationReport<>(subject, items.build(), subreports.build());
     }
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ValidationType.java b/compiler/src/main/java/dagger/internal/codegen/ValidationType.java
index d60207241..eb9f27109 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ValidationType.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ValidationType.java
@@ -1,5 +1,5 @@
 /*
-* Copyright (C) 2015 Google, Inc.
+* Copyright (C) 2015 The Dagger Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
@@ -13,9 +13,10 @@
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
+
 package dagger.internal.codegen;
 
-import com.google.common.base.Optional;
+import java.util.Optional;
 import javax.tools.Diagnostic;
 
 /**
@@ -34,7 +35,7 @@
       case WARNING:
         return Optional.of(Diagnostic.Kind.WARNING);
       default:
-        return Optional.absent();
+        return Optional.empty();
     }
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/package-info.java b/compiler/src/main/java/dagger/internal/codegen/package-info.java
index ff764c87a..0490adb8a 100644
--- a/compiler/src/main/java/dagger/internal/codegen/package-info.java
+++ b/compiler/src/main/java/dagger/internal/codegen/package-info.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 Google, Inc.
+ * Copyright (C) 2016 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
diff --git a/compiler/src/test/java/dagger/internal/codegen/AccessibilityTest.java b/compiler/src/test/java/dagger/internal/codegen/AccessibilityTest.java
index 43d471879..bfe73f31c 100644
--- a/compiler/src/test/java/dagger/internal/codegen/AccessibilityTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/AccessibilityTest.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,8 +13,12 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal.codegen;
 
+import static com.google.common.truth.Truth.assertThat;
+import static dagger.internal.codegen.Accessibility.isElementAccessibleFrom;
+
 import com.google.testing.compile.CompilationRule;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.TypeElement;
@@ -25,9 +29,6 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import static com.google.common.truth.Truth.assertThat;
-import static dagger.internal.codegen.Accessibility.isElementAccessibleFrom;
-
 @RunWith(JUnit4.class)
 @SuppressWarnings("unused") // contains a variety things used by the compilation rule for testing
 public class AccessibilityTest {
diff --git a/compiler/src/test/java/dagger/internal/codegen/BindingTypeMapperTest.java b/compiler/src/test/java/dagger/internal/codegen/BindingTypeMapperTest.java
new file mode 100644
index 000000000..51b91f6b7
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/BindingTypeMapperTest.java
@@ -0,0 +1,66 @@
+/*
+ * Copyright (C) 2014 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.truth.Truth.assertThat;
+import static dagger.internal.codegen.BindingType.MEMBERS_INJECTION;
+import static dagger.internal.codegen.BindingType.PRODUCTION;
+import static dagger.internal.codegen.BindingType.PROVISION;
+import static dagger.internal.codegen.DependencyRequest.Kind.INSTANCE;
+import static dagger.internal.codegen.DependencyRequest.Kind.LAZY;
+import static dagger.internal.codegen.DependencyRequest.Kind.MEMBERS_INJECTOR;
+import static dagger.internal.codegen.DependencyRequest.Kind.PRODUCED;
+import static dagger.internal.codegen.DependencyRequest.Kind.PRODUCER;
+import static dagger.internal.codegen.DependencyRequest.Kind.PROVIDER;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/**
+ * Test case for {@link BindingTypeMapper}.
+ */
+@RunWith(JUnit4.class)
+public class BindingTypeMapperTest {
+  @Test public void forProvider() {
+    BindingTypeMapper mapper = BindingTypeMapper.FOR_PROVIDER;
+    assertThat(mapper.getBindingType(INSTANCE))
+        .isEqualTo(PROVISION);
+    assertThat(mapper.getBindingType(LAZY))
+        .isEqualTo(PROVISION);
+    assertThat(mapper.getBindingType(PROVIDER))
+        .isEqualTo(PROVISION);
+    assertThat(mapper.getBindingType(MEMBERS_INJECTOR))
+        .isEqualTo(MEMBERS_INJECTION);
+  }
+
+  @Test public void forProducer() {
+    BindingTypeMapper mapper = BindingTypeMapper.FOR_PRODUCER;
+    assertThat(mapper.getBindingType(INSTANCE))
+        .isEqualTo(PRODUCTION);
+    assertThat(mapper.getBindingType(LAZY))
+        .isEqualTo(PROVISION);
+    assertThat(mapper.getBindingType(PROVIDER))
+        .isEqualTo(PROVISION);
+    assertThat(mapper.getBindingType(MEMBERS_INJECTOR))
+        .isEqualTo(MEMBERS_INJECTION);
+    assertThat(mapper.getBindingType(PRODUCER))
+        .isEqualTo(PRODUCTION);
+    assertThat(mapper.getBindingType(PRODUCED))
+        .isEqualTo(PRODUCTION);
+  }
+}
diff --git a/compiler/src/test/java/dagger/internal/codegen/BindsMethodValidatorTest.java b/compiler/src/test/java/dagger/internal/codegen/BindsMethodValidatorTest.java
index 16ce9b532..a8567173d 100644
--- a/compiler/src/test/java/dagger/internal/codegen/BindsMethodValidatorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/BindsMethodValidatorTest.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 Google, Inc.
+ * Copyright (C) 2016 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,10 +13,16 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal.codegen;
 
+import static dagger.internal.codegen.DaggerModuleMethodSubject.Factory.assertThatMethodInUnannotatedClass;
+import static dagger.internal.codegen.DaggerModuleMethodSubject.Factory.assertThatModuleMethod;
+
 import com.google.common.collect.ImmutableList;
 import dagger.Module;
+import dagger.multibindings.IntKey;
+import dagger.multibindings.LongKey;
 import dagger.producers.ProducerModule;
 import java.io.IOException;
 import java.lang.annotation.Annotation;
@@ -28,9 +34,6 @@
 import org.junit.runners.Parameterized;
 import org.junit.runners.Parameterized.Parameters;
 
-import static dagger.internal.codegen.DaggerModuleMethodSubject.Factory.assertThatMethodInUnannotatedClass;
-import static dagger.internal.codegen.DaggerModuleMethodSubject.Factory.assertThatModuleMethod;
-
 @RunWith(Parameterized.class)
 public class BindsMethodValidatorTest {
   @Parameters
@@ -118,6 +121,20 @@ public void elementsIntoSet_withRawSets() {
         .hasError("cannot return a raw Set");
   }
 
+  @Test
+  public void intoMap_noMapKey() {
+    assertThatMethod("@Binds @IntoMap abstract Object bindNoMapKey(String string);")
+         .hasError("methods of type map must declare a map key");
+  }
+
+  @Test
+  public void intoMap_multipleMapKeys() {
+    assertThatMethod(
+            "@Binds @IntoMap @IntKey(1) @LongKey(2L) abstract Object manyMapKeys(String string);")
+        .importing(IntKey.class, LongKey.class)
+        .hasError("may not have more than one @MapKey-marked annotation");
+  }
+
   private DaggerModuleMethodSubject assertThatMethod(String method) {
     return assertThatModuleMethod(method).withDeclaration(moduleDeclaration);
   }
diff --git a/compiler/src/test/java/dagger/internal/codegen/BindsOptionalOfMethodValidatorTest.java b/compiler/src/test/java/dagger/internal/codegen/BindsOptionalOfMethodValidatorTest.java
new file mode 100644
index 000000000..9f48dd308
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/BindsOptionalOfMethodValidatorTest.java
@@ -0,0 +1,138 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static dagger.internal.codegen.DaggerModuleMethodSubject.Factory.assertThatMethodInUnannotatedClass;
+import static dagger.internal.codegen.DaggerModuleMethodSubject.Factory.assertThatModuleMethod;
+
+import com.google.common.collect.ImmutableList;
+import dagger.Module;
+import dagger.producers.ProducerModule;
+import java.lang.annotation.Annotation;
+import java.util.Collection;
+import javax.inject.Inject;
+import javax.inject.Qualifier;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+import org.junit.runners.Parameterized.Parameters;
+
+/** Tests {@link BindsOptionalOfMethodValidator}. */
+@RunWith(Parameterized.class)
+public class BindsOptionalOfMethodValidatorTest {
+  @Parameters(name = "{0}")
+  public static Collection<Object[]> data() {
+    return ImmutableList.copyOf(new Object[][] {{Module.class}, {ProducerModule.class}});
+  }
+
+  private final String moduleDeclaration;
+
+  public BindsOptionalOfMethodValidatorTest(Class<? extends Annotation> moduleAnnotation) {
+    moduleDeclaration = "@" + moduleAnnotation.getCanonicalName() + " abstract class %s { %s }";
+  }
+
+  @Test
+  public void nonAbstract() {
+    assertThatMethod("@BindsOptionalOf Object concrete() { return null; }")
+        .hasError("must be abstract");
+  }
+
+  @Test
+  public void hasParameters() {
+    assertThatMethod("@BindsOptionalOf abstract Object hasParameters(String s1);")
+        .hasError("parameters");
+  }
+
+  @Test
+  public void typeParameters() {
+    assertThatMethod("@BindsOptionalOf abstract <S> S generic();").hasError("type parameters");
+  }
+
+  @Test
+  public void notInModule() {
+    assertThatMethodInUnannotatedClass("@BindsOptionalOf abstract Object notInModule();")
+        .hasError("within a @Module or @ProducerModule");
+  }
+
+  @Test
+  public void throwsException() {
+    assertThatMethod("@BindsOptionalOf abstract Object throwsException() throws RuntimeException;")
+        .hasError("may not throw");
+  }
+
+  @Test
+  public void returnsVoid() {
+    assertThatMethod("@BindsOptionalOf abstract void returnsVoid();").hasError("void");
+  }
+
+  @Test
+  public void returnsMembersInjector() {
+    assertThatMethod("@BindsOptionalOf abstract MembersInjector<Object> returnsMembersInjector();")
+        .hasError("framework");
+  }
+
+  @Test
+  public void tooManyQualifiers() {
+    assertThatMethod(
+            "@BindsOptionalOf @Qualifier1 @Qualifier2 abstract String tooManyQualifiers();")
+        .importing(Qualifier1.class, Qualifier2.class)
+        .hasError("more than one @Qualifier");
+  }
+
+  @Test
+  public void intoSet() {
+    assertThatMethod("@BindsOptionalOf @IntoSet abstract String intoSet();")
+        .hasError("Multibinding annotations");
+  }
+
+  @Test
+  public void elementsIntoSet() {
+    assertThatMethod("@BindsOptionalOf @ElementsIntoSet abstract Set<String> elementsIntoSet();")
+        .hasError("Multibinding annotations");
+  }
+
+  @Test
+  public void intoMap() {
+    assertThatMethod("@BindsOptionalOf @IntoMap abstract String intoMap();")
+        .hasError("Multibinding annotations");
+  }
+
+  /** An injectable value object. */
+  public static final class Thing {
+    @Inject
+    Thing() {}
+  }
+
+  @Test
+  public void implicitlyProvidedType() {
+    assertThatMethod("@BindsOptionalOf abstract Thing thing();")
+        .importing(Thing.class)
+        .hasError("return unqualified types that have an @Inject-annotated constructor");
+  }
+
+  private DaggerModuleMethodSubject assertThatMethod(String method) {
+    return assertThatModuleMethod(method).withDeclaration(moduleDeclaration);
+  }
+
+  /** A qualifier. */
+  @Qualifier
+  public @interface Qualifier1 {}
+
+  /** A qualifier. */
+  @Qualifier
+  public @interface Qualifier2 {}
+}
diff --git a/compiler/src/test/java/dagger/internal/codegen/CanReleaseReferencesValidatorTest.java b/compiler/src/test/java/dagger/internal/codegen/CanReleaseReferencesValidatorTest.java
new file mode 100644
index 000000000..bdaea7ec5
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/CanReleaseReferencesValidatorTest.java
@@ -0,0 +1,54 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.truth.Truth.assertAbout;
+import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+
+import com.google.auto.value.processor.AutoAnnotationProcessor;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/** Tests for {@link CanReleaseReferencesValidator}. */
+@RunWith(JUnit4.class)
+public final class CanReleaseReferencesValidatorTest {
+  @Test
+  public void annotatesSourceRetainedAnnotation() {
+    JavaFileObject annotation =
+        JavaFileObjects.forSourceLines(
+            "test.Metadata",
+            "package test;",
+            "",
+            "import dagger.releasablereferences.CanReleaseReferences;",
+            "import java.lang.annotation.Retention;",
+            "import java.lang.annotation.RetentionPolicy;",
+            "",
+            "@CanReleaseReferences",
+            "@Retention(RetentionPolicy.SOURCE)",
+            "@interface Metadata {}");
+    assertAbout(javaSource())
+        .that(annotation)
+        .processedWith(new ComponentProcessor(), new AutoAnnotationProcessor())
+        .failsToCompile()
+        .withErrorContaining("SOURCE")
+        .in(annotation)
+        .onLine(8);
+  }
+}
diff --git a/compiler/src/test/java/dagger/internal/codegen/CodeBlocksTest.java b/compiler/src/test/java/dagger/internal/codegen/CodeBlocksTest.java
new file mode 100644
index 000000000..43507c9ea
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/CodeBlocksTest.java
@@ -0,0 +1,88 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.truth.Truth.assertThat;
+import static dagger.internal.codegen.CodeBlocks.javadocLinkTo;
+import static dagger.internal.codegen.CodeBlocks.joiningCodeBlocks;
+import static dagger.internal.codegen.CodeBlocks.toParametersCodeBlock;
+import static javax.lang.model.element.ElementKind.METHOD;
+
+import com.google.testing.compile.CompilationRule;
+import com.squareup.javapoet.CodeBlock;
+import java.util.stream.Stream;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.util.Elements;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/** Tests for {@link CodeBlocks}. */
+@RunWith(JUnit4.class)
+public final class CodeBlocksTest {
+  private static final CodeBlock objectO = CodeBlock.of("$T o", Object.class);
+  private static final CodeBlock stringS = CodeBlock.of("$T s", String.class);
+  private static final CodeBlock intI = CodeBlock.of("$T i", int.class);
+
+  @Rule public CompilationRule compilationRule = new CompilationRule();
+  private Elements elements;
+
+  @Before
+  public void setUp() {
+    this.elements = compilationRule.getElements();
+  }
+
+  @Test
+  public void testToParametersCodeBlock() {
+    assertThat(Stream.of(objectO, stringS, intI).collect(toParametersCodeBlock()))
+        .isEqualTo(CodeBlock.of("$T o, $T s, $T i", Object.class, String.class, int.class));
+  }
+
+  @Test
+  public void testToParametersCodeBlock_empty() {
+    assertThat(Stream.<CodeBlock>of().collect(toParametersCodeBlock())).isEqualTo(CodeBlock.of(""));
+  }
+
+  @Test
+  public void testToParametersCodeBlock_oneElement() {
+    assertThat(Stream.of(objectO).collect(toParametersCodeBlock())).isEqualTo(objectO);
+  }
+
+  @Test
+  public void testJoiningCodeBlocks() {
+    assertThat(Stream.of(objectO, stringS, intI).collect(joiningCodeBlocks("!")))
+        .isEqualTo(CodeBlock.of("$T o!$T s!$T i", Object.class, String.class, int.class));
+  }
+
+  @Test
+  public void testJavadocLinkTo() {
+    ExecutableElement equals =
+        elements
+            .getTypeElement(Object.class.getCanonicalName())
+            .getEnclosedElements()
+            .stream()
+            .filter(element -> element.getKind().equals(METHOD))
+            .map(ExecutableElement.class::cast)
+            .filter(method -> method.getSimpleName().contentEquals("equals"))
+            .findFirst()
+            .get();
+    assertThat(javadocLinkTo(equals))
+        .isEqualTo(CodeBlock.of("{@link $T#equals($T)}", Object.class, Object.class));
+  }
+}
diff --git a/compiler/src/test/java/dagger/internal/codegen/Compilers.java b/compiler/src/test/java/dagger/internal/codegen/Compilers.java
new file mode 100644
index 000000000..a42d1a2ff
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/Compilers.java
@@ -0,0 +1,30 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.testing.compile.Compiler.javac;
+
+import com.google.testing.compile.Compiler;
+
+/** {@link Compiler} instances for testing Dagger. */
+final class Compilers {
+
+  /** Returns a compiler that runs the Dagger processor. */
+  static Compiler daggerCompiler() {
+    return javac().withProcessors(new ComponentProcessor());
+  }
+}
diff --git a/compiler/src/test/java/dagger/internal/codegen/ComponentBuilderTest.java b/compiler/src/test/java/dagger/internal/codegen/ComponentBuilderTest.java
index 3623d76d2..f5af32957 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ComponentBuilderTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ComponentBuilderTest.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,20 +13,24 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal.codegen;
 
+import static com.google.common.truth.Truth.assertAbout;
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+import static dagger.internal.codegen.Compilers.daggerCompiler;
+import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
+
 import com.google.common.collect.ImmutableList;
+import com.google.testing.compile.Compilation;
 import com.google.testing.compile.JavaFileObjects;
 import javax.tools.JavaFileObject;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import static com.google.common.truth.Truth.assertAbout;
-import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
-import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
-import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
-
 /** Tests for {@link dagger.Component.Builder} */
 @RunWith(JUnit4.class)
 public class ComponentBuilderTest {
@@ -36,312 +40,338 @@
 
   @Test
   public void testEmptyBuilder() {
-    JavaFileObject injectableTypeFile = JavaFileObjects.forSourceLines("test.SomeInjectableType",
-        "package test;",
-        "",
-        "import javax.inject.Inject;",
-        "",
-        "final class SomeInjectableType {",
-        "  @Inject SomeInjectableType() {}",
-        "}");
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "interface SimpleComponent {",
-        "  SomeInjectableType someInjectableType();",
-        "",
-        "  @Component.Builder",
-        "  static interface Builder {",
-        "     SimpleComponent build();",
-        "  }",
-        "}");
-    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
-        "test.DaggerSimpleComponent",
-        "package test;",
-        "",
-        "import javax.annotation.Generated;",
-        "",
-        GENERATED_ANNOTATION,
-        "public final class DaggerSimpleComponent implements SimpleComponent {",
-        "  private DaggerSimpleComponent(Builder builder) {",
-        "    assert builder != null;",
-        "  }",
-        "",
-        "  public static SimpleComponent.Builder builder() {",
-        "    return new Builder();",
-        "  }",
-        "",
-        "  public static SimpleComponent create() {",
-        "    return builder().build();",
-        "  }",
-        "",
-        "  @Override",
-        "  public SomeInjectableType someInjectableType() {",
-        "    return SomeInjectableType_Factory.create().get();",
-        "  }",
-        "",
-        "  private static final class Builder implements SimpleComponent.Builder {",
-        "    @Override",
-        "    public SimpleComponent build() {",
-        "      return new DaggerSimpleComponent(this);",
-        "    }",
-        "  }",
-        "}");
-    assertAbout(javaSources()).that(ImmutableList.of(injectableTypeFile, componentFile))
+    JavaFileObject injectableTypeFile =
+        JavaFileObjects.forSourceLines(
+            "test.SomeInjectableType",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "final class SomeInjectableType {",
+            "  @Inject SomeInjectableType() {}",
+            "}");
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component",
+            "interface SimpleComponent {",
+            "  SomeInjectableType someInjectableType();",
+            "",
+            "  @Component.Builder",
+            "  static interface Builder {",
+            "     SimpleComponent build();",
+            "  }",
+            "}");
+    JavaFileObject generatedComponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerSimpleComponent",
+            "package test;",
+            "",
+            "import javax.annotation.Generated;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerSimpleComponent implements SimpleComponent {",
+            "  private DaggerSimpleComponent(Builder builder) {",
+            "    assert builder != null;",
+            "  }",
+            "",
+            "  public static SimpleComponent.Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static SimpleComponent create() {",
+            "    return new Builder().build();",
+            "  }",
+            "",
+            "  @Override",
+            "  public SomeInjectableType someInjectableType() {",
+            "    return new SomeInjectableType();",
+            "  }",
+            "",
+            "  private static final class Builder implements SimpleComponent.Builder {",
+            "    @Override",
+            "    public SimpleComponent build() {",
+            "      return new DaggerSimpleComponent(this);",
+            "    }",
+            "  }",
+            "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(injectableTypeFile, componentFile))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
-        .and().generatesSources(generatedComponent);
+        .and()
+        .generatesSources(generatedComponent);
   }
 
   @Test
   public void testUsesBuildAndSetterNames() {
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "",
-        "@Module",
-        "final class TestModule {",
-        "  @Provides String string() { return null; }",
-        "}");
-
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "",
-        "@Component(modules = TestModule.class)",
-        "interface TestComponent {",
-        "  String string();",
-        "",
-        "  @Component.Builder",
-        "  interface Builder {",
-        "    Builder setTestModule(TestModule testModule);",
-        "    TestComponent create();",
-        "  }",
-        "}");
-    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
-        "test.DaggerTestComponent",
-        "package test;",
-        "",
-        "import dagger.internal.Preconditions;",
-        "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
-        "",
-        GENERATED_ANNOTATION,
-        "public final class DaggerTestComponent implements TestComponent {",
-        "  private Provider<String> stringProvider;",
-        "",
-        "  private DaggerTestComponent(Builder builder) {",
-        "    assert builder != null;",
-        "    initialize(builder);",
-        "  }",
-        "",
-        "  public static TestComponent.Builder builder() {",
-        "    return new Builder();",
-        "  }",
-        "",
-        "  public static TestComponent create() {",
-        "    return builder().create();",
-        "  }",
-        "",
-        "  @SuppressWarnings(\"unchecked\")",
-        "  private void initialize(final Builder builder) {",
-        "    this.stringProvider = TestModule_StringFactory.create(builder.testModule);",
-        "  }",
-        "",
-        "  @Override",
-        "  public String string() {",
-        "    return stringProvider.get();",
-        "  }",
-        "",
-        "  private static final class Builder implements TestComponent.Builder {",
-        "    private TestModule testModule;",
-        "",
-        "    @Override",
-        "    public TestComponent create() {",
-        "      if (testModule == null) {",
-        "        this.testModule = new TestModule();",
-        "      }",
-        "      return new DaggerTestComponent(this);",
-        "    }",
-        "",
-        "    @Override",
-        "    public Builder setTestModule(TestModule testModule) {",
-        "      this.testModule = Preconditions.checkNotNull(testModule);",
-        "      return this;",
-        "    }",
-        "  }",
-        "}");
+    JavaFileObject moduleFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "final class TestModule {",
+            "  @Provides String string() { return null; }",
+            "}");
+
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = TestModule.class)",
+            "interface TestComponent {",
+            "  String string();",
+            "",
+            "  @Component.Builder",
+            "  interface Builder {",
+            "    Builder setTestModule(TestModule testModule);",
+            "    TestComponent create();",
+            "  }",
+            "}");
+    JavaFileObject generatedComponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerTestComponent",
+            "package test;",
+            "",
+            "import dagger.internal.Preconditions;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerTestComponent implements TestComponent {",
+            "  private Provider<String> stringProvider;",
+            "",
+            "  private DaggerTestComponent(Builder builder) {",
+            "    assert builder != null;",
+            "    initialize(builder);",
+            "  }",
+            "",
+            "  public static TestComponent.Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static TestComponent create() {",
+            "    return new Builder().create();",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize(final Builder builder) {",
+            "    this.stringProvider = TestModule_StringFactory.create(builder.testModule);",
+            "  }",
+            "",
+            "  @Override",
+            "  public String string() {",
+            "    return stringProvider.get();",
+            "  }",
+            "",
+            "  private static final class Builder implements TestComponent.Builder {",
+            "    private TestModule testModule;",
+            "",
+            "    @Override",
+            "    public TestComponent create() {",
+            "      if (testModule == null) {",
+            "        this.testModule = new TestModule();",
+            "      }",
+            "      return new DaggerTestComponent(this);",
+            "    }",
+            "",
+            "    @Override",
+            "    public Builder setTestModule(TestModule testModule) {",
+            "      this.testModule = Preconditions.checkNotNull(testModule);",
+            "      return this;",
+            "    }",
+            "  }",
+            "}");
     assertAbout(javaSources())
         .that(ImmutableList.of(moduleFile, componentFile))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
-        .and().generatesSources(generatedComponent);
+        .and()
+        .generatesSources(generatedComponent);
   }
 
   @Test
   public void testIgnoresModulesNotInApi() {
-    JavaFileObject module1 = JavaFileObjects.forSourceLines("test.TestModule1",
-        "package test;",
-        "",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "",
-        "@Module",
-        "final class TestModule1 {",
-        "  @Provides String string() { return null; }",
-        "}");
-    JavaFileObject module2 = JavaFileObjects.forSourceLines("test.TestModule2",
-        "package test;",
-        "",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "",
-        "@Module",
-        "final class TestModule2 {",
-        "  @Provides Integer integer() { return null; }",
-        "}");
-
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "",
-        "@Component(modules = {TestModule1.class, TestModule2.class})",
-        "interface TestComponent {",
-        "  String string();",
-        "  Integer integer();",
-        "",
-        "  @Component.Builder",
-        "  interface Builder {",
-        "    Builder testModule1(TestModule1 testModule1);",
-        "    TestComponent build();",
-        "  }",
-        "}");
-    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
-        "test.DaggerTestComponent",
-        "package test;",
-        "",
-        "import dagger.internal.Preconditions;",
-        "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
-        "",
-        GENERATED_ANNOTATION,
-        "public final class DaggerTestComponent implements TestComponent {",
-        "  private Provider<String> stringProvider;",
-        "  private Provider<Integer> integerProvider;",
-        "",
-        "  private DaggerTestComponent(Builder builder) {",
-        "    assert builder != null;",
-        "    initialize(builder);",
-        "  }",
-        "",
-        "  public static TestComponent.Builder builder() {",
-        "    return new Builder();",
-        "  }",
-        "",
-        "  public static TestComponent create() {",
-        "    return builder().build();",
-        "  }",
-        "",
-        "  @SuppressWarnings(\"unchecked\")",
-        "  private void initialize(final Builder builder) {",
-        "    this.stringProvider = TestModule1_StringFactory.create(builder.testModule1);",
-        "    this.integerProvider = TestModule2_IntegerFactory.create(builder.testModule2);",
-        "  }",
-        "",
-        "  @Override",
-        "  public String string() {",
-        "    return stringProvider.get();",
-        "  }",
-        "",
-        "  @Override",
-        "  public Integer integer() {",
-        "    return integerProvider.get();",
-        "  }",
-        "",
-        "  private static final class Builder implements TestComponent.Builder {",
-        "    private TestModule1 testModule1;",
-        "    private TestModule2 testModule2;",
-        "",
-        "    @Override",
-        "    public TestComponent build() {",
-        "      if (testModule1 == null) {",
-        "        this.testModule1 = new TestModule1();",
-        "      }",
-        "      if (testModule2 == null) {",
-        "        this.testModule2 = new TestModule2();",
-        "      }",
-        "      return new DaggerTestComponent(this);",
-        "    }",
-        "",
-        "    @Override",
-        "    public Builder testModule1(TestModule1 testModule1) {",
-        "      this.testModule1 = Preconditions.checkNotNull(testModule1);",
-        "      return this;",
-        "    }",
-        "  }",
-        "}");
+    JavaFileObject module1 =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule1",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "final class TestModule1 {",
+            "  @Provides String string() { return null; }",
+            "}");
+    JavaFileObject module2 =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule2",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "final class TestModule2 {",
+            "  @Provides Integer integer() { return null; }",
+            "}");
+
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = {TestModule1.class, TestModule2.class})",
+            "interface TestComponent {",
+            "  String string();",
+            "  Integer integer();",
+            "",
+            "  @Component.Builder",
+            "  interface Builder {",
+            "    Builder testModule1(TestModule1 testModule1);",
+            "    TestComponent build();",
+            "  }",
+            "}");
+    JavaFileObject generatedComponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerTestComponent",
+            "package test;",
+            "",
+            "import dagger.internal.Preconditions;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerTestComponent implements TestComponent {",
+            "  private Provider<String> stringProvider;",
+            "  private Provider<Integer> integerProvider;",
+            "",
+            "  private DaggerTestComponent(Builder builder) {",
+            "    assert builder != null;",
+            "    initialize(builder);",
+            "  }",
+            "",
+            "  public static TestComponent.Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static TestComponent create() {",
+            "    return new Builder().build();",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize(final Builder builder) {",
+            "    this.stringProvider = TestModule1_StringFactory.create(builder.testModule1);",
+            "    this.integerProvider = TestModule2_IntegerFactory.create(builder.testModule2);",
+            "  }",
+            "",
+            "  @Override",
+            "  public String string() {",
+            "    return stringProvider.get();",
+            "  }",
+            "",
+            "  @Override",
+            "  public Integer integer() {",
+            "    return integerProvider.get();",
+            "  }",
+            "",
+            "  private static final class Builder implements TestComponent.Builder {",
+            "    private TestModule1 testModule1;",
+            "    private TestModule2 testModule2;",
+            "",
+            "    @Override",
+            "    public TestComponent build() {",
+            "      if (testModule1 == null) {",
+            "        this.testModule1 = new TestModule1();",
+            "      }",
+            "      if (testModule2 == null) {",
+            "        this.testModule2 = new TestModule2();",
+            "      }",
+            "      return new DaggerTestComponent(this);",
+            "    }",
+            "",
+            "    @Override",
+            "    public Builder testModule1(TestModule1 testModule1) {",
+            "      this.testModule1 = Preconditions.checkNotNull(testModule1);",
+            "      return this;",
+            "    }",
+            "  }",
+            "}");
     assertAbout(javaSources())
         .that(ImmutableList.of(module1, module2, componentFile))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
-        .and().generatesSources(generatedComponent);
+        .and()
+        .generatesSources(generatedComponent);
   }
 
   @Test
   public void testMoreThanOneBuilderFails() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "interface SimpleComponent {",
-        "  @Component.Builder",
-        "  static interface Builder {",
-        "     SimpleComponent build();",
-        "  }",
-        "",
-        "  @Component.Builder",
-        "  interface Builder2 {",
-        "     SimpleComponent build();",
-        "  }",
-        "}");
-    assertAbout(javaSource()).that(componentFile)
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component",
+            "interface SimpleComponent {",
+            "  @Component.Builder",
+            "  static interface Builder {",
+            "     SimpleComponent build();",
+            "  }",
+            "",
+            "  @Component.Builder",
+            "  interface Builder2 {",
+            "     SimpleComponent build();",
+            "  }",
+            "}");
+    assertAbout(javaSource())
+        .that(componentFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
-        .withErrorContaining(String.format(MSGS.moreThanOne(),
-            "[test.SimpleComponent.Builder, test.SimpleComponent.Builder2]"))
+        .withErrorContaining(
+            String.format(
+                MSGS.moreThanOne(),
+                "[test.SimpleComponent.Builder, test.SimpleComponent.Builder2]"))
         .in(componentFile);
   }
 
   @Test
   public void testBuilderGenericsFails() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "interface SimpleComponent {",
-        "  @Component.Builder",
-        "  interface Builder<T> {",
-        "     SimpleComponent build();",
-        "  }",
-        "}");
-    assertAbout(javaSource()).that(componentFile)
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component",
+            "interface SimpleComponent {",
+            "  @Component.Builder",
+            "  interface Builder<T> {",
+            "     SimpleComponent build();",
+            "  }",
+            "}");
+    assertAbout(javaSource())
+        .that(componentFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(MSGS.generics())
@@ -350,14 +380,17 @@ public void testBuilderGenericsFails() {
 
   @Test
   public void testBuilderNotInComponentFails() {
-    JavaFileObject builder = JavaFileObjects.forSourceLines("test.Builder",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "",
-        "@Component.Builder",
-        "interface Builder {}");
-    assertAbout(javaSource()).that(builder)
+    JavaFileObject builder =
+        JavaFileObjects.forSourceLines(
+            "test.Builder",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component.Builder",
+            "interface Builder {}");
+    assertAbout(javaSource())
+        .that(builder)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(MSGS.mustBeInComponent())
@@ -366,19 +399,21 @@ public void testBuilderNotInComponentFails() {
 
   @Test
   public void testBuilderMissingBuildMethodFails() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "interface SimpleComponent {",
-        "  @Component.Builder",
-        "  interface Builder {}",
-        "}");
-    assertAbout(javaSource()).that(componentFile)
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component",
+            "interface SimpleComponent {",
+            "  @Component.Builder",
+            "  interface Builder {}",
+            "}");
+    assertAbout(javaSource())
+        .that(componentFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(MSGS.missingBuildMethod())
@@ -387,19 +422,21 @@ public void testBuilderMissingBuildMethodFails() {
 
   @Test
   public void testPrivateBuilderFails() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "abstract class SimpleComponent {",
-        "  @Component.Builder",
-        "  private interface Builder {}",
-        "}");
-    assertAbout(javaSource()).that(componentFile)
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component",
+            "abstract class SimpleComponent {",
+            "  @Component.Builder",
+            "  private interface Builder {}",
+            "}");
+    assertAbout(javaSource())
+        .that(componentFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(MSGS.isPrivate())
@@ -408,19 +445,21 @@ public void testPrivateBuilderFails() {
 
   @Test
   public void testNonStaticBuilderFails() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "abstract class SimpleComponent {",
-        "  @Component.Builder",
-        "  abstract class Builder {}",
-        "}");
-    assertAbout(javaSource()).that(componentFile)
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component",
+            "abstract class SimpleComponent {",
+            "  @Component.Builder",
+            "  abstract class Builder {}",
+            "}");
+    assertAbout(javaSource())
+        .that(componentFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(MSGS.mustBeStatic())
@@ -429,19 +468,21 @@ public void testNonStaticBuilderFails() {
 
   @Test
   public void testNonAbstractBuilderFails() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "abstract class SimpleComponent {",
-        "  @Component.Builder",
-        "  static class Builder {}",
-        "}");
-    assertAbout(javaSource()).that(componentFile)
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component",
+            "abstract class SimpleComponent {",
+            "  @Component.Builder",
+            "  static class Builder {}",
+            "}");
+    assertAbout(javaSource())
+        .that(componentFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(MSGS.mustBeAbstract());
@@ -449,21 +490,23 @@ public void testNonAbstractBuilderFails() {
 
   @Test
   public void testBuilderOneCxtorWithArgsFails() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "abstract class SimpleComponent {",
-        "  @Component.Builder",
-        "  static abstract class Builder {",
-        "    Builder(String unused) {}",
-        "  }",
-        "}");
-    assertAbout(javaSource()).that(componentFile)
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component",
+            "abstract class SimpleComponent {",
+            "  @Component.Builder",
+            "  static abstract class Builder {",
+            "    Builder(String unused) {}",
+            "  }",
+            "}");
+    assertAbout(javaSource())
+        .that(componentFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(MSGS.cxtorOnlyOneAndNoArgs())
@@ -472,22 +515,24 @@ public void testBuilderOneCxtorWithArgsFails() {
 
   @Test
   public void testBuilderMoreThanOneCxtorFails() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "abstract class SimpleComponent {",
-        "  @Component.Builder",
-        "  static abstract class Builder {",
-        "    Builder() {}",
-        "    Builder(String unused) {}",
-        "  }",
-        "}");
-    assertAbout(javaSource()).that(componentFile)
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component",
+            "abstract class SimpleComponent {",
+            "  @Component.Builder",
+            "  static abstract class Builder {",
+            "    Builder() {}",
+            "    Builder(String unused) {}",
+            "  }",
+            "}");
+    assertAbout(javaSource())
+        .that(componentFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(MSGS.cxtorOnlyOneAndNoArgs())
@@ -496,19 +541,21 @@ public void testBuilderMoreThanOneCxtorFails() {
 
   @Test
   public void testBuilderEnumFails() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "abstract class SimpleComponent {",
-        "  @Component.Builder",
-        "  enum Builder {}",
-        "}");
-    assertAbout(javaSource()).that(componentFile)
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component",
+            "abstract class SimpleComponent {",
+            "  @Component.Builder",
+            "  enum Builder {}",
+            "}");
+    assertAbout(javaSource())
+        .that(componentFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(MSGS.mustBeClassOrInterface())
@@ -517,317 +564,382 @@ public void testBuilderEnumFails() {
 
   @Test
   public void testBuilderBuildReturnsWrongTypeFails() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "abstract class SimpleComponent {",
-        "  @Component.Builder",
-        "  interface Builder {",
-        "    String build();",
-        "  }",
-        "}");
-    assertAbout(javaSource()).that(componentFile)
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component",
+            "abstract class SimpleComponent {",
+            "  @Component.Builder",
+            "  interface Builder {",
+            "    String build();",
+            "  }",
+            "}");
+    assertAbout(javaSource())
+        .that(componentFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(MSGS.buildMustReturnComponentType())
-            .in(componentFile).onLine(11);
+        .in(componentFile)
+        .onLine(10);
   }
 
   @Test
   public void testInheritedBuilderBuildReturnsWrongTypeFails() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "abstract class SimpleComponent {",
-        "  interface Parent {",
-        "    String build();",
-        "  }",
-        "",
-        "  @Component.Builder",
-        "  interface Builder extends Parent {}",
-        "}");
-    assertAbout(javaSource()).that(componentFile)
-        .processedWith(new ComponentProcessor())
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component",
+            "abstract class SimpleComponent {",
+            "  interface Parent {",
+            "    String build();",
+            "  }",
+            "",
+            "  @Component.Builder",
+            "  interface Builder extends Parent {}",
+            "}");
+    assertAbout(javaSource())
+        .that(componentFile)
+        .processedWith(new ComponentProcessor())
         .failsToCompile()
-        .withErrorContaining(
-            String.format(MSGS.inheritedBuildMustReturnComponentType(), "build"))
-            .in(componentFile).onLine(14);
+        .withErrorContaining(String.format(MSGS.inheritedBuildMustReturnComponentType(), "build"))
+        .in(componentFile)
+        .onLine(13);
   }
 
   @Test
   public void testTwoBuildMethodsFails() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "abstract class SimpleComponent {",
-        "  @Component.Builder",
-        "  interface Builder {",
-        "    SimpleComponent build();",
-        "    SimpleComponent create();",
-        "  }",
-        "}");
-    assertAbout(javaSource()).that(componentFile)
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component",
+            "abstract class SimpleComponent {",
+            "  @Component.Builder",
+            "  interface Builder {",
+            "    SimpleComponent build();",
+            "    SimpleComponent create();",
+            "  }",
+            "}");
+    assertAbout(javaSource())
+        .that(componentFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(String.format(MSGS.twoBuildMethods(), "build()"))
-            .in(componentFile).onLine(12);
+        .in(componentFile)
+        .onLine(11);
   }
 
   @Test
   public void testInheritedTwoBuildMethodsFails() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "abstract class SimpleComponent {",
-        "  interface Parent {",
-        "    SimpleComponent build();",
-        "    SimpleComponent create();",
-        "  }",
-        "",
-        "  @Component.Builder",
-        "  interface Builder extends Parent {}",
-        "}");
-    assertAbout(javaSource()).that(componentFile)
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component",
+            "abstract class SimpleComponent {",
+            "  interface Parent {",
+            "    SimpleComponent build();",
+            "    SimpleComponent create();",
+            "  }",
+            "",
+            "  @Component.Builder",
+            "  interface Builder extends Parent {}",
+            "}");
+    assertAbout(javaSource())
+        .that(componentFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
-        .withErrorContaining(
-            String.format(MSGS.inheritedTwoBuildMethods(), "create()", "build()"))
-            .in(componentFile).onLine(15);
+        .withErrorContaining(String.format(MSGS.inheritedTwoBuildMethods(), "build()", "create()"))
+        .in(componentFile)
+        .onLine(14);
   }
 
   @Test
   public void testMoreThanOneArgFails() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "abstract class SimpleComponent {",
-        "  @Component.Builder",
-        "  interface Builder {",
-        "    SimpleComponent build();",
-        "    Builder set(String s, Integer i);",
-        "    Builder set(Number n, Double d);",
-        "  }",
-        "}");
-    assertAbout(javaSource()).that(componentFile)
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component",
+            "abstract class SimpleComponent {",
+            "  @Component.Builder",
+            "  interface Builder {",
+            "    SimpleComponent build();",
+            "    Builder set(String s, Integer i);",
+            "    Builder set(Number n, Double d);",
+            "  }",
+            "}");
+    assertAbout(javaSource())
+        .that(componentFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(MSGS.methodsMustTakeOneArg())
-            .in(componentFile).onLine(12)
-        .and().withErrorContaining(MSGS.methodsMustTakeOneArg())
-            .in(componentFile).onLine(13);
+        .in(componentFile)
+        .onLine(11)
+        .and()
+        .withErrorContaining(MSGS.methodsMustTakeOneArg())
+        .in(componentFile)
+        .onLine(12);
   }
 
   @Test
   public void testInheritedMoreThanOneArgFails() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "abstract class SimpleComponent {",
-        "  interface Parent {",
-        "    SimpleComponent build();",
-        "    Builder set1(String s, Integer i);",
-        "  }",
-        "",
-        "  @Component.Builder",
-        "  interface Builder extends Parent {}",
-        "}");
-    assertAbout(javaSource()).that(componentFile)
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component",
+            "abstract class SimpleComponent {",
+            "  interface Parent {",
+            "    SimpleComponent build();",
+            "    Builder set1(String s, Integer i);",
+            "  }",
+            "",
+            "  @Component.Builder",
+            "  interface Builder extends Parent {}",
+            "}");
+    assertAbout(javaSource())
+        .that(componentFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(
-            String.format(MSGS.inheritedMethodsMustTakeOneArg(),
-                "set1(java.lang.String,java.lang.Integer)"))
-            .in(componentFile).onLine(15);
+            String.format(
+                MSGS.inheritedMethodsMustTakeOneArg(), "set1(java.lang.String,java.lang.Integer)"))
+        .in(componentFile)
+        .onLine(14);
   }
 
   @Test
   public void testSetterReturningNonVoidOrBuilderFails() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "abstract class SimpleComponent {",
-        "  @Component.Builder",
-        "  interface Builder {",
-        "    SimpleComponent build();",
-        "    String set(Integer i);",
-        "  }",
-        "}");
-    assertAbout(javaSource()).that(componentFile)
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component",
+            "abstract class SimpleComponent {",
+            "  @Component.Builder",
+            "  interface Builder {",
+            "    SimpleComponent build();",
+            "    String set(Integer i);",
+            "  }",
+            "}");
+    assertAbout(javaSource())
+        .that(componentFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(MSGS.methodsMustReturnVoidOrBuilder())
-            .in(componentFile).onLine(12);
+        .in(componentFile)
+        .onLine(11);
   }
 
   @Test
   public void testInheritedSetterReturningNonVoidOrBuilderFails() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "abstract class SimpleComponent {",
-        "  interface Parent {",
-        "    SimpleComponent build();",
-        "    String set(Integer i);",
-        "  }",
-        "",
-        "  @Component.Builder",
-        "  interface Builder extends Parent {}",
-        "}");
-    assertAbout(javaSource()).that(componentFile)
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component",
+            "abstract class SimpleComponent {",
+            "  interface Parent {",
+            "    SimpleComponent build();",
+            "    String set(Integer i);",
+            "  }",
+            "",
+            "  @Component.Builder",
+            "  interface Builder extends Parent {}",
+            "}");
+    assertAbout(javaSource())
+        .that(componentFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(
-            String.format(MSGS.inheritedMethodsMustReturnVoidOrBuilder(),
-                "set(java.lang.Integer)"))
-            .in(componentFile).onLine(15);
+            String.format(MSGS.inheritedMethodsMustReturnVoidOrBuilder(), "set(java.lang.Integer)"))
+        .in(componentFile)
+        .onLine(14);
   }
 
   @Test
   public void testGenericsOnSetterMethodFails() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "abstract class SimpleComponent {",
-        "  @Component.Builder",
-        "  interface Builder {",
-        "    SimpleComponent build();",
-        "    <T> Builder set(T t);",
-        "  }",
-        "}");
-    assertAbout(javaSource()).that(componentFile)
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component",
+            "abstract class SimpleComponent {",
+            "  @Component.Builder",
+            "  interface Builder {",
+            "    SimpleComponent build();",
+            "    <T> Builder set(T t);",
+            "  }",
+            "}");
+    assertAbout(javaSource())
+        .that(componentFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(MSGS.methodsMayNotHaveTypeParameters())
-            .in(componentFile).onLine(12);
+        .in(componentFile)
+        .onLine(11);
   }
 
   @Test
   public void testGenericsOnInheritedSetterMethodFails() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "abstract class SimpleComponent {",
-        "  interface Parent {",
-        "    SimpleComponent build();",
-        "    <T> Builder set(T t);",
-        "  }",
-        "",
-        "  @Component.Builder",
-        "  interface Builder extends Parent {}",
-        "}");
-    assertAbout(javaSource()).that(componentFile)
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component",
+            "abstract class SimpleComponent {",
+            "  interface Parent {",
+            "    SimpleComponent build();",
+            "    <T> Builder set(T t);",
+            "  }",
+            "",
+            "  @Component.Builder",
+            "  interface Builder extends Parent {}",
+            "}");
+    assertAbout(javaSource())
+        .that(componentFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(
             String.format(MSGS.inheritedMethodsMayNotHaveTypeParameters(), "<T>set(T)"))
-            .in(componentFile).onLine(15);
+        .in(componentFile)
+        .onLine(14);
   }
 
   @Test
   public void testMultipleSettersPerTypeFails() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "abstract class SimpleComponent {",
-        "  @Component.Builder",
-        "  interface Builder {",
-        "    SimpleComponent build();",
-        "    void set1(String s);",
-        "    void set2(String s);",
-        "  }",
-        "}");
-    assertAbout(javaSource()).that(componentFile)
+    JavaFileObject moduleFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "final class TestModule {",
+            "  @Provides String s() { return \"\"; }",
+            "}");
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component(modules = TestModule.class)",
+            "abstract class SimpleComponent {",
+            "  abstract String s();",
+            "",
+            "  @Component.Builder",
+            "  interface Builder {",
+            "    SimpleComponent build();",
+            "    void set1(TestModule s);",
+            "    void set2(TestModule s);",
+            "  }",
+            "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(moduleFile, componentFile))
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(
-            String.format(MSGS.manyMethodsForType(),
-                  "java.lang.String", "[set1(java.lang.String), set2(java.lang.String)]"))
-            .in(componentFile).onLine(10);
+            String.format(
+                MSGS.manyMethodsForType(),
+                "test.TestModule",
+                "[set1(test.TestModule), set2(test.TestModule)]"))
+        .in(componentFile)
+        .onLine(11);
   }
 
   @Test
   public void testMultipleSettersPerTypeIncludingResolvedGenericsFails() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "abstract class SimpleComponent {",
-        "  interface Parent<T> {",
-        "    void set1(T t);",
-        "  }",
-        "",
-        "  @Component.Builder",
-        "  interface Builder extends Parent<String> {",
-        "    SimpleComponent build();",
-        "    void set2(String s);",
-        "  }",
-        "}");
-    assertAbout(javaSource()).that(componentFile)
+    JavaFileObject moduleFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "final class TestModule {",
+            "  @Provides String s() { return \"\"; }",
+            "}");
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component(modules = TestModule.class)",
+            "abstract class SimpleComponent {",
+            "  abstract String s();",
+            "",
+            "  interface Parent<T> {",
+            "    void set1(T t);",
+            "  }",
+            "",
+            "  @Component.Builder",
+            "  interface Builder extends Parent<TestModule> {",
+            "    SimpleComponent build();",
+            "    void set2(TestModule s);",
+            "  }",
+            "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(moduleFile, componentFile))
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(
-            String.format(MSGS.manyMethodsForType(),
-                  "java.lang.String", "[set1(T), set2(java.lang.String)]"))
-            .in(componentFile).onLine(14);
+            String.format(
+                MSGS.manyMethodsForType(), "test.TestModule", "[set1(T), set2(test.TestModule)]"))
+        .in(componentFile)
+        .onLine(15);
   }
 
   @Test
@@ -874,61 +986,71 @@ public void testExtraSettersFails() {
 
   @Test
   public void testMissingSettersFail() {
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "",
-        "@Module",
-        "final class TestModule {",
-        "  TestModule(String unused) {}",
-        "  @Provides String s() { return null; }",
-        "}");
-    JavaFileObject module2File = JavaFileObjects.forSourceLines("test.Test2Module",
-        "package test;",
-        "",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "",
-        "@Module",
-        "final class Test2Module {",
-        "  @Provides Integer i() { return null; }",
-        "}");
-    JavaFileObject module3File = JavaFileObjects.forSourceLines("test.Test3Module",
-        "package test;",
-        "",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "",
-        "@Module",
-        "final class Test3Module {",
-        "  Test3Module(String unused) {}",
-        "  @Provides Double d() { return null; }",
-        "}");
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "",
-        "@Component(modules = {TestModule.class, Test2Module.class, Test3Module.class},",
-        "           dependencies = OtherComponent.class)",
-        "interface TestComponent {",
-        "  String string();",
-        "  Integer integer();",
-        "",
-        "  @Component.Builder",
-        "  interface Builder {",
-        "    TestComponent create();",
-        "  }",
-        "}");
-    JavaFileObject otherComponent = JavaFileObjects.forSourceLines("test.OtherComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "",
-        "@Component",
-        "interface OtherComponent {}");
+    JavaFileObject moduleFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "final class TestModule {",
+            "  TestModule(String unused) {}",
+            "  @Provides String s() { return null; }",
+            "}");
+    JavaFileObject module2File =
+        JavaFileObjects.forSourceLines(
+            "test.Test2Module",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "final class Test2Module {",
+            "  @Provides Integer i() { return null; }",
+            "}");
+    JavaFileObject module3File =
+        JavaFileObjects.forSourceLines(
+            "test.Test3Module",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "final class Test3Module {",
+            "  Test3Module(String unused) {}",
+            "  @Provides Double d() { return null; }",
+            "}");
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = {TestModule.class, Test2Module.class, Test3Module.class},",
+            "           dependencies = OtherComponent.class)",
+            "interface TestComponent {",
+            "  String string();",
+            "  Integer integer();",
+            "",
+            "  @Component.Builder",
+            "  interface Builder {",
+            "    TestComponent create();",
+            "  }",
+            "}");
+    JavaFileObject otherComponent =
+        JavaFileObjects.forSourceLines(
+            "test.OtherComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface OtherComponent {}");
     assertAbout(javaSources())
         .that(ImmutableList.of(moduleFile, module2File, module3File, componentFile, otherComponent))
         .processedWith(new ComponentProcessor())
@@ -936,8 +1058,174 @@ public void testMissingSettersFail() {
         .withErrorContaining(
             // Ignores Test2Module because we can construct it ourselves.
             // TODO(sameb): Ignore Test3Module because it's not used within transitive dependencies.
-            String.format(MSGS.missingSetters(),
-                "[test.TestModule, test.Test3Module, test.OtherComponent]"))
-            .in(componentFile).onLine(12);
+            String.format(
+                MSGS.missingSetters(), "[test.TestModule, test.Test3Module, test.OtherComponent]"))
+        .in(componentFile)
+        .onLine(12);
+  }
+
+  @Test
+  public void covariantBuildMethodReturnType() {
+    JavaFileObject foo =
+        JavaFileObjects.forSourceLines(
+            "test.Foo",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class Foo {",
+            "  @Inject Foo() {}",
+            "}");
+    JavaFileObject supertype =
+        JavaFileObjects.forSourceLines(
+            "test.Supertype",
+            "package test;",
+            "",
+            "interface Supertype {",
+            "  Foo foo();",
+            "}");
+
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.HasSupertype",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface HasSupertype extends Supertype {",
+            "  @Component.Builder",
+            "  interface Builder {",
+            "    Supertype build();",
+            "  }",
+            "}");
+
+    Compilation compilation = daggerCompiler().compile(foo, supertype, component);
+    assertThat(compilation).succeededWithoutWarnings();
+  }
+
+  @Test
+  public void covariantBuildMethodReturnType_hasNewMethod() {
+    JavaFileObject foo =
+        JavaFileObjects.forSourceLines(
+            "test.Foo",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class Foo {",
+            "  @Inject Foo() {}",
+            "}");
+    JavaFileObject bar =
+        JavaFileObjects.forSourceLines(
+            "test.Bar",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class Bar {",
+            "  @Inject Bar() {}",
+            "}");
+    JavaFileObject supertype =
+        JavaFileObjects.forSourceLines(
+            "test.Supertype",
+            "package test;",
+            "",
+            "interface Supertype {",
+            "  Foo foo();",
+            "}");
+
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.HasSupertype",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface HasSupertype extends Supertype {",
+            "  Bar bar();",
+            "",
+            "  @Component.Builder",
+            "  interface Builder {",
+            "    Supertype build();",
+            "  }",
+            "}");
+
+    Compilation compilation = daggerCompiler().compile(foo, bar, supertype, component);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .hadWarningContaining(
+            "test.HasSupertype.Builder.build() returns test.Supertype, but test.HasSupertype "
+                + "declares additional component method(s): bar(). In order to provide type-safe "
+                + "access to these methods, override build() to return test.HasSupertype")
+        .inFile(component)
+        .onLine(11);
+  }
+
+  @Test
+  public void covariantBuildMethodReturnType_hasNewMethod_buildMethodInherited() {
+    JavaFileObject foo =
+        JavaFileObjects.forSourceLines(
+            "test.Foo",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class Foo {",
+            "  @Inject Foo() {}",
+            "}");
+    JavaFileObject bar =
+        JavaFileObjects.forSourceLines(
+            "test.Bar",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class Bar {",
+            "  @Inject Bar() {}",
+            "}");
+    JavaFileObject supertype =
+        JavaFileObjects.forSourceLines(
+            "test.Supertype",
+            "package test;",
+            "",
+            "interface Supertype {",
+            "  Foo foo();",
+            "}");
+
+    JavaFileObject builderSupertype =
+        JavaFileObjects.forSourceLines(
+            "test.BuilderSupertype",
+            "package test;",
+            "",
+            "interface BuilderSupertype {",
+            "  Supertype build();",
+            "}");
+
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.HasSupertype",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface HasSupertype extends Supertype {",
+            "  Bar bar();",
+            "",
+            "  @Component.Builder",
+            "  interface Builder extends BuilderSupertype {}",
+            "}");
+
+    Compilation compilation =
+        daggerCompiler().compile(foo, bar, supertype, builderSupertype, component);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .hadWarningContaining(
+            "[test.BuilderSupertype.build()] test.HasSupertype.Builder.build() returns "
+                + "test.Supertype, but test.HasSupertype declares additional component method(s): "
+                + "bar(). In order to provide type-safe access to these methods, override build() "
+                + "to return test.HasSupertype");
   }
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/ComponentHierarchyValidatorTest.java b/compiler/src/test/java/dagger/internal/codegen/ComponentHierarchyValidatorTest.java
new file mode 100644
index 000000000..db2702f58
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/ComponentHierarchyValidatorTest.java
@@ -0,0 +1,124 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.testing.compile.JavaSourcesSubject.assertThat;
+
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/** Tests for {ComponentHierarchyValidator}. */
+@RunWith(JUnit4.class)
+public class ComponentHierarchyValidatorTest {
+  @Test
+  public void singletonSubcomponent() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.Parent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Singleton;",
+            "",
+            "@Singleton",
+            "@Component",
+            "interface Parent {",
+            "  Child child();",
+            "}");
+    JavaFileObject subcomponent =
+        JavaFileObjects.forSourceLines(
+            "test.Child",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "import javax.inject.Singleton;",
+            "",
+            "@Singleton",
+            "@Subcomponent",
+            "interface Child {}");
+
+    assertThat(component, subcomponent)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("conflicting scopes")
+        .and().withErrorContaining("test.Parent also has @Singleton");
+
+    assertThat(component, subcomponent)
+        .withCompilerOptions("-Adagger.disableInterComponentScopeValidation=none")
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError();
+  }
+  
+  @Test
+  public void productionComponents_productionScopeImplicitOnBoth() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.Parent",
+            "package test;",
+            "",
+            "import dagger.producers.ProductionComponent;",
+            "",
+            "@ProductionComponent(modules = ParentModule.class)",
+            "interface Parent {",
+            "  Child child();",
+            "  Object productionScopedObject();",
+            "}");
+    JavaFileObject parentModule =
+        JavaFileObjects.forSourceLines(
+            "test.ParentModule",
+            "package test;",
+            "",
+            "import dagger.Provides;",
+            "import dagger.producers.ProducerModule;",
+            "import dagger.producers.ProductionScope;",
+            "",
+            "@ProducerModule",
+            "class ParentModule {",
+            "  @Provides @ProductionScope Object parentScopedObject() { return new Object(); }",
+            "}");
+    JavaFileObject subcomponent =
+        JavaFileObjects.forSourceLines(
+            "test.Child",
+            "package test;",
+            "",
+            "import dagger.producers.ProductionSubcomponent;",
+            "",
+            "@ProductionSubcomponent(modules = ChildModule.class)",
+            "interface Child {",
+            "  String productionScopedString();",
+            "}");
+    JavaFileObject childModule =
+        JavaFileObjects.forSourceLines(
+            "test.ChildModule",
+            "package test;",
+            "",
+            "import dagger.Provides;",
+            "import dagger.producers.ProducerModule;",
+            "import dagger.producers.ProductionScope;",
+            "",
+            "@ProducerModule",
+            "class ChildModule {",
+            "  @Provides @ProductionScope String childScopedString() { return new String(); }",
+            "}");
+    assertThat(component, subcomponent, parentModule, childModule)
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError();
+  }
+}
diff --git a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
index 9dfe0a6c6..74e1b9e57 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Google, Inc.
+ * Copyright (C) 2014 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,15 +13,22 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal.codegen;
 
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static com.google.testing.compile.Compiler.javac;
+import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
+
 import com.google.auto.common.MoreElements;
 import com.google.common.base.Joiner;
 import com.google.common.base.Predicate;
 import com.google.common.base.Predicates;
-import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Lists;
 import com.google.common.collect.Sets;
+import com.google.testing.compile.Compilation;
+import com.google.testing.compile.Compiler;
 import com.google.testing.compile.JavaFileObjects;
 import com.squareup.javapoet.CodeBlock;
 import dagger.MembersInjector;
@@ -43,13 +50,6 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import static com.google.common.truth.Truth.assertAbout;
-import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
-import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
-import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
-import static java.util.Arrays.asList;
-import static javax.tools.StandardLocation.SOURCE_OUTPUT;
-
 @RunWith(JUnit4.class)
 public class ComponentProcessorTest {
   private static final CodeBlock NPE_LITERAL =
@@ -63,10 +63,9 @@
         "",
         "@Component",
         "final class NotAComponent {}");
-    assertAbout(javaSource()).that(componentFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("interface");
+    Compilation compilation = daggerCompiler().compile(componentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining("interface");
   }
 
   @Test public void componentOnEnum() {
@@ -79,10 +78,9 @@
         "enum NotAComponent {",
         "  INSTANCE",
         "}");
-    assertAbout(javaSource()).that(componentFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("interface");
+    Compilation compilation = daggerCompiler().compile(componentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining("interface");
   }
 
   @Test public void componentOnAnnotation() {
@@ -93,10 +91,9 @@
         "",
         "@Component",
         "@interface NotAComponent {}");
-    assertAbout(javaSource()).that(componentFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("interface");
+    Compilation compilation = daggerCompiler().compile(componentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining("interface");
   }
 
   @Test public void nonModuleModule() {
@@ -107,10 +104,41 @@
         "",
         "@Component(modules = Object.class)",
         "interface NotAComponent {}");
-    assertAbout(javaSource()).that(componentFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("is not annotated with @Module");
+    Compilation compilation = daggerCompiler().compile(componentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining("is not annotated with @Module");
+  }
+
+  @Test
+  public void componentWithInvalidModule() {
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.BadModule",
+            "package test;",
+            "",
+            "import dagger.Binds;",
+            "import dagger.Module;",
+            "",
+            "@Module",
+            "abstract class BadModule {",
+            "  @Binds abstract Object noParameters();",
+            "}");
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.BadComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = BadModule.class)",
+            "interface BadComponent {",
+            "  Object object();",
+            "}");
+    Compilation compilation = daggerCompiler().compile(module, component);
+    assertThat(compilation)
+        .hadErrorContaining("test.BadModule has errors")
+        .inFile(component)
+        .onLine(5);
   }
 
   @Test public void doubleBindingFromResolvedModules() {
@@ -156,14 +184,15 @@
         "interface BadComponent {",
         "  List<Integer> listOfInteger();",
         "}");
-    assertAbout(javaSources()).that(ImmutableList.of(parent, child, another, componentFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile().withErrorContaining(
-            "java.util.List<java.lang.Integer> is bound multiple times")
-        .and().withErrorContaining(
-            "@Provides List<Integer> test.ChildNumberModule.provideListB(Integer)")
-        .and().withErrorContaining(
-            "@Provides List<Integer> test.AnotherModule.provideListOfInteger()");
+
+    Compilation compilation = daggerCompiler().compile(parent, child, another, componentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("java.util.List<java.lang.Integer> is bound multiple times");
+    assertThat(compilation)
+        .hadErrorContaining("@Provides List<Integer> test.ChildNumberModule.provideListB(Integer)");
+    assertThat(compilation)
+        .hadErrorContaining("@Provides List<Integer> test.AnotherModule.provideListOfInteger()");
   }
 
   @Test public void privateNestedClassWithWarningThatIsAnErrorInComponent() {
@@ -188,11 +217,13 @@
         "interface BadComponent {",
         "  OuterClass outerClass();",
         "}");
-    assertAbout(javaSources()).that(ImmutableList.of(outerClass, componentFile))
-        .withCompilerOptions("-Adagger.privateMemberValidation=WARNING")
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("Dagger does not support injection into private classes");
+    Compilation compilation =
+        daggerCompiler()
+            .withOptions("-Adagger.privateMemberValidation=WARNING")
+            .compile(outerClass, componentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("Dagger does not support injection into private classes");
   }
 
   @Test public void simpleComponent() {
@@ -209,7 +240,6 @@
         "",
         "import dagger.Component;",
         "import dagger.Lazy;",
-        "",
         "import javax.inject.Provider;",
         "",
         "@Component",
@@ -239,12 +269,12 @@
             "  }",
             "",
             "  public static SimpleComponent create() {",
-            "    return builder().build();",
+            "    return new Builder().build();",
             "  }",
             "",
             "  @Override",
             "  public SomeInjectableType someInjectableType() {",
-            "    return SomeInjectableType_Factory.create().get();",
+            "    return new SomeInjectableType();",
             "  }",
             "",
             "  @Override",
@@ -266,10 +296,11 @@
             "    }",
             "  }",
             "}");
-    assertAbout(javaSources()).that(ImmutableList.of(injectableTypeFile, componentFile))
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError()
-        .and().generatesSources(generatedComponent);
+    Compilation compilation = daggerCompiler().compile(injectableTypeFile, componentFile);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerSimpleComponent")
+        .hasSourceEquivalentTo(generatedComponent);
   }
 
   @Test public void componentWithScope() {
@@ -322,7 +353,7 @@
             "  }",
             "",
             "  public static SimpleComponent create() {",
-            "    return builder().build();",
+            "    return new Builder().build();",
             "  }",
             "",
             "  @SuppressWarnings(\"unchecked\")",
@@ -355,10 +386,11 @@
             "    }",
             "  }",
             "}");
-    assertAbout(javaSources()).that(ImmutableList.of(injectableTypeFile, componentFile))
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError()
-        .and().generatesSources(generatedComponent);
+    Compilation compilation = daggerCompiler().compile(injectableTypeFile, componentFile);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerSimpleComponent")
+        .hasSourceEquivalentTo(generatedComponent);
   }
 
   @Test public void simpleComponentWithNesting() {
@@ -381,59 +413,62 @@
         "  }",
         "}");
 
-    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
-        "test.DaggerOuterType_SimpleComponent",
-        "package test;",
-        "",
-        "import dagger.MembersInjector;",
-        "import javax.annotation.Generated;",
-        "",
-        GENERATED_ANNOTATION,
-        "public final class DaggerOuterType_SimpleComponent implements OuterType.SimpleComponent {",
-        "  private MembersInjector<OuterType.B> bMembersInjector;",
-        "",
-        "  private DaggerOuterType_SimpleComponent(Builder builder) {",
-        "    assert builder != null;",
-        "    initialize(builder);",
-        "  }",
-        "",
-        "  public static Builder builder() {",
-        "    return new Builder();",
-        "  }",
-        "",
-        "  public static OuterType.SimpleComponent create() {",
-        "    return builder().build();",
-        "  }",
-        "",
-        "  @SuppressWarnings(\"unchecked\")",
-        "  private void initialize(final Builder builder) {",
-        "    this.bMembersInjector =",
-        "        OuterType_B_MembersInjector.create(OuterType_A_Factory.create());",
-        "  }",
-        "",
-        "  @Override",
-        "  public OuterType.A a() {",
-        "    return OuterType_A_Factory.create().get();",
-        "  }",
-        "",
-        "  @Override",
-        "  public void inject(OuterType.B b) {",
-        "    bMembersInjector.injectMembers(b);",
-        "  }",
-        "",
-        "  public static final class Builder {",
-        "    private Builder() {",
-        "    }",
-        "",
-        "    public OuterType.SimpleComponent build() {",
-        "      return new DaggerOuterType_SimpleComponent(this);",
-        "    }",
-        "  }",
-        "}");
-    assertAbout(javaSources()).that(ImmutableList.of(nestedTypesFile))
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError()
-        .and().generatesSources(generatedComponent);
+    JavaFileObject generatedComponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerOuterType_SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.MembersInjector;",
+            "import javax.annotation.Generated;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerOuterType_SimpleComponent",
+            "    implements OuterType.SimpleComponent {",
+            "  private MembersInjector<OuterType.B> bMembersInjector;",
+            "",
+            "  private DaggerOuterType_SimpleComponent(Builder builder) {",
+            "    assert builder != null;",
+            "    initialize(builder);",
+            "  }",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static OuterType.SimpleComponent create() {",
+            "    return new Builder().build();",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize(final Builder builder) {",
+            "    this.bMembersInjector =",
+            "        OuterType_B_MembersInjector.create(OuterType_A_Factory.create());",
+            "  }",
+            "",
+            "  @Override",
+            "  public OuterType.A a() {",
+            "    return new OuterType.A();",
+            "  }",
+            "",
+            "  @Override",
+            "  public void inject(OuterType.B b) {",
+            "    bMembersInjector.injectMembers(b);",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private Builder() {",
+            "    }",
+            "",
+            "    public OuterType.SimpleComponent build() {",
+            "      return new DaggerOuterType_SimpleComponent(this);",
+            "    }",
+            "  }",
+            "}");
+    Compilation compilation = daggerCompiler().compile(nestedTypesFile);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerOuterType_SimpleComponent")
+        .hasSourceEquivalentTo(generatedComponent);
   }
 
   @Test public void componentWithModule() {
@@ -473,75 +508,76 @@
         "package test;",
         "",
         "import dagger.Component;",
-        "",
         "import javax.inject.Provider;",
         "",
         "@Component(modules = TestModule.class)",
         "interface TestComponent {",
         "  A a();",
         "}");
-    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
-        "test.DaggerTestComponent",
-        "package test;",
-        "",
-        "import dagger.internal.Preconditions;",
-        "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
-        "",
-        GENERATED_ANNOTATION,
-        "public final class DaggerTestComponent implements TestComponent {",
-        "  private Provider<B> bProvider;",
-        "  private Provider<A> aProvider;",
-        "",
-        "  private DaggerTestComponent(Builder builder) {",
-        "    assert builder != null;",
-        "    initialize(builder);",
-        "  }",
-        "",
-        "  public static Builder builder() {",
-        "    return new Builder();",
-        "  }",
-        "",
-        "  public static TestComponent create() {",
-        "    return builder().build();",
-        "  }",
-        "",
-        "  @SuppressWarnings(\"unchecked\")",
-        "  private void initialize(final Builder builder) {",
-        "    this.bProvider = TestModule_BFactory.create(builder.testModule,",
-        "        C_Factory.create());",
-        "    this.aProvider = A_Factory.create(bProvider);",
-        "  }",
-        "",
-        "  @Override",
-        "  public A a() {",
-        "    return aProvider.get();",
-        "  }",
-        "",
-        "  public static final class Builder {",
-        "    private TestModule testModule;",
-        "",
-        "    private Builder() {",
-        "    }",
-        "",
-        "    public TestComponent build() {",
-        "      if (testModule == null) {",
-        "        this.testModule = new TestModule();",
-        "      }",
-        "      return new DaggerTestComponent(this);",
-        "    }",
-        "",
-        "    public Builder testModule(TestModule testModule) {",
-        "      this.testModule = Preconditions.checkNotNull(testModule);",
-        "      return this;",
-        "    }",
-        "  }",
-        "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(aFile, bFile, cFile, moduleFile, componentFile))
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError()
-        .and().generatesSources(generatedComponent);
+    JavaFileObject generatedComponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerTestComponent",
+            "package test;",
+            "",
+            "import dagger.internal.Preconditions;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerTestComponent implements TestComponent {",
+            "  private Provider<B> bProvider;",
+            "  private Provider<A> aProvider;",
+            "",
+            "  private DaggerTestComponent(Builder builder) {",
+            "    assert builder != null;",
+            "    initialize(builder);",
+            "  }",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static TestComponent create() {",
+            "    return new Builder().build();",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize(final Builder builder) {",
+            "    this.bProvider = TestModule_BFactory.create(builder.testModule,",
+            "        C_Factory.create());",
+            "    this.aProvider = A_Factory.create(bProvider);",
+            "  }",
+            "",
+            "  @Override",
+            "  public A a() {",
+            "    return new A(bProvider.get());",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private TestModule testModule;",
+            "",
+            "    private Builder() {",
+            "    }",
+            "",
+            "    public TestComponent build() {",
+            "      if (testModule == null) {",
+            "        this.testModule = new TestModule();",
+            "      }",
+            "      return new DaggerTestComponent(this);",
+            "    }",
+            "",
+            "    public Builder testModule(TestModule testModule) {",
+            "      this.testModule = Preconditions.checkNotNull(testModule);",
+            "      return this;",
+            "    }",
+            "  }",
+            "}");
+    Compilation compilation =
+        daggerCompiler().compile(aFile, bFile, cFile, moduleFile, componentFile);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerTestComponent")
+        .hasSourceEquivalentTo(generatedComponent);
   }
 
   @Test
@@ -591,7 +627,6 @@ public void componentWithAbstractModule() {
             "package test;",
             "",
             "import dagger.Component;",
-            "",
             "import javax.inject.Provider;",
             "",
             "@Component(modules = TestModule.class)",
@@ -621,7 +656,7 @@ public void componentWithAbstractModule() {
             "  }",
             "",
             "  public static TestComponent create() {",
-            "    return builder().build();",
+            "    return new Builder().build();",
             "  }",
             "",
             "  @SuppressWarnings(\"unchecked\")",
@@ -632,7 +667,7 @@ public void componentWithAbstractModule() {
             "",
             "  @Override",
             "  public A a() {",
-            "    return aProvider.get();",
+            "    return new A(TestModule.b(new C()));",
             "  }",
             "",
             "  public static final class Builder {",
@@ -645,12 +680,12 @@ public void componentWithAbstractModule() {
             "    }",
             "  }",
             "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(aFile, bFile, cFile, moduleFile, componentFile))
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError()
-        .and()
-        .generatesSources(generatedComponent);
+    Compilation compilation =
+        daggerCompiler().compile(aFile, bFile, cFile, moduleFile, componentFile);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerTestComponent")
+        .hasSourceEquivalentTo(generatedComponent);
   }
 
   @Test public void transitiveModuleDeps() {
@@ -715,7 +750,6 @@ public void componentWithAbstractModule() {
         "package test;",
         "",
         "import dagger.Component;",
-        "",
         "import javax.inject.Provider;",
         "",
         "@Component(modules = TestModule.class)",
@@ -742,7 +776,7 @@ public void componentWithAbstractModule() {
         "  }",
         "",
         "  public static TestComponent create() {",
-        "    return builder().build();",
+        "    return new Builder().build();",
         "  }",
         "",
         "  public static final class Builder {",
@@ -790,19 +824,22 @@ public void componentWithAbstractModule() {
         "    }",
         "  }",
         "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(always,
-            testModule,
-            parentTest,
-            parentTestIncluded,
-            depModule,
-            refByDep,
-            parentDep,
-            parentDepIncluded,
-            componentFile))
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError()
-        .and().generatesSources(generatedComponent);
+    Compilation compilation =
+        daggerCompiler()
+            .compile(
+                always,
+                testModule,
+                parentTest,
+                parentTestIncluded,
+                depModule,
+                refByDep,
+                parentDep,
+                parentDepIncluded,
+                componentFile);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerTestComponent")
+        .hasSourceEquivalentTo(generatedComponent);
   }
 
   @Test
@@ -821,23 +858,19 @@ public void generatedTransitiveModule() {
         "",
         "@Component(modules = RootModule.class)",
         "interface TestComponent {}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(rootModule, component))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile();
-    assertAbout(javaSources())
-        .that(ImmutableList.of(rootModule, component))
-        .processedWith(
-            new ComponentProcessor(),
-            new GeneratingProcessor(
-                "test.GeneratedModule",
-                "package test;",
-                "",
-                "import dagger.Module;",
-                "",
-                "@Module",
-                "final class GeneratedModule {}"))
-        .compilesWithoutError();
+    assertThat(daggerCompiler().compile(rootModule, component)).failed();
+    assertThat(
+            daggerCompiler(
+                    new GeneratingProcessor(
+                        "test.GeneratedModule",
+                        "package test;",
+                        "",
+                        "import dagger.Module;",
+                        "",
+                        "@Module",
+                        "final class GeneratedModule {}"))
+                .compile(rootModule, component))
+        .succeeded();
   }
 
   @Test
@@ -862,23 +895,19 @@ public void generatedModuleInSubcomponent() {
             "interface TestComponent {",
             "  ChildComponent childComponent();",
             "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(subcomponent, component))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile();
-    assertAbout(javaSources())
-        .that(ImmutableList.of(subcomponent, component))
-        .processedWith(
-            new ComponentProcessor(),
-            new GeneratingProcessor(
-                "test.GeneratedModule",
-                "package test;",
-                "",
-                "import dagger.Module;",
-                "",
-                "@Module",
-                "final class GeneratedModule {}"))
-        .compilesWithoutError();
+    assertThat(daggerCompiler().compile(subcomponent, component)).failed();
+    assertThat(
+            daggerCompiler(
+                    new GeneratingProcessor(
+                        "test.GeneratedModule",
+                        "package test;",
+                        "",
+                        "import dagger.Module;",
+                        "",
+                        "@Module",
+                        "final class GeneratedModule {}"))
+                .compile(subcomponent, component))
+        .succeeded();
   }
 
   @Test
@@ -957,7 +986,7 @@ public void subcomponentOmitsInheritedBindings() {
             "  }",
             "",
             "  public static Parent create() {",
-            "    return builder().build();",
+            "    return new Builder().build();",
             "  }",
             "",
             "  @SuppressWarnings(\"unchecked\")",
@@ -1022,59 +1051,147 @@ public void subcomponentOmitsInheritedBindings() {
             "    }",
             "  }",
             "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(parent, parentModule, child))
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError()
-        .and()
-        .generatesSources(expected);
+    Compilation compilation = daggerCompiler().compile(parent, parentModule, child);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerParent")
+        .hasSourceEquivalentTo(expected);
   }
 
-  @Test public void testDefaultPackage() {
-    JavaFileObject aClass = JavaFileObjects.forSourceLines("AClass", "class AClass {}");
-    JavaFileObject bClass = JavaFileObjects.forSourceLines("BClass",
-        "import javax.inject.Inject;",
-        "",
-        "class BClass {",
-        "  @Inject BClass(AClass a) {}",
-        "}");
-    JavaFileObject aModule = JavaFileObjects.forSourceLines("AModule",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "",
-        "@Module class AModule {",
-        "  @Provides AClass aClass() {",
-        "    return new AClass();",
-        "  }",
-        "}");
-    JavaFileObject component = JavaFileObjects.forSourceLines("SomeComponent",
-        "import dagger.Component;",
-        "",
-        "@Component(modules = AModule.class)",
-        "interface SomeComponent {",
-        "  BClass bClass();",
-        "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(aModule, aClass, bClass, component))
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError();
-  }
+  @Test
+  public void subcomponentNotGeneratedIfNotUsedInGraph() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.Parent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = ParentModule.class)",
+            "interface Parent {",
+            "  String notSubcomponent();",
+            "}");
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.Parent",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module(subcomponents = Child.class)",
+            "class ParentModule {",
+            "  @Provides static String notSubcomponent() { return new String(); }",
+            "}");
 
-  @Test public void setBindings() {
-    JavaFileObject emptySetModuleFile = JavaFileObjects.forSourceLines("test.EmptySetModule",
-        "package test;",
-        "",
-        "import static dagger.Provides.Type.SET_VALUES;",
-        "",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "import dagger.multibindings.ElementsIntoSet;",
-        "import java.util.Collections;",
-        "import java.util.Set;",
-        "",
-        "@Module",
-        "final class EmptySetModule {",
-        "  @Provides @ElementsIntoSet Set<String> emptySet() { return Collections.emptySet(); }",
+    JavaFileObject subcomponent =
+        JavaFileObjects.forSourceLines(
+            "test.Child",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent",
+            "interface Child {",
+            "  @Subcomponent.Builder",
+            "  interface Builder {",
+            "    Child build();",
+            "  }",
+            "}");
+
+    JavaFileObject generatedComponentWithoutSubcomponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerParent",
+            "package test;",
+            "",
+            "import dagger.internal.Preconditions;",
+            "import javax.annotation.Generated;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerParent implements Parent {",
+            "",
+            "  private DaggerParent(Builder builder) {",
+            "    assert builder != null;",
+            "  }",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static Parent create() {",
+            "    return new Builder().build();",
+            "  }",
+            "",
+            "  @Override",
+            "  public String notSubcomponent() {",
+            "    return ParentModule.notSubcomponent();",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "",
+            "    private Builder() {",
+            "    }",
+            "",
+            "    public Parent build() {",
+            "      return new DaggerParent(this);",
+            "    }",
+            "",
+            "    @Deprecated",
+            "    public Builder parentModule(ParentModule parentModule) {",
+            "      Preconditions.checkNotNull(parentModule);",
+            "      return this;",
+            "    }",
+            "  }",
+            "}");
+
+    Compilation compilation = daggerCompiler().compile(component, module, subcomponent);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerParent")
+        .hasSourceEquivalentTo(generatedComponentWithoutSubcomponent);
+  }
+
+  @Test
+  public void testDefaultPackage() {
+    JavaFileObject aClass = JavaFileObjects.forSourceLines("AClass", "class AClass {}");
+    JavaFileObject bClass = JavaFileObjects.forSourceLines("BClass",
+        "import javax.inject.Inject;",
+        "",
+        "class BClass {",
+        "  @Inject BClass(AClass a) {}",
+        "}");
+    JavaFileObject aModule = JavaFileObjects.forSourceLines("AModule",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module class AModule {",
+        "  @Provides AClass aClass() {",
+        "    return new AClass();",
+        "  }",
+        "}");
+    JavaFileObject component = JavaFileObjects.forSourceLines("SomeComponent",
+        "import dagger.Component;",
+        "",
+        "@Component(modules = AModule.class)",
+        "interface SomeComponent {",
+        "  BClass bClass();",
+        "}");
+    assertThat(daggerCompiler().compile(aModule, aClass, bClass, component)).succeeded();
+  }
+
+  @Test public void setBindings() {
+    JavaFileObject emptySetModuleFile = JavaFileObjects.forSourceLines("test.EmptySetModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import dagger.multibindings.ElementsIntoSet;",
+        "import java.util.Collections;",
+        "import java.util.Set;",
+        "",
+        "@Module",
+        "final class EmptySetModule {",
+        "  @Provides @ElementsIntoSet Set<String> emptySet() { return Collections.emptySet(); }",
         "}");
     JavaFileObject setModuleFile = JavaFileObjects.forSourceLines("test.SetModule",
         "package test;",
@@ -1092,7 +1209,6 @@ public void subcomponentOmitsInheritedBindings() {
         "",
         "import dagger.Component;",
         "import java.util.Set;",
-        "",
         "import javax.inject.Provider;",
         "",
         "@Component(modules = {EmptySetModule.class, SetModule.class})",
@@ -1126,7 +1242,7 @@ public void subcomponentOmitsInheritedBindings() {
             "  }",
             "",
             "  public static TestComponent create() {",
-            "    return builder().build();",
+            "    return new Builder().build();",
             "  }",
             "",
             "  @SuppressWarnings(\"unchecked\")",
@@ -1175,11 +1291,12 @@ public void subcomponentOmitsInheritedBindings() {
             "    }",
             "  }",
             "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(emptySetModuleFile, setModuleFile, componentFile))
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError()
-        .and().generatesSources(generatedComponent);
+    Compilation compilation =
+        daggerCompiler().compile(emptySetModuleFile, setModuleFile, componentFile);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerTestComponent")
+        .hasSourceEquivalentTo(generatedComponent);
   }
 
   @Test public void membersInjection() {
@@ -1205,7 +1322,6 @@ public void subcomponentOmitsInheritedBindings() {
         "",
         "import dagger.Component;",
         "import dagger.Lazy;",
-        "",
         "import javax.inject.Provider;",
         "",
         "@Component",
@@ -1234,7 +1350,7 @@ public void subcomponentOmitsInheritedBindings() {
         "  }",
         "",
         "  public static SimpleComponent create() {",
-        "    return builder().build();",
+        "    return new Builder().build();",
         "  }",
         "",
         "  @SuppressWarnings(\"unchecked\")",
@@ -1263,11 +1379,12 @@ public void subcomponentOmitsInheritedBindings() {
         "    }",
         "  }",
         "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(injectableTypeFile, injectedTypeFile, componentFile))
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError()
-        .and().generatesSources(generatedComponent);
+    Compilation compilation =
+        daggerCompiler().compile(injectableTypeFile, injectedTypeFile, componentFile);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerSimpleComponent")
+        .hasSourceEquivalentTo(generatedComponent);
   }
 
   @Test public void componentInjection() {
@@ -1284,64 +1401,65 @@ public void subcomponentOmitsInheritedBindings() {
         "",
         "import dagger.Component;",
         "import dagger.Lazy;",
-        "",
         "import javax.inject.Provider;",
         "",
         "@Component",
         "interface SimpleComponent {",
         "  SomeInjectableType someInjectableType();",
         "}");
-    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
-        "test.DaggerSimpleComponent",
-        "package test;",
-        "",
-        "import dagger.internal.InstanceFactory;",
-        "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
-        "",
-        GENERATED_ANNOTATION,
-        "public final class DaggerSimpleComponent implements SimpleComponent {",
-        "  private Provider<SimpleComponent> simpleComponentProvider;",
-        "  private Provider<SomeInjectableType> someInjectableTypeProvider;",
-        "",
-        "  private DaggerSimpleComponent(Builder builder) {",
-        "    assert builder != null;",
-        "    initialize(builder);",
-        "  }",
-        "",
-        "  public static Builder builder() {",
-        "    return new Builder();",
-        "  }",
-        "",
-        "  public static SimpleComponent create() {",
-        "    return builder().build();",
-        "  }",
-        "",
-        "  @SuppressWarnings(\"unchecked\")",
-        "  private void initialize(final Builder builder) {",
-        "    this.simpleComponentProvider = InstanceFactory.<SimpleComponent>create(this);",
-        "    this.someInjectableTypeProvider =",
-        "        SomeInjectableType_Factory.create(simpleComponentProvider);",
-        "  }",
-        "",
-        "  @Override",
-        "  public SomeInjectableType someInjectableType() {",
-        "    return someInjectableTypeProvider.get();",
-        "  }",
-        "",
-        "  public static final class Builder {",
-        "    private Builder() {",
-        "    }",
-        "",
-        "    public SimpleComponent build() {",
-        "      return new DaggerSimpleComponent(this);",
-        "    }",
-        "  }",
-        "}");
-    assertAbout(javaSources()).that(ImmutableList.of(injectableTypeFile, componentFile))
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError()
-        .and().generatesSources(generatedComponent);
+    JavaFileObject generatedComponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerSimpleComponent",
+            "package test;",
+            "",
+            "import dagger.internal.InstanceFactory;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerSimpleComponent implements SimpleComponent {",
+            "  private Provider<SimpleComponent> simpleComponentProvider;",
+            "  private Provider<SomeInjectableType> someInjectableTypeProvider;",
+            "",
+            "  private DaggerSimpleComponent(Builder builder) {",
+            "    assert builder != null;",
+            "    initialize(builder);",
+            "  }",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static SimpleComponent create() {",
+            "    return new Builder().build();",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize(final Builder builder) {",
+            "    this.simpleComponentProvider = InstanceFactory.<SimpleComponent>create(this);",
+            "    this.someInjectableTypeProvider =",
+            "        SomeInjectableType_Factory.create(simpleComponentProvider);",
+            "  }",
+            "",
+            "  @Override",
+            "  public SomeInjectableType someInjectableType() {",
+            "    return new SomeInjectableType(simpleComponentProvider.get())",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private Builder() {",
+            "    }",
+            "",
+            "    public SimpleComponent build() {",
+            "      return new DaggerSimpleComponent(this);",
+            "    }",
+            "  }",
+            "}");
+    Compilation compilation = daggerCompiler().compile(injectableTypeFile, componentFile);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerSimpleComponent")
+        .hasSourceEquivalentTo(generatedComponent);
   }
 
   @Test public void membersInjectionInsideProvision() {
@@ -1394,7 +1512,7 @@ public void subcomponentOmitsInheritedBindings() {
         "  }",
         "",
         "  public static SimpleComponent create() {",
-        "    return builder().build();",
+        "    return new Builder().build();",
         "  }",
         "",
         "  @SuppressWarnings(\"unchecked\")",
@@ -1419,11 +1537,12 @@ public void subcomponentOmitsInheritedBindings() {
         "    }",
         "  }",
         "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(injectableTypeFile, injectedTypeFile, componentFile))
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError()
-        .and().generatesSources(generatedComponent);
+    Compilation compilation =
+        daggerCompiler().compile(injectableTypeFile, injectedTypeFile, componentFile);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerSimpleComponent")
+        .hasSourceEquivalentTo(generatedComponent);
   }
 
   @Test public void injectionWithGenericBaseClass() {
@@ -1471,7 +1590,7 @@ public void subcomponentOmitsInheritedBindings() {
         "  }",
         "",
         "  public static SimpleComponent create() {",
-        "    return builder().build();",
+        "    return new Builder().build();",
         "  }",
         "",
         "  @SuppressWarnings(\"unchecked\")",
@@ -1494,11 +1613,12 @@ public void subcomponentOmitsInheritedBindings() {
         "    }",
         "  }",
         "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(genericType, injectableTypeFile, componentFile))
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError()
-        .and().generatesSources(generatedComponent);
+    Compilation compilation =
+        daggerCompiler().compile(genericType, injectableTypeFile, componentFile);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerSimpleComponent")
+        .hasSourceEquivalentTo(generatedComponent);
   }
 
   @Test public void componentDependency() {
@@ -1523,7 +1643,6 @@ public void subcomponentOmitsInheritedBindings() {
         "",
         "import dagger.Component;",
         "import dagger.Lazy;",
-        "",
         "import javax.inject.Provider;",
         "",
         "@Component",
@@ -1535,101 +1654,101 @@ public void subcomponentOmitsInheritedBindings() {
         "",
         "import dagger.Component;",
         "import dagger.Lazy;",
-        "",
         "import javax.inject.Provider;",
         "",
         "@Component(dependencies = AComponent.class)",
         "interface BComponent {",
         "  B b();",
         "}");
-    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
-        "test.DaggerBComponent",
+    JavaFileObject generatedComponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerBComponent",
+            "package test;",
+            "",
+            "import dagger.internal.Preconditions;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerBComponent implements BComponent {",
+            "  private Provider<A> aProvider;",
+            "  private Provider<B> bProvider;",
+            "",
+            "  private DaggerBComponent(Builder builder) {",
+            "    assert builder != null;",
+            "    initialize(builder);",
+            "  }",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize(final Builder builder) {",
+            "    this.aProvider = new dagger.internal.Factory<A>() {",
+            "      private final AComponent aComponent = builder.aComponent;",
+            "      @Override public A get() {",
+            "        return Preconditions.checkNotNull(aComponent.a(), " + NPE_LITERAL + ");",
+            "      }",
+            "    };",
+            "    this.bProvider = B_Factory.create(aProvider);",
+            "  }",
+            "",
+            "  @Override",
+            "  public B b() {",
+            "    return new B(aProvider.get());",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private AComponent aComponent;",
+            "",
+            "    private Builder() {",
+            "    }",
+            "",
+            "    public BComponent build() {",
+            "      if (aComponent == null) {",
+            "        throw new IllegalStateException(AComponent.class.getCanonicalName()",
+            "            + \" must be set\");",
+            "      }",
+            "      return new DaggerBComponent(this);",
+            "    }",
+            "",
+            "    public Builder aComponent(AComponent aComponent) {",
+            "      this.aComponent = Preconditions.checkNotNull(aComponent);",
+            "      return this;",
+            "    }",
+            "  }",
+            "}");
+    Compilation compilation =
+        daggerCompiler().compile(aFile, bFile, aComponentFile, bComponentFile);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerBComponent")
+        .hasSourceEquivalentTo(generatedComponent);
+  }
+
+  @Test public void moduleNameCollision() {
+    JavaFileObject aFile = JavaFileObjects.forSourceLines("test.A",
         "package test;",
         "",
-        "import dagger.internal.Factory;",
-        "import dagger.internal.Preconditions;",
-        "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
+        "public final class A {}");
+    JavaFileObject otherAFile = JavaFileObjects.forSourceLines("other.test.A",
+        "package other.test;",
         "",
-        GENERATED_ANNOTATION,
-        "public final class DaggerBComponent implements BComponent {",
-        "  private Provider<A> aProvider;",
-        "  private Provider<B> bProvider;",
+        "public final class A {}");
+
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
         "",
-        "  private DaggerBComponent(Builder builder) {",
-        "    assert builder != null;",
-        "    initialize(builder);",
-        "  }",
+        "import dagger.Module;",
+        "import dagger.Provides;",
         "",
-        "  public static Builder builder() {",
-        "    return new Builder();",
-        "  }",
-        "",
-        "  @SuppressWarnings(\"unchecked\")",
-        "  private void initialize(final Builder builder) {",
-        "    this.aProvider = new Factory<A>() {",
-        "      private final AComponent aComponent = builder.aComponent;",
-        "      @Override public A get() {",
-        "        return Preconditions.checkNotNull(aComponent.a(), " + NPE_LITERAL + ");",
-        "      }",
-        "    };",
-        "    this.bProvider = B_Factory.create(aProvider);",
-        "  }",
-        "",
-        "  @Override",
-        "  public B b() {",
-        "    return bProvider.get();",
-        "  }",
-        "",
-        "  public static final class Builder {",
-        "    private AComponent aComponent;",
-        "",
-        "    private Builder() {",
-        "    }",
-        "",
-        "    public BComponent build() {",
-        "      if (aComponent == null) {",
-        "        throw new IllegalStateException(AComponent.class.getCanonicalName()",
-        "            + \" must be set\");",
-        "      }",
-        "      return new DaggerBComponent(this);",
-        "    }",
-        "",
-        "    public Builder aComponent(AComponent aComponent) {",
-        "      this.aComponent = Preconditions.checkNotNull(aComponent);",
-        "      return this;",
-        "    }",
-        "  }",
-        "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(aFile, bFile, aComponentFile, bComponentFile))
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError()
-        .and().generatesSources(generatedComponent);
-  }
-
-  @Test public void moduleNameCollision() {
-    JavaFileObject aFile = JavaFileObjects.forSourceLines("test.A",
-        "package test;",
-        "",
-        "public final class A {}");
-    JavaFileObject otherAFile = JavaFileObjects.forSourceLines("other.test.A",
-        "package other.test;",
-        "",
-        "public final class A {}");
-
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "",
-        "@Module",
-        "public final class TestModule {",
-        "  @Provides A a() { return null; }",
-        "}");
-    JavaFileObject otherModuleFile = JavaFileObjects.forSourceLines("other.test.TestModule",
-        "package other.test;",
+        "@Module",
+        "public final class TestModule {",
+        "  @Provides A a() { return null; }",
+        "}");
+    JavaFileObject otherModuleFile = JavaFileObjects.forSourceLines("other.test.TestModule",
+        "package other.test;",
         "",
         "import dagger.Module;",
         "import dagger.Provides;",
@@ -1643,7 +1762,6 @@ public void subcomponentOmitsInheritedBindings() {
         "package test;",
         "",
         "import dagger.Component;",
-        "",
         "import javax.inject.Provider;",
         "",
         "@Component(modules = {TestModule.class, other.test.TestModule.class})",
@@ -1674,7 +1792,7 @@ public void subcomponentOmitsInheritedBindings() {
         "  }",
         "",
         "  public static TestComponent create() {",
-        "    return builder().build();",
+        "    return new Builder().build();",
         "  }",
         "",
         "  @SuppressWarnings(\"unchecked\")",
@@ -1721,11 +1839,12 @@ public void subcomponentOmitsInheritedBindings() {
         "    }",
         "  }",
         "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(aFile, otherAFile, moduleFile, otherModuleFile, componentFile))
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError()
-        .and().generatesSources(generatedComponent);
+    Compilation compilation =
+        daggerCompiler().compile(aFile, otherAFile, moduleFile, otherModuleFile, componentFile);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerTestComponent")
+        .hasSourceEquivalentTo(generatedComponent);
   }
 
   @Test public void resolutionOrder() {
@@ -1766,7 +1885,6 @@ public void subcomponentOmitsInheritedBindings() {
         "package test;",
         "",
         "import dagger.Component;",
-        "",
         "import javax.inject.Provider;",
         "",
         "@Component",
@@ -1775,68 +1893,69 @@ public void subcomponentOmitsInheritedBindings() {
         "  C c();",
         "  X x();",
         "}");
-    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
-        "test.DaggerTestComponent",
-        "package test;",
-        "",
-        "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
-        "",
-        GENERATED_ANNOTATION,
-        "public final class DaggerTestComponent implements TestComponent {",
-        "  private Provider<B> bProvider;",
-        "  private Provider<A> aProvider;",
-        "  private Provider<X> xProvider;",
-        "",
-        "  private DaggerTestComponent(Builder builder) {",
-        "    assert builder != null;",
-        "    initialize(builder);",
-        "  }",
-        "",
-        "  public static Builder builder() {",
-        "    return new Builder();",
-        "  }",
-        "",
-        "  public static TestComponent create() {",
-        "    return builder().build();",
-        "  }",
-        "",
-        "  @SuppressWarnings(\"unchecked\")",
-        "  private void initialize(final Builder builder) {",
-        "    this.bProvider = B_Factory.create(C_Factory.create());",
-        "    this.aProvider = A_Factory.create(bProvider);",
-        "    this.xProvider = X_Factory.create(C_Factory.create());",
-        "  }",
-        "",
-        "  @Override",
-        "  public A a() {",
-        "    return aProvider.get();",
-        "  }",
-        "",
-        "  @Override",
-        "  public C c() {",
-        "    return C_Factory.create().get();",
-        "  }",
-        "",
-        "  @Override",
-        "  public X x() {",
-        "    return xProvider.get();",
-        "  }",
-        "",
-        "  public static final class Builder {",
-        "    private Builder() {",
-        "    }",
-        "",
-        "    public TestComponent build() {",
-        "      return new DaggerTestComponent(this);",
-        "    }",
-        "  }",
-        "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(aFile, bFile, cFile, xFile, componentFile))
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError()
-        .and().generatesSources(generatedComponent);
+    JavaFileObject generatedComponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerTestComponent",
+            "package test;",
+            "",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerTestComponent implements TestComponent {",
+            "  private Provider<B> bProvider;",
+            "  private Provider<A> aProvider;",
+            "  private Provider<X> xProvider;",
+            "",
+            "  private DaggerTestComponent(Builder builder) {",
+            "    assert builder != null;",
+            "    initialize(builder);",
+            "  }",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static TestComponent create() {",
+            "    return new Builder().build();",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize(final Builder builder) {",
+            "    this.bProvider = B_Factory.create(C_Factory.create());",
+            "    this.aProvider = A_Factory.create(bProvider);",
+            "    this.xProvider = X_Factory.create(C_Factory.create());",
+            "  }",
+            "",
+            "  @Override",
+            "  public A a() {",
+            "    return new A(new B(new C()));",
+            "  }",
+            "",
+            "  @Override",
+            "  public C c() {",
+            "    return new C();",
+            "  }",
+            "",
+            "  @Override",
+            "  public X x() {",
+            "    return new X(new C());",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private Builder() {",
+            "    }",
+            "",
+            "    public TestComponent build() {",
+            "      return new DaggerTestComponent(this);",
+            "    }",
+            "  }",
+            "}");
+    Compilation compilation = daggerCompiler().compile(aFile, bFile, cFile, xFile, componentFile);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerTestComponent")
+        .hasSourceEquivalentTo(generatedComponent);
   }
 
   @Test public void simpleComponent_redundantComponentMethod() {
@@ -1853,7 +1972,6 @@ public void subcomponentOmitsInheritedBindings() {
         "",
         "import dagger.Component;",
         "import dagger.Lazy;",
-        "",
         "import javax.inject.Provider;",
         "",
         "@Component",
@@ -1865,7 +1983,6 @@ public void subcomponentOmitsInheritedBindings() {
         "",
         "import dagger.Component;",
         "import dagger.Lazy;",
-        "",
         "import javax.inject.Provider;",
         "",
         "@Component",
@@ -1877,51 +1994,57 @@ public void subcomponentOmitsInheritedBindings() {
         "",
         "import dagger.Component;",
         "import dagger.Lazy;",
-        "",
         "import javax.inject.Provider;",
         "",
         "@Component",
         "interface SimpleComponent extends SupertypeA, SupertypeB {",
         "}");
-    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
-        "test.DaggerSimpleComponent",
-        "package test;",
-        "",
-        "import javax.annotation.Generated;",
-        "",
-        GENERATED_ANNOTATION,
-        "public final class DaggerSimpleComponent implements SimpleComponent {",
-        "  private DaggerSimpleComponent(Builder builder) {",
-        "    assert builder != null;",
-        "  }",
-        "",
-        "  public static Builder builder() {",
-        "    return new Builder();",
-        "  }",
-        "",
-        "  public static SimpleComponent create() {",
-        "    return builder().build();",
-        "  }",
-        "",
-        "  @Override",
-        "  public SomeInjectableType someInjectableType() {",
-        "    return SomeInjectableType_Factory.create().get();",
-        "  }",
-        "",
-        "  public static final class Builder {",
-        "    private Builder() {",
-        "    }",
-        "",
-        "    public SimpleComponent build() {",
-        "      return new DaggerSimpleComponent(this);",
-        "    }",
-        "  }",
-        "}");
-    assertAbout(javaSources()).that(ImmutableList.of(
-            injectableTypeFile, componentSupertypeAFile, componentSupertypeBFile, componentFile))
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError()
-        .and().generatesSources(generatedComponent);
+    JavaFileObject generatedComponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerSimpleComponent",
+            "package test;",
+            "",
+            "import javax.annotation.Generated;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerSimpleComponent implements SimpleComponent {",
+            "  private DaggerSimpleComponent(Builder builder) {",
+            "    assert builder != null;",
+            "  }",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static SimpleComponent create() {",
+            "    return new Builder().build();",
+            "  }",
+            "",
+            "  @Override",
+            "  public SomeInjectableType someInjectableType() {",
+            "    return new SomeInjectableType();",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private Builder() {",
+            "    }",
+            "",
+            "    public SimpleComponent build() {",
+            "      return new DaggerSimpleComponent(this);",
+            "    }",
+            "  }",
+            "}");
+    Compilation compilation =
+        daggerCompiler()
+            .compile(
+                injectableTypeFile,
+                componentSupertypeAFile,
+                componentSupertypeBFile,
+                componentFile);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerSimpleComponent")
+        .hasSourceEquivalentTo(generatedComponent);
   }
 
   @Test public void simpleComponent_inheritedComponentMethodDep() {
@@ -1938,7 +2061,6 @@ public void subcomponentOmitsInheritedBindings() {
         "",
         "import dagger.Component;",
         "import dagger.Lazy;",
-        "",
         "import javax.inject.Provider;",
         "",
         "@Component",
@@ -1950,7 +2072,6 @@ public void subcomponentOmitsInheritedBindings() {
         "",
         "import dagger.Component;",
         "import dagger.Lazy;",
-        "",
         "import javax.inject.Provider;",
         "",
         "@Component",
@@ -1961,52 +2082,54 @@ public void subcomponentOmitsInheritedBindings() {
         "",
         "import dagger.Component;",
         "import dagger.Lazy;",
-        "",
         "import javax.inject.Provider;",
         "",
         "@Component(dependencies = SimpleComponent.class)",
         "interface ComponentWithDep {",
         "  SomeInjectableType someInjectableType();",
         "}");
-    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
-        "test.DaggerSimpleComponent",
-        "package test;",
-        "",
-        "import javax.annotation.Generated;",
-        "",
-        GENERATED_ANNOTATION,
-        "public final class DaggerSimpleComponent implements SimpleComponent {",
-        "  private DaggerSimpleComponent(Builder builder) {",
-        "    assert builder != null;",
-        "  }",
-        "",
-        "  public static Builder builder() {",
-        "    return new Builder();",
-        "  }",
-        "",
-        "  public static SimpleComponent create() {",
-        "    return builder().build();",
-        "  }",
-        "",
-        "  @Override",
-        "  public SomeInjectableType someInjectableType() {",
-        "    return SomeInjectableType_Factory.create().get();",
-        "  }",
-        "",
-        "  public static final class Builder {",
-        "    private Builder() {",
-        "    }",
-        "",
-        "    public SimpleComponent build() {",
-        "      return new DaggerSimpleComponent(this);",
-        "    }",
-        "  }",
-        "}");
-    assertAbout(javaSources()).that(ImmutableList.of(
-            injectableTypeFile, componentSupertype, depComponentFile, componentFile))
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError()
-        .and().generatesSources(generatedComponent);
+    JavaFileObject generatedComponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerSimpleComponent",
+            "package test;",
+            "",
+            "import javax.annotation.Generated;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerSimpleComponent implements SimpleComponent {",
+            "  private DaggerSimpleComponent(Builder builder) {",
+            "    assert builder != null;",
+            "  }",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static SimpleComponent create() {",
+            "    return new Builder().build();",
+            "  }",
+            "",
+            "  @Override",
+            "  public SomeInjectableType someInjectableType() {",
+            "    return new SomeInjectableType();",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private Builder() {",
+            "    }",
+            "",
+            "    public SimpleComponent build() {",
+            "      return new DaggerSimpleComponent(this);",
+            "    }",
+            "  }",
+            "}");
+    Compilation compilation =
+        daggerCompiler()
+            .compile(injectableTypeFile, componentSupertype, depComponentFile, componentFile);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerSimpleComponent")
+        .hasSourceEquivalentTo(generatedComponent);
   }
 
   @Test public void wildcardGenericsRequiresAtProvides() {
@@ -2041,19 +2164,19 @@ public void subcomponentOmitsInheritedBindings() {
         "",
         "import dagger.Component;",
         "import dagger.Lazy;",
-        "",
         "import javax.inject.Provider;",
         "",
         "@Component",
         "interface SimpleComponent {",
         "  C c();",
         "}");
-    assertAbout(javaSources()).that(ImmutableList.of(aFile, bFile, cFile, componentFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
+    Compilation compilation = daggerCompiler().compile(aFile, bFile, cFile, componentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
             "test.B<? extends test.A> cannot be provided without an @Provides-annotated method");
   }
+
   @Test
   public void componentImplicitlyDependsOnGeneratedType() {
     JavaFileObject injectableTypeFile = JavaFileObjects.forSourceLines("test.SomeInjectableType",
@@ -2073,23 +2196,22 @@ public void componentImplicitlyDependsOnGeneratedType() {
         "interface SimpleComponent {",
         "  SomeInjectableType someInjectableType();",
         "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(injectableTypeFile, componentFile))
-        .processedWith(
-            new ComponentProcessor(),
-            new GeneratingProcessor(
-                "test.GeneratedType",
-                "package test;",
-                "",
-                "import javax.inject.Inject;",
-                "",
-                "final class GeneratedType {",
-                "  @Inject GeneratedType() {}",
-                "}"))
-        .compilesWithoutError()
-        .and()
-        .generatesFileNamed(SOURCE_OUTPUT, "test", "DaggerSimpleComponent.java");
+    Compilation compilation =
+        daggerCompiler(
+                new GeneratingProcessor(
+                    "test.GeneratedType",
+                    "package test;",
+                    "",
+                    "import javax.inject.Inject;",
+                    "",
+                    "final class GeneratedType {",
+                    "  @Inject GeneratedType() {}",
+                    "}"))
+            .compile(injectableTypeFile, componentFile);
+    assertThat(compilation).succeeded();
+    assertThat(compilation).generatedSourceFile("test.DaggerSimpleComponent");
   }
+
   @Test
   public void componentSupertypeDependsOnGeneratedType() {
     JavaFileObject componentFile =
@@ -2109,22 +2231,20 @@ public void componentSupertypeDependsOnGeneratedType() {
             "interface SimpleComponentInterface {",
             "  GeneratedType generatedType();",
             "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(componentFile, interfaceFile))
-        .processedWith(
-            new ComponentProcessor(),
-            new GeneratingProcessor(
-                "test.GeneratedType",
-                "package test;",
-                "",
-                "import javax.inject.Inject;",
-                "",
-                "final class GeneratedType {",
-                "  @Inject GeneratedType() {}",
-                "}"))
-        .compilesWithoutError()
-        .and()
-        .generatesFileNamed(SOURCE_OUTPUT, "test", "DaggerSimpleComponent.java");
+    Compilation compilation =
+        daggerCompiler(
+                new GeneratingProcessor(
+                    "test.GeneratedType",
+                    "package test;",
+                    "",
+                    "import javax.inject.Inject;",
+                    "",
+                    "final class GeneratedType {",
+                    "  @Inject GeneratedType() {}",
+                    "}"))
+            .compile(componentFile, interfaceFile);
+    assertThat(compilation).succeeded();
+    assertThat(compilation).generatedSourceFile("test.DaggerSimpleComponent");
   }
 
   @Test
@@ -2192,7 +2312,7 @@ public void genericTestToLetMeDebugInEclipse() {
          "  }",
          "",
          "  public static SimpleComponent create() {",
-         "    return builder().build();",
+         "    return new Builder().build();",
          "  }",
          "",
          "  @SuppressWarnings(\"unchecked\")",
@@ -2214,10 +2334,11 @@ public void genericTestToLetMeDebugInEclipse() {
          "    }",
          "  }",
          "}");
-     assertAbout(javaSources()).that(ImmutableList.of(aFile, bFile, componentFile))
-         .processedWith(new ComponentProcessor())
-         .compilesWithoutError()
-         .and().generatesSources(generatedComponent);
+    Compilation compilation = daggerCompiler().compile(aFile, bFile, componentFile);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerSimpleComponent")
+        .hasSourceEquivalentTo(generatedComponent);
    }
 
   /**
@@ -2230,9 +2351,19 @@ public void genericTestToLetMeDebugInEclipse() {
    */
   @Test
   public void unprocessedMembersInjectorNotes() {
-    assertAbout(javaSources())
-        .that(
-            ImmutableList.of(
+    Compilation compilation =
+        javac()
+            .withOptions(
+                "-Xlint:-processing",
+                 "-Adagger.warnIfInjectionFactoryNotGeneratedUpstream=enabled")
+            .withProcessors(
+                new ElementFilteringComponentProcessor(
+                    Predicates.not(
+                        element ->
+                            MoreElements.getPackage(element)
+                                .getQualifiedName()
+                                .contentEquals("test.inject"))))
+            .compile(
                 JavaFileObjects.forSourceLines(
                     "test.TestComponent",
                     "package test;",
@@ -2312,36 +2443,25 @@ public void unprocessedMembersInjectorNotes() {
                     "public class ParentInjectMemberWithConstructor",
                     "    extends LocalInjectMemberNoConstructor {",
                     "  @Inject ParentInjectMemberWithConstructor() {}",
-                    "}")))
-        .withCompilerOptions("-Xlint:-processing")
-        .processedWith(
-            new ElementFilteringComponentProcessor(
-                Predicates.not(
-                    new Predicate<Element>() {
-                      @Override
-                      public boolean apply(Element element) {
-                        return MoreElements.getPackage(element)
-                            .getQualifiedName()
-                            .contentEquals("test.inject");
-                      }
-                    })))
-        .compilesWithoutWarnings()
-        .withNoteContaining(
+                    "}"));
+
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .hadNoteContaining(
             "Generating a MembersInjector for "
                 + "test.inject.LocalInjectMemberNoConstructor. "
-                + "Prefer to run the dagger processor over that class instead.")
-        .and()
-        .withNoteContaining(
+                + "Prefer to run the dagger processor over that class instead.");
+    assertThat(compilation)
+        .hadNoteContaining(
             "Generating a MembersInjector for "
                 + "test.inject.LocalInjectMemberWithConstructor. "
-                + "Prefer to run the dagger processor over that class instead.")
-        .and()
-        .withNoteContaining(
+                + "Prefer to run the dagger processor over that class instead.");
+    assertThat(compilation)
+        .hadNoteContaining(
             "Generating a MembersInjector for "
                 + "test.inject.ParentInjectMemberWithConstructor. "
-                + "Prefer to run the dagger processor over that class instead.")
-        .and()
-        .withNoteCount(3);
+                + "Prefer to run the dagger processor over that class instead.");
+    assertThat(compilation).hadNoteCount(3);
   }
 
   @Test
@@ -2365,12 +2485,11 @@ public void scopeAnnotationOnInjectConstructorNotValid() {
             "final class AClass {",
             "  @Inject @AScope AClass() {}",
             "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(aScope, aClass))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("@Scope annotations are not allowed on @Inject constructors.")
-        .in(aClass)
+    Compilation compilation = daggerCompiler().compile(aScope, aClass);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("@Scope annotations are not allowed on @Inject constructors.")
+        .inFile(aClass)
         .onLine(6);
   }
 
@@ -2390,17 +2509,308 @@ public void attemptToInjectWildcardGenerics() {
             "  Lazy<? extends Number> wildcardNumberLazy();",
             "  Provider<? super Number> wildcardNumberProvider();",
             "}");
-    assertAbout(javaSources())
-        .that(asList(testComponent))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("wildcard type")
-        .in(testComponent)
-        .onLine(9)
-        .and()
-        .withErrorContaining("wildcard type")
-        .in(testComponent)
-        .onLine(10);
+    Compilation compilation = daggerCompiler().compile(testComponent);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining("wildcard type").inFile(testComponent).onLine(9);
+    assertThat(compilation).hadErrorContaining("wildcard type").inFile(testComponent).onLine(10);
+  }
+
+  @Test
+  public void unusedSubcomponents_dontResolveExtraBindingsInParentComponents() {
+    JavaFileObject foo =
+        JavaFileObjects.forSourceLines(
+            "test.Foo",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "import javax.inject.Singleton;",
+            "",
+            "@Singleton",
+            "class Foo {",
+            "  @Inject Foo() {}",
+            "}");
+
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "",
+            "@Module(subcomponents = Pruned.class)",
+            "class TestModule {}");
+
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.Parent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Singleton;",
+            "",
+            "@Singleton",
+            "@Component(modules = TestModule.class)",
+            "interface Parent {}");
+
+    JavaFileObject prunedSubcomponent =
+        JavaFileObjects.forSourceLines(
+            "test.Pruned",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent",
+            "interface Pruned {",
+            "  @Subcomponent.Builder",
+            "  interface Builder {",
+            "    Pruned build();",
+            "  }",
+            "",
+            "  Foo foo();",
+            "}");
+    JavaFileObject generated =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerParent",
+            "package test;",
+            "",
+            "import dagger.internal.Preconditions;",
+            "import javax.annotation.Generated;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerParent implements Parent {",
+            "  private DaggerParent(Builder builder) {",
+            "    assert builder != null;",
+            "  }",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static Parent create() {",
+            "    return new Builder().build();",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private Builder() {}",
+            "",
+            "    public Parent build() {",
+            "      return new DaggerParent(this);",
+            "    }",
+            "",
+            "    @Deprecated",
+            "    public Builder testModule(TestModule testModule) {",
+            "      Preconditions.checkNotNull(testModule);",
+            "      return this;",
+            "    }",
+            "  }",
+            "}");
+
+    Compilation compilation = daggerCompiler().compile(foo, module, component, prunedSubcomponent);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerParent")
+        .hasSourceEquivalentTo(generated);
+  }
+
+  // TODO(b/34107586): Fix and enable test.
+  @Test
+  @Ignore
+  public void invalidComponentDependencies() {
+    JavaFileObject testComponent =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(dependencies = int.class)",
+            "interface TestComponent {}");
+    Compilation compilation = daggerCompiler().compile(testComponent);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining("int is not a valid component dependency type");
+  }
+
+  @Test
+  public void invalidComponentModules() {
+    JavaFileObject testComponent =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = int.class)",
+            "interface TestComponent {}");
+    Compilation compilation = daggerCompiler().compile(testComponent);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining("int is not a valid module type");
+  }
+
+  @Test
+  public void moduleInDependencies() {
+    JavaFileObject testModule =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "final class TestModule {",
+            "  @Provides String s() { return null; }",
+            "}");
+    JavaFileObject testComponent =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(dependencies = TestModule.class)",
+            "interface TestComponent {}");
+    Compilation compilation = daggerCompiler().compile(testModule, testComponent);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("test.TestModule is a module, which cannot be a component dependency");
+  }
+
+  @Test
+  public void bindsInstanceInModule() {
+    JavaFileObject testModule =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.BindsInstance;",
+            "import dagger.Module;",
+            "",
+            "@Module",
+            "abstract class TestModule {",
+            "  @BindsInstance abstract void str(String string);",
+            "}");
+    Compilation compilation = daggerCompiler().compile(testModule);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            "@BindsInstance methods should not be included in @Modules. Did you mean @Binds");
+  }
+
+  @Test
+  public void bindsInstanceInComponent() {
+    JavaFileObject testComponent =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.BindsInstance;",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface TestComponent {",
+            "  @BindsInstance String s(String s);",
+            "}");
+    Compilation compilation = daggerCompiler().compile(testComponent);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            "@BindsInstance methods should not be included in @Components. "
+                + "Did you mean to put it in a @Component.Builder?");
+  }
+
+  @Test
+  public void bindsInstanceNotAbstract() {
+    JavaFileObject notAbstract =
+        JavaFileObjects.forSourceLines(
+            "test.BindsInstanceNotAbstract",
+            "package test;",
+            "",
+            "import dagger.BindsInstance;",
+            "import dagger.Component;",
+            "",
+            "class BindsInstanceNotAbstract {",
+            "  @BindsInstance BindsInstanceNotAbstract bind(int unused) { return this; }",
+            "}");
+    Compilation compilation = daggerCompiler().compile(notAbstract);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("@BindsInstance methods must be abstract")
+        .inFile(notAbstract)
+        .onLine(7);
+  }
+
+  @Test
+  public void bindsInstanceNoParameters() {
+    JavaFileObject notAbstract =
+        JavaFileObjects.forSourceLines(
+            "test.BindsInstanceNoParameters",
+            "package test;",
+            "",
+            "import dagger.BindsInstance;",
+            "",
+            "interface BindsInstanceNoParameters {",
+            "  @BindsInstance void noParams();",
+            "}");
+    Compilation compilation = daggerCompiler().compile(notAbstract);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            "@BindsInstance methods should have exactly one parameter for the bound type")
+        .inFile(notAbstract)
+        .onLine(6);
+  }
+
+  @Test
+  public void bindsInstanceManyParameters() {
+    JavaFileObject notAbstract =
+        JavaFileObjects.forSourceLines(
+            "test.BindsInstanceNoParameter",
+            "package test;",
+            "",
+            "import dagger.BindsInstance;",
+            "",
+            "interface BindsInstanceManyParameters {",
+            "  @BindsInstance void manyParams(int i, long l);",
+            "}");
+    Compilation compilation = daggerCompiler().compile(notAbstract);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            "@BindsInstance methods should have exactly one parameter for the bound type")
+        .inFile(notAbstract)
+        .onLine(6);
+  }
+
+  @Test
+  public void bindsInstanceFrameworkType() {
+    JavaFileObject bindsFrameworkType =
+        JavaFileObjects.forSourceLines(
+            "test.BindsInstanceFrameworkType",
+            "package test;",
+            "",
+            "import dagger.BindsInstance;",
+            "import dagger.producers.Producer;",
+            "import javax.inject.Provider;",
+            "",
+            "interface BindsInstanceFrameworkType {",
+            "  @BindsInstance void bindsProvider(Provider<Object> objectProvider);",
+            "  @BindsInstance void bindsProducer(Producer<Object> objectProducer);",
+            "}");
+    Compilation compilation = daggerCompiler().compile(bindsFrameworkType);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("@BindsInstance parameters may not be framework types")
+        .inFile(bindsFrameworkType)
+        .onLine(8);
+
+    assertThat(compilation)
+        .hadErrorContaining("@BindsInstance parameters may not be framework types")
+        .inFile(bindsFrameworkType)
+        .onLine(9);
+  }
+
+  private static Compiler daggerCompiler(Processor... extraProcessors) {
+    return javac().withProcessors(Lists.asList(new ComponentProcessor(), extraProcessors));
   }
 
   /**
@@ -2433,6 +2843,11 @@ public SourceVersion getSupportedSourceVersion() {
       return componentProcessor.getSupportedSourceVersion();
     }
 
+    @Override
+    public Set<String> getSupportedOptions() {
+      return componentProcessor.getSupportedOptions();
+    }
+
     @Override
     public boolean process(
         Set<? extends TypeElement> annotations, final RoundEnvironment roundEnv) {
diff --git a/compiler/src/test/java/dagger/internal/codegen/DaggerModuleMethodSubject.java b/compiler/src/test/java/dagger/internal/codegen/DaggerModuleMethodSubject.java
index 3581057bc..171d36511 100644
--- a/compiler/src/test/java/dagger/internal/codegen/DaggerModuleMethodSubject.java
+++ b/compiler/src/test/java/dagger/internal/codegen/DaggerModuleMethodSubject.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 Google, Inc.
+ * Copyright (C) 2016 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,12 +13,14 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal.codegen;
 
-import com.google.common.base.Function;
+import static com.google.common.truth.Truth.assertAbout;
+import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
-import com.google.common.collect.Iterables;
 import com.google.common.truth.FailureStrategy;
 import com.google.common.truth.Subject;
 import com.google.common.truth.SubjectFactory;
@@ -30,11 +32,9 @@
 import java.io.PrintWriter;
 import java.io.StringWriter;
 import java.util.Arrays;
+import java.util.List;
 import javax.tools.JavaFileObject;
 
-import static com.google.common.truth.Truth.assertAbout;
-import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
-
 /** A {@link Truth} subject for testing Dagger module methods. */
 final class DaggerModuleMethodSubject extends Subject<DaggerModuleMethodSubject, String> {
 
@@ -107,7 +107,7 @@ private DaggerModuleMethodSubject(FailureStrategy failureStrategy, String subjec
    * </ul>
    */
   DaggerModuleMethodSubject importing(Class<?>... imports) {
-    return importing(FluentIterable.from(Arrays.asList(imports)));
+    return importing(Arrays.asList(imports));
   }
 
   /**
@@ -120,8 +120,10 @@ DaggerModuleMethodSubject importing(Class<?>... imports) {
    * <li>{@code javax.inject.*}
    * </ul>
    */
-  DaggerModuleMethodSubject importing(Iterable<? extends Class<?>> imports) {
-    this.imports.addAll(Iterables.transform(imports, IMPORT));
+  DaggerModuleMethodSubject importing(List<? extends Class<?>> imports) {
+    imports.stream()
+        .map(clazz -> String.format("import %s;", clazz.getCanonicalName()))
+        .forEachOrdered(this.imports::add);
     return this;
   }
 
@@ -158,7 +160,7 @@ void hasError(String errorSubstring) {
   }
 
   private int methodLine(String source) {
-    String beforeMethod = source.substring(0, source.indexOf(getSubject()));
+    String beforeMethod = source.substring(0, source.indexOf(actual()));
     int methodLine = 1;
     for (int nextNewlineIndex = beforeMethod.indexOf('\n');
         nextNewlineIndex >= 0;
@@ -177,16 +179,9 @@ private String moduleSource() {
       writer.println(importLine);
     }
     writer.println();
-    writer.printf(declaration, "TestModule", "\n" + getSubject() + "\n");
+    writer.printf(declaration, "TestModule", "\n" + actual() + "\n");
     writer.println();
     return stringWriter.toString();
   }
 
-  private static final Function<Class<?>, String> IMPORT =
-      new Function<Class<?>, String>() {
-        @Override
-        public String apply(Class<?> clazz) {
-          return String.format("import %s;", clazz.getCanonicalName());
-        }
-      };
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/DependencyRequestMapperTest.java b/compiler/src/test/java/dagger/internal/codegen/DependencyRequestMapperTest.java
deleted file mode 100644
index 2bc5fc017..000000000
--- a/compiler/src/test/java/dagger/internal/codegen/DependencyRequestMapperTest.java
+++ /dev/null
@@ -1,154 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen;
-
-import com.google.common.collect.Iterables;
-import com.google.testing.compile.CompilationRule;
-import dagger.Lazy;
-import dagger.MembersInjector;
-import dagger.Module;
-import dagger.Provides;
-import dagger.producers.Produced;
-import dagger.producers.Producer;
-import dagger.producers.ProducerModule;
-import dagger.producers.Produces;
-import java.util.List;
-import javax.inject.Provider;
-import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.TypeElement;
-import javax.lang.model.element.VariableElement;
-import javax.lang.model.util.ElementFilter;
-import javax.lang.model.util.Elements;
-import javax.lang.model.util.Types;
-import org.junit.Before;
-import org.junit.Rule;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-import static com.google.common.truth.Truth.assertThat;
-
-/**
- * Test case for {@link DependencyRequestMapper}.
- */
-@RunWith(JUnit4.class)
-public class DependencyRequestMapperTest {
-  @Rule public CompilationRule compilationRule = new CompilationRule();
-
-  private Elements elements;
-  private Types types;
-  private Key.Factory keyFactory;
-  private DependencyRequest.Factory dependencyRequestFactory;
-
-  @Before public void setUp() {
-    this.types = compilationRule.getTypes();
-    this.elements = compilationRule.getElements();
-    this.keyFactory = new Key.Factory(types, elements);
-    this.dependencyRequestFactory = new DependencyRequest.Factory(elements, keyFactory);
-  }
-
-  private List<? extends VariableElement> sampleProviderParameters() {
-    TypeElement moduleElement =
-        elements.getTypeElement(ProvidesMethodModule.class.getCanonicalName());
-    ExecutableElement providesMethod =
-        Iterables.getOnlyElement(ElementFilter.methodsIn(moduleElement.getEnclosedElements()));
-    return providesMethod.getParameters();
-  }
-
-  private List<? extends VariableElement> sampleProducerParameters() {
-    TypeElement moduleElement =
-        elements.getTypeElement(ProducesMethodModule.class.getCanonicalName());
-    ExecutableElement producesMethod =
-        Iterables.getOnlyElement(ElementFilter.methodsIn(moduleElement.getEnclosedElements()));
-    return producesMethod.getParameters();
-  }
-
-  private DependencyRequest dependencyRequestForInstance() {
-    return dependencyRequestFactory.forRequiredVariable(sampleProviderParameters().get(0));
-  }
-
-  private DependencyRequest dependencyRequestForLazy() {
-    return dependencyRequestFactory.forRequiredVariable(sampleProviderParameters().get(1));
-  }
-
-  private DependencyRequest dependencyRequestForProvider() {
-    return dependencyRequestFactory.forRequiredVariable(sampleProviderParameters().get(2));
-  }
-
-  private DependencyRequest dependencyRequestForMembersInjector() {
-    return dependencyRequestFactory.forRequiredVariable(sampleProviderParameters().get(3));
-  }
-
-  private DependencyRequest dependencyRequestForProducer() {
-    return dependencyRequestFactory.forRequiredVariable(sampleProducerParameters().get(0));
-  }
-
-  private DependencyRequest dependencyRequestForProduced() {
-    return dependencyRequestFactory.forRequiredVariable(sampleProducerParameters().get(1));
-  }
-
-  @Test public void forProvider() {
-    DependencyRequestMapper mapper = DependencyRequestMapper.FOR_PROVIDER;
-    assertThat(mapper.getFrameworkClass(dependencyRequestForInstance()))
-        .isEqualTo(Provider.class);
-    assertThat(mapper.getFrameworkClass(dependencyRequestForLazy()))
-        .isEqualTo(Provider.class);
-    assertThat(mapper.getFrameworkClass(dependencyRequestForProvider()))
-        .isEqualTo(Provider.class);
-    assertThat(mapper.getFrameworkClass(dependencyRequestForMembersInjector()))
-        .isEqualTo(MembersInjector.class);
-  }
-
-  @Test public void forProducer() {
-    DependencyRequestMapper mapper = DependencyRequestMapper.FOR_PRODUCER;
-    assertThat(mapper.getFrameworkClass(dependencyRequestForInstance()))
-        .isEqualTo(Producer.class);
-    assertThat(mapper.getFrameworkClass(dependencyRequestForLazy()))
-        .isEqualTo(Provider.class);
-    assertThat(mapper.getFrameworkClass(dependencyRequestForProvider()))
-        .isEqualTo(Provider.class);
-    assertThat(mapper.getFrameworkClass(dependencyRequestForMembersInjector()))
-        .isEqualTo(MembersInjector.class);
-    assertThat(mapper.getFrameworkClass(dependencyRequestForProducer()))
-        .isEqualTo(Producer.class);
-    assertThat(mapper.getFrameworkClass(dependencyRequestForProduced()))
-        .isEqualTo(Producer.class);
-  }
-
-  @Module
-  static final class ProvidesMethodModule {
-    @Provides
-    static String provideString(
-        @SuppressWarnings("unused") Integer a,
-        @SuppressWarnings("unused") Lazy<Integer> b,
-        @SuppressWarnings("unused") Provider<Integer> c,
-        @SuppressWarnings("unused") MembersInjector<Y> d) {
-      throw new UnsupportedOperationException();
-    }
-  }
-
-  @ProducerModule
-  static final class ProducesMethodModule {
-    @Produces
-    static String produceString(
-        @SuppressWarnings("unused") Producer<Integer> a,
-        @SuppressWarnings("unused") Produced<Integer> b) {
-      return null;
-    }
-  }
-  
-  static final class Y {}
-}
diff --git a/compiler/src/test/java/dagger/internal/codegen/ErrorMessagesTest.java b/compiler/src/test/java/dagger/internal/codegen/ErrorMessagesTest.java
index 141d5c452..e7c392150 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ErrorMessagesTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ErrorMessagesTest.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Google, Inc.
+ * Copyright (C) 2014 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,14 +13,15 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal.codegen;
 
+import static com.google.common.truth.Truth.assertThat;
+
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import static com.google.common.truth.Truth.assertThat;
-
 @RunWith(JUnit4.class)
 public class ErrorMessagesTest {
   @Test public void stripCommonTypePrefixes() {
diff --git a/compiler/src/test/java/dagger/internal/codegen/ForReleasableReferencesValidatorTest.java b/compiler/src/test/java/dagger/internal/codegen/ForReleasableReferencesValidatorTest.java
new file mode 100644
index 000000000..05f849f21
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/ForReleasableReferencesValidatorTest.java
@@ -0,0 +1,102 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.truth.Truth.assertAbout;
+import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+
+import com.google.common.collect.ImmutableList;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/** Tests validation of {@code @ForReleasableRefernces}. */
+@RunWith(JUnit4.class)
+public class ForReleasableReferencesValidatorTest {
+  @Test
+  public void notAScope() {
+    JavaFileObject notAScope =
+        JavaFileObjects.forSourceLines(
+            "test.NotAScope", // force one-string-per-line format
+            "package test;",
+            "",
+            "@interface NotAScope {}");
+    JavaFileObject injects =
+        JavaFileObjects.forSourceLines(
+            "test.Injects",
+            "package test;",
+            "",
+            "import dagger.releasablereferences.ForReleasableReferences;",
+            "import dagger.releasablereferences.ReleasableReferenceManager;",
+            "",
+            "interface Injects {",
+            "  @ForReleasableReferences(NotAScope.class) ReleasableReferenceManager manager();",
+            "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(notAScope, injects))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            "The value of @ForReleasableReferences must be a reference-releasing scope. "
+                + "Did you mean to annotate test.NotAScope with @javax.inject.Scope and "
+                + "@dagger.releasablereferences.CanReleaseReferences?")
+        .in(injects)
+        .onLine(7)
+        .atColumn(3);
+  }
+
+  @Test
+  public void notAReferenceReleasingScope() {
+    JavaFileObject testScope =
+        JavaFileObjects.forSourceLines(
+            "test.TestScope",
+            "package test;",
+            "",
+            "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
+            "",
+            "import java.lang.annotation.Retention;",
+            "import javax.inject.Scope;",
+            "",
+            "@Retention(RUNTIME)",
+            "@Scope",
+            "@interface TestScope {}");
+    JavaFileObject injects =
+        JavaFileObjects.forSourceLines(
+            "test.Injects",
+            "package test;",
+            "",
+            "import dagger.releasablereferences.ForReleasableReferences;",
+            "import dagger.releasablereferences.ReleasableReferenceManager;",
+            "",
+            "interface Injects {",
+            "  @ForReleasableReferences(TestScope.class) ReleasableReferenceManager manager();",
+            "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(testScope, injects))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            "The value of @ForReleasableReferences must be a reference-releasing scope. "
+                + "Did you mean to annotate test.TestScope with "
+                + "@dagger.releasablereferences.CanReleaseReferences?")
+        .in(injects)
+        .onLine(7)
+        .atColumn(3);
+  }
+}
diff --git a/compiler/src/test/java/dagger/internal/codegen/FrameworkFieldTest.java b/compiler/src/test/java/dagger/internal/codegen/FrameworkFieldTest.java
index 118b8484b..6905f6ae9 100644
--- a/compiler/src/test/java/dagger/internal/codegen/FrameworkFieldTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/FrameworkFieldTest.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Google, Inc.
+ * Copyright (C) 2014 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,8 +13,15 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal.codegen;
 
+import static com.google.common.truth.Truth.assertThat;
+import static dagger.internal.codegen.TypeNames.MEMBERS_INJECTOR;
+import static dagger.internal.codegen.TypeNames.PROVIDER;
+import static dagger.internal.codegen.TypeNames.membersInjectorOf;
+import static dagger.internal.codegen.TypeNames.providerOf;
+
 import com.google.testing.compile.CompilationRule;
 import com.squareup.javapoet.ClassName;
 import javax.inject.Inject;
@@ -24,12 +31,6 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import static com.google.common.truth.Truth.assertThat;
-import static dagger.internal.codegen.TypeNames.MEMBERS_INJECTOR;
-import static dagger.internal.codegen.TypeNames.PROVIDER;
-import static dagger.internal.codegen.TypeNames.membersInjectorOf;
-import static dagger.internal.codegen.TypeNames.providerOf;
-
 /**
  * Test case for {@link FrameworkField}.
  */
diff --git a/compiler/src/test/java/dagger/internal/codegen/GeneratedLines.java b/compiler/src/test/java/dagger/internal/codegen/GeneratedLines.java
index 487830801..4a6f2f477 100644
--- a/compiler/src/test/java/dagger/internal/codegen/GeneratedLines.java
+++ b/compiler/src/test/java/dagger/internal/codegen/GeneratedLines.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal.codegen;
 
 /**
diff --git a/compiler/src/test/java/dagger/internal/codegen/GraphValidationScopingTest.java b/compiler/src/test/java/dagger/internal/codegen/GraphValidationScopingTest.java
index 8196d1afe..1bdea110a 100644
--- a/compiler/src/test/java/dagger/internal/codegen/GraphValidationScopingTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/GraphValidationScopingTest.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Google, Inc.
+ * Copyright (C) 2014 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,20 +13,20 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal.codegen;
 
+import static com.google.common.truth.Truth.assertAbout;
+import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+import static java.util.Arrays.asList;
+
 import com.google.testing.compile.JavaFileObjects;
 import javax.tools.JavaFileObject;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import static com.google.common.truth.Truth.assertAbout;
-import static com.google.common.truth.Truth.assert_;
-import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
-import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
-import static java.util.Arrays.asList;
-
 @RunWith(JUnit4.class)
 public class GraphValidationScopingTest {
   @Test public void componentWithoutScopeIncludesScopedBindings_Fail() {
@@ -63,10 +63,12 @@
         "  @Provides long integer() { return 0L; }",
         "  @Provides float floatingPoint() { return 0.0f; }",
         "}");
-    String errorMessage = "test.MyComponent (unscoped) may not reference scoped bindings:\n"
-        + "      @Provides @Singleton String test.ScopedModule.string()\n"
-        + "      @Singleton class test.ScopedType";
-    assert_().about(javaSources()).that(asList(componentFile, typeFile, moduleFile))
+    String errorMessage =
+        "test.MyComponent (unscoped) may not reference scoped bindings:\n"
+            + "      @Singleton class test.ScopedType\n"
+            + "      @Provides @Singleton String test.ScopedModule.string()";
+    assertAbout(javaSources())
+        .that(asList(componentFile, typeFile, moduleFile))
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(errorMessage);
@@ -113,11 +115,13 @@
         "  @Provides long integer() { return 0L; }", // unscoped - valid
         "  @Provides @Singleton float floatingPoint() { return 0.0f; }", // same scope - valid
         "}");
-    String errorMessage = "test.MyComponent scoped with @Singleton "
-        + "may not reference bindings with different scopes:\n"
-        + "      @Provides @test.PerTest String test.ScopedModule.string()\n"
-        + "      @test.PerTest class test.ScopedType";
-    assert_().about(javaSources()).that(asList(componentFile, scopeFile, typeFile, moduleFile))
+    String errorMessage =
+        "test.MyComponent scoped with @Singleton "
+            + "may not reference bindings with different scopes:\n"
+            + "      @test.PerTest class test.ScopedType\n"
+            + "      @Provides @test.PerTest String test.ScopedModule.string()";
+    assertAbout(javaSources())
+        .that(asList(componentFile, scopeFile, typeFile, moduleFile))
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(errorMessage);
@@ -187,7 +191,7 @@
         "@test.SimpleScope test.SimpleScopedComponent depends on more than one scoped component:\n"
         + "      @Singleton test.SingletonComponentA\n"
         + "      @Singleton test.SingletonComponentB";
-    assert_().about(javaSources())
+    assertAbout(javaSources())
         .that(
             asList(type, simpleScope, simpleScoped, singletonScopedA, singletonScopedB, scopeless))
         .processedWith(new ComponentProcessor())
@@ -228,7 +232,7 @@
     String errorMessage =
         "test.UnscopedComponent (unscoped) cannot depend on scoped components:\n"
         + "      @Singleton test.ScopedComponent";
-    assert_().about(javaSources())
+    assertAbout(javaSources())
         .that(asList(type, scopedComponent, unscopedComponent))
         .processedWith(new ComponentProcessor())
         .failsToCompile()
@@ -275,7 +279,7 @@
     String errorMessage =
         "This @Singleton component cannot depend on scoped components:\n"
         + "      @test.SimpleScope test.SimpleScopedComponent";
-    assert_().about(javaSources())
+    assertAbout(javaSources())
         .that(asList(type, simpleScope, simpleScoped, singletonScoped))
         .processedWith(new ComponentProcessor())
         .failsToCompile()
@@ -341,13 +345,13 @@
         + "      @test.ScopeA test.ComponentLong\n"
         + "      @test.ScopeB test.ComponentMedium\n"
         + "      @test.ScopeA test.ComponentShort";
-    assert_().about(javaSources())
+    assertAbout(javaSources())
         .that(asList(type, scopeA, scopeB, longLifetime, mediumLifetime, shortLifetime))
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(errorMessage);
   }
-  
+
   @Test
   public void reusableNotAllowedOnComponent() {
     JavaFileObject someComponent =
diff --git a/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java b/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
index ae7bb4b89..83ad31d98 100644
--- a/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Google, Inc.
+ * Copyright (C) 2014 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,8 +13,15 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal.codegen;
 
+import static com.google.common.truth.Truth.assertAbout;
+import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+import static com.google.testing.compile.JavaSourcesSubject.assertThat;
+import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+import static dagger.internal.codegen.ErrorMessages.nullableToNonNullable;
+
 import com.google.common.base.Joiner;
 import com.google.common.collect.ImmutableList;
 import com.google.testing.compile.JavaFileObjects;
@@ -24,16 +31,14 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import static com.google.common.truth.Truth.assertAbout;
-import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
-import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
-import static dagger.internal.codegen.ErrorMessages.nullableToNonNullable;
-
 @RunWith(JUnit4.class)
 public class GraphValidationTest {
   private static final JavaFileObject NULLABLE =
       JavaFileObjects.forSourceLines(
-          "test.Nullable", "package test;", "public @interface Nullable {}");
+          "test.Nullable", // force one-string-per-line format
+          "package test;",
+          "",
+          "public @interface Nullable {}");
 
   @Test public void componentOnConcreteClass() {
     JavaFileObject component = JavaFileObjects.forSourceLines("test.MyComponent",
@@ -202,6 +207,38 @@ public void membersInjectDependsOnUnboundedType() {
         .onLine(7);
   }
 
+  @Test
+  public void invalidMembersInjection() {
+    JavaFileObject injected =
+        JavaFileObjects.forSourceLines(
+            "test.Injected",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "final class Injected {",
+            "  @Inject static Object object;",
+            "}");
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface TestComponent {",
+            "  void inject(Injected injected);",
+            "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(injected, component))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("static fields")
+        .in(injected)
+        .onLine(6);
+  }
+
   @Test public void cyclicDependency() {
     JavaFileObject component = JavaFileObjects.forSourceLines("test.Outer",
         "package test;",
@@ -233,7 +270,7 @@ public void membersInjectDependsOnUnboundedType() {
     String expectedError =
         Joiner.on('\n')
             .join(
-                "test.Outer.CComponent.getC() contains a dependency cycle:",
+                "Found a dependency cycle:",
                 "      test.Outer.C is injected at",
                 "          test.Outer.A.<init>(cParam)",
                 "      test.Outer.A is injected at",
@@ -286,7 +323,7 @@ public void membersInjectDependsOnUnboundedType() {
     String expectedError =
         Joiner.on('\n')
             .join(
-                "test.Outer.DComponent.getD() contains a dependency cycle:",
+                "Found a dependency cycle:",
                 "      test.Outer.C is injected at",
                 "          test.Outer.A.<init>(cParam)",
                 "      test.Outer.A is injected at",
@@ -358,7 +395,7 @@ public void cyclicDependencyNotBrokenByMapBinding() {
     String expectedError =
         Joiner.on('\n')
             .join(
-                "test.Outer.CComponent.getC() contains a dependency cycle:",
+                "Found a dependency cycle:",
                 "      test.Outer.C is injected at",
                 "          test.Outer.CModule.c(c)",
                 "      java.util.Map<java.lang.String,test.Outer.C> is injected at",
@@ -423,7 +460,7 @@ public void cyclicDependencyWithSetBinding() {
     String expectedError =
         Joiner.on('\n')
             .join(
-                "test.Outer.CComponent.getC() contains a dependency cycle:",
+                "Found a dependency cycle:",
                 "      test.Outer.C is injected at",
                 "          test.Outer.CModule.c(c)",
                 "      java.util.Set<test.Outer.C> is injected at",
@@ -483,7 +520,7 @@ public void falsePositiveCyclicDependencyIndirectionDetected() {
     String expectedError =
         Joiner.on('\n')
             .join(
-                "test.Outer.DComponent.getD() contains a dependency cycle:",
+                "Found a dependency cycle:",
                 "      test.Outer.C is injected at",
                 "          test.Outer.A.<init>(cParam)",
                 "      test.Outer.A is injected at",
@@ -504,6 +541,193 @@ public void falsePositiveCyclicDependencyIndirectionDetected() {
         .onLine(28);
   }
 
+  @Test
+  public void cyclicDependencyInSubcomponents() {
+    JavaFileObject parent =
+        JavaFileObjects.forSourceLines(
+            "test.Parent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface Parent {",
+            "  Child child();",
+            "}");
+    JavaFileObject child =
+        JavaFileObjects.forSourceLines(
+            "test.Child",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = ChildModule.class)",
+            "interface Child {",
+            "  Grandchild grandchild();",
+            "}");
+    JavaFileObject grandchild =
+        JavaFileObjects.forSourceLines(
+            "test.Grandchild",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = GrandchildModule.class)",
+            "interface Grandchild {",
+            "  String entry();",
+            "}");
+    JavaFileObject childModule =
+        JavaFileObjects.forSourceLines(
+            "test.ChildModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "abstract class ChildModule {",
+            "  @Provides static Object object(String string) {",
+            "    return string;",
+            "  }",
+            "}");
+    JavaFileObject grandchildModule =
+        JavaFileObjects.forSourceLines(
+            "test.GrandchildModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "abstract class GrandchildModule {",
+            "  @Provides static String string(Object object) {",
+            "    return object.toString();",
+            "  }",
+            "}");
+
+    String expectedError =
+        Joiner.on('\n')
+            .join(
+                "[test.Grandchild.entry()] Found a dependency cycle:",
+                "      java.lang.String is injected at",
+                "          test.ChildModule.object(string)",
+                "      java.lang.Object is injected at",
+                "          test.GrandchildModule.string(object)",
+                "      java.lang.String is provided at",
+                "          test.Grandchild.entry()");
+
+    assertAbout(javaSources())
+        .that(ImmutableList.of(parent, child, grandchild, childModule, grandchildModule))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(expectedError)
+        .in(child)
+        .onLine(6);
+  }
+
+  @Test
+  public void circularBindsMethods() {
+    JavaFileObject qualifier =
+        JavaFileObjects.forSourceLines(
+            "test.SomeQualifier",
+            "package test;",
+            "",
+            "import javax.inject.Qualifier;",
+            "",
+            "@Qualifier @interface SomeQualifier {}");
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Binds;",
+            "import dagger.Module;",
+            "",
+            "@Module",
+            "abstract class TestModule {",
+            "  @Binds abstract Object bindUnqualified(@SomeQualifier Object qualified);",
+            "  @Binds @SomeQualifier abstract Object bindQualified(Object unqualified);",
+            "}");
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = TestModule.class)",
+            "interface TestComponent {",
+            "  Object unqualified();",
+            "  @SomeQualifier Object qualified();",
+            "}");
+
+    assertThat(qualifier, module, component)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            "Found a dependency cycle:\n"
+                + "      java.lang.Object is injected at\n"
+                + "          test.TestModule.bindQualified(unqualified)\n"
+                + "      @test.SomeQualifier java.lang.Object is injected at\n"
+                + "          test.TestModule.bindUnqualified(qualified)\n"
+                + "      java.lang.Object is provided at\n"
+                + "          test.TestComponent.unqualified()")
+        .in(component)
+        .onLine(7)
+        .and()
+        .withErrorContaining(
+            "Found a dependency cycle:\n"
+                + "      @test.SomeQualifier java.lang.Object is injected at\n"
+                + "          test.TestModule.bindUnqualified(qualified)\n"
+                + "      java.lang.Object is injected at\n"
+                + "          test.TestModule.bindQualified(unqualified)\n"
+                + "      @test.SomeQualifier java.lang.Object is provided at\n"
+                + "          test.TestComponent.qualified()")
+        .in(component)
+        .onLine(8);
+  }
+
+  @Test
+  public void selfReferentialBinds() {
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Binds;",
+            "import dagger.Module;",
+            "",
+            "@Module",
+            "abstract class TestModule {",
+            "  @Binds abstract Object bindToSelf(Object sameKey);",
+            "}");
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = TestModule.class)",
+            "interface TestComponent {",
+            "  Object selfReferential();",
+            "}");
+
+    assertThat(module, component)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            // TODO(gak): cl/126230644 produces a better error message in this case. Here it isn't
+            // unclear what is going wrong.
+            "Found a dependency cycle:\n"
+                + "      java.lang.Object is injected at\n"
+                + "          test.TestModule.bindToSelf(sameKey)\n"
+                + "      java.lang.Object is provided at\n"
+                + "          test.TestComponent.selfReferential()")
+        .in(component)
+        .onLine(7);
+  }
+
   @Test public void duplicateExplicitBindings_ProvidesAndComponentProvision() {
     JavaFileObject component = JavaFileObjects.forSourceLines("test.Outer",
         "package test;",
@@ -587,7 +811,57 @@ public void falsePositiveCyclicDependencyIndirectionDetected() {
         .failsToCompile()
         .withErrorContaining(expectedError).in(component).onLine(24);
   }
-  
+
+  @Test
+  public void duplicateExplicitBindings_ProvidesVsBinds() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.Outer",
+            "package test;",
+            "",
+            "import dagger.Binds;",
+            "import dagger.Component;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import javax.inject.Inject;",
+            "",
+            "final class Outer {",
+            "  interface A {}",
+            "",
+            "  static final class B implements A {",
+            "    @Inject B() {}",
+            "  }",
+            "",
+            "  @Module",
+            "  static class Module1 {",
+            "    @Provides A provideA1() { return new A() {}; }",
+            "  }",
+            "",
+            "  @Module",
+            "  static abstract class Module2 {",
+            "    @Binds abstract A bindA2(B b);",
+            "  }",
+            "",
+            "  @Component(modules = { Module1.class, Module2.class})",
+            "  interface TestComponent {",
+            "    A getA();",
+            "  }",
+            "}");
+
+    assertAbout(javaSource())
+        .that(component)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            Joiner.on("\n      ")
+                .join(
+                    "test.Outer.A is bound multiple times:",
+                    "@Provides test.Outer.A test.Outer.Module1.provideA1()",
+                    "@Binds test.Outer.A test.Outer.Module2.bindA2(test.Outer.B)"))
+        .in(component)
+        .onLine(28);
+  }
+
   @Test public void duplicateExplicitBindings_MultipleProvisionTypes() {
     JavaFileObject component = JavaFileObjects.forSourceLines("test.Outer",
         "package test;",
@@ -689,6 +963,8 @@ public void duplicateExplicitBindings_UniqueBindingAndMultibindingDeclaration()
             "test.Outer",
             "package test;",
             "",
+            "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
+            "",
             "import dagger.Component;",
             "import dagger.Module;",
             "import dagger.Multibindings;",
@@ -698,8 +974,6 @@ public void duplicateExplicitBindings_UniqueBindingAndMultibindingDeclaration()
             "import java.util.Map;",
             "import java.util.Set;",
             "",
-            "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
-            "",
             "final class Outer {",
             "  @Module",
             "  static class TestModule1 {",
@@ -753,7 +1027,7 @@ public void duplicateExplicitBindings_UniqueBindingAndMultibindingDeclaration()
         .in(component)
         .onLine(36);
   }
-  
+
   @Test public void duplicateBindings_TruncateAfterLimit() {
     JavaFileObject component = JavaFileObjects.forSourceLines("test.Outer",
         "package test;",
@@ -871,10 +1145,12 @@ public void duplicateExplicitBindings_UniqueBindingAndMultibindingDeclaration()
             "package test;",
             "",
             "import dagger.Component;",
+            "import dagger.Lazy;",
             "import dagger.Module;",
             "import dagger.Provides;",
             "import javax.inject.Inject;",
             "import javax.inject.Named;",
+            "import javax.inject.Provider;",
             "",
             "final class TestClass {",
             "  interface A {}",
@@ -907,44 +1183,59 @@ public void duplicateExplicitBindings_UniqueBindingAndMultibindingDeclaration()
             "  interface AComponent {",
             "    @Named(\"slim shady\") D getFoo();",
             "    C injectC(C c);",
+            "    Provider<C> cProvider();",
+            "    Lazy<C> lazyC();",
+            "    Provider<Lazy<C>> lazyCProvider();",
             "  }",
             "}");
     String errorText = "test.TestClass.A cannot be provided without an @Provides-annotated method.";
     String firstError =
-        Joiner.on('\n')
+        Joiner.on("\n      ")
             .join(
                 errorText,
-                "      test.TestClass.A is injected at",
-                "          test.TestClass.B.<init>(a)",
-                "      test.TestClass.B is injected at",
-                "          test.TestClass.C.b",
-                "      test.TestClass.C is injected at",
-                "          test.TestClass.DImpl.<init>(c, …)",
-                "      test.TestClass.DImpl is injected at",
-                "          test.TestClass.DModule.d(…, impl, …)",
-                "      @javax.inject.Named(\"slim shady\") test.TestClass.D is provided at",
-                "          test.TestClass.AComponent.getFoo()");
-    String secondError =
-        Joiner.on('\n')
+                "test.TestClass.A is injected at",
+                "    test.TestClass.B.<init>(a)",
+                "test.TestClass.B is injected at",
+                "    test.TestClass.C.b",
+                "test.TestClass.C is injected at",
+                "    test.TestClass.DImpl.<init>(c, …)",
+                "test.TestClass.DImpl is injected at",
+                "    test.TestClass.DModule.d(…, impl, …)",
+                "@javax.inject.Named(\"slim shady\") test.TestClass.D is provided at",
+                "    test.TestClass.AComponent.getFoo()");
+    String otherErrorFormat =
+        Joiner.on("\n      ")
             .join(
                 errorText,
-                "      test.TestClass.A is injected at",
-                "          test.TestClass.B.<init>(a)",
-                "      test.TestClass.B is injected at",
-                "          test.TestClass.C.b",
-                "      test.TestClass.C is injected at",
-                "          test.TestClass.AComponent.injectC(c)");
+                "test.TestClass.A is injected at",
+                "    test.TestClass.B.<init>(a)",
+                "test.TestClass.B is injected at",
+                "    test.TestClass.C.b",
+                "test.TestClass.C is %s at",
+                "    test.TestClass.AComponent.%s");
     assertAbout(javaSource())
         .that(component)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(firstError)
         .in(component)
-        .onLine(38)
+        .onLine(40)
+        .and()
+        .withErrorContaining(String.format(otherErrorFormat, "injected", "injectC(c)"))
+        .in(component)
+        .onLine(41)
         .and()
-        .withErrorContaining(secondError)
+        .withErrorContaining(String.format(otherErrorFormat, "provided", "cProvider()"))
         .in(component)
-        .onLine(39);
+        .onLine(42)
+        .and()
+        .withErrorContaining(String.format(otherErrorFormat, "provided", "lazyC()"))
+        .in(component)
+        .onLine(43)
+        .and()
+        .withErrorContaining(String.format(otherErrorFormat, "provided", "lazyCProvider()"))
+        .in(component)
+        .onLine(44);
   }
 
   @Test
@@ -997,6 +1288,89 @@ public void bindsMethodAppearsInTrace() {
         .onLine(5);
   }
 
+  @Test
+  public void bindsMissingRightHandSide() {
+    JavaFileObject duplicates =
+        JavaFileObjects.forSourceLines(
+            "test.Duplicates",
+            "package test;",
+            "",
+            "import dagger.Binds;",
+            "import dagger.Component;",
+            "import dagger.Module;",
+            "import dagger.multibindings.IntKey;",
+            "import dagger.multibindings.IntoSet;",
+            "import dagger.multibindings.IntoMap;",
+            "import dagger.multibindings.LongKey;",
+            "import dagger.Provides;",
+            "import javax.inject.Inject;",
+            "",
+            "interface Duplicates {",
+            "",
+            "  interface BoundTwice {}",
+            "",
+            "  class BoundImpl implements BoundTwice {",
+            "    @Inject BoundImpl() {}",
+            "  }",
+            "",
+            "  class NotBound implements BoundTwice {}",
+            "",
+            "  @Module",
+            "  abstract class DuplicatesModule {",
+            "    @Binds abstract BoundTwice bindWithResolvedKey(BoundImpl impl);",
+            "    @Binds abstract BoundTwice bindWithUnresolvedKey(NotBound notBound);",
+            "",
+            "    @Binds abstract Object bindObject(NotBound notBound);",
+            "",
+            "    @Binds @IntoSet abstract BoundTwice bindWithUnresolvedKey_set(NotBound notBound);",
+            "",
+            "    @Binds @IntoMap @IntKey(1)",
+            "    abstract BoundTwice bindWithUnresolvedKey_intMap(NotBound notBound);",
+            "",
+            "    @Provides @IntoMap @LongKey(2L)",
+            "    static BoundTwice provideWithUnresolvedKey_longMap(BoundImpl impl) {",
+            "      return impl;",
+            "    }",
+            "    @Binds @IntoMap @LongKey(2L)",
+            "    abstract BoundTwice bindWithUnresolvedKey_longMap(NotBound notBound);",
+            "  }",
+            "}");
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.C",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import java.util.Set;",
+            "import java.util.Map;",
+            "import test.Duplicates.BoundTwice;",
+            "",
+            "@Component(modules = Duplicates.DuplicatesModule.class)",
+            "interface C {",
+            "  BoundTwice boundTwice();",
+            "  Object object();",
+            "  Set<BoundTwice> set();",
+            "  Map<Integer, BoundTwice> intMap();",
+            "  Map<Long, BoundTwice> longMap();",
+            "}");
+
+    assertThat(duplicates, component)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("test.Duplicates.BoundTwice is bound multiple times:")
+            .in(component).onLine(10)
+        .and().withErrorContaining("test.Duplicates.DuplicatesModule.bindWithUnresolvedKey")
+            .in(component).onLine(10)
+        .and().withErrorContaining("test.Duplicates.NotBound cannot be provided")
+            .in(component).onLine(11)
+        .and().withErrorContaining("test.Duplicates.NotBound cannot be provided")
+            .in(component).onLine(12)
+        .and().withErrorContaining("test.Duplicates.NotBound cannot be provided")
+            .in(component).onLine(13)
+        .and().withErrorContaining("same map key is bound more than once")
+            .in(component).onLine(14);
+  }
+
   @Test public void resolvedParametersInDependencyTrace() {
     JavaFileObject generic = JavaFileObjects.forSourceLines("test.Generic",
         "package test;",
@@ -1272,6 +1646,190 @@ public void bindsMethodAppearsInTrace() {
         .compilesWithoutError();
   }
 
+  @Test
+  public void nullCheckForOptionalInstance() {
+    JavaFileObject a =
+        JavaFileObjects.forSourceLines(
+            "test.A",
+            "package test;",
+            "",
+            "import com.google.common.base.Optional;",
+            "import javax.inject.Inject;",
+            "",
+            "final class A {",
+            "  @Inject A(Optional<String> optional) {}",
+            "}");
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.BindsOptionalOf;",
+            "import dagger.Provides;",
+            "import javax.inject.Inject;",
+            "",
+            "@dagger.Module",
+            "abstract class TestModule {",
+            "  @Nullable @Provides static String provideString() { return null; }",
+            "  @BindsOptionalOf abstract String optionalString();",
+            "}");
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = TestModule.class)",
+            "interface TestComponent {",
+            "  A a();",
+            "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(NULLABLE, a, module, component))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            nullableToNonNullable(
+                "java.lang.String",
+                "@test.Nullable @Provides String test.TestModule.provideString()"));
+  }
+
+  @Test
+  public void nullCheckForOptionalProvider() {
+    JavaFileObject a =
+        JavaFileObjects.forSourceLines(
+            "test.A",
+            "package test;",
+            "",
+            "import com.google.common.base.Optional;",
+            "import javax.inject.Inject;",
+            "import javax.inject.Provider;",
+            "",
+            "final class A {",
+            "  @Inject A(Optional<Provider<String>> optional) {}",
+            "}");
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.BindsOptionalOf;",
+            "import dagger.Provides;",
+            "import javax.inject.Inject;",
+            "",
+            "@dagger.Module",
+            "abstract class TestModule {",
+            "  @Nullable @Provides static String provideString() { return null; }",
+            "  @BindsOptionalOf abstract String optionalString();",
+            "}");
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = TestModule.class)",
+            "interface TestComponent {",
+            "  A a();",
+            "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(NULLABLE, a, module, component))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError();
+  }
+
+  @Test
+  public void nullCheckForOptionalLazy() {
+    JavaFileObject a =
+        JavaFileObjects.forSourceLines(
+            "test.A",
+            "package test;",
+            "",
+            "import com.google.common.base.Optional;",
+            "import dagger.Lazy;",
+            "import javax.inject.Inject;",
+            "",
+            "final class A {",
+            "  @Inject A(Optional<Lazy<String>> optional) {}",
+            "}");
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.BindsOptionalOf;",
+            "import dagger.Provides;",
+            "import javax.inject.Inject;",
+            "",
+            "@dagger.Module",
+            "abstract class TestModule {",
+            "  @Nullable @Provides static String provideString() { return null; }",
+            "  @BindsOptionalOf abstract String optionalString();",
+            "}");
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = TestModule.class)",
+            "interface TestComponent {",
+            "  A a();",
+            "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(NULLABLE, a, module, component))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError();
+  }
+
+  @Test
+  public void nullCheckForOptionalProviderOfLazy() {
+    JavaFileObject a =
+        JavaFileObjects.forSourceLines(
+            "test.A",
+            "package test;",
+            "",
+            "import com.google.common.base.Optional;",
+            "import dagger.Lazy;",
+            "import javax.inject.Inject;",
+            "import javax.inject.Provider;",
+            "",
+            "final class A {",
+            "  @Inject A(Optional<Provider<Lazy<String>>> optional) {}",
+            "}");
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.BindsOptionalOf;",
+            "import dagger.Provides;",
+            "import javax.inject.Inject;",
+            "",
+            "@dagger.Module",
+            "abstract class TestModule {",
+            "  @Nullable @Provides static String provideString() { return null; }",
+            "  @BindsOptionalOf abstract String optionalString();",
+            "}");
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = TestModule.class)",
+            "interface TestComponent {",
+            "  A a();",
+            "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(NULLABLE, a, module, component))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError();
+  }
+
   @Test public void componentDependencyMustNotCycle_Direct() {
     JavaFileObject shortLifetime = JavaFileObjects.forSourceLines("test.ComponentShort",
         "package test;",
@@ -1342,7 +1900,7 @@ public void bindsMethodAppearsInTrace() {
         .and()
         .withErrorContaining(shortErrorMessage).in(shortLifetime);
   }
-  
+
   @Test
   public void subcomponentBindingConflictsWithParent() {
     JavaFileObject parentChildConflict =
@@ -1369,7 +1927,7 @@ public void subcomponentBindingConflictsWithParent() {
             "import javax.inject.Qualifier;",
             "",
             "@Qualifier @interface ChildGrandchildConflict {}");
-    
+
     /* Some annotation processor implementations do not report more than one error per element. So
      * separate parents for testing parent-conflicts-with-child and
      * parent-conflicts-with-grandchild.
@@ -1572,7 +2130,7 @@ public void subcomponentBindingConflictsWithParentWithNullableViolationAsWarning
         .in(parentConflictsWithChild)
         .onLine(9);
   }
-  
+
   @Test
   public void bindingUsedOnlyInSubcomponentDependsOnBindingOnlyInSubcomponent() {
     JavaFileObject parent =
@@ -1626,7 +2184,7 @@ public void bindingUsedOnlyInSubcomponentDependsOnBindingOnlyInSubcomponent() {
         .in(parent)
         .onLine(4);
   }
-  
+
   @Test
   public void multibindingContributionBetweenAncestorComponentAndEntrypointComponent() {
     JavaFileObject parent =
@@ -1700,4 +2258,277 @@ public void multibindingContributionBetweenAncestorComponentAndEntrypointCompone
         .in(parent)
         .onLine(4);
   }
+
+  @Test
+  public void missingReleasableReferenceManager() {
+    JavaFileObject testScope =
+        JavaFileObjects.forSourceLines(
+            "test.TestScope",
+            "package test;",
+            "",
+            "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
+            "",
+            "import dagger.releasablereferences.CanReleaseReferences;",
+            "import java.lang.annotation.Retention;",
+            "import javax.inject.Scope;",
+            "",
+            "@CanReleaseReferences",
+            "@BadMetadata",
+            "@Scope",
+            "@Retention(RUNTIME)",
+            "@interface TestScope {}");
+    JavaFileObject otherScope =
+        JavaFileObjects.forSourceLines(
+            "test.OtherScope",
+            "package test;",
+            "",
+            "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
+            "",
+            "import dagger.releasablereferences.CanReleaseReferences;",
+            "import java.lang.annotation.Retention;",
+            "import javax.inject.Scope;",
+            "",
+            "@CanReleaseReferences",
+            "@Scope",
+            "@Retention(RUNTIME)",
+            "@interface OtherScope {}");
+    JavaFileObject yetAnotherScope =
+        JavaFileObjects.forSourceLines(
+            "test.YetAnotherScope",
+            "package test;",
+            "",
+            "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
+            "",
+            "import dagger.releasablereferences.CanReleaseReferences;",
+            "import java.lang.annotation.Retention;",
+            "import javax.inject.Scope;",
+            "",
+            "@CanReleaseReferences",
+            "@Scope",
+            "@Retention(RUNTIME)",
+            "@interface YetAnotherScope {}");
+    JavaFileObject testMetadata =
+        JavaFileObjects.forSourceLines(
+            "test.TestMetadata",
+            "package test;",
+            "",
+            "import dagger.releasablereferences.CanReleaseReferences;",
+            "",
+            "@CanReleaseReferences",
+            "@interface TestMetadata {}");
+    JavaFileObject badMetadata =
+        JavaFileObjects.forSourceLines(
+            "test.BadMetadata", // force one-string-per-line format
+            "package test;",
+            "",
+            "@interface BadMetadata {}");
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import dagger.releasablereferences.ForReleasableReferences;",
+            "import dagger.releasablereferences.ReleasableReferenceManager;",
+            "import dagger.releasablereferences.TypedReleasableReferenceManager;",
+            "",
+            "@TestScope",
+            "@YetAnotherScope",
+            "@Component",
+            "interface TestComponent {",
+            "  @ForReleasableReferences(OtherScope.class)",
+            "  ReleasableReferenceManager otherManager();",
+            "",
+            "  @ForReleasableReferences(TestScope.class)",
+            "  TypedReleasableReferenceManager<TestMetadata> typedManager();",
+            "",
+            "  @ForReleasableReferences(TestScope.class)",
+            "  TypedReleasableReferenceManager<BadMetadata> badManager();",
+            "}");
+    assertAbout(javaSources())
+        .that(
+            ImmutableList.of(
+                testScope, otherScope, yetAnotherScope, testMetadata, badMetadata, component))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            "There is no binding for "
+                + "@dagger.releasablereferences.ForReleasableReferences(test.OtherScope.class) "
+                + "dagger.releasablereferences.ReleasableReferenceManager "
+                + "because no component in test.TestComponent's component hierarchy is annotated "
+                + "with @test.OtherScope. "
+                + "The available reference-releasing scopes are "
+                + "[@test.TestScope, @test.YetAnotherScope].")
+        .in(component)
+        .onLine(13)
+        .and()
+        .withErrorContaining(
+            "There is no binding for "
+                + "@dagger.releasablereferences.ForReleasableReferences(test.TestScope.class) "
+                + "dagger.releasablereferences.TypedReleasableReferenceManager<test.TestMetadata> "
+                + "because test.TestScope is not annotated with @test.TestMetadata")
+        .in(component)
+        .onLine(16)
+        .and()
+        .withErrorContaining(
+            "There is no binding for "
+                + "@dagger.releasablereferences.ForReleasableReferences(test.TestScope.class) "
+                + "dagger.releasablereferences.TypedReleasableReferenceManager<test.BadMetadata> "
+                + "because test.BadMetadata is not annotated with "
+                + "@dagger.releasablereferences.CanReleaseReferences")
+        .in(component)
+        .onLine(19);
+  }
+
+  @Test
+  public void releasableReferenceManagerConflict() {
+    JavaFileObject testScope =
+        JavaFileObjects.forSourceLines(
+            "test.TestScope",
+            "package test;",
+            "",
+            "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
+            "",
+            "import dagger.releasablereferences.CanReleaseReferences;",
+            "import java.lang.annotation.Retention;",
+            "import javax.inject.Scope;",
+            "",
+            "@TestMetadata",
+            "@CanReleaseReferences",
+            "@Scope",
+            "@Retention(RUNTIME)",
+            "@interface TestScope {}");
+    JavaFileObject testMetadata =
+        JavaFileObjects.forSourceLines(
+            "test.TestMetadata",
+            "package test;",
+            "",
+            "import dagger.releasablereferences.CanReleaseReferences;",
+            "",
+            "@CanReleaseReferences",
+            "@interface TestMetadata {}");
+
+    JavaFileObject testModule =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.releasablereferences.ForReleasableReferences;",
+            "import dagger.releasablereferences.ReleasableReferenceManager;",
+            "import dagger.releasablereferences.TypedReleasableReferenceManager;",
+            "import java.util.Set;",
+            "",
+            "@Module",
+            "abstract class TestModule {",
+            "  @Provides @ForReleasableReferences(TestScope.class)",
+            "  static ReleasableReferenceManager rrm() {",
+            "    return null;",
+            "  }",
+            "",
+            "  @Provides @ForReleasableReferences(TestScope.class)",
+            "  static TypedReleasableReferenceManager<TestMetadata> typedRrm() {",
+            "    return null;",
+            "  }",
+            "",
+            "  @Provides",
+            "  static Set<ReleasableReferenceManager> rrmSet() {",
+            "    return null;",
+            "  }",
+            "",
+            "  @Provides",
+            "  static Set<TypedReleasableReferenceManager<TestMetadata>> typedRrmSet() {",
+            "    return null;",
+            "  }",
+            "}");
+
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import dagger.releasablereferences.ForReleasableReferences;",
+            "import dagger.releasablereferences.ReleasableReferenceManager;",
+            "import dagger.releasablereferences.TypedReleasableReferenceManager;",
+            "import java.util.Set;",
+            "",
+            "@TestScope",
+            "@Component(modules = TestModule.class)",
+            "interface TestComponent {",
+            "  @ForReleasableReferences(TestScope.class)",
+            "  ReleasableReferenceManager testManager();",
+            "",
+            "  @ForReleasableReferences(TestScope.class)",
+            "  TypedReleasableReferenceManager<TestMetadata> typedManager();",
+            "",
+            "  Set<ReleasableReferenceManager> managers();",
+            "  Set<TypedReleasableReferenceManager<TestMetadata>> typedManagers();",
+            "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(testScope, testMetadata, testModule, component))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            String.format(
+                error(
+                    "@%1$s.ForReleasableReferences(test.TestScope.class) "
+                        + "%1$s.ReleasableReferenceManager is bound multiple times:",
+                    "@Provides @%1$s.ForReleasableReferences(test.TestScope.class) "
+                        + "%1$s.ReleasableReferenceManager test.TestModule.rrm()",
+                    "binding for "
+                        + "@%1$s.ForReleasableReferences(value = test.TestScope.class) "
+                        + "%1$s.ReleasableReferenceManager from the scope declaration"),
+                "dagger.releasablereferences"))
+        .in(component)
+        .onLine(13)
+        .and()
+        .withErrorContaining(
+            String.format(
+                error(
+                    "@%1$s.ForReleasableReferences(test.TestScope.class) "
+                        + "%1$s.TypedReleasableReferenceManager<test.TestMetadata> "
+                        + "is bound multiple times:",
+                    "@Provides @%1$s.ForReleasableReferences(test.TestScope.class) "
+                        + "%1$s.TypedReleasableReferenceManager<test.TestMetadata> "
+                        + "test.TestModule.typedRrm()",
+                    "binding for "
+                        + "@%1$s.ForReleasableReferences(value = test.TestScope.class) "
+                        + "%1$s.TypedReleasableReferenceManager<test.TestMetadata> "
+                        + "from the scope declaration"),
+                "dagger.releasablereferences"))
+        .in(component)
+        .onLine(16)
+        .and()
+        .withErrorContaining(
+            error(
+                "java.util.Set<dagger.releasablereferences.ReleasableReferenceManager> "
+                    + "is bound multiple times:",
+                "@Provides "
+                    + "Set<dagger.releasablereferences.ReleasableReferenceManager> "
+                    + "test.TestModule.rrmSet()",
+                "Dagger-generated binding for "
+                    + "Set<dagger.releasablereferences.ReleasableReferenceManager>"))
+        .in(component)
+        .onLine(18)
+        .and()
+        .withErrorContaining(
+            String.format(
+                error(
+                    "java.util.Set<%1$s.TypedReleasableReferenceManager<test.TestMetadata>> "
+                        + "is bound multiple times:",
+                    "@Provides "
+                        + "Set<%1$s.TypedReleasableReferenceManager<test.TestMetadata>> "
+                        + "test.TestModule.typedRrmSet()",
+                    "Dagger-generated binding for "
+                        + "Set<%1$s.TypedReleasableReferenceManager<test.TestMetadata>>"),
+                "dagger.releasablereferences"))
+        .in(component)
+        .onLine(19);
+  }
+
+  private String error(String... lines) {
+    return Joiner.on("\n      ").join(lines);
+  }
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/InaccessibleTypeTest.java b/compiler/src/test/java/dagger/internal/codegen/InaccessibleTypeTest.java
index 5a1097968..4f2932e41 100644
--- a/compiler/src/test/java/dagger/internal/codegen/InaccessibleTypeTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/InaccessibleTypeTest.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,8 +13,13 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal.codegen;
 
+import static com.google.common.truth.Truth.assertAbout;
+import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
+
 import com.google.common.collect.ImmutableList;
 import com.google.testing.compile.JavaFileObjects;
 import javax.tools.JavaFileObject;
@@ -22,10 +27,6 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import static com.google.common.truth.Truth.assertAbout;
-import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
-import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
-
 @RunWith(JUnit4.class)
 public class InaccessibleTypeTest {
   @Test public void basicInjectedType() {
@@ -66,7 +67,6 @@
         "package test;",
         "",
         "import dagger.Component;",
-        "",
         "import foreign.PublicClass;",
         "import javax.inject.Provider;",
         "",
@@ -74,76 +74,88 @@
         "interface TestComponent {",
         "  PublicClass publicClass();",
         "}");
-    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
-        "test.DaggerTestComponent",
-        "package test;",
-        "",
-        "import foreign.NoDepClass_Factory;",
-        "import foreign.NonPublicClass1_Factory;",
-        "import foreign.NonPublicClass2_Factory;",
-        "import foreign.PublicClass;",
-        "import foreign.PublicClass_Factory;",
-        "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
-        "",
-        GENERATED_ANNOTATION,
-        "public final class DaggerTestComponent implements TestComponent {",
-        "  @SuppressWarnings(\"rawtypes\")",
-        "  private Provider nonPublicClass1Provider;",
-        "  @SuppressWarnings(\"rawtypes\")",
-        "  private Provider nonPublicClass2Provider;",
-        "  private Provider<PublicClass> publicClassProvider;",
-        "",
-        "  private DaggerTestComponent(Builder builder) {",
-        "    assert builder != null;",
-        "    initialize(builder);",
-        "  }",
-        "",
-        "  public static Builder builder() {",
-        "    return new Builder();",
-        "  }",
-        "",
-        "  public static TestComponent create() {",
-        "    return builder().build();",
-        "  }",
-        "",
-        "  @SuppressWarnings(\"unchecked\")",
-        "  private void initialize(final Builder builder) {",
-        "    this.nonPublicClass1Provider =",
-        "        NonPublicClass1_Factory.create(NoDepClass_Factory.create());",
-        "    this.nonPublicClass2Provider =",
-        "        NonPublicClass2_Factory.create(NoDepClass_Factory.create());",
-        "    this.publicClassProvider = PublicClass_Factory.create(",
-        "        nonPublicClass1Provider,",
-        "        nonPublicClass2Provider,",
-        "        NoDepClass_Factory.create());",
-        "  }",
-        "",
-        "  @Override",
-        "  public PublicClass publicClass() {",
-        "    return publicClassProvider.get();",
-        "  }",
-        "",
-        "  public static final class Builder {",
-        "    private Builder() {",
-        "    }",
-        "",
-        "    public TestComponent build() {",
-        "      return new DaggerTestComponent(this);",
-        "    }",
-        "  }",
-        "}");
+    JavaFileObject generatedComponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerTestComponent",
+            "package test;",
+            "",
+            "import foreign.NoDepClass_Factory;",
+            "import foreign.NonPublicClass1_Factory;",
+            "import foreign.NonPublicClass2_Factory;",
+            "import foreign.PublicClass;",
+            "import foreign.PublicClass_Factory;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerTestComponent implements TestComponent {",
+            "  @SuppressWarnings(\"rawtypes\")",
+            "  private Provider nonPublicClass1Provider;",
+            "  @SuppressWarnings(\"rawtypes\")",
+            "  private Provider nonPublicClass2Provider;",
+            "  private Provider<PublicClass> publicClassProvider;",
+            "",
+            "  private DaggerTestComponent(Builder builder) {",
+            "    assert builder != null;",
+            "    initialize(builder);",
+            "  }",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static TestComponent create() {",
+            "    return new Builder().build();",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize(final Builder builder) {",
+            "    this.nonPublicClass1Provider =",
+            "        NonPublicClass1_Factory.create(NoDepClass_Factory.create());",
+            "    this.nonPublicClass2Provider =",
+            "        NonPublicClass2_Factory.create(NoDepClass_Factory.create());",
+            "    this.publicClassProvider = PublicClass_Factory.create(",
+            "        nonPublicClass1Provider,",
+            "        nonPublicClass2Provider,",
+            "        NoDepClass_Factory.create());",
+            "  }",
+            "",
+            "  @Override",
+            "  public PublicClass publicClass() {",
+            "    return PublicClass_Factory.newPublicClass(",
+            "        NonPublicClass1_Factory.newNonPublicClass1(",
+            "            NoDepClass_Factory.newNoDepClass()),",
+            "        NonPublicClass2_Factory.newNonPublicClass2(",
+            "            NoDepClass_Factory.newNoDepClass()),",
+            "        NoDepClass_Factory.newNoDepClass());",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private Builder() {",
+            "    }",
+            "",
+            "    public TestComponent build() {",
+            "      return new DaggerTestComponent(this);",
+            "    }",
+            "  }",
+            "}");
     assertAbout(javaSources())
-        .that(ImmutableList.of(
-            noDepClassFile,
-            publicClassFile,
-            nonPublicClass1File,
-            nonPublicClass2File,
-            componentFile))
-        .withCompilerOptions("-Xlint:-processing", "-Xlint:rawtypes", "-Xlint:unchecked", "-Werror")
+        .that(
+            ImmutableList.of(
+                noDepClassFile,
+                publicClassFile,
+                nonPublicClass1File,
+                nonPublicClass2File,
+                componentFile))
+        .withCompilerOptions(
+            "-Xlint:-processing",
+            "-Xlint:rawtypes",
+            "-Xlint:unchecked",
+            "-Werror")
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
-        .and().generatesSources(generatedComponent);
+        .and()
+        .generatesSources(generatedComponent);
   }
 
   @Test public void memberInjectedType() {
@@ -196,7 +208,6 @@
         "package test;",
         "",
         "import dagger.Component;",
-        "",
         "import javax.inject.Provider;",
         "",
         "@Component",
@@ -225,7 +236,7 @@
             "  }",
             "",
             "  public static TestComponent create() {",
-            "    return builder().build();",
+            "    return new Builder().build();",
             "  }",
             "",
             "  @SuppressWarnings(\"unchecked\")",
@@ -248,16 +259,17 @@
             "  }",
             "}");
     assertAbout(javaSources())
-        .that(ImmutableList.of(
-            noDepClassFile,
-            aClassFile,
-            bClassFile,
-            cClassFile,
-            dClassFile,
-            componentFile))
-        .withCompilerOptions("-Xlint:-processing", "-Xlint:rawtypes", "-Xlint:unchecked", "-Werror")
+        .that(
+            ImmutableList.of(
+                noDepClassFile, aClassFile, bClassFile, cClassFile, dClassFile, componentFile))
+        .withCompilerOptions(
+            "-Xlint:-processing",
+            "-Xlint:rawtypes",
+            "-Xlint:unchecked",
+            "-Werror")
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
-        .and().generatesSources(generatedComponent);
+        .and()
+        .generatesSources(generatedComponent);
   }
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java b/compiler/src/test/java/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java
index 7237812f7..bf557bdc8 100644
--- a/compiler/src/test/java/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Google, Inc.
+ * Copyright (C) 2014 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,14 +13,8 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package dagger.internal.codegen;
 
-import com.google.common.collect.ImmutableList;
-import com.google.testing.compile.JavaFileObjects;
-import javax.tools.JavaFileObject;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
+package dagger.internal.codegen;
 
 import static com.google.common.truth.Truth.assertAbout;
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
@@ -43,6 +37,13 @@
 import static dagger.internal.codegen.ErrorMessages.STATIC_INJECT_METHOD;
 import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
 
+import com.google.common.collect.ImmutableList;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
 @RunWith(JUnit4.class)
 // TODO(gak): add tests for generation in the default package.
 public final class InjectConstructorFactoryGeneratorTest {
@@ -131,31 +132,37 @@
         "class GenericClass<T> {",
         "  @Inject GenericClass(T t) {}",
         "}");
-    JavaFileObject expected = JavaFileObjects.forSourceLines("test.GenericClass_Factory",
-        "package test;",
-        "",
-        "import dagger.internal.Factory;",
-        "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
-        "",
-        GENERATED_ANNOTATION,
-        "public final class GenericClass_Factory<T> implements Factory<GenericClass<T>> {",
-        "  private final Provider<T> tProvider;",
-        "",
-        "  public GenericClass_Factory(Provider<T> tProvider) {",
-        "    assert tProvider != null;",
-        "    this.tProvider = tProvider;",
-        "  }",
-        "",
-        "  @Override",
-        "  public GenericClass<T> get() {",
-        "    return new GenericClass<T>(tProvider.get());",
-        "  }",
-        "",
-        "  public static <T> Factory<GenericClass<T>> create(Provider<T> tProvider) {",
-        "    return new GenericClass_Factory<T>(tProvider);",
-        "  }",
-        "}");
+    JavaFileObject expected =
+        JavaFileObjects.forSourceLines(
+            "test.GenericClass_Factory",
+            "package test;",
+            "",
+            "import dagger.internal.Factory;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class GenericClass_Factory<T> implements Factory<GenericClass<T>> {",
+            "  private final Provider<T> tProvider;",
+            "",
+            "  public GenericClass_Factory(Provider<T> tProvider) {",
+            "    assert tProvider != null;",
+            "    this.tProvider = tProvider;",
+            "  }",
+            "",
+            "  @Override",
+            "  public GenericClass<T> get() {",
+            "    return new GenericClass<T>(tProvider.get());",
+            "  }",
+            "",
+            "  public static <T> Factory<GenericClass<T>> create(Provider<T> tProvider) {",
+            "    return new GenericClass_Factory<T>(tProvider);",
+            "  }",
+            "",
+            "  public static <T> GenericClass<T> newGenericClass(T t) {",
+            "    return new GenericClass<T>(t);",
+            "  }",
+            "}");
     assertAbout(javaSource()).that(file)
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
@@ -221,28 +228,33 @@
         "class GenericClass<T> {",
         "  @Inject GenericClass() {}",
         "}");
-    JavaFileObject expected = JavaFileObjects.forSourceLines("test.GenericClass_Factory",
-        "package test;",
-        "",
-        "import dagger.internal.Factory;",
-        "import javax.annotation.Generated;",
-        "",
-        "@SuppressWarnings(\"rawtypes\")",
-        GENERATED_ANNOTATION,
-        "public enum GenericClass_Factory implements Factory<GenericClass> {",
-        "  INSTANCE;",
-        "",
-        "  @Override",
-        "  public GenericClass get() {",
-        "    return new GenericClass();",
-        "  }",
-        "",
-        "  @SuppressWarnings(\"unchecked\")",
-        "  public static <T> Factory<GenericClass<T>> create() {",
-        "    return (Factory) INSTANCE;",
-        "  }",
-        "",
-        "}");
+    JavaFileObject expected =
+        JavaFileObjects.forSourceLines(
+            "test.GenericClass_Factory",
+            "package test;",
+            "",
+            "import dagger.internal.Factory;",
+            "import javax.annotation.Generated;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class GenericClass_Factory<T> implements Factory<GenericClass<T>> {",
+            "  @SuppressWarnings(\"rawtypes\")",
+            "  private static final GenericClass_Factory INSTANCE = new GenericClass_Factory();",
+            "",
+            "  @Override",
+            "  public GenericClass<T> get() {",
+            "    return new GenericClass<T>();",
+            "  }",
+            "",
+            "  @SuppressWarnings({\"rawtypes\", \"unchecked\"})",
+            "  public static <T> Factory<GenericClass<T>> create() {",
+            "    return (Factory) INSTANCE;",
+            "  }",
+            "",
+            "  public static <T> GenericClass<T> newGenericClass() {",
+            "    return new GenericClass<T>();",
+            "  }",
+            "}");
     assertAbout(javaSource()).that(file)
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
@@ -258,35 +270,41 @@
         "class GenericClass<A, B> {",
         "  @Inject GenericClass(A a, B b) {}",
         "}");
-    JavaFileObject expected = JavaFileObjects.forSourceLines("test.GenericClass_Factory",
-        "package test;",
-        "",
-        "import dagger.internal.Factory;",
-        "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
-        "",
-        GENERATED_ANNOTATION,
-        "public final class GenericClass_Factory<A, B> implements Factory<GenericClass<A, B>> {",
-        "  private final Provider<A> aProvider;",
-        "  private final Provider<B> bProvider;",
-        "",
-        "  public GenericClass_Factory(Provider<A> aProvider, Provider<B> bProvider) {",
-        "    assert aProvider != null;",
-        "    this.aProvider = aProvider;",
-        "    assert bProvider != null;",
-        "    this.bProvider = bProvider;",
-        "  }",
-        "",
-        "  @Override",
-        "  public GenericClass<A, B> get() {",
-        "    return new GenericClass<A, B>(aProvider.get(), bProvider.get());",
-        "  }",
-        "",
-        "  public static <A, B> Factory<GenericClass<A, B>> create(",
-        "      Provider<A> aProvider, Provider<B> bProvider) {",
-        "    return new GenericClass_Factory<A, B>(aProvider, bProvider);",
-        "  }",
-        "}");
+    JavaFileObject expected =
+        JavaFileObjects.forSourceLines(
+            "test.GenericClass_Factory",
+            "package test;",
+            "",
+            "import dagger.internal.Factory;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class GenericClass_Factory<A, B> implements Factory<GenericClass<A, B>> {",
+            "  private final Provider<A> aProvider;",
+            "  private final Provider<B> bProvider;",
+            "",
+            "  public GenericClass_Factory(Provider<A> aProvider, Provider<B> bProvider) {",
+            "    assert aProvider != null;",
+            "    this.aProvider = aProvider;",
+            "    assert bProvider != null;",
+            "    this.bProvider = bProvider;",
+            "  }",
+            "",
+            "  @Override",
+            "  public GenericClass<A, B> get() {",
+            "    return new GenericClass<A, B>(aProvider.get(), bProvider.get());",
+            "  }",
+            "",
+            "  public static <A, B> Factory<GenericClass<A, B>> create(",
+            "      Provider<A> aProvider, Provider<B> bProvider) {",
+            "    return new GenericClass_Factory<A, B>(aProvider, bProvider);",
+            "  }",
+            "",
+            "  public static <A, B> GenericClass<A, B> newGenericClass(A a, B b) {",
+            "    return new GenericClass<A, B>(a, b);",
+            "  }",
+            "}");
     assertAbout(javaSource()).that(file)
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
@@ -305,46 +323,57 @@
         "    C extends List<? super String>> {",
         "  @Inject GenericClass(A a, B b, C c) {}",
         "}");
-    JavaFileObject expected = JavaFileObjects.forSourceLines("test.GenericClass_Factory",
-        "package test;",
-        "",
-        "import dagger.internal.Factory;",
-        "import java.util.List;",
-        "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
-        "",
-        GENERATED_ANNOTATION,
-        "public final class GenericClass_Factory<A extends Number & Comparable<A>,",
-        "        B extends List<? extends String>,",
-        "        C extends List<? super String>>",
-        "    implements Factory<GenericClass<A, B, C>> {",
-        "  private final Provider<A> aProvider;",
-        "  private final Provider<B> bProvider;",
-        "  private final Provider<C> cProvider;",
-        "",
-        "  public GenericClass_Factory(Provider<A> aProvider,",
-        "      Provider<B> bProvider,",
-        "      Provider<C> cProvider) {",
-        "    assert aProvider != null;",
-        "    this.aProvider = aProvider;",
-        "    assert bProvider != null;",
-        "    this.bProvider = bProvider;",
-        "    assert cProvider != null;",
-        "    this.cProvider = cProvider;",
-        "  }",
-        "",
-        "  @Override",
-        "  public GenericClass<A, B, C> get() {",
-        "    return new GenericClass<A, B, C>(aProvider.get(), bProvider.get(), cProvider.get());",
-        "  }",
-        "",
-        "  public static <A extends Number & Comparable<A>,",
-        "      B extends List<? extends String>,",
-        "      C extends List<? super String>> Factory<GenericClass<A, B, C>> create(",
-        "          Provider<A> aProvider, Provider<B> bProvider, Provider<C> cProvider) {",
-        "    return new GenericClass_Factory<A, B, C>(aProvider, bProvider, cProvider);",
-        "  }",
-        "}");
+    JavaFileObject expected =
+        JavaFileObjects.forSourceLines(
+            "test.GenericClass_Factory",
+            "package test;",
+            "",
+            "import dagger.internal.Factory;",
+            "import java.util.List;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class GenericClass_Factory<A extends Number & Comparable<A>,",
+            "        B extends List<? extends String>,",
+            "        C extends List<? super String>>",
+            "    implements Factory<GenericClass<A, B, C>> {",
+            "  private final Provider<A> aProvider;",
+            "  private final Provider<B> bProvider;",
+            "  private final Provider<C> cProvider;",
+            "",
+            "  public GenericClass_Factory(Provider<A> aProvider,",
+            "      Provider<B> bProvider,",
+            "      Provider<C> cProvider) {",
+            "    assert aProvider != null;",
+            "    this.aProvider = aProvider;",
+            "    assert bProvider != null;",
+            "    this.bProvider = bProvider;",
+            "    assert cProvider != null;",
+            "    this.cProvider = cProvider;",
+            "  }",
+            "",
+            "  @Override",
+            "  public GenericClass<A, B, C> get() {",
+            "    return new GenericClass<A, B, C>(",
+            "        aProvider.get(), bProvider.get(), cProvider.get());",
+            "  }",
+            "",
+            "  public static <A extends Number & Comparable<A>,",
+            "      B extends List<? extends String>,",
+            "      C extends List<? super String>> Factory<GenericClass<A, B, C>> create(",
+            "          Provider<A> aProvider, Provider<B> bProvider, Provider<C> cProvider) {",
+            "    return new GenericClass_Factory<A, B, C>(aProvider, bProvider, cProvider);",
+            "  }",
+            "",
+            "  public static <",
+            "          A extends Number & Comparable<A>,",
+            "          B extends List<? extends String>,",
+            "          C extends List<? super String>>",
+            "      GenericClass<A, B, C> newGenericClass(A a, B b, C c) {",
+            "    return new GenericClass<A, B, C>(a, b, c);",
+            "  }",
+            "}");
     assertAbout(javaSource()).that(file)
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
@@ -370,13 +399,15 @@
             "test.GenericClass_Factory",
             "package test;",
             "",
+            "import dagger.Lazy;",
             "import dagger.internal.DoubleCheck;",
             "import dagger.internal.Factory;",
             "import javax.annotation.Generated;",
             "import javax.inject.Provider;",
             "",
             GENERATED_ANNOTATION,
-            "public final class GenericClass_Factory<A, B> implements Factory<GenericClass<A, B>> {",
+            "public final class GenericClass_Factory<A, B>",
+            "    implements Factory<GenericClass<A, B>> {",
             "  private final Provider<A> aAndA2AndPaAndLaProvider;",
             "  private final Provider<A> qaProvider;",
             "  private final Provider<String> sAndS2AndPsAndLsProvider;",
@@ -439,6 +470,26 @@
             "        bAndB2AndPbAndLbProvider,",
             "        qbProvider);",
             "  }",
+            "",
+            "  public static <A, B> GenericClass<A, B> newGenericClass(",
+            "      A a,",
+            "      A a2,",
+            "      Provider<A> pa,",
+            "      A qa,",
+            "      Lazy<A> la,",
+            "      String s,",
+            "      String s2,",
+            "      Provider<String> ps,",
+            "      String qs,",
+            "      Lazy<String> ls,",
+            "      B b,",
+            "      B b2,",
+            "      Provider<B> pb,",
+            "      B qb,",
+            "      Lazy<B> lb) {",
+            "    return new GenericClass<A, B>(",
+            "        a, a2, pa, qa, la, s, s2, ps, qs, ls, b, b2, pb, qb, lb);",
+            "  }",
             "}");
     assertAbout(javaSources()).that(ImmutableList.of(file, QUALIFIER_A))
         .processedWith(new ComponentProcessor())
@@ -921,33 +972,38 @@
         "class InjectConstructor {",
         "  @Inject InjectConstructor(String s) {}",
         "}");
-    JavaFileObject expected = JavaFileObjects.forSourceLines(
-        "test.InjectConstructor_Factory",
-        "package test;",
-        "",
-        "import dagger.internal.Factory;",
-        "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
-        "",
-        GENERATED_ANNOTATION,
-        "public final class InjectConstructor_Factory ",
-        "    implements Factory<InjectConstructor> {",
-        "",
-        "  private final Provider<String> sProvider;",
-        "",
-        "  public InjectConstructor_Factory(Provider<String> sProvider) {",
-        "    assert sProvider != null;",
-        "    this.sProvider = sProvider;",
-        "  }",
-        "",
-        "  @Override public InjectConstructor get() {",
-        "    return new InjectConstructor(sProvider.get());",
-        "  }",
-        "",
-        "  public static Factory<InjectConstructor> create(Provider<String> sProvider) {",
-        "    return new InjectConstructor_Factory(sProvider);",
-        "  }",
-        "}");
+    JavaFileObject expected =
+        JavaFileObjects.forSourceLines(
+            "test.InjectConstructor_Factory",
+            "package test;",
+            "",
+            "import dagger.internal.Factory;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class InjectConstructor_Factory ",
+            "    implements Factory<InjectConstructor> {",
+            "",
+            "  private final Provider<String> sProvider;",
+            "",
+            "  public InjectConstructor_Factory(Provider<String> sProvider) {",
+            "    assert sProvider != null;",
+            "    this.sProvider = sProvider;",
+            "  }",
+            "",
+            "  @Override public InjectConstructor get() {",
+            "    return new InjectConstructor(sProvider.get());",
+            "  }",
+            "",
+            "  public static Factory<InjectConstructor> create(Provider<String> sProvider) {",
+            "    return new InjectConstructor_Factory(sProvider);",
+            "  }",
+            "",
+            "  public static InjectConstructor newInjectConstructor(String s) {",
+            "    return new InjectConstructor(s);",
+            "  }",
+            "}");
     assertAbout(javaSource()).that(file).processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and().generatesSources(expected);
@@ -1066,35 +1122,40 @@ public void wildcardDependency() {
         "class InjectConstructor {",
         "  @Inject InjectConstructor(List<?> objects) {}",
         "}");
-    JavaFileObject expected = JavaFileObjects.forSourceLines(
-        "test.InjectConstructor_Factory",
-        "package test;",
-        "",
-        "import dagger.internal.Factory;",
-        "import java.util.List;",
-        "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
-        "",
-        GENERATED_ANNOTATION,
-        "public final class InjectConstructor_Factory ",
-        "    implements Factory<InjectConstructor> {",
-        "",
-        "  private final Provider<List<?>> objectsProvider;",
-        "",
-        "  public InjectConstructor_Factory(Provider<List<?>> objectsProvider) {",
-        "    assert objectsProvider != null;",
-        "    this.objectsProvider = objectsProvider;",
-        "  }",
-        "",
-        "  @Override public InjectConstructor get() {",
-        "    return new InjectConstructor(objectsProvider.get());",
-        "  }",
-        "",
-        "  public static Factory<InjectConstructor> create(",
-        "      Provider<List<?>> objectsProvider) {",
-        "    return new InjectConstructor_Factory(objectsProvider);",
-        "  }",
-        "}");
+    JavaFileObject expected =
+        JavaFileObjects.forSourceLines(
+            "test.InjectConstructor_Factory",
+            "package test;",
+            "",
+            "import dagger.internal.Factory;",
+            "import java.util.List;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class InjectConstructor_Factory ",
+            "    implements Factory<InjectConstructor> {",
+            "",
+            "  private final Provider<List<?>> objectsProvider;",
+            "",
+            "  public InjectConstructor_Factory(Provider<List<?>> objectsProvider) {",
+            "    assert objectsProvider != null;",
+            "    this.objectsProvider = objectsProvider;",
+            "  }",
+            "",
+            "  @Override public InjectConstructor get() {",
+            "    return new InjectConstructor(objectsProvider.get());",
+            "  }",
+            "",
+            "  public static Factory<InjectConstructor> create(",
+            "      Provider<List<?>> objectsProvider) {",
+            "    return new InjectConstructor_Factory(objectsProvider);",
+            "  }",
+            "",
+            "  public static InjectConstructor newInjectConstructor(List<?> objects) {",
+            "    return new InjectConstructor(objects);",
+            "  }",
+            "}");
     assertAbout(javaSource()).that(file).processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and().generatesSources(expected);
@@ -1115,34 +1176,39 @@ public void basicNameCollision() {
         "class InjectConstructor {",
         "  @Inject InjectConstructor(Factory factory) {}",
         "}");
-    JavaFileObject expected = JavaFileObjects.forSourceLines(
-        "test.InjectConstructor_Factory",
-        "package test;",
-        "",
-        "import dagger.internal.Factory;",
-        "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
-        "",
-        GENERATED_ANNOTATION,
-        "public final class InjectConstructor_Factory ",
-        "    implements Factory<InjectConstructor> {",
-        "",
-        "  private final Provider<other.pkg.Factory> factoryProvider;",
-        "",
-        "  public InjectConstructor_Factory(Provider<other.pkg.Factory> factoryProvider) {",
-        "    assert factoryProvider != null;",
-        "    this.factoryProvider = factoryProvider;",
-        "  }",
-        "",
-        "  @Override public InjectConstructor get() {",
-        "    return new InjectConstructor(factoryProvider.get());",
-        "  }",
-        "",
-        "  public static Factory<InjectConstructor> create(",
-        "      Provider<other.pkg.Factory> factoryProvider) {",
-        "    return new InjectConstructor_Factory(factoryProvider);",
-        "  }",
-        "}");
+    JavaFileObject expected =
+        JavaFileObjects.forSourceLines(
+            "test.InjectConstructor_Factory",
+            "package test;",
+            "",
+            "import dagger.internal.Factory;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class InjectConstructor_Factory ",
+            "    implements Factory<InjectConstructor> {",
+            "",
+            "  private final Provider<other.pkg.Factory> factoryProvider;",
+            "",
+            "  public InjectConstructor_Factory(Provider<other.pkg.Factory> factoryProvider) {",
+            "    assert factoryProvider != null;",
+            "    this.factoryProvider = factoryProvider;",
+            "  }",
+            "",
+            "  @Override public InjectConstructor get() {",
+            "    return new InjectConstructor(factoryProvider.get());",
+            "  }",
+            "",
+            "  public static Factory<InjectConstructor> create(",
+            "      Provider<other.pkg.Factory> factoryProvider) {",
+            "    return new InjectConstructor_Factory(factoryProvider);",
+            "  }",
+            "",
+            "  public static InjectConstructor newInjectConstructor(other.pkg.Factory factory) {",
+            "    return new InjectConstructor(factory);",
+            "  }",
+            "}");
     assertAbout(javaSources()).that(ImmutableList.of(factoryFile, file))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
@@ -1166,35 +1232,40 @@ public void nestedNameCollision() {
         "class InjectConstructor {",
         "  @Inject InjectConstructor(Outer.Factory factory) {}",
         "}");
-    JavaFileObject expected = JavaFileObjects.forSourceLines(
-        "test.InjectConstructor_Factory",
-        "package test;",
-        "",
-        "import dagger.internal.Factory;",
-        "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
-        "import other.pkg.Outer;",
-        "",
-        GENERATED_ANNOTATION,
-        "public final class InjectConstructor_Factory ",
-        "    implements Factory<InjectConstructor> {",
-        "",
-        "  private final Provider<Outer.Factory> factoryProvider;",
-        "",
-        "  public InjectConstructor_Factory(Provider<Outer.Factory> factoryProvider) {",
-        "    assert factoryProvider != null;",
-        "    this.factoryProvider = factoryProvider;",
-        "  }",
-        "",
-        "  @Override public InjectConstructor get() {",
-        "    return new InjectConstructor(factoryProvider.get());",
-        "  }",
-        "",
-        "  public static Factory<InjectConstructor> create(",
-        "      Provider<Outer.Factory> factoryProvider) {",
-        "    return new InjectConstructor_Factory(factoryProvider);",
-        "  }",
-        "}");
+    JavaFileObject expected =
+        JavaFileObjects.forSourceLines(
+            "test.InjectConstructor_Factory",
+            "package test;",
+            "",
+            "import dagger.internal.Factory;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "import other.pkg.Outer;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class InjectConstructor_Factory ",
+            "    implements Factory<InjectConstructor> {",
+            "",
+            "  private final Provider<Outer.Factory> factoryProvider;",
+            "",
+            "  public InjectConstructor_Factory(Provider<Outer.Factory> factoryProvider) {",
+            "    assert factoryProvider != null;",
+            "    this.factoryProvider = factoryProvider;",
+            "  }",
+            "",
+            "  @Override public InjectConstructor get() {",
+            "    return new InjectConstructor(factoryProvider.get());",
+            "  }",
+            "",
+            "  public static Factory<InjectConstructor> create(",
+            "      Provider<Outer.Factory> factoryProvider) {",
+            "    return new InjectConstructor_Factory(factoryProvider);",
+            "  }",
+            "",
+            "  public static InjectConstructor newInjectConstructor(Outer.Factory factory) {",
+            "    return new InjectConstructor(factory);",
+            "  }",
+            "}");
     assertAbout(javaSources()).that(ImmutableList.of(factoryFile, file))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
@@ -1220,39 +1291,47 @@ public void samePackageNameCollision() {
         "class InjectConstructor implements CommonName {",
         "  @Inject InjectConstructor(other.pkg.CommonName otherPackage, CommonName samePackage) {}",
         "}");
-    JavaFileObject expected = JavaFileObjects.forSourceLines(
-        "test.InjectConstructor_Factory",
-        "package test;",
-        "",
-        "import dagger.internal.Factory;",
-        "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
-        "",
-        GENERATED_ANNOTATION,
-        "public final class InjectConstructor_Factory ",
-        "    implements Factory<InjectConstructor> {",
-        "",
-        "  private final Provider<other.pkg.CommonName> otherPackageProvider;",
-        "  private final Provider<CommonName> samePackageProvider;",
-        "",
-        "  public InjectConstructor_Factory(Provider<other.pkg.CommonName> otherPackageProvider,",
-        "      Provider<CommonName> samePackageProvider) {",
-        "    assert otherPackageProvider != null;",
-        "    this.otherPackageProvider = otherPackageProvider;",
-        "    assert samePackageProvider != null;",
-        "    this.samePackageProvider = samePackageProvider;",
-        "  }",
-        "",
-        "  @Override public InjectConstructor get() {",
-        "    return new InjectConstructor(otherPackageProvider.get(), samePackageProvider.get());",
-        "  }",
-        "",
-        "  public static Factory<InjectConstructor> create(",
-        "      Provider<other.pkg.CommonName> otherPackageProvider,",
-        "      Provider<CommonName> samePackageProvider) {",
-        "    return new InjectConstructor_Factory(otherPackageProvider, samePackageProvider);",
-        "  }",
-        "}");
+    JavaFileObject expected =
+        JavaFileObjects.forSourceLines(
+            "test.InjectConstructor_Factory",
+            "package test;",
+            "",
+            "import dagger.internal.Factory;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class InjectConstructor_Factory ",
+            "    implements Factory<InjectConstructor> {",
+            "",
+            "  private final Provider<other.pkg.CommonName> otherPackageProvider;",
+            "  private final Provider<CommonName> samePackageProvider;",
+            "",
+            "  public InjectConstructor_Factory(",
+            "      Provider<other.pkg.CommonName> otherPackageProvider,",
+            "      Provider<CommonName> samePackageProvider) {",
+            "    assert otherPackageProvider != null;",
+            "    this.otherPackageProvider = otherPackageProvider;",
+            "    assert samePackageProvider != null;",
+            "    this.samePackageProvider = samePackageProvider;",
+            "  }",
+            "",
+            "  @Override public InjectConstructor get() {",
+            "    return new InjectConstructor(",
+            "        otherPackageProvider.get(), samePackageProvider.get());",
+            "  }",
+            "",
+            "  public static Factory<InjectConstructor> create(",
+            "      Provider<other.pkg.CommonName> otherPackageProvider,",
+            "      Provider<CommonName> samePackageProvider) {",
+            "    return new InjectConstructor_Factory(otherPackageProvider, samePackageProvider);",
+            "  }",
+            "",
+            "  public static InjectConstructor newInjectConstructor(",
+            "      other.pkg.CommonName otherPackage, CommonName samePackage) {",
+            "    return new InjectConstructor(otherPackage, samePackage);",
+            "  }",
+            "}");
     assertAbout(javaSources())
         .that(ImmutableList.of(samePackageInterface, differentPackageInterface, file))
         .processedWith(new ComponentProcessor())
@@ -1270,24 +1349,30 @@ public void noDeps() {
         "final class SimpleType {",
         "  @Inject SimpleType() {}",
         "}");
-    JavaFileObject factory = JavaFileObjects.forSourceLines("test.SimpleType_Factory",
-        "package test;",
-        "",
-        "import dagger.internal.Factory;",
-        "import javax.annotation.Generated;",
-        "",
-        GENERATED_ANNOTATION,
-        "public enum SimpleType_Factory implements Factory<SimpleType> {",
-        "  INSTANCE;",
-        "",
-        "  @Override public SimpleType get() {",
-        "    return new SimpleType();",
-        "  }",
-        "",
-        "  public static Factory<SimpleType> create() {",
-        "    return INSTANCE;",
-        "  }",
-        "}");
+    JavaFileObject factory =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleType_Factory",
+            "package test;",
+            "",
+            "import dagger.internal.Factory;",
+            "import javax.annotation.Generated;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class SimpleType_Factory implements Factory<SimpleType> {",
+            "  private static final SimpleType_Factory INSTANCE = new SimpleType_Factory();",
+            "",
+            "  @Override public SimpleType get() {",
+            "    return new SimpleType();",
+            "  }",
+            "",
+            "  public static Factory<SimpleType> create() {",
+            "    return INSTANCE;",
+            "  }",
+            "",
+            "  public static SimpleType newSimpleType() {",
+            "    return new SimpleType();",
+            "  }",
+            "}");
     assertAbout(javaSource())
         .that(simpleType)
         .processedWith(new ComponentProcessor())
@@ -1314,25 +1399,30 @@ public void noDeps() {
         "    void inject(B b);",
         "  }",
         "}");
-    JavaFileObject aFactory = JavaFileObjects.forSourceLines(
-        "test.OuterType_A_Factory",
-        "package test;",
-        "",
-        "import dagger.internal.Factory;",
-        "import javax.annotation.Generated;",
-        "",
-        GENERATED_ANNOTATION,
-        "public enum OuterType_A_Factory implements Factory<OuterType.A> {",
-        "  INSTANCE;",
-        "",
-        "  @Override public OuterType.A get() {",
-        "    return new OuterType.A();",
-        "  }",
-        "",
-        "  public static Factory<OuterType.A> create() {",
-        "    return INSTANCE;",
-        "  }",
-        "}");
+    JavaFileObject aFactory =
+        JavaFileObjects.forSourceLines(
+            "test.OuterType_A_Factory",
+            "package test;",
+            "",
+            "import dagger.internal.Factory;",
+            "import javax.annotation.Generated;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class OuterType_A_Factory implements Factory<OuterType.A> {",
+            "  private static final OuterType_A_Factory INSTANCE = new OuterType_A_Factory();",
+            "",
+            "  @Override public OuterType.A get() {",
+            "    return new OuterType.A();",
+            "  }",
+            "",
+            "  public static Factory<OuterType.A> create() {",
+            "    return INSTANCE;",
+            "  }",
+            "",
+            "  public static OuterType.A newA() {",
+            "    return new OuterType.A();",
+            "  }",
+            "}");
     assertAbout(javaSources()).that(ImmutableList.of(nestedTypesFile))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
diff --git a/compiler/src/test/java/dagger/internal/codegen/KeyTest.java b/compiler/src/test/java/dagger/internal/codegen/KeyTest.java
index 3592fbb17..930a52183 100644
--- a/compiler/src/test/java/dagger/internal/codegen/KeyTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/KeyTest.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Google, Inc.
+ * Copyright (C) 2014 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,17 +13,18 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal.codegen;
 
+import static com.google.common.truth.Truth.assertThat;
+
 import com.google.auto.common.MoreTypes;
-import com.google.common.base.Equivalence;
-import com.google.common.base.Optional;
 import com.google.common.collect.Iterables;
 import com.google.common.util.concurrent.ListenableFuture;
 import com.google.testing.compile.CompilationRule;
 import dagger.Module;
 import dagger.Provides;
-import dagger.internal.codegen.Key.BindingMethodIdentifier;
+import dagger.internal.codegen.Key.MultibindingContributionIdentifier;
 import dagger.multibindings.ElementsIntoSet;
 import dagger.multibindings.IntoSet;
 import dagger.producers.ProducerModule;
@@ -45,8 +46,6 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import static com.google.common.truth.Truth.assertThat;
-
 /**
  * Tests {@link Key}.
  */
@@ -69,14 +68,10 @@
         compilationRule.getElements().getTypeElement(InjectedClass.class.getCanonicalName());
     ExecutableElement constructor =
         Iterables.getOnlyElement(ElementFilter.constructorsIn(typeElement.getEnclosedElements()));
-    assertThat(
-            keyFactory.forInjectConstructorWithResolvedType(
-                constructor.getEnclosingElement().asType()))
-        .isEqualTo(
-            new AutoValue_Key(
-                Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
-                MoreTypes.equivalence().wrap(typeElement.asType()),
-                Optional.<BindingMethodIdentifier>absent()));
+    Key key =
+        keyFactory.forInjectConstructorWithResolvedType(constructor.getEnclosingElement().asType());
+    assertThat(key).isEqualTo(Key.builder(typeElement.asType()).build());
+    assertThat(key.toString()).isEqualTo("dagger.internal.codegen.KeyTest.InjectedClass");
   }
 
   static final class InjectedClass {
@@ -90,12 +85,9 @@
         elements.getTypeElement(ProvidesMethodModule.class.getCanonicalName());
     ExecutableElement providesMethod =
         Iterables.getOnlyElement(ElementFilter.methodsIn(moduleElement.getEnclosedElements()));
-    assertThat(keyFactory.forProvidesMethod(providesMethod, moduleElement))
-        .isEqualTo(
-            new AutoValue_Key(
-                Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
-                MoreTypes.equivalence().wrap(stringType),
-                Optional.<BindingMethodIdentifier>absent()));
+    Key key = keyFactory.forProvidesMethod(providesMethod, moduleElement);
+    assertThat(key).isEqualTo(Key.builder(stringType).build());
+    assertThat(key.toString()).isEqualTo("java.lang.String");
   }
 
   @Module
@@ -117,6 +109,10 @@
     assertThat(MoreTypes.equivalence().wrap(key.qualifier().get().getAnnotationType()))
         .isEqualTo(MoreTypes.equivalence().wrap(qualifierElement.asType()));
     assertThat(key.wrappedType()).isEqualTo(MoreTypes.equivalence().wrap(stringType));
+    assertThat(key.toString())
+        .isEqualTo(
+            "@dagger.internal.codegen.KeyTest.TestQualifier("
+                + "{@dagger.internal.codegen.KeyTest.InnerAnnotation}) java.lang.String");
   }
 
   @Test public void qualifiedKeyEquivalents() {
@@ -132,9 +128,13 @@
     Element injectionField =
         Iterables.getOnlyElement(ElementFilter.fieldsIn(injectableElement.getEnclosedElements()));
     AnnotationMirror qualifier = Iterables.getOnlyElement(injectionField.getAnnotationMirrors());
-    Key injectionKey = keyFactory.forQualifiedType(Optional.<AnnotationMirror>of(qualifier), type);
+    Key injectionKey = Key.builder(type).qualifier(qualifier).build();
 
     assertThat(provisionKey).isEqualTo(injectionKey);
+    assertThat(injectionKey.toString())
+        .isEqualTo(
+            "@dagger.internal.codegen.KeyTest.TestQualifier("
+                + "{@dagger.internal.codegen.KeyTest.InnerAnnotation}) java.lang.String");
   }
 
   @Module
@@ -165,12 +165,19 @@ String provideQualifiedString() {
         elements.getTypeElement(SetProvidesMethodsModule.class.getCanonicalName());
     for (ExecutableElement providesMethod
         : ElementFilter.methodsIn(moduleElement.getEnclosedElements())) {
-      assertThat(keyFactory.forProvidesMethod(providesMethod, moduleElement))
+      Key key = keyFactory.forProvidesMethod(providesMethod, moduleElement);
+      assertThat(key)
           .isEqualTo(
-              new AutoValue_Key(
-                  Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
-                  MoreTypes.equivalence().wrap(setOfStringsType),
-                  Optional.of(BindingMethodIdentifier.create(providesMethod, moduleElement))));
+              Key.builder(setOfStringsType)
+                  .multibindingContributionIdentifier(
+                      new MultibindingContributionIdentifier(providesMethod, moduleElement))
+                  .build());
+      assertThat(key.toString())
+          .isEqualTo(
+              String.format(
+                  "java.util.Set<java.lang.String> "
+                      + "dagger.internal.codegen.KeyTest.SetProvidesMethodsModule#%s",
+                  providesMethod.getSimpleName()));
     }
   }
 
@@ -217,6 +224,8 @@ String provideQualifiedString() {
     Key intKey = keyFactory.forProvidesMethod(intMethod, primitiveHolder);
     Key integerKey = keyFactory.forProvidesMethod(integerMethod, boxedPrimitiveHolder);
     assertThat(intKey).isEqualTo(integerKey);
+    assertThat(intKey.toString()).isEqualTo("java.lang.Integer");
+    assertThat(integerKey.toString()).isEqualTo("java.lang.Integer");
   }
 
   @Test public void forProducesMethod() {
@@ -225,12 +234,9 @@ String provideQualifiedString() {
         elements.getTypeElement(ProducesMethodsModule.class.getCanonicalName());
     for (ExecutableElement producesMethod
         : ElementFilter.methodsIn(moduleElement.getEnclosedElements())) {
-      assertThat(keyFactory.forProducesMethod(producesMethod, moduleElement))
-          .isEqualTo(
-              new AutoValue_Key(
-                  Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
-                  MoreTypes.equivalence().wrap(stringType),
-                  Optional.<BindingMethodIdentifier>absent()));
+      Key key = keyFactory.forProducesMethod(producesMethod, moduleElement);
+      assertThat(key).isEqualTo(Key.builder(stringType).build());
+      assertThat(key.toString()).isEqualTo("java.lang.String");
     }
   }
 
@@ -253,12 +259,19 @@ String provideQualifiedString() {
         elements.getTypeElement(SetProducesMethodsModule.class.getCanonicalName());
     for (ExecutableElement producesMethod
         : ElementFilter.methodsIn(moduleElement.getEnclosedElements())) {
-      assertThat(keyFactory.forProducesMethod(producesMethod, moduleElement))
+      Key key = keyFactory.forProducesMethod(producesMethod, moduleElement);
+      assertThat(key)
+          .isEqualTo(
+              Key.builder(setOfStringsType)
+                  .multibindingContributionIdentifier(
+                      new MultibindingContributionIdentifier(producesMethod, moduleElement))
+                  .build());
+      assertThat(key.toString())
           .isEqualTo(
-              new AutoValue_Key(
-                  Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
-                  MoreTypes.equivalence().wrap(setOfStringsType),
-                  Optional.of(BindingMethodIdentifier.create(producesMethod, moduleElement))));
+              String.format(
+                  "java.util.Set<java.lang.String> "
+                      + "dagger.internal.codegen.KeyTest.SetProducesMethodsModule#%s",
+                  producesMethod.getSimpleName()));
     }
   }
 
diff --git a/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java
index df33d2a87..5c4f98214 100644
--- a/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Google, Inc.
+ * Copyright (C) 2014 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,8 +13,13 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal.codegen;
 
+import static com.google.common.truth.Truth.assertAbout;
+import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
+
 import com.google.auto.value.processor.AutoAnnotationProcessor;
 import com.google.common.collect.ImmutableList;
 import com.google.testing.compile.JavaFileObjects;
@@ -23,10 +28,6 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import static com.google.common.truth.Truth.assertAbout;
-import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
-import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
-
 @RunWith(JUnit4.class)
 public class MapBindingComponentProcessorTest {
 
@@ -136,7 +137,7 @@ public void mapBindingsWithEnumKey() {
             "  }",
             "",
             "  public static TestComponent create() {",
-            "    return builder().build();",
+            "    return new Builder().build();",
             "  }",
             "",
             "  @SuppressWarnings(\"unchecked\")",
@@ -289,7 +290,7 @@ public void mapBindingsWithStringKey() {
             "  }",
             "",
             "  public static TestComponent create() {",
-            "    return builder().build();",
+            "    return new Builder().build();",
             "  }",
             "",
             "  @SuppressWarnings(\"unchecked\")",
@@ -451,7 +452,7 @@ public void mapBindingsWithWrappedKey() {
             "  }",
             "",
             "  public static TestComponent create() {",
-            "    return builder().build();",
+            "    return new Builder().build();",
             "  }",
             "",
             "  @SuppressWarnings(\"unchecked\")",
@@ -619,7 +620,7 @@ public void mapBindingsWithNonProviderValue() {
             "  }",
             "",
             "  public static TestComponent create() {",
-            "    return builder().build();",
+            "    return new Builder().build();",
             "  }",
             "",
             "  @SuppressWarnings(\"unchecked\")",
@@ -734,7 +735,7 @@ public void injectMapWithoutMapBinding() {
         "  }",
         "",
         "  public static TestComponent create() {",
-        "    return builder().build();",
+        "    return new Builder().build();",
         "  }",
         "",
         "  @SuppressWarnings(\"unchecked\")",
diff --git a/compiler/src/test/java/dagger/internal/codegen/MapKeyProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/MapKeyProcessorTest.java
index a26866ae8..62fe2fdb6 100644
--- a/compiler/src/test/java/dagger/internal/codegen/MapKeyProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/MapKeyProcessorTest.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Google, Inc.
+ * Copyright (C) 2014 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,8 +13,14 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal.codegen;
 
+import static com.google.common.truth.Truth.assertAbout;
+import static com.google.testing.compile.JavaSourcesSubject.assertThat;
+import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
+
 import com.google.auto.value.processor.AutoAnnotationProcessor;
 import com.google.common.collect.ImmutableList;
 import com.google.testing.compile.JavaFileObjects;
@@ -23,11 +29,6 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import static com.google.common.truth.Truth.assertAbout;
-import static com.google.testing.compile.JavaSourcesSubject.assertThat;
-import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
-import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
-
 @RunWith(JUnit4.class)
 public class MapKeyProcessorTest {
   @Test
@@ -147,8 +148,6 @@ public void mapKeyComponentFileWithDisorderedKeyField() {
     JavaFileObject mapModuleTwoFile =JavaFileObjects.forSourceLines("test.MapModuleTwo",
         "package test;",
         "",
-        "import static dagger.Provides.Type.MAP;",
-        "",
         "import dagger.Module;",
         "import dagger.Provides;",
         "import dagger.multibindings.IntoMap;",
@@ -236,7 +235,7 @@ public void mapKeyComponentFileWithDisorderedKeyField() {
             "  }",
             "",
             "  public static TestComponent create() {",
-            "    return builder().build();",
+            "    return new Builder().build();",
             "  }",
             "",
             "  @SuppressWarnings(\"unchecked\")",
@@ -411,7 +410,7 @@ public void mapKeyComponentFileWithDefaultField() {
             "  }",
             "",
             "  public static TestComponent create() {",
-            "    return builder().build();",
+            "    return new Builder().build();",
             "  }",
             "",
             "  @SuppressWarnings(\"unchecked\")",
diff --git a/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java b/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java
index f30368611..35337fce5 100644
--- a/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,8 +13,17 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal.codegen;
 
+import static com.google.common.truth.Truth.assertAbout;
+import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+import static com.google.testing.compile.JavaSourcesSubject.assertThat;
+import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+import static dagger.internal.codegen.ErrorMessages.INJECT_INTO_PRIVATE_CLASS;
+import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
+import static javax.tools.StandardLocation.CLASS_OUTPUT;
+
 import com.google.common.base.Joiner;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
@@ -30,13 +39,6 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import static com.google.common.truth.Truth.assertAbout;
-import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
-import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
-import static dagger.internal.codegen.ErrorMessages.INJECT_INTO_PRIVATE_CLASS;
-import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
-import static javax.tools.StandardLocation.CLASS_OUTPUT;
-
 @RunWith(JUnit4.class)
 public class MembersInjectionTest {
   @Test
@@ -86,7 +88,7 @@ public void parentClass_noInjectedMembers() {
         "  }",
         "",
         "  public static TestComponent create() {",
-        "    return builder().build();",
+        "    return new Builder().build();",
         "  }",
         "",
         "  @SuppressWarnings(\"unchecked\")",
@@ -176,7 +178,7 @@ public void parentClass_injectedMembersInSupertype() {
             "  }",
             "",
             "  public static TestComponent create() {",
-            "    return builder().build();",
+            "    return new Builder().build();",
             "  }",
             "",
             "  @SuppressWarnings(\"unchecked\")",
@@ -1081,4 +1083,35 @@ public void fieldInjectionForShadowedMember() {
         .processedWith(new ComponentProcessor())
         .compilesWithoutError();
   }
+
+  @Test public void rawFrameworkTypes() {
+    JavaFileObject file =
+        JavaFileObjects.forSourceLines(
+            "test.RawFrameworkTypes",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Inject;",
+            "import javax.inject.Provider;",
+            "",
+            "class RawProviderField {",
+            "  @Inject Provider fieldWithRawProvider;",
+            "}",
+            "",
+            "class RawProviderParameter {",
+            "  @Inject void methodInjection(Provider rawProviderParameter) {}",
+            "}",
+            "",
+            "@Component",
+            "interface C {",
+            "  void inject(RawProviderField rawProviderField);",
+            "  void inject(RawProviderParameter rawProviderParameter);",
+            "}");
+    assertThat(file)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("javax.inject.Provider cannot be provided").in(file).onLine(17)
+        .and()
+        .withErrorContaining("javax.inject.Provider cannot be provided").in(file).onLine(18);
+  }
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/MethodSignatureFormatterTest.java b/compiler/src/test/java/dagger/internal/codegen/MethodSignatureFormatterTest.java
index 62d688561..224967faf 100644
--- a/compiler/src/test/java/dagger/internal/codegen/MethodSignatureFormatterTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/MethodSignatureFormatterTest.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Google, Inc.
+ * Copyright (C) 2014 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,8 +13,12 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal.codegen;
 
+import static com.google.common.truth.Truth.assertThat;
+import static javax.lang.model.util.ElementFilter.methodsIn;
+
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Iterables;
 import com.google.testing.compile.CompilationRule;
@@ -28,9 +32,6 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import static com.google.common.truth.Truth.assertThat;
-import static javax.lang.model.util.ElementFilter.methodsIn;
-
 @RunWith(JUnit4.class)
 public class MethodSignatureFormatterTest {
   @Rule public CompilationRule compilationRule = new CompilationRule();
diff --git a/compiler/src/test/java/dagger/internal/codegen/MissingBindingSuggestionsTest.java b/compiler/src/test/java/dagger/internal/codegen/MissingBindingSuggestionsTest.java
index 03ec35d9b..f63771743 100644
--- a/compiler/src/test/java/dagger/internal/codegen/MissingBindingSuggestionsTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/MissingBindingSuggestionsTest.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,8 +13,12 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal.codegen;
 
+import static com.google.common.truth.Truth.assertAbout;
+import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+
 import com.google.common.collect.ImmutableList;
 import com.google.testing.compile.JavaFileObjects;
 import javax.tools.JavaFileObject;
@@ -22,9 +26,6 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import static com.google.common.truth.Truth.assertAbout;
-import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
-
 @RunWith(JUnit4.class)
 public class MissingBindingSuggestionsTest {
   private static JavaFileObject injectable(String className, String constructorParams) {
diff --git a/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java b/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
index 2253201af..8d02a499c 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Google, Inc.
+ * Copyright (C) 2014 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,16 +13,8 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package dagger.internal.codegen;
 
-import com.google.common.collect.ImmutableList;
-import com.google.testing.compile.CompileTester;
-import com.google.testing.compile.JavaFileObjects;
-import com.squareup.javapoet.CodeBlock;
-import javax.tools.JavaFileObject;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
+package dagger.internal.codegen;
 
 import static com.google.common.truth.Truth.assertAbout;
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
@@ -45,6 +37,15 @@
 import static dagger.internal.codegen.ErrorMessages.MODULES_WITH_TYPE_PARAMS_MUST_BE_ABSTRACT;
 import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
 
+import com.google.common.collect.ImmutableList;
+import com.google.testing.compile.CompileTester;
+import com.google.testing.compile.JavaFileObjects;
+import com.squareup.javapoet.CodeBlock;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
 @RunWith(JUnit4.class)
 public class ModuleFactoryGeneratorTest {
 
@@ -246,30 +247,36 @@ public void providesMethodReturnsProduced() {
         "    return \"\";",
         "  }",
         "}");
-    JavaFileObject factoryFile = JavaFileObjects.forSourceLines("TestModule_ProvideStringFactory",
-        "package test;",
-        "",
-        "import dagger.internal.Factory;",
-        "import dagger.internal.Preconditions;",
-        "import javax.annotation.Generated;",
-        "",
-        GENERATED_ANNOTATION,
-        "public final class TestModule_ProvideStringFactory implements Factory<String> {",
-        "  private final TestModule module;",
-        "",
-        "  public TestModule_ProvideStringFactory(TestModule module) {",
-        "    assert module != null;",
-        "    this.module = module;",
-        "  }",
-        "",
-        "  @Override public String get() {",
-        "    return Preconditions.checkNotNull(module.provideString(), " + NPE_LITERAL + ");",
-        "  }",
-        "",
-        "  public static Factory<String> create(TestModule module) {",
-        "    return new TestModule_ProvideStringFactory(module);",
-        "  }",
-        "}");
+    JavaFileObject factoryFile =
+        JavaFileObjects.forSourceLines(
+            "TestModule_ProvideStringFactory",
+            "package test;",
+            "",
+            "import dagger.internal.Factory;",
+            "import dagger.internal.Preconditions;",
+            "import javax.annotation.Generated;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class TestModule_ProvideStringFactory implements Factory<String> {",
+            "  private final TestModule module;",
+            "",
+            "  public TestModule_ProvideStringFactory(TestModule module) {",
+            "    assert module != null;",
+            "    this.module = module;",
+            "  }",
+            "",
+            "  @Override public String get() {",
+            "    return Preconditions.checkNotNull(module.provideString(), " + NPE_LITERAL + ");",
+            "  }",
+            "",
+            "  public static Factory<String> create(TestModule module) {",
+            "    return new TestModule_ProvideStringFactory(module);",
+            "  }",
+            "",
+            "  public static String proxyProvideString(TestModule instance) {",
+            "    return instance.provideString();",
+            "  }",
+            "}");
     assertAbout(javaSource()).that(moduleFile)
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
@@ -289,29 +296,35 @@ public void providesMethodReturnsProduced() {
         "    return \"\";",
         "  }",
         "}");
-    JavaFileObject factoryFile = JavaFileObjects.forSourceLines("TestModule_ProvideStringFactory",
-        "package test;",
-        "",
-        "import dagger.internal.Factory;",
-        "import javax.annotation.Generated;",
-        "",
-        GENERATED_ANNOTATION,
-        "public final class TestModule_ProvideStringFactory implements Factory<String> {",
-        "  private final TestModule module;",
-        "",
-        "  public TestModule_ProvideStringFactory(TestModule module) {",
-        "    assert module != null;",
-        "    this.module = module;",
-        "  }",
-        "",
-        "  @Override public String get() {",
-        "    return module.provideString();",
-        "  }",
-        "",
-        "  public static Factory<String> create(TestModule module) {",
-        "    return new TestModule_ProvideStringFactory(module);",
-        "  }",
-        "}");
+    JavaFileObject factoryFile =
+        JavaFileObjects.forSourceLines(
+            "TestModule_ProvideStringFactory",
+            "package test;",
+            "",
+            "import dagger.internal.Factory;",
+            "import javax.annotation.Generated;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class TestModule_ProvideStringFactory implements Factory<String> {",
+            "  private final TestModule module;",
+            "",
+            "  public TestModule_ProvideStringFactory(TestModule module) {",
+            "    assert module != null;",
+            "    this.module = module;",
+            "  }",
+            "",
+            "  @Override public String get() {",
+            "    return module.provideString();",
+            "  }",
+            "",
+            "  public static Factory<String> create(TestModule module) {",
+            "    return new TestModule_ProvideStringFactory(module);",
+            "  }",
+            "",
+            "  public static String proxyProvideString(TestModule instance) {",
+            "    return instance.provideString();",
+            "  }",
+            "}");
     assertAbout(javaSource()).that(moduleFile)
         .withCompilerOptions("-Adagger.nullableValidation=WARNING")
         .processedWith(new ComponentProcessor())
@@ -330,31 +343,37 @@ public void providesMethodReturnsProduced() {
         "final class TestModule {",
         "  @Provides @Nullable String provideString() { return null; }",
         "}");
-    JavaFileObject factoryFile = JavaFileObjects.forSourceLines("TestModule_ProvideStringFactory",
-        "package test;",
-        "",
-        "import dagger.internal.Factory;",
-        "import javax.annotation.Generated;",
-        "",
-        GENERATED_ANNOTATION,
-        "public final class TestModule_ProvideStringFactory implements Factory<String> {",
-        "  private final TestModule module;",
-        "",
-        "  public TestModule_ProvideStringFactory(TestModule module) {",
-        "    assert module != null;",
-        "    this.module = module;",
-        "  }",
-        "",
-        "  @Override",
-        "  @Nullable",
-        "  public String get() {",
-        "    return module.provideString();",
-        "  }",
-        "",
-        "  public static Factory<String> create(TestModule module) {",
-        "    return new TestModule_ProvideStringFactory(module);",
-        "  }",
-        "}");
+    JavaFileObject factoryFile =
+        JavaFileObjects.forSourceLines(
+            "TestModule_ProvideStringFactory",
+            "package test;",
+            "",
+            "import dagger.internal.Factory;",
+            "import javax.annotation.Generated;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class TestModule_ProvideStringFactory implements Factory<String> {",
+            "  private final TestModule module;",
+            "",
+            "  public TestModule_ProvideStringFactory(TestModule module) {",
+            "    assert module != null;",
+            "    this.module = module;",
+            "  }",
+            "",
+            "  @Override",
+            "  @Nullable",
+            "  public String get() {",
+            "    return module.provideString();",
+            "  }",
+            "",
+            "  public static Factory<String> create(TestModule module) {",
+            "    return new TestModule_ProvideStringFactory(module);",
+            "  }",
+            "",
+            "  public static String proxyProvideString(TestModule instance) {",
+            "    return instance.provideString();",
+            "  }",
+            "}");
     assertAbout(javaSources()).that(ImmutableList.of(moduleFile, NULLABLE))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
@@ -391,7 +410,6 @@ public void providesMethodReturnsProduced() {
         "import dagger.MembersInjector;",
         "import dagger.Module;",
         "import dagger.Provides;",
-        "",
         "import java.util.Arrays;",
         "import java.util.List;",
         "",
@@ -410,54 +428,61 @@ public void providesMethodReturnsProduced() {
         "    return new Object();",
         "  }",
         "}");
-    JavaFileObject listFactoryFile = JavaFileObjects.forSourceLines(
-        "TestModule_ProvideObjectsFactory",
-        "package test;",
-        "",
-        "import dagger.MembersInjector;",
-        "import dagger.internal.Factory;",
-        "import dagger.internal.Preconditions;",
-        "import java.util.List;",
-        "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
-        "",
-        GENERATED_ANNOTATION,
-        "public final class TestModule_ProvideObjectsFactory implements Factory<List<Object>> {",
-        "  private final TestModule module;",
-        "  private final Provider<Object> aProvider;",
-        "  private final Provider<Object> bProvider;",
-        "  private final MembersInjector<X> xMembersInjector;",
-        "",
-        "  public TestModule_ProvideObjectsFactory(",
-        "      TestModule module,",
-        "      Provider<Object> aProvider,",
-        "      Provider<Object> bProvider,",
-        "      MembersInjector<X> xMembersInjector) {",
-        "    assert module != null;",
-        "    this.module = module;",
-        "    assert aProvider != null;",
-        "    this.aProvider = aProvider;",
-        "    assert bProvider != null;",
-        "    this.bProvider = bProvider;",
-        "    assert xMembersInjector != null;",
-        "    this.xMembersInjector = xMembersInjector;",
-        "  }",
-        "",
-        "  @Override public List<Object> get() {",
-        "    return Preconditions.checkNotNull(",
-        "        module.provideObjects(aProvider.get(), bProvider.get(), xMembersInjector),",
-        "        " + NPE_LITERAL + ");",
-        "  }",
-        "",
-        "  public static Factory<List<Object>> create(",
-        "      TestModule module,",
-        "      Provider<Object> aProvider,",
-        "      Provider<Object> bProvider,",
-        "      MembersInjector<X> xMembersInjector) {",
-        "    return new TestModule_ProvideObjectsFactory(",
-        "        module, aProvider, bProvider, xMembersInjector);",
-        "  }",
-        "}");
+    JavaFileObject listFactoryFile =
+        JavaFileObjects.forSourceLines(
+            "TestModule_ProvideObjectsFactory",
+            "package test;",
+            "",
+            "import dagger.MembersInjector;",
+            "import dagger.internal.Factory;",
+            "import dagger.internal.Preconditions;",
+            "import java.util.List;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class TestModule_ProvideObjectsFactory",
+            "    implements Factory<List<Object>> {",
+            "  private final TestModule module;",
+            "  private final Provider<Object> aProvider;",
+            "  private final Provider<Object> bProvider;",
+            "  private final MembersInjector<X> xMembersInjector;",
+            "",
+            "  public TestModule_ProvideObjectsFactory(",
+            "      TestModule module,",
+            "      Provider<Object> aProvider,",
+            "      Provider<Object> bProvider,",
+            "      MembersInjector<X> xMembersInjector) {",
+            "    assert module != null;",
+            "    this.module = module;",
+            "    assert aProvider != null;",
+            "    this.aProvider = aProvider;",
+            "    assert bProvider != null;",
+            "    this.bProvider = bProvider;",
+            "    assert xMembersInjector != null;",
+            "    this.xMembersInjector = xMembersInjector;",
+            "  }",
+            "",
+            "  @Override public List<Object> get() {",
+            "    return Preconditions.checkNotNull(",
+            "        module.provideObjects(aProvider.get(), bProvider.get(), xMembersInjector),",
+            "        " + NPE_LITERAL + ");",
+            "  }",
+            "",
+            "  public static Factory<List<Object>> create(",
+            "      TestModule module,",
+            "      Provider<Object> aProvider,",
+            "      Provider<Object> bProvider,",
+            "      MembersInjector<X> xMembersInjector) {",
+            "    return new TestModule_ProvideObjectsFactory(",
+            "        module, aProvider, bProvider, xMembersInjector);",
+            "  }",
+            "",
+            "  public static List<Object> proxyProvideObjects(",
+            "      TestModule instance, Object a, Object b, Object x) {",
+            "    return instance.provideObjects(a, b, (MembersInjector<X>) x);",
+            "  }",
+            "}");
     assertAbout(javaSources()).that(
             ImmutableList.of(classXFile, moduleFile, QUALIFIER_A, QUALIFIER_B))
         .processedWith(new ComponentProcessor())
@@ -480,30 +505,36 @@ public void providesMethodReturnsProduced() {
         "    return \"\";",
         "  }",
         "}");
-    JavaFileObject factoryFile = JavaFileObjects.forSourceLines("TestModule_ProvideStringFactory",
-        "package test;",
-        "",
-        "import dagger.internal.Factory;",
-        "import dagger.internal.Preconditions;",
-        "import javax.annotation.Generated;",
-        "",
-        GENERATED_ANNOTATION,
-        "public final class TestModule_ProvideStringFactory implements Factory<String> {",
-        "  private final TestModule module;",
-        "",
-        "  public TestModule_ProvideStringFactory(TestModule module) {",
-        "    assert module != null;",
-        "    this.module = module;",
-        "  }",
-        "",
-        "  @Override public String get() {",
-        "    return Preconditions.checkNotNull(module.provideString(), " + NPE_LITERAL + ");",
-        "  }",
-        "",
-        "  public static Factory<String> create(TestModule module) {",
-        "    return new TestModule_ProvideStringFactory(module);",
-        "  }",
-        "}");
+    JavaFileObject factoryFile =
+        JavaFileObjects.forSourceLines(
+            "TestModule_ProvideStringFactory",
+            "package test;",
+            "",
+            "import dagger.internal.Factory;",
+            "import dagger.internal.Preconditions;",
+            "import javax.annotation.Generated;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class TestModule_ProvideStringFactory implements Factory<String> {",
+            "  private final TestModule module;",
+            "",
+            "  public TestModule_ProvideStringFactory(TestModule module) {",
+            "    assert module != null;",
+            "    this.module = module;",
+            "  }",
+            "",
+            "  @Override public String get() {",
+            "    return Preconditions.checkNotNull(module.provideString(), " + NPE_LITERAL + ");",
+            "  }",
+            "",
+            "  public static Factory<String> create(TestModule module) {",
+            "    return new TestModule_ProvideStringFactory(module);",
+            "  }",
+            "",
+            "  public static String proxyProvideString(TestModule instance) {",
+            "    return instance.provideString();",
+            "  }",
+            "}");
     assertAbout(javaSource()).that(moduleFile)
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
@@ -527,33 +558,40 @@ public void providesMethodReturnsProduced() {
         "    return new ArrayList<>();",
         "  }",
         "}");
-    JavaFileObject factoryFile = JavaFileObjects.forSourceLines(
-        "TestModule_ProvideWildcardListFactory",
-        "package test;",
-        "",
-        "import dagger.internal.Factory;",
-        "import dagger.internal.Preconditions;",
-        "import java.util.List;",
-        "import javax.annotation.Generated;",
-        "",
-        GENERATED_ANNOTATION,
-        "public final class TestModule_ProvideWildcardListFactory implements "
-            + "Factory<List<List<?>>> {",
-        "  private final TestModule module;",
-        "",
-        "  public TestModule_ProvideWildcardListFactory(TestModule module) {",
-        "    assert module != null;",
-        "    this.module = module;",
-        "  }",
-        "",
-        "  @Override public List<List<?>> get() {",
-        "    return Preconditions.checkNotNull(module.provideWildcardList(), " + NPE_LITERAL + ");",
-        "  }",
-        "",
-        "  public static Factory<List<List<?>>> create(TestModule module) {",
-        "    return new TestModule_ProvideWildcardListFactory(module);",
-        "  }",
-        "}");
+    JavaFileObject factoryFile =
+        JavaFileObjects.forSourceLines(
+            "TestModule_ProvideWildcardListFactory",
+            "package test;",
+            "",
+            "import dagger.internal.Factory;",
+            "import dagger.internal.Preconditions;",
+            "import java.util.List;",
+            "import javax.annotation.Generated;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class TestModule_ProvideWildcardListFactory implements "
+                + "Factory<List<List<?>>> {",
+            "  private final TestModule module;",
+            "",
+            "  public TestModule_ProvideWildcardListFactory(TestModule module) {",
+            "    assert module != null;",
+            "    this.module = module;",
+            "  }",
+            "",
+            "  @Override public List<List<?>> get() {",
+            "    return Preconditions.checkNotNull(module.provideWildcardList(), "
+                + NPE_LITERAL
+                + ");",
+            "  }",
+            "",
+            "  public static Factory<List<List<?>>> create(TestModule module) {",
+            "    return new TestModule_ProvideWildcardListFactory(module);",
+            "  }",
+            "",
+            "  public static List<List<?>> proxyProvideWildcardList(TestModule instance) {",
+            "    return instance.provideWildcardList();",
+            "  }",
+            "}");
     assertAbout(javaSource()).that(moduleFile)
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
@@ -575,31 +613,37 @@ public void providesMethodReturnsProduced() {
         "    return null;",
         "  }",
         "}");
-    JavaFileObject factoryFile = JavaFileObjects.forSourceLines("TestModule_ProvideStringsFactory",
-        "package test;",
-        "",
-        "import dagger.internal.Factory;",
-        "import dagger.internal.Preconditions;",
-        "import java.util.Set;",
-        "import javax.annotation.Generated;",
-        "",
-        GENERATED_ANNOTATION,
-        "public final class TestModule_ProvideStringsFactory implements Factory<Set<String>> {",
-        "  private final TestModule module;",
-        "",
-        "  public TestModule_ProvideStringsFactory(TestModule module) {",
-        "    assert module != null;",
-        "    this.module = module;",
-        "  }",
-        "",
-        "  @Override public Set<String> get() {",
-        "    return Preconditions.checkNotNull(module.provideStrings(), " + NPE_LITERAL + ");",
-        "  }",
-        "",
-        "  public static Factory<Set<String>> create(TestModule module) {",
-        "    return new TestModule_ProvideStringsFactory(module);",
-        "  }",
-        "}");
+    JavaFileObject factoryFile =
+        JavaFileObjects.forSourceLines(
+            "TestModule_ProvideStringsFactory",
+            "package test;",
+            "",
+            "import dagger.internal.Factory;",
+            "import dagger.internal.Preconditions;",
+            "import java.util.Set;",
+            "import javax.annotation.Generated;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class TestModule_ProvideStringsFactory implements Factory<Set<String>> {",
+            "  private final TestModule module;",
+            "",
+            "  public TestModule_ProvideStringsFactory(TestModule module) {",
+            "    assert module != null;",
+            "    this.module = module;",
+            "  }",
+            "",
+            "  @Override public Set<String> get() {",
+            "    return Preconditions.checkNotNull(module.provideStrings(), " + NPE_LITERAL + ");",
+            "  }",
+            "",
+            "  public static Factory<Set<String>> create(TestModule module) {",
+            "    return new TestModule_ProvideStringsFactory(module);",
+            "  }",
+            "",
+            "  public static Set<String> proxyProvideStrings(TestModule instance) {",
+            "    return instance.provideStrings();",
+            "  }",
+            "}");
     assertAbout(javaSource()).that(moduleFile)
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
@@ -892,6 +936,12 @@ public void genericSubclassedModule() {
             "      Factory<List<B>> create(ParentModule<A, B, C> module, Provider<B> bProvider) {",
             "    return new ParentModule_ProvideListBFactory<A, B, C>(module, bProvider);",
             "  }",
+            "",
+            "  public static <A extends CharSequence, B, C extends Number & Comparable<C>> List<B>",
+            "      proxyProvideListB(",
+            "          ParentModule<A, B, C> instance, B b) {",
+            "    return instance.provideListB(b);",
+            "  }",
             "}");
     JavaFileObject bElementFactory =
         JavaFileObjects.forSourceLines(
@@ -927,6 +977,12 @@ public void genericSubclassedModule() {
             "      Factory<B> create(ParentModule<A, B, C> module, Provider<B> bProvider) {",
             "    return new ParentModule_ProvideBElementFactory<A, B, C>(module, bProvider);",
             "  }",
+            "",
+            "  public static <A extends CharSequence, B, C extends Number & Comparable<C>>",
+            "      B proxyProvideBElement(",
+            "          ParentModule<A, B, C> instance, B b) {",
+            "        return instance.provideBElement(b);",
+            "  }",
             "}");
     JavaFileObject bEntryFactory =
         JavaFileObjects.forSourceLines(
@@ -962,60 +1018,77 @@ public void genericSubclassedModule() {
             "      Factory<B> create(ParentModule<A, B, C> module, Provider<B> bProvider) {",
             "    return new ParentModule_ProvideBEntryFactory<A, B, C>(module, bProvider);",
             "  }",
+            "",
+            "  public static <A extends CharSequence, B, C extends Number & Comparable<C>>",
+            "      B proxyProvideBEntry(",
+            "          ParentModule<A, B, C> instance, B b) {",
+            "        return instance.provideBEntry(b);",
+            "  }",
+            "}");
+    JavaFileObject numberFactory =
+        JavaFileObjects.forSourceLines(
+            "test.ChildNumberModule_ProvideNumberFactory",
+            "package test;",
+            "",
+            "import dagger.internal.Factory;",
+            "import dagger.internal.Preconditions;",
+            "import javax.annotation.Generated;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class ChildNumberModule_ProvideNumberFactory",
+            "    implements Factory<Number> {",
+            "  private final ChildNumberModule module;",
+            "",
+            "  public ChildNumberModule_ProvideNumberFactory(ChildNumberModule module) {",
+            "    assert module != null;",
+            "    this.module = module;",
+            "  }",
+            "",
+            "  @Override",
+            "  public Number get() {  ",
+            "    return Preconditions.checkNotNull(module.provideNumber(), " + NPE_LITERAL + ");",
+            "  }",
+            "",
+            "  public static Factory<Number> create(ChildNumberModule module) {",
+            "    return new ChildNumberModule_ProvideNumberFactory(module);",
+            "  }",
+            "",
+            "  public static Number proxyProvideNumber(ChildNumberModule instance) {",
+            "    return instance.provideNumber();",
+            "  }",
+            "}");
+    JavaFileObject integerFactory =
+        JavaFileObjects.forSourceLines(
+            "test.ChildIntegerModule_ProvideIntegerFactory",
+            "package test;",
+            "",
+            "import dagger.internal.Factory;",
+            "import dagger.internal.Preconditions;",
+            "import javax.annotation.Generated;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class ChildIntegerModule_ProvideIntegerFactory",
+            "    implements Factory<Integer> {",
+            "  private final ChildIntegerModule module;",
+            "",
+            "  public ChildIntegerModule_ProvideIntegerFactory(ChildIntegerModule module) {",
+            "    assert module != null;",
+            "    this.module = module;",
+            "  }",
+            "",
+            "  @Override",
+            "  public Integer get() {  ",
+            "    return Preconditions.checkNotNull(module.provideInteger(), " + NPE_LITERAL + ");",
+            "  }",
+            "",
+            "  public static Factory<Integer> create(ChildIntegerModule module) {",
+            "    return new ChildIntegerModule_ProvideIntegerFactory(module);",
+            "  }",
+            "",
+            "  public static Integer proxyProvideInteger(ChildIntegerModule instance) {",
+            "    return instance.provideInteger();",
+            "  }",
             "}");
-    JavaFileObject numberFactory = JavaFileObjects.forSourceLines(
-        "test.ChildNumberModule_ProvideNumberFactory",
-        "package test;",
-        "",
-        "import dagger.internal.Factory;",
-        "import dagger.internal.Preconditions;",
-        "import javax.annotation.Generated;",
-        "",
-        GENERATED_ANNOTATION,
-        "public final class ChildNumberModule_ProvideNumberFactory implements Factory<Number> {",
-        "  private final ChildNumberModule module;",
-        "",
-        "  public ChildNumberModule_ProvideNumberFactory(ChildNumberModule module) {",
-        "    assert module != null;",
-        "    this.module = module;",
-        "  }",
-        "",
-        "  @Override",
-        "  public Number get() {  ",
-        "    return Preconditions.checkNotNull(module.provideNumber(), " + NPE_LITERAL + ");",
-        "  }",
-        "",
-        "  public static Factory<Number> create(ChildNumberModule module) {",
-        "    return new ChildNumberModule_ProvideNumberFactory(module);",
-        "  }",
-        "}");
-    JavaFileObject integerFactory = JavaFileObjects.forSourceLines(
-        "test.ChildIntegerModule_ProvideIntegerFactory",
-        "package test;",
-        "",
-        "import dagger.internal.Factory;",
-        "import dagger.internal.Preconditions;",
-        "import javax.annotation.Generated;",
-        "",
-        GENERATED_ANNOTATION,
-        "public final class ChildIntegerModule_ProvideIntegerFactory",
-        "    implements Factory<Integer> {",
-        "  private final ChildIntegerModule module;",
-        "",
-        "  public ChildIntegerModule_ProvideIntegerFactory(ChildIntegerModule module) {",
-        "    assert module != null;",
-        "    this.module = module;",
-        "  }",
-        "",
-        "  @Override",
-        "  public Integer get() {  ",
-        "    return Preconditions.checkNotNull(module.provideInteger(), " + NPE_LITERAL + ");",
-        "  }",
-        "",
-        "  public static Factory<Integer> create(ChildIntegerModule module) {",
-        "    return new ChildIntegerModule_ProvideIntegerFactory(module);",
-        "  }",
-        "}");
     assertAbout(javaSources())
         .that(ImmutableList.of(parent, numberChild, integerChild, component))
         .processedWith(new ComponentProcessor())
@@ -1050,6 +1123,10 @@ public void genericSubclassedModule() {
             "  @Provides static Object provideNonGenericType() {",
             "    return new Object();",
             "  }",
+            "",
+            "  @Provides static String provideNonGenericTypeWithDeps(Object o) {",
+            "    return o.toString();",
+            "  }",
             "}");
 
     JavaFileObject provideMapStringNumberFactory =
@@ -1063,9 +1140,10 @@ public void genericSubclassedModule() {
             "import javax.annotation.Generated;",
             "",
             GENERATED_ANNOTATION,
-            "public enum ParameterizedModule_ProvideMapStringNumberFactory",
+            "public final class ParameterizedModule_ProvideMapStringNumberFactory",
             "    implements Factory<Map<String, Number>> {",
-            "  INSTANCE;",
+            "  private static final ParameterizedModule_ProvideMapStringNumberFactory INSTANCE =",
+            "      new ParameterizedModule_ProvideMapStringNumberFactory();",
             "",
             "  @Override",
             "  public Map<String, Number> get() {",
@@ -1076,6 +1154,10 @@ public void genericSubclassedModule() {
             "  public static Factory<Map<String, Number>> create() {",
             "    return INSTANCE;",
             "  }",
+            "",
+            "  public static Map<String, Number> proxyProvideMapStringNumber() {",
+            "    return ParameterizedModule.provideMapStringNumber();",
+            "  }",
             "}");
 
     JavaFileObject provideNonGenericTypeFactory =
@@ -1088,9 +1170,10 @@ public void genericSubclassedModule() {
             "import javax.annotation.Generated;",
             "",
             GENERATED_ANNOTATION,
-            "public enum ParameterizedModule_ProvideNonGenericTypeFactory",
+            "public final class ParameterizedModule_ProvideNonGenericTypeFactory",
             "    implements Factory<Object> {",
-            "  INSTANCE;",
+            "  private static final ParameterizedModule_ProvideNonGenericTypeFactory INSTANCE = ",
+            "      new ParameterizedModule_ProvideNonGenericTypeFactory();",
             "",
             "  @Override",
             "  public Object get() {",
@@ -1101,6 +1184,47 @@ public void genericSubclassedModule() {
             "  public static Factory<Object> create() {",
             "    return INSTANCE;",
             "  }",
+            "",
+            "  public static Object proxyProvideNonGenericType() {",
+            "    return ParameterizedModule.provideNonGenericType();",
+            "  }",
+            "}");
+
+    JavaFileObject provideNonGenericTypeWithDepsFactory =
+        JavaFileObjects.forSourceLines(
+            "test.ParameterizedModule_ProvideNonGenericTypeWithDepsFactory;",
+            "package test;",
+            "",
+            "import dagger.internal.Factory;",
+            "import dagger.internal.Preconditions;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class ParameterizedModule_ProvideNonGenericTypeWithDepsFactory",
+            "    implements Factory<String> {",
+            "  private final Provider<Object> oProvider;",
+            "",
+            "  public ParameterizedModule_ProvideNonGenericTypeWithDepsFactory(",
+            "      Provider<Object> oProvider) {",
+            "    assert oProvider != null;",
+            "    this.oProvider = oProvider;",
+            "  }",
+            "",
+            "  @Override",
+            "  public String get() {",
+            "    return Preconditions.checkNotNull(",
+            "        ParameterizedModule.provideNonGenericTypeWithDeps(oProvider.get()),",
+            "        " + NPE_LITERAL + ");",
+            "  }",
+            "",
+            "  public static Factory<String> create(Provider<Object> oProvider) {",
+            "    return new ParameterizedModule_ProvideNonGenericTypeWithDepsFactory(oProvider);",
+            "  }",
+            "",
+            "  public static String proxyProvideNonGenericTypeWithDeps(Object o) {",
+            "    return ParameterizedModule.provideNonGenericTypeWithDeps(o);",
+            "  }",
             "}");
 
     assertAbout(javaSource())
@@ -1108,7 +1232,10 @@ public void genericSubclassedModule() {
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and()
-        .generatesSources(provideMapStringNumberFactory, provideNonGenericTypeFactory);
+        .generatesSources(
+            provideMapStringNumberFactory,
+            provideNonGenericTypeFactory,
+            provideNonGenericTypeWithDepsFactory);
   }
 
   @Test public void providesMethodMultipleQualifiers() {
@@ -1117,7 +1244,6 @@ public void genericSubclassedModule() {
         "",
         "import dagger.Module;",
         "import dagger.Provides;",
-        "",
         "import javax.annotation.Nullable;",
         "import javax.inject.Singleton;",
         "",
diff --git a/compiler/src/test/java/dagger/internal/codegen/ModuleValidatorTest.java b/compiler/src/test/java/dagger/internal/codegen/ModuleValidatorTest.java
new file mode 100644
index 000000000..e3b1a2ebb
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/ModuleValidatorTest.java
@@ -0,0 +1,318 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static com.google.testing.compile.JavaSourcesSubject.assertThat;
+import static dagger.internal.codegen.Compilers.daggerCompiler;
+import static dagger.internal.codegen.DaggerModuleMethodSubject.Factory.assertThatModuleMethod;
+
+import com.google.testing.compile.JavaFileObjects;
+import dagger.Module;
+import dagger.producers.ProducerModule;
+import java.lang.annotation.Annotation;
+import java.util.Arrays;
+import java.util.Collection;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+@RunWith(Parameterized.class)
+public final class ModuleValidatorTest {
+
+  @Parameterized.Parameters(name = "{0}")
+  public static Collection<Object[]> parameters() {
+    return Arrays.asList(new Object[][] {{ModuleType.MODULE}, {ModuleType.PRODUCER_MODULE}});
+  }
+
+  private enum ModuleType {
+    MODULE(Module.class),
+    PRODUCER_MODULE(ProducerModule.class),
+    ;
+
+    private final Class<? extends Annotation> annotation;
+
+    ModuleType(Class<? extends Annotation> annotation) {
+      this.annotation = annotation;
+    }
+
+    String annotationWithSubcomponent(String subcomponent) {
+      return String.format("@%s(subcomponents = %s)", annotation.getSimpleName(), subcomponent);
+    }
+
+    String importStatement() {
+      return String.format("import %s;", annotation.getName());
+    }
+
+    String simpleName() {
+      return annotation.getSimpleName();
+    }
+  }
+
+  private final ModuleType moduleType;
+
+  public ModuleValidatorTest(ModuleType moduleType) {
+    this.moduleType = moduleType;
+  }
+
+  @Test
+  public void moduleSubcomponents_notASubcomponent() {
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            moduleType.importStatement(),
+            "",
+            moduleType.annotationWithSubcomponent("NotASubcomponent.class"),
+            "class TestModule {}");
+    JavaFileObject notASubcomponent =
+        JavaFileObjects.forSourceLines(
+            "test.NotASubcomponent", "package test;", "", "class NotASubcomponent {}");
+    assertThat(module, notASubcomponent)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            "test.NotASubcomponent is not a @Subcomponent or @ProductionSubcomponent")
+        .in(module)
+        .onLine(5);
+  }
+
+  @Test
+  public void moduleSubcomponents_listsSubcomponentBuilder() {
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            moduleType.importStatement(),
+            "",
+            moduleType.annotationWithSubcomponent("Sub.Builder.class"),
+            "class TestModule {}");
+    JavaFileObject subcomponent =
+        JavaFileObjects.forSourceLines(
+            "test.Sub",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent",
+            "interface Sub {",
+            "  @Subcomponent.Builder",
+            "  interface Builder {",
+            "    Sub build();",
+            "  }",
+            "}");
+    assertThat(module, subcomponent)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            "test.Sub.Builder is a @Subcomponent.Builder. Did you mean to use test.Sub?")
+        .in(module)
+        .onLine(5);
+  }
+
+  @Test
+  public void moduleSubcomponents_listsProductionSubcomponentBuilder() {
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            moduleType.importStatement(),
+            "",
+            moduleType.annotationWithSubcomponent("Sub.Builder.class"),
+            "class TestModule {}");
+    JavaFileObject subcomponent =
+        JavaFileObjects.forSourceLines(
+            "test.Sub",
+            "package test;",
+            "",
+            "import dagger.producers.ProductionSubcomponent;",
+            "",
+            "@ProductionSubcomponent",
+            "interface Sub {",
+            "  @ProductionSubcomponent.Builder",
+            "  interface Builder {",
+            "    Sub build();",
+            "  }",
+            "}");
+    assertThat(module, subcomponent)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            "test.Sub.Builder is a @ProductionSubcomponent.Builder. Did you mean to use test.Sub?")
+        .in(module)
+        .onLine(5);
+  }
+
+  @Test
+  public void moduleSubcomponents_noSubcomponentBuilder() {
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            moduleType.importStatement(),
+            "",
+            moduleType.annotationWithSubcomponent("NoBuilder.class"),
+            "class TestModule {}");
+    JavaFileObject subcomponent =
+        JavaFileObjects.forSourceLines(
+            "test.NoBuilder",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent",
+            "interface NoBuilder {}");
+    assertThat(module, subcomponent)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            "test.NoBuilder doesn't have a @Subcomponent.Builder, which is required when used "
+                + "with @"
+                + moduleType.simpleName()
+                + ".subcomponents")
+        .in(module)
+        .onLine(5);
+  }
+
+  @Test
+  public void moduleSubcomponents_noProductionSubcomponentBuilder() {
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            moduleType.importStatement(),
+            "",
+            moduleType.annotationWithSubcomponent("NoBuilder.class"),
+            "class TestModule {}");
+    JavaFileObject subcomponent =
+        JavaFileObjects.forSourceLines(
+            "test.NoBuilder",
+            "package test;",
+            "",
+            "import dagger.producers.ProductionSubcomponent;",
+            "",
+            "@ProductionSubcomponent",
+            "interface NoBuilder {}");
+    assertThat(module, subcomponent)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            "test.NoBuilder doesn't have a @ProductionSubcomponent.Builder, which is required "
+                + "when used with @"
+                + moduleType.simpleName()
+                + ".subcomponents")
+        .in(module)
+        .onLine(5);
+  }
+
+  @Test
+  public void moduleSubcomponentsAreTypes() {
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "",
+            "@Module(subcomponents = int.class)",
+            "class TestModule {}");
+    assertThat(module)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("int is not a valid subcomponent type")
+        .in(module)
+        .onLine(5);
+  }
+  
+  @Test
+  public void tooManyAnnotations() {
+    assertThatModuleMethod(
+            "@BindsOptionalOf @Multibinds abstract Set<Object> tooManyAnnotations();")
+        .hasError("is annotated with more than one of");
+  }
+
+  @Test
+  public void invalidIncludedModule() {
+    JavaFileObject badModule =
+        JavaFileObjects.forSourceLines(
+            "test.BadModule",
+            "package test;",
+            "",
+            "import dagger.Binds;",
+            "import dagger.Module;",
+            "",
+            "@Module",
+            "abstract class BadModule {",
+            "  @Binds abstract Object noParameters();",
+            "}");
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.IncludesBadModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "",
+            "@Module(includes = BadModule.class)",
+            "abstract class IncludesBadModule {}");
+    assertThat(daggerCompiler().compile(badModule, module))
+        .hadErrorContaining("test.BadModule has errors")
+        .inFile(module)
+        .onLine(5);
+  }
+
+  @Test
+  public void invalidNestedMultibindingsType() {
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.IncludesBadMultibindings",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Multibindings;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "abstract class IncludesBadMultibindings {",
+            "  @Provides static String string() { return \"a string\"; }",
+            "",
+            "  @Multibindings interface BadMultibindings {",
+            "    String notASetOrMap();",
+            "  }",
+            "}");
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = IncludesBadMultibindings.class)",
+            "interface TestComponent {",
+            "  String aString();",
+            "}");
+    assertThat(daggerCompiler().compile(module, component))
+        .hadErrorContaining("test.IncludesBadMultibindings has errors")
+        .inFile(component)
+        .onLine(5);
+  }
+}
diff --git a/compiler/src/test/java/dagger/internal/codegen/MultibindingTest.java b/compiler/src/test/java/dagger/internal/codegen/MultibindingTest.java
index 90da7f518..dce0b65d2 100644
--- a/compiler/src/test/java/dagger/internal/codegen/MultibindingTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/MultibindingTest.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 Google, Inc.
+ * Copyright (C) 2016 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,53 +13,20 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal.codegen;
 
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static com.google.testing.compile.JavaSourcesSubject.assertThat;
+
 import com.google.testing.compile.JavaFileObjects;
 import javax.tools.JavaFileObject;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import static com.google.testing.compile.JavaSourcesSubject.assertThat;
-
 @RunWith(JUnit4.class)
 public class MultibindingTest {
-  @Test
-  public void providesTypeAndAnnotationOnSameMethod_failsToCompile() {
-    JavaFileObject module =
-        JavaFileObjects.forSourceLines(
-            "test.MultibindingModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.multibindings.IntoSet;",
-            "",
-            "import static dagger.Provides.Type.SET;",
-            "import static dagger.Provides.Type.UNIQUE;",
-            "",
-            "@Module",
-            "class MultibindingModule {",
-            "  @Provides(type = SET) @IntoSet Integer provideInt() { ",
-            "    return 1;",
-            "  }",
-            "  @Provides(type = UNIQUE) @IntoSet Integer provideConflictingMultibindingTypes() { ",
-            "    return 2;",
-            "  }",
-            "}");
-
-    assertThat(module)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("@Provides.type cannot be used with multibinding annotations")
-        .in(module)
-        .onLine(12)
-        .and()
-        .withErrorContaining("@Provides.type cannot be used with multibinding annotations")
-        .in(module)
-        .onLine(15);
-  }
 
   @Test
   public void providesWithTwoMultibindingAnnotations_failsToCompile() {
@@ -89,34 +56,6 @@ public void providesWithTwoMultibindingAnnotations_failsToCompile() {
         .onLine(10);
   }
 
-  @Test
-  public void producesTypeAndAnnotationOnSameMethod_failsToCompile() {
-    JavaFileObject module =
-        JavaFileObjects.forSourceLines(
-            "test.MultibindingModule",
-            "package test;",
-            "",
-            "import dagger.producers.ProducerModule;",
-            "import dagger.producers.Produces;",
-            "import dagger.multibindings.IntoSet;",
-            "",
-            "import static dagger.producers.Produces.Type.SET;",
-            "",
-            "@ProducerModule",
-            "class MultibindingModule {",
-            "  @Produces(type = SET) @IntoSet Integer produceInt() { ",
-            "    return 1;",
-            "  }",
-            "}");
-
-    assertThat(module)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("@Produces.type cannot be used with multibinding annotations")
-        .in(module)
-        .onLine(11);
-  }
-
   @Test
   public void appliedOnInvalidMethods_failsToCompile() {
     JavaFileObject component =
@@ -126,7 +65,6 @@ public void appliedOnInvalidMethods_failsToCompile() {
             "",
             "import java.util.Set;",
             "import java.util.Map;",
-            "",
             "import dagger.Component;",
             "import dagger.multibindings.IntoSet;",
             "import dagger.multibindings.ElementsIntoSet;",
@@ -144,16 +82,16 @@ public void appliedOnInvalidMethods_failsToCompile() {
         .withErrorContaining(
             "Multibinding annotations may only be on @Provides, @Produces, or @Binds methods")
         .in(component)
-        .onLine(12)
+        .onLine(11)
         .and()
         .withErrorContaining(
             "Multibinding annotations may only be on @Provides, @Produces, or @Binds methods")
         .in(component)
-        .onLine(13)
+        .onLine(12)
         .and()
         .withErrorContaining(
             "Multibinding annotations may only be on @Provides, @Produces, or @Binds methods")
         .in(component)
-        .onLine(14);
+        .onLine(13);
   }
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/MultibindingsValidatorTest.java b/compiler/src/test/java/dagger/internal/codegen/MultibindingsValidatorTest.java
index 5741aa6f1..95248e4c3 100644
--- a/compiler/src/test/java/dagger/internal/codegen/MultibindingsValidatorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/MultibindingsValidatorTest.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,8 +13,14 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal.codegen;
 
+import static com.google.common.truth.Truth.assertAbout;
+import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+import static dagger.internal.codegen.DaggerModuleMethodSubject.Factory.assertThatMultibindingsMethod;
+import static java.util.Arrays.asList;
+
 import com.google.testing.compile.JavaFileObjects;
 import javax.inject.Qualifier;
 import javax.tools.JavaFileObject;
@@ -22,11 +28,6 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import static com.google.common.truth.Truth.assertAbout;
-import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
-import static dagger.internal.codegen.DaggerModuleMethodSubject.Factory.assertThatMultibindingsMethod;
-import static java.util.Arrays.asList;
-
 @RunWith(JUnit4.class)
 public class MultibindingsValidatorTest {
 
@@ -49,7 +50,7 @@
           "",
           "@Qualifier",
           "@interface OtherQualifier {}");
-  
+
   @Test
   public void abstractClass() {
     JavaFileObject testModule =
@@ -200,7 +201,7 @@ public void notWithinModule() {
         .in(testModule)
         .onLine(9);
   }
-  
+
   @Test
   public void voidMethod() {
     assertThatMultibindingsMethod("void voidMethod();")
diff --git a/compiler/src/test/java/dagger/internal/codegen/MultibindsValidatorTest.java b/compiler/src/test/java/dagger/internal/codegen/MultibindsValidatorTest.java
index e36006550..6f642f603 100644
--- a/compiler/src/test/java/dagger/internal/codegen/MultibindsValidatorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/MultibindsValidatorTest.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 Google, Inc.
+ * Copyright (C) 2016 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,8 +13,12 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal.codegen;
 
+import static dagger.internal.codegen.DaggerModuleMethodSubject.Factory.assertThatMethodInUnannotatedClass;
+import static dagger.internal.codegen.DaggerModuleMethodSubject.Factory.assertThatModuleMethod;
+
 import com.google.common.collect.ImmutableList;
 import dagger.Module;
 import dagger.producers.ProducerModule;
@@ -26,9 +30,6 @@
 import org.junit.runners.Parameterized;
 import org.junit.runners.Parameterized.Parameters;
 
-import static dagger.internal.codegen.DaggerModuleMethodSubject.Factory.assertThatMethodInUnannotatedClass;
-import static dagger.internal.codegen.DaggerModuleMethodSubject.Factory.assertThatModuleMethod;
-
 @RunWith(Parameterized.class)
 public class MultibindsValidatorTest {
 
diff --git a/compiler/src/test/java/dagger/internal/codegen/MultipleRequestTest.java b/compiler/src/test/java/dagger/internal/codegen/MultipleRequestTest.java
index 27e720d01..3dfd29566 100644
--- a/compiler/src/test/java/dagger/internal/codegen/MultipleRequestTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/MultipleRequestTest.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Google, Inc.
+ * Copyright (C) 2014 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,8 +13,12 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal.codegen;
 
+import static com.google.common.truth.Truth.assertAbout;
+import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+
 import com.google.common.collect.ImmutableList;
 import com.google.testing.compile.JavaFileObjects;
 import javax.tools.JavaFileObject;
@@ -22,9 +26,6 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import static com.google.common.truth.Truth.assert_;
-import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
-
 @RunWith(JUnit4.class)
 public class MultipleRequestTest {
   private static final JavaFileObject DEP_FILE = JavaFileObjects.forSourceLines("test.Dep",
@@ -37,82 +38,91 @@
       "}");
 
   @Test public void multipleRequests_constructor() {
-    assert_().about(javaSources())
-        .that(ImmutableList.of(
-            DEP_FILE,
-            JavaFileObjects.forSourceLines("test.ConstructorInjectsMultiple",
-                "package test;",
-                "",
-                "import javax.inject.Inject;",
-                "",
-                "class ConstructorInjectsMultiple {",
-                "  @Inject ConstructorInjectsMultiple(Dep d1, Dep d2) {}",
-                "}"),
-            JavaFileObjects.forSourceLines("test.SimpleComponent",
-                "package test;",
-                "",
-                "import dagger.Component;",
-                "",
-                "@Component",
-                "interface SimpleComponent {",
-                "  ConstructorInjectsMultiple get();",
-                "}")))
+    assertAbout(javaSources())
+        .that(
+            ImmutableList.of(
+                DEP_FILE,
+                JavaFileObjects.forSourceLines(
+                    "test.ConstructorInjectsMultiple",
+                    "package test;",
+                    "",
+                    "import javax.inject.Inject;",
+                    "",
+                    "class ConstructorInjectsMultiple {",
+                    "  @Inject ConstructorInjectsMultiple(Dep d1, Dep d2) {}",
+                    "}"),
+                JavaFileObjects.forSourceLines(
+                    "test.SimpleComponent",
+                    "package test;",
+                    "",
+                    "import dagger.Component;",
+                    "",
+                    "@Component",
+                    "interface SimpleComponent {",
+                    "  ConstructorInjectsMultiple get();",
+                    "}")))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError();
   }
 
   @Test public void multipleRequests_field() {
-    assert_().about(javaSources())
-        .that(ImmutableList.of(
-            DEP_FILE,
-            JavaFileObjects.forSourceLines("test.FieldInjectsMultiple",
-                "package test;",
-                "",
-                "import javax.inject.Inject;",
-                "",
-                "class FieldInjectsMultiple {",
-                "  @Inject Dep d1;",
-                "  @Inject Dep d2;",
-                "  @Inject FieldInjectsMultiple() {}",
-                "}"),
-            JavaFileObjects.forSourceLines("test.SimpleComponent",
-                "package test;",
-                "",
-                "import dagger.Component;",
-                "",
-                "@Component",
-                "interface SimpleComponent {",
-                "  FieldInjectsMultiple get();",
-                "}")))
+    assertAbout(javaSources())
+        .that(
+            ImmutableList.of(
+                DEP_FILE,
+                JavaFileObjects.forSourceLines(
+                    "test.FieldInjectsMultiple",
+                    "package test;",
+                    "",
+                    "import javax.inject.Inject;",
+                    "",
+                    "class FieldInjectsMultiple {",
+                    "  @Inject Dep d1;",
+                    "  @Inject Dep d2;",
+                    "  @Inject FieldInjectsMultiple() {}",
+                    "}"),
+                JavaFileObjects.forSourceLines(
+                    "test.SimpleComponent",
+                    "package test;",
+                    "",
+                    "import dagger.Component;",
+                    "",
+                    "@Component",
+                    "interface SimpleComponent {",
+                    "  FieldInjectsMultiple get();",
+                    "}")))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError();
   }
 
   @Test public void multipleRequests_providesMethod() {
-    assert_().about(javaSources())
-        .that(ImmutableList.of(
-            DEP_FILE,
-            JavaFileObjects.forSourceLines("test.FieldInjectsMultiple",
-                "package test;",
-                "",
-                "import dagger.Module;",
-                "import dagger.Provides;",
-                "",
-                "@Module",
-                "class SimpleModule {",
-                "  @Provides Object provide(Dep d1, Dep d2) {",
-                "    return null;",
-                "  }",
-                "}"),
-            JavaFileObjects.forSourceLines("test.SimpleComponent",
-                "package test;",
-                "",
-                "import dagger.Component;",
-                "",
-                "@Component(modules = SimpleModule.class)",
-                "interface SimpleComponent {",
-                "  Object get();",
-                "}")))
+    assertAbout(javaSources())
+        .that(
+            ImmutableList.of(
+                DEP_FILE,
+                JavaFileObjects.forSourceLines(
+                    "test.FieldInjectsMultiple",
+                    "package test;",
+                    "",
+                    "import dagger.Module;",
+                    "import dagger.Provides;",
+                    "",
+                    "@Module",
+                    "class SimpleModule {",
+                    "  @Provides Object provide(Dep d1, Dep d2) {",
+                    "    return null;",
+                    "  }",
+                    "}"),
+                JavaFileObjects.forSourceLines(
+                    "test.SimpleComponent",
+                    "package test;",
+                    "",
+                    "import dagger.Component;",
+                    "",
+                    "@Component(modules = SimpleModule.class)",
+                    "interface SimpleComponent {",
+                    "  Object get();",
+                    "}")))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError();
   }
diff --git a/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java b/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
index 4b9f17869..ce65429c3 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Google, Inc.
+ * Copyright (C) 2014 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,15 +16,6 @@
 // TODO(beder): Merge the error-handling tests with the ModuleFactoryGeneratorTest.
 package dagger.internal.codegen;
 
-import com.google.common.collect.ImmutableList;
-import com.google.common.util.concurrent.ListenableFuture;
-import com.google.testing.compile.JavaFileObjects;
-import javax.inject.Qualifier;
-import javax.tools.JavaFileObject;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
 import static com.google.common.truth.Truth.assertAbout;
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
@@ -45,9 +36,18 @@
 import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_SET_VALUES_RETURN_SET;
 import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
 
+import com.google.common.collect.ImmutableList;
+import com.google.common.util.concurrent.ListenableFuture;
+import com.google.testing.compile.JavaFileObjects;
+import javax.inject.Qualifier;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
 @RunWith(JUnit4.class)
 public class ProducerModuleFactoryGeneratorTest {
-  
+
   private String formatErrorMessage(String msg) {
     return String.format(msg, "Produces");
   }
@@ -366,7 +366,8 @@ public void publicModuleNonPublicIncludes() {
             "",
             GENERATED_ANNOTATION,
             "public final class TestModule_ProduceStringFactory",
-            "    extends AbstractProducer<String> implements AsyncFunction<Void, String> {",
+            "    extends AbstractProducer<String>",
+            "    implements AsyncFunction<Void, String>, Executor {",
             "  private final TestModule module;",
             "  private final Provider<Executor> executorProvider;",
             "  private final Provider<ProductionComponentMonitor> monitorProvider;",
@@ -388,7 +389,7 @@ public void publicModuleNonPublicIncludes() {
             "",
             "  @Override protected ListenableFuture<String> compute() {",
             "    return Futures.transformAsync(",
-            "        Futures.<Void>immediateFuture(null), this, executorProvider.get());",
+            "        Futures.<Void>immediateFuture(null), this, this);",
             "  }",
             "",
             "  @Deprecated",
@@ -403,6 +404,15 @@ public void publicModuleNonPublicIncludes() {
             "      monitor.methodFinished();",
             "    }",
             "  }",
+            "",
+            "  @Deprecated",
+            "  @Override public void execute(Runnable runnable) {",
+            "    assert monitor != null :",
+            "        \"execute() may only be called internally from compute(); \"",
+            "        + \"if it's called explicitly, the monitor might be null\";",
+            "    monitor.ready();",
+            "    executorProvider.get().execute(runnable);",
+            "  }",
             "}");
     assertAbout(javaSource())
         .that(moduleFile)
@@ -447,7 +457,8 @@ public void singleProducesMethodNoArgsFutureWithProducerName() {
             "",
             GENERATED_ANNOTATION,
             "public final class TestModule_ProduceStringFactory",
-            "    extends AbstractProducer<String> implements AsyncFunction<Void, String> {",
+            "    extends AbstractProducer<String>",
+            "    implements AsyncFunction<Void, String>, Executor {",
             "  private final TestModule module;",
             "  private final Provider<Executor> executorProvider;",
             "  private final Provider<ProductionComponentMonitor> monitorProvider;",
@@ -469,7 +480,7 @@ public void singleProducesMethodNoArgsFutureWithProducerName() {
             "",
             "  @Override protected ListenableFuture<String> compute() {",
             "    return Futures.transformAsync(",
-            "      Futures.<Void>immediateFuture(null), this, executorProvider.get());",
+            "      Futures.<Void>immediateFuture(null), this, this);",
             "  }",
             "",
             "  @Deprecated",
@@ -484,6 +495,15 @@ public void singleProducesMethodNoArgsFutureWithProducerName() {
             "      monitor.methodFinished();",
             "    }",
             "  }",
+            "",
+            "  @Deprecated",
+            "  @Override public void execute(Runnable runnable) {",
+            "    assert monitor != null :",
+            "        \"execute() may only be called internally from compute(); \"",
+            "        + \"if it's called explicitly, the monitor might be null\";",
+            "    monitor.ready();",
+            "    executorProvider.get().execute(runnable);",
+            "  }",
             "}");
     assertAbout(javaSource())
         .that(moduleFile)
diff --git a/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java
index 2885c6ebc..561795632 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Google, Inc.
+ * Copyright (C) 2014 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,8 +13,14 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal.codegen;
 
+import static com.google.common.truth.Truth.assertAbout;
+import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
+
 import com.google.common.collect.ImmutableList;
 import com.google.testing.compile.JavaFileObjects;
 import javax.tools.JavaFileObject;
@@ -22,11 +28,6 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import static com.google.common.truth.Truth.assertAbout;
-import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
-import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
-import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
-
 @RunWith(JUnit4.class)
 public class ProductionComponentProcessorTest {
   @Test public void componentOnConcreteClass() {
@@ -235,7 +236,7 @@ public void simpleComponent() {
             "  }",
             "",
             "  public static TestClass.SimpleComponent create() {",
-            "    return builder().build()",
+            "    return new Builder().build()",
             "  }",
             "",
             "  @SuppressWarnings(\"unchecked\")",
@@ -296,14 +297,6 @@ public void simpleComponent() {
             "    }",
             "",
             "    @Deprecated",
-            "    public Builder testClass_SimpleComponent_MonitoringModule(",
-            "        TestClass_SimpleComponent_MonitoringModule",
-            "        testClass_SimpleComponent_MonitoringModule) {",
-            "      Preconditions.checkNotNull(testClass_SimpleComponent_MonitoringModule);",
-            "      return this;",
-            "    }",
-            "",
-            "    @Deprecated",
             "    public Builder testClass_SimpleComponent_ProductionExecutorModule(",
             "        TestClass_SimpleComponent_ProductionExecutorModule",
             "        testClass_SimpleComponent_ProductionExecutorModule) {",
diff --git a/compiler/src/test/java/dagger/internal/codegen/ProductionGraphValidationTest.java b/compiler/src/test/java/dagger/internal/codegen/ProductionGraphValidationTest.java
index 0206ec7fd..040000fbf 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ProductionGraphValidationTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ProductionGraphValidationTest.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Google, Inc.
+ * Copyright (C) 2014 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,18 +13,22 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal.codegen;
 
+import static com.google.common.truth.Truth.assertAbout;
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+import static dagger.internal.codegen.Compilers.daggerCompiler;
+
 import com.google.common.collect.ImmutableList;
+import com.google.testing.compile.Compilation;
 import com.google.testing.compile.JavaFileObjects;
 import javax.tools.JavaFileObject;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import static com.google.common.truth.Truth.assertAbout;
-import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
-
 /**
  * Unit tests for {@link BindingGraphValidator} that exercise producer-specific logic.
  */
@@ -148,29 +152,31 @@
   }
 
   @Test public void provisionEntryPointDependsOnProduction() {
-    JavaFileObject component = JavaFileObjects.forSourceLines("test.TestClass",
-        "package test;",
-        "",
-        "import com.google.common.util.concurrent.ListenableFuture;",
-        "import dagger.producers.ProducerModule;",
-        "import dagger.producers.Produces;",
-        "import dagger.producers.ProductionComponent;",
-        "",
-        "final class TestClass {",
-        "  interface A {}",
-        "",
-        "  @ProducerModule",
-        "  final class AModule {",
-        "    @Produces ListenableFuture<A> a() {",
-        "      return null;",
-        "    }",
-        "  }",
-        "",
-        "  @ProductionComponent(modules = {ExecutorModule.class, AModule.class})",
-        "  interface AComponent {",
-        "    A getA();",
-        "  }",
-        "}");
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestClass",
+            "package test;",
+            "",
+            "import com.google.common.util.concurrent.ListenableFuture;",
+            "import dagger.producers.ProducerModule;",
+            "import dagger.producers.Produces;",
+            "import dagger.producers.ProductionComponent;",
+            "",
+            "final class TestClass {",
+            "  interface A {}",
+            "",
+            "  @ProducerModule",
+            "  static final class AModule {",
+            "    @Produces ListenableFuture<A> a() {",
+            "      return null;",
+            "    }",
+            "  }",
+            "",
+            "  @ProductionComponent(modules = {ExecutorModule.class, AModule.class})",
+            "  interface AComponent {",
+            "    A getA();",
+            "  }",
+            "}");
     String expectedError =
         "test.TestClass.A is a provision entry-point, which cannot depend on a production.";
     assertAbout(javaSources()).that(ImmutableList.of(EXECUTOR_MODULE, component))
@@ -179,6 +185,65 @@
         .withErrorContaining(expectedError).in(component).onLine(20);
   }
 
+  @Test
+  public void providingMultibindingWithProductions() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestClass",
+            "package test;",
+            "",
+            "import com.google.common.util.concurrent.ListenableFuture;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntoMap;",
+            "import dagger.multibindings.StringKey;",
+            "import dagger.producers.ProducerModule;",
+            "import dagger.producers.Produces;",
+            "import dagger.producers.ProductionComponent;",
+            "import java.util.Map;",
+            "import javax.inject.Provider;",
+            "",
+            "final class TestClass {",
+            "  interface A {}",
+            "  interface B {}",
+            "",
+            "  @Module",
+            "  static final class AModule {",
+            "    @Provides static A a(Map<String, Provider<Object>> map) {",
+            "      return null;",
+            "    }",
+            "",
+            "    @Provides @IntoMap @StringKey(\"a\") static Object aEntry() {",
+            "      return \"a\";",
+            "    }",
+            "  }",
+            "",
+            "  @ProducerModule",
+            "  static final class BModule {",
+            "    @Produces static B b(A a) {",
+            "      return null;",
+            "    }",
+            "",
+            "    @Produces @IntoMap @StringKey(\"b\") static Object bEntry() {",
+            "      return \"b\";",
+            "    }",
+            "  }",
+            "",
+            "  @ProductionComponent(",
+            "      modules = {ExecutorModule.class, AModule.class, BModule.class})",
+            "  interface AComponent {",
+            "    ListenableFuture<B> b();",
+            "  }",
+            "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(EXECUTOR_MODULE, component))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("test.TestClass.A is a provision, which cannot depend on a production")
+        .in(component)
+        .onLine(43);
+  }
+
   @Test
   public void monitoringDependsOnUnboundType() {
     JavaFileObject component =
@@ -275,9 +340,8 @@ public void monitoringDependsOnProduction() {
             "  }",
             "}");
     String expectedError =
-        "@Provides @dagger.multibindings.IntoSet"
-            + " dagger.producers.monitoring.ProductionComponentMonitor.Factory"
-            + " test.TestClass.MonitoringModule.monitorFactory(test.TestClass.A) is a provision,"
+        "java.util.Set<dagger.producers.monitoring.ProductionComponentMonitor.Factory>"
+            + " test.TestClass.MonitoringModule#monitorFactory is a provision,"
             + " which cannot depend on a production.";
     assertAbout(javaSources()).that(ImmutableList.of(EXECUTOR_MODULE, component))
         .processedWith(new ComponentProcessor())
@@ -286,7 +350,7 @@ public void monitoringDependsOnProduction() {
         .in(component)
         .onLine(37);
   }
-  
+
   @Test
   public void cycleNotBrokenByMap() {
     JavaFileObject component =
@@ -377,4 +441,44 @@ public void cycleNotBrokenByProducerMap() {
         .in(component)
         .onLine(8);
   }
+  
+  @Test
+  public void componentWithBadModule() {
+    JavaFileObject badModule =
+        JavaFileObjects.forSourceLines(
+            "test.BadModule",
+            "package test;",
+            "",
+            "import dagger.BindsOptionalOf;",
+            "import dagger.multibindings.Multibinds;",
+            "import dagger.Module;",
+            "import java.util.Set;",
+            "",
+            "@Module",
+            "abstract class BadModule {",
+            "  @Multibinds",
+            "  @BindsOptionalOf",
+            "  abstract Set<String> strings();",
+            "}");
+    JavaFileObject badComponent =
+        JavaFileObjects.forSourceLines(
+            "test.BadComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import java.util.Optional;",
+            "import java.util.Set;",
+            "",
+            "@Component(modules = BadModule.class)",
+            "interface BadComponent {",
+            "  Set<String> strings();",
+            "  Optional<Set<String>> optionalStrings();",
+            "}");
+    Compilation compilation = daggerCompiler().compile(badModule, badComponent);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("test.BadModule has errors")
+        .inFile(badComponent)
+        .onLine(7);
+  }
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/RepeatedModuleValidationTest.java b/compiler/src/test/java/dagger/internal/codegen/RepeatedModuleValidationTest.java
index dddda0e81..978dc6b3e 100644
--- a/compiler/src/test/java/dagger/internal/codegen/RepeatedModuleValidationTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/RepeatedModuleValidationTest.java
@@ -1,5 +1,8 @@
 package dagger.internal.codegen;
 
+import static com.google.common.truth.Truth.assertAbout;
+import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+
 import com.google.common.collect.ImmutableList;
 import com.google.testing.compile.JavaFileObjects;
 import javax.tools.JavaFileObject;
@@ -7,9 +10,6 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import static com.google.common.truth.Truth.assertAbout;
-import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
-
 @RunWith(JUnit4.class)
 public class RepeatedModuleValidationTest {
   private static final JavaFileObject MODULE_FILE =
diff --git a/compiler/src/test/java/dagger/internal/codegen/SourceFilesTest.java b/compiler/src/test/java/dagger/internal/codegen/SourceFilesTest.java
new file mode 100644
index 000000000..c7fe99876
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/SourceFilesTest.java
@@ -0,0 +1,70 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.truth.Truth.assertThat;
+import static dagger.internal.codegen.SourceFiles.simpleVariableName;
+
+import com.google.testing.compile.CompilationRule;
+import java.util.List;
+import javax.lang.model.element.TypeElement;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/** Tests for {@link SourceFiles}. */
+@RunWith(JUnit4.class)
+public final class SourceFilesTest {
+  @Rule public CompilationRule compilation = new CompilationRule();
+
+  private TypeElement typeElementFor(Class<?> clazz) {
+    return compilation.getElements().getTypeElement(clazz.getCanonicalName());
+  }
+
+  private static final class Int {}
+
+  @Test
+  public void testSimpleVariableName_typeCollisions() {
+    // a handful of boxed types
+    assertThat(simpleVariableName(typeElementFor(Long.class))).isEqualTo("l");
+    assertThat(simpleVariableName(typeElementFor(Double.class))).isEqualTo("d");
+    // not a boxed type type, but a custom type might collide
+    assertThat(simpleVariableName(typeElementFor(Int.class))).isEqualTo("i");
+    // void is the weird pseudo-boxed type
+    assertThat(simpleVariableName(typeElementFor(Void.class))).isEqualTo("v");
+    // reflective types
+    assertThat(simpleVariableName(typeElementFor(Class.class))).isEqualTo("clazz");
+    assertThat(simpleVariableName(typeElementFor(Package.class))).isEqualTo("pkg");
+  }
+
+  private static final class For {}
+
+  private static final class Goto {}
+
+  @Test
+  public void testSimpleVariableName_randomKeywords() {
+    assertThat(simpleVariableName(typeElementFor(For.class))).isEqualTo("for_");
+    assertThat(simpleVariableName(typeElementFor(Goto.class))).isEqualTo("goto_");
+  }
+
+  @Test
+  public void testSimpleVariableName() {
+    assertThat(simpleVariableName(typeElementFor(Object.class))).isEqualTo("object");
+    assertThat(simpleVariableName(typeElementFor(List.class))).isEqualTo("list");
+  }
+}
diff --git a/compiler/src/test/java/dagger/internal/codegen/SubcomponentBuilderValidationTest.java b/compiler/src/test/java/dagger/internal/codegen/SubcomponentBuilderValidationTest.java
index 6311a90ca..f4cb9ed51 100644
--- a/compiler/src/test/java/dagger/internal/codegen/SubcomponentBuilderValidationTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/SubcomponentBuilderValidationTest.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,39 +13,43 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal.codegen;
 
+import static com.google.common.truth.Truth.assertAbout;
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+import static dagger.internal.codegen.Compilers.daggerCompiler;
+
+import com.google.common.base.Joiner;
 import com.google.common.collect.ImmutableList;
+import com.google.testing.compile.Compilation;
 import com.google.testing.compile.JavaFileObjects;
 import javax.tools.JavaFileObject;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import static com.google.common.truth.Truth.assertAbout;
-import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
-import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
-
 /** Tests for {@link dagger.Subcomponent.Builder} validation. */
 @RunWith(JUnit4.class)
 public class SubcomponentBuilderValidationTest {
-  
+
   private static final ErrorMessages.SubcomponentBuilderMessages MSGS =
       new ErrorMessages.SubcomponentBuilderMessages();
-  
+
   @Test
   public void testRefSubcomponentAndSubBuilderFails() {
     JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.ParentComponent",
         "package test;",
         "",
         "import dagger.Component;",
-        "",
         "import javax.inject.Provider;",
         "",
         "@Component",
         "interface ParentComponent {",
         "  ChildComponent child();",
-        "  ChildComponent.Builder builder();",        
+        "  ChildComponent.Builder builder();",
         "}");
     JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
         "package test;",
@@ -66,20 +70,19 @@ public void testRefSubcomponentAndSubBuilderFails() {
             "test.ChildComponent", "[child(), builder()]"))
         .in(componentFile);
   }
-  
+
   @Test
   public void testRefSubBuilderTwiceFails() {
     JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.ParentComponent",
         "package test;",
         "",
         "import dagger.Component;",
-        "",
         "import javax.inject.Provider;",
         "",
         "@Component",
         "interface ParentComponent {",
         "  ChildComponent.Builder builder1();",
-        "  ChildComponent.Builder builder2();",        
+        "  ChildComponent.Builder builder2();",
         "}");
     JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
         "package test;",
@@ -100,19 +103,18 @@ public void testRefSubBuilderTwiceFails() {
             "test.ChildComponent", "[builder1(), builder2()]"))
         .in(componentFile);
   }
-  
+
   @Test
   public void testMoreThanOneBuilderFails() {
     JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.ParentComponent",
         "package test;",
         "",
         "import dagger.Component;",
-        "",
         "import javax.inject.Provider;",
         "",
         "@Component",
         "interface ParentComponent {",
-        "  ChildComponent.Builder1 build();",        
+        "  ChildComponent.Builder1 build();",
         "}");
     JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
         "package test;",
@@ -138,19 +140,18 @@ public void testMoreThanOneBuilderFails() {
             "[test.ChildComponent.Builder1, test.ChildComponent.Builder2]"))
         .in(childComponentFile);
   }
-  
+
   @Test
   public void testBuilderGenericsFails() {
     JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.ParentComponent",
         "package test;",
         "",
         "import dagger.Component;",
-        "",
         "import javax.inject.Provider;",
         "",
         "@Component",
         "interface ParentComponent {",
-        "  ChildComponent.Builder1 build();",        
+        "  ChildComponent.Builder1 build();",
         "}");
     JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
         "package test;",
@@ -162,7 +163,7 @@ public void testBuilderGenericsFails() {
         "  @Subcomponent.Builder",
         "  interface Builder<T> {",
         "     ChildComponent build();",
-        "  }",           
+        "  }",
         "}");
     assertAbout(javaSources()).that(ImmutableList.of(componentFile, childComponentFile))
         .processedWith(new ComponentProcessor())
@@ -170,7 +171,7 @@ public void testBuilderGenericsFails() {
         .withErrorContaining(MSGS.generics())
         .in(childComponentFile);
   }
-  
+
   @Test
   public void testBuilderNotInComponentFails() {
     JavaFileObject builder = JavaFileObjects.forSourceLines("test.Builder",
@@ -186,19 +187,18 @@ public void testBuilderNotInComponentFails() {
         .withErrorContaining(MSGS.mustBeInComponent())
         .in(builder);
   }
-  
+
   @Test
   public void testBuilderMissingBuildMethodFails() {
     JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.ParentComponent",
         "package test;",
         "",
         "import dagger.Component;",
-        "",
         "import javax.inject.Provider;",
         "",
         "@Component",
         "interface ParentComponent {",
-        "  ChildComponent.Builder1 build();",        
+        "  ChildComponent.Builder1 build();",
         "}");
     JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
         "package test;",
@@ -216,7 +216,7 @@ public void testBuilderMissingBuildMethodFails() {
         .withErrorContaining(MSGS.missingBuildMethod())
         .in(childComponentFile);
   }
-  
+
   @Test
   public void testPrivateBuilderFails() {
     JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
@@ -235,7 +235,7 @@ public void testPrivateBuilderFails() {
         .withErrorContaining(MSGS.isPrivate())
         .in(childComponentFile);
   }
-  
+
   @Test
   public void testNonStaticBuilderFails() {
     JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
@@ -254,7 +254,7 @@ public void testNonStaticBuilderFails() {
         .withErrorContaining(MSGS.mustBeStatic())
         .in(childComponentFile);
   }
-  
+
   @Test
   public void testNonAbstractBuilderFails() {
     JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
@@ -273,7 +273,7 @@ public void testNonAbstractBuilderFails() {
         .withErrorContaining(MSGS.mustBeAbstract())
         .in(childComponentFile);
   }
-  
+
   @Test
   public void testBuilderOneCxtorWithArgsFails() {
     JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
@@ -294,7 +294,7 @@ public void testBuilderOneCxtorWithArgsFails() {
         .withErrorContaining(MSGS.cxtorOnlyOneAndNoArgs())
         .in(childComponentFile);
   }
-  
+
   @Test
   public void testBuilderMoreThanOneCxtorFails() {
     JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
@@ -316,7 +316,7 @@ public void testBuilderMoreThanOneCxtorFails() {
         .withErrorContaining(MSGS.cxtorOnlyOneAndNoArgs())
         .in(childComponentFile);
   }
-  
+
   @Test
   public void testBuilderEnumFails() {
     JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
@@ -335,7 +335,7 @@ public void testBuilderEnumFails() {
         .withErrorContaining(MSGS.mustBeClassOrInterface())
         .in(childComponentFile);
   }
-  
+
   @Test
   public void testBuilderBuildReturnsWrongTypeFails() {
     JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
@@ -356,7 +356,7 @@ public void testBuilderBuildReturnsWrongTypeFails() {
         .withErrorContaining(MSGS.buildMustReturnComponentType())
             .in(childComponentFile).onLine(9);
   }
-  
+
   @Test
   public void testInheritedBuilderBuildReturnsWrongTypeFails() {
     JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
@@ -380,7 +380,7 @@ public void testInheritedBuilderBuildReturnsWrongTypeFails() {
             String.format(MSGS.inheritedBuildMustReturnComponentType(), "build"))
             .in(childComponentFile).onLine(12);
   }
-  
+
   @Test
   public void testTwoBuildMethodsFails() {
     JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
@@ -402,7 +402,7 @@ public void testTwoBuildMethodsFails() {
         .withErrorContaining(String.format(MSGS.twoBuildMethods(), "build()"))
             .in(childComponentFile).onLine(10);
   }
-  
+
   @Test
   public void testInheritedTwoBuildMethodsFails() {
     JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
@@ -424,10 +424,10 @@ public void testInheritedTwoBuildMethodsFails() {
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(
-            String.format(MSGS.inheritedTwoBuildMethods(), "create()", "build()"))
+            String.format(MSGS.inheritedTwoBuildMethods(), "build()", "create()"))
             .in(childComponentFile).onLine(13);
   }
-  
+
   @Test
   public void testMoreThanOneArgFails() {
     JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
@@ -452,7 +452,7 @@ public void testMoreThanOneArgFails() {
         .and().withErrorContaining(MSGS.methodsMustTakeOneArg())
             .in(childComponentFile).onLine(11);
   }
-  
+
   @Test
   public void testInheritedMoreThanOneArgFails() {
     JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
@@ -478,7 +478,7 @@ public void testInheritedMoreThanOneArgFails() {
                 "set1(java.lang.String,java.lang.Integer)"))
             .in(childComponentFile).onLine(13);
   }
-  
+
   @Test
   public void testSetterReturningNonVoidOrBuilderFails() {
     JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
@@ -500,7 +500,7 @@ public void testSetterReturningNonVoidOrBuilderFails() {
         .withErrorContaining(MSGS.methodsMustReturnVoidOrBuilder())
             .in(childComponentFile).onLine(10);
   }
-  
+
   @Test
   public void testInheritedSetterReturningNonVoidOrBuilderFails() {
     JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
@@ -524,9 +524,9 @@ public void testInheritedSetterReturningNonVoidOrBuilderFails() {
         .withErrorContaining(
             String.format(MSGS.inheritedMethodsMustReturnVoidOrBuilder(),
                 "set(java.lang.Integer)"))
-            .in(childComponentFile).onLine(13);    
+            .in(childComponentFile).onLine(13);
   }
-  
+
   @Test
   public void testGenericsOnSetterMethodFails() {
     JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
@@ -548,7 +548,7 @@ public void testGenericsOnSetterMethodFails() {
         .withErrorContaining(MSGS.methodsMayNotHaveTypeParameters())
             .in(childComponentFile).onLine(10);
   }
-  
+
   @Test
   public void testGenericsOnInheritedSetterMethodFails() {
     JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
@@ -571,74 +571,179 @@ public void testGenericsOnInheritedSetterMethodFails() {
         .failsToCompile()
         .withErrorContaining(
             String.format(MSGS.inheritedMethodsMayNotHaveTypeParameters(), "<T>set(T)"))
-            .in(childComponentFile).onLine(13);    
+            .in(childComponentFile).onLine(13);
   }
-  
+
   @Test
   public void testMultipleSettersPerTypeFails() {
-    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
-        "package test;",
-        "",
-        "import dagger.Subcomponent;",
-        "",
-        "@Subcomponent",
-        "abstract class ChildComponent {",
-        "  @Subcomponent.Builder",
-        "  interface Builder {",
-        "    ChildComponent build();",
-        "    void set1(String s);",
-        "    void set2(String s);",
-        "  }",
-        "}");
-    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
+    JavaFileObject moduleFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "final class TestModule {",
+            "  @Provides String s() { return \"\"; }",
+            "}");
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.ParentComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface ParentComponent {",
+            "  ChildComponent.Builder childComponentBuilder();",
+            "}");
+    JavaFileObject childComponentFile =
+        JavaFileObjects.forSourceLines(
+            "test.ChildComponent",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = TestModule.class)",
+            "abstract class ChildComponent {",
+            "  abstract String s();",
+            "",
+            "  @Subcomponent.Builder",
+            "  interface Builder {",
+            "    ChildComponent build();",
+            "    void set1(TestModule s);",
+            "    void set2(TestModule s);",
+            "  }",
+            "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(moduleFile, componentFile, childComponentFile))
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(
-            String.format(MSGS.manyMethodsForType(),
-                  "java.lang.String", "[set1(java.lang.String), set2(java.lang.String)]"))
-            .in(childComponentFile).onLine(8);
+            String.format(
+                MSGS.manyMethodsForType(),
+                "test.TestModule",
+                "[set1(test.TestModule), set2(test.TestModule)]"))
+        .in(childComponentFile)
+        .onLine(10);
   }
-  
+
   @Test
   public void testMultipleSettersPerTypeIncludingResolvedGenericsFails() {
-    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
-        "package test;",
-        "",
-        "import dagger.Subcomponent;",
-        "",
-        "@Subcomponent",
-        "abstract class ChildComponent {",
-        "  interface Parent<T> {",
-        "    void set1(T t);",
-        "  }",
-        "",
-        "  @Subcomponent.Builder",
-        "  interface Builder extends Parent<String> {",
-        "    ChildComponent build();",
-        "    void set2(String s);",
-        "  }",
-        "}");
-    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
+    JavaFileObject moduleFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "final class TestModule {",
+            "  @Provides String s() { return \"\"; }",
+            "}");
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.ParentComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface ParentComponent {",
+            "  ChildComponent.Builder childComponentBuilder();",
+            "}");
+    JavaFileObject childComponentFile =
+        JavaFileObjects.forSourceLines(
+            "test.ChildComponent",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = TestModule.class)",
+            "abstract class ChildComponent {",
+            "  abstract String s();",
+            "",
+            "  interface Parent<T> {",
+            "    void set1(T t);",
+            "  }",
+            "",
+            "  @Subcomponent.Builder",
+            "  interface Builder extends Parent<TestModule> {",
+            "    ChildComponent build();",
+            "    void set2(TestModule s);",
+            "  }",
+            "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(moduleFile, componentFile, childComponentFile))
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(
-            String.format(MSGS.manyMethodsForType(),
-                  "java.lang.String", "[set1(T), set2(java.lang.String)]"))
-            .in(childComponentFile).onLine(12);
+            String.format(
+                MSGS.manyMethodsForType(), "test.TestModule", "[set1(T), set2(test.TestModule)]"))
+        .in(childComponentFile)
+        .onLine(14);
+  }
+
+  @Test
+  public void testMultipleSettersPerBoundInstanceTypeFails() {
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.ParentComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface ParentComponent {",
+            "  ChildComponent.Builder childComponentBuilder();",
+            "}");
+    JavaFileObject childComponentFile =
+        JavaFileObjects.forSourceLines(
+            "test.ChildComponent",
+            "package test;",
+            "",
+            "import dagger.BindsInstance;",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent",
+            "interface ChildComponent {",
+            "  String s();",
+            "",
+            "  @Subcomponent.Builder",
+            "  interface Builder {",
+            "    ChildComponent build();",
+            "    @BindsInstance void set1(String s);",
+            "    @BindsInstance void set2(String s);",
+            "  }",
+            "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(componentFile, childComponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            Joiner.on("\n      ")
+                .join(
+                    "java.lang.String is bound multiple times:",
+                    "@BindsInstance void test.ChildComponent.Builder.set1(String)",
+                    "@BindsInstance void test.ChildComponent.Builder.set2(String)"))
+        .in(childComponentFile)
+        .onLine(8);
   }
-  
+
   @Test
   public void testExtraSettersFails() {
     JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.ParentComponent",
         "package test;",
         "",
         "import dagger.Component;",
-        "",
         "import javax.inject.Provider;",
         "",
         "@Component",
         "interface ParentComponent {",
-        "  ChildComponent.Builder build();",        
+        "  ChildComponent.Builder build();",
         "}");
     JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
         "package test;",
@@ -662,9 +767,8 @@ public void testExtraSettersFails() {
                   "[void test.ChildComponent.Builder.set1(String),"
                   + " void test.ChildComponent.Builder.set2(Integer)]"))
             .in(childComponentFile).onLine(8);
-    
   }
-  
+
   @Test
   public void testMissingSettersFail() {
     JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
@@ -703,12 +807,11 @@ public void testMissingSettersFail() {
         "package test;",
         "",
         "import dagger.Component;",
-        "",
         "import javax.inject.Provider;",
         "",
         "@Component",
         "interface ParentComponent {",
-        "  ChildComponent.Builder build();",        
+        "  ChildComponent.Builder build();",
         "}");
     JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
         "package test;",
@@ -739,4 +842,169 @@ public void testMissingSettersFail() {
             String.format(MSGS.missingSetters(), "[test.TestModule, test.Test3Module]"))
             .in(childComponentFile).onLine(11);
   }
+
+  @Test
+  public void covariantBuildMethodReturnType() {
+    JavaFileObject foo =
+        JavaFileObjects.forSourceLines(
+            "test.Foo",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class Foo {",
+            "  @Inject Foo() {}",
+            "}");
+    JavaFileObject supertype =
+        JavaFileObjects.forSourceLines(
+            "test.Supertype",
+            "package test;",
+            "",
+            "interface Supertype {",
+            "  Foo foo();",
+            "}");
+
+    JavaFileObject subcomponent =
+        JavaFileObjects.forSourceLines(
+            "test.HasSupertype",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent",
+            "interface HasSupertype extends Supertype {",
+            "  @Subcomponent.Builder",
+            "  interface Builder {",
+            "    Supertype build();",
+            "  }",
+            "}");
+
+    Compilation compilation = daggerCompiler().compile(foo, supertype, subcomponent);
+    assertThat(compilation).succeededWithoutWarnings();
+  }
+
+  @Test
+  public void covariantBuildMethodReturnType_hasNewMethod() {
+    JavaFileObject foo =
+        JavaFileObjects.forSourceLines(
+            "test.Foo",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class Foo {",
+            "  @Inject Foo() {}",
+            "}");
+    JavaFileObject bar =
+        JavaFileObjects.forSourceLines(
+            "test.Bar",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class Bar {",
+            "  @Inject Bar() {}",
+            "}");
+    JavaFileObject supertype =
+        JavaFileObjects.forSourceLines(
+            "test.Supertype",
+            "package test;",
+            "",
+            "interface Supertype {",
+            "  Foo foo();",
+            "}");
+
+    JavaFileObject subcomponent =
+        JavaFileObjects.forSourceLines(
+            "test.HasSupertype",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent",
+            "interface HasSupertype extends Supertype {",
+            "  Bar bar();",
+            "",
+            "  @Subcomponent.Builder",
+            "  interface Builder {",
+            "    Supertype build();",
+            "  }",
+            "}");
+
+    Compilation compilation = daggerCompiler().compile(foo, bar, supertype, subcomponent);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .hadWarningContaining(
+            "test.HasSupertype.Builder.build() returns test.Supertype, but test.HasSupertype "
+                + "declares additional component method(s): bar(). In order to provide type-safe "
+                + "access to these methods, override build() to return test.HasSupertype")
+        .inFile(subcomponent)
+        .onLine(11);
+  }
+
+  @Test
+  public void covariantBuildMethodReturnType_hasNewMethod_buildMethodInherited() {
+    JavaFileObject foo =
+        JavaFileObjects.forSourceLines(
+            "test.Foo",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class Foo {",
+            "  @Inject Foo() {}",
+            "}");
+    JavaFileObject bar =
+        JavaFileObjects.forSourceLines(
+            "test.Bar",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class Bar {",
+            "  @Inject Bar() {}",
+            "}");
+    JavaFileObject supertype =
+        JavaFileObjects.forSourceLines(
+            "test.Supertype",
+            "package test;",
+            "",
+            "interface Supertype {",
+            "  Foo foo();",
+            "}");
+
+    JavaFileObject builderSupertype =
+        JavaFileObjects.forSourceLines(
+            "test.BuilderSupertype",
+            "package test;",
+            "",
+            "interface BuilderSupertype {",
+            "  Supertype build();",
+            "}");
+
+    JavaFileObject subcomponent =
+        JavaFileObjects.forSourceLines(
+            "test.HasSupertype",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent",
+            "interface HasSupertype extends Supertype {",
+            "  Bar bar();",
+            "",
+            "  @Subcomponent.Builder",
+            "  interface Builder extends BuilderSupertype {}",
+            "}");
+
+    Compilation compilation =
+        daggerCompiler().compile(foo, bar, supertype, builderSupertype, subcomponent);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .hadWarningContaining(
+            "[test.BuilderSupertype.build()] test.HasSupertype.Builder.build() returns "
+                + "test.Supertype, but test.HasSupertype declares additional component method(s): "
+                + "bar(). In order to provide type-safe access to these methods, override build() "
+                + "to return test.HasSupertype");
+  }
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/SubcomponentValidationTest.java b/compiler/src/test/java/dagger/internal/codegen/SubcomponentValidationTest.java
index c2d7d1d16..976864df8 100644
--- a/compiler/src/test/java/dagger/internal/codegen/SubcomponentValidationTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/SubcomponentValidationTest.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,8 +13,14 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal.codegen;
 
+import static com.google.common.truth.Truth.assertAbout;
+import static com.google.testing.compile.JavaSourcesSubject.assertThat;
+import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
+
 import com.google.common.collect.ImmutableList;
 import com.google.testing.compile.JavaFileObjects;
 import javax.tools.JavaFileObject;
@@ -22,10 +28,6 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import static com.google.common.truth.Truth.assertAbout;
-import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
-import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
-
 @RunWith(JUnit4.class)
 public final class SubcomponentValidationTest {
   @Test public void factoryMethod_missingModulesWithParameters() {
@@ -197,12 +199,16 @@
         "interface ChildComponent {",
         "  String getString();",
         "}");
-    assertAbout(javaSources()).that(ImmutableList.of(moduleFile, componentFile, childComponentFile))
+    assertAbout(javaSources())
+        .that(ImmutableList.of(moduleFile, componentFile, childComponentFile))
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(
-            "java.lang.Integer cannot be provided without an @Inject constructor or from an "
-                + "@Provides-annotated method");
+            "[test.ChildComponent.getString()] "
+                + "java.lang.Integer cannot be provided without an @Inject constructor or from an "
+                + "@Provides-annotated method")
+        .in(componentFile)
+        .onLine(6);
   }
 
   @Test public void subcomponentOnConcreteType() {
@@ -365,7 +371,7 @@ public void delegateFactoryNotCreatedForSubcomponentWhenProviderExistsInParent()
             "  }",
             "",
             "  public static ParentComponent create() {  ",
-            "    return builder().build();",
+            "    return new Builder().build();",
             "  }",
             "",
             "  @SuppressWarnings(\"unchecked\")",
@@ -522,7 +528,7 @@ public void multipleSubcomponentsWithSameSimpleNamesCanExistInSameComponent() {
             "  }",
             "",
             "  public static ParentComponent create() {",
-            "    return builder().build();",
+            "    return new Builder().build();",
             "  }",
             "",
             "  @Override",
@@ -629,7 +635,7 @@ public void subcomponentSimpleNamesDisambiguated() {
             "  }",
             "",
             "  public static ParentComponent create() {",
-            "    return builder().build();",
+            "    return new Builder().build();",
             "  }",
             "",
             "  @Override",
@@ -727,7 +733,7 @@ public void subcomponentImplNameUsesFullyQualifiedClassNameIfNecessary() {
             "  }",
             "",
             "  public static ParentComponent create() {",
-            "    return builder().build();",
+            "    return new Builder().build();",
             "  }",
             "",
             "  @Override",
@@ -806,7 +812,7 @@ public void parentComponentNameShouldNotBeDisambiguatedWhenItConflictsWithASubco
             "  }",
             "",
             "  public static C create() {",
-            "    return builder().build();",
+            "    return new Builder().build();",
             "  }",
             "",
             "  @Override",
@@ -876,11 +882,17 @@ public void subcomponentBuilderNamesShouldNotConflict() {
             "package test;",
             "",
             "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
             "",
             GENERATED_ANNOTATION,
             "public final class DaggerC implements C {",
+            "",
+            "  private Provider<C.Foo.Sub.Builder> fooBuilderProvider;",
+            "  private Provider<C.Bar.Sub.Builder> barBuilderProvider;",
+            "",
             "  private DaggerC(Builder builder) {",
             "    assert builder != null;",
+            "    initialize(builder);",
             "  }",
             "",
             "  public static Builder builder() {",
@@ -888,17 +900,36 @@ public void subcomponentBuilderNamesShouldNotConflict() {
             "  }",
             "",
             "  public static C create() {",
-            "    return builder().build();",
+            "    return new Builder().build();",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize(final Builder builder) {",
+            "    this.fooBuilderProvider = ",
+            "        new dagger.internal.Factory<C.Foo.Sub.Builder>() {",
+            "          @Override",
+            "          public C.Foo.Sub.Builder get() {",
+            "            return new Foo_SubBuilder();",
+            "          }",
+            "        };",
+            "",
+            "    this.barBuilderProvider = ",
+            "        new dagger.internal.Factory<C.Bar.Sub.Builder>() {",
+            "          @Override",
+            "          public C.Bar.Sub.Builder get() {",
+            "            return new Bar_SubBuilder();",
+            "          }",
+            "        };",
             "  }",
             "",
             "  @Override",
             "  public C.Foo.Sub.Builder fooBuilder() {",
-            "    return new Foo_SubBuilder();",
+            "    return fooBuilderProvider.get();",
             "  }",
             "",
             "  @Override",
             "  public C.Bar.Sub.Builder barBuilder() {",
-            "    return new Bar_SubBuilder();",
+            "    return barBuilderProvider.get();",
             "  }",
             "",
             "  public static final class Builder {",
@@ -943,4 +974,60 @@ public void subcomponentBuilderNamesShouldNotConflict() {
         .and()
         .generatesSources(componentGeneratedFile);
   }
+
+  @Test
+  public void duplicateBindingWithSubcomponentDeclaration() {
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module(subcomponents = Sub.class)",
+            "class TestModule {",
+            "  @Provides Sub.Builder providesConflictsWithModuleSubcomponents() { return null; }",
+            "  @Provides Object usesSubcomponentBuilder(Sub.Builder builder) {",
+            "    return new Builder().toString();",
+            "  }",
+            "}");
+
+    JavaFileObject subcomponent =
+        JavaFileObjects.forSourceLines(
+            "test.Sub",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent",
+            "interface Sub {",
+            "  @Subcomponent.Builder",
+            "  interface Builder {",
+            "    Sub build();",
+            "  }",
+            "}");
+
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.Sub",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = TestModule.class)",
+            "interface C {",
+            "  Object dependsOnBuilder();",
+            "}");
+
+    assertThat(module, component, subcomponent)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("test.Sub.Builder is bound multiple times:")
+        .and()
+        .withErrorContaining(
+            "@Provides test.Sub.Builder test.TestModule.providesConflictsWithModuleSubcomponents()")
+        .and()
+        .withErrorContaining("@Module(subcomponents = test.Sub.class) for test.TestModule");
+  }
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/ValidationReportTest.java b/compiler/src/test/java/dagger/internal/codegen/ValidationReportTest.java
index d7f445125..2ca4ce75f 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ValidationReportTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ValidationReportTest.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,8 +13,13 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal.codegen;
 
+import static com.google.common.truth.Truth.assertAbout;
+import static com.google.common.truth.Truth.assertThat;
+import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+
 import com.google.common.collect.ImmutableSet;
 import com.google.testing.compile.JavaFileObjects;
 import dagger.internal.codegen.ValidationReport.Builder;
@@ -27,10 +32,6 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import static com.google.common.truth.Truth.assertAbout;
-import static com.google.common.truth.Truth.assertThat;
-import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
-
 @RunWith(JUnit4.class)
 public class ValidationReportTest {
   private static final JavaFileObject TEST_CLASS_FILE =
diff --git a/compiler/src/test/java/dagger/tests/integration/operation/PrimitiveInjectionTest.java b/compiler/src/test/java/dagger/tests/integration/operation/PrimitiveInjectionTest.java
index ae438514a..67beb03dd 100644
--- a/compiler/src/test/java/dagger/tests/integration/operation/PrimitiveInjectionTest.java
+++ b/compiler/src/test/java/dagger/tests/integration/operation/PrimitiveInjectionTest.java
@@ -1,6 +1,5 @@
 /**
- * Copyright (C) 2013 Google, Inc.
- * Copyright (C) 2013 Square, Inc.
+ * Copyright (C) 2013 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,8 +13,14 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.tests.integration.operation;
 
+import static com.google.common.truth.Truth.assertAbout;
+import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
+import static java.util.Arrays.asList;
+
 import com.google.testing.compile.JavaFileObjects;
 import dagger.internal.codegen.ComponentProcessor;
 import javax.tools.JavaFileObject;
@@ -23,11 +28,6 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import static com.google.common.truth.Truth.assert_;
-import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
-import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
-import static java.util.Arrays.asList;
-
 @RunWith(JUnit4.class)
 public final class PrimitiveInjectionTest {
 
@@ -49,14 +49,16 @@
       "  @Inject PrimitiveInjectable(int ignored) {}",
       "}");
 
-  JavaFileObject primitiveModule = JavaFileObjects.forSourceLines("test.PrimitiveModule",
-      "package test;",
-      "import dagger.Module;",
-      "import dagger.Provides;",
-      "@Module",
-      "class PrimitiveModule {",
-      "  @Provides int primitiveInt() { return Integer.MAX_VALUE; }",
-      "}");
+  JavaFileObject primitiveModule =
+      JavaFileObjects.forSourceLines(
+          "test.PrimitiveModule",
+          "package test;",
+          "import dagger.Module;",
+          "import dagger.Provides;",
+          "@Module",
+          "class PrimitiveModule {",
+          "  @Provides static int primitiveInt() { return Integer.MAX_VALUE; }",
+          "}");
 
   JavaFileObject component = JavaFileObjects.forSourceLines("test.PrimitiveComponent",
       "package test;",
@@ -68,75 +70,70 @@
       "  PrimitiveInjectable primitiveInjectable();",
       "}");
 
-  JavaFileObject expectedComponent = JavaFileObjects.forSourceLines(
-      "test.DaggerPrimitiveComponent",
-      "package test;",
-      "",
-      "import dagger.internal.Preconditions;",
-      "import javax.annotation.Generated;",
-      "import javax.inject.Provider;",
-      "",
-      GENERATED_ANNOTATION,
-      "public final class DaggerPrimitiveComponent implements PrimitiveComponent {",
-      "  private Provider<Integer> primitiveIntProvider;",
-      "  private Provider<PrimitiveInjectable> primitiveInjectableProvider;",
-      "",
-      "  private DaggerPrimitiveComponent(Builder builder) {",
-      "    assert builder != null;",
-      "    initialize(builder);",
-      "  }",
-      "",
-      "  public static Builder builder() {",
-      "    return new Builder();",
-      "  }",
-      "",
-      "  public static PrimitiveComponent create() {",
-      "    return builder().build();",
-      "  }",
-      "",
-      "  @SuppressWarnings(\"unchecked\")",
-      "  private void initialize(final Builder builder) {",
-      "    this.primitiveIntProvider =",
-      "        PrimitiveModule_PrimitiveIntFactory.create(builder.primitiveModule);",
-      "    this.primitiveInjectableProvider =",
-      "        PrimitiveInjectable_Factory.create(primitiveIntProvider);",
-      "  }",
-      "",
-      "  @Override",
-      "  public int primitiveInt() {",
-      "    return primitiveIntProvider.get();",
-      "  }",
-      "",
-      "  @Override",
-      "  public PrimitiveInjectable primitiveInjectable() {",
-      "    return primitiveInjectableProvider.get();",
-      "  }",
-      "",
-      "  public static final class Builder {",
-      "    private PrimitiveModule primitiveModule;",
-      "",
-      "    private Builder() {",
-      "    }",
-      "",
-      "    public PrimitiveComponent build() {",
-      "      if (primitiveModule == null) {",
-      "        this.primitiveModule = new PrimitiveModule();",
-      "      }",
-      "      return new DaggerPrimitiveComponent(this);",
-      "    }",
-      "",
-      "    public Builder primitiveModule(PrimitiveModule primitiveModule) {",
-      "      this.primitiveModule = Preconditions.checkNotNull(primitiveModule);",
-      "      return this;",
-      "    }",
-      "  }",
-      "}");
+  JavaFileObject expectedComponent =
+      JavaFileObjects.forSourceLines(
+          "test.DaggerPrimitiveComponent",
+          "package test;",
+          "",
+          "import dagger.internal.Preconditions;",
+          "import javax.annotation.Generated;",
+          "import javax.inject.Provider;",
+          "",
+          GENERATED_ANNOTATION,
+          "public final class DaggerPrimitiveComponent implements PrimitiveComponent {",
+          "  private Provider<PrimitiveInjectable> primitiveInjectableProvider;",
+          "",
+          "  private DaggerPrimitiveComponent(Builder builder) {",
+          "    assert builder != null;",
+          "    initialize(builder);",
+          "  }",
+          "",
+          "  public static Builder builder() {",
+          "    return new Builder();",
+          "  }",
+          "",
+          "  public static PrimitiveComponent create() {",
+          "    return new Builder().build();",
+          "  }",
+          "",
+          "  @SuppressWarnings(\"unchecked\")",
+          "  private void initialize(final Builder builder) {",
+          "    this.primitiveInjectableProvider = PrimitiveInjectable_Factory.create(",
+          "        PrimitiveModule_PrimitiveIntFactory.create());",
+          "  }",
+          "",
+          "  @Override",
+          "  public int primitiveInt() {",
+          "    return PrimitiveModule.primitiveInt();",
+          "  }",
+          "",
+          "  @Override",
+          "  public PrimitiveInjectable primitiveInjectable() {",
+          "    return new PrimitiveInjectable(PrimitiveModule.primitiveInt());",
+          "  }",
+          "",
+          "  public static final class Builder {",
+          "",
+          "    private Builder() {}",
+          "",
+          "    public PrimitiveComponent build() {",
+          "      return new DaggerPrimitiveComponent(this);",
+          "    }",
+          "",
+          "    @Deprecated",
+          "    public Builder primitiveModule(PrimitiveModule primitiveModule) {",
+          "      Preconditions.checkNotNull(primitiveModule);",
+          "      return this;",
+          "    }",
+          "  }",
+          "}");
 
   @Test public void primitiveArrayTypesAllInjected() {
-    assert_().about(javaSources())
+    assertAbout(javaSources())
         .that(asList(component, primitiveInjectable, primitiveModule))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
-        .and().generatesSources(expectedComponent);
+        .and()
+        .generatesSources(expectedComponent);
   }
 }
diff --git a/core/BUILD b/core/BUILD
new file mode 100644
index 000000000..bd2407ecd
--- /dev/null
+++ b/core/BUILD
@@ -0,0 +1,44 @@
+# Copyright (C) 2017 The Dagger Authors.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+# Description:
+#   A JSR-330 compliant dependency injection system for android and java
+
+package(default_visibility = ["//:src"])
+
+load("//:build_defs.bzl", "DOCLINT_HTML_AND_SYNTAX", "DOCLINT_REFERENCES")
+load("//:test_defs.bzl", "GenJavaTests")
+
+java_library(
+    name = "core",
+    plugins = [
+        # TODO(cgruber): Enable Beta checker.
+    ],
+    exports = ["//core/src/main/java/dagger:core"],
+)
+
+GenJavaTests(
+    name = "core_tests",
+    srcs = glob(["src/test/java/**/*.java"]),
+    javacopts = DOCLINT_HTML_AND_SYNTAX + DOCLINT_REFERENCES,
+    deps = [
+        ":core",
+        "//third_party:guava",
+        "//third_party:jsr330_inject",
+        "//third_party:junit",
+        "//third_party:truth",
+    ],
+)
+
+test_suite(name = "AllTests")
diff --git a/core/pom.xml b/core/pom.xml
index 76559449a..4641a5f5c 100644
--- a/core/pom.xml
+++ b/core/pom.xml
@@ -1,6 +1,6 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <!--
- Copyright (C) 2012 Square, Inc.
+ Copyright (C) 2012 The Dagger Authors.
 
   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
@@ -20,17 +20,12 @@
   <parent>
     <groupId>com.google.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>2.5-SNAPSHOT</version>
+    <version>HEAD-SNAPSHOT</version>
   </parent>
 
   <artifactId>dagger</artifactId>
   <name>Dagger</name>
 
-  <properties>
-    <!-- Runtime must remain Java6 to support android. -->
-    <java.version>1.6</java.version>
-  </properties>
-
   <dependencies>
     <dependency>
       <groupId>javax.inject</groupId>
@@ -56,6 +51,36 @@
 
   <build>
     <plugins>
+      <plugin>
+        <artifactId>maven-compiler-plugin</artifactId>
+        <configuration>
+          <compilerArgument>-Xlint:all</compilerArgument>
+          <showWarnings>true</showWarnings>
+          <showDeprecation>true</showDeprecation>
+        </configuration>
+        <executions>
+          <execution>
+            <id>default-compile</id>
+            <goals>
+              <goal>compile</goal>
+            </goals>
+            <configuration>
+              <source>1.7</source>
+              <target>1.7</target>
+            </configuration>
+          </execution>
+          <execution>
+            <id>default-testCompile</id>
+            <goals>
+              <goal>testCompile</goal>
+            </goals>
+            <configuration>
+              <source>1.8</source>
+              <target>1.8</target>
+            </configuration>
+          </execution>
+        </executions>
+      </plugin>
       <plugin>
         <groupId>org.codehaus.mojo</groupId>
         <artifactId>animal-sniffer-maven-plugin</artifactId>
diff --git a/core/src/main/java/dagger/BUILD b/core/src/main/java/dagger/BUILD
new file mode 100644
index 000000000..d5dc94fac
--- /dev/null
+++ b/core/src/main/java/dagger/BUILD
@@ -0,0 +1,48 @@
+# Copyright (C) 2017 The Dagger Authors.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+# Description:
+#   A JSR-330 compliant dependency injection system for android and java
+
+package(default_visibility = ["//:src"])
+
+load(
+    "//:build_defs.bzl",
+    "DOCLINT_HTML_AND_SYNTAX",
+    "PRE_JAVA_8_INFERENCE_OPTS",
+    "SOURCE_7_TARGET_7",
+)
+
+java_library(
+    name = "core",
+    srcs = glob(["**/*.java"]),
+    javacopts = PRE_JAVA_8_INFERENCE_OPTS + SOURCE_7_TARGET_7 + DOCLINT_HTML_AND_SYNTAX,
+    exports = ["//third_party:jsr330_inject"],
+    deps = ["//third_party:jsr330_inject"],
+)
+
+filegroup(
+    name = "javadoc-srcs",
+    srcs = glob(["**/*"]),
+)
+
+load("//tools:javadoc.bzl", "javadoc_library")
+
+javadoc_library(
+    name = "core-javadoc",
+    srcs = [":javadoc-srcs"],
+    exclude_packages = ["dagger.internal"],
+    root_packages = ["dagger"],
+    deps = ["//third_party:jsr330_inject"],
+)
diff --git a/core/src/main/java/dagger/Binds.java b/core/src/main/java/dagger/Binds.java
index 4bdb3e2ba..848619fb7 100644
--- a/core/src/main/java/dagger/Binds.java
+++ b/core/src/main/java/dagger/Binds.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 Google, Inc.
+ * Copyright (C) 2016 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,31 +13,52 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger;
 
+import static java.lang.annotation.ElementType.METHOD;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 
-import static java.lang.annotation.ElementType.METHOD;
-import static java.lang.annotation.RetentionPolicy.RUNTIME;
-
 /**
  * Annotates <em>abstract</em> methods of a {@link Module} that delegate bindings. For example, to
  * bind {@link java.util.Random} to {@link java.security.SecureRandom} a module could declare the
  * following: {@code @Binds abstract Random bindRandom(SecureRandom secureRandom);}
  *
  * <p>{@code @Binds} methods are a drop-in replacement for {@link Provides} methods that simply
- * return an injected parameter.  Prefer {@code @Binds} because the generated implementation is
+ * return an injected parameter. Prefer {@code @Binds} because the generated implementation is
  * likely to be more efficient.
  *
  * <p>A {@code @Binds} method:
+ *
  * <ul>
- * <li>Must be {@code abstract}.
- * <li>Must have a single parameter whose type is assignable to the return type.  The return type is
- * the bound type and the parameter is the type to which it is bound.
- * <li>May be {@linkplain javax.inject.Scope scoped}.
- * <li>May be {@linkplain javax.inject.Qualifier qualified}.
+ *   <li>Must be {@code abstract}.
+ *   <li>May be {@linkplain javax.inject.Scope scoped}.
+ *   <li>May be {@linkplain javax.inject.Qualifier qualified}.
+ *   <li>Must have a single parameter whose type is assignable to the return type. The return type
+ *       declares the bound type (just as it would for a {@literal @}{@link dagger.Provides} method)
+ *       and the parameter is the type to which it is bound.
+ *       <p>For {@linkplain dagger.multibindings multibindings}, assignability is checked in similar
+ *       ways:
+ *       <dl>
+ *         <dt>{@link dagger.multibindings.IntoSet}
+ *         <dd>The parameter must be assignable to the only parameter of {@link java.util.Set#add}
+ *             when viewed as a member of the return type — the parameter must be assignable to the
+ *             return type.
+ *         <dt>{@link dagger.multibindings.ElementsIntoSet}
+ *         <dd>The parameter must be assignable to the the only parameter of {@link
+ *             java.util.Set#addAll} when viewed as a member of the return type — if the return type
+ *             is {@code Set<E>}, the parameter must be assignable to
+ *            {@code Collection<? extends E>}.
+ *         <dt>{@link dagger.multibindings.IntoMap}
+ *         <dd>The parameter must be assignable to the {@code value} parameter of {@link
+ *             java.util.Map#put} when viewed as a member of a {@link java.util.Map} in which {@code
+ *             V} is bound to the return type — the parameter must be assignable to the return type
+ *       </dl>
+ *
  * </ul>
  */
 @Documented
diff --git a/core/src/main/java/dagger/BindsInstance.java b/core/src/main/java/dagger/BindsInstance.java
new file mode 100644
index 000000000..cd87db8a8
--- /dev/null
+++ b/core/src/main/java/dagger/BindsInstance.java
@@ -0,0 +1,62 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger;
+
+import static java.lang.annotation.ElementType.METHOD;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+import dagger.internal.Beta;
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+
+/**
+ * Marks a method on a component builder or subcomponent builder that allows an instance to be bound
+ * to some type within the component.
+ *
+ * <p>For example:
+ *
+ * <pre>
+ *   {@literal @Component.Builder}
+ *   interface Builder {
+ *     {@literal @BindsInstance} Builder foo(Foo foo);
+ *     {@literal @BindsInstance} Builder bar({@literal @Blue} Bar bar);
+ *     ...
+ *   }
+ * </pre>
+ *
+ * <p>will allow clients of this builder to pass their own instances of {@code Foo} and {@code Bar},
+ * and those instances can be injected within the component as {@code Foo} or {@code @Blue Bar},
+ * respectively.
+ *
+ * <p>{@code @BindsInstance} methods may not be passed null arguments unless the parameter is
+ * annotated with {@code @Nullable}; in that case, both null and non-null arguments may be passed to
+ * the method.
+ *
+ * <p>{@code @BindsInstance} methods must be called before building the component, unless their
+ * parameter is marked {@code @Nullable}, in which case the component will act as though it was
+ * called with a null argument. Primitives, of course, may not be marked {@code @Nullable}.
+ *
+ * <p>Binding an instance is equivalent to passing an instance to a module constructor and providing
+ * that instance, but is often more efficient. When possible, binding object instances should be
+ * preferred to using module instances.
+ */
+@Documented
+@Retention(RUNTIME)
+@Target(METHOD)
+@Beta
+public @interface BindsInstance {}
diff --git a/core/src/main/java/dagger/BindsOptionalOf.java b/core/src/main/java/dagger/BindsOptionalOf.java
new file mode 100644
index 000000000..887d9ae8f
--- /dev/null
+++ b/core/src/main/java/dagger/BindsOptionalOf.java
@@ -0,0 +1,78 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger;
+
+import static java.lang.annotation.ElementType.METHOD;
+
+import dagger.internal.Beta;
+import java.lang.annotation.Documented;
+import java.lang.annotation.Target;
+import javax.inject.Inject;
+import javax.inject.Qualifier;
+
+/**
+ * Annotates methods that declare bindings for {@code Optional} containers of values from bindings
+ * that may or may not be present in the component.
+ *
+ * <p>If a module contains a method declaration like this:
+ *
+ * <pre>
+ * {@literal @BindsOptionalOf} abstract Foo optionalFoo();</pre>
+ *
+ * then any binding in the component can depend on an {@code Optional} of {@code Foo}. If there is
+ * no binding for {@code Foo} in the component, the {@code Optional} will be absent. If there is a
+ * binding for {@code Foo} in the component, the {@code Optional} will be present, and its value
+ * will be the value given by the binding for {@code Foo}.
+ *
+ * <p>A {@code @BindsOptionalOf} method:
+ *
+ * <ul>
+ * <li>must be {@code abstract}
+ * <li>may have a {@linkplain Qualifier qualifier} annotation
+ * <li>must not return {@code void}
+ * <li>must not have parameters
+ * <li>must not throw exceptions
+ * <li>must not return an unqualified type with an {@link Inject @Inject}-annotated constructor,
+ *     since such a type is always present
+ * </ul>
+ *
+ * <p>Other bindings may inject any of:
+ *
+ * <ul>
+ * <li>{@code Optional<Foo>}
+ * <li>{@code Optional<Provider<Foo>>}
+ * <li>{@code Optional<Lazy<Foo>>}
+ * <li>{@code Optional<Provider<Lazy<Foo>>>}
+ * </ul>
+ *
+ * <p>Explicit bindings for any of the above will conflict with a {@code @BindsOptionalOf} binding.
+ *
+ * <p>If the binding for {@code Foo} is a {@code @Produces} binding, then another {@code @Produces}
+ * binding can depend on any of:
+ *
+ * <ul>
+ * <li>{@code Optional<Foo>}
+ * <li>{@code Optional<Producer<Foo>>}
+ * <li>{@code Optional<Produced<Foo>>}
+ * </ul>
+ *
+ * <p>You can inject either {@code com.google.common.base.Optional} or {@code java.util.Optional}.
+ */
+@Documented
+@Beta
+@Target(METHOD)
+public @interface BindsOptionalOf {}
diff --git a/core/src/main/java/dagger/Component.java b/core/src/main/java/dagger/Component.java
index 452edb8a4..25abeda8d 100644
--- a/core/src/main/java/dagger/Component.java
+++ b/core/src/main/java/dagger/Component.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Google, Inc.
+ * Copyright (C) 2014 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,8 +13,12 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger;
 
+import static java.lang.annotation.ElementType.TYPE;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
@@ -24,9 +28,6 @@
 import javax.inject.Scope;
 import javax.inject.Singleton;
 
-import static java.lang.annotation.ElementType.TYPE;
-import static java.lang.annotation.RetentionPolicy.RUNTIME;
-
 /**
  * Annotates an interface or abstract class for which a fully-formed, dependency-injected
  * implementation is to be generated from a set of {@linkplain #modules}. The generated class will
@@ -170,9 +171,13 @@
  * inherit the <em>entire</em> binding graph from its parent when it is declared. For that reason,
  * a subcomponent isn't evaluated for completeness until it is associated with a parent.
  *
- * <p>Subcomponents are declared via a factory method on a parent component or subcomponent. The
- * method may have any name, but must return the subcomponent. The factory method's parameters may
- * be any number of the subcomponent's modules, but must at least include those without visible
+ * <p>Subcomponents are declared by listing the class in the {@link Module#subcomponents()}
+ * attribute of one of the parent component's modules. This binds the {@link Subcomponent.Builder}
+ * within the parent component.
+ *
+ * <p>Subcomponents may also be declared via a factory method on a parent component or subcomponent.
+ * The method may have any name, but must return the subcomponent. The factory method's parameters
+ * may be any number of the subcomponent's modules, but must at least include those without visible
  * no-arg constructors. The following is an example of a factory method that creates a
  * request-scoped subcomponent from a singleton-scoped parent: <pre><code>
  *   {@literal @}Singleton {@literal @}Component
diff --git a/core/src/main/java/dagger/Lazy.java b/core/src/main/java/dagger/Lazy.java
index 075c5f405..a5ad92e98 100644
--- a/core/src/main/java/dagger/Lazy.java
+++ b/core/src/main/java/dagger/Lazy.java
@@ -1,6 +1,5 @@
 /*
- * Copyright (C) 2012 Google, Inc.
- * Copyright (C) 2012 Square, Inc.
+ * Copyright (C) 2012 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger;
 
 /**
diff --git a/core/src/main/java/dagger/MapKey.java b/core/src/main/java/dagger/MapKey.java
index e41829e1e..7440ea30c 100644
--- a/core/src/main/java/dagger/MapKey.java
+++ b/core/src/main/java/dagger/MapKey.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Google, Inc.
+ * Copyright (C) 2014 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,17 +13,18 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger;
 
+import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
 import dagger.internal.Beta;
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 import java.util.Map;
 
-import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
-import static java.lang.annotation.RetentionPolicy.RUNTIME;
-
 /**
  * Identifies annotation types that are used to associate keys with values returned by
  * {@linkplain Provides provider methods} in order to compose a {@linkplain
diff --git a/core/src/main/java/dagger/MembersInjector.java b/core/src/main/java/dagger/MembersInjector.java
index d0de7f396..510f476a9 100644
--- a/core/src/main/java/dagger/MembersInjector.java
+++ b/core/src/main/java/dagger/MembersInjector.java
@@ -1,6 +1,5 @@
 /*
- * Copyright (C) 2012 Square, Inc.
- * Copyright (C) 2009 Google Inc.
+ * Copyright (C) 2012 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger;
 
 /**
diff --git a/core/src/main/java/dagger/Module.java b/core/src/main/java/dagger/Module.java
index 05f0f3a6a..862be7aed 100644
--- a/core/src/main/java/dagger/Module.java
+++ b/core/src/main/java/dagger/Module.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 Square, Inc.
+ * Copyright (C) 2012 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,8 +13,10 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger;
 
+import dagger.internal.Beta;
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
@@ -33,4 +35,14 @@
    * to the object graph.
    */
   Class<?>[] includes() default {};
+
+  /**
+   * Any {@link Subcomponent}- or {@code @ProductionSubcomponent}-annotated classes which should be
+   * children of the component in which this module is installed. A subcomponent may be listed in
+   * more than one module in a component.
+   *
+   * @since 2.7
+   */
+  @Beta
+  Class<?>[] subcomponents() default {};
 }
diff --git a/core/src/main/java/dagger/Multibindings.java b/core/src/main/java/dagger/Multibindings.java
index b83324df5..c544e092f 100644
--- a/core/src/main/java/dagger/Multibindings.java
+++ b/core/src/main/java/dagger/Multibindings.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,14 +13,15 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger;
 
+import static java.lang.annotation.ElementType.TYPE;
+
 import dagger.internal.Beta;
 import java.lang.annotation.Documented;
 import java.lang.annotation.Target;
 
-import static java.lang.annotation.ElementType.TYPE;
-
 /**
  * Annotates interfaces that declare multibindings.
  *
diff --git a/core/src/main/java/dagger/Provides.java b/core/src/main/java/dagger/Provides.java
index 7be82c012..de204557b 100644
--- a/core/src/main/java/dagger/Provides.java
+++ b/core/src/main/java/dagger/Provides.java
@@ -1,6 +1,5 @@
 /*
- * Copyright (C) 2007 Google Inc.
- * Copyright (C) 2012 Square, Inc.
+ * Copyright (C) 2007 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,16 +13,16 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger;
 
-import dagger.internal.Beta;
+import static java.lang.annotation.ElementType.METHOD;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 
-import static java.lang.annotation.ElementType.METHOD;
-import static java.lang.annotation.RetentionPolicy.RUNTIME;
-
 /**
  * Annotates methods of a {@linkplain Module module} to create a provider method binding. The
  * method's return type is bound to its returned value. The {@linkplain Component component}
@@ -46,47 +45,4 @@
  */
 @Documented @Target(METHOD) @Retention(RUNTIME)
 public @interface Provides {
-  /** The type of binding into which the return type of the annotated method contributes. */
-  enum Type {
-    /**
-     * The method is the only one which can produce the value for the specified return type. This
-     * is the default behavior.
-     */
-    UNIQUE,
-
-    /**
-     * The method's return type forms the generic type argument of a {@code Set<T>}, and the
-     * returned value is contributed to the set. The object graph will pass dependencies to the
-     * method as parameters. The {@code Set<T>} produced from the accumulation of values will be
-     * immutable.
-     *
-     * @see <a href="http://google.github.io/dagger/multibindings#set-multibindings">Set
-     *      multibinding</a>
-     */
-    SET,
-
-    /**
-     * Like {@link #SET}, except the method's return type is {@code Set<T>}, where any values are
-     * contributed to the set. An example use is to provide a default empty set binding, which is
-     * otherwise not possible using {@link #SET}.
-     *
-     * @see <a href="http://google.github.io/dagger/multibindings#set-multibindings">Set
-     *      multibinding</a>
-     */
-    SET_VALUES,
-
-    /**
-     * The method's return type forms the type argument for the value of a
-     * {@code Map<K, Provider<V>>}, and the combination of the annotated key and the returned value
-     * is contributed to the map as a key/value pair. The {@code Map<K, Provider<V>>} produced from
-     * the accumulation of values will be immutable.
-     *
-     * @see <a href="http://google.github.io/dagger/multibindings#map-multibindings">Map
-     *      multibinding</a>
-     */
-    @Beta
-    MAP;
-  }
-
-  Type type() default Type.UNIQUE;
 }
diff --git a/core/src/main/java/dagger/Reusable.java b/core/src/main/java/dagger/Reusable.java
index b7b61d8d1..34610e5a4 100644
--- a/core/src/main/java/dagger/Reusable.java
+++ b/core/src/main/java/dagger/Reusable.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 Google, Inc.
+ * Copyright (C) 2016 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,15 +13,16 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger;
 
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
 import dagger.internal.Beta;
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import javax.inject.Scope;
 
-import static java.lang.annotation.RetentionPolicy.RUNTIME;
-
 /**
  * A scope that indicates that the object returned by a binding may be (but might not be) reused.
  *
diff --git a/core/src/main/java/dagger/Subcomponent.java b/core/src/main/java/dagger/Subcomponent.java
index 988f17b49..262327e5d 100644
--- a/core/src/main/java/dagger/Subcomponent.java
+++ b/core/src/main/java/dagger/Subcomponent.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,15 +13,16 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger;
 
+import static java.lang.annotation.ElementType.TYPE;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 
-import static java.lang.annotation.ElementType.TYPE;
-import static java.lang.annotation.RetentionPolicy.RUNTIME;
-
 /**
  * A subcomponent that inherits the bindings from a parent {@link Component} or
  * {@link Subcomponent}. The details of how to associate a subcomponent with a parent are described
diff --git a/core/src/main/java/dagger/internal/Beta.java b/core/src/main/java/dagger/internal/Beta.java
index a0a82c659..2e97f058e 100644
--- a/core/src/main/java/dagger/internal/Beta.java
+++ b/core/src/main/java/dagger/internal/Beta.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,13 +13,14 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal;
 
+import static java.lang.annotation.RetentionPolicy.SOURCE;
+
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 
-import static java.lang.annotation.RetentionPolicy.SOURCE;
-
 /**
  * Signifies that a public API (public class, method or field) is subject to
  * incompatible changes, or even removal, in a future release. An API bearing
diff --git a/core/src/main/java/dagger/internal/DaggerCollections.java b/core/src/main/java/dagger/internal/DaggerCollections.java
index e317c28b7..3d47a8497 100644
--- a/core/src/main/java/dagger/internal/DaggerCollections.java
+++ b/core/src/main/java/dagger/internal/DaggerCollections.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Google, Inc.
+ * Copyright (C) 2014 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal;
 
 import java.util.ArrayList;
diff --git a/core/src/main/java/dagger/internal/DelegateFactory.java b/core/src/main/java/dagger/internal/DelegateFactory.java
index d1e864d17..4ec047ca8 100644
--- a/core/src/main/java/dagger/internal/DelegateFactory.java
+++ b/core/src/main/java/dagger/internal/DelegateFactory.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Google, Inc.
+ * Copyright (C) 2014 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal;
 
 import javax.inject.Provider;
diff --git a/core/src/main/java/dagger/internal/DoubleCheck.java b/core/src/main/java/dagger/internal/DoubleCheck.java
index ef1708fa9..e4a074b40 100644
--- a/core/src/main/java/dagger/internal/DoubleCheck.java
+++ b/core/src/main/java/dagger/internal/DoubleCheck.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 Google, Inc.
+ * Copyright (C) 2016 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,13 +13,14 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal;
 
+import static dagger.internal.Preconditions.checkNotNull;
+
 import dagger.Lazy;
 import javax.inject.Provider;
 
-import static dagger.internal.Preconditions.checkNotNull;
-
 /**
  * A {@link Lazy} and {@link Provider} implementation that memoizes the value returned from a
  * delegate using the double-check idiom described in Item 71 of <i>Effective Java 2</i>.
@@ -50,7 +51,8 @@ public T get() {
           Object currentInstance = instance;
           if (currentInstance != UNINITIALIZED && currentInstance != result) {
             throw new IllegalStateException("Scoped provider was invoked recursively returning "
-                + "different results: " + currentInstance + " & " + result);
+                + "different results: " + currentInstance + " & " + result + ". This is likely "
+                + "due to a circular dependency.");
           }
           instance = result;
           /* Null out the reference to the provider. We are never going to need it again, so we
diff --git a/core/src/main/java/dagger/internal/Factory.java b/core/src/main/java/dagger/internal/Factory.java
index 8451989ba..4fa0399fa 100644
--- a/core/src/main/java/dagger/internal/Factory.java
+++ b/core/src/main/java/dagger/internal/Factory.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Google, Inc.
+ * Copyright (C) 2014 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal;
 
 import dagger.Provides;
diff --git a/core/src/main/java/dagger/internal/GwtIncompatible.java b/core/src/main/java/dagger/internal/GwtIncompatible.java
new file mode 100644
index 000000000..f6100a2d0
--- /dev/null
+++ b/core/src/main/java/dagger/internal/GwtIncompatible.java
@@ -0,0 +1,20 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal;
+
+/** Marks an element incompatible with GWT. */
+public @interface GwtIncompatible {}
diff --git a/core/src/main/java/dagger/internal/InstanceFactory.java b/core/src/main/java/dagger/internal/InstanceFactory.java
index ca57f71bd..c3d1f5675 100644
--- a/core/src/main/java/dagger/internal/InstanceFactory.java
+++ b/core/src/main/java/dagger/internal/InstanceFactory.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Google, Inc.
+ * Copyright (C) 2014 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,28 +13,44 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal;
 
+import static dagger.internal.Preconditions.checkNotNull;
+
+import dagger.Lazy;
+
 /**
- * A {@link Factory} implementation that returns a single instance for all invocations of
- * {@link #get}.
+ * A {@link Factory} implementation that returns a single instance for all invocations of {@link
+ * #get}.
  *
  * <p>Note that while this is a {@link Factory} implementation, and thus unscoped, each call to
- * {@link #get} will always return the same instance.  As such, any scoping applied to this factory
- * is redundant and unnecessary.  However, using this with {@link DoubleCheck#provider} is valid and
+ * {@link #get} will always return the same instance. As such, any scoping applied to this factory
+ * is redundant and unnecessary. However, using this with {@link DoubleCheck#provider} is valid and
  * may be desired for testing or contractual guarantees.
  *
  * @author Gregory Kick
  * @since 2.0
  */
-public final class InstanceFactory<T> implements Factory<T> {
+public final class InstanceFactory<T> implements Factory<T>, Lazy<T> {
   public static <T> Factory<T> create(T instance) {
-    if (instance == null) {
-      throw new NullPointerException();
-    }
-    return new InstanceFactory<T>(instance);
+    return new InstanceFactory<T>(checkNotNull(instance, "instance cannot be null"));
+  }
+
+  public static <T> Factory<T> createNullable(T instance) {
+    return instance == null
+        ? InstanceFactory.<T>nullInstanceFactory()
+        : new InstanceFactory<T>(instance);
+  }
+
+  @SuppressWarnings("unchecked") // bivariant implementation
+  private static <T> InstanceFactory<T> nullInstanceFactory() {
+    return (InstanceFactory<T>) NULL_INSTANCE_FACTORY;
   }
 
+  private static final InstanceFactory<Object> NULL_INSTANCE_FACTORY =
+      new InstanceFactory<Object>(null);
+
   private final T instance;
 
   private InstanceFactory(T instance) {
diff --git a/core/src/main/java/dagger/internal/MapFactory.java b/core/src/main/java/dagger/internal/MapFactory.java
index b0364ba01..d4b918924 100644
--- a/core/src/main/java/dagger/internal/MapFactory.java
+++ b/core/src/main/java/dagger/internal/MapFactory.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Google, Inc.
+ * Copyright (C) 2014 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,15 +13,16 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal;
 
+import static dagger.internal.DaggerCollections.newLinkedHashMapWithExpectedSize;
+import static java.util.Collections.unmodifiableMap;
+
 import java.util.Map;
 import java.util.Map.Entry;
 import javax.inject.Provider;
 
-import static dagger.internal.DaggerCollections.newLinkedHashMapWithExpectedSize;
-import static java.util.Collections.unmodifiableMap;
-
 /**
  * A {@link Factory} implementation used to implement {@link Map} bindings. This factory returns a
  * {@code Map<K, V>} when calling {@link #get} (as specified by {@link Factory}).
diff --git a/core/src/main/java/dagger/internal/MapProviderFactory.java b/core/src/main/java/dagger/internal/MapProviderFactory.java
index 141a77bf0..c27beb222 100644
--- a/core/src/main/java/dagger/internal/MapProviderFactory.java
+++ b/core/src/main/java/dagger/internal/MapProviderFactory.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Google, Inc.
+ * Copyright (C) 2014 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,25 +13,27 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal;
 
+import static dagger.internal.DaggerCollections.newLinkedHashMapWithExpectedSize;
+import static java.util.Collections.unmodifiableMap;
+
+import dagger.Lazy;
 import java.util.Collections;
 import java.util.LinkedHashMap;
 import java.util.Map;
 import javax.inject.Provider;
 
-import static dagger.internal.DaggerCollections.newLinkedHashMapWithExpectedSize;
-import static java.util.Collections.unmodifiableMap;
-
 /**
  * A {@link Factory} implementation used to implement {@link Map} bindings. This factory returns a
  * {@code Map<K, Provider<V>>} when calling {@link #get} (as specified by {@link Factory}).
  *
  * @author Chenying Hou
  * @since 2.0
- *
  */
-public final class MapProviderFactory<K, V> implements Factory<Map<K, Provider<V>>> {
+public final class MapProviderFactory<K, V>
+    implements Factory<Map<K, Provider<V>>>, Lazy<Map<K, Provider<V>>> {
   private static final MapProviderFactory<Object, Object> EMPTY =
       new MapProviderFactory<Object, Object>(Collections.<Object, Provider<Object>>emptyMap());
 
diff --git a/core/src/main/java/dagger/internal/MembersInjectors.java b/core/src/main/java/dagger/internal/MembersInjectors.java
index 5be2b8ee2..44d37af12 100644
--- a/core/src/main/java/dagger/internal/MembersInjectors.java
+++ b/core/src/main/java/dagger/internal/MembersInjectors.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Google Inc.
+ * Copyright (C) 2014 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,13 +13,14 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal;
 
+import static dagger.internal.Preconditions.checkNotNull;
+
 import dagger.MembersInjector;
 import javax.inject.Inject;
 
-import static dagger.internal.Preconditions.checkNotNull;
-
 /**
  * Basic {@link MembersInjector} implementations used by the framework.
  *
diff --git a/core/src/main/java/dagger/internal/Preconditions.java b/core/src/main/java/dagger/internal/Preconditions.java
index 1877cd0eb..99e180530 100644
--- a/core/src/main/java/dagger/internal/Preconditions.java
+++ b/core/src/main/java/dagger/internal/Preconditions.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 Google, Inc.
+ * Copyright (C) 2016 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal;
 
 /**
@@ -49,6 +50,36 @@
     return reference;
   }
 
+  /**
+   * Ensures that an object reference passed as a parameter to the calling method is not null.
+   *
+   * @param reference an object reference
+   * @param errorMessageTemplate a template for the exception message should the check fail. The
+   *     message is formed by replacing the single {@code %s} placeholder in the template with
+   *     {@code errorMessageArg}.
+   * @param errorMessageArg the argument to be substituted into the message template. Converted to a
+   *     string using {@link String#valueOf(Object)}.
+   * @return the non-null reference that was validated
+   * @throws NullPointerException if {@code reference} is null
+   * @throws IllegalArgumentException if {@code errorMessageTemplate} doesn't contain exactly one
+   *     "%s"
+   */
+  public static <T> T checkNotNull(
+      T reference, String errorMessageTemplate, Object errorMessageArg) {
+    if (reference == null) {
+      // Poor-persons version of String.format, which is not GWT-compatible
+      if (!errorMessageTemplate.contains("%s")) {
+        throw new IllegalArgumentException("errorMessageTemplate has no format specifiers");
+      }
+      if (errorMessageTemplate.indexOf("%s") != errorMessageTemplate.lastIndexOf("%s")) {
+        throw new IllegalArgumentException(
+            "errorMessageTemplate has more than one format specifier");
+      }
+      throw new NullPointerException(
+          errorMessageTemplate.replaceFirst("%s", String.valueOf(errorMessageArg)));
+    }
+    return reference;
+  }
+
   private Preconditions() {}
 }
-
diff --git a/core/src/main/java/dagger/internal/ProviderOfLazy.java b/core/src/main/java/dagger/internal/ProviderOfLazy.java
index 77d4961dd..23b6afd75 100644
--- a/core/src/main/java/dagger/internal/ProviderOfLazy.java
+++ b/core/src/main/java/dagger/internal/ProviderOfLazy.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 Google, Inc.
+ * Copyright (C) 2016 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,13 +13,14 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal;
 
+import static dagger.internal.Preconditions.checkNotNull;
+
 import dagger.Lazy;
 import javax.inject.Provider;
 
-import static dagger.internal.Preconditions.checkNotNull;
-
 /**
  * A {@link Provider} of {@link Lazy} instances that each delegate to a given {@link Provider}.
  */
diff --git a/core/src/main/java/dagger/internal/ReferenceReleasingProvider.java b/core/src/main/java/dagger/internal/ReferenceReleasingProvider.java
new file mode 100644
index 000000000..56c9df14c
--- /dev/null
+++ b/core/src/main/java/dagger/internal/ReferenceReleasingProvider.java
@@ -0,0 +1,163 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal;
+
+import static dagger.internal.Preconditions.checkNotNull;
+
+import java.lang.ref.WeakReference;
+import javax.inject.Provider;
+
+/**
+ * A {@link Provider} implementation that can exchange its strong reference to the stored object for
+ * a {@link WeakReference}.
+ *
+ * <p>The provider can be in any one of four states at a time:
+ *
+ * <ul>
+ * <li>In <b>uninitialized</b> state, the provider's strong reference and its weak reference are
+ *     both {@code null}.
+ * <li>In <b>cleared</b> state, the strong reference is {@code null}, and the weak reference's value
+ *     is {@code null}.
+ * <li>In <b>strong-reference</b> state, the strong reference refers to the stored object, and the
+ *     weak reference is {@code null}.
+ * <li>In <b>weak-reference</b> state, the strong reference is {@code null}, and the weak
+ *     reference's value is not {@code null}.
+ * </ul>
+ *
+ * <p>The provider starts in <b>uninitialized</b> state.
+ *
+ * <p>{@link #get()} transitions to <b>strong-reference</b> state when in <b>uninitialized</b> or
+ * <b>cleared</b> state.
+ *
+ * <p>{@link #releaseStrongReference()} transitions to <b>weak-reference</b> state when in
+ * <b>strong-reference</b> state, unless the stored value is {@code null}.
+ *
+ * <p>{@link #restoreStrongReference()} transitions to <b>strong-reference</b> state when in
+ * <b>weak-reference</b> state.
+ *
+ * <p>If garbage collection clears the weak reference while in <b>weak-reference</b> state, the
+ * provider transitions to <b>cleared</b> state.
+ *
+ * <p><img src="doc-files/ReferenceReleasingProvider-statemachine.png">
+ *
+ * @see <a href="http://google.github.io/dagger/users-guide.html#releasable-references">Releasable
+ *     references</a>
+ */
+@GwtIncompatible
+public final class ReferenceReleasingProvider<T> implements Provider<T> {
+  private static final Object NULL = new Object(); // sentinel used when provider.get() returns null
+
+  private final Provider<T> provider;
+  private volatile Object strongReference;
+  private volatile WeakReference<T> weakReference;
+
+  private ReferenceReleasingProvider(Provider<T> provider) {
+    assert provider != null;
+    this.provider = provider;
+  }
+
+  /**
+   * Releases the strong reference to the object previously returned by {@link #get()}, and creates
+   * a {@link WeakReference} to that object, unless the stored value is {@code null}.
+   */
+  public void releaseStrongReference() {
+    Object value = strongReference;
+    if (value != null && value != NULL) {
+      synchronized (this) {
+        @SuppressWarnings("unchecked") // values other than NULL come from the provider
+        T storedValue = (T) value;
+        weakReference = new WeakReference<T>(storedValue);
+        strongReference = null;
+      }
+    }
+  }
+
+  /**
+   * Restores the strong reference that was previously {@linkplain #releaseStrongReference()
+   * released} if the {@link WeakReference} has not yet been cleared during garbage collection.
+   */
+  public void restoreStrongReference() {
+    Object value = strongReference;
+    if (weakReference != null && value == null) {
+      synchronized (this) {
+        value = strongReference;
+        if (weakReference != null && value == null) {
+          value = weakReference.get();
+          if (value != null) {
+            strongReference = value;
+            weakReference = null;
+          }
+        }
+      }
+    }
+  }
+
+  /**
+   * Returns the result of calling {@link Provider#get()} on the underlying {@link Provider}.
+   *
+   * <p>Calling {@code get()} in <b>uninitialized</b> or <b>cleared</b> state calls {@code get()}
+   * on the underlying provider, sets the strong reference to the returned value, and returns it,
+   * leaving the provider in <b>strong-reference</b> state.
+   *
+   * <p>Calling {@code get()} in <b>strong-reference</b> state simply returns the strong reference,
+   * leaving the provider in <b>strong-reference</b> state.
+   *
+   * <p>Calling {@code get()} in <b>weak-reference</b> state returns the {@link WeakReference}'s
+   * value, leaving the provider in <b>weak-reference</b> state.
+   */
+  @SuppressWarnings("unchecked") // cast only happens when result comes from the provider
+  @Override
+  public T get() {
+    Object value = currentValue();
+    if (value == null) {
+      synchronized (this) {
+        value = currentValue();
+        if (value == null) {
+          value = provider.get();
+          if (value == null) {
+            value = NULL;
+          }
+          strongReference = value;
+        }
+      }
+    }
+    return value == NULL ? null : (T) value;
+  }
+
+  private Object currentValue() {
+    Object value = strongReference;
+    if (value != null) {
+      return value;
+    }
+    if (weakReference != null) {
+      return weakReference.get();
+    }
+    return null;
+  }
+
+  /**
+   * Returns a {@link Provider} that stores the value from the given delegate provider and is
+   * managed by {@code references}.
+   */
+  public static <T> ReferenceReleasingProvider<T> create(
+      Provider<T> delegate, ReferenceReleasingProviderManager references) {
+    ReferenceReleasingProvider<T> provider =
+        new ReferenceReleasingProvider<T>(checkNotNull(delegate));
+    references.addProvider(provider);
+    return provider;
+  }
+}
diff --git a/core/src/main/java/dagger/internal/ReferenceReleasingProviderManager.java b/core/src/main/java/dagger/internal/ReferenceReleasingProviderManager.java
new file mode 100644
index 000000000..083de46b0
--- /dev/null
+++ b/core/src/main/java/dagger/internal/ReferenceReleasingProviderManager.java
@@ -0,0 +1,107 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal;
+
+import static dagger.internal.Preconditions.checkNotNull;
+
+import dagger.releasablereferences.ReleasableReferenceManager;
+import java.lang.annotation.Annotation;
+import java.lang.ref.WeakReference;
+import java.util.Iterator;
+import java.util.Queue;
+import java.util.concurrent.ConcurrentLinkedQueue;
+
+/**
+ * A {@link ReleasableReferenceManager} that forwards calls to a dynamic set of weakly-referenced
+ * {@link ReferenceReleasingProvider}s.
+ *
+ * @see <a href="http://google.github.io/dagger/users-guide.html#releasable-references">Releasable
+ *     references</a>
+ */
+@GwtIncompatible
+public final class ReferenceReleasingProviderManager implements ReleasableReferenceManager {
+
+  private final Class<? extends Annotation> scope;
+  private final Queue<WeakReference<ReferenceReleasingProvider<?>>> providers =
+      new ConcurrentLinkedQueue<WeakReference<ReferenceReleasingProvider<?>>>();
+
+  public ReferenceReleasingProviderManager(Class<? extends Annotation> scope) {
+    this.scope = checkNotNull(scope);
+  }
+
+  /**
+   * Adds a weak reference to {@code provider}.
+   */
+  public void addProvider(ReferenceReleasingProvider<?> provider) {
+    providers.add(new WeakReference<ReferenceReleasingProvider<?>>(provider));
+  }
+
+  @Override
+  public Class<? extends Annotation> scope() {
+    return scope;
+  }
+
+  /**
+   * {@inheritDoc} Calls {@link ReferenceReleasingProvider#releaseStrongReference()} on all
+   * providers that have been {@linkplain #addProvider(ReferenceReleasingProvider) added} and that
+   * are still weakly referenced.
+   */
+  @Override
+  public void releaseStrongReferences() {
+    execute(Operation.RELEASE);
+  }
+
+  /**
+   * {@inheritDoc} Calls {@link ReferenceReleasingProvider#restoreStrongReference()} on all
+   * providers that have been {@linkplain #addProvider(ReferenceReleasingProvider) added} and that
+   * are still weakly referenced.
+   */
+  @Override
+  public void restoreStrongReferences() {
+    execute(Operation.RESTORE);
+  }
+
+  private void execute(Operation operation) {
+    Iterator<WeakReference<ReferenceReleasingProvider<?>>> iterator = providers.iterator();
+    while (iterator.hasNext()) {
+      ReferenceReleasingProvider<?> provider = iterator.next().get();
+      if (provider == null) {
+        iterator.remove();
+      } else {
+        operation.execute(provider);
+      }
+    }
+  }
+
+  private enum Operation {
+    RELEASE {
+      @Override
+      void execute(ReferenceReleasingProvider<?> provider) {
+        provider.releaseStrongReference();
+      }
+    },
+    RESTORE {
+      @Override
+      void execute(ReferenceReleasingProvider<?> provider) {
+        provider.restoreStrongReference();
+      }
+    },
+    ;
+
+    abstract void execute(ReferenceReleasingProvider<?> provider);
+  }
+}
diff --git a/core/src/main/java/dagger/internal/SetFactory.java b/core/src/main/java/dagger/internal/SetFactory.java
index dd0d92711..b5a2ecd1e 100644
--- a/core/src/main/java/dagger/internal/SetFactory.java
+++ b/core/src/main/java/dagger/internal/SetFactory.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Google, Inc.
+ * Copyright (C) 2014 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,13 +13,8 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package dagger.internal;
 
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.List;
-import java.util.Set;
-import javax.inject.Provider;
+package dagger.internal;
 
 import static dagger.internal.DaggerCollections.hasDuplicates;
 import static dagger.internal.DaggerCollections.newHashSetWithExpectedSize;
@@ -28,6 +23,12 @@
 import static java.util.Collections.emptySet;
 import static java.util.Collections.unmodifiableSet;
 
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.List;
+import java.util.Set;
+import javax.inject.Provider;
+
 /**
  * A {@link Factory} implementation used to implement {@link Set} bindings. This factory always
  * returns a new {@link Set} instance for each call to {@link #get} (as required by {@link Factory})
@@ -37,13 +38,7 @@
  * @since 2.0
  */
 public final class SetFactory<T> implements Factory<Set<T>> {
-  private static final Factory<Set<Object>> EMPTY_FACTORY =
-      new Factory<Set<Object>>() {
-        @Override
-        public Set<Object> get() {
-          return emptySet();
-        }
-      };
+  private static final Factory<Set<Object>> EMPTY_FACTORY = InstanceFactory.create(emptySet());
 
   @SuppressWarnings({"unchecked", "rawtypes"}) // safe covariant cast
   public static <T> Factory<Set<T>> empty() {
diff --git a/core/src/main/java/dagger/internal/SingleCheck.java b/core/src/main/java/dagger/internal/SingleCheck.java
index 3a9a14766..45b1bd793 100644
--- a/core/src/main/java/dagger/internal/SingleCheck.java
+++ b/core/src/main/java/dagger/internal/SingleCheck.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Google, Inc.
+ * Copyright (C) 2014 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,47 +13,52 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal;
 
+import static dagger.internal.Preconditions.checkNotNull;
+
 import dagger.Lazy;
 import javax.inject.Provider;
 
-import static dagger.internal.Preconditions.checkNotNull;
-
 /**
- * A {@link Provider} implementation that memoizes the result of a {@link Factory} instance using
+ * A {@link Provider} implementation that memoizes the result of another {@link Provider} using
  * simple lazy initialization, not the double-checked lock pattern.
  */
 public final class SingleCheck<T> implements Provider<T>, Lazy<T> {
   private static final Object UNINITIALIZED = new Object();
 
-  private volatile Factory<T> factory;
+  private volatile Provider<T> provider;
   private volatile Object instance = UNINITIALIZED;
 
-  private SingleCheck(Factory<T> factory) {
-    assert factory != null;
-    this.factory = factory;
+  private SingleCheck(Provider<T> provider) {
+    assert provider != null;
+    this.provider = provider;
   }
 
-  @SuppressWarnings("unchecked") // cast only happens when result comes from the factory
+  @SuppressWarnings("unchecked") // cast only happens when result comes from the delegate provider
   @Override
   public T get() {
-    // factory is volatile and might become null afer the check to instance == UNINITIALIZED
-    // retrieve the factory first, which should not be null if instance is UNINITIALIZED.
+    // provider is volatile and might become null after the check to instance == UNINITIALIZED, so
+    // retrieve the provider first, which should not be null if instance is UNINITIALIZED.
     // This relies upon instance also being volatile so that the reads and writes of both variables
     // cannot be reordered.
-    Factory<T> factoryReference = factory;
+    Provider<T> providerReference = provider;
     if (instance == UNINITIALIZED) {
-      instance = factoryReference.get();
+      instance = providerReference.get();
       // Null out the reference to the provider. We are never going to need it again, so we can make
-      // it eligble for GC.
-      factory = null;
+      // it eligible for GC.
+      provider = null;
     }
     return (T) instance;
   }
 
-  /** Returns a new provider for the given factory. */
-  public static <T> Provider<T> provider(Factory<T> factory) {
-    return new SingleCheck<T>(checkNotNull(factory));
+  /** Returns a {@link Provider} that caches the value from the given delegate provider. */
+  public static <T> Provider<T> provider(Provider<T> provider) {
+    // If a scoped @Binds delegates to a scoped binding, don't cache the value again.
+    if (provider instanceof SingleCheck || provider instanceof DoubleCheck) {
+      return provider;
+    }
+    return new SingleCheck<T>(checkNotNull(provider));
   }
 }
diff --git a/core/src/main/java/dagger/internal/TypedReleasableReferenceManagerDecorator.java b/core/src/main/java/dagger/internal/TypedReleasableReferenceManagerDecorator.java
new file mode 100644
index 000000000..a1167ef8e
--- /dev/null
+++ b/core/src/main/java/dagger/internal/TypedReleasableReferenceManagerDecorator.java
@@ -0,0 +1,71 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal;
+
+import static dagger.internal.Preconditions.checkNotNull;
+
+import dagger.releasablereferences.ReleasableReferenceManager;
+import dagger.releasablereferences.TypedReleasableReferenceManager;
+import java.lang.annotation.Annotation;
+
+/**
+ * A {@link TypedReleasableReferenceManager} that decorates another {@link
+ * ReleasableReferenceManager} with a metadata annotation.
+ *
+ * <p>For each scope that requires a {@link ReleasableReferenceManager}, the generated component
+ * implementation has a field that implements that manager. For every {@link
+ * TypedReleasableReferenceManager} that is required for that scope, the component uses this class
+ * to decorate the field with the metadata annotation.
+ *
+ * @param <M> the type of the metadata annotation
+ */
+@GwtIncompatible
+public final class TypedReleasableReferenceManagerDecorator<M extends Annotation>
+    implements TypedReleasableReferenceManager<M> {
+
+  private final ReleasableReferenceManager delegate;
+  private final M metadata;
+
+  /**
+   * Constructs a manager that delegates {@link #releaseStrongReferences()} and {@link
+   * #releaseStrongReferences()} to {@code delegate}.
+   */
+  public TypedReleasableReferenceManagerDecorator(ReleasableReferenceManager delegate, M metadata) {
+    this.delegate = checkNotNull(delegate);
+    this.metadata = checkNotNull(metadata);
+  }
+
+  @Override
+  public Class<? extends Annotation> scope() {
+    return delegate.scope();
+  }
+
+  @Override
+  public M metadata() {
+    return metadata;
+  }
+
+  @Override
+  public void releaseStrongReferences() {
+    delegate.releaseStrongReferences();
+  }
+
+  @Override
+  public void restoreStrongReferences() {
+    delegate.restoreStrongReferences();
+  }
+}
diff --git a/core/src/main/java/dagger/internal/doc-files/ReferenceReleasingProvider-statemachine.png b/core/src/main/java/dagger/internal/doc-files/ReferenceReleasingProvider-statemachine.png
new file mode 100644
index 000000000..8195dc0f0
Binary files /dev/null and b/core/src/main/java/dagger/internal/doc-files/ReferenceReleasingProvider-statemachine.png differ
diff --git a/core/src/main/java/dagger/multibindings/ClassKey.java b/core/src/main/java/dagger/multibindings/ClassKey.java
index 52dc16d0d..22a055827 100644
--- a/core/src/main/java/dagger/multibindings/ClassKey.java
+++ b/core/src/main/java/dagger/multibindings/ClassKey.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,24 +13,28 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.multibindings;
 
+import static java.lang.annotation.ElementType.METHOD;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
 import dagger.MapKey;
 import dagger.internal.Beta;
 import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 
-import static java.lang.annotation.ElementType.METHOD;
-
 /**
  * A {@link MapKey} annotation for maps with {@code Class<?>} keys.
- * 
+ *
  * <p>If your map's keys can be constrained, consider using a custom annotation instead, with a
  * member whose type is {@code Class<? extends Something>}.
  */
 @Beta
 @Documented
 @Target(METHOD)
+@Retention(RUNTIME)
 @MapKey
 public @interface ClassKey {
   Class<?> value();
diff --git a/core/src/main/java/dagger/multibindings/ElementsIntoSet.java b/core/src/main/java/dagger/multibindings/ElementsIntoSet.java
index 7e157399f..84ae395d3 100644
--- a/core/src/main/java/dagger/multibindings/ElementsIntoSet.java
+++ b/core/src/main/java/dagger/multibindings/ElementsIntoSet.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 Google, Inc.
+ * Copyright (C) 2016 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,15 +13,16 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.multibindings;
 
+import static java.lang.annotation.ElementType.METHOD;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 
-import static java.lang.annotation.ElementType.METHOD;
-import static java.lang.annotation.RetentionPolicy.RUNTIME;
-
 /**
  * The method's return type is {@code Set<T>} and all values are contributed to the set. The {@code
  * Set<T>} produced from the accumulation of values will be immutable. An example use is to provide
diff --git a/core/src/main/java/dagger/multibindings/IntKey.java b/core/src/main/java/dagger/multibindings/IntKey.java
index 766f6dc99..12ebc10d9 100644
--- a/core/src/main/java/dagger/multibindings/IntKey.java
+++ b/core/src/main/java/dagger/multibindings/IntKey.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,19 +13,23 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.multibindings;
 
+import static java.lang.annotation.ElementType.METHOD;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
 import dagger.MapKey;
 import dagger.internal.Beta;
 import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 
-import static java.lang.annotation.ElementType.METHOD;
-
 /** A {@link MapKey} annotation for maps with {@code int} keys. */
 @Beta
 @Documented
 @Target(METHOD)
+@Retention(RUNTIME)
 @MapKey
 public @interface IntKey {
   int value();
diff --git a/core/src/main/java/dagger/multibindings/IntoMap.java b/core/src/main/java/dagger/multibindings/IntoMap.java
index a1e786eca..7a2619c8f 100644
--- a/core/src/main/java/dagger/multibindings/IntoMap.java
+++ b/core/src/main/java/dagger/multibindings/IntoMap.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 Google, Inc.
+ * Copyright (C) 2016 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,16 +13,17 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.multibindings;
 
+import static java.lang.annotation.ElementType.METHOD;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
 import dagger.internal.Beta;
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 
-import static java.lang.annotation.ElementType.METHOD;
-import static java.lang.annotation.RetentionPolicy.RUNTIME;
-
 /**
  * The method's return type forms the type argument for the value of a
  * {@code Map<K, Provider<V>>}, and the combination of the annotated key and the returned value
diff --git a/core/src/main/java/dagger/multibindings/IntoSet.java b/core/src/main/java/dagger/multibindings/IntoSet.java
index a7e3a7cdf..08dc2c82b 100644
--- a/core/src/main/java/dagger/multibindings/IntoSet.java
+++ b/core/src/main/java/dagger/multibindings/IntoSet.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 Google, Inc.
+ * Copyright (C) 2016 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,15 +13,16 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.multibindings;
 
+import static java.lang.annotation.ElementType.METHOD;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 
-import static java.lang.annotation.ElementType.METHOD;
-import static java.lang.annotation.RetentionPolicy.RUNTIME;
-
 /**
  * The method's return type forms the generic type argument of a {@code Set<T>}, and the
  * returned value is contributed to the set. The object graph will pass dependencies to the
diff --git a/core/src/main/java/dagger/multibindings/LongKey.java b/core/src/main/java/dagger/multibindings/LongKey.java
index 9d9a40800..a8d6ab64e 100644
--- a/core/src/main/java/dagger/multibindings/LongKey.java
+++ b/core/src/main/java/dagger/multibindings/LongKey.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,19 +13,23 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.multibindings;
 
+import static java.lang.annotation.ElementType.METHOD;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
 import dagger.MapKey;
 import dagger.internal.Beta;
 import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 
-import static java.lang.annotation.ElementType.METHOD;
-
 /** A {@link MapKey} annotation for maps with {@code long} keys. */
 @Beta
 @Documented
 @Target(METHOD)
+@Retention(RUNTIME)
 @MapKey
 public @interface LongKey {
   long value();
diff --git a/core/src/main/java/dagger/multibindings/Multibinds.java b/core/src/main/java/dagger/multibindings/Multibinds.java
index 48dd94257..4ce886c5a 100644
--- a/core/src/main/java/dagger/multibindings/Multibinds.java
+++ b/core/src/main/java/dagger/multibindings/Multibinds.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,14 +13,17 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.multibindings;
 
+import static java.lang.annotation.ElementType.METHOD;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
 import dagger.internal.Beta;
 import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 
-import static java.lang.annotation.ElementType.METHOD;
-
 /**
  * Annotates abstract module methods that declare multibindings.
  *
@@ -50,5 +53,6 @@
  */
 @Documented
 @Target(METHOD)
+@Retention(RUNTIME)
 @Beta
 public @interface Multibinds {}
diff --git a/core/src/main/java/dagger/multibindings/StringKey.java b/core/src/main/java/dagger/multibindings/StringKey.java
index 11dcbfaa6..40d48c87c 100644
--- a/core/src/main/java/dagger/multibindings/StringKey.java
+++ b/core/src/main/java/dagger/multibindings/StringKey.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,19 +13,23 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.multibindings;
 
+import static java.lang.annotation.ElementType.METHOD;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
 import dagger.MapKey;
 import dagger.internal.Beta;
 import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 
-import static java.lang.annotation.ElementType.METHOD;
-
 /** A {@link MapKey} annotation for maps with {@link String} keys. */
 @Beta
 @Documented
 @Target(METHOD)
+@Retention(RUNTIME)
 @MapKey
 public @interface StringKey {
   String value();
diff --git a/core/src/main/java/dagger/multibindings/package-info.java b/core/src/main/java/dagger/multibindings/package-info.java
index e62974ddb..fdf64d211 100644
--- a/core/src/main/java/dagger/multibindings/package-info.java
+++ b/core/src/main/java/dagger/multibindings/package-info.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 Google, Inc.
+ * Copyright (C) 2016 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -21,4 +21,5 @@
  * @see <a href="http://google.github.io/dagger/multibindings">Multibindings in the Dagger
  *      User's Guide</a>
  */
+
 package dagger.multibindings;
diff --git a/core/src/main/java/dagger/package-info.java b/core/src/main/java/dagger/package-info.java
index e5cc67f39..92e1fc9ad 100644
--- a/core/src/main/java/dagger/package-info.java
+++ b/core/src/main/java/dagger/package-info.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -31,4 +31,5 @@
  * {@linkplain java.util.ServiceLoader service loader} to automatically configure the processor, so
  * explict build configuration shouldn't be necessary.
  */
+
 package dagger;
diff --git a/core/src/main/java/dagger/releasablereferences/CanReleaseReferences.java b/core/src/main/java/dagger/releasablereferences/CanReleaseReferences.java
new file mode 100644
index 000000000..7877c47a2
--- /dev/null
+++ b/core/src/main/java/dagger/releasablereferences/CanReleaseReferences.java
@@ -0,0 +1,65 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.releasablereferences;
+
+import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
+
+import dagger.internal.Beta;
+import dagger.internal.GwtIncompatible;
+import java.lang.annotation.Documented;
+import java.lang.annotation.Target;
+
+/**
+ * Annotates {@linkplain javax.inject.Scope scope annotations} to indicate that references to
+ * objects stored within that scope can be <a
+ * href="http://google.github.io/dagger/users-guide.html#releasable-references">released</a> during
+ * the lifetime of the scope.
+ *
+ * <p>A scope can release references if it is annotated with {@code CanReleaseReferences} or if it
+ * is annotated with an annotation that itself is annotated with {@code CanReleaseReferences}.
+ *
+ * <p>For example:
+ *
+ * <pre>
+ *   {@literal @Documented}
+ *   {@literal @Retention(RUNTIME)}
+ *   {@literal @CanReleaseReferences}
+ *   {@literal @Scope}
+ *   public {@literal @interface} MyScope {}</pre>
+ *
+ * or:
+ *
+ * <pre>
+ *   {@literal @CanReleaseReferences}
+ *   public {@literal @interface} SomeAnnotation {}
+ *
+ *   {@literal @Documented}
+ *   {@literal @Retention(RUNTIME)}
+ *   {@literal @SomeAnnotation}
+ *   {@literal @Scope}
+ *   public {@literal @interface} MyScope {}</pre>
+ *
+ * <p><b>Note:</b>Releasable references uses Java's {@link java.lang.ref.WeakReference}, and so is
+ * not compatible with <a href="http://www.gwtproject.org/">GWT</a>.
+ *
+ * @since 2.8
+ */
+@Beta
+@Documented
+@GwtIncompatible
+@Target(ANNOTATION_TYPE)
+public @interface CanReleaseReferences {}
diff --git a/core/src/main/java/dagger/releasablereferences/ForReleasableReferences.java b/core/src/main/java/dagger/releasablereferences/ForReleasableReferences.java
new file mode 100644
index 000000000..ef1b653bd
--- /dev/null
+++ b/core/src/main/java/dagger/releasablereferences/ForReleasableReferences.java
@@ -0,0 +1,84 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.releasablereferences;
+
+import static java.lang.annotation.ElementType.FIELD;
+import static java.lang.annotation.ElementType.METHOD;
+import static java.lang.annotation.ElementType.PARAMETER;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+import dagger.internal.Beta;
+import dagger.internal.GwtIncompatible;
+import java.lang.annotation.Annotation;
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+import javax.inject.Qualifier;
+
+/**
+ * A {@link Qualifier} to inject a {@link ReleasableReferenceManager} or {@link
+ * TypedReleasableReferenceManager} object for a particular scope.
+ *
+ * <p>For example:
+ *
+ * <pre>
+ *   {@literal @Documented}
+ *   {@literal @Retention(RUNTIME)}
+ *   {@literal @CanReleaseReferences}
+ *   {@literal @Scope}
+ *   {@literal public @interface} MyScope {}
+ *
+ *   {@literal @CanReleaseReferences}
+ *   {@literal public @interface} MyMetadata {
+ *     int value();
+ *   }
+ *
+ *   {@literal @Documented}
+ *   {@literal @Retention(RUNTIME)}
+ *   {@literal @MyMetadata}(15)
+ *   {@literal @Scope}
+ *   {@literal public @interface YourScope} {}
+ *
+ *   class MyClass {
+ *     {@literal @Inject}
+ *     MyClass(
+ *         {@literal @ForReleasableReferences(MyScope.class)}
+ *         ReleasableReferenceManager myScopeReferenceManager,
+ *         {@literal @ForReleasableReferences(YourScope.class)}
+ *         {@literal TypedReleasableReferenceManager<MyMetadata>} yourScopeReferenceManager) {
+ *       // …
+ *     }
+ *   }
+ * </pre>
+ *
+ * <p><b>Note:</b>Releasable references uses Java's {@link java.lang.ref.WeakReference}, and so is
+ * not compatible with <a href="http://www.gwtproject.org/">GWT</a>.
+ *
+ * @see <a href="http://google.github.io/dagger/users-guide.html#releasable-references">Releasable
+ *     references</a>
+ * @since 2.8
+ */
+@Beta
+@Documented
+@GwtIncompatible
+@Target({FIELD, PARAMETER, METHOD})
+@Retention(RUNTIME)
+@Qualifier
+public @interface ForReleasableReferences {
+  /** The {@linkplain CanReleaseReferences reference-releasing} scope annotation type. */
+  Class<? extends Annotation> value();
+}
diff --git a/core/src/main/java/dagger/releasablereferences/ReleasableReferenceManager.java b/core/src/main/java/dagger/releasablereferences/ReleasableReferenceManager.java
new file mode 100644
index 000000000..829fd4c41
--- /dev/null
+++ b/core/src/main/java/dagger/releasablereferences/ReleasableReferenceManager.java
@@ -0,0 +1,99 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.releasablereferences;
+
+import dagger.internal.Beta;
+import dagger.internal.GwtIncompatible;
+import java.lang.annotation.Annotation;
+import java.lang.ref.WeakReference;
+import javax.inject.Provider;
+
+/**
+ * An object that can <a
+ * href="http://google.github.io/dagger/users-guide.html#releasable-references">release or restore
+ * strong references</a> held in a {@link CanReleaseReferences @CanReleaseReferences} scope.
+ *
+ * <p>Your top-level component can provide a {@link
+ * ForReleasableReferences @ForReleasableReferences(Foo.class)} {@link ReleasableReferenceManager}
+ * object for any {@link CanReleaseReferences @CanReleaseReferences}-annotated scope {@code Foo}
+ * anywhere in your component hierarchy.
+ *
+ * <p>It can also provide a {@code Set<ReleasableReferenceManager>} that contains all such objects.
+ *
+ * <p>Each provider in the {@link CanReleaseReferences @CanReleaseReferences} {@link #scope()} can
+ * be in any one of four states at a time:
+ *
+ * <ul>
+ *   <li>In <b>uninitialized</b> state, the provider's strong reference and its {@link
+ *       WeakReference} are both {@code null}.
+ *   <li>In <b>cleared</b> state, the provider's strong reference is {@code null}, and its {@link
+ *       WeakReference}'s value is {@code null}.
+ *   <li>In <b>strong-reference</b> state, the provider's strong reference refers to the cached
+ *       value, and its {@link WeakReference} is {@code null}.
+ *   <li>In <b>weak-reference</b> state, the provider's strong reference is {@code null}, and its
+ *       {@link WeakReference}'s value is not {@code null}.
+ * </ul>
+ *
+ * <p>All providers within {@link #scope()} start in <b>uninitialized</b> state.
+ *
+ * <p>Calling {@link Provider#get()} on a provider within {@link #scope()} transitions it to
+ * <b>strong-reference</b> state if it was in <b>uninitialized</b> or <b>empty</b> state.
+ *
+ * <p>{@link #releaseStrongReferences()} transitions all providers within {@link #scope()} that are
+ * in <b>strong-reference</b> state to <b>weak-reference</b> state.
+ *
+ * <p>{@link #restoreStrongReferences()} transitions all providers within {@link #scope()} that are
+ * in <b>weak-reference</b> state to <b>strong-reference</b> state.
+ *
+ * <p>If garbage collection clears the {@link WeakReference} for any provider within {@link
+ * #scope()} that is in <b>weak-reference</b> state, that provider transitions to <b>cleared</b>
+ * state.
+ *
+ * <p><img src="doc-files/ReleasableReferenceManager-statemachine.png"
+ * alt="ReleasableReferenceManager state machine">
+ *
+ * <p>This interface is implemented by Dagger.
+ *
+ * @since 2.8
+ */
+@Beta
+@GwtIncompatible
+public interface ReleasableReferenceManager {
+
+  /** The scope whose references are managed by this object. */
+  Class<? extends Annotation> scope();
+
+  /**
+   * Releases the strong references held by all providers in this {@linkplain #scope() scope} to the
+   * objects previously returned by {@link Provider#get()}, leaving only {@link WeakReference}s.
+   *
+   * <p>If any such {@link WeakReference} is cleared during garbage collection, the next call to
+   * that {@link Provider#get()} will execute the underlying binding again, and the provider will
+   * hold a strong reference to the new returned value.
+   *
+   * <p>Calls to {@link Provider#get()} on any such provider return the weakly-referenced object
+   * until the {@link WeakReference} is cleared or {@link #restoreStrongReferences()} is called.
+   */
+  void releaseStrongReferences();
+
+  /**
+   * Restores strong references for all providers in this {@linkplain #scope() scope} that were
+   * previously {@linkplain #releaseStrongReferences() released} but whose {@link WeakReference} has
+   * not yet been cleared during garbage collection.
+   */
+  void restoreStrongReferences();
+}
diff --git a/core/src/main/java/dagger/releasablereferences/TypedReleasableReferenceManager.java b/core/src/main/java/dagger/releasablereferences/TypedReleasableReferenceManager.java
new file mode 100644
index 000000000..aa067c5bb
--- /dev/null
+++ b/core/src/main/java/dagger/releasablereferences/TypedReleasableReferenceManager.java
@@ -0,0 +1,63 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.releasablereferences;
+
+import dagger.internal.Beta;
+import dagger.internal.GwtIncompatible;
+import java.lang.annotation.Annotation;
+
+/**
+ * A {@link ReleasableReferenceManager} for a scope that is annotated with an annotation that itself
+ * is annotated with {@link CanReleaseReferences}. That annotation is available as {@link
+ * #metadata()} and may be useful at runtime to decide when to release references held by the scope.
+ *
+ * <p>For example:
+ *
+ * <pre>
+ *   {@literal @CanReleaseReferences}
+ *   public {@literal @interface} SomeAnnotation {
+ *     int value();
+ *   }
+ *
+ *   {@literal @Documented}
+ *   {@literal @Retention(RUNTIME)}
+ *   {@literal @SomeAnnotation}(15)
+ *   {@literal @Scope}
+ *   public {@literal @interface} MyScope {}
+ *
+ *   // In a component that is (or has a subcomponent) annotated with {@literal @MyScope}:
+ *   {@literal @Inject}
+ *   void manager(
+ *       {@literal @ForReferenceReleasingScope(MyScope.class)}
+ *       {@literal TypedReferenceReleasingScope<SomeAnnotation>} manager) {
+ *     manager.metadata().value(); // returns 15
+ *   }</pre>
+ *
+ * <p>This interface is implemented by Dagger.
+ *
+ * @param <M> the type of the metadata annotation
+ */
+@Beta
+@GwtIncompatible
+public interface TypedReleasableReferenceManager<M extends Annotation>
+    extends ReleasableReferenceManager {
+
+  /**
+   * Returns the annotation on {@link #scope()} that is annotated with {@link CanReleaseReferences}.
+   */
+  M metadata();
+}
diff --git a/core/src/main/java/dagger/releasablereferences/doc-files/ReleasableReferenceManager-statemachine.png b/core/src/main/java/dagger/releasablereferences/doc-files/ReleasableReferenceManager-statemachine.png
new file mode 100644
index 000000000..6400f1d23
Binary files /dev/null and b/core/src/main/java/dagger/releasablereferences/doc-files/ReleasableReferenceManager-statemachine.png differ
diff --git a/core/src/main/java/dagger/releasablereferences/package-info.java b/core/src/main/java/dagger/releasablereferences/package-info.java
new file mode 100644
index 000000000..d0d29edbd
--- /dev/null
+++ b/core/src/main/java/dagger/releasablereferences/package-info.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * This package contains the API by which Dagger allows you
+ * <a href="http://google.github.io/dagger/users-guide.html#releasable-references">release
+ * references</a> held within some scopes.
+ * 
+ * <p><b>Note:</b>Releasable references uses Java's {@link java.lang.ref.WeakReference}, and so is
+ * not compatible with <a href="http://www.gwtproject.org/">GWT</a>.
+ *
+ * @since 2.8
+ */
+
+package dagger.releasablereferences;
diff --git a/core/src/test/java/dagger/internal/DoubleCheckTest.java b/core/src/test/java/dagger/internal/DoubleCheckTest.java
index 077c50807..20abbe566 100644
--- a/core/src/test/java/dagger/internal/DoubleCheckTest.java
+++ b/core/src/test/java/dagger/internal/DoubleCheckTest.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 Google, Inc.
+ * Copyright (C) 2016 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,8 +13,12 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal;
 
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+
 import com.google.common.collect.Lists;
 import com.google.common.collect.Sets;
 import com.google.common.util.concurrent.Uninterruptibles;
@@ -33,10 +37,6 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import static com.google.common.truth.Truth.assertThat;
-import static com.google.common.truth.Truth.assert_;
-import static org.junit.Assert.fail;
-
 @RunWith(JUnit4.class)
 public class DoubleCheckTest {
   @Test
@@ -58,13 +58,7 @@ public void lazy_nullPointerException() {
   }
 
   private static final Provider<Object> DOUBLE_CHECK_OBJECT_PROVIDER =
-      DoubleCheck.provider(
-          new Provider<Object>() {
-            @Override
-            public Object get() {
-              return new Object();
-            }
-          });
+      DoubleCheck.provider(Object::new);
 
   @Test
   public void doubleWrapping_provider() {
@@ -90,23 +84,20 @@ public void get() throws Exception {
     List<Callable<Object>> tasks = Lists.newArrayListWithCapacity(numThreads);
     for (int i = 0; i < numThreads; i++) {
       tasks.add(
-          new Callable<Object>() {
-            @Override
-            public Object call() throws Exception {
-              latch.countDown();
-              return lazy.get();
-            }
+          () -> {
+            latch.countDown();
+            return lazy.get();
           });
     }
 
     List<Future<Object>> futures = executor.invokeAll(tasks);
 
-    assert_().that(provider.provisions.get()).isEqualTo(1);
+    assertThat(provider.provisions.get()).isEqualTo(1);
     Set<Object> results = Sets.newIdentityHashSet();
     for (Future<Object> future : futures) {
       results.add(future.get());
     }
-    assert_().that(results.size()).isEqualTo(1);
+    assertThat(results).hasSize(1);
   }
 
   private static class LatchedProvider implements Provider<Object> {
@@ -130,13 +121,8 @@ public Object get() {
 
   @Test public void reentranceWithoutCondition_throwsStackOverflow() {
     final AtomicReference<Provider<Object>> doubleCheckReference =
-        new AtomicReference<Provider<Object>>();
-    Provider<Object> doubleCheck = DoubleCheck.provider(new Provider<Object>() {
-      @Override
-      public Object get() {
-        return doubleCheckReference.get().get();
-      }
-    });
+        new AtomicReference<>();
+    Provider<Object> doubleCheck = DoubleCheck.provider(() -> doubleCheckReference.get().get());
     doubleCheckReference.set(doubleCheck);
     try {
       doubleCheck.get();
@@ -146,39 +132,39 @@ public Object get() {
 
   @Test public void reentranceReturningSameInstance() {
     final AtomicReference<Provider<Object>> doubleCheckReference =
-        new AtomicReference<Provider<Object>>();
+        new AtomicReference<>();
     final AtomicInteger invocationCount = new AtomicInteger();
     final Object object = new Object();
-    Provider<Object> doubleCheck = DoubleCheck.provider(new Provider<Object>() {
-     @Override
-      public Object get() {
-         if (invocationCount.incrementAndGet() == 1) {
-          doubleCheckReference.get().get();
-        }
-        return object;
-      }
-    });
+    Provider<Object> doubleCheck = DoubleCheck.provider(() -> {
+        if (invocationCount.incrementAndGet() == 1) {
+         doubleCheckReference.get().get();
+       }
+       return object;
+     });
     doubleCheckReference.set(doubleCheck);
     assertThat(doubleCheck.get()).isSameAs(object);
   }
 
   @Test public void reentranceReturningDifferentInstances_throwsIllegalStateException() {
     final AtomicReference<Provider<Object>> doubleCheckReference =
-        new AtomicReference<Provider<Object>>();
+        new AtomicReference<>();
     final AtomicInteger invocationCount = new AtomicInteger();
-    Provider<Object> doubleCheck = DoubleCheck.provider(new Provider<Object>() {
-     @Override
-      public Object get() {
-        if (invocationCount.incrementAndGet() == 1) {
-          doubleCheckReference.get().get();
-        }
-        return new Object();
-      }
-    });
+    Provider<Object> doubleCheck = DoubleCheck.provider(() -> {
+       if (invocationCount.incrementAndGet() == 1) {
+         doubleCheckReference.get().get();
+       }
+       return new Object();
+     });
     doubleCheckReference.set(doubleCheck);
     try {
       doubleCheck.get();
       fail();
     } catch (IllegalStateException expected) {}
   }
+
+  @Test
+  public void instanceFactoryAsLazyDoesNotWrap() {
+    Factory<Object> factory = InstanceFactory.create(new Object());
+    assertThat(DoubleCheck.lazy(factory)).isSameAs(factory);
+  }
 }
diff --git a/core/src/test/java/dagger/internal/InstanceFactoryTest.java b/core/src/test/java/dagger/internal/InstanceFactoryTest.java
index acaf20d79..82b66e687 100644
--- a/core/src/test/java/dagger/internal/InstanceFactoryTest.java
+++ b/core/src/test/java/dagger/internal/InstanceFactoryTest.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Google, Inc.
+ * Copyright (C) 2014 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,30 +13,31 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal;
 
-import org.junit.Rule;
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+
 import org.junit.Test;
-import org.junit.rules.ExpectedException;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import static com.google.common.truth.Truth.assert_;
-
 @RunWith(JUnit4.class)
 public final class InstanceFactoryTest {
-  @Rule public final ExpectedException thrown = ExpectedException.none();
-
   @Test public void instanceFactory() {
     Object instance = new Object();
     Factory<Object> factory = InstanceFactory.create(instance);
-    assert_().that(factory.get()).isEqualTo(instance);
-    assert_().that(factory.get()).isEqualTo(instance);
-    assert_().that(factory.get()).isEqualTo(instance);
+    assertThat(factory.get()).isEqualTo(instance);
+    assertThat(factory.get()).isEqualTo(instance);
+    assertThat(factory.get()).isEqualTo(instance);
   }
 
   @Test public void create_throwsNullPointerException() {
-    thrown.expect(NullPointerException.class);
-    InstanceFactory.create(null);
+    try {
+      InstanceFactory.create(null);
+      fail();
+    } catch (NullPointerException expected) {
+    }
   }
 }
diff --git a/core/src/test/java/dagger/internal/MapProviderFactoryTest.java b/core/src/test/java/dagger/internal/MapProviderFactoryTest.java
index b4496e926..5598ff223 100644
--- a/core/src/test/java/dagger/internal/MapProviderFactoryTest.java
+++ b/core/src/test/java/dagger/internal/MapProviderFactoryTest.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Google, Inc.
+ * Copyright (C) 2014 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,8 +13,11 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal;
 
+import static com.google.common.truth.Truth.assertThat;
+
 import java.util.LinkedHashMap;
 import java.util.Map;
 import java.util.concurrent.atomic.AtomicInteger;
@@ -25,8 +28,6 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import static com.google.common.truth.Truth.assert_;
-
 @RunWith(JUnit4.class)
 @SuppressWarnings("unchecked")
 public class MapProviderFactoryTest {
@@ -62,25 +63,18 @@ public void iterationOrder() {
         .put("four", p4)
         .build();
 
-    Map<String, Provider<Integer>> expectedMap = new LinkedHashMap<String, Provider<Integer>>();
+    Map<String, Provider<Integer>> expectedMap = new LinkedHashMap<>();
     expectedMap.put("two", p2);
     expectedMap.put("one", p1);
     expectedMap.put("three", p3);
     expectedMap.put("one", p5);
     expectedMap.put("four", p4);
-    assert_()
-        .that(factory.get().entrySet())
+    assertThat(factory.get().entrySet())
         .containsExactlyElementsIn(expectedMap.entrySet())
         .inOrder();
   }
 
   private static Provider<Integer> incrementingIntegerProvider(int seed) {
-    final AtomicInteger value = new AtomicInteger(seed);
-    return new Provider<Integer>() {
-      @Override
-      public Integer get() {
-        return value.getAndIncrement();
-      }
-    };
+    return new AtomicInteger(seed)::getAndIncrement;
   }
 }
diff --git a/core/src/test/java/dagger/internal/SetFactoryTest.java b/core/src/test/java/dagger/internal/SetFactoryTest.java
index af7cb99bf..0032578c6 100644
--- a/core/src/test/java/dagger/internal/SetFactoryTest.java
+++ b/core/src/test/java/dagger/internal/SetFactoryTest.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Google, Inc.
+ * Copyright (C) 2014 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,8 +13,11 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal;
 
+import static com.google.common.truth.Truth.assertThat;
+
 import com.google.common.collect.ImmutableSet;
 import java.util.Arrays;
 import java.util.LinkedHashSet;
@@ -27,8 +30,6 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import static com.google.common.truth.Truth.assertThat;
-
 @RunWith(JUnit4.class)
 @SuppressWarnings("unchecked")
 public class SetFactoryTest {
@@ -37,7 +38,7 @@
   @Test
   public void providerReturnsNull() {
     Factory<Set<Integer>> factory =
-        SetFactory.<Integer>builder(0, 1).addCollectionProvider(providerOf((Set<Integer>) null)).build();
+        SetFactory.<Integer>builder(0, 1).addCollectionProvider(() -> null).build();
     thrown.expect(NullPointerException.class);
     factory.get();
   }
@@ -45,16 +46,16 @@ public void providerReturnsNull() {
   @Test
   public void providerReturnsNullSet() {
     Factory<Set<Integer>> factory =
-        SetFactory.<Integer>builder(1, 0).addProvider(providerOf((Integer) null)).build();
+        SetFactory.<Integer>builder(1, 0).addProvider(() -> null).build();
     thrown.expect(NullPointerException.class);
     factory.get();
   }
 
   @Test
   public void providerReturnsSetWithNullElement() {
-    Set<Integer> set = new LinkedHashSet<Integer>(Arrays.asList(1, null, 3));
+    Set<Integer> set = new LinkedHashSet<>(Arrays.asList(1, null, 3));
     Factory<Set<Integer>> factory =
-        SetFactory.<Integer>builder(0, 1).addCollectionProvider(providerOf(set)).build();
+        SetFactory.<Integer>builder(0, 1).addCollectionProvider(() -> set).build();
     thrown.expect(NullPointerException.class);
     factory.get();
   }
@@ -73,32 +74,13 @@ public void invokesProvidersEveryTime() {
     assertThat(factory.get()).containsExactly(2, 12, 24, 25, 34, 35);
   }
 
-  private static <T> Provider<T> providerOf(final T value) {
-    return new Provider<T>() {
-      @Override
-      public T get() {
-        return value;
-      }
-    };
-  }
-
   private static Provider<Integer> incrementingIntegerProvider(int seed) {
     final AtomicInteger value = new AtomicInteger(seed);
-    return new Provider<Integer>() {
-      @Override
-      public Integer get() {
-        return value.getAndIncrement();
-      }
-    };
+    return value::getAndIncrement;
   }
 
   private static Provider<Set<Integer>> incrementingIntegerSetProvider(int seed) {
     final AtomicInteger value = new AtomicInteger(seed);
-    return new Provider<Set<Integer>>() {
-      @Override
-      public Set<Integer> get() {
-        return ImmutableSet.of(value.getAndIncrement(), value.getAndIncrement());
-      }
-    };
+    return () -> ImmutableSet.of(value.getAndIncrement(), value.getAndIncrement());
   }
 }
diff --git a/core/src/test/java/dagger/internal/SingleCheckTest.java b/core/src/test/java/dagger/internal/SingleCheckTest.java
index 3bc2075cf..0c043fd4c 100644
--- a/core/src/test/java/dagger/internal/SingleCheckTest.java
+++ b/core/src/test/java/dagger/internal/SingleCheckTest.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Google, Inc.
+ * Copyright (C) 2014 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,15 +13,17 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.internal;
 
+import static com.google.common.truth.Truth.assertThat;
+
+import java.util.concurrent.atomic.AtomicInteger;
 import javax.inject.Provider;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import static com.google.common.truth.Truth.assertThat;
-
 /**
  * Tests {@link SingleCheck}.
  */
@@ -34,16 +36,8 @@ public void create_nullPointerException() {
 
   @Test
   public void get() {
-    Provider<Integer> provider =
-        SingleCheck.provider(
-            new Factory<Integer>() {
-              int i = 0;
-
-              @Override
-              public Integer get() {
-                return i++;
-              }
-            });
+    AtomicInteger integer = new AtomicInteger();
+    Provider<Integer> provider = SingleCheck.provider(integer::getAndIncrement);
     assertThat(provider.get()).isEqualTo(0);
     assertThat(provider.get()).isEqualTo(0);
     assertThat(provider.get()).isEqualTo(0);
diff --git a/deploy_website.sh b/deploy_website.sh
deleted file mode 100755
index 1fde1bd57..000000000
--- a/deploy_website.sh
+++ /dev/null
@@ -1,49 +0,0 @@
-#!/bin/bash
-#
-# Deploys the current Dagger website to the gh-pages branch of the GitHub
-# repository. To test the site locally before deploying run `jekyll --server`
-# in the website/ directory.
-
-set -ex
-
-REPO="git@github.com:square/dagger.git"
-GROUP_ID="com.squareup.dagger"
-ARTIFACT_ID="dagger"
-
-DIR=temp-dagger-clone
-
-# Delete any existing temporary website clone
-rm -rf $DIR
-
-# Clone the current repo into temp folder
-git clone $REPO $DIR
-
-# Move working directory into temp folder
-cd $DIR
-
-# Checkout and track the gh-pages branch
-git checkout -t origin/gh-pages
-
-# Delete everything
-rm -rf *
-
-# Copy website files from real repo
-cp -R ../website/* .
-
-# Download the latest javadoc
-curl -L "http://repository.sonatype.org/service/local/artifact/maven/redirect?r=central-proxy&g=$GROUP_ID&a=$ARTIFACT_ID&v=LATEST&c=javadoc" > javadoc.zip
-mkdir javadoc
-unzip javadoc.zip -d javadoc
-rm javadoc.zip
-
-# Stage all files in git and create a commit
-git add .
-git add -u
-git commit -m "Website at $(date)"
-
-# Push the new files up to GitHub
-git push origin gh-pages
-
-# Delete our temp folder
-cd ..
-rm -rf $DIR
diff --git a/examples/android-activity-graphs/pom.xml b/examples/android-activity-graphs/pom.xml
index 6c77a198b..83247d6e5 100644
--- a/examples/android-activity-graphs/pom.xml
+++ b/examples/android-activity-graphs/pom.xml
@@ -1,6 +1,6 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <!--
- Copyright (C) 2013 Square, Inc.
+ Copyright (C) 2013 The Dagger Authors.
 
   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.google.dagger.example</groupId>
     <artifactId>dagger-example-parent</artifactId>
-    <version>2.5-SNAPSHOT</version>
+    <version>HEAD-SNAPSHOT</version>
   </parent>
 
   <artifactId>android-activity-graphs</artifactId>
@@ -36,12 +36,10 @@
     <dependency>
       <groupId>com.google.dagger</groupId>
       <artifactId>dagger</artifactId>
-      <version>${project.version}</version>
     </dependency>
     <dependency>
       <groupId>com.google.dagger</groupId>
       <artifactId>dagger-compiler</artifactId>
-      <version>${project.version}</version>
       <scope>provided</scope>
       <optional>true</optional>
     </dependency>
diff --git a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/AbstractActivityComponent.java b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/AbstractActivityComponent.java
index 430838e83..35f578d6c 100644
--- a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/AbstractActivityComponent.java
+++ b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/AbstractActivityComponent.java
@@ -1,6 +1,5 @@
 /*
- * Copyright (C) 2013 Square, Inc.
- * Copyright (C) 2014 Google, Inc.
+ * Copyright (C) 2013 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package com.example.dagger.activitygraphs;
 
 import android.app.Activity;
diff --git a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ActivityModule.java b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ActivityModule.java
index cf5462e50..1a2a5945e 100644
--- a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ActivityModule.java
+++ b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ActivityModule.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013 Square, Inc.
+ * Copyright (C) 2013 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package com.example.dagger.activitygraphs;
 
 import android.app.Activity;
diff --git a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ApplicationComponent.java b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ApplicationComponent.java
index 04c206225..37629ee3b 100644
--- a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ApplicationComponent.java
+++ b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ApplicationComponent.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013 Square, Inc.
+ * Copyright (C) 2013 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package com.example.dagger.activitygraphs;
 
 import android.app.Application;
diff --git a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/DemoApplication.java b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/DemoApplication.java
index 72057332c..1174a62bf 100644
--- a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/DemoApplication.java
+++ b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/DemoApplication.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013 Square, Inc.
+ * Copyright (C) 2013 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,11 +13,11 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package com.example.dagger.activitygraphs;
 
 import android.app.Application;
 import android.location.LocationManager;
-import javax.inject.Singleton;
 import javax.inject.Inject;
 
 public class DemoApplication extends Application {
diff --git a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/DemoApplicationModule.java b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/DemoApplicationModule.java
index 070d2c79d..e3f4634ad 100644
--- a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/DemoApplicationModule.java
+++ b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/DemoApplicationModule.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013 Square, Inc.
+ * Copyright (C) 2013 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,16 +13,17 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package com.example.dagger.activitygraphs;
 
+import static android.content.Context.LOCATION_SERVICE;
+
 import android.app.Application;
 import android.location.LocationManager;
 import dagger.Module;
 import dagger.Provides;
 import javax.inject.Singleton;
 
-import static android.content.Context.LOCATION_SERVICE;
-
 /**
  * A module for Android-specific dependencies which require a {@link Context} or
  * {@link android.app.Application} to create.
diff --git a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/PerActivity.java b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/PerActivity.java
index d54b193e3..f4700161c 100644
--- a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/PerActivity.java
+++ b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/PerActivity.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013 Square, Inc.
+ * Copyright (C) 2013 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,13 +13,14 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package com.example.dagger.activitygraphs;
 
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
 import java.lang.annotation.Retention;
 import javax.inject.Scope;
 
-import static java.lang.annotation.RetentionPolicy.RUNTIME;
-
 /**
  * A scoping annotation to permit objects whose lifetime should
  * conform to the life of the activity to be memoized in the
diff --git a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ui/ActivityTitleController.java b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ui/ActivityTitleController.java
index c416c75b3..6352d837f 100644
--- a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ui/ActivityTitleController.java
+++ b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ui/ActivityTitleController.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013 Square, Inc.
+ * Copyright (C) 2013 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package com.example.dagger.activitygraphs.ui;
 
 import android.app.Activity;
diff --git a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ui/HomeActivity.java b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ui/HomeActivity.java
index 1f3bb7002..dcdb1b885 100644
--- a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ui/HomeActivity.java
+++ b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ui/HomeActivity.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013 Square, Inc.
+ * Copyright (C) 2013 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package com.example.dagger.activitygraphs.ui;
 
 import android.location.LocationManager;
diff --git a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ui/HomeComponent.java b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ui/HomeComponent.java
index 84d2a427c..57b9b894b 100644
--- a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ui/HomeComponent.java
+++ b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ui/HomeComponent.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013 Square, Inc.
+ * Copyright (C) 2013 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package com.example.dagger.activitygraphs.ui;
 
 import com.example.dagger.activitygraphs.AbstractActivityComponent;
diff --git a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ui/HomeFragment.java b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ui/HomeFragment.java
index 1df2724cb..37d6383c2 100644
--- a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ui/HomeFragment.java
+++ b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ui/HomeFragment.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013 Square, Inc.
+ * Copyright (C) 2013 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,8 +13,11 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package com.example.dagger.activitygraphs.ui;
 
+import static android.view.Gravity.CENTER;
+
 import android.os.Bundle;
 import android.support.v4.app.Fragment;
 import android.view.LayoutInflater;
@@ -23,8 +26,6 @@
 import android.widget.TextView;
 import javax.inject.Inject;
 
-import static android.view.Gravity.CENTER;
-
 public class HomeFragment extends Fragment {
   @Inject ActivityTitleController titleController;
 
diff --git a/examples/android-simple/pom.xml b/examples/android-simple/pom.xml
index fff3de566..75183cdef 100644
--- a/examples/android-simple/pom.xml
+++ b/examples/android-simple/pom.xml
@@ -1,6 +1,6 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <!--
- Copyright (C) 2013 Square, Inc.
+ Copyright (C) 2013 The Dagger Authors.
 
   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.google.dagger.example</groupId>
     <artifactId>dagger-example-parent</artifactId>
-    <version>2.5-SNAPSHOT</version>
+    <version>HEAD-SNAPSHOT</version>
   </parent>
 
   <artifactId>android-simple</artifactId>
@@ -36,12 +36,10 @@
     <dependency>
       <groupId>com.google.dagger</groupId>
       <artifactId>dagger</artifactId>
-      <version>${project.version}</version>
     </dependency>
     <dependency>
       <groupId>com.google.dagger</groupId>
       <artifactId>dagger-compiler</artifactId>
-      <version>${project.version}</version>
       <scope>provided</scope>
       <optional>true</optional>
     </dependency>
diff --git a/examples/android-simple/src/main/java/com/example/dagger/simple/AndroidModule.java b/examples/android-simple/src/main/java/com/example/dagger/simple/AndroidModule.java
index 18184d164..574fa727c 100644
--- a/examples/android-simple/src/main/java/com/example/dagger/simple/AndroidModule.java
+++ b/examples/android-simple/src/main/java/com/example/dagger/simple/AndroidModule.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013 Square, Inc.
+ * Copyright (C) 2013 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,16 +13,17 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package com.example.dagger.simple;
 
+import static android.content.Context.LOCATION_SERVICE;
+
 import android.content.Context;
 import android.location.LocationManager;
 import dagger.Module;
 import dagger.Provides;
 import javax.inject.Singleton;
 
-import static android.content.Context.LOCATION_SERVICE;
-
 /**
  * A module for Android-specific dependencies which require a {@link Context} or
  * {@link android.app.Application} to create.
diff --git a/examples/android-simple/src/main/java/com/example/dagger/simple/DemoActivity.java b/examples/android-simple/src/main/java/com/example/dagger/simple/DemoActivity.java
index aa09f2d0a..4847b101c 100644
--- a/examples/android-simple/src/main/java/com/example/dagger/simple/DemoActivity.java
+++ b/examples/android-simple/src/main/java/com/example/dagger/simple/DemoActivity.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013 Square, Inc.
+ * Copyright (C) 2013 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package com.example.dagger.simple;
 
 import android.app.Activity;
diff --git a/examples/android-simple/src/main/java/com/example/dagger/simple/DemoApplication.java b/examples/android-simple/src/main/java/com/example/dagger/simple/DemoApplication.java
index 55402c654..d6b3868f5 100644
--- a/examples/android-simple/src/main/java/com/example/dagger/simple/DemoApplication.java
+++ b/examples/android-simple/src/main/java/com/example/dagger/simple/DemoApplication.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013 Square, Inc.
+ * Copyright (C) 2013 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,14 +13,13 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package com.example.dagger.simple;
 
 import android.app.Application;
 import android.location.LocationManager;
 import com.example.dagger.simple.ui.HomeActivity;
 import dagger.Component;
-import java.util.Arrays;
-import java.util.List;
 import javax.inject.Inject;
 import javax.inject.Singleton;
 
diff --git a/examples/android-simple/src/main/java/com/example/dagger/simple/ForApplication.java b/examples/android-simple/src/main/java/com/example/dagger/simple/ForApplication.java
index 84d224740..517843efd 100644
--- a/examples/android-simple/src/main/java/com/example/dagger/simple/ForApplication.java
+++ b/examples/android-simple/src/main/java/com/example/dagger/simple/ForApplication.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013 Square, Inc.
+ * Copyright (C) 2013 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,13 +13,14 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package com.example.dagger.simple;
 
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
 import java.lang.annotation.Retention;
 import javax.inject.Qualifier;
 
-import static java.lang.annotation.RetentionPolicy.RUNTIME;
-
 @Qualifier @Retention(RUNTIME)
 public @interface ForApplication {
 }
diff --git a/examples/android-simple/src/main/java/com/example/dagger/simple/ui/HomeActivity.java b/examples/android-simple/src/main/java/com/example/dagger/simple/ui/HomeActivity.java
index 7e33b8eec..f0669c61d 100644
--- a/examples/android-simple/src/main/java/com/example/dagger/simple/ui/HomeActivity.java
+++ b/examples/android-simple/src/main/java/com/example/dagger/simple/ui/HomeActivity.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013 Square, Inc.
+ * Copyright (C) 2013 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package com.example.dagger.simple.ui;
 
 import android.location.LocationManager;
diff --git a/examples/pom.xml b/examples/pom.xml
index d5d04b3ce..bbf1becec 100644
--- a/examples/pom.xml
+++ b/examples/pom.xml
@@ -1,7 +1,6 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <!--
- Copyright (C) 2013 Google, Inc.
- Copyright (C) 2013 Square, Inc.
+  Copyright (C) 2013 The Dagger Authors.
 
   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
@@ -21,7 +20,7 @@
   <parent>
     <groupId>com.google.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>2.5-SNAPSHOT</version>
+    <version>HEAD-SNAPSHOT</version>
   </parent>
 
   <groupId>com.google.dagger.example</groupId>
@@ -48,6 +47,16 @@
         <artifactId>support-v4</artifactId>
         <version>r7</version>
       </dependency>
+      <dependency>
+        <groupId>com.google.dagger</groupId>
+        <artifactId>dagger</artifactId>
+        <version>${project.version}</version>
+      </dependency>
+      <dependency>
+        <groupId>com.google.dagger</groupId>
+        <artifactId>dagger-compiler</artifactId>
+        <version>${project.version}</version>
+      </dependency>
     </dependencies>
   </dependencyManagement>
 
@@ -67,7 +76,7 @@
           <version>4.3.0</version>
           <configuration>
             <sdk>
-              <platform>23</platform>
+              <platform>${android.latest.version}</platform>
               <path>${env.ANDROID_HOME}</path>
             </sdk>
           </configuration>
diff --git a/examples/simple/pom.xml b/examples/simple/pom.xml
index f9bd69295..145c5e22b 100644
--- a/examples/simple/pom.xml
+++ b/examples/simple/pom.xml
@@ -1,6 +1,6 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <!--
- Copyright (C) 2012 Square, Inc.
+  Copyright (C) 2012 The Dagger Authors.
 
   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.google.dagger.example</groupId>
     <artifactId>dagger-example-parent</artifactId>
-    <version>2.5-SNAPSHOT</version>
+    <version>HEAD-SNAPSHOT</version>
   </parent>
 
   <artifactId>simple</artifactId>
@@ -35,12 +35,10 @@
     <dependency>
       <groupId>com.google.dagger</groupId>
       <artifactId>dagger</artifactId>
-      <version>${project.version}</version>
     </dependency>
     <dependency>
       <groupId>com.google.dagger</groupId>
       <artifactId>dagger-compiler</artifactId>
-      <version>${project.version}</version>
       <optional>true</optional>
     </dependency>
   </dependencies>
diff --git a/examples/simple/src/main/java/coffee/PumpModule.java b/examples/simple/src/main/java/coffee/PumpModule.java
index 338ad33c2..df00b8624 100644
--- a/examples/simple/src/main/java/coffee/PumpModule.java
+++ b/examples/simple/src/main/java/coffee/PumpModule.java
@@ -1,11 +1,10 @@
 package coffee;
 
+import dagger.Binds;
 import dagger.Module;
-import dagger.Provides;
 
 @Module
-class PumpModule {
-  @Provides Pump providePump(Thermosiphon pump) {
-    return pump;
-  }
+abstract class PumpModule {
+  @Binds
+  abstract Pump providePump(Thermosiphon pump);
 }
diff --git a/gwt/pom.xml b/gwt/pom.xml
index 06d031fb7..a182efe64 100644
--- a/gwt/pom.xml
+++ b/gwt/pom.xml
@@ -1,6 +1,6 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <!--
- Copyright (C) 2015 Google, Inc.
+ Copyright (C) 2015 The Dagger Authors.
 
   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
@@ -22,7 +22,7 @@
   <parent>
     <groupId>com.google.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>2.5-SNAPSHOT</version>
+    <version>HEAD-SNAPSHOT</version>
   </parent>
 
   <artifactId>dagger-gwt</artifactId>
@@ -30,49 +30,20 @@
 
   <dependencies>
     <dependency>
-      <groupId>com.google.dagger</groupId>
+      <groupId>${project.groupId}</groupId>
       <artifactId>dagger</artifactId>
       <version>${project.version}</version>
     </dependency>
     <dependency>
-      <groupId>com.google.dagger</groupId>
+      <groupId>${project.groupId}</groupId>
       <artifactId>dagger</artifactId>
+      <classifier>sources</classifier>
       <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>javax.inject</groupId>
+      <artifactId>javax.inject</artifactId>
       <classifier>sources</classifier>
     </dependency>
   </dependencies>
-
-  <build>
-    <plugins>
-      <!--
-        Include JSR 330 sources in dagger-gwt to avoid implicit
-        compilation warnings in downstream projects.
-      -->
-      <plugin>
-        <artifactId>maven-dependency-plugin</artifactId>
-        <version>2.10</version>
-        <executions>
-          <execution>
-            <id>unpack-jsr330-sources</id>
-            <goals>
-              <goal>unpack</goal>
-            </goals>
-            <configuration>
-              <artifactItems>
-                <artifactItem>
-                  <groupId>javax.inject</groupId>
-                  <artifactId>javax.inject</artifactId>
-                  <version>${javax.inject.version}</version>
-                  <type>java-source</type>
-                  <overWrite>true</overWrite>
-                  <outputDirectory>${project.build.outputDirectory}/dagger/super/</outputDirectory>
-                </artifactItem>
-              </artifactItems>
-            </configuration>
-          </execution>
-        </executions>
-      </plugin>
-    </plugins>
-  </build>
-
 </project>
diff --git a/gwt/src/main/resources/dagger/Dagger.gwt.xml b/gwt/src/main/resources/dagger/Dagger.gwt.xml
index f81c5c00c..ad106fd22 100644
--- a/gwt/src/main/resources/dagger/Dagger.gwt.xml
+++ b/gwt/src/main/resources/dagger/Dagger.gwt.xml
@@ -1,5 +1,5 @@
 <!--
- Copyright (C) 2015 Google, Inc.
+  Copyright (C) 2015 The Dagger Authors.
 
   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
@@ -14,6 +14,7 @@
   limitations under the License.
 -->
 <module>
+  <inherits name="javax.inject.Inject" />
+
   <source path=""/>
-  <super-source path="super"/>
 </module>
diff --git a/gwt/src/main/resources/javax/inject/Inject.gwt.xml b/gwt/src/main/resources/javax/inject/Inject.gwt.xml
new file mode 100644
index 000000000..b6349264f
--- /dev/null
+++ b/gwt/src/main/resources/javax/inject/Inject.gwt.xml
@@ -0,0 +1,18 @@
+<!--
+ Copyright (C) 2017 The Dagger Authors.
+
+  Licensed under the Apache License, Version 2.0 (the "License");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<module>
+  <source path=""/>
+</module>
diff --git a/java/dagger/android/ActivityKey.java b/java/dagger/android/ActivityKey.java
new file mode 100644
index 000000000..2fe7aeeee
--- /dev/null
+++ b/java/dagger/android/ActivityKey.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android;
+
+import static java.lang.annotation.ElementType.METHOD;
+
+import android.app.Activity;
+import dagger.MapKey;
+import dagger.internal.Beta;
+import java.lang.annotation.Target;
+
+/** {@link MapKey} annotation to key bindings by a type of an {@link Activity}. */
+@Beta
+@MapKey
+@Target(METHOD)
+public @interface ActivityKey {
+  Class<? extends Activity> value();
+}
diff --git a/java/dagger/android/AndroidInjection.java b/java/dagger/android/AndroidInjection.java
new file mode 100644
index 000000000..990bd9208
--- /dev/null
+++ b/java/dagger/android/AndroidInjection.java
@@ -0,0 +1,186 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android;
+
+import static dagger.internal.Preconditions.checkNotNull;
+
+import android.app.Activity;
+import android.app.Application;
+import android.app.Fragment;
+import android.app.Service;
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.util.Log;
+import dagger.internal.Beta;
+
+/** Injects core Android types. */
+@Beta
+public final class AndroidInjection {
+  private static final String TAG = "dagger.android";
+
+  /**
+   * Injects {@code activity} if an associated {@link AndroidInjector.Factory} implementation can be
+   * found, otherwise throws an {@link IllegalArgumentException}.
+   *
+   * @throws RuntimeException if the {@link Application} doesn't implement {@link
+   *     HasDispatchingActivityInjector}, or if no {@code AndroidInjector.Factory<? extends
+   *     Activity>} is bound for {@code activity}.
+   */
+  public static void inject(Activity activity) {
+    checkNotNull(activity, "activity");
+    Application application = activity.getApplication();
+    if (!(application instanceof HasDispatchingActivityInjector)) {
+      throw new RuntimeException(
+          String.format(
+              "%s does not implement %s",
+              application.getClass().getCanonicalName(),
+              HasDispatchingActivityInjector.class.getCanonicalName()));
+    }
+
+    DispatchingAndroidInjector<Activity> activityInjector =
+        ((HasDispatchingActivityInjector) application).activityInjector();
+    checkNotNull(
+        activityInjector,
+        "%s.activityInjector() returned null",
+        application.getClass().getCanonicalName());
+
+    activityInjector.inject(activity);
+  }
+
+  /**
+   * Injects {@code fragment} if an associated {@link AndroidInjector.Factory} implementation can be
+   * found, otherwise throws an {@link IllegalArgumentException}.
+   *
+   * <p>Uses the following algorithm to find the appropriate {@code
+   * DispatchingAndroidInjector<Fragment>} to inject {@code fragment}:
+   *
+   * <ol>
+   *   <li>Walks the parent-fragment hierarchy to find the a fragment that implements {@link
+   *       HasDispatchingFragmentInjector}, and if none do
+   *   <li>Uses the {@code fragment}'s {@link Fragment#getActivity() activity} if it implements
+   *       {@link HasDispatchingFragmentInjector}, and if not
+   *   <li>Uses the {@link android.app.Application} if it implements {@link
+   *       HasDispatchingFragmentInjector}.
+   * </ol>
+   *
+   * If none of them implement {@link HasDispatchingFragmentInjector}, a {@link
+   * IllegalArgumentException} is thrown.
+   *
+   * @throws IllegalArgumentException if no {@code AndroidInjector.Factory<? extends Fragment>} is
+   *     bound for {@code fragment}.
+   */
+  public static void inject(Fragment fragment) {
+    checkNotNull(fragment, "fragment");
+    HasDispatchingFragmentInjector hasDispatchingFragmentInjector =
+        findHasFragmentInjector(fragment);
+    Log.d(
+        TAG,
+        String.format(
+            "An injector for %s was found in %s",
+            fragment.getClass().getCanonicalName(),
+            hasDispatchingFragmentInjector.getClass().getCanonicalName()));
+
+    DispatchingAndroidInjector<Fragment> fragmentInjector =
+        hasDispatchingFragmentInjector.fragmentInjector();
+    checkNotNull(
+        fragmentInjector,
+        "%s.fragmentInjector() returned null",
+        hasDispatchingFragmentInjector.getClass().getCanonicalName());
+
+    fragmentInjector.inject(fragment);
+  }
+
+  private static HasDispatchingFragmentInjector findHasFragmentInjector(Fragment fragment) {
+    Fragment parentFragment = fragment;
+    while ((parentFragment = parentFragment.getParentFragment()) != null) {
+      if (parentFragment instanceof HasDispatchingFragmentInjector) {
+        return (HasDispatchingFragmentInjector) parentFragment;
+      }
+    }
+    Activity activity = fragment.getActivity();
+    if (activity instanceof HasDispatchingFragmentInjector) {
+      return (HasDispatchingFragmentInjector) activity;
+    }
+    if (activity.getApplication() instanceof HasDispatchingFragmentInjector) {
+      return (HasDispatchingFragmentInjector) activity.getApplication();
+    }
+    throw new IllegalArgumentException(
+        String.format("No injector was found for %s", fragment.getClass().getCanonicalName()));
+  }
+
+  /**
+   * Injects {@code service} if an associated {@link AndroidInjector.Factory} implementation can be
+   * found, otherwise throws an {@link IllegalArgumentException}.
+   *
+   * @throws RuntimeException if the {@link Application} doesn't implement {@link
+   *     HasDispatchingServiceInjector}, or if no {@code AndroidInjector.Factory<? extends Service>}
+   *     is bound for {@code service}.
+   */
+  public static void inject(Service service) {
+    checkNotNull(service, "service");
+    Application application = service.getApplication();
+    if (!(application instanceof HasDispatchingServiceInjector)) {
+      throw new RuntimeException(
+          String.format(
+              "%s does not implement %s",
+              application.getClass().getCanonicalName(),
+              HasDispatchingServiceInjector.class.getCanonicalName()));
+    }
+
+    DispatchingAndroidInjector<Service> serviceInjector =
+        ((HasDispatchingServiceInjector) application).serviceInjector();
+    checkNotNull(
+        serviceInjector,
+        "%s.serviceInjector() returned null",
+        application.getClass().getCanonicalName());
+
+    serviceInjector.inject(service);
+  }
+
+  /**
+   * Injects {@code broadcastReceiver} if an associated {@link AndroidInjector.Factory}
+   * implementation can be found, otherwise throws an {@link IllegalArgumentException}.
+   *
+   * @throws RuntimeException if the {@link Application} from {@link
+   *     Context#getApplicationContext()} doesn't implement {@link
+   *     HasDispatchingBroadcastReceiverInjector}, or if no {@code AndroidInjector.Factory<? extends
+   *     BroadcastReceiver>} is bound for {@code broadcastReceiver}.
+   */
+  public static void inject(BroadcastReceiver broadcastReceiver, Context context) {
+    checkNotNull(broadcastReceiver, "broadcastReceiver");
+    checkNotNull(context, "context");
+    Application application = (Application) context.getApplicationContext();
+    if (!(application instanceof HasDispatchingBroadcastReceiverInjector)) {
+      throw new RuntimeException(
+          String.format(
+              "%s does not implement %s",
+              application.getClass().getCanonicalName(),
+              HasDispatchingBroadcastReceiverInjector.class.getCanonicalName()));
+    }
+
+    DispatchingAndroidInjector<BroadcastReceiver> broadcastReceiverInjector =
+        ((HasDispatchingBroadcastReceiverInjector) application).broadcastReceiverInjector();
+    checkNotNull(
+        broadcastReceiverInjector,
+        "%s.broadcastReceiverInjector() returned null",
+        application.getClass().getCanonicalName());
+
+    broadcastReceiverInjector.inject(broadcastReceiver);
+  }
+
+  private AndroidInjection() {}
+}
diff --git a/java/dagger/android/AndroidInjectionModule.java b/java/dagger/android/AndroidInjectionModule.java
new file mode 100644
index 000000000..9fc359a6e
--- /dev/null
+++ b/java/dagger/android/AndroidInjectionModule.java
@@ -0,0 +1,54 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android;
+
+import android.app.Activity;
+import android.app.Fragment;
+import android.app.Service;
+import android.content.BroadcastReceiver;
+import dagger.Module;
+import dagger.internal.Beta;
+import dagger.multibindings.Multibinds;
+import java.util.Map;
+
+/**
+ * Contains bindings to ensure the usability of {@code dagger.android} framework classes. This
+ * module should be installed in the component that is used to inject the {@link
+ * android.app.Application} class.
+ */
+@Beta
+@Module
+public abstract class AndroidInjectionModule {
+  @Multibinds
+  abstract Map<Class<? extends Activity>, AndroidInjector.Factory<? extends Activity>>
+      activityInjectorFactories();
+
+  @Multibinds
+  abstract Map<Class<? extends Fragment>, AndroidInjector.Factory<? extends Fragment>>
+      fragmentInjectorFactories();
+
+  @Multibinds
+  abstract Map<Class<? extends Service>, AndroidInjector.Factory<? extends Service>>
+      serviceInjectorFactories();
+
+  @Multibinds
+  abstract Map<
+          Class<? extends BroadcastReceiver>, AndroidInjector.Factory<? extends BroadcastReceiver>>
+      broadcastReceiverInjectorFactories();
+
+  private AndroidInjectionModule() {}
+}
diff --git a/java/dagger/android/AndroidInjector.java b/java/dagger/android/AndroidInjector.java
new file mode 100644
index 000000000..3e05de68a
--- /dev/null
+++ b/java/dagger/android/AndroidInjector.java
@@ -0,0 +1,79 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android;
+
+import dagger.BindsInstance;
+import dagger.internal.Beta;
+
+/**
+ * Performs members-injection for a concrete subtype of a <a
+ * href="https://developer.android.com/guide/components/index.html">core Android type</a> (e.g.,
+ * {@link android.app.Activity} or {@link android.app.Fragment}).
+ *
+ * <p>Commonly implemented by {@link dagger.Subcomponent}-annotated types whose {@link
+ * dagger.Subcomponent.Builder} extends {@link Builder}.
+ *
+ * @param <T> a concrete subtype of a core Android type
+ * @see AndroidInjection
+ * @see DispatchingAndroidInjector
+ */
+@Beta
+public interface AndroidInjector<T> {
+
+  /** Injects the members of {@code instance}. */
+  void inject(T instance);
+
+  /**
+   * Creates {@link AndroidInjector}s for a concrete subtype of a core Android type.
+   *
+   * @param <T> the concrete type to be injected
+   */
+  interface Factory<T> {
+    /**
+     * Creates an {@link AndroidInjector} for {@code instance}. This should be the same instance
+     * that will be passed to {@link #inject(Object)}.
+     */
+    AndroidInjector<T> create(T instance);
+  }
+
+  /**
+   * An adapter that lets the common {@link dagger.Subcomponent.Builder} pattern implement {@link
+   * Factory}.
+   *
+   * @param <T> the concrete type to be injected
+   */
+  abstract class Builder<T> implements AndroidInjector.Factory<T> {
+    @Override
+    public final AndroidInjector<T> create(T instance) {
+      seedInstance(instance);
+      return build();
+    }
+
+    /**
+     * Provides {@code instance} to be used in the binding graph of the built {@link
+     * AndroidInjector}. By default, this is used as a {@link BindsInstance} method, but it may be
+     * overridden to provide any modules which need a reference to the activity.
+     *
+     * <p>This should be the same instance that will be passed to {@link #inject(Object)}.
+     */
+    @BindsInstance
+    public abstract void seedInstance(T instance);
+
+    /** Returns a newly-constructed {@link AndroidInjector}. */
+    public abstract AndroidInjector<T> build();
+  }
+}
diff --git a/java/dagger/android/AndroidManifest.xml b/java/dagger/android/AndroidManifest.xml
new file mode 100644
index 000000000..f071b6018
--- /dev/null
+++ b/java/dagger/android/AndroidManifest.xml
@@ -0,0 +1,19 @@
+<!--
+ Copyright (C) 2016 The Dagger Authors.
+
+  Licensed under the Apache License, Version 2.0 (the "License");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="dagger.android">
+  <uses-sdk android:minSdkVersion="14" />
+</manifest>
diff --git a/java/dagger/android/AndroidMemorySensitiveReferenceManager.java b/java/dagger/android/AndroidMemorySensitiveReferenceManager.java
new file mode 100644
index 000000000..015c71991
--- /dev/null
+++ b/java/dagger/android/AndroidMemorySensitiveReferenceManager.java
@@ -0,0 +1,74 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android;
+
+import dagger.internal.Beta;
+import dagger.internal.GwtIncompatible;
+import dagger.releasablereferences.TypedReleasableReferenceManager;
+import java.util.Set;
+import javax.inject.Inject;
+
+/**
+ * Releases references in {@link ReleaseReferencesAt} {@linkplain javax.inject.Scope scopes} in
+ * low-memory conditions.
+ *
+ * <p>In order to release references in low-memory conditions, inject an {@code
+ * AndroidMemorySensitiveReferenceManager} into your {@link android.app.Application} and delegate
+ * {@link android.app.Application#onTrimMemory(int)} to it.
+ *
+ * <p>For example:
+ *
+ * <pre>
+ *   class MyApplication extends Application {
+ *     {@literal @Inject} AndroidMemorySensitiveReferenceManager manager;
+ *
+ *     public void onTrimMemory(int level) {
+ *       manager.onTrimMemory(level);
+ *     }
+ *   }</pre>
+ *
+ * @since 2.8
+ */
+@Beta
+@GwtIncompatible
+public final class AndroidMemorySensitiveReferenceManager {
+
+  private final Set<TypedReleasableReferenceManager<ReleaseReferencesAt>> managers;
+
+  @Inject
+  AndroidMemorySensitiveReferenceManager(
+      Set<TypedReleasableReferenceManager<ReleaseReferencesAt>> managers) {
+    this.managers = managers;
+  }
+
+  /**
+   * Releases references for {@link ReleaseReferencesAt} scopes whose {@link
+   * ReleaseReferencesAt#value()} is less than or equal to {@code level}. Restores references for
+   * scopes whose {@link ReleaseReferencesAt#value()} is greater than {@code level}.
+   *
+   * @see android.app.Application#onTrimMemory(int)
+   */
+  public void onTrimMemory(int level) {
+    for (TypedReleasableReferenceManager<ReleaseReferencesAt> manager : managers) {
+      if (level >= manager.metadata().value()) {
+        manager.releaseStrongReferences();
+      } else {
+        manager.restoreStrongReferences();
+      }
+    }
+  }
+}
diff --git a/java/dagger/android/BUILD b/java/dagger/android/BUILD
new file mode 100644
index 000000000..8752b5ba9
--- /dev/null
+++ b/java/dagger/android/BUILD
@@ -0,0 +1,53 @@
+# Copyright (C) 2017 The Dagger Authors.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+# Description:
+#   Public Dagger API for Android
+
+package(default_visibility = ["//:src"])
+
+load(
+    "//:build_defs.bzl",
+    "DOCLINT_HTML_AND_SYNTAX",
+    "DOCLINT_REFERENCES",
+    "SOURCE_7_TARGET_7",
+    "PRE_JAVA_8_INFERENCE_OPTS",
+)
+
+filegroup(
+    name = "android-srcs",
+    srcs = glob(["*.java"]),
+)
+
+android_library(
+    name = "android",
+    srcs = [":android-srcs"],
+    javacopts = PRE_JAVA_8_INFERENCE_OPTS + SOURCE_7_TARGET_7 + DOCLINT_HTML_AND_SYNTAX + DOCLINT_REFERENCES,
+    manifest = "AndroidManifest.xml",
+    deps = [
+        "//:dagger_with_compiler",
+        "//third_party:auto_value",
+        "@androidsdk//com.android.support:support-annotations-25.0.0",
+    ],
+)
+
+load("//tools:javadoc.bzl", "javadoc_library")
+
+javadoc_library(
+    name = "android-javadoc",
+    srcs = [":android-srcs"],
+    android_api_level = 25,
+    root_packages = ["dagger.android"],
+    deps = [":android"],
+)
diff --git a/java/dagger/android/BroadcastReceiverKey.java b/java/dagger/android/BroadcastReceiverKey.java
new file mode 100644
index 000000000..942577ac1
--- /dev/null
+++ b/java/dagger/android/BroadcastReceiverKey.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android;
+
+import static java.lang.annotation.ElementType.METHOD;
+
+import android.content.BroadcastReceiver;
+import dagger.MapKey;
+import dagger.internal.Beta;
+import java.lang.annotation.Target;
+
+/** {@link MapKey} annotation to key bindings by a type of a {@link BroadcastReceiver}. */
+@Beta
+@MapKey
+@Target(METHOD)
+public @interface BroadcastReceiverKey {
+  Class<? extends BroadcastReceiver> value();
+}
diff --git a/java/dagger/android/DaggerActivity.java b/java/dagger/android/DaggerActivity.java
new file mode 100644
index 000000000..f08c02a7b
--- /dev/null
+++ b/java/dagger/android/DaggerActivity.java
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android;
+
+import android.app.Activity;
+import android.app.Fragment;
+import android.os.Bundle;
+import dagger.internal.Beta;
+import javax.inject.Inject;
+
+/**
+ * An {@link Activity} that injects its members in {@link #onCreate(Bundle)} and can be used to
+ * inject {@link Fragment}s attached to it.
+ */
+@Beta
+public abstract class DaggerActivity extends Activity implements HasDispatchingFragmentInjector {
+
+  @Inject DispatchingAndroidInjector<Fragment> fragmentInjector;
+
+  @Override
+  protected void onCreate(Bundle savedInstanceState) {
+    AndroidInjection.inject(this);
+    super.onCreate(savedInstanceState);
+  }
+
+  @Override
+  public DispatchingAndroidInjector<Fragment> fragmentInjector() {
+    return fragmentInjector;
+  }
+}
diff --git a/java/dagger/android/DaggerBroadcastReceiver.java b/java/dagger/android/DaggerBroadcastReceiver.java
new file mode 100644
index 000000000..601c5a31e
--- /dev/null
+++ b/java/dagger/android/DaggerBroadcastReceiver.java
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android;
+
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.support.annotation.CallSuper;
+
+/**
+ * A {@link BroadcastReceiver} that injects its members in the first call to {@link
+ * #onReceive(Context, Intent)}.
+ *
+ * <p>This class should only be used for {@link BroadcastReceiver}s that are declared in an {@code
+ * AndroidManifest.xml}. If, instead, the {@link BroadcastReceiver} is created in code, prefer
+ * constructor injection.
+ *
+ * <p>Note: this class is <em>not thread safe</em> and should not be used with multiple {@link
+ * android.os.Handler}s in calls to {@link Context#registerReceiver(BroadcastReceiver,
+ * android.content.IntentFilter, String, android.os.Handler)}. Injection is performed on each
+ * invocation to {@link #onReceive(Context, Intent)} which could result in inconsistent views of
+ * injected dependencies across threads.
+ *
+ * <p>Subclasses should override {@link #onReceive(Context, Intent)} and call {@code
+ * super.onReceive(context, intent)} immediately to ensure injection is performed immediately.
+ */
+public abstract class DaggerBroadcastReceiver extends BroadcastReceiver {
+  @CallSuper
+  @Override
+  public void onReceive(Context context, Intent intent) {
+    AndroidInjection.inject(this, context);
+  }
+}
diff --git a/java/dagger/android/DaggerFragment.java b/java/dagger/android/DaggerFragment.java
new file mode 100644
index 000000000..d7b552f76
--- /dev/null
+++ b/java/dagger/android/DaggerFragment.java
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android;
+
+import android.app.Fragment;
+import android.content.Context;
+import dagger.internal.Beta;
+import javax.inject.Inject;
+
+/**
+ * A {@link Fragment} that injects its members in {@link #onAttach(Context)} and can be used to
+ * inject child {@link Fragment}s attached to it. Note that when this fragment gets reattached, its
+ * members will be injected again.
+ */
+@Beta
+public abstract class DaggerFragment extends Fragment implements HasDispatchingFragmentInjector {
+
+  @Inject DispatchingAndroidInjector<Fragment> childFragmentInjector;
+
+  @Override
+  public void onAttach(Context context) {
+    AndroidInjection.inject(this);
+    super.onAttach(context);
+  }
+
+  @Override
+  public DispatchingAndroidInjector<Fragment> fragmentInjector() {
+    return childFragmentInjector;
+  }
+}
diff --git a/java/dagger/android/DaggerIntentService.java b/java/dagger/android/DaggerIntentService.java
new file mode 100644
index 000000000..865d18948
--- /dev/null
+++ b/java/dagger/android/DaggerIntentService.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android;
+
+import android.app.IntentService;
+
+/** An {@link IntentService} that injects its members in {@link #onCreate()}. */
+public abstract class DaggerIntentService extends IntentService {
+  public DaggerIntentService(String name) {
+    super(name);
+  }
+
+  @Override
+  public void onCreate() {
+    AndroidInjection.inject(this);
+    super.onCreate();
+  }
+}
diff --git a/java/dagger/android/DaggerService.java b/java/dagger/android/DaggerService.java
new file mode 100644
index 000000000..8b37c1b76
--- /dev/null
+++ b/java/dagger/android/DaggerService.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android;
+
+import android.app.Service;
+
+/** A {@link Service} that injects its members in {@link #onCreate()}. */
+public abstract class DaggerService extends Service {
+  @Override
+  public void onCreate() {
+    AndroidInjection.inject(this);
+    super.onCreate();
+  }
+}
diff --git a/java/dagger/android/DispatchingAndroidInjector.java b/java/dagger/android/DispatchingAndroidInjector.java
new file mode 100644
index 000000000..b22f6ecd4
--- /dev/null
+++ b/java/dagger/android/DispatchingAndroidInjector.java
@@ -0,0 +1,134 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android;
+
+import static dagger.internal.Preconditions.checkNotNull;
+
+import android.app.Activity;
+import android.app.Fragment;
+import dagger.internal.Beta;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import java.util.Map;
+import javax.inject.Inject;
+import javax.inject.Provider;
+
+/**
+ * Performs members-injection on instances of core Android types (e.g. {@link Activity}, {@link
+ * Fragment}) that are constructed by the Android framework and not by Dagger. This class relies on
+ * an injected mapping from each concrete class to an {@link AndroidInjector.Factory} for an {@link
+ * AndroidInjector} of that class. Each concrete class must have its own entry in the map, even if
+ * it extends another class which is already present in the map. Calls {@link Object#getClass()} on
+ * the instance in order to find the appropriate {@link AndroidInjector.Factory}.
+ *
+ * @param <T> the core Android type to be injected
+ */
+@Beta
+public final class DispatchingAndroidInjector<T> {
+  private static final String NO_SUPERTYPES_BOUND_FORMAT =
+      "No injector factory bound for Class<%s>";
+  private static final String SUPERTYPES_BOUND_FORMAT =
+      "No injector factory bound for Class<%1$s>. Injector factories were bound for supertypes "
+          + "of %1$s: %2$s. Did you mean to bind an injector factory for the subtype?";
+
+  private final Map<Class<? extends T>, Provider<AndroidInjector.Factory<? extends T>>>
+      injectorFactories;
+
+  @Inject
+  DispatchingAndroidInjector(
+      Map<Class<? extends T>, Provider<AndroidInjector.Factory<? extends T>>> injectorFactories) {
+    this.injectorFactories = injectorFactories;
+  }
+
+  /**
+   * Attempts to perform members-injection on {@code instance}, returning {@code true} if
+   * successful, {@code false} otherwise.
+   *
+   * @throws InvalidInjectorBindingException if the injector factory bound for a class does not
+   *     inject instances of that class
+   */
+  public boolean maybeInject(T instance) {
+    Provider<AndroidInjector.Factory<? extends T>> factoryProvider =
+        injectorFactories.get(instance.getClass());
+    if (factoryProvider == null) {
+      return false;
+    }
+
+    @SuppressWarnings("unchecked")
+    AndroidInjector.Factory<T> factory = (AndroidInjector.Factory<T>) factoryProvider.get();
+    try {
+      AndroidInjector<T> injector =
+          checkNotNull(
+              factory.create(instance),
+              "%s.create(I) should not return null.",
+              factory.getClass().getCanonicalName());
+
+      injector.inject(instance);
+      return true;
+    } catch (ClassCastException e) {
+      throw new InvalidInjectorBindingException(
+          String.format(
+              "%s does not implement AndroidInjector.Factory<%s>",
+              factory.getClass().getCanonicalName(), instance.getClass().getCanonicalName()),
+          e);
+    }
+  }
+
+  /**
+   * Performs members-injection on {@code instance}.
+   *
+   * @throws InvalidInjectorBindingException if the injector factory bound for a class does not
+   *     inject instances of that class
+   * @throws IllegalArgumentException if no {@link AndroidInjector.Factory} is bound for {@code
+   *     instance}
+   */
+  public void inject(T instance) {
+    boolean wasInjected = maybeInject(instance);
+    if (!wasInjected) {
+      throw new IllegalArgumentException(errorMessageSuggestions(instance));
+    }
+  }
+
+  /**
+   * Exception thrown if an incorrect binding is made for a {@link AndroidInjector.Factory}. If you
+   * see this exception, make sure the value in your {@code @ActivityKey(YourActivity.class)} or
+   * {@code @FragmentKey(YourFragment.class)} matches the type argument of the injector factory.
+   */
+  @Beta
+  public static final class InvalidInjectorBindingException extends RuntimeException {
+    InvalidInjectorBindingException(String message, ClassCastException cause) {
+      super(message, cause);
+    }
+  }
+
+  /** Returns an error message with the class names that are supertypes of {@code instance}. */
+  private String errorMessageSuggestions(T instance) {
+    List<String> suggestions = new ArrayList<String>();
+    for (Class<? extends T> activityClass : injectorFactories.keySet()) {
+      if (activityClass.isInstance(instance)) {
+        suggestions.add(activityClass.getCanonicalName());
+      }
+    }
+    Collections.sort(suggestions);
+
+    return String.format(
+        suggestions.isEmpty() ? NO_SUPERTYPES_BOUND_FORMAT : SUPERTYPES_BOUND_FORMAT,
+        instance.getClass().getCanonicalName(),
+        suggestions);
+  }
+}
diff --git a/java/dagger/android/FragmentKey.java b/java/dagger/android/FragmentKey.java
new file mode 100644
index 000000000..5f27e3f01
--- /dev/null
+++ b/java/dagger/android/FragmentKey.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android;
+
+import static java.lang.annotation.ElementType.METHOD;
+
+import android.app.Fragment;
+import dagger.MapKey;
+import dagger.internal.Beta;
+import java.lang.annotation.Target;
+
+/** {@link MapKey} annotation to key bindings by a type of a {@link Fragment}. */
+@Beta
+@MapKey
+@Target(METHOD)
+public @interface FragmentKey {
+  Class<? extends Fragment> value();
+}
diff --git a/java/dagger/android/HasDispatchingActivityInjector.java b/java/dagger/android/HasDispatchingActivityInjector.java
new file mode 100644
index 000000000..680139d89
--- /dev/null
+++ b/java/dagger/android/HasDispatchingActivityInjector.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android;
+
+import android.app.Activity;
+import dagger.internal.Beta;
+
+/** Provides a {@link DispatchingAndroidInjector} of {@link Activity}s. */
+@Beta
+public interface HasDispatchingActivityInjector {
+
+  /** Returns a {@link DispatchingAndroidInjector} of {@link Activity}s. */
+  DispatchingAndroidInjector<Activity> activityInjector();
+}
diff --git a/java/dagger/android/HasDispatchingBroadcastReceiverInjector.java b/java/dagger/android/HasDispatchingBroadcastReceiverInjector.java
new file mode 100644
index 000000000..aa21d3e10
--- /dev/null
+++ b/java/dagger/android/HasDispatchingBroadcastReceiverInjector.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android;
+
+import android.content.BroadcastReceiver;
+import dagger.internal.Beta;
+
+/** Provides a {@link DispatchingAndroidInjector} of {@link BroadcastReceiver}s. */
+@Beta
+public interface HasDispatchingBroadcastReceiverInjector {
+
+  /** Returns a {@link DispatchingAndroidInjector} of {@link BroadcastReceiver}s. */
+  DispatchingAndroidInjector<BroadcastReceiver> broadcastReceiverInjector();
+}
diff --git a/java/dagger/android/HasDispatchingFragmentInjector.java b/java/dagger/android/HasDispatchingFragmentInjector.java
new file mode 100644
index 000000000..f7d223a76
--- /dev/null
+++ b/java/dagger/android/HasDispatchingFragmentInjector.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android;
+
+import android.app.Fragment;
+import dagger.internal.Beta;
+
+/** Provides a {@link DispatchingAndroidInjector} of {@link Fragment}s. */
+@Beta
+public interface HasDispatchingFragmentInjector {
+
+  /** Returns a {@link DispatchingAndroidInjector} of {@link Fragment}s. */
+  DispatchingAndroidInjector<Fragment> fragmentInjector();
+}
diff --git a/java/dagger/android/HasDispatchingServiceInjector.java b/java/dagger/android/HasDispatchingServiceInjector.java
new file mode 100644
index 000000000..b25dd77bf
--- /dev/null
+++ b/java/dagger/android/HasDispatchingServiceInjector.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android;
+
+import android.app.Service;
+import dagger.internal.Beta;
+
+/** Provides a {@link DispatchingAndroidInjector} of {@link Service}s. */
+@Beta
+public interface HasDispatchingServiceInjector {
+
+  /** Returns a {@link DispatchingAndroidInjector} of {@link Service}s. */
+  DispatchingAndroidInjector<Service> serviceInjector();
+}
diff --git a/java/dagger/android/OnTrimMemoryValue.java b/java/dagger/android/OnTrimMemoryValue.java
new file mode 100644
index 000000000..041ca422f
--- /dev/null
+++ b/java/dagger/android/OnTrimMemoryValue.java
@@ -0,0 +1,50 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android;
+
+import static android.content.ComponentCallbacks2.TRIM_MEMORY_BACKGROUND;
+import static android.content.ComponentCallbacks2.TRIM_MEMORY_COMPLETE;
+import static android.content.ComponentCallbacks2.TRIM_MEMORY_MODERATE;
+import static android.content.ComponentCallbacks2.TRIM_MEMORY_RUNNING_CRITICAL;
+import static android.content.ComponentCallbacks2.TRIM_MEMORY_RUNNING_LOW;
+import static android.content.ComponentCallbacks2.TRIM_MEMORY_RUNNING_MODERATE;
+import static android.content.ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN;
+import static java.lang.annotation.RetentionPolicy.SOURCE;
+
+import android.content.ComponentCallbacks2;
+import android.support.annotation.IntDef;
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+
+/**
+ * Annotates an integer element to indicate that its value should be one of the constants defined in
+ * {@link ComponentCallbacks2}.
+ *
+ * @since 2.8
+ */
+@Documented
+@Retention(SOURCE)
+@IntDef({
+  TRIM_MEMORY_BACKGROUND,
+  TRIM_MEMORY_COMPLETE,
+  TRIM_MEMORY_MODERATE,
+  TRIM_MEMORY_RUNNING_CRITICAL,
+  TRIM_MEMORY_RUNNING_LOW,
+  TRIM_MEMORY_RUNNING_MODERATE,
+  TRIM_MEMORY_UI_HIDDEN
+})
+@interface OnTrimMemoryValue {}
diff --git a/java/dagger/android/ReleaseReferencesAt.java b/java/dagger/android/ReleaseReferencesAt.java
new file mode 100644
index 000000000..e978d8f10
--- /dev/null
+++ b/java/dagger/android/ReleaseReferencesAt.java
@@ -0,0 +1,65 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android;
+
+import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
+
+import dagger.internal.Beta;
+import dagger.internal.GwtIncompatible;
+import dagger.releasablereferences.CanReleaseReferences;
+import java.lang.annotation.Documented;
+import java.lang.annotation.Target;
+
+/**
+ * Annotates {@linkplain javax.inject.Scope scopes} to associate them with a low-memory threshold
+ * level, as described in {@link android.app.Application#onTrimMemory(int)}.
+ *
+ * <p>For example:
+ *
+ * <pre>
+ *   {@literal @Documented}
+ *   {@literal @Retention}(RUNTIME)
+ *   {@literal @Target}({TYPE, METHOD})
+ *   {@literal @ReleaseReferencesAt}(TRIM_MEMORY_BACKGROUND)
+ *   {@literal @Scope}
+ *   public {@literal @interface} MyScope {}</pre>
+ *
+ * <p>Any scope annotated with {@code @ReleaseReferencesAt} can {@linkplain CanReleaseReferences
+ * release its references}.
+ *
+ * <p>In order to release references in low-memory conditions, inject an {@link
+ * AndroidMemorySensitiveReferenceManager} into your {@link android.app.Application} and delegate
+ * {@link android.app.Application#onTrimMemory(int)} to it.
+ *
+ * @since 2.8
+ */
+@Beta
+@Documented
+@GwtIncompatible
+@Target(ANNOTATION_TYPE)
+@CanReleaseReferences
+public @interface ReleaseReferencesAt {
+  /**
+   * If {@link AndroidMemorySensitiveReferenceManager#onTrimMemory(int)} is called with a value
+   * greater than or equal to this, the scope's references will be released. If it is called with a
+   * value less than this, the scope's references will be restored.
+   *
+   * <p>Use one of the constants defined in {@link android.content.ComponentCallbacks2}.
+   */
+  @OnTrimMemoryValue
+  int value();
+}
diff --git a/java/dagger/android/ServiceKey.java b/java/dagger/android/ServiceKey.java
new file mode 100644
index 000000000..1461a98e5
--- /dev/null
+++ b/java/dagger/android/ServiceKey.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android;
+
+import static java.lang.annotation.ElementType.METHOD;
+
+import android.app.Service;
+import dagger.MapKey;
+import dagger.internal.Beta;
+import java.lang.annotation.Target;
+
+/** {@link MapKey} annotation to key bindings by a type of a {@link Service}. */
+@Beta
+@MapKey
+@Target(METHOD)
+public @interface ServiceKey {
+  Class<? extends Service> value();
+}
diff --git a/java/dagger/android/processor/AndroidMapKeyValidator.java b/java/dagger/android/processor/AndroidMapKeyValidator.java
new file mode 100644
index 000000000..eedc504c0
--- /dev/null
+++ b/java/dagger/android/processor/AndroidMapKeyValidator.java
@@ -0,0 +1,199 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.processor;
+
+import static com.google.auto.common.AnnotationMirrors.getAnnotatedAnnotations;
+import static com.google.auto.common.AnnotationMirrors.getAnnotationValue;
+import static com.google.auto.common.MoreElements.getAnnotationMirror;
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
+import static com.google.common.collect.Iterables.getOnlyElement;
+import static java.util.stream.Collectors.toMap;
+import static javax.lang.model.util.ElementFilter.methodsIn;
+
+import com.google.auto.common.BasicAnnotationProcessor.ProcessingStep;
+import com.google.auto.common.MoreElements;
+import com.google.auto.common.MoreTypes;
+import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.SetMultimap;
+import dagger.Binds;
+import dagger.MapKey;
+import dagger.android.AndroidInjector;
+import java.lang.annotation.Annotation;
+import java.util.List;
+import java.util.Set;
+import java.util.stream.Stream;
+import javax.annotation.processing.Messager;
+import javax.inject.Qualifier;
+import javax.inject.Scope;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.type.WildcardType;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
+import javax.tools.Diagnostic.Kind;
+
+/**
+ * Validates the correctness of {@link dagger.MapKey}s in {@code dagger.android} and {@code
+ * dagger.android.support} methods.
+ */
+final class AndroidMapKeyValidator implements ProcessingStep {
+  private static final String LINK_TO_DOCS = "google.github.io/dagger/android";
+
+  private final Elements elements;
+  private final Types types;
+  private final Messager messager;
+  private final ImmutableMap<Class<? extends Annotation>, TypeMirror> annotationsAndFrameworkTypes;
+
+  AndroidMapKeyValidator(Elements elements, Types types, Messager messager) {
+    this.elements = elements;
+    this.types = types;
+    this.messager = messager;
+    this.annotationsAndFrameworkTypes = annotationsAndFrameworkTypes(elements);
+  }
+
+  private ImmutableMap<Class<? extends Annotation>, TypeMirror> annotationsAndFrameworkTypes(
+      Elements elements) {
+    return ImmutableMap.copyOf(
+        Stream.of(
+                elements.getPackageElement("dagger.android"),
+                elements.getPackageElement("dagger.android.support"))
+            .filter(element -> element != null)
+            .flatMap(element -> element.getEnclosedElements().stream())
+            .filter(element -> isAnnotationPresent(element, MapKey.class))
+            .filter(element -> element.getAnnotation(MapKey.class).unwrapValue())
+            .flatMap(AndroidMapKeyValidator::classForAnnotationElement)
+            .collect(toMap(key -> key, key -> mapKeyValue(key, elements))));
+  }
+
+  @SuppressWarnings("unchecked")
+  private static Stream<Class<? extends Annotation>> classForAnnotationElement(Element element) {
+    try {
+      return Stream.of((Class<? extends Annotation>)
+          Class.forName(MoreElements.asType(element).getQualifiedName().toString()));
+    } catch (ClassNotFoundException e) {
+      return Stream.of();
+    }
+  }
+
+  private static TypeMirror mapKeyValue(Class<? extends Annotation> annotation, Elements elements) {
+    List<ExecutableElement> mapKeyMethods =
+        methodsIn(elements.getTypeElement(annotation.getCanonicalName()).getEnclosedElements());
+    TypeMirror returnType = getOnlyElement(mapKeyMethods).getReturnType();
+    // TODO(ronshapiro): replace with MoreTypes.asWildcard() when auto-common 0.9 is released
+    return ((WildcardType) getOnlyElement(MoreTypes.asDeclared(returnType).getTypeArguments()))
+        .getExtendsBound();
+  }
+
+  @Override
+  public Set<? extends Class<? extends Annotation>> annotations() {
+    return annotationsAndFrameworkTypes.keySet();
+  }
+
+  @Override
+  public Set<Element> process(
+      SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
+    elementsByAnnotation.forEach(
+        (annotation, element) -> validateMethod(annotation, MoreElements.asExecutable(element)));
+    return ImmutableSet.of();
+  }
+
+  private void validateMethod(Class<? extends Annotation> annotation, ExecutableElement method) {
+    if (!getAnnotatedAnnotations(method, Qualifier.class).isEmpty()) {
+      return;
+    }
+
+    TypeMirror returnType = method.getReturnType();
+    if (!types.isAssignable(types.erasure(returnType), factoryElement().asType())) {
+      // if returnType is not related to AndroidInjector.Factory, ignore the method
+      return;
+    }
+
+    TypeMirror frameworkType = annotationsAndFrameworkTypes.get(annotation);
+
+    if (!getAnnotatedAnnotations(method, Scope.class).isEmpty()) {
+      SuppressWarnings suppressedWarnings = method.getAnnotation(SuppressWarnings.class);
+      if (suppressedWarnings == null
+          || !ImmutableSet.copyOf(suppressedWarnings.value())
+              .contains("dagger.android.ScopedInjectorFactory")) {
+        messager.printMessage(
+            Kind.ERROR,
+            String.format(
+                "%s bindings should not be scoped. Scoping this method may leak instances of %s. ",
+                AndroidInjector.Factory.class.getCanonicalName(), frameworkType),
+            method);
+      }
+    }
+
+    DeclaredType intendedReturnType = injectorFactoryOf(types.getWildcardType(frameworkType, null));
+    if (!MoreTypes.equivalence().equivalent(returnType, intendedReturnType)) {
+      messager.printMessage(
+          Kind.ERROR,
+          String.format(
+              "@%s methods should bind %s, not %s. See %s",
+              annotation.getCanonicalName(), intendedReturnType, returnType, LINK_TO_DOCS),
+          method);
+    }
+
+    // @Binds methods should only have one parameter, but we can't guarantee the order of Processors
+    // in javac, so do a basic check for valid form
+    if (isAnnotationPresent(method, Binds.class) && method.getParameters().size() == 1) {
+      validateMapKeyMatchesBindsParameter(annotation, method);
+    }
+  }
+
+  /**
+   * A valid @Binds method could bind an {@link AndroidInjector.Factory} for one type, while giving
+   * it a map key of a different type. The return type and parameter type would pass typical @Binds
+   * validation, but the map lookup in {@link dagger.android.DispatchingAndroidInjector} would
+   * retrieve the wrong injector factory.
+   *
+   * <pre>{@code
+   * {@literal @Binds}
+   * {@literal @IntoMap}
+   * {@literal @ActivityKey(GreenActivity.class)}
+   * abstract AndroidInjector.Factory<? extends Activity> bindBlueActivity(
+   *     BlueActivityComponent.Builder builder);
+   * }</pre>
+   */
+  private void validateMapKeyMatchesBindsParameter(
+      Class<? extends Annotation> annotation, ExecutableElement method) {
+    TypeMirror parameterType = getOnlyElement(method.getParameters()).asType();
+    AnnotationMirror annotationMirror = getAnnotationMirror(method, annotation).get();
+    TypeMirror mapKeyValue = (TypeMirror) getAnnotationValue(annotationMirror, "value").getValue();
+    if (!types.isAssignable(parameterType, injectorFactoryOf(mapKeyValue))) {
+      messager.printMessage(
+          Kind.ERROR,
+          String.format("%s does not implement AndroidInjector<%s>", parameterType, mapKeyValue),
+          method,
+          annotationMirror);
+    }
+  }
+
+  /** Returns a {@link DeclaredType} for {@code AndroidInjector.Factory<implementationType>}. */
+  private DeclaredType injectorFactoryOf(TypeMirror implementationType) {
+    return types.getDeclaredType(factoryElement(), implementationType);
+  }
+
+  private TypeElement factoryElement() {
+    return elements.getTypeElement(AndroidInjector.Factory.class.getCanonicalName());
+  }
+}
diff --git a/java/dagger/android/processor/AndroidProcessor.java b/java/dagger/android/processor/AndroidProcessor.java
new file mode 100644
index 000000000..b69bb4e2e
--- /dev/null
+++ b/java/dagger/android/processor/AndroidProcessor.java
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.processor;
+
+import com.google.auto.common.BasicAnnotationProcessor;
+import com.google.auto.service.AutoService;
+import com.google.common.collect.ImmutableList;
+import javax.annotation.processing.Processor;
+import javax.lang.model.SourceVersion;
+
+/**
+ * An {@linkplain javax.annotation.processing.Processor annotation processor} to verify usage of
+ * {@code dagger.android} code.
+ */
+@AutoService(Processor.class)
+public final class AndroidProcessor extends BasicAnnotationProcessor {
+  @Override
+  protected Iterable<? extends ProcessingStep> initSteps() {
+    return ImmutableList.of(
+        new AndroidMapKeyValidator(
+            processingEnv.getElementUtils(),
+            processingEnv.getTypeUtils(),
+            processingEnv.getMessager()));
+  }
+
+  @Override
+  public SourceVersion getSupportedSourceVersion() {
+    return SourceVersion.latestSupported();
+  }
+}
diff --git a/java/dagger/android/processor/BUILD b/java/dagger/android/processor/BUILD
new file mode 100644
index 000000000..9167fad25
--- /dev/null
+++ b/java/dagger/android/processor/BUILD
@@ -0,0 +1,60 @@
+# Copyright (C) 2017 The Dagger Authors.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+# Description:
+#   Public Dagger API for Android
+
+package(default_visibility = ["//:src"])
+
+load(
+    "//:build_defs.bzl",
+    "DOCLINT_HTML_AND_SYNTAX",
+    "DOCLINT_REFERENCES",
+)
+
+filegroup(
+    name = "srcs",
+    srcs = glob(["*.java"]),
+)
+
+java_library(
+    name = "processor",
+    srcs = [":srcs"],
+    javacopts = DOCLINT_HTML_AND_SYNTAX + DOCLINT_REFERENCES,
+    deps = [
+        "//third_party:guava",
+        "//third_party:auto_service",
+        "//third_party:auto_value",
+        "//third_party:auto_common",
+        "//core",
+        # https://github.com/bazelbuild/bazel/issues/2517
+        "//java/dagger/android:libandroid.jar",
+        "//java/dagger/android/support:libsupport.jar",
+    ],
+)
+
+java_plugin(
+    name = "plugin",
+    processor_class = "dagger.android.processor.AndroidProcessor",
+    deps = [":processor"],
+)
+
+load("//tools:javadoc.bzl", "javadoc_library")
+
+javadoc_library(
+    name = "processor-javadoc",
+    srcs = [":srcs"],
+    root_packages = ["dagger.android.processor"],
+    deps = [":processor"],
+)
diff --git a/java/dagger/android/support/AndroidManifest.xml b/java/dagger/android/support/AndroidManifest.xml
new file mode 100644
index 000000000..d080e115c
--- /dev/null
+++ b/java/dagger/android/support/AndroidManifest.xml
@@ -0,0 +1,19 @@
+<!--
+  ~ Copyright (C) 2017 The Dagger Authors.
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~ http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  -->
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+  package="dagger.android.support">
+  <uses-sdk android:minSdkVersion="14" />
+</manifest>
diff --git a/java/dagger/android/support/AndroidSupportInjection.java b/java/dagger/android/support/AndroidSupportInjection.java
new file mode 100644
index 000000000..64e3537e2
--- /dev/null
+++ b/java/dagger/android/support/AndroidSupportInjection.java
@@ -0,0 +1,94 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.support;
+
+import static dagger.internal.Preconditions.checkNotNull;
+
+import android.app.Activity;
+import android.support.v4.app.Fragment;
+import android.util.Log;
+import dagger.android.DispatchingAndroidInjector;
+import dagger.internal.Beta;
+
+/** Injects core Android types from support libraries. */
+@Beta
+public final class AndroidSupportInjection {
+  private static final String TAG = "dagger.android.support";
+
+  /**
+   * Injects {@code fragment} if an associated {@link dagger.android.AndroidInjector.Factory}
+   * implementation can be found, otherwise throws an {@link IllegalArgumentException}.
+   *
+   * <p>Uses the following algorithm to find the appropriate {@code
+   * DispatchingAndroidInjector<Fragment>} to inject {@code fragment}:
+   *
+   * <ol>
+   *   <li>Walks the parent-fragment hierarchy to find the a fragment that implements {@link
+   *       HasDispatchingSupportFragmentInjector}, and if none do
+   *   <li>Uses the {@code fragment}'s {@link Fragment#getActivity() activity} if it implements
+   *       {@link HasDispatchingSupportFragmentInjector}, and if not
+   *   <li>Uses the {@link android.app.Application} if it implements {@link
+   *       HasDispatchingSupportFragmentInjector}.
+   * </ol>
+   *
+   * If none of them implement {@link HasDispatchingSupportFragmentInjector}, a {@link
+   * IllegalArgumentException} is thrown.
+   *
+   * @throws IllegalArgumentException if no {@code AndroidInjector.Factory<Fragment, ?>} is bound
+   *     for {@code fragment}.
+   */
+  public static void inject(Fragment fragment) {
+    checkNotNull(fragment, "fragment");
+    HasDispatchingSupportFragmentInjector hasDispatchingSupportFragmentInjector =
+        findHasFragmentInjector(fragment);
+    Log.d(
+        TAG,
+        String.format(
+            "An injector for %s was found in %s",
+            fragment.getClass().getCanonicalName(),
+            hasDispatchingSupportFragmentInjector.getClass().getCanonicalName()));
+
+    DispatchingAndroidInjector<Fragment> fragmentInjector =
+        hasDispatchingSupportFragmentInjector.supportFragmentInjector();
+    checkNotNull(
+        fragmentInjector,
+        "%s.supportFragmentInjector() returned null",
+        hasDispatchingSupportFragmentInjector.getClass().getCanonicalName());
+
+    fragmentInjector.inject(fragment);
+  }
+
+  private static HasDispatchingSupportFragmentInjector findHasFragmentInjector(Fragment fragment) {
+    Fragment parentFragment = fragment;
+    while ((parentFragment = parentFragment.getParentFragment()) != null) {
+      if (parentFragment instanceof HasDispatchingSupportFragmentInjector) {
+        return (HasDispatchingSupportFragmentInjector) parentFragment;
+      }
+    }
+    Activity activity = fragment.getActivity();
+    if (activity instanceof HasDispatchingSupportFragmentInjector) {
+      return (HasDispatchingSupportFragmentInjector) activity;
+    }
+    if (activity.getApplication() instanceof HasDispatchingSupportFragmentInjector) {
+      return (HasDispatchingSupportFragmentInjector) activity.getApplication();
+    }
+    throw new IllegalArgumentException(
+        String.format("No injector was found for %s", fragment.getClass().getCanonicalName()));
+  }
+
+  private AndroidSupportInjection() {}
+}
diff --git a/java/dagger/android/support/AndroidSupportInjectionModule.java b/java/dagger/android/support/AndroidSupportInjectionModule.java
new file mode 100644
index 000000000..6349afb67
--- /dev/null
+++ b/java/dagger/android/support/AndroidSupportInjectionModule.java
@@ -0,0 +1,40 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.support;
+
+import android.support.v4.app.Fragment;
+import dagger.Module;
+import dagger.android.AndroidInjectionModule;
+import dagger.android.AndroidInjector;
+import dagger.internal.Beta;
+import dagger.multibindings.Multibinds;
+import java.util.Map;
+
+/**
+ * Configures bindings to ensure the usability of {@code dagger.android} and {@code
+ * dagger.android.support} framework classes. This module should be installed in the root-most
+ * component which will use these types.
+ */
+@Beta
+@Module(includes = AndroidInjectionModule.class)
+public abstract class AndroidSupportInjectionModule {
+  @Multibinds
+  abstract Map<Class<? extends Fragment>, AndroidInjector.Factory<? extends Fragment>>
+      supportFragmentInjectorFactories();
+
+  private AndroidSupportInjectionModule() {}
+}
diff --git a/java/dagger/android/support/BUILD b/java/dagger/android/support/BUILD
new file mode 100644
index 000000000..143b1fde6
--- /dev/null
+++ b/java/dagger/android/support/BUILD
@@ -0,0 +1,49 @@
+# Copyright (C) 2017 The Dagger Authors.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+# Description:
+#   Public Dagger API for Android that interacts with the Android support libraries
+
+package(default_visibility = ["//:src"])
+
+load("//:build_defs.bzl", "SOURCE_7_TARGET_7", "PRE_JAVA_8_INFERENCE_OPTS")
+
+filegroup(
+    name = "support-srcs",
+    srcs = glob(["*.java"]),
+)
+
+android_library(
+    name = "support",
+    srcs = glob(["*.java"]),
+    javacopts = PRE_JAVA_8_INFERENCE_OPTS + SOURCE_7_TARGET_7,
+    manifest = "AndroidManifest.xml",
+    deps = [
+        "//:dagger_with_compiler",
+        "//java/dagger/android",
+        "@androidsdk//com.android.support:appcompat-v7-25.0.0",
+        "@androidsdk//com.android.support:support-annotations-25.0.0",
+        "@androidsdk//com.android.support:support-v4-25.0.0",
+    ],
+)
+
+load("//tools:javadoc.bzl", "javadoc_library")
+
+javadoc_library(
+    name = "support-javadoc",
+    srcs = [":support-srcs"],
+    android_api_level = 25,
+    root_packages = ["dagger.android.support"],
+    deps = [":support"],
+)
diff --git a/java/dagger/android/support/DaggerAppCompatActivity.java b/java/dagger/android/support/DaggerAppCompatActivity.java
new file mode 100644
index 000000000..f1b403362
--- /dev/null
+++ b/java/dagger/android/support/DaggerAppCompatActivity.java
@@ -0,0 +1,54 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.support;
+
+import android.os.Bundle;
+import android.support.v4.app.Fragment;
+import android.support.v7.app.AppCompatActivity;
+import dagger.android.AndroidInjection;
+import dagger.android.DispatchingAndroidInjector;
+import dagger.android.HasDispatchingFragmentInjector;
+import dagger.internal.Beta;
+import javax.inject.Inject;
+
+/**
+ * An {@link AppCompatActivity} that injects its members in {@link #onCreate(Bundle)} and can be
+ * used to inject {@code Fragment}s attached to it.
+ */
+@Beta
+public abstract class DaggerAppCompatActivity extends AppCompatActivity
+    implements HasDispatchingFragmentInjector, HasDispatchingSupportFragmentInjector {
+
+  @Inject DispatchingAndroidInjector<Fragment> supportFragmentInjector;
+  @Inject DispatchingAndroidInjector<android.app.Fragment> frameworkFragmentInjector;
+
+  @Override
+  protected void onCreate(Bundle savedInstanceState) {
+    AndroidInjection.inject(this);
+    super.onCreate(savedInstanceState);
+  }
+
+  @Override
+  public DispatchingAndroidInjector<Fragment> supportFragmentInjector() {
+    return supportFragmentInjector;
+  }
+
+  @Override
+  public DispatchingAndroidInjector<android.app.Fragment> fragmentInjector() {
+    return frameworkFragmentInjector;
+  }
+}
diff --git a/java/dagger/android/support/DaggerFragment.java b/java/dagger/android/support/DaggerFragment.java
new file mode 100644
index 000000000..b21f85968
--- /dev/null
+++ b/java/dagger/android/support/DaggerFragment.java
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.support;
+
+import android.content.Context;
+import android.support.v4.app.Fragment;
+import dagger.android.DispatchingAndroidInjector;
+import dagger.internal.Beta;
+import javax.inject.Inject;
+
+/**
+ * A {@link Fragment} that injects its members in {@link #onAttach(Context)} and can be used to
+ * inject child {@link Fragment}s attached to it. Note that when this fragment gets reattached, its
+ * members will be injected again.
+ */
+@Beta
+public abstract class DaggerFragment extends Fragment implements
+    HasDispatchingSupportFragmentInjector {
+
+  @Inject DispatchingAndroidInjector<Fragment> childFragmentInjector;
+
+  @Override
+  public void onAttach(Context context) {
+    AndroidSupportInjection.inject(this);
+    super.onAttach(context);
+  }
+
+  @Override
+  public DispatchingAndroidInjector<Fragment> supportFragmentInjector() {
+    return childFragmentInjector;
+  }
+}
diff --git a/java/dagger/android/support/FragmentKey.java b/java/dagger/android/support/FragmentKey.java
new file mode 100644
index 000000000..a5ecda4d7
--- /dev/null
+++ b/java/dagger/android/support/FragmentKey.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.support;
+
+import static java.lang.annotation.ElementType.METHOD;
+
+import android.support.v4.app.Fragment;
+import dagger.MapKey;
+import dagger.internal.Beta;
+import java.lang.annotation.Target;
+
+/** {@link MapKey} annotation to key bindings by a type of a {@link Fragment}. */
+@Beta
+@MapKey
+@Target(METHOD)
+public @interface FragmentKey {
+  Class<? extends Fragment> value();
+}
diff --git a/java/dagger/android/support/HasDispatchingSupportFragmentInjector.java b/java/dagger/android/support/HasDispatchingSupportFragmentInjector.java
new file mode 100644
index 000000000..088854468
--- /dev/null
+++ b/java/dagger/android/support/HasDispatchingSupportFragmentInjector.java
@@ -0,0 +1,29 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.support;
+
+import android.support.v4.app.Fragment;
+import dagger.android.DispatchingAndroidInjector;
+import dagger.internal.Beta;
+
+/** Provides a {@link DispatchingAndroidInjector} of {@link Fragment}s. */
+@Beta
+public interface HasDispatchingSupportFragmentInjector {
+
+  /** Returns a {@link DispatchingAndroidInjector} of {@link Fragment}s. */
+  DispatchingAndroidInjector<Fragment> supportFragmentInjector();
+}
diff --git a/javatests/dagger/android/AndroidInjectionTest.java b/javatests/dagger/android/AndroidInjectionTest.java
new file mode 100644
index 000000000..43fb06242
--- /dev/null
+++ b/javatests/dagger/android/AndroidInjectionTest.java
@@ -0,0 +1,209 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+
+import android.app.Activity;
+import android.app.Application;
+import android.app.Fragment;
+import com.google.common.collect.ImmutableMap;
+import org.robolectric.RobolectricTestRunner;
+import dagger.android.AndroidInjector.Factory;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
+import org.robolectric.annotation.Config;
+import org.robolectric.util.FragmentTestUtil;
+
+@Config(manifest = Config.NONE)
+@RunWith(RobolectricTestRunner.class)
+public final class AndroidInjectionTest {
+
+  // Most positive tests are performed in javatests/dagger/android/support/functional, but
+  // Robolectric's support for framework fragments is lacking, so we supplement those tests here:
+  public static class InjectableFragment extends Fragment {
+    String tag;
+  }
+
+  private static DispatchingAndroidInjector<Fragment> dispatchingFragmentInjector(String tag) {
+    return new DispatchingAndroidInjector<>(
+        ImmutableMap.of(
+            InjectableFragment.class,
+            () ->
+                new Factory<InjectableFragment>() {
+                  @Override
+                  public AndroidInjector<InjectableFragment> create(InjectableFragment fragment) {
+                    return f -> f.tag = tag;
+                  }
+                }));
+  }
+
+  public static class ApplicationInjectsFragment extends Application
+      implements HasDispatchingFragmentInjector {
+    @Override
+    public DispatchingAndroidInjector<Fragment> fragmentInjector() {
+      return dispatchingFragmentInjector("injected by app");
+    }
+  }
+
+  @Config(manifest = Config.NONE, application = ApplicationInjectsFragment.class)
+  @Test
+  public void fragmentInjectedByApplication() {
+    Activity activity = Robolectric.setupActivity(Activity.class);
+    InjectableFragment fragment = new InjectableFragment();
+    activity.getFragmentManager().beginTransaction().add(fragment, "tag").commit();
+
+    AndroidInjection.inject(fragment);
+
+    assertThat(fragment.tag).isEqualTo("injected by app");
+  }
+
+  public static class ActivityInjectsFragment extends Activity
+      implements HasDispatchingFragmentInjector {
+    @Override
+    public DispatchingAndroidInjector<Fragment> fragmentInjector() {
+      return dispatchingFragmentInjector("injected by activity");
+    }
+  }
+
+  @Config(manifest = Config.NONE, application = ApplicationInjectsFragment.class)
+  @Test
+  public void fragmentInjectedByActivity() {
+    ActivityInjectsFragment activity = Robolectric.setupActivity(ActivityInjectsFragment.class);
+    InjectableFragment fragment = new InjectableFragment();
+    activity.getFragmentManager().beginTransaction().add(fragment, "tag").commit();
+
+    AndroidInjection.inject(fragment);
+
+    assertThat(fragment.tag).isEqualTo("injected by activity");
+  }
+
+  public static class ParentFragmentInjectsChildFragment extends Fragment
+      implements HasDispatchingFragmentInjector {
+    @Override
+    public DispatchingAndroidInjector<Fragment> fragmentInjector() {
+      return dispatchingFragmentInjector("injected by parent fragment");
+    }
+  }
+
+  @Config(manifest = Config.NONE, application = ApplicationInjectsFragment.class)
+  @Test
+  public void fragmentInjectedByParentFragment() {
+    ActivityInjectsFragment activity = Robolectric.setupActivity(ActivityInjectsFragment.class);
+    ParentFragmentInjectsChildFragment parentFragment = new ParentFragmentInjectsChildFragment();
+    InjectableFragment childFragment = new InjectableFragment();
+
+    activity.getFragmentManager().beginTransaction().add(parentFragment, "tag").commit();
+    parentFragment
+        .getChildFragmentManager()
+        .beginTransaction()
+        .add(childFragment, "child-tag")
+        .commit();
+    AndroidInjection.inject(childFragment);
+
+    assertThat(childFragment.tag).isEqualTo("injected by parent fragment");
+  }
+
+  @Test
+  public void injectActivity_applicationDoesntImplementHasDispatchingActivityInjector() {
+    Activity activity = Robolectric.setupActivity(Activity.class);
+
+    try {
+      AndroidInjection.inject(activity);
+      fail();
+    } catch (Exception e) {
+      assertThat(e)
+          .hasMessageThat()
+          .contains("Application does not implement dagger.android.HasDispatchingActivityInjector");
+    }
+  }
+
+  @Test
+  public void injectFragment_hasDispatchingFragmentInjectorNotFound() {
+    Fragment fragment = new Fragment();
+    FragmentTestUtil.startFragment(fragment);
+
+    try {
+      AndroidInjection.inject(fragment);
+      fail();
+    } catch (Exception e) {
+      assertThat(e).hasMessageThat().contains("No injector was found");
+    }
+  }
+
+  private static class ApplicationReturnsNull extends Application
+      implements HasDispatchingActivityInjector, HasDispatchingFragmentInjector {
+    @Override
+    public DispatchingAndroidInjector<Activity> activityInjector() {
+      return null;
+    }
+
+    @Override
+    public DispatchingAndroidInjector<Fragment> fragmentInjector() {
+      return null;
+    }
+  }
+
+  @Test
+  @Config(manifest = Config.NONE, application = ApplicationReturnsNull.class)
+  public void dispatchingAndroidInjector_returnsNull() {
+    Activity activity = Robolectric.setupActivity(Activity.class);
+
+    try {
+      AndroidInjection.inject(activity);
+      fail();
+    } catch (Exception e) {
+      assertThat(e).hasMessageThat().contains("activityInjector() returned null");
+    }
+  }
+
+  @Test
+  @Config(manifest = Config.NONE, application = ApplicationReturnsNull.class)
+  public void dispatchingFragmentInjector_returnsNull() {
+    Fragment fragment = new Fragment();
+    FragmentTestUtil.startFragment(fragment);
+
+    try {
+      AndroidInjection.inject(fragment);
+      fail();
+    } catch (Exception e) {
+      assertThat(e).hasMessageThat().contains("fragmentInjector() returned null");
+    }
+  }
+
+  @Test
+  public void injectActivity_nullInput() {
+    try {
+      AndroidInjection.inject((Activity) null);
+      fail();
+    } catch (NullPointerException e) {
+      assertThat(e).hasMessageThat().contains("activity");
+    }
+  }
+
+  @Test
+  public void injectFragment_nullInput() {
+    try {
+      AndroidInjection.inject((Fragment) null);
+      fail();
+    } catch (NullPointerException e) {
+      assertThat(e).hasMessageThat().contains("fragment");
+    }
+  }
+}
diff --git a/javatests/dagger/android/BUILD b/javatests/dagger/android/BUILD
new file mode 100644
index 000000000..cf47d8be9
--- /dev/null
+++ b/javatests/dagger/android/BUILD
@@ -0,0 +1,34 @@
+# Copyright (C) 2017 The Dagger Authors.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+# Description:
+#   Tests for Dagger's Android integrations
+
+package(default_visibility = ["//:src"])
+
+load("//:build_defs.bzl", "DOCLINT_HTML_AND_SYNTAX")
+load("//:test_defs.bzl", "GenRobolectricTests")
+
+GenRobolectricTests(
+    name = "android_tests",
+    srcs = glob(["*.java"]),
+    javacopts = DOCLINT_HTML_AND_SYNTAX,
+    deps = [
+        "//:dagger_with_compiler",
+        "//java/dagger/android",
+        "//third_party:guava",
+        "//third_party:junit",
+        "//third_party:truth",
+    ],
+)
diff --git a/javatests/dagger/android/DispatchingAndroidInjectorTest.java b/javatests/dagger/android/DispatchingAndroidInjectorTest.java
new file mode 100644
index 000000000..2d1e6132c
--- /dev/null
+++ b/javatests/dagger/android/DispatchingAndroidInjectorTest.java
@@ -0,0 +1,102 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+
+import android.app.Activity;
+import org.robolectric.RobolectricTestRunner;
+import dagger.android.DispatchingAndroidInjector.InvalidInjectorBindingException;
+import java.util.HashMap;
+import java.util.Map;
+import javax.inject.Provider;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
+import org.robolectric.annotation.Config;
+
+@Config(manifest = Config.NONE)
+@RunWith(RobolectricTestRunner.class)
+public final class DispatchingAndroidInjectorTest {
+  private DispatchingAndroidInjector<Activity> dispatchingAndroidInjector;
+
+  @Before
+  public void setup() {
+    Map<Class<? extends Activity>, Provider<AndroidInjector.Factory<? extends Activity>>>
+        injectorFactories = new HashMap<>();
+    injectorFactories.put(FooActivity.class, FooInjector.Factory::new);
+    injectorFactories.put(ReturnsNullActivity.class, () -> null);
+    injectorFactories.put(WrongActivity.class, FooInjector.Factory::new);
+    dispatchingAndroidInjector = new DispatchingAndroidInjector<>(injectorFactories);
+  }
+
+  @Test
+  public void maybeInject_returnsTrue_ifMatchingInjectorExists() {
+    FooActivity fooActivity = Robolectric.setupActivity(FooActivity.class);
+    assertThat(dispatchingAndroidInjector.maybeInject(fooActivity)).isTrue();
+  }
+
+  @Test
+  public void maybeInject_returnsFalse_ifNoMatchingInjectorExists() {
+    BarActivity barActivity = Robolectric.setupActivity(BarActivity.class);
+    assertThat(dispatchingAndroidInjector.maybeInject(barActivity)).isFalse();
+  }
+
+  @Test
+  public void throwsIfFactoryCreateReturnsNull() {
+    ReturnsNullActivity returnsNullActivity = Robolectric.setupActivity(ReturnsNullActivity.class);
+
+    try {
+      dispatchingAndroidInjector.maybeInject(returnsNullActivity);
+      fail("Expected NullPointerException");
+    } catch (NullPointerException expected) {
+    }
+  }
+
+  @Test
+  public void throwsIfClassMismatched() {
+    WrongActivity wrongActivity = Robolectric.setupActivity(WrongActivity.class);
+
+    try {
+      dispatchingAndroidInjector.maybeInject(wrongActivity);
+      fail("Expected InvalidInjectorBindingException");
+    } catch (InvalidInjectorBindingException expected) {
+    }
+  }
+
+  static class FooActivity extends Activity {}
+
+  static class BarActivity extends Activity {}
+
+  static class ReturnsNullActivity extends Activity {}
+
+  static class WrongActivity extends Activity {}
+
+  static class FooInjector implements AndroidInjector<FooActivity> {
+    @Override
+    public void inject(FooActivity instance) {}
+
+    static class Factory implements AndroidInjector.Factory<FooActivity> {
+      @Override
+      public AndroidInjector<FooActivity> create(FooActivity activity) {
+        return new FooInjector();
+      }
+    }
+  }
+}
diff --git a/javatests/dagger/android/functional/AndroidMemorySensitiveReferenceManagerTest.java b/javatests/dagger/android/functional/AndroidMemorySensitiveReferenceManagerTest.java
new file mode 100644
index 000000000..076de40fc
--- /dev/null
+++ b/javatests/dagger/android/functional/AndroidMemorySensitiveReferenceManagerTest.java
@@ -0,0 +1,144 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.functional;
+
+import static android.content.ComponentCallbacks2.TRIM_MEMORY_COMPLETE;
+import static android.content.ComponentCallbacks2.TRIM_MEMORY_RUNNING_MODERATE;
+import static android.content.ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN;
+import static com.google.common.truth.Truth.assertThat;
+import static dagger.android.functional.AndroidMemorySensitiveReferenceManagerTest.AllWeakReferencesCleared.allWeakReferencesCleared;
+
+import com.google.common.collect.ImmutableList;
+import com.google.common.testing.GcFinalization;
+import com.google.common.testing.GcFinalization.FinalizationPredicate;
+import org.robolectric.RobolectricTestRunner;
+import java.lang.ref.WeakReference;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+/** Functional tests of {@link dagger.android.AndroidMemorySensitiveReferenceManager}. */
+@RunWith(RobolectricTestRunner.class)
+public final class AndroidMemorySensitiveReferenceManagerTest {
+
+  private TestModule testModule;
+  private TestComponent component;
+
+  @Before
+  public void setUp() {
+    testModule = new TestModule();
+    component = DaggerTestComponent.builder().testModule(testModule).build();
+  }
+
+  @Test
+  public void scoped() {
+    assertThat(component.releasedWhenUiHidden()).isSameAs(component.releasedWhenUiHidden());
+    assertThat(component.releasedWhenModerate()).isSameAs(component.releasedWhenModerate());
+    assertThat(testModule.releasedWhenUiHiddenCalls).isEqualTo(1);
+    assertThat(testModule.releasedWhenModerateCalls).isEqualTo(1);
+  }
+
+  @Test
+  public void onTrimMemory_aboveThresholds() {
+    component.releasedWhenUiHidden();
+    component.releasedWhenModerate();
+
+    component.manager().onTrimMemory(TRIM_MEMORY_COMPLETE);
+    GcFinalization.awaitDone(
+        allWeakReferencesCleared(
+            component.releasedWhenUiHidden(), component.releasedWhenModerate()));
+
+    assertThat(component.releasedWhenUiHidden()).isSameAs(component.releasedWhenUiHidden());
+    assertThat(component.releasedWhenModerate()).isSameAs(component.releasedWhenModerate());
+    assertThat(testModule.releasedWhenUiHiddenCalls).isEqualTo(2);
+    assertThat(testModule.releasedWhenModerateCalls).isEqualTo(2);
+  }
+
+  @Test
+  public void onTrimMemory_atOneThresholdBelowAnother() {
+    component.releasedWhenUiHidden();
+    component.releasedWhenModerate();
+
+    component.manager().onTrimMemory(TRIM_MEMORY_UI_HIDDEN);
+    GcFinalization.awaitDone(allWeakReferencesCleared(component.releasedWhenUiHidden()));
+
+    assertThat(component.releasedWhenUiHidden()).isSameAs(component.releasedWhenUiHidden());
+    assertThat(component.releasedWhenModerate()).isSameAs(component.releasedWhenModerate());
+    assertThat(testModule.releasedWhenUiHiddenCalls).isEqualTo(2);
+    assertThat(testModule.releasedWhenModerateCalls).isEqualTo(1);
+  }
+
+  @Test
+  public void onTrimMemory_belowThresholds() {
+    component.releasedWhenUiHidden();
+    component.releasedWhenModerate();
+    assertThat(testModule.releasedWhenUiHiddenCalls).isEqualTo(1);
+    assertThat(testModule.releasedWhenModerateCalls).isEqualTo(1);
+
+    component.manager().onTrimMemory(TRIM_MEMORY_RUNNING_MODERATE);
+    GcFinalization.awaitDone(allWeakReferencesCleared(new Object()));
+
+    assertThat(component.releasedWhenUiHidden()).isSameAs(component.releasedWhenUiHidden());
+    assertThat(component.releasedWhenModerate()).isSameAs(component.releasedWhenModerate());
+    assertThat(testModule.releasedWhenUiHiddenCalls).isEqualTo(1);
+    assertThat(testModule.releasedWhenModerateCalls).isEqualTo(1);
+  }
+
+  @Test
+  public void onTrimMemory_restore() {
+    component.releasedWhenUiHidden();
+    component.releasedWhenModerate();
+    assertThat(testModule.releasedWhenUiHiddenCalls).isEqualTo(1);
+    assertThat(testModule.releasedWhenModerateCalls).isEqualTo(1);
+
+    component.manager().onTrimMemory(TRIM_MEMORY_UI_HIDDEN);
+    component.manager().onTrimMemory(TRIM_MEMORY_RUNNING_MODERATE);
+    GcFinalization.awaitDone(allWeakReferencesCleared(new Object()));
+
+    assertThat(component.releasedWhenUiHidden()).isSameAs(component.releasedWhenUiHidden());
+    assertThat(component.releasedWhenModerate()).isSameAs(component.releasedWhenModerate());
+    assertThat(testModule.releasedWhenUiHiddenCalls).isEqualTo(1);
+    assertThat(testModule.releasedWhenModerateCalls).isEqualTo(1);
+  }
+
+  static final class AllWeakReferencesCleared implements FinalizationPredicate {
+
+    private final ImmutableList<WeakReference<Object>> references;
+
+    AllWeakReferencesCleared(ImmutableList<WeakReference<Object>> references) {
+      this.references = references;
+    }
+
+    @Override
+    public boolean isDone() {
+      for (WeakReference<Object> reference : references) {
+        if (reference.get() != null) {
+          return false;
+        }
+      }
+      return true;
+    }
+
+    static AllWeakReferencesCleared allWeakReferencesCleared(Object... objects) {
+      ImmutableList.Builder<WeakReference<Object>> referencesBuilder = ImmutableList.builder();
+      for (Object object : objects) {
+        referencesBuilder.add(new WeakReference<>(object));
+      }
+      return new AllWeakReferencesCleared(referencesBuilder.build());
+    }
+  }
+}
diff --git a/javatests/dagger/android/functional/BUILD b/javatests/dagger/android/functional/BUILD
new file mode 100644
index 000000000..fdad2858f
--- /dev/null
+++ b/javatests/dagger/android/functional/BUILD
@@ -0,0 +1,54 @@
+# Copyright (C) 2017 The Dagger Authors.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+# Description:
+#   Functional test code for Dagger-Android
+
+package(default_visibility = ["//:src"])
+
+load(
+    "//:build_defs.bzl",
+    "DOCLINT_HTML_AND_SYNTAX",
+    "PRE_JAVA_8_INFERENCE_OPTS",
+)
+load("//:test_defs.bzl", "GenRobolectricTests")
+
+# Sample code to be tested in functional tests.
+android_library(
+    name = "code_under_test",
+    srcs = glob(
+        ["*.java"],
+        exclude = ["*Test.java"],
+    ),
+    javacopts = PRE_JAVA_8_INFERENCE_OPTS + DOCLINT_HTML_AND_SYNTAX,
+    deps = [
+        # NOTE: This should not depend on Guava or jsr305 to ensure that Dagger can be
+        # used without a Guava and jsr305 deps.
+        "//:dagger_with_compiler",
+        "//java/dagger/android",
+    ],
+)
+
+GenRobolectricTests(
+    name = "android_functional_tests",
+    srcs = glob(["*Test.java"]),
+    javacopts = PRE_JAVA_8_INFERENCE_OPTS + DOCLINT_HTML_AND_SYNTAX,
+    deps = [
+        ":code_under_test",
+        "//third_party:guava",
+        "//third_party:guava_testlib",
+        "//third_party:junit",
+        "//third_party:truth",
+    ],
+)
diff --git a/javatests/dagger/android/functional/InScope.java b/javatests/dagger/android/functional/InScope.java
new file mode 100644
index 000000000..295ee069c
--- /dev/null
+++ b/javatests/dagger/android/functional/InScope.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.functional;
+
+import java.lang.annotation.Annotation;
+import javax.inject.Qualifier;
+
+@Qualifier
+@interface InScope {
+  Class<? extends Annotation> value();
+}
diff --git a/javatests/dagger/android/functional/ReleaseWhenModerate.java b/javatests/dagger/android/functional/ReleaseWhenModerate.java
new file mode 100644
index 000000000..c8971b42d
--- /dev/null
+++ b/javatests/dagger/android/functional/ReleaseWhenModerate.java
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.functional;
+
+import static android.content.ComponentCallbacks2.TRIM_MEMORY_MODERATE;
+import static java.lang.annotation.ElementType.METHOD;
+import static java.lang.annotation.ElementType.TYPE;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+import dagger.android.ReleaseReferencesAt;
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+import javax.inject.Scope;
+
+@Documented
+@Retention(RUNTIME)
+@Target({TYPE, METHOD})
+@ReleaseReferencesAt(TRIM_MEMORY_MODERATE)
+@Scope
+@interface ReleaseWhenModerate {}
diff --git a/javatests/dagger/android/functional/ReleaseWhenUiHidden.java b/javatests/dagger/android/functional/ReleaseWhenUiHidden.java
new file mode 100644
index 000000000..ca22db44a
--- /dev/null
+++ b/javatests/dagger/android/functional/ReleaseWhenUiHidden.java
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.functional;
+
+import static android.content.ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN;
+import static java.lang.annotation.ElementType.METHOD;
+import static java.lang.annotation.ElementType.TYPE;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+import dagger.android.ReleaseReferencesAt;
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+import javax.inject.Scope;
+
+@Documented
+@Retention(RUNTIME)
+@Target({TYPE, METHOD})
+@ReleaseReferencesAt(TRIM_MEMORY_UI_HIDDEN)
+@Scope
+@interface ReleaseWhenUiHidden {}
diff --git a/javatests/dagger/android/functional/TestComponent.java b/javatests/dagger/android/functional/TestComponent.java
new file mode 100644
index 000000000..03d40755b
--- /dev/null
+++ b/javatests/dagger/android/functional/TestComponent.java
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.functional;
+
+import dagger.Component;
+import dagger.android.AndroidMemorySensitiveReferenceManager;
+import javax.inject.Singleton;
+
+@Singleton
+@ReleaseWhenUiHidden
+@ReleaseWhenModerate
+@Component(modules = TestModule.class)
+interface TestComponent {
+  AndroidMemorySensitiveReferenceManager manager();
+
+  @InScope(ReleaseWhenUiHidden.class)
+  Object releasedWhenUiHidden();
+
+  @InScope(ReleaseWhenModerate.class)
+  Object releasedWhenModerate();
+}
diff --git a/javatests/dagger/android/functional/TestModule.java b/javatests/dagger/android/functional/TestModule.java
new file mode 100644
index 000000000..dd3adaa0b
--- /dev/null
+++ b/javatests/dagger/android/functional/TestModule.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.functional;
+
+import dagger.Module;
+import dagger.Provides;
+
+@Module
+class TestModule {
+  int releasedWhenUiHiddenCalls;
+  int releasedWhenModerateCalls;
+
+  @Provides
+  @ReleaseWhenUiHidden
+  @InScope(ReleaseWhenUiHidden.class)
+  Object releasedWhenUiHidden() {
+    ++releasedWhenUiHiddenCalls;
+    return new Object();
+  }
+
+  @Provides
+  @ReleaseWhenModerate
+  @InScope(ReleaseWhenModerate.class)
+  Object releasedWhenModerate() {
+    ++releasedWhenModerateCalls;
+    return new Object();
+  }
+}
diff --git a/javatests/dagger/android/support/AndroidSupportInjectionTest.java b/javatests/dagger/android/support/AndroidSupportInjectionTest.java
new file mode 100644
index 000000000..87593af4c
--- /dev/null
+++ b/javatests/dagger/android/support/AndroidSupportInjectionTest.java
@@ -0,0 +1,78 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.support;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+
+import android.app.Application;
+import android.support.v4.app.Fragment;
+import org.robolectric.RobolectricTestRunner;
+import dagger.android.DispatchingAndroidInjector;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.annotation.Config;
+import org.robolectric.shadows.support.v4.SupportFragmentTestUtil;
+
+@Config(manifest = Config.NONE)
+@RunWith(RobolectricTestRunner.class)
+public final class AndroidSupportInjectionTest {
+  @Test
+  public void injectFragment_simpleApplication() {
+    Fragment fragment = new Fragment();
+    SupportFragmentTestUtil.startFragment(fragment);
+
+    try {
+      AndroidSupportInjection.inject(fragment);
+      fail();
+    } catch (Exception e) {
+      assertThat(e).hasMessageThat().contains("No injector was found");
+    }
+  }
+
+  private static class ApplicationReturnsNull extends Application
+      implements HasDispatchingSupportFragmentInjector {
+    @Override
+    public DispatchingAndroidInjector<Fragment> supportFragmentInjector() {
+      return null;
+    }
+  }
+
+  @Test
+  @Config(manifest = Config.NONE, application = ApplicationReturnsNull.class)
+  public void dispatchingFragmentInjector_returnsNull() {
+    Fragment fragment = new Fragment();
+    SupportFragmentTestUtil.startFragment(fragment);
+
+    try {
+      AndroidSupportInjection.inject(fragment);
+      fail();
+    } catch (Exception e) {
+      assertThat(e).hasMessageThat().contains("supportFragmentInjector() returned null");
+    }
+  }
+
+  @Test
+  public void injectFragment_nullInput() {
+    try {
+      AndroidSupportInjection.inject(null);
+      fail();
+    } catch (NullPointerException e) {
+      assertThat(e).hasMessageThat().contains("fragment");
+    }
+  }
+}
diff --git a/javatests/dagger/android/support/BUILD b/javatests/dagger/android/support/BUILD
new file mode 100644
index 000000000..c194709bf
--- /dev/null
+++ b/javatests/dagger/android/support/BUILD
@@ -0,0 +1,37 @@
+# Copyright (C) 2017 The Dagger Authors.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+# Description:
+#   Tests for Dagger's Android and Support library integrations
+
+package(default_visibility = ["//:src"])
+
+load("//:build_defs.bzl", "DOCLINT_HTML_AND_SYNTAX")
+load("//:test_defs.bzl", "GenRobolectricTests")
+
+GenRobolectricTests(
+    name = "android-support-tests",
+    srcs = glob(["*.java"]),
+    javacopts = DOCLINT_HTML_AND_SYNTAX,
+    deps = [
+        "//:dagger_with_compiler",
+        "//java/dagger/android",
+        "//java/dagger/android/support",
+        "//third_party:guava",
+        "//third_party:junit",
+        "//third_party:truth",
+        "@androidsdk//com.android.support:appcompat-v7-25.0.0",
+        "@androidsdk//com.android.support:support-v4-25.0.0",
+    ],
+)
diff --git a/javatests/dagger/android/support/functional/AllControllersAreDirectChildrenOfApplication.java b/javatests/dagger/android/support/functional/AllControllersAreDirectChildrenOfApplication.java
new file mode 100644
index 000000000..f595e3a74
--- /dev/null
+++ b/javatests/dagger/android/support/functional/AllControllersAreDirectChildrenOfApplication.java
@@ -0,0 +1,225 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.support.functional;
+
+import android.app.Activity;
+import android.app.Application;
+import android.app.Service;
+import android.content.BroadcastReceiver;
+import android.support.v4.app.Fragment;
+import dagger.Binds;
+import dagger.Component;
+import dagger.Module;
+import dagger.Provides;
+import dagger.Subcomponent;
+import dagger.android.ActivityKey;
+import dagger.android.AndroidInjector;
+import dagger.android.BroadcastReceiverKey;
+import dagger.android.DispatchingAndroidInjector;
+import dagger.android.HasDispatchingActivityInjector;
+import dagger.android.HasDispatchingBroadcastReceiverInjector;
+import dagger.android.HasDispatchingServiceInjector;
+import dagger.android.ServiceKey;
+import dagger.android.support.AndroidSupportInjectionModule;
+import dagger.android.support.FragmentKey;
+import dagger.android.support.functional.AllControllersAreDirectChildrenOfApplication.ApplicationComponent.BroadcastReceiverSubcomponent.BroadcastReceiverModule;
+import dagger.android.support.functional.AllControllersAreDirectChildrenOfApplication.ApplicationComponent.IntentServiceSubcomponent.IntentServiceModule;
+import dagger.android.support.functional.AllControllersAreDirectChildrenOfApplication.ApplicationComponent.ServiceSubcomponent.ServiceModule;
+import dagger.multibindings.IntoMap;
+import dagger.multibindings.IntoSet;
+import javax.inject.Inject;
+
+public final class AllControllersAreDirectChildrenOfApplication extends Application
+    implements HasDispatchingActivityInjector,
+        HasDispatchingServiceInjector,
+        HasDispatchingBroadcastReceiverInjector {
+  @Inject DispatchingAndroidInjector<Activity> activityInjector;
+  @Inject DispatchingAndroidInjector<Service> serviceInjector;
+  @Inject DispatchingAndroidInjector<BroadcastReceiver> broadcastReceiverInjector;
+
+  @Override
+  public void onCreate() {
+    super.onCreate();
+    DaggerAllControllersAreDirectChildrenOfApplication_ApplicationComponent.create().inject(this);
+  }
+
+  @Override
+  public DispatchingAndroidInjector<Activity> activityInjector() {
+    return activityInjector;
+  }
+
+  @Override
+  public DispatchingAndroidInjector<Service> serviceInjector() {
+    return serviceInjector;
+  }
+
+  @Override
+  public DispatchingAndroidInjector<BroadcastReceiver> broadcastReceiverInjector() {
+    return broadcastReceiverInjector;
+  }
+
+  @Component(
+    modules = {ApplicationComponent.ApplicationModule.class, AndroidSupportInjectionModule.class}
+  )
+  interface ApplicationComponent {
+    void inject(AllControllersAreDirectChildrenOfApplication application);
+
+    @Module(
+      subcomponents = {
+        ActivitySubcomponent.class,
+        ParentFragmentSubcomponent.class,
+        ChildFragmentSubcomponent.class,
+        ServiceSubcomponent.class,
+        IntentServiceSubcomponent.class,
+        BroadcastReceiverSubcomponent.class,
+      }
+    )
+    abstract class ApplicationModule {
+      @Provides
+      @IntoSet
+      static Class<?> addToComponentHierarchy() {
+        return ApplicationComponent.class;
+      }
+
+      @Binds
+      @IntoMap
+      @ActivityKey(TestActivity.class)
+      abstract AndroidInjector.Factory<? extends Activity> bindFactoryForTestActivity(
+          ActivitySubcomponent.Builder builder);
+
+      @Binds
+      @IntoMap
+      @FragmentKey(TestParentFragment.class)
+      abstract AndroidInjector.Factory<? extends Fragment> bindFactoryForParentFragment(
+          ParentFragmentSubcomponent.Builder builder);
+
+      @Binds
+      @IntoMap
+      @FragmentKey(TestChildFragment.class)
+      abstract AndroidInjector.Factory<? extends Fragment> bindFactoryForChildFragment(
+          ChildFragmentSubcomponent.Builder builder);
+
+      @Binds
+      @IntoMap
+      @ServiceKey(TestService.class)
+      abstract AndroidInjector.Factory<? extends Service> bindFactoryForService(
+          ServiceSubcomponent.Builder b);
+
+      @Binds
+      @IntoMap
+      @ServiceKey(TestIntentService.class)
+      abstract AndroidInjector.Factory<? extends Service> bindFactoryForIntentService(
+          IntentServiceSubcomponent.Builder b);
+
+      @Binds
+      @IntoMap
+      @BroadcastReceiverKey(TestBroadcastReceiver.class)
+      abstract AndroidInjector.Factory<? extends BroadcastReceiver> bindFactoryForBroadcastReceiver(
+          BroadcastReceiverSubcomponent.Builder b);
+    }
+
+    @Subcomponent(modules = ActivitySubcomponent.ActivityModule.class)
+    interface ActivitySubcomponent extends AndroidInjector<TestActivity> {
+      @Module
+      abstract class ActivityModule {
+        @Provides
+        @IntoSet
+        static Class<?> addToComponentHierarchy() {
+          return ActivitySubcomponent.class;
+        }
+      }
+
+      @Subcomponent.Builder
+      abstract class Builder extends AndroidInjector.Builder<TestActivity> {}
+    }
+
+    @Subcomponent(modules = ParentFragmentSubcomponent.ParentFragmentModule.class)
+    interface ParentFragmentSubcomponent extends AndroidInjector<TestParentFragment> {
+      @Module
+      abstract class ParentFragmentModule {
+        @Provides
+        @IntoSet
+        static Class<?> addToComponentHierarchy() {
+          return ParentFragmentSubcomponent.class;
+        }
+      }
+
+      @Subcomponent.Builder
+      abstract class Builder extends AndroidInjector.Builder<TestParentFragment> {}
+    }
+
+    @Subcomponent(modules = ChildFragmentSubcomponent.ChildFragmentModule.class)
+    interface ChildFragmentSubcomponent extends AndroidInjector<TestChildFragment> {
+      @Module
+      abstract class ChildFragmentModule {
+        @Provides
+        @IntoSet
+        static Class<?> addToComponentHierarchy() {
+          return ChildFragmentSubcomponent.class;
+        }
+      }
+
+      @Subcomponent.Builder
+      abstract class Builder extends AndroidInjector.Builder<TestChildFragment> {}
+    }
+
+    @Subcomponent(modules = ServiceModule.class)
+    interface ServiceSubcomponent extends AndroidInjector<TestService> {
+      @Subcomponent.Builder
+      abstract class Builder extends AndroidInjector.Builder<TestService> {}
+
+      @Module
+      abstract class ServiceModule {
+        @Provides
+        @IntoSet
+        static Class<?> addToComponentHierarchy() {
+          return ServiceSubcomponent.class;
+        }
+      }
+    }
+
+    @Subcomponent(modules = IntentServiceModule.class)
+    interface IntentServiceSubcomponent extends AndroidInjector<TestIntentService> {
+      @Subcomponent.Builder
+      abstract class Builder extends AndroidInjector.Builder<TestIntentService> {}
+
+      @Module
+      abstract class IntentServiceModule {
+        @Provides
+        @IntoSet
+        static Class<?> addToComponentHierarchy() {
+          return IntentServiceSubcomponent.class;
+        }
+      }
+    }
+
+    @Subcomponent(modules = BroadcastReceiverModule.class)
+    interface BroadcastReceiverSubcomponent extends AndroidInjector<TestBroadcastReceiver> {
+      @Subcomponent.Builder
+      abstract class Builder extends AndroidInjector.Builder<TestBroadcastReceiver> {}
+
+      @Module
+      abstract class BroadcastReceiverModule {
+        @Provides
+        @IntoSet
+        static Class<?> addToComponentHierarchy() {
+          return BroadcastReceiverSubcomponent.class;
+        }
+      }
+    }
+  }
+}
diff --git a/javatests/dagger/android/support/functional/AndroidManifest.xml b/javatests/dagger/android/support/functional/AndroidManifest.xml
new file mode 100644
index 000000000..1ace8cb8f
--- /dev/null
+++ b/javatests/dagger/android/support/functional/AndroidManifest.xml
@@ -0,0 +1,24 @@
+<!--
+  ~ Copyright (C) 2017 The Dagger Authors.
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~ http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  -->
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+  package="dagger.android.support.functional">
+
+  <application android:theme="@style/Theme.AppCompat">
+    <activity android:name="dagger.android.support.functional.ParentOfFragmentActivity"/>
+    <activity android:name="dagger.android.support.functional.SiblingOfFragmentActivity"/>
+    <activity android:name="dagger.android.support.functional.InjectedWithoutSubcomponentActivity"/>
+  </application>
+</manifest>
diff --git a/javatests/dagger/android/support/functional/BUILD b/javatests/dagger/android/support/functional/BUILD
new file mode 100644
index 000000000..ee7a3050f
--- /dev/null
+++ b/javatests/dagger/android/support/functional/BUILD
@@ -0,0 +1,52 @@
+# Copyright (C) 2017 The Dagger Authors.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+# Description:
+#   Functional test code for Dagger-Android
+
+package(default_visibility = ["//:src"])
+
+android_library(
+    name = "functional",
+    srcs = glob(
+        ["*.java"],
+        exclude = ["*Test.java"],
+    ),
+    manifest = "AndroidManifest.xml",
+    resource_files = glob(["res/**"]),
+    deps = [
+        "//:dagger_with_compiler",
+        "//java/dagger/android",
+        "//java/dagger/android/support",
+        "//third_party:guava",
+        "@androidsdk//com.android.support:appcompat-v7-25.0.0",
+        "@androidsdk//com.android.support:support-v4-25.0.0",
+    ],
+)
+
+load("//:test_defs.bzl", "GenRobolectricTests")
+
+GenRobolectricTests(
+    name = "functional_tests",
+    srcs = glob(["*Test.java"]),
+    deps = [
+        ":functional",
+        "//:dagger_with_compiler",
+        "//java/dagger/android",
+        "//java/dagger/android/support",
+        "//third_party:junit",
+        "//third_party:truth",
+        "@androidsdk//com.android.support:support-v4-25.0.0",
+    ],
+)
diff --git a/javatests/dagger/android/support/functional/ComponentStructureFollowsControllerStructureApplication.java b/javatests/dagger/android/support/functional/ComponentStructureFollowsControllerStructureApplication.java
new file mode 100644
index 000000000..705b9b3a6
--- /dev/null
+++ b/javatests/dagger/android/support/functional/ComponentStructureFollowsControllerStructureApplication.java
@@ -0,0 +1,224 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.support.functional;
+
+import android.app.Activity;
+import android.app.Application;
+import android.app.Service;
+import android.content.BroadcastReceiver;
+import android.support.v4.app.Fragment;
+import dagger.Binds;
+import dagger.Component;
+import dagger.Module;
+import dagger.Provides;
+import dagger.Subcomponent;
+import dagger.android.ActivityKey;
+import dagger.android.AndroidInjector;
+import dagger.android.BroadcastReceiverKey;
+import dagger.android.DispatchingAndroidInjector;
+import dagger.android.HasDispatchingActivityInjector;
+import dagger.android.HasDispatchingBroadcastReceiverInjector;
+import dagger.android.HasDispatchingServiceInjector;
+import dagger.android.ServiceKey;
+import dagger.android.support.AndroidSupportInjectionModule;
+import dagger.android.support.FragmentKey;
+import dagger.android.support.functional.ComponentStructureFollowsControllerStructureApplication.ApplicationComponent.BroadcastReceiverSubcomponent.BroadcastReceiverModule;
+import dagger.android.support.functional.ComponentStructureFollowsControllerStructureApplication.ApplicationComponent.IntentServiceSubcomponent.IntentServiceModule;
+import dagger.android.support.functional.ComponentStructureFollowsControllerStructureApplication.ApplicationComponent.ServiceSubcomponent.ServiceModule;
+import dagger.multibindings.IntoMap;
+import dagger.multibindings.IntoSet;
+import javax.inject.Inject;
+
+public final class ComponentStructureFollowsControllerStructureApplication extends Application
+    implements HasDispatchingActivityInjector,
+        HasDispatchingServiceInjector,
+        HasDispatchingBroadcastReceiverInjector {
+  @Inject DispatchingAndroidInjector<Activity> activityInjector;
+  @Inject DispatchingAndroidInjector<Service> serviceInjector;
+  @Inject DispatchingAndroidInjector<BroadcastReceiver> broadcastReceiverInjector;
+
+  @Override
+  public void onCreate() {
+    super.onCreate();
+    DaggerComponentStructureFollowsControllerStructureApplication_ApplicationComponent.create()
+        .inject(this);
+  }
+
+  @Override
+  public DispatchingAndroidInjector<Activity> activityInjector() {
+    return activityInjector;
+  }
+
+  @Override
+  public DispatchingAndroidInjector<Service> serviceInjector() {
+    return serviceInjector;
+  }
+
+  @Override
+  public DispatchingAndroidInjector<BroadcastReceiver> broadcastReceiverInjector() {
+    return broadcastReceiverInjector;
+  }
+
+  @Component(
+    modules = {ApplicationComponent.ApplicationModule.class, AndroidSupportInjectionModule.class}
+  )
+  interface ApplicationComponent {
+    void inject(ComponentStructureFollowsControllerStructureApplication application);
+
+    @Module(
+      subcomponents = {
+        ActivitySubcomponent.class,
+        ServiceSubcomponent.class,
+        IntentServiceSubcomponent.class,
+        BroadcastReceiverSubcomponent.class,
+      }
+    )
+    abstract class ApplicationModule {
+      @Provides
+      @IntoSet
+      static Class<?> addToComponentHierarchy() {
+        return ApplicationComponent.class;
+      }
+
+      @Binds
+      @IntoMap
+      @ActivityKey(TestActivity.class)
+      abstract AndroidInjector.Factory<? extends Activity> bindFactoryForTestActivity(
+          ActivitySubcomponent.Builder builder);
+
+      @Binds
+      @IntoMap
+      @ServiceKey(TestService.class)
+      abstract AndroidInjector.Factory<? extends Service> bindFactoryForService(
+          ServiceSubcomponent.Builder b);
+
+      @Binds
+      @IntoMap
+      @ServiceKey(TestIntentService.class)
+      abstract AndroidInjector.Factory<? extends Service> bindFactoryForIntentService(
+          IntentServiceSubcomponent.Builder b);
+
+      @Binds
+      @IntoMap
+      @BroadcastReceiverKey(TestBroadcastReceiver.class)
+      abstract AndroidInjector.Factory<? extends BroadcastReceiver> bindFactoryForBroadcastReceiver(
+          BroadcastReceiverSubcomponent.Builder b);
+    }
+
+    @Subcomponent(modules = ActivitySubcomponent.ActivityModule.class)
+    interface ActivitySubcomponent extends AndroidInjector<TestActivity> {
+      @Module(subcomponents = ParentFragmentSubcomponent.class)
+      abstract class ActivityModule {
+        @Provides
+        @IntoSet
+        static Class<?> addToComponentHierarchy() {
+          return ActivitySubcomponent.class;
+        }
+
+        @Binds
+        @IntoMap
+        @FragmentKey(TestParentFragment.class)
+        abstract AndroidInjector.Factory<? extends Fragment> bindFactoryForParentFragment(
+            ParentFragmentSubcomponent.Builder builder);
+      }
+
+      @Subcomponent.Builder
+      abstract class Builder extends AndroidInjector.Builder<TestActivity> {}
+
+      @Subcomponent(modules = ParentFragmentSubcomponent.ParentFragmentModule.class)
+      interface ParentFragmentSubcomponent extends AndroidInjector<TestParentFragment> {
+        @Module(subcomponents = ChildFragmentSubcomponent.class)
+        abstract class ParentFragmentModule {
+          @Provides
+          @IntoSet
+          static Class<?> addToComponentHierarchy() {
+            return ParentFragmentSubcomponent.class;
+          }
+
+          @Binds
+          @IntoMap
+          @FragmentKey(TestChildFragment.class)
+          abstract AndroidInjector.Factory<? extends Fragment> bindFactoryForChildFragment(
+              ChildFragmentSubcomponent.Builder builder);
+        }
+
+        @Subcomponent.Builder
+        abstract class Builder extends AndroidInjector.Builder<TestParentFragment> {}
+
+        @Subcomponent(modules = ChildFragmentSubcomponent.ChildFragmentModule.class)
+        interface ChildFragmentSubcomponent extends AndroidInjector<TestChildFragment> {
+          @Module
+          abstract class ChildFragmentModule {
+            @Provides
+            @IntoSet
+            static Class<?> addToComponentHierarchy() {
+              return ChildFragmentSubcomponent.class;
+            }
+          }
+
+          @Subcomponent.Builder
+          abstract class Builder extends AndroidInjector.Builder<TestChildFragment> {}
+        }
+      }
+    }
+
+    @Subcomponent(modules = ServiceModule.class)
+    interface ServiceSubcomponent extends AndroidInjector<TestService> {
+      @Subcomponent.Builder
+      abstract class Builder extends AndroidInjector.Builder<TestService> {}
+
+      @Module
+      abstract class ServiceModule {
+        @Provides
+        @IntoSet
+        static Class<?> addToComponentHierarchy() {
+          return ServiceSubcomponent.class;
+        }
+      }
+    }
+
+    @Subcomponent(modules = IntentServiceModule.class)
+    interface IntentServiceSubcomponent extends AndroidInjector<TestIntentService> {
+      @Subcomponent.Builder
+      abstract class Builder extends AndroidInjector.Builder<TestIntentService> {}
+
+      @Module
+      abstract class IntentServiceModule {
+        @Provides
+        @IntoSet
+        static Class<?> addToComponentHierarchy() {
+          return IntentServiceSubcomponent.class;
+        }
+      }
+    }
+
+    @Subcomponent(modules = BroadcastReceiverModule.class)
+    interface BroadcastReceiverSubcomponent extends AndroidInjector<TestBroadcastReceiver> {
+      @Subcomponent.Builder
+      abstract class Builder extends AndroidInjector.Builder<TestBroadcastReceiver> {}
+
+      @Module
+      abstract class BroadcastReceiverModule {
+        @Provides
+        @IntoSet
+        static Class<?> addToComponentHierarchy() {
+          return BroadcastReceiverSubcomponent.class;
+        }
+      }
+    }
+  }
+}
diff --git a/javatests/dagger/android/support/functional/InjectorsTest.java b/javatests/dagger/android/support/functional/InjectorsTest.java
new file mode 100644
index 000000000..bf3a85b73
--- /dev/null
+++ b/javatests/dagger/android/support/functional/InjectorsTest.java
@@ -0,0 +1,161 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.support.functional;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.content.Intent;
+import android.content.res.Configuration;
+import org.robolectric.RobolectricTestRunner;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.android.controller.ActivityController;
+import org.robolectric.annotation.Config;
+
+@RunWith(RobolectricTestRunner.class)
+public class InjectorsTest {
+  private static final String MANIFEST =
+      "//javatests/dagger/android/support/functional"
+          + ":functional/AndroidManifest.xml";
+
+  private ActivityController<TestActivity> activityController;
+  private TestActivity activity;
+  private TestParentFragment parentFragment;
+  private TestChildFragment childFragment;
+  private TestService service;
+  private TestIntentService intentService;
+  private TestBroadcastReceiver broadcastReceiver;
+
+  @Before
+  public void setUp() {
+    activityController = Robolectric.buildActivity(TestActivity.class);
+    activity = activityController.setup().get();
+    parentFragment =
+        (TestParentFragment)
+            activity.getSupportFragmentManager().findFragmentByTag("parent-fragment");
+    childFragment =
+        (TestChildFragment)
+            parentFragment.getChildFragmentManager().findFragmentByTag("child-fragment");
+
+    service = Robolectric.buildService(TestService.class).create().get();
+    intentService = Robolectric.buildIntentService(TestIntentService.class).create().get();
+
+    broadcastReceiver = new TestBroadcastReceiver();
+    broadcastReceiver.onReceive(RuntimeEnvironment.application, new Intent());
+  }
+
+  @Test
+  @Config(
+    manifest = MANIFEST,
+    application = ComponentStructureFollowsControllerStructureApplication.class
+  )
+  public void componentStructureFollowsControllerStructure() {
+    assertThat(activity.componentHierarchy)
+        .containsExactly(
+            ComponentStructureFollowsControllerStructureApplication.ApplicationComponent.class,
+            ComponentStructureFollowsControllerStructureApplication.ApplicationComponent
+                .ActivitySubcomponent.class);
+    assertThat(parentFragment.componentHierarchy)
+        .containsExactly(
+            ComponentStructureFollowsControllerStructureApplication.ApplicationComponent.class,
+            ComponentStructureFollowsControllerStructureApplication.ApplicationComponent
+                .ActivitySubcomponent.class,
+            ComponentStructureFollowsControllerStructureApplication.ApplicationComponent
+                .ActivitySubcomponent.ParentFragmentSubcomponent.class);
+    assertThat(childFragment.componentHierarchy)
+        .containsExactly(
+            ComponentStructureFollowsControllerStructureApplication.ApplicationComponent.class,
+            ComponentStructureFollowsControllerStructureApplication.ApplicationComponent
+                .ActivitySubcomponent.class,
+            ComponentStructureFollowsControllerStructureApplication.ApplicationComponent
+                .ActivitySubcomponent.ParentFragmentSubcomponent.class,
+            ComponentStructureFollowsControllerStructureApplication.ApplicationComponent
+                .ActivitySubcomponent.ParentFragmentSubcomponent.ChildFragmentSubcomponent.class);
+
+    assertThat(service.componentHierarchy)
+        .containsExactly(
+            ComponentStructureFollowsControllerStructureApplication.ApplicationComponent.class,
+            ComponentStructureFollowsControllerStructureApplication.ApplicationComponent
+                .ServiceSubcomponent.class);
+    assertThat(intentService.componentHierarchy)
+        .containsExactly(
+            ComponentStructureFollowsControllerStructureApplication.ApplicationComponent.class,
+            ComponentStructureFollowsControllerStructureApplication.ApplicationComponent
+                .IntentServiceSubcomponent.class);
+
+    assertThat(broadcastReceiver.componentHierarchy)
+        .containsExactly(
+            ComponentStructureFollowsControllerStructureApplication.ApplicationComponent.class,
+            ComponentStructureFollowsControllerStructureApplication.ApplicationComponent
+                .BroadcastReceiverSubcomponent.class);
+
+    changeConfiguration();
+  }
+
+  @Test
+  @Config(manifest = MANIFEST, application = AllControllersAreDirectChildrenOfApplication.class)
+  public void AllControllersAreDirectChildrenOfApplication() {
+    assertThat(activity.componentHierarchy)
+        .containsExactly(
+            AllControllersAreDirectChildrenOfApplication.ApplicationComponent.class,
+            AllControllersAreDirectChildrenOfApplication.ApplicationComponent.ActivitySubcomponent
+                .class);
+    assertThat(parentFragment.componentHierarchy)
+        .containsExactly(
+            AllControllersAreDirectChildrenOfApplication.ApplicationComponent.class,
+            AllControllersAreDirectChildrenOfApplication.ApplicationComponent
+                .ParentFragmentSubcomponent.class);
+    assertThat(childFragment.componentHierarchy)
+        .containsExactly(
+            AllControllersAreDirectChildrenOfApplication.ApplicationComponent.class,
+            AllControllersAreDirectChildrenOfApplication.ApplicationComponent
+                .ChildFragmentSubcomponent.class);
+
+    assertThat(service.componentHierarchy)
+        .containsExactly(
+            AllControllersAreDirectChildrenOfApplication.ApplicationComponent.class,
+            AllControllersAreDirectChildrenOfApplication.ApplicationComponent
+                .ServiceSubcomponent.class);
+    assertThat(intentService.componentHierarchy)
+        .containsExactly(
+            AllControllersAreDirectChildrenOfApplication.ApplicationComponent.class,
+            AllControllersAreDirectChildrenOfApplication.ApplicationComponent
+                .IntentServiceSubcomponent.class);
+
+    assertThat(broadcastReceiver.componentHierarchy)
+        .containsExactly(
+            AllControllersAreDirectChildrenOfApplication.ApplicationComponent.class,
+            AllControllersAreDirectChildrenOfApplication.ApplicationComponent
+                .BroadcastReceiverSubcomponent.class);
+
+    changeConfiguration();
+  }
+
+  // https://github.com/google/dagger/issues/598
+  private void changeConfiguration() {
+    Configuration oldConfiguration = activity.getResources().getConfiguration();
+    Configuration newConfiguration = new Configuration(oldConfiguration);
+    newConfiguration.orientation =
+        oldConfiguration.orientation == Configuration.ORIENTATION_LANDSCAPE
+            ? Configuration.ORIENTATION_PORTRAIT
+            : Configuration.ORIENTATION_LANDSCAPE;
+    activityController.configurationChange(newConfiguration);
+  }
+}
diff --git a/javatests/dagger/android/support/functional/TestActivity.java b/javatests/dagger/android/support/functional/TestActivity.java
new file mode 100644
index 000000000..c4fda4293
--- /dev/null
+++ b/javatests/dagger/android/support/functional/TestActivity.java
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.support.functional;
+
+import android.os.Bundle;
+import dagger.android.support.DaggerAppCompatActivity;
+import java.util.Set;
+import javax.inject.Inject;
+
+public final class TestActivity extends DaggerAppCompatActivity {
+  @Inject Set<Class<?>> componentHierarchy;
+
+  @Override
+  protected void onCreate(Bundle savedInstanceState) {
+    super.onCreate(savedInstanceState);
+
+    setContentView(R.layout.activity_layout);
+
+    getSupportFragmentManager()
+        .beginTransaction()
+        .add(new TestParentFragment(), "parent-fragment")
+        .commit();
+  }
+}
diff --git a/javatests/dagger/android/support/functional/TestBroadcastReceiver.java b/javatests/dagger/android/support/functional/TestBroadcastReceiver.java
new file mode 100644
index 000000000..edf93fef1
--- /dev/null
+++ b/javatests/dagger/android/support/functional/TestBroadcastReceiver.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.support.functional;
+
+import dagger.android.DaggerBroadcastReceiver;
+import java.util.Set;
+import javax.inject.Inject;
+
+public final class TestBroadcastReceiver extends DaggerBroadcastReceiver {
+  @Inject Set<Class<?>> componentHierarchy;
+}
diff --git a/javatests/dagger/android/support/functional/TestChildFragment.java b/javatests/dagger/android/support/functional/TestChildFragment.java
new file mode 100644
index 000000000..781c57809
--- /dev/null
+++ b/javatests/dagger/android/support/functional/TestChildFragment.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.support.functional;
+
+import dagger.android.support.DaggerFragment;
+import java.util.Set;
+import javax.inject.Inject;
+
+public final class TestChildFragment extends DaggerFragment {
+  @Inject Set<Class<?>> componentHierarchy;
+}
diff --git a/javatests/dagger/android/support/functional/TestIntentService.java b/javatests/dagger/android/support/functional/TestIntentService.java
new file mode 100644
index 000000000..dc301d493
--- /dev/null
+++ b/javatests/dagger/android/support/functional/TestIntentService.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.support.functional;
+
+import android.content.Intent;
+import dagger.android.DaggerIntentService;
+import java.util.Set;
+import javax.inject.Inject;
+
+public final class TestIntentService extends DaggerIntentService {
+  @Inject Set<Class<?>> componentHierarchy;
+
+  public TestIntentService(String name) {
+    super(name);
+  }
+
+  @Override
+  protected void onHandleIntent(Intent intent) {}
+}
diff --git a/javatests/dagger/android/support/functional/TestParentFragment.java b/javatests/dagger/android/support/functional/TestParentFragment.java
new file mode 100644
index 000000000..6d2d6f47d
--- /dev/null
+++ b/javatests/dagger/android/support/functional/TestParentFragment.java
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.support.functional;
+
+import android.content.Context;
+import dagger.android.support.DaggerFragment;
+import java.util.Set;
+import javax.inject.Inject;
+
+public final class TestParentFragment extends DaggerFragment {
+  @Inject Set<Class<?>> componentHierarchy;
+
+  @Override
+  public void onAttach(Context context) {
+    super.onAttach(context);
+    getChildFragmentManager()
+        .beginTransaction()
+        .add(new TestChildFragment(), "child-fragment")
+        .commit();
+  }
+}
diff --git a/javatests/dagger/android/support/functional/TestService.java b/javatests/dagger/android/support/functional/TestService.java
new file mode 100644
index 000000000..d3c6dc1cc
--- /dev/null
+++ b/javatests/dagger/android/support/functional/TestService.java
@@ -0,0 +1,77 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.support.functional;
+
+import android.content.Intent;
+import android.os.IBinder;
+import android.os.IInterface;
+import android.os.Parcel;
+import android.os.RemoteException;
+import dagger.android.DaggerService;
+import java.io.FileDescriptor;
+import java.util.Set;
+import javax.inject.Inject;
+
+public final class TestService extends DaggerService {
+  @Inject Set<Class<?>> componentHierarchy;
+
+  @Override
+  public IBinder onBind(Intent intent) {
+    return new MockBinder();
+  }
+
+  private static class MockBinder implements IBinder {
+    @Override
+    public String getInterfaceDescriptor() throws RemoteException {
+      return null;
+    }
+
+    @Override
+    public boolean pingBinder() {
+      return false;
+    }
+
+    @Override
+    public boolean isBinderAlive() {
+      return false;
+    }
+
+    @Override
+    public IInterface queryLocalInterface(String descriptor) {
+      return null;
+    }
+
+    @Override
+    public void dump(FileDescriptor fd, String[] args) throws RemoteException {}
+
+    @Override
+    public void dumpAsync(FileDescriptor fd, String[] args) throws RemoteException {}
+
+    @Override
+    public boolean transact(int code, Parcel data, Parcel reply, int flags) throws RemoteException {
+      return false;
+    }
+
+    @Override
+    public void linkToDeath(DeathRecipient recipient, int flags) throws RemoteException {}
+
+    @Override
+    public boolean unlinkToDeath(DeathRecipient recipient, int flags) {
+      return false;
+    }
+  }
+}
diff --git a/javatests/dagger/android/support/functional/res/layout/activity_layout.xml b/javatests/dagger/android/support/functional/res/layout/activity_layout.xml
new file mode 100644
index 000000000..d886d971d
--- /dev/null
+++ b/javatests/dagger/android/support/functional/res/layout/activity_layout.xml
@@ -0,0 +1,21 @@
+<!--
+  ~ Copyright (C) 2016 The Dagger Authors.
+  ~
+  ~  Licensed under the Apache License, Version 2.0 (the "License");
+  ~  you may not use this file except in compliance with the License.
+  ~  You may obtain a copy of the License at
+  ~
+  ~  http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~  Unless required by applicable law or agreed to in writing, software
+  ~  distributed under the License is distributed on an "AS IS" BASIS,
+  ~  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~  See the License for the specific language governing permissions and
+  ~  limitations under the License.
+  -->
+
+<FrameLayout
+  xmlns:android="http://schemas.android.com/apk/res/android"
+  android:id="@+id/fragment_container"
+  android:layout_width="match_parent"
+  android:layout_height="match_parent" />
diff --git a/maven_sha1_test.py b/maven_sha1_test.py
new file mode 100644
index 000000000..c999dfafa
--- /dev/null
+++ b/maven_sha1_test.py
@@ -0,0 +1,42 @@
+# Copyright (C) 2017 The Dagger Authors.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+import ast
+import unittest
+
+class WorkspaceVisitor(ast.NodeVisitor):
+  def __init__(self):
+    self.missing_sha1 = []
+
+  def visit_Call(self, rule):
+    if rule.func.id == 'maven_jar':
+      name = None
+      for parameter in rule.keywords:
+        if parameter.arg == 'sha1':
+          return
+        if parameter.arg == 'name':
+          name = parameter.value.s
+      self.missing_sha1.append(name)
+
+class MavenSha1Test(unittest.TestCase):
+  def test_each_maven_jar_rule_has_sha1(self):
+    with open('WORKSPACE', 'r') as workspace:
+      visitor = WorkspaceVisitor()
+      visitor.visit(ast.parse(workspace.read()))
+      if len(visitor.missing_sha1) > 0:
+        missing = ', '.join(visitor.missing_sha1)
+        self.fail('%s did not specify a sha1' % missing)
+
+if __name__ == '__main__':
+  unittest.main()
diff --git a/pom.xml b/pom.xml
index b81f8c8b6..8c7a198f3 100644
--- a/pom.xml
+++ b/pom.xml
@@ -1,7 +1,6 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <!--
-  Copyright (C) 2012 Google, Inc.
-  Copyright (C) 2012 Square, Inc.
+  Copyright (C) 2012 The Dagger Authors.
 
   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
@@ -27,10 +26,10 @@
   <groupId>com.google.dagger</groupId>
   <artifactId>dagger-parent</artifactId>
   <packaging>pom</packaging>
-  <version>2.5-SNAPSHOT</version>
+  <version>HEAD-SNAPSHOT</version>
   <name>Dagger (Parent)</name>
   <description>A fast dependency injector for Android and Java.</description>
-  <url>https://github.com/square/dagger</url>
+  <url>https://github.com/google/dagger</url>
 
   <modules>
     <module>compiler</module>
@@ -42,25 +41,8 @@
 
   <properties>
     <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
-
-    <!-- Compilation -->
-    <java.version>1.7</java.version>
-    <javax.inject.version>1</javax.inject.version>
-    <javax.annotation.version>3.0.1</javax.annotation.version>
-    <auto.common.version>0.6</auto.common.version>
-    <auto.factory.version>1.0-beta3</auto.factory.version>
-    <auto.service.version>1.0-rc2</auto.service.version>
-    <auto.value.version>1.2</auto.value.version>
-    <errorprone.version>2.0.8</errorprone.version>
-    <guava.version>19.0</guava.version>
-    <google.java.format.version>1.0</google.java.format.version>
-
-
-    <!-- Test Dependencies -->
-    <compile-testing.version>0.9</compile-testing.version>
-    <junit.version>4.11</junit.version>
-    <mockito.version>1.9.5</mockito.version>
-    <truth.version>0.28</truth.version>
+    <android.support.version>24.2.0</android.support.version>
+    <android.latest.version>25</android.latest.version>
   </properties>
 
   <scm>
@@ -92,72 +74,88 @@
       <dependency>
         <groupId>javax.inject</groupId>
         <artifactId>javax.inject</artifactId>
-        <version>${javax.inject.version}</version>
+        <version>1</version>
+      </dependency>
+      <dependency>
+        <groupId>javax.inject</groupId>
+        <artifactId>javax.inject</artifactId>
+        <classifier>sources</classifier>
+        <version>1</version>
       </dependency>
-       <dependency>
+      <dependency>
         <groupId>javax.inject</groupId>
         <artifactId>javax.inject-tck</artifactId>
-        <version>${javax.inject.version}</version>
+        <version>1</version>
       </dependency>
       <dependency>
         <groupId>com.google.code.findbugs</groupId>
         <artifactId>jsr305</artifactId>
-        <version>${javax.annotation.version}</version>
+        <version>3.0.1</version>
       </dependency>
       <dependency>
         <groupId>com.google.guava</groupId>
         <artifactId>guava</artifactId>
-        <version>${guava.version}</version>
+        <version>20.0-rc1</version>
       </dependency>
       <dependency>
         <groupId>com.google.guava</groupId>
         <artifactId>guava-testlib</artifactId>
-        <version>${guava.version}</version>
+        <version>20.0-rc1</version>
       </dependency>
       <dependency>
         <groupId>com.google.googlejavaformat</groupId>
         <artifactId>google-java-format</artifactId>
-        <version>${google.java.format.version}</version>
+        <version>1.3</version>
       </dependency>
       <dependency>
         <groupId>com.google.auto</groupId>
         <artifactId>auto-common</artifactId>
-        <version>${auto.common.version}</version>
+        <version>0.8</version>
+      </dependency>
+      <dependency>
+        <groupId>com.google.auto.factory</groupId>
+        <artifactId>auto-factory</artifactId>
+        <version>1.0-beta3</version>
       </dependency>
       <dependency>
         <groupId>com.google.auto.service</groupId>
         <artifactId>auto-service</artifactId>
-        <version>${auto.service.version}</version>
+        <version>1.0-rc2</version>
       </dependency>
       <dependency>
         <groupId>com.google.auto.value</groupId>
         <artifactId>auto-value</artifactId>
-        <version>${auto.value.version}</version>
+        <version>1.4-rc1</version>
       </dependency>
       <dependency>
         <groupId>com.google.errorprone</groupId>
         <artifactId>error_prone_annotations</artifactId>
-        <version>${errorprone.version}</version>
+        <version>2.0.12</version>
       </dependency>
       <dependency>
         <groupId>junit</groupId>
         <artifactId>junit</artifactId>
-        <version>${junit.version}</version>
+        <version>4.11</version>
       </dependency>
       <dependency>
         <groupId>com.google.testing.compile</groupId>
         <artifactId>compile-testing</artifactId>
-        <version>${compile-testing.version}</version>
+        <version>0.10</version>
       </dependency>
       <dependency>
         <groupId>org.mockito</groupId>
         <artifactId>mockito-core</artifactId>
-        <version>${mockito.version}</version>
+        <version>1.9.5</version>
       </dependency>
       <dependency>
         <groupId>com.google.truth</groupId>
         <artifactId>truth</artifactId>
-        <version>${truth.version}</version>
+        <version>0.30</version>
+      </dependency>
+      <dependency>
+        <groupId>com.squareup</groupId>
+        <artifactId>javapoet</artifactId>
+        <version>1.7.0</version>
       </dependency>
     </dependencies>
   </dependencyManagement>
@@ -184,8 +182,8 @@
       <plugin>
         <artifactId>maven-compiler-plugin</artifactId>
         <configuration>
-          <source>${java.version}</source>
-          <target>${java.version}</target>
+          <source>1.7</source>
+          <target>1.7</target>
           <compilerArgument>-Xlint:all</compilerArgument>
           <showWarnings>true</showWarnings>
           <showDeprecation>true</showDeprecation>
@@ -202,29 +200,14 @@
 
       <plugin>
         <artifactId>maven-javadoc-plugin</artifactId>
+        <version>2.10.4</version>
         <configuration>
           <windowtitle>Dagger Dependency Injection ${project.version} API</windowtitle>
           <doctitle>Dagger Dependency Injection ${project.version} API</doctitle>
+          <docfilessubdirs>true</docfilessubdirs>
+          <additionalparam>-Xdoclint:html,reference,syntax</additionalparam>
         </configuration>
       </plugin>
-
-      <plugin>
-        <artifactId>maven-checkstyle-plugin</artifactId>
-        <version>2.10</version>
-        <configuration>
-          <failsOnError>false</failsOnError>
-          <consoleOutput>true</consoleOutput>
-          <configLocation>checkstyle.xml</configLocation>
-        </configuration>
-        <executions>
-          <execution>
-            <phase>compile</phase>
-            <goals>
-              <goal>checkstyle</goal>
-            </goals>
-          </execution>
-        </executions>
-      </plugin>
     </plugins>
   </build>
 
diff --git a/producers/BUILD b/producers/BUILD
new file mode 100644
index 000000000..1fd2de12e
--- /dev/null
+++ b/producers/BUILD
@@ -0,0 +1,81 @@
+# Copyright (C) 2017 The Dagger Authors.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+# Description:
+#   An asynchronous dependency injection system that extends JSR-330.
+
+package(default_visibility = ["//:src"])
+
+load(
+    "//:build_defs.bzl",
+    "DOCLINT_HTML_AND_SYNTAX",
+    "DOCLINT_REFERENCES",
+    "SOURCE_7_TARGET_7",
+    "JAVA_7_SOURCE_LEVEL",
+    "PRE_JAVA_8_INFERENCE_OPTS",
+)
+
+filegroup(
+    name = "producers-srcs",
+    srcs = glob(["src/main/java/**/*.java"]),
+)
+
+java_library(
+    name = "producers",
+    srcs = [":producers-srcs"],
+    javacopts = PRE_JAVA_8_INFERENCE_OPTS + SOURCE_7_TARGET_7 + DOCLINT_HTML_AND_SYNTAX + DOCLINT_REFERENCES,
+    plugins = [
+        # TODO(cgruber): Enable Beta checker.
+    ],
+    exports = [
+        # TODO(dpb): Don't export any of Guava.
+        "//third_party:guava",
+        "//third_party:jsr330_inject",
+    ],
+    deps = [
+        "//core",
+        "//third_party:guava",
+        "//third_party:jsr305_annotations",
+        "//third_party:jsr330_inject",
+    ],
+)
+
+load("//tools:javadoc.bzl", "javadoc_library")
+
+javadoc_library(
+    name = "producers-javadoc",
+    srcs = [":producers-srcs"],
+    exclude_packages = [
+        "dagger.producers.internal",
+        "dagger.producers.monitoring.internal",
+    ],
+    root_packages = ["dagger.producers"],
+    deps = [":producers"],
+)
+
+load("//:test_defs.bzl", "GenJavaTests")
+
+GenJavaTests(
+    name = "produces_tests",
+    srcs = glob(["src/test/java/**/*.java"]),
+    javacopts = PRE_JAVA_8_INFERENCE_OPTS + JAVA_7_SOURCE_LEVEL,
+    deps = [
+        ":producers",
+        "//third_party:guava",
+        "//third_party:guava_testlib",
+        "//third_party:junit",
+        "//third_party:mockito",
+        "//third_party:truth",
+    ],
+)
diff --git a/producers/pom.xml b/producers/pom.xml
index b20421b62..67aafefd6 100644
--- a/producers/pom.xml
+++ b/producers/pom.xml
@@ -1,6 +1,6 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <!--
- Copyright (C) 2014 Google, Inc.
+ Copyright (C) 2014 The Dagger Authors.
 
   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.google.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>2.5-SNAPSHOT</version>
+    <version>HEAD-SNAPSHOT</version>
   </parent>
 
   <artifactId>dagger-producers</artifactId>
diff --git a/producers/src/main/java/dagger/producers/Produced.java b/producers/src/main/java/dagger/producers/Produced.java
index 59af18274..1f5dba073 100644
--- a/producers/src/main/java/dagger/producers/Produced.java
+++ b/producers/src/main/java/dagger/producers/Produced.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Google Inc.
+ * Copyright (C) 2014 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,16 +13,17 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.producers;
 
+import static com.google.common.base.Preconditions.checkNotNull;
+
 import com.google.common.base.Objects;
 import dagger.internal.Beta;
 import java.util.concurrent.ExecutionException;
 import javax.annotation.CheckReturnValue;
 import javax.annotation.Nullable;
 
-import static com.google.common.base.Preconditions.checkNotNull;
-
 /**
  * An interface that represents the result of a {@linkplain Producer production} of type {@code T},
  * or an exception that was thrown during that production. For any type {@code T} that can be
diff --git a/producers/src/main/java/dagger/producers/Producer.java b/producers/src/main/java/dagger/producers/Producer.java
index b6103d272..22513838e 100644
--- a/producers/src/main/java/dagger/producers/Producer.java
+++ b/producers/src/main/java/dagger/producers/Producer.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Google Inc.
+ * Copyright (C) 2014 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,11 +13,11 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.producers;
 
-import dagger.internal.Beta;
 import com.google.common.util.concurrent.ListenableFuture;
-
+import dagger.internal.Beta;
 import javax.annotation.CheckReturnValue;
 
 /**
diff --git a/producers/src/main/java/dagger/producers/ProducerModule.java b/producers/src/main/java/dagger/producers/ProducerModule.java
index f383145ad..ea4ea6812 100644
--- a/producers/src/main/java/dagger/producers/ProducerModule.java
+++ b/producers/src/main/java/dagger/producers/ProducerModule.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Google Inc.
+ * Copyright (C) 2014 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,17 +13,18 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.producers;
 
+import static java.lang.annotation.ElementType.TYPE;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
 import dagger.Module;
 import dagger.internal.Beta;
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 
-import static java.lang.annotation.ElementType.TYPE;
-import static java.lang.annotation.RetentionPolicy.RUNTIME;
-
 /**
  * Annotates a class that contributes {@link Produces} bindings to the production component.
  *
@@ -40,4 +41,13 @@
    * inclusions recursively, are all contributed to the object graph.
    */
   Class<?>[] includes() default {};
+
+  /**
+   * Any {@link dagger.Subcomponent}- or {@link ProductionSubcomponent}-annotated classes which
+   * should be children of the component in which this module is installed. A subcomponent may be
+   * listed in more than one module in a component.
+   *
+   * @since 2.7
+   */
+  Class<?>[] subcomponents() default {};
 }
diff --git a/producers/src/main/java/dagger/producers/Produces.java b/producers/src/main/java/dagger/producers/Produces.java
index 4bd807618..d133a5865 100644
--- a/producers/src/main/java/dagger/producers/Produces.java
+++ b/producers/src/main/java/dagger/producers/Produces.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Google Inc.
+ * Copyright (C) 2014 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,17 +13,18 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.producers;
 
-import dagger.internal.Beta;
+import static java.lang.annotation.ElementType.METHOD;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
 import com.google.common.util.concurrent.ListenableFuture;
+import dagger.internal.Beta;
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 
-import static java.lang.annotation.ElementType.METHOD;
-import static java.lang.annotation.RetentionPolicy.RUNTIME;
-
 /**
  * Annotates methods of a producer module to create a production binding. If the method returns
  * a {@link ListenableFuture}, then the parameter type of the future is bound to the value that the
@@ -36,38 +37,4 @@
 @Target(METHOD)
 @Retention(RUNTIME)
 @Beta
-public @interface Produces {
-  /** The type of binding into which the return type of the annotated method contributes. */
-  enum Type {
-    /**
-     * The method is the only one which can produce the value for the specified type. This is the
-     * default behavior.
-     */
-    UNIQUE,
-
-    /**
-     * The method's resulting type forms the generic type argument of a {@code Set<T>}, and the
-     * returned value or future is contributed to the set. The {@code Set<T>} produced from the
-     * accumulation of values will be immutable.
-     */
-    SET,
-
-    /**
-     * Like {@link #SET}, except the method's return type is either {@code Set<T>} or
-     * {@code Set<ListenableFuture<T>>}, where any values are contributed to the set. An example use
-     * is to provide a default empty set binding, which is otherwise not possible using
-     * {@link #SET}.
-     */
-    SET_VALUES,
-
-    /**
-     * The method's return type forms the type argument for the value of a
-     * {@code Map<K, Producer<V>>}, and the combination of the annotated key and the returned value
-     * is contributed to the map as a key/value pair. The {@code Map<K, Producer<V>>} produced from
-     * the accumulation of values will be immutable.
-     */
-    MAP;
-  }
-
-  Type type() default Type.UNIQUE;
-}
+public @interface Produces {}
diff --git a/producers/src/main/java/dagger/producers/Production.java b/producers/src/main/java/dagger/producers/Production.java
index 2ecdec809..563fc166a 100644
--- a/producers/src/main/java/dagger/producers/Production.java
+++ b/producers/src/main/java/dagger/producers/Production.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 Google, Inc.
+ * Copyright (C) 2016 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,15 +13,16 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.producers;
 
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
 import dagger.internal.Beta;
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import javax.inject.Qualifier;
 
-import static java.lang.annotation.RetentionPolicy.RUNTIME;
-
 /**
  * Qualifies a type that will be provided to the framework for use internally.
  *
diff --git a/producers/src/main/java/dagger/producers/ProductionComponent.java b/producers/src/main/java/dagger/producers/ProductionComponent.java
index 3640dfe66..6e7376b4b 100644
--- a/producers/src/main/java/dagger/producers/ProductionComponent.java
+++ b/producers/src/main/java/dagger/producers/ProductionComponent.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Google Inc.
+ * Copyright (C) 2014 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,8 +13,11 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.producers;
 
+import static java.lang.annotation.ElementType.TYPE;
+
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.Module;
 import dagger.Provides;
@@ -24,12 +27,10 @@
 import javax.inject.Inject;
 import javax.inject.Qualifier;
 
-import static java.lang.annotation.ElementType.TYPE;
-
 /**
  * Annotates an interface or abstract class for which a fully-formed, dependency-injected
- * implementation is to be generated from a set of {@linkplain #modules}. The generated class will
- * have the name of the type annotated with {@code @ProductionComponent} prepended with
+ * implementation is to be generated from a set of {@linkplain #modules modules}. The generated
+ * class will have the name of the type annotated with {@code @ProductionComponent} prepended with
  * {@code Dagger}.  For example, {@code @ProductionComponent interface MyComponent {...}} will
  * produce an implementation named {@code DaggerMyComponent}.
  *
diff --git a/producers/src/main/java/dagger/producers/ProductionScope.java b/producers/src/main/java/dagger/producers/ProductionScope.java
index 8e3a405d8..393c24071 100644
--- a/producers/src/main/java/dagger/producers/ProductionScope.java
+++ b/producers/src/main/java/dagger/producers/ProductionScope.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 Google, Inc.
+ * Copyright (C) 2016 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,14 +13,15 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.producers;
 
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import javax.inject.Scope;
 
-import static java.lang.annotation.RetentionPolicy.RUNTIME;
-
 /**
  * A scope annotation for provision bindings that are tied to the lifetime of a
  * {@link ProductionComponent} or {@link ProductionSubcomponent}.
diff --git a/producers/src/main/java/dagger/producers/ProductionSubcomponent.java b/producers/src/main/java/dagger/producers/ProductionSubcomponent.java
index 1eecca1b3..4fc453af1 100644
--- a/producers/src/main/java/dagger/producers/ProductionSubcomponent.java
+++ b/producers/src/main/java/dagger/producers/ProductionSubcomponent.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 Google, Inc.
+ * Copyright (C) 2016 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,8 +13,12 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.producers;
 
+import static java.lang.annotation.ElementType.TYPE;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
 import dagger.Component;
 import dagger.Module;
 import dagger.Subcomponent;
@@ -22,9 +26,6 @@
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 
-import static java.lang.annotation.ElementType.TYPE;
-import static java.lang.annotation.RetentionPolicy.RUNTIME;
-
 /**
  * A subcomponent that inherits the bindings from a parent {@link Component}, {@link Subcomponent},
  * {@link ProductionComponent}, or {@link ProductionSubcomponent}. The details of how to associate a
diff --git a/producers/src/main/java/dagger/producers/internal/AbstractProducer.java b/producers/src/main/java/dagger/producers/internal/AbstractProducer.java
index 85a973370..d7fa6aec2 100644
--- a/producers/src/main/java/dagger/producers/internal/AbstractProducer.java
+++ b/producers/src/main/java/dagger/producers/internal/AbstractProducer.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,17 +13,17 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.producers.internal;
 
+import static com.google.common.base.Preconditions.checkNotNull;
+
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.producers.Producer;
 import dagger.producers.monitoring.ProducerMonitor;
 import dagger.producers.monitoring.ProducerToken;
 import dagger.producers.monitoring.ProductionComponentMonitor;
 import dagger.producers.monitoring.internal.Monitors;
-
-import static com.google.common.base.Preconditions.checkNotNull;
-
 import javax.annotation.Nullable;
 import javax.inject.Provider;
 
diff --git a/producers/src/main/java/dagger/producers/internal/MapOfProducedProducer.java b/producers/src/main/java/dagger/producers/internal/MapOfProducedProducer.java
index f55194fec..7aace23a2 100644
--- a/producers/src/main/java/dagger/producers/internal/MapOfProducedProducer.java
+++ b/producers/src/main/java/dagger/producers/internal/MapOfProducedProducer.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 Google, Inc.
+ * Copyright (C) 2016 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,8 +13,12 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.producers.internal;
 
+import static com.google.common.util.concurrent.Futures.transform;
+import static com.google.common.util.concurrent.MoreExecutors.directExecutor;
+
 import com.google.common.base.Function;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.Iterables;
@@ -68,7 +72,7 @@ private MapOfProducedProducer(Producer<Map<K, Producer<V>>> mapProducerProducer)
           @Override
           public ListenableFuture<Map<K, Produced<V>>> apply(final Map<K, Producer<V>> map) {
             // TODO(beder): Use Futures.whenAllComplete when Guava 20 is released.
-            return Futures.transform(
+            return transform(
                 Futures.allAsList(
                     Iterables.transform(
                         map.entrySet(), MapOfProducedProducer.<K, V>entryUnwrapper())),
@@ -77,9 +81,11 @@ private MapOfProducedProducer(Producer<Map<K, Producer<V>>> mapProducerProducer)
                   public Map<K, Produced<V>> apply(List<Map.Entry<K, Produced<V>>> entries) {
                     return ImmutableMap.copyOf(entries);
                   }
-                });
+                },
+                directExecutor());
           }
-        });
+        },
+        directExecutor());
   }
 
   private static final Function<
@@ -92,14 +98,15 @@ private MapOfProducedProducer(Producer<Map<K, Producer<V>>> mapProducerProducer)
             @Override
             public ListenableFuture<Map.Entry<Object, Produced<Object>>> apply(
                 final Map.Entry<Object, Producer<Object>> entry) {
-              return Futures.transform(
+              return transform(
                   Producers.createFutureProduced(entry.getValue().get()),
                   new Function<Produced<Object>, Map.Entry<Object, Produced<Object>>>() {
                     @Override
                     public Map.Entry<Object, Produced<Object>> apply(Produced<Object> value) {
                       return Maps.immutableEntry(entry.getKey(), value);
                     }
-                  });
+                  },
+                  directExecutor());
             }
           };
 
diff --git a/producers/src/main/java/dagger/producers/internal/MapOfProducerProducer.java b/producers/src/main/java/dagger/producers/internal/MapOfProducerProducer.java
index 0424a68d5..216966e75 100644
--- a/producers/src/main/java/dagger/producers/internal/MapOfProducerProducer.java
+++ b/producers/src/main/java/dagger/producers/internal/MapOfProducerProducer.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 Google, Inc.
+ * Copyright (C) 2016 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,17 +13,20 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.producers.internal;
 
+import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.collect.Maps.newLinkedHashMapWithExpectedSize;
+import static dagger.producers.internal.Producers.producerFromProvider;
+
 import com.google.common.collect.ImmutableMap;
 import com.google.common.util.concurrent.Futures;
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.internal.Beta;
 import dagger.producers.Producer;
 import java.util.Map;
-
-import static com.google.common.base.Preconditions.checkNotNull;
-import static com.google.common.collect.Maps.newLinkedHashMapWithExpectedSize;
+import javax.inject.Provider;
 
 /**
  * A {@link Producer} implementation used to implement {@link Map} bindings. This factory returns an
@@ -73,12 +76,20 @@ private Builder(int size) {
       return new MapOfProducerProducer<K, V>(ImmutableMap.copyOf(mapBuilder));
     }
 
-    /** Associates k with producerOfValue in {@code Builder}. */
+    /** Associates key with producerOfValue in {@code Builder}. */
     public Builder<K, V> put(K key, Producer<V> producerOfValue) {
       checkNotNull(key, "key");
       checkNotNull(producerOfValue, "producer of value");
       mapBuilder.put(key, producerOfValue);
       return this;
     }
+
+    /** Associates key with providerOfValue in {@code Builder}. */
+    public Builder<K, V> put(K key, Provider<V> providerOfValue) {
+      checkNotNull(key, "key");
+      checkNotNull(providerOfValue, "provider of value");
+      mapBuilder.put(key, producerFromProvider(providerOfValue));
+      return this;
+    }
   }
 }
diff --git a/producers/src/main/java/dagger/producers/internal/MapProducer.java b/producers/src/main/java/dagger/producers/internal/MapProducer.java
index 6897959f7..33eb76e8c 100644
--- a/producers/src/main/java/dagger/producers/internal/MapProducer.java
+++ b/producers/src/main/java/dagger/producers/internal/MapProducer.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 Google, Inc.
+ * Copyright (C) 2016 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,8 +13,12 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.producers.internal;
 
+import static com.google.common.util.concurrent.Futures.transform;
+import static com.google.common.util.concurrent.MoreExecutors.directExecutor;
+
 import com.google.common.base.Function;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.Iterables;
@@ -64,7 +68,7 @@ private MapProducer(Producer<Map<K, Producer<V>>> mapProducerProducer) {
           @Override
           public ListenableFuture<Map<K, V>> apply(final Map<K, Producer<V>> map) {
             // TODO(beder): Use Futures.whenAllComplete when Guava 20 is released.
-            return Futures.transform(
+            return transform(
                 Futures.allAsList(
                     Iterables.transform(map.entrySet(), MapProducer.<K, V>entryUnwrapper())),
                 new Function<List<Map.Entry<K, V>>, Map<K, V>>() {
@@ -72,9 +76,11 @@ private MapProducer(Producer<Map<K, Producer<V>>> mapProducerProducer) {
                   public Map<K, V> apply(List<Map.Entry<K, V>> entries) {
                     return ImmutableMap.copyOf(entries);
                   }
-                });
+                },
+                directExecutor());
           }
-        });
+        },
+        directExecutor());
   }
 
   private static final Function<
@@ -85,14 +91,15 @@ private MapProducer(Producer<Map<K, Producer<V>>> mapProducerProducer) {
             @Override
             public ListenableFuture<Map.Entry<Object, Object>> apply(
                 final Map.Entry<Object, Producer<Object>> entry) {
-              return Futures.transform(
+              return transform(
                   entry.getValue().get(),
                   new Function<Object, Map.Entry<Object, Object>>() {
                     @Override
                     public Map.Entry<Object, Object> apply(Object value) {
                       return Maps.immutableEntry(entry.getKey(), value);
                     }
-                  });
+                  },
+                  directExecutor());
             }
           };
 
diff --git a/producers/src/main/java/dagger/producers/internal/Producers.java b/producers/src/main/java/dagger/producers/internal/Producers.java
index 17e5cb68a..029bcb51a 100644
--- a/producers/src/main/java/dagger/producers/internal/Producers.java
+++ b/producers/src/main/java/dagger/producers/internal/Producers.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Google, Inc.
+ * Copyright (C) 2014 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,8 +13,14 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.producers.internal;
 
+import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.util.concurrent.Futures.catchingAsync;
+import static com.google.common.util.concurrent.Futures.transform;
+import static com.google.common.util.concurrent.MoreExecutors.directExecutor;
+
 import com.google.common.base.Function;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.util.concurrent.AsyncFunction;
@@ -22,11 +28,10 @@
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.producers.Produced;
 import dagger.producers.Producer;
+import java.util.List;
 import java.util.Set;
 import javax.inject.Provider;
 
-import static com.google.common.base.Preconditions.checkNotNull;
-
 /**
  * Utility methods for use in generated producer code.
  *
@@ -47,17 +52,19 @@
   // TODO(beder): Document what happens with an InterruptedException after you figure out how to
   // trigger one in a test.
   public static <T> ListenableFuture<Produced<T>> createFutureProduced(ListenableFuture<T> future) {
-    return Futures.catchingAsync(
-        Futures.transform(
+    return catchingAsync(
+        transform(
             future,
             new Function<T, Produced<T>>() {
               @Override
               public Produced<T> apply(final T value) {
                 return Produced.successful(value);
               }
-            }),
+            },
+            directExecutor()),
         Throwable.class,
-        Producers.<T>futureFallbackForProduced());
+        Producers.<T>futureFallbackForProduced(),
+        directExecutor());
 
   }
 
@@ -80,11 +87,34 @@
    * future.
    */
   public static <T> ListenableFuture<Set<T>> createFutureSingletonSet(ListenableFuture<T> future) {
-    return Futures.transform(future, new Function<T, Set<T>>() {
-      @Override public Set<T> apply(T value) {
-        return ImmutableSet.of(value);
-      }
-    });
+    return transform(
+        future,
+        new Function<T, Set<T>>() {
+          @Override
+          public Set<T> apply(T value) {
+            return ImmutableSet.of(value);
+          }
+        },
+        directExecutor());
+  }
+
+  /**
+   * Creates a new {@code ListenableFuture} whose value is a set containing the values of all its
+   * input futures, if all succeed. If any input fails, the returned future fails immediately.
+   *
+   * <p>This is the set equivalent of {@link Futures#allAsList}.
+   */
+  public static <T> ListenableFuture<Set<T>> allAsSet(
+      Iterable<? extends ListenableFuture<? extends T>> futures) {
+    return transform(
+        Futures.allAsList(futures),
+        new Function<List<T>, Set<T>>() {
+          @Override
+          public Set<T> apply(List<T> values) {
+            return ImmutableSet.copyOf(values);
+          }
+        },
+        directExecutor());
   }
 
   /**
diff --git a/producers/src/main/java/dagger/producers/internal/ProductionImplementation.java b/producers/src/main/java/dagger/producers/internal/ProductionImplementation.java
index b5cfa927a..8a0149c17 100644
--- a/producers/src/main/java/dagger/producers/internal/ProductionImplementation.java
+++ b/producers/src/main/java/dagger/producers/internal/ProductionImplementation.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 Google, Inc.
+ * Copyright (C) 2016 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,15 +13,16 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.producers.internal;
 
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
 import dagger.internal.Beta;
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import javax.inject.Qualifier;
 
-import static java.lang.annotation.RetentionPolicy.RUNTIME;
-
 /**
  * Qualifies a type that will be used as an internal implementation detail in the framework.
  *
diff --git a/producers/src/main/java/dagger/producers/internal/SetOfProducedProducer.java b/producers/src/main/java/dagger/producers/internal/SetOfProducedProducer.java
index 390949993..0156887d5 100644
--- a/producers/src/main/java/dagger/producers/internal/SetOfProducedProducer.java
+++ b/producers/src/main/java/dagger/producers/internal/SetOfProducedProducer.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,8 +13,14 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.producers.internal;
 
+import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.util.concurrent.MoreExecutors.directExecutor;
+import static dagger.internal.DaggerCollections.hasDuplicates;
+import static dagger.internal.DaggerCollections.presizedList;
+
 import com.google.common.base.Function;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.util.concurrent.Futures;
@@ -27,10 +33,6 @@
 import java.util.Set;
 import java.util.concurrent.ExecutionException;
 
-import static com.google.common.base.Preconditions.checkNotNull;
-import static dagger.internal.DaggerCollections.hasDuplicates;
-import static dagger.internal.DaggerCollections.presizedList;
-
 /**
  * A {@link Producer} implementation used to implement {@link Set} bindings. This producer returns a
  * future {@code Set<Produced<T>>} whose elements are populated by subsequent calls to the delegate
@@ -168,6 +170,7 @@ private SetOfProducedProducer(
             }
             return builder.build();
           }
-        });
+        },
+        directExecutor());
   }
 }
diff --git a/producers/src/main/java/dagger/producers/internal/SetProducer.java b/producers/src/main/java/dagger/producers/internal/SetProducer.java
index 10e27e60f..ff25ad709 100644
--- a/producers/src/main/java/dagger/producers/internal/SetProducer.java
+++ b/producers/src/main/java/dagger/producers/internal/SetProducer.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,8 +13,15 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.producers.internal;
 
+import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.util.concurrent.Futures.transform;
+import static com.google.common.util.concurrent.MoreExecutors.directExecutor;
+import static dagger.internal.DaggerCollections.hasDuplicates;
+import static dagger.internal.DaggerCollections.presizedList;
+
 import com.google.common.base.Function;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.util.concurrent.Futures;
@@ -25,10 +32,6 @@
 import java.util.List;
 import java.util.Set;
 
-import static com.google.common.base.Preconditions.checkNotNull;
-import static dagger.internal.DaggerCollections.hasDuplicates;
-import static dagger.internal.DaggerCollections.presizedList;
-
 /**
  * A {@link Producer} implementation used to implement {@link Set} bindings. This producer returns
  * a future {@link Set} whose elements are populated by subsequent calls to the delegate
@@ -136,7 +139,7 @@ private SetProducer(
     for (Producer<Collection<T>> producer : collectionProducers) {
       futureCollections.add(checkNotNull(producer.get()));
     }
-    return Futures.transform(
+    return transform(
         Futures.allAsList(futureCollections),
         new Function<List<Collection<T>>, Set<T>>() {
           @Override
@@ -147,6 +150,7 @@ private SetProducer(
             }
             return builder.build();
           }
-        });
+        },
+        directExecutor());
   }
 }
diff --git a/producers/src/main/java/dagger/producers/monitoring/ProducerMonitor.java b/producers/src/main/java/dagger/producers/monitoring/ProducerMonitor.java
index 2d2bc8734..a7ead827d 100644
--- a/producers/src/main/java/dagger/producers/monitoring/ProducerMonitor.java
+++ b/producers/src/main/java/dagger/producers/monitoring/ProducerMonitor.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,10 +13,13 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.producers.monitoring;
 
+import static com.google.common.util.concurrent.Futures.addCallback;
+import static com.google.common.util.concurrent.MoreExecutors.directExecutor;
+
 import com.google.common.util.concurrent.FutureCallback;
-import com.google.common.util.concurrent.Futures;
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.producers.Producer;
 import dagger.producers.Produces;
@@ -79,6 +82,19 @@
    * <p>Note that if a method depends on {@code Producer<T>}, then this does not count as requesting
    * {@code T}; that is only triggered by calling {@link Producer#get()}.
    *
+   * <p>Depending on how this producer is requested, the following threading constraints are
+   * guaranteed:
+   *
+   * <ol>
+   *   <li>If the producer is requested directly by a method on a component, then {@code requested}
+   *       will be called on the same thread as the component method call.
+   *   <li>If the producer is requested by value from another producer (i.e., injected as {@code T}
+   *       or {@code Produced<T>}), then {@code requested} will be called from the same thread as
+   *       the other producer's {@code requested}.
+   *   <li>If the producer is requested by calling {@link Producer#get()}, then {@code requested}
+   *       will be called from the same thread as that {@code get()} call.
+   * </ol>
+   *
    * <p>When multiple monitors are installed, the order that each monitor will call this method is
    * unspecified, but will remain consistent throughout the course of the execution of a component.
    *
@@ -87,7 +103,21 @@
   public void requested() {}
 
   /**
-   * Called when the producer method is about to start executing.
+   * Called when all of the producer's inputs are available. This is called regardless of whether
+   * the inputs have succeeded or not; when the inputs have succeeded, this is called prior to
+   * scheduling the method on the executor, and if an input has failed and the producer will be
+   * skipped, this method will be called before {@link #failed(Throwable)} is called.
+   *
+   * <p>When multiple monitors are installed, the order that each monitor will call this method is
+   * unspecified, but will remain consistent throughout the course of the execution of a component.
+   *
+   * <p>This implementation is a no-op.
+   */
+  public void ready() {}
+
+  /**
+   * Called when the producer method is about to start executing. This will be called from the same
+   * thread as the producer method itself.
    *
    * <p>When multiple monitors are installed, calls to this method will be in the reverse order from
    * calls to {@link #requested()}.
@@ -98,7 +128,7 @@ public void methodStarting() {}
 
   /**
    * Called when the producer method has finished executing. This will be called from the same
-   * thread as {@link #methodStarting()}.
+   * thread as {@link #methodStarting()} and the producer method itself.
    *
    * <p>When multiple monitors are installed, calls to this method will be in the reverse order from
    * calls to {@link #requested()}.
@@ -132,7 +162,7 @@ public void failed(@SuppressWarnings("unused") Throwable t) {}
    * overridden in the framework!
    */
   public <T> void addCallbackTo(ListenableFuture<T> future) {
-    Futures.addCallback(
+    addCallback(
         future,
         new FutureCallback<T>() {
           @Override
@@ -144,7 +174,8 @@ public void onSuccess(T value) {
           public void onFailure(Throwable t) {
             failed(t);
           }
-        });
+        },
+        directExecutor());
   }
 
   private static final ProducerMonitor NO_OP =
diff --git a/producers/src/main/java/dagger/producers/monitoring/ProducerTimingRecorder.java b/producers/src/main/java/dagger/producers/monitoring/ProducerTimingRecorder.java
index bdff4a198..ae09cd4d8 100644
--- a/producers/src/main/java/dagger/producers/monitoring/ProducerTimingRecorder.java
+++ b/producers/src/main/java/dagger/producers/monitoring/ProducerTimingRecorder.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.producers.monitoring;
 
 import dagger.producers.Produces;
diff --git a/producers/src/main/java/dagger/producers/monitoring/ProducerToken.java b/producers/src/main/java/dagger/producers/monitoring/ProducerToken.java
index 311d951a9..21b5a51eb 100644
--- a/producers/src/main/java/dagger/producers/monitoring/ProducerToken.java
+++ b/producers/src/main/java/dagger/producers/monitoring/ProducerToken.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,14 +13,15 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.producers.monitoring;
 
+import static com.google.common.base.Preconditions.checkNotNull;
+
 import dagger.producers.Produces;
 import java.util.Objects;
 import javax.annotation.Nullable;
 
-import static com.google.common.base.Preconditions.checkNotNull;
-
 /** A token that represents an individual {@linkplain Produces producer method}. */
 public final class ProducerToken {
   @Nullable private final Class<?> classToken;
@@ -82,7 +83,7 @@ public String toString() {
     if (methodName != null) {
       return methodName;
     } else if (classToken != null) {
-      return classToken.toString();
+      return classToken.getCanonicalName();
     } else {
       throw new IllegalStateException();
     }
diff --git a/producers/src/main/java/dagger/producers/monitoring/ProductionComponentMonitor.java b/producers/src/main/java/dagger/producers/monitoring/ProductionComponentMonitor.java
index 8adebdc1d..17cce77ef 100644
--- a/producers/src/main/java/dagger/producers/monitoring/ProductionComponentMonitor.java
+++ b/producers/src/main/java/dagger/producers/monitoring/ProductionComponentMonitor.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.producers.monitoring;
 
 import dagger.producers.Produces;
diff --git a/producers/src/main/java/dagger/producers/monitoring/ProductionComponentTimingRecorder.java b/producers/src/main/java/dagger/producers/monitoring/ProductionComponentTimingRecorder.java
index debe06d9a..718d4d972 100644
--- a/producers/src/main/java/dagger/producers/monitoring/ProductionComponentTimingRecorder.java
+++ b/producers/src/main/java/dagger/producers/monitoring/ProductionComponentTimingRecorder.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.producers.monitoring;
 
 import dagger.producers.Produces;
diff --git a/producers/src/main/java/dagger/producers/monitoring/TimingProducerMonitor.java b/producers/src/main/java/dagger/producers/monitoring/TimingProducerMonitor.java
index a4bfa17c1..c63e10822 100644
--- a/producers/src/main/java/dagger/producers/monitoring/TimingProducerMonitor.java
+++ b/producers/src/main/java/dagger/producers/monitoring/TimingProducerMonitor.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,13 +13,14 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.producers.monitoring;
 
+import static java.util.concurrent.TimeUnit.NANOSECONDS;
+
 import com.google.common.base.Stopwatch;
 import com.google.common.base.Ticker;
 
-import static java.util.concurrent.TimeUnit.NANOSECONDS;
-
 /**
  * A monitor that measures the timing of the execution of a producer method, and logs those timings
  * with the given recorder.
diff --git a/producers/src/main/java/dagger/producers/monitoring/TimingProductionComponentMonitor.java b/producers/src/main/java/dagger/producers/monitoring/TimingProductionComponentMonitor.java
index fcdcb218b..66589d951 100644
--- a/producers/src/main/java/dagger/producers/monitoring/TimingProductionComponentMonitor.java
+++ b/producers/src/main/java/dagger/producers/monitoring/TimingProductionComponentMonitor.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.producers.monitoring;
 
 import com.google.common.base.Stopwatch;
diff --git a/producers/src/main/java/dagger/producers/monitoring/TimingRecorders.java b/producers/src/main/java/dagger/producers/monitoring/TimingRecorders.java
index 34016e29f..471d527c7 100644
--- a/producers/src/main/java/dagger/producers/monitoring/TimingRecorders.java
+++ b/producers/src/main/java/dagger/producers/monitoring/TimingRecorders.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.producers.monitoring;
 
 import com.google.common.collect.ImmutableList;
diff --git a/producers/src/main/java/dagger/producers/monitoring/internal/Monitors.java b/producers/src/main/java/dagger/producers/monitoring/internal/Monitors.java
index b4e28b6af..24b1f4dea 100644
--- a/producers/src/main/java/dagger/producers/monitoring/internal/Monitors.java
+++ b/producers/src/main/java/dagger/producers/monitoring/internal/Monitors.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.producers.monitoring.internal;
 
 import com.google.common.collect.ImmutableList;
@@ -136,6 +137,15 @@ public void requested() {
       }
     }
 
+    @Override
+    public void ready() {
+      try {
+        delegate.ready();
+      } catch (RuntimeException e) {
+        logProducerMonitorMethodException(e, delegate, "ready");
+      }
+    }
+
     @Override
     public void methodStarting() {
       try {
@@ -262,6 +272,17 @@ public void requested() {
       }
     }
 
+    @Override
+    public void ready() {
+      for (ProducerMonitor delegate : delegates) {
+        try {
+          delegate.ready();
+        } catch (RuntimeException e) {
+          logProducerMonitorMethodException(e, delegate, "ready");
+        }
+      }
+    }
+
     @Override
     public void methodStarting() {
       for (ProducerMonitor delegate : delegates) {
diff --git a/producers/src/main/java/dagger/producers/monitoring/package-info.java b/producers/src/main/java/dagger/producers/monitoring/package-info.java
index d10408706..122df5d2c 100644
--- a/producers/src/main/java/dagger/producers/monitoring/package-info.java
+++ b/producers/src/main/java/dagger/producers/monitoring/package-info.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -20,4 +20,5 @@
  * <p>The interfaces in this package are not stable. Do not use these interfaces unless you are
  * prepared to be broken.
  */
+
 package dagger.producers.monitoring;
diff --git a/producers/src/main/java/dagger/producers/package-info.java b/producers/src/main/java/dagger/producers/package-info.java
index 8cf2e28b5..01d261a87 100644
--- a/producers/src/main/java/dagger/producers/package-info.java
+++ b/producers/src/main/java/dagger/producers/package-info.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 Google, Inc.
+ * Copyright (C) 2016 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -25,4 +25,5 @@
  * google.github.io/dagger/producers</a>.
  *
  */
+
 package dagger.producers;
diff --git a/producers/src/test/java/dagger/producers/ProducedTest.java b/producers/src/test/java/dagger/producers/ProducedTest.java
index 165e7301c..f344f9dc7 100644
--- a/producers/src/test/java/dagger/producers/ProducedTest.java
+++ b/producers/src/test/java/dagger/producers/ProducedTest.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,8 +13,12 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.producers;
 
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+
 import com.google.common.testing.EqualsTester;
 import java.util.concurrent.CancellationException;
 import java.util.concurrent.ExecutionException;
@@ -22,9 +26,6 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import static com.google.common.truth.Truth.assertThat;
-import static org.junit.Assert.fail;
-
 /**
  * Tests {@link Produced}.
  */
diff --git a/producers/src/test/java/dagger/producers/internal/AbstractProducerTest.java b/producers/src/test/java/dagger/producers/internal/AbstractProducerTest.java
index 5169a1bc2..0e2fca495 100644
--- a/producers/src/test/java/dagger/producers/internal/AbstractProducerTest.java
+++ b/producers/src/test/java/dagger/producers/internal/AbstractProducerTest.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Google, Inc.
+ * Copyright (C) 2014 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,8 +13,16 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.producers.internal;
 
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.verifyNoMoreInteractions;
+import static org.mockito.Mockito.when;
+
 import com.google.common.util.concurrent.Futures;
 import com.google.common.util.concurrent.ListenableFuture;
 import com.google.common.util.concurrent.SettableFuture;
@@ -32,13 +40,6 @@
 import org.mockito.Mockito;
 import org.mockito.MockitoAnnotations;
 
-import static com.google.common.truth.Truth.assertThat;
-import static org.junit.Assert.fail;
-import static org.mockito.Matchers.any;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.verifyNoMoreInteractions;
-import static org.mockito.Mockito.when;
-
 /**
  * Tests {@link AbstractProducer}.
  */
diff --git a/producers/src/test/java/dagger/producers/internal/MapOfProducerProducerTest.java b/producers/src/test/java/dagger/producers/internal/MapOfProducerProducerTest.java
index 95d110da4..fe285ed5c 100644
--- a/producers/src/test/java/dagger/producers/internal/MapOfProducerProducerTest.java
+++ b/producers/src/test/java/dagger/producers/internal/MapOfProducerProducerTest.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 Google, Inc.
+ * Copyright (C) 2016 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,8 +13,12 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.producers.internal;
 
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+
 import dagger.producers.Producer;
 import java.util.Map;
 import java.util.concurrent.ExecutionException;
@@ -22,9 +26,6 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import static com.google.common.truth.Truth.assertThat;
-import static org.junit.Assert.fail;
-
 @RunWith(JUnit4.class)
 public final class MapOfProducerProducerTest {
   @Test
diff --git a/producers/src/test/java/dagger/producers/internal/MapProducerTest.java b/producers/src/test/java/dagger/producers/internal/MapProducerTest.java
index 7ede26921..3a8f19ddc 100644
--- a/producers/src/test/java/dagger/producers/internal/MapProducerTest.java
+++ b/producers/src/test/java/dagger/producers/internal/MapProducerTest.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 Google, Inc.
+ * Copyright (C) 2016 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,8 +13,12 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.producers.internal;
 
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+
 import com.google.common.collect.ImmutableMap;
 import dagger.producers.Producer;
 import java.util.Map;
@@ -23,9 +27,6 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import static com.google.common.truth.Truth.assertThat;
-import static org.junit.Assert.fail;
-
 @RunWith(JUnit4.class)
 public final class MapProducerTest {
   @Test
diff --git a/producers/src/test/java/dagger/producers/internal/ProducersTest.java b/producers/src/test/java/dagger/producers/internal/ProducersTest.java
index d0d4bf326..910b73ca0 100644
--- a/producers/src/test/java/dagger/producers/internal/ProducersTest.java
+++ b/producers/src/test/java/dagger/producers/internal/ProducersTest.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Google, Inc.
+ * Copyright (C) 2014 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,8 +13,13 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.producers.internal;
 
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+
+import com.google.common.collect.ImmutableList;
 import com.google.common.util.concurrent.Futures;
 import com.google.common.util.concurrent.ListenableFuture;
 import com.google.common.util.concurrent.SettableFuture;
@@ -28,9 +33,6 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import static com.google.common.truth.Truth.assertThat;
-import static org.junit.Assert.fail;
-
 /**
  * Tests {@link Producers}.
  */
@@ -96,6 +98,32 @@
     }
   }
 
+  @Test
+  public void allAsSet_success() throws Exception {
+    ListenableFuture<Set<String>> future =
+        Producers.allAsSet(
+            ImmutableList.of(
+                Futures.immediateFuture("monkey"), Futures.immediateFuture("gorilla")));
+    assertThat(future.isDone()).isTrue();
+    assertThat(future.get()).containsExactly("monkey", "gorilla");
+  }
+
+  @Test
+  public void allAsSet_failure() throws Exception {
+    ListenableFuture<Set<String>> future =
+        Producers.allAsSet(
+            ImmutableList.of(
+                Futures.immediateFuture("monkey"),
+                Futures.<String>immediateFailedFuture(new RuntimeException("gorilla"))));
+    assertThat(future.isDone()).isTrue();
+    try {
+      future.get();
+      fail();
+    } catch (ExecutionException e) {
+      assertThat(e.getCause()).hasMessage("gorilla");
+    }
+  }
+
   @Test public void producerFromProvider() throws Exception {
     Producer<Integer> producer = Producers.producerFromProvider(new Provider<Integer>() {
       int i = 0;
diff --git a/producers/src/test/java/dagger/producers/internal/SetOfProducedProducerTest.java b/producers/src/test/java/dagger/producers/internal/SetOfProducedProducerTest.java
index e92ef745e..8588bf485 100644
--- a/producers/src/test/java/dagger/producers/internal/SetOfProducedProducerTest.java
+++ b/producers/src/test/java/dagger/producers/internal/SetOfProducedProducerTest.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,8 +13,11 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.producers.internal;
 
+import static com.google.common.truth.Truth.assertThat;
+
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Sets;
@@ -28,8 +31,6 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import static com.google.common.truth.Truth.assertThat;
-
 /**
  * Tests {@link SetOfProducedProducer}.
  */
diff --git a/producers/src/test/java/dagger/producers/internal/SetProducerTest.java b/producers/src/test/java/dagger/producers/internal/SetProducerTest.java
index 9ad22daf1..12d293ce1 100644
--- a/producers/src/test/java/dagger/producers/internal/SetProducerTest.java
+++ b/producers/src/test/java/dagger/producers/internal/SetProducerTest.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 Google, Inc.
+ * Copyright (C) 2014 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,8 +13,12 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.producers.internal;
 
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+
 import com.google.common.collect.ImmutableSet;
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.producers.Producer;
@@ -25,9 +29,6 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import static com.google.common.truth.Truth.assertThat;
-import static org.junit.Assert.fail;
-
 /**
  * Tests {@link SetProducer}.
  */
diff --git a/producers/src/test/java/dagger/producers/monitoring/TimingProductionComponentMonitorTest.java b/producers/src/test/java/dagger/producers/monitoring/TimingProductionComponentMonitorTest.java
index bceecf1aa..449b5a6e7 100644
--- a/producers/src/test/java/dagger/producers/monitoring/TimingProductionComponentMonitorTest.java
+++ b/producers/src/test/java/dagger/producers/monitoring/TimingProductionComponentMonitorTest.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,8 +13,14 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.producers.monitoring;
 
+import static org.mockito.Mockito.any;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.verifyNoMoreInteractions;
+import static org.mockito.Mockito.when;
+
 import com.google.common.testing.FakeTicker;
 import org.junit.Before;
 import org.junit.Test;
@@ -23,11 +29,6 @@
 import org.mockito.Mock;
 import org.mockito.MockitoAnnotations;
 
-import static org.mockito.Mockito.any;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.verifyNoMoreInteractions;
-import static org.mockito.Mockito.when;
-
 @RunWith(JUnit4.class)
 public final class TimingProductionComponentMonitorTest {
   private static final class ProducerClassA {}
diff --git a/producers/src/test/java/dagger/producers/monitoring/TimingRecordersTest.java b/producers/src/test/java/dagger/producers/monitoring/TimingRecordersTest.java
index cf54d9670..c0c7eb6c5 100644
--- a/producers/src/test/java/dagger/producers/monitoring/TimingRecordersTest.java
+++ b/producers/src/test/java/dagger/producers/monitoring/TimingRecordersTest.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google, Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,8 +13,16 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.producers.monitoring;
 
+import static com.google.common.truth.Truth.assertThat;
+import static org.mockito.Mockito.any;
+import static org.mockito.Mockito.doThrow;
+import static org.mockito.Mockito.inOrder;
+import static org.mockito.Mockito.verifyNoMoreInteractions;
+import static org.mockito.Mockito.when;
+
 import com.google.common.collect.ImmutableList;
 import org.junit.Before;
 import org.junit.Test;
@@ -24,13 +32,6 @@
 import org.mockito.Mock;
 import org.mockito.MockitoAnnotations;
 
-import static com.google.common.truth.Truth.assertThat;
-import static org.mockito.Mockito.any;
-import static org.mockito.Mockito.doThrow;
-import static org.mockito.Mockito.inOrder;
-import static org.mockito.Mockito.verifyNoMoreInteractions;
-import static org.mockito.Mockito.when;
-
 @RunWith(JUnit4.class)
 public final class TimingRecordersTest {
   @Mock
diff --git a/producers/src/test/java/dagger/producers/monitoring/internal/MonitorsTest.java b/producers/src/test/java/dagger/producers/monitoring/internal/MonitorsTest.java
index 31952c334..5ed6b9d6e 100644
--- a/producers/src/test/java/dagger/producers/monitoring/internal/MonitorsTest.java
+++ b/producers/src/test/java/dagger/producers/monitoring/internal/MonitorsTest.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 Google Inc.
+ * Copyright (C) 2015 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,8 +13,16 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package dagger.producers.monitoring.internal;
 
+import static com.google.common.truth.Truth.assertThat;
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.doThrow;
+import static org.mockito.Mockito.inOrder;
+import static org.mockito.Mockito.verifyNoMoreInteractions;
+import static org.mockito.Mockito.when;
+
 import com.google.common.collect.ImmutableList;
 import dagger.producers.monitoring.ProducerMonitor;
 import dagger.producers.monitoring.ProducerToken;
@@ -27,13 +35,6 @@
 import org.mockito.Mock;
 import org.mockito.MockitoAnnotations;
 
-import static com.google.common.truth.Truth.assertThat;
-import static org.mockito.Matchers.any;
-import static org.mockito.Mockito.doThrow;
-import static org.mockito.Mockito.inOrder;
-import static org.mockito.Mockito.verifyNoMoreInteractions;
-import static org.mockito.Mockito.when;
-
 @RunWith(JUnit4.class)
 public final class MonitorsTest {
   @Mock private ProductionComponentMonitor.Factory mockProductionComponentMonitorFactory;
diff --git a/test_defs.bzl b/test_defs.bzl
new file mode 100644
index 000000000..bd81669a9
--- /dev/null
+++ b/test_defs.bzl
@@ -0,0 +1,58 @@
+# Copyright (C) 2017 The Dagger Authors.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+def GenJavaTests(name, srcs, deps, plugins = None, javacopts = None):
+  _GenTests(native.java_library, native.java_test, name, srcs, deps, plugins, javacopts)
+
+def GenRobolectricTests(name, srcs, deps, plugins = None, javacopts = None):
+  # TODO(ronshapiro): enable these when Bazel supports robolectric tests
+  pass
+
+def _GenTests(
+    library_rule_type, test_rule_type, name, srcs, deps, plugins = None, javacopts = None):
+  test_files = []
+  supporting_files = []
+  for src in srcs:
+    if src.endswith("Test.java"):
+      test_files.append(src)
+    else:
+      supporting_files.append(src)
+
+  test_deps = [] + deps
+  if len(supporting_files) > 0:
+    supporting_files_name = name + "_lib"
+    test_deps.append(":" + supporting_files_name)
+    library_rule_type(
+        name = supporting_files_name,
+        deps = deps,
+        srcs = supporting_files,
+        plugins = plugins,
+        javacopts = javacopts,
+        testonly = 1,
+    )
+
+  for test_file in test_files:
+    test_name = test_file.replace(".java", "")
+    prefix_path = "src/test/java/"
+    if PACKAGE_NAME.find("javatests/") != -1:
+      prefix_path = "javatests/"
+    test_class = (PACKAGE_NAME + "/" + test_name).rpartition(prefix_path)[2].replace("/",".")
+    test_rule_type(
+        name = test_name,
+        deps = test_deps,
+        srcs = [test_file],
+        plugins = plugins,
+        javacopts = javacopts,
+        test_class = test_class,
+    )
diff --git a/third_party/BUILD b/third_party/BUILD
new file mode 100644
index 000000000..e07597903
--- /dev/null
+++ b/third_party/BUILD
@@ -0,0 +1,190 @@
+# Copyright (C) 2017 The Dagger Authors.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+package(default_visibility = ["//visibility:public"])
+
+java_library(
+    name = "jsr_250",
+    exports = ["@javax_annotation_jsr250_api//jar"],
+)
+
+java_library(
+    name = "jsr305_annotations",
+    exports = ["@com_google_code_findbugs_jsr305//jar"],
+)
+
+java_library(
+    name = "jsr330_inject",
+    exports = ["@javax_inject_javax_inject//jar"],
+)
+
+java_library(
+    name = "jsr330_inject_tck",
+    exports = ["@javax_inject_javax_inject_tck//jar"],
+)
+
+java_library(
+    name = "error_prone_annotations",
+    tags = ["compile_time_dep"],
+    exports = ["@com_google_errorprone_error_prone_annotations//jar"],
+)
+
+java_library(
+    name = "junit",
+    testonly = 1,
+    exports = [
+        "@junit_junit//jar",
+        "@org_hamcrest_hamcrest_core//jar",
+    ],
+)
+
+java_library(
+    name = "truth",
+    testonly = 1,
+    exports = ["@com_google_truth_truth//jar"],
+)
+
+java_library(
+    name = "guava",
+    exports = ["@com_google_guava_guava//jar"],
+)
+
+java_library(
+    name = "guava_testlib",
+    testonly = 1,
+    exports = ["@com_google_guava_guava_testlib//jar"],
+)
+
+java_library(
+    name = "auto_common",
+    exports = ["@com_google_auto_auto_common//jar"],
+)
+
+java_plugin(
+    name = "auto_value_processor",
+    processor_class = "com.google.auto.value.processor.AutoValueProcessor",
+    visibility = ["//visibility:private"],
+    deps = [
+        ":auto_common",
+        ":auto_service",
+        "//third_party:guava",
+        "@com_google_auto_value_auto_value//jar",
+    ],
+)
+
+java_plugin(
+    name = "auto_annotation_processor",
+    processor_class = "com.google.auto.value.processor.AutoAnnotationProcessor",
+    visibility = ["//visibility:private"],
+    deps = [
+        ":auto_common",
+        ":auto_service",
+        "//third_party:guava",
+        "@com_google_auto_value_auto_value//jar",
+    ],
+)
+
+java_library(
+    name = "auto_value",
+    exported_plugins = [
+        ":auto_value_processor",
+        ":auto_annotation_processor",
+    ],
+    tags = ["compile_time_dep"],
+    exports = [
+        ":jsr_250",
+        "@com_google_auto_value_auto_value//jar",
+    ],
+)
+
+java_plugin(
+    name = "auto_factory_processor",
+    generates_api = 1,
+    processor_class = "com.google.auto.factory.processor.AutoFactoryProcessor",
+    visibility = ["//visibility:private"],
+    deps = [
+        ":auto_common",
+        ":auto_service",
+        "//third_party:guava",
+        "@com_google_auto_factory_auto_factory//jar",
+        "@com_squareup_javawriter//jar",
+    ],
+)
+
+java_library(
+    name = "auto_factory",
+    exported_plugins = [":auto_factory_processor"],
+    exports = ["@com_google_auto_factory_auto_factory//jar"],
+)
+
+java_plugin(
+    name = "auto_service_processor",
+    processor_class = "com.google.auto.service.processor.AutoServiceProcessor",
+    visibility = ["//visibility:private"],
+    deps = [
+        ":auto_common",
+        "//third_party:guava",
+        "@com_google_auto_service_auto_service//jar",
+    ],
+)
+
+java_library(
+    name = "auto_service",
+    exported_plugins = [":auto_service_processor"],
+    tags = ["compile_time_dep"],
+    exports = ["@com_google_auto_service_auto_service//jar"],
+)
+
+java_library(
+    name = "google_java_format",
+    exports = [
+        "@com_google_googlejavaformat_google_java_format//jar",
+    ],
+    runtime_deps = [
+        ":guava",
+        "@com_google_errorprone_javac//jar",
+    ],
+)
+
+java_library(
+    name = "javapoet",
+    exports = ["@com_squareup_javapoet//jar"],
+)
+
+java_library(
+    name = "mockito",
+    testonly = 1,
+    exports = ["@org_mockito_mockito_core//jar"],
+    runtime_deps = [
+        "@org_hamcrest_hamcrest_core//jar",
+        "@org_objenesis_objenesis//jar",
+    ],
+)
+
+java_library(
+    name = "compile_testing",
+    testonly = 1,
+    exports = [
+        "@com_google_testing_compile_compile_testing//jar",
+    ],
+    runtime_deps = [
+        ":auto_value",
+        ":jsr305_annotations",
+        "//third_party:error_prone_annotations",
+        "//third_party:guava",
+        "//third_party:junit",
+        "//third_party:truth",
+        "@local_jdk//:lib/tools.jar",
+    ],
+)
diff --git a/tools/AndroidManifest.xml b/tools/AndroidManifest.xml
new file mode 100644
index 000000000..b18621a3e
--- /dev/null
+++ b/tools/AndroidManifest.xml
@@ -0,0 +1,4 @@
+<!-- A dummy AndroidManifest.xml to be used for generating Javadoc when Android sources are used -->
+<manifest xmlns:android="http://schemas.android.com/apk/res/android" package="dummy">
+  <uses-sdk android:minSdkVersion="14" />
+</manifest>
diff --git a/tools/BUILD b/tools/BUILD
new file mode 100644
index 000000000..8ea1fc720
--- /dev/null
+++ b/tools/BUILD
@@ -0,0 +1,71 @@
+# Copyright (C) 2017 The Dagger Authors.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+# Description:
+#   Tools for Dagger
+
+package(default_visibility = ["//:src"])
+
+sh_library(
+    name = "javadoc_library_impl",
+    srcs = ["javadoc_library_impl.sh"],
+)
+
+sh_binary(
+    name = "jarjar_library_impl",
+    srcs = ["jarjar_library_impl.sh"],
+)
+
+sh_test(
+    name = "jarjar_library_impl_test",
+    srcs = ["jarjar_library_impl_test.sh"],
+    args = ["$(JAVABASE)"],
+    data = [
+        ":jarjar_deploy.jar",
+        ":jarjar_library_impl",
+        "//tools/testdata:bar",
+        "//tools/testdata:bar_with_dupe_file",
+        "//tools/testdata:foo",
+        "//tools/testdata:foo_with_dupe_file",
+        "@local_jdk//:bin/jar",
+        "@local_jdk//:bin/java",
+        "@local_jdk//:jre",
+    ],
+)
+
+java_binary(
+    name = "jarjar",
+    main_class = "org.pantsbuild.jarjar.Main",
+    runtime_deps = [
+        "@javax_annotation_jsr250_api//jar",
+        "@javax_enterprise_cdi_api//jar",
+        "@javax_inject_javax_inject//jar",
+        "@org_apache_ant_ant//jar",
+        "@org_apache_ant_ant_launcher//jar",
+        "@org_apache_maven_maven_artifact//jar",
+        "@org_apache_maven_maven_model//jar",
+        "@org_apache_maven_maven_plugin_api//jar",
+        "@org_codehaus_plexus_plexus_classworlds//jar",
+        "@org_codehaus_plexus_plexus_component_annotations//jar",
+        "@org_codehaus_plexus_plexus_utils//jar",
+        "@org_eclipse_sisu_org_eclipse_sisu_inject//jar",
+        "@org_eclipse_sisu_org_eclipse_sisu_plexus//jar",
+        "@org_ow2_asm_asm//jar",
+        "@org_ow2_asm_asm_commons//jar",
+        "@org_ow2_asm_asm_tree//jar",
+        "@org_pantsbuild_jarjar//jar",
+    ],
+)
+
+exports_files(["AndroidManifest.xml"])
diff --git a/tools/bazel.rc b/tools/bazel.rc
new file mode 100644
index 000000000..de078cce9
--- /dev/null
+++ b/tools/bazel.rc
@@ -0,0 +1,2 @@
+# Include debug info in the compiled jars
+build --javacopt=-g
\ No newline at end of file
diff --git a/tools/jarjar.bzl b/tools/jarjar.bzl
new file mode 100644
index 000000000..17e1aed31
--- /dev/null
+++ b/tools/jarjar.bzl
@@ -0,0 +1,140 @@
+# Copyright (C) 2017 The Dagger Authors.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+def jarjar_deps():
+  """
+  Deps that are necessary to build jarjar_binary() but aren't used in the regular build process for
+  Dagger, so they are organized separately from the workspace file.
+  """
+  native.maven_jar(
+      name = "org_codehaus_plexus_plexus_utils",
+      artifact = "org.codehaus.plexus:plexus-utils:3.0.20",
+      sha1 = "e121ed37af8ee3928952f6d8a303de24e019aab0",
+  )
+
+  native.maven_jar(
+      name = "org_eclipse_sisu_org_eclipse_sisu_plexus",
+      artifact = "org.eclipse.sisu:org.eclipse.sisu.plexus:0.3.0",
+      sha1 = "3f53953a998d03b9b0f7d5098f63119e434af0ef",
+  )
+
+  native.maven_jar(
+      name = "org_apache_ant_ant_launcher",
+      artifact = "org.apache.ant:ant-launcher:1.9.6",
+      sha1 = "d75dd4c39ba06401f20e7afffb861d268baec6bc",
+  )
+
+  native.maven_jar(
+      name = "org_apache_maven_maven_plugin_api",
+      artifact = "org.apache.maven:maven-plugin-api:3.3.3",
+      sha1 = "3b78a7e40707be313c4d5449ba514c9747e1c731",
+  )
+
+  native.maven_jar(
+      name = "org_eclipse_sisu_org_eclipse_sisu_inject",
+      artifact = "org.eclipse.sisu:org.eclipse.sisu.inject:0.3.0",
+      sha1 = "6c25adce9ca9af097728ed57834e8807e3b6e2b5",
+  )
+
+  native.maven_jar(
+      name = "org_ow2_asm_asm",
+      artifact = "org.ow2.asm:asm:5.0.4",
+      sha1 = "0da08b8cce7bbf903602a25a3a163ae252435795",
+  )
+
+  native.maven_jar(
+      name = "org_ow2_asm_asm_tree",
+      artifact = "org.ow2.asm:asm-tree:5.0.4",
+      sha1 = "396ce0c07ba2b481f25a70195c7c94922f0d1b0b",
+  )
+
+  native.maven_jar(
+      name = "javax_enterprise_cdi_api",
+      artifact = "javax.enterprise:cdi-api:1.0",
+      sha1 = "44c453f60909dfc223552ace63e05c694215156b",
+  )
+
+  native.maven_jar(
+      name = "org_ow2_asm_asm_commons",
+      artifact = "org.ow2.asm:asm-commons:5.0.4",
+      sha1 = "5a556786086c23cd689a0328f8519db93821c04c",
+  )
+
+  native.maven_jar(
+      name = "org_apache_maven_maven_model",
+      artifact = "org.apache.maven:maven-model:3.3.3",
+      sha1 = "73ba535c2e3a1381aeab131598010b3a723d4b47",
+  )
+
+  native.maven_jar(
+      name = "org_apache_maven_maven_artifact",
+      artifact = "org.apache.maven:maven-artifact:3.3.3",
+      sha1 = "d9f439dfef726e54eebb390ff38dd27356901528",
+  )
+
+  native.maven_jar(
+      name = "org_pantsbuild_jarjar",
+      artifact = "org.pantsbuild:jarjar:1.6.3",
+      sha1 = "cf54d4b142f5409c394095181c8d308a81869622",
+  )
+
+  native.maven_jar(
+      name = "org_codehaus_plexus_plexus_classworlds",
+      artifact = "org.codehaus.plexus:plexus-classworlds:2.5.2",
+      sha1 = "4abb111bfdace5b8167db4c0ef74644f3f88f142",
+  )
+
+  native.maven_jar(
+      name = "org_apache_ant_ant",
+      artifact = "org.apache.ant:ant:1.9.6",
+      sha1 = "80e2063b01bab3c79c2d84e4ed5e73868394c85a",
+  )
+
+  native.maven_jar(
+      name = "org_codehaus_plexus_plexus_component_annotations",
+      artifact = "org.codehaus.plexus:plexus-component-annotations:1.5.5",
+      sha1 = "c72f2660d0cbed24246ddb55d7fdc4f7374d2078",
+  )
+
+def jarjar_library(name, deps, rules_file):
+  """
+  Combines `deps` into one jar file named <name>.jar and jarjar with the rules specified in
+  `rules_file`.
+
+  See: https://github.com/pantsbuild/jarjar
+  """
+  native.genrule(
+      name = name,
+      srcs = deps + [
+          rules_file,
+          "//tools:jarjar_deploy.jar",
+      ],
+      tools = [
+          "//tools:jarjar_library_impl",
+          "@local_jdk//:bin/jar",
+          "@local_jdk//:bin/java",
+          "@local_jdk//:jre",
+      ],
+      outs = [name + ".jar"],
+      cmd = """
+      export JAVA_HOME=$(JAVABASE)
+      $(location //tools:jarjar_library_impl) $@ "{deps}" {rules} \
+        $(location //tools:jarjar_deploy.jar) \
+        $$(readlink $(location @local_jdk//:bin/jar)) \
+        $$(readlink $(location @local_jdk//:bin/java)) \
+        $(@D)
+      """.format(
+          deps=" ".join(["$(location %s)" % dep for dep in deps]),
+          rules="$(location %s)" % rules_file),
+  )
diff --git a/tools/jarjar_library_impl.sh b/tools/jarjar_library_impl.sh
new file mode 100755
index 000000000..357628d14
--- /dev/null
+++ b/tools/jarjar_library_impl.sh
@@ -0,0 +1,56 @@
+#!/usr/bin/env bash
+
+# Copyright (C) 2017 The Dagger Authors.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+if [[ ! $JAVA_HOME =~ ^/ ]]; then
+  JAVA_HOME=$(readlink -f $JAVA_HOME)
+fi
+
+OUT=$1
+DEPS=$2
+RULES_FILE=$3
+JARJAR=$4
+JAR_BINARY=$5
+JAVA_BINARY=$6
+TMPDIR=$7/combined
+
+mkdir -p $TMPDIR
+for dep in $DEPS; do
+  unzip -B $dep -d $TMPDIR
+done
+pushd $TMPDIR
+
+# Concatenate similar files in META-INF/services
+for file in META-INF/services/*; do
+  original=$(echo $file | sed s/"~[0-9]*$"//)
+  if [[ "$file" != "$original" ]]; then
+    cat $file >> $original
+    rm $file
+  fi
+done
+
+rm META-INF/MANIFEST.MF*
+rm -rf META-INF/maven/
+duplicate_files=$(find * -type f -regex ".*~[0-9]*$")
+if [[ -n "$duplicate_files" ]]; then
+  echo "Error: duplicate files in merged jar: $duplicate_files"
+  exit 1
+fi
+$JAR_BINARY cvf combined.jar *
+
+popd
+
+$JAVA_BINARY -jar $JARJAR process $RULES_FILE $TMPDIR/combined.jar $OUT
+rm -rf $TMPDIR
diff --git a/tools/jarjar_library_impl_test.sh b/tools/jarjar_library_impl_test.sh
new file mode 100755
index 000000000..edc65d44c
--- /dev/null
+++ b/tools/jarjar_library_impl_test.sh
@@ -0,0 +1,60 @@
+#!/usr/bin/env bash
+
+# Copyright (C) 2017 The Dagger Authors.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+
+export JAVA_HOME=$(readlink -f $1)
+
+set -eu
+
+JAR_BINARY="$(readlink external/local_jdk/bin/jar)"
+JAVA_BINARY="$(readlink external/local_jdk/bin/java)"
+
+report_bad_output() {
+  $JAR_BINARY tf output.jar
+  echo $1
+  exit 1
+}
+
+ROOT=$TEST_SRCDIR/$TEST_WORKSPACE
+
+cd $TEST_TMPDIR
+
+echo "rule foo.** baz.@1" > rules_file
+
+$ROOT/tools/jarjar_library_impl.sh \
+  "output.jar" \
+  "$ROOT/tools/testdata/libfoo.jar $ROOT/tools/testdata/libbar.jar" \
+  "rules_file" \
+  "$ROOT/tools/jarjar_deploy.jar" \
+  "$JAR_BINARY" \
+  "$JAVA_BINARY" \
+  "."
+if $JAR_BINARY  tf output.jar | grep -F -q foo/Foo.class; then
+  report_bad_output "Expected foo/Foo.class to be renamed to baz/Foo.class"
+elif ! $JAR_BINARY tf output.jar | grep -F -q baz/Foo.class; then
+  report_bad_output "Expected baz/Foo.class to be in the output jar"
+fi
+
+if $ROOT/tools/jarjar_library_impl.sh \
+  "output.jar" \
+  "$ROOT/tools/testdata/libfoo_with_dupe_file.jar $ROOT/tools/testdata/libbar_with_dupe_file.jar" \
+  "rules_file" \
+  "$ROOT/tools/jarjar_deploy.jar" \
+  "$JAR_BINARY" \
+  "$JAVA_BINARY" \
+  "."; then
+  report_bad_output 'Expected duplicate file "dupe"'
+fi
diff --git a/tools/javadoc.bzl b/tools/javadoc.bzl
new file mode 100644
index 000000000..4331f9a17
--- /dev/null
+++ b/tools/javadoc.bzl
@@ -0,0 +1,107 @@
+# Copyright (C) 2017 The Dagger Authors.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+def _check_non_empty(value, name):
+  if not value:
+    fail("%s must be non-empty" % name)
+
+def javadoc_library(
+    name,
+    srcs = [],
+    deps = [],
+    root_packages = [],
+    exclude_packages = [],
+    android_api_level = None,
+    doctitle = None):
+  """
+  Generates a Javadoc jar $GENDIR/path/to/target/<name>.jar.
+
+  Arguments:
+    srcs: source files to process
+    deps: targets that contain references to other types referenced in Javadoc. This can be the
+        java_library/android_library target(s) for the same sources
+    root_packages: Java packages to include in generated Javadoc. Any subpackages not listed in
+        exclude_packages will be included as well
+    exclude_packages: Java packages to exclude from generated Javadoc
+    android_api_level: If Android APIs are used, the API level to compile against to generate
+        Javadoc
+    doctitle: title for Javadoc's index.html. See javadoc -doctitle
+  """
+  _check_non_empty(srcs, "srcs")
+  _check_non_empty(root_packages, "root_packages")
+
+  exclude_packages_option = ""
+  if exclude_packages:
+    exclude_packages_option = "-exclude " + ":".join(exclude_packages)
+
+  deploy_jar_name = name + "_deploy_jar_for_javadoc"
+  deploy_jar_label = ":%s_deploy.jar" % deploy_jar_name
+
+  genrule_srcs = srcs + deps + [
+      deploy_jar_label,
+      "//tools:javadoc_library_impl"
+  ]
+
+  bootclasspath_option = ""
+  if android_api_level:
+    native.android_binary(
+        name = deploy_jar_name,
+        deps = deps,
+        manifest = "//tools:AndroidManifest.xml",
+        custom_package = "dummy",
+        tags = ["manual"],
+    )
+    android_jar = "@androidsdk//:platforms/android-%s/android.jar" % android_api_level
+    genrule_srcs.append(android_jar)
+    bootclasspath_option = "-bootclasspath $(location %s)" % android_jar
+  else:
+    native.java_binary(
+        name = deploy_jar_name,
+        runtime_deps = deps,
+        main_class = "dummy",
+        tags = ["manual"],
+    )
+
+  doctitle_option = ""
+  if doctitle:
+    doctitle_option = "-doctitle \"%s\"" % doctitle
+
+  external_javadoc_links = [
+      "https://docs.oracle.com/javase/8/docs/api/",
+      "https://developer.android.com/reference/",
+      "https://google.github.io/guava/releases/21.0/api/docs/",
+      "https://docs.oracle.com/javaee/7/api/"
+  ]
+
+  linkoffline_options = ' '.join(
+      ["-linkoffline {0} {0}".format(url) for url in external_javadoc_links])
+
+  native.genrule(
+      name = name,
+      srcs = genrule_srcs,
+      outs = [name + ".jar"],
+      tools = ["@local_jdk//:bin/javadoc", "@local_jdk//:bin/jar"],
+      cmd = """
+$(location //tools:javadoc_library_impl) \
+  "$(location @local_jdk//:bin/javadoc)" "$(location @local_jdk//:bin/jar)" "$@" \
+  "{include_packages}" "{exclude_packages}" "$(location {deploy_jar})" "{bootclasspath}" \
+  "{linkoffline}" "{doctitle}" "$(@D)"
+      """.format(
+          deploy_jar=deploy_jar_label,
+          include_packages=":".join(root_packages),
+          exclude_packages=exclude_packages_option,
+          bootclasspath=bootclasspath_option,
+          doctitle=doctitle_option,
+          linkoffline=linkoffline_options)
+  )
diff --git a/tools/javadoc_library_impl.sh b/tools/javadoc_library_impl.sh
new file mode 100755
index 000000000..b2d711598
--- /dev/null
+++ b/tools/javadoc_library_impl.sh
@@ -0,0 +1,47 @@
+#!/usr/bin/env sh
+
+# Copyright (C) 2017 The Dagger Authors.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+JAVADOC_BINARY=$1
+JAR_BINARY=$2
+OUTPUT=$3
+INCLUDE_PACKAGES=$4
+EXCLUDE_PACKAGES=$5
+DEPLOY_JAR=$6
+BOOTCLASSPATH=$7
+LINKOFFLINE=$8
+DOCTITLE=$9
+TEMPDIR=${10}/tmp
+
+mkdir -p $TEMPDIR
+
+$JAVADOC_BINARY \
+  -sourcepath $(find * -type d -regex ".*java" -print0 | tr '\0' :) \
+  $INCLUDE_PACKAGES \
+  -use \
+  -subpackages $INCLUDE_PACKAGES \
+  -encoding UTF8 \
+  $EXCLUDE_PACKAGES \
+  -classpath $DEPLOY_JAR \
+  $BOOTCLASSPATH \
+  $LINKOFFLINE \
+  -notimestamp \
+  $DOCTITLE \
+  -bottom "Copyright &copy; 2012–2017 The Dagger Authors. All rights reserved." \
+  -d $TEMPDIR
+
+$JAR_BINARY cvf $OUTPUT -C $TEMPDIR $TEMPDIR/*
+rm -rf $TEMPDIR
+
diff --git a/tools/testdata/BUILD b/tools/testdata/BUILD
new file mode 100644
index 000000000..b994ff545
--- /dev/null
+++ b/tools/testdata/BUILD
@@ -0,0 +1,44 @@
+# Copyright (C) 2017 The Dagger Authors.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+# Description:
+#   Tools for Dagger
+
+package(default_visibility = ["//:src"])
+
+java_library(
+    name = "foo",
+    srcs = ["Foo.java"],
+    deps = ["//third_party:auto_service"],
+)
+
+java_library(
+    name = "foo_with_dupe_file",
+    srcs = ["Foo.java"],
+    resources = ["dupe"],
+    deps = ["//third_party:auto_service"],
+)
+
+java_library(
+    name = "bar",
+    srcs = ["Bar.java"],
+    deps = ["//third_party:auto_service"],
+)
+
+java_library(
+    name = "bar_with_dupe_file",
+    srcs = ["Bar.java"],
+    resources = ["dupe"],
+    deps = ["//third_party:auto_service"],
+)
diff --git a/tools/testdata/Bar.java b/tools/testdata/Bar.java
new file mode 100644
index 000000000..e040e39fd
--- /dev/null
+++ b/tools/testdata/Bar.java
@@ -0,0 +1,22 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package bar;
+
+import com.google.auto.service.AutoService;
+
+@AutoService(Object.class)
+class Bar {}
diff --git a/tools/testdata/Foo.java b/tools/testdata/Foo.java
new file mode 100644
index 000000000..f2305c83a
--- /dev/null
+++ b/tools/testdata/Foo.java
@@ -0,0 +1,22 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package foo;
+
+import com.google.auto.service.AutoService;
+
+@AutoService(Object.class)
+class Foo {}
diff --git a/tools/testdata/dupe b/tools/testdata/dupe
new file mode 100644
index 000000000..b68619fc0
--- /dev/null
+++ b/tools/testdata/dupe
@@ -0,0 +1 @@
+duped data file
diff --git a/util/deploy-to-maven-central.sh b/util/deploy-to-maven-central.sh
new file mode 100755
index 000000000..1cd368938
--- /dev/null
+++ b/util/deploy-to-maven-central.sh
@@ -0,0 +1,44 @@
+#!/bin/bash
+
+set -eu
+
+if [ $# -lt 2 ]; then
+  echo "usage $0 <ssl-key> <version-name> [<param> ...]"
+  exit 1;
+fi
+key=$1
+version_name=$2
+shift 2
+
+if [[ ! $version_name =~ ^2\. ]]; then
+  echo 'Version name must begin with "2."'
+  exit 2
+fi
+
+#validate key
+keystatus=$(gpg --list-keys | grep ${key} | awk '{print $1}')
+if [ "${keystatus}" != "pub" ]; then
+  echo "Could not find public key with label ${key}"
+  echo -n "Available keys from: "
+  gpg --list-keys | grep --invert-match '^sub'
+
+  exit 64
+fi
+
+sh $(dirname $0)/execute-deploy.sh \
+  "$version_name" \
+  "sonatype-nexus-staging" \
+  "https://oss.sonatype.org/service/local/staging/deploy/maven2/" \
+  "-Dgpg.keyname=${key}"
+
+# Publish javadocs to gh-pages
+bazel build //:user-docs.jar
+git clone --quiet --branch gh-pages \
+    https://github.com/google/dagger gh-pages > /dev/null
+cd gh-pages
+unzip ../bazel-genfiles/user-docs.jar -d api/$version_name
+git add api/$version_name
+git commit -m "$version_name docs"
+git push origin gh-pages
+cd ..
+rm -rf gh-pages
diff --git a/util/execute-deploy.sh b/util/execute-deploy.sh
new file mode 100755
index 000000000..fa5fc978c
--- /dev/null
+++ b/util/execute-deploy.sh
@@ -0,0 +1,79 @@
+#!/bin/sh
+
+VERSION_NAME=$1
+REPOSITORY_ID=$2
+REPOSITORY_URL=$3
+EXTRA_MAVEN_ARGS=$4
+
+python $(dirname $0)/maven/generate_poms.py $VERSION_NAME \
+  //core/src/main/java/dagger:core \
+  //compiler:compiler \
+  //producers:producers \
+  //java/dagger/android:android \
+  //java/dagger/android/support:support \
+  //java/dagger/android/processor:processor
+
+library_output_file() {
+  library=$1
+  library_output=bazel-bin/$library
+  if [[ ! -e $library_output ]]; then
+     library_output=bazel-genfiles/$library
+  fi
+  if [[ ! -e $library_output ]]; then
+    echo "Could not find bazel output file for $library"
+    exit 1
+  fi
+  echo -n $library_output
+}
+
+deploy_library() {
+  library=$1
+  srcjar=$2
+  javadoc=$3
+  pomfile=$4
+  bazel build $library $srcjar $javadoc
+  mvn gpg:sign-and-deploy-file \
+    -Dfile=$(library_output_file $library) \
+    -DrepositoryId=$REPOSITORY_ID \
+    -Durl=$REPOSITORY_URL \
+    -Djavadoc=bazel-genfiles/$javadoc \
+    -DpomFile=$pomfile \
+    -Dsources=bazel-bin/$srcjar \
+    $EXTRA_MAVEN_ARGS
+}
+
+deploy_library \
+  core/src/main/java/dagger/libcore.jar \
+  core/src/main/java/dagger/libcore-src.jar \
+  core/src/main/java/dagger/core-javadoc.jar \
+  dagger.pom.xml
+
+deploy_library \
+  shaded_compiler.jar \
+  compiler/libcompiler-src.jar \
+  compiler/compiler-javadoc.jar \
+  dagger-compiler.pom.xml
+
+deploy_library \
+  producers/libproducers.jar \
+  producers/libproducers-src.jar \
+  producers/producers-javadoc.jar \
+  dagger-producers.pom.xml
+
+deploy_library \
+  java/dagger/android/android.aar \
+  java/dagger/android/libandroid-src.jar \
+  java/dagger/android/android-javadoc.jar \
+  dagger-android.pom.xml
+
+deploy_library \
+  java/dagger/android/support/support.aar \
+  java/dagger/android/support/libsupport-src.jar \
+  java/dagger/android/support/support-javadoc.jar \
+  dagger-android-support.pom.xml
+
+deploy_library \
+  java/dagger/android/processor/libprocessor.jar \
+  java/dagger/android/processor/libprocessor-src.jar \
+  java/dagger/android/processor/processor-javadoc.jar \
+  dagger-android-processor.pom.xml
diff --git a/util/generate-latest-docs.sh b/util/generate-latest-docs.sh
index 573576999..e534adc46 100755
--- a/util/generate-latest-docs.sh
+++ b/util/generate-latest-docs.sh
@@ -1,25 +1,28 @@
 # see http://benlimmer.com/2013/12/26/automatically-publish-javadoc-to-gh-pages-with-travis-ci/ for details
 
+set -eu
+
 if [ "$TRAVIS_REPO_SLUG" == "google/dagger" ] && \
-   [ "$TRAVIS_JDK_VERSION" == "oraclejdk7" ] && \
+   [ "$TRAVIS_JDK_VERSION" == "$JDK_FOR_PUBLISHING" ] && \
    [ "$TRAVIS_PULL_REQUEST" == "false" ] && \
    [ "$TRAVIS_BRANCH" == "master" ]; then
   echo -e "Publishing javadoc...\n"
-  mvn javadoc:aggregate -P!examples -DexcludePackageNames=*.internal
-  TARGET="$(pwd)/target"
+  bazel build //:user-docs.jar
 
   cd $HOME
   git clone --quiet --branch=gh-pages https://${GH_TOKEN}@github.com/google/dagger gh-pages > /dev/null
-  
+
   cd gh-pages
   git config --global user.email "travis@travis-ci.org"
   git config --global user.name "travis-ci"
-  git rm -rf api/latest 
+  git rm -rf api/latest
   mkdir -p api
-  mv ${TARGET}/site/apidocs api/latest
+  unzip ../bazel-genfiles/user-docs.jar -d api/latest
   git add -f api/latest
   git commit -m "Lastest javadoc on successful travis build $TRAVIS_BUILD_NUMBER auto-pushed to gh-pages"
   git push -fq origin gh-pages > /dev/null
 
   echo -e "Published Javadoc to gh-pages.\n"
+else
+  echo -e "Not publishing docs for jdk=${TRAVIS_JDK_VERSION} and branch=${TRAVIS_BRANCH}"
 fi
diff --git a/util/maven/__init__.py b/util/maven/__init__.py
new file mode 100644
index 000000000..e69de29bb
diff --git a/util/maven/generate_poms.py b/util/maven/generate_poms.py
new file mode 100644
index 000000000..7254ec46b
--- /dev/null
+++ b/util/maven/generate_poms.py
@@ -0,0 +1,124 @@
+# Copyright (C) 2017 The Dagger Authors.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+import os
+import re
+from subprocess import check_output
+import sys
+from workspace_parser import maven_artifacts
+from xml_formatting import generate_pom
+
+
+def _shell(command):
+  output = check_output(command,
+                        shell=True,
+                        stderr=open(os.devnull)).strip()
+  return output.splitlines()
+
+def deps_of(label):
+  return _shell(
+      """bazel query 'let deps = labels(deps, {0}) in
+      $deps except attr(tags, compile_time_dep, $deps)'""".format(label))
+
+def exports_for(label):
+  return _shell('bazel query "labels(exports, %s)"' % label)
+
+def pom_deps(label):
+  accumulated_deps = set()
+  for dep in deps_of(label):
+    if dep.startswith("@local_jdk//:"): continue
+    if dep.startswith(('//:', '//third_party:')):
+      for export in exports_for(dep):
+        accumulated_deps.add(export)
+        accumulated_deps.update(pom_deps(export))
+    else:
+      if ':lib' in dep and dep.endswith('.jar'):
+        dep = dep[:-4].replace(':lib', ':')
+      accumulated_deps.add(dep)
+
+  return accumulated_deps
+
+
+GROUP = 'com.google.dagger'
+
+METADATA = {
+    '//core/src/main/java/dagger:core': {
+        'name': 'Dagger',
+        'artifact': 'dagger',
+        'alias': '//core:core',
+    },
+    '//compiler:compiler': {
+        'name': 'Dagger Compiler',
+        'artifact': 'dagger-compiler',
+    },
+    '//producers:producers': {
+        'name': 'Dagger Producers',
+        'artifact': 'dagger-producers',
+    },
+    '//java/dagger/android:android': {
+        'name': 'Dagger Android',
+        'artifact': 'dagger-android',
+        'packaging': 'aar',
+    },
+    '//java/dagger/android/support:support': {
+        'name': 'Dagger Android Support',
+        'artifact': 'dagger-android-support',
+        'packaging': 'aar',
+    },
+    '//java/dagger/android/processor:processor': {
+        'name': 'Dagger Android Processor',
+        'artifact': 'dagger-android-processor',
+    },
+}
+
+class UnknownDependencyException(Exception): pass
+
+def main():
+  if len(sys.argv) < 3:
+    print 'Usage: %s <version> <target_for_pom>...' % sys.argv[0]
+    sys.exit(1)
+
+  version = sys.argv[1]
+  artifacts = maven_artifacts()
+
+  android_sdk_pattern = re.compile(
+      r'@androidsdk//([a-z.-]*):([a-z0-9-]*)-([0-9.]*)')
+
+  for label, metadata in METADATA.iteritems():
+    artifacts[label] = (
+        'com.google.dagger:%s:%s' % (metadata['artifact'], version)
+    )
+    if 'alias' in metadata:
+      artifacts[metadata['alias']] = artifacts[label]
+
+  def artifact_for_dep(label):
+    if label in artifacts:
+      return artifacts[label]
+    match = android_sdk_pattern.match(label)
+    if match:
+      return ':'.join(match.groups())
+    raise UnknownDependencyException('No artifact found for %s' % label)
+
+  for arg in sys.argv[2:]:
+    metadata = METADATA[arg]
+    with open('%s.pom.xml' % metadata['artifact'], 'w') as pom_file:
+      pom_file.write(
+          generate_pom(
+              artifacts[arg],
+              metadata,
+              map(artifact_for_dep, pom_deps(arg)),
+              version))
+
+if __name__ == '__main__':
+  main()
diff --git a/util/maven/workspace_parser.py b/util/maven/workspace_parser.py
new file mode 100644
index 000000000..47e24483a
--- /dev/null
+++ b/util/maven/workspace_parser.py
@@ -0,0 +1,37 @@
+# Copyright (C) 2017 The Dagger Authors.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+import ast
+
+class WorkspaceVisitor(ast.NodeVisitor):
+  def __init__(self):
+    self.artifacts = {}
+
+  def visit_Call(self, rule):
+    if rule.func.id is not 'maven_jar': return
+    name = None
+    artifact = None
+    for keyword in rule.keywords:
+      if keyword.arg == 'name':
+        name = keyword.value.s
+      if keyword.arg == 'artifact':
+        artifact = keyword.value.s
+    self.artifacts['@%s//jar:jar' % name] = artifact
+
+def maven_artifacts():
+  visitor = WorkspaceVisitor()
+  with open('WORKSPACE', 'r') as workspace:
+    visitor.visit(ast.parse(workspace.read()))
+
+  return visitor.artifacts
diff --git a/util/maven/xml_formatting.py b/util/maven/xml_formatting.py
new file mode 100644
index 000000000..71db83b8b
--- /dev/null
+++ b/util/maven/xml_formatting.py
@@ -0,0 +1,100 @@
+# Copyright (C) 2017 The Dagger Authors.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+DEP_BLOCK = """
+<dependency>
+  <groupId>%s</groupId>
+  <artifactId>%s</artifactId>
+  <version>%s</version>
+</dependency>
+""".strip()
+
+def maven_dependency_xml(artifact_string):
+  group, artifact, version = artifact_string.split(':')
+  formatted = DEP_BLOCK % (group, artifact, version)
+  return '\n'.join(['    %s' %x for x in formatted.split('\n')])
+
+POM_OUTLINE = """<?xml version="1.0" encoding="UTF-8"?>
+<!--
+ Copyright (C) 2012 The Dagger Authors.
+
+  Licensed under the Apache License, Version 2.0 (the "License");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>org.sonatype.oss</groupId>
+    <artifactId>oss-parent</artifactId>
+    <version>7</version>
+  </parent>
+
+  <groupId>{group}</groupId>
+  <artifactId>{artifact}</artifactId>
+  <name>{name}</name>
+  <version>{version}</version>
+  <description>A fast dependency injector for Android and Java.</description>
+  <url>https://github.com/google/dagger</url>
+  <packaging>{packaging}</packaging>
+
+  <scm>
+    <url>http://github.com/google/dagger/</url>
+    <connection>scm:git:git://github.com/google/dagger.git</connection>
+    <developerConnection>scm:git:ssh://git@github.com/google/dagger.git</developerConnection>
+    <tag>HEAD</tag>
+  </scm>
+
+  <issueManagement>
+    <system>GitHub Issues</system>
+    <url>http://github.com/google/dagger/issues</url>
+  </issueManagement>
+
+  <licenses>
+    <license>
+      <name>Apache 2.0</name>
+      <url>http://www.apache.org/licenses/LICENSE-2.0.txt</url>
+    </license>
+  </licenses>
+
+  <organization>
+    <name>Google, Inc.</name>
+    <url>http://www.google.com</url>
+  </organization>
+
+  <dependencies>
+{deps}
+  </dependencies>
+</project>
+"""
+
+def generate_pom(artifact_string, metadata, deps, version):
+  group, artifact, version = artifact_string.split(':')
+
+  return POM_OUTLINE.format(
+      group=group,
+      artifact=artifact,
+      name=metadata['name'],
+      version=version,
+      packaging=metadata.get('packaging', 'jar'),
+      deps='\n'.join(map(maven_dependency_xml, deps)))
diff --git a/util/mvn-deploy.sh b/util/mvn-deploy.sh
deleted file mode 100755
index ec4b7a0d2..000000000
--- a/util/mvn-deploy.sh
+++ /dev/null
@@ -1,21 +0,0 @@
-#!/bin/bash
-if [ $# -lt 1 ]; then
-  echo "usage $0 <ssl-key> [<param> ...]"
-  exit 1;
-fi
-key=$1
-shift
-
-#validate key
-keystatus=$(gpg --list-keys | grep ${key} | awk '{print $1}')
-if [ "${keystatus}" != "pub" ]; then
-  echo "Could not find public key with label ${key}"
-  echo -n "Available keys from: "
-  gpg --list-keys | grep --invert-match '^sub'
-
-  exit 64
-fi
-
-mvn "$@" -P '!examples' -P sonatype-oss-release \
-    -Dgpg.skip=false -Dgpg.keyname=${key} \
-    clean site:jar deploy
diff --git a/util/publish-snapshot-on-commit.sh b/util/publish-snapshot-on-commit.sh
index be27cb6e0..ab0d84cab 100755
--- a/util/publish-snapshot-on-commit.sh
+++ b/util/publish-snapshot-on-commit.sh
@@ -1,12 +1,20 @@
 # see https://coderwall.com/p/9b_lfq
 
+set -eu
+
 if [ "$TRAVIS_REPO_SLUG" == "google/dagger" ] && \
-   [ "$TRAVIS_JDK_VERSION" == "oraclejdk7" ] && \
+   [ "$TRAVIS_JDK_VERSION" == "$JDK_FOR_PUBLISHING" ] && \
    [ "$TRAVIS_PULL_REQUEST" == "false" ] && \
    [ "$TRAVIS_BRANCH" == "master" ]; then
   echo -e "Publishing maven snapshot...\n"
 
-  mvn clean source:jar deploy --settings="util/settings.xml" -DskipTests=true -Dinvoker.skip=true -Dmaven.javadoc.skip=true
+  sh $(dirname $0)/execute-deploy.sh \
+    "HEAD-SNAPSHOT" \
+    "sonatype-nexus-snapshots" \
+    "https://oss.sonatype.org/content/repositories/snapshots" \
+    "--settings=util/settings.xml"
 
   echo -e "Published maven snapshot"
+else
+  echo -e "Not publishing snapshot for jdk=${TRAVIS_JDK_VERSION} and branch=${TRAVIS_BRANCH}"
 fi
