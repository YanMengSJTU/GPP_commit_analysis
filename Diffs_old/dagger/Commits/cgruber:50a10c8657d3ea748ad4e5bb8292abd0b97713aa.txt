diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/provisions/Provisions.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/provisions/Provisions.java
new file mode 100644
index 000000000..0833995ce
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/provisions/Provisions.java
@@ -0,0 +1,80 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package producerstest.provisions;
+
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.producers.Producer;
+import dagger.producers.ProducerModule;
+import dagger.producers.Produces;
+import dagger.producers.ProductionComponent;
+import javax.inject.Inject;
+import producerstest.ExecutorModule;
+
+import javax.inject.Qualifier;
+
+/** Tests for requesting provisions from producers. */
+final class Provisions {
+  static final class InjectedClass {
+    @Inject InjectedClass() {}
+  }
+
+  static final class WrappedProducer<T> {
+    final Producer<T> producer;
+
+    WrappedProducer(Producer<T> producer) {
+      this.producer = producer;
+    }
+  }
+
+  static final class Output {
+    final Producer<InjectedClass> injectedClass1;
+    final Producer<InjectedClass> injectedClass2;
+
+    Output(Producer<InjectedClass> injectedClass1, Producer<InjectedClass> injectedClass2) {
+      this.injectedClass1 = injectedClass1;
+      this.injectedClass2 = injectedClass2;
+    }
+  }
+
+  @Qualifier @interface First {}
+  @Qualifier @interface Second {}
+
+  @ProducerModule
+  static final class TestModule {
+    @Produces @First static WrappedProducer<InjectedClass> firstProducer(
+        Producer<InjectedClass> injectedClass) {
+      return new WrappedProducer<InjectedClass>(injectedClass);
+    }
+
+    @Produces @Second static WrappedProducer<InjectedClass> secondProducer(
+        Producer<InjectedClass> injectedClass) {
+      return new WrappedProducer<InjectedClass>(injectedClass);
+    }
+
+    @Produces static Output output(
+        @First WrappedProducer<InjectedClass> producer1,
+        @Second WrappedProducer<InjectedClass> producer2) {
+      return new Output(producer1.producer, producer2.producer);
+    }
+  }
+
+  @ProductionComponent(modules = {ExecutorModule.class, TestModule.class})
+  interface TestComponent {
+    ListenableFuture<Output> output();
+  }
+
+  private Provisions() {}
+}
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/provisions/ProvisionsTest.java b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/provisions/ProvisionsTest.java
new file mode 100644
index 000000000..e4371cbf4
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/provisions/ProvisionsTest.java
@@ -0,0 +1,36 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package producerstest.provisions;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import producerstest.provisions.DaggerProvisions_TestComponent;
+import producerstest.provisions.Provisions.Output;
+import producerstest.provisions.Provisions.TestComponent;
+
+import static com.google.common.truth.Truth.assertThat;
+
+@RunWith(JUnit4.class)
+public final class ProvisionsTest {
+
+  @Test
+  public void provisionsOnlyAreHeldInOneProducer() throws Exception {
+    TestComponent component = DaggerProvisions_TestComponent.create();
+    Output output = component.output().get();
+    assertThat(output.injectedClass1).isSameAs(output.injectedClass2);
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
index 4eebafe40..aa0cae688 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -141,6 +141,7 @@
   protected TypeSpec.Builder component;
   private final UniqueNameSet componentFieldNames = new UniqueNameSet();
   private final Map<BindingKey, MemberSelect> memberSelects = new HashMap<>();
+  private final Map<BindingKey, MemberSelect> producerFromProviderMemberSelects = new HashMap<>();
   protected final MethodSpec.Builder constructor = constructorBuilder().addModifiers(PRIVATE);
   protected Optional<ClassName> builderName = Optional.absent();
 
@@ -483,17 +484,22 @@ private void addField(ResolvedBindings resolvedBindings) {
 
     // TODO(gak): get rid of the field for unscoped delegated bindings
 
-    FieldSpec frameworkField = addFrameworkField(resolvedBindings);
+    FieldSpec frameworkField = addFrameworkField(resolvedBindings, Optional.<BindingType>absent());
     memberSelects.put(
         bindingKey,
         localField(name, frameworkField.name));
   }
 
-  private FieldSpec addFrameworkField(ResolvedBindings resolvedBindings) {
+  /**
+   * Adds a field representing the resolved bindings, optionally forcing it to use a particular
+   * binding type (instead of the type the resolved bindings would typically use).
+   */
+  private FieldSpec addFrameworkField(
+      ResolvedBindings resolvedBindings, Optional<BindingType> bindingType) {
     boolean useRawType = useRawType(resolvedBindings);
 
     FrameworkField contributionBindingField =
-        FrameworkField.createForResolvedBindings(resolvedBindings);
+        FrameworkField.createForResolvedBindings(resolvedBindings, bindingType);
     FieldSpec.Builder contributionField =
         componentField(
             useRawType
@@ -795,7 +801,7 @@ private void initializeFrameworkTypes() {
         return Optional.of(
             CodeBlocks.concat(
                 ImmutableList.of(
-                    initializeDelegateFactoriesForUninitializedDependencies(binding),
+                    initializeDeferredDependencies(binding),
                     initializeMember(
                         bindingKey, initializeFactoryForContributionBinding(binding)))));
       default:
@@ -814,10 +820,21 @@ private void initializeFrameworkTypes() {
     return Optional.of(
         CodeBlocks.concat(
             ImmutableList.of(
-                initializeDelegateFactoriesForUninitializedDependencies(binding),
+                initializeDeferredDependencies(binding),
                 initializeMember(bindingKey, initializeMembersInjectorForBinding(binding)))));
   }
 
+  /**
+   * Initializes any dependencies of the given binding that need to be instantiated, i.e., as we get
+   * to them during normal initialization.
+   */
+  private CodeBlock initializeDeferredDependencies(Binding binding) {
+    return CodeBlocks.concat(
+        ImmutableList.of(
+            initializeDelegateFactoriesForUninitializedDependencies(binding),
+            initializeProducersFromProviderDependencies(binding)));
+  }
+
   /**
    * Initializes delegate factories for any dependencies of {@code binding} that are uninitialized
    * because of a dependency cycle.
@@ -841,6 +858,33 @@ private CodeBlock initializeDelegateFactoriesForUninitializedDependencies(Bindin
     return CodeBlocks.concat(initializations.build());
   }
 
+  private CodeBlock initializeProducersFromProviderDependencies(Binding binding) {
+    ImmutableList.Builder<CodeBlock> initializations = ImmutableList.builder();
+    for (FrameworkDependency frameworkDependency : frameworkDependenciesForBinding(binding)) {
+      ResolvedBindings resolvedBindings =
+          graph.resolvedBindings().get(frameworkDependency.bindingKey());
+      if (resolvedBindings.frameworkClass().equals(Provider.class)
+          && frameworkDependency.frameworkClass().equals(Producer.class)) {
+        MemberSelect memberSelect =
+            producerFromProviderMemberSelects.get(frameworkDependency.bindingKey());
+        if (memberSelect != null) {
+          continue;
+        }
+        FieldSpec frameworkField =
+            addFrameworkField(resolvedBindings, Optional.of(BindingType.PRODUCTION));
+        memberSelect = localField(name, frameworkField.name);
+        producerFromProviderMemberSelects.put(frameworkDependency.bindingKey(), memberSelect);
+        initializations.add(
+            CodeBlock.of(
+                "this.$L = $T.producerFromProvider($L);",
+                memberSelect.getExpressionFor(name),
+                PRODUCERS,
+                getMemberSelectExpression(frameworkDependency.bindingKey())));
+      }
+    }
+    return CodeBlocks.concat(initializations.build());
+  }
+
   private CodeBlock initializeMember(BindingKey bindingKey, CodeBlock initializationCodeBlock) {
     ImmutableList.Builder<CodeBlock> initializations = ImmutableList.builder();
 
@@ -1053,13 +1097,12 @@ private CodeBlock initializeMembersInjectorForBinding(MembersInjectionBinding bi
    */
   private CodeBlock getDependencyArgument(FrameworkDependency frameworkDependency) {
     BindingKey requestedKey = frameworkDependency.bindingKey();
-    CodeBlock frameworkExpression = getMemberSelectExpression(requestedKey);
     ResolvedBindings resolvedBindings = graph.resolvedBindings().get(requestedKey);
     if (resolvedBindings.frameworkClass().equals(Provider.class)
         && frameworkDependency.frameworkClass().equals(Producer.class)) {
-      return CodeBlock.of("$T.producerFromProvider($L)", PRODUCERS, frameworkExpression);
+      return producerFromProviderMemberSelects.get(requestedKey).getExpressionFor(name);
     } else {
-      return frameworkExpression;
+      return getMemberSelectExpression(requestedKey);
     }
   }
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java b/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java
index d8d2e37d8..c1d4e1ac2 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java
@@ -18,6 +18,7 @@
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
 import com.google.common.base.CaseFormat;
+import com.google.common.base.Optional;
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.ParameterizedTypeName;
 import com.squareup.javapoet.TypeName;
@@ -53,14 +54,17 @@ private static FrameworkField createForMapBindingContribution(Key key, String na
         name.endsWith(suffix) ? name : name + suffix);
   }
 
-  static FrameworkField createForResolvedBindings(ResolvedBindings resolvedBindings) {
+  static FrameworkField createForResolvedBindings(
+      ResolvedBindings resolvedBindings, Optional<BindingType> bindingType) {
     if (resolvedBindings.isMultibindingContribution()
         && resolvedBindings.contributionType().equals(ContributionType.MAP)) {
       return createForMapBindingContribution(
           resolvedBindings.key(), frameworkFieldName(resolvedBindings));
     } else {
       return createWithTypeFromKey(
-          resolvedBindings.frameworkClass(),
+          bindingType.isPresent()
+              ? bindingType.get().frameworkClass()
+              : resolvedBindings.frameworkClass(),
           resolvedBindings.key(),
           frameworkFieldName(resolvedBindings));
     }
diff --git a/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java
index 00ebc99b6..b494e9d88 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java
@@ -223,6 +223,7 @@ public void simpleComponent() {
             "  private Provider<ProductionComponentMonitor> monitorProvider;",
             "  private Provider<TestClass.B> bProvider;",
             "  private Producer<TestClass.A> aProducer;",
+            "  private Producer<TestClass.B> bProducer;",
             "",
             "  private DaggerTestClass_SimpleComponent(Builder builder) {",
             "    assert builder != null;",
@@ -254,11 +255,12 @@ public void simpleComponent() {
             "                SetFactory.<ProductionComponentMonitor.Factory>create());",
             "    this.bProvider = TestClass$BModule_BFactory.create(",
             "        builder.bModule, TestClass$C_Factory.create());",
+            "    this.bProducer = Producers.producerFromProvider(bProvider);",
             "    this.aProducer = new TestClass$AModule_AFactory(",
             "        builder.aModule,",
             "        executorProvider2,",
             "        monitorProvider,",
-            "        Producers.producerFromProvider(bProvider));",
+            "        bProducer);",
             "  }",
             "",
             "  @Override",
