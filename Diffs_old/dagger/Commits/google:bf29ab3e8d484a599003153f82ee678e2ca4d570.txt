diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
index dd4ab51ff..84f273f07 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -80,7 +80,6 @@
 import javax.tools.Diagnostic;
 import javax.tools.Diagnostic.Kind;
 
-import static com.google.auto.common.MoreTypes.asDeclared;
 import static com.google.common.base.CaseFormat.LOWER_CAMEL;
 import static com.google.common.base.CaseFormat.UPPER_CAMEL;
 import static com.google.common.base.Preconditions.checkState;
@@ -475,26 +474,22 @@ private void addField(ResolvedBindings resolvedBindings) {
     boolean useRawType = bindingPackage.isPresent()
         && !bindingPackage.get().equals(name.packageName());
     if (resolvedBindings.isMultibindings()) {
-      ImmutableSet<ContributionBinding> contributionBindings =
-          resolvedBindings.contributionBindings();
       // note that here we rely on the order of the resolved bindings being from parent to child
       // otherwise, the numbering wouldn't work
       int contributionNumber = 0;
-      for (ContributionBinding contributionBinding : contributionBindings) {
-        if (!contributionBinding.isSyntheticBinding()) {
-          contributionNumber++;
-          if (resolvedBindings.ownedContributionBindings().contains(contributionBinding)) {
-            FrameworkField contributionBindingField =
-                FrameworkField.createForSyntheticContributionBinding(
-                    contributionNumber, contributionBinding);
-            FieldWriter contributionField = addFrameworkField(useRawType, contributionBindingField);
-
-            ImmutableList<String> contributionSelectTokens =
-                ImmutableList.of(contributionField.name());
-            multibindingContributionSnippets.put(
-                contributionBinding,
-                MemberSelect.instanceSelect(name, memberSelectSnippet(contributionSelectTokens)));
-          }
+      for (ContributionBinding contributionBinding : resolvedBindings.contributionBindings()) {
+        contributionNumber++;
+        if (resolvedBindings.ownedContributionBindings().contains(contributionBinding)) {
+          FrameworkField contributionBindingField =
+              FrameworkField.createForSyntheticContributionBinding(
+                  contributionNumber, contributionBinding);
+          FieldWriter contributionField = addFrameworkField(useRawType, contributionBindingField);
+
+          ImmutableList<String> contributionSelectTokens =
+              ImmutableList.of(contributionField.name());
+          multibindingContributionSnippets.put(
+              contributionBinding,
+              MemberSelect.instanceSelect(name, memberSelectSnippet(contributionSelectTokens)));
         }
       }
     }
@@ -794,9 +789,7 @@ private Snippet initializeMapMultibindings(ResolvedBindings resolvedBindings) {
       }
     }
     initializationSnippets.add(
-        initializeMember(
-            resolvedBindings.bindingKey(),
-            initializeMapBinding(resolvedBindings.contributionBindings())));
+        initializeMember(resolvedBindings.bindingKey(), initializeMapBinding(resolvedBindings)));
 
     return Snippet.concat(initializationSnippets.build());
   }
@@ -1019,6 +1012,16 @@ private Snippet initializeFactoryForContributionBinding(ContributionBinding bind
               generatedClassNameForBinding(binding),
               Snippet.makeParametersSnippet(parameters));
         }
+        
+      case SYNTHETIC_MAP:
+        checkState(
+            MapType.isMap(binding.key().type()),
+            "Expected synthetic binding to be for a map: %s",
+            binding);
+        return Snippet.format(
+            "%s.create(%s)",
+            ClassName.fromClass(MapFactory.class),
+            getMemberSelectSnippet(getOnlyElement(binding.dependencies()).bindingKey()));
 
       default:
         throw new AssertionError();
@@ -1097,29 +1100,18 @@ private TypeMirror typeMirrorAsMemberOf(TypeElement bindingTypeElement, Element
     }
   }
 
-  private Snippet initializeMapBinding(Set<ContributionBinding> bindings) {
-    // Get type information from the first binding.
-    ContributionBinding firstBinding = bindings.iterator().next();
-    MapType mapType = MapType.from(asDeclared(firstBinding.key().type()));
-
-    if (!mapType.valuesAreTypeOf(Provider.class)) {
-      return Snippet.format(
-          "%s.create(%s)",
-          ClassName.fromClass(MapFactory.class),
-          getMemberSelectSnippet(getOnlyElement(firstBinding.dependencies()).bindingKey()));
-    }
-
-    ImmutableList.Builder<dagger.internal.codegen.writer.Snippet> snippets =
-        ImmutableList.builder();
+  private Snippet initializeMapBinding(ResolvedBindings resolvedBindings) {
+    MapType mapType = MapType.from(resolvedBindings.bindingKey().key().type());
+    ImmutableList.Builder<Snippet> snippets = ImmutableList.builder();
     snippets.add(
         Snippet.format(
             "%s.<%s, %s>builder(%d)",
             ClassName.fromClass(MapProviderFactory.class),
             TypeNames.forTypeMirror(mapType.keyType()),
             TypeNames.forTypeMirror(mapType.unwrappedValueType(Provider.class)),
-            bindings.size()));
+            resolvedBindings.contributionBindings().size()));
 
-    for (ContributionBinding binding : bindings) {
+    for (ContributionBinding binding : resolvedBindings.contributionBindings()) {
       snippets.add(
           Snippet.format(
               "    .put(%s, %s)",
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
index c318228a2..b65f9f153 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
@@ -310,16 +310,12 @@ private BindingGraph create(
        * <li>All explicit bindings for the requested key.
        * <li>All explicit bindings for {@code Set<T>} if the requested key's type is
        *     {@code Set<Produced<T>>}.
-       * <li>All explicit bindings for {@code Map<K, Producer<V>>} or {@code Map<K, Provider<V>>} if
-       *     the requested key's type is {@code Map<K, V>} and there are some explicit bindings
-       *     for the requested key.
        * <li>A synthetic binding that depends on {@code Map<K, Producer<V>>} if the requested key's
        *     type is {@code Map<K, V>} and there are some explicit bindings for
-       *     {@code Map<K, Producer<V>>} but no explicit bindings for the requested key.
+       *     {@code Map<K, Producer<V>>}.
        * <li>A synthetic binding that depends on {@code Map<K, Provider<V>>} if the requested key's
        *     type is {@code Map<K, V>} and there are some explicit bindings for
-       *     {@code Map<K, Provider<V>>} but no explicit bindings for the requested key or for
-       *     {@code Map<K, Producer<V>>}.
+       *     {@code Map<K, Provider<V>>} but no explicit bindings for {@code Map<K, Producer<V>>}.
        * <li>An implicit {@link Inject @Inject}-annotated constructor binding if there is one and
        *     there are no explicit bindings or synthetic bindings.
        * </ul>
@@ -331,15 +327,13 @@ ResolvedBindings lookUpBindings(DependencyRequest request) {
         BindingKey bindingKey = request.bindingKey();
         switch (bindingKey.kind()) {
           case CONTRIBUTION:
-            ImmutableSet<ContributionBinding> explicitBindingsForKey =
-                new ImmutableSet.Builder<ContributionBinding>()
-                    // Add for explicit keys (those from modules and components).
-                    .addAll(getExplicitBindings(bindingKey.key()))
-                    // If the key is Set<Produced<T>>, then add bindings for Set<T>.
-                    .addAll(
-                        getExplicitBindings(
-                            keyFactory.implicitSetKeyFromProduced(bindingKey.key())))
-                    .build();
+            ImmutableSet.Builder<ContributionBinding> explicitBindingsBuilder =
+                ImmutableSet.builder();
+            // Add explicit bindings (those from modules and components).
+            explicitBindingsBuilder.addAll(getExplicitBindings(bindingKey.key()));
+            // If the key is Set<Produced<T>>, then add explicit bindings for Set<T>.
+            explicitBindingsBuilder.addAll(
+                getExplicitBindings(keyFactory.implicitSetKeyFromProduced(bindingKey.key())));
 
             // If the key is Map<K, V>, get its implicit binding keys, which are either
             // Map<K, Provider<V>> or Map<K, Producer<V>>, and grab their explicit bindings.
@@ -348,33 +342,31 @@ ResolvedBindings lookUpBindings(DependencyRequest request) {
             ImmutableSet<ContributionBinding> explicitProducerMapBindings =
                 getExplicitBindings(keyFactory.implicitMapProducerKeyFrom(bindingKey.key()));
 
-            final Set<? extends ContributionBinding> resolvedContributionBindings;
-            if (!explicitBindingsForKey.isEmpty()) {
-              /* If there are any explicit bindings for this key, then combine those with any
-               * conflicting Map<K, Provider<V>> bindings and let the validator fail. */
-              resolvedContributionBindings =
-                  new ImmutableSet.Builder<ContributionBinding>()
-                      .addAll(explicitBindingsForKey)
-                      .addAll(explicitProviderMapBindings)
-                      .addAll(explicitProducerMapBindings)
-                      .build();
-            } else if (!explicitProducerMapBindings.isEmpty()) {
-              /* If this binding is for Map<K, V> and there are no explicit Map<K, V> bindings but
-               * some explicit Map<K, Producer<V>> bindings, then this binding must have only the
-               * implicit dependency on Map<K, Producer<V>>. */
-              resolvedContributionBindings =
-                  ImmutableSet.of(productionBindingFactory.implicitMapOfProducerBinding(request));
+            if (!explicitProducerMapBindings.isEmpty()) {
+              /* If the binding key is Map<K, V>, and there are some explicit Map<K, Producer<V>>
+               * bindings, then add the synthetic binding that depends on Map<K, Producer<V>>. */
+              explicitBindingsBuilder.add(
+                  productionBindingFactory.implicitMapOfProducerBinding(request));
             } else if (!explicitProviderMapBindings.isEmpty()) {
-              /* If this binding is for Map<K, V> and there are no explicit Map<K, V> bindings but
-               * some explicit Map<K, Provider<V>> bindings, then this binding must have only the
-               * implicit dependency on Map<K, Provider<V>>. */
-              resolvedContributionBindings =
-                  ImmutableSet.of(provisionBindingFactory.implicitMapOfProviderBinding(request));
-            } else {
-              /* If there are no explicit bindings at all, look for an implicit @Inject-constructed
-               * binding. */
+              /* If the binding key is Map<K, V>, and there are some explicit Map<K, Provider<V>>
+               * bindings but no explicit Map<K, Producer<V>> bindings, then add the synthetic
+               * binding that depends on Map<K, Provider<V>>. */
+              explicitBindingsBuilder.add(
+                  provisionBindingFactory.implicitMapOfProviderBinding(request));
+            }
+
+            ImmutableSet<ContributionBinding> explicitBindings = explicitBindingsBuilder.build();
+
+            final Set<? extends ContributionBinding> resolvedContributionBindings;
+            if (explicitBindings.isEmpty()) {
+              /* If there are no explicit or synthetic bindings, use an implicit @Inject-
+               * constructed binding if there is one. */
               resolvedContributionBindings =
                   injectBindingRegistry.getOrFindProvisionBinding(bindingKey.key()).asSet();
+            } else {
+              /* Otherwise there is at least one binding. If the graph is invalid, the validator
+               * will report that. */
+              resolvedContributionBindings = explicitBindings;
             }
             return ResolvedBindings.forContributionBindings(
                 bindingKey,
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
index 9af08b1a4..153b175f1 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -33,6 +33,7 @@
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Maps;
 import com.google.common.collect.Multimap;
+import com.google.common.collect.Multimaps;
 import com.google.common.collect.Ordering;
 import com.google.common.collect.Sets;
 import dagger.Component;
@@ -51,6 +52,7 @@
 import java.util.Iterator;
 import java.util.LinkedHashSet;
 import java.util.Map;
+import java.util.Queue;
 import java.util.Set;
 import javax.inject.Provider;
 import javax.lang.model.element.AnnotationMirror;
@@ -83,6 +85,7 @@
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
 import static dagger.internal.codegen.ContributionBinding.indexMapBindingsByAnnotationType;
 import static dagger.internal.codegen.ContributionBinding.indexMapBindingsByMapKey;
+import static dagger.internal.codegen.ContributionBinding.Kind.SYNTHETIC_MAP;
 import static dagger.internal.codegen.ErrorMessages.DUPLICATE_SIZE_LIMIT;
 import static dagger.internal.codegen.ErrorMessages.INDENT;
 import static dagger.internal.codegen.ErrorMessages.MEMBERS_INJECTION_WITH_UNBOUNDED_TYPE;
@@ -299,7 +302,7 @@ private boolean validateResolvedBinding(
             return true;
           }
           ImmutableListMultimap<ContributionType, ContributionBinding> contributionsByType =
-              resolvedBinding.contributionTypes();
+              contributionBindingsByType(resolvedBinding);
           if (contributionsByType.keySet().size() > 1) {
             reportMultipleBindingTypes(path);
             return false;
@@ -336,6 +339,58 @@ private boolean validateResolvedBinding(
       return true;
     }
 
+    /**
+     * Returns an object that contains all the same bindings as {@code resolvedBindings}, except
+     * that any {@link #SYNTHETIC_MAP} {@link ContributionBinding}s are replaced by the contribution
+     * bindings of their dependencies.
+     *
+     * <p>For example, if:
+     *
+     * <ul>
+     * <li>The bindings for {@code key1} are {@code A} and {@code B}.
+     * <li>{@code B} is a synthetic binding with a dependency on {@code key2}.
+     * <li>The bindings for {@code key2} are {@code C} and {@code D}.
+     * </ul>
+     *
+     * then {@code inlineSyntheticBindings(bindingsForKey1)} has bindings {@code A}, {@code C}, and
+     * {@code D}.
+     *
+     * <p>The replacement is repeated until none of the bindings are synthetic.
+     */
+    private ImmutableSet<ContributionBinding> inlineSyntheticContributions(
+        ResolvedBindings resolvedBinding) {
+      if (!Iterables.any(
+          resolvedBinding.contributionBindings(), ContributionBinding.isOfKind(SYNTHETIC_MAP))) {
+        return resolvedBinding.contributionBindings();
+      }
+
+      ImmutableSet.Builder<ContributionBinding> inlinedBindings = ImmutableSet.builder();
+
+      Queue<ContributionBinding> bindings =
+          new ArrayDeque<>(resolvedBinding.contributionBindings());
+
+      for (ContributionBinding binding = bindings.poll();
+          binding != null;
+          binding = bindings.poll()) {
+        if (binding.bindingKind().equals(SYNTHETIC_MAP)) {
+          BindingKey syntheticBindingDependency =
+              Iterables.getOnlyElement(binding.dependencies()).bindingKey();
+          ResolvedBindings syntheticBindingDependencyBindings =
+              subject.resolvedBindings().get(syntheticBindingDependency);
+          bindings.addAll(syntheticBindingDependencyBindings.contributionBindings());
+        } else {
+          inlinedBindings.add(binding);
+        }
+      }
+      return inlinedBindings.build();
+    }
+
+    private ImmutableListMultimap<ContributionType, ContributionBinding> contributionBindingsByType(
+        ResolvedBindings resolvedBinding) {
+      return Multimaps.index(
+          inlineSyntheticContributions(resolvedBinding), ContributionBinding.CONTRIBUTION_TYPE);
+    }
+
     /** Ensures that if the request isn't nullable, then each contribution is also not nullable. */
     private boolean validateNullability(
         DependencyRequest request, Set<ContributionBinding> bindings) {
@@ -822,18 +877,18 @@ private void reportDuplicateBindings(Deque<ResolvedRequest> path) {
       StringBuilder builder = new StringBuilder();
       new Formatter(builder)
           .format(ErrorMessages.DUPLICATE_BINDINGS_FOR_KEY_FORMAT, formatRootRequestKey(path));
-      appendBindings(builder, resolvedBinding.contributionBindings(), 1);
+      appendBindings(builder, inlineSyntheticContributions(resolvedBinding), 1);
       reportBuilder.addError(builder.toString(), path.getLast().request().requestElement());
     }
 
     @SuppressWarnings("resource") // Appendable is a StringBuilder.
     private void reportMultipleBindingTypes(Deque<ResolvedRequest> path) {
-      ResolvedBindings resolvedBinding = path.peek().binding();
       StringBuilder builder = new StringBuilder();
       new Formatter(builder)
           .format(ErrorMessages.MULTIPLE_BINDING_TYPES_FOR_KEY_FORMAT, formatRootRequestKey(path));
+      ResolvedBindings resolvedBinding = path.peek().binding();
       ImmutableListMultimap<ContributionType, ContributionBinding> bindingsByType =
-          resolvedBinding.contributionTypes();
+          contributionBindingsByType(resolvedBinding);
       for (ContributionType type :
           Ordering.natural().immutableSortedCopy(bindingsByType.keySet())) {
         builder.append(INDENT);
diff --git a/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
index f5c6f4ce9..d6be50c37 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
@@ -49,7 +49,7 @@
  * @since 2.0
  */
 abstract class ContributionBinding extends Binding {
-  
+
   @Override
   Set<DependencyRequest> implicitDependencies() {
     // Optimization: If we don't need the memberInjectionRequest, don't create more objects.
@@ -88,6 +88,14 @@ ContributionType contributionType() {
     }
   }
   
+  static final Function<ContributionBinding, ContributionType> CONTRIBUTION_TYPE =
+      new Function<ContributionBinding, ContributionType>() {
+        @Override
+        public ContributionType apply(ContributionBinding binding) {
+          return binding.contributionType();
+        }
+      };
+  
   /** Returns the type that specifies this' nullability, absent if not nullable. */
   abstract Optional<DeclaredType> nullableType();
 
@@ -104,7 +112,7 @@ ContributionType contributionType() {
    * implicitly by the framework.
    */
   boolean isSyntheticBinding() {
-    return bindingKind().equals(Kind.SYNTHETIC);
+    return bindingKind().equals(Kind.SYNTHETIC_MAP);
   }
 
   /** If this provision requires members injection, this will be the corresponding request. */
@@ -116,10 +124,10 @@ boolean isSyntheticBinding() {
    */
   enum Kind {
     /**
-     * A binding that is not explicitly tied to an element, but generated implicitly by the
-     * framework.
+     * The synthetic binding for {@code Map<K, V>} that depends on either
+     * {@code Map<K, Provider<V>>} or {@code Map<K, Producer<V>>}.
      */
-    SYNTHETIC,
+    SYNTHETIC_MAP,
 
     // Provision kinds
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
index d1579c3fe..453215667 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
@@ -109,7 +109,7 @@
 
   abstract Kind kind();
   abstract Key key();
-
+  
   BindingKey bindingKey() {
     switch (kind()) {
       case INSTANCE:
@@ -363,6 +363,11 @@ public KindAndType visitError(ErrorType errorType, Void p) {
               throw new TypeNotPresentException(errorType.toString(), null);
             }
 
+            @Override
+            public KindAndType visitExecutable(ExecutableType executableType, Void p) {
+              return executableType.getReturnType().accept(this, null);
+            }
+
             @Override
             public KindAndType visitDeclared(DeclaredType declaredType, Void p) {
               for (Kind kind : Kind.values()) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java b/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java
index 3f4605401..13ed223bc 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java
@@ -18,7 +18,7 @@
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
 import com.google.common.base.CaseFormat;
-import dagger.MembersInjector;
+import dagger.internal.codegen.ContributionBinding.ContributionType;
 import dagger.internal.codegen.writer.ClassName;
 import dagger.internal.codegen.writer.ParameterizedTypeName;
 import dagger.internal.codegen.writer.TypeNames;
@@ -78,40 +78,22 @@ static FrameworkField createForSyntheticContributionBinding(
   }
 
   static FrameworkField createForResolvedBindings(ResolvedBindings resolvedBindings) {
+    return createWithTypeFromKey(
+        resolvedBindings.frameworkClass(),
+        resolvedBindings.bindingKey().key(),
+        frameworkFieldName(resolvedBindings));
+  }
+
+  private static String frameworkFieldName(ResolvedBindings resolvedBindings) {
     BindingKey bindingKey = resolvedBindings.bindingKey();
-    switch (bindingKey.kind()) {
-      case CONTRIBUTION:
-        switch (resolvedBindings.contributionType()) {
-          case SET:
-          case MAP:
-            return createWithTypeFromKey(
-                resolvedBindings.frameworkClass(),
-                bindingKey.key(),
-                KeyVariableNamer.INSTANCE.apply(bindingKey.key()));
-          case UNIQUE:
-            ContributionBinding binding = getOnlyElement(resolvedBindings.contributionBindings());
-            return createWithTypeFromKey(
-                resolvedBindings.frameworkClass(),
-                bindingKey.key(),
-                BINDING_ELEMENT_NAME.visit(binding.bindingElement()));
-          default:
-            throw new AssertionError();
-        }
-      case MEMBERS_INJECTION:
-        return createWithTypeFromKey(
-            MembersInjector.class,
-            bindingKey.key(),
-            CaseFormat.UPPER_CAMEL.to(
-                CaseFormat.LOWER_CAMEL,
-                resolvedBindings
-                    .membersInjectionBinding()
-                    .get()
-                    .bindingElement()
-                    .getSimpleName()
-                    .toString()));
-      default:
-        throw new AssertionError();
+    if (bindingKey.kind().equals(BindingKey.Kind.CONTRIBUTION)
+        && resolvedBindings.contributionType().equals(ContributionType.UNIQUE)) {
+      ContributionBinding binding = getOnlyElement(resolvedBindings.contributionBindings());
+      if (!binding.bindingKind().equals(ContributionBinding.Kind.SYNTHETIC_MAP)) {
+        return BINDING_ELEMENT_NAME.visit(binding.bindingElement());
+      }
     }
+    return KeyVariableNamer.INSTANCE.apply(bindingKey.key());
   }
 
   private static final ElementVisitor<String, Void> BINDING_ELEMENT_NAME =
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
index 1666fbf8c..133be5ba8 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
@@ -157,8 +157,8 @@ ProductionBinding implicitMapOfProducerBinding(DependencyRequest mapOfValueReque
           Optional.<DeclaredType>absent(),
           Optional.<TypeElement>absent(),
           Optional.<DependencyRequest>absent(),
-          Kind.SYNTHETIC,
-          Produces.Type.MAP,
+          Kind.SYNTHETIC_MAP,
+          Produces.Type.UNIQUE,
           ImmutableList.<TypeMirror>of(),
           Optional.<DependencyRequest>absent());
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
index b2ac74fb3..2582b31fd 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
@@ -184,7 +184,7 @@ ProvisionBinding forProvidesMethod(ExecutableElement providesMethod, TypeMirror
           providesAnnotation.type(),
           scope);
     }
-
+    
     ProvisionBinding implicitMapOfProviderBinding(DependencyRequest mapOfValueRequest) {
       checkNotNull(mapOfValueRequest);
       Optional<Key> implicitMapOfProviderKey =
@@ -205,8 +205,8 @@ ProvisionBinding implicitMapOfProviderBinding(DependencyRequest mapOfValueReques
           Optional.<DeclaredType>absent(),
           Optional.<TypeElement>absent(),
           Optional.<DependencyRequest>absent(),
-          Kind.SYNTHETIC,
-          Provides.Type.MAP,
+          Kind.SYNTHETIC_MAP,
+          Provides.Type.UNIQUE,
           scopeOf(implicitMapOfProviderRequest.requestElement()));
     }
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java b/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
index a0b7f9208..f8b6aec87 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
@@ -18,13 +18,11 @@
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Optional;
 import com.google.common.collect.FluentIterable;
-import com.google.common.collect.ImmutableListMultimap;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ImmutableSetMultimap;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Multimap;
-import com.google.common.collect.Ordering;
 import dagger.MembersInjector;
 import dagger.internal.codegen.ContributionBinding.ContributionType;
 import java.util.EnumSet;
@@ -233,19 +231,6 @@ ContributionType contributionType() {
     return Iterables.getOnlyElement(types);
   }
 
-  /**
-   * The {@link #contributionBindings()}, indexed by {@link ContributionType}.
-   */
-  ImmutableListMultimap<ContributionType, ContributionBinding> contributionTypes() {
-    ImmutableListMultimap.Builder<ContributionType, ContributionBinding> builder =
-        ImmutableListMultimap.builder();
-    builder.orderKeysBy(Ordering.<ContributionType>natural());
-    for (ContributionBinding binding : contributionBindings()) {
-      builder.put(binding.contributionType(), binding);
-    }
-    return builder.build();
-  }
-
   /**
    * The name of the package in which these bindings must be managed, for
    * example if a binding references non-public types.
