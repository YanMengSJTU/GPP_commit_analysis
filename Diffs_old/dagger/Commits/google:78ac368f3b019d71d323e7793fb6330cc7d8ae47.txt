diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildComponentRequiringModules.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildComponentRequiringModules.java
new file mode 100644
index 000000000..905c68990
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildComponentRequiringModules.java
@@ -0,0 +1,26 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.subcomponent;
+
+import dagger.Subcomponent;
+
+@Subcomponent(modules = {
+    ChildModule.class,
+    ChildModuleWithParameters.class,
+    ChildModuleWithState.class})
+interface ChildComponentRequiringModules {
+  int getInt();
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildModuleWithParameters.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildModuleWithParameters.java
new file mode 100644
index 000000000..e18b4a6da
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildModuleWithParameters.java
@@ -0,0 +1,26 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.subcomponent;
+
+import dagger.Module;
+
+/**
+ * This is a module that can't be constructed with a default constructor.
+ */
+@Module
+final class ChildModuleWithParameters {
+  public ChildModuleWithParameters(@SuppressWarnings("unused") Object whatever) {}
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildModuleWithState.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildModuleWithState.java
new file mode 100644
index 000000000..5908a005b
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildModuleWithState.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.subcomponent;
+
+import dagger.Module;
+import dagger.Provides;
+
+/**
+ * This is a module that can be constructed with a default constructor, but has state, so callers
+ * might want to pass a reference anyway.
+ */
+@Module
+final class ChildModuleWithState {
+  private int i = 0;
+
+  @Provides int provideInt() {
+    return i++;
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentComponent.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentComponent.java
index ed4e6f0e8..babf3ea34 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentComponent.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentComponent.java
@@ -28,4 +28,8 @@
   Set<Object> objectSet();
 
   ChildComponent newChildComponent();
+
+  ChildComponentRequiringModules newChildComponentRequiringModules(
+      ChildModuleWithParameters cmwp,
+      ChildModuleWithState childModuleWithState);
 }
diff --git a/compiler/src/it/functional-tests/src/test/java/test/subcomponent/SubcomponentScopeTest.java b/compiler/src/it/functional-tests/src/test/java/test/subcomponent/SubcomponentTest.java
similarity index 81%
rename from compiler/src/it/functional-tests/src/test/java/test/subcomponent/SubcomponentScopeTest.java
rename to compiler/src/it/functional-tests/src/test/java/test/subcomponent/SubcomponentTest.java
index 4e897ff72..69fff735e 100644
--- a/compiler/src/it/functional-tests/src/test/java/test/subcomponent/SubcomponentScopeTest.java
+++ b/compiler/src/it/functional-tests/src/test/java/test/subcomponent/SubcomponentTest.java
@@ -24,7 +24,7 @@
 import static com.google.common.truth.Truth.assertThat;
 
 @RunWith(JUnit4.class)
-public class SubcomponentScopeTest {
+public class SubcomponentTest {
   @Test
   public void scopePropagatesUpward_class() {
     ParentComponent parentComponent = Dagger_ParentComponent.create();
@@ -73,4 +73,20 @@ public void unscopedProviders() {
             .newGrandchildComponent()
             .getUnscopedTypeProvider());
   }
+
+  @Test
+  public void passedModules() {
+    ParentComponent parentComponent = Dagger_ParentComponent.create();
+    ChildModuleWithState childModuleWithState = new ChildModuleWithState();
+    ChildComponentRequiringModules childComponent1 =
+        parentComponent.newChildComponentRequiringModules(
+            new ChildModuleWithParameters(new Object()),
+            childModuleWithState);
+    ChildComponentRequiringModules childComponent2 =
+        parentComponent.newChildComponentRequiringModules(
+            new ChildModuleWithParameters(new Object()),
+            childModuleWithState);
+    assertThat(childComponent1.getInt()).isEqualTo(0);
+    assertThat(childComponent2.getInt()).isEqualTo(1);
+  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
index c2f8adf06..a2926cc22 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
@@ -55,6 +55,7 @@
 import static dagger.internal.codegen.ConfigurationAnnotations.getTransitiveModules;
 import static dagger.internal.codegen.MembersInjectionBinding.Strategy.DELEGATE;
 import static dagger.internal.codegen.MembersInjectionBinding.Strategy.NO_OP;
+import static dagger.internal.codegen.Util.componentCanMakeNewInstances;
 import static javax.lang.model.util.ElementFilter.methodsIn;
 
 /**
@@ -64,9 +65,14 @@
  */
 @AutoValue
 abstract class BindingGraph {
+  enum ModuleStrategy {
+    PASSED,
+    CONSTRUCTED,
+  }
+
   abstract ComponentDescriptor componentDescriptor();
   abstract ImmutableSet<DependencyRequest> entryPoints();
-  abstract ImmutableMap<TypeElement, ImmutableSet<TypeElement>> transitiveModules();
+  abstract ImmutableMap<TypeElement, ModuleStrategy> transitiveModules();
   abstract ImmutableMap<BindingKey, ResolvedBindings> resolvedBindings();
   abstract ImmutableMap<ExecutableElement, BindingGraph> subgraphs();
 
@@ -191,9 +197,13 @@ private BindingGraph create(Optional<RequestResolver> parentResolver,
       ImmutableSet<TypeElement> moduleTypes =
           MoreTypes.asTypeElements(getComponentModules(componentAnnotation));
 
-      ImmutableMap<TypeElement, ImmutableSet<TypeElement>> transitiveModules =
-          getTransitiveModules(types, elements, moduleTypes);
-      for (TypeElement module : transitiveModules.keySet()) {
+      ImmutableMap.Builder<TypeElement, ModuleStrategy> transitiveModules = ImmutableMap.builder();
+      for (TypeElement module : getTransitiveModules(types, elements, moduleTypes)) {
+        transitiveModules.put(module,
+            (componentCanMakeNewInstances(module) && module.getTypeParameters().isEmpty())
+                ? ModuleStrategy.CONSTRUCTED
+                : ModuleStrategy.PASSED);
+
         // traverse the modules, collect the bindings
         List<ExecutableElement> moduleMethods = methodsIn(elements.getAllMembers(module));
         for (ExecutableElement moduleMethod : moduleMethods) {
@@ -233,8 +243,8 @@ private BindingGraph create(Optional<RequestResolver> parentResolver,
       return new AutoValue_BindingGraph(
           componentDescriptor,
           componentMethodRequests,
-          transitiveModules,
-          ImmutableMap.copyOf(requestResolver.resolvedBindings),
+          transitiveModules.build(),
+          requestResolver.getResolvedBindings(),
           subgraphsBuilder.build());
     }
 
@@ -483,6 +493,29 @@ void resolve(DependencyRequest request) {
           cycleStack.pop();
         }
       }
+
+      ImmutableMap<BindingKey, ResolvedBindings> getResolvedBindings() {
+        ImmutableMap.Builder<BindingKey, ResolvedBindings> resolvedBindingsBuilder =
+            ImmutableMap.builder();
+        resolvedBindingsBuilder.putAll(resolvedBindings);
+        if (parentResolver.isPresent()) {
+          for (ResolvedBindings resolvedInParent :
+            parentResolver.get().getResolvedBindings().values()) {
+            BindingKey bindingKey = resolvedInParent.bindingKey();
+            if (!resolvedBindings.containsKey(bindingKey)) {
+              if (resolvedInParent.ownedBindings().isEmpty()) {
+                // reuse the instance if we can get away with it
+                resolvedBindingsBuilder.put(bindingKey, resolvedInParent);
+              } else {
+                resolvedBindingsBuilder.put(bindingKey,
+                    ResolvedBindings.create(
+                        bindingKey, ImmutableSet.<Binding>of(), resolvedInParent.bindings()));
+              }
+            }
+          }
+        }
+        return resolvedBindingsBuilder.build();
+      }
     }
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
index 7f9263a68..8e3022e2b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -43,6 +43,7 @@
 import java.util.Formatter;
 import java.util.HashSet;
 import java.util.Iterator;
+import java.util.Map.Entry;
 import java.util.Set;
 import javax.inject.Singleton;
 import javax.lang.model.element.AnnotationMirror;
@@ -107,6 +108,11 @@
   public ValidationReport<BindingGraph> validate(final BindingGraph subject) {
     final ValidationReport.Builder<BindingGraph> reportBuilder =
         ValidationReport.Builder.about(subject);
+    return validate(subject, reportBuilder);
+  }
+
+  private ValidationReport<BindingGraph> validate(final BindingGraph subject,
+      final ValidationReport.Builder<BindingGraph> reportBuilder) {
     ImmutableMap<BindingKey, ResolvedBindings> resolvedBindings = subject.resolvedBindings();
 
     validateComponentScope(subject, reportBuilder, resolvedBindings);
@@ -137,9 +143,18 @@ boolean visitResolvedRequest(Deque<ResolvedRequest> path) {
       });
     }
 
+    validateSubcomponents(subject, reportBuilder);
+
     return reportBuilder.build();
   }
 
+  private void validateSubcomponents(BindingGraph graph,
+      ValidationReport.Builder<BindingGraph> reportBuilder) {
+    for (Entry<ExecutableElement, BindingGraph> subgraphEntry : graph.subgraphs().entrySet()) {
+      validate(subgraphEntry.getValue(), reportBuilder);
+    }
+  }
+
   /**
    * Validates that the set of bindings resolved is consistent with the type of the binding, and
    * returns true if the bindings are valid.
@@ -502,7 +517,7 @@ void validateComponentScope(final BindingGraph subject,
     ImmutableSet.Builder<String> incompatiblyScopedMethodsBuilder = ImmutableSet.builder();
     for (ResolvedBindings bindings : resolvedBindings.values()) {
       if (bindings.bindingKey().kind().equals(BindingKey.Kind.CONTRIBUTION)) {
-        for (ContributionBinding contributionBinding : bindings.contributionBindings()) {
+        for (ContributionBinding contributionBinding : bindings.ownedContributionBindings()) {
           if (contributionBinding instanceof ProvisionBinding) {
             ProvisionBinding provisionBinding = (ProvisionBinding) contributionBinding;
             if (provisionBinding.scope().isPresent()
@@ -576,16 +591,13 @@ private void reportMissingBinding(
     boolean requiresContributionMethod = !key.isValidImplicitProvisionKey(types);
     boolean requiresProvision = doesPathRequireProvisionOnly(path);
     StringBuilder errorMessage = new StringBuilder();
-    final String requiresErrorMessageFormat;
-    if (requiresContributionMethod) {
-      requiresErrorMessageFormat = requiresProvision
-          ? REQUIRES_PROVIDER_FORMAT
-          : REQUIRES_PROVIDER_OR_PRODUCER_FORMAT;
-    } else {
-      requiresErrorMessageFormat = requiresProvision
-          ? REQUIRES_AT_INJECT_CONSTRUCTOR_OR_PROVIDER_FORMAT
-          : REQUIRES_AT_INJECT_CONSTRUCTOR_OR_PROVIDER_OR_PRODUCER_FORMAT;
-    }
+    String requiresErrorMessageFormat = requiresContributionMethod
+        ? requiresProvision
+            ? REQUIRES_PROVIDER_FORMAT
+            : REQUIRES_PROVIDER_OR_PRODUCER_FORMAT
+        : requiresProvision
+            ? REQUIRES_AT_INJECT_CONSTRUCTOR_OR_PROVIDER_FORMAT
+            : REQUIRES_AT_INJECT_CONSTRUCTOR_OR_PROVIDER_OR_PRODUCER_FORMAT;
     errorMessage.append(String.format(requiresErrorMessageFormat, typeName));
     if (key.isValidMembersInjectionKey()
         && !injectBindingRegistry.getOrFindMembersInjectionBinding(key).injectionSites()
@@ -750,8 +762,13 @@ private void reportCycle(Deque<ResolvedRequest> path,
     abstract ResolvedBindings binding();
 
     static ResolvedRequest create(DependencyRequest request, BindingGraph graph) {
-      return new AutoValue_BindingGraphValidator_ResolvedRequest(
-          request, graph.resolvedBindings().get(request.bindingKey()));
+      BindingKey bindingKey = request.bindingKey();
+      ResolvedBindings resolvedBindings = graph.resolvedBindings().get(bindingKey);
+      return new AutoValue_BindingGraphValidator_ResolvedRequest(request,
+          resolvedBindings == null
+              ? ResolvedBindings.create(bindingKey,
+                  ImmutableSet.<Binding>of(), ImmutableSet.<Binding>of())
+              : resolvedBindings);
     }
   }
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
index 678b72c93..72540b0bf 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
@@ -33,6 +33,7 @@
 import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
 import com.google.common.collect.Sets;
+import com.google.common.collect.Sets.SetView;
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.Component;
 import dagger.MapKey;
@@ -89,6 +90,7 @@
 
 import static com.google.auto.common.MoreTypes.asDeclared;
 import static com.google.common.base.CaseFormat.LOWER_CAMEL;
+import static com.google.common.base.Verify.verify;
 import static dagger.internal.codegen.Binding.bindingPackageFor;
 import static dagger.internal.codegen.ConfigurationAnnotations.getMapKeys;
 import static dagger.internal.codegen.ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD;
@@ -99,13 +101,11 @@
 import static dagger.internal.codegen.SourceFiles.factoryNameForProvisionBinding;
 import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
 import static dagger.internal.codegen.SourceFiles.membersInjectorNameForMembersInjectionBinding;
-import static javax.lang.model.element.ElementKind.CONSTRUCTOR;
+import static dagger.internal.codegen.Util.componentCanMakeNewInstances;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.PUBLIC;
 import static javax.lang.model.element.Modifier.STATIC;
-import static javax.lang.model.element.NestingKind.MEMBER;
-import static javax.lang.model.element.NestingKind.TOP_LEVEL;
 import static javax.lang.model.type.TypeKind.VOID;
 
 /**
@@ -272,7 +272,7 @@ Snippet getSnippetFor(ClassName usingClass) {
           .addSnippet("}")
           .addSnippet("this.%s = %s;", builderField.name(), contributionName)
           .addSnippet("return this;");
-      if (hasNoArgsConstructor(contributionElement)) {
+      if (componentCanMakeNewInstances(contributionElement)) {
         buildMethod.body()
             .addSnippet("if (%s == null) {", builderField.name())
             .addSnippet("  this.%s = new %s();",
@@ -329,88 +329,99 @@ Snippet getSnippetFor(ClassName usingClass) {
 
     writeInterfaceMethods(input, componentWriter, memberSelectSnippets, enumBindingKeys);
 
-    writeSubcomponents(input,
-        componentWriter,
-        proxyWriters,
-        componentContributionFields,
-        memberSelectSnippets,
-        multibindingContributionSnippets);
+    for (Entry<ExecutableElement, BindingGraph> subgraphEntry : input.subgraphs().entrySet()) {
+      writeSubcomponent(componentWriter,
+          proxyWriters,
+          componentContributionFields,
+          memberSelectSnippets,
+          multibindingContributionSnippets,
+          subgraphEntry.getKey(),
+          subgraphEntry.getValue());
+    }
 
     return memberSelectSnippets;
   }
 
-  private void writeSubcomponents(BindingGraph input,
-      ClassWriter componentWriter,
+  private void writeSubcomponent(ClassWriter componentWriter,
       Set<JavaWriter> proxyWriters,
-      Map<TypeElement, MemberSelect> componentContributionFields,
+      Map<TypeElement, MemberSelect> parentContributionFields,
       ImmutableMap<BindingKey, MemberSelect> parentMemberSelectSnippets,
-      ImmutableMap<ContributionBinding, Snippet> multibindingContributionSnippets) {
-    for (Entry<ExecutableElement, BindingGraph> subgraphEntry : input.subgraphs().entrySet()) {
-      TypeName componentType =
-          TypeNames.forTypeMirror(subgraphEntry.getKey().getReturnType());
-
-      ClassWriter subcomponentWriter = componentWriter.addNestedClass(
-          subgraphEntry.getValue().componentDescriptor().componentDefinitionType().getSimpleName()
-              + "Impl");
+      ImmutableMap<ContributionBinding, Snippet> parentMultibindingContributionSnippets,
+      ExecutableElement subcomponentFactoryMethod,
+      BindingGraph subgraph) {
+    TypeName subcomponentType =
+        TypeNames.forTypeMirror(subcomponentFactoryMethod.getReturnType());
 
-      subcomponentWriter.addModifiers(PRIVATE, FINAL);
-      subcomponentWriter.addImplementedType(componentType);
+    ClassWriter subcomponentWriter = componentWriter.addNestedClass(
+        subgraph.componentDescriptor().componentDefinitionType().getSimpleName()
+            + "Impl");
 
-      writeSubcomponent(subgraphEntry.getValue(),
-          subcomponentWriter,
-          proxyWriters,
-          ImmutableMap.copyOf(componentContributionFields),
-          multibindingContributionSnippets,
-          parentMemberSelectSnippets);
-
-      MethodWriter componentMethod = componentWriter.addMethod(componentType,
-          subgraphEntry.getKey().getSimpleName().toString());
-      componentMethod.addModifiers(PUBLIC);
-      componentMethod.annotate(Override.class);
-      // TODO(gak): need to pipe through the method params
-      componentMethod.body().addSnippet("return new %s();",
-          subcomponentWriter.name());
-    }
-  }
+    subcomponentWriter.addModifiers(PRIVATE, FINAL);
+    subcomponentWriter.addImplementedType(subcomponentType);
 
-  private ImmutableMap<BindingKey, MemberSelect> writeSubcomponent(
-      BindingGraph input, ClassWriter componentWriter,
-      Set<JavaWriter> proxyWriters,
-      ImmutableMap<TypeElement, MemberSelect> parentContributionFields,
-      ImmutableMap<ContributionBinding, Snippet> parentMultibindingContributionSnippets,
-      ImmutableMap<BindingKey, MemberSelect> parentMemberSelectSnippets) {
-    // the full set of types that calling code uses to construct a component instance
-    ImmutableMap<TypeElement, String> componentContributionNames =
-        ImmutableMap.copyOf(Maps.asMap(
-            Sets.union(
-                input.transitiveModules().keySet(),
-                input.componentDescriptor().dependencies()),
-            new Function<TypeElement, String>() {
-              @Override public String apply(TypeElement input) {
-                return CaseFormat.UPPER_CAMEL.to(LOWER_CAMEL, input.getSimpleName().toString());
-              }
-            }));
+    MethodWriter componentMethod = componentWriter.addMethod(subcomponentType,
+        subcomponentFactoryMethod.getSimpleName().toString());
+    componentMethod.addModifiers(PUBLIC);
+    componentMethod.annotate(Override.class);
 
-    ConstructorWriter constructorWriter = componentWriter.addConstructor();
+    ConstructorWriter constructorWriter = subcomponentWriter.addConstructor();
     constructorWriter.addModifiers(PRIVATE);
+    constructorWriter.body();
 
     Map<TypeElement, MemberSelect> componentContributionFields =
         Maps.newHashMap(parentContributionFields);
+    ImmutableList.Builder<Snippet> subcomponentConstructorParameters = ImmutableList.builder();
+
+    for (VariableElement moduleVariable : subcomponentFactoryMethod.getParameters()) {
+      // safe because this passed validation
+      TypeElement moduleType = MoreTypes.asTypeElement(moduleVariable.asType());
+      verify(subgraph.transitiveModules().containsKey(moduleType));
+      componentMethod.addParameter(
+          TypeNames.forTypeMirror(moduleVariable.asType()),
+          moduleVariable.getSimpleName().toString());
+      if (!componentContributionFields.containsKey(moduleType)) {
+        String preferredModuleName = CaseFormat.UPPER_CAMEL.to(LOWER_CAMEL,
+            moduleType.getSimpleName().toString());
+        FieldWriter contributionField =
+            subcomponentWriter.addField(moduleType, preferredModuleName);
+        contributionField.addModifiers(PRIVATE, FINAL);
+        String actualModuleName = contributionField.name();
+        constructorWriter.addParameter(
+            TypeNames.forTypeMirror(moduleVariable.asType()), actualModuleName);
+        constructorWriter.body().addSnippet(Snippet.format(Joiner.on('\n').join(
+            "if (%s == null) {",
+            "  throw new NullPointerException();",
+            "}"), actualModuleName));
+        constructorWriter.body().addSnippet(
+            Snippet.format("this.%1$s = %1$s;", actualModuleName));
+        MemberSelect moduleSelect = MemberSelect.instanceSelect(
+            subcomponentWriter.name(), Snippet.format(actualModuleName));
+        componentContributionFields.put(moduleType, moduleSelect);
+        subcomponentConstructorParameters.add(Snippet.format("%s", moduleVariable.getSimpleName()));
+      }
+    }
 
-    for (Entry<TypeElement, String> entry : componentContributionNames.entrySet()) {
-      TypeElement contributionElement = entry.getKey();
-      String contributionName = entry.getValue();
+    SetView<TypeElement> uninitializedModules = Sets.difference(
+        subgraph.transitiveModules().keySet(), componentContributionFields.keySet());
+    for (TypeElement moduleType : uninitializedModules) {
+      String preferredModuleName = CaseFormat.UPPER_CAMEL.to(LOWER_CAMEL,
+          moduleType.getSimpleName().toString());
       FieldWriter contributionField =
-          componentWriter.addField(contributionElement, contributionName);
-      if (hasNoArgsConstructor(entry.getKey())) {
-        contributionField.setInitializer(Snippet.format("new %s()",
-            ClassName.fromTypeElement(entry.getKey())));
-      }
+          subcomponentWriter.addField(moduleType, preferredModuleName);
       contributionField.addModifiers(PRIVATE, FINAL);
-      componentContributionFields.put(contributionElement, MemberSelect.instanceSelect(
-          componentWriter.name(), Snippet.format(contributionField.name())));
+      String actualModuleName = contributionField.name();
+      constructorWriter.body().addSnippet(
+          Snippet.format("this.%s = new %s();", actualModuleName,
+              ClassName.fromTypeElement(moduleType)));
+      MemberSelect moduleSelect = MemberSelect.instanceSelect(
+          subcomponentWriter.name(), Snippet.format(actualModuleName));
+      componentContributionFields.put(moduleType, moduleSelect);
     }
 
+    componentMethod.body().addSnippet("return new %s(%s);",
+        subcomponentWriter.name(),
+        Snippet.makeParametersSnippet(subcomponentConstructorParameters.build()));
+
     Map<BindingKey, MemberSelect> memberSelectSnippetsBuilder = Maps.newHashMap();
 
     Map<ContributionBinding, Snippet> multibindingContributionSnippetsBuilder = Maps.newHashMap();
@@ -418,8 +429,8 @@ private void writeSubcomponents(BindingGraph input,
 
     Map<String, ProxyClassAndField> packageProxies = Maps.newHashMap();
 
-    writeFields(input,
-        componentWriter,
+    writeFields(subgraph,
+        subcomponentWriter,
         proxyWriters,
         memberSelectSnippetsBuilder,
         parentMultibindingContributionSnippets,
@@ -440,8 +451,8 @@ private void writeSubcomponents(BindingGraph input,
         ImmutableMap.copyOf(multibindingContributionSnippetsBuilder);
     ImmutableSet<BindingKey> enumBindingKeys = enumBindingKeysBuilder.build();
 
-    initializeFrameworkTypes(input,
-        componentWriter,
+    initializeFrameworkTypes(subgraph,
+        subcomponentWriter,
         constructorWriter,
         Optional.<ClassName>absent(),
         componentContributionFields,
@@ -449,19 +460,20 @@ private void writeSubcomponents(BindingGraph input,
         parentMultibindingContributionSnippets,
         multibindingContributionSnippets);
 
-    writeInterfaceMethods(input, componentWriter, memberSelectSnippets, enumBindingKeys);
+    writeInterfaceMethods(subgraph, subcomponentWriter, memberSelectSnippets, enumBindingKeys);
 
-    writeSubcomponents(input,
-        componentWriter,
-        proxyWriters,
-        componentContributionFields,
-        memberSelectSnippets,
-        new ImmutableMap.Builder<ContributionBinding, Snippet>()
-            .putAll(parentMultibindingContributionSnippets)
-            .putAll(multibindingContributionSnippets)
-            .build());
-
-    return memberSelectSnippets;
+    for (Entry<ExecutableElement, BindingGraph> subgraphEntry : subgraph.subgraphs().entrySet()) {
+      writeSubcomponent(subcomponentWriter,
+          proxyWriters,
+          componentContributionFields,
+          memberSelectSnippets,
+          new ImmutableMap.Builder<ContributionBinding, Snippet>()
+              .putAll(parentMultibindingContributionSnippets)
+              .putAll(multibindingContributionSnippets)
+              .build(),
+          subgraphEntry.getKey(),
+          subgraphEntry.getValue());
+    }
   }
 
   private void writeFields(BindingGraph input,
@@ -758,9 +770,11 @@ private void initializeFrameworkTypes(BindingGraph input,
                   ImmutableSet<ProvisionBinding> provisionBindings =
                       (ImmutableSet<ProvisionBinding>) bindings;
                   for (ProvisionBinding provisionBinding : provisionBindings) {
-                    if (!isNonProviderMap(provisionBinding)) {
+                    if (!isNonProviderMap(provisionBinding)
+                        && multibindingContributionSnippets.containsKey(provisionBinding)) {
+                      Snippet snippet = multibindingContributionSnippets.get(provisionBinding);
                       initializeMethod.body().addSnippet("this.%s = %s;",
-                        multibindingContributionSnippets.get(provisionBinding),
+                          snippet,
                           initializeFactoryForProvisionBinding(provisionBinding,
                               componentWriter.name(),
                               input.componentDescriptor().dependencyMethodIndex(),
@@ -771,7 +785,11 @@ private void initializeFrameworkTypes(BindingGraph input,
                   if (!provisionBindings.isEmpty()) {
                     Snippet initializeMapSnippet = initializeMapBinding(
                         componentWriter.name(), memberSelectSnippets,
-                        multibindingContributionSnippets, provisionBindings);
+                        new ImmutableMap.Builder<ContributionBinding, Snippet>()
+                            .putAll(parentMultibindingContributionSnippets)
+                            .putAll(multibindingContributionSnippets)
+                            .build(),
+                        provisionBindings);
                     initializeMethod.body().addSnippet("this.%s = %s;",
                         memberSelectSnippet, initializeMapSnippet);
                   }
@@ -1278,18 +1296,4 @@ private boolean isNonProviderMap(Binding binding) {
     return MoreTypes.isTypeOf(Map.class, bindingType) // Implicitly guarantees a declared type.
         && !MoreTypes.isTypeOf(Provider.class, asDeclared(bindingType).getTypeArguments().get(1));
   }
-
-  private boolean hasNoArgsConstructor(TypeElement type) {
-    if (type.getNestingKind().equals(TOP_LEVEL)
-        || type.getNestingKind().equals(MEMBER) && type.getModifiers().contains(STATIC)) {
-      for (Element enclosed : type.getEnclosedElements()) {
-        if (enclosed.getKind().equals(CONSTRUCTOR)) {
-          if (((ExecutableElement) enclosed).getParameters().isEmpty()) {
-            return true;
-          }
-        }
-      }
-    }
-    return false;
-  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
index a298e8aff..3c163ce5f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -15,10 +15,6 @@
  */
 package dagger.internal.codegen;
 
-import java.util.EnumSet;
-
-import javax.tools.Diagnostic;
-import java.util.Arrays;
 import com.google.auto.common.BasicAnnotationProcessor;
 import com.google.auto.service.AutoService;
 import com.google.common.collect.ImmutableList;
@@ -27,6 +23,7 @@
 import dagger.Provides;
 import dagger.producers.ProducerModule;
 import dagger.producers.Produces;
+import java.util.EnumSet;
 import java.util.Map;
 import java.util.Set;
 import javax.annotation.processing.Filer;
@@ -36,6 +33,8 @@
 import javax.lang.model.SourceVersion;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
+import javax.tools.Diagnostic;
+
 import static javax.tools.Diagnostic.Kind.ERROR;
 
 /**
@@ -85,7 +84,8 @@ public SourceVersion getSupportedSourceVersion() {
     ModuleValidator moduleValidator = new ModuleValidator(types, elements, methodSignatureFormatter,
         Module.class, Provides.class);
     ProvidesMethodValidator providesMethodValidator = new ProvidesMethodValidator(elements);
-    ComponentValidator componentValidator = new ComponentValidator(moduleValidator);
+    ComponentValidator componentValidator =
+        new ComponentValidator(elements, types, moduleValidator);
     MapKeyValidator mapKeyValidator = new MapKeyValidator();
     ModuleValidator producerModuleValidator = new ModuleValidator(types, elements,
         methodSignatureFormatter, ProducerModule.class, Produces.class);
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
index ed99925e9..022275750 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
@@ -15,17 +15,42 @@
  */
 package dagger.internal.codegen;
 
+import com.google.auto.common.MoreElements;
+import com.google.auto.common.MoreTypes;
+import com.google.common.base.Joiner;
+import com.google.common.base.Optional;
+import com.google.common.base.Predicate;
+import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Iterables;
+import com.google.common.collect.Sets;
+import com.google.common.collect.Sets.SetView;
 import dagger.Component;
+import dagger.Module;
+import dagger.Subcomponent;
+import java.util.List;
+import java.util.Set;
 import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.ElementFilter;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.SimpleTypeVisitor6;
+import javax.lang.model.util.Types;
 
 import static com.google.auto.common.MoreElements.getAnnotationMirror;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentModules;
+import static dagger.internal.codegen.ConfigurationAnnotations.getTransitiveModules;
+import static dagger.internal.codegen.Util.componentCanMakeNewInstances;
 import static javax.lang.model.element.ElementKind.CLASS;
 import static javax.lang.model.element.ElementKind.INTERFACE;
 import static javax.lang.model.element.Modifier.ABSTRACT;
+import static javax.lang.model.type.TypeKind.VOID;
 
 /**
  * Performs superficial validation of the contract of the {@link Component} annotation.
@@ -33,12 +58,16 @@
  * @author Gregory Kick
  */
 final class ComponentValidator implements Validator<TypeElement> {
+  private final Elements elements;
+  private final Types types;
   private final ModuleValidator moduleValidator;
-  
-  ComponentValidator(ModuleValidator moduleValidator) {
+
+  ComponentValidator(Elements elements, Types types, ModuleValidator moduleValidator) {
+    this.elements = elements;
+    this.types = types;
     this.moduleValidator = moduleValidator;
   }
-  
+
   @Override public ValidationReport<TypeElement> validate(final TypeElement subject) {
     final ValidationReport.Builder<TypeElement> builder = ValidationReport.Builder.about(subject);
 
@@ -47,9 +76,131 @@
       builder.addItem("@Component may only be applied to an interface or abstract class", subject);
     }
 
+    List<? extends Element> members = elements.getAllMembers(subject);
+    for (ExecutableElement method : ElementFilter.methodsIn(members)) {
+      if (method.getModifiers().contains(ABSTRACT)) {
+        List<? extends VariableElement> parameters = method.getParameters();
+        TypeMirror returnType = method.getReturnType();
+
+        // abstract methods are ones we have to implement, so they each need to be validated
+        // first, check the return type.  if it's a subcomponent, validate that method as such.
+        Optional<AnnotationMirror> subcomponentAnnotation  = returnType.accept(
+            new SimpleTypeVisitor6<Optional<AnnotationMirror>, Void>() {
+              @Override protected Optional<AnnotationMirror> defaultAction(TypeMirror e, Void p) {
+                return Optional.absent();
+              }
+
+              @Override public Optional<AnnotationMirror> visitDeclared(DeclaredType t, Void p) {
+                return MoreElements.getAnnotationMirror(t.asElement(), Subcomponent.class);
+              }
+            }, null);
+        if (subcomponentAnnotation.isPresent()) {
+          validateSubcomponentMethod(
+              builder, method, parameters, returnType, subcomponentAnnotation);
+        } else {
+          // if it's not a subcomponent...
+          switch (parameters.size()) {
+            case 0:
+              // no parameters means that it is a provision method
+              // basically, there are no restrictions here.  \o/
+              break;
+            case 1:
+              // one parameter means that it's a members injection method
+              VariableElement onlyParameter = Iterables.getOnlyElement(parameters);
+              if (!(returnType.getKind().equals(VOID)
+                  || types.isSameType(returnType, onlyParameter.asType()))) {
+                builder.addItem(
+                    "Members injection methods may only return the injected type or void.",
+                    method);
+              }
+              break;
+            default:
+              // this isn't any method that we know how to implement...
+              builder.addItem(
+                  "This method isn't a valid provision method, members injection method or "
+                      + "subcomponent factory method. Dagger cannot implement this method", method);
+              break;
+          }
+        }
+      }
+    }
+
     AnnotationMirror componentMirror = getAnnotationMirror(subject, Component.class).get();
     ImmutableList<TypeMirror> moduleTypes = getComponentModules(componentMirror);
     moduleValidator.validateReferencedModules(subject, builder, moduleTypes);
     return builder.build();
   }
+
+  private void validateSubcomponentMethod(final ValidationReport.Builder<TypeElement> builder,
+      ExecutableElement method, List<? extends VariableElement> parameters, TypeMirror returnType,
+      Optional<AnnotationMirror> subcomponentAnnotation) {
+    ImmutableSet<TypeElement> moduleTypes =
+        MoreTypes.asTypeElements(getComponentModules(subcomponentAnnotation.get()));
+
+    ImmutableSet<TypeElement> transitiveModules =
+        getTransitiveModules(types, elements, moduleTypes);
+
+    ImmutableSet<TypeElement> requiredModules =
+        FluentIterable.from(transitiveModules)
+            .filter(new Predicate<TypeElement>() {
+              @Override public boolean apply(TypeElement input) {
+                return !componentCanMakeNewInstances(input);
+              }
+            })
+            .toSet();
+
+    Set<TypeElement> variableTypes = Sets.newHashSet();
+
+    for (VariableElement parameter : parameters) {
+      Optional<TypeElement> moduleType = parameter.asType().accept(
+          new SimpleTypeVisitor6<Optional<TypeElement>, Void>() {
+            @Override protected Optional<TypeElement> defaultAction(TypeMirror e, Void p) {
+              return Optional.absent();
+            }
+
+            @Override public Optional<TypeElement> visitDeclared(DeclaredType t, Void p) {
+              return MoreElements.isAnnotationPresent(t.asElement(), Module.class)
+                  ? Optional.of(MoreTypes.asTypeElement(t))
+                  : Optional.<TypeElement>absent();
+            }
+          }, null);
+      if (moduleType.isPresent()) {
+        if (variableTypes.contains(moduleType.get())) {
+          builder.addItem(
+              String.format(
+                  "A module may only occur once an an argument in a Subcomponent factory "
+                      + "method, but %s was already passed.",
+                  moduleType.get().getQualifiedName()), parameter);
+        }
+        if (!transitiveModules.contains(moduleType.get())) {
+          builder.addItem(
+              String.format(
+                  "%s is present as an argument to the %s factory method, but is not one of the"
+                      + " modules used to implement the subcomponent.",
+                  moduleType.get().getQualifiedName(),
+                  MoreTypes.asTypeElement(returnType).getQualifiedName()),
+              method);
+        }
+        variableTypes.add(moduleType.get());
+      } else {
+        builder.addItem(
+            String.format(
+                "Subcomponent factory methods may only accept modules, but %s is not.",
+                parameter.asType()),
+            parameter);
+      }
+    }
+
+    SetView<TypeElement> missingModules =
+        Sets.difference(requiredModules, ImmutableSet.copyOf(variableTypes));
+    if (!missingModules.isEmpty()) {
+      builder.addItem(
+          String.format(
+              "%s requires modules which have no visible default constructors. "
+                  + "Add the following modules as parameters to this method: %s",
+              MoreTypes.asTypeElement(returnType).getQualifiedName(),
+              Joiner.on(", ").join(missingModules)),
+          method);
+    }
+  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java b/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
index 3a91a1e34..de60f4285 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
@@ -15,8 +15,6 @@
  */
 package dagger.internal.codegen;
 
-import javax.lang.model.type.DeclaredType;
-
 import com.google.auto.common.AnnotationMirrors;
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
@@ -24,10 +22,9 @@
 import com.google.common.base.Optional;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
-import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.Maps;
 import com.google.common.collect.Queues;
+import com.google.common.collect.Sets;
 import dagger.Component;
 import dagger.MapKey;
 import dagger.Module;
@@ -35,8 +32,8 @@
 import dagger.producers.ProducerModule;
 import dagger.producers.ProductionComponent;
 import java.util.List;
-import java.util.Map;
 import java.util.Queue;
+import java.util.Set;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.AnnotationValue;
 import javax.lang.model.element.Element;
@@ -47,6 +44,7 @@
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.SimpleTypeVisitor6;
 import javax.lang.model.util.Types;
+
 import static com.google.auto.common.AnnotationMirrors.getAnnotationValue;
 import static com.google.auto.common.MoreElements.getAnnotationMirror;
 import static com.google.common.base.Preconditions.checkNotNull;
@@ -95,7 +93,7 @@ static boolean isComponent(TypeElement componentDefinitionType) {
   static ImmutableSet<? extends AnnotationMirror> getMapKeys(Element element) {
     return AnnotationMirrors.getAnnotatedAnnotations(element, MapKey.class);
   }
-  
+
   /** Returns the first type that specifies this' nullability, or absent if none. */
   static Optional<DeclaredType> getNullableType(Element element) {
     List<? extends AnnotationMirror> mirrors = element.getAnnotationMirrors();
@@ -124,11 +122,11 @@ static boolean isComponent(TypeElement componentDefinitionType) {
    * given seed modules.  If a module is malformed and a type listed in {@link Module#includes}
    * is not annotated with {@link Module}, it is ignored.
    */
-  static ImmutableMap<TypeElement, ImmutableSet<TypeElement>> getTransitiveModules(
-      Types types, Elements elements, ImmutableSet<TypeElement> seedModules) {
+  static ImmutableSet<TypeElement> getTransitiveModules(
+      Types types, Elements elements, Iterable<TypeElement> seedModules) {
     TypeMirror objectType = elements.getTypeElement(Object.class.getCanonicalName()).asType();
     Queue<TypeElement> moduleQueue = Queues.newArrayDeque(seedModules);
-    Map<TypeElement, ImmutableSet<TypeElement>> moduleElements = Maps.newLinkedHashMap();
+    Set<TypeElement> moduleElements = Sets.newLinkedHashSet();
     for (TypeElement moduleElement = moduleQueue.poll();
         moduleElement != null;
         moduleElement = moduleQueue.poll()) {
@@ -143,15 +141,15 @@ static boolean isComponent(TypeElement componentDefinitionType) {
         // against this element, not the parent.)
         addIncludesFromSuperclasses(types, moduleElement, moduleDependenciesBuilder, objectType);
         ImmutableSet<TypeElement> moduleDependencies = moduleDependenciesBuilder.build();
-        moduleElements.put(moduleElement, moduleDependencies);
+        moduleElements.add(moduleElement);
         for (TypeElement dependencyType : moduleDependencies) {
-          if (!moduleElements.containsKey(dependencyType)) {
+          if (!moduleElements.contains(dependencyType)) {
             moduleQueue.add(dependencyType);
           }
         }
       }
     }
-    return ImmutableMap.copyOf(moduleElements);
+    return ImmutableSet.copyOf(moduleElements);
   }
 
   static boolean isSubcomponentType(TypeMirror type) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
index 8604eee34..53b5d2232 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
@@ -161,7 +161,7 @@
   static final String PROVIDES_OR_PRODUCES_METHOD_MULTIPLE_QUALIFIERS =
       "Cannot use more than one @Qualifier on a @Provides or @Produces method";
 
-  /*mapKey errors*/
+  /* mapKey errors*/
   static final String MAPKEY_WITHOUT_FIELDS =
       "Map key annotation does not have fields";
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/Util.java b/compiler/src/main/java/dagger/internal/codegen/Util.java
index 2b633b33b..58ad95c36 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Util.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Util.java
@@ -27,6 +27,7 @@
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.AnnotationValue;
 import javax.lang.model.element.AnnotationValueVisitor;
+import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
@@ -36,6 +37,9 @@
 import javax.lang.model.util.SimpleAnnotationValueVisitor6;
 
 import static com.google.common.base.Preconditions.checkState;
+import static javax.lang.model.element.ElementKind.CONSTRUCTOR;
+import static javax.lang.model.element.Modifier.ABSTRACT;
+import static javax.lang.model.element.Modifier.STATIC;
 
 /**
  * Utilities for handling types in annotation processors
@@ -120,5 +124,56 @@ protected TypeElement defaultAction(Object o, Void v) {
         : Optional.<T>absent();
   }
 
+  private static boolean requiresEnclosingInstance(TypeElement typeElement) {
+    switch (typeElement.getNestingKind()) {
+      case TOP_LEVEL:
+        return false;
+      case MEMBER:
+        return !typeElement.getModifiers().contains(STATIC);
+      case ANONYMOUS:
+      case LOCAL:
+        return true;
+      default:
+        throw new AssertionError("TypeElement cannot have nesting kind: "
+            + typeElement.getNestingKind());
+    }
+  }
+
+  /**
+   * Returns true if and only if a component can instantiate new instances (typically of a module)
+   * rather than requiring that they be passed.
+   */
+  static boolean componentCanMakeNewInstances(TypeElement typeElement) {
+    switch (typeElement.getKind()) {
+      case CLASS:
+        break;
+      case ENUM:
+      case ANNOTATION_TYPE:
+      case INTERFACE:
+        return false;
+      default:
+        throw new AssertionError("TypeElement cannot have kind: " + typeElement.getKind());
+    }
+
+    if (typeElement.getModifiers().contains(ABSTRACT)) {
+      return false;
+    }
+
+    if (requiresEnclosingInstance(typeElement)) {
+      return false;
+    }
+
+    for (Element enclosed : typeElement.getEnclosedElements()) {
+      if (enclosed.getKind().equals(CONSTRUCTOR)
+          && ((ExecutableElement) enclosed).getParameters().isEmpty()) {
+        return true;
+      }
+    }
+
+    // TODO(gak): still need checks for visibility
+
+    return false;
+  }
+
   private Util() {}
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/SubcomponentValidationTest.java b/compiler/src/test/java/dagger/internal/codegen/SubcomponentValidationTest.java
new file mode 100644
index 000000000..cf15210ee
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/SubcomponentValidationTest.java
@@ -0,0 +1,195 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.common.collect.ImmutableList;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assertAbout;
+import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+
+@RunWith(JUnit4.class)
+public final class SubcomponentValidationTest {
+  @Test public void factoryMethod_missingModulesWithParameters() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component",
+        "interface TestComponent {",
+        "  ChildComponent newChildComponent();",
+        "}");
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent(modules = ModuleWithParameters.class)",
+        "interface ChildComponent {}");
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.ModuleWithParameters",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "",
+        "@Module",
+        "final class ModuleWithParameters {",
+        "  ModuleWithParameters(Object whatever) {}",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(componentFile, childComponentFile, moduleFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            "test.ChildComponent requires modules which have no visible default constructors. "
+                + "Add the following modules as parameters to this method: "
+                + "test.ModuleWithParameters")
+        .in(componentFile).onLine(7);
+  }
+
+  @Test public void factoryMethod_nonModuleParameter() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component",
+        "interface TestComponent {",
+        "  ChildComponent newChildComponent(String someRandomString);",
+        "}");
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "interface ChildComponent {}");
+    assertAbout(javaSources()).that(ImmutableList.of(componentFile, childComponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            "Subcomponent factory methods may only accept modules, but java.lang.String is not.")
+        .in(componentFile).onLine(7).atColumn(43);
+  }
+
+  @Test public void factoryMethod_duplicateParameter() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "",
+        "@Module",
+        "final class TestModule {}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component",
+        "interface TestComponent {",
+        "  ChildComponent newChildComponent(TestModule testModule1, TestModule testModule2);",
+        "}");
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent(modules = TestModule.class)",
+        "interface ChildComponent {}");
+    assertAbout(javaSources()).that(ImmutableList.of(moduleFile, componentFile, childComponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            "A module may only occur once an an argument in a Subcomponent factory method, "
+                + "but test.TestModule was already passed.")
+        .in(componentFile).onLine(7).atColumn(71);
+  }
+
+  @Test public void factoryMethod_superflouousModule() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "",
+        "@Module",
+        "final class TestModule {}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component",
+        "interface TestComponent {",
+        "  ChildComponent newChildComponent(TestModule testModule);",
+        "}");
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "interface ChildComponent {}");
+    assertAbout(javaSources()).that(ImmutableList.of(moduleFile, componentFile, childComponentFile))
+    .processedWith(new ComponentProcessor())
+    .failsToCompile()
+    .withErrorContaining(
+        "test.TestModule is present as an argument to the test.ChildComponent factory method, but "
+            + "is not one of the modules used to implement the subcomponent.")
+                .in(componentFile).onLine(7);
+  }
+
+  @Test public void missingBinding() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "final class TestModule {",
+        "  @Provides String provideString(int i) {",
+        "    return Integer.toString(i);",
+        "  }",
+        "}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component",
+        "interface TestComponent {",
+        "  ChildComponent newChildComponent();",
+        "}");
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent(modules = TestModule.class)",
+        "interface ChildComponent {",
+        "  String getString();",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(moduleFile, componentFile, childComponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            "java.lang.Integer cannot be provided without an @Inject constructor or from an "
+                + "@Provides-annotated method");
+  }
+}
