diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
index 03d6e6a50..947a753a7 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -35,6 +35,7 @@
 import dagger.internal.codegen.BindingGraph.ResolvedBindings;
 import dagger.internal.codegen.ContributionBinding.BindingType;
 import dagger.internal.codegen.ValidationReport.Builder;
+import dagger.internal.codegen.writer.TypeNames;
 import java.util.ArrayDeque;
 import java.util.Deque;
 import java.util.Formatter;
@@ -44,7 +45,6 @@
 import javax.inject.Singleton;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.Name;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Types;
@@ -377,8 +377,7 @@ private void reportMissingBinding(
       Deque<DependencyRequest> requestPath, ValidationReport.Builder<BindingGraph> reportBuilder) {
     Key key = requestPath.peek().key();
     TypeMirror type = key.type();
-    // TODO(sameb): This excludes type variables from the error message right now.
-    Name typeName = MoreElements.asType(types.asElement(type)).getQualifiedName();
+    String typeName = TypeNames.forTypeMirror(type).toString();
     boolean requiresProvidesMethod = !key.isValidImplicitProvisionKey(types);
     StringBuilder errorMessage = new StringBuilder();
     if (requiresProvidesMethod) {
diff --git a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
index 032916dc0..8d41a1013 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
@@ -1549,7 +1549,8 @@
     assertAbout(javaSources()).that(ImmutableList.of(aFile, bFile, cFile, componentFile))
         .processedWith(new ComponentProcessor())
         .failsToCompile()
-        .withErrorContaining("test.B cannot be provided without an @Provides-annotated method");
+        .withErrorContaining(
+            "test.B<? extends test.A> cannot be provided without an @Provides-annotated method");
   }
   
   @Test public void arrayGenericsRequiresAtProvides() {
@@ -1594,7 +1595,8 @@
     assertAbout(javaSources()).that(ImmutableList.of(aFile, bFile, cFile, componentFile))
         .processedWith(new ComponentProcessor())
         .failsToCompile()
-        .withErrorContaining("test.B cannot be provided without an @Provides-annotated method");
+        .withErrorContaining("test.B<java.lang.Object[]> cannot be provided without"
+            + " an @Provides-annotated method");
   }
   
   @Test public void rawTypeGenericsRequiresAtProvides() {
diff --git a/compiler/src/test/java/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java b/compiler/src/test/java/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java
index 045170d77..0f3586746 100644
--- a/compiler/src/test/java/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java
@@ -292,10 +292,7 @@
         "import javax.inject.Inject;",
         "import java.util.List;",
         "",
-        // TODO(sameb): Use A extends Number & Comparable<A> instead,
-        //     so we test intersection tests.  Unfortunately, that's flaky due to
-        //     some weirdness in which tools processor gets picked up by compile-testing.
-        "class GenericClass<A extends B,",
+        "class GenericClass<A extends Number & Comparable<A>,",
         "    B extends List<? extends String>,",
         "    C extends List<? super String>> {",
         "  @Inject GenericClass(A a, B b, C c) {}",
@@ -309,7 +306,7 @@
         "import javax.inject.Provider;",
         "",
         "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class GenericClass$$Factory<A extends B,",
+        "public final class GenericClass$$Factory<A extends Number & Comparable<A>,",
         "        B extends List<? extends String>,",
         "        C extends List<? super String>>",
         "    implements Factory<GenericClass<A, B, C>> {",
@@ -333,7 +330,7 @@
         "    return new GenericClass<A, B, C>(aProvider.get(), bProvider.get(), cProvider.get());",
         "  }",
         "",
-        "  public static <A extends B,",
+        "  public static <A extends Number & Comparable<A>,",
         "      B extends List<? extends String>,",
         "      C extends List<? super String>> Factory<GenericClass<A, B, C>> create(",
         "          Provider<A> aProvider, Provider<B> bProvider, Provider<C> cProvider) {",
