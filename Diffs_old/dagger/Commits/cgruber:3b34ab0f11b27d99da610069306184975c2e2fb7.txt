diff --git a/producers/src/main/java/dagger/producers/monitoring/internal/Monitors.java b/producers/src/main/java/dagger/producers/monitoring/internal/Monitors.java
new file mode 100644
index 000000000..bd57fada4
--- /dev/null
+++ b/producers/src/main/java/dagger/producers/monitoring/internal/Monitors.java
@@ -0,0 +1,322 @@
+/*
+ * Copyright (C) 2015 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.producers.monitoring.internal;
+
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.Iterables;
+import dagger.producers.monitoring.ProducerMonitor;
+import dagger.producers.monitoring.ProducerToken;
+import dagger.producers.monitoring.ProductionComponentMonitor;
+import java.util.Collection;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+import javax.annotation.Nullable;
+
+/**
+ * Utility methods relating to monitoring, for use in generated producers code.
+ *
+ * @author Jesse Beder
+ */
+public final class Monitors {
+  private static final Logger logger = Logger.getLogger(Monitors.class.getName());
+
+  /**
+   * Returns a monitor factory that delegates to the given factories, and ensures that any method
+   * called on this object, even transitively, does not throw a {@link RuntimeException}.
+   *
+   * <p>If the delegate monitors throw an {@link Error}, then that will escape this monitor
+   * implementation. Errors are treated as unrecoverable conditions, and may cause the entire
+   * component's execution to fail.
+   */
+  @Nullable
+  public static ProductionComponentMonitor.Factory delegatingProductionComponentMonitorFactory(
+      Collection<? extends ProductionComponentMonitor.Factory> factories) {
+    if (factories.isEmpty()) {
+      return null;
+    } else if (factories.size() == 1) {
+      return new NonThrowingProductionComponentMonitor.Factory(Iterables.getOnlyElement(factories));
+    } else {
+      return new DelegatingProductionComponentMonitor.Factory(factories);
+    }
+  }
+
+  /**
+   * A component monitor that delegates to a single monitor, and catches and logs all exceptions
+   * that the delegate throws.
+   */
+  private static final class NonThrowingProductionComponentMonitor
+      implements ProductionComponentMonitor {
+    private final ProductionComponentMonitor delegate;
+
+    NonThrowingProductionComponentMonitor(ProductionComponentMonitor delegate) {
+      this.delegate = delegate;
+    }
+
+    @Override
+    public ProducerMonitor producerMonitorFor(ProducerToken token) {
+      try {
+        ProducerMonitor monitor = delegate.producerMonitorFor(token);
+        if (monitor == null) {
+          return null;
+        } else {
+          return new NonThrowingProducerMonitor(monitor);
+        }
+      } catch (RuntimeException e) {
+        logProducerMonitorForException(e, delegate, token);
+        return null;
+      }
+    }
+
+    static final class Factory implements ProductionComponentMonitor.Factory {
+      private final ProductionComponentMonitor.Factory delegate;
+
+      Factory(ProductionComponentMonitor.Factory delegate) {
+        this.delegate = delegate;
+      }
+
+      @Override
+      public ProductionComponentMonitor create(Object component) {
+        try {
+          ProductionComponentMonitor monitor = delegate.create(component);
+          if (monitor == null) {
+            return null;
+          } else {
+            return new NonThrowingProductionComponentMonitor(monitor);
+          }
+        } catch (RuntimeException e) {
+          logCreateException(e, delegate, component);
+          return null;
+        }
+      }
+    }
+  }
+
+  /**
+   * A producer monitor that delegates to a single monitor, and catches and logs all exceptions
+   * that the delegate throws.
+   */
+  private static final class NonThrowingProducerMonitor extends ProducerMonitor {
+    private final ProducerMonitor delegate;
+
+    NonThrowingProducerMonitor(ProducerMonitor delegate) {
+      this.delegate = delegate;
+    }
+
+    @Override
+    public void methodStarting() {
+      try {
+        delegate.methodStarting();
+      } catch (RuntimeException e) {
+        logProducerMonitorMethodException(e, delegate, "methodStarting");
+      }
+    }
+
+    @Override
+    public void methodFinished() {
+      try {
+        delegate.methodFinished();
+      } catch (RuntimeException e) {
+        logProducerMonitorMethodException(e, delegate, "methodFinished");
+      }
+    }
+
+    @Override
+    public void succeeded(Object o) {
+      try {
+        delegate.succeeded(o);
+      } catch (RuntimeException e) {
+        logProducerMonitorArgMethodException(e, delegate, "succeeded", o);
+      }
+    }
+
+    @Override
+    public void failed(Throwable t) {
+      try {
+        delegate.failed(t);
+      } catch (RuntimeException e) {
+        logProducerMonitorArgMethodException(e, delegate, "failed", t);
+      }
+    }
+  }
+
+  /**
+   * A component monitor that delegates to several monitors, and catches and logs all exceptions
+   * that the delegates throw.
+   */
+  private static final class DelegatingProductionComponentMonitor
+      implements ProductionComponentMonitor {
+    private final ImmutableList<ProductionComponentMonitor> delegates;
+
+    DelegatingProductionComponentMonitor(ImmutableList<ProductionComponentMonitor> delegates) {
+      this.delegates = delegates;
+    }
+
+    @Override
+    public ProducerMonitor producerMonitorFor(ProducerToken token) {
+      ImmutableList.Builder<ProducerMonitor> monitorsBuilder = ImmutableList.builder();
+      for (ProductionComponentMonitor delegate : delegates) {
+        try {
+          ProducerMonitor monitor = delegate.producerMonitorFor(token);
+          if (monitor != null) {
+            monitorsBuilder.add(monitor);
+          }
+        } catch (RuntimeException e) {
+          logProducerMonitorForException(e, delegate, token);
+        }
+      }
+      ImmutableList<ProducerMonitor> monitors = monitorsBuilder.build();
+      if (monitors.isEmpty()) {
+        return null;
+      } else if (monitors.size() == 1) {
+        return new NonThrowingProducerMonitor(Iterables.getOnlyElement(monitors));
+      } else {
+        return new DelegatingProducerMonitor(monitors);
+      }
+    }
+
+    static final class Factory implements ProductionComponentMonitor.Factory {
+      private final ImmutableList<ProductionComponentMonitor.Factory> delegates;
+
+      Factory(Iterable<? extends ProductionComponentMonitor.Factory> delegates) {
+        this.delegates = ImmutableList.copyOf(delegates);
+      }
+
+      @Override
+      public ProductionComponentMonitor create(Object component) {
+        ImmutableList.Builder<ProductionComponentMonitor> monitorsBuilder = ImmutableList.builder();
+        for (ProductionComponentMonitor.Factory delegate : delegates) {
+          try {
+            ProductionComponentMonitor monitor = delegate.create(component);
+            if (monitor != null) {
+              monitorsBuilder.add(monitor);
+            }
+          } catch (RuntimeException e) {
+            logCreateException(e, delegate, component);
+          }
+        }
+        ImmutableList<ProductionComponentMonitor> monitors = monitorsBuilder.build();
+        if (monitors.isEmpty()) {
+          return null;
+        } else if (monitors.size() == 1) {
+          return new NonThrowingProductionComponentMonitor(Iterables.getOnlyElement(monitors));
+        } else {
+          return new DelegatingProductionComponentMonitor(monitors);
+        }
+      }
+    }
+  }
+
+  /**
+   * A producer monitor that delegates to several monitors, and catches and logs all exceptions
+   * that the delegates throw.
+   */
+  private static final class DelegatingProducerMonitor extends ProducerMonitor {
+    private final ImmutableList<ProducerMonitor> delegates;
+
+    DelegatingProducerMonitor(ImmutableList<ProducerMonitor> delegates) {
+      this.delegates = delegates;
+    }
+
+    @Override
+    public void methodStarting() {
+      for (ProducerMonitor delegate : delegates) {
+        try {
+          delegate.methodStarting();
+        } catch (RuntimeException e) {
+          logProducerMonitorMethodException(e, delegate, "methodStarting");
+        }
+      }
+    }
+
+    @Override
+    public void methodFinished() {
+      for (ProducerMonitor delegate : delegates.reverse()) {
+        try {
+          delegate.methodFinished();
+        } catch (RuntimeException e) {
+          logProducerMonitorMethodException(e, delegate, "methodFinished");
+        }
+      }
+    }
+
+    @Override
+    public void succeeded(Object o) {
+      for (ProducerMonitor delegate : delegates.reverse()) {
+        try {
+          delegate.succeeded(o);
+        } catch (RuntimeException e) {
+          logProducerMonitorArgMethodException(e, delegate, "succeeded", o);
+        }
+      }
+    }
+
+    @Override
+    public void failed(Throwable t) {
+      for (ProducerMonitor delegate : delegates.reverse()) {
+        try {
+          delegate.failed(t);
+        } catch (RuntimeException e) {
+          logProducerMonitorArgMethodException(e, delegate, "failed", t);
+        }
+      }
+    }
+  }
+
+  private static void logCreateException(
+      RuntimeException e, ProductionComponentMonitor.Factory factory, Object component) {
+    logger.log(
+        Level.SEVERE,
+        "RuntimeException while calling ProductionComponentMonitor.Factory.create on factory "
+            + factory
+            + " with component "
+            + component,
+        e);
+  }
+
+  private static void logProducerMonitorForException(
+      RuntimeException e, ProductionComponentMonitor monitor, ProducerToken token) {
+    logger.log(
+        Level.SEVERE,
+        "RuntimeException while calling ProductionComponentMonitor.producerMonitorFor on monitor "
+            + monitor
+            + " with token "
+            + token,
+        e);
+  }
+
+  private static void logProducerMonitorMethodException(
+      RuntimeException e, ProducerMonitor monitor, String method) {
+    logger.log(
+        Level.SEVERE,
+        "RuntimeException while calling ProducerMonitor." + method + " on monitor " + monitor,
+        e);
+  }
+
+  private static void logProducerMonitorArgMethodException(
+      RuntimeException e, ProducerMonitor monitor, String method, Object arg) {
+    logger.log(
+        Level.SEVERE,
+        "RuntimeException while calling ProducerMonitor."
+            + method
+            + " on monitor "
+            + monitor
+            + " with "
+            + arg,
+        e);
+  }
+
+  private Monitors() {}
+}
diff --git a/producers/src/test/java/dagger/producers/monitoring/internal/MonitorsTest.java b/producers/src/test/java/dagger/producers/monitoring/internal/MonitorsTest.java
new file mode 100644
index 000000000..1e46173ae
--- /dev/null
+++ b/producers/src/test/java/dagger/producers/monitoring/internal/MonitorsTest.java
@@ -0,0 +1,453 @@
+/*
+ * Copyright (C) 2015 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.producers.monitoring.internal;
+
+import com.google.common.collect.ImmutableList;
+import dagger.producers.monitoring.ProducerMonitor;
+import dagger.producers.monitoring.ProducerToken;
+import dagger.producers.monitoring.ProductionComponentMonitor;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import org.mockito.InOrder;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.mockito.Mockito.any;
+import static org.mockito.Mockito.doThrow;
+import static org.mockito.Mockito.inOrder;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.verifyNoMoreInteractions;
+import static org.mockito.Mockito.verifyZeroInteractions;
+import static org.mockito.Mockito.when;
+
+@RunWith(JUnit4.class)
+public final class MonitorsTest {
+  @Mock private ProductionComponentMonitor.Factory mockProductionComponentMonitorFactory;
+  @Mock private ProductionComponentMonitor mockProductionComponentMonitor;
+  @Mock private ProducerMonitor mockProducerMonitor;
+  @Mock private ProductionComponentMonitor.Factory mockProductionComponentMonitorFactoryA;
+  @Mock private ProductionComponentMonitor.Factory mockProductionComponentMonitorFactoryB;
+  @Mock private ProductionComponentMonitor.Factory mockProductionComponentMonitorFactoryC;
+  @Mock private ProductionComponentMonitor mockProductionComponentMonitorA;
+  @Mock private ProductionComponentMonitor mockProductionComponentMonitorB;
+  @Mock private ProductionComponentMonitor mockProductionComponentMonitorC;
+  @Mock private ProducerMonitor mockProducerMonitorA;
+  @Mock private ProducerMonitor mockProducerMonitorB;
+  @Mock private ProducerMonitor mockProducerMonitorC;
+
+  @Before
+  public void initMocks() {
+    MockitoAnnotations.initMocks(this);
+  }
+
+  @Test
+  public void zeroMonitorsReturnsNull() {
+    ProductionComponentMonitor.Factory factory =
+        Monitors.delegatingProductionComponentMonitorFactory(
+            ImmutableList.<ProductionComponentMonitor.Factory>of());
+    assertThat(factory).isNull();
+  }
+
+  @Test
+  public void singleMonitor_nullProductionComponentMonitor() {
+    when(mockProductionComponentMonitorFactory.create(any(Object.class))).thenReturn(null);
+    ProductionComponentMonitor.Factory factory =
+        Monitors.delegatingProductionComponentMonitorFactory(
+            ImmutableList.of(mockProductionComponentMonitorFactory));
+    assertThat(factory.create(new Object())).isNull();
+  }
+
+  @Test
+  public void singleMonitor_throwingProductionComponentMonitorFactory() {
+    doThrow(new RuntimeException("monkey"))
+        .when(mockProductionComponentMonitorFactory)
+        .create(any(Object.class));
+    ProductionComponentMonitor.Factory factory =
+        Monitors.delegatingProductionComponentMonitorFactory(
+            ImmutableList.of(mockProductionComponentMonitorFactory));
+    assertThat(factory.create(new Object())).isNull();
+  }
+
+  @Test
+  public void singleMonitor_nullProducerMonitor() {
+    when(mockProductionComponentMonitorFactory.create(any(Object.class)))
+        .thenReturn(mockProductionComponentMonitor);
+    when(mockProductionComponentMonitor.producerMonitorFor(any(ProducerToken.class)))
+        .thenReturn(null);
+    ProductionComponentMonitor.Factory factory =
+        Monitors.delegatingProductionComponentMonitorFactory(
+            ImmutableList.of(mockProductionComponentMonitorFactory));
+    ProductionComponentMonitor monitor = factory.create(new Object());
+    assertThat(monitor.producerMonitorFor(ProducerToken.create(Object.class))).isNull();
+  }
+
+  @Test
+  public void singleMonitor_throwingProductionComponentMonitor() {
+    when(mockProductionComponentMonitorFactory.create(any(Object.class)))
+        .thenReturn(mockProductionComponentMonitor);
+    doThrow(new RuntimeException("monkey"))
+        .when(mockProductionComponentMonitor)
+        .producerMonitorFor(any(ProducerToken.class));
+    ProductionComponentMonitor.Factory factory =
+        Monitors.delegatingProductionComponentMonitorFactory(
+            ImmutableList.of(mockProductionComponentMonitorFactory));
+    ProductionComponentMonitor monitor = factory.create(new Object());
+    assertThat(monitor.producerMonitorFor(ProducerToken.create(Object.class))).isNull();
+  }
+
+  @Test
+  public void singleMonitor_normalProducerMonitorSuccess() {
+    setUpNormalSingleMonitor();
+    ProductionComponentMonitor.Factory factory =
+        Monitors.delegatingProductionComponentMonitorFactory(
+            ImmutableList.of(mockProductionComponentMonitorFactory));
+    ProductionComponentMonitor monitor = factory.create(new Object());
+    ProducerMonitor producerMonitor =
+        monitor.producerMonitorFor(ProducerToken.create(Object.class));
+    Object o = new Object();
+    producerMonitor.methodStarting();
+    producerMonitor.methodFinished();
+    producerMonitor.succeeded(o);
+
+    InOrder order = inOrder(mockProducerMonitor);
+    order.verify(mockProducerMonitor).methodStarting();
+    order.verify(mockProducerMonitor).methodFinished();
+    order.verify(mockProducerMonitor).succeeded(o);
+    verifyNoMoreInteractions(mockProducerMonitor);
+  }
+
+  @Test
+  public void singleMonitor_normalProducerMonitorFailure() {
+    setUpNormalSingleMonitor();
+    ProductionComponentMonitor.Factory factory =
+        Monitors.delegatingProductionComponentMonitorFactory(
+            ImmutableList.of(mockProductionComponentMonitorFactory));
+    ProductionComponentMonitor monitor = factory.create(new Object());
+    ProducerMonitor producerMonitor =
+        monitor.producerMonitorFor(ProducerToken.create(Object.class));
+    Throwable t = new RuntimeException("monkey");
+    producerMonitor.methodStarting();
+    producerMonitor.methodFinished();
+    producerMonitor.failed(t);
+
+    InOrder order = inOrder(mockProducerMonitor);
+    order.verify(mockProducerMonitor).methodStarting();
+    order.verify(mockProducerMonitor).methodFinished();
+    order.verify(mockProducerMonitor).failed(t);
+    verifyNoMoreInteractions(mockProducerMonitor);
+  }
+
+  @Test
+  public void singleMonitor_throwingProducerMonitorSuccess() {
+    setUpNormalSingleMonitor();
+    doThrow(new RuntimeException("monkey")).when(mockProducerMonitor).methodStarting();
+    doThrow(new RuntimeException("monkey")).when(mockProducerMonitor).methodFinished();
+    doThrow(new RuntimeException("monkey")).when(mockProducerMonitor).succeeded(any(Object.class));
+    ProductionComponentMonitor.Factory factory =
+        Monitors.delegatingProductionComponentMonitorFactory(
+            ImmutableList.of(mockProductionComponentMonitorFactory));
+    ProductionComponentMonitor monitor = factory.create(new Object());
+    ProducerMonitor producerMonitor =
+        monitor.producerMonitorFor(ProducerToken.create(Object.class));
+    Object o = new Object();
+    producerMonitor.methodStarting();
+    producerMonitor.methodFinished();
+    producerMonitor.succeeded(o);
+
+    InOrder order = inOrder(mockProducerMonitor);
+    order.verify(mockProducerMonitor).methodStarting();
+    order.verify(mockProducerMonitor).methodFinished();
+    order.verify(mockProducerMonitor).succeeded(o);
+    verifyNoMoreInteractions(mockProducerMonitor);
+  }
+
+  @Test
+  public void singleMonitor_throwingProducerMonitorFailure() {
+    setUpNormalSingleMonitor();
+    doThrow(new RuntimeException("monkey")).when(mockProducerMonitor).methodStarting();
+    doThrow(new RuntimeException("monkey")).when(mockProducerMonitor).methodFinished();
+    doThrow(new RuntimeException("monkey")).when(mockProducerMonitor).failed(any(Throwable.class));
+    ProductionComponentMonitor.Factory factory =
+        Monitors.delegatingProductionComponentMonitorFactory(
+            ImmutableList.of(mockProductionComponentMonitorFactory));
+    ProductionComponentMonitor monitor = factory.create(new Object());
+    ProducerMonitor producerMonitor =
+        monitor.producerMonitorFor(ProducerToken.create(Object.class));
+    Throwable t = new RuntimeException("gorilla");
+    producerMonitor.methodStarting();
+    producerMonitor.methodFinished();
+    producerMonitor.failed(t);
+
+    InOrder order = inOrder(mockProducerMonitor);
+    order.verify(mockProducerMonitor).methodStarting();
+    order.verify(mockProducerMonitor).methodFinished();
+    order.verify(mockProducerMonitor).failed(t);
+    verifyNoMoreInteractions(mockProducerMonitor);
+  }
+
+  @Test
+  public void multipleMonitors_nullProductionComponentMonitors() {
+    when(mockProductionComponentMonitorFactoryA.create(any(Object.class))).thenReturn(null);
+    when(mockProductionComponentMonitorFactoryB.create(any(Object.class))).thenReturn(null);
+    when(mockProductionComponentMonitorFactoryC.create(any(Object.class))).thenReturn(null);
+    ProductionComponentMonitor.Factory factory =
+        Monitors.delegatingProductionComponentMonitorFactory(
+            ImmutableList.of(
+                mockProductionComponentMonitorFactoryA,
+                mockProductionComponentMonitorFactoryB,
+                mockProductionComponentMonitorFactoryC));
+    assertThat(factory.create(new Object())).isNull();
+  }
+
+  @Test
+  public void multipleMonitors_throwingProductionComponentMonitorFactories() {
+    doThrow(new RuntimeException("monkey"))
+        .when(mockProductionComponentMonitorFactoryA)
+        .create(any(Object.class));
+    doThrow(new RuntimeException("monkey"))
+        .when(mockProductionComponentMonitorFactoryB)
+        .create(any(Object.class));
+    doThrow(new RuntimeException("monkey"))
+        .when(mockProductionComponentMonitorFactoryC)
+        .create(any(Object.class));
+    ProductionComponentMonitor.Factory factory =
+        Monitors.delegatingProductionComponentMonitorFactory(
+            ImmutableList.of(
+                mockProductionComponentMonitorFactoryA,
+                mockProductionComponentMonitorFactoryB,
+                mockProductionComponentMonitorFactoryC));
+    assertThat(factory.create(new Object())).isNull();
+  }
+
+  @Test
+  public void multipleMonitors_someNullProductionComponentMonitors() {
+    when(mockProductionComponentMonitorFactoryA.create(any(Object.class)))
+        .thenReturn(mockProductionComponentMonitorA);
+    when(mockProductionComponentMonitorFactoryB.create(any(Object.class))).thenReturn(null);
+    when(mockProductionComponentMonitorFactoryC.create(any(Object.class))).thenReturn(null);
+    when(mockProductionComponentMonitorA.producerMonitorFor(any(ProducerToken.class)))
+        .thenReturn(mockProducerMonitorA);
+    ProductionComponentMonitor.Factory factory =
+        Monitors.delegatingProductionComponentMonitorFactory(
+            ImmutableList.of(
+                mockProductionComponentMonitorFactoryA,
+                mockProductionComponentMonitorFactoryB,
+                mockProductionComponentMonitorFactoryC));
+    ProductionComponentMonitor monitor = factory.create(new Object());
+    ProducerMonitor producerMonitor =
+        monitor.producerMonitorFor(ProducerToken.create(Object.class));
+
+    Object o = new Object();
+    producerMonitor.methodStarting();
+    producerMonitor.methodFinished();
+    producerMonitor.succeeded(o);
+
+    InOrder order = inOrder(mockProducerMonitorA);
+    order.verify(mockProducerMonitorA).methodStarting();
+    order.verify(mockProducerMonitorA).methodFinished();
+    order.verify(mockProducerMonitorA).succeeded(o);
+    verifyNoMoreInteractions(mockProducerMonitorA);
+  }
+
+  @Test
+  public void multipleMonitors_someThrowingProductionComponentMonitorFactories() {
+    when(mockProductionComponentMonitorFactoryA.create(any(Object.class)))
+        .thenReturn(mockProductionComponentMonitorA);
+    doThrow(new RuntimeException("monkey"))
+        .when(mockProductionComponentMonitorFactoryB)
+        .create(any(Object.class));
+    doThrow(new RuntimeException("monkey"))
+        .when(mockProductionComponentMonitorFactoryC)
+        .create(any(Object.class));
+    when(mockProductionComponentMonitorA.producerMonitorFor(any(ProducerToken.class)))
+        .thenReturn(mockProducerMonitorA);
+    ProductionComponentMonitor.Factory factory =
+        Monitors.delegatingProductionComponentMonitorFactory(
+            ImmutableList.of(
+                mockProductionComponentMonitorFactoryA,
+                mockProductionComponentMonitorFactoryB,
+                mockProductionComponentMonitorFactoryC));
+    ProductionComponentMonitor monitor = factory.create(new Object());
+    ProducerMonitor producerMonitor =
+        monitor.producerMonitorFor(ProducerToken.create(Object.class));
+
+    Object o = new Object();
+    producerMonitor.methodStarting();
+    producerMonitor.methodFinished();
+    producerMonitor.succeeded(o);
+
+    InOrder order = inOrder(mockProducerMonitorA);
+    order.verify(mockProducerMonitorA).methodStarting();
+    order.verify(mockProducerMonitorA).methodFinished();
+    order.verify(mockProducerMonitorA).succeeded(o);
+    verifyNoMoreInteractions(mockProducerMonitorA);
+  }
+
+  @Test
+  public void multipleMonitors_normalProductionComponentMonitorSuccess() {
+    setUpNormalMultipleMonitors();
+    ProductionComponentMonitor.Factory factory =
+        Monitors.delegatingProductionComponentMonitorFactory(
+            ImmutableList.of(
+                mockProductionComponentMonitorFactoryA,
+                mockProductionComponentMonitorFactoryB,
+                mockProductionComponentMonitorFactoryC));
+    ProductionComponentMonitor monitor = factory.create(new Object());
+    ProducerMonitor producerMonitor =
+        monitor.producerMonitorFor(ProducerToken.create(Object.class));
+
+    Object o = new Object();
+    producerMonitor.methodStarting();
+    producerMonitor.methodFinished();
+    producerMonitor.succeeded(o);
+
+    InOrder order = inOrder(mockProducerMonitorA, mockProducerMonitorB, mockProducerMonitorC);
+    order.verify(mockProducerMonitorA).methodStarting();
+    order.verify(mockProducerMonitorB).methodStarting();
+    order.verify(mockProducerMonitorC).methodStarting();
+    order.verify(mockProducerMonitorC).methodFinished();
+    order.verify(mockProducerMonitorB).methodFinished();
+    order.verify(mockProducerMonitorA).methodFinished();
+    order.verify(mockProducerMonitorC).succeeded(o);
+    order.verify(mockProducerMonitorB).succeeded(o);
+    order.verify(mockProducerMonitorA).succeeded(o);
+    verifyNoMoreInteractions(mockProducerMonitorA, mockProducerMonitorB, mockProducerMonitorC);
+  }
+
+  @Test
+  public void multipleMonitors_normalProductionComponentMonitorFailure() {
+    setUpNormalMultipleMonitors();
+    ProductionComponentMonitor.Factory factory =
+        Monitors.delegatingProductionComponentMonitorFactory(
+            ImmutableList.of(
+                mockProductionComponentMonitorFactoryA,
+                mockProductionComponentMonitorFactoryB,
+                mockProductionComponentMonitorFactoryC));
+    ProductionComponentMonitor monitor = factory.create(new Object());
+    ProducerMonitor producerMonitor =
+        monitor.producerMonitorFor(ProducerToken.create(Object.class));
+
+    Throwable t = new RuntimeException("chimpanzee");
+    producerMonitor.methodStarting();
+    producerMonitor.methodFinished();
+    producerMonitor.failed(t);
+
+    InOrder order = inOrder(mockProducerMonitorA, mockProducerMonitorB, mockProducerMonitorC);
+    order.verify(mockProducerMonitorA).methodStarting();
+    order.verify(mockProducerMonitorB).methodStarting();
+    order.verify(mockProducerMonitorC).methodStarting();
+    order.verify(mockProducerMonitorC).methodFinished();
+    order.verify(mockProducerMonitorB).methodFinished();
+    order.verify(mockProducerMonitorA).methodFinished();
+    order.verify(mockProducerMonitorC).failed(t);
+    order.verify(mockProducerMonitorB).failed(t);
+    order.verify(mockProducerMonitorA).failed(t);
+    verifyNoMoreInteractions(mockProducerMonitorA, mockProducerMonitorB, mockProducerMonitorC);
+  }
+
+  @Test
+  public void multipleMonitors_someThrowingProducerMonitorsSuccess() {
+    setUpNormalMultipleMonitors();
+    doThrow(new RuntimeException("monkey")).when(mockProducerMonitorA).methodStarting();
+    doThrow(new RuntimeException("monkey")).when(mockProducerMonitorB).methodFinished();
+    doThrow(new RuntimeException("monkey")).when(mockProducerMonitorC).succeeded(any(Object.class));
+    ProductionComponentMonitor.Factory factory =
+        Monitors.delegatingProductionComponentMonitorFactory(
+            ImmutableList.of(
+                mockProductionComponentMonitorFactoryA,
+                mockProductionComponentMonitorFactoryB,
+                mockProductionComponentMonitorFactoryC));
+    ProductionComponentMonitor monitor = factory.create(new Object());
+    ProducerMonitor producerMonitor =
+        monitor.producerMonitorFor(ProducerToken.create(Object.class));
+
+    Object o = new Object();
+    producerMonitor.methodStarting();
+    producerMonitor.methodFinished();
+    producerMonitor.succeeded(o);
+
+    InOrder order = inOrder(mockProducerMonitorA, mockProducerMonitorB, mockProducerMonitorC);
+    order.verify(mockProducerMonitorA).methodStarting();
+    order.verify(mockProducerMonitorB).methodStarting();
+    order.verify(mockProducerMonitorC).methodStarting();
+    order.verify(mockProducerMonitorC).methodFinished();
+    order.verify(mockProducerMonitorB).methodFinished();
+    order.verify(mockProducerMonitorA).methodFinished();
+    order.verify(mockProducerMonitorC).succeeded(o);
+    order.verify(mockProducerMonitorB).succeeded(o);
+    order.verify(mockProducerMonitorA).succeeded(o);
+    verifyNoMoreInteractions(mockProducerMonitorA, mockProducerMonitorB, mockProducerMonitorC);
+  }
+
+  @Test
+  public void multipleMonitors_someThrowingProducerMonitorsFailure() {
+    setUpNormalMultipleMonitors();
+    doThrow(new RuntimeException("monkey")).when(mockProducerMonitorA).methodStarting();
+    doThrow(new RuntimeException("monkey")).when(mockProducerMonitorB).methodFinished();
+    doThrow(new RuntimeException("monkey")).when(mockProducerMonitorC).failed(any(Throwable.class));
+    ProductionComponentMonitor.Factory factory =
+        Monitors.delegatingProductionComponentMonitorFactory(
+            ImmutableList.of(
+                mockProductionComponentMonitorFactoryA,
+                mockProductionComponentMonitorFactoryB,
+                mockProductionComponentMonitorFactoryC));
+    ProductionComponentMonitor monitor = factory.create(new Object());
+    ProducerMonitor producerMonitor =
+        monitor.producerMonitorFor(ProducerToken.create(Object.class));
+
+    Throwable t = new RuntimeException("chimpanzee");
+    producerMonitor.methodStarting();
+    producerMonitor.methodFinished();
+    producerMonitor.failed(t);
+
+    InOrder order = inOrder(mockProducerMonitorA, mockProducerMonitorB, mockProducerMonitorC);
+    order.verify(mockProducerMonitorA).methodStarting();
+    order.verify(mockProducerMonitorB).methodStarting();
+    order.verify(mockProducerMonitorC).methodStarting();
+    order.verify(mockProducerMonitorC).methodFinished();
+    order.verify(mockProducerMonitorB).methodFinished();
+    order.verify(mockProducerMonitorA).methodFinished();
+    order.verify(mockProducerMonitorC).failed(t);
+    order.verify(mockProducerMonitorB).failed(t);
+    order.verify(mockProducerMonitorA).failed(t);
+    verifyNoMoreInteractions(mockProducerMonitorA, mockProducerMonitorB, mockProducerMonitorC);
+  }
+
+  private void setUpNormalSingleMonitor() {
+    when(mockProductionComponentMonitorFactory.create(any(Object.class)))
+        .thenReturn(mockProductionComponentMonitor);
+    when(mockProductionComponentMonitor.producerMonitorFor(any(ProducerToken.class)))
+        .thenReturn(mockProducerMonitor);
+  }
+
+  private void setUpNormalMultipleMonitors() {
+    when(mockProductionComponentMonitorFactoryA.create(any(Object.class)))
+        .thenReturn(mockProductionComponentMonitorA);
+    when(mockProductionComponentMonitorFactoryB.create(any(Object.class)))
+        .thenReturn(mockProductionComponentMonitorB);
+    when(mockProductionComponentMonitorFactoryC.create(any(Object.class)))
+        .thenReturn(mockProductionComponentMonitorC);
+    when(mockProductionComponentMonitorA.producerMonitorFor(any(ProducerToken.class)))
+        .thenReturn(mockProducerMonitorA);
+    when(mockProductionComponentMonitorB.producerMonitorFor(any(ProducerToken.class)))
+        .thenReturn(mockProducerMonitorB);
+    when(mockProductionComponentMonitorC.producerMonitorFor(any(ProducerToken.class)))
+        .thenReturn(mockProducerMonitorC);
+  }
+}
