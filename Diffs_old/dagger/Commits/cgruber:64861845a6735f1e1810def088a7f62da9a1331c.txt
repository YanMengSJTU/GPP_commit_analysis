diff --git a/java/dagger/internal/codegen/BUILD b/java/dagger/internal/codegen/BUILD
index 22f2960d2..cf030e84e 100644
--- a/java/dagger/internal/codegen/BUILD
+++ b/java/dagger/internal/codegen/BUILD
@@ -211,6 +211,7 @@ java_library(
         "MemberSelect.java",
         "MembersInjectionBindingExpression.java",
         "MembersInjectionMethods.java",
+        "MembersInjectorFieldInitializer.java",
         "MembersInjectorGenerator.java",
         "MonitoringModuleGenerator.java",
         "MonitoringModuleProcessingStep.java",
@@ -218,8 +219,10 @@ java_library(
         "OptionalFactories.java",
         "PrivateMethodBindingExpression.java",
         "ProducerFactoryGenerator.java",
+        "ProducerFromProviderFieldInitializer.java",
         "ProductionExecutorModuleGenerator.java",
         "ProviderOrProducerBindingExpression.java",
+        "ProviderOrProducerFieldInitializer.java",
         "ReferenceReleasingManagerFields.java",
         "SetBindingExpression.java",
         "SimpleInvocationBindingExpression.java",
diff --git a/java/dagger/internal/codegen/ComponentBindingExpressions.java b/java/dagger/internal/codegen/ComponentBindingExpressions.java
index fc27afae5..96650d251 100644
--- a/java/dagger/internal/codegen/ComponentBindingExpressions.java
+++ b/java/dagger/internal/codegen/ComponentBindingExpressions.java
@@ -16,6 +16,7 @@
 
 package dagger.internal.codegen;
 
+import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static dagger.internal.codegen.Accessibility.isRawTypeAccessible;
 import static dagger.internal.codegen.Accessibility.isTypeAccessibleFrom;
@@ -23,6 +24,7 @@
 import static dagger.internal.codegen.ContributionBinding.Kind.PROVISION;
 import static dagger.internal.codegen.ContributionBinding.Kind.SYNTHETIC_MULTIBOUND_MAP;
 import static dagger.internal.codegen.ContributionBinding.Kind.SYNTHETIC_MULTIBOUND_SET;
+import static dagger.internal.codegen.MemberSelect.staticMemberSelect;
 
 import com.google.common.collect.ImmutableSet;
 import com.squareup.javapoet.ClassName;
@@ -258,53 +260,89 @@ private BindingExpression createBindingExpression(BindingKey bindingKey) {
               generatedComponentModel, componentBindingExpressions, graph, elements, types);
     }
 
-    private FrameworkInstanceBindingExpression newFrameworkInstanceBindingExpression(
-        boolean isProducerFromProvider, ResolvedBindings resolvedBindings) {
-      return FrameworkInstanceBindingExpression.create(
-          resolvedBindings,
-          graph,
-          subcomponentNames,
+    /** Creates a binding expression. */
+    BindingExpression create(ResolvedBindings resolvedBindings) {
+      switch (resolvedBindings.bindingType()) {
+        case MEMBERS_INJECTION:
+          return membersInjectionBindingExpression(resolvedBindings);
+
+        case PROVISION:
+          return provisionBindingExpression(resolvedBindings);
+
+        case PRODUCTION:
+          return frameworkInstanceBindingExpression(resolvedBindings);
+
+        default:
+          throw new AssertionError(resolvedBindings);
+      }
+    }
+
+    /** Returns a binding expression for a members injection binding. */
+    private MembersInjectionBindingExpression membersInjectionBindingExpression(
+        ResolvedBindings resolvedBindings) {
+      return new MembersInjectionBindingExpression(
+          frameworkInstanceBindingExpression(resolvedBindings),
           generatedComponentModel,
+          membersInjectionMethods);
+    }
+
+    /**
+     * Returns a binding expression that uses a {@link javax.inject.Provider} for provision
+     * bindings, a {@link dagger.producers.Producer} for production bindings, or a {@link
+     * dagger.MembersInjector} for members injection bindings.
+     */
+    private FrameworkInstanceBindingExpression frameworkInstanceBindingExpression(
+        ResolvedBindings resolvedBindings) {
+      Optional<MemberSelect> staticMethod = staticMemberSelect(resolvedBindings);
+      return new FrameworkInstanceBindingExpression(
+          resolvedBindings,
           componentBindingExpressions,
-          componentRequirementFields,
-          referenceReleasingManagerFields,
-          isProducerFromProvider,
-          optionalFactories,
-          compilerOptions,
+          resolvedBindings.bindingType().frameworkType(),
+          staticMethod.isPresent()
+              ? staticMethod::get
+              : frameworkFieldInitializer(resolvedBindings),
           types,
           elements);
     }
 
-    /** Creates a binding expression */
-    BindingExpression create(ResolvedBindings resolvedBindings) {
-      FrameworkInstanceBindingExpression frameworkInstanceBindingExpression =
-          newFrameworkInstanceBindingExpression(
-              false /* isProducerFromProvider */, resolvedBindings);
-
+    /**
+     * Returns an initializer for a {@link javax.inject.Provider} field for provision bindings, a
+     * {@link dagger.producers.Producer} field for production bindings, or a {@link
+     * dagger.MembersInjector} field for members injection bindings.
+     */
+    private FrameworkFieldInitializer frameworkFieldInitializer(ResolvedBindings resolvedBindings) {
       switch (resolvedBindings.bindingType()) {
-        case MEMBERS_INJECTION:
-          return new MembersInjectionBindingExpression(
-              frameworkInstanceBindingExpression, generatedComponentModel, membersInjectionMethods);
+        case PRODUCTION:
         case PROVISION:
-          return provisionBindingExpression(frameworkInstanceBindingExpression);
+          return new ProviderOrProducerFieldInitializer(
+              resolvedBindings,
+              subcomponentNames,
+              generatedComponentModel,
+              componentBindingExpressions,
+              componentRequirementFields,
+              referenceReleasingManagerFields,
+              compilerOptions,
+              graph,
+              optionalFactories);
+
+        case MEMBERS_INJECTION:
+          return new MembersInjectorFieldInitializer(
+              resolvedBindings, generatedComponentModel, componentBindingExpressions);
+
         default:
-          return frameworkInstanceBindingExpression;
+          throw new AssertionError(resolvedBindings);
       }
     }
 
-    private BindingExpression provisionBindingExpression(
-        FrameworkInstanceBindingExpression providerBindingExpression) {
+    /** Returns a binding expression for a provision binding. */
+    private BindingExpression provisionBindingExpression(ResolvedBindings resolvedBindings) {
       // TODO(user): this can be removed once we pass DependencyRequest.Kind to the factory.
       // With DependencyRequest.Kind, we can know if it's a ProducerFromProvider or not, so we won't
       // have to pass in both types of binding expressions.
-      ResolvedBindings resolvedBindings = providerBindingExpression.resolvedBindings();
-      FrameworkInstanceBindingExpression producerBindingExpression =
-          newFrameworkInstanceBindingExpression(
-              true /* isProducerFromProvider */, resolvedBindings);
       BindingExpression bindingExpression =
           new ProviderOrProducerBindingExpression(
-              providerBindingExpression,
-              producerBindingExpression);
+              frameworkInstanceBindingExpression(resolvedBindings),
+              producerFromProviderInstanceBindingExpression(resolvedBindings));
 
       BindingExpression inlineBindingExpression =
           inlineProvisionBindingExpression(bindingExpression);
@@ -324,6 +362,23 @@ private BindingExpression provisionBindingExpression(
       return inlineBindingExpression;
     }
 
+    /**
+     * Returns a binding expression that uses a {@link dagger.producers.Producer} field for a
+     * provision binding.
+     */
+    private FrameworkInstanceBindingExpression producerFromProviderInstanceBindingExpression(
+        ResolvedBindings resolvedBindings) {
+      checkArgument(resolvedBindings.bindingType().frameworkType().equals(FrameworkType.PROVIDER));
+      return new FrameworkInstanceBindingExpression(
+          resolvedBindings,
+          componentBindingExpressions,
+          FrameworkType.PRODUCER,
+          new ProducerFromProviderFieldInitializer(
+              resolvedBindings, generatedComponentModel, componentBindingExpressions),
+          types,
+          elements);
+    }
+
     private BindingExpression inlineProvisionBindingExpression(
         BindingExpression bindingExpression) {
       ProvisionBinding provisionBinding =
diff --git a/java/dagger/internal/codegen/FrameworkFieldInitializer.java b/java/dagger/internal/codegen/FrameworkFieldInitializer.java
index 5f3be4247..1c30fcee4 100644
--- a/java/dagger/internal/codegen/FrameworkFieldInitializer.java
+++ b/java/dagger/internal/codegen/FrameworkFieldInitializer.java
@@ -16,118 +16,47 @@
 
 package dagger.internal.codegen;
 
-import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
-import static com.google.common.base.Preconditions.checkState;
-import static com.google.common.base.Verify.verify;
-import static com.google.common.collect.Iterables.getOnlyElement;
-import static com.squareup.javapoet.MethodSpec.constructorBuilder;
-import static com.squareup.javapoet.MethodSpec.methodBuilder;
-import static com.squareup.javapoet.TypeSpec.anonymousClassBuilder;
 import static dagger.internal.codegen.Accessibility.isTypeAccessibleFrom;
 import static dagger.internal.codegen.AnnotationSpecs.Suppression.RAWTYPES;
-import static dagger.internal.codegen.BindingType.PROVISION;
-import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
-import static dagger.internal.codegen.ContributionBinding.Kind.INJECTION;
 import static dagger.internal.codegen.DaggerStreams.toImmutableList;
 import static dagger.internal.codegen.GeneratedComponentModel.FieldSpecKind.FRAMEWORK_FIELD;
-import static dagger.internal.codegen.GeneratedComponentModel.TypeSpecKind.COMPONENT_PROVISION_FACTORY;
-import static dagger.internal.codegen.MapKeys.getMapKeyExpression;
-import static dagger.internal.codegen.MoreAnnotationMirrors.getTypeValue;
-import static dagger.internal.codegen.SourceFiles.generatedClassNameForBinding;
-import static dagger.internal.codegen.SourceFiles.mapFactoryClassName;
-import static dagger.internal.codegen.SourceFiles.membersInjectorNameForType;
-import static dagger.internal.codegen.SourceFiles.setFactoryClassName;
-import static dagger.internal.codegen.SourceFiles.simpleVariableName;
-import static dagger.internal.codegen.TypeNames.DOUBLE_CHECK;
-import static dagger.internal.codegen.TypeNames.INSTANCE_FACTORY;
-import static dagger.internal.codegen.TypeNames.REFERENCE_RELEASING_PROVIDER;
-import static dagger.internal.codegen.TypeNames.SINGLE_CHECK;
-import static dagger.internal.codegen.TypeNames.TYPED_RELEASABLE_REFERENCE_MANAGER_DECORATOR;
-import static dagger.internal.codegen.TypeNames.listenableFutureOf;
-import static dagger.internal.codegen.TypeNames.producerOf;
-import static dagger.internal.codegen.TypeNames.providerOf;
-import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
-import static javax.lang.model.element.Modifier.PUBLIC;
-import static javax.lang.model.element.Modifier.STATIC;
 
-import com.google.auto.common.MoreElements;
-import com.google.auto.common.MoreTypes;
 import com.google.common.collect.ImmutableList;
-import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.Lists;
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
 import com.squareup.javapoet.FieldSpec;
-import com.squareup.javapoet.MethodSpec;
-import com.squareup.javapoet.TypeName;
-import com.squareup.javapoet.TypeSpec;
 import dagger.internal.DelegateFactory;
-import dagger.internal.InstanceFactory;
-import dagger.internal.TypedReleasableReferenceManagerDecorator;
-import dagger.producers.Produced;
-import dagger.producers.Producer;
-import dagger.releasablereferences.ForReleasableReferences;
-import dagger.releasablereferences.ReleasableReferenceManager;
-import dagger.releasablereferences.TypedReleasableReferenceManager;
-import java.util.Arrays;
-import java.util.HashSet;
-import java.util.List;
+import dagger.internal.codegen.MemberSelect.MemberSelectSupplier;
 import java.util.Optional;
-import javax.inject.Provider;
-import javax.lang.model.element.AnnotationMirror;
-import javax.lang.model.element.TypeElement;
-import javax.lang.model.type.TypeMirror;
 
 /**
  * An object that can initialize a framework-type component field for a binding. An instance should
  * be created for each field.
  */
-// TODO(dpb): Split this class up, at least by binding kind, but maybe also producerFromProvider?
-final class FrameworkFieldInitializer {
-  private final SubcomponentNames subcomponentNames;
-  private final GeneratedComponentModel generatedComponentModel;
+abstract class FrameworkFieldInitializer implements MemberSelectSupplier {
+  protected final GeneratedComponentModel generatedComponentModel;
   private final ComponentBindingExpressions componentBindingExpressions;
-  private final ComponentRequirementFields componentRequirementFields;
-  // TODO(ronshapiro): add Binding.bindingKey() and use that instead of taking a ResolvedBindings
   private final ResolvedBindings resolvedBindings;
-  private final CompilerOptions compilerOptions;
-  private final BindingGraph graph;
-  private final boolean isProducerFromProvider;
-  private final OptionalFactories optionalFactories;
-  private final ReferenceReleasingManagerFields referenceReleasingManagerFields;
   private FieldSpec fieldSpec;
   private InitializationState fieldInitializationState = InitializationState.UNINITIALIZED;
 
-  FrameworkFieldInitializer(
-      ResolvedBindings resolvedBindings,
-      SubcomponentNames subcomponentNames,
+  protected FrameworkFieldInitializer(
       GeneratedComponentModel generatedComponentModel,
       ComponentBindingExpressions componentBindingExpressions,
-      ComponentRequirementFields componentRequirementFields,
-      ReferenceReleasingManagerFields referenceReleasingManagerFields,
-      CompilerOptions compilerOptions,
-      BindingGraph graph,
-      boolean isProducerFromProvider,
-      OptionalFactories optionalFactories) {
-    this.subcomponentNames = checkNotNull(subcomponentNames);
+      ResolvedBindings resolvedBindings) {
     this.generatedComponentModel = checkNotNull(generatedComponentModel);
     this.componentBindingExpressions = checkNotNull(componentBindingExpressions);
-    this.componentRequirementFields = checkNotNull(componentRequirementFields);
-    this.referenceReleasingManagerFields = checkNotNull(referenceReleasingManagerFields);
     this.resolvedBindings = checkNotNull(resolvedBindings);
-    this.compilerOptions = checkNotNull(compilerOptions);
-    this.graph = checkNotNull(graph);
-    this.optionalFactories = checkNotNull(optionalFactories);
-    this.isProducerFromProvider = isProducerFromProvider;
   }
 
   /**
    * Returns the {@link MemberSelect} for the framework field, and adds the field and its
    * initialization code to the component if it's needed and not already added.
    */
-  MemberSelect getOrCreateMemberSelect() {
+  @Override
+  public final MemberSelect memberSelect() {
     initializeField();
     return MemberSelect.localField(generatedComponentModel.name(), checkNotNull(fieldSpec).name);
   }
@@ -184,11 +113,8 @@ private FieldSpec getOrCreateField() {
     boolean useRawType =
         !isTypeAccessibleFrom(
             resolvedBindings.key().type(), generatedComponentModel.name().packageName());
-
-    Optional<ClassName> alternativeFrameworkClass =
-        isProducerFromProvider ? Optional.of(TypeNames.PRODUCER) : Optional.empty();
     FrameworkField contributionBindingField =
-        FrameworkField.forResolvedBindings(resolvedBindings, alternativeFrameworkClass);
+        FrameworkField.forResolvedBindings(resolvedBindings, alternativeFrameworkClass());
     FieldSpec.Builder contributionField =
         FieldSpec.builder(
             useRawType ? contributionBindingField.type().rawType : contributionBindingField.type(),
@@ -203,524 +129,25 @@ private FieldSpec getOrCreateField() {
     return fieldSpec;
   }
 
-  /** Returns the expression to use to initialize the field. */
-  private CodeBlock getFieldInitialization() {
-    if (isProducerFromProvider) {
-      return FrameworkType.PROVIDER.to(
-          DependencyRequest.Kind.PRODUCER,
-          componentBindingExpressions
-              .getDependencyExpression(
-                  FrameworkDependency.create(resolvedBindings.bindingKey(), PROVISION),
-                  generatedComponentModel.name())
-              .codeBlock());
-    }
-
-    switch (resolvedBindings.bindingKey().kind()) {
-      case CONTRIBUTION:
-        return contributionBindingInitialization();
-      case MEMBERS_INJECTION:
-        return membersInjectionBindingInitialization();
-      default:
-        throw new AssertionError();
-    }
-  }
-
-  private CodeBlock contributionBindingInitialization() {
-    ContributionBinding contributionBinding = resolvedBindings.contributionBinding();
-    switch (contributionBinding.factoryCreationStrategy()) {
-      case DELEGATE:
-        CodeBlock delegatingCodeBlock =
-            CodeBlock.of(
-                "($T) $L",
-                contributionBinding.bindingType().frameworkClass(),
-                getDependencyExpression(
-                    getOnlyElement(contributionBinding.frameworkDependencies())));
-        return decorateForScope(delegatingCodeBlock, contributionBinding.scope());
-      case SINGLETON_INSTANCE:
-        checkState(contributionBinding.scope().isPresent());
-        // fall through
-      case CLASS_CONSTRUCTOR:
-        return factoryForContributionBindingInitialization(contributionBinding);
-
-      default:
-        throw new AssertionError();
-    }
-  }
-
-  private CodeBlock membersInjectionBindingInitialization() {
-    MembersInjectionBinding membersInjectionBinding =
-        resolvedBindings.membersInjectionBinding().get();
-    return CodeBlock.of(
-        "$T.create($L)",
-        membersInjectorNameForType(membersInjectionBinding.membersInjectedType()),
-        makeParametersCodeBlock(getBindingDependencyExpressions(membersInjectionBinding)));
-  }
-
-  private CodeBlock factoryForContributionBindingInitialization(ContributionBinding binding) {
-    TypeName bindingKeyTypeName = TypeName.get(binding.key().type());
-    switch (binding.bindingKind()) {
-      case COMPONENT:
-        // This bindingKeyTypeName type parameter can be removed when we drop java 7 source support
-        return CodeBlock.of("$T.<$T>create(this)", INSTANCE_FACTORY, bindingKeyTypeName);
-
-      case COMPONENT_DEPENDENCY:
-        return CodeBlock.of(
-            "$T.create($L)",
-            INSTANCE_FACTORY,
-            componentRequirementFields.getExpressionDuringInitialization(
-                ComponentRequirement.forDependency(binding.key().type()),
-                generatedComponentModel.name()));
-
-      case COMPONENT_PROVISION:
-        {
-          TypeElement dependencyType = dependencyTypeForBinding(binding);
-          String dependencyVariable = simpleVariableName(dependencyType);
-          String componentMethod = binding.bindingElement().get().getSimpleName().toString();
-          // TODO(sameb): The Provider.get() throws a very vague NPE.  The stack trace doesn't
-          // help to figure out what the method or return type is.  If we include a string
-          // of the return type or method name in the error message, that can defeat obfuscation.
-          // We can easily include the raw type (no generics) + annotation type (no values),
-          // using .class & String.format -- but that wouldn't be the whole story.
-          // What should we do?
-          CodeBlock invocation =
-              ComponentProvisionBindingExpression.maybeCheckForNull(
-                  (ProvisionBinding) binding,
-                  compilerOptions,
-                  CodeBlock.of("$L.$L()", dependencyVariable, componentMethod));
-          ClassName dependencyClassName = ClassName.get(dependencyType);
-          String factoryName =
-              dependencyClassName.toString().replace('.', '_') + "_" + componentMethod;
-          MethodSpec.Builder getMethod =
-              methodBuilder("get")
-                  .addAnnotation(Override.class)
-                  .addModifiers(PUBLIC)
-                  .returns(bindingKeyTypeName)
-                  .addStatement("return $L", invocation);
-          if (binding.nullableType().isPresent()) {
-            getMethod.addAnnotation(
-                ClassName.get(MoreTypes.asTypeElement(binding.nullableType().get())));
-          }
-          generatedComponentModel.addType(
-              COMPONENT_PROVISION_FACTORY,
-              TypeSpec.classBuilder(factoryName)
-                  .addSuperinterface(providerOf(bindingKeyTypeName))
-                  .addModifiers(PRIVATE, STATIC)
-                  .addField(dependencyClassName, dependencyVariable, PRIVATE, FINAL)
-                  .addMethod(
-                      constructorBuilder()
-                          .addParameter(dependencyClassName, dependencyVariable)
-                          .addStatement("this.$1L = $1L", dependencyVariable)
-                          .build())
-                  .addMethod(getMethod.build())
-                  .build());
-          return CodeBlock.of(
-              "new $L($L)",
-              factoryName,
-              componentRequirementFields.getExpressionDuringInitialization(
-                  ComponentRequirement.forDependency(dependencyType.asType()),
-                  generatedComponentModel.name()));
-        }
-
-      case SUBCOMPONENT_BUILDER:
-        String subcomponentName =
-            subcomponentNames.get(
-                graph
-                    .componentDescriptor()
-                    .subcomponentsByBuilderType()
-                    .get(MoreTypes.asTypeElement(binding.key().type())));
-        return CodeBlock.of(
-            "$L",
-            anonymousClassBuilder("")
-                .superclass(providerOf(bindingKeyTypeName))
-                .addMethod(
-                    methodBuilder("get")
-                        .addAnnotation(Override.class)
-                        .addModifiers(PUBLIC)
-                        .returns(bindingKeyTypeName)
-                        .addStatement("return new $LBuilder()", subcomponentName)
-                        .build())
-                .build());
-
-      case BUILDER_BINDING:
-        return CodeBlock.of(
-            "$T.$L($L)",
-            InstanceFactory.class,
-            binding.nullableType().isPresent() ? "createNullable" : "create",
-            componentRequirementFields.getExpressionDuringInitialization(
-                ComponentRequirement.forBinding(binding), generatedComponentModel.name()));
-
-      case INJECTION:
-      case PROVISION:
-        {
-          List<CodeBlock> arguments =
-              Lists.newArrayListWithCapacity(binding.explicitDependencies().size() + 1);
-          if (binding.requiresModuleInstance()) {
-            arguments.add(
-                componentRequirementFields.getExpressionDuringInitialization(
-                    ComponentRequirement.forModule(binding.contributingModule().get().asType()),
-                    generatedComponentModel.name()));
-          }
-          arguments.addAll(getBindingDependencyExpressions(binding));
-
-          CodeBlock factoryCreate =
-              CodeBlock.of(
-                  "$T.create($L)",
-                  generatedClassNameForBinding(binding),
-                  makeParametersCodeBlock(arguments));
-
-          // If scoping a parameterized factory for an @Inject class, Java 7 cannot always infer the
-          // type properly, so cast to a raw framework type before scoping.
-          if (binding.bindingKind().equals(INJECTION)
-              && binding.unresolved().isPresent()
-              && binding.scope().isPresent()) {
-            factoryCreate =
-                CodeBlock.of("($T) $L", binding.bindingType().frameworkClass(), factoryCreate);
-          }
-          return decorateForScope(factoryCreate, binding.scope());
-        }
-
-      case COMPONENT_PRODUCTION:
-        {
-          TypeElement dependencyType = dependencyTypeForBinding(binding);
-          FieldSpec dependencyField =
-              FieldSpec.builder(
-                      ClassName.get(dependencyType),
-                      simpleVariableName(dependencyType),
-                      PRIVATE,
-                      FINAL)
-                  .initializer(
-                      componentRequirementFields.getExpressionDuringInitialization(
-                          ComponentRequirement.forDependency(dependencyType.asType()),
-                          generatedComponentModel.name()))
-                  .build();
-          return CodeBlock.of(
-              "$L",
-              anonymousClassBuilder("")
-                  .superclass(producerOf(bindingKeyTypeName))
-                  .addField(dependencyField)
-                  .addMethod(
-                      methodBuilder("get")
-                          .addAnnotation(Override.class)
-                          .addModifiers(PUBLIC)
-                          .returns(listenableFutureOf(bindingKeyTypeName))
-                          .addStatement(
-                              "return $N.$L()",
-                              dependencyField,
-                              binding.bindingElement().get().getSimpleName())
-                          .build())
-                  .build());
-        }
-
-      case PRODUCTION:
-        {
-          List<CodeBlock> arguments =
-              Lists.newArrayListWithCapacity(binding.dependencies().size() + 2);
-          if (binding.requiresModuleInstance()) {
-            arguments.add(
-                componentRequirementFields.getExpressionDuringInitialization(
-                    ComponentRequirement.forModule(binding.contributingModule().get().asType()),
-                    generatedComponentModel.name()));
-          }
-          arguments.addAll(getBindingDependencyExpressions(binding));
-
-          return CodeBlock.of(
-              "new $T($L)",
-              generatedClassNameForBinding(binding),
-              makeParametersCodeBlock(arguments));
-        }
-
-      case SYNTHETIC_MULTIBOUND_SET:
-        return factoryForSetMultibindingInitialization(binding);
-
-      case SYNTHETIC_MULTIBOUND_MAP:
-        return factoryForMapMultibindingInitialization(binding);
-
-      case SYNTHETIC_RELEASABLE_REFERENCE_MANAGER:
-        return factoryForSyntheticReleasableReferenceManagerBindingInitialization(binding);
-
-      case SYNTHETIC_RELEASABLE_REFERENCE_MANAGERS:
-        return factoryForSyntheticSetOfReleasableReferenceManagersInitialization(binding);
-
-      case SYNTHETIC_OPTIONAL_BINDING:
-        return factoryForSyntheticOptionalBindingInitialization(binding);
-
-      default:
-        throw new AssertionError(binding);
-    }
-  }
-
   /**
-   * Maybe wraps the given creation code block in single/double check or reference releasing
-   * providers.
+   * Returns the framework class to use for the field, if different from the one implied by the
+   * binding. This implementation returns {@link Optional#empty()}.
    */
-  private CodeBlock decorateForScope(CodeBlock factoryCreate, Optional<Scope> maybeScope) {
-    if (!maybeScope.isPresent()) {
-      return factoryCreate;
-    }
-    Scope scope = maybeScope.get();
-    if (referenceReleasingManagerFields.requiresReleasableReferences(scope)) {
-      return CodeBlock.of(
-          "$T.create($L, $L)",
-          REFERENCE_RELEASING_PROVIDER,
-          factoryCreate,
-          referenceReleasingManagerFields.getExpression(scope, generatedComponentModel.name()));
-    } else {
-      return CodeBlock.of(
-          "$T.provider($L)", scope.isReusable() ? SINGLE_CHECK : DOUBLE_CHECK, factoryCreate);
-    }
-  }
-
-  private TypeElement dependencyTypeForBinding(ContributionBinding binding) {
-    return graph.componentDescriptor().dependencyMethodIndex().get(binding.bindingElement().get());
+  protected Optional<ClassName> alternativeFrameworkClass() {
+    return Optional.empty();
   }
 
-  private CodeBlock factoryForSetMultibindingInitialization(ContributionBinding binding) {
-    CodeBlock.Builder builder = CodeBlock.builder().add("$T.", setFactoryClassName(binding));
-    boolean useRawTypes = useRawType();
-    if (!useRawTypes) {
-      SetType setType = SetType.from(binding.key());
-      builder.add(
-          "<$T>",
-          setType.elementsAreTypeOf(Produced.class)
-              ? setType.unwrappedElementType(Produced.class)
-              : setType.elementType());
-    }
-    int individualProviders = 0;
-    int setProviders = 0;
-    CodeBlock.Builder builderMethodCalls = CodeBlock.builder();
-    for (FrameworkDependency frameworkDependency : binding.frameworkDependencies()) {
-      ContributionType contributionType =
-          graph.resolvedBindings().get(frameworkDependency.bindingKey()).contributionType();
-      String methodName;
-      String methodNameSuffix = frameworkDependency.frameworkClass().getSimpleName();
-      switch (contributionType) {
-        case SET:
-          individualProviders++;
-          methodName = "add" + methodNameSuffix;
-          break;
-        case SET_VALUES:
-          setProviders++;
-          methodName = "addCollection" + methodNameSuffix;
-          break;
-        default:
-          throw new AssertionError(frameworkDependency + " is not a set multibinding");
-      }
-
-      builderMethodCalls.add(
-          ".$L($L)",
-          methodName,
-          potentiallyCast(
-              useRawTypes,
-              frameworkDependency.frameworkClass(),
-              getDependencyExpression(frameworkDependency)));
-    }
-    builder.add("builder($L, $L)", individualProviders, setProviders);
-    builder.add(builderMethodCalls.build());
-    return builder.add(".build()").build();
-  }
-
-  private CodeBlock factoryForMapMultibindingInitialization(ContributionBinding binding) {
-    ImmutableList<FrameworkDependency> frameworkDependencies = binding.frameworkDependencies();
-
-    ImmutableList.Builder<CodeBlock> codeBlocks = ImmutableList.builder();
-    MapType mapType = MapType.from(binding.key().type());
-    CodeBlock.Builder builderCall = CodeBlock.builder().add("$T.", mapFactoryClassName(binding));
-    boolean useRawTypes = useRawType();
-    if (!useRawTypes) {
-      // TODO(ronshapiro): either inline this into mapFactoryClassName, or add a
-      // mapType.unwrappedValueType() method that doesn't require a framework type
-      TypeMirror valueType = mapType.valueType();
-      for (Class<?> frameworkClass :
-          ImmutableSet.of(Provider.class, Producer.class, Produced.class)) {
-        if (mapType.valuesAreTypeOf(frameworkClass)) {
-          valueType = mapType.unwrappedValueType(frameworkClass);
-          break;
-        }
-      }
-      builderCall.add("<$T, $T>", mapType.keyType(), valueType);
-    }
-
-    if (binding.bindingType().equals(BindingType.PROVISION)) {
-      builderCall.add("builder($L)", frameworkDependencies.size());
-    } else {
-      builderCall.add("builder()");
-    }
-    codeBlocks.add(builderCall.build());
-
-    for (FrameworkDependency frameworkDependency : frameworkDependencies) {
-      BindingKey bindingKey = frameworkDependency.bindingKey();
-      ContributionBinding contributionBinding =
-          graph.resolvedBindings().get(bindingKey).contributionBinding();
-      CodeBlock value =
-          potentiallyCast(
-              useRawTypes,
-              frameworkDependency.frameworkClass(),
-              getDependencyExpression(frameworkDependency));
-      codeBlocks.add(
-          CodeBlock.of(
-              ".put($L, $L)",
-              getMapKeyExpression(contributionBinding, generatedComponentModel.name()),
-              value));
-    }
-    codeBlocks.add(CodeBlock.of(".build()"));
-
-    return CodeBlocks.concat(codeBlocks.build());
-  }
-
-  // TODO(ronshapiro): Use functionality from Expression
-  private CodeBlock potentiallyCast(boolean shouldCast, Class<?> classToCast, CodeBlock notCasted) {
-    if (!shouldCast) {
-      return notCasted;
-    }
-    return CodeBlock.of("($T) $L", classToCast, notCasted);
-  }
-
-  private boolean useRawType() {
-
-    return !isTypeAccessibleFrom(
-        resolvedBindings.key().type(), generatedComponentModel.name().packageName());
-  }
-
-  /**
-   * Initializes the factory for a {@link
-   * ContributionBinding.Kind#SYNTHETIC_RELEASABLE_REFERENCE_MANAGER} binding.
-   *
-   * <p>The {@code get()} method just returns the component field with the {@link
-   * dagger.internal.ReferenceReleasingProviderManager} object.
-   */
-  private CodeBlock factoryForSyntheticReleasableReferenceManagerBindingInitialization(
-      ContributionBinding binding) {
-    // The scope is the value of the @ForReleasableReferences annotation.
-    Scope scope = forReleasableReferencesAnnotationValue(binding.key().qualifier().get());
-
-    CodeBlock managerExpression;
-    if (MoreTypes.isTypeOf(TypedReleasableReferenceManager.class, binding.key().type())) {
-      /* The key's type is TypedReleasableReferenceManager<M>, so return
-       * new TypedReleasableReferenceManager(field, metadata). */
-      TypeMirror metadataType =
-          MoreTypes.asDeclared(binding.key().type()).getTypeArguments().get(0);
-      managerExpression =
-          typedReleasableReferenceManagerDecoratorExpression(
-              referenceReleasingManagerFields.getExpression(scope, generatedComponentModel.name()),
-              scope.releasableReferencesMetadata(metadataType).get());
-    } else {
-      // The key's type is ReleasableReferenceManager, so return the field as is.
-      managerExpression =
-          referenceReleasingManagerFields.getExpression(scope, generatedComponentModel.name());
-    }
-
-    TypeName keyType = TypeName.get(binding.key().type());
-    return CodeBlock.of(
-        "$L",
-        anonymousClassBuilder("")
-            .addSuperinterface(providerOf(keyType))
-            .addMethod(
-                methodBuilder("get")
-                    .addAnnotation(Override.class)
-                    .addModifiers(PUBLIC)
-                    .returns(keyType)
-                    .addCode("return $L;", managerExpression)
-                    .build())
-            .build());
-  }
-
-  /**
-   * Initializes the factory for a {@link
-   * ContributionBinding.Kind#SYNTHETIC_RELEASABLE_REFERENCE_MANAGERS} binding.
-   *
-   * <p>A binding for {@code Set<ReleasableReferenceManager>} will include managers for all
-   * reference-releasing scopes. A binding for {@code Set<TypedReleasableReferenceManager<M>>} will
-   * include managers for all reference-releasing scopes whose metadata type is {@code M}.
-   */
-  private CodeBlock factoryForSyntheticSetOfReleasableReferenceManagersInitialization(
-      ContributionBinding binding) {
-    Key key = binding.key();
-    SetType keyType = SetType.from(key);
-    ImmutableList.Builder<CodeBlock> managerExpressions = ImmutableList.builder();
-    for (Scope scope : graph.scopesRequiringReleasableReferenceManagers()) {
-      CodeBlock releasableReferenceManagerExpression =
-          referenceReleasingManagerFields.getExpression(scope, generatedComponentModel.name());
-
-      if (keyType.elementsAreTypeOf(ReleasableReferenceManager.class)) {
-        managerExpressions.add(releasableReferenceManagerExpression);
-      } else if (keyType.elementsAreTypeOf(TypedReleasableReferenceManager.class)) {
-        TypeMirror metadataType =
-            keyType.unwrappedElementType(TypedReleasableReferenceManager.class);
-        Optional<AnnotationMirror> metadata = scope.releasableReferencesMetadata(metadataType);
-        if (metadata.isPresent()) {
-          managerExpressions.add(
-              typedReleasableReferenceManagerDecoratorExpression(
-                  releasableReferenceManagerExpression, metadata.get()));
-        }
-      } else {
-        throw new IllegalArgumentException("inappropriate key: " + binding);
-      }
-    }
-    TypeName keyTypeName = TypeName.get(key.type());
-    return CodeBlock.of(
-        "$L",
-        anonymousClassBuilder("")
-            .addSuperinterface(providerOf(keyTypeName))
-            .addMethod(
-                methodBuilder("get")
-                    .addAnnotation(Override.class)
-                    .addModifiers(PUBLIC)
-                    .returns(keyTypeName)
-                    .addCode(
-                        "return new $T($T.asList($L));",
-                        HashSet.class,
-                        Arrays.class,
-                        makeParametersCodeBlock(managerExpressions.build()))
-                    .build())
-            .build());
-  }
-
-  /**
-   * Returns an expression that evaluates to a {@link TypedReleasableReferenceManagerDecorator} that
-   * decorates the {@code managerExpression} to supply {@code metadata}.
-   */
-  private CodeBlock typedReleasableReferenceManagerDecoratorExpression(
-      CodeBlock managerExpression, AnnotationMirror metadata) {
-    return CodeBlock.of(
-        "new $T<$T>($L, $L)",
-        TYPED_RELEASABLE_REFERENCE_MANAGER_DECORATOR,
-        metadata.getAnnotationType(),
-        managerExpression,
-        new AnnotationExpression(metadata).getAnnotationInstanceExpression());
-  }
-
-  private Scope forReleasableReferencesAnnotationValue(AnnotationMirror annotation) {
-    checkArgument(
-        MoreTypes.isTypeOf(ForReleasableReferences.class, annotation.getAnnotationType()));
-    return Scope.scope(
-        MoreElements.asType(MoreTypes.asDeclared(getTypeValue(annotation, "value")).asElement()));
-  }
-
-  /**
-   * Returns an expression that initializes a {@link Provider} or {@link Producer} for an optional
-   * binding.
-   */
-  private CodeBlock factoryForSyntheticOptionalBindingInitialization(ContributionBinding binding) {
-    if (binding.explicitDependencies().isEmpty()) {
-      verify(
-          binding.bindingType().equals(BindingType.PROVISION),
-          "Absent optional bindings should be provisions: %s",
-          binding);
-      return optionalFactories.absentOptionalProvider(binding);
-    } else {
-      return optionalFactories.presentOptionalFactory(
-          binding, getDependencyExpression(getOnlyElement(binding.frameworkDependencies())));
-    }
-  }
+  /** Returns the expression to use to initialize the field. */
+  protected abstract CodeBlock getFieldInitialization();
 
   /** Returns a list of code blocks for referencing all of the given binding's dependencies. */
-  private ImmutableList<CodeBlock> getBindingDependencyExpressions(Binding binding) {
+  protected final ImmutableList<CodeBlock> getBindingDependencyExpressions(Binding binding) {
     ImmutableList<FrameworkDependency> dependencies = binding.frameworkDependencies();
     return dependencies.stream().map(this::getDependencyExpression).collect(toImmutableList());
   }
 
   /** Returns a code block referencing the given dependency. */
-  private CodeBlock getDependencyExpression(FrameworkDependency frameworkDependency) {
+  protected final CodeBlock getDependencyExpression(FrameworkDependency frameworkDependency) {
     return componentBindingExpressions
         .getDependencyExpression(frameworkDependency, generatedComponentModel.name())
         .codeBlock();
diff --git a/java/dagger/internal/codegen/FrameworkInstanceBindingExpression.java b/java/dagger/internal/codegen/FrameworkInstanceBindingExpression.java
index b52889bb3..98685dbe3 100644
--- a/java/dagger/internal/codegen/FrameworkInstanceBindingExpression.java
+++ b/java/dagger/internal/codegen/FrameworkInstanceBindingExpression.java
@@ -16,15 +16,12 @@
 
 package dagger.internal.codegen;
 
-import static com.google.common.base.Preconditions.checkArgument;
 import static dagger.internal.codegen.Accessibility.isTypeAccessibleFrom;
-import static dagger.internal.codegen.MemberSelect.staticMemberSelect;
 
-import com.google.common.base.Supplier;
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
 import com.squareup.javapoet.FieldSpec;
-import java.util.Optional;
+import dagger.internal.codegen.MemberSelect.MemberSelectSupplier;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
@@ -32,62 +29,16 @@
 /** A binding expression that uses an instance of a {@link FrameworkType}. */
 final class FrameworkInstanceBindingExpression extends BindingExpression {
   private final ComponentBindingExpressions componentBindingExpressions;
-  private final Supplier<MemberSelect> frameworkFieldSupplier;
+  private final MemberSelectSupplier frameworkFieldSupplier;
   private final FrameworkType frameworkType;
   private final DaggerTypes types;
   private final Elements elements;
 
-  /** Returns a binding expression for a binding. */
-  static FrameworkInstanceBindingExpression create(
-      ResolvedBindings resolvedBindings,
-      BindingGraph graph,
-      SubcomponentNames subcomponentNames,
-      GeneratedComponentModel generatedComponentModel,
-      ComponentBindingExpressions componentBindingExpressions,
-      ComponentRequirementFields componentRequirementFields,
-      ReferenceReleasingManagerFields referenceReleasingManagerFields,
-      boolean isProducerFromProvider,
-      OptionalFactories optionalFactories,
-      CompilerOptions compilerOptions,
-      DaggerTypes types,
-      Elements elements) {
-    FrameworkType frameworkType = resolvedBindings.bindingType().frameworkType();
-    checkArgument(!isProducerFromProvider || frameworkType.equals(FrameworkType.PROVIDER));
-
-    Optional<MemberSelect> staticMemberSelect = staticMemberSelect(resolvedBindings);
-    Supplier<MemberSelect> frameworkFieldSupplier;
-    if (!isProducerFromProvider && staticMemberSelect.isPresent()) {
-      frameworkFieldSupplier = staticMemberSelect::get;
-    } else {
-      FrameworkFieldInitializer fieldInitializer =
-          new FrameworkFieldInitializer(
-              resolvedBindings,
-              subcomponentNames,
-              generatedComponentModel,
-              componentBindingExpressions,
-              componentRequirementFields,
-              referenceReleasingManagerFields,
-              compilerOptions,
-              graph,
-              isProducerFromProvider,
-              optionalFactories);
-      frameworkFieldSupplier = fieldInitializer::getOrCreateMemberSelect;
-    }
-
-    return new FrameworkInstanceBindingExpression(
-        resolvedBindings,
-        componentBindingExpressions,
-        isProducerFromProvider ? FrameworkType.PRODUCER : frameworkType,
-        frameworkFieldSupplier,
-        types,
-        elements);
-  }
-
-  private FrameworkInstanceBindingExpression(
+  FrameworkInstanceBindingExpression(
       ResolvedBindings resolvedBindings,
       ComponentBindingExpressions componentBindingExpressions,
       FrameworkType frameworkType,
-      Supplier<MemberSelect> frameworkFieldSupplier,
+      MemberSelectSupplier frameworkFieldSupplier,
       DaggerTypes types,
       Elements elements) {
     super(resolvedBindings);
@@ -108,7 +59,7 @@ private FrameworkInstanceBindingExpression(
   Expression getDependencyExpression(
       DependencyRequest.Kind requestKind, ClassName requestingClass) {
     if (requestKind.equals(frameworkRequestKind())) {
-      MemberSelect memberSelect = frameworkFieldSupplier.get();
+      MemberSelect memberSelect = frameworkFieldSupplier.memberSelect();
       TypeMirror expressionType =
           isTypeAccessibleFrom(instanceType(), requestingClass.packageName())
                   || isInlinedFactoryCreation(memberSelect)
diff --git a/java/dagger/internal/codegen/MemberSelect.java b/java/dagger/internal/codegen/MemberSelect.java
index 7e71fa473..adf41d163 100644
--- a/java/dagger/internal/codegen/MemberSelect.java
+++ b/java/dagger/internal/codegen/MemberSelect.java
@@ -49,6 +49,13 @@
  * Represents a {@link com.sun.source.tree.MemberSelectTree} as a {@link CodeBlock}.
  */
 abstract class MemberSelect {
+
+  /** An object that supplies a {@link MemberSelect}. */
+  interface MemberSelectSupplier {
+    /** Returns a {@link MemberSelect}, with possible side effects on the first call. */
+    MemberSelect memberSelect();
+  }
+
   /**
    * Returns a {@link MemberSelect} that accesses the field given by {@code fieldName} owned by
    * {@code owningClass}.  In this context "local" refers to the fact that the field is owned by the
diff --git a/java/dagger/internal/codegen/MembersInjectionBindingExpression.java b/java/dagger/internal/codegen/MembersInjectionBindingExpression.java
index 6539f44d9..4707c668f 100644
--- a/java/dagger/internal/codegen/MembersInjectionBindingExpression.java
+++ b/java/dagger/internal/codegen/MembersInjectionBindingExpression.java
@@ -28,20 +28,20 @@
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.VariableElement;
 
-/** A binding expression that can wrap another */
+/** A binding expression for members injection bindings. */
 final class MembersInjectionBindingExpression extends BindingExpression {
-  private final FrameworkInstanceBindingExpression membersInjectorField;
+  private final FrameworkInstanceBindingExpression membersInjectorExpression;
   private final GeneratedComponentModel generatedComponentModel;
   private final MembersInjectionBinding binding;
   private final MembersInjectionMethods membersInjectionMethods;
 
   MembersInjectionBindingExpression(
-      FrameworkInstanceBindingExpression membersInjectorField,
+      FrameworkInstanceBindingExpression membersInjectorExpression,
       GeneratedComponentModel generatedComponentModel,
       MembersInjectionMethods membersInjectionMethods) {
-    super(membersInjectorField.resolvedBindings());
+    super(membersInjectorExpression.resolvedBindings());
     checkArgument(resolvedBindings().bindingKey().kind().equals(BindingKey.Kind.MEMBERS_INJECTION));
-    this.membersInjectorField = membersInjectorField;
+    this.membersInjectorExpression = membersInjectorExpression;
     this.generatedComponentModel = generatedComponentModel;
     this.binding = resolvedBindings().membersInjectionBinding().get();
     this.membersInjectionMethods = membersInjectionMethods;
@@ -51,7 +51,7 @@
   Expression getDependencyExpression(
       DependencyRequest.Kind requestKind, ClassName requestingClass) {
     checkArgument(requestKind.equals(DependencyRequest.Kind.MEMBERS_INJECTOR));
-    return membersInjectorField.getDependencyExpression(requestKind, requestingClass);
+    return membersInjectorExpression.getDependencyExpression(requestKind, requestingClass);
   }
 
   @Override
@@ -64,8 +64,8 @@ CodeBlock getComponentMethodImplementation(
     ExecutableElement methodElement = componentMethod.methodElement();
     List<? extends VariableElement> parameters = methodElement.getParameters();
     if (parameters.isEmpty() /* i.e. it's a request for a MembersInjector<T> */) {
-      return membersInjectorField
-          .getComponentMethodImplementation(componentMethod, generatedComponentModel.name());
+      return membersInjectorExpression.getComponentMethodImplementation(
+          componentMethod, generatedComponentModel.name());
     }
 
     ParameterSpec parameter = ParameterSpec.get(getOnlyElement(parameters));
diff --git a/java/dagger/internal/codegen/MembersInjectorFieldInitializer.java b/java/dagger/internal/codegen/MembersInjectorFieldInitializer.java
new file mode 100644
index 000000000..721293aff
--- /dev/null
+++ b/java/dagger/internal/codegen/MembersInjectorFieldInitializer.java
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkNotNull;
+import static dagger.internal.codegen.BindingKey.Kind.MEMBERS_INJECTION;
+import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
+import static dagger.internal.codegen.SourceFiles.membersInjectorNameForType;
+
+import com.squareup.javapoet.CodeBlock;
+
+/** An initializer for {@link dagger.MembersInjector} fields. */
+final class MembersInjectorFieldInitializer extends FrameworkFieldInitializer {
+
+  // TODO(ronshapiro): add Binding.bindingKey() and use that instead of taking a ResolvedBindings
+  private final ResolvedBindings resolvedBindings;
+
+  MembersInjectorFieldInitializer(
+      ResolvedBindings resolvedBindings,
+      GeneratedComponentModel generatedComponentModel,
+      ComponentBindingExpressions componentBindingExpressions) {
+    super(generatedComponentModel, componentBindingExpressions, resolvedBindings);
+    checkArgument(resolvedBindings.bindingKey().kind().equals(MEMBERS_INJECTION));
+    this.resolvedBindings = checkNotNull(resolvedBindings);
+  }
+
+  @Override
+  protected CodeBlock getFieldInitialization() {
+    MembersInjectionBinding membersInjectionBinding =
+        resolvedBindings.membersInjectionBinding().get();
+    return CodeBlock.of(
+        "$T.create($L)",
+        membersInjectorNameForType(membersInjectionBinding.membersInjectedType()),
+        makeParametersCodeBlock(getBindingDependencyExpressions(membersInjectionBinding)));
+  }
+}
diff --git a/java/dagger/internal/codegen/ProducerFromProviderFieldInitializer.java b/java/dagger/internal/codegen/ProducerFromProviderFieldInitializer.java
new file mode 100644
index 000000000..fae83acd6
--- /dev/null
+++ b/java/dagger/internal/codegen/ProducerFromProviderFieldInitializer.java
@@ -0,0 +1,58 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.base.Preconditions.checkNotNull;
+import static dagger.internal.codegen.BindingType.PROVISION;
+
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+import dagger.producers.Producer;
+import java.util.Optional;
+
+/** An initializer for {@link Producer} fields that are adaptations of provision bindings. */
+final class ProducerFromProviderFieldInitializer extends FrameworkFieldInitializer {
+
+  private final ComponentBindingExpressions componentBindingExpressions;
+  // TODO(ronshapiro): add Binding.bindingKey() and use that instead of taking a ResolvedBindings
+  private final ResolvedBindings resolvedBindings;
+
+  ProducerFromProviderFieldInitializer(
+      ResolvedBindings resolvedBindings,
+      GeneratedComponentModel generatedComponentModel,
+      ComponentBindingExpressions componentBindingExpressions) {
+    super(generatedComponentModel, componentBindingExpressions, resolvedBindings);
+    this.componentBindingExpressions = checkNotNull(componentBindingExpressions);
+    this.resolvedBindings = checkNotNull(resolvedBindings);
+  }
+
+  @Override
+  protected CodeBlock getFieldInitialization() {
+    return FrameworkType.PROVIDER.to(
+        DependencyRequest.Kind.PRODUCER,
+        componentBindingExpressions
+            .getDependencyExpression(
+                FrameworkDependency.create(resolvedBindings.bindingKey(), PROVISION),
+                generatedComponentModel.name())
+            .codeBlock());
+  }
+
+  @Override
+  protected Optional<ClassName> alternativeFrameworkClass() {
+    return Optional.of(ClassName.get(Producer.class));
+  }
+}
diff --git a/java/dagger/internal/codegen/ProviderOrProducerFieldInitializer.java b/java/dagger/internal/codegen/ProviderOrProducerFieldInitializer.java
new file mode 100644
index 000000000..e1c3ca94f
--- /dev/null
+++ b/java/dagger/internal/codegen/ProviderOrProducerFieldInitializer.java
@@ -0,0 +1,593 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.base.Preconditions.checkState;
+import static com.google.common.base.Verify.verify;
+import static com.google.common.collect.Iterables.getOnlyElement;
+import static com.squareup.javapoet.MethodSpec.constructorBuilder;
+import static com.squareup.javapoet.MethodSpec.methodBuilder;
+import static com.squareup.javapoet.TypeSpec.anonymousClassBuilder;
+import static dagger.internal.codegen.Accessibility.isTypeAccessibleFrom;
+import static dagger.internal.codegen.BindingKey.Kind.CONTRIBUTION;
+import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
+import static dagger.internal.codegen.ContributionBinding.Kind.INJECTION;
+import static dagger.internal.codegen.GeneratedComponentModel.TypeSpecKind.COMPONENT_PROVISION_FACTORY;
+import static dagger.internal.codegen.MapKeys.getMapKeyExpression;
+import static dagger.internal.codegen.MoreAnnotationMirrors.getTypeValue;
+import static dagger.internal.codegen.SourceFiles.generatedClassNameForBinding;
+import static dagger.internal.codegen.SourceFiles.mapFactoryClassName;
+import static dagger.internal.codegen.SourceFiles.setFactoryClassName;
+import static dagger.internal.codegen.SourceFiles.simpleVariableName;
+import static dagger.internal.codegen.TypeNames.DOUBLE_CHECK;
+import static dagger.internal.codegen.TypeNames.INSTANCE_FACTORY;
+import static dagger.internal.codegen.TypeNames.REFERENCE_RELEASING_PROVIDER;
+import static dagger.internal.codegen.TypeNames.SINGLE_CHECK;
+import static dagger.internal.codegen.TypeNames.TYPED_RELEASABLE_REFERENCE_MANAGER_DECORATOR;
+import static dagger.internal.codegen.TypeNames.listenableFutureOf;
+import static dagger.internal.codegen.TypeNames.producerOf;
+import static dagger.internal.codegen.TypeNames.providerOf;
+import static javax.lang.model.element.Modifier.FINAL;
+import static javax.lang.model.element.Modifier.PRIVATE;
+import static javax.lang.model.element.Modifier.PUBLIC;
+import static javax.lang.model.element.Modifier.STATIC;
+
+import com.google.auto.common.MoreElements;
+import com.google.auto.common.MoreTypes;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Lists;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.FieldSpec;
+import com.squareup.javapoet.MethodSpec;
+import com.squareup.javapoet.TypeName;
+import com.squareup.javapoet.TypeSpec;
+import dagger.internal.InstanceFactory;
+import dagger.internal.TypedReleasableReferenceManagerDecorator;
+import dagger.producers.Produced;
+import dagger.producers.Producer;
+import dagger.releasablereferences.ForReleasableReferences;
+import dagger.releasablereferences.ReleasableReferenceManager;
+import dagger.releasablereferences.TypedReleasableReferenceManager;
+import java.util.Arrays;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Optional;
+import javax.inject.Provider;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.TypeMirror;
+
+/**
+ * An initializer for {@link Provider} or {@link Producer} fields other than {@link Producer} fields
+ * that {@linkplain ProducerFromProviderFieldInitializer adapt provision bindings}.
+ */
+// TODO(dpb): Split this up by binding kind.
+final class ProviderOrProducerFieldInitializer extends FrameworkFieldInitializer {
+  private final SubcomponentNames subcomponentNames;
+  private final ComponentRequirementFields componentRequirementFields;
+  // TODO(ronshapiro): add Binding.bindingKey() and use that instead of taking a ResolvedBindings
+  private final ResolvedBindings resolvedBindings;
+  private final CompilerOptions compilerOptions;
+  private final BindingGraph graph;
+  private final OptionalFactories optionalFactories;
+  private final ReferenceReleasingManagerFields referenceReleasingManagerFields;
+
+  ProviderOrProducerFieldInitializer(
+      ResolvedBindings resolvedBindings,
+      SubcomponentNames subcomponentNames,
+      GeneratedComponentModel generatedComponentModel,
+      ComponentBindingExpressions componentBindingExpressions,
+      ComponentRequirementFields componentRequirementFields,
+      ReferenceReleasingManagerFields referenceReleasingManagerFields,
+      CompilerOptions compilerOptions,
+      BindingGraph graph,
+      OptionalFactories optionalFactories) {
+    super(generatedComponentModel, componentBindingExpressions, resolvedBindings);
+    checkArgument(resolvedBindings.bindingKey().kind().equals(CONTRIBUTION));
+    this.subcomponentNames = checkNotNull(subcomponentNames);
+    this.componentRequirementFields = checkNotNull(componentRequirementFields);
+    this.referenceReleasingManagerFields = checkNotNull(referenceReleasingManagerFields);
+    this.resolvedBindings = checkNotNull(resolvedBindings);
+    this.compilerOptions = checkNotNull(compilerOptions);
+    this.graph = checkNotNull(graph);
+    this.optionalFactories = checkNotNull(optionalFactories);
+  }
+
+  @Override
+  protected CodeBlock getFieldInitialization() {
+    ContributionBinding contributionBinding = resolvedBindings.contributionBinding();
+    switch (contributionBinding.factoryCreationStrategy()) {
+      case DELEGATE:
+        CodeBlock delegatingCodeBlock =
+            CodeBlock.of(
+                "($T) $L",
+                contributionBinding.bindingType().frameworkClass(),
+                getDependencyExpression(
+                    getOnlyElement(contributionBinding.frameworkDependencies())));
+        return decorateForScope(delegatingCodeBlock, contributionBinding.scope());
+      case SINGLETON_INSTANCE:
+        checkState(contributionBinding.scope().isPresent());
+        // fall through
+      case CLASS_CONSTRUCTOR:
+        return factoryForContributionBindingInitialization(contributionBinding);
+
+      default:
+        throw new AssertionError();
+    }
+  }
+
+  private CodeBlock factoryForContributionBindingInitialization(ContributionBinding binding) {
+    TypeName bindingKeyTypeName = TypeName.get(binding.key().type());
+    switch (binding.bindingKind()) {
+      case COMPONENT:
+        // This bindingKeyTypeName type parameter can be removed when we drop java 7 source support
+        return CodeBlock.of("$T.<$T>create(this)", INSTANCE_FACTORY, bindingKeyTypeName);
+
+      case COMPONENT_DEPENDENCY:
+        return CodeBlock.of(
+            "$T.create($L)",
+            INSTANCE_FACTORY,
+            componentRequirementFields.getExpressionDuringInitialization(
+                ComponentRequirement.forDependency(binding.key().type()),
+                generatedComponentModel.name()));
+
+      case COMPONENT_PROVISION:
+        {
+          TypeElement dependencyType = dependencyTypeForBinding(binding);
+          String dependencyVariable = simpleVariableName(dependencyType);
+          String componentMethod = binding.bindingElement().get().getSimpleName().toString();
+          // TODO(sameb): The Provider.get() throws a very vague NPE.  The stack trace doesn't
+          // help to figure out what the method or return type is.  If we include a string
+          // of the return type or method name in the error message, that can defeat obfuscation.
+          // We can easily include the raw type (no generics) + annotation type (no values),
+          // using .class & String.format -- but that wouldn't be the whole story.
+          // What should we do?
+          CodeBlock invocation =
+              ComponentProvisionBindingExpression.maybeCheckForNull(
+                  (ProvisionBinding) binding,
+                  compilerOptions,
+                  CodeBlock.of("$L.$L()", dependencyVariable, componentMethod));
+          ClassName dependencyClassName = ClassName.get(dependencyType);
+          String factoryName =
+              dependencyClassName.toString().replace('.', '_') + "_" + componentMethod;
+          MethodSpec.Builder getMethod =
+              methodBuilder("get")
+                  .addAnnotation(Override.class)
+                  .addModifiers(PUBLIC)
+                  .returns(bindingKeyTypeName)
+                  .addStatement("return $L", invocation);
+          if (binding.nullableType().isPresent()) {
+            getMethod.addAnnotation(
+                ClassName.get(MoreTypes.asTypeElement(binding.nullableType().get())));
+          }
+          generatedComponentModel.addType(
+              COMPONENT_PROVISION_FACTORY,
+              TypeSpec.classBuilder(factoryName)
+                  .addSuperinterface(providerOf(bindingKeyTypeName))
+                  .addModifiers(PRIVATE, STATIC)
+                  .addField(dependencyClassName, dependencyVariable, PRIVATE, FINAL)
+                  .addMethod(
+                      constructorBuilder()
+                          .addParameter(dependencyClassName, dependencyVariable)
+                          .addStatement("this.$1L = $1L", dependencyVariable)
+                          .build())
+                  .addMethod(getMethod.build())
+                  .build());
+          return CodeBlock.of(
+              "new $L($L)",
+              factoryName,
+              componentRequirementFields.getExpressionDuringInitialization(
+                  ComponentRequirement.forDependency(dependencyType.asType()),
+                  generatedComponentModel.name()));
+        }
+
+      case SUBCOMPONENT_BUILDER:
+        String subcomponentName =
+            subcomponentNames.get(
+                graph
+                    .componentDescriptor()
+                    .subcomponentsByBuilderType()
+                    .get(MoreTypes.asTypeElement(binding.key().type())));
+        return CodeBlock.of(
+            "$L",
+            anonymousClassBuilder("")
+                .superclass(providerOf(bindingKeyTypeName))
+                .addMethod(
+                    methodBuilder("get")
+                        .addAnnotation(Override.class)
+                        .addModifiers(PUBLIC)
+                        .returns(bindingKeyTypeName)
+                        .addStatement("return new $LBuilder()", subcomponentName)
+                        .build())
+                .build());
+
+      case BUILDER_BINDING:
+        return CodeBlock.of(
+            "$T.$L($L)",
+            InstanceFactory.class,
+            binding.nullableType().isPresent() ? "createNullable" : "create",
+            componentRequirementFields.getExpressionDuringInitialization(
+                ComponentRequirement.forBinding(binding), generatedComponentModel.name()));
+
+      case INJECTION:
+      case PROVISION:
+        {
+          List<CodeBlock> arguments =
+              Lists.newArrayListWithCapacity(binding.explicitDependencies().size() + 1);
+          if (binding.requiresModuleInstance()) {
+            arguments.add(
+                componentRequirementFields.getExpressionDuringInitialization(
+                    ComponentRequirement.forModule(binding.contributingModule().get().asType()),
+                    generatedComponentModel.name()));
+          }
+          arguments.addAll(getBindingDependencyExpressions(binding));
+
+          CodeBlock factoryCreate =
+              CodeBlock.of(
+                  "$T.create($L)",
+                  generatedClassNameForBinding(binding),
+                  makeParametersCodeBlock(arguments));
+
+          // If scoping a parameterized factory for an @Inject class, Java 7 cannot always infer the
+          // type properly, so cast to a raw framework type before scoping.
+          if (binding.bindingKind().equals(INJECTION)
+              && binding.unresolved().isPresent()
+              && binding.scope().isPresent()) {
+            factoryCreate =
+                CodeBlock.of("($T) $L", binding.bindingType().frameworkClass(), factoryCreate);
+          }
+          return decorateForScope(factoryCreate, binding.scope());
+        }
+
+      case COMPONENT_PRODUCTION:
+        {
+          TypeElement dependencyType = dependencyTypeForBinding(binding);
+          FieldSpec dependencyField =
+              FieldSpec.builder(
+                      ClassName.get(dependencyType),
+                      simpleVariableName(dependencyType),
+                      PRIVATE,
+                      FINAL)
+                  .initializer(
+                      componentRequirementFields.getExpressionDuringInitialization(
+                          ComponentRequirement.forDependency(dependencyType.asType()),
+                          generatedComponentModel.name()))
+                  .build();
+          return CodeBlock.of(
+              "$L",
+              anonymousClassBuilder("")
+                  .superclass(producerOf(bindingKeyTypeName))
+                  .addField(dependencyField)
+                  .addMethod(
+                      methodBuilder("get")
+                          .addAnnotation(Override.class)
+                          .addModifiers(PUBLIC)
+                          .returns(listenableFutureOf(bindingKeyTypeName))
+                          .addStatement(
+                              "return $N.$L()",
+                              dependencyField,
+                              binding.bindingElement().get().getSimpleName())
+                          .build())
+                  .build());
+        }
+
+      case PRODUCTION:
+        {
+          List<CodeBlock> arguments =
+              Lists.newArrayListWithCapacity(binding.dependencies().size() + 2);
+          if (binding.requiresModuleInstance()) {
+            arguments.add(
+                componentRequirementFields.getExpressionDuringInitialization(
+                    ComponentRequirement.forModule(binding.contributingModule().get().asType()),
+                    generatedComponentModel.name()));
+          }
+          arguments.addAll(getBindingDependencyExpressions(binding));
+
+          return CodeBlock.of(
+              "new $T($L)",
+              generatedClassNameForBinding(binding),
+              makeParametersCodeBlock(arguments));
+        }
+
+      case SYNTHETIC_MULTIBOUND_SET:
+        return factoryForSetMultibindingInitialization(binding);
+
+      case SYNTHETIC_MULTIBOUND_MAP:
+        return factoryForMapMultibindingInitialization(binding);
+
+      case SYNTHETIC_RELEASABLE_REFERENCE_MANAGER:
+        return factoryForSyntheticReleasableReferenceManagerBindingInitialization(binding);
+
+      case SYNTHETIC_RELEASABLE_REFERENCE_MANAGERS:
+        return factoryForSyntheticSetOfReleasableReferenceManagersInitialization(binding);
+
+      case SYNTHETIC_OPTIONAL_BINDING:
+        return factoryForSyntheticOptionalBindingInitialization(binding);
+
+      default:
+        throw new AssertionError(binding);
+    }
+  }
+
+  /**
+   * Maybe wraps the given creation code block in single/double check or reference releasing
+   * providers.
+   */
+  private CodeBlock decorateForScope(CodeBlock factoryCreate, Optional<Scope> maybeScope) {
+    if (!maybeScope.isPresent()) {
+      return factoryCreate;
+    }
+    Scope scope = maybeScope.get();
+    if (referenceReleasingManagerFields.requiresReleasableReferences(scope)) {
+      return CodeBlock.of(
+          "$T.create($L, $L)",
+          REFERENCE_RELEASING_PROVIDER,
+          factoryCreate,
+          referenceReleasingManagerFields.getExpression(scope, generatedComponentModel.name()));
+    } else {
+      return CodeBlock.of(
+          "$T.provider($L)", scope.isReusable() ? SINGLE_CHECK : DOUBLE_CHECK, factoryCreate);
+    }
+  }
+
+  private TypeElement dependencyTypeForBinding(ContributionBinding binding) {
+    return graph.componentDescriptor().dependencyMethodIndex().get(binding.bindingElement().get());
+  }
+
+  private CodeBlock factoryForSetMultibindingInitialization(ContributionBinding binding) {
+    CodeBlock.Builder builder = CodeBlock.builder().add("$T.", setFactoryClassName(binding));
+    boolean useRawTypes = useRawType();
+    if (!useRawTypes) {
+      SetType setType = SetType.from(binding.key());
+      builder.add(
+          "<$T>",
+          setType.elementsAreTypeOf(Produced.class)
+              ? setType.unwrappedElementType(Produced.class)
+              : setType.elementType());
+    }
+    int individualProviders = 0;
+    int setProviders = 0;
+    CodeBlock.Builder builderMethodCalls = CodeBlock.builder();
+    for (FrameworkDependency frameworkDependency : binding.frameworkDependencies()) {
+      ContributionType contributionType =
+          graph.resolvedBindings().get(frameworkDependency.bindingKey()).contributionType();
+      String methodName;
+      String methodNameSuffix = frameworkDependency.frameworkClass().getSimpleName();
+      switch (contributionType) {
+        case SET:
+          individualProviders++;
+          methodName = "add" + methodNameSuffix;
+          break;
+        case SET_VALUES:
+          setProviders++;
+          methodName = "addCollection" + methodNameSuffix;
+          break;
+        default:
+          throw new AssertionError(frameworkDependency + " is not a set multibinding");
+      }
+
+      builderMethodCalls.add(
+          ".$L($L)",
+          methodName,
+          potentiallyCast(
+              useRawTypes,
+              frameworkDependency.frameworkClass(),
+              getDependencyExpression(frameworkDependency)));
+    }
+    builder.add("builder($L, $L)", individualProviders, setProviders);
+    builder.add(builderMethodCalls.build());
+    return builder.add(".build()").build();
+  }
+
+  private CodeBlock factoryForMapMultibindingInitialization(ContributionBinding binding) {
+    ImmutableList<FrameworkDependency> frameworkDependencies = binding.frameworkDependencies();
+
+    ImmutableList.Builder<CodeBlock> codeBlocks = ImmutableList.builder();
+    MapType mapType = MapType.from(binding.key().type());
+    CodeBlock.Builder builderCall = CodeBlock.builder().add("$T.", mapFactoryClassName(binding));
+    boolean useRawTypes = useRawType();
+    if (!useRawTypes) {
+      // TODO(ronshapiro): either inline this into mapFactoryClassName, or add a
+      // mapType.unwrappedValueType() method that doesn't require a framework type
+      TypeMirror valueType = mapType.valueType();
+      for (Class<?> frameworkClass :
+          ImmutableSet.of(Provider.class, Producer.class, Produced.class)) {
+        if (mapType.valuesAreTypeOf(frameworkClass)) {
+          valueType = mapType.unwrappedValueType(frameworkClass);
+          break;
+        }
+      }
+      builderCall.add("<$T, $T>", mapType.keyType(), valueType);
+    }
+
+    if (binding.bindingType().equals(BindingType.PROVISION)) {
+      builderCall.add("builder($L)", frameworkDependencies.size());
+    } else {
+      builderCall.add("builder()");
+    }
+    codeBlocks.add(builderCall.build());
+
+    for (FrameworkDependency frameworkDependency : frameworkDependencies) {
+      BindingKey bindingKey = frameworkDependency.bindingKey();
+      ContributionBinding contributionBinding =
+          graph.resolvedBindings().get(bindingKey).contributionBinding();
+      CodeBlock value =
+          potentiallyCast(
+              useRawTypes,
+              frameworkDependency.frameworkClass(),
+              getDependencyExpression(frameworkDependency));
+      codeBlocks.add(
+          CodeBlock.of(
+              ".put($L, $L)",
+              getMapKeyExpression(contributionBinding, generatedComponentModel.name()),
+              value));
+    }
+    codeBlocks.add(CodeBlock.of(".build()"));
+
+    return CodeBlocks.concat(codeBlocks.build());
+  }
+
+  // TODO(ronshapiro): Use functionality from Expression
+  private CodeBlock potentiallyCast(boolean shouldCast, Class<?> classToCast, CodeBlock notCasted) {
+    if (!shouldCast) {
+      return notCasted;
+    }
+    return CodeBlock.of("($T) $L", classToCast, notCasted);
+  }
+
+  private boolean useRawType() {
+
+    return !isTypeAccessibleFrom(
+        resolvedBindings.key().type(), generatedComponentModel.name().packageName());
+  }
+
+  /**
+   * Initializes the factory for a {@link
+   * ContributionBinding.Kind#SYNTHETIC_RELEASABLE_REFERENCE_MANAGER} binding.
+   *
+   * <p>The {@code get()} method just returns the component field with the {@link
+   * dagger.internal.ReferenceReleasingProviderManager} object.
+   */
+  private CodeBlock factoryForSyntheticReleasableReferenceManagerBindingInitialization(
+      ContributionBinding binding) {
+    // The scope is the value of the @ForReleasableReferences annotation.
+    Scope scope = forReleasableReferencesAnnotationValue(binding.key().qualifier().get());
+
+    CodeBlock managerExpression;
+    if (MoreTypes.isTypeOf(TypedReleasableReferenceManager.class, binding.key().type())) {
+      /* The key's type is TypedReleasableReferenceManager<M>, so return
+       * new TypedReleasableReferenceManager(field, metadata). */
+      TypeMirror metadataType =
+          MoreTypes.asDeclared(binding.key().type()).getTypeArguments().get(0);
+      managerExpression =
+          typedReleasableReferenceManagerDecoratorExpression(
+              referenceReleasingManagerFields.getExpression(scope, generatedComponentModel.name()),
+              scope.releasableReferencesMetadata(metadataType).get());
+    } else {
+      // The key's type is ReleasableReferenceManager, so return the field as is.
+      managerExpression =
+          referenceReleasingManagerFields.getExpression(scope, generatedComponentModel.name());
+    }
+
+    TypeName keyType = TypeName.get(binding.key().type());
+    return CodeBlock.of(
+        "$L",
+        anonymousClassBuilder("")
+            .addSuperinterface(providerOf(keyType))
+            .addMethod(
+                methodBuilder("get")
+                    .addAnnotation(Override.class)
+                    .addModifiers(PUBLIC)
+                    .returns(keyType)
+                    .addCode("return $L;", managerExpression)
+                    .build())
+            .build());
+  }
+
+  /**
+   * Initializes the factory for a {@link
+   * ContributionBinding.Kind#SYNTHETIC_RELEASABLE_REFERENCE_MANAGERS} binding.
+   *
+   * <p>A binding for {@code Set<ReleasableReferenceManager>} will include managers for all
+   * reference-releasing scopes. A binding for {@code Set<TypedReleasableReferenceManager<M>>} will
+   * include managers for all reference-releasing scopes whose metadata type is {@code M}.
+   */
+  private CodeBlock factoryForSyntheticSetOfReleasableReferenceManagersInitialization(
+      ContributionBinding binding) {
+    Key key = binding.key();
+    SetType keyType = SetType.from(key);
+    ImmutableList.Builder<CodeBlock> managerExpressions = ImmutableList.builder();
+    for (Scope scope : graph.scopesRequiringReleasableReferenceManagers()) {
+      CodeBlock releasableReferenceManagerExpression =
+          referenceReleasingManagerFields.getExpression(scope, generatedComponentModel.name());
+
+      if (keyType.elementsAreTypeOf(ReleasableReferenceManager.class)) {
+        managerExpressions.add(releasableReferenceManagerExpression);
+      } else if (keyType.elementsAreTypeOf(TypedReleasableReferenceManager.class)) {
+        TypeMirror metadataType =
+            keyType.unwrappedElementType(TypedReleasableReferenceManager.class);
+        Optional<AnnotationMirror> metadata = scope.releasableReferencesMetadata(metadataType);
+        if (metadata.isPresent()) {
+          managerExpressions.add(
+              typedReleasableReferenceManagerDecoratorExpression(
+                  releasableReferenceManagerExpression, metadata.get()));
+        }
+      } else {
+        throw new IllegalArgumentException("inappropriate key: " + binding);
+      }
+    }
+    TypeName keyTypeName = TypeName.get(key.type());
+    return CodeBlock.of(
+        "$L",
+        anonymousClassBuilder("")
+            .addSuperinterface(providerOf(keyTypeName))
+            .addMethod(
+                methodBuilder("get")
+                    .addAnnotation(Override.class)
+                    .addModifiers(PUBLIC)
+                    .returns(keyTypeName)
+                    .addCode(
+                        "return new $T($T.asList($L));",
+                        HashSet.class,
+                        Arrays.class,
+                        makeParametersCodeBlock(managerExpressions.build()))
+                    .build())
+            .build());
+  }
+
+  /**
+   * Returns an expression that evaluates to a {@link TypedReleasableReferenceManagerDecorator} that
+   * decorates the {@code managerExpression} to supply {@code metadata}.
+   */
+  private CodeBlock typedReleasableReferenceManagerDecoratorExpression(
+      CodeBlock managerExpression, AnnotationMirror metadata) {
+    return CodeBlock.of(
+        "new $T<$T>($L, $L)",
+        TYPED_RELEASABLE_REFERENCE_MANAGER_DECORATOR,
+        metadata.getAnnotationType(),
+        managerExpression,
+        new AnnotationExpression(metadata).getAnnotationInstanceExpression());
+  }
+
+  private Scope forReleasableReferencesAnnotationValue(AnnotationMirror annotation) {
+    checkArgument(
+        MoreTypes.isTypeOf(ForReleasableReferences.class, annotation.getAnnotationType()));
+    return Scope.scope(
+        MoreElements.asType(MoreTypes.asDeclared(getTypeValue(annotation, "value")).asElement()));
+  }
+
+  /**
+   * Returns an expression that initializes a {@link Provider} or {@link Producer} for an optional
+   * binding.
+   */
+  private CodeBlock factoryForSyntheticOptionalBindingInitialization(ContributionBinding binding) {
+    if (binding.explicitDependencies().isEmpty()) {
+      verify(
+          binding.bindingType().equals(BindingType.PROVISION),
+          "Absent optional bindings should be provisions: %s",
+          binding);
+      return optionalFactories.absentOptionalProvider(binding);
+    } else {
+      return optionalFactories.presentOptionalFactory(
+          binding, getDependencyExpression(getOnlyElement(binding.frameworkDependencies())));
+    }
+  }
+}
