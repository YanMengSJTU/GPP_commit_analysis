diff --git a/CHANGELOG.md b/CHANGELOG.md
index 2bb845ff5..a3d9ba3f8 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -4,6 +4,11 @@ Change Log
 Dagger 2 (Components)
 ---------------------
 
+### Version 2.3 *(2016-04-08)*
+  * Adds [`@Reusable`]
+  (http://google.github.io/dagger/users-guide.html#reusable-scope) scope
+  [(javadoc)](http://google.github.io/dagger/api/latest/dagger/Reusable.html)
+
 ### Version 2.2 *(2016-03-22)*
   * `dagger.mapkeys` moved to `dagger.multibindings` and all `@MapKey`
     implementations now correctly have `@Beta` applied
diff --git a/compiler/pom.xml b/compiler/pom.xml
index d8a74e902..91dbd4df1 100644
--- a/compiler/pom.xml
+++ b/compiler/pom.xml
@@ -21,7 +21,7 @@
   <parent>
     <groupId>com.google.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>2.2-SNAPSHOT</version>
+    <version>2.4-SNAPSHOT</version>
   </parent>
 
   <artifactId>dagger-compiler</artifactId>
@@ -99,7 +99,7 @@
     <dependency>
       <groupId>com.squareup</groupId>
       <artifactId>javapoet</artifactId>
-      <version>1.5.1</version>
+      <version>1.6.1</version>
     </dependency>
     <dependency>
       <groupId>org.mockito</groupId>
diff --git a/compiler/src/it/functional-tests/pom.xml b/compiler/src/it/functional-tests/pom.xml
index ae30d1571..8f3252eee 100644
--- a/compiler/src/it/functional-tests/pom.xml
+++ b/compiler/src/it/functional-tests/pom.xml
@@ -22,7 +22,7 @@ limitations under the License.
   <parent>
     <groupId>com.google.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>2.2-SNAPSHOT</version>
+    <version>2.4-SNAPSHOT</version>
   </parent>
   <groupId>dagger.tests</groupId>
   <artifactId>functional-tests</artifactId>
diff --git a/compiler/src/it/functional-tests/src/main/java/test/BasicComponent.java b/compiler/src/it/functional-tests/src/main/java/test/BasicComponent.java
index b9b54d914..5629a0f09 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/BasicComponent.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/BasicComponent.java
@@ -74,6 +74,7 @@
   InjectedThing injectedThing();
   Provider<InjectedThing> injectedThingProvider();
   Lazy<InjectedThing> lazyInjectedThing();
+  Provider<Lazy<InjectedThing>> lazyInjectedThingProvider();
   MembersInjector<InjectedThing> injectedThingMembersInjector();
   
   @Nullable Object nullObject();
diff --git a/compiler/src/it/functional-tests/src/main/java/test/InjectedThing.java b/compiler/src/it/functional-tests/src/main/java/test/InjectedThing.java
index 73a46e8aa..438b69f16 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/InjectedThing.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/InjectedThing.java
@@ -88,6 +88,7 @@
   @Inject Thing thing;
   @Inject Provider<Thing> thingProvider;
   @Inject Lazy<Thing> lazyThing;
+  @Inject Provider<Lazy<Thing>> lazyThingProvider;
   @Inject MembersInjector<Thing> thingMembersInjector;
 
   @Inject InjectedThing(
diff --git a/compiler/src/it/functional-tests/src/main/java/test/MultibindingModule.java b/compiler/src/it/functional-tests/src/main/java/test/MultibindingModule.java
index b5ca08ed8..6f1766612 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/MultibindingModule.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/MultibindingModule.java
@@ -20,55 +20,86 @@
 import dagger.Provides;
 import dagger.multibindings.ClassKey;
 import dagger.multibindings.IntKey;
+import dagger.multibindings.IntoMap;
+import dagger.multibindings.IntoSet;
 import dagger.multibindings.LongKey;
 import dagger.multibindings.StringKey;
+
 import java.math.BigDecimal;
 import java.math.BigInteger;
 import java.util.Collection;
+import java.util.HashSet;
 import java.util.Map;
 import java.util.Set;
+
 import javax.inject.Named;
 import javax.inject.Provider;
 
 import static dagger.Provides.Type.MAP;
 import static dagger.Provides.Type.SET;
+import static dagger.Provides.Type.SET_VALUES;
 
 @Module
 class MultibindingModule {
-  @Provides(type = MAP)
+  @Provides
+  @IntoMap
   @StringKey("foo")
   static String provideFooKey(double doubleDependency) {
     return "foo value";
   }
 
   @Provides(type = MAP)
+  @StringKey("foo @Provides(type)")
+  static String provideFooProvidesTypeKey(double doubleDependency) {
+    return "foo @Provides(type) value";
+  }
+
+  @Provides
+  @IntoMap
   @StringKey("bar")
   static String provideBarKey() {
     return "bar value";
   }
 
-  @Provides(type = MAP)
+  @Provides
+  @IntoMap
   @StringKey("foo")
   static String[] provideFooArrayValue(double doubleDependency) {
     return new String[] {"foo1", "foo2"};
   }
 
-  @Provides(type = MAP)
+  @Provides
+  @IntoMap
   @StringKey("bar")
   static String[] provideBarArrayValue() {
     return new String[] {"bar1", "bar2"};
   }
 
-  @Provides(type = SET)
+  @Provides
+  @IntoSet
   static int provideFiveToSet() {
     return 5;
   }
 
-  @Provides(type = SET)
+  @Provides
+  @IntoSet
   static int provideSixToSet() {
     return 6;
   }
 
+  @Provides(type = SET)
+  static int provideIntoSetWithProvidesType() {
+    return -100;
+  }
+
+  @Provides(type = SET_VALUES)
+  static Set<Integer> provideElementsIntoSetWithProvidesType() {
+    Set<Integer> set = new HashSet<>();
+    set.add(-101);
+    set.add(-102);
+    return set;
+  }
+
   @Provides
   static Set<String> provideMapKeys(Map<String, Provider<String>> map) {
     return map.keySet();
@@ -79,91 +110,106 @@ static int provideSixToSet() {
     return map.values();
   }
 
-  @Provides(type = MAP)
+  @Provides
+  @IntoMap
   @NestedAnnotationContainer.NestedWrappedKey(Integer.class)
   static String valueForInteger() {
     return "integer";
   }
 
-  @Provides(type = MAP)
+  @Provides
+  @IntoMap
   @NestedAnnotationContainer.NestedWrappedKey(Long.class)
   static String valueForLong() {
     return "long";
   }
 
-  @Provides(type = MAP)
+  @Provides
+  @IntoMap
   @ClassKey(Integer.class)
   static String valueForClassInteger() {
     return "integer";
   }
 
-  @Provides(type = MAP)
+  @Provides
+  @IntoMap
   @ClassKey(Long.class)
   static String valueForClassLong() {
     return "long";
   }
 
-  @Provides(type = MAP)
+  @Provides
+  @IntoMap
   @NumberClassKey(BigDecimal.class)
   static String valueForNumberClassBigDecimal() {
     return "bigdecimal";
   }
 
-  @Provides(type = MAP)
+  @Provides
+  @IntoMap
   @NumberClassKey(BigInteger.class)
   static String valueForNumberClassBigInteger() {
     return "biginteger";
   }
 
-  @Provides(type = MAP)
+  @Provides
+  @IntoMap
   @LongKey(100)
   static String valueFor100Long() {
     return "100 long";
   }
 
-  @Provides(type = MAP)
+  @Provides
+  @IntoMap
   @IntKey(100)
   static String valueFor100Int() {
     return "100 int";
   }
 
-  @Provides(type = MAP)
+  @Provides
+  @IntoMap
   @ShortKey(100)
   static String valueFor100Short() {
     return "100 short";
   }
 
-  @Provides(type = MAP)
+  @Provides
+  @IntoMap
   @ByteKey(100)
   static String valueFor100Byte() {
     return "100 byte";
   }
 
-  @Provides(type = MAP)
+  @Provides
+  @IntoMap
   @BooleanKey(true)
   static String valueForTrue() {
     return "true";
   }
 
-  @Provides(type = MAP)
+  @Provides
+  @IntoMap
   @CharKey('a')
   static String valueForA() {
     return "a char";
   }
 
-  @Provides(type = MAP)
+  @Provides
+  @IntoMap
   @CharKey('\n')
   static String valueForNewline() {
     return "newline char";
   }
 
-  @Provides(type = MAP)
+  @Provides
+  @IntoMap
   @UnwrappedAnnotationKey(@StringKey("foo\n"))
   static String valueForUnwrappedAnnotationKeyFoo() {
     return "foo annotation";
   }
 
-  @Provides(type = MAP)
+  @Provides
+  @IntoMap
   @WrappedAnnotationKey(
     value = @StringKey("foo"),
     integers = {1, 2, 3},
@@ -174,30 +220,35 @@ static String valueForWrappedAnnotationKeyFoo() {
     return "wrapped foo annotation";
   }
 
-  @Provides(type = SET)
+  @Provides
+  @IntoSet
   @Named("complexQualifier")
   static String valueForComplexQualifierSet() {
     return "foo";
   }
 
-  @Provides(type = SET)
+  @Provides
+  @IntoSet
   static CharSequence setContribution() {
     return "foo";
   }
 
-  @Provides(type = SET)
+  @Provides
+  @IntoSet
   @Named("complexQualifier")
   static CharSequence qualifiedSetContribution() {
     return "qualified foo";
   }
 
-  @Provides(type = MAP)
+  @Provides
+  @IntoMap
   @StringKey("key")
   static CharSequence mapContribution() {
     return "foo value";
   }
 
-  @Provides(type = MAP)
+  @Provides
+  @IntoMap
   @Named("complexQualifier")
   @StringKey("key")
   static CharSequence qualifiedMapContribution() {
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/SomeQualifier.java b/compiler/src/it/functional-tests/src/main/java/test/SomeQualifier.java
similarity index 93%
rename from compiler/src/it/functional-tests/src/main/java/test/subcomponent/SomeQualifier.java
rename to compiler/src/it/functional-tests/src/main/java/test/SomeQualifier.java
index 83606e538..cf68c3056 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/SomeQualifier.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/SomeQualifier.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package test.subcomponent;
+package test;
 
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
@@ -24,4 +24,4 @@
 @Documented
 @Retention(RUNTIME)
 @Qualifier
-@interface SomeQualifier {}
+public @interface SomeQualifier {}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/bind/Foo.java b/compiler/src/it/functional-tests/src/main/java/test/bind/Foo.java
new file mode 100644
index 000000000..b0b126a0c
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/bind/Foo.java
@@ -0,0 +1,21 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.bind;
+
+/**
+ * This is the type that will be bound.  We throw in generics just to complicate the test.
+ */
+interface Foo<T> {}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/bind/FooOfObjects.java b/compiler/src/it/functional-tests/src/main/java/test/bind/FooOfObjects.java
new file mode 100644
index 000000000..14b98c944
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/bind/FooOfObjects.java
@@ -0,0 +1,23 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package test.bind;
+
+import javax.inject.Inject;
+
+final class FooOfObjects implements Foo<Object> {
+  @Inject FooOfObjects() {}
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/bind/FooOfStrings.java b/compiler/src/it/functional-tests/src/main/java/test/bind/FooOfStrings.java
new file mode 100644
index 000000000..2bf81689a
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/bind/FooOfStrings.java
@@ -0,0 +1,23 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.bind;
+
+import javax.inject.Inject;
+
+final class FooOfStrings implements Foo<String> {
+  @Inject
+  FooOfStrings() {}
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/bind/InterfaceModule.java b/compiler/src/it/functional-tests/src/main/java/test/bind/InterfaceModule.java
new file mode 100644
index 000000000..48e705cd5
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/bind/InterfaceModule.java
@@ -0,0 +1,24 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.bind;
+
+import dagger.Binds;
+import dagger.Module;
+
+@Module
+interface InterfaceModule {
+  @Binds Foo<Object> bindFooOfObjects(FooOfObjects impl);
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/bind/SimpleBindingModule.java b/compiler/src/it/functional-tests/src/main/java/test/bind/SimpleBindingModule.java
new file mode 100644
index 000000000..f884c8b8c
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/bind/SimpleBindingModule.java
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.bind;
+
+import dagger.Binds;
+import dagger.Module;
+import dagger.Provides;
+import javax.inject.Singleton;
+import test.SomeQualifier;
+
+@Module(includes = InterfaceModule.class)
+abstract class SimpleBindingModule {
+  @Binds
+  abstract Object bindObject(FooOfStrings impl);
+
+  @Binds
+  abstract Foo<String> bindFooOfStrings(FooOfStrings impl);
+
+  @Binds
+  abstract Foo<? extends Number> bindFooOfNumbers(Foo<Integer> fooOfIntegers);
+
+  @Binds
+  @Singleton
+  @SomeQualifier
+  abstract Foo<String> bindQualifiedFooOfStrings(FooOfStrings impl);
+
+  @Provides
+  static Foo<Integer> provideFooOfIntegers() {
+    return new Foo<Integer>() {};
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/bind/TestComponent.java b/compiler/src/it/functional-tests/src/main/java/test/bind/TestComponent.java
new file mode 100644
index 000000000..d92e6029f
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/bind/TestComponent.java
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.bind;
+
+import dagger.Component;
+import javax.inject.Singleton;
+import test.SomeQualifier;
+
+@Singleton
+@Component(modules = SimpleBindingModule.class)
+public interface TestComponent {
+  Object object();
+
+  Foo<String> fooOfStrings();
+
+  Foo<Object> fooOfObjects();
+
+  @SomeQualifier
+  Foo<String> qualifiedFooOfStrings();
+
+  Foo<Integer> fooOfIntegers();
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/cycle/Cycles.java b/compiler/src/it/functional-tests/src/main/java/test/cycle/Cycles.java
index 95d6508cf..63bf45c87 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/cycle/Cycles.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/cycle/Cycles.java
@@ -20,13 +20,12 @@
 import dagger.Module;
 import dagger.Provides;
 import dagger.Subcomponent;
+import dagger.multibindings.IntoMap;
 import dagger.multibindings.StringKey;
 import java.util.Map;
 import javax.inject.Inject;
 import javax.inject.Provider;
 
-import static dagger.Provides.Type.MAP;
-
 /**
  * Cycle classes used for testing cyclic dependencies.
  * A <- (E <- D <- B <- C <- Provider<A>, Lazy<A>), (B <- C <- Provider<A>, Lazy<A>)
@@ -119,13 +118,15 @@ private Cycles() {}
 
   @Module
   static class CycleMapModule {
-    @Provides(type = MAP)
+    @Provides
+    @IntoMap
     @StringKey("X")
     static X x(X x) {
       return x;
     }
 
-    @Provides(type = MAP)
+    @Provides
+    @IntoMap
     @StringKey("Y")
     static Y y(Y y) {
       return y;
diff --git a/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/AModule.java b/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/AModule.java
index d62506a56..01208d919 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/AModule.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/AModule.java
@@ -18,12 +18,13 @@
 
 import dagger.Module;
 import dagger.Provides;
-
-import static dagger.Provides.Type.SET;
+import dagger.multibindings.IntoSet;
 
 @Module
 public final class AModule {
-  @Provides(type = SET) String provideString() {
+  @Provides
+  @IntoSet
+  static String provideString() {
     return "a";
   }
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/multipackage/b/BModule.java b/compiler/src/it/functional-tests/src/main/java/test/multipackage/b/BModule.java
index 4d817f153..6217bf830 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/multipackage/b/BModule.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/multipackage/b/BModule.java
@@ -18,12 +18,13 @@
 
 import dagger.Module;
 import dagger.Provides;
-
-import static dagger.Provides.Type.SET;
+import dagger.multibindings.IntoSet;
 
 @Module
 public final class BModule {
-  @Provides(type = SET) String provideString() {
+  @Provides
+  @IntoSet
+  static String provideString() {
     return "b";
   }
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/multipackage/c/CModule.java b/compiler/src/it/functional-tests/src/main/java/test/multipackage/c/CModule.java
index e608afb2c..edfb9233d 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/multipackage/c/CModule.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/multipackage/c/CModule.java
@@ -18,13 +18,13 @@
 
 import dagger.Module;
 import dagger.Provides;
-import java.util.Set;
-
-import static dagger.Provides.Type.SET;
+import dagger.multibindings.IntoSet;
 
 @Module
 public final class CModule {
-  @Provides(type = SET) String provideString() {
+  @Provides
+  @IntoSet
+  static String provideString() {
     return "c";
   }
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/multipackage/d/DModule.java b/compiler/src/it/functional-tests/src/main/java/test/multipackage/d/DModule.java
index 51f8ace76..7c9f4343e 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/multipackage/d/DModule.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/multipackage/d/DModule.java
@@ -18,13 +18,13 @@
 
 import dagger.Module;
 import dagger.Provides;
-import java.util.Set;
-
-import static dagger.Provides.Type.SET;
+import dagger.multibindings.IntoSet;
 
 @Module
 public final class DModule {
-  @Provides(type = SET) String provideString() {
+  @Provides
+  @IntoSet
+  static String provideString() {
     return "d";
   }
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/scope/BlueModule.java b/compiler/src/it/functional-tests/src/main/java/test/scope/BlueModule.java
index c5fa3fa68..f80824118 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/scope/BlueModule.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/scope/BlueModule.java
@@ -17,12 +17,12 @@
 
 import dagger.Module;
 import dagger.Provides;
-
-import static dagger.Provides.Type.SET;
+import dagger.multibindings.IntoSet;
 
 @Module
 final class BlueModule {
-  @Provides(type = SET)
+  @Provides
+  @IntoSet
   @BlueScope
   static Object blue() {
     return new Object();
diff --git a/compiler/src/it/functional-tests/src/main/java/test/scope/GreenModule.java b/compiler/src/it/functional-tests/src/main/java/test/scope/GreenModule.java
index 9a160ff4b..919a9a178 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/scope/GreenModule.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/scope/GreenModule.java
@@ -17,12 +17,12 @@
 
 import dagger.Module;
 import dagger.Provides;
-
-import static dagger.Provides.Type.SET;
+import dagger.multibindings.IntoSet;
 
 @Module
 final class GreenModule  {
-  @Provides(type = SET)
+  @Provides
+  @IntoSet
   @GreenScope
   static Object green() {
     return new Object();
diff --git a/compiler/src/it/functional-tests/src/main/java/test/scope/TurquoiseModule.java b/compiler/src/it/functional-tests/src/main/java/test/scope/TurquoiseModule.java
index 7947ccfbd..77af9e76a 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/scope/TurquoiseModule.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/scope/TurquoiseModule.java
@@ -17,18 +17,19 @@
 
 import dagger.Module;
 import dagger.Provides;
-
-import static dagger.Provides.Type.SET;
+import dagger.multibindings.IntoSet;
 
 @Module
 final class TurquoiseModule {
-  @Provides(type = SET)
+  @Provides
+  @IntoSet
   @BlueScope
   static Object blue() {
     return new Object();
   }
 
-  @Provides(type = SET)
+  @Provides
+  @IntoSet
   @GreenScope
   static Object green() {
     return new Object();
diff --git a/compiler/src/it/functional-tests/src/main/java/test/staticprovides/AllStaticModule.java b/compiler/src/it/functional-tests/src/main/java/test/staticprovides/AllStaticModule.java
index f47d36c6a..4844e0563 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/staticprovides/AllStaticModule.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/staticprovides/AllStaticModule.java
@@ -15,21 +15,26 @@
  */
 package test.staticprovides;
 
-import static dagger.Provides.Type.SET;
-import static dagger.Provides.Type.SET_VALUES;
 import static java.util.Collections.emptySet;
 
 import dagger.Module;
 import dagger.Provides;
+import dagger.multibindings.ElementsIntoSet;
+import dagger.multibindings.IntoSet;
+
 import java.util.Set;
 
 @Module
 final class AllStaticModule {
-  @Provides(type = SET) static String contributeString() {
+  @Provides
+  @IntoSet
+  static String contributeString() {
     return AllStaticModule.class + ".contributeString";
   }
 
-  @Provides(type = SET_VALUES) static Set<Integer> contibuteEmptyIntegerSet() {
+  @Provides
+  @ElementsIntoSet
+  static Set<Integer> contibuteEmptyIntegerSet() {
     return emptySet();
   }
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/staticprovides/SomeStaticModule.java b/compiler/src/it/functional-tests/src/main/java/test/staticprovides/SomeStaticModule.java
index 53ee14d95..05219de36 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/staticprovides/SomeStaticModule.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/staticprovides/SomeStaticModule.java
@@ -15,18 +15,21 @@
  */
 package test.staticprovides;
 
-import static dagger.Provides.Type.SET;
-
 import dagger.Module;
 import dagger.Provides;
+import dagger.multibindings.IntoSet;
 
 @Module
 final class SomeStaticModule {
-  @Provides(type = SET) static String contributeStringFromAStaticMethod() {
+  @Provides
+  @IntoSet
+  static String contributeStringFromAStaticMethod() {
     return SomeStaticModule.class + ".contributeStringFromAStaticMethod";
   }
 
-  @Provides(type = SET) String contributeStringFromAnInstanceMethod() {
+  @Provides
+  @IntoSet
+  static String contributeStringFromAnInstanceMethod() {
     return SomeStaticModule.class + ".contributeStringFromAnInstanceMethod";
   }
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/sub/ContributionsModule.java b/compiler/src/it/functional-tests/src/main/java/test/sub/ContributionsModule.java
index b10ac4533..953012ca6 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/sub/ContributionsModule.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/sub/ContributionsModule.java
@@ -17,25 +17,30 @@
 
 import dagger.Module;
 import dagger.Provides;
+import dagger.multibindings.ElementsIntoSet;
+import dagger.multibindings.IntoSet;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.LinkedHashSet;
 import java.util.Set;
 
-import static dagger.Provides.Type.SET;
-import static dagger.Provides.Type.SET_VALUES;
-
 @Module
 public final class ContributionsModule {
-  @Provides(type = SET) int contributeAnInt(double doubleDependency) {
+  @Provides
+  @IntoSet
+  static int contributeAnInt(double doubleDependency) {
     return 1742;
   }
 
-  @Provides(type = SET) int contributeAnotherInt() {
+  @Provides
+  @IntoSet
+  static int contributeAnotherInt() {
     return 832;
   }
 
-  @Provides(type = SET_VALUES) Set<Integer> contributeSomeInts() {
+  @Provides
+  @ElementsIntoSet
+  static Set<Integer> contributeSomeInts() {
     return Collections.unmodifiableSet(new LinkedHashSet<Integer>(Arrays.asList(-1, -90, -17)));
   }
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildModule.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildModule.java
index ef28bd47a..9ad2b5439 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildModule.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildModule.java
@@ -17,12 +17,13 @@
 
 import dagger.Module;
 import dagger.Provides;
-
-import static dagger.Provides.Type.SET;
+import dagger.multibindings.IntoSet;
 
 @Module
 final class ChildModule {
-  @Provides(type = SET) Object provideUnscopedObject() {
+  @Provides
+  @IntoSet
+  static Object provideUnscopedObject() {
     return new Object() {
       @Override public String toString() {
         return "unscoped in child";
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/GrandchildModule.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/GrandchildModule.java
index b2885412f..b74ad8beb 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/GrandchildModule.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/GrandchildModule.java
@@ -17,12 +17,13 @@
 
 import dagger.Module;
 import dagger.Provides;
-
-import static dagger.Provides.Type.SET;
+import dagger.multibindings.IntoSet;
 
 @Module
 final class GrandchildModule {
-  @Provides(type = SET) Object provideUnscopedObject() {
+  @Provides
+  @IntoSet
+  static Object provideUnscopedObject() {
     return new Object() {
       @Override public String toString() {
         return "unscoped in grandchild";
@@ -30,11 +31,13 @@
     };
   }
 
-  @Provides AnInterface provideAnInterface(ImplementsAnInterface implementsAnInterface) {
+  @Provides
+  static AnInterface provideAnInterface(ImplementsAnInterface implementsAnInterface) {
     return implementsAnInterface;
   }
 
-  @Provides NeedsAnInterface provideNeedsAnInterface(AnInterface anInterface) {
+  @Provides
+  static NeedsAnInterface provideNeedsAnInterface(AnInterface anInterface) {
     return new NeedsAnInterface(anInterface);
   }
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/MultibindingSubcomponents.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/MultibindingSubcomponents.java
index 4ecf8caf3..14abce625 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/MultibindingSubcomponents.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/MultibindingSubcomponents.java
@@ -19,15 +19,14 @@
 import dagger.Module;
 import dagger.Provides;
 import dagger.Subcomponent;
+import dagger.multibindings.IntoMap;
+import dagger.multibindings.IntoSet;
 import dagger.multibindings.StringKey;
 import java.util.Map;
 import java.util.Objects;
 import java.util.Set;
 import javax.inject.Inject;
 
-import static dagger.Provides.Type.MAP;
-import static dagger.Provides.Type.SET;
-
 final class MultibindingSubcomponents {
 
   /** Multibindings for this type are bound only in the parent component. */
@@ -86,23 +85,27 @@ public String toString() {
   @Module
   static final class ParentMultibindingModule {
 
-    @Provides(type = SET)
+    @Provides
+    @IntoSet
     static BoundInParent onlyInParentElement() {
       return BoundInParent.INSTANCE;
     }
 
-    @Provides(type = MAP)
+    @Provides
+    @IntoMap
     @StringKey("parent key")
     static BoundInParent onlyInParentEntry() {
       return BoundInParent.INSTANCE;
     }
 
-    @Provides(type = SET)
+    @Provides
+    @IntoSet
     static BoundInParentAndChild inParentAndChildElement() {
       return BoundInParentAndChild.IN_PARENT;
     }
 
-    @Provides(type = MAP)
+    @Provides
+    @IntoMap
     @StringKey("parent key")
     static BoundInParentAndChild inParentAndChildEntry() {
       return BoundInParentAndChild.IN_PARENT;
@@ -110,8 +113,9 @@ static BoundInParentAndChild inParentAndChildEntry() {
 
     /* This is not static because otherwise we have no tests that cover the case where a
      * subcomponent uses a module instance installed onto a parent component. */
-    @Provides(type = SET)
-    RequiresMultibindings<BoundInParentAndChild>
+    @Provides
+    @IntoSet
+    static RequiresMultibindings<BoundInParentAndChild>
         requiresMultibindingsInParentAndChildElement(
             RequiresMultibindings<BoundInParentAndChild> requiresMultibindingsInParentAndChild) {
       return requiresMultibindingsInParentAndChild;
@@ -121,23 +125,27 @@ static BoundInParentAndChild inParentAndChildEntry() {
   @Module
   static final class ChildMultibindingModule {
 
-    @Provides(type = SET)
+    @Provides
+    @IntoSet
     static BoundInParentAndChild inParentAndChildElement() {
       return BoundInParentAndChild.IN_CHILD;
     }
 
-    @Provides(type = MAP)
+    @Provides
+    @IntoMap
     @StringKey("child key")
     static BoundInParentAndChild inParentAndChildEntry() {
       return BoundInParentAndChild.IN_CHILD;
     }
 
-    @Provides(type = SET)
+    @Provides
+    @IntoSet
     static BoundInChild onlyInChildElement() {
       return BoundInChild.INSTANCE;
     }
 
-    @Provides(type = MAP)
+    @Provides
+    @IntoMap
     @StringKey("child key")
     static BoundInChild onlyInChildEntry() {
       return BoundInChild.INSTANCE;
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentComponent.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentComponent.java
index 504139aa2..2e5316e43 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentComponent.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentComponent.java
@@ -17,6 +17,7 @@
 
 import dagger.Component;
 import javax.inject.Singleton;
+import test.SomeQualifier;
 
 @Component(modules = {ParentModule.class, UnresolvableChildComponentModule.class})
 @Singleton
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentModule.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentModule.java
index dbe1a534a..748db15b0 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentModule.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentModule.java
@@ -17,13 +17,14 @@
 
 import dagger.Module;
 import dagger.Provides;
+import dagger.multibindings.IntoSet;
 import javax.inject.Singleton;
 
-import static dagger.Provides.Type.SET;
-
 @Module
 final class ParentModule {
-  @Provides(type = SET) Object provideUnscopedObject() {
+  @Provides
+  @IntoSet
+  static Object provideUnscopedObject() {
     return new Object() {
       @Override public String toString() {
         return "unscoped in parent";
@@ -31,7 +32,10 @@
     };
   }
 
-  @Provides(type = SET) @Singleton Object provideSingletonObject() {
+  @Provides
+  @IntoSet
+  @Singleton
+  static Object provideSingletonObject() {
     return new Object() {
       @Override public String toString() {
         return "singleton";
@@ -39,8 +43,10 @@
     };
   }
 
-  @Provides @Singleton @BoundAsSingleton UnscopedType provideUnscopedTypeBoundAsSingleton(
-      UnscopedType unscopedType) {
+  @Provides
+  @Singleton
+  @BoundAsSingleton
+  static UnscopedType provideUnscopedTypeBoundAsSingleton(UnscopedType unscopedType) {
     return unscopedType;
   }
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/UnresolvableChildComponentModule.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/UnresolvableChildComponentModule.java
index 0c273f737..c36fe316a 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/UnresolvableChildComponentModule.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/UnresolvableChildComponentModule.java
@@ -17,6 +17,7 @@
 
 import dagger.Module;
 import dagger.Provides;
+import test.SomeQualifier;
 
 @Module
 final class UnresolvableChildComponentModule {
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/RepeatedModule.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/RepeatedModule.java
index d0997513d..e3da28032 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/RepeatedModule.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/RepeatedModule.java
@@ -17,8 +17,7 @@
 
 import dagger.Module;
 import dagger.Provides;
-
-import static dagger.Provides.Type.SET;
+import dagger.multibindings.IntoSet;
 
 @Module
 final class RepeatedModule {
@@ -34,7 +33,8 @@ static String provideString() {
     return "a string";
   }
 
-  @Provides(type = SET)
+  @Provides
+  @IntoSet
   static String contributeString() {
     return "a string in a set";
   }
diff --git a/compiler/src/it/functional-tests/src/test/java/test/BasicTest.java b/compiler/src/it/functional-tests/src/test/java/test/BasicTest.java
index 4514457c1..cc3c52584 100644
--- a/compiler/src/it/functional-tests/src/test/java/test/BasicTest.java
+++ b/compiler/src/it/functional-tests/src/test/java/test/BasicTest.java
@@ -15,6 +15,8 @@
 */
 package test;
 
+import dagger.Lazy;
+import javax.inject.Provider;
 import org.junit.experimental.theories.DataPoint;
 import org.junit.experimental.theories.Theories;
 import org.junit.experimental.theories.Theory;
@@ -120,4 +122,16 @@ public void nullableInjection(BasicComponent basicComponent) {
     assertThat(basicComponent.nullObjectProvider().get()).isNull();
     assertThat(basicComponent.lazyNullObject().get()).isNull();
   }
+  
+  @Theory
+  public void providerOfLazy(BasicComponent basicComponent) {
+    Provider<Lazy<InjectedThing>> lazyInjectedThingProvider =
+        basicComponent.lazyInjectedThingProvider();
+    Lazy<InjectedThing> lazyInjectedThing1 = lazyInjectedThingProvider.get();
+    Lazy<InjectedThing> lazyInjectedThing2 = lazyInjectedThingProvider.get();
+    assertThat(lazyInjectedThing2).isNotSameAs(lazyInjectedThing1);
+    assertThat(lazyInjectedThing1.get()).isSameAs(lazyInjectedThing1.get());
+    assertThat(lazyInjectedThing2.get()).isSameAs(lazyInjectedThing2.get());
+    assertThat(lazyInjectedThing2.get()).isNotSameAs(lazyInjectedThing1.get());
+  }
 }
diff --git a/compiler/src/it/functional-tests/src/test/java/test/MultibindingTest.java b/compiler/src/it/functional-tests/src/test/java/test/MultibindingTest.java
index a28110b91..33b9aed38 100644
--- a/compiler/src/it/functional-tests/src/test/java/test/MultibindingTest.java
+++ b/compiler/src/it/functional-tests/src/test/java/test/MultibindingTest.java
@@ -44,9 +44,10 @@
 
   @Test public void map() {
     Map<String, String> map = multibindingComponent.map();
-    assertThat(map).hasSize(2);
+    assertThat(map).hasSize(3);
     assertThat(map).containsEntry("foo", "foo value");
     assertThat(map).containsEntry("bar", "bar value");
+    assertThat(map).containsEntry("foo @Provides(type)", "foo @Provides(type) value");
   }
 
   @Test public void mapOfArrays() {
@@ -60,14 +61,18 @@
 
   @Test public void mapOfProviders() {
     Map<String, Provider<String>> mapOfProviders = multibindingComponent.mapOfProviders();
-    assertThat(mapOfProviders).hasSize(2);
+    assertThat(mapOfProviders).hasSize(3);
     assertThat(mapOfProviders.get("foo").get()).isEqualTo("foo value");
     assertThat(mapOfProviders.get("bar").get()).isEqualTo("bar value");
+    assertThat(mapOfProviders.get("foo @Provides(type)").get())
+        .isEqualTo("foo @Provides(type) value");
   }
 
   @Test public void mapKeysAndValues() {
-    assertThat(multibindingComponent.mapKeys()).containsExactly("foo", "bar");
-    assertThat(multibindingComponent.mapValues()).containsExactly("foo value", "bar value");
+    assertThat(multibindingComponent.mapKeys())
+        .containsExactly("foo", "bar", "foo @Provides(type)");
+    assertThat(multibindingComponent.mapValues())
+        .containsExactly("foo value", "bar value", "foo @Provides(type) value");
   }
 
   @Test public void nestedKeyMap() {
@@ -148,10 +153,12 @@ public void shortKeyMap() {
   }
 
   @Test public void setBindings() {
-    assertThat(multibindingComponent.set()).containsExactly(-90, -17, -1, 5, 6, 832, 1742);
+    assertThat(multibindingComponent.set())
+        .containsExactly(-90, -17, -1, 5, 6, 832, 1742, -100, -101, -102);
   }
 
-  @Test public void complexQualifierSet() {
+  @Test
+  public void complexQualifierSet() {
     assertThat(multibindingComponent.complexQualifierStringSet()).containsExactly("foo");
   }
 
diff --git a/compiler/src/it/functional-tests/src/test/java/test/bind/BindTest.java b/compiler/src/it/functional-tests/src/test/java/test/bind/BindTest.java
new file mode 100644
index 000000000..04de60e00
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/test/java/test/bind/BindTest.java
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.bind;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assertThat;
+
+@RunWith(JUnit4.class)
+public class BindTest {
+  @Test
+  public void bindDelegates() {
+    TestComponent component = DaggerTestComponent.create();
+    assertThat(component.object()).isInstanceOf(FooOfStrings.class);
+    assertThat(component.fooOfStrings()).isInstanceOf(FooOfStrings.class);
+    assertThat(component.fooOfObjects()).isInstanceOf(FooOfObjects.class);
+    assertThat(component.fooOfIntegers()).isNotNull();
+  }
+
+  @Test
+  public void bindWithScope() {
+    TestComponent component = DaggerTestComponent.create();
+    assertThat(component.qualifiedFooOfStrings())
+        .isSameAs(component.qualifiedFooOfStrings());
+  }
+}
diff --git a/compiler/src/it/producers-functional-tests/pom.xml b/compiler/src/it/producers-functional-tests/pom.xml
index b8add885f..3a802c88d 100644
--- a/compiler/src/it/producers-functional-tests/pom.xml
+++ b/compiler/src/it/producers-functional-tests/pom.xml
@@ -22,7 +22,7 @@ limitations under the License.
   <parent>
     <groupId>com.google.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>2.2-SNAPSHOT</version>
+    <version>2.4-SNAPSHOT</version>
   </parent>
   <groupId>dagger.tests</groupId>
   <artifactId>producers-functional-tests</artifactId>
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/DependedProductionComponent.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/DependedProductionComponent.java
index ba98e3698..50b466da5 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/DependedProductionComponent.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/DependedProductionComponent.java
@@ -18,7 +18,7 @@
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.producers.ProductionComponent;
 
-@ProductionComponent(modules = DependedProducerModule.class)
+@ProductionComponent(modules = {ExecutorModule.class, DependedProducerModule.class})
 interface DependedProductionComponent {
   ListenableFuture<Integer> numGreetings();
 }
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/DependentComponent.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/DependentComponent.java
index 85709f0f3..f467178c6 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/DependentComponent.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/DependentComponent.java
@@ -21,8 +21,9 @@
 import java.util.List;
 
 @ProductionComponent(
-    modules = DependentProducerModule.class,
-    dependencies = {DependedComponent.class, DependedProductionComponent.class})
+  modules = {ExecutorModule.class, DependentProducerModule.class},
+  dependencies = {DependedComponent.class, DependedProductionComponent.class}
+)
 interface DependentComponent {
   ListenableFuture<List<String>> greetings();
 }
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/ExecutorModule.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/ExecutorModule.java
new file mode 100644
index 000000000..f37eac5c4
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/ExecutorModule.java
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package producerstest;
+
+import com.google.common.util.concurrent.MoreExecutors;
+import dagger.Module;
+import dagger.Provides;
+import dagger.producers.Production;
+import java.util.concurrent.Executor;
+
+/**
+ * A module that provides an optionally user-defined executor for a production component, defaulting
+ * to the direct executor.
+ */
+@Module
+public final class ExecutorModule {
+  private final Executor executor;
+
+  public ExecutorModule() {
+    this(MoreExecutors.directExecutor());
+  }
+
+  public ExecutorModule(Executor executor) {
+    this.executor = executor;
+  }
+
+  @Provides
+  @Production
+  Executor executor() {
+    return executor;
+  }
+}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/SimpleComponent.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/SimpleComponent.java
index 1d1e49233..ea793fd4d 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/SimpleComponent.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/SimpleComponent.java
@@ -18,7 +18,7 @@
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.producers.ProductionComponent;
 
-@ProductionComponent(modules = ResponseProducerModule.class)
+@ProductionComponent(modules = {ExecutorModule.class, ResponseProducerModule.class})
 interface SimpleComponent {
   ListenableFuture<Response> response();
 }
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/SimpleProducerModule.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/SimpleProducerModule.java
index 63500ca0c..7e335cc3b 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/SimpleProducerModule.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/SimpleProducerModule.java
@@ -20,6 +20,8 @@
 import com.google.common.util.concurrent.ListenableFuture;
 import com.google.common.util.concurrent.SettableFuture;
 import dagger.Lazy;
+import dagger.multibindings.ElementsIntoSet;
+import dagger.multibindings.IntoSet;
 import dagger.producers.Produced;
 import dagger.producers.Producer;
 import dagger.producers.ProducerModule;
@@ -29,9 +31,6 @@
 import javax.inject.Provider;
 import javax.inject.Qualifier;
 
-import static dagger.producers.Produces.Type.SET;
-import static dagger.producers.Produces.Type.SET_VALUES;
-
 /**
  * A module that contains various signatures of produces methods. This is not used in any
  * components.
@@ -142,85 +141,101 @@ static String strWithFrameworkTypeArgs(
 
   // Set bindings.
 
-  @Produces(type = SET)
+  @Produces
+  @IntoSet
   static String setOfStrElement() {
     return "set of str element";
   }
 
-  @Produces(type = SET)
+  @Produces
+  @IntoSet
   static String setOfStrElementThrowingException() throws IOException {
     return "set of str element throwing exception";
   }
 
-  @Produces(type = SET)
+  @Produces
+  @IntoSet
   static ListenableFuture<String> setOfStrFutureElement() {
     return Futures.immediateFuture("set of str element");
   }
 
-  @Produces(type = SET)
+  @Produces
+  @IntoSet
   static ListenableFuture<String> setOfStrFutureElementThrowingException() throws IOException {
     return Futures.immediateFuture("set of str element throwing exception");
   }
 
-  @Produces(type = SET)
+  @Produces
+  @IntoSet
   static String setOfStrElementWithArg(int i) {
     return "set of str element with arg";
   }
 
-  @Produces(type = SET)
+  @Produces
+  @IntoSet
   static String setOfStrElementWithArgThrowingException(int i) throws IOException {
     return "set of str element with arg throwing exception";
   }
 
-  @Produces(type = SET)
+  @Produces
+  @IntoSet
   static ListenableFuture<String> setOfStrFutureElementWithArg(int i) {
     return Futures.immediateFuture("set of str element with arg");
   }
 
-  @Produces(type = SET)
+  @Produces
+  @IntoSet
   static ListenableFuture<String> setOfStrFutureElementWithArgThrowingException(int i)
       throws IOException {
     return Futures.immediateFuture("set of str element with arg throwing exception");
   }
 
-  @Produces(type = SET_VALUES)
+  @Produces
+  @ElementsIntoSet
   static Set<String> setOfStrValues() {
     return ImmutableSet.of("set of str 1", "set of str 2");
   }
 
-  @Produces(type = SET_VALUES)
+  @Produces
+  @ElementsIntoSet
   static Set<String> setOfStrValuesThrowingException() throws IOException {
     return ImmutableSet.of("set of str 1", "set of str 2 throwing exception");
   }
 
-  @Produces(type = SET_VALUES)
+  @Produces
+  @ElementsIntoSet
   static ListenableFuture<Set<String>> setOfStrFutureValues() {
     return Futures.<Set<String>>immediateFuture(ImmutableSet.of("set of str 1", "set of str 2"));
   }
 
-  @Produces(type = SET_VALUES)
+  @Produces
+  @ElementsIntoSet
   static ListenableFuture<Set<String>> setOfStrFutureValuesThrowingException() throws IOException {
     return Futures.<Set<String>>immediateFuture(
         ImmutableSet.of("set of str 1", "set of str 2 throwing exception"));
   }
 
-  @Produces(type = SET_VALUES)
+  @Produces
+  @ElementsIntoSet
   static Set<String> setOfStrValuesWithArg(int i) {
     return ImmutableSet.of("set of str with arg 1", "set of str with arg 2");
   }
 
-  @Produces(type = SET_VALUES)
+  @Produces
+  @ElementsIntoSet
   static Set<String> setOfStrValuesWithArgThrowingException(int i) throws IOException {
     return ImmutableSet.of("set of str with arg 1", "set of str with arg 2 throwing exception");
   }
 
-  @Produces(type = SET_VALUES)
+  @Produces
+  @ElementsIntoSet
   static ListenableFuture<Set<String>> setOfStrFutureValuesWithArg(int i) {
     return Futures.<Set<String>>immediateFuture(
         ImmutableSet.of("set of str with arg 1", "set of str with arg 2"));
   }
 
-  @Produces(type = SET_VALUES)
+  @Produces
+  @ElementsIntoSet
   static ListenableFuture<Set<String>> setOfStrFutureValuesWithArgThrowingException(int i)
       throws IOException {
     return Futures.<Set<String>>immediateFuture(
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/badexecutor/SimpleComponent.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/badexecutor/SimpleComponent.java
index 6b3536eae..efeb1d003 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/badexecutor/SimpleComponent.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/badexecutor/SimpleComponent.java
@@ -17,12 +17,16 @@
 
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.producers.ProductionComponent;
+import producerstest.ExecutorModule;
 
 /**
  * A component that contains entry points that exercise different execution paths, for verifying the
  * behavior when the executor throws a {@link java.util.concurrent.RejectedExecutionException}.
  */
-@ProductionComponent(dependencies = ComponentDependency.class, modules = SimpleProducerModule.class)
+@ProductionComponent(
+  dependencies = ComponentDependency.class,
+  modules = {ExecutorModule.class, SimpleProducerModule.class}
+)
 interface SimpleComponent {
   /** An entry point exposing a producer method with no args. */
   ListenableFuture<String> noArgStr();
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/builder/TestComponentWithBuilder.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/builder/TestComponentWithBuilder.java
index 16dc9bad7..1e4973fc1 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/builder/TestComponentWithBuilder.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/builder/TestComponentWithBuilder.java
@@ -17,10 +17,10 @@
 
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.producers.ProductionComponent;
-import java.util.concurrent.Executor;
+import producerstest.ExecutorModule;
 
 @ProductionComponent(
-  modules = {StringModule.class, IntModule.class},
+  modules = {ExecutorModule.class, StringModule.class, IntModule.class},
   dependencies = DepComponent.class
 )
 interface TestComponentWithBuilder {
@@ -31,7 +31,6 @@
   interface Builder {
     Builder depComponent(DepComponent depComponent);
     Builder strModule(StringModule strModule);
-    Builder executor(Executor executor);
     TestComponentWithBuilder build();
   }
 }
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/MonitoredComponent.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/MonitoredComponent.java
index 48acbabac..d46c88fa9 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/MonitoredComponent.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/MonitoredComponent.java
@@ -17,8 +17,11 @@
 
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.producers.ProductionComponent;
+import producerstest.ExecutorModule;
 
-@ProductionComponent(modules = {MonitoringModule.class, StubModule.class, ServingModule.class})
+@ProductionComponent(
+  modules = {ExecutorModule.class, MonitoringModule.class, StubModule.class, ServingModule.class}
+)
 interface MonitoredComponent {
   ListenableFuture<String> output();
 }
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/MonitoringModule.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/MonitoringModule.java
index 0c4209076..4b99c7a12 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/MonitoringModule.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/MonitoringModule.java
@@ -17,10 +17,9 @@
 
 import dagger.Module;
 import dagger.Provides;
+import dagger.multibindings.IntoSet;
 import dagger.producers.monitoring.ProductionComponentMonitor;
 
-import static dagger.Provides.Type.SET;
-
 @Module
 final class MonitoringModule {
   private final ProductionComponentMonitor.Factory monitorFactory;
@@ -29,7 +28,8 @@
     this.monitorFactory = monitorFactory;
   }
 
-  @Provides(type = SET)
+  @Provides
+  @IntoSet
   ProductionComponentMonitor.Factory monitorFactory() {
     return monitorFactory;
   }
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/MultibindingComponent.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/MultibindingComponent.java
index 845e52426..8decb55fb 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/MultibindingComponent.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/MultibindingComponent.java
@@ -21,11 +21,12 @@
 import dagger.producers.ProductionComponent;
 import java.util.Map;
 import java.util.Set;
+import producerstest.ExecutorModule;
 import producerstest.multibindings.Qualifiers.ObjCount;
 import producerstest.multibindings.Qualifiers.PossiblyThrowingMap;
 import producerstest.multibindings.Qualifiers.PossiblyThrowingSet;
 
-@ProductionComponent(modules = MultibindingProducerModule.class)
+@ProductionComponent(modules = {ExecutorModule.class, MultibindingProducerModule.class})
 interface MultibindingComponent {
   ListenableFuture<Set<String>> strs();
   ListenableFuture<Integer> strCount();
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/MultibindingProducerModule.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/MultibindingProducerModule.java
index 8e311f8fe..6f182c0e6 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/MultibindingProducerModule.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/MultibindingProducerModule.java
@@ -19,7 +19,10 @@
 import com.google.common.util.concurrent.Futures;
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.Multibindings;
+import dagger.multibindings.ElementsIntoSet;
 import dagger.multibindings.IntKey;
+import dagger.multibindings.IntoMap;
+import dagger.multibindings.IntoSet;
 import dagger.producers.Produced;
 import dagger.producers.ProducerModule;
 import dagger.producers.Produces;
@@ -29,28 +32,28 @@
 import producerstest.multibindings.Qualifiers.PossiblyThrowingMap;
 import producerstest.multibindings.Qualifiers.PossiblyThrowingSet;
 
-import static dagger.producers.Produces.Type.MAP;
-import static dagger.producers.Produces.Type.SET;
-import static dagger.producers.Produces.Type.SET_VALUES;
-
 @ProducerModule
 final class MultibindingProducerModule {
-  @Produces(type = SET)
+  @Produces
+  @IntoSet
   static ListenableFuture<String> futureStr() {
     return Futures.immediateFuture("foo");
   }
 
-  @Produces(type = SET)
+  @Produces
+  @IntoSet
   static String str() {
     return "bar";
   }
 
-  @Produces(type = SET_VALUES)
+  @Produces
+  @ElementsIntoSet
   static ListenableFuture<Set<String>> futureStrs() {
     return Futures.<Set<String>>immediateFuture(ImmutableSet.of("foo1", "foo2"));
   }
 
-  @Produces(type = SET_VALUES)
+  @Produces
+  @ElementsIntoSet
   static Set<String> strs() {
     return ImmutableSet.of("bar1", "bar2");
   }
@@ -60,44 +63,51 @@ static int strCount(Set<String> strs) {
     return strs.size();
   }
 
-  @Produces(type = SET)
+  @Produces
+  @IntoSet
   @PossiblyThrowingSet
   static String successfulStringForSet() {
     return "singleton";
   }
 
-  @Produces(type = SET_VALUES)
+  @Produces
+  @ElementsIntoSet
   @PossiblyThrowingSet
   static Set<String> successfulStringsForSet() {
     return ImmutableSet.of("double", "ton");
   }
 
-  @Produces(type = SET)
+  @Produces
+  @IntoSet
   @PossiblyThrowingSet
   static String throwingStringForSet() {
     throw new RuntimeException("monkey");
   }
 
-  @Produces(type = MAP)
+  @Produces
+  @IntoMap
   @IntKey(42)
   static ListenableFuture<String> futureFor42() {
     return Futures.immediateFuture("forty two");
   }
 
-  @Produces(type = MAP)
+  @Produces
+  @IntoMap
   @IntKey(15)
   static String valueFor15() {
     return "fifteen";
   }
 
-  @Produces(type = MAP)
+  @Produces
+  @IntoMap
   @PossiblyThrowingMap
   @IntKey(42)
   static ListenableFuture<String> successfulFutureFor42() {
     return Futures.immediateFuture("forty two");
   }
 
-  @Produces(type = MAP)
+  @Produces
+  @IntoMap
   @PossiblyThrowingMap
   @IntKey(15)
   static String throwingValueFor15() {
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/provisions/Provisions.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/provisions/Provisions.java
new file mode 100644
index 000000000..0833995ce
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/provisions/Provisions.java
@@ -0,0 +1,80 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package producerstest.provisions;
+
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.producers.Producer;
+import dagger.producers.ProducerModule;
+import dagger.producers.Produces;
+import dagger.producers.ProductionComponent;
+import javax.inject.Inject;
+import producerstest.ExecutorModule;
+
+import javax.inject.Qualifier;
+
+/** Tests for requesting provisions from producers. */
+final class Provisions {
+  static final class InjectedClass {
+    @Inject InjectedClass() {}
+  }
+
+  static final class WrappedProducer<T> {
+    final Producer<T> producer;
+
+    WrappedProducer(Producer<T> producer) {
+      this.producer = producer;
+    }
+  }
+
+  static final class Output {
+    final Producer<InjectedClass> injectedClass1;
+    final Producer<InjectedClass> injectedClass2;
+
+    Output(Producer<InjectedClass> injectedClass1, Producer<InjectedClass> injectedClass2) {
+      this.injectedClass1 = injectedClass1;
+      this.injectedClass2 = injectedClass2;
+    }
+  }
+
+  @Qualifier @interface First {}
+  @Qualifier @interface Second {}
+
+  @ProducerModule
+  static final class TestModule {
+    @Produces @First static WrappedProducer<InjectedClass> firstProducer(
+        Producer<InjectedClass> injectedClass) {
+      return new WrappedProducer<InjectedClass>(injectedClass);
+    }
+
+    @Produces @Second static WrappedProducer<InjectedClass> secondProducer(
+        Producer<InjectedClass> injectedClass) {
+      return new WrappedProducer<InjectedClass>(injectedClass);
+    }
+
+    @Produces static Output output(
+        @First WrappedProducer<InjectedClass> producer1,
+        @Second WrappedProducer<InjectedClass> producer2) {
+      return new Output(producer1.producer, producer2.producer);
+    }
+  }
+
+  @ProductionComponent(modules = {ExecutorModule.class, TestModule.class})
+  interface TestComponent {
+    ListenableFuture<Output> output();
+  }
+
+  private Provisions() {}
+}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/scope/SetComponent.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/scope/SetComponent.java
index c7801c06a..75a05fa3f 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/scope/SetComponent.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/scope/SetComponent.java
@@ -18,8 +18,9 @@
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.producers.ProductionComponent;
 import java.util.Set;
+import producerstest.ExecutorModule;
 
-@ProductionComponent(modules = {ScopedModule.class, SetProducerModule.class})
+@ProductionComponent(modules = {ExecutorModule.class, ScopedModule.class, SetProducerModule.class})
 interface SetComponent {
   ScopedObject scopedObject();
 
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/scope/SetProducerModule.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/scope/SetProducerModule.java
index a5fc81e16..e930e2749 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/scope/SetProducerModule.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/scope/SetProducerModule.java
@@ -15,23 +15,24 @@
  */
 package producerstest.scope;
 
+import dagger.multibindings.IntoSet;
 import dagger.producers.ProducerModule;
 import dagger.producers.Produces;
 
-import static dagger.producers.Produces.Type.SET;
-
 /**
  * A module that provides two entries into a set; but since the inputs are scoped, the set should
  * only have one value.
  */
 @ProducerModule
 final class SetProducerModule {
-  @Produces(type = SET)
+  @Produces
+  @IntoSet
   static Object setValue1(Object value) {
     return value;
   }
 
-  @Produces(type = SET)
+  @Produces
+  @IntoSet
   static Object setValue2(Object value) {
     return value;
   }
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/subcomponent/Subcomponents.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/subcomponent/Subcomponents.java
deleted file mode 100644
index b998c5a3d..000000000
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/subcomponent/Subcomponents.java
+++ /dev/null
@@ -1,142 +0,0 @@
-/*
- * Copyright (C) 2016 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package producerstest.subcomponent;
-
-import com.google.common.util.concurrent.ListenableFuture;
-import dagger.Component;
-import dagger.Module;
-import dagger.Provides;
-import dagger.producers.ProducerModule;
-import dagger.producers.Produces;
-import dagger.producers.ProductionComponent;
-import dagger.producers.ProductionSubcomponent;
-import java.util.concurrent.Executor;
-import javax.inject.Inject;
-import javax.inject.Provider;
-import javax.inject.Qualifier;
-
-final class Subcomponents {
-  @Qualifier
-  @interface FromParent {}
-
-  @Qualifier
-  @interface FromChild {}
-
-  @Qualifier
-  @interface FromGrandchild {}
-
-  @Module
-  static final class ParentModule {
-    @Provides
-    @FromParent
-    static String fromParent() {
-      return "parent";
-    }
-  }
-
-  @Component(modules = ParentModule.class)
-  interface ParentComponent {
-    InjectsChildBuilder injectsChildBuilder();
-
-    ChildComponentWithExecutor.Builder newChildComponentBuilder();
-  }
-
-  @ProducerModule
-  static final class ParentProducerModule {
-    @Produces
-    @FromParent
-    static String fromParent() {
-      return "parentproduction";
-    }
-  }
-
-  @ProductionComponent(modules = ParentProducerModule.class)
-  interface ParentProductionComponent {
-    ChildComponent.Builder newChildComponentBuilder();
-  }
-
-  @ProducerModule
-  static final class ChildProducerModule {
-    @Produces
-    @FromChild
-    static String fromChild(@FromParent String fromParent) {
-      return "child:" + fromParent;
-    }
-  }
-
-  @ProductionSubcomponent(modules = ChildProducerModule.class)
-  interface ChildComponent {
-    @FromChild
-    ListenableFuture<String> fromChild();
-
-    GrandchildComponent.Builder newGrandchildComponentBuilder();
-
-    @ProductionSubcomponent.Builder
-    interface Builder {
-      ChildComponent build();
-    }
-  }
-
-  @ProductionSubcomponent(modules = ChildProducerModule.class)
-  interface ChildComponentWithExecutor {
-    @FromChild
-    ListenableFuture<String> fromChild();
-
-    GrandchildComponent.Builder newGrandchildComponentBuilder();
-
-    @ProductionSubcomponent.Builder
-    interface Builder {
-      Builder executor(Executor executor);
-
-      ChildComponentWithExecutor build();
-    }
-  }
-
-  static final class InjectsChildBuilder {
-    private final Provider<ChildComponentWithExecutor.Builder> childBuilder;
-
-    @Inject
-    InjectsChildBuilder(Provider<ChildComponentWithExecutor.Builder> childBuilder) {
-      this.childBuilder = childBuilder;
-    }
-
-    ChildComponentWithExecutor.Builder childBuilder() {
-      return childBuilder.get();
-    }
-  }
-
-  @ProducerModule
-  static final class GrandchildProducerModule {
-    @Produces
-    @FromGrandchild
-    static String fromGranchild(@FromChild String fromChild) {
-      return "grandchild:" + fromChild;
-    }
-  }
-
-  @ProductionSubcomponent(modules = GrandchildProducerModule.class)
-  interface GrandchildComponent {
-    @FromGrandchild
-    ListenableFuture<String> fromGrandchild();
-
-    @ProductionSubcomponent.Builder
-    interface Builder {
-      GrandchildComponent build();
-    }
-  }
-
-  private Subcomponents() {}
-}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/subcomponent/sub/ChildComponent.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/subcomponent/sub/ChildComponent.java
index a53bb3564..0059631b8 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/subcomponent/sub/ChildComponent.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/subcomponent/sub/ChildComponent.java
@@ -17,15 +17,14 @@
 
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.producers.ProductionSubcomponent;
-import java.util.concurrent.Executor;
+import producerstest.ExecutorModule;
 
-@ProductionSubcomponent(modules = ChildModule.class)
+@ProductionSubcomponent(modules = {ExecutorModule.class, ChildModule.class})
 public interface ChildComponent {
   ListenableFuture<String> str();
 
   @ProductionSubcomponent.Builder
   interface Builder {
-    Builder executor(Executor executor);
     ChildComponent build();
   }
 }
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/DependentTest.java b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/DependentTest.java
index b2533d735..e4812b823 100644
--- a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/DependentTest.java
+++ b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/DependentTest.java
@@ -17,7 +17,6 @@
 
 import com.google.common.util.concurrent.Futures;
 import com.google.common.util.concurrent.ListenableFuture;
-import com.google.common.util.concurrent.MoreExecutors;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
@@ -27,30 +26,24 @@
 @RunWith(JUnit4.class)
 public class DependentTest {
   @Test public void dependentComponent() throws Exception {
-    DependentComponent dependentComponent = DaggerDependentComponent
-        .builder()
-        .dependedProductionComponent(DaggerDependedProductionComponent.builder()
-            .executor(MoreExecutors.directExecutor())
-            .build())
-        .dependedComponent(DaggerDependedComponent.create())
-        .executor(MoreExecutors.directExecutor())
-        .build();
+    DependentComponent dependentComponent =
+        DaggerDependentComponent.builder()
+            .dependedProductionComponent(DaggerDependedProductionComponent.create())
+            .dependedComponent(DaggerDependedComponent.create())
+            .build();
     assertThat(dependentComponent).isNotNull();
     assertThat(dependentComponent.greetings().get()).containsExactly(
         "2", "Hello world!", "HELLO WORLD!");
   }
 
   @Test public void reuseBuilderWithDependentComponent() throws Exception {
-    DaggerDependentComponent.Builder dependentComponentBuilder = DaggerDependentComponent
-        .builder()
-        .executor(MoreExecutors.directExecutor());
+    DaggerDependentComponent.Builder dependentComponentBuilder = DaggerDependentComponent.builder();
 
-    DependentComponent componentUsingComponents = dependentComponentBuilder
-        .dependedProductionComponent(DaggerDependedProductionComponent.builder()
-            .executor(MoreExecutors.directExecutor())
-            .build())
-        .dependedComponent(DaggerDependedComponent.create())
-        .build();
+    DependentComponent componentUsingComponents =
+        dependentComponentBuilder
+            .dependedProductionComponent(DaggerDependedProductionComponent.create())
+            .dependedComponent(DaggerDependedComponent.create())
+            .build();
 
     DependentComponent componentUsingJavaImpls = dependentComponentBuilder
         .dependedProductionComponent(new DependedProductionComponent() {
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/SimpleTest.java b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/SimpleTest.java
index cacc0f11d..e4812ab9a 100644
--- a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/SimpleTest.java
+++ b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/SimpleTest.java
@@ -15,7 +15,6 @@
 */
 package producerstest;
 
-import com.google.common.util.concurrent.MoreExecutors;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
@@ -25,10 +24,7 @@
 @RunWith(JUnit4.class)
 public class SimpleTest {
   @Test public void testSimpleComponent() throws Exception {
-    SimpleComponent simpleComponent = DaggerSimpleComponent
-        .builder()
-        .executor(MoreExecutors.directExecutor())
-        .build();
+    SimpleComponent simpleComponent = DaggerSimpleComponent.create();
     assertThat(simpleComponent).isNotNull();
     assertThat(simpleComponent.response().get().data()).isEqualTo("Hello, Request #5!");
   }
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/badexecutor/BadExecutorTest.java b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/badexecutor/BadExecutorTest.java
index 8a49797f5..0e4d44d39 100644
--- a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/badexecutor/BadExecutorTest.java
+++ b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/badexecutor/BadExecutorTest.java
@@ -10,6 +10,7 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
+import producerstest.ExecutorModule;
 
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.fail;
@@ -31,7 +32,7 @@ public void setUpComponent() {
     ListeningExecutorService executorService = MoreExecutors.newDirectExecutorService();
     component =
         DaggerSimpleComponent.builder()
-            .executor(executorService)
+            .executorModule(new ExecutorModule(executorService))
             .componentDependency(dependency)
             .build();
     executorService.shutdown();
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/builder/ProductionComponentBuilderTest.java b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/builder/ProductionComponentBuilderTest.java
index 715761df4..10e5f4fac 100644
--- a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/builder/ProductionComponentBuilderTest.java
+++ b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/builder/ProductionComponentBuilderTest.java
@@ -17,7 +17,6 @@
 
 import com.google.common.util.concurrent.Futures;
 import com.google.common.util.concurrent.ListenableFuture;
-import com.google.common.util.concurrent.MoreExecutors;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
@@ -32,7 +31,6 @@
   public void successfulBuild() throws Exception {
     TestComponentWithBuilder component =
         DaggerTestComponentWithBuilder.builder()
-            .executor(MoreExecutors.directExecutor())
             .depComponent(depComponent(15.3))
             .strModule(new StringModule())
             .build();
@@ -44,25 +42,15 @@ public void successfulBuild() throws Exception {
   public void successfulBuild_withMissingZeroArgModule() throws Exception {
     TestComponentWithBuilder component =
         DaggerTestComponentWithBuilder.builder()
-            .executor(MoreExecutors.directExecutor())
             .depComponent(depComponent(15.3))
             .build();
     assertThat(component.s().get()).isEqualTo("arg: 42");
     assertThat(component.d().get()).isEqualTo(15.3);
   }
 
-  @Test(expected = IllegalStateException.class)
-  public void missingExecutor() {
-    DaggerTestComponentWithBuilder.builder()
-        .depComponent(depComponent(15.3))
-        .strModule(new StringModule())
-        .build();
-  }
-
   @Test(expected = IllegalStateException.class)
   public void missingDepComponent() {
     DaggerTestComponentWithBuilder.builder()
-        .executor(MoreExecutors.directExecutor())
         .strModule(new StringModule())
         .build();
   }
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/monitoring/MonitoringTest.java b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/monitoring/MonitoringTest.java
index 6572215ff..e36f35886 100644
--- a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/monitoring/MonitoringTest.java
+++ b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/monitoring/MonitoringTest.java
@@ -18,7 +18,6 @@
 import com.google.common.base.Throwables;
 import com.google.common.collect.ImmutableList;
 import com.google.common.util.concurrent.ListenableFuture;
-import com.google.common.util.concurrent.MoreExecutors;
 import com.google.common.util.concurrent.SettableFuture;
 import dagger.producers.monitoring.ProducerMonitor;
 import dagger.producers.monitoring.ProducerToken;
@@ -67,7 +66,6 @@ public void setUp() {
   public void basicMonitoring() throws Exception {
     MonitoredComponent component =
         DaggerMonitoredComponent.builder()
-            .executor(MoreExecutors.directExecutor())
             .monitoringModule(new MonitoringModule(componentMonitorFactory))
             .stubModule(new StubModule(server1, server2))
             .build();
@@ -110,7 +108,6 @@ public void basicMonitoring() throws Exception {
   public void basicMonitoringWithFailure() throws Exception {
     MonitoredComponent component =
         DaggerMonitoredComponent.builder()
-            .executor(MoreExecutors.directExecutor())
             .monitoringModule(new MonitoringModule(componentMonitorFactory))
             .stubModule(new StubModule(server1, server2))
             .build();
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/multibindings/MultibindingTest.java b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/multibindings/MultibindingTest.java
index 0919fded2..03aae67bb 100644
--- a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/multibindings/MultibindingTest.java
+++ b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/multibindings/MultibindingTest.java
@@ -17,7 +17,6 @@
 
 import com.google.common.collect.Iterables;
 import com.google.common.util.concurrent.ListenableFuture;
-import com.google.common.util.concurrent.MoreExecutors;
 import dagger.producers.Produced;
 import dagger.producers.Producer;
 import java.util.HashSet;
@@ -35,8 +34,7 @@
 public class MultibindingTest {
   @Test
   public void setBinding() throws Exception {
-    MultibindingComponent multibindingComponent =
-        DaggerMultibindingComponent.builder().executor(MoreExecutors.directExecutor()).build();
+    MultibindingComponent multibindingComponent = DaggerMultibindingComponent.create();
     assertThat(multibindingComponent.strs().get())
         .containsExactly("foo", "foo1", "foo2", "bar", "bar1", "bar2");
     assertThat(multibindingComponent.strCount().get()).isEqualTo(6);
@@ -44,8 +42,7 @@ public void setBinding() throws Exception {
 
   @Test
   public void setBindingOfProduced() throws Exception {
-    MultibindingComponent multibindingComponent =
-        DaggerMultibindingComponent.builder().executor(MoreExecutors.directExecutor()).build();
+    MultibindingComponent multibindingComponent = DaggerMultibindingComponent.create();
     assertThat(multibindingComponent.successfulSet().get())
         .containsExactly(
             Produced.successful("foo"),
@@ -58,8 +55,7 @@ public void setBindingOfProduced() throws Exception {
 
   @Test
   public void setBindingOfProducedWithFailures() throws Exception {
-    MultibindingComponent multibindingComponent =
-        DaggerMultibindingComponent.builder().executor(MoreExecutors.directExecutor()).build();
+    MultibindingComponent multibindingComponent = DaggerMultibindingComponent.create();
     Set<Produced<String>> possiblyThrowingSet = multibindingComponent.possiblyThrowingSet().get();
     Set<String> successes = new HashSet<>();
     Set<ExecutionException> failures = new HashSet<>();
@@ -77,8 +73,7 @@ public void setBindingOfProducedWithFailures() throws Exception {
 
   @Test
   public void mapBinding() throws Exception {
-    MultibindingComponent multibindingComponent =
-        DaggerMultibindingComponent.builder().executor(MoreExecutors.directExecutor()).build();
+    MultibindingComponent multibindingComponent = DaggerMultibindingComponent.create();
     Map<Integer, String> map = multibindingComponent.map().get();
     assertThat(map).hasSize(2);
     assertThat(map).containsEntry(15, "fifteen");
@@ -87,8 +82,7 @@ public void mapBinding() throws Exception {
 
   @Test
   public void mapOfProducerBinding() throws Exception {
-    MultibindingComponent multibindingComponent =
-        DaggerMultibindingComponent.builder().executor(MoreExecutors.directExecutor()).build();
+    MultibindingComponent multibindingComponent = DaggerMultibindingComponent.create();
     Map<Integer, Producer<String>> map = multibindingComponent.mapOfProducer().get();
     assertThat(map).hasSize(2);
     assertThat(map).containsKey(15);
@@ -99,8 +93,7 @@ public void mapOfProducerBinding() throws Exception {
 
   @Test
   public void mapOfProducedBinding() throws Exception {
-    MultibindingComponent multibindingComponent =
-        DaggerMultibindingComponent.builder().executor(MoreExecutors.directExecutor()).build();
+    MultibindingComponent multibindingComponent = DaggerMultibindingComponent.create();
     Map<Integer, Produced<String>> map = multibindingComponent.mapOfProduced().get();
     assertThat(map).hasSize(2);
     assertThat(map).containsKey(15);
@@ -111,8 +104,7 @@ public void mapOfProducedBinding() throws Exception {
 
   @Test
   public void mapBindingWithFailures() throws Exception {
-    MultibindingComponent multibindingComponent =
-        DaggerMultibindingComponent.builder().executor(MoreExecutors.directExecutor()).build();
+    MultibindingComponent multibindingComponent = DaggerMultibindingComponent.create();
     try {
       multibindingComponent.possiblyThrowingMap().get();
       fail();
@@ -123,8 +115,7 @@ public void mapBindingWithFailures() throws Exception {
 
   @Test
   public void mapOfProducerBindingWithFailures() throws Exception {
-    MultibindingComponent multibindingComponent =
-        DaggerMultibindingComponent.builder().executor(MoreExecutors.directExecutor()).build();
+    MultibindingComponent multibindingComponent = DaggerMultibindingComponent.create();
     Map<Integer, Producer<String>> map =
         multibindingComponent.possiblyThrowingMapOfProducer().get();
     assertThat(map).hasSize(2);
@@ -142,8 +133,7 @@ public void mapOfProducerBindingWithFailures() throws Exception {
 
   @Test
   public void mapOfProducedBindingWithFailures() throws Exception {
-    MultibindingComponent multibindingComponent =
-        DaggerMultibindingComponent.builder().executor(MoreExecutors.directExecutor()).build();
+    MultibindingComponent multibindingComponent = DaggerMultibindingComponent.create();
     Map<Integer, Produced<String>> map =
         multibindingComponent.possiblyThrowingMapOfProduced().get();
     assertThat(map).hasSize(2);
@@ -161,8 +151,7 @@ public void mapOfProducedBindingWithFailures() throws Exception {
 
   @Test
   public void emptySet() throws Exception {
-    MultibindingComponent multibindingComponent =
-        DaggerMultibindingComponent.builder().executor(MoreExecutors.directExecutor()).build();
+    MultibindingComponent multibindingComponent = DaggerMultibindingComponent.create();
     assertThat(multibindingComponent.objs().get()).isEmpty();
     assertThat(multibindingComponent.producedObjs().get()).isEmpty();
     assertThat(multibindingComponent.objCount().get()).isEqualTo(0);
@@ -170,8 +159,7 @@ public void emptySet() throws Exception {
 
   @Test
   public void emptyMap() throws Exception {
-    MultibindingComponent multibindingComponent =
-        DaggerMultibindingComponent.builder().executor(MoreExecutors.directExecutor()).build();
+    MultibindingComponent multibindingComponent = DaggerMultibindingComponent.create();
     assertThat(multibindingComponent.objMap().get()).isEmpty();
     assertThat(multibindingComponent.objMapOfProduced().get()).isEmpty();
     assertThat(multibindingComponent.objMapOfProducer().get()).isEmpty();
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/provisions/ProvisionsTest.java b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/provisions/ProvisionsTest.java
new file mode 100644
index 000000000..e4371cbf4
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/provisions/ProvisionsTest.java
@@ -0,0 +1,36 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package producerstest.provisions;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import producerstest.provisions.DaggerProvisions_TestComponent;
+import producerstest.provisions.Provisions.Output;
+import producerstest.provisions.Provisions.TestComponent;
+
+import static com.google.common.truth.Truth.assertThat;
+
+@RunWith(JUnit4.class)
+public final class ProvisionsTest {
+
+  @Test
+  public void provisionsOnlyAreHeldInOneProducer() throws Exception {
+    TestComponent component = DaggerProvisions_TestComponent.create();
+    Output output = component.output().get();
+    assertThat(output.injectedClass1).isSameAs(output.injectedClass2);
+  }
+}
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/scope/ScopeTest.java b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/scope/ScopeTest.java
index 36ce255e5..6af6d8af6 100644
--- a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/scope/ScopeTest.java
+++ b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/scope/ScopeTest.java
@@ -15,7 +15,6 @@
  */
 package producerstest.scope;
 
-import com.google.common.util.concurrent.MoreExecutors;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
@@ -27,8 +26,7 @@
 
   @Test
   public void scope() throws Exception {
-    SetComponent component =
-        DaggerSetComponent.builder().executor(MoreExecutors.directExecutor()).build();
+    SetComponent component = DaggerSetComponent.create();
     assertThat(component.set().get()).hasSize(1);
     assertThat(component.scopedObject()).isSameAs(component.scopedObject());
   }
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/subcomponent/MultiPackageSubcomponentTest.java b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/subcomponent/MultiPackageSubcomponentTest.java
index ad5c86d22..313202172 100644
--- a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/subcomponent/MultiPackageSubcomponentTest.java
+++ b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/subcomponent/MultiPackageSubcomponentTest.java
@@ -17,8 +17,6 @@
 
 import static com.google.common.truth.Truth.assertThat;
 
-import com.google.common.util.concurrent.MoreExecutors;
-import java.util.concurrent.Executor;
 import producerstest.subcomponent.MultiPackageSubcomponents.ParentComponent;
 import producerstest.subcomponent.sub.ChildComponent;
 import org.junit.Test;
@@ -30,9 +28,8 @@
 
   @Test
   public void childComponent() throws Exception {
-    Executor executor = MoreExecutors.directExecutor();
     ParentComponent parent = DaggerMultiPackageSubcomponents_ParentComponent.create();
-    ChildComponent child = parent.childComponentBuilder().executor(executor).build();
+    ChildComponent child = parent.childComponentBuilder().build();
     assertThat(child.str().get()).isEqualTo("Hello, World 42");
   }
 }
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/subcomponent/SubcomponentTest.java b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/subcomponent/SubcomponentTest.java
deleted file mode 100644
index ddd43403e..000000000
--- a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/subcomponent/SubcomponentTest.java
+++ /dev/null
@@ -1,77 +0,0 @@
-/*
- * Copyright (C) 2016 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package producerstest.subcomponent;
-
-import static com.google.common.truth.Truth.assertThat;
-
-import com.google.common.util.concurrent.MoreExecutors;
-import java.util.concurrent.Executor;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-import producerstest.subcomponent.Subcomponents.ChildComponent;
-import producerstest.subcomponent.Subcomponents.ChildComponentWithExecutor;
-import producerstest.subcomponent.Subcomponents.GrandchildComponent;
-import producerstest.subcomponent.Subcomponents.ParentComponent;
-import producerstest.subcomponent.Subcomponents.ParentProductionComponent;
-
-@RunWith(JUnit4.class)
-public final class SubcomponentTest {
-  @Test
-  public void topLevelComponent_child() throws Exception {
-    Executor executor = MoreExecutors.directExecutor();
-    ParentComponent parent = DaggerSubcomponents_ParentComponent.create();
-    ChildComponentWithExecutor child = parent.newChildComponentBuilder().executor(executor).build();
-    assertThat(child.fromChild().get()).isEqualTo("child:parent");
-  }
-
-  @Test
-  public void topLevelComponent_injectsChildBuilder() throws Exception {
-    Executor executor = MoreExecutors.directExecutor();
-    ParentComponent parent = DaggerSubcomponents_ParentComponent.create();
-    ChildComponentWithExecutor child =
-        parent.injectsChildBuilder().childBuilder().executor(executor).build();
-    assertThat(child.fromChild().get()).isEqualTo("child:parent");
-  }
-
-  @Test
-  public void topLevelComponent_grandchild() throws Exception {
-    Executor executor = MoreExecutors.directExecutor();
-    ParentComponent parent = DaggerSubcomponents_ParentComponent.create();
-    ChildComponentWithExecutor child = parent.newChildComponentBuilder().executor(executor).build();
-    GrandchildComponent grandchild = child.newGrandchildComponentBuilder().build();
-    assertThat(grandchild.fromGrandchild().get()).isEqualTo("grandchild:child:parent");
-  }
-
-  @Test
-  public void topLevelProductionComponent_child() throws Exception {
-    Executor executor = MoreExecutors.directExecutor();
-    ParentProductionComponent parent =
-        DaggerSubcomponents_ParentProductionComponent.builder().executor(executor).build();
-    ChildComponent child = parent.newChildComponentBuilder().build();
-    assertThat(child.fromChild().get()).isEqualTo("child:parentproduction");
-  }
-
-  @Test
-  public void topLevelProductionComponent_grandchild() throws Exception {
-    Executor executor = MoreExecutors.directExecutor();
-    ParentProductionComponent parent =
-        DaggerSubcomponents_ParentProductionComponent.builder().executor(executor).build();
-    ChildComponent child = parent.newChildComponentBuilder().build();
-    GrandchildComponent grandchild = child.newGrandchildComponentBuilder().build();
-    assertThat(grandchild.fromGrandchild().get()).isEqualTo("grandchild:child:parentproduction");
-  }
-}
diff --git a/compiler/src/it/tck/pom.xml b/compiler/src/it/tck/pom.xml
index ecbcb34f5..4a27fb334 100644
--- a/compiler/src/it/tck/pom.xml
+++ b/compiler/src/it/tck/pom.xml
@@ -22,7 +22,7 @@ limitations under the License.
   <parent>
     <groupId>com.google.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>2.2-SNAPSHOT</version>
+    <version>2.4-SNAPSHOT</version>
   </parent>
   <groupId>dagger.tests</groupId>
   <artifactId>tck</artifactId>
diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
index d7eb38720..fe7d31792 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -106,12 +106,13 @@
 import static dagger.internal.codegen.TypeNames.SET_FACTORY;
 import static dagger.internal.codegen.TypeNames.SET_OF_PRODUCED_PRODUCER;
 import static dagger.internal.codegen.TypeNames.SET_PRODUCER;
-import static dagger.internal.codegen.TypeNames.SIMPLE_LAZILY_INITIALIZED_PROVIDER;
+import static dagger.internal.codegen.TypeNames.SINGLE_CHECK;
 import static dagger.internal.codegen.TypeNames.STRING;
 import static dagger.internal.codegen.TypeNames.UNSUPPORTED_OPERATION_EXCEPTION;
 import static dagger.internal.codegen.TypeNames.providerOf;
 import static dagger.internal.codegen.TypeSpecs.addSupertype;
 import static dagger.internal.codegen.Util.componentCanMakeNewInstances;
+import static dagger.internal.codegen.Util.requiresAPassedInstance;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
@@ -140,6 +141,7 @@
   protected TypeSpec.Builder component;
   private final UniqueNameSet componentFieldNames = new UniqueNameSet();
   private final Map<BindingKey, MemberSelect> memberSelects = new HashMap<>();
+  private final Map<BindingKey, MemberSelect> producerFromProviderMemberSelects = new HashMap<>();
   protected final MethodSpec.Builder constructor = constructorBuilder().addModifiers(PRIVATE);
   protected Optional<ClassName> builderName = Optional.absent();
 
@@ -188,7 +190,7 @@ protected final ClassName componentDefinitionTypeName() {
    */
   private CodeBlock getComponentContributionExpression(TypeElement contributionType) {
     if (builderFields.containsKey(contributionType)) {
-      return CodeBlocks.format("builder.$N", builderFields.get(contributionType));
+      return CodeBlock.of("builder.$N", builderFields.get(contributionType));
     } else {
       Optional<CodeBlock> codeBlock =
           getOrCreateComponentContributionFieldExpression(contributionType);
@@ -344,7 +346,7 @@ private void addBuildMethod(
       if (componentCanMakeNewInstances(builderFieldEntry.getKey())) {
         buildMethod.addCode(
             "if ($1N == null) { this.$1N = new $2T(); }", builderField, builderField.type);
-      } else {
+      } else if (requiresAPassedInstance(elements, builderFieldEntry.getKey())) {
         buildMethod.addCode(
             "if ($N == null) { throw new $T($T.class.getCanonicalName() + $S); }",
             builderField,
@@ -480,17 +482,24 @@ private void addField(ResolvedBindings resolvedBindings) {
       return;
     }
 
-    FieldSpec frameworkField = addFrameworkField(resolvedBindings);
+    // TODO(gak): get rid of the field for unscoped delegated bindings
+
+    FieldSpec frameworkField = addFrameworkField(resolvedBindings, Optional.<BindingType>absent());
     memberSelects.put(
         bindingKey,
         localField(name, frameworkField.name));
   }
 
-  private FieldSpec addFrameworkField(ResolvedBindings resolvedBindings) {
+  /**
+   * Adds a field representing the resolved bindings, optionally forcing it to use a particular
+   * binding type (instead of the type the resolved bindings would typically use).
+   */
+  private FieldSpec addFrameworkField(
+      ResolvedBindings resolvedBindings, Optional<BindingType> bindingType) {
     boolean useRawType = useRawType(resolvedBindings);
 
     FrameworkField contributionBindingField =
-        FrameworkField.createForResolvedBindings(resolvedBindings);
+        FrameworkField.createForResolvedBindings(resolvedBindings, bindingType);
     FieldSpec.Builder contributionField =
         componentField(
             useRawType
@@ -543,7 +552,7 @@ private boolean useRawType(ResolvedBindings resolvedBindings) {
               return Optional.of(
                   staticMethod(
                       generatedClassNameForBinding(contributionBinding),
-                      CodeBlocks.format("create()")));
+                      CodeBlock.of("create()")));
           }
         }
         break;
@@ -686,6 +695,7 @@ private void implementInterfaceMethods() {
             case PRODUCED:
             case PRODUCER:
             case PROVIDER:
+            case PROVIDER_OF_LAZY:
             case FUTURE:
               interfaceMethod.addStatement(
                   "return $L",
@@ -769,15 +779,35 @@ private void initializeFrameworkTypes() {
 
   private Optional<CodeBlock> initializeContributionBinding(BindingKey bindingKey) {
     ContributionBinding binding = graph.resolvedBindings().get(bindingKey).contributionBinding();
-    if (binding.factoryCreationStrategy().equals(ENUM_INSTANCE) && !binding.scope().isPresent()) {
-      return Optional.absent();
+    switch (binding.factoryCreationStrategy()) {
+      case DELEGATE:
+        CodeBlock delegatingCodeBlock = CodeBlock.of(
+            "($T) $L",
+            binding.frameworkClass(),
+            getMemberSelect(
+                Iterables.getOnlyElement(binding.dependencies()).bindingKey())
+                    .getExpressionFor(name));
+        return Optional.of(
+            initializeMember(
+                bindingKey,
+                binding.scope().isPresent()
+                    ? decorateForScope(delegatingCodeBlock, binding.scope().get())
+                    : delegatingCodeBlock));
+      case ENUM_INSTANCE:
+        if (!binding.scope().isPresent()) {
+          return Optional.absent();
+        }
+        // fall through
+      case CLASS_CONSTRUCTOR:
+        return Optional.of(
+            CodeBlocks.concat(
+                ImmutableList.of(
+                    initializeDeferredDependencies(binding),
+                    initializeMember(
+                        bindingKey, initializeFactoryForContributionBinding(binding)))));
+      default:
+        throw new AssertionError();
     }
-
-    return Optional.of(
-        CodeBlocks.concat(
-            ImmutableList.of(
-                initializeDelegateFactoriesForUninitializedDependencies(binding),
-                initializeMember(bindingKey, initializeFactoryForContributionBinding(binding)))));
   }
 
   private Optional<CodeBlock> initializeMembersInjectionBinding(BindingKey bindingKey) {
@@ -791,10 +821,21 @@ private void initializeFrameworkTypes() {
     return Optional.of(
         CodeBlocks.concat(
             ImmutableList.of(
-                initializeDelegateFactoriesForUninitializedDependencies(binding),
+                initializeDeferredDependencies(binding),
                 initializeMember(bindingKey, initializeMembersInjectorForBinding(binding)))));
   }
 
+  /**
+   * Initializes any dependencies of the given binding that need to be instantiated, i.e., as we get
+   * to them during normal initialization.
+   */
+  private CodeBlock initializeDeferredDependencies(Binding binding) {
+    return CodeBlocks.concat(
+        ImmutableList.of(
+            initializeDelegateFactoriesForUninitializedDependencies(binding),
+            initializeProducersFromProviderDependencies(binding)));
+  }
+
   /**
    * Initializes delegate factories for any dependencies of {@code binding} that are uninitialized
    * because of a dependency cycle.
@@ -809,7 +850,7 @@ private CodeBlock initializeDelegateFactoriesForUninitializedDependencies(Bindin
       if (!getMemberSelect(dependencyKey).staticMember()
           && getInitializationState(dependencyKey).equals(UNINITIALIZED)) {
         initializations.add(
-            CodeBlocks.format(
+            CodeBlock.of(
                 "this.$L = new $T();", getMemberSelectExpression(dependencyKey), DELEGATE_FACTORY));
         setInitializationState(dependencyKey, DELEGATED);
       }
@@ -818,6 +859,33 @@ private CodeBlock initializeDelegateFactoriesForUninitializedDependencies(Bindin
     return CodeBlocks.concat(initializations.build());
   }
 
+  private CodeBlock initializeProducersFromProviderDependencies(Binding binding) {
+    ImmutableList.Builder<CodeBlock> initializations = ImmutableList.builder();
+    for (FrameworkDependency frameworkDependency : frameworkDependenciesForBinding(binding)) {
+      ResolvedBindings resolvedBindings =
+          graph.resolvedBindings().get(frameworkDependency.bindingKey());
+      if (resolvedBindings.frameworkClass().equals(Provider.class)
+          && frameworkDependency.frameworkClass().equals(Producer.class)) {
+        MemberSelect memberSelect =
+            producerFromProviderMemberSelects.get(frameworkDependency.bindingKey());
+        if (memberSelect != null) {
+          continue;
+        }
+        FieldSpec frameworkField =
+            addFrameworkField(resolvedBindings, Optional.of(BindingType.PRODUCTION));
+        memberSelect = localField(name, frameworkField.name);
+        producerFromProviderMemberSelects.put(frameworkDependency.bindingKey(), memberSelect);
+        initializations.add(
+            CodeBlock.of(
+                "this.$L = $T.producerFromProvider($L);",
+                memberSelect.getExpressionFor(name),
+                PRODUCERS,
+                getMemberSelectExpression(frameworkDependency.bindingKey())));
+      }
+    }
+    return CodeBlocks.concat(initializations.build());
+  }
+
   private CodeBlock initializeMember(BindingKey bindingKey, CodeBlock initializationCodeBlock) {
     ImmutableList.Builder<CodeBlock> initializations = ImmutableList.builder();
 
@@ -825,14 +893,14 @@ private CodeBlock initializeMember(BindingKey bindingKey, CodeBlock initializati
     CodeBlock delegateFactoryVariable = delegateFactoryVariableExpression(bindingKey);
     if (getInitializationState(bindingKey).equals(DELEGATED)) {
       initializations.add(
-          CodeBlocks.format(
+          CodeBlock.of(
               "$1T $2L = ($1T) $3L;", DELEGATE_FACTORY, delegateFactoryVariable, memberSelect));
     }
     initializations.add(
-        CodeBlocks.format("this.$L = $L;", memberSelect, initializationCodeBlock));
+        CodeBlock.of("this.$L = $L;", memberSelect, initializationCodeBlock));
     if (getInitializationState(bindingKey).equals(DELEGATED)) {
       initializations.add(
-          CodeBlocks.format("$L.setDelegatedProvider($L);", delegateFactoryVariable, memberSelect));
+          CodeBlock.of("$L.setDelegatedProvider($L);", delegateFactoryVariable, memberSelect));
     }
     setInitializationState(bindingKey, INITIALIZED);
 
@@ -840,15 +908,14 @@ private CodeBlock initializeMember(BindingKey bindingKey, CodeBlock initializati
   }
 
   private CodeBlock delegateFactoryVariableExpression(BindingKey key) {
-    return CodeBlocks.format(
-        "$LDelegate", getMemberSelectExpression(key).toString().replace('.', '_'));
+    return CodeBlock.of("$LDelegate", getMemberSelectExpression(key).toString().replace('.', '_'));
   }
 
   private CodeBlock initializeFactoryForContributionBinding(ContributionBinding binding) {
     TypeName bindingKeyTypeName = TypeName.get(binding.key().type());
     switch (binding.bindingKind()) {
       case COMPONENT:
-        return CodeBlocks.format(
+        return CodeBlock.of(
             "$T.<$T>create($L)",
             INSTANCE_FACTORY,
             bindingKeyTypeName,
@@ -863,7 +930,7 @@ private CodeBlock initializeFactoryForContributionBinding(ContributionBinding bi
               graph.componentDescriptor().dependencyMethodIndex().get(binding.bindingElement());
           String localFactoryVariable = simpleVariableName(bindingTypeElement);
           CodeBlock callFactoryMethod =
-              CodeBlocks.format(
+              CodeBlock.of(
                   "$L.$L()",
                   localFactoryVariable,
                   binding.bindingElement().getSimpleName().toString());
@@ -876,12 +943,12 @@ private CodeBlock initializeFactoryForContributionBinding(ContributionBinding bi
           CodeBlock getMethodBody =
               binding.nullableType().isPresent()
                       || compilerOptions.nullableValidationKind().equals(Diagnostic.Kind.WARNING)
-                  ? CodeBlocks.format("return $L;", callFactoryMethod)
-                  : CodeBlocks.format("return $T.checkNotNull($L, $S);",
+                  ? CodeBlock.of("return $L;", callFactoryMethod)
+                  : CodeBlock.of("return $T.checkNotNull($L, $S);",
                       Preconditions.class,
                       callFactoryMethod,
                       CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD);
-          return CodeBlocks.format(
+          return CodeBlock.of(
               Joiner.on('\n')
                   .join(
                       "new $1T<$2T>() {",
@@ -900,7 +967,7 @@ private CodeBlock initializeFactoryForContributionBinding(ContributionBinding bi
         }
 
       case SUBCOMPONENT_BUILDER:
-        return CodeBlocks.format(
+        return CodeBlock.of(
             Joiner.on('\n')
                 .join(
                     "new $1T<$2T>() {",
@@ -924,7 +991,7 @@ private CodeBlock initializeFactoryForContributionBinding(ContributionBinding bi
           arguments.addAll(getDependencyArguments(binding));
 
           CodeBlock factoryCreate =
-              CodeBlocks.format(
+              CodeBlock.of(
                   "$T.create($L)",
                   generatedClassNameForBinding(binding),
                   makeParametersCodeBlock(arguments));
@@ -933,19 +1000,11 @@ private CodeBlock initializeFactoryForContributionBinding(ContributionBinding bi
               : factoryCreate;
         }
 
-      case EXECUTOR_DEPENDENCY:
-        return CodeBlocks.format(
-            "$T.<$T>create($L)",
-            INSTANCE_FACTORY,
-            bindingKeyTypeName,
-            getComponentContributionExpression(
-                graph.componentDescriptor().executorDependency().get()));
-
       case COMPONENT_PRODUCTION:
         {
           TypeElement bindingTypeElement =
               graph.componentDescriptor().dependencyMethodIndex().get(binding.bindingElement());
-          return CodeBlocks.format(
+          return CodeBlock.of(
               Joiner.on('\n')
                   .join(
                       "new $1T<$2T>() {",
@@ -973,14 +1032,14 @@ private CodeBlock initializeFactoryForContributionBinding(ContributionBinding bi
           }
           arguments.addAll(getDependencyArguments(binding));
 
-          return CodeBlocks.format(
+          return CodeBlock.of(
               "new $T($L)",
               generatedClassNameForBinding(binding),
               makeParametersCodeBlock(arguments));
         }
 
       case SYNTHETIC_MAP:
-        return CodeBlocks.format(
+        return CodeBlock.of(
             "$T.create($L)",
             mapFactoryClassName(binding),
             getMemberSelectExpression(getOnlyElement(binding.dependencies()).bindingKey()));
@@ -997,23 +1056,24 @@ private CodeBlock initializeFactoryForContributionBinding(ContributionBinding bi
   }
 
   private CodeBlock decorateForScope(CodeBlock factoryCreate, Scope scope) {
-    return scope.equals(reusableScope(elements))
-        ? CodeBlocks.format("$T.create($L)", SIMPLE_LAZILY_INITIALIZED_PROVIDER, factoryCreate)
-        : CodeBlocks.format("$T.provider($L)", DOUBLE_CHECK, factoryCreate);
+    return CodeBlock.of(
+        "$T.provider($L)",
+        scope.equals(reusableScope(elements)) ? SINGLE_CHECK : DOUBLE_CHECK,
+        factoryCreate);
   }
 
   private CodeBlock nullableAnnotation(Optional<DeclaredType> nullableType) {
     return nullableType.isPresent()
-        ? CodeBlocks.format("@$T ", TypeName.get(nullableType.get()))
-        : CodeBlocks.format("");
+        ? CodeBlock.of("@$T ", TypeName.get(nullableType.get()))
+        : CodeBlock.of("");
   }
 
   private CodeBlock initializeMembersInjectorForBinding(MembersInjectionBinding binding) {
     switch (binding.injectionStrategy()) {
       case NO_OP:
-        return CodeBlocks.format("$T.noOp()", MEMBERS_INJECTORS);
+        return CodeBlock.of("$T.noOp()", MEMBERS_INJECTORS);
       case INJECT_MEMBERS:
-        return CodeBlocks.format(
+        return CodeBlock.of(
             "$T.create($L)",
             membersInjectorNameForType(binding.bindingElement()),
             makeParametersCodeBlock(getDependencyArguments(binding)));
@@ -1039,18 +1099,17 @@ private CodeBlock initializeMembersInjectorForBinding(MembersInjectionBinding bi
    */
   private CodeBlock getDependencyArgument(FrameworkDependency frameworkDependency) {
     BindingKey requestedKey = frameworkDependency.bindingKey();
-    CodeBlock frameworkExpression = getMemberSelectExpression(requestedKey);
     ResolvedBindings resolvedBindings = graph.resolvedBindings().get(requestedKey);
     if (resolvedBindings.frameworkClass().equals(Provider.class)
         && frameworkDependency.frameworkClass().equals(Producer.class)) {
-      return CodeBlocks.format("$T.producerFromProvider($L)", PRODUCERS, frameworkExpression);
+      return producerFromProviderMemberSelects.get(requestedKey).getExpressionFor(name);
     } else {
-      return frameworkExpression;
+      return getMemberSelectExpression(requestedKey);
     }
   }
 
   private CodeBlock initializeFactoryForSetMultibinding(ContributionBinding binding) {
-    return CodeBlocks.format(
+    return CodeBlock.of(
         "$T.create($L)",
         setFactoryClassName(binding.bindingType(), binding.key()),
         makeParametersCodeBlock(getDependencyArguments(binding)));
@@ -1063,7 +1122,7 @@ private CodeBlock initializeFactoryForMapMultibinding(ContributionBinding bindin
     ImmutableList.Builder<CodeBlock> codeBlocks = ImmutableList.builder();
     MapType mapType = MapType.from(binding.key().type());
     codeBlocks.add(
-        CodeBlocks.format(
+        CodeBlock.of(
             "$T.<$T, $T>builder($L)",
             frameworkMapFactoryClassName(binding.bindingType()),
             TypeName.get(mapType.keyType()),
@@ -1076,12 +1135,12 @@ private CodeBlock initializeFactoryForMapMultibinding(ContributionBinding bindin
       ContributionBinding contributionBinding =
           graph.resolvedBindings().get(bindingKey).contributionBinding();
       codeBlocks.add(
-          CodeBlocks.format(
+          CodeBlock.of(
               ".put($L, $L)",
               getMapKeyExpression(contributionBinding.bindingElement()),
               getDependencyArgument(frameworkDependency)));
     }
-    codeBlocks.add(CodeBlocks.format(".build()"));
+    codeBlocks.add(CodeBlock.of(".build()"));
 
     return CodeBlocks.concat(codeBlocks.build());
   }
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
index d9cd68f1b..210ee33d9 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
@@ -48,7 +48,6 @@
 import java.util.Set;
 import java.util.concurrent.Callable;
 import java.util.concurrent.ExecutionException;
-import java.util.concurrent.Executor;
 import javax.inject.Inject;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.ExecutableElement;
@@ -110,8 +109,7 @@
 
   /**
    * Returns the set of types necessary to implement the component, but are not part of the injected
-   * graph.  This includes modules, component dependencies and an {@link Executor} in the case of
-   * {@link ProductionComponent}.
+   * graph.  This includes modules and component dependencies.
    */
   ImmutableSet<TypeElement> componentRequirements() {
     return SUBGRAPH_TRAVERSER
@@ -141,7 +139,6 @@
             })
         .filter(in(ownedModuleTypes()))
         .append(componentDescriptor().dependencies())
-        .append(componentDescriptor().executorDependency().asSet())
         .toSet();
   }
 
@@ -165,7 +162,6 @@ public ComponentDescriptor apply(BindingGraph graph) {
     return new ImmutableSet.Builder<TypeElement>()
         .addAll(componentDescriptor().transitiveModuleTypes())
         .addAll(componentDescriptor().dependencies())
-        .addAll(componentDescriptor().executorDependency().asSet())
         .build();
   }
 
@@ -195,17 +191,12 @@ BindingGraph create(ComponentDescriptor componentDescriptor) {
     private BindingGraph create(
         Optional<Resolver> parentResolver, ComponentDescriptor componentDescriptor) {
       ImmutableSet.Builder<ContributionBinding> explicitBindingsBuilder = ImmutableSet.builder();
+      ImmutableSet.Builder<DelegateDeclaration> delegatesBuilder = ImmutableSet.builder();
 
       // binding for the component itself
       TypeElement componentDefinitionType = componentDescriptor.componentDefinitionType();
       explicitBindingsBuilder.add(provisionBindingFactory.forComponent(componentDefinitionType));
 
-      // immediate binding for the executor, if it's provided to the builder
-      if (componentDescriptor.executorDependency().isPresent()) {
-        explicitBindingsBuilder.add(
-            provisionBindingFactory.forExecutorDependency(componentDefinitionType));
-      }
-
       // Collect Component dependencies.
       Optional<AnnotationMirror> componentMirror =
           getAnnotationMirror(componentDefinitionType, Component.class)
@@ -247,6 +238,7 @@ private BindingGraph create(
       for (ModuleDescriptor moduleDescriptor : componentDescriptor.transitiveModules()) {
         explicitBindingsBuilder.addAll(moduleDescriptor.bindings());
         multibindingDeclarations.addAll(moduleDescriptor.multibindingDeclarations());
+        delegatesBuilder.addAll(moduleDescriptor.delegateDeclarations());
       }
 
       Resolver requestResolver =
@@ -254,7 +246,8 @@ private BindingGraph create(
               parentResolver,
               componentDescriptor,
               indexByKey(explicitBindingsBuilder.build()),
-              indexByKey(multibindingDeclarations.build()));
+              indexByKey(multibindingDeclarations.build()),
+              indexByKey(delegatesBuilder.build()));
       for (ComponentMethodDescriptor componentMethod : componentDescriptor.componentMethods()) {
         Optional<DependencyRequest> componentMethodRequest = componentMethod.dependencyRequest();
         if (componentMethodRequest.isPresent()) {
@@ -293,6 +286,7 @@ private BindingGraph create(
       final ImmutableSet<ContributionBinding> explicitBindingsSet;
       final ImmutableSetMultimap<Key, ContributionBinding> explicitMultibindings;
       final ImmutableSetMultimap<Key, MultibindingDeclaration> multibindingDeclarations;
+      final ImmutableSetMultimap<Key, DelegateDeclaration> delegateDeclarations;
       final Map<BindingKey, ResolvedBindings> resolvedBindings;
       final Deque<BindingKey> cycleStack = new ArrayDeque<>();
       final Cache<BindingKey, Boolean> dependsOnLocalMultibindingsCache =
@@ -304,7 +298,8 @@ private BindingGraph create(
           Optional<Resolver> parentResolver,
           ComponentDescriptor componentDescriptor,
           ImmutableSetMultimap<Key, ContributionBinding> explicitBindings,
-          ImmutableSetMultimap<Key, MultibindingDeclaration> multibindingDeclarations) {
+          ImmutableSetMultimap<Key, MultibindingDeclaration> multibindingDeclarations,
+          ImmutableSetMultimap<Key, DelegateDeclaration> delegateDeclarations) {
         assert parentResolver != null;
         this.parentResolver = parentResolver;
         assert componentDescriptor != null;
@@ -314,6 +309,8 @@ private BindingGraph create(
         this.explicitBindingsSet = ImmutableSet.copyOf(explicitBindings.values());
         assert multibindingDeclarations != null;
         this.multibindingDeclarations = multibindingDeclarations;
+        assert delegateDeclarations != null;
+        this.delegateDeclarations = delegateDeclarations;
         this.resolvedBindings = Maps.newLinkedHashMap();
 
         ImmutableSetMultimap.Builder<Key, ContributionBinding> explicitMultibindingsBuilder =
@@ -349,40 +346,47 @@ private BindingGraph create(
        */
       ResolvedBindings lookUpBindings(DependencyRequest request) {
         BindingKey bindingKey = request.bindingKey();
+        Key key = bindingKey.key();
         switch (bindingKey.kind()) {
           case CONTRIBUTION:
             Set<ContributionBinding> contributionBindings = new LinkedHashSet<>();
             Set<ContributionBinding> multibindings = new LinkedHashSet<>();
             ImmutableSet.Builder<MultibindingDeclaration> multibindingDeclarationsBuilder =
                 ImmutableSet.builder();
+            ImmutableSet.Builder<DelegateDeclaration> delegateDeclarationsBuilder =
+                ImmutableSet.builder();
 
             // Add explicit bindings and declarations (those from modules and components).
-            contributionBindings.addAll(getExplicitBindings(bindingKey.key()));
-            multibindings.addAll(getExplicitMultibindings(bindingKey.key()));
-            multibindingDeclarationsBuilder.addAll(getMultibindingDeclarations(bindingKey.key()));
+            contributionBindings.addAll(getExplicitBindings(key));
+            multibindings.addAll(getExplicitMultibindings(key));
+            multibindingDeclarationsBuilder.addAll(getMultibindingDeclarations(key));
+            delegateDeclarationsBuilder.addAll(getDelegateDeclarations(key));
 
             // If the key is Set<Produced<T>>, then add explicit bindings and declarations for
             // Set<T>.
-            Optional<Key> implicitSetKey = keyFactory.implicitSetKeyFromProduced(bindingKey.key());
+            Optional<Key> implicitSetKey = keyFactory.implicitSetKeyFromProduced(key);
             contributionBindings.addAll(getExplicitBindings(implicitSetKey));
             multibindings.addAll(getExplicitMultibindings(implicitSetKey));
             multibindingDeclarationsBuilder.addAll(getMultibindingDeclarations(implicitSetKey));
+            delegateDeclarationsBuilder.addAll(getDelegateDeclarations(implicitSetKey));
 
             ImmutableSet<MultibindingDeclaration> multibindingDeclarations =
                 multibindingDeclarationsBuilder.build();
+            ImmutableSet<DelegateDeclaration> delegateDeclarations =
+                delegateDeclarationsBuilder.build();
+
+            contributionBindings.addAll(delegateBindings(delegateDeclarations));
 
             // If the key is Map<K, V>, get its map-of-framework-type binding keys, which are either
             // Map<K, Provider<V>> or Map<K, Producer<V>>, and grab their explicit bindings and
             // declarations.
-            Optional<Key> implicitMapProviderKey =
-                keyFactory.implicitMapProviderKeyFrom(bindingKey.key());
+            Optional<Key> implicitMapProviderKey = keyFactory.implicitMapProviderKeyFrom(key);
             ImmutableSet<ContributionBinding> explicitProviderMapBindings =
                 getExplicitMultibindings(implicitMapProviderKey);
             ImmutableSet<MultibindingDeclaration> explicitProviderMultibindingDeclarations =
                 getMultibindingDeclarations(implicitMapProviderKey);
 
-            Optional<Key> implicitMapProducerKey =
-                keyFactory.implicitMapProducerKeyFrom(bindingKey.key());
+            Optional<Key> implicitMapProducerKey = keyFactory.implicitMapProducerKeyFrom(key);
             ImmutableSet<ContributionBinding> explicitProducerMapBindings =
                 getExplicitMultibindings(implicitMapProducerKey);
             ImmutableSet<MultibindingDeclaration> explicitProducerMultibindingDeclarations =
@@ -390,19 +394,19 @@ ResolvedBindings lookUpBindings(DependencyRequest request) {
 
             if (!explicitProducerMapBindings.isEmpty()
                 || !explicitProducerMultibindingDeclarations.isEmpty()) {
-              /* If the binding key is Map<K, V>, and there are some explicit Map<K, Producer<V>>
-               * bindings or multibinding declarations, then add the synthetic binding that depends
-               * on Map<K, Producer<V>>. */
+              /* If the binding key is Map<K, V> or Map<K, Produced<V>> and there are some explicit
+               * Map<K, Producer<V>> bindings or multibinding declarations, then add the synthetic
+               * binding that depends on Map<K, Producer<V>>. */
               contributionBindings.add(
-                  productionBindingFactory.implicitMapOfProducerBinding(request));
+                  productionBindingFactory.syntheticMapOfValuesOrProducedBinding(request));
             } else if (!explicitProviderMapBindings.isEmpty()
                 || !explicitProviderMultibindingDeclarations.isEmpty()) {
-              /* If the binding key is Map<K, V>, and there are some explicit Map<K, Provider<V>>
+              /* If the binding key is Map<K, V> and there are some explicit Map<K, Provider<V>>
                * bindings or multibinding declarations but no explicit Map<K, Producer<V>> bindings
                * or multibinding declarations, then add the synthetic binding that depends on
                * Map<K, Provider<V>>. */
               contributionBindings.add(
-                  provisionBindingFactory.implicitMapOfProviderBinding(request));
+                  provisionBindingFactory.syntheticMapOfValuesBinding(request));
             }
 
             Iterable<? extends HasBindingType> multibindingsAndDeclarations =
@@ -421,13 +425,14 @@ ResolvedBindings lookUpBindings(DependencyRequest request) {
                   provisionBindingFactory.syntheticMultibinding(request, multibindings));
             }
 
-            /* If there are no explicit or synthetic bindings or multibinding declarations, use an
-             * implicit @Inject- constructed binding if there is one. */
+            /* If there are no explicit or synthetic bindings, multibinding declarations or delegate
+             * declarations, use an implicit @Inject- constructed binding if there is one. */
             if (contributionBindings.isEmpty()
                 && multibindings.isEmpty()
-                && multibindingDeclarations.isEmpty()) {
+                && multibindingDeclarations.isEmpty()
+                && delegateDeclarations.isEmpty()) {
               contributionBindings.addAll(
-                  injectBindingRegistry.getOrFindProvisionBinding(bindingKey.key()).asSet());
+                  injectBindingRegistry.getOrFindProvisionBinding(key).asSet());
             }
 
             return ResolvedBindings.forContributionBindings(
@@ -439,7 +444,7 @@ ResolvedBindings lookUpBindings(DependencyRequest request) {
           case MEMBERS_INJECTION:
             // no explicit deps for members injection, so just look it up
             Optional<MembersInjectionBinding> binding =
-                injectBindingRegistry.getOrFindMembersInjectionBinding(bindingKey.key());
+                injectBindingRegistry.getOrFindMembersInjectionBinding(key);
             return binding.isPresent()
                 ? ResolvedBindings.forMembersInjectionBinding(
                     bindingKey, componentDescriptor, binding.get())
@@ -449,6 +454,32 @@ ResolvedBindings lookUpBindings(DependencyRequest request) {
         }
       }
 
+      private ImmutableSet<ContributionBinding> delegateBindings(
+          ImmutableSet<DelegateDeclaration> delegateDeclarations) {
+        ImmutableSet.Builder<ContributionBinding> builder = ImmutableSet.builder();
+        for (DelegateDeclaration delegateDeclaration : delegateDeclarations) {
+          DependencyRequest delegateRequest = delegateDeclaration.delegateRequest();
+          ResolvedBindings resolvedDelegate = lookUpBindings(delegateRequest);
+          for (ContributionBinding explicitDelegate : resolvedDelegate.contributionBindings()) {
+            switch (explicitDelegate.bindingType()) {
+              case PRODUCTION:
+                builder.add(
+                    productionBindingFactory.delegate(
+                        delegateDeclaration, (ProductionBinding) explicitDelegate));
+                break;
+              case PROVISION:
+                builder.add(
+                    provisionBindingFactory.delegate(
+                        delegateDeclaration, (ProvisionBinding) explicitDelegate));
+                break;
+              default:
+                throw new AssertionError();
+            }
+          }
+        }
+        return builder.build();
+      }
+
       private ImmutableSetMultimap<ComponentDescriptor, ContributionBinding>
           indexBindingsByOwningComponent(
               DependencyRequest request, Iterable<? extends ContributionBinding> bindings) {
@@ -594,6 +625,22 @@ private boolean isResolvedInParent(DependencyRequest request, ContributionBindin
             : ImmutableSet.<MultibindingDeclaration>of();
       }
 
+      private ImmutableSet<DelegateDeclaration> getDelegateDeclarations(Key key) {
+        ImmutableSet.Builder<DelegateDeclaration> delegateDeclarations =
+            ImmutableSet.builder();
+        for (Resolver resolver : getResolverLineage()) {
+          delegateDeclarations.addAll(resolver.delegateDeclarations.get(key));
+        }
+        return delegateDeclarations.build();
+      }
+
+      private ImmutableSet<DelegateDeclaration> getDelegateDeclarations(
+          Optional<Key> optionalKey) {
+        return optionalKey.isPresent()
+            ? getDelegateDeclarations(optionalKey.get())
+            : ImmutableSet.<DelegateDeclaration>of();
+      }
+
       private Optional<ResolvedBindings> getPreviouslyResolvedBindings(
           final BindingKey bindingKey) {
         Optional<ResolvedBindings> result = Optional.fromNullable(resolvedBindings.get(bindingKey));
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
index 04647c97d..17ed72d44 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -31,6 +31,8 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ImmutableSetMultimap;
 import com.google.common.collect.Iterables;
+import com.google.common.collect.Iterators;
+import com.google.common.collect.LinkedHashMultiset;
 import com.google.common.collect.Maps;
 import com.google.common.collect.Multimap;
 import com.google.common.collect.Ordering;
@@ -48,8 +50,6 @@
 import java.util.Deque;
 import java.util.Formatter;
 import java.util.HashSet;
-import java.util.Iterator;
-import java.util.LinkedHashSet;
 import java.util.Map;
 import java.util.Queue;
 import java.util.Set;
@@ -72,7 +72,7 @@
 import static com.google.auto.common.MoreTypes.asDeclared;
 import static com.google.auto.common.MoreTypes.asExecutable;
 import static com.google.auto.common.MoreTypes.asTypeElements;
-import static com.google.common.base.Predicates.equalTo;
+import static com.google.common.base.Preconditions.checkState;
 import static com.google.common.base.Predicates.in;
 import static com.google.common.base.Predicates.not;
 import static com.google.common.base.Verify.verify;
@@ -138,7 +138,98 @@
     this.keyFactory = keyFactory;
   }
 
-  private class Validation {
+  /** A dependency path from an entry point. */
+  static final class DependencyPath {
+    final Deque<ResolvedRequest> requestPath = new ArrayDeque<>();
+    private final LinkedHashMultiset<BindingKey> keyPath = LinkedHashMultiset.create();
+    private final Set<DependencyRequest> resolvedRequests = new HashSet<>();
+
+    /** The entry point. */
+    Element entryPointElement() {
+      return requestPath.getFirst().request().requestElement();
+    }
+
+    /** The current dependency request, which is a transitive dependency of the entry point. */
+    DependencyRequest currentDependencyRequest() {
+      return requestPath.getLast().request();
+    }
+
+    /**
+     * The resolved bindings for the {@linkplain #currentDependencyRequest() current dependency
+     * request.
+     */
+    ResolvedBindings currentBinding() {
+      return requestPath.getLast().binding();
+    }
+
+    /**
+     * The binding that depends on the {@linkplain #currentDependencyRequest() current request}.
+     *
+     * @throws IllegalStateException if there are fewer than two requests in the path
+     */
+    ResolvedBindings previousBinding() {
+      checkState(size() > 1);
+      return Iterators.get(requestPath.descendingIterator(), 1).binding();
+    }
+
+    /**
+     * {@code true} if there is a dependency cycle, which means that the
+     * {@linkplain #currentDependencyRequest() current request}'s binding key occurs earlier in the
+     * path.
+     */
+    boolean hasCycle() {
+      return keyPath.count(currentDependencyRequest().bindingKey()) > 1;
+    }
+
+    /**
+     * If there is a cycle, the segment of the path that represents the cycle. The first request's
+     * and the last request's binding keys are equal. The last request is the
+     * {@linkplain #currentDependencyRequest() current request}.
+     *
+     * @throws IllegalStateException if {@link #hasCycle()} is {@code false}
+     */
+    ImmutableList<ResolvedRequest> cycle() {
+      checkState(hasCycle(), "no cycle");
+      return FluentIterable.from(requestPath)
+          .skip(indexOf(keyPath, Predicates.equalTo(currentDependencyRequest().bindingKey())))
+          .toList();
+    }
+
+    /**
+     * Makes {@code request} the current request. Be sure to call {@link #pop()} to back up to the
+     * previous request in the path.
+     */
+    void push(ResolvedRequest request) {
+      requestPath.addLast(request);
+      keyPath.add(request.request().bindingKey());
+    }
+
+    /** Makes the previous request the current request. */
+    void pop() {
+      verify(keyPath.remove(requestPath.removeLast().request().bindingKey()));
+    }
+
+    /**
+     * Adds the {@linkplain #currentDependencyRequest() current request} to a set of visited
+     * requests, and returns {@code true} if the set didn't already contain it.
+     */
+    boolean visitCurrentRequest() {
+      return resolvedRequests.add(currentDependencyRequest());
+    }
+
+    int size() {
+      return requestPath.size();
+    }
+
+    /** The nonsynthetic dependency requests in this path, starting with the entry point. */
+    FluentIterable<DependencyRequest> nonsyntheticRequests() {
+      return FluentIterable.from(requestPath)
+          .filter(Predicates.not(new PreviousBindingWasSynthetic()))
+          .transform(REQUEST_FROM_RESOLVED_REQUEST);
+    }
+  }
+
+  private final class Validation {
     final BindingGraph subject;
     final ValidationReport.Builder<TypeElement> reportBuilder;
     final Optional<Validation> parent;
@@ -172,11 +263,7 @@ void validateSubgraph() {
            subject.componentDescriptor().componentMethods()) {
         Optional<DependencyRequest> entryPoint = componentMethod.dependencyRequest();
         if (entryPoint.isPresent()) {
-          traverseRequest(
-              entryPoint.get(),
-              new ArrayDeque<ResolvedRequest>(),
-              new LinkedHashSet<BindingKey>(),
-              new HashSet<DependencyRequest>());
+          traverseRequest(entryPoint.get(), new DependencyPath());
         }
       }
 
@@ -234,51 +321,31 @@ public boolean apply(TypeElement moduleType) {
      * cycles found.
      *
      * @param request the current dependency request
-     * @param bindingPath the dependency request path from the parent of {@code request} at the head
-     *     up to the root dependency request from the component method at the tail
-     * @param keysInPath the binding keys corresponding to the dependency requests in
-     *     {@code bindingPath}, but in reverse order: the first element is the binding key from the
-     *     component method
-     * @param resolvedRequests the requests that have already been resolved, so we can avoid
-     *     traversing that part of the graph again
      */
-    // TODO(dpb): It might be simpler to invert bindingPath's order.
-    private void traverseRequest(
-        DependencyRequest request,
-        Deque<ResolvedRequest> bindingPath,
-        LinkedHashSet<BindingKey> keysInPath,
-        Set<DependencyRequest> resolvedRequests) {
-      verify(bindingPath.size() == keysInPath.size(),
-          "mismatched path vs keys -- (%s vs %s)", bindingPath, keysInPath);
-      BindingKey requestKey = request.bindingKey();
-      if (keysInPath.contains(requestKey)) {
-        reportCycle(
-            // Invert bindingPath to match keysInPath's order
-            ImmutableList.copyOf(bindingPath).reverse(),
-            request,
-            indexOf(keysInPath, equalTo(requestKey)));
-        return;
-      }
+    private void traverseRequest(DependencyRequest request, DependencyPath path) {
+      path.push(ResolvedRequest.create(request, subject));
+      try {
+        if (path.hasCycle()) {
+          reportCycle(path);
+          return;
+        }
+
+        if (path.visitCurrentRequest()) {
+          validateResolvedBinding(path);
 
-      // If request has already been resolved, avoid re-traversing the binding path.
-      if (resolvedRequests.add(request)) {
-        ResolvedRequest resolvedRequest = ResolvedRequest.create(request, subject);
-        bindingPath.push(resolvedRequest);
-        keysInPath.add(requestKey);
-        validateResolvedBinding(bindingPath, resolvedRequest.binding());
-
-        // Validate all dependencies within the component that owns the binding.
-        for (Map.Entry<ComponentDescriptor, Collection<Binding>> entry :
-            resolvedRequest.binding().bindingsByComponent().asMap().entrySet()) {
-          Validation validation = validationForComponent(entry.getKey());
-          for (Binding binding : entry.getValue()) {
-            for (DependencyRequest nextRequest : binding.implicitDependencies()) {
-              validation.traverseRequest(nextRequest, bindingPath, keysInPath, resolvedRequests);
+          // Validate all dependencies within the component that owns the binding.
+          for (Map.Entry<ComponentDescriptor, Collection<Binding>> entry :
+              path.currentBinding().bindingsByComponent().asMap().entrySet()) {
+            Validation validation = validationForComponent(entry.getKey());
+            for (Binding binding : entry.getValue()) {
+              for (DependencyRequest nextRequest : binding.implicitDependencies()) {
+                validation.traverseRequest(nextRequest, path);
+              }
             }
           }
         }
-        bindingPath.poll();
-        keysInPath.remove(requestKey);
+      } finally {
+        path.pop();
       }
     }
 
@@ -299,8 +366,8 @@ private Validation validationForComponent(ComponentDescriptor component) {
     /**
      * Reports errors if the set of bindings resolved is inconsistent with the type of the binding.
      */
-    private void validateResolvedBinding(
-        Deque<ResolvedRequest> path, ResolvedBindings resolvedBinding) {
+    private void validateResolvedBinding(DependencyPath path) {
+      ResolvedBindings resolvedBinding = path.currentBinding();
       if (resolvedBinding.isEmpty()) {
         reportMissingBinding(path);
         return;
@@ -314,7 +381,8 @@ private void validateResolvedBinding(
             throw new AssertionError(
                 "contribution binding keys should never have members injection bindings");
           }
-          validateNullability(path.peek().request(), resolvedBinding.contributionBindings());
+          validateNullability(
+              path.currentDependencyRequest(), resolvedBinding.contributionBindings());
           if (resolvedBinding.contributionBindings().size() > 1) {
             reportDuplicateBindings(path);
             return;
@@ -405,10 +473,11 @@ private ResolvedBindings inlineSyntheticContributions(ResolvedBindings resolvedB
         multibindingDeclarations.addAll(queued.multibindingDeclarations());
         for (Map.Entry<ComponentDescriptor, ContributionBinding> bindingEntry :
             queued.allContributionBindings().entries()) {
+          BindingGraph owningGraph = validationForComponent(bindingEntry.getKey()).subject;
           ContributionBinding binding = bindingEntry.getValue();
           if (binding.isSyntheticBinding()) {
             for (DependencyRequest dependency : binding.dependencies()) {
-              queue.add(subject.resolvedBindings().get(dependency.bindingKey()));
+              queue.add(owningGraph.resolvedBindings().get(dependency.bindingKey()));
             }
           } else {
             contributions.put(bindingEntry);
@@ -459,8 +528,7 @@ private void validateNullability(DependencyRequest request, Set<ContributionBind
     /**
      * Reports errors if {@code mapBindings} has more than one binding for the same map key.
      */
-    private void validateMapKeySet(
-        Deque<ResolvedRequest> path, Set<ContributionBinding> mapBindings) {
+    private void validateMapKeySet(DependencyPath path, Set<ContributionBinding> mapBindings) {
       for (Collection<ContributionBinding> mapBindingsForMapKey :
           indexMapBindingsByMapKey(mapBindings).asMap().values()) {
         if (mapBindingsForMapKey.size() > 1) {
@@ -473,7 +541,7 @@ private void validateMapKeySet(
      * Reports errors if {@code mapBindings} uses more than one {@link MapKey} annotation type.
      */
     private void validateMapKeyAnnotationTypes(
-        Deque<ResolvedRequest> path, Set<ContributionBinding> contributionBindings) {
+        DependencyPath path, Set<ContributionBinding> contributionBindings) {
       ImmutableSetMultimap<Equivalence.Wrapper<DeclaredType>, ContributionBinding>
           mapBindingsByAnnotationType = indexMapBindingsByAnnotationType(contributionBindings);
       if (mapBindingsByAnnotationType.keySet().size() > 1) {
@@ -484,8 +552,7 @@ private void validateMapKeyAnnotationTypes(
     /**
      * Reports errors if a members injection binding is invalid.
      */
-    private void validateMembersInjectionBinding(
-        Binding binding, final Deque<ResolvedRequest> path) {
+    private void validateMembersInjectionBinding(Binding binding, final DependencyPath path) {
       binding
           .key()
           .type()
@@ -494,7 +561,8 @@ private void validateMembersInjectionBinding(
                 @Override
                 protected Void defaultAction(TypeMirror e, Void p) {
                   reportBuilder.addError(
-                      "Invalid members injection request.", path.peek().request().requestElement());
+                      "Invalid members injection request.",
+                      path.currentDependencyRequest().requestElement());
                   return null;
                 }
 
@@ -547,20 +615,13 @@ public Boolean visitPrimitive(PrimitiveType t, Void p) {
                         declared = false;
                     }
                     if (!declared) {
-                      ImmutableList<String> printableDependencyPath =
-                          FluentIterable.from(path)
-                              .transform(REQUEST_FROM_RESOLVED_REQUEST)
-                              .transform(dependencyRequestFormatter)
-                              .filter(Predicates.not(Predicates.equalTo("")))
-                              .toList()
-                              .reverse();
                       reportBuilder.addError(
                           String.format(
                               MEMBERS_INJECTION_WITH_UNBOUNDED_TYPE,
                               arg.toString(),
                               type.toString(),
-                              Joiner.on('\n').join(printableDependencyPath)),
-                          path.peek().request().requestElement());
+                              dependencyRequestFormatter.toDependencyTrace(path)),
+                          path.entryPointElement());
                       return null;
                     }
                   }
@@ -572,19 +633,12 @@ public Boolean visitPrimitive(PrimitiveType t, Void p) {
                   // allow it and instantiate the type bounds... but we don't.)
                   if (!MoreTypes.asDeclared(element.asType()).getTypeArguments().isEmpty()
                       && types.isSameType(types.erasure(element.asType()), type)) {
-                    ImmutableList<String> printableDependencyPath =
-                        FluentIterable.from(path)
-                            .transform(REQUEST_FROM_RESOLVED_REQUEST)
-                            .transform(dependencyRequestFormatter)
-                            .filter(Predicates.not(Predicates.equalTo("")))
-                            .toList()
-                            .reverse();
                     reportBuilder.addError(
                         String.format(
                             ErrorMessages.MEMBERS_INJECTION_WITH_RAW_TYPE,
                             type.toString(),
-                            Joiner.on('\n').join(printableDependencyPath)),
-                        path.peek().request().requestElement());
+                            dependencyRequestFormatter.toDependencyTrace(path)),
+                        path.entryPointElement());
                   }
                   return null;
                 }
@@ -826,6 +880,7 @@ void validateComponentScope() {
             // reference to scoped @Provides methods or @Inject types decorated by any
             // scope annotation.
             switch (contributionBinding.bindingKind()) {
+              case SYNTHETIC_DELEGATE_BINDING:
               case PROVISION:
                 ExecutableElement provisionMethod =
                     MoreElements.asExecutable(contributionBinding.bindingElement());
@@ -867,7 +922,7 @@ void validateComponentScope() {
     }
 
     @SuppressWarnings("resource") // Appendable is a StringBuilder.
-    private void reportProviderMayNotDependOnProducer(Deque<ResolvedRequest> path) {
+    private void reportProviderMayNotDependOnProducer(DependencyPath path) {
       StringBuilder errorMessage = new StringBuilder();
       if (path.size() == 1) {
         new Formatter(errorMessage)
@@ -882,7 +937,7 @@ private void reportProviderMayNotDependOnProducer(Deque<ResolvedRequest> path) {
         new Formatter(errorMessage).format(ErrorMessages.PROVIDER_MAY_NOT_DEPEND_ON_PRODUCER_FORMAT,
             keyFormatter.format(dependentProvisions.iterator().next().key()));
       }
-      reportBuilder.addError(errorMessage.toString(), path.getLast().request().requestElement());
+      reportBuilder.addError(errorMessage.toString(), path.entryPointElement());
     }
 
     /**
@@ -890,9 +945,8 @@ private void reportProviderMayNotDependOnProducer(Deque<ResolvedRequest> path) {
      * Currently, the only other portions of the message are the dependency path, line number and
      * filename. Not static because it uses the instance field types.
      */
-    private StringBuilder requiresErrorMessageBase(Deque<ResolvedRequest> path) {
-      DependencyRequest request = path.peek().request();
-      Key key = request.key();
+    private StringBuilder requiresErrorMessageBase(DependencyPath path) {
+      Key key = path.currentDependencyRequest().key();
       String requiresErrorMessageFormat;
       // TODO(dpb): Check for wildcard injection somewhere else first?
       if (key.type().getKind().equals(TypeKind.WILDCARD)) {
@@ -920,38 +974,31 @@ private StringBuilder requiresErrorMessageBase(Deque<ResolvedRequest> path) {
           errorMessage.append(ErrorMessages.MEMBERS_INJECTION_DOES_NOT_IMPLY_PROVISION);
         }
       }
-      return errorMessage;
+      return errorMessage.append('\n');
     }
 
-    private void reportMissingBinding(Deque<ResolvedRequest> path) {
-      StringBuilder errorMessage = requiresErrorMessageBase(path);
-      FluentIterable<String> printableDependencyPath =
-          FluentIterable.from(path)
-              .filter(Predicates.not(PREVIOUS_REQUEST_WAS_SYNTHETIC))
-              .transform(REQUEST_FROM_RESOLVED_REQUEST)
-              .transform(dependencyRequestFormatter)
-              .filter(Predicates.not(Predicates.equalTo("")));
-      for (String dependency : printableDependencyPath) {
-        errorMessage.append('\n').append(dependency);
-      }
-      for (String suggestion : MissingBindingSuggestions.forKey(topLevelGraph(),
-          path.peek().request().bindingKey())) {
+    private void reportMissingBinding(DependencyPath path) {
+      StringBuilder errorMessage =
+          requiresErrorMessageBase(path).append(dependencyRequestFormatter.toDependencyTrace(path));
+      for (String suggestion :
+          MissingBindingSuggestions.forKey(
+              topLevelGraph(), path.currentDependencyRequest().bindingKey())) {
         errorMessage.append('\n').append(suggestion);
       }
-      reportBuilder.addError(errorMessage.toString(), path.getLast().request().requestElement());
+      reportBuilder.addError(errorMessage.toString(), path.entryPointElement());
     }
 
     @SuppressWarnings("resource") // Appendable is a StringBuilder.
-    private void reportDependsOnProductionExecutor(Deque<ResolvedRequest> path) {
+    private void reportDependsOnProductionExecutor(DependencyPath path) {
       StringBuilder builder = new StringBuilder();
       new Formatter(builder)
           .format(ErrorMessages.DEPENDS_ON_PRODUCTION_EXECUTOR_FORMAT, formatRootRequestKey(path));
-      reportBuilder.addError(builder.toString(), path.getLast().request().requestElement());
+      reportBuilder.addError(builder.toString(), path.entryPointElement());
     }
 
     @SuppressWarnings("resource") // Appendable is a StringBuilder.
-    private void reportDuplicateBindings(Deque<ResolvedRequest> path) {
-      ResolvedBindings resolvedBinding = path.peek().binding();
+    private void reportDuplicateBindings(DependencyPath path) {
+      ResolvedBindings resolvedBinding = path.currentBinding();
       if (FluentIterable.from(resolvedBinding.contributionBindings())
           .transform(ContributionBinding.KIND)
           .anyMatch(IS_SYNTHETIC_KIND)) {
@@ -965,8 +1012,7 @@ private void reportDuplicateBindings(Deque<ResolvedRequest> path) {
           inlineSyntheticContributions(resolvedBinding).contributionBindings();
       hasSourceElementFormatter.formatIndentedList(
           builder, duplicateBindings, 1, DUPLICATE_SIZE_LIMIT);
-      owningReportBuilder(duplicateBindings)
-          .addError(builder.toString(), path.getLast().request().requestElement());
+      owningReportBuilder(duplicateBindings).addError(builder.toString(), path.entryPointElement());
     }
 
     /**
@@ -1006,11 +1052,11 @@ private void reportDuplicateBindings(Deque<ResolvedRequest> path) {
     }
 
     @SuppressWarnings("resource") // Appendable is a StringBuilder.
-    private void reportMultipleBindingTypes(Deque<ResolvedRequest> path) {
+    private void reportMultipleBindingTypes(DependencyPath path) {
       StringBuilder builder = new StringBuilder();
       new Formatter(builder)
           .format(ErrorMessages.MULTIPLE_BINDING_TYPES_FOR_KEY_FORMAT, formatRootRequestKey(path));
-      ResolvedBindings resolvedBinding = path.peek().binding();
+      ResolvedBindings resolvedBinding = path.currentBinding();
       ImmutableListMultimap<ContributionType, HasSourceElement> declarationsByType =
           declarationsByType(resolvedBinding);
       verify(
@@ -1027,19 +1073,19 @@ private void reportMultipleBindingTypes(Deque<ResolvedRequest> path) {
             builder, declarationsByType.get(type), 2, DUPLICATE_SIZE_LIMIT);
         builder.append('\n');
       }
-      reportBuilder.addError(builder.toString(), path.getLast().request().requestElement());
+      reportBuilder.addError(builder.toString(), path.entryPointElement());
     }
 
     private void reportDuplicateMapKeys(
-        Deque<ResolvedRequest> path, Collection<ContributionBinding> mapBindings) {
+        DependencyPath path, Collection<ContributionBinding> mapBindings) {
       StringBuilder builder = new StringBuilder();
       builder.append(duplicateMapKeysError(formatRootRequestKey(path)));
       hasSourceElementFormatter.formatIndentedList(builder, mapBindings, 1, DUPLICATE_SIZE_LIMIT);
-      reportBuilder.addError(builder.toString(), path.getLast().request().requestElement());
+      reportBuilder.addError(builder.toString(), path.entryPointElement());
     }
 
     private void reportInconsistentMapKeyAnnotations(
-        Deque<ResolvedRequest> path,
+        DependencyPath path,
         Multimap<Equivalence.Wrapper<DeclaredType>, ContributionBinding>
             mapBindingsByAnnotationType) {
       StringBuilder builder =
@@ -1057,51 +1103,24 @@ private void reportInconsistentMapKeyAnnotations(
 
         hasSourceElementFormatter.formatIndentedList(builder, bindings, 2, DUPLICATE_SIZE_LIMIT);
       }
-      reportBuilder.addError(builder.toString(), path.getLast().request().requestElement());
+      reportBuilder.addError(builder.toString(), path.entryPointElement());
     }
 
-    /**
-     * Reports a cycle in the binding path.
-     *
-     * @param bindingPath the binding path, starting with the component provision dependency, and
-     *     ending with the binding that depends on {@code request}
-     * @param request the request that would have been added to the binding path if its
-     *     {@linkplain DependencyRequest#bindingKey() binding key} wasn't already in it
-     * @param indexOfDuplicatedKey the index of the dependency request in {@code bindingPath} whose
-     *     {@linkplain DependencyRequest#bindingKey() binding key} matches {@code request}'s
-     */
-    private void reportCycle(
-        Iterable<ResolvedRequest> bindingPath,
-        DependencyRequest request,
-        int indexOfDuplicatedKey) {
-      ImmutableList<DependencyRequest> requestPath =
-          FluentIterable.from(bindingPath)
-              .transform(REQUEST_FROM_RESOLVED_REQUEST)
-              .append(request)
-              .toList();
-      Element rootRequestElement = requestPath.get(0).requestElement();
-      ImmutableList<DependencyRequest> cycle =
-          requestPath.subList(indexOfDuplicatedKey, requestPath.size());
-      if (!providersBreakingCycle(cycle).isEmpty()) {
+    private void reportCycle(DependencyPath path) {
+      if (!providersBreakingCycle(path.cycle()).isEmpty()) {
         return;
       }
       // TODO(cgruber): Provide a hint for the start and end of the cycle.
-      TypeElement componentType = MoreElements.asType(rootRequestElement.getEnclosingElement());
+      TypeElement componentType =
+          MoreElements.asType(path.entryPointElement().getEnclosingElement());
       reportBuilder.addItem(
           String.format(
               CONTAINS_DEPENDENCY_CYCLE_FORMAT,
               componentType.getQualifiedName(),
-              rootRequestElement.getSimpleName(),
-              FluentIterable.from(bindingPath) // TODO(dpb): Resolve with similar code above.
-                  .skip(1)
-                  .filter(Predicates.not(PREVIOUS_REQUEST_WAS_SYNTHETIC))
-                  .transform(REQUEST_FROM_RESOLVED_REQUEST)
-                  .append(request)
-                  .transform(dependencyRequestFormatter)
-                  .filter(not(equalTo("")))
-                  .join(Joiner.on('\n'))),
+              path.entryPointElement().getSimpleName(),
+              dependencyRequestFormatter.toDependencyTrace(path)),
           ERROR,
-          rootRequestElement);
+          path.entryPointElement());
     }
 
     /**
@@ -1115,13 +1134,14 @@ private void reportCycle(
      * really broken.
      */
     private ImmutableSet<DependencyRequest> providersBreakingCycle(
-        ImmutableList<DependencyRequest> cycle) {
+        ImmutableList<ResolvedRequest> cycle) {
       ImmutableSet.Builder<DependencyRequest> providers = ImmutableSet.builder();
       for (int i = 1; i < cycle.size(); i++) {
-        DependencyRequest dependencyRequest = cycle.get(i);
+        DependencyRequest dependencyRequest = cycle.get(i).request();
         switch (dependencyRequest.kind()) {
           case PROVIDER:
-            if (isDependencyOfSyntheticMap(dependencyRequest, cycle.get(i - 1))) {
+            // TODO(dpb): Just exclude requests from synthetic bindings.
+            if (isDependencyOfSyntheticMap(dependencyRequest, cycle.get(i - 1).request())) {
               i++; // Skip the Provider requests in the Map<K, Provider<V>> too.
             } else {
               providers.add(dependencyRequest);
@@ -1199,10 +1219,10 @@ private void appendIndentedComponentsList(StringBuilder message, Iterable<TypeEl
    * Returns whether the given dependency path would require the most recent request to be resolved
    * by only provision bindings.
    */
-  private boolean doesPathRequireProvisionOnly(Deque<ResolvedRequest> path) {
+  private boolean doesPathRequireProvisionOnly(DependencyPath path) {
     if (path.size() == 1) {
       // if this is an entry-point, then we check the request
-      switch (path.peek().request().kind()) {
+      switch (path.currentDependencyRequest().kind()) {
         case INSTANCE:
         case PROVIDER:
         case LAZY:
@@ -1226,17 +1246,14 @@ private boolean doesPathRequireProvisionOnly(Deque<ResolvedRequest> path) {
    * that is, returns those provision bindings that depend on the latest request in the path.
    */
   private ImmutableSet<? extends Binding> provisionsDependingOnLatestRequest(
-      Deque<ResolvedRequest> path) {
-    Iterator<ResolvedRequest> iterator = path.iterator();
-    final DependencyRequest request = iterator.next().request();
-    ResolvedRequest previousResolvedRequest = iterator.next();
-    return FluentIterable.from(previousResolvedRequest.binding().bindings())
+      final DependencyPath path) {
+    return FluentIterable.from(path.previousBinding().bindings())
         .filter(BindingType.isOfType(BindingType.PROVISION))
         .filter(
             new Predicate<Binding>() {
               @Override
               public boolean apply(Binding binding) {
-                return binding.implicitDependencies().contains(request);
+                return binding.implicitDependencies().contains(path.currentDependencyRequest());
               }
             })
         .toSet();
@@ -1247,6 +1264,7 @@ private String formatContributionType(ContributionType type) {
       case MAP:
         return "Map";
       case SET:
+      case SET_VALUES:
         return "Set";
       case UNIQUE:
         return "Unique";
@@ -1255,8 +1273,8 @@ private String formatContributionType(ContributionType type) {
     }
   }
 
-  private String formatRootRequestKey(Deque<ResolvedRequest> path) {
-    return keyFormatter.format(path.peek().request().key());
+  private String formatRootRequestKey(DependencyPath path) {
+    return keyFormatter.format(path.currentDependencyRequest().key());
   }
 
   @AutoValue
@@ -1283,16 +1301,15 @@ public DependencyRequest apply(ResolvedRequest resolvedRequest) {
         }
       };
 
-  private static final Predicate<ResolvedRequest> PREVIOUS_REQUEST_WAS_SYNTHETIC =
-      new Predicate<ResolvedRequest>() {
+  private static final class PreviousBindingWasSynthetic implements Predicate<ResolvedRequest> {
+    private ResolvedBindings previousBinding;
 
-        boolean previousRequestWasSynthetic;
-
-        @Override
-        public boolean apply(ResolvedRequest resolvedRequest) {
-          boolean returnValue = previousRequestWasSynthetic;
-          previousRequestWasSynthetic = resolvedRequest.binding().isSyntheticContribution();
-          return returnValue;
-        }
-      };
+    @Override
+    public boolean apply(ResolvedRequest resolvedRequest) {
+      boolean previousBindingWasSynthetic =
+          previousBinding != null && previousBinding.isSyntheticContribution();
+      previousBinding = resolvedRequest.binding();
+      return previousBindingWasSynthetic;
+    }
+  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindsMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindsMethodValidator.java
new file mode 100644
index 000000000..2184a8b92
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/BindsMethodValidator.java
@@ -0,0 +1,127 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.common.cache.CacheBuilder;
+import com.google.common.cache.CacheLoader;
+import com.google.common.cache.LoadingCache;
+import com.google.common.collect.Iterables;
+import dagger.Binds;
+import dagger.Module;
+import dagger.producers.ProducerModule;
+import java.util.List;
+import java.util.Set;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
+
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkNotNull;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_NOT_IN_MODULE;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_TYPE_PARAMETER;
+import static dagger.internal.codegen.ErrorMessages.BIND_METHOD_NOT_ABSTRACT;
+import static dagger.internal.codegen.ErrorMessages.BIND_METHOD_ONE_ASSIGNABLE_PARAMETER;
+import static dagger.internal.codegen.Validation.validateMethodQualifiers;
+import static dagger.internal.codegen.Validation.validateReturnType;
+import static dagger.internal.codegen.Validation.validateUncheckedThrows;
+import static javax.lang.model.element.Modifier.ABSTRACT;
+
+/**
+ * A {@linkplain ValidationReport validator} for {@link Bind} methods.
+ */
+final class BindsMethodValidator {
+  private final Elements elements;
+  private final Types types;
+  private final LoadingCache<ExecutableElement, ValidationReport<ExecutableElement>>
+      validationCache;
+
+  BindsMethodValidator(Elements elements, Types types) {
+    this.elements = checkNotNull(elements);
+    this.types = checkNotNull(types);
+    this.validationCache = CacheBuilder.newBuilder().build(new ValidationLoader());
+  }
+
+  private final class ValidationLoader
+      extends CacheLoader<ExecutableElement, ValidationReport<ExecutableElement>> {
+    @Override
+    public ValidationReport<ExecutableElement> load(ExecutableElement bindsMethodElement) {
+      ValidationReport.Builder<ExecutableElement> builder =
+          ValidationReport.about(bindsMethodElement);
+
+      checkArgument(isAnnotationPresent(bindsMethodElement, Binds.class));
+
+      Element enclosingElement = bindsMethodElement.getEnclosingElement();
+      if (!isAnnotationPresent(enclosingElement, Module.class)
+          && !isAnnotationPresent(enclosingElement, ProducerModule.class)) {
+        builder.addError(
+            formatErrorMessage(
+                BINDING_METHOD_NOT_IN_MODULE,
+                String.format(
+                    // the first @ is in the format string
+                    "%s or @%s",
+                    Module.class.getSimpleName(),
+                    ProducerModule.class.getSimpleName())),
+            bindsMethodElement);
+      }
+
+      if (!bindsMethodElement.getTypeParameters().isEmpty()) {
+        builder.addError(formatErrorMessage(BINDING_METHOD_TYPE_PARAMETER), bindsMethodElement);
+      }
+
+      Set<Modifier> modifiers = bindsMethodElement.getModifiers();
+      if (!modifiers.contains(ABSTRACT)) {
+        builder.addError(formatErrorMessage(BIND_METHOD_NOT_ABSTRACT), bindsMethodElement);
+      }
+      TypeMirror returnType = bindsMethodElement.getReturnType();
+      validateReturnType(Binds.class, builder, returnType);
+
+      List<? extends VariableElement> parameters = bindsMethodElement.getParameters();
+      if (parameters.size() == 1) {
+        VariableElement parameter = Iterables.getOnlyElement(parameters);
+        if (!types.isAssignable(parameter.asType(), returnType)) {
+          builder.addError(
+              formatErrorMessage(BIND_METHOD_ONE_ASSIGNABLE_PARAMETER), bindsMethodElement);
+        }
+      } else {
+        builder.addError(
+            formatErrorMessage(BIND_METHOD_ONE_ASSIGNABLE_PARAMETER), bindsMethodElement);
+      }
+
+      validateUncheckedThrows(elements, types, bindsMethodElement, Binds.class, builder);
+
+      validateMethodQualifiers(builder, bindsMethodElement);
+
+      return builder.build();
+    }
+  }
+
+  ValidationReport<ExecutableElement> validate(ExecutableElement bindsMethodElement) {
+    return validationCache.getUnchecked(bindsMethodElement);
+  }
+
+  private String formatErrorMessage(String msg) {
+    return String.format(msg, Binds.class.getSimpleName());
+  }
+
+  private String formatErrorMessage(String msg, String parameter) {
+    return String.format(msg, Binds.class.getSimpleName(), parameter);
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/CodeBlocks.java b/compiler/src/main/java/dagger/internal/codegen/CodeBlocks.java
index 047f455af..dc2bf6ed2 100644
--- a/compiler/src/main/java/dagger/internal/codegen/CodeBlocks.java
+++ b/compiler/src/main/java/dagger/internal/codegen/CodeBlocks.java
@@ -24,11 +24,6 @@
 
 final class CodeBlocks {
 
-  /** Shorthand for a {@link CodeBlock} with a single format and an argument list. */
-  static CodeBlock format(String format, Object... args) {
-    return CodeBlock.builder().add(format, args).build();
-  }
-
   /**
    * Returns a comma-separated version of {@code codeBlocks} as one unified {@link CodeBlock}.
    */
@@ -61,14 +56,14 @@ static CodeBlock join(Iterable<CodeBlock> codeBlocks, String delimiter) {
   }
 
   static CodeBlock stringLiteral(String toWrap) {
-    return format("$S", toWrap);
+    return CodeBlock.of("$S", toWrap);
   }
 
   private static final Function<TypeMirror, CodeBlock> TYPE_MIRROR_TO_CODE_BLOCK =
       new Function<TypeMirror, CodeBlock>() {
         @Override
         public CodeBlock apply(TypeMirror typeMirror) {
-          return CodeBlocks.format("$T", typeMirror);
+          return CodeBlock.of("$T", typeMirror);
         }
       };
 
@@ -76,7 +71,7 @@ public CodeBlock apply(TypeMirror typeMirror) {
       new Function<ParameterSpec, CodeBlock>() {
           @Override
           public CodeBlock apply(ParameterSpec input) {
-            return CodeBlocks.format("$N", input);
+            return CodeBlock.of("$N", input);
           }
       };
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
index 2060f199b..fa3e8e30e 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
@@ -42,7 +42,6 @@
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
-import java.util.concurrent.Executor;
 import javax.inject.Provider;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.ExecutableElement;
@@ -272,11 +271,6 @@ boolean isProducer() {
    */
   abstract ImmutableMap<ExecutableElement, TypeElement> dependencyMethodIndex();
 
-  /**
-   * The element representing {@link Executor}, if it should be a dependency of this component.
-   */
-  abstract Optional<TypeElement> executorDependency();
-
   /**
    * The scopes of the component.
    */
@@ -486,7 +480,6 @@ private ComponentDescriptor create(
         scopes = FluentIterable.from(scopes).append(Scope.productionScope(elements)).toSet();
       }
 
-      Optional<TypeElement> executorDependency = createExecutorDependency(kind, builderSpec);
       return new AutoValue_ComponentDescriptor(
           kind,
           componentMirror,
@@ -494,7 +487,6 @@ private ComponentDescriptor create(
           componentDependencyTypes,
           modules.build(),
           dependencyMethodIndex.build(),
-          executorDependency,
           scopes,
           subcomponentDescriptors.build(),
           componentMethodsBuilder.build(),
@@ -595,25 +587,6 @@ private ComponentMethodDescriptor getDescriptorForComponentMethod(
           map.build(), buildMethod, element.getEnclosingElement().asType()));
     }
 
-    // TODO(beder): Remove the executor dependency when all clients have been updated.
-    private Optional<TypeElement> createExecutorDependency(
-        Kind componentKind, Optional<BuilderSpec> builderSpec) {
-      if (!componentKind.isProducer()) {
-        return Optional.absent();
-      }
-      TypeElement executorTypeElement = elements.getTypeElement(Executor.class.getCanonicalName());
-      if (!builderSpec.isPresent()) {
-        // if there's no builder on a component (not a subcomponent!), we'll add an executor()
-        // method to the generated builder so it must be specified
-        return componentKind.equals(Kind.PRODUCTION_COMPONENT)
-            ? Optional.of(executorTypeElement)
-            : Optional.<TypeElement>absent();
-      }
-      return builderSpec.get().methodMap().containsKey(executorTypeElement)
-          ? Optional.of(executorTypeElement)
-          : Optional.<TypeElement>absent();
-    }
-
     /**
      * Returns a descriptor for a generated module that handles monitoring for production
      * components. This module is generated in the {@link MonitoringModuleProcessingStep}.
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
index 77a63cfd3..b78e8d26b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -84,6 +84,7 @@ public SourceVersion getSupportedSourceVersion() {
     MapKeyValidator mapKeyValidator = new MapKeyValidator();
     ProvidesMethodValidator providesMethodValidator = new ProvidesMethodValidator(elements, types);
     ProducesMethodValidator producesMethodValidator = new ProducesMethodValidator(elements, types);
+    BindsMethodValidator bindsMethodValidator = new BindsMethodValidator(elements, types);
 
     Key.Factory keyFactory = new Key.Factory(types, elements);
 
@@ -113,6 +114,9 @@ public SourceVersion getSupportedSourceVersion() {
     MembersInjectionBinding.Factory membersInjectionBindingFactory =
         new MembersInjectionBinding.Factory(elements, types, keyFactory, dependencyRequestFactory);
 
+    DelegateDeclaration.Factory bindingDelegateDeclarationFactory =
+        new DelegateDeclaration.Factory(types, keyFactory, dependencyRequestFactory);
+
     this.injectBindingRegistry =
         new InjectBindingRegistry(
             elements,
@@ -129,7 +133,8 @@ public SourceVersion getSupportedSourceVersion() {
             elements,
             provisionBindingFactory,
             productionBindingFactory,
-            multibindingDeclarationFactory);
+            multibindingDeclarationFactory,
+            bindingDelegateDeclarationFactory);
 
     ComponentDescriptor.Factory componentDescriptorFactory = new ComponentDescriptor.Factory(
         elements, types, dependencyRequestFactory, moduleDescriptorFactory);
@@ -162,11 +167,13 @@ public SourceVersion getSupportedSourceVersion() {
         new MonitoringModuleProcessingStep(messager, monitoringModuleGenerator),
         new ProductionExecutorModuleProcessingStep(messager, productionExecutorModuleGenerator),
         new MultibindingsProcessingStep(messager, multibindingsValidator),
+        new MultibindingAnnotationsProcessingStep(messager),
         new ModuleProcessingStep(
             messager,
             moduleValidator,
             providesMethodValidator,
             provisionBindingFactory,
+            bindsMethodValidator,
             factoryGenerator),
         new ComponentProcessingStep(
             ComponentDescriptor.Kind.COMPONENT,
@@ -183,6 +190,7 @@ public SourceVersion getSupportedSourceVersion() {
             messager,
             moduleValidator,
             producesMethodValidator,
+            bindsMethodValidator,
             productionBindingFactory,
             producerFactoryGenerator),
         new ComponentProcessingStep(
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
index d47a3c68c..4fd5f414b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
@@ -143,7 +143,7 @@ public ComponentValidationReport validate(final TypeElement subject,
           String.format(ErrorMessages.builderMsgsFor(componentKind).moreThanOne(), builders),
           subject);
     }
-    
+
     Optional<AnnotationMirror> reusableAnnotation = getAnnotationMirror(subject, Reusable.class);
     if (reusableAnnotation.isPresent()) {
       builder.addError(COMPONENT_ANNOTATED_REUSABLE, subject, reusableAnnotation.get());
@@ -240,7 +240,7 @@ public ComponentValidationReport validate(final TypeElement subject,
         getAnnotationMirror(subject, componentKind.annotationType()).get();
     ImmutableList<TypeMirror> moduleTypes = getComponentModules(componentMirror);
     moduleValidator.validateReferencedModules(
-        subject, builder, moduleTypes, componentKind.moduleKinds());
+        subject, componentMirror, builder, moduleTypes, componentKind.moduleKinds());
 
     // Make sure we validate any subcomponents we're referencing, unless we know we validated
     // them already in this pass.
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java
index 9e46214e5..ccccf9032 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java
@@ -39,7 +39,7 @@
 import static com.squareup.javapoet.MethodSpec.methodBuilder;
 import static com.squareup.javapoet.TypeSpec.classBuilder;
 import static dagger.internal.codegen.TypeSpecs.addSupertype;
-import static dagger.internal.codegen.Util.componentCanMakeNewInstances;
+import static dagger.internal.codegen.Util.requiresAPassedInstance;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PUBLIC;
 import static javax.lang.model.element.Modifier.STATIC;
@@ -142,7 +142,7 @@ public String apply(ComponentDescriptor componentDescriptor) {
 
   @Override
   protected TypeSpec.Builder createComponentClass() {
-    TypeSpec.Builder component = classBuilder(name.simpleName()).addModifiers(PUBLIC, FINAL);
+    TypeSpec.Builder component = classBuilder(name).addModifiers(PUBLIC, FINAL);
     addSupertype(component, componentDefinitionType());
     return component;
   }
@@ -195,12 +195,12 @@ protected void addFactoryMethods() {
 
   /** {@code true} if all of the graph's required dependencies can be automatically constructed. */
   private boolean canInstantiateAllRequirements() {
-    return Iterables.all(
+    return !Iterables.any(
         graph.componentRequirements(),
         new Predicate<TypeElement>() {
           @Override
           public boolean apply(TypeElement dependency) {
-            return componentCanMakeNewInstances(dependency);
+            return requiresAPassedInstance(elements, dependency);
           }
         });
   }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
index 6aec6a795..2d9298e14 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
@@ -123,6 +123,12 @@ public Kind apply(ContributionBinding binding) {
      */
     SYNTHETIC_MULTIBOUND_MAP,
 
+    /**
+     * A binding (provision or production) that delegates from requests for one key to another.
+     * These are the bindings that satisfy {@code @Bind} declarations.
+     */
+    SYNTHETIC_DELEGATE_BINDING,
+
     // Provision kinds
 
     /** An {@link Inject}-annotated constructor. */
@@ -142,13 +148,6 @@ public Kind apply(ContributionBinding binding) {
      */
     SUBCOMPONENT_BUILDER,
 
-    /**
-     * The executor provided in a builder for a production component. This executor is used to
-     * schedule producer methods, and its specification on the component builder is to provide an
-     * implicit provision for it.
-     */
-    EXECUTOR_DEPENDENCY,
-
     // Production kinds
 
     /** A {@link Produces}-annotated method that doesn't return a {@link ListenableFuture}. */
@@ -171,7 +170,11 @@ public Kind apply(ContributionBinding binding) {
      */
     static final Predicate<Kind> IS_SYNTHETIC_KIND =
         Predicates.in(
-            immutableEnumSet(SYNTHETIC_MAP, SYNTHETIC_MULTIBOUND_SET, SYNTHETIC_MULTIBOUND_MAP));
+            immutableEnumSet(
+                SYNTHETIC_MAP,
+                SYNTHETIC_MULTIBOUND_SET,
+                SYNTHETIC_MULTIBOUND_MAP,
+                SYNTHETIC_DELEGATE_BINDING));
 
     /**
      * A predicate that tests whether a kind is for synthetic multibindings.
@@ -200,21 +203,6 @@ static Kind forMultibindingRequest(DependencyRequest request) {
    * The kind of this contribution binding.
    */
   protected abstract Kind bindingKind();
-  
-  /**
-   * A predicate that passes for bindings of a given kind.
-   */
-  static Predicate<ContributionBinding> isOfKind(Kind kind) {
-    return Predicates.compose(Predicates.equalTo(kind), KIND);
-  }
-
-  /** The provision type that was used to bind the key. */
-  abstract Provides.Type provisionType();
-
-  @Override
-  public ContributionType contributionType() {
-    return ContributionType.forProvisionType(provisionType());
-  }
 
   /**
    * The strategy for getting an instance of a factory for a {@link ContributionBinding}.
@@ -224,6 +212,8 @@ public ContributionType contributionType() {
     ENUM_INSTANCE,
     /** The factory must be created by calling the constructor. */
     CLASS_CONSTRUCTOR,
+    /** The factory is simply delegated to another. */
+    DELEGATE,
   }
 
   /**
@@ -233,18 +223,18 @@ public ContributionType contributionType() {
    */
   FactoryCreationStrategy factoryCreationStrategy() {
     switch (bindingKind()) {
+      case SYNTHETIC_DELEGATE_BINDING:
+        return FactoryCreationStrategy.DELEGATE;
       case PROVISION:
         return implicitDependencies().isEmpty() && bindingElement().getModifiers().contains(STATIC)
             ? FactoryCreationStrategy.ENUM_INSTANCE
             : FactoryCreationStrategy.CLASS_CONSTRUCTOR;
-
       case INJECTION:
       case SYNTHETIC_MULTIBOUND_SET:
       case SYNTHETIC_MULTIBOUND_MAP:
         return implicitDependencies().isEmpty()
             ? FactoryCreationStrategy.ENUM_INSTANCE
             : FactoryCreationStrategy.CLASS_CONSTRUCTOR;
-        
       default:
         return FactoryCreationStrategy.CLASS_CONSTRUCTOR;
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ContributionType.java b/compiler/src/main/java/dagger/internal/codegen/ContributionType.java
index a1033932a..b5966695a 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ContributionType.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ContributionType.java
@@ -18,6 +18,15 @@
 import com.google.common.base.Function;
 import com.google.common.collect.ImmutableListMultimap;
 import com.google.common.collect.Multimaps;
+import dagger.Provides;
+import dagger.multibindings.ElementsIntoSet;
+import dagger.multibindings.IntoMap;
+import dagger.multibindings.IntoSet;
+import dagger.producers.Produces;
+import javax.lang.model.element.ExecutableElement;
+
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
+import static com.google.common.base.Preconditions.checkArgument;
 
 /**
  * Whether a binding or declaration is for a unique contribution or a map or set multibinding.
@@ -27,6 +36,8 @@
   MAP,
   /** Represents set bindings. */
   SET,
+  /** Represents set values bindings. */
+  SET_VALUES,
   /** Represents a valid non-collection binding. */
   UNIQUE,
   ;
@@ -48,11 +59,12 @@ boolean isMultibinding() {
   }
 
   /** The contribution type for a given provision type. */
-  static ContributionType forProvisionType(dagger.Provides.Type provisionType) {
+  private static ContributionType forProvisionType(Provides.Type provisionType) {
     switch (provisionType) {
       case SET:
-      case SET_VALUES:
         return SET;
+      case SET_VALUES:
+        return SET_VALUES;
       case MAP:
         return MAP;
       case UNIQUE:
@@ -62,6 +74,47 @@ static ContributionType forProvisionType(dagger.Provides.Type provisionType) {
     }
   }
 
+  private static ContributionType forProductionType(Produces.Type productionType) {
+    switch (productionType) {
+      case SET:
+        return SET;
+      case SET_VALUES:
+        return SET_VALUES;
+      case MAP:
+        return MAP;
+      case UNIQUE:
+        return UNIQUE;
+      default:
+        throw new AssertionError("Unknown production type: " + productionType);
+    }
+  }
+
+  /**
+   * The contribution type from a binding method annotations. Presumes a well-formed binding method
+   * (only one of @IntoSet, @IntoMap, @ElementsIntoSet, @Provides.type or @Produces.type. {@link
+   * ProvidesMethodValidator} and {@link ProducesMethodValidator} validate correctness on their own.
+   */
+  static ContributionType fromBindingMethod(ExecutableElement method) {
+    checkArgument(
+        isAnnotationPresent(method, Provides.class)
+            || isAnnotationPresent(method, Produces.class));
+    if (isAnnotationPresent(method, IntoMap.class)) {
+      return ContributionType.MAP;
+    } else if (isAnnotationPresent(method, IntoSet.class)) {
+      return ContributionType.SET;
+    } else if (isAnnotationPresent(method, ElementsIntoSet.class)) {
+      return ContributionType.SET_VALUES;
+    }
+
+    if (isAnnotationPresent(method, Provides.class)) {
+      return forProvisionType(method.getAnnotation(Provides.class).type());
+    } else if (isAnnotationPresent(method, Produces.class)) {
+      return forProductionType(method.getAnnotation(Produces.class).type());
+    } else {
+      throw new AssertionError();
+    }
+  }
+
   /** Indexes objects by their contribution type. */
   static <T extends HasContributionType>
       ImmutableListMultimap<ContributionType, T> indexByContributionType(
diff --git a/compiler/src/main/java/dagger/internal/codegen/DelegateDeclaration.java b/compiler/src/main/java/dagger/internal/codegen/DelegateDeclaration.java
new file mode 100644
index 000000000..78cc5d102
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/DelegateDeclaration.java
@@ -0,0 +1,73 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.common.MoreElements;
+import com.google.auto.common.MoreTypes;
+import com.google.auto.value.AutoValue;
+import com.google.common.collect.Iterables;
+import dagger.Binds;
+import dagger.internal.codegen.ContributionType.HasContributionType;
+import dagger.internal.codegen.Key.HasKey;
+import dagger.internal.codegen.SourceElement.HasSourceElement;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.ExecutableType;
+import javax.lang.model.util.Types;
+
+import static com.google.common.base.Preconditions.checkArgument;
+import static dagger.internal.codegen.ContributionType.UNIQUE;
+
+/**
+ * The declaration for a delegate binding established by a {@link Bind} method.
+ */
+@AutoValue
+abstract class DelegateDeclaration implements HasKey, HasSourceElement, HasContributionType {
+  abstract DependencyRequest delegateRequest();
+
+  @Override
+  public ContributionType contributionType() {
+    return UNIQUE;
+  }
+
+  static final class Factory {
+    private final Types types;
+    private final Key.Factory keyFactory;
+    private final DependencyRequest.Factory dependencyRequestFactory;
+
+    Factory(
+        Types types, Key.Factory keyFactory, DependencyRequest.Factory dependencyRequestFactory) {
+      this.types = types;
+      this.keyFactory = keyFactory;
+      this.dependencyRequestFactory = dependencyRequestFactory;
+    }
+
+    DelegateDeclaration create(
+        ExecutableElement bindsMethod, TypeElement contributingElement) {
+      checkArgument(MoreElements.isAnnotationPresent(bindsMethod, Binds.class));
+      SourceElement sourceElement = SourceElement.forElement(bindsMethod, contributingElement);
+      ExecutableType resolvedMethod =
+          MoreTypes.asExecutable(sourceElement.asMemberOfContributingType(types));
+      DependencyRequest delegateRequest =
+          dependencyRequestFactory.forRequiredResolvedVariable(
+              MoreTypes.asDeclared(contributingElement.asType()),
+              Iterables.getOnlyElement(bindsMethod.getParameters()),
+              Iterables.getOnlyElement(resolvedMethod.getParameterTypes()));
+      return new AutoValue_DelegateDeclaration(
+          keyFactory.forBindsMethod(sourceElement), sourceElement, delegateRequest);
+    }
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
index 8866cb570..f25b941a8 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
@@ -28,6 +28,7 @@
 import dagger.Lazy;
 import dagger.MembersInjector;
 import dagger.Provides;
+import dagger.internal.codegen.DependencyRequest.Factory.KindAndType;
 import dagger.producers.Produced;
 import dagger.producers.Producer;
 import dagger.producers.internal.AbstractProducer;
@@ -47,6 +48,8 @@
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.SimpleTypeVisitor7;
 
+import static com.google.auto.common.MoreTypes.asDeclared;
+import static com.google.auto.common.MoreTypes.isType;
 import static com.google.auto.common.MoreTypes.isTypeOf;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
@@ -74,22 +77,25 @@
   enum Kind {
     /** A default request for an instance.  E.g.: {@code Blah} */
     INSTANCE,
-    
+
     /** A request for a {@link Provider}.  E.g.: {@code Provider<Blah>} */
     PROVIDER(Provider.class),
-    
+
     /** A request for a {@link Lazy}.  E.g.: {@code Lazy<Blah>} */
     LAZY(Lazy.class),
-    
+
+    /** A request for a {@link Provider} of a {@link Lazy}. E.g.: {@code Provider<Lazy<Blah>>} */
+    PROVIDER_OF_LAZY,
+
     /** A request for a {@link MembersInjector}.  E.g.: {@code MembersInjector<Blah>} */
     MEMBERS_INJECTOR(MembersInjector.class),
-    
+
     /** A request for a {@link Producer}.  E.g.: {@code Producer<Blah>} */
     PRODUCER(Producer.class),
-    
+
     /** A request for a {@link Produced}.  E.g.: {@code Produced<Blah>} */
     PRODUCED(Produced.class),
-    
+
     /**
      * A request for a {@link ListenableFuture}.  E.g.: {@code ListenableFuture<Blah>}.
      * These can only be requested by component interfaces.
@@ -106,6 +112,23 @@
     Kind() {
       this.frameworkClass = Optional.absent();
     }
+    
+    /**
+     * If {@code type}'s raw type is {@link #frameworkClass}, returns a {@link KindAndType} with
+     * this kind that represents the dependency request.
+     */
+    Optional<KindAndType> from(TypeMirror type) {
+      return frameworkClass.isPresent() && isType(type) && isTypeOf(frameworkClass.get(), type)
+          ? Optional.of(this.ofType(getOnlyElement(asDeclared(type).getTypeArguments())))
+          : Optional.<KindAndType>absent();
+    }
+
+    /**
+     * Returns a {@link KindAndType} with this kind and {@code type} type.
+     */
+    KindAndType ofType(TypeMirror type) {
+      return new AutoValue_DependencyRequest_Factory_KindAndType(this, type);
+    }
   }
 
   abstract Kind kind();
@@ -116,6 +139,7 @@ BindingKey bindingKey() {
       case INSTANCE:
       case LAZY:
       case PROVIDER:
+      case PROVIDER_OF_LAZY:
       case PRODUCER:
       case PRODUCED:
       case FUTURE:
@@ -232,6 +256,7 @@ private Kind multibindingContributionRequestKind(ContributionBinding multibindin
               ? Kind.PRODUCER
               : Kind.PROVIDER;
         case SET:
+        case SET_VALUES:
           return Kind.INSTANCE;
         case UNIQUE:
           throw new IllegalArgumentException(
@@ -402,6 +427,31 @@ private DependencyRequest newDependencyRequest(
     static abstract class KindAndType {
       abstract Kind kind();
       abstract TypeMirror type();
+
+      static Optional<KindAndType> from(TypeMirror type) {
+        for (Kind kind : Kind.values()) {
+          Optional<KindAndType> kindAndType = kind.from(type);
+          if (kindAndType.isPresent()) {
+            return kindAndType.get().maybeProviderOfLazy().or(kindAndType);
+          }
+        }
+        return Optional.absent();
+      }
+
+      /**
+       * If {@code kindAndType} represents a {@link Kind#PROVIDER} of a {@code Lazy<T>} for some
+       * type {@code T}, then this method returns ({@link Kind#PROVIDER_OF_LAZY}, {@code T}).
+       */
+      private Optional<KindAndType> maybeProviderOfLazy() {
+        if (kind().equals(Kind.PROVIDER)) {
+          Optional<KindAndType> providedKindAndType = from(type());
+          if (providedKindAndType.isPresent()
+              && providedKindAndType.get().kind().equals(Kind.LAZY)) {
+            return Optional.of(Kind.PROVIDER_OF_LAZY.ofType(providedKindAndType.get().type()));
+          }
+        }
+        return Optional.absent();
+      }
     }
 
     /**
@@ -427,14 +477,7 @@ public KindAndType visitExecutable(ExecutableType executableType, Void p) {
 
             @Override
             public KindAndType visitDeclared(DeclaredType declaredType, Void p) {
-              for (Kind kind : Kind.values()) {
-                if (kind.frameworkClass.isPresent()
-                    && isTypeOf(kind.frameworkClass.get(), declaredType)) {
-                  return new AutoValue_DependencyRequest_Factory_KindAndType(
-                      kind, Iterables.getOnlyElement(declaredType.getTypeArguments()));
-                }
-              }
-              return defaultAction(declaredType, p);
+              return KindAndType.from(declaredType).or(defaultAction(declaredType, p));
             }
 
             @Override
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyRequestFormatter.java b/compiler/src/main/java/dagger/internal/codegen/DependencyRequestFormatter.java
index db8fc8aef..cd783be2a 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DependencyRequestFormatter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyRequestFormatter.java
@@ -16,9 +16,12 @@
 package dagger.internal.codegen;
 
 import com.google.auto.common.MoreElements;
+import com.google.common.base.Joiner;
 import com.google.common.base.Optional;
+import com.google.common.base.Predicates;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import dagger.Provides;
+import dagger.internal.codegen.BindingGraphValidator.DependencyPath;
 import dagger.producers.Produces;
 import javax.inject.Inject;
 import javax.lang.model.element.AnnotationMirror;
@@ -40,20 +43,20 @@
  * 
  * <dl>
  * <dt>For component provision methods
- * <dd>{@code ComponentType.method() injects @Qualifier SomeType}
+ * <dd>{@code @Qualifier SomeType is provided at\n    ComponentType.method()}
  * 
  * <dt>For component injection methods
- * <dd>{@code ComponentType.method(foo) injects SomeType}
+ * <dd>{@code SomeType is injected at\n    ComponentType.method(foo)}
  * 
  * <dt>For parameters to {@link Provides @Provides}, {@link Produces @Produces}, or
  * {@link Inject @Inject} methods:
- * <dd>{@code EnclosingType.method([…, ]param[, …]) injects @Qualified ResolvedType}
+ * <dd>{@code @Qualified ResolvedType is injected at\n    EnclosingType.method([…, ]param[, …])}
  * 
  * <dt>For parameters to {@link Inject @Inject} constructors:
- * <dd>{@code EnclosingType.<init>([…, ]param[, …]) injects @Qualified ResolvedType}
+ * <dd>{@code @Qualified ResolvedType is injected at\n    EnclosingType.<init>([…, ]param[, …])}
  * 
  * <dt>For {@link Inject @Inject} fields:
- * <dd>{@code EnclosingType.field injects @Qualified ResolvedType}
+ * <dd>{@code @Qualified ResolvedType is injected at\n    EnclosingType.field}
  * </dl>
  */
 final class DependencyRequestFormatter extends Formatter<DependencyRequest> {
@@ -66,6 +69,22 @@
     this.elements = elements;
   }
 
+  /**
+   * A string representation of the dependency trace, starting with the
+   * {@linkplain DependencyPath#currentDependencyRequest() current request} and ending with the
+   * entry point.
+   */
+  String toDependencyTrace(DependencyPath dependencyPath) {
+    return Joiner.on('\n')
+        .join(
+            dependencyPath
+                .nonsyntheticRequests()
+                .transform(this)
+                .filter(Predicates.not(Predicates.equalTo("")))
+                .toList()
+                .reverse());
+  }
+
   // TODO(cgruber): Sweep this class for TypeMirror.toString() usage and do some preventive format.
   // TODO(cgruber): consider returning a small structure containing strings to be indented later.
   @Override
@@ -80,17 +99,17 @@ public String format(DependencyRequest request) {
               public String visitExecutableAsMethod(
                   ExecutableElement method, DependencyRequest request) {
                 StringBuilder builder = new StringBuilder(INDENT);
+                appendRequestedKeyAndVerb(
+                    builder,
+                    request.key().qualifier(),
+                    request.key().type(),
+                    componentMethodRequestVerb(request));
                 appendEnclosingTypeAndMemberName(method, builder);
                 builder.append('(');
                 for (VariableElement parameter : method.getParameters()) {
                   builder.append(parameter.getSimpleName());
                 }
                 builder.append(')');
-                appendRequest(
-                    builder,
-                    componentMethodRequestVerb(request),
-                    request.key().qualifier(),
-                    request.key().type());
                 return builder.toString();
               }
 
@@ -103,9 +122,10 @@ public String visitExecutableAsMethod(
               public String visitVariableAsParameter(
                   final VariableElement variable, DependencyRequest request) {
                 StringBuilder builder = new StringBuilder(INDENT);
+                appendRequestedKeyAndVerb(request, builder);
+
                 ExecutableElement methodOrConstructor =
                     asExecutable(variable.getEnclosingElement());
-
                 appendEnclosingTypeAndMemberName(methodOrConstructor, builder).append('(');
                 int parameterIndex = methodOrConstructor.getParameters().indexOf(variable);
                 if (parameterIndex > 0) {
@@ -116,7 +136,6 @@ public String visitVariableAsParameter(
                   builder.append(", …");
                 }
                 builder.append(')');
-                appendRequest(builder, request);
                 return builder.toString();
               }
 
@@ -125,8 +144,8 @@ public String visitVariableAsParameter(
               public String visitVariableAsField(
                   VariableElement variable, DependencyRequest request) {
                 StringBuilder builder = new StringBuilder(INDENT);
+                appendRequestedKeyAndVerb(request, builder);
                 appendEnclosingTypeAndMemberName(variable, builder);
-                appendRequest(builder, request);
                 return builder.toString();
               }
 
@@ -144,15 +163,18 @@ protected String defaultAction(Element element, DependencyRequest request) {
             request);
   }
 
-  private void appendRequest(StringBuilder builder, DependencyRequest request) {
-    appendRequest(
-        builder, "injects", request.key().qualifier(), requestedTypeWithFrameworkClass(request));
+  private void appendRequestedKeyAndVerb(DependencyRequest request, StringBuilder builder) {
+    appendRequestedKeyAndVerb(
+        builder, request.key().qualifier(), requestedTypeWithFrameworkClass(request), "injected");
   }
 
-  private void appendRequest(
-      StringBuilder builder, String verb, Optional<AnnotationMirror> qualifier, TypeMirror type) {
-    builder.append("\n    ").append(INDENT).append(verb).append(' ');
-    appendQualifiedType(builder, qualifier, type);
+  private void appendRequestedKeyAndVerb(
+      StringBuilder builder,
+      Optional<AnnotationMirror> qualifier,
+      TypeMirror requestedType,
+      String verb) {
+    appendQualifiedType(builder, qualifier, requestedType);
+    builder.append(" is ").append(verb).append(" at\n    ").append(INDENT);
   }
 
   private TypeMirror requestedTypeWithFrameworkClass(DependencyRequest request) {
@@ -174,22 +196,22 @@ private void appendQualifiedType(
   }
 
   /**
-   * Returns the verb for a component method dependency request. Returns "produces", "provides", or
-   * "injects", depending on the kind of request.
+   * Returns the verb for a component method dependency request. Returns "produced", "provided", or
+   * "injected", depending on the kind of request.
    */
   private String componentMethodRequestVerb(DependencyRequest request) {
     switch (request.kind()) {
       case FUTURE:
       case PRODUCER:
-        return "produces";
+        return "produced";
 
       case INSTANCE:
       case LAZY:
       case PROVIDER:
-        return "provides";
+        return "provided";
 
       case MEMBERS_INJECTOR:
-        return "injects";
+        return "injected";
 
       case PRODUCED:
       default:
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyRequestMapper.java b/compiler/src/main/java/dagger/internal/codegen/DependencyRequestMapper.java
index 9ca294206..c57bed0b0 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DependencyRequestMapper.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyRequestMapper.java
@@ -60,6 +60,7 @@
       switch (request.kind()) {
         case INSTANCE:
         case PROVIDER:
+        case PROVIDER_OF_LAZY:
         case LAZY:
           return Provider.class;
         case MEMBERS_INJECTOR:
@@ -83,6 +84,7 @@
         case PRODUCER:
           return Producer.class;
         case PROVIDER:
+        case PROVIDER_OF_LAZY:
         case LAZY:
           return Provider.class;
         case MEMBERS_INJECTOR:
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyVariableNamer.java b/compiler/src/main/java/dagger/internal/codegen/DependencyVariableNamer.java
index b12a854d9..81a2d13eb 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DependencyVariableNamer.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyVariableNamer.java
@@ -19,6 +19,8 @@
 import com.google.common.base.CaseFormat;
 import com.google.common.base.Function;
 import dagger.Lazy;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
 import javax.inject.Provider;
 
 /**
@@ -32,6 +34,8 @@
  */
 //TODO(gak): develop the heuristics to get better names
 final class DependencyVariableNamer implements Function<DependencyRequest, String> {
+  private static final Pattern LAZY_PROVIDER_PATTERN = Pattern.compile("lazy(\\w+)Provider");
+
   @Override
   public String apply(DependencyRequest dependency) {
     if (dependency.overriddenVariableName().isPresent()) {
@@ -48,6 +52,12 @@ public String apply(DependencyRequest dependency) {
         return variableName.startsWith("lazy") && !variableName.equals("lazy")
             ? toLowerCamel(variableName.substring(4))
             : variableName;
+      case PROVIDER_OF_LAZY:
+        Matcher matcher = LAZY_PROVIDER_PATTERN.matcher(variableName);
+        if (matcher.matches()) {
+          return toLowerCamel(matcher.group(1));
+        }
+        // fall through
       case PROVIDER:
         return variableName.endsWith("Provider") && !variableName.equals("Provider")
             ? variableName.substring(0, variableName.length() - 8)
diff --git a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
index ef091ee0f..b8a439417 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
@@ -74,20 +74,22 @@
       "@Inject constructors are invalid on inner classes";
   static final String INJECT_CONSTRUCTOR_ON_ABSTRACT_CLASS =
       "@Inject is nonsense on the constructor of an abstract class";
-    static final String QUALIFIER_ON_INJECT_CONSTRUCTOR =
+  static final String QUALIFIER_ON_INJECT_CONSTRUCTOR =
       "@Qualifier annotations are not allowed on @Inject constructors.";
+  static final String SCOPE_ON_INJECT_CONSTRUCTOR =
+      "@Scope annotations are not allowed on @Inject constructors. Annotate the class instead.";
 
   /* fields */
   static final String PRIVATE_INJECT_FIELD =
       "Dagger does not support injection into private fields";
-  
+
   static final String STATIC_INJECT_FIELD =
       "Dagger does not support injection into static fields";
 
   /* methods */
   static final String PRIVATE_INJECT_METHOD =
       "Dagger does not support injection into private methods";
-  
+
   static final String STATIC_INJECT_METHOD =
       "Dagger does not support injection into static methods";
 
@@ -98,7 +100,7 @@
   static final String CANNOT_INJECT_WILDCARD_TYPE =
       "Dagger does not support injecting Provider<T>, Lazy<T> or Produced<T> when T is a wildcard "
           + "type such as <%s>.";
-  
+
   /*
    * Configuration errors
    *
@@ -118,13 +120,13 @@ static String inconsistentMapKeyAnnotationsError(String key) {
 
   static final String COMPONENT_ANNOTATED_REUSABLE =
       "@Reusable cannot be applied to components or subcomponents.";
-  
-  static final String PROVIDES_METHOD_RETURN_TYPE =
-      "@Provides methods must either return a primitive, an array, a type variable, or a declared"
+
+  static final String BINDING_METHOD_RETURN_TYPE =
+      "@%s methods must either return a primitive, an array, a type variable, or a declared"
           + " type.";
 
-  static final String PROVIDES_METHOD_THROWS =
-      "@Provides methods may only throw unchecked exceptions";
+  static final String BINDING_METHOD_THROWS_CHECKED =
+      "@%s methods may only throw unchecked exceptions";
 
   static final String PRODUCES_METHOD_NULLABLE =
       "@Nullable on @Produces methods does not do anything.";
@@ -151,13 +153,21 @@ static String inconsistentMapKeyAnnotationsError(String key) {
   static final String BINDING_METHOD_MUST_RETURN_A_VALUE =
       "@%s methods must return a value (not void).";
 
+  static final String BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES =
+      "@%s methods must not return framework types.";
+
   static final String BINDING_METHOD_ABSTRACT = "@%s methods cannot be abstract";
 
+  static final String BIND_METHOD_NOT_ABSTRACT = "@Bind methods must be abstract";
+
   static final String BINDING_METHOD_PRIVATE = "@%s methods cannot be private";
 
   static final String BINDING_METHOD_TYPE_PARAMETER =
       "@%s methods may not have type parameters.";
 
+  static final String BIND_METHOD_ONE_ASSIGNABLE_PARAMETER =
+      "@Bind methods must have only one parameter whose type is assignable to the return type";
+
   static final String BINDING_METHOD_NOT_IN_MODULE =
       "@%s methods can only be present within a @%s";
 
@@ -173,6 +183,10 @@ static String inconsistentMapKeyAnnotationsError(String key) {
   static final String BINDING_METHOD_WITH_SAME_NAME =
       "Cannot have more than one @%s method with the same name in a single module";
 
+  static final String INCOMPATIBLE_MODULE_METHODS =
+      "A @%1$s may contain non-static @%2$s methods or @Bind methods,"
+          + " but not both at the same time.  (Static @%2$s may be used with either.)";
+
   static final String MODULES_WITH_TYPE_PARAMS_MUST_BE_ABSTRACT =
       "Modules with type parameters must be abstract";
 
@@ -191,8 +205,8 @@ static String inconsistentMapKeyAnnotationsError(String key) {
   static final String METHOD_OVERRIDES_PROVIDES_METHOD =
       "@%s methods may not be overridden in modules. Overrides: %s";
 
-  static final String PROVIDES_OR_PRODUCES_METHOD_MULTIPLE_QUALIFIERS =
-      "Cannot use more than one @Qualifier on a @Provides or @Produces method";
+  static final String BINDING_METHOD_MULTIPLE_QUALIFIERS =
+      "Cannot use more than one @Qualifier";
 
   /* mapKey errors*/
   static final String MAPKEY_WITHOUT_MEMBERS =
@@ -213,7 +227,7 @@ static String inconsistentMapKeyAnnotationsError(String key) {
 
   static final String PROVIDER_MAY_NOT_DEPEND_ON_PRODUCER_FORMAT =
       "%s is a provision, which cannot depend on a production.";
-  
+
   static final String DEPENDS_ON_PRODUCTION_EXECUTOR_FORMAT =
       "%s may not depend on the production executor.";
 
@@ -270,6 +284,16 @@ static String nullableToNonNullable(String typeName, String bindingString) {
   static final String CANNOT_RETURN_NULL_FROM_NON_NULLABLE_PROVIDES_METHOD =
       "Cannot return null from a non-@Nullable @Provides method";
 
+  /* Multibinding messages */
+  static final String MULTIBINDING_ANNOTATION_NOT_ON_PROVIDES_OR_PRODUCES =
+      "Multibinding annotations may only be on @Provides or @Produces methods";
+
+  static final String MULTIPLE_MULTIBINDING_ANNOTATIONS_ON_METHOD =
+      "Multiple multibinding annotations cannot be placed on the same %s method";
+
+  static final String MULTIBINDING_ANNOTATION_CONFLICTS_WITH_BINDING_ANNOTATION_ENUM =
+      "@%s.type cannot be used with multibinding annotations";
+
   static ComponentBuilderMessages builderMsgsFor(ComponentDescriptor.Kind kind) {
     switch(kind) {
       case COMPONENT:
diff --git a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
index 2bbcb2414..a9350edfe 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
@@ -29,6 +29,7 @@
 import com.squareup.javapoet.TypeName;
 import com.squareup.javapoet.TypeSpec;
 import com.squareup.javapoet.TypeVariableName;
+import dagger.Provides;
 import dagger.internal.Factory;
 import dagger.internal.MembersInjectors;
 import dagger.internal.Preconditions;
@@ -47,13 +48,13 @@
 import static com.squareup.javapoet.MethodSpec.methodBuilder;
 import static com.squareup.javapoet.TypeSpec.classBuilder;
 import static com.squareup.javapoet.TypeSpec.enumBuilder;
-import static dagger.Provides.Type.SET;
 import static dagger.internal.codegen.AnnotationSpecs.SUPPRESS_WARNINGS_RAWTYPES;
 import static dagger.internal.codegen.AnnotationSpecs.SUPPRESS_WARNINGS_UNCHECKED;
 import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
 import static dagger.internal.codegen.ContributionBinding.FactoryCreationStrategy.ENUM_INSTANCE;
 import static dagger.internal.codegen.ContributionBinding.Kind.INJECTION;
 import static dagger.internal.codegen.ContributionBinding.Kind.PROVISION;
+import static dagger.internal.codegen.ContributionType.SET;
 import static dagger.internal.codegen.ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_PROVIDES_METHOD;
 import static dagger.internal.codegen.SourceFiles.bindingTypeElementTypeVariableNames;
 import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
@@ -126,7 +127,7 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
         break;
       case CLASS_CONSTRUCTOR:
         factoryBuilder =
-            classBuilder(generatedTypeName.simpleName())
+            classBuilder(generatedTypeName)
                 .addTypeVariables(typeParameters)
                 .addModifiers(FINAL);
         constructorBuilder = Optional.of(constructorBuilder().addModifiers(PUBLIC));
@@ -146,6 +147,8 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
               constructorBuilder.get());
         }
         break;
+      case DELEGATE:
+        return Optional.absent();
       default:
         throw new AssertionError();
     }
@@ -211,7 +214,7 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
     for (DependencyRequest dependency : binding.dependencies()) {
       parameters.add(
           frameworkTypeUsageStatement(
-              CodeBlocks.format("$L", fields.get(dependency.bindingKey()).name()),
+              CodeBlock.of("$L", fields.get(dependency.bindingKey()).name()),
               dependency.kind()));
     }
     CodeBlock parametersCodeBlock = makeParametersCodeBlock(parameters);
@@ -233,7 +236,7 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
           ".$L($L)", binding.bindingElement().getSimpleName(), parametersCodeBlock);
       CodeBlock providesMethodInvocation = providesMethodInvocationBuilder.build();
 
-      if (binding.provisionType().equals(SET)) {
+      if (binding.contributionType().equals(SET)) {
         TypeName paramTypeName = TypeName.get(
             MoreTypes.asDeclared(keyType).getTypeArguments().get(0));
         // TODO(cgruber): only be explicit with the parameter if paramType contains wildcards.
diff --git a/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java b/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java
index d8d2e37d8..c1d4e1ac2 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java
@@ -18,6 +18,7 @@
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
 import com.google.common.base.CaseFormat;
+import com.google.common.base.Optional;
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.ParameterizedTypeName;
 import com.squareup.javapoet.TypeName;
@@ -53,14 +54,17 @@ private static FrameworkField createForMapBindingContribution(Key key, String na
         name.endsWith(suffix) ? name : name + suffix);
   }
 
-  static FrameworkField createForResolvedBindings(ResolvedBindings resolvedBindings) {
+  static FrameworkField createForResolvedBindings(
+      ResolvedBindings resolvedBindings, Optional<BindingType> bindingType) {
     if (resolvedBindings.isMultibindingContribution()
         && resolvedBindings.contributionType().equals(ContributionType.MAP)) {
       return createForMapBindingContribution(
           resolvedBindings.key(), frameworkFieldName(resolvedBindings));
     } else {
       return createWithTypeFromKey(
-          resolvedBindings.frameworkClass(),
+          bindingType.isPresent()
+              ? bindingType.get().frameworkClass()
+              : resolvedBindings.frameworkClass(),
           resolvedBindings.key(),
           frameworkFieldName(resolvedBindings));
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/FrameworkTypes.java b/compiler/src/main/java/dagger/internal/codegen/FrameworkTypes.java
index e565da792..84aca3bb7 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FrameworkTypes.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FrameworkTypes.java
@@ -17,26 +17,43 @@
 
 import com.google.auto.common.MoreTypes;
 import com.google.common.collect.ImmutableSet;
+import dagger.Lazy;
+import dagger.MembersInjector;
 import dagger.producers.Produced;
 import dagger.producers.Producer;
+import java.util.Set;
+import javax.inject.Provider;
 import javax.lang.model.type.TypeMirror;
 
+import static com.google.auto.common.MoreTypes.isType;
+
 /**
  * A collection of utility methods for dealing with Dagger framework types. A framework type is any
  * type that the framework itself defines.
  */
 final class FrameworkTypes {
+  private static final ImmutableSet<Class<?>> PROVISION_TYPES =
+      ImmutableSet.of(Provider.class, Lazy.class, MembersInjector.class);
+
   // NOTE(beder): ListenableFuture is not considered a producer framework type because it is not
   // defined by the framework, so we can't treat it specially in ordinary Dagger.
-  private static final ImmutableSet<Class<?>> PRODUCER_TYPES =
+  private static final ImmutableSet<Class<?>> PRODUCTION_TYPES =
       ImmutableSet.of(Produced.class, Producer.class);
 
   /** Returns true if the type represents a producer-related framework type. */
   static boolean isProducerType(TypeMirror type) {
-    if (!MoreTypes.isType(type)) {
-      return false;
-    }
-    for (Class<?> clazz : PRODUCER_TYPES) {
+    return isType(type) && typeIsOneOf(PRODUCTION_TYPES, type);
+  }
+
+  /** Returns true if the type represents a framework type. */
+  static boolean isFrameworkType(TypeMirror type) {
+    return isType(type)
+        && (typeIsOneOf(PROVISION_TYPES, type)
+            || typeIsOneOf(PRODUCTION_TYPES, type));
+  }
+
+  private static boolean typeIsOneOf(Set<Class<?>> classes, TypeMirror type) {
+    for (Class<?> clazz : classes) {
       if (MoreTypes.isTypeOf(clazz, type)) {
         return true;
       }
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectConstructorValidator.java b/compiler/src/main/java/dagger/internal/codegen/InjectConstructorValidator.java
index 23b2edcab..dceeb52c8 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectConstructorValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectConstructorValidator.java
@@ -37,6 +37,7 @@
 import static dagger.internal.codegen.ErrorMessages.MULTIPLE_QUALIFIERS;
 import static dagger.internal.codegen.ErrorMessages.MULTIPLE_SCOPES;
 import static dagger.internal.codegen.ErrorMessages.QUALIFIER_ON_INJECT_CONSTRUCTOR;
+import static dagger.internal.codegen.ErrorMessages.SCOPE_ON_INJECT_CONSTRUCTOR;
 import static dagger.internal.codegen.ErrorMessages.provisionMayNotDependOnProducerType;
 import static dagger.internal.codegen.InjectionAnnotations.getQualifiers;
 import static dagger.internal.codegen.InjectionAnnotations.getScopes;
@@ -62,6 +63,10 @@
       builder.addError(QUALIFIER_ON_INJECT_CONSTRUCTOR, constructorElement, qualifier);
     }
 
+    for (AnnotationMirror scope : getScopes(constructorElement)) {
+      builder.addError(SCOPE_ON_INJECT_CONSTRUCTOR, constructorElement, scope);
+    }
+
     for (VariableElement parameter : constructorElement.getParameters()) {
       ImmutableSet<? extends AnnotationMirror> qualifiers = getQualifiers(parameter);
       if (qualifiers.size() > 1) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/Key.java b/compiler/src/main/java/dagger/internal/codegen/Key.java
index 635cc5421..a27593174 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Key.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Key.java
@@ -28,12 +28,11 @@
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Multimaps;
 import com.google.common.util.concurrent.ListenableFuture;
+import dagger.Binds;
 import dagger.Multibindings;
-import dagger.Provides;
 import dagger.producers.Produced;
 import dagger.producers.Producer;
 import dagger.producers.Production;
-import dagger.producers.Produces;
 import dagger.producers.internal.ProductionImplementation;
 import java.util.Map;
 import java.util.Set;
@@ -45,6 +44,7 @@
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.ExecutableType;
 import javax.lang.model.type.PrimitiveType;
@@ -54,6 +54,7 @@
 import javax.lang.model.util.SimpleTypeVisitor6;
 import javax.lang.model.util.Types;
 
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static com.google.auto.common.MoreTypes.asExecutable;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
@@ -302,48 +303,29 @@ Key forSubcomponentBuilderMethod(
     }
 
     Key forProvidesMethod(SourceElement sourceElement) {
-      checkArgument(sourceElement.element().getKind().equals(METHOD));
-      ExecutableElement method = MoreElements.asExecutable(sourceElement.element());
-      ExecutableType methodType =
-          MoreTypes.asExecutable(sourceElement.asMemberOfContributingType(types));
-      Provides providesAnnotation = method.getAnnotation(Provides.class);
-      checkArgument(providesAnnotation != null);
-      TypeMirror returnType = normalize(types, methodType.getReturnType());
-      TypeMirror keyType =
-          providesOrProducesKeyType(
-              returnType,
-              method,
-              Optional.of(providesAnnotation.type()),
-              Optional.<Produces.Type>absent());
-      Key key = forMethod(method, keyType);
-      return providesAnnotation.type().equals(Provides.Type.UNIQUE)
-          ? key
-          : key.withBindingMethod(sourceElement);
+      return forProvidesOrProducesMethod(sourceElement, getProviderElement());
     }
 
-    // TODO(beder): Reconcile this method with forProvidesMethod when Provides.Type and
-    // Produces.Type are no longer different.
     Key forProducesMethod(SourceElement sourceElement) {
+      return forProvidesOrProducesMethod(sourceElement, getProducerElement());
+    }
+
+    private Key forProvidesOrProducesMethod(
+        SourceElement sourceElement, TypeElement frameworkType) {
       checkArgument(sourceElement.element().getKind().equals(METHOD));
       ExecutableElement method = MoreElements.asExecutable(sourceElement.element());
       ExecutableType methodType =
           MoreTypes.asExecutable(sourceElement.asMemberOfContributingType(types));
-      Produces producesAnnotation = method.getAnnotation(Produces.class);
-      checkArgument(producesAnnotation != null);
+      ContributionType contributionType = ContributionType.fromBindingMethod(method);
       TypeMirror returnType = normalize(types, methodType.getReturnType());
-      TypeMirror unfuturedType = returnType;
-      if (MoreTypes.isTypeOf(ListenableFuture.class, returnType)) {
-        unfuturedType =
-            Iterables.getOnlyElement(MoreTypes.asDeclared(returnType).getTypeArguments());
+      if (frameworkType.equals(getProducerElement())
+          && MoreTypes.isTypeOf(ListenableFuture.class, returnType)) {
+        returnType = Iterables.getOnlyElement(MoreTypes.asDeclared(returnType).getTypeArguments());
       }
       TypeMirror keyType =
-          providesOrProducesKeyType(
-              unfuturedType,
-              method,
-              Optional.<Provides.Type>absent(),
-              Optional.of(producesAnnotation.type()));
+          providesOrProducesKeyType(returnType, method, contributionType, frameworkType);
       Key key = forMethod(method, keyType);
-      return producesAnnotation.type().equals(Produces.Type.UNIQUE)
+      return contributionType.equals(ContributionType.UNIQUE)
           ? key
           : key.withBindingMethod(sourceElement);
     }
@@ -370,26 +352,42 @@ Key forMultibindingsMethod(
       return forMethod(method, keyType);
     }
 
+    /** Returns the key bound by a {@link Binds} method. */
+    Key forBindsMethod(SourceElement bindsMethodElement) {
+      ExecutableElement method = MoreElements.asExecutable(bindsMethodElement.element());
+      ExecutableType methodType =
+          MoreTypes.asExecutable(bindsMethodElement.asMemberOfContributingType(types));
+      checkArgument(isAnnotationPresent(method, Binds.class));
+      TypeMirror returnType = normalize(types, methodType.getReturnType());
+      return forMethod(method, returnType);
+    }
+
+    /** Returns the key for the single parameter of a {@link Binds} method. */
+    Key forBindParameter(SourceElement bindsMethodElement) {
+      ExecutableElement method = MoreElements.asExecutable(bindsMethodElement.element());
+      VariableElement parameterElement = Iterables.getOnlyElement(method.getParameters());
+      ExecutableType methodType =
+          MoreTypes.asExecutable(bindsMethodElement.asMemberOfContributingType(types));
+      checkArgument(isAnnotationPresent(method, Binds.class));
+      TypeMirror parameterType = Iterables.getOnlyElement(methodType.getParameterTypes());
+      return forQualifiedType(getQualifier(parameterElement), parameterType);
+    }
+
     private TypeMirror providesOrProducesKeyType(
         TypeMirror returnType,
         ExecutableElement method,
-        Optional<Provides.Type> providesType,
-        Optional<Produces.Type> producesType) {
-      switch (providesType.isPresent()
-          ? providesType.get()
-          : Provides.Type.valueOf(producesType.get().name())) {
+        ContributionType contributionType,
+        TypeElement frameworkType) {
+      switch (contributionType) {
         case UNIQUE:
           return returnType;
         case SET:
           return types.getDeclaredType(getSetElement(), returnType);
         case MAP:
-          return mapOfFrameworkType(
-              mapKeyType(method),
-              providesType.isPresent() ? getProviderElement() : getProducerElement(),
-              returnType);
+          return mapOfFrameworkType(mapKeyType(method), frameworkType, returnType);
         case SET_VALUES:
           // TODO(gak): do we want to allow people to use "covariant return" here?
-          checkArgument(MoreTypes.isType(returnType) && MoreTypes.isTypeOf(Set.class, returnType));
+          checkArgument(SetType.isSet(returnType));
           return returnType;
         default:
           throw new AssertionError();
diff --git a/compiler/src/main/java/dagger/internal/codegen/MapKeyGenerator.java b/compiler/src/main/java/dagger/internal/codegen/MapKeyGenerator.java
index ac15287b8..1f3195e04 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MapKeyGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MapKeyGenerator.java
@@ -111,7 +111,7 @@ ClassName nameGeneratedType(MapKeyCreatorSpecification mapKeyCreatorType) {
   Optional<TypeSpec.Builder> write(
       ClassName generatedTypeName, MapKeyCreatorSpecification mapKeyCreatorType) {
     TypeSpec.Builder mapKeyCreatorBuilder =
-        classBuilder(generatedTypeName.simpleName()).addModifiers(PUBLIC, FINAL);
+        classBuilder(generatedTypeName).addModifiers(PUBLIC, FINAL);
 
     mapKeyCreatorBuilder.addMethod(constructorBuilder().addModifiers(PRIVATE).build());
 
@@ -137,7 +137,7 @@ private MethodSpec buildCreateMethod(
       String parameterName = annotationMember.getSimpleName().toString();
       TypeName parameterType = TypeName.get(annotationMember.getReturnType());
       createMethod.addParameter(parameterType, parameterName);
-      parameters.add(CodeBlocks.format("$L", parameterName));
+      parameters.add(CodeBlock.of("$L", parameterName));
     }
 
     ClassName autoAnnotationClass = mapKeyGeneratedTypeName.peerClass(
diff --git a/compiler/src/main/java/dagger/internal/codegen/MapKeys.java b/compiler/src/main/java/dagger/internal/codegen/MapKeys.java
index 84a988f50..46ab6c2e9 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MapKeys.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MapKeys.java
@@ -185,7 +185,7 @@ static CodeBlock getMapKeyExpression(Element bindingElement) {
 
     @Override
     public CodeBlock visitEnumConstant(VariableElement c, AnnotationValue p) {
-      return CodeBlocks.format(
+      return CodeBlock.of(
           "$T.$L", TypeName.get(c.getEnclosingElement().asType()), c.getSimpleName());
     }
 
@@ -196,52 +196,52 @@ public CodeBlock visitAnnotation(AnnotationMirror a, AnnotationValue p) {
 
     @Override
     public CodeBlock visitType(TypeMirror t, AnnotationValue p) {
-      return CodeBlocks.format("$T.class", TypeName.get(t));
+      return CodeBlock.of("$T.class", TypeName.get(t));
     }
 
     @Override
     public CodeBlock visitString(String s, AnnotationValue p) {
-      return CodeBlocks.format("$S", s);
+      return CodeBlock.of("$S", s);
     }
 
     @Override
     public CodeBlock visitByte(byte b, AnnotationValue p) {
-      return CodeBlocks.format("(byte) $L", b);
+      return CodeBlock.of("(byte) $L", b);
     }
 
     @Override
     public CodeBlock visitChar(char c, AnnotationValue p) {
-      return CodeBlocks.format("$L", p);
+      return CodeBlock.of("$L", p);
     }
 
     @Override
     public CodeBlock visitDouble(double d, AnnotationValue p) {
-      return CodeBlocks.format("$LD", d);
+      return CodeBlock.of("$LD", d);
     }
 
     @Override
     public CodeBlock visitFloat(float f, AnnotationValue p) {
-      return CodeBlocks.format("$LF", f);
+      return CodeBlock.of("$LF", f);
     }
 
     @Override
     public CodeBlock visitInt(int i, AnnotationValue p) {
-      return CodeBlocks.format("(int) $L", i);
+      return CodeBlock.of("(int) $L", i);
     }
 
     @Override
     public CodeBlock visitLong(long i, AnnotationValue p) {
-      return CodeBlocks.format("$LL", i);
+      return CodeBlock.of("$LL", i);
     }
 
     @Override
     public CodeBlock visitShort(short s, AnnotationValue p) {
-      return CodeBlocks.format("(short) $L", s);
+      return CodeBlock.of("(short) $L", s);
     }
 
     @Override
     protected CodeBlock defaultAction(Object o, AnnotationValue p) {
-      return CodeBlocks.format("$L", o);
+      return CodeBlock.of("$L", o);
     }
 
     @Override
@@ -250,7 +250,7 @@ public CodeBlock visitArray(List<? extends AnnotationValue> values, AnnotationVa
       for (int i = 0; i < values.size(); i++) {
         codeBlocks.add(this.visit(values.get(i), p));
       }
-      return CodeBlocks.format("{$L}", makeParametersCodeBlock(codeBlocks.build()));
+      return CodeBlock.of("{$L}", makeParametersCodeBlock(codeBlocks.build()));
     }
   }
 
@@ -278,7 +278,7 @@ public CodeBlock visitArray(List<? extends AnnotationValue> values, AnnotationVa
    */
   private static CodeBlock annotationExpression(
       AnnotationMirror mapKeyAnnotation, final MapKeyExpression mapKeyExpression) {
-    return CodeBlocks.format(
+    return CodeBlock.of(
         "$T.create$L($L)",
         mapKeyExpression.mapKeyCreator,
         mapKeyAnnotation.getAnnotationType().asElement().getSimpleName(),
@@ -304,7 +304,7 @@ public CodeBlock apply(Map.Entry<ExecutableElement, AnnotationValue> entry) {
 
         @Override
         public CodeBlock visitArray(ArrayType t, CodeBlock p) {
-          return CodeBlocks.format("new $T[] $L", RAW_TYPE_NAME.visit(t.getComponentType()), p);
+          return CodeBlock.of("new $T[] $L", RAW_TYPE_NAME.visit(t.getComponentType()), p);
         }
 
         @Override
diff --git a/compiler/src/main/java/dagger/internal/codegen/MemberSelect.java b/compiler/src/main/java/dagger/internal/codegen/MemberSelect.java
index 0639dbf3f..33a14838f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MemberSelect.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MemberSelect.java
@@ -61,8 +61,8 @@ static MemberSelect localField(ClassName owningClass, String fieldName) {
     @Override
     CodeBlock getExpressionFor(ClassName usingClass) {
       return owningClass().equals(usingClass)
-          ? CodeBlocks.format("$L", fieldName)
-          : CodeBlocks.format("$T.this.$L", owningClass(), fieldName);
+          ? CodeBlock.of("$L", fieldName)
+          : CodeBlock.of("$T.this.$L", owningClass(), fieldName);
     }
   }
 
@@ -86,7 +86,7 @@ static MemberSelect staticMethod(ClassName owningClass, CodeBlock methodInvocati
     CodeBlock getExpressionFor(ClassName usingClass) {
       return owningClass().equals(usingClass)
           ? methodCodeBlock
-          : CodeBlocks.format("$T.$L", owningClass(), methodCodeBlock);
+          : CodeBlock.of("$T.$L", owningClass(), methodCodeBlock);
     }
   }
 
@@ -97,7 +97,7 @@ static MemberSelect noOpMembersInjector(TypeMirror type) {
     return new ParameterizedStaticMethod(
         MEMBERS_INJECTORS,
         ImmutableList.of(type),
-        CodeBlocks.format("noOp()"),
+        CodeBlock.of("noOp()"),
         MEMBERS_INJECTOR);
   }
 
@@ -117,7 +117,7 @@ static MemberSelect emptyFrameworkMapFactory(
     return new ParameterizedStaticMethod(
         frameworkMapFactoryClass,
         ImmutableList.of(keyType, unwrappedValueType),
-        CodeBlocks.format("empty()"),
+        CodeBlock.of("empty()"),
         frameworkMapFactoryClass);
   }
 
@@ -130,7 +130,7 @@ static MemberSelect emptySetProvider(ClassName setFactoryType, SetType setType)
     return new ParameterizedStaticMethod(
         setFactoryType,
         ImmutableList.of(setType.elementType()),
-        CodeBlocks.format("create()"),
+        CodeBlock.of("create()"),
         SET);
   }
 
@@ -158,13 +158,13 @@ CodeBlock getExpressionFor(ClassName usingClass) {
       }
 
       if (accessible) {
-        return CodeBlocks.format(
+        return CodeBlock.of(
             "$T.<$L>$L",
             owningClass(),
             makeParametersCodeBlock(toCodeBlocks(typeParameters)),
             methodCodeBlock);
       } else {
-        return CodeBlocks.format("(($T) $T.$L)", rawReturnType, owningClass(), methodCodeBlock);
+        return CodeBlock.of("(($T) $T.$L)", rawReturnType, owningClass(), methodCodeBlock);
       }
     }
   }
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
index 1a0379c1f..ac1b505db 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
@@ -100,7 +100,7 @@ ClassName nameGeneratedType(MembersInjectionBinding binding) {
 
     ImmutableList<TypeVariableName> typeParameters = bindingTypeElementTypeVariableNames(binding);
     TypeSpec.Builder injectorTypeBuilder =
-        classBuilder(generatedTypeName.simpleName())
+        classBuilder(generatedTypeName)
             .addModifiers(PUBLIC, FINAL)
             .addTypeVariables(typeParameters);
 
@@ -176,7 +176,7 @@ ClassName nameGeneratedType(MembersInjectionBinding binding) {
       constructorBuilder.addStatement("assert $N != null", field);
       constructorBuilder.addStatement("this.$N = $N", field, field);
       dependencyFieldsBuilder.put(bindingKey, field);
-      constructorInvocationParameters.add(CodeBlocks.format("$N", field));
+      constructorInvocationParameters.add(CodeBlock.of("$N", field));
     }
     createMethodBuilder.addCode(CodeBlocks.join(constructorInvocationParameters.build(), ", "));
     createMethodBuilder.addCode(");");
@@ -235,7 +235,7 @@ private CodeBlock directInjectMemberCodeBlock(
       MembersInjectionBinding binding,
       ImmutableMap<BindingKey, FieldSpec> dependencyFields,
       InjectionSite injectionSite) {
-    return CodeBlocks.format(
+    return CodeBlock.of(
         injectionSite.element().getKind().isField() ? "$L.$L = $L;" : "$L.$L($L);",
         getInstanceCodeBlockWithPotentialCast(
             injectionSite.element().getEnclosingElement(), binding.bindingElement()),
@@ -250,14 +250,14 @@ private CodeBlock directInjectMemberCodeBlock(
    */
   private CodeBlock delegateInjectMemberCodeBlock(
       ImmutableMap<BindingKey, FieldSpec> dependencyFields, InjectionSite injectionSite) {
-    return CodeBlocks.format(
+    return CodeBlock.of(
         "$L.$L($L);",
         membersInjectorNameForType(
             MoreElements.asType(injectionSite.element().getEnclosingElement())),
         injectionSiteDelegateMethodName(injectionSite.element()),
         makeParametersCodeBlock(
             new ImmutableList.Builder<CodeBlock>()
-                .add(CodeBlocks.format("instance"))
+                .add(CodeBlock.of("instance"))
                 .addAll(parameterCodeBlocks(dependencyFields, injectionSite.dependencies(), false))
                 .build()));
   }
@@ -276,7 +276,7 @@ private CodeBlock delegateInjectMemberCodeBlock(
     ImmutableList.Builder<CodeBlock> parameters = ImmutableList.builder();
     for (DependencyRequest dependency : dependencies) {
       CodeBlock fieldCodeBlock =
-          CodeBlocks.format("$L", dependencyFields.get(dependency.bindingKey()).name);
+          CodeBlock.of("$L", dependencyFields.get(dependency.bindingKey()).name);
       parameters.add(
           passValue
               ? frameworkTypeUsageStatement(fieldCodeBlock, dependency.kind())
@@ -288,13 +288,13 @@ private CodeBlock delegateInjectMemberCodeBlock(
   private CodeBlock getInstanceCodeBlockWithPotentialCast(
       Element injectionSiteElement, Element bindingElement) {
     if (injectionSiteElement.equals(bindingElement)) {
-      return CodeBlocks.format("instance");
+      return CodeBlock.of("instance");
     }
     TypeName injectionSiteName = TypeName.get(injectionSiteElement.asType());
     if (injectionSiteName instanceof ParameterizedTypeName) {
       injectionSiteName = ((ParameterizedTypeName) injectionSiteName).rawType;
     }
-    return CodeBlocks.format("(($T) instance)", injectionSiteName);
+    return CodeBlock.of("(($T) instance)", injectionSiteName);
   }
 
   private String injectionSiteDelegateMethodName(Element injectionSiteElement) {
@@ -325,7 +325,7 @@ private MethodSpec injectorMethodForSubclasses(
               .build();
       methodBuilder.addParameter(parameter);
       providedParameters.add(
-          frameworkTypeUsageStatement(CodeBlocks.format("$N", parameter), dependency.kind()));
+          frameworkTypeUsageStatement(CodeBlock.of("$N", parameter), dependency.kind()));
     }
     if (injectionElement.getKind().isField()) {
       methodBuilder.addStatement(
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java
index 781296236..a4e645ec3 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java
@@ -23,6 +23,7 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
+import dagger.Binds;
 import dagger.Module;
 import dagger.Multibindings;
 import dagger.Provides;
@@ -67,12 +68,17 @@
   abstract ImmutableSet<ModuleDescriptor> includedModules();
 
   abstract ImmutableSet<ContributionBinding> bindings();
-  
+
   /**
    * The multibinding declarations contained in this module.
    */
   abstract ImmutableSet<MultibindingDeclaration> multibindingDeclarations();
 
+  /**
+   * The {@link Binds} method declarations that define delegate bindings.
+   */
+  abstract ImmutableSet<DelegateDeclaration> delegateDeclarations();
+
   enum DefaultCreationStrategy {
     PASSED,
     CONSTRUCTED,
@@ -138,16 +144,19 @@
     private final ProvisionBinding.Factory provisionBindingFactory;
     private final ProductionBinding.Factory productionBindingFactory;
     private final MultibindingDeclaration.Factory multibindingDeclarationFactory;
+    private final DelegateDeclaration.Factory bindingDelegateDeclarationFactory;
 
     Factory(
         Elements elements,
         ProvisionBinding.Factory provisionBindingFactory,
         ProductionBinding.Factory productionBindingFactory,
-        MultibindingDeclaration.Factory multibindingDeclarationFactory) {
+        MultibindingDeclaration.Factory multibindingDeclarationFactory,
+        DelegateDeclaration.Factory bindingDelegateDeclarationFactory) {
       this.elements = elements;
       this.provisionBindingFactory = provisionBindingFactory;
       this.productionBindingFactory = productionBindingFactory;
       this.multibindingDeclarationFactory = multibindingDeclarationFactory;
+      this.bindingDelegateDeclarationFactory = bindingDelegateDeclarationFactory;
     }
 
     ModuleDescriptor create(TypeElement moduleElement) {
@@ -158,6 +167,7 @@ ModuleDescriptor create(TypeElement moduleElement) {
       AnnotationMirror moduleAnnotation = probableModuleAnnotation.get();
 
       ImmutableSet.Builder<ContributionBinding> bindings = ImmutableSet.builder();
+      ImmutableSet.Builder<DelegateDeclaration> delegates = ImmutableSet.builder();
       for (ExecutableElement moduleMethod : methodsIn(elements.getAllMembers(moduleElement))) {
         if (isAnnotationPresent(moduleMethod, Provides.class)) {
           bindings.add(provisionBindingFactory.forProvidesMethod(moduleMethod, moduleElement));
@@ -165,8 +175,11 @@ ModuleDescriptor create(TypeElement moduleElement) {
         if (isAnnotationPresent(moduleMethod, Produces.class)) {
           bindings.add(productionBindingFactory.forProducesMethod(moduleMethod, moduleElement));
         }
+        if (isAnnotationPresent(moduleMethod, Binds.class)) {
+          delegates.add(bindingDelegateDeclarationFactory.create(moduleMethod, moduleElement));
+        }
       }
-      
+
       ImmutableSet.Builder<MultibindingDeclaration> multibindingDeclarations =
           ImmutableSet.builder();
       for (TypeElement memberType : typesIn(elements.getAllMembers(moduleElement))) {
@@ -189,6 +202,7 @@ ModuleDescriptor create(TypeElement moduleElement) {
               collectIncludedModules(new LinkedHashSet<ModuleDescriptor>(), moduleElement)),
           bindings.build(),
           multibindingDeclarations.build(),
+          delegates.build(),
           defaultCreationStrategy);
     }
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/ModuleProcessingStep.java
index 00d73bda1..4e095b944 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleProcessingStep.java
@@ -22,6 +22,7 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.SetMultimap;
 import com.google.common.collect.Sets;
+import dagger.Binds;
 import dagger.Module;
 import dagger.Provides;
 import java.lang.annotation.Annotation;
@@ -47,6 +48,7 @@
   private final Messager messager;
   private final ModuleValidator moduleValidator;
   private final ProvidesMethodValidator providesMethodValidator;
+  private final BindsMethodValidator bindsMethodValidator;
   private final ProvisionBinding.Factory provisionBindingFactory;
   private final FactoryGenerator factoryGenerator;
   private final Set<Element> processedModuleElements = Sets.newLinkedHashSet();
@@ -56,36 +58,30 @@
       ModuleValidator moduleValidator,
       ProvidesMethodValidator providesMethodValidator,
       ProvisionBinding.Factory provisionBindingFactory,
+      BindsMethodValidator bindsMethodValidator,
       FactoryGenerator factoryGenerator) {
     this.messager = messager;
     this.moduleValidator = moduleValidator;
     this.providesMethodValidator = providesMethodValidator;
+    this.bindsMethodValidator = bindsMethodValidator;
     this.provisionBindingFactory = provisionBindingFactory;
     this.factoryGenerator = factoryGenerator;
   }
 
   @Override
   public Set<Class<? extends Annotation>> annotations() {
-    return ImmutableSet.of(Module.class, Provides.class);
+    return ImmutableSet.of(Module.class, Provides.class, Binds.class);
   }
 
   @Override
   public Set<Element> process(
       SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
     // first, check and collect all provides methods
-    ImmutableSet.Builder<ExecutableElement> validProvidesMethodsBuilder = ImmutableSet.builder();
-    for (Element providesElement : elementsByAnnotation.get(Provides.class)) {
-      if (providesElement.getKind().equals(METHOD)) {
-        ExecutableElement providesMethodElement = (ExecutableElement) providesElement;
-        ValidationReport<ExecutableElement> methodReport =
-            providesMethodValidator.validate(providesMethodElement);
-        methodReport.printMessagesTo(messager);
-        if (methodReport.isClean()) {
-          validProvidesMethodsBuilder.add(providesMethodElement);
-        }
-      }
-    }
-    ImmutableSet<ExecutableElement> validProvidesMethods = validProvidesMethodsBuilder.build();
+    ImmutableSet<ExecutableElement> validProvidesMethods =
+        validateProvidesMethods(elementsByAnnotation);
+
+    // second, check and collect all bind methods
+    ImmutableSet<ExecutableElement> validBindsMethods = validateBindsMethods(elementsByAnnotation);
 
     // process each module
     for (Element moduleElement :
@@ -97,18 +93,26 @@
       if (report.isClean()) {
         ImmutableSet.Builder<ExecutableElement> moduleProvidesMethodsBuilder =
             ImmutableSet.builder();
+        ImmutableSet.Builder<ExecutableElement> moduleBindsMethodsBuilder =
+            ImmutableSet.builder();
         List<ExecutableElement> moduleMethods =
             ElementFilter.methodsIn(moduleElement.getEnclosedElements());
         for (ExecutableElement methodElement : moduleMethods) {
           if (isAnnotationPresent(methodElement, Provides.class)) {
             moduleProvidesMethodsBuilder.add(methodElement);
           }
+          if (isAnnotationPresent(methodElement, Binds.class)) {
+            moduleBindsMethodsBuilder.add(methodElement);
+          }
         }
         ImmutableSet<ExecutableElement> moduleProvidesMethods =
             moduleProvidesMethodsBuilder.build();
+        ImmutableSet<ExecutableElement> moduleBindsMethods =
+            moduleBindsMethodsBuilder.build();
 
-        if (Sets.difference(moduleProvidesMethods, validProvidesMethods).isEmpty()) {
-          // all of the provides methods in this module are valid!
+        if (Sets.difference(moduleProvidesMethods, validProvidesMethods).isEmpty()
+            && Sets.difference(moduleBindsMethods, validBindsMethods).isEmpty()) {
+          // all of the provides and bind methods in this module are valid!
           // time to generate some factories!
           ImmutableSet<ProvisionBinding> bindings =
               FluentIterable.from(moduleProvidesMethods)
@@ -136,4 +140,41 @@ public ProvisionBinding apply(ExecutableElement providesMethod) {
     }
     return ImmutableSet.of();
   }
+
+  /* TODO(gak): Add an interface for Validators and combine these two methods and the ones in
+   * ProducerModuleProcessingStep */
+
+  private ImmutableSet<ExecutableElement> validateBindsMethods(
+      SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
+    ImmutableSet.Builder<ExecutableElement> validBindsMethodsBuilder = ImmutableSet.builder();
+    for (Element bindElement : elementsByAnnotation.get(Binds.class)) {
+      if (bindElement.getKind().equals(METHOD)) {
+        ExecutableElement bindsMethodElement = (ExecutableElement) bindElement;
+        ValidationReport<ExecutableElement> methodReport =
+            bindsMethodValidator.validate(bindsMethodElement);
+        methodReport.printMessagesTo(messager);
+        if (methodReport.isClean()) {
+          validBindsMethodsBuilder.add(bindsMethodElement);
+        }
+      }
+    }
+    return validBindsMethodsBuilder.build();
+  }
+
+  private ImmutableSet<ExecutableElement> validateProvidesMethods(
+      SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
+    ImmutableSet.Builder<ExecutableElement> validProvidesMethodsBuilder = ImmutableSet.builder();
+    for (Element providesElement : elementsByAnnotation.get(Provides.class)) {
+      if (providesElement.getKind().equals(METHOD)) {
+        ExecutableElement providesMethodElement = (ExecutableElement) providesElement;
+        ValidationReport<ExecutableElement> methodReport =
+            providesMethodValidator.validate(providesMethodElement);
+        methodReport.printMessagesTo(messager);
+        if (methodReport.isClean()) {
+          validProvidesMethodsBuilder.add(providesMethodElement);
+        }
+      }
+    }
+    return validProvidesMethodsBuilder.build();
+  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java b/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java
index 9bb5fd1b5..5057dba7e 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java
@@ -26,10 +26,12 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ListMultimap;
 import com.google.common.collect.Sets;
+import dagger.Binds;
 import dagger.Module;
 import dagger.producers.ProducerModule;
 import java.lang.annotation.Annotation;
 import java.util.Collection;
+import java.util.EnumSet;
 import java.util.List;
 import java.util.Map.Entry;
 import java.util.Set;
@@ -53,13 +55,14 @@
 import static com.google.common.collect.Iterables.any;
 import static dagger.internal.codegen.ConfigurationAnnotations.getModuleIncludes;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_WITH_SAME_NAME;
+import static dagger.internal.codegen.ErrorMessages.INCOMPATIBLE_MODULE_METHODS;
 import static dagger.internal.codegen.ErrorMessages.METHOD_OVERRIDES_PROVIDES_METHOD;
 import static dagger.internal.codegen.ErrorMessages.MODULES_WITH_TYPE_PARAMS_MUST_BE_ABSTRACT;
 import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_OVERRIDES_ANOTHER;
-import static dagger.internal.codegen.ErrorMessages.REFERENCED_MODULES_MUST_NOT_BE_ABSTRACT;
 import static dagger.internal.codegen.ErrorMessages.REFERENCED_MODULE_MUST_NOT_HAVE_TYPE_PARAMS;
 import static dagger.internal.codegen.ErrorMessages.REFERENCED_MODULE_NOT_ANNOTATED;
 import static javax.lang.model.element.Modifier.ABSTRACT;
+import static javax.lang.model.element.Modifier.STATIC;
 
 /**
  * A {@linkplain ValidationReport validator} for {@link Module}s or {@link ProducerModule}s.
@@ -86,13 +89,30 @@
     List<ExecutableElement> moduleMethods = ElementFilter.methodsIn(subject.getEnclosedElements());
     ListMultimap<String, ExecutableElement> allMethodsByName = ArrayListMultimap.create();
     ListMultimap<String, ExecutableElement> bindingMethodsByName = ArrayListMultimap.create();
+
+    Set<ModuleMethodKind> methodKinds = EnumSet.noneOf(ModuleMethodKind.class);
     for (ExecutableElement moduleMethod : moduleMethods) {
       if (isAnnotationPresent(moduleMethod, moduleKind.methodAnnotation())) {
         bindingMethodsByName.put(moduleMethod.getSimpleName().toString(), moduleMethod);
+        methodKinds.add(
+            moduleMethod.getModifiers().contains(STATIC)
+                ? ModuleMethodKind.STATIC_BINDING
+                : ModuleMethodKind.INSTANCE_BINDING);
+      } else if (isAnnotationPresent(moduleMethod, Binds.class)) {
+        methodKinds.add(ModuleMethodKind.ABSTRACT_DECLARATION);
       }
       allMethodsByName.put(moduleMethod.getSimpleName().toString(), moduleMethod);
     }
 
+    if (methodKinds.containsAll(
+        EnumSet.of(ModuleMethodKind.ABSTRACT_DECLARATION, ModuleMethodKind.INSTANCE_BINDING))) {
+      builder.addError(
+          String.format(
+              INCOMPATIBLE_MODULE_METHODS,
+              moduleKind.moduleAnnotation().getSimpleName(),
+              moduleKind.methodAnnotation().getSimpleName()));
+    }
+
     validateModuleVisibility(subject, moduleKind, builder);
     validateMethodsWithSameName(moduleKind, builder, bindingMethodsByName);
     if (subject.getKind() != ElementKind.INTERFACE) {
@@ -106,6 +126,12 @@
     return builder.build();
   }
 
+  enum ModuleMethodKind {
+    ABSTRACT_DECLARATION,
+    INSTANCE_BINDING,
+    STATIC_BINDING,
+  }
+
   private void validateModifiers(
       TypeElement subject, ValidationReport.Builder<TypeElement> builder) {
     // This coupled with the check for abstract modules in ComponentValidator guarantees that
@@ -138,8 +164,8 @@ private void validateReferencedModules(
       ValidationReport.Builder<TypeElement> builder) {
     // Validate that all the modules we include are valid for inclusion.
     AnnotationMirror mirror = getAnnotationMirror(subject, moduleKind.moduleAnnotation()).get();
-    ImmutableList<TypeMirror> includedTypes = getModuleIncludes(mirror);
-    validateReferencedModules(subject, builder, includedTypes, ImmutableSet.of(moduleKind));
+    ImmutableList<TypeMirror> includes = getModuleIncludes(mirror);
+    validateReferencedModules(subject, mirror, builder, includes, ImmutableSet.of(moduleKind));
   }
 
   private static ImmutableSet<? extends Class<? extends Annotation>> includedModuleClasses(
@@ -161,14 +187,15 @@ private void validateReferencedModules(
    */
   void validateReferencedModules(
       final TypeElement subject,
+      final AnnotationMirror moduleAnnotation,
       final ValidationReport.Builder<TypeElement> builder,
-      ImmutableList<TypeMirror> includedTypes,
+      ImmutableList<TypeMirror> includes,
       ImmutableSet<ModuleDescriptor.Kind> validModuleKinds) {
     final ImmutableSet<? extends Class<? extends Annotation>> includedModuleClasses =
         includedModuleClasses(validModuleKinds);
 
-    for (TypeMirror includedType : includedTypes) {
-      includedType.accept(
+    for (TypeMirror includesType : includes) {
+      includesType.accept(
           new SimpleTypeVisitor6<Void, Void>() {
             @Override
             protected Void defaultAction(TypeMirror mirror, Void p) {
@@ -213,12 +240,6 @@ public String apply(
                                             }))),
                     subject);
               }
-              if (element.getModifiers().contains(ABSTRACT)) {
-                builder.addError(
-                    String.format(
-                        REFERENCED_MODULES_MUST_NOT_BE_ABSTRACT, element.getQualifiedName()),
-                    subject);
-              }
               return null;
             }
           },
diff --git a/compiler/src/main/java/dagger/internal/codegen/MonitoringModuleGenerator.java b/compiler/src/main/java/dagger/internal/codegen/MonitoringModuleGenerator.java
index 76a3f6b9d..438631580 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MonitoringModuleGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MonitoringModuleGenerator.java
@@ -60,7 +60,7 @@ ClassName nameGeneratedType(TypeElement componentElement) {
   @Override
   Optional<TypeSpec.Builder> write(ClassName generatedTypeName, TypeElement componentElement) {
     return Optional.of(
-        classBuilder(generatedTypeName.simpleName())
+        classBuilder(generatedTypeName)
             .addAnnotation(
                 AnnotationSpec.builder(Module.class)
                     .build())
diff --git a/compiler/src/main/java/dagger/internal/codegen/MultibindingAnnotations.java b/compiler/src/main/java/dagger/internal/codegen/MultibindingAnnotations.java
new file mode 100644
index 000000000..b2ab200b7
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/MultibindingAnnotations.java
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.common.collect.ImmutableSet;
+import dagger.multibindings.ElementsIntoSet;
+import dagger.multibindings.IntoMap;
+import dagger.multibindings.IntoSet;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.ExecutableElement;
+
+import static com.google.auto.common.MoreElements.getAnnotationMirror;
+
+/**
+ * Utility methods related to processing {@link IntoSet}, {@link ElementsIntoSet}, and {@link
+ * IntoMap}.
+ */
+final class MultibindingAnnotations {
+  static ImmutableSet<AnnotationMirror> forMethod(ExecutableElement method) {
+    return ImmutableSet.<AnnotationMirror>builder()
+        .addAll(getAnnotationMirror(method, IntoSet.class).asSet())
+        .addAll(getAnnotationMirror(method, ElementsIntoSet.class).asSet())
+        .addAll(getAnnotationMirror(method, IntoMap.class).asSet())
+        .build();
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/MultibindingAnnotationsProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/MultibindingAnnotationsProcessingStep.java
new file mode 100644
index 000000000..108557e91
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/MultibindingAnnotationsProcessingStep.java
@@ -0,0 +1,77 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.common.BasicAnnotationProcessor.ProcessingStep;
+import com.google.common.base.Predicate;
+import com.google.common.base.Predicates;
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.SetMultimap;
+import dagger.Provides;
+import dagger.multibindings.ElementsIntoSet;
+import dagger.multibindings.IntoMap;
+import dagger.multibindings.IntoSet;
+import dagger.producers.Produces;
+import java.lang.annotation.Annotation;
+import java.util.Map.Entry;
+import java.util.Set;
+import javax.annotation.processing.Messager;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.Element;
+import javax.tools.Diagnostic.Kind;
+
+import static com.google.auto.common.MoreElements.getAnnotationMirror;
+import static dagger.internal.codegen.ErrorMessages.MULTIBINDING_ANNOTATION_NOT_ON_PROVIDES_OR_PRODUCES;
+import static dagger.internal.codegen.Util.hasAnnotationType;
+
+/**
+ * Processing step which verifies that {@link IntoSet @IntoSet}, {@link ElementsIntoSet
+ * @ElementsIntoSet} and {@link IntoMap @IntoMap} are not present on invalid elements.
+ */
+final class MultibindingAnnotationsProcessingStep implements ProcessingStep {
+
+  private final Messager messager;
+
+  MultibindingAnnotationsProcessingStep(Messager messager) {
+    this.messager = messager;
+  }
+
+  @Override
+  public Set<? extends Class<? extends Annotation>> annotations() {
+    return ImmutableSet.of(IntoSet.class, ElementsIntoSet.class, IntoMap.class);
+  }
+
+  @Override
+  public Set<Element> process(
+      SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
+    for (Entry<Class<? extends Annotation>, Element> entry : elementsByAnnotation.entries()) {
+      Element element = entry.getValue();
+      boolean onBindingMethod =
+          FluentIterable.from(element.getAnnotationMirrors()).anyMatch(providesOrProducesMethod());
+      if (!onBindingMethod) {
+        AnnotationMirror annotation = getAnnotationMirror(entry.getValue(), entry.getKey()).get();
+        messager.printMessage(
+            Kind.ERROR, MULTIBINDING_ANNOTATION_NOT_ON_PROVIDES_OR_PRODUCES, element, annotation);
+      }
+    }
+    return ImmutableSet.of();
+  }
+
+  private static Predicate<AnnotationMirror> providesOrProducesMethod() {
+    return Predicates.or(hasAnnotationType(Provides.class), hasAnnotationType(Produces.class));
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
index 6c15b50fb..41fd0c0e7 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
@@ -29,8 +29,6 @@
 import com.squareup.javapoet.TypeName;
 import com.squareup.javapoet.TypeSpec;
 import dagger.producers.Producer;
-import dagger.producers.Produces;
-import dagger.producers.Produces.Type;
 import dagger.producers.monitoring.ProducerMonitor;
 import java.util.List;
 import javax.annotation.processing.Filer;
@@ -45,6 +43,7 @@
 import static dagger.internal.codegen.AnnotationSpecs.SUPPRESS_WARNINGS_UNCHECKED;
 import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
 import static dagger.internal.codegen.CodeBlocks.toCodeBlocks;
+import static dagger.internal.codegen.ContributionType.MAP;
 import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
 import static dagger.internal.codegen.SourceFiles.generatedClassNameForBinding;
 import static dagger.internal.codegen.TypeNames.ASYNC_FUNCTION;
@@ -90,14 +89,14 @@ ClassName nameGeneratedType(ProductionBinding binding) {
   @Override
   Optional<TypeSpec.Builder> write(ClassName generatedTypeName, ProductionBinding binding) {
     TypeMirror keyType =
-        binding.productionType().equals(Type.MAP)
+        binding.contributionType().equals(MAP)
             ? MapType.from(binding.key().type()).unwrappedValueType(Producer.class)
             : binding.key().type();
     TypeName providedTypeName = TypeName.get(keyType);
     TypeName futureTypeName = listenableFutureOf(providedTypeName);
 
     TypeSpec.Builder factoryBuilder =
-        classBuilder(generatedTypeName.simpleName())
+        classBuilder(generatedTypeName)
             .addModifiers(PUBLIC, FINAL)
             .superclass(abstractProducerOf(providedTypeName));
 
@@ -134,18 +133,18 @@ ClassName nameGeneratedType(ProductionBinding binding) {
     for (DependencyRequest dependency : asyncDependencies) {
       TypeName futureType = listenableFutureOf(asyncDependencyType(dependency));
       CodeBlock futureAccess =
-          CodeBlocks.format("$L.get()", fields.get(dependency.bindingKey()).name());
+          CodeBlock.of("$L.get()", fields.get(dependency.bindingKey()).name());
       computeMethodBuilder.addStatement(
           "$T $L = $L",
           futureType,
           dependencyFutureName(dependency),
           dependency.kind().equals(DependencyRequest.Kind.PRODUCED)
-              ? CodeBlocks.format("$T.createFutureProduced($L)", PRODUCERS, futureAccess)
+              ? CodeBlock.of("$T.createFutureProduced($L)", PRODUCERS, futureAccess)
               : futureAccess);
     }
     FutureTransform futureTransform = FutureTransform.create(fields, binding, asyncDependencies);
     CodeBlock transformCodeBlock =
-        CodeBlocks.format(
+        CodeBlock.of(
             Joiner.on('\n')
                 .join(
                     "new $1T<$2T, $3T>() {",
@@ -158,7 +157,7 @@ ClassName nameGeneratedType(ProductionBinding binding) {
             futureTransform.applyArgType(),
             providedTypeName,
             futureTransform.hasUncheckedCast()
-                ? CodeBlocks.format("$L // safe by specification", SUPPRESS_WARNINGS_UNCHECKED)
+                ? CodeBlock.of("$L // safe by specification", SUPPRESS_WARNINGS_UNCHECKED)
                 : "",
             futureTypeName,
             futureTransform.applyArgName(),
@@ -218,14 +217,14 @@ private CodeBlock producerTokenConstruction(
       ClassName generatedTypeName, ProductionBinding binding) {
     CodeBlock producerTokenArgs =
         compilerOptions.writeProducerNameInToken()
-            ? CodeBlocks.format(
+            ? CodeBlock.of(
                 "$S",
                 String.format(
                     "%s#%s",
                     ClassName.get(binding.bindingTypeElement()),
                     binding.bindingElement().getSimpleName()))
-            : CodeBlocks.format("$T.class", generatedTypeName);
-    return CodeBlocks.format("$T.create($L)", PRODUCER_TOKEN, producerTokenArgs);
+            : CodeBlock.of("$T.class", generatedTypeName);
+    return CodeBlock.of("$T.create($L)", PRODUCER_TOKEN, producerTokenArgs);
   }
 
   /** Returns a name of the variable representing this dependency's future. */
@@ -283,7 +282,7 @@ static FutureTransform create(
 
     @Override
     CodeBlock futureCodeBlock() {
-      return CodeBlocks.format("$T.<$T>immediateFuture(null)", FUTURES, VOID_CLASS);
+      return CodeBlock.of("$T.<$T>immediateFuture(null)", FUTURES, VOID_CLASS);
     }
 
     @Override
@@ -302,7 +301,7 @@ String applyArgName() {
       for (DependencyRequest dependency : binding.dependencies()) {
         parameterCodeBlocks.add(
             frameworkTypeUsageStatement(
-                CodeBlocks.format("$L", fields.get(dependency.bindingKey()).name()),
+                CodeBlock.of("$L", fields.get(dependency.bindingKey()).name()),
                 dependency.kind()));
       }
       return parameterCodeBlocks.build();
@@ -322,7 +321,7 @@ String applyArgName() {
 
     @Override
     CodeBlock futureCodeBlock() {
-      return CodeBlocks.format("$L", dependencyFutureName(asyncDependency));
+      return CodeBlock.of("$L", dependencyFutureName(asyncDependency));
     }
 
     @Override
@@ -342,12 +341,12 @@ String applyArgName() {
         // We really want to compare instances here, because asyncDependency is an element in the
         // set binding.dependencies().
         if (dependency == asyncDependency) {
-          parameterCodeBlocks.add(CodeBlocks.format("$L", applyArgName()));
+          parameterCodeBlocks.add(CodeBlock.of("$L", applyArgName()));
         } else {
           parameterCodeBlocks.add(
               // TODO(ronshapiro) extract this into a method shared by FutureTransform subclasses
               frameworkTypeUsageStatement(
-                  CodeBlocks.format("$L", fields.get(dependency.bindingKey()).name()),
+                  CodeBlock.of("$L", fields.get(dependency.bindingKey()).name()),
                   dependency.kind()));
         }
       }
@@ -368,7 +367,7 @@ String applyArgName() {
 
     @Override
     CodeBlock futureCodeBlock() {
-      return CodeBlocks.format(
+      return CodeBlock.of(
           "$T.<$T>allAsList($L)",
           FUTURES,
           OBJECT,
@@ -378,7 +377,7 @@ CodeBlock futureCodeBlock() {
                       new Function<DependencyRequest, CodeBlock>() {
                         @Override
                         public CodeBlock apply(DependencyRequest dependency) {
-                          return CodeBlocks.format("$L", dependencyFutureName(dependency));
+                          return CodeBlock.of("$L", dependencyFutureName(dependency));
                         }
                       })));
     }
@@ -435,13 +434,13 @@ private static TypeName asyncDependencyType(DependencyRequest dependency) {
     for (DependencyRequest dependency : binding.dependencies()) {
       if (isAsyncDependency(dependency)) {
         codeBlocks.add(
-            CodeBlocks.format(
+            CodeBlock.of(
                 "($T) $L.get($L)", asyncDependencyType(dependency), listArgName, argIndex));
         argIndex++;
       } else {
         codeBlocks.add(
             frameworkTypeUsageStatement(
-                CodeBlocks.format("$L", fields.get(dependency.bindingKey()).name()),
+                CodeBlock.of("$L", fields.get(dependency.bindingKey()).name()),
                 dependency.kind()));
       }
     }
@@ -462,11 +461,11 @@ private CodeBlock getInvocationCodeBlock(
       TypeName providedTypeName,
       ImmutableList<CodeBlock> parameterCodeBlocks) {
     CodeBlock moduleCodeBlock =
-        CodeBlocks.format(
+        CodeBlock.of(
             "$L.$L($L)",
             binding.bindingElement().getModifiers().contains(STATIC)
-                ? CodeBlocks.format("$T", ClassName.get(binding.bindingTypeElement()))
-                : CodeBlocks.format("$T.this.module", generatedTypeName),
+                ? CodeBlock.of("$T", ClassName.get(binding.bindingTypeElement()))
+                : CodeBlock.of("$T.this.module", generatedTypeName),
             binding.bindingElement().getSimpleName(),
             makeParametersCodeBlock(parameterCodeBlocks));
 
@@ -474,15 +473,15 @@ private CodeBlock getInvocationCodeBlock(
     // because we'll wrap all monitoring in non-throwing monitors before we pass them to the
     // factories.
     ImmutableList.Builder<CodeBlock> codeBlocks = ImmutableList.builder();
-    codeBlocks.add(CodeBlocks.format("monitor.methodStarting();"));
+    codeBlocks.add(CodeBlock.of("monitor.methodStarting();"));
 
     final CodeBlock valueCodeBlock;
-    if (binding.productionType().equals(Produces.Type.SET)) {
+    if (binding.contributionType().equals(ContributionType.SET)) {
       if (binding.bindingKind().equals(ContributionBinding.Kind.FUTURE_PRODUCTION)) {
         valueCodeBlock =
-            CodeBlocks.format("$T.createFutureSingletonSet($L)", PRODUCERS, moduleCodeBlock);
+            CodeBlock.of("$T.createFutureSingletonSet($L)", PRODUCERS, moduleCodeBlock);
       } else {
-        valueCodeBlock = CodeBlocks.format("$T.of($L)", IMMUTABLE_SET, moduleCodeBlock);
+        valueCodeBlock = CodeBlock.of("$T.of($L)", IMMUTABLE_SET, moduleCodeBlock);
       }
     } else {
       valueCodeBlock = moduleCodeBlock;
@@ -490,9 +489,9 @@ private CodeBlock getInvocationCodeBlock(
     CodeBlock returnCodeBlock =
         binding.bindingKind().equals(ContributionBinding.Kind.FUTURE_PRODUCTION)
             ? valueCodeBlock
-            : CodeBlocks.format(
+            : CodeBlock.of(
                 "$T.<$T>immediateFuture($L)", FUTURES, providedTypeName, valueCodeBlock);
-    return CodeBlocks.format(
+    return CodeBlock.of(
         Joiner.on('\n')
             .join(
                 "monitor.methodStarting();",
@@ -511,8 +510,8 @@ private CodeBlock getInvocationCodeBlock(
    */
   private CodeBlock getThrowsClause(List<? extends TypeMirror> thrownTypes) {
     if (thrownTypes.isEmpty()) {
-      return CodeBlocks.format("");
+      return CodeBlock.of("");
     }
-    return CodeBlocks.format("throws $L", makeParametersCodeBlock(toCodeBlocks(thrownTypes)));
+    return CodeBlock.of("throws $L", makeParametersCodeBlock(toCodeBlocks(thrownTypes)));
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProducerModuleProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/ProducerModuleProcessingStep.java
index d3873e969..fa8a8227d 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProducerModuleProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProducerModuleProcessingStep.java
@@ -23,6 +23,7 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.SetMultimap;
 import com.google.common.collect.Sets;
+import dagger.Binds;
 import dagger.producers.ProducerModule;
 import dagger.producers.Produces;
 import java.lang.annotation.Annotation;
@@ -48,6 +49,7 @@
   private final Messager messager;
   private final ModuleValidator moduleValidator;
   private final ProducesMethodValidator producesMethodValidator;
+  private final BindsMethodValidator bindsMethodValidator;
   private final ProductionBinding.Factory productionBindingFactory;
   private final ProducerFactoryGenerator factoryGenerator;
   private final Set<Element> processedModuleElements = Sets.newLinkedHashSet();
@@ -56,11 +58,13 @@
       Messager messager,
       ModuleValidator moduleValidator,
       ProducesMethodValidator producesMethodValidator,
+      BindsMethodValidator bindsMethodValidator,
       ProductionBinding.Factory productionBindingFactory,
       ProducerFactoryGenerator factoryGenerator) {
     this.messager = messager;
     this.moduleValidator = moduleValidator;
     this.producesMethodValidator = producesMethodValidator;
+    this.bindsMethodValidator = bindsMethodValidator;
     this.productionBindingFactory = productionBindingFactory;
     this.factoryGenerator = factoryGenerator;
   }
@@ -74,19 +78,11 @@
   public Set<Element> process(
       SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
     // first, check and collect all produces methods
-    ImmutableSet.Builder<ExecutableElement> validProducesMethodsBuilder = ImmutableSet.builder();
-    for (Element producesElement : elementsByAnnotation.get(Produces.class)) {
-      if (producesElement.getKind().equals(METHOD)) {
-        ExecutableElement producesMethodElement = (ExecutableElement) producesElement;
-        ValidationReport<ExecutableElement> methodReport =
-            producesMethodValidator.validate(producesMethodElement);
-        methodReport.printMessagesTo(messager);
-        if (methodReport.isClean()) {
-          validProducesMethodsBuilder.add(producesMethodElement);
-        }
-      }
-    }
-    ImmutableSet<ExecutableElement> validProducesMethods = validProducesMethodsBuilder.build();
+    ImmutableSet<ExecutableElement> validProducesMethods =
+        validateProducesMethods(elementsByAnnotation);
+
+    // second, check and collect all bind methods
+    ImmutableSet<ExecutableElement> validBindsMethods = validateBindsMethods(elementsByAnnotation);
 
     // process each module
     for (Element moduleElement :
@@ -100,17 +96,24 @@
         if (report.isClean()) {
           ImmutableSet.Builder<ExecutableElement> moduleProducesMethodsBuilder =
               ImmutableSet.builder();
+          ImmutableSet.Builder<ExecutableElement> moduleBindsMethodsBuilder =
+              ImmutableSet.builder();
           List<ExecutableElement> moduleMethods =
               ElementFilter.methodsIn(moduleElement.getEnclosedElements());
           for (ExecutableElement methodElement : moduleMethods) {
             if (isAnnotationPresent(methodElement, Produces.class)) {
               moduleProducesMethodsBuilder.add(methodElement);
             }
+            if (isAnnotationPresent(methodElement, Binds.class)) {
+              moduleBindsMethodsBuilder.add(methodElement);
+            }
           }
           ImmutableSet<ExecutableElement> moduleProducesMethods =
               moduleProducesMethodsBuilder.build();
+          ImmutableSet<ExecutableElement> moduleBindsMethods = moduleBindsMethodsBuilder.build();
 
-          if (Sets.difference(moduleProducesMethods, validProducesMethods).isEmpty()) {
+          if (Sets.difference(moduleProducesMethods, validProducesMethods).isEmpty()
+              && Sets.difference(moduleBindsMethods, validBindsMethods).isEmpty()) {
             // all of the produces methods in this module are valid!
             // time to generate some factories!
             ImmutableSet<ProductionBinding> bindings =
@@ -141,4 +144,38 @@ public ProductionBinding apply(ExecutableElement producesMethod) {
     }
     return ImmutableSet.of();
   }
+
+  private ImmutableSet<ExecutableElement> validateProducesMethods(
+      SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
+    ImmutableSet.Builder<ExecutableElement> validProducesMethodsBuilder = ImmutableSet.builder();
+    for (Element producesElement : elementsByAnnotation.get(Produces.class)) {
+      if (producesElement.getKind().equals(METHOD)) {
+        ExecutableElement producesMethodElement = (ExecutableElement) producesElement;
+        ValidationReport<ExecutableElement> methodReport =
+            producesMethodValidator.validate(producesMethodElement);
+        methodReport.printMessagesTo(messager);
+        if (methodReport.isClean()) {
+          validProducesMethodsBuilder.add(producesMethodElement);
+        }
+      }
+    }
+    return validProducesMethodsBuilder.build();
+  }
+
+  private ImmutableSet<ExecutableElement> validateBindsMethods(
+      SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
+    ImmutableSet.Builder<ExecutableElement> validBindsMethodsBuilder = ImmutableSet.builder();
+    for (Element bindElement : elementsByAnnotation.get(Binds.class)) {
+      if (bindElement.getKind().equals(METHOD)) {
+        ExecutableElement bindsMethodElement = (ExecutableElement) bindElement;
+        ValidationReport<ExecutableElement> methodReport =
+            bindsMethodValidator.validate(bindsMethodElement);
+        methodReport.printMessagesTo(messager);
+        if (methodReport.isClean()) {
+          validBindsMethodsBuilder.add(bindsMethodElement);
+        }
+      }
+    }
+    return validBindsMethodsBuilder.build();
+  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProducesMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/ProducesMethodValidator.java
index ce2479008..15b7a9619 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProducesMethodValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProducesMethodValidator.java
@@ -31,14 +31,14 @@
 import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
 
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
-import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_ABSTRACT;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_MUST_RETURN_A_VALUE;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_NOT_IN_MODULE;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_NOT_MAP_HAS_MAP_KEY;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_PRIVATE;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_SET_VALUES_RAW_SET;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_TYPE_PARAMETER;
@@ -50,14 +50,15 @@
 import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_SET_VALUES_RETURN_SET;
 import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_THROWS;
 import static dagger.internal.codegen.MapKeys.getMapKeys;
+import static dagger.internal.codegen.ProvidesMethodValidator.validateMapKey;
+import static dagger.internal.codegen.ProvidesMethodValidator.validateMultibindingSpecifiers;
+import static dagger.internal.codegen.Validation.validateMethodQualifiers;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.type.TypeKind.ARRAY;
 import static javax.lang.model.type.TypeKind.DECLARED;
 import static javax.lang.model.type.TypeKind.VOID;
 
-import javax.lang.model.util.Types;
-
 /**
  * A {@linkplain ValidationReport validator} for {@link Produces} methods.
  *
@@ -83,9 +84,6 @@ private TypeElement getSetElement() {
     ValidationReport.Builder<ExecutableElement> builder =
         ValidationReport.about(producesMethodElement);
 
-    Produces producesAnnotation = producesMethodElement.getAnnotation(Produces.class);
-    checkArgument(producesAnnotation != null);
-
     Element enclosingElement = producesMethodElement.getEnclosingElement();
     if (!isAnnotationPresent(enclosingElement, ProducerModule.class)) {
       builder.addError(
@@ -116,6 +114,11 @@ private TypeElement getSetElement() {
           formatErrorMessage(BINDING_METHOD_MUST_RETURN_A_VALUE), producesMethodElement);
     }
 
+    if (FrameworkTypes.isFrameworkType(returnType)) {
+      builder.addError(
+          formatErrorMessage(BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES), producesMethodElement);
+    }
+
     TypeMirror exceptionType = elements.getTypeElement(Exception.class.getCanonicalName()).asType();
     TypeMirror errorType = elements.getTypeElement(Error.class.getCanonicalName()).asType();
     for (TypeMirror thrownType : producesMethodElement.getThrownTypes()) {
@@ -125,17 +128,15 @@ private TypeElement getSetElement() {
       }
     }
 
-    // check mapkey is right
-    if (!producesAnnotation.type().equals(Produces.Type.MAP)
-        && !getMapKeys(producesMethodElement).isEmpty()) {
-      builder.addError(
-          formatErrorMessage(BINDING_METHOD_NOT_MAP_HAS_MAP_KEY), producesMethodElement);
-    }
+    ContributionType contributionType = ContributionType.fromBindingMethod(producesMethodElement);
+    validateMapKey(builder, producesMethodElement, contributionType, Produces.class);
+
+    validateMultibindingSpecifiers(builder, producesMethodElement, Produces.class);
 
-    ProvidesMethodValidator.validateMethodQualifiers(builder, producesMethodElement);
+    validateMethodQualifiers(builder, producesMethodElement);
 
-    switch (producesAnnotation.type()) {
-      case UNIQUE: // fall through
+    switch (contributionType) {
+      case UNIQUE:
       case SET:
         validateSingleReturnType(builder, returnType);
         break;
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
index c21aec6db..554abf1e5 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
@@ -22,8 +22,6 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Sets;
 import com.google.common.util.concurrent.ListenableFuture;
-import dagger.Provides;
-import dagger.producers.Produces;
 import java.util.Set;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
@@ -56,11 +54,6 @@ public BindingType bindingType() {
     return Optional.absent();
   }
 
-  @Override
-  Provides.Type provisionType() {
-    return Provides.Type.valueOf(productionType().name());
-  }
-
   @Override
   Set<DependencyRequest> implicitDependencies() {
     // Similar optimizations to ContributionBinding.implicitDependencies().
@@ -73,9 +66,6 @@ public BindingType bindingType() {
     }
   }
 
-  /** Returns provision type that was used to bind the key. */
-  abstract Produces.Type productionType();
-
   /** Returns the list of types in the throws clause of the method. */
   abstract ImmutableList<? extends TypeMirror> thrownTypes();
 
@@ -100,8 +90,6 @@ public BindingType bindingType() {
     ProductionBinding forProducesMethod(
         ExecutableElement producesMethod, TypeElement contributedBy) {
       checkArgument(producesMethod.getKind().equals(METHOD));
-      Produces producesAnnotation = producesMethod.getAnnotation(Produces.class);
-      checkArgument(producesAnnotation != null);
       SourceElement sourceElement = SourceElement.forElement(producesMethod, contributedBy);
       Key key = keyFactory.forProducesMethod(sourceElement);
       ExecutableType resolvedMethod =
@@ -119,6 +107,7 @@ ProductionBinding forProducesMethod(
           ? Kind.FUTURE_PRODUCTION
           : Kind.IMMEDIATE;
       return new AutoValue_ProductionBinding(
+          ContributionType.fromBindingMethod(producesMethod),
           sourceElement,
           key,
           dependencies,
@@ -126,42 +115,51 @@ ProductionBinding forProducesMethod(
           Optional.<DeclaredType>absent(), // TODO(beder): Add nullability checking with Java 8.
           Optional.<DependencyRequest>absent(),
           kind,
-          producesAnnotation.type(),
           ImmutableList.copyOf(producesMethod.getThrownTypes()),
           Optional.of(executorRequest),
           Optional.of(monitorRequest));
     }
 
-    ProductionBinding implicitMapOfProducerBinding(DependencyRequest mapOfValueRequest) {
-      checkNotNull(mapOfValueRequest);
-      Optional<Key> implicitMapOfProducerKey =
-          keyFactory.implicitMapProducerKeyFrom(mapOfValueRequest.key());
+    /**
+     * A synthetic binding of {@code Map<K, V>} or {@code Map<K, Produced<V>>} that depends on
+     * {@code Map<K, Producer<V>>}.
+     */
+    ProductionBinding syntheticMapOfValuesOrProducedBinding(
+        DependencyRequest requestForMapOfValuesOrProduced) {
+      checkNotNull(requestForMapOfValuesOrProduced);
+      Optional<Key> mapOfProducersKey =
+          keyFactory.implicitMapProducerKeyFrom(requestForMapOfValuesOrProduced.key());
       checkArgument(
-          implicitMapOfProducerKey.isPresent(), "%s is not for a Map<K, V>", mapOfValueRequest);
-      DependencyRequest implicitMapOfProducerRequest =
+          mapOfProducersKey.isPresent(),
+          "%s is not for a Map<K, V>",
+          requestForMapOfValuesOrProduced);
+      DependencyRequest requestForMapOfProducers =
           dependencyRequestFactory.forImplicitMapBinding(
-              mapOfValueRequest, implicitMapOfProducerKey.get());
+              requestForMapOfValuesOrProduced, mapOfProducersKey.get());
       return new AutoValue_ProductionBinding(
-          SourceElement.forElement(implicitMapOfProducerRequest.requestElement()),
-          mapOfValueRequest.key(),
-          ImmutableSet.of(implicitMapOfProducerRequest),
-          findBindingPackage(mapOfValueRequest.key()),
+          ContributionType.UNIQUE,
+          SourceElement.forElement(requestForMapOfProducers.requestElement()),
+          requestForMapOfValuesOrProduced.key(),
+          ImmutableSet.of(requestForMapOfProducers),
+          findBindingPackage(requestForMapOfValuesOrProduced.key()),
           Optional.<DeclaredType>absent(),
           Optional.<DependencyRequest>absent(),
           Kind.SYNTHETIC_MAP,
-          Produces.Type.UNIQUE,
           ImmutableList.<TypeMirror>of(),
           Optional.<DependencyRequest>absent(),
           Optional.<DependencyRequest>absent());
     }
 
     /**
-     * A binding that depends explicitly on a set of individual provision or production multibinding
-     * contribution methods.
+     * A synthetic binding that depends explicitly on a set of individual provision or production
+     * multibinding contribution methods.
+     * 
+     * <p>Note that these could be set multibindings or map multibindings.
      */
     ProductionBinding syntheticMultibinding(
         final DependencyRequest request, Iterable<ContributionBinding> multibindingContributions) {
       return new AutoValue_ProductionBinding(
+          ContributionType.UNIQUE,
           SourceElement.forElement(request.requestElement()),
           request.key(),
           dependencyRequestFactory.forMultibindingContributions(request, multibindingContributions),
@@ -169,7 +167,6 @@ ProductionBinding syntheticMultibinding(
           Optional.<DeclaredType>absent(),
           Optional.<DependencyRequest>absent(),
           Kind.forMultibindingRequest(request),
-          Produces.Type.UNIQUE,
           ImmutableList.<TypeMirror>of(),
           Optional.<DependencyRequest>absent(),
           Optional.<DependencyRequest>absent());
@@ -181,6 +178,7 @@ ProductionBinding forComponentMethod(ExecutableElement componentMethod) {
       checkArgument(componentMethod.getParameters().isEmpty());
       checkArgument(MoreTypes.isTypeOf(ListenableFuture.class, componentMethod.getReturnType()));
       return new AutoValue_ProductionBinding(
+          ContributionType.UNIQUE,
           SourceElement.forElement(componentMethod),
           keyFactory.forProductionComponentMethod(componentMethod),
           ImmutableSet.<DependencyRequest>of(),
@@ -188,10 +186,25 @@ ProductionBinding forComponentMethod(ExecutableElement componentMethod) {
           Optional.<DeclaredType>absent(),
           Optional.<DependencyRequest>absent(),
           Kind.COMPONENT_PRODUCTION,
-          Produces.Type.UNIQUE,
           ImmutableList.copyOf(componentMethod.getThrownTypes()),
           Optional.<DependencyRequest>absent(),
           Optional.<DependencyRequest>absent());
     }
+
+    ProductionBinding delegate(
+        DelegateDeclaration delegateDeclaration, ProductionBinding delegateBinding) {
+      return new AutoValue_ProductionBinding(
+          delegateBinding.contributionType(),
+          delegateDeclaration.sourceElement(),
+          delegateDeclaration.key(),
+          ImmutableSet.of(delegateDeclaration.delegateRequest()),
+          findBindingPackage(delegateDeclaration.key()),
+          delegateBinding.nullableType(),
+          Optional.<DependencyRequest>absent(),
+          Kind.SYNTHETIC_DELEGATE_BINDING,
+          ImmutableList.<TypeMirror>of(),
+          Optional.<DependencyRequest>absent(),
+          Optional.<DependencyRequest>absent());
+    }
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProductionExecutorModuleGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ProductionExecutorModuleGenerator.java
index d6a90a70d..4a44c0869 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProductionExecutorModuleGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProductionExecutorModuleGenerator.java
@@ -59,7 +59,7 @@ ClassName nameGeneratedType(TypeElement componentElement) {
   @Override
   Optional<TypeSpec.Builder> write(ClassName generatedTypeName, TypeElement componentElement) {
     return Optional.of(
-        classBuilder(generatedTypeName.simpleName())
+        classBuilder(generatedTypeName)
             .addAnnotation(
                 AnnotationSpec.builder(Module.class)
                     .build())
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java
index 61420df59..c435c3427 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java
@@ -19,6 +19,7 @@
 import com.google.common.collect.Iterables;
 import dagger.Module;
 import dagger.Provides;
+import java.lang.annotation.Annotation;
 import java.util.Set;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
@@ -30,11 +31,13 @@
 import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
 
+import static com.google.auto.common.MoreElements.getAnnotationMirror;
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
-import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_ABSTRACT;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_MUST_RETURN_A_VALUE;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_NOT_IN_MODULE;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_NOT_MAP_HAS_MAP_KEY;
@@ -43,22 +46,19 @@
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_TYPE_PARAMETER;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_WITH_MULTIPLE_MAP_KEY;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_WITH_NO_MAP_KEY;
-import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_RETURN_TYPE;
+import static dagger.internal.codegen.ErrorMessages.MULTIBINDING_ANNOTATION_CONFLICTS_WITH_BINDING_ANNOTATION_ENUM;
+import static dagger.internal.codegen.ErrorMessages.MULTIPLE_MULTIBINDING_ANNOTATIONS_ON_METHOD;
 import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_SET_VALUES_RETURN_SET;
-import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_THROWS;
-import static dagger.internal.codegen.ErrorMessages.PROVIDES_OR_PRODUCES_METHOD_MULTIPLE_QUALIFIERS;
 import static dagger.internal.codegen.ErrorMessages.provisionMayNotDependOnProducerType;
-import static dagger.internal.codegen.InjectionAnnotations.getQualifiers;
 import static dagger.internal.codegen.MapKeys.getMapKeys;
+import static dagger.internal.codegen.Validation.validateMethodQualifiers;
+import static dagger.internal.codegen.Validation.validateReturnType;
+import static dagger.internal.codegen.Validation.validateUncheckedThrows;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.element.Modifier.PRIVATE;
-import static javax.lang.model.type.TypeKind.ARRAY;
 import static javax.lang.model.type.TypeKind.DECLARED;
-import static javax.lang.model.type.TypeKind.TYPEVAR;
 import static javax.lang.model.type.TypeKind.VOID;
 
-import javax.lang.model.util.Types;
-
 /**
  * A {@linkplain ValidationReport validator} for {@link Provides} methods.
  *
@@ -82,9 +82,6 @@ private TypeElement getSetElement() {
     ValidationReport.Builder<ExecutableElement> builder =
         ValidationReport.about(providesMethodElement);
 
-    Provides providesAnnotation = providesMethodElement.getAnnotation(Provides.class);
-    checkArgument(providesAnnotation != null);
-
     Element enclosingElement = providesMethodElement.getEnclosingElement();
     if (!isAnnotationPresent(enclosingElement, Module.class)) {
       builder.addError(
@@ -110,16 +107,7 @@ private TypeElement getSetElement() {
           formatErrorMessage(BINDING_METHOD_MUST_RETURN_A_VALUE), providesMethodElement);
     }
 
-    TypeMirror runtimeExceptionType =
-        elements.getTypeElement(RuntimeException.class.getCanonicalName()).asType();
-    TypeMirror errorType = elements.getTypeElement(Error.class.getCanonicalName()).asType();
-    for (TypeMirror thrownType : providesMethodElement.getThrownTypes()) {
-      if (!types.isSubtype(thrownType, runtimeExceptionType)
-          && !types.isSubtype(thrownType, errorType)) {
-        builder.addError(PROVIDES_METHOD_THROWS, providesMethodElement);
-        break;
-      }
-    }
+    validateUncheckedThrows(elements, types, providesMethodElement, Provides.class, builder);
 
     for (VariableElement parameter : providesMethodElement.getParameters()) {
       if (FrameworkTypes.isProducerType(parameter.asType())) {
@@ -127,22 +115,29 @@ private TypeElement getSetElement() {
       }
     }
 
-    // check mapkey is right
-    if (!providesAnnotation.type().equals(Provides.Type.MAP)
-        && !getMapKeys(providesMethodElement).isEmpty()) {
-      builder.addError(
-          formatErrorMessage(BINDING_METHOD_NOT_MAP_HAS_MAP_KEY), providesMethodElement);
-    }
+    ContributionType contributionType = ContributionType.fromBindingMethod(providesMethodElement);
+
+    validateMapKey(builder, providesMethodElement, contributionType, Provides.class);
 
     validateMethodQualifiers(builder, providesMethodElement);
 
-    switch (providesAnnotation.type()) {
-      case UNIQUE: // fall through
+    validateMultibindingSpecifiers(builder, providesMethodElement, Provides.class);
+    switch (contributionType) {
+      case UNIQUE:
+        /* Validate that a unique binding is not attempting to bind a framework type. This
+         * validation is only appropriate for unique bindings because multibindings may collect
+         * framework types.  E.g. Set<Provider<Foo>> is perfectly reasonable. */
+        if (FrameworkTypes.isFrameworkType(returnType)) {
+          builder.addError(
+              formatErrorMessage(BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES),
+              providesMethodElement);
+        }
+        // fall through
       case SET:
-        validateKeyType(builder, returnType);
+        validateReturnType(Provides.class, builder, returnType);
         break;
       case MAP:
-        validateKeyType(builder, returnType);
+        validateReturnType(Provides.class, builder, returnType);
         ImmutableSet<? extends AnnotationMirror> mapKeys = getMapKeys(providesMethodElement);
         switch (mapKeys.size()) {
           case 0:
@@ -169,7 +164,9 @@ private TypeElement getSetElement() {
             builder.addError(
                 formatErrorMessage(BINDING_METHOD_SET_VALUES_RAW_SET), providesMethodElement);
           } else {
-            validateKeyType(builder,
+            validateReturnType(
+                Provides.class,
+                builder,
                 Iterables.getOnlyElement(declaredReturnType.getTypeArguments()));
           }
         }
@@ -181,33 +178,58 @@ private TypeElement getSetElement() {
     return builder.build();
   }
 
-  /** Validates that a Provides or Produces method doesn't have multiple qualifiers. */
-  static void validateMethodQualifiers(ValidationReport.Builder<ExecutableElement> builder,
-      ExecutableElement methodElement) {
-    ImmutableSet<? extends AnnotationMirror> qualifiers = getQualifiers(methodElement);
-    if (qualifiers.size() > 1) {
-      for (AnnotationMirror qualifier : qualifiers) {
-        builder.addError(PROVIDES_OR_PRODUCES_METHOD_MULTIPLE_QUALIFIERS, methodElement, qualifier);
+  /** Validate that methods for map multibindings have a {@code @MapKey} annotation. */
+  static void validateMapKey(
+      ValidationReport.Builder<ExecutableElement> builder,
+      ExecutableElement method,
+      ContributionType contributionType,
+      Class<? extends Annotation> bindingAnnotation) {
+    if (!contributionType.equals(ContributionType.MAP) && !getMapKeys(method).isEmpty()) {
+      builder.addError(
+          String.format(BINDING_METHOD_NOT_MAP_HAS_MAP_KEY, bindingAnnotation.getSimpleName()),
+          method);
+    }
+  }
+
+  /**
+   * Validate that at most one multibinding annotation is used, and not in conflict with {@link
+   * Provides#type()}.
+   */
+  static void validateMultibindingSpecifiers(
+      ValidationReport.Builder<ExecutableElement> builder,
+      ExecutableElement method,
+      Class<? extends Annotation> bindingAnnotation) {
+    ImmutableSet<AnnotationMirror> multibindingAnnotations =
+        MultibindingAnnotations.forMethod(method);
+    if (multibindingAnnotations.size() > 1) {
+      for (AnnotationMirror annotation : multibindingAnnotations) {
+        builder.addError(
+            String.format(
+                MULTIPLE_MULTIBINDING_ANNOTATIONS_ON_METHOD, bindingAnnotation.getSimpleName()),
+            method,
+            annotation);
       }
     }
+
+    AnnotationMirror bindingAnnotationMirror = getAnnotationMirror(method, bindingAnnotation).get();
+    boolean usesProvidesType = false;
+    for (ExecutableElement member : bindingAnnotationMirror.getElementValues().keySet()) {
+      usesProvidesType |= member.getSimpleName().contentEquals("type");
+    }
+    if (usesProvidesType && !multibindingAnnotations.isEmpty()) {
+      builder.addError(
+          String.format(
+              MULTIBINDING_ANNOTATION_CONFLICTS_WITH_BINDING_ANNOTATION_ENUM,
+              bindingAnnotation.getSimpleName()),
+          method);
+    }
   }
 
   private String formatErrorMessage(String msg) {
     return String.format(msg, Provides.class.getSimpleName());
   }
 
-  private String formatModuleErrorMessage(String msg) {
+  private static String formatModuleErrorMessage(String msg) {
     return String.format(msg, Provides.class.getSimpleName(), Module.class.getSimpleName());
   }
-
-  private void validateKeyType(ValidationReport.Builder<? extends Element> reportBuilder,
-      TypeMirror type) {
-    TypeKind kind = type.getKind();
-    if (!(kind.isPrimitive()
-        || kind.equals(DECLARED)
-        || kind.equals(ARRAY)
-        || kind.equals(TYPEVAR))) {
-      reportBuilder.addError(PROVIDES_METHOD_RETURN_TYPE, reportBuilder.getSubject());
-    }
-  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
index aa08f5c2e..80b6d8230 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
@@ -21,8 +21,6 @@
 import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Sets;
-import dagger.Provides;
-import java.util.concurrent.Executor;
 import javax.inject.Inject;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ElementKind;
@@ -64,7 +62,7 @@ public BindingType bindingType() {
 
   @Override
   abstract Optional<Scope> scope();
-  
+
   static final class Factory {
     private final Elements elements;
     private final Types types;
@@ -119,6 +117,7 @@ ProvisionBinding forInjectConstructor(ExecutableElement constructorElement,
           MoreElements.asType(constructorElement.getEnclosingElement());
 
       return new AutoValue_ProvisionBinding(
+          ContributionType.UNIQUE,
           SourceElement.forElement(constructorElement),
           key,
           dependencies,
@@ -126,7 +125,6 @@ ProvisionBinding forInjectConstructor(ExecutableElement constructorElement,
           Optional.<DeclaredType>absent(),
           membersInjectionRequest,
           Kind.INJECTION,
-          Provides.Type.UNIQUE,
           hasNonDefaultTypeParameters(bindingTypeElement, key.type(), types)
               ? Optional.of(forInjectConstructor(constructorElement, Optional.<TypeMirror>absent()))
               : Optional.<ProvisionBinding>absent(),
@@ -154,8 +152,6 @@ ProvisionBinding forInjectConstructor(ExecutableElement constructorElement,
     ProvisionBinding forProvidesMethod(
         ExecutableElement providesMethod, TypeElement contributedBy) {
       checkArgument(providesMethod.getKind().equals(METHOD));
-      Provides providesAnnotation = providesMethod.getAnnotation(Provides.class);
-      checkArgument(providesAnnotation != null);
       SourceElement sourceElement = SourceElement.forElement(providesMethod, contributedBy);
       ExecutableType resolvedMethod =
           MoreTypes.asExecutable(sourceElement.asMemberOfContributingType(types));
@@ -167,6 +163,7 @@ ProvisionBinding forProvidesMethod(
               resolvedMethod.getParameterTypes());
       Optional<Scope> scope = Scope.uniqueScopeOf(providesMethod);
       return new AutoValue_ProvisionBinding(
+          ContributionType.fromBindingMethod(providesMethod),
           sourceElement,
           key,
           dependencies,
@@ -174,42 +171,47 @@ ProvisionBinding forProvidesMethod(
           ConfigurationAnnotations.getNullableType(providesMethod),
           Optional.<DependencyRequest>absent(),
           Kind.PROVISION,
-          providesAnnotation.type(),
           Optional.<ProvisionBinding>absent(),
           scope);
     }
-    
-    ProvisionBinding implicitMapOfProviderBinding(DependencyRequest mapOfValueRequest) {
-      checkNotNull(mapOfValueRequest);
-      Optional<Key> implicitMapOfProviderKey =
-          keyFactory.implicitMapProviderKeyFrom(mapOfValueRequest.key());
+
+    /**
+     * A synthetic binding of {@code Map<K, V>} that depends on {@code Map<K, Provider<V>>}.
+     */
+    ProvisionBinding syntheticMapOfValuesBinding(DependencyRequest requestForMapOfValues) {
+      checkNotNull(requestForMapOfValues);
+      Optional<Key> mapOfProvidersKey =
+          keyFactory.implicitMapProviderKeyFrom(requestForMapOfValues.key());
       checkArgument(
-          implicitMapOfProviderKey.isPresent(),
+          mapOfProvidersKey.isPresent(),
           "%s is not a request for Map<K, V>",
-          mapOfValueRequest);
-      DependencyRequest implicitMapOfProviderRequest =
+          requestForMapOfValues);
+      DependencyRequest requestForMapOfProviders =
           dependencyRequestFactory.forImplicitMapBinding(
-              mapOfValueRequest, implicitMapOfProviderKey.get());
+              requestForMapOfValues, mapOfProvidersKey.get());
       return new AutoValue_ProvisionBinding(
-          SourceElement.forElement(implicitMapOfProviderRequest.requestElement()),
-          mapOfValueRequest.key(),
-          ImmutableSet.of(implicitMapOfProviderRequest),
-          findBindingPackage(mapOfValueRequest.key()),
+          ContributionType.UNIQUE,
+          SourceElement.forElement(requestForMapOfProviders.requestElement()),
+          requestForMapOfValues.key(),
+          ImmutableSet.of(requestForMapOfProviders),
+          findBindingPackage(requestForMapOfValues.key()),
           Optional.<DeclaredType>absent(),
           Optional.<DependencyRequest>absent(),
           Kind.SYNTHETIC_MAP,
-          Provides.Type.UNIQUE,
           Optional.<ProvisionBinding>absent(),
-          Scope.uniqueScopeOf(implicitMapOfProviderRequest.requestElement()));
+          Scope.uniqueScopeOf(requestForMapOfProviders.requestElement()));
     }
 
     /**
-     * A binding that depends explicitly on a set of individual provision multibinding contribution
-     * methods.
+     * A synthetic binding that depends explicitly on a set of individual provision multibinding
+     * contribution methods.
+     * 
+     * <p>Note that these could be set multibindings or map multibindings.
      */
     ProvisionBinding syntheticMultibinding(
         final DependencyRequest request, Iterable<ContributionBinding> multibindingContributions) {
       return new AutoValue_ProvisionBinding(
+          ContributionType.UNIQUE,
           SourceElement.forElement(request.requestElement()),
           request.key(),
           dependencyRequestFactory.forMultibindingContributions(request, multibindingContributions),
@@ -217,7 +219,6 @@ ProvisionBinding syntheticMultibinding(
           Optional.<DeclaredType>absent(),
           Optional.<DependencyRequest>absent(),
           Kind.forMultibindingRequest(request),
-          Provides.Type.UNIQUE,
           Optional.<ProvisionBinding>absent(),
           Scope.uniqueScopeOf(request.requestElement()));
     }
@@ -225,6 +226,7 @@ ProvisionBinding syntheticMultibinding(
     ProvisionBinding forComponent(TypeElement componentDefinitionType) {
       checkNotNull(componentDefinitionType);
       return new AutoValue_ProvisionBinding(
+          ContributionType.UNIQUE,
           SourceElement.forElement(componentDefinitionType),
           keyFactory.forComponent(componentDefinitionType.asType()),
           ImmutableSet.<DependencyRequest>of(),
@@ -232,7 +234,6 @@ ProvisionBinding forComponent(TypeElement componentDefinitionType) {
           Optional.<DeclaredType>absent(),
           Optional.<DependencyRequest>absent(),
           Kind.COMPONENT,
-          Provides.Type.UNIQUE,
           Optional.<ProvisionBinding>absent(),
           Optional.<Scope>absent());
     }
@@ -243,6 +244,7 @@ ProvisionBinding forComponentMethod(ExecutableElement componentMethod) {
       checkArgument(componentMethod.getParameters().isEmpty());
       Optional<Scope> scope = Scope.uniqueScopeOf(componentMethod);
       return new AutoValue_ProvisionBinding(
+          ContributionType.UNIQUE,
           SourceElement.forElement(componentMethod),
           keyFactory.forComponentMethod(componentMethod),
           ImmutableSet.<DependencyRequest>of(),
@@ -250,7 +252,6 @@ ProvisionBinding forComponentMethod(ExecutableElement componentMethod) {
           ConfigurationAnnotations.getNullableType(componentMethod),
           Optional.<DependencyRequest>absent(),
           Kind.COMPONENT_PROVISION,
-          Provides.Type.UNIQUE,
           Optional.<ProvisionBinding>absent(),
           scope);
     }
@@ -262,6 +263,7 @@ ProvisionBinding forSubcomponentBuilderMethod(
       checkArgument(subcomponentBuilderMethod.getParameters().isEmpty());
       DeclaredType declaredContainer = asDeclared(contributedBy.asType());
       return new AutoValue_ProvisionBinding(
+          ContributionType.UNIQUE,
           SourceElement.forElement(subcomponentBuilderMethod, contributedBy),
           keyFactory.forSubcomponentBuilderMethod(subcomponentBuilderMethod, declaredContainer),
           ImmutableSet.<DependencyRequest>of(),
@@ -269,25 +271,23 @@ ProvisionBinding forSubcomponentBuilderMethod(
           Optional.<DeclaredType>absent(),
           Optional.<DependencyRequest>absent(),
           Kind.SUBCOMPONENT_BUILDER,
-          Provides.Type.UNIQUE,
           Optional.<ProvisionBinding>absent(),
           Optional.<Scope>absent());
     }
 
-    ProvisionBinding forExecutorDependency(TypeElement componentElement) {
-      TypeElement executorElement = elements.getTypeElement(Executor.class.getCanonicalName());
-      checkNotNull(executorElement);
+    ProvisionBinding delegate(
+        DelegateDeclaration delegateDeclaration, ProvisionBinding delegate) {
       return new AutoValue_ProvisionBinding(
-          SourceElement.forElement(componentElement),
-          keyFactory.forProductionExecutor(),
-          ImmutableSet.<DependencyRequest>of(),
-          Optional.<String>absent(),
-          Optional.<DeclaredType>absent(),
+          delegate.contributionType(),
+          delegateDeclaration.sourceElement(),
+          delegateDeclaration.key(),
+          ImmutableSet.of(delegateDeclaration.delegateRequest()),
+          findBindingPackage(delegateDeclaration.key()),
+          delegate.nullableType(),
           Optional.<DependencyRequest>absent(),
-          Kind.EXECUTOR_DEPENDENCY,
-          Provides.Type.UNIQUE,
+          Kind.SYNTHETIC_DELEGATE_BINDING,
           Optional.<ProvisionBinding>absent(),
-          Optional.<Scope>absent());
+          Scope.uniqueScopeOf(delegateDeclaration.sourceElement().element()));
     }
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
index 61edc72e7..ab7c64937 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
@@ -38,6 +38,7 @@
 import static com.google.common.base.Preconditions.checkArgument;
 import static dagger.internal.codegen.FrameworkDependency.frameworkDependenciesForBinding;
 import static dagger.internal.codegen.TypeNames.DOUBLE_CHECK;
+import static dagger.internal.codegen.TypeNames.PROVIDER_OF_LAZY;
 
 /**
  * Utilities for generating files.
@@ -125,14 +126,16 @@ static CodeBlock frameworkTypeUsageStatement(
       CodeBlock frameworkTypeMemberSelect, DependencyRequest.Kind dependencyKind) {
     switch (dependencyKind) {
       case LAZY:
-        return CodeBlocks.format("$T.lazy($L)", DOUBLE_CHECK, frameworkTypeMemberSelect);
+        return CodeBlock.of("$T.lazy($L)", DOUBLE_CHECK, frameworkTypeMemberSelect);
       case INSTANCE:
       case FUTURE:
-        return CodeBlocks.format("$L.get()", frameworkTypeMemberSelect);
+        return CodeBlock.of("$L.get()", frameworkTypeMemberSelect);
       case PROVIDER:
       case PRODUCER:
       case MEMBERS_INJECTOR:
-        return CodeBlocks.format("$L", frameworkTypeMemberSelect);
+        return CodeBlock.of("$L", frameworkTypeMemberSelect);
+      case PROVIDER_OF_LAZY:
+        return CodeBlock.of("$T.create($L)", PROVIDER_OF_LAZY, frameworkTypeMemberSelect);
       default:
         throw new AssertionError();
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/SubcomponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/SubcomponentWriter.java
index 17af901fe..af327aa82 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SubcomponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SubcomponentWriter.java
@@ -107,7 +107,7 @@ private ExecutableType resolvedSubcomponentFactoryMethod() {
 
   @Override
   protected TypeSpec.Builder createComponentClass() {
-    TypeSpec.Builder subcomponent = classBuilder(name.simpleName()).addModifiers(PRIVATE, FINAL);
+    TypeSpec.Builder subcomponent = classBuilder(name).addModifiers(PRIVATE, FINAL);
 
     addSupertype(
         subcomponent,
@@ -192,7 +192,7 @@ private void writeSubcomponentWithoutBuilder(
         MemberSelect moduleSelect = localField(name, actualModuleName);
         componentContributionFields.put(moduleTypeElement, moduleSelect);
         subcomponentConstructorParameters.add(
-            CodeBlocks.format("$L", moduleVariable.getSimpleName()));
+            CodeBlock.of("$L", moduleVariable.getSimpleName()));
       }
     }
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/TypeNames.java b/compiler/src/main/java/dagger/internal/codegen/TypeNames.java
index b88c6caa0..f16e38364 100644
--- a/compiler/src/main/java/dagger/internal/codegen/TypeNames.java
+++ b/compiler/src/main/java/dagger/internal/codegen/TypeNames.java
@@ -30,8 +30,9 @@
 import dagger.internal.MapFactory;
 import dagger.internal.MapProviderFactory;
 import dagger.internal.MembersInjectors;
+import dagger.internal.ProviderOfLazy;
 import dagger.internal.SetFactory;
-import dagger.internal.SimpleLazilyInitializedProvider;
+import dagger.internal.SingleCheck;
 import dagger.producers.Produced;
 import dagger.producers.Producer;
 import dagger.producers.internal.AbstractProducer;
@@ -77,12 +78,12 @@
   static final ClassName PRODUCER = ClassName.get(Producer.class);
   static final ClassName PRODUCERS = ClassName.get(Producers.class);
   static final ClassName PROVIDER = ClassName.get(Provider.class);
-  static final ClassName SIMPLE_LAZILY_INITIALIZED_PROVIDER =
-      ClassName.get(SimpleLazilyInitializedProvider.class);
+  static final ClassName PROVIDER_OF_LAZY = ClassName.get(ProviderOfLazy.class);
   static final ClassName SET = ClassName.get(Set.class);
   static final ClassName SET_FACTORY = ClassName.get(SetFactory.class);
   static final ClassName SET_OF_PRODUCED_PRODUCER = ClassName.get(SetOfProducedProducer.class);
   static final ClassName SET_PRODUCER = ClassName.get(SetProducer.class);
+  static final ClassName SINGLE_CHECK = ClassName.get(SingleCheck.class);
   static final ClassName STRING = ClassName.get(String.class);
   static final ClassName UNSUPPORTED_OPERATION_EXCEPTION =
       ClassName.get(UnsupportedOperationException.class);
diff --git a/compiler/src/main/java/dagger/internal/codegen/Util.java b/compiler/src/main/java/dagger/internal/codegen/Util.java
index 1b941ceab..e7d9685e1 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Util.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Util.java
@@ -16,8 +16,16 @@
  */
 package dagger.internal.codegen;
 
+import com.google.auto.common.MoreElements;
+import com.google.auto.common.MoreTypes;
+import com.google.common.base.Predicate;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableSet;
+import dagger.Binds;
+import dagger.Provides;
+import dagger.producers.Produces;
+import java.lang.annotation.Annotation;
+import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
@@ -25,6 +33,7 @@
 
 import static com.google.auto.common.MoreElements.getLocalAndInheritedMethods;
 import static com.google.auto.common.MoreElements.hasModifiers;
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static javax.lang.model.element.ElementKind.CONSTRUCTOR;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.element.Modifier.PRIVATE;
@@ -34,6 +43,32 @@
  * Utilities for handling types in annotation processors
  */
 final class Util {
+  /**
+   * Returns true if the passed {@link TypeElement} requires a passed instance in order to be used
+   * within a component.
+   */
+  static boolean requiresAPassedInstance(Elements elements, TypeElement typeElement) {
+    ImmutableSet<ExecutableElement> methods =
+        MoreElements.getLocalAndInheritedMethods(typeElement, elements);
+    boolean foundInstanceMethod = false;
+    for (ExecutableElement method : methods) {
+      if (method.getModifiers().contains(ABSTRACT) && !isAnnotationPresent(method, Binds.class)) {
+        /* We found an abstract method that isn't a @Bind method.  That automatically means that
+         * a user will have to provide an instance because we don't know which subclass to use. */
+        return true;
+      } else if (!method.getModifiers().contains(STATIC)
+          && (isAnnotationPresent(method, Provides.class)
+              || isAnnotationPresent(method, Produces.class))) {
+        foundInstanceMethod = true;
+      }
+    }
+
+    if (foundInstanceMethod) {
+      return !componentCanMakeNewInstances(typeElement);
+    }
+
+    return false;
+  }
 
   /**
    * Returns true if and only if a component can instantiate new instances (typically of a module)
@@ -94,5 +129,16 @@ private static boolean requiresEnclosingInstance(TypeElement typeElement) {
         .toSet();
   }
 
+  // TODO(ronshapiro): add into auto/common/AnnotationMirrors.java
+  static Predicate<AnnotationMirror> hasAnnotationType(
+      final Class<? extends Annotation> annotation) {
+    return new Predicate<AnnotationMirror>() {
+      @Override
+      public boolean apply(AnnotationMirror input) {
+        return MoreTypes.isTypeOf(annotation, input.getAnnotationType());
+      }
+    };
+  }
+
   private Util() {}
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/Validation.java b/compiler/src/main/java/dagger/internal/codegen/Validation.java
new file mode 100644
index 000000000..4a2c659b8
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/Validation.java
@@ -0,0 +1,87 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.common.collect.ImmutableSet;
+import java.lang.annotation.Annotation;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.type.TypeKind;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
+
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_MULTIPLE_QUALIFIERS;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_RETURN_TYPE;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_THROWS_CHECKED;
+import static dagger.internal.codegen.InjectionAnnotations.getQualifiers;
+import static javax.lang.model.type.TypeKind.ARRAY;
+import static javax.lang.model.type.TypeKind.DECLARED;
+import static javax.lang.model.type.TypeKind.TYPEVAR;
+
+final class Validation {
+
+  private Validation() {}
+
+  /** Validates that the given method only throws unchecked exceptions. */
+  static void validateUncheckedThrows(
+      Elements elements,
+      Types types,
+      ExecutableElement methodElement,
+      Class<? extends Annotation> methodAnnotation,
+      ValidationReport.Builder<ExecutableElement> builder) {
+    TypeMirror runtimeExceptionType =
+        elements.getTypeElement(RuntimeException.class.getCanonicalName()).asType();
+    TypeMirror errorType = elements.getTypeElement(Error.class.getCanonicalName()).asType();
+    for (TypeMirror thrownType : methodElement.getThrownTypes()) {
+      if (!types.isSubtype(thrownType, runtimeExceptionType)
+          && !types.isSubtype(thrownType, errorType)) {
+        builder.addError(
+            String.format(BINDING_METHOD_THROWS_CHECKED, methodAnnotation.getSimpleName()),
+            methodElement);
+        break;
+      }
+    }
+  }
+
+  /** Validates that the return type of a binding method is an acceptable kind. */
+  static void validateReturnType(
+      Class<? extends Annotation> methodAnnotation,
+      ValidationReport.Builder<? extends Element> reportBuilder,
+      TypeMirror returnType) {
+    TypeKind kind = returnType.getKind();
+    if (!(kind.isPrimitive()
+        || kind.equals(DECLARED)
+        || kind.equals(ARRAY)
+        || kind.equals(TYPEVAR))) {
+      reportBuilder.addError(
+          String.format(BINDING_METHOD_RETURN_TYPE, methodAnnotation.getSimpleName()),
+          reportBuilder.getSubject());
+    }
+  }
+
+  /** Validates that a Provides, Produces or Bind method doesn't have multiple qualifiers. */
+  static void validateMethodQualifiers(
+      ValidationReport.Builder<ExecutableElement> builder, ExecutableElement methodElement) {
+    ImmutableSet<? extends AnnotationMirror> qualifiers = getQualifiers(methodElement);
+    if (qualifiers.size() > 1) {
+      for (AnnotationMirror qualifier : qualifiers) {
+        builder.addError(BINDING_METHOD_MULTIPLE_QUALIFIERS, methodElement, qualifier);
+      }
+    }
+  }
+}
diff --git a/compiler/src/test/java/dagger/internal/codegen/BindsMethodValidatorTest.java b/compiler/src/test/java/dagger/internal/codegen/BindsMethodValidatorTest.java
new file mode 100644
index 000000000..13aafff1f
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/BindsMethodValidatorTest.java
@@ -0,0 +1,177 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.common.collect.ImmutableList;
+import com.google.testing.compile.JavaFileObjects;
+import dagger.Module;
+import dagger.producers.ProducerModule;
+import java.lang.annotation.Annotation;
+import java.util.Collection;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+import org.junit.runners.Parameterized.Parameters;
+
+import static com.google.common.truth.Truth.assertAbout;
+import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+
+@RunWith(Parameterized.class)
+public class BindsMethodValidatorTest {
+  @Parameters
+  public static Collection<Object[]> data() {
+    return ImmutableList.copyOf(new Object[][] {{Module.class}, {ProducerModule.class}});
+  }
+
+  private final Class<? extends Annotation> moduleAnnotation;
+
+  public BindsMethodValidatorTest(Class<? extends Annotation> moduleAnnotation) {
+    this.moduleAnnotation = moduleAnnotation;
+  }
+
+  @Test
+  public void nonAbstract() {
+    JavaFileObject moduleFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Binds;",
+            "",
+            "@" + moduleAnnotation.getCanonicalName(),
+            "abstract class TestModule {",
+            "  @Binds Object bindObject(String impl) { return null; }",
+            "}");
+    assertAbout(javaSource())
+        .that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("must be abstract")
+        .in(moduleFile)
+        .onLine(7);
+  }
+
+  @Test
+  public void notAssignable() {
+    JavaFileObject moduleFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Binds;",
+            "",
+            "@" + moduleAnnotation.getCanonicalName(),
+            "abstract class TestModule {",
+            "  @Binds abstract String bindString(Object impl);",
+            "}");
+    assertAbout(javaSource())
+        .that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("assignable")
+        .in(moduleFile)
+        .onLine(7);
+  }
+
+  @Test
+  public void moreThanOneParamter() {
+    JavaFileObject moduleFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Binds;",
+            "",
+            "@" + moduleAnnotation.getCanonicalName(),
+            "abstract class TestModule {",
+            "  @Binds abstract Object bindObject(String s1, String s2);",
+            "}");
+    assertAbout(javaSource())
+        .that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("one parameter")
+        .in(moduleFile)
+        .onLine(7);
+  }
+
+  @Test
+  public void typeParameters() {
+    JavaFileObject moduleFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Binds;",
+            "",
+            "@" + moduleAnnotation.getCanonicalName(),
+            "abstract class TestModule {",
+            "  @Binds abstract <S, T extends S> S bindS(T t);",
+            "}");
+    assertAbout(javaSource())
+        .that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("type parameters")
+        .in(moduleFile)
+        .onLine(7);
+  }
+
+  @Test
+  public void notInModule() {
+    JavaFileObject moduleFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Binds;",
+            "",
+            "abstract class TestModule {",
+            "  @Binds abstract Object bindObject(String s);",
+            "}");
+    assertAbout(javaSource())
+        .that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("within a @Module or @ProducerModule")
+        .in(moduleFile)
+        .onLine(6);
+  }
+
+  @Test
+  public void throwsException() {
+    JavaFileObject moduleFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Binds;",
+            "import java.io.IOException;",
+            "",
+            "@" + moduleAnnotation.getCanonicalName(),
+            "abstract class TestModule {",
+            "  @Binds abstract Object bindObject(String s1) throws IOException;",
+            "}");
+    assertAbout(javaSource())
+        .that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("only throw unchecked")
+        .in(moduleFile)
+        .onLine(8);
+  }
+}
diff --git a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
index 59b1b4a8c..3e0d2b003 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
@@ -46,7 +46,6 @@
 import static com.google.common.truth.Truth.assertAbout;
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
-import static dagger.internal.codegen.ErrorMessages.REFERENCED_MODULES_MUST_NOT_BE_ABSTRACT;
 import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
 import static javax.tools.StandardLocation.SOURCE_OUTPUT;
 
@@ -113,36 +112,6 @@
         .withErrorContaining("is not annotated with @Module");
   }
 
-  private void checkCannotReferToModuleOfType(String moduleType) {
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import dagger.Module;",
-        "",
-        "@Module",
-        moduleType + " TestModule {}");
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.BadComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "",
-        "@Component(modules = TestModule.class)",
-        "interface BadComponent {}");
-    assertAbout(javaSources()).that(ImmutableList.of(moduleFile, componentFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
-            String.format(REFERENCED_MODULES_MUST_NOT_BE_ABSTRACT, "test.TestModule"));
-  }
-
-  @Test public void cannotReferToAbstractClassModules() {
-    checkCannotReferToModuleOfType("abstract class");
-  }
-
-  @Test public void cannotReferToInterfaceModules() {
-    checkCannotReferToModuleOfType("interface");
-  }
-
   @Test public void doubleBindingFromResolvedModules() {
     JavaFileObject parent = JavaFileObjects.forSourceLines("test.ParentModule",
         "package test;",
@@ -793,18 +762,17 @@ public void subcomponentOmitsInheritedBindings() {
             "",
             "import dagger.Module;",
             "import dagger.Provides;",
+            "import dagger.multibindings.IntoSet;",
+            "import dagger.multibindings.IntoMap;",
             "import dagger.multibindings.StringKey;",
             "",
-            "import static dagger.Provides.Type.SET;",
-            "import static dagger.Provides.Type.MAP;",
-            "",
             "@Module",
             "class ParentModule {",
-            "  @Provides(type = SET) static Object parentObject() {",
+            "  @Provides @IntoSet static Object parentObject() {",
             "    return \"parent object\";",
             "  }",
             "",
-            "  @Provides(type = MAP) @StringKey(\"parent key\") Object parentKeyObject() {",
+            "  @Provides @IntoMap @StringKey(\"parent key\") Object parentKeyObject() {",
             "    return \"parent value\";",
             "  }",
             "}");
@@ -961,24 +929,24 @@ public void subcomponentOmitsInheritedBindings() {
         "",
         "import dagger.Module;",
         "import dagger.Provides;",
+        "import dagger.multibindings.ElementsIntoSet;",
         "import java.util.Collections;",
         "import java.util.Set;",
         "",
         "@Module",
         "final class EmptySetModule {",
-        "  @Provides(type = SET_VALUES) Set<String> emptySet() { return Collections.emptySet(); }",
+        "  @Provides @ElementsIntoSet Set<String> emptySet() { return Collections.emptySet(); }",
         "}");
     JavaFileObject setModuleFile = JavaFileObjects.forSourceLines("test.SetModule",
         "package test;",
         "",
-        "import static dagger.Provides.Type.SET;",
-        "",
         "import dagger.Module;",
         "import dagger.Provides;",
+        "import dagger.multibindings.IntoSet;",
         "",
         "@Module",
         "final class SetModule {",
-        "  @Provides(type = SET) String string() { return \"\"; }",
+        "  @Provides @IntoSet String string() { return \"\"; }",
         "}");
     JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
         "package test;",
@@ -2234,6 +2202,36 @@ public boolean apply(Element element) {
         .withNoteCount(3);
   }
 
+  @Test
+  public void scopeAnnotationOnInjectConstructorNotValid() {
+    JavaFileObject aScope =
+        JavaFileObjects.forSourceLines(
+            "test.AScope",
+            "package test;",
+            "",
+            "import javax.inject.Scope;",
+            "",
+            "@Scope",
+            "@interface AScope {}");
+    JavaFileObject aClass =
+        JavaFileObjects.forSourceLines(
+            "test.AClass",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "final class AClass {",
+            "  @Inject @AScope AClass() {}",
+            "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(aScope, aClass))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("@Scope annotations are not allowed on @Inject constructors.")
+        .in(aClass)
+        .onLine(6);
+  }
+
   /**
    * A {@link ComponentProcessor} that excludes elements using a {@link Predicate}.
    */
diff --git a/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java b/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
index ce284d511..0362ef195 100644
--- a/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
@@ -160,6 +160,48 @@
         .withErrorContaining(expectedError).in(component).onLine(19);
   }
 
+  @Test
+  public void membersInjectDependsOnUnboundedType() {
+    JavaFileObject injectsUnboundedType =
+        JavaFileObjects.forSourceLines(
+            "test.InjectsUnboundedType",
+            "package test;",
+            "",
+            "import dagger.MembersInjector;",
+            "import java.util.ArrayList;",
+            "import javax.inject.Inject;",
+            "",
+            "class InjectsUnboundedType {",
+            "  @Inject MembersInjector<ArrayList<?>> listInjector;",
+            "}");
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface TestComponent {",
+            "  void injectsUnboundedType(InjectsUnboundedType injects);",
+            "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(injectsUnboundedType, component))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            Joiner.on('\n')
+                .join(
+                    "Type parameters must be bounded for members injection."
+                        + " ? required by java.util.ArrayList<?>, via:",
+                    "      dagger.MembersInjector<java.util.ArrayList<?>> is injected at",
+                    "          test.InjectsUnboundedType.listInjector",
+                    "      test.InjectsUnboundedType is injected at",
+                    "          test.TestComponent.injectsUnboundedType(injects)"))
+        .in(component)
+        .onLine(7);
+  }
+
   @Test public void cyclicDependency() {
     JavaFileObject component = JavaFileObjects.forSourceLines("test.Outer",
         "package test;",
@@ -192,12 +234,14 @@
         Joiner.on('\n')
             .join(
                 "test.Outer.CComponent.getC() contains a dependency cycle:",
-                "      test.Outer.C.<init>(bParam)",
-                "          injects test.Outer.B",
-                "      test.Outer.B.<init>(aParam)",
-                "          injects test.Outer.A",
-                "      test.Outer.A.<init>(cParam)",
-                "          injects test.Outer.C");
+                "      test.Outer.C is injected at",
+                "          test.Outer.A.<init>(cParam)",
+                "      test.Outer.A is injected at",
+                "          test.Outer.B.<init>(aParam)",
+                "      test.Outer.B is injected at",
+                "          test.Outer.C.<init>(bParam)",
+                "      test.Outer.C is provided at",
+                "          test.Outer.CComponent.getC()");
 
     assertAbout(javaSource()).that(component)
         .processedWith(new ComponentProcessor())
@@ -243,14 +287,16 @@
         Joiner.on('\n')
             .join(
                 "test.Outer.DComponent.getD() contains a dependency cycle:",
-                "      test.Outer.D.<init>(cParam)",
-                "          injects test.Outer.C",
-                "      test.Outer.C.<init>(bParam)",
-                "          injects test.Outer.B",
-                "      test.Outer.B.<init>(aParam)",
-                "          injects test.Outer.A",
-                "      test.Outer.A.<init>(cParam)",
-                "          injects test.Outer.C");
+                "      test.Outer.C is injected at",
+                "          test.Outer.A.<init>(cParam)",
+                "      test.Outer.A is injected at",
+                "          test.Outer.B.<init>(aParam)",
+                "      test.Outer.B is injected at",
+                "          test.Outer.C.<init>(bParam)",
+                "      test.Outer.C is injected at",
+                "          test.Outer.D.<init>(cParam)",
+                "      test.Outer.D is provided at",
+                "          test.Outer.DComponent.getD()");
 
     assertAbout(javaSource())
         .that(component)
@@ -272,6 +318,7 @@ public void cyclicDependencyNotBrokenByMapBinding() {
             "import dagger.MapKey;",
             "import dagger.Module;",
             "import dagger.Provides;",
+            "import dagger.multibindings.IntoMap;",
             "import java.util.Map;",
             "import javax.inject.Inject;",
             "",
@@ -295,7 +342,7 @@ public void cyclicDependencyNotBrokenByMapBinding() {
             "",
             "  @Module",
             "  static class CModule {",
-            "    @Provides(type = Provides.Type.MAP)",
+            "    @Provides @IntoMap",
             "    @StringKey(\"C\")",
             "    static C c(C c) {",
             "      return c;",
@@ -312,14 +359,16 @@ public void cyclicDependencyNotBrokenByMapBinding() {
         Joiner.on('\n')
             .join(
                 "test.Outer.CComponent.getC() contains a dependency cycle:",
-                "      test.Outer.C.<init>(bParam)",
-                "          injects test.Outer.B",
-                "      test.Outer.B.<init>(aParam)",
-                "          injects test.Outer.A",
-                "      test.Outer.A.<init>(cMap)",
-                "          injects java.util.Map<java.lang.String,test.Outer.C>",
-                "      test.Outer.CModule.c(c)",
-                "          injects test.Outer.C");
+                "      test.Outer.C is injected at",
+                "          test.Outer.CModule.c(c)",
+                "      java.util.Map<java.lang.String,test.Outer.C> is injected at",
+                "          test.Outer.A.<init>(cMap)",
+                "      test.Outer.A is injected at",
+                "          test.Outer.B.<init>(aParam)",
+                "      test.Outer.B is injected at",
+                "          test.Outer.C.<init>(bParam)",
+                "      test.Outer.C is provided at",
+                "          test.Outer.CComponent.getC()");
 
     assertAbout(javaSource())
         .that(component)
@@ -327,7 +376,7 @@ public void cyclicDependencyNotBrokenByMapBinding() {
         .failsToCompile()
         .withErrorContaining(expectedError)
         .in(component)
-        .onLine(25);
+        .onLine(26);
   }
 
   @Test
@@ -340,6 +389,7 @@ public void cyclicDependencyWithSetBinding() {
             "import dagger.Component;",
             "import dagger.Module;",
             "import dagger.Provides;",
+            "import dagger.multibindings.IntoSet;",
             "import java.util.Set;",
             "import javax.inject.Inject;",
             "",
@@ -363,7 +413,7 @@ public void cyclicDependencyWithSetBinding() {
             "",
             "  @Module",
             "  static class CModule {",
-            "    @Provides(type = Provides.Type.SET)",
+            "    @Provides @IntoSet",
             "    static C c(C c) {",
             "      return c;",
             "    }",
@@ -374,15 +424,16 @@ public void cyclicDependencyWithSetBinding() {
         Joiner.on('\n')
             .join(
                 "test.Outer.CComponent.getC() contains a dependency cycle:",
-                "      test.Outer.C.<init>(bParam)",
-                "          injects test.Outer.B",
-                "      test.Outer.B.<init>(aParam)",
-                "          injects test.Outer.A",
-                "      test.Outer.A.<init>(cSet)",
-                "          injects java.util.Set<test.Outer.C>",
-                "      test.Outer.CModule.c(c)",
-                "          injects test.Outer.C"
-                );
+                "      test.Outer.C is injected at",
+                "          test.Outer.CModule.c(c)",
+                "      java.util.Set<test.Outer.C> is injected at",
+                "          test.Outer.A.<init>(cSet)",
+                "      test.Outer.A is injected at",
+                "          test.Outer.B.<init>(aParam)",
+                "      test.Outer.B is injected at",
+                "          test.Outer.C.<init>(bParam)",
+                "      test.Outer.C is provided at",
+                "          test.Outer.CComponent.getC()");
 
     assertAbout(javaSource())
         .that(component)
@@ -390,7 +441,7 @@ public void cyclicDependencyWithSetBinding() {
         .failsToCompile()
         .withErrorContaining(expectedError)
         .in(component)
-        .onLine(24);
+        .onLine(25);
   }
 
   @Test
@@ -433,14 +484,16 @@ public void falsePositiveCyclicDependencyIndirectionDetected() {
         Joiner.on('\n')
             .join(
                 "test.Outer.DComponent.getD() contains a dependency cycle:",
-                "      test.Outer.D.<init>(cParam)",
-                "          injects javax.inject.Provider<test.Outer.C>",
-                "      test.Outer.C.<init>(bParam)",
-                "          injects test.Outer.B",
-                "      test.Outer.B.<init>(aParam)",
-                "          injects test.Outer.A",
-                "      test.Outer.A.<init>(cParam)",
-                "          injects test.Outer.C");
+                "      test.Outer.C is injected at",
+                "          test.Outer.A.<init>(cParam)",
+                "      test.Outer.A is injected at",
+                "          test.Outer.B.<init>(aParam)",
+                "      test.Outer.B is injected at",
+                "          test.Outer.C.<init>(bParam)",
+                "      javax.inject.Provider<test.Outer.C> is injected at",
+                "          test.Outer.D.<init>(cParam)",
+                "      test.Outer.D is provided at",
+                "          test.Outer.DComponent.getD()");
 
     assertAbout(javaSource())
         .that(component)
@@ -544,15 +597,14 @@ public void falsePositiveCyclicDependencyIndirectionDetected() {
         "import dagger.Module;",
         "import dagger.Provides;",
         "import dagger.MapKey;",
+        "import dagger.multibindings.IntoMap;",
+        "import dagger.multibindings.IntoSet;",
         "import java.util.HashMap;",
         "import java.util.HashSet;",
         "import java.util.Map;",
         "import java.util.Set;",
         "",
         "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
-        "import static dagger.Provides.Type.MAP;",
-        "import static dagger.Provides.Type.SET;",
-        "",
         "final class Outer {",
         "  @MapKey(unwrapValue = true)",
         "  @interface StringKey {",
@@ -561,11 +613,11 @@ public void falsePositiveCyclicDependencyIndirectionDetected() {
         "",
         "  @Module",
         "  static class TestModule1 {",
-        "    @Provides(type = MAP)",
+        "    @Provides @IntoMap",
         "    @StringKey(\"foo\")",
         "    String stringMapEntry() { return \"\"; }",
         "",
-        "    @Provides(type = SET) String stringSetElement() { return \"\"; }",
+        "    @Provides @IntoSet String stringSetElement() { return \"\"; }",
         "  }",
         "",
         "  @Module",
@@ -587,7 +639,8 @@ public void falsePositiveCyclicDependencyIndirectionDetected() {
     String expectedSetError =
         "java.util.Set<java.lang.String> has incompatible bindings or declarations:\n"
             + "      Set bindings and declarations:\n"
-            + "          @Provides(type=SET) String test.Outer.TestModule1.stringSetElement()\n"
+            + "          @Provides @dagger.multibindings.IntoSet String "
+            + "test.Outer.TestModule1.stringSetElement()\n"
             + "      Unique bindings and declarations:\n"
             + "          @Provides Set<String> test.Outer.TestModule2.stringSet()";
 
@@ -595,7 +648,8 @@ public void falsePositiveCyclicDependencyIndirectionDetected() {
         "java.util.Map<java.lang.String,java.lang.String> has incompatible bindings "
             + "or declarations:\n"
             + "      Map bindings and declarations:\n"
-            + "          @Provides(type=MAP) @test.Outer.StringKey(\"foo\") String"
+            + "          @Provides @dagger.multibindings.IntoMap "
+            + "@test.Outer.StringKey(\"foo\") String"
             + " test.Outer.TestModule1.stringMapEntry()\n"
             + "      Unique bindings and declarations:\n"
             + "          @Provides Map<String,String> test.Outer.TestModule2.stringMap()";
@@ -606,11 +660,11 @@ public void falsePositiveCyclicDependencyIndirectionDetected() {
         .failsToCompile()
         .withErrorContaining(expectedSetError)
         .in(component)
-        .onLine(43)
+        .onLine(42)
         .and()
         .withErrorContaining(expectedMapError)
         .in(component)
-        .onLine(44);
+        .onLine(43);
   }
 
   @Test
@@ -630,8 +684,6 @@ public void duplicateExplicitBindings_UniqueBindingAndMultibindingDeclaration()
             "import java.util.Set;",
             "",
             "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
-            "import static dagger.Provides.Type.MAP;",
-            "import static dagger.Provides.Type.SET;",
             "",
             "final class Outer {",
             "  @Module",
@@ -680,11 +732,11 @@ public void duplicateExplicitBindings_UniqueBindingAndMultibindingDeclaration()
         .failsToCompile()
         .withErrorContaining(expectedSetError)
         .in(component)
-        .onLine(37)
+        .onLine(35)
         .and()
         .withErrorContaining(expectedMapError)
         .in(component)
-        .onLine(38);
+        .onLine(36);
   }
   
   @Test public void duplicateBindings_TruncateAfterLimit() {
@@ -847,26 +899,26 @@ public void duplicateExplicitBindings_UniqueBindingAndMultibindingDeclaration()
         Joiner.on('\n')
             .join(
                 errorText,
-                "      test.TestClass.B.<init>(a)",
-                "          injects test.TestClass.A",
-                "      test.TestClass.C.b",
-                "          injects test.TestClass.B",
-                "      test.TestClass.DImpl.<init>(c, …)",
-                "          injects test.TestClass.C",
-                "      test.TestClass.DModule.d(…, impl, …)",
-                "          injects test.TestClass.DImpl",
-                "      test.TestClass.AComponent.getFoo()",
-                "          provides @javax.inject.Named(\"slim shady\") test.TestClass.D");
+                "      test.TestClass.A is injected at",
+                "          test.TestClass.B.<init>(a)",
+                "      test.TestClass.B is injected at",
+                "          test.TestClass.C.b",
+                "      test.TestClass.C is injected at",
+                "          test.TestClass.DImpl.<init>(c, …)",
+                "      test.TestClass.DImpl is injected at",
+                "          test.TestClass.DModule.d(…, impl, …)",
+                "      @javax.inject.Named(\"slim shady\") test.TestClass.D is provided at",
+                "          test.TestClass.AComponent.getFoo()");
     String secondError =
         Joiner.on('\n')
             .join(
                 errorText,
-                "      test.TestClass.B.<init>(a)",
-                "          injects test.TestClass.A",
-                "      test.TestClass.C.b",
-                "          injects test.TestClass.B",
-                "      test.TestClass.AComponent.injectC(c)",
-                "          injects test.TestClass.C");
+                "      test.TestClass.A is injected at",
+                "          test.TestClass.B.<init>(a)",
+                "      test.TestClass.B is injected at",
+                "          test.TestClass.C.b",
+                "      test.TestClass.C is injected at",
+                "          test.TestClass.AComponent.injectC(c)");
     assertAbout(javaSource())
         .that(component)
         .processedWith(new ComponentProcessor())
@@ -920,14 +972,14 @@ public void duplicateExplicitBindings_UniqueBindingAndMultibindingDeclaration()
         Joiner.on("\n")
             .join(
                 "java.util.List cannot be provided without an @Provides-annotated method.",
-                "      test.TestClass.<init>(list)",
-                "          injects java.util.List",
-                "      test.Generic.<init>(t)",
-                "          injects test.TestClass",
-                "      test.UsesTest.<init>(genericTestClass)",
-                "          injects test.Generic<test.TestClass>",
-                "      test.TestComponent.usesTest()",
-                "          provides test.UsesTest");
+                "      java.util.List is injected at",
+                "          test.TestClass.<init>(list)",
+                "      test.TestClass is injected at",
+                "          test.Generic.<init>(t)",
+                "      test.Generic<test.TestClass> is injected at",
+                "          test.UsesTest.<init>(genericTestClass)",
+                "      test.UsesTest is provided at",
+                "          test.TestComponent.usesTest()");
     assertAbout(javaSources()).that(ImmutableList.of(generic, testClass, usesTest, component))
         .processedWith(new ComponentProcessor())
         .failsToCompile()
@@ -975,14 +1027,14 @@ public void duplicateExplicitBindings_UniqueBindingAndMultibindingDeclaration()
         Joiner.on("\n")
             .join(
                 "java.util.List cannot be provided without an @Provides-annotated method.",
-                "      test.TestClass.<init>(list)",
-                "          injects java.util.List",
-                "      test.Generic.t",
-                "          injects test.TestClass",
-                "      test.UsesTest.<init>(genericTestClass)",
-                "          injects test.Generic<test.TestClass>",
-                "      test.TestComponent.usesTest()",
-                "          provides test.UsesTest");
+                "      java.util.List is injected at",
+                "          test.TestClass.<init>(list)",
+                "      test.TestClass is injected at",
+                "          test.Generic.t",
+                "      test.Generic<test.TestClass> is injected at",
+                "          test.UsesTest.<init>(genericTestClass)",
+                "      test.UsesTest is provided at",
+                "          test.TestComponent.usesTest()");
     assertAbout(javaSources()).that(ImmutableList.of(generic, testClass, usesTest, component))
         .processedWith(new ComponentProcessor())
         .failsToCompile()
diff --git a/compiler/src/test/java/dagger/internal/codegen/KeyTest.java b/compiler/src/test/java/dagger/internal/codegen/KeyTest.java
index 0a5814765..8635fc713 100644
--- a/compiler/src/test/java/dagger/internal/codegen/KeyTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/KeyTest.java
@@ -23,6 +23,8 @@
 import com.google.testing.compile.CompilationRule;
 import dagger.Module;
 import dagger.Provides;
+import dagger.multibindings.IntoSet;
+import dagger.multibindings.ElementsIntoSet;
 import dagger.producers.ProducerModule;
 import dagger.producers.Produces;
 import java.util.Set;
@@ -43,8 +45,6 @@
 import org.junit.runners.JUnit4;
 
 import static com.google.common.truth.Truth.assertThat;
-import static dagger.Provides.Type.SET;
-import static dagger.Provides.Type.SET_VALUES;
 
 /**
  * Tests {@link Key}.
@@ -178,11 +178,11 @@ String provideQualifiedString() {
 
   @Module
   static final class SetProvidesMethodsModule {
-    @Provides(type = SET) String provideString() {
+    @Provides @IntoSet String provideString() {
       throw new UnsupportedOperationException();
     }
 
-    @Provides(type = SET_VALUES) Set<String> provideStrings() {
+    @Provides @ElementsIntoSet Set<String> provideStrings() {
       throw new UnsupportedOperationException();
     }
   }
@@ -270,19 +270,19 @@ String provideQualifiedString() {
 
   @ProducerModule
   static final class SetProducesMethodsModule {
-    @Produces(type = Produces.Type.SET) String produceString() {
+    @Produces @IntoSet String produceString() {
       throw new UnsupportedOperationException();
     }
 
-    @Produces(type = Produces.Type.SET) ListenableFuture<String> produceFutureString() {
+    @Produces @IntoSet ListenableFuture<String> produceFutureString() {
       throw new UnsupportedOperationException();
     }
 
-    @Produces(type = Produces.Type.SET_VALUES) Set<String> produceStrings() {
+    @Produces @ElementsIntoSet Set<String> produceStrings() {
       throw new UnsupportedOperationException();
     }
 
-    @Produces(type = Produces.Type.SET_VALUES)
+    @Produces @ElementsIntoSet
     ListenableFuture<Set<String>> produceFutureStrings() {
       throw new UnsupportedOperationException();
     }
diff --git a/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java
index a295f5098..df33d2a87 100644
--- a/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java
@@ -37,14 +37,13 @@ public void mapBindingsWithEnumKey() {
             .forSourceLines("test.MapModuleOne",
                 "package test;",
                 "",
-                "import static dagger.Provides.Type.MAP;",
-                "",
                 "import dagger.Module;",
                 "import dagger.Provides;",
+                "import dagger.multibindings.IntoMap;",
                 "",
                 "@Module",
                 "final class MapModuleOne {",
-                "  @Provides(type = MAP) @PathKey(PathEnum.ADMIN) Handler provideAdminHandler() {",
+                "  @Provides @IntoMap @PathKey(PathEnum.ADMIN) Handler provideAdminHandler() {",
                 "    return new AdminHandler();",
                 "  }",
                 "}");
@@ -53,14 +52,13 @@ public void mapBindingsWithEnumKey() {
             .forSourceLines("test.MapModuleTwo",
                 "package test;",
                 "",
-                "import static dagger.Provides.Type.MAP;",
-                "",
                 "import dagger.Module;",
                 "import dagger.Provides;",
+                "import dagger.multibindings.IntoMap;",
                 "",
                 "@Module",
                 "final class MapModuleTwo {",
-                "  @Provides(type = MAP) @PathKey(PathEnum.LOGIN) Handler provideLoginHandler() {",
+                "  @Provides @IntoMap @PathKey(PathEnum.LOGIN) Handler provideLoginHandler() {",
                 "    return new LoginHandler();",
                 "  }",
                 "}");
@@ -209,15 +207,14 @@ public void mapBindingsWithStringKey() {
             .forSourceLines("test.MapModuleOne",
                 "package test;",
                 "",
-                "import static dagger.Provides.Type.MAP;",
-                "",
                 "import dagger.Module;",
                 "import dagger.Provides;",
                 "import dagger.multibindings.StringKey;",
+                "import dagger.multibindings.IntoMap;",
                 "",
                 "@Module",
                 "final class MapModuleOne {",
-                "  @Provides(type = MAP) @StringKey(\"Admin\") Handler provideAdminHandler() {",
+                "  @Provides @IntoMap @StringKey(\"Admin\") Handler provideAdminHandler() {",
                 "    return new AdminHandler();",
                 "  }",
                 "}");
@@ -226,15 +223,14 @@ public void mapBindingsWithStringKey() {
             .forSourceLines("test.MapModuleTwo",
                 "package test;",
                 "",
-                "import static dagger.Provides.Type.MAP;",
-                "",
                 "import dagger.Module;",
                 "import dagger.Provides;",
+                "import dagger.multibindings.IntoMap;",
                 "import dagger.multibindings.StringKey;",
                 "",
                 "@Module",
                 "final class MapModuleTwo {",
-                "  @Provides(type = MAP) @StringKey(\"Login\") Handler provideLoginHandler() {",
+                "  @Provides @IntoMap @StringKey(\"Login\") Handler provideLoginHandler() {",
                 "    return new LoginHandler();",
                 "  }",
                 "}");
@@ -362,14 +358,13 @@ public void mapBindingsWithWrappedKey() {
             .forSourceLines("test.MapModuleOne",
                 "package test;",
                 "",
-                "import static dagger.Provides.Type.MAP;",
-                "",
                 "import dagger.Module;",
                 "import dagger.Provides;",
+                "import dagger.multibindings.IntoMap;",
                 "",
                 "@Module",
                 "final class MapModuleOne {",
-                "  @Provides(type = MAP)",
+                "  @Provides @IntoMap",
                 "  @WrappedClassKey(Integer.class) Handler provideAdminHandler() {",
                 "    return new AdminHandler();",
                 "  }",
@@ -379,14 +374,13 @@ public void mapBindingsWithWrappedKey() {
             .forSourceLines("test.MapModuleTwo",
                 "package test;",
                 "",
-                "import static dagger.Provides.Type.MAP;",
-                "",
                 "import dagger.Module;",
                 "import dagger.Provides;",
+                "import dagger.multibindings.IntoMap;",
                 "",
                 "@Module",
                 "final class MapModuleTwo {",
-                "  @Provides(type = MAP)",
+                "  @Provides @IntoMap",
                 "  @WrappedClassKey(Long.class) Handler provideLoginHandler() {",
                 "    return new LoginHandler();",
                 "  }",
@@ -527,28 +521,26 @@ public void mapBindingsWithNonProviderValue() {
     JavaFileObject mapModuleOneFile = JavaFileObjects.forSourceLines("test.MapModuleOne",
         "package test;",
         "",
-        "import static dagger.Provides.Type.MAP;",
-        "",
         "import dagger.Module;",
         "import dagger.Provides;",
+        "import dagger.multibindings.IntoMap;",
         "",
         "@Module",
         "final class MapModuleOne {",
-        "  @Provides(type = MAP) @PathKey(PathEnum.ADMIN) Handler provideAdminHandler() {",
+        "  @Provides @IntoMap @PathKey(PathEnum.ADMIN) Handler provideAdminHandler() {",
         "    return new AdminHandler();",
         "  }",
         "}");
     JavaFileObject mapModuleTwoFile = JavaFileObjects.forSourceLines("test.MapModuleTwo",
         "package test;",
         "",
-        "import static dagger.Provides.Type.MAP;",
-        "",
         "import dagger.Module;",
         "import dagger.Provides;",
+        "import dagger.multibindings.IntoMap;",
         "",
         "@Module",
         "final class MapModuleTwo {",
-        "  @Provides(type = MAP) @PathKey(PathEnum.LOGIN) Handler provideLoginHandler() {",
+        "  @Provides @IntoMap @PathKey(PathEnum.LOGIN) Handler provideLoginHandler() {",
         "    return new LoginHandler();",
         "  }",
         "}");
@@ -789,16 +781,15 @@ public void mapBindingsWithDuplicateKeys() {
             "import dagger.Module;",
             "import dagger.Provides;",
             "import dagger.multibindings.StringKey;",
-            "",
-            "import static dagger.Provides.Type.MAP;",
+            "import dagger.multibindings.IntoMap;",
             "",
             "@Module",
             "final class MapModule {",
-            "  @Provides(type = MAP) @StringKey(\"AKey\") Object provideObjectForAKey() {",
+            "  @Provides @IntoMap @StringKey(\"AKey\") Object provideObjectForAKey() {",
             "    return \"one\";",
             "  }",
             "",
-            "  @Provides(type = MAP) @StringKey(\"AKey\") Object provideObjectForAKeyAgain() {",
+            "  @Provides @IntoMap @StringKey(\"AKey\") Object provideObjectForAKeyAgain() {",
             "    return \"one again\";",
             "  }",
             "}");
@@ -838,16 +829,15 @@ public void mapBindingsWithInconsistentKeyAnnotations() {
             "import dagger.Module;",
             "import dagger.Provides;",
             "import dagger.multibindings.StringKey;",
-            "",
-            "import static dagger.Provides.Type.MAP;",
+            "import dagger.multibindings.IntoMap;",
             "",
             "@Module",
             "final class MapModule {",
-            "  @Provides(type = MAP) @StringKey(\"AKey\") Object provideObjectForAKey() {",
+            "  @Provides @IntoMap @StringKey(\"AKey\") Object provideObjectForAKey() {",
             "    return \"one\";",
             "  }",
             "",
-            "  @Provides(type = MAP) @StringKeyTwo(\"BKey\") Object provideObjectForBKey() {",
+            "  @Provides @IntoMap @StringKeyTwo(\"BKey\") Object provideObjectForBKey() {",
             "    return \"two\";",
             "  }",
             "}");
diff --git a/compiler/src/test/java/dagger/internal/codegen/MapKeyProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/MapKeyProcessorTest.java
index 1fbd7fd11..bd1cc483f 100644
--- a/compiler/src/test/java/dagger/internal/codegen/MapKeyProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/MapKeyProcessorTest.java
@@ -130,15 +130,16 @@ public void mapKeyComponentFileWithDisorderedKeyField() {
     JavaFileObject mapModuleOneFile = JavaFileObjects.forSourceLines("test.MapModuleOne",
         "package test;",
         "",
-        "import static dagger.Provides.Type.MAP;",
-        "",
         "import dagger.Module;",
         "import dagger.Provides;",
+        "import dagger.multibindings.IntoMap;",
         "",
         "@Module",
         "final class MapModuleOne {",
-        "  @Provides(type = MAP) @PathKey(relativePath = \"AdminPath\", value = PathEnum.ADMIN)",
-        "      Handler provideAdminHandler() {",
+        "  @Provides",
+        "  @IntoMap",
+        "  @PathKey(relativePath = \"AdminPath\", value = PathEnum.ADMIN)",
+        "  Handler provideAdminHandler() {",
         "    return new AdminHandler();",
         "  }",
         "}");
@@ -149,11 +150,14 @@ public void mapKeyComponentFileWithDisorderedKeyField() {
         "",
         "import dagger.Module;",
         "import dagger.Provides;",
+        "import dagger.multibindings.IntoMap;",
         "",
         "@Module",
         "final class MapModuleTwo {",
-        "  @Provides(type = MAP) @PathKey(value = PathEnum.LOGIN, relativePath = \"LoginPath\")",
-        "      Handler provideLoginHandler() {",
+        "  @Provides",
+        "  @IntoMap",
+        "  @PathKey(value = PathEnum.LOGIN, relativePath = \"LoginPath\")",
+        "  Handler provideLoginHandler() {",
         "    return new LoginHandler();",
         "  }",
         "}");
@@ -304,29 +308,31 @@ public void mapKeyComponentFileWithDefaultField() {
     JavaFileObject mapModuleOneFile = JavaFileObjects.forSourceLines("test.MapModuleOne",
         "package test;",
         "",
-        "import static dagger.Provides.Type.MAP;",
-        "",
         "import dagger.Module;",
         "import dagger.Provides;",
+        "import dagger.multibindings.IntoMap;",
         "",
         "@Module",
         "final class MapModuleOne {",
-        "  @Provides(type = MAP) @PathKey(value = PathEnum.ADMIN) Handler provideAdminHandler() {",
+        "  @Provides",
+        "  @IntoMap",
+        "  @PathKey(value = PathEnum.ADMIN) Handler provideAdminHandler() {",
         "    return new AdminHandler();",
         "  }",
         "}");
     JavaFileObject mapModuleTwoFile =JavaFileObjects.forSourceLines("test.MapModuleTwo",
         "package test;",
         "",
-        "import static dagger.Provides.Type.MAP;",
-        "",
         "import dagger.Module;",
         "import dagger.Provides;",
+        "import dagger.multibindings.IntoMap;",
         "",
         "@Module",
         "final class MapModuleTwo {",
-        "  @Provides(type = MAP) @PathKey(value = PathEnum.LOGIN, relativePath = \"LoginPath\")",
-        "      Handler provideLoginHandler() {",
+        "  @Provides",
+        "  @IntoMap",
+        "  @PathKey(value = PathEnum.LOGIN, relativePath = \"LoginPath\")",
+        "  Handler provideLoginHandler() {",
         "    return new LoginHandler();",
         "  }",
         "}");
diff --git a/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java b/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
index 63c5821e5..acc6bb6e4 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
@@ -16,6 +16,7 @@
 package dagger.internal.codegen;
 
 import com.google.common.collect.ImmutableList;
+import com.google.testing.compile.CompileTester;
 import com.google.testing.compile.JavaFileObjects;
 import com.squareup.javapoet.CodeBlock;
 import javax.tools.JavaFileObject;
@@ -25,19 +26,21 @@
 
 import static com.google.common.truth.Truth.assertAbout;
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+import static com.google.testing.compile.JavaSourcesSubject.assertThat;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_ABSTRACT;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_MULTIPLE_QUALIFIERS;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_MUST_RETURN_A_VALUE;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_NOT_IN_MODULE;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_PRIVATE;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_RETURN_TYPE;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_SET_VALUES_RAW_SET;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_THROWS_CHECKED;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_TYPE_PARAMETER;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_WITH_SAME_NAME;
 import static dagger.internal.codegen.ErrorMessages.MODULES_WITH_TYPE_PARAMS_MUST_BE_ABSTRACT;
-import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_RETURN_TYPE;
 import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_SET_VALUES_RETURN_SET;
-import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_THROWS;
-import static dagger.internal.codegen.ErrorMessages.PROVIDES_OR_PRODUCES_METHOD_MULTIPLE_QUALIFIERS;
 import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
 
 @RunWith(JUnit4.class)
@@ -131,6 +134,45 @@ private String formatModuleErrorMessage(String msg) {
         .withErrorContaining(formatErrorMessage(BINDING_METHOD_MUST_RETURN_A_VALUE));
   }
 
+  @Test public void providesMethodFrameworkType() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.Lazy;",
+        "import dagger.MembersInjector;",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import dagger.producers.Producer;",
+        "import dagger.producers.Produced;",
+        "import javax.inject.Provider;",
+        "",
+        "@Module",
+        "final class TestModule {",
+        "  @Provides Provider<String> provideProvider() {}",
+        "  @Provides Lazy<String> provideLazy() {}",
+        "  @Provides MembersInjector<String> provideMembersInjector() {}",
+        "  @Provides Producer<String> provideProducer() {}",
+        "  @Provides Produced<String> provideProduced() {}",
+        "}");
+    assertAbout(javaSource()).that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(formatErrorMessage(BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES))
+        .in(moduleFile).onLine(13)
+        .and()
+        .withErrorContaining(formatErrorMessage(BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES))
+        .in(moduleFile).onLine(14)
+        .and()
+        .withErrorContaining(formatErrorMessage(BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES))
+        .in(moduleFile).onLine(15)
+        .and()
+        .withErrorContaining(formatErrorMessage(BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES))
+        .in(moduleFile).onLine(16)
+        .and()
+        .withErrorContaining(formatErrorMessage(BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES))
+        .in(moduleFile).onLine(17);
+  }
+
   @Test public void providesMethodWithTypeParameter() {
     JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
         "package test;",
@@ -154,39 +196,37 @@ private String formatModuleErrorMessage(String msg) {
     JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
         "package test;",
         "",
-        "import static dagger.Provides.Type.SET_VALUES;",
-        "",
         "import dagger.Module;",
         "import dagger.Provides;",
+        "import dagger.multibindings.ElementsIntoSet;",
         "",
         "import java.util.Set;",
         "",
         "@Module",
         "final class TestModule {",
-        "  @Provides(type = SET_VALUES) Set<?> provideWildcard() {",
+        "  @Provides @ElementsIntoSet Set<?> provideWildcard() {",
         "    return null;",
         "  }",
         "}");
     assertAbout(javaSource()).that(moduleFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
-        .withErrorContaining(PROVIDES_METHOD_RETURN_TYPE);
+        .withErrorContaining(String.format(BINDING_METHOD_RETURN_TYPE, "Provides"));
   }
 
   @Test public void providesMethodSetValuesRawSet() {
     JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
         "package test;",
         "",
-        "import static dagger.Provides.Type.SET_VALUES;",
-        "",
         "import dagger.Module;",
         "import dagger.Provides;",
+        "import dagger.multibindings.ElementsIntoSet;",
         "",
         "import java.util.Set;",
         "",
         "@Module",
         "final class TestModule {",
-        "  @Provides(type = SET_VALUES) Set provideSomething() {",
+        "  @Provides @ElementsIntoSet Set provideSomething() {",
         "    return null;",
         "  }",
         "}");
@@ -200,16 +240,15 @@ private String formatModuleErrorMessage(String msg) {
     JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
         "package test;",
         "",
-        "import static dagger.Provides.Type.SET_VALUES;",
-        "",
         "import dagger.Module;",
         "import dagger.Provides;",
+        "import dagger.multibindings.ElementsIntoSet;",
         "",
         "import java.util.List;",
         "",
         "@Module",
         "final class TestModule {",
-        "  @Provides(type = SET_VALUES) List<String> provideStrings() {",
+        "  @Provides @ElementsIntoSet List<String> provideStrings() {",
         "    return null;",
         "  }",
         "}");
@@ -333,28 +372,6 @@ private String formatModuleErrorMessage(String msg) {
                 ErrorMessages.REFERENCED_MODULE_NOT_ANNOTATED, "java.lang.Void", "@Module"));
   }
 
-  @Test public void referencedModulesMustNotBeAbstract() {
-    JavaFileObject module = JavaFileObjects.forSourceLines("test.Parent",
-        "package test;",
-        "",
-        "import dagger.Module;",
-        "",
-        "@Module(includes = AbstractModule.class)",
-        "class TestModule {}");
-    JavaFileObject abstractModule = JavaFileObjects.forSourceLines("test.AbstractModule",
-        "package test;",
-        "",
-        "import dagger.Module;",
-        "",
-        "@Module",
-        "abstract class AbstractModule {}");
-    assertAbout(javaSources()).that(ImmutableList.of(module, abstractModule))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(String.format(ErrorMessages.REFERENCED_MODULES_MUST_NOT_BE_ABSTRACT,
-            "test.AbstractModule"));
-  }
-
   @Test public void singleProvidesMethodNoArgs() {
     JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
         "package test;",
@@ -591,15 +608,14 @@ private String formatModuleErrorMessage(String msg) {
     JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
         "package test;",
         "",
-        "import static dagger.Provides.Type.SET;",
-        "",
         "import java.util.logging.Logger;",
         "import dagger.Module;",
         "import dagger.Provides;",
+        "import dagger.multibindings.IntoSet;",
         "",
         "@Module",
         "final class TestModule {",
-        "  @Provides(type = SET) String provideString() {",
+        "  @Provides @IntoSet String provideString() {",
         "    return \"\";",
         "  }",
         "}");
@@ -638,17 +654,16 @@ private String formatModuleErrorMessage(String msg) {
     JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
         "package test;",
         "",
-        "import static dagger.Provides.Type.SET;",
-        "",
         "import java.util.logging.Logger;",
         "import dagger.Module;",
         "import dagger.Provides;",
+        "import dagger.multibindings.IntoSet;",
         "import java.util.ArrayList;",
         "import java.util.List;",
         "",
         "@Module",
         "final class TestModule {",
-        "  @Provides(type = SET) List<List<?>> provideWildcardList() {",
+        "  @Provides @IntoSet List<List<?>> provideWildcardList() {",
         "    return new ArrayList<>();",
         "  }",
         "}");
@@ -690,15 +705,14 @@ private String formatModuleErrorMessage(String msg) {
     JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
         "package test;",
         "",
-        "import static dagger.Provides.Type.SET_VALUES;",
-        "",
         "import dagger.Module;",
         "import dagger.Provides;",
+        "import dagger.multibindings.ElementsIntoSet;",
         "import java.util.Set;",
         "",
         "@Module",
         "final class TestModule {",
-        "  @Provides(type = SET_VALUES) Set<String> provideStrings() {",
+        "  @Provides @ElementsIntoSet Set<String> provideStrings() {",
         "    return null;",
         "  }",
         "}");
@@ -782,11 +796,11 @@ public void providesMethodThrowsChecked() {
         .that(moduleFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
-        .withErrorContaining(formatErrorMessage(PROVIDES_METHOD_THROWS))
+        .withErrorContaining(formatErrorMessage(BINDING_METHOD_THROWS_CHECKED))
         .in(moduleFile)
         .onLine(8)
         .and()
-        .withErrorContaining(formatErrorMessage(PROVIDES_METHOD_THROWS))
+        .withErrorContaining(formatErrorMessage(BINDING_METHOD_THROWS_CHECKED))
         .in(moduleFile)
         .onLine(12);
   }
@@ -929,13 +943,12 @@ public void genericSubclassedModule() {
             "",
             "import dagger.Module;",
             "import dagger.Provides;",
+            "import dagger.multibindings.IntoSet;",
+            "import dagger.multibindings.IntoMap;",
             "import dagger.multibindings.StringKey;",
             "import java.util.List;",
             "import java.util.ArrayList;",
             "",
-            "import static dagger.Provides.Type.MAP;",
-            "import static dagger.Provides.Type.SET;",
-            "",
             "@Module",
             "abstract class ParentModule<A extends CharSequence,",
             "                            B,",
@@ -946,11 +959,11 @@ public void genericSubclassedModule() {
             "    return list;",
             "  }",
             "",
-            "  @Provides(type = SET) B provideBElement(B b) {",
+            "  @Provides @IntoSet B provideBElement(B b) {",
             "    return b;",
             "  }",
             "",
-            "  @Provides(type = MAP) @StringKey(\"b\") B provideBEntry(B b) {",
+            "  @Provides @IntoMap @StringKey(\"b\") B provideBEntry(B b) {",
             "    return b;",
             "  }",
             "}");
@@ -1258,7 +1271,7 @@ public void genericSubclassedModule() {
     assertAbout(javaSources()).that(ImmutableList.of(moduleFile, QUALIFIER_A, QUALIFIER_B))
         .processedWith(new ComponentProcessor())
         .failsToCompile()
-        .withErrorContaining(PROVIDES_OR_PRODUCES_METHOD_MULTIPLE_QUALIFIERS);
+        .withErrorContaining(BINDING_METHOD_MULTIPLE_QUALIFIERS);
   }
 
   @Test public void providerDependsOnProduced() {
@@ -1300,4 +1313,72 @@ public void genericSubclassedModule() {
         .failsToCompile()
         .withErrorContaining("Produced may only be injected in @Produces methods");
   }
+
+  private static final String BIND_METHOD = "@Binds abstract Foo bindFoo(FooImpl impl);";
+  private static final String STATIC_PROVIDES_METHOD =
+      "@Provides static Bar provideBar() { return new Bar(); }";
+  private static final String INSTANCE_PROVIDES_METHOD =
+      "@Provides Baz provideBaz() { return new Baz(); }";
+  private static final String SOME_ABSTRACT_METHOD = "abstract void blah();";
+
+  @Test
+  public void moduleMethodPermutations() {
+    assertThatMethodCombination(BIND_METHOD, INSTANCE_PROVIDES_METHOD)
+        .failsToCompile()
+        .withErrorContaining("not both at the same time");
+    assertThatMethodCombination(BIND_METHOD, STATIC_PROVIDES_METHOD).compilesWithoutError();
+    assertThatMethodCombination(INSTANCE_PROVIDES_METHOD, SOME_ABSTRACT_METHOD)
+        .compilesWithoutError();
+  }
+
+  private CompileTester assertThatMethodCombination(String... methodLines) {
+    JavaFileObject fooFile =
+        JavaFileObjects.forSourceLines(
+            "test.Foo",
+            "package test;",
+            "",
+            "interface Foo {}");
+    JavaFileObject fooImplFile =
+        JavaFileObjects.forSourceLines(
+            "test.FooImpl",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "final class FooImpl implements Foo {",
+            "  @Inject FooImpl() {}",
+            "}");
+    JavaFileObject barFile =
+        JavaFileObjects.forSourceLines(
+            "test.Bar",
+            "package test;",
+            "",
+            "final class Bar {}");
+    JavaFileObject bazFile =
+        JavaFileObjects.forSourceLines(
+            "test.Baz",
+            "package test;",
+            "",
+            "final class Baz {}");
+
+    ImmutableList<String> moduleLines =
+        new ImmutableList.Builder<String>()
+            .add(
+                "package test;",
+                "",
+                "import dagger.Binds;",
+                "import dagger.Module;",
+                "import dagger.Provides;",
+                "",
+                "@Module abstract class TestModule {")
+            .add(methodLines)
+            .add("}")
+            .build();
+
+    JavaFileObject bindsMethodAndInstanceProvidesMethodModuleFile =
+        JavaFileObjects.forSourceLines("test.TestModule", moduleLines);
+    return assertThat(
+            fooFile, fooImplFile, barFile, bazFile, bindsMethodAndInstanceProvidesMethodModuleFile)
+        .processedWith(new ComponentProcessor());
+  }
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/MultibindingTest.java b/compiler/src/test/java/dagger/internal/codegen/MultibindingTest.java
new file mode 100644
index 000000000..5b2728e88
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/MultibindingTest.java
@@ -0,0 +1,159 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.testing.compile.JavaSourcesSubject.assertThat;
+
+@RunWith(JUnit4.class)
+public class MultibindingTest {
+  @Test
+  public void providesTypeAndAnnotationOnSameMethod_failsToCompile() {
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.MultibindingModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntoSet;",
+            "",
+            "import static dagger.Provides.Type.SET;",
+            "import static dagger.Provides.Type.UNIQUE;",
+            "",
+            "@Module",
+            "class MultibindingModule {",
+            "  @Provides(type = SET) @IntoSet Integer provideInt() { ",
+            "    return 1;",
+            "  }",
+            "  @Provides(type = UNIQUE) @IntoSet Integer provideConflictingMultibindingTypes() { ",
+            "    return 2;",
+            "  }",
+            "}");
+
+    assertThat(module)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("@Provides.type cannot be used with multibinding annotations")
+        .in(module)
+        .onLine(12)
+        .and()
+        .withErrorContaining("@Provides.type cannot be used with multibinding annotations")
+        .in(module)
+        .onLine(15);
+  }
+
+  @Test
+  public void providesWithTwoMultibindingAnnotations_failsToCompile() {
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.MultibindingModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntoSet;",
+            "import dagger.multibindings.IntoMap;",
+            "",
+            "@Module",
+            "class MultibindingModule {",
+            "  @Provides @IntoSet @IntoMap Integer provideInt() { ",
+            "    return 1;",
+            "  }",
+            "}");
+
+    assertThat(module)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            "Multiple multibinding annotations cannot be placed on the same Provides method")
+        .in(module)
+        .onLine(10);
+  }
+
+  @Test
+  public void producesTypeAndAnnotationOnSameMethod_failsToCompile() {
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.MultibindingModule",
+            "package test;",
+            "",
+            "import dagger.producers.ProducerModule;",
+            "import dagger.producers.Produces;",
+            "import dagger.multibindings.IntoSet;",
+            "",
+            "import static dagger.producers.Produces.Type.SET;",
+            "",
+            "@ProducerModule",
+            "class MultibindingModule {",
+            "  @Produces(type = SET) @IntoSet Integer produceInt() { ",
+            "    return 1;",
+            "  }",
+            "}");
+
+    assertThat(module)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("@Produces.type cannot be used with multibinding annotations")
+        .in(module)
+        .onLine(11);
+  }
+
+  @Test
+  public void appliedOnInvalidMethods_failsToCompile() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.SomeType",
+            "package test;",
+            "",
+            "import java.util.Set;",
+            "import java.util.Map;",
+            "",
+            "import dagger.Component;",
+            "import dagger.multibindings.IntoSet;",
+            "import dagger.multibindings.ElementsIntoSet;",
+            "import dagger.multibindings.IntoMap;",
+            "",
+            "interface SomeType {",
+            "  @IntoSet Set<Integer> ints();",
+            "  @ElementsIntoSet Set<Double> doubles();",
+            "  @IntoMap Map<Integer, Double> map();",
+            "}");
+
+    assertThat(component)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            "Multibinding annotations may only be on @Provides or @Produces methods")
+        .in(component)
+        .onLine(12)
+        .and()
+        .withErrorContaining(
+            "Multibinding annotations may only be on @Provides or @Produces methods")
+        .in(component)
+        .onLine(13)
+        .and()
+        .withErrorContaining(
+            "Multibinding annotations may only be on @Provides or @Produces methods")
+        .in(component)
+        .onLine(14);
+  }
+}
diff --git a/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java b/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
index f9ea63cfb..5973a7bb3 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
@@ -27,6 +27,8 @@
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_ABSTRACT;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_MULTIPLE_QUALIFIERS;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_MUST_RETURN_A_VALUE;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_NOT_IN_MODULE;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_PRIVATE;
@@ -37,7 +39,6 @@
 import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_RETURN_TYPE;
 import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_SET_VALUES_RETURN_SET;
 import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_THROWS;
-import static dagger.internal.codegen.ErrorMessages.PROVIDES_OR_PRODUCES_METHOD_MULTIPLE_QUALIFIERS;
 import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
 
 @RunWith(JUnit4.class)
@@ -120,6 +121,45 @@ private String formatModuleErrorMessage(String msg) {
         .withErrorContaining(formatErrorMessage(BINDING_METHOD_MUST_RETURN_A_VALUE));
   }
 
+  @Test public void producesMethodFrameworkType() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.Lazy;",
+        "import dagger.MembersInjector;",
+        "import dagger.producers.ProducerModule;",
+        "import dagger.producers.Produced;",
+        "import dagger.producers.Producer;",
+        "import dagger.producers.Produces;",
+        "import javax.inject.Provider;",
+        "",
+        "@ProducerModule",
+        "final class TestModule {",
+        "  @Produces Provider<String> produceProvider() {}",
+        "  @Produces Lazy<String> produceLazy() {}",
+        "  @Produces MembersInjector<String> produceMembersInjector() {}",
+        "  @Produces Producer<String> produceProducer() {}",
+        "  @Produces Produced<String> produceProduced() {}",
+        "}");
+    assertAbout(javaSource()).that(moduleFile)
+    .processedWith(new ComponentProcessor())
+    .failsToCompile()
+    .withErrorContaining(formatErrorMessage(BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES))
+    .in(moduleFile).onLine(13)
+    .and()
+    .withErrorContaining(formatErrorMessage(BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES))
+    .in(moduleFile).onLine(14)
+    .and()
+    .withErrorContaining(formatErrorMessage(BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES))
+    .in(moduleFile).onLine(15)
+    .and()
+    .withErrorContaining(formatErrorMessage(BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES))
+    .in(moduleFile).onLine(16)
+    .and()
+    .withErrorContaining(formatErrorMessage(BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES))
+    .in(moduleFile).onLine(17);
+  }
+
   @Test public void producesMethodReturnRawFuture() {
     JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
         "package test;",
@@ -179,8 +219,7 @@ private String formatModuleErrorMessage(String msg) {
     JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
         "package test;",
         "",
-        "import static dagger.producers.Produces.Type.SET_VALUES;",
-        "",
+        "import dagger.multibindings.ElementsIntoSet;",
         "import dagger.producers.ProducerModule;",
         "import dagger.producers.Produces;",
         "",
@@ -188,7 +227,7 @@ private String formatModuleErrorMessage(String msg) {
         "",
         "@ProducerModule",
         "final class TestModule {",
-        "  @Produces(type = SET_VALUES) Set<?> produceWildcard() {",
+        "  @Produces @ElementsIntoSet Set<?> produceWildcard() {",
         "    return null;",
         "  }",
         "}");
@@ -202,8 +241,7 @@ private String formatModuleErrorMessage(String msg) {
     JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
         "package test;",
         "",
-        "import static dagger.producers.Produces.Type.SET_VALUES;",
-        "",
+        "import dagger.multibindings.ElementsIntoSet;",
         "import dagger.producers.ProducerModule;",
         "import dagger.producers.Produces;",
         "",
@@ -211,7 +249,7 @@ private String formatModuleErrorMessage(String msg) {
         "",
         "@ProducerModule",
         "final class TestModule {",
-        "  @Produces(type = SET_VALUES) Set produceSomething() {",
+        "  @Produces @ElementsIntoSet Set produceSomething() {",
         "    return null;",
         "  }",
         "}");
@@ -225,8 +263,7 @@ private String formatModuleErrorMessage(String msg) {
     JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
         "package test;",
         "",
-        "import static dagger.producers.Produces.Type.SET_VALUES;",
-        "",
+        "import dagger.multibindings.ElementsIntoSet;",
         "import dagger.producers.ProducerModule;",
         "import dagger.producers.Produces;",
         "",
@@ -234,7 +271,7 @@ private String formatModuleErrorMessage(String msg) {
         "",
         "@ProducerModule",
         "final class TestModule {",
-        "  @Produces(type = SET_VALUES) List<String> produceStrings() {",
+        "  @Produces @ElementsIntoSet List<String> produceStrings() {",
         "    return null;",
         "  }",
         "}");
@@ -248,9 +285,8 @@ private String formatModuleErrorMessage(String msg) {
     JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
         "package test;",
         "",
-        "import static dagger.producers.Produces.Type.SET_VALUES;",
-        "",
         "import com.google.common.util.concurrent.ListenableFuture;",
+        "import dagger.multibindings.ElementsIntoSet;",
         "import dagger.producers.ProducerModule;",
         "import dagger.producers.Produces;",
         "",
@@ -258,7 +294,7 @@ private String formatModuleErrorMessage(String msg) {
         "",
         "@ProducerModule",
         "final class TestModule {",
-        "  @Produces(type = SET_VALUES) ListenableFuture<Set<?>> produceWildcard() {",
+        "  @Produces @ElementsIntoSet ListenableFuture<Set<?>> produceWildcard() {",
         "    return null;",
         "  }",
         "}");
@@ -272,9 +308,8 @@ private String formatModuleErrorMessage(String msg) {
     JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
         "package test;",
         "",
-        "import static dagger.producers.Produces.Type.SET_VALUES;",
-        "",
         "import com.google.common.util.concurrent.ListenableFuture;",
+        "import dagger.multibindings.ElementsIntoSet;",
         "import dagger.producers.ProducerModule;",
         "import dagger.producers.Produces;",
         "",
@@ -282,7 +317,7 @@ private String formatModuleErrorMessage(String msg) {
         "",
         "@ProducerModule",
         "final class TestModule {",
-        "  @Produces(type = SET_VALUES) ListenableFuture<Set> produceSomething() {",
+        "  @Produces @ElementsIntoSet ListenableFuture<Set> produceSomething() {",
         "    return null;",
         "  }",
         "}");
@@ -296,9 +331,8 @@ private String formatModuleErrorMessage(String msg) {
     JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
         "package test;",
         "",
-        "import static dagger.producers.Produces.Type.SET_VALUES;",
-        "",
         "import com.google.common.util.concurrent.ListenableFuture;",
+        "import dagger.multibindings.ElementsIntoSet;",
         "import dagger.producers.ProducerModule;",
         "import dagger.producers.Produces;",
         "",
@@ -306,7 +340,7 @@ private String formatModuleErrorMessage(String msg) {
         "",
         "@ProducerModule",
         "final class TestModule {",
-        "  @Produces(type = SET_VALUES) ListenableFuture<List<String>> produceStrings() {",
+        "  @Produces @ElementsIntoSet ListenableFuture<List<String>> produceStrings() {",
         "    return null;",
         "  }",
         "}");
@@ -685,6 +719,6 @@ public void singleProducesMethodNoArgsFutureWithProducerName() {
     assertAbout(javaSources()).that(ImmutableList.of(moduleFile, QUALIFIER_A, QUALIFIER_B))
         .processedWith(new ComponentProcessor())
         .failsToCompile()
-        .withErrorContaining(PROVIDES_OR_PRODUCES_METHOD_MULTIPLE_QUALIFIERS);
+        .withErrorContaining(BINDING_METHOD_MULTIPLE_QUALIFIERS);
   }
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java
index 64cfba626..b494e9d88 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java
@@ -89,7 +89,7 @@
   }
 
   @Test
-  public void builderWithExecutorAndProvidedExecutor() {
+  public void dependsOnProductionExecutor() {
     JavaFileObject moduleFile =
         JavaFileObjects.forSourceLines(
             "test.ExecutorModule",
@@ -114,10 +114,12 @@ public void builderWithExecutorAndProvidedExecutor() {
             "",
             "import dagger.producers.ProducerModule;",
             "import dagger.producers.Produces;",
+            "import dagger.producers.Production;",
+            "import java.util.concurrent.Executor;",
             "",
             "@ProducerModule",
             "final class SimpleModule {",
-            "  @Produces String str() {",
+            "  @Produces String str(@Production Executor executor) {",
             "    return \"\";",
             "  }",
             "}");
@@ -136,7 +138,6 @@ public void builderWithExecutorAndProvidedExecutor() {
             "",
             "  @ProductionComponent.Builder",
             "  interface Builder {",
-            "    Builder executor(Executor executor);",
             "    SimpleComponent build();",
             "  }",
             "}");
@@ -144,108 +145,58 @@ public void builderWithExecutorAndProvidedExecutor() {
         .that(ImmutableList.of(moduleFile, producerModuleFile, componentFile))
         .processedWith(new ComponentProcessor())
         .failsToCompile()
-        .withErrorContaining("is bound multiple times");
+        .withErrorContaining("may not depend on the production executor");
   }
 
   @Test
-  public void dependsOnProductionExecutor() {
-    JavaFileObject moduleFile =
+  public void simpleComponent() {
+    JavaFileObject component =
         JavaFileObjects.forSourceLines(
-            "test.ExecutorModule",
+            "test.TestClass",
             "package test;",
             "",
+            "import com.google.common.util.concurrent.ListenableFuture;",
             "import com.google.common.util.concurrent.MoreExecutors;",
             "import dagger.Module;",
             "import dagger.Provides;",
-            "import dagger.producers.Production;",
-            "import java.util.concurrent.Executor;",
-            "",
-            "@Module",
-            "final class ExecutorModule {",
-            "  @Provides @Production Executor executor() {",
-            "    return MoreExecutors.directExecutor();",
-            "  }",
-            "}");
-    JavaFileObject producerModuleFile =
-        JavaFileObjects.forSourceLines(
-            "test.SimpleModule",
-            "package test;",
-            "",
             "import dagger.producers.ProducerModule;",
             "import dagger.producers.Produces;",
             "import dagger.producers.Production;",
+            "import dagger.producers.ProductionComponent;",
             "import java.util.concurrent.Executor;",
+            "import javax.inject.Inject;",
             "",
-            "@ProducerModule",
-            "final class SimpleModule {",
-            "  @Produces String str(@Production Executor executor) {",
-            "    return \"\";",
+            "final class TestClass {",
+            "  static final class C {",
+            "    @Inject C() {}",
             "  }",
-            "}");
-    JavaFileObject componentFile =
-        JavaFileObjects.forSourceLines(
-            "test.SimpleComponent",
-            "package test;",
             "",
-            "import com.google.common.util.concurrent.ListenableFuture;",
-            "import dagger.producers.ProductionComponent;",
-            "import java.util.concurrent.Executor;",
+            "  interface A {}",
+            "  interface B {}",
             "",
-            "@ProductionComponent(modules = {ExecutorModule.class, SimpleModule.class})",
-            "interface SimpleComponent {",
-            "  ListenableFuture<String> str();",
+            "  @Module",
+            "  static final class BModule {",
+            "    @Provides B b(C c) {",
+            "      return null;",
+            "    }",
             "",
-            "  @ProductionComponent.Builder",
-            "  interface Builder {",
-            "    SimpleComponent build();",
+            "    @Provides @Production Executor executor() {",
+            "      return MoreExecutors.directExecutor();",
+            "    }",
+            "  }",
+            "",
+            "  @ProducerModule",
+            "  static final class AModule {",
+            "    @Produces ListenableFuture<A> a(B b) {",
+            "      return null;",
+            "    }",
+            "  }",
+            "",
+            "  @ProductionComponent(modules = {AModule.class, BModule.class})",
+            "  interface SimpleComponent {",
+            "    ListenableFuture<A> a();",
             "  }",
             "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(moduleFile, producerModuleFile, componentFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("may not depend on the production executor");
-  }
-
-  @Test public void simpleComponent() {
-    JavaFileObject component = JavaFileObjects.forSourceLines("test.TestClass",
-        "package test;",
-        "",
-        "import com.google.common.util.concurrent.ListenableFuture;",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "import dagger.producers.ProducerModule;",
-        "import dagger.producers.Produces;",
-        "import dagger.producers.ProductionComponent;",
-        "import javax.inject.Inject;",
-        "",
-        "final class TestClass {",
-        "  static final class C {",
-        "    @Inject C() {}",
-        "  }",
-        "",
-        "  interface A {}",
-        "  interface B {}",
-        "",
-        "  @Module",
-        "  static final class BModule {",
-        "    @Provides B b(C c) {",
-        "      return null;",
-        "    }",
-        "  }",
-        "",
-        "  @ProducerModule",
-        "  static final class AModule {",
-        "    @Produces ListenableFuture<A> a(B b) {",
-        "      return null;",
-        "    }",
-        "  }",
-        "",
-        "  @ProductionComponent(modules = {AModule.class, BModule.class})",
-        "  interface SimpleComponent {",
-        "    ListenableFuture<A> a();",
-        "  }",
-        "}");
     JavaFileObject generatedComponent =
         JavaFileObjects.forSourceLines(
             "test.DaggerTestClass_SimpleComponent",
@@ -266,12 +217,13 @@ public void dependsOnProductionExecutor() {
             GENERATED_ANNOTATION,
             "public final class DaggerTestClass_SimpleComponent",
             "    implements TestClass.SimpleComponent {",
-            "  private Provider<Executor> simpleComponentProvider;",
             "  private Provider<Executor> executorProvider;",
-            "  private Provider<TestClass.SimpleComponent> simpleComponentProvider2;",
+            "  private Provider<Executor> executorProvider2;",
+            "  private Provider<TestClass.SimpleComponent> simpleComponentProvider;",
             "  private Provider<ProductionComponentMonitor> monitorProvider;",
             "  private Provider<TestClass.B> bProvider;",
             "  private Producer<TestClass.A> aProducer;",
+            "  private Producer<TestClass.B> bProducer;",
             "",
             "  private DaggerTestClass_SimpleComponent(Builder builder) {",
             "    assert builder != null;",
@@ -282,28 +234,33 @@ public void dependsOnProductionExecutor() {
             "    return new Builder();",
             "  }",
             "",
+            "  public static TestClass.SimpleComponent create() {",
+            "    return builder().build()",
+            "  }",
+            "",
             "  @SuppressWarnings(\"unchecked\")",
             "  private void initialize(final Builder builder) {",
-            "    this.simpleComponentProvider =",
-            "        InstanceFactory.<Executor>create(builder.executor);",
             "    this.executorProvider =",
-            "        DoubleCheck.provider(",
-            "            TestClass$SimpleComponent_ProductionExecutorModule_ExecutorFactory",
-            "                .create(simpleComponentProvider));",
-            "    this.simpleComponentProvider2 =",
+            "        TestClass$BModule_ExecutorFactory.create(builder.bModule);",
+            "     this.executorProvider2 =",
+            "         DoubleCheck.provider(",
+            "             TestClass$SimpleComponent_ProductionExecutorModule_ExecutorFactory.create(",
+            "                 executorProvider));",
+            "    this.simpleComponentProvider =",
             "        InstanceFactory.<TestClass.SimpleComponent>create(this);",
             "    this.monitorProvider =",
             "        DoubleCheck.provider(",
             "            TestClass$SimpleComponent_MonitoringModule_MonitorFactory.create(",
-            "                simpleComponentProvider2,",
+            "                simpleComponentProvider,",
             "                SetFactory.<ProductionComponentMonitor.Factory>create());",
             "    this.bProvider = TestClass$BModule_BFactory.create(",
             "        builder.bModule, TestClass$C_Factory.create());",
+            "    this.bProducer = Producers.producerFromProvider(bProvider);",
             "    this.aProducer = new TestClass$AModule_AFactory(",
             "        builder.aModule,",
-            "        executorProvider,",
+            "        executorProvider2,",
             "        monitorProvider,",
-            "        Producers.producerFromProvider(bProvider));",
+            "        bProducer);",
             "  }",
             "",
             "  @Override",
@@ -314,7 +271,6 @@ public void dependsOnProductionExecutor() {
             "  public static final class Builder {",
             "    private TestClass.BModule bModule;",
             "    private TestClass.AModule aModule;",
-            "    private Executor executor;",
             "",
             "    private Builder() {",
             "    }",
@@ -326,10 +282,6 @@ public void dependsOnProductionExecutor() {
             "      if (aModule == null) {",
             "        this.aModule = new TestClass.AModule();",
             "      }",
-            "      if (executor == null) {",
-            "        throw new IllegalStateException(Executor.class.getCanonicalName()",
-            "            + \" must be set\");",
-            "      }",
             "      return new DaggerTestClass_SimpleComponent(this);",
             "    }",
             "",
@@ -358,12 +310,6 @@ public void dependsOnProductionExecutor() {
             "      Preconditions.checkNotNull(testClass$SimpleComponent_ProductionExecutorModule);",
             "      return this;",
             "    }",
-            "",
-            "    public Builder executor(Executor executor) {",
-            "      this.executor = Preconditions.checkNotNull(executor);",
-            "      return this;",
-            "    }",
-            "  }",
             "}");
     assertAbout(javaSource()).that(component)
         .processedWith(new ComponentProcessor())
@@ -376,11 +322,14 @@ public void dependsOnProductionExecutor() {
         "package test;",
         "",
         "import com.google.common.util.concurrent.ListenableFuture;",
+        "import com.google.common.util.concurrent.MoreExecutors;",
         "import dagger.Module;",
         "import dagger.Provides;",
         "import dagger.producers.ProducerModule;",
         "import dagger.producers.Produces;",
+        "import dagger.producers.Production;",
         "import dagger.producers.ProductionComponent;",
+        "import java.util.concurrent.Executor;",
         "import javax.annotation.Nullable;",
         "import javax.inject.Inject;",
         "",
@@ -394,6 +343,10 @@ public void dependsOnProductionExecutor() {
         "    @Provides @Nullable C c() {",
         "      return null;",
         "    }",
+        "",
+        "    @Provides @Production Executor executor() {",
+        "      return MoreExecutors.directExecutor();",
+        "    }",
         "  }",
         "",
         "  @ProducerModule",
@@ -417,10 +370,10 @@ public void dependsOnProductionExecutor() {
         .compilesWithoutError()
         .withWarningContaining("@Nullable on @Produces methods does not do anything")
         .in(component)
-        .onLine(26)
+        .onLine(33)
         .and()
         .withWarningContaining("@Nullable on @Produces methods does not do anything")
         .in(component)
-        .onLine(29);
+        .onLine(36);
   }
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/ProductionGraphValidationTest.java b/compiler/src/test/java/dagger/internal/codegen/ProductionGraphValidationTest.java
index 399fb758f..0206ec7fd 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ProductionGraphValidationTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ProductionGraphValidationTest.java
@@ -17,14 +17,12 @@
 
 import com.google.common.collect.ImmutableList;
 import com.google.testing.compile.JavaFileObjects;
-import java.util.Arrays;
 import javax.tools.JavaFileObject;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
 import static com.google.common.truth.Truth.assertAbout;
-import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
 
 /**
@@ -32,6 +30,24 @@
  */
 @RunWith(JUnit4.class)
 public class ProductionGraphValidationTest {
+  private static final JavaFileObject EXECUTOR_MODULE =
+      JavaFileObjects.forSourceLines(
+          "test.ExecutorModule",
+          "package test;",
+          "",
+          "import com.google.common.util.concurrent.MoreExecutors;",
+          "import dagger.Module;",
+          "import dagger.Provides;",
+          "import dagger.producers.Production;",
+          "import java.util.concurrent.Executor;",
+          "",
+          "@Module",
+          "class ExecutorModule {",
+          "  @Provides @Production Executor executor() {",
+          "    return MoreExecutors.directExecutor();",
+          "  }",
+          "}");
+
   @Test public void componentWithUnprovidedInput() {
     JavaFileObject component = JavaFileObjects.forSourceLines("test.MyComponent",
         "package test;",
@@ -39,7 +55,7 @@
         "import com.google.common.util.concurrent.ListenableFuture;",
         "import dagger.producers.ProductionComponent;",
         "",
-        "@ProductionComponent(modules = FooModule.class)",
+        "@ProductionComponent(modules = {ExecutorModule.class, FooModule.class})",
         "interface MyComponent {",
         "  ListenableFuture<Foo> getFoo();",
         "}");
@@ -58,7 +74,7 @@
         "    return null;",
         "  }",
         "}");
-    assertAbout(javaSources()).that(Arrays.asList(module, component))
+    assertAbout(javaSources()).that(ImmutableList.of(EXECUTOR_MODULE, module, component))
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining("test.Bar cannot be provided without an @Inject constructor or from "
@@ -76,14 +92,14 @@
         "final class TestClass {",
         "  interface A {}",
         "",
-        "  @ProductionComponent()",
+        "  @ProductionComponent(modules = ExecutorModule.class)",
         "  interface AComponent {",
         "    ListenableFuture<A> getA();",
         "  }",
         "}");
     String expectedError =
         "test.TestClass.A cannot be provided without an @Provides- or @Produces-annotated method.";
-    assertAbout(javaSource()).that(component)
+    assertAbout(javaSources()).that(ImmutableList.of(EXECUTOR_MODULE, component))
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(expectedError).in(component).onLine(11);
@@ -118,14 +134,14 @@
         "    }",
         "  }",
         "",
-        "  @ProductionComponent(modules = {AModule.class, BModule.class})",
+        "  @ProductionComponent(modules = {ExecutorModule.class, AModule.class, BModule.class})",
         "  interface AComponent {",
         "    ListenableFuture<A> getA();",
         "  }",
         "}");
     String expectedError =
         "test.TestClass.A is a provision, which cannot depend on a production.";
-    assertAbout(javaSource()).that(component)
+    assertAbout(javaSources()).that(ImmutableList.of(EXECUTOR_MODULE, component))
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(expectedError).in(component).onLine(30);
@@ -150,14 +166,14 @@
         "    }",
         "  }",
         "",
-        "  @ProductionComponent(modules = AModule.class)",
+        "  @ProductionComponent(modules = {ExecutorModule.class, AModule.class})",
         "  interface AComponent {",
         "    A getA();",
         "  }",
         "}");
     String expectedError =
         "test.TestClass.A is a provision entry-point, which cannot depend on a production.";
-    assertAbout(javaSource()).that(component)
+    assertAbout(javaSources()).that(ImmutableList.of(EXECUTOR_MODULE, component))
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(expectedError).in(component).onLine(20);
@@ -173,19 +189,18 @@ public void monitoringDependsOnUnboundType() {
             "import com.google.common.util.concurrent.ListenableFuture;",
             "import dagger.Module;",
             "import dagger.Provides;",
+            "import dagger.multibindings.IntoSet;",
             "import dagger.producers.ProducerModule;",
             "import dagger.producers.Produces;",
             "import dagger.producers.ProductionComponent;",
             "import dagger.producers.monitoring.ProductionComponentMonitor;",
             "",
-            "import static dagger.Provides.Type.SET;",
-            "",
             "final class TestClass {",
             "  interface A {}",
             "",
             "  @Module",
             "  final class MonitoringModule {",
-            "    @Provides(type = SET)",
+            "    @Provides @IntoSet",
             "    ProductionComponentMonitor.Factory monitorFactory(A unbound) {",
             "      return null;",
             "    }",
@@ -198,20 +213,21 @@ public void monitoringDependsOnUnboundType() {
             "    }",
             "  }",
             "",
-            "  @ProductionComponent(modules = {MonitoringModule.class, StringModule.class})",
+            "  @ProductionComponent(",
+            "    modules = {ExecutorModule.class, MonitoringModule.class, StringModule.class}",
+            "  )",
             "  interface StringComponent {",
             "    ListenableFuture<String> getString();",
             "  }",
             "}");
     String expectedError =
         "test.TestClass.A cannot be provided without an @Provides-annotated method.";
-    assertAbout(javaSource())
-        .that(component)
+    assertAbout(javaSources()).that(ImmutableList.of(EXECUTOR_MODULE, component))
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(expectedError)
         .in(component)
-        .onLine(33);
+        .onLine(34);
   }
 
   @Test
@@ -224,19 +240,18 @@ public void monitoringDependsOnProduction() {
             "import com.google.common.util.concurrent.ListenableFuture;",
             "import dagger.Module;",
             "import dagger.Provides;",
+            "import dagger.multibindings.IntoSet;",
             "import dagger.producers.ProducerModule;",
             "import dagger.producers.Produces;",
             "import dagger.producers.ProductionComponent;",
             "import dagger.producers.monitoring.ProductionComponentMonitor;",
             "",
-            "import static dagger.Provides.Type.SET;",
-            "",
             "final class TestClass {",
             "  interface A {}",
             "",
             "  @Module",
             "  final class MonitoringModule {",
-            "    @Provides(type = SET) ProductionComponentMonitor.Factory monitorFactory(A a) {",
+            "    @Provides @IntoSet ProductionComponentMonitor.Factory monitorFactory(A a) {",
             "      return null;",
             "    }",
             "  }",
@@ -252,44 +267,50 @@ public void monitoringDependsOnProduction() {
             "    }",
             "  }",
             "",
-            "  @ProductionComponent(modules = {MonitoringModule.class, StringModule.class})",
+            "  @ProductionComponent(",
+            "    modules = {ExecutorModule.class, MonitoringModule.class, StringModule.class}",
+            "  )",
             "  interface StringComponent {",
             "    ListenableFuture<String> getString();",
             "  }",
             "}");
     String expectedError =
-        "@Provides(type=SET) dagger.producers.monitoring.ProductionComponentMonitor.Factory"
+        "@Provides @dagger.multibindings.IntoSet"
+            + " dagger.producers.monitoring.ProductionComponentMonitor.Factory"
             + " test.TestClass.MonitoringModule.monitorFactory(test.TestClass.A) is a provision,"
             + " which cannot depend on a production.";
-    assertAbout(javaSource())
-        .that(component)
+    assertAbout(javaSources()).that(ImmutableList.of(EXECUTOR_MODULE, component))
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(expectedError)
         .in(component)
-        .onLine(36);
+        .onLine(37);
   }
   
   @Test
   public void cycleNotBrokenByMap() {
     JavaFileObject component =
         JavaFileObjects.forSourceLines(
-            "TestComponent",
+            "test.TestComponent",
+            "package test;",
+            "",
             "import com.google.common.util.concurrent.ListenableFuture;",
             "import dagger.producers.ProductionComponent;",
             "",
-            "@ProductionComponent(modules = TestModule.class)",
+            "@ProductionComponent(modules = {ExecutorModule.class, TestModule.class})",
             "interface TestComponent {",
             "  ListenableFuture<String> string();",
             "}");
     JavaFileObject module =
         JavaFileObjects.forSourceLines(
-            "TestModule",
+            "test.TestModule",
+            "package test;",
+            "",
             "import dagger.producers.ProducerModule;",
             "import dagger.producers.Produces;",
+            "import dagger.multibindings.IntoMap;",
             "import dagger.multibindings.StringKey;",
             "import java.util.Map;",
-            "import static dagger.producers.Produces.Type.MAP;",
             "",
             "@ProducerModule",
             "final class TestModule {",
@@ -297,41 +318,45 @@ public void cycleNotBrokenByMap() {
             "    return \"string\";",
             "  }",
             "",
-            "  @Produces(type = MAP) @StringKey(\"key\")",
+            "  @Produces @IntoMap @StringKey(\"key\")",
             "  static String entry(String string) {",
             "    return string;",
             "  }",
             "}");
     assertAbout(javaSources())
-        .that(ImmutableList.of(component, module))
+        .that(ImmutableList.of(EXECUTOR_MODULE, component, module))
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining("cycle")
         .in(component)
-        .onLine(6);
+        .onLine(8);
   }
 
   @Test
   public void cycleNotBrokenByProducerMap() {
     JavaFileObject component =
         JavaFileObjects.forSourceLines(
-            "TestComponent",
+            "test.TestComponent",
+            "package test;",
+            "",
             "import com.google.common.util.concurrent.ListenableFuture;",
             "import dagger.producers.ProductionComponent;",
             "",
-            "@ProductionComponent(modules = TestModule.class)",
+            "@ProductionComponent(modules = {ExecutorModule.class, TestModule.class})",
             "interface TestComponent {",
             "  ListenableFuture<String> string();",
             "}");
     JavaFileObject module =
         JavaFileObjects.forSourceLines(
-            "TestModule",
+            "test.TestModule",
+            "package test;",
+            "",
             "import dagger.producers.Producer;",
             "import dagger.producers.ProducerModule;",
             "import dagger.producers.Produces;",
             "import dagger.multibindings.StringKey;",
+            "import dagger.multibindings.IntoMap;",
             "import java.util.Map;",
-            "import static dagger.producers.Produces.Type.MAP;",
             "",
             "@ProducerModule",
             "final class TestModule {",
@@ -339,17 +364,17 @@ public void cycleNotBrokenByProducerMap() {
             "    return \"string\";",
             "  }",
             "",
-            "  @Produces(type = MAP) @StringKey(\"key\")",
+            "  @Produces @IntoMap @StringKey(\"key\")",
             "  static String entry(String string) {",
             "    return string;",
             "  }",
             "}");
     assertAbout(javaSources())
-        .that(ImmutableList.of(component, module))
+        .that(ImmutableList.of(EXECUTOR_MODULE, component, module))
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining("cycle")
         .in(component)
-        .onLine(6);
+        .onLine(8);
   }
 }
diff --git a/core/pom.xml b/core/pom.xml
index e51fc5a05..6c5e4cf39 100644
--- a/core/pom.xml
+++ b/core/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.google.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>2.2-SNAPSHOT</version>
+    <version>2.4-SNAPSHOT</version>
   </parent>
 
   <artifactId>dagger</artifactId>
diff --git a/core/src/main/java/dagger/Binds.java b/core/src/main/java/dagger/Binds.java
new file mode 100644
index 000000000..78b9a7fec
--- /dev/null
+++ b/core/src/main/java/dagger/Binds.java
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+
+import static java.lang.annotation.ElementType.METHOD;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+/**
+ * Annotates <em>abstract</em> methods of a {@link Module} that delegate bindings. For example, to
+ * bind {@link java.util.Random} to {@link java.security.SecureRandom} a module could declare the
+ * following: {@code @Bind abstract Random bindRandom(SecureRandom secureRandom);}
+ *
+ * <p>{@code @Bind} methods are a drop-in replacement for {@link Provides} methods that simply
+ * return an injected parameter.  Prefer {@code @Bind} because the generated implementation is
+ * likely to be more efficient.
+ *
+ * <p>A {@code @Bind} method:
+ * <ul>
+ * <li>Must be {@code abstract}.
+ * <li>Must have a single parameter whose type is assignable to the return type.  The return type is
+ * the bound type and the parameter is the type to which it is bound.
+ * <li>May be {@linkplain javax.inject.Scope scoped}.
+ * <li>May be {@linkplain javax.inject.Qualifier qualified}.
+ * </ul>
+ */
+@Documented
+@Retention(RUNTIME)
+@Target(METHOD)
+public @interface Binds {}
diff --git a/core/src/main/java/dagger/MapKey.java b/core/src/main/java/dagger/MapKey.java
index dfcfc139e..a169e0731 100644
--- a/core/src/main/java/dagger/MapKey.java
+++ b/core/src/main/java/dagger/MapKey.java
@@ -26,9 +26,10 @@
 
 /**
  * Identifies annotation types that are used to associate keys with values returned by
- * {@linkplain Provides provider methods} in order to compose a {@linkplain Provides.Type#MAP map}.
+ * {@linkplain Provides provider methods} in order to compose a {@linkplain
+ * dagger.multibindings.IntoMap map}.
  *
- * <p>Every provider method annotated with {@code @Provides(type = MAP)} must also have an
+ * <p>Every provider method annotated with {@code @Provides} and {@code @IntoMap} must also have an
  * annotation that identifies the key for that map entry. That annotation's type must be annotated
  * with {@code @MapKey}.
  *
@@ -45,7 +46,8 @@
  *
  * {@literal @}Module
  * class SomeModule {
- *   {@literal @}Provides(type = MAP)
+ *   {@literal @}Provides
+ *   {@literal @}IntoMap
  *   {@literal @}SomeEnumKey(SomeEnum.FOO)
  *   Integer provideFooValue() {
  *     return 2;
@@ -80,7 +82,8 @@
  *
  * {@literal @}Module
  * class SomeModule {
- *   {@literal @}Provides(type = MAP)
+ *   {@literal @}Provides
+ *   {@literal @}IntoMap
  *   {@literal @}MyMapKey(someString = "foo", someEnum = BAR)
  *   Integer provideFooBarValue() {
  *     return 2;
diff --git a/core/src/main/java/dagger/Reusable.java b/core/src/main/java/dagger/Reusable.java
index 01175e0ee..d5e7d89c2 100644
--- a/core/src/main/java/dagger/Reusable.java
+++ b/core/src/main/java/dagger/Reusable.java
@@ -15,6 +15,7 @@
  */
 package dagger;
 
+import dagger.internal.Beta;
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import javax.inject.Scope;
@@ -31,6 +32,7 @@
  * </a>
  */
 @Documented
+@Beta
 @Retention(RUNTIME)
 @Scope
 public @interface Reusable {}
diff --git a/core/src/main/java/dagger/internal/DoubleCheck.java b/core/src/main/java/dagger/internal/DoubleCheck.java
index 6498eae31..513722929 100644
--- a/core/src/main/java/dagger/internal/DoubleCheck.java
+++ b/core/src/main/java/dagger/internal/DoubleCheck.java
@@ -53,9 +53,15 @@ public T get() {
     return (T) result;
   }
 
-  /** Returns a new provider that caches the value from the given factory. */
-  public static <T> Provider<T> provider(Factory<T> factory) {
-    return new DoubleCheck<T>(checkNotNull(factory));
+  /** Returns a {@link Provider} that caches the value from the given delegate provider. */
+  public static <T> Provider<T> provider(Provider<T> delegate) {
+    checkNotNull(delegate);
+    if (delegate instanceof DoubleCheck) {
+      /* This should be a rare case, but if we have a scoped @Bind that delegates to a scoped
+       * binding, we shouldn't cache the value again. */
+      return delegate;
+    }
+    return new DoubleCheck<T>(delegate);
   }
 
   /** Returns a {@link Lazy} that caches the value from the given provider. */
diff --git a/core/src/main/java/dagger/internal/InstanceFactory.java b/core/src/main/java/dagger/internal/InstanceFactory.java
index 400d26825..ca57f71bd 100644
--- a/core/src/main/java/dagger/internal/InstanceFactory.java
+++ b/core/src/main/java/dagger/internal/InstanceFactory.java
@@ -21,8 +21,8 @@
  *
  * <p>Note that while this is a {@link Factory} implementation, and thus unscoped, each call to
  * {@link #get} will always return the same instance.  As such, any scoping applied to this factory
- * is redundant and unnecessary.  However, using this with {@link DoubleCheck#provider(Factory)} is
- * valid and may be desired for testing or contractual guarantees.
+ * is redundant and unnecessary.  However, using this with {@link DoubleCheck#provider} is valid and
+ * may be desired for testing or contractual guarantees.
  *
  * @author Gregory Kick
  * @since 2.0
diff --git a/core/src/main/java/dagger/internal/ProviderOfLazy.java b/core/src/main/java/dagger/internal/ProviderOfLazy.java
new file mode 100644
index 000000000..77d4961dd
--- /dev/null
+++ b/core/src/main/java/dagger/internal/ProviderOfLazy.java
@@ -0,0 +1,53 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal;
+
+import dagger.Lazy;
+import javax.inject.Provider;
+
+import static dagger.internal.Preconditions.checkNotNull;
+
+/**
+ * A {@link Provider} of {@link Lazy} instances that each delegate to a given {@link Provider}.
+ */
+public final class ProviderOfLazy<T> implements Provider<Lazy<T>> {
+
+  private final Provider<T> provider;
+
+  private ProviderOfLazy(Provider<T> provider) {
+    assert provider != null;
+    this.provider = provider;
+  }
+
+  /**
+   * Returns a new instance of {@link Lazy Lazy&lt;T&gt;}, which calls {@link Provider#get()} at
+   * most once on the {@link Provider} held by this object.
+   */
+  @Override
+  public Lazy<T> get() {
+    return DoubleCheck.lazy(provider);
+  }
+
+  /**
+   * Creates a new {@link Provider Provider&lt;Lazy&lt;T&gt;&gt;} that decorates the given
+   * {@link Provider}.
+   *
+   * @see #get()
+   */
+  public static <T> Provider<Lazy<T>> create(Provider<T> provider) {
+    return new ProviderOfLazy<T>(checkNotNull(provider));
+  }
+}
diff --git a/core/src/main/java/dagger/internal/SimpleLazilyInitializedProvider.java b/core/src/main/java/dagger/internal/SingleCheck.java
similarity index 62%
rename from core/src/main/java/dagger/internal/SimpleLazilyInitializedProvider.java
rename to core/src/main/java/dagger/internal/SingleCheck.java
index a87d3136f..3a9a14766 100644
--- a/core/src/main/java/dagger/internal/SimpleLazilyInitializedProvider.java
+++ b/core/src/main/java/dagger/internal/SingleCheck.java
@@ -24,13 +24,13 @@
  * A {@link Provider} implementation that memoizes the result of a {@link Factory} instance using
  * simple lazy initialization, not the double-checked lock pattern.
  */
-public final class SimpleLazilyInitializedProvider<T> implements Provider<T>, Lazy<T> {
+public final class SingleCheck<T> implements Provider<T>, Lazy<T> {
   private static final Object UNINITIALIZED = new Object();
 
-  private final Factory<T> factory;
+  private volatile Factory<T> factory;
   private volatile Object instance = UNINITIALIZED;
 
-  private SimpleLazilyInitializedProvider(Factory<T> factory) {
+  private SingleCheck(Factory<T> factory) {
     assert factory != null;
     this.factory = factory;
   }
@@ -38,14 +38,22 @@ private SimpleLazilyInitializedProvider(Factory<T> factory) {
   @SuppressWarnings("unchecked") // cast only happens when result comes from the factory
   @Override
   public T get() {
+    // factory is volatile and might become null afer the check to instance == UNINITIALIZED
+    // retrieve the factory first, which should not be null if instance is UNINITIALIZED.
+    // This relies upon instance also being volatile so that the reads and writes of both variables
+    // cannot be reordered.
+    Factory<T> factoryReference = factory;
     if (instance == UNINITIALIZED) {
-      instance = factory.get();
+      instance = factoryReference.get();
+      // Null out the reference to the provider. We are never going to need it again, so we can make
+      // it eligble for GC.
+      factory = null;
     }
     return (T) instance;
   }
 
   /** Returns a new provider for the given factory. */
-  public static <T> Provider<T> create(Factory<T> factory) {
-    return new SimpleLazilyInitializedProvider<T>(checkNotNull(factory));
+  public static <T> Provider<T> provider(Factory<T> factory) {
+    return new SingleCheck<T>(checkNotNull(factory));
   }
 }
diff --git a/core/src/main/java/dagger/multibindings/ElementsIntoSet.java b/core/src/main/java/dagger/multibindings/ElementsIntoSet.java
new file mode 100644
index 000000000..8ff7dd97c
--- /dev/null
+++ b/core/src/main/java/dagger/multibindings/ElementsIntoSet.java
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.multibindings;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+
+import static java.lang.annotation.ElementType.METHOD;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+/**
+ * The method's return type is {@code Set<T>} and all values are contributed to the set. The {@code
+ * Set<T>} produced from the accumulation of values will be immutable. An example use is to provide
+ * a default empty set binding, which is otherwise not possible using {@link IntoSet}.
+ *
+ * @see <a href=google.github.io/dagger/multibindings#set-multibindings>Set multibinding</a>
+ */
+@Documented
+@Target(METHOD)
+@Retention(RUNTIME)
+public @interface ElementsIntoSet {}
diff --git a/core/src/main/java/dagger/multibindings/IntoMap.java b/core/src/main/java/dagger/multibindings/IntoMap.java
new file mode 100644
index 000000000..4dc3427a3
--- /dev/null
+++ b/core/src/main/java/dagger/multibindings/IntoMap.java
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.multibindings;
+
+import dagger.internal.Beta;
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+
+import static java.lang.annotation.ElementType.METHOD;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+/**
+ * The method's return type forms the type argument for the value of a
+ * {@code Map<K, Provider<V>>}, and the combination of the annotated key and the returned value
+ * is contributed to the map as a key/value pair. The {@code Map<K, Provider<V>>} produced from
+ * the accumulation of values will be immutable.
+ *
+ * @see <a href=google.github.io/dagger/multibindings#map-multibindings>Map multibinding</a>
+ */
+@Documented
+@Target(METHOD)
+@Retention(RUNTIME)
+@Beta
+public @interface IntoMap {}
diff --git a/core/src/main/java/dagger/multibindings/IntoSet.java b/core/src/main/java/dagger/multibindings/IntoSet.java
new file mode 100644
index 000000000..c98a957a9
--- /dev/null
+++ b/core/src/main/java/dagger/multibindings/IntoSet.java
@@ -0,0 +1,36 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.multibindings;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+
+import static java.lang.annotation.ElementType.METHOD;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+/**
+ * The method's return type forms the generic type argument of a {@code Set<T>}, and the
+ * returned value is contributed to the set. The object graph will pass dependencies to the
+ * method as parameters. The {@code Set<T>} produced from the accumulation of values will be
+ * immutable.
+ *
+ * @see <a href=google.github.io/dagger/multibindings#set-multibindings>Set multibinding</a>
+ */
+@Documented
+@Target(METHOD)
+@Retention(RUNTIME)
+public @interface IntoSet {}
diff --git a/core/src/test/java/dagger/internal/DoubleCheckTest.java b/core/src/test/java/dagger/internal/DoubleCheckTest.java
index af110f49b..280dccf25 100644
--- a/core/src/test/java/dagger/internal/DoubleCheckTest.java
+++ b/core/src/test/java/dagger/internal/DoubleCheckTest.java
@@ -28,11 +28,11 @@
 import java.util.concurrent.Future;
 import java.util.concurrent.atomic.AtomicInteger;
 import javax.inject.Provider;
-import org.junit.Ignore;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
+import static com.google.common.truth.Truth.assertThat;
 import static com.google.common.truth.Truth.assert_;
 import static org.junit.Assert.fail;
 
@@ -56,7 +56,29 @@ public void lazy_nullPointerException() {
     }
   }
 
-  @Test public void get() throws Exception {
+  private static final Provider<Object> DOUBLE_CHECK_OBJECT_PROVIDER =
+      DoubleCheck.provider(
+          new Provider<Object>() {
+            @Override
+            public Object get() {
+              return new Object();
+            }
+          });
+
+  @Test
+  public void doubleWrapping_provider() {
+    assertThat(DoubleCheck.provider(DOUBLE_CHECK_OBJECT_PROVIDER))
+        .isSameAs(DOUBLE_CHECK_OBJECT_PROVIDER);
+  }
+
+  @Test
+  public void doubleWrapping_lazy() {
+    assertThat(DoubleCheck.lazy(DOUBLE_CHECK_OBJECT_PROVIDER))
+        .isSameAs(DOUBLE_CHECK_OBJECT_PROVIDER);
+  }
+
+  @Test
+  public void get() throws Exception {
     int numThreads = 10;
     ExecutorService executor = Executors.newFixedThreadPool(numThreads);
 
@@ -66,12 +88,14 @@ public void lazy_nullPointerException() {
 
     List<Callable<Object>> tasks = Lists.newArrayListWithCapacity(numThreads);
     for (int i = 0; i < numThreads; i++) {
-      tasks.add(new Callable<Object>() {
-        @Override public Object call() throws Exception {
-          latch.countDown();
-          return lazy.get();
-        }
-      });
+      tasks.add(
+          new Callable<Object>() {
+            @Override
+            public Object call() throws Exception {
+              latch.countDown();
+              return lazy.get();
+            }
+          });
     }
 
     List<Future<Object>> futures = executor.invokeAll(tasks);
diff --git a/core/src/test/java/dagger/internal/SimpleLazilyInitializedProviderTest.java b/core/src/test/java/dagger/internal/SingleCheckTest.java
similarity index 86%
rename from core/src/test/java/dagger/internal/SimpleLazilyInitializedProviderTest.java
rename to core/src/test/java/dagger/internal/SingleCheckTest.java
index c1fd61c19..3bc2075cf 100644
--- a/core/src/test/java/dagger/internal/SimpleLazilyInitializedProviderTest.java
+++ b/core/src/test/java/dagger/internal/SingleCheckTest.java
@@ -23,19 +23,19 @@
 import static com.google.common.truth.Truth.assertThat;
 
 /**
- * Tests {@link SimpleLazilyInitializedProvider}.
+ * Tests {@link SingleCheck}.
  */
 @RunWith(JUnit4.class)
-public class SimpleLazilyInitializedProviderTest {
+public class SingleCheckTest {
   @Test(expected = NullPointerException.class)
   public void create_nullPointerException() {
-    SimpleLazilyInitializedProvider.create(null);
+    SingleCheck.provider(null);
   }
 
   @Test
   public void get() {
     Provider<Integer> provider =
-        SimpleLazilyInitializedProvider.create(
+        SingleCheck.provider(
             new Factory<Integer>() {
               int i = 0;
 
diff --git a/examples/android-activity-graphs/pom.xml b/examples/android-activity-graphs/pom.xml
index 8e9afd4b1..437f3e7f3 100644
--- a/examples/android-activity-graphs/pom.xml
+++ b/examples/android-activity-graphs/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.google.dagger.example</groupId>
     <artifactId>dagger-example-parent</artifactId>
-    <version>2.2-SNAPSHOT</version>
+    <version>2.4-SNAPSHOT</version>
   </parent>
 
   <artifactId>android-activity-graphs</artifactId>
diff --git a/examples/android-simple/pom.xml b/examples/android-simple/pom.xml
index 53f8dced3..77f8223b0 100644
--- a/examples/android-simple/pom.xml
+++ b/examples/android-simple/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.google.dagger.example</groupId>
     <artifactId>dagger-example-parent</artifactId>
-    <version>2.2-SNAPSHOT</version>
+    <version>2.4-SNAPSHOT</version>
   </parent>
 
   <artifactId>android-simple</artifactId>
diff --git a/examples/pom.xml b/examples/pom.xml
index 406e8d7f6..bfa34f454 100644
--- a/examples/pom.xml
+++ b/examples/pom.xml
@@ -21,7 +21,7 @@
   <parent>
     <groupId>com.google.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>2.2-SNAPSHOT</version>
+    <version>2.4-SNAPSHOT</version>
   </parent>
 
   <groupId>com.google.dagger.example</groupId>
diff --git a/examples/simple/pom.xml b/examples/simple/pom.xml
index e690d06d5..3b09104d0 100644
--- a/examples/simple/pom.xml
+++ b/examples/simple/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.google.dagger.example</groupId>
     <artifactId>dagger-example-parent</artifactId>
-    <version>2.2-SNAPSHOT</version>
+    <version>2.4-SNAPSHOT</version>
   </parent>
 
   <artifactId>simple</artifactId>
diff --git a/gwt/pom.xml b/gwt/pom.xml
index 841372c40..5851c158f 100644
--- a/gwt/pom.xml
+++ b/gwt/pom.xml
@@ -22,7 +22,7 @@
   <parent>
     <groupId>com.google.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>2.2-SNAPSHOT</version>
+    <version>2.4-SNAPSHOT</version>
   </parent>
 
   <artifactId>dagger-gwt</artifactId>
diff --git a/pom.xml b/pom.xml
index 0c73114ea..dde2b225d 100644
--- a/pom.xml
+++ b/pom.xml
@@ -27,7 +27,7 @@
   <groupId>com.google.dagger</groupId>
   <artifactId>dagger-parent</artifactId>
   <packaging>pom</packaging>
-  <version>2.2-SNAPSHOT</version>
+  <version>2.4-SNAPSHOT</version>
   <name>Dagger (Parent)</name>
   <description>A fast dependency injector for Android and Java.</description>
   <url>https://github.com/square/dagger</url>
@@ -47,11 +47,10 @@
     <java.version>1.7</java.version>
     <javax.inject.version>1</javax.inject.version>
     <javax.annotation.version>3.0.1</javax.annotation.version>
-    <javawriter.version>2.5.0</javawriter.version>
     <auto.common.version>0.6</auto.common.version>
     <auto.factory.version>1.0-beta3</auto.factory.version>
     <auto.service.version>1.0-rc2</auto.service.version>
-    <auto.value.version>1.1</auto.value.version>
+    <auto.value.version>1.2</auto.value.version>
     <errorprone.version>2.0.8</errorprone.version>
     <guava.version>19.0</guava.version>
     <google.java.format.version>0.1-alpha</google.java.format.version>
@@ -105,11 +104,6 @@
         <artifactId>jsr305</artifactId>
         <version>${javax.annotation.version}</version>
       </dependency>
-      <dependency>
-        <groupId>com.squareup</groupId>
-        <artifactId>javawriter</artifactId>
-        <version>${javawriter.version}</version>
-      </dependency>
       <dependency>
         <groupId>com.google.guava</groupId>
         <artifactId>guava</artifactId>
diff --git a/producers/pom.xml b/producers/pom.xml
index da5e87e39..1082e03f0 100644
--- a/producers/pom.xml
+++ b/producers/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.google.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>2.2-SNAPSHOT</version>
+    <version>2.4-SNAPSHOT</version>
   </parent>
 
   <artifactId>dagger-producers</artifactId>
diff --git a/producers/src/main/java/dagger/producers/monitoring/ProductionComponentMonitor.java b/producers/src/main/java/dagger/producers/monitoring/ProductionComponentMonitor.java
index 90e6d856a..af3164bac 100644
--- a/producers/src/main/java/dagger/producers/monitoring/ProductionComponentMonitor.java
+++ b/producers/src/main/java/dagger/producers/monitoring/ProductionComponentMonitor.java
@@ -28,7 +28,7 @@
  * <p>For example: <pre><code>
  *   {@literal @Module}
  *   final class MyMonitorModule {
- *     {@literal @Provides(type = SET)} ProductionComponentMonitor.Factory provideMonitorFactory(
+ *     {@literal @Provides @IntoSet} ProductionComponentMonitor.Factory provideMonitorFactory(
  *         MyProductionComponentMonitor.Factory monitorFactory) {
  *       return monitorFactory;
  *     }
diff --git a/producers/src/main/java/dagger/producers/package-info.java b/producers/src/main/java/dagger/producers/package-info.java
new file mode 100644
index 000000000..8cf2e28b5
--- /dev/null
+++ b/producers/src/main/java/dagger/producers/package-info.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * This package contains the public API for Dagger 2's producer functionality.
+ *
+ * <p>Dagger Producers is an extension to Dagger that implements asynchronous
+ * dependency injection in Java.
+ *
+ * <p>Extended documentation on Dagger Producers can be found at
+ * <a href="http://google.github.io/dagger/producers">
+ * google.github.io/dagger/producers</a>.
+ *
+ */
+package dagger.producers;
