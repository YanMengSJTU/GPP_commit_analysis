diff --git a/compiler/src/it/functional-tests/src/main/java/test/BasicComponent.java b/compiler/src/it/functional-tests/src/main/java/test/BasicComponent.java
index 0f8fe75bb..9ee15b5d2 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/BasicComponent.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/BasicComponent.java
@@ -16,6 +16,8 @@
 package test;
 
 import dagger.Component;
+import dagger.Lazy;
+import dagger.MembersInjector;
 import javax.inject.Provider;
 
 @Component(modules = PrimitivesModule.class)
@@ -69,6 +71,11 @@
 
   Thing thing();
   InjectedThing injectedThing();
+  Provider<InjectedThing> injectedThingProvider();
+  Lazy<InjectedThing> lazyInjectedThing();
+  MembersInjector<InjectedThing> injectedThingMembersInjector();
 
   TypeWithInheritedMembersInjection typeWithInheritedMembersInjection();
+  MembersInjector<TypeWithInheritedMembersInjection>
+      typeWithInheritedMembersInjectionMembersInjector();
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/InjectedThing.java b/compiler/src/it/functional-tests/src/main/java/test/InjectedThing.java
index a28a6ff2d..73a46e8aa 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/InjectedThing.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/InjectedThing.java
@@ -16,6 +16,7 @@
 package test;
 
 import dagger.Lazy;
+import dagger.MembersInjector;
 import javax.inject.Inject;
 import javax.inject.Provider;
 
@@ -87,6 +88,7 @@
   @Inject Thing thing;
   @Inject Provider<Thing> thingProvider;
   @Inject Lazy<Thing> lazyThing;
+  @Inject MembersInjector<Thing> thingMembersInjector;
 
   @Inject InjectedThing(
       byte primitiveByte,
@@ -154,7 +156,8 @@
 
       Thing thing,
       Provider<Thing> thingProvider,
-      Lazy<Thing> lazyThing) {}
+      Lazy<Thing> lazyThing,
+      MembersInjector<Thing> thingMembersInjector) {}
 
   @Inject void primitiveByte(byte primitiveByte) {}
   @Inject void primitiveChar(char primitiveChar) {}
@@ -222,4 +225,5 @@
   @Inject void thing(Thing thing) {}
   @Inject void thingProvider(Provider<Thing> thingProvider) {}
   @Inject void lazyThing(Lazy<Thing> lazyThing) {}
+  @Inject void thingMembersInjector(MembersInjector<Thing> thingMembersInjector) {}
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
index a2926cc22..69c9b3d74 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
@@ -29,7 +29,7 @@
 import com.google.common.collect.Sets;
 import dagger.Component;
 import dagger.Provides;
-import dagger.internal.codegen.ComponentDescriptor.ComponentMethodType;
+import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
 import dagger.producers.Produces;
 import dagger.producers.ProductionComponent;
 import java.util.Deque;
@@ -71,7 +71,6 @@
   }
 
   abstract ComponentDescriptor componentDescriptor();
-  abstract ImmutableSet<DependencyRequest> entryPoints();
   abstract ImmutableMap<TypeElement, ModuleStrategy> transitiveModules();
   abstract ImmutableMap<BindingKey, ResolvedBindings> resolvedBindings();
   abstract ImmutableMap<ExecutableElement, BindingGraph> subgraphs();
@@ -223,13 +222,11 @@ private BindingGraph create(Optional<RequestResolver> parentResolver,
           componentDescriptor.wrappedScope(),
           explicitBindingsByKey(explicitProvisionBindingsBuilder.build()),
           explicitBindingsByKey(explicitProductionBindingsBuilder.build()));
-      ImmutableSetMultimap<ComponentMethodType, ExecutableElement> componentMethods =
-          componentDescriptor.componentMethods();
-
-      ImmutableSet<DependencyRequest> componentMethodRequests =
-          componentMethodRequests(componentMethods);
-      for (DependencyRequest componentMethodRequest : componentMethodRequests) {
-        requestResolver.resolve(componentMethodRequest);
+      for (ComponentMethodDescriptor componentMethod : componentDescriptor.componentMethods()) {
+        Optional<DependencyRequest> componentMethodRequest = componentMethod.dependencyRequest();
+        if (componentMethodRequest.isPresent()) {
+          requestResolver.resolve(componentMethodRequest.get());
+        }
       }
 
       ImmutableMap.Builder<ExecutableElement, BindingGraph> subgraphsBuilder =
@@ -242,7 +239,6 @@ private BindingGraph create(Optional<RequestResolver> parentResolver,
 
       return new AutoValue_BindingGraph(
           componentDescriptor,
-          componentMethodRequests,
           transitiveModules.build(),
           requestResolver.getResolvedBindings(),
           subgraphsBuilder.build());
@@ -258,26 +254,6 @@ private BindingGraph create(Optional<RequestResolver> parentResolver,
       return builder.build();
     }
 
-    private ImmutableSet<DependencyRequest> componentMethodRequests(
-        ImmutableSetMultimap<ComponentMethodType, ExecutableElement> componentMethods) {
-      ImmutableSet.Builder<DependencyRequest> interfaceRequestsBuilder = ImmutableSet.builder();
-      for (ExecutableElement provisionMethod : componentMethods.get(ComponentMethodType.PROVISON)) {
-        interfaceRequestsBuilder.add(
-            dependencyRequestFactory.forComponentProvisionMethod(provisionMethod));
-      }
-      for (ExecutableElement productionMethod :
-          componentMethods.get(ComponentMethodType.PRODUCTION)) {
-        interfaceRequestsBuilder.add(
-            dependencyRequestFactory.forComponentProductionMethod(productionMethod));
-      }
-      for (ExecutableElement membersInjectionMethod :
-          componentMethods.get(ComponentMethodType.MEMBERS_INJECTION)) {
-        interfaceRequestsBuilder.add(
-            dependencyRequestFactory.forComponentMembersInjectionMethod(membersInjectionMethod));
-      }
-      return interfaceRequestsBuilder.build();
-    }
-
     private final class RequestResolver {
       final Optional<RequestResolver> parentResolver;
       final Optional<Equivalence.Wrapper<AnnotationMirror>> targetScope;
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
index a1e0b6962..e886353ed 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -35,6 +35,7 @@
 import com.google.common.collect.Sets;
 import dagger.Component;
 import dagger.internal.codegen.BindingGraph.ResolvedBindings;
+import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
 import dagger.internal.codegen.ContributionBinding.BindingType;
 import dagger.internal.codegen.ValidationReport.Builder;
 import dagger.internal.codegen.writer.TypeNames;
@@ -117,8 +118,13 @@
     validateComponentScope(subject, reportBuilder, resolvedBindings);
     validateDependencyScopes(subject, reportBuilder);
 
-    for (DependencyRequest entryPoint : subject.entryPoints()) {
-      traverseRequest(entryPoint, new ArrayDeque<ResolvedRequest>(), subject, reportBuilder);
+    for (ComponentMethodDescriptor componentMethod :
+        subject.componentDescriptor().componentMethods()) {
+      Optional<DependencyRequest> entryPoint = componentMethod.dependencyRequest();
+      if (entryPoint.isPresent()) {
+        traverseRequest(entryPoint.get(), new ArrayDeque<ResolvedRequest>(), subject,
+            reportBuilder);
+      }
     }
 
     validateSubcomponents(subject, reportBuilder);
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
index e2a2eb605..218e3b340 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
@@ -23,16 +23,18 @@
 import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.ImmutableSetMultimap;
 import com.google.common.collect.Lists;
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.Component;
+import dagger.Lazy;
+import dagger.MembersInjector;
 import dagger.Subcomponent;
 import dagger.producers.ProductionComponent;
 import java.lang.annotation.Annotation;
 import java.util.Iterator;
 import java.util.List;
 import java.util.concurrent.Executor;
+import javax.inject.Provider;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.Modifier;
@@ -120,9 +122,16 @@
 
   abstract ImmutableMap<ExecutableElement, ComponentDescriptor> subcomponents();
 
-  abstract ImmutableSetMultimap<ComponentMethodType, ExecutableElement> componentMethods();
+  abstract ImmutableSet<ComponentMethodDescriptor> componentMethods();
 
-  enum ComponentMethodType {
+  @AutoValue
+  static abstract class ComponentMethodDescriptor {
+    abstract ComponentMethodKind kind();
+    abstract Optional<DependencyRequest> dependencyRequest();
+    abstract ExecutableElement methodElement();
+  }
+
+  enum ComponentMethodKind {
     PROVISON,
     PRODUCTION,
     MEMBERS_INJECTION,
@@ -131,9 +140,11 @@
 
   static final class Factory {
     private final Elements elements;
+    private final DependencyRequest.Factory dependencyRequestFactory;
 
-    Factory(Elements elements) {
+    Factory(Elements elements, DependencyRequest.Factory dependencyRequestFactory) {
       this.elements = elements;
+      this.dependencyRequestFactory = dependencyRequestFactory;
     }
 
     ComponentDescriptor forComponent(TypeElement componentDefinitionType) {
@@ -175,16 +186,16 @@ private ComponentDescriptor create(TypeElement componentDefinitionType, Kind kin
       ImmutableSet<ExecutableElement> unimplementedMethods =
           getUnimplementedMethods(elements, componentDefinitionType);
 
-      ImmutableSetMultimap.Builder<ComponentMethodType, ExecutableElement> componentMethodsBuilder =
-          ImmutableSetMultimap.builder();
+      ImmutableSet.Builder<ComponentMethodDescriptor> componentMethodsBuilder =
+          ImmutableSet.builder();
 
       ImmutableMap.Builder<ExecutableElement, ComponentDescriptor> subcomponentDescriptors =
           ImmutableMap.builder();
       for (ExecutableElement componentMethod : unimplementedMethods) {
-        ComponentMethodType componentMethodType =
-            getComponentMethodType(kind, componentMethod);
-        componentMethodsBuilder.put(componentMethodType, componentMethod);
-        if (componentMethodType.equals(ComponentMethodType.SUBCOMPONENT)) {
+        ComponentMethodDescriptor componentMethodDescriptor =
+            getDescriptorForComponentMethod(kind, componentMethod);
+        componentMethodsBuilder.add(componentMethodDescriptor);
+        if (componentMethodDescriptor.kind().equals(ComponentMethodKind.SUBCOMPONENT)) {
           subcomponentDescriptors.put(componentMethod,
               create(MoreElements.asType(MoreTypes.asElement(componentMethod.getReturnType())),
                   Kind.COMPONENT));
@@ -203,36 +214,64 @@ private ComponentDescriptor create(TypeElement componentDefinitionType, Kind kin
           subcomponentDescriptors.build(),
           componentMethodsBuilder.build());
     }
-  }
 
-  private static ComponentMethodType getComponentMethodType(Kind componentKind,
-      ExecutableElement method) {
-    TypeMirror returnType = method.getReturnType();
-    if (returnType.getKind().equals(DECLARED) &&
-        getAnnotationMirror(MoreTypes.asElement(returnType), Subcomponent.class).isPresent()) {
-      return ComponentMethodType.SUBCOMPONENT;
-    }
+    private ComponentMethodDescriptor getDescriptorForComponentMethod(Kind componentKind,
+        ExecutableElement componentMethod) {
+      TypeMirror returnType = componentMethod.getReturnType();
+      if (returnType.getKind().equals(DECLARED)) {
+        if (MoreTypes.isTypeOf(Provider.class, returnType)
+            || MoreTypes.isTypeOf(Lazy.class, returnType)) {
+          return new AutoValue_ComponentDescriptor_ComponentMethodDescriptor(
+              ComponentMethodKind.PROVISON,
+              Optional.of(dependencyRequestFactory.forComponentProvisionMethod(componentMethod)),
+              componentMethod);
+        } else if (MoreTypes.isTypeOf(MembersInjector.class, returnType)) {
+          return new AutoValue_ComponentDescriptor_ComponentMethodDescriptor(
+              ComponentMethodKind.MEMBERS_INJECTION,
+              Optional.of(dependencyRequestFactory.forComponentMembersInjectionMethod(
+                  componentMethod)),
+              componentMethod);
+        } else if (getAnnotationMirror(MoreTypes.asElement(returnType), Subcomponent.class)
+            .isPresent()) {
+          return new AutoValue_ComponentDescriptor_ComponentMethodDescriptor(
+              ComponentMethodKind.SUBCOMPONENT,
+              Optional.<DependencyRequest>absent(),
+              componentMethod);
+        }
+      }
 
-    if (method.getParameters().isEmpty()
-        && !method.getReturnType().getKind().equals(VOID)) {
-      switch (componentKind) {
-        case COMPONENT:
-          return ComponentMethodType.PROVISON;
-        case PRODUCTION_COMPONENT:
-          return ComponentMethodType.PRODUCTION;
-        default:
-          throw new AssertionError();
+      // a typical provision method
+      if (componentMethod.getParameters().isEmpty()
+          && !componentMethod.getReturnType().getKind().equals(VOID)) {
+        switch (componentKind) {
+          case COMPONENT:
+            return new AutoValue_ComponentDescriptor_ComponentMethodDescriptor(
+                ComponentMethodKind.PROVISON,
+                Optional.of(dependencyRequestFactory.forComponentProvisionMethod(componentMethod)),
+                componentMethod);
+          case PRODUCTION_COMPONENT:
+            return new AutoValue_ComponentDescriptor_ComponentMethodDescriptor(
+                ComponentMethodKind.PRODUCTION,
+                Optional.of(dependencyRequestFactory.forComponentProductionMethod(componentMethod)),
+                componentMethod);
+          default:
+            throw new AssertionError();
+        }
       }
-    }
 
-    List<? extends VariableElement> parameters = method.getParameters();
-    if (parameters.size() == 1
-        && (returnType.getKind().equals(VOID)
-            || MoreTypes.equivalence().equivalent(returnType, parameters.get(0).asType()))) {
-      return ComponentMethodType.MEMBERS_INJECTION;
-    }
+      List<? extends VariableElement> parameters = componentMethod.getParameters();
+      if (parameters.size() == 1
+          && (returnType.getKind().equals(VOID)
+              || MoreTypes.equivalence().equivalent(returnType, parameters.get(0).asType()))) {
+        return new AutoValue_ComponentDescriptor_ComponentMethodDescriptor(
+            ComponentMethodKind.MEMBERS_INJECTION,
+            Optional.of(dependencyRequestFactory.forComponentMembersInjectionMethod(
+                componentMethod)),
+            componentMethod);
+      }
 
-    throw new IllegalArgumentException();
+      throw new IllegalArgumentException("not a valid component method: " + componentMethod);
+    }
   }
 
   static boolean isComponentContributionMethod(Elements elements, ExecutableElement method) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
index f18ae164c..17d079c10 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
@@ -46,6 +46,7 @@
 import dagger.internal.ScopedProvider;
 import dagger.internal.SetFactory;
 import dagger.internal.codegen.BindingGraph.ResolvedBindings;
+import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
 import dagger.internal.codegen.ContributionBinding.BindingType;
 import dagger.internal.codegen.writer.ClassName;
 import dagger.internal.codegen.writer.ClassWriter;
@@ -655,63 +656,74 @@ private void writeInterfaceMethods(BindingGraph input, ClassWriter componentWrit
       ImmutableSet<BindingKey> enumBindingKeys) throws AssertionError {
     Set<MethodSignature> interfaceMethods = Sets.newHashSet();
 
-    for (DependencyRequest interfaceRequest : input.entryPoints()) {
-      ExecutableElement requestElement =
-          MoreElements.asExecutable(interfaceRequest.requestElement());
-      MethodSignature signature = MethodSignature.fromExecutableElement(requestElement);
-      if (!interfaceMethods.contains(signature)) {
-        interfaceMethods.add(signature);
-        MethodWriter interfaceMethod = requestElement.getReturnType().getKind().equals(VOID)
-            ? componentWriter.addMethod(VoidName.VOID, requestElement.getSimpleName().toString())
-                : componentWriter.addMethod(requestElement.getReturnType(),
-                    requestElement.getSimpleName().toString());
-        interfaceMethod.annotate(Override.class);
-        interfaceMethod.addModifiers(PUBLIC);
-        BindingKey bindingKey = interfaceRequest.bindingKey();
-        switch(interfaceRequest.kind()) {
-          case MEMBERS_INJECTOR:
-            MemberSelect membersInjectorSelect = memberSelectSnippets.get(bindingKey);
-            VariableElement parameter = Iterables.getOnlyElement(requestElement.getParameters());
-            Name parameterName = parameter.getSimpleName();
-            interfaceMethod.addParameter(
-                TypeNames.forTypeMirror(parameter.asType()), parameterName.toString());
-            interfaceMethod.body()
+    for (ComponentMethodDescriptor componentMethod :
+        input.componentDescriptor().componentMethods()) {
+      if (componentMethod.dependencyRequest().isPresent()) {
+        DependencyRequest interfaceRequest = componentMethod.dependencyRequest().get();
+        ExecutableElement requestElement =
+            MoreElements.asExecutable(interfaceRequest.requestElement());
+        MethodSignature signature = MethodSignature.fromExecutableElement(requestElement);
+        if (!interfaceMethods.contains(signature)) {
+          interfaceMethods.add(signature);
+          MethodWriter interfaceMethod = requestElement.getReturnType().getKind().equals(VOID)
+              ? componentWriter.addMethod(VoidName.VOID, requestElement.getSimpleName().toString())
+                  : componentWriter.addMethod(requestElement.getReturnType(),
+                      requestElement.getSimpleName().toString());
+          interfaceMethod.annotate(Override.class);
+          interfaceMethod.addModifiers(PUBLIC);
+          BindingKey bindingKey = interfaceRequest.bindingKey();
+          switch(interfaceRequest.kind()) {
+            case MEMBERS_INJECTOR:
+              MemberSelect membersInjectorSelect = memberSelectSnippets.get(bindingKey);
+              List<? extends VariableElement> parameters = requestElement.getParameters();
+              if (parameters.isEmpty()) {
+                // we're returning the framework type
+                interfaceMethod.body().addSnippet("return %s;",
+                    membersInjectorSelect.getSnippetFor(componentWriter.name()));
+              } else {
+                VariableElement parameter = Iterables.getOnlyElement(parameters);
+                Name parameterName = parameter.getSimpleName();
+                interfaceMethod.addParameter(
+                    TypeNames.forTypeMirror(parameter.asType()), parameterName.toString());
+                interfaceMethod.body()
                 .addSnippet("%s.injectMembers(%s);",
                     // in this case we know we won't need the cast because we're never going to pass
                     // the reference to anything
                     membersInjectorSelect.getSnippetFor(componentWriter.name()),
                     parameterName);
-            if (!requestElement.getReturnType().getKind().equals(VOID)) {
-              interfaceMethod.body().addSnippet("return %s;", parameterName);
-            }
-            break;
-          case INSTANCE:
-            if (enumBindingKeys.contains(bindingKey)
-                && !MoreTypes.asDeclared(bindingKey.key().type())
-                        .getTypeArguments().isEmpty()) {
-              // If using a parameterized enum type, then we need to store the factory
-              // in a temporary variable, in order to help javac be able to infer
-              // the generics of the Factory.create methods.
-              TypeName factoryType = ParameterizedTypeName.create(Provider.class,
-                  TypeNames.forTypeMirror(requestElement.getReturnType()));
-              interfaceMethod.body().addSnippet("%s factory = %s;", factoryType,
-                  memberSelectSnippets.get(bindingKey).getSnippetFor(componentWriter.name()));
-              interfaceMethod.body().addSnippet("return factory.get();");
+                if (!requestElement.getReturnType().getKind().equals(VOID)) {
+                  interfaceMethod.body().addSnippet("return %s;", parameterName);
+                }
+              }
               break;
-            }
-            // fall through in the else case.
-          case LAZY:
-          case PRODUCED:
-          case PRODUCER:
-          case PROVIDER:
-          case FUTURE:
-            interfaceMethod.body().addSnippet("return %s;",
-                frameworkTypeUsageStatement(
-                    memberSelectSnippets.get(bindingKey).getSnippetFor(componentWriter.name()),
-                    interfaceRequest.kind()));
-            break;
-          default:
-            throw new AssertionError();
+            case INSTANCE:
+              if (enumBindingKeys.contains(bindingKey)
+                  && !MoreTypes.asDeclared(bindingKey.key().type())
+                          .getTypeArguments().isEmpty()) {
+                // If using a parameterized enum type, then we need to store the factory
+                // in a temporary variable, in order to help javac be able to infer
+                // the generics of the Factory.create methods.
+                TypeName factoryType = ParameterizedTypeName.create(Provider.class,
+                    TypeNames.forTypeMirror(requestElement.getReturnType()));
+                interfaceMethod.body().addSnippet("%s factory = %s;", factoryType,
+                    memberSelectSnippets.get(bindingKey).getSnippetFor(componentWriter.name()));
+                interfaceMethod.body().addSnippet("return factory.get();");
+                break;
+              }
+              // fall through in the else case.
+            case LAZY:
+            case PRODUCED:
+            case PRODUCER:
+            case PROVIDER:
+            case FUTURE:
+              interfaceMethod.body().addSnippet("return %s;",
+                  frameworkTypeUsageStatement(
+                      memberSelectSnippets.get(bindingKey).getSnippetFor(componentWriter.name()),
+                      interfaceRequest.kind()));
+              break;
+            default:
+              throw new AssertionError();
+          }
         }
       }
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
index 86c4ffa89..fa18be53d 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -117,7 +117,7 @@ public SourceVersion getSupportedSourceVersion() {
         membersInjectionBindingFactory, membersInjectorGenerator);
 
     ComponentDescriptor.Factory componentDescriptorFactory =
-        new ComponentDescriptor.Factory(elements);
+        new ComponentDescriptor.Factory(elements, dependencyRequestFactory);
 
     BindingGraph.Factory bindingGraphFactory = new BindingGraph.Factory(
         elements, types, injectBindingRegistry, keyFactory,
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
index 9e36418fd..9b42030e8 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
@@ -44,6 +44,7 @@
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
+import static javax.lang.model.type.TypeKind.DECLARED;
 
 /**
  * Represents a request for a key at an injection point. Parameters to {@link Inject} constructors
@@ -200,12 +201,23 @@ DependencyRequest forComponentMembersInjectionMethod(ExecutableElement membersIn
       Optional<AnnotationMirror> qualifier =
           InjectionAnnotations.getQualifier(membersInjectionMethod);
       checkArgument(!qualifier.isPresent());
-      return new AutoValue_DependencyRequest(Kind.MEMBERS_INJECTOR,
-          keyFactory.forMembersInjectedType(
-              Iterables.getOnlyElement(membersInjectionMethod.getParameters()).asType()),
-          membersInjectionMethod,
-          getEnclosingType(membersInjectionMethod),
-          false /* doesn't allow null */);
+      TypeMirror returnType = membersInjectionMethod.getReturnType();
+      if (returnType.getKind().equals(DECLARED)
+          && MoreTypes.isTypeOf(MembersInjector.class, returnType)) {
+        return new AutoValue_DependencyRequest(Kind.MEMBERS_INJECTOR,
+            keyFactory.forMembersInjectedType(
+                Iterables.getOnlyElement(((DeclaredType) returnType).getTypeArguments())),
+                membersInjectionMethod,
+                getEnclosingType(membersInjectionMethod),
+                false /* doesn't allow null */);
+      } else {
+        return new AutoValue_DependencyRequest(Kind.MEMBERS_INJECTOR,
+            keyFactory.forMembersInjectedType(
+                Iterables.getOnlyElement(membersInjectionMethod.getParameters()).asType()),
+                membersInjectionMethod,
+                getEnclosingType(membersInjectionMethod),
+                false /* doesn't allow null */);
+      }
     }
 
     DependencyRequest forMembersInjectedType(DeclaredType type) {
