diff --git a/java/dagger/internal/codegen/AbstractComponentWriter.java b/java/dagger/internal/codegen/AbstractComponentWriter.java
index 42a07c716..940f654a5 100644
--- a/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -29,7 +29,6 @@
 import static com.squareup.javapoet.TypeSpec.classBuilder;
 import static dagger.internal.codegen.Accessibility.isTypeAccessibleFrom;
 import static dagger.internal.codegen.AnnotationSpecs.Suppression.UNCHECKED;
-import static dagger.internal.codegen.BindingKey.contribution;
 import static dagger.internal.codegen.BindingType.PRODUCTION;
 import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
 import static dagger.internal.codegen.ContributionBinding.Kind.INJECTION;
@@ -322,60 +321,24 @@ protected final ClassName builderName() {
   protected abstract void addFactoryMethods();
 
   /**
-   * Adds a {@link dagger.internal.ReferenceReleasingProviderManager} field for every {@link
-   * CanReleaseReferences @ReleasableReferences} scope for which {@linkplain
-   * #requiresReleasableReferences(Scope) one is required}.
+   * Adds a {@link dagger.internal.ReferenceReleasingProviderManager} field for every scope for
+   * which {@linkplain BindingGraph#scopesRequiringReleasableReferenceManagers() one is required}.
    */
   private void addReferenceReleasingProviderManagerFields() {
     ImmutableMap.Builder<Scope, MemberSelect> fields = ImmutableMap.builder();
-    for (Scope scope : graph.componentDescriptor().releasableReferencesScopes()) {
-      if (requiresReleasableReferences(scope)) {
-        FieldSpec field = referenceReleasingProxyManagerField(scope);
-        component.addField(field);
-        fields.put(scope, localField(name, field.name));
-      }
+    for (Scope scope : graph.scopesRequiringReleasableReferenceManagers()) {
+      FieldSpec field = referenceReleasingProxyManagerField(scope);
+      component.addField(field);
+      fields.put(scope, localField(name, field.name));
     }
     referenceReleasingProviderManagerFields = fields.build();
   }
 
   /**
-   * Returns {@code true} if {@code scope} {@linkplain CanReleaseReferences can release its
-   * references} and there is a dependency request in the component for any of
-   *
-   * <ul>
-   * <li>{@code @ForReleasableReferences(scope)} {@link ReleasableReferenceManager}
-   * <li>{@code @ForReleasableReferences(scope)} {@code TypedReleasableReferenceManager<M>}, where
-   *     {@code M} is the releasable-references metatadata type for {@code scope}
-   * <li>{@code Set<ReleasableReferenceManager>}
-   * <li>{@code Set<TypedReleasableReferenceManager<M>>}, where {@code M} is the metadata type for
-   *     the scope
-   * </ul>
+   * Returns {@code true} if {@code scope} is in {@link
+   * BindingGraph#scopesRequiringReleasableReferenceManagers()} for the root graph.
    */
-  private boolean requiresReleasableReferences(Scope scope) {
-    if (!scope.canReleaseReferences()) {
-      return false;
-    }
-
-    if (graphHasContributionBinding(keyFactory.forReleasableReferenceManager(scope))
-        || graphHasContributionBinding(keyFactory.forSetOfReleasableReferenceManagers())) {
-      return true;
-    }
-
-    for (AnnotationMirror metadata : scope.releasableReferencesMetadata()) {
-      if (graphHasContributionBinding(
-              keyFactory.forTypedReleasableReferenceManager(scope, metadata.getAnnotationType()))
-          || graphHasContributionBinding(
-              keyFactory.forSetOfTypedReleasableReferenceManagers(metadata.getAnnotationType()))) {
-        return true;
-      }
-    }
-
-    return false;
-  }
-
-  private boolean graphHasContributionBinding(Key key) {
-    return graph.resolvedBindings().containsKey(contribution(key));
-  }
+  protected abstract boolean requiresReleasableReferences(Scope scope);
 
   private FieldSpec referenceReleasingProxyManagerField(Scope scope) {
     return componentField(
diff --git a/java/dagger/internal/codegen/BindingGraph.java b/java/dagger/internal/codegen/BindingGraph.java
index ba01bb723..110d08ea0 100644
--- a/java/dagger/internal/codegen/BindingGraph.java
+++ b/java/dagger/internal/codegen/BindingGraph.java
@@ -20,7 +20,6 @@
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Verify.verify;
 import static com.google.common.collect.Iterables.isEmpty;
-import static dagger.internal.codegen.BindingKey.contribution;
 import static dagger.internal.codegen.ComponentDescriptor.Kind.PRODUCTION_COMPONENT;
 import static dagger.internal.codegen.ComponentDescriptor.isComponentContributionMethod;
 import static dagger.internal.codegen.ComponentDescriptor.isComponentProductionMethod;
@@ -55,6 +54,8 @@
 import dagger.internal.codegen.Key.HasKey;
 import dagger.producers.Produced;
 import dagger.producers.Producer;
+import dagger.releasablereferences.CanReleaseReferences;
+import dagger.releasablereferences.ReleasableReferenceManager;
 import java.util.ArrayDeque;
 import java.util.Collection;
 import java.util.Deque;
@@ -87,6 +88,23 @@
   abstract ImmutableMap<BindingKey, ResolvedBindings> resolvedBindings();
   abstract ImmutableSet<BindingGraph> subgraphs();
 
+  /**
+   * The scopes in the graph that {@linkplain CanReleaseReferences can release their references} for
+   * which there is a dependency request for any of the following:
+   *
+   * <ul>
+   *   <li>{@code @ForReleasableReferences(scope)} {@link ReleasableReferenceManager}
+   *   <li>{@code @ForReleasableReferences(scope)} {@code TypedReleasableReferenceManager<M>}, where
+   *       {@code M} is the releasable-references metatadata type for {@code scope}
+   *   <li>{@code Set<ReleasableReferenceManager>}
+   *   <li>{@code Set<TypedReleasableReferenceManager<M>>}, where {@code M} is the metadata type for
+   *       the scope
+   * </ul>
+   *
+   * <p>This set is always empty for subcomponent graphs.
+   */
+  abstract ImmutableSet<Scope> scopesRequiringReleasableReferenceManagers();
+
   /** Returns the resolved bindings for the dependencies of {@code binding}. */
   ImmutableSet<ResolvedBindings> resolvedDependencies(ContributionBinding binding) {
     return binding
@@ -283,33 +301,9 @@ private BindingGraph create(
         optionalsBuilder.addAll(moduleDescriptor.optionalDeclarations());
       }
 
-      // TODO(dpb,gak): Do we need to bind an empty Set<ReleasableReferenceManager> if there are
-      // none?
-      for (Scope scope : componentDescriptor.releasableReferencesScopes()) {
-        // Add a binding for @ForReleasableReferences(scope) ReleasableReferenceManager.
-        explicitBindingsBuilder.add(
-            provisionBindingFactory.provideReleasableReferenceManager(scope));
-
-        /* Add a binding for Set<ReleasableReferenceManager>. Even if these are added more than
-         * once, each instance will be equal to the rest. Since they're being added to a set, there
-         * will be only one instance. */
-        explicitBindingsBuilder.add(
-            provisionBindingFactory.provideSetOfReleasableReferenceManagers());
-
-        for (AnnotationMirror metadata : scope.releasableReferencesMetadata()) {
-          // Add a binding for @ForReleasableReferences(scope) TypedReleasableReferenceManager<M>.
-          explicitBindingsBuilder.add(
-              provisionBindingFactory.provideTypedReleasableReferenceManager(
-                  scope, metadata.getAnnotationType()));
-
-          /* Add a binding for Set<TypedReleasableReferenceManager<M>>. Even if these are added more
-           * than once, each instance will be equal to the rest. Since they're being added to a set,
-           * there will be only one instance. */
-          explicitBindingsBuilder.add(
-              provisionBindingFactory.provideSetOfTypedReleasableReferenceManagers(
-                  metadata.getAnnotationType()));
-        }
-      }
+      ImmutableSetMultimap<Scope, ProvisionBinding> releasableReferenceManagerBindings =
+          getReleasableReferenceManagerBindings(componentDescriptor);
+      explicitBindingsBuilder.addAll(releasableReferenceManagerBindings.values());
 
       final Resolver requestResolver =
           new Resolver(
@@ -341,7 +335,9 @@ private BindingGraph create(
         }
       }
 
-      for (ResolvedBindings resolvedBindings : requestResolver.getResolvedBindings().values()) {
+      ImmutableMap<BindingKey, ResolvedBindings> resolvedBindingsMap =
+          requestResolver.getResolvedBindings();
+      for (ResolvedBindings resolvedBindings : resolvedBindingsMap.values()) {
         verify(
             resolvedBindings.owningComponent().equals(componentDescriptor),
             "%s is not owned by %s",
@@ -351,11 +347,77 @@ private BindingGraph create(
 
       return new AutoValue_BindingGraph(
           componentDescriptor,
-          requestResolver.getResolvedBindings(),
+          resolvedBindingsMap,
           subgraphs.build(),
+          getScopesRequiringReleasableReferenceManagers(
+              releasableReferenceManagerBindings, resolvedBindingsMap),
           requestResolver.getOwnedModules());
     }
 
+    /**
+     * Returns the bindings for {@link ReleasableReferenceManager}s for all {@link
+     * CanReleaseReferences @CanReleaseReferences} scopes.
+     */
+    private ImmutableSetMultimap<Scope, ProvisionBinding> getReleasableReferenceManagerBindings(
+        ComponentDescriptor componentDescriptor) {
+      ImmutableSetMultimap.Builder<Scope, ProvisionBinding> bindings =
+          ImmutableSetMultimap.builder();
+      // TODO(dpb,gak): Do we need to bind an empty Set<ReleasableReferenceManager> if there are
+      // none?
+      for (Scope scope : componentDescriptor.releasableReferencesScopes()) {
+        // Add a binding for @ForReleasableReferences(scope) ReleasableReferenceManager.
+        bindings.put(scope, provisionBindingFactory.provideReleasableReferenceManager(scope));
+
+        /* Add a binding for Set<ReleasableReferenceManager>. Even if these are added more than
+         * once, each instance will be equal to the rest. Since they're being added to a set, there
+         * will be only one instance. */
+        bindings.put(scope, provisionBindingFactory.provideSetOfReleasableReferenceManagers());
+
+        for (AnnotationMirror metadata : scope.releasableReferencesMetadata()) {
+          // Add a binding for @ForReleasableReferences(scope) TypedReleasableReferenceManager<M>.
+          bindings.put(
+              scope,
+              provisionBindingFactory.provideTypedReleasableReferenceManager(
+                  scope, metadata.getAnnotationType()));
+
+          /* Add a binding for Set<TypedReleasableReferenceManager<M>>. Even if these are added more
+           * than once, each instance will be equal to the rest. Since they're being added to a set,
+           * there will be only one instance. */
+          bindings.put(
+              scope,
+              provisionBindingFactory.provideSetOfTypedReleasableReferenceManagers(
+                  metadata.getAnnotationType()));
+        }
+      }
+      return bindings.build();
+    }
+
+    /**
+     * Returns the set of scopes that will be returned by {@link
+     * BindingGraph#scopesRequiringReleasableReferenceManagers()}.
+     *
+     * @param releasableReferenceManagerBindings the {@link ReleasableReferenceManager} bindings for
+     *     each scope
+     * @param resolvedBindingsMap the resolved bindings for the component
+     */
+    private ImmutableSet<Scope> getScopesRequiringReleasableReferenceManagers(
+        ImmutableSetMultimap<Scope, ProvisionBinding> releasableReferenceManagerBindings,
+        ImmutableMap<BindingKey, ResolvedBindings> resolvedBindingsMap) {
+      ImmutableSet.Builder<Scope> scopes = ImmutableSet.builder();
+      releasableReferenceManagerBindings
+          .asMap()
+          .forEach(
+              (scope, bindings) -> {
+                for (Binding binding : bindings) {
+                  if (resolvedBindingsMap.containsKey(BindingKey.contribution(binding.key()))) {
+                    scopes.add(scope);
+                    return;
+                  }
+                }
+              });
+      return scopes.build();
+    }
+
     private final class Resolver {
       final Optional<Resolver> parentResolver;
       final ComponentDescriptor componentDescriptor;
@@ -659,7 +721,7 @@ private boolean multibindingsRequireProduction(
         DependencyRequest.Kind kind =
             DependencyRequest.extractKindAndType(OptionalType.from(key).valueType()).kind();
         ResolvedBindings underlyingKeyBindings =
-            lookUpBindings(contribution(keyFactory.unwrapOptional(key).get()));
+            lookUpBindings(BindingKey.contribution(keyFactory.unwrapOptional(key).get()));
         if (underlyingKeyBindings.isEmpty()) {
           return Optional.of(provisionBindingFactory.syntheticAbsentBinding(key));
         } else if (underlyingKeyBindings.bindingTypes().contains(BindingType.PRODUCTION)
diff --git a/java/dagger/internal/codegen/ComponentWriter.java b/java/dagger/internal/codegen/ComponentWriter.java
index 8bb273ab8..529d17537 100644
--- a/java/dagger/internal/codegen/ComponentWriter.java
+++ b/java/dagger/internal/codegen/ComponentWriter.java
@@ -229,4 +229,9 @@ private boolean canInstantiateAllRequirements() {
         graph.componentRequirements(),
         dependency -> dependency.requiresAPassedInstance(elements, types));
   }
+
+  @Override
+  protected boolean requiresReleasableReferences(Scope scope) {
+    return graph.scopesRequiringReleasableReferenceManagers().contains(scope);
+  }
 }
diff --git a/java/dagger/internal/codegen/ProvisionBinding.java b/java/dagger/internal/codegen/ProvisionBinding.java
index 12f43dad1..6d40e97ec 100644
--- a/java/dagger/internal/codegen/ProvisionBinding.java
+++ b/java/dagger/internal/codegen/ProvisionBinding.java
@@ -384,7 +384,7 @@ ProvisionBinding provideReleasableReferenceManager(Scope scope) {
      * TypedReleasableReferenceManager<metadataType>} that provides the component-instantiated
      * object.
      */
-    ContributionBinding provideTypedReleasableReferenceManager(
+    ProvisionBinding provideTypedReleasableReferenceManager(
         Scope scope, DeclaredType metadataType) {
       return provideReleasableReferenceManager(scope)
           .toBuilder()
@@ -404,7 +404,7 @@ ProvisionBinding provideSetOfReleasableReferenceManagers() {
     /**
      * Returns a synthetic binding for {@code Set<TypedReleasableReferenceManager<metadataType>}.
      */
-    ContributionBinding provideSetOfTypedReleasableReferenceManagers(DeclaredType metadataType) {
+    ProvisionBinding provideSetOfTypedReleasableReferenceManagers(DeclaredType metadataType) {
       return provideSetOfReleasableReferenceManagers()
           .toBuilder()
           .key(keyFactory.forSetOfTypedReleasableReferenceManagers(metadataType))
diff --git a/java/dagger/internal/codegen/SubcomponentWriter.java b/java/dagger/internal/codegen/SubcomponentWriter.java
index 739e3c4b5..c53030770 100644
--- a/java/dagger/internal/codegen/SubcomponentWriter.java
+++ b/java/dagger/internal/codegen/SubcomponentWriter.java
@@ -78,6 +78,11 @@ protected CodeBlock getReferenceReleasingProviderManagerExpression(Scope scope)
     return parent.getReferenceReleasingProviderManagerExpression(scope);
   }
 
+  @Override
+  protected boolean requiresReleasableReferences(Scope scope) {
+    return parent.requiresReleasableReferences(scope);
+  }
+
   private ExecutableType resolvedSubcomponentFactoryMethod() {
     checkState(
         subcomponentFactoryMethod.isPresent(),
