diff --git a/java/dagger/internal/codegen/BUILD b/java/dagger/internal/codegen/BUILD
index 77e8c7d0b..45a0c0c28 100644
--- a/java/dagger/internal/codegen/BUILD
+++ b/java/dagger/internal/codegen/BUILD
@@ -62,7 +62,6 @@ java_library(
     srcs = [
         "Accessibility.java",
         "AnnotationSpecs.java",
-        "BindingKey.java",
         "CodeBlocks.java",
         "CompilerOptions.java",
         "ContributionType.java",
diff --git a/java/dagger/internal/codegen/BindingGraphValidator.java b/java/dagger/internal/codegen/BindingGraphValidator.java
index 05f13471b..ae07793d8 100644
--- a/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -98,6 +98,7 @@
 import dagger.MapKey;
 import dagger.internal.codegen.ComponentDescriptor.BuilderRequirementMethod;
 import dagger.internal.codegen.ComponentDescriptor.BuilderSpec;
+import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
 import dagger.internal.codegen.ComponentRequirement.NullPolicy;
 import dagger.internal.codegen.ContributionType.HasContributionType;
 import dagger.model.Key;
@@ -183,8 +184,8 @@
 
     @Override
     protected BindingGraphTraverser bindingGraphTraverser(
-        ComponentTreePath componentPath, DependencyRequest entryPoint) {
-      return new BindingGraphValidation(componentPath, entryPoint);
+        ComponentTreePath componentPath, ComponentMethodDescriptor entryPointMethod) {
+      return new BindingGraphValidation(componentPath, entryPointMethod);
     }
 
     /** Returns a report that contains all validation messages found during traversal. */
@@ -582,8 +583,9 @@ private void checkScopedBindings(BindingGraph graph) {
 
     final class BindingGraphValidation extends BindingGraphTraverser {
 
-      BindingGraphValidation(ComponentTreePath componentPath, DependencyRequest entryPoint) {
-        super(componentPath, entryPoint);
+      BindingGraphValidation(
+          ComponentTreePath componentPath, ComponentMethodDescriptor entryPointMethod) {
+        super(componentPath, entryPointMethod);
       }
 
       /** Reports an error for the current component at the entry point. */
diff --git a/java/dagger/internal/codegen/BindingKey.java b/java/dagger/internal/codegen/BindingKey.java
deleted file mode 100644
index c90ceb92e..000000000
--- a/java/dagger/internal/codegen/BindingKey.java
+++ /dev/null
@@ -1,46 +0,0 @@
-/*
- * Copyright (C) 2014 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal.codegen;
-
-import com.google.auto.value.AutoValue;
-import dagger.model.Key;
-
-/**
- * A value object that pairs a {@link Key} with the style of its binding (i.e., whether it's a
- * members injector or normal contribution).
- *
- *  @author Gregory Kick
- *  @since 2.0
- */
-@AutoValue
-abstract class BindingKey {
-  /** The style of binding that makes a {@link Key} available. */
-  enum Kind {
-    CONTRIBUTION, MEMBERS_INJECTION;
-  }
-
-  static BindingKey contribution(Key key) {
-    return new AutoValue_BindingKey(Kind.CONTRIBUTION, key);
-  }
-
-  static BindingKey membersInjection(Key key) {
-    return new AutoValue_BindingKey(Kind.MEMBERS_INJECTION, key);
-  }
-
-  abstract Kind kind();
-  abstract Key key();
-}
diff --git a/java/dagger/internal/codegen/BindingNetwork.java b/java/dagger/internal/codegen/BindingNetwork.java
index 825e72336..081d837b9 100644
--- a/java/dagger/internal/codegen/BindingNetwork.java
+++ b/java/dagger/internal/codegen/BindingNetwork.java
@@ -25,8 +25,6 @@
 import static com.google.common.graph.Graphs.inducedSubgraph;
 import static com.google.common.graph.Graphs.reachableNodes;
 import static com.google.common.graph.Graphs.transpose;
-import static dagger.internal.codegen.BindingKey.contribution;
-import static dagger.internal.codegen.BindingKey.membersInjection;
 import static dagger.internal.codegen.ContributionBinding.Kind.SUBCOMPONENT_BUILDER;
 import static dagger.internal.codegen.DaggerStreams.instancesOf;
 import static dagger.internal.codegen.DaggerStreams.toImmutableMap;
@@ -41,7 +39,9 @@
 import com.google.common.graph.NetworkBuilder;
 import dagger.BindsOptionalOf;
 import dagger.Module;
+import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
 import dagger.internal.codegen.ComponentTreeTraverser.ComponentTreePath;
+import dagger.model.Key;
 import dagger.multibindings.Multibinds;
 import java.util.Optional;
 import java.util.stream.Stream;
@@ -96,10 +96,10 @@ private BindingNetwork(Network<Node, Edge> bindingNetwork) {
     return bindingNodesStream().collect(toImmutableSet());
   }
 
-  /** Returns the binding nodes for a binding. */
-  public ImmutableSet<BindingNode> bindingNodes(BindingKey bindingKey) {
+  /** Returns the binding nodes for a key. */
+  public ImmutableSet<BindingNode> bindingNodes(Key key) {
     return bindingNodesStream()
-        .filter(node -> node.bindingKey().equals(bindingKey))
+        .filter(node -> node.binding().key().equals(key))
         .collect(toImmutableSet());
   }
 
@@ -332,22 +332,6 @@ Binding binding() {
       return binding;
     }
 
-    /** The binding key for this binding. */
-    // TODO(dpb): Put this on Binding.
-    public BindingKey bindingKey() {
-      switch (binding.bindingType()) {
-        case MEMBERS_INJECTION:
-          return membersInjection(binding.key());
-
-        case PRODUCTION:
-        case PROVISION:
-          return contribution(binding.key());
-
-        default:
-          throw new AssertionError(binding);
-      }
-    }
-
     /**
      * The declarations (other than the binding's {@link Binding#bindingElement()}) that are
      * associated with the binding.
@@ -422,8 +406,8 @@ protected void visitSubcomponentFactoryMethod(
 
     @Override
     protected BindingGraphTraverser bindingGraphTraverser(
-        ComponentTreePath componentPath, DependencyRequest entryPoint) {
-      return new BindingGraphVisitor(componentPath, entryPoint);
+        ComponentTreePath componentPath, ComponentMethodDescriptor entryPointMethod) {
+      return new BindingGraphVisitor(componentPath, entryPointMethod);
     }
 
     BindingNetwork bindingNetwork() {
@@ -434,8 +418,9 @@ BindingNetwork bindingNetwork() {
 
       private Node current;
 
-      BindingGraphVisitor(ComponentTreePath componentPath, DependencyRequest entryPoint) {
-        super(componentPath, entryPoint);
+      BindingGraphVisitor(
+          ComponentTreePath componentPath, ComponentMethodDescriptor entryPointMethod) {
+        super(componentPath, entryPointMethod);
         current = currentComponent;
         network.addNode(current);
       }
diff --git a/java/dagger/internal/codegen/BindingTypeMapper.java b/java/dagger/internal/codegen/BindingTypeMapper.java
index 173f23715..e5fb8fdcf 100644
--- a/java/dagger/internal/codegen/BindingTypeMapper.java
+++ b/java/dagger/internal/codegen/BindingTypeMapper.java
@@ -72,8 +72,8 @@ static BindingTypeMapper forBindingType(BindingType bindingType) {
   abstract BindingType getBindingType(RequestKind requestKind);
 
   /**
-   * Returns the {@link BindingType} to use for a collection of requests of the same
-   * {@link BindingKey}. This allows factories to only take a single argument for multiple requests
+   * Returns the {@link BindingType} to use for a collection of requests of the same {@link
+   * dagger.model.Key}. This allows factories to only take a single argument for multiple requests
    * of the same key.
    */
   BindingType getBindingType(Iterable<DependencyRequest> requests) {
diff --git a/java/dagger/internal/codegen/ComponentDescriptor.java b/java/dagger/internal/codegen/ComponentDescriptor.java
index 78b5829ab..1dab29f47 100644
--- a/java/dagger/internal/codegen/ComponentDescriptor.java
+++ b/java/dagger/internal/codegen/ComponentDescriptor.java
@@ -322,13 +322,11 @@ private static void addTransitiveModules(
 
   abstract ImmutableSet<ComponentMethodDescriptor> componentMethods();
 
-  /** The dependency requests defined by methods on the component type. */
-  ImmutableSet<DependencyRequest> entryPoints() {
+  /** The entry point methods on the component type. */
+  ImmutableSet<ComponentMethodDescriptor> entryPointMethods() {
     return componentMethods()
         .stream()
-        .map(ComponentMethodDescriptor::dependencyRequest)
-        .filter(Optional::isPresent)
-        .map(Optional::get)
+        .filter(method -> method.dependencyRequest().isPresent())
         .collect(toImmutableSet());
   }
 
diff --git a/java/dagger/internal/codegen/ComponentRequirementField.java b/java/dagger/internal/codegen/ComponentRequirementField.java
index df99621f3..eab59b926 100644
--- a/java/dagger/internal/codegen/ComponentRequirementField.java
+++ b/java/dagger/internal/codegen/ComponentRequirementField.java
@@ -29,8 +29,8 @@
 /**
  * A factory for expressions of {@link ComponentRequirement}s in the generated component. This is
  * <em>not</em> a {@link BindingExpression}, since {@link ComponentRequirement}s do not have a
- * {@link BindingKey}. See {@link ComponentRequirementBindingExpression} for binding expressions
- * that are themselves a binding.
+ * {@link dagger.model.Key}. See {@link ComponentRequirementBindingExpression} for binding
+ * expressions that are themselves a component requirement.
  */
 abstract class ComponentRequirementField {
   private final ComponentRequirement componentRequirement;
diff --git a/java/dagger/internal/codegen/ComponentTreeTraverser.java b/java/dagger/internal/codegen/ComponentTreeTraverser.java
index 36433f41d..5a6cc990c 100644
--- a/java/dagger/internal/codegen/ComponentTreeTraverser.java
+++ b/java/dagger/internal/codegen/ComponentTreeTraverser.java
@@ -38,6 +38,8 @@
 import com.google.common.collect.Iterators;
 import com.google.common.collect.LinkedHashMultiset;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
+import dagger.internal.codegen.ComponentDescriptor.ComponentMethodKind;
+import dagger.model.Key;
 import java.util.ArrayDeque;
 import java.util.Deque;
 import java.util.HashSet;
@@ -61,8 +63,8 @@
  * component in the tree, and {@link #visitSubcomponentFactoryMethod(BindingGraph, BindingGraph,
  * ExecutableElement)} to perform custom logic at each subcomponent factory method.
  *
- * <p>Subclasses can override {@link #bindingGraphTraverser(ComponentTreePath, DependencyRequest)}
- * to traverse each entry point within each component in the tree.
+ * <p>Subclasses can override {@link #bindingGraphTraverser(ComponentTreePath,
+ * ComponentMethodDescriptor)} to traverse each entry point within each component in the tree.
  */
 public class ComponentTreeTraverser {
 
@@ -100,8 +102,8 @@ public final void traverseComponents() {
    * <ol>
    *   <li>If this component is installed in its parent by a subcomponent factory method, calls
    *       {@link #visitSubcomponentFactoryMethod(BindingGraph, BindingGraph, ExecutableElement)}.
-   *   <li>For each entry point in the component, calls {@link #visitEntryPoint(DependencyRequest,
-   *       BindingGraph)}.
+   *   <li>For each entry point in the component, calls {@link
+   *       #visitEntryPoint(ComponentMethodDescriptor, BindingGraph)}.
    *   <li>For each child component, calls {@link #visitComponent(BindingGraph)}, updating the
    *       traversal state.
    * </ol>
@@ -122,8 +124,9 @@ protected void visitComponent(BindingGraph graph) {
       }
     }
 
-    for (DependencyRequest entryPoint : graph.componentDescriptor().entryPoints()) {
-      visitEntryPoint(entryPoint, graph);
+    for (ComponentMethodDescriptor entryPointMethod :
+        graph.componentDescriptor().entryPointMethods()) {
+      visitEntryPoint(entryPointMethod, graph);
     }
 
     for (BindingGraph child : graph.subgraphs()) {
@@ -157,13 +160,13 @@ protected void visitSubcomponentFactoryMethod(
    * standard order.
    *
    * <p>This implementation passes the entry point and the current component tree path to {@link
-   * #bindingGraphTraverser(ComponentTreePath, DependencyRequest)}, and calls {@link
+   * #bindingGraphTraverser(ComponentTreePath, ComponentMethodDescriptor)}, and calls {@link
    * BindingGraphTraverser#traverseDependencies()} on the returned object.
    *
    * @param graph the graph for the component that contains the entry point
    */
-  protected void visitEntryPoint(DependencyRequest entryPoint, BindingGraph graph) {
-    bindingGraphTraverser(componentTreePath(), entryPoint).traverseDependencies();
+  protected void visitEntryPoint(ComponentMethodDescriptor entryPointMethod, BindingGraph graph) {
+    bindingGraphTraverser(componentTreePath(), entryPointMethod).traverseDependencies();
   }
 
   /**
@@ -174,11 +177,11 @@ protected void visitEntryPoint(DependencyRequest entryPoint, BindingGraph graph)
    *
    * @param componentPath the path from the root component to the component that includes the entry
    *     point
-   * @param entryPoint the entry point
+   * @param entryPointMethod the entry point method
    */
   protected BindingGraphTraverser bindingGraphTraverser(
-      ComponentTreePath componentPath, DependencyRequest entryPoint) {
-    return new NoOpBindingGraphTraverser(componentPath, entryPoint);
+      ComponentTreePath componentPath, ComponentMethodDescriptor entryPointMethod) {
+    return new NoOpBindingGraphTraverser(componentPath, entryPointMethod);
   }
 
   /**
@@ -198,10 +201,10 @@ protected final ComponentTreePath componentTreePath() {
   public static class BindingGraphTraverser {
 
     private final ComponentTreePath componentTreePath;
-    private final DependencyRequest entryPoint;
+    private final ComponentMethodDescriptor entryPointMethod;
     private final Deque<DependencyRequest> dependencyRequestPath = new ArrayDeque<>();
     private final Deque<ResolvedBindings> resolvedBindingsPath = new ArrayDeque<>();
-    private final LinkedHashMultiset<BindingKey> bindingKeysInPath = LinkedHashMultiset.create();
+    private final LinkedHashMultiset<Key> keysInPath = LinkedHashMultiset.create();
     private final Set<DependencyRequest> visitedDependencyRequests = new HashSet<>();
 
     /**
@@ -209,11 +212,12 @@ protected final ComponentTreePath componentTreePath() {
      *
      * @param componentPath the path from the root component to the component that includes the
      *     entry point to be traversed
-     * @param entryPoint the entry point to be traversed
+     * @param entryPointMethod the entry point method to be traversed
      */
-    public BindingGraphTraverser(ComponentTreePath componentPath, DependencyRequest entryPoint) {
+    public BindingGraphTraverser(
+        ComponentTreePath componentPath, ComponentMethodDescriptor entryPointMethod) {
       this.componentTreePath = componentPath;
-      this.entryPoint = entryPoint;
+      this.entryPointMethod = entryPointMethod;
     }
 
     /**
@@ -225,9 +229,9 @@ public BindingGraphTraverser(ComponentTreePath componentPath, DependencyRequest
     public void traverseDependencies() {
       checkState(dependencyRequestPath.isEmpty());
       checkState(resolvedBindingsPath.isEmpty());
-      checkState(bindingKeysInPath.isEmpty());
+      checkState(keysInPath.isEmpty());
       checkState(visitedDependencyRequests.isEmpty());
-      nextDependencyRequest(entryPoint, currentGraph());
+      nextDependencyRequest(entryPointMethod.dependencyRequest().get(), currentGraph());
     }
 
     /**
@@ -243,7 +247,7 @@ public void traverseDependencies() {
      * @param dependencyRequest the object returned by {@link #dependencyRequest()}
      */
     protected void visitDependencyRequest(DependencyRequest dependencyRequest) {
-      if (!atDependencyCycle()) {
+      if (visitedDependencyRequests.add(dependencyRequest) && !atDependencyCycle()) {
         visitResolvedBindings(resolvedBindingsPath.getLast());
       }
     }
@@ -382,24 +386,34 @@ protected void visitBinding(Binding binding, ComponentDescriptor owningComponent
 
     private void nextDependencyRequest(
         DependencyRequest dependencyRequest, BindingGraph bindingGraph) {
-      if (!visitedDependencyRequests.add(dependencyRequest)) {
-        return;
-      }
-
       ResolvedBindings resolvedBindings =
           bindingGraph.resolvedBindings(dependencyRequest.kind(), dependencyRequest.key());
       dependencyRequestPath.addLast(dependencyRequest);
       resolvedBindingsPath.addLast(resolvedBindings);
-      bindingKeysInPath.add(dependencyRequest.bindingKey());
+      // Don't add the key of a members injection request, as it doesn't participate in cycles
+      if (!isComponentMembersInjectionRequest(dependencyRequest)) {
+        keysInPath.add(dependencyRequest.key());
+      }
       try {
         visitDependencyRequest(dependencyRequest);
       } finally {
         verify(dependencyRequestPath.removeLast().equals(dependencyRequest));
         verify(resolvedBindingsPath.removeLast().equals(resolvedBindings));
-        verify(bindingKeysInPath.remove(dependencyRequest.bindingKey()));
+        if (!isComponentMembersInjectionRequest(dependencyRequest)) {
+          verify(keysInPath.remove(dependencyRequest.key()));
+        }
       }
     }
 
+    /**
+     * Returns {@code true} if {@code dependencyRequest} is the {@link #entryPointMethod}'s request
+     * and the entry point is a members injection method.
+     */
+    private boolean isComponentMembersInjectionRequest(DependencyRequest dependencyRequest) {
+      return entryPointMethod.kind().equals(ComponentMethodKind.MEMBERS_INJECTION)
+          && entryPointMethod.dependencyRequest().get().equals(dependencyRequest);
+    }
+
     /**
      * Returns the path from the root component to the component that includes the {@linkplain
      * #entryPointElement()} entry point.
@@ -433,7 +447,7 @@ public BindingGraph owningGraph(Iterable<ContributionBinding> bindings) {
      */
     protected final boolean atDependencyCycle() {
       checkState(!dependencyRequestPath.isEmpty());
-      return bindingKeysInPath.count(dependencyRequest().bindingKey()) > 1;
+      return keysInPath.count(dependencyRequest().key()) > 1;
     }
 
     /**
@@ -478,7 +492,7 @@ protected final ResolvedBindings resolvedBindings() {
      * @throws IllegalStateException if this object is not currently traversing dependencies
      */
     protected final Element entryPointElement() {
-      return entryPoint.requestElement().get();
+      return entryPointMethod.dependencyRequest().get().requestElement().get();
     }
 
     /**
@@ -509,11 +523,11 @@ protected final DependencyTrace dependencyTrace() {
      * {@linkplain #dependencyRequest() current dependency request}.
      *
      * <p>The first request and the last request in the trace will have the same {@linkplain
-     * DependencyRequest#bindingKey() binding key}.
+     * DependencyRequest#key()} key}.
      */
     protected final DependencyTrace cycleDependencyTrace() {
       checkState(atDependencyCycle(), "no cycle");
-      int skip = indexOf(bindingKeysInPath, equalTo(dependencyRequest().bindingKey()));
+      int skip = indexOf(keysInPath, equalTo(dependencyRequest().key()));
       return new DependencyTrace(
           skip(dependencyRequestPath, skip), skip(resolvedBindingsPath, skip));
     }
@@ -522,8 +536,8 @@ protected final DependencyTrace cycleDependencyTrace() {
   /** A traverser that does nothing. */
   private static final class NoOpBindingGraphTraverser extends BindingGraphTraverser {
     private NoOpBindingGraphTraverser(
-        ComponentTreePath componentPath, DependencyRequest entryPoint) {
-      super(componentPath, entryPoint);
+        ComponentTreePath componentPath, ComponentMethodDescriptor entryPointMethod) {
+      super(componentPath, entryPointMethod);
     }
 
     @Override
diff --git a/java/dagger/internal/codegen/DependencyRequest.java b/java/dagger/internal/codegen/DependencyRequest.java
index ea5827783..61a25d65e 100644
--- a/java/dagger/internal/codegen/DependencyRequest.java
+++ b/java/dagger/internal/codegen/DependencyRequest.java
@@ -40,23 +40,6 @@
   abstract RequestKind kind();
   abstract Key key();
 
-  BindingKey bindingKey() {
-    switch (kind()) {
-      case INSTANCE:
-      case LAZY:
-      case PROVIDER:
-      case PROVIDER_OF_LAZY:
-      case PRODUCER:
-      case PRODUCED:
-      case FUTURE:
-        return BindingKey.contribution(key());
-      case MEMBERS_INJECTION:
-        return BindingKey.membersInjection(key());
-      default:
-        throw new AssertionError(this);
-    }
-  }
-
   /** The element that declares this dependency request. Absent for synthetic requests. */
   abstract Optional<Element> requestElement();
 
diff --git a/java/dagger/internal/codegen/PrivateMethodBindingExpression.java b/java/dagger/internal/codegen/PrivateMethodBindingExpression.java
index 29f874f41..c46d28e6f 100644
--- a/java/dagger/internal/codegen/PrivateMethodBindingExpression.java
+++ b/java/dagger/internal/codegen/PrivateMethodBindingExpression.java
@@ -163,12 +163,12 @@ private boolean canInlineScope() {
         .owningComponent()
         .componentMethods()
         .stream()
-        .filter(method -> componentMethodMatchesRequestBindingKeyAndKind(method))
+        .filter(this::componentMethodMatchesRequestKeyAndKind)
         .findFirst();
   }
 
-  /** Returns true if the component method matches the dependency request binding key and kind. */
-  private boolean componentMethodMatchesRequestBindingKeyAndKind(
+  /** Returns true if the component method matches the dependency request key and kind. */
+  private boolean componentMethodMatchesRequestKeyAndKind(
       ComponentMethodDescriptor componentMethod) {
     return componentMethod
         .dependencyRequest()
diff --git a/java/dagger/internal/codegen/ProducerFromProviderFieldInitializer.java b/java/dagger/internal/codegen/ProducerFromProviderFieldInitializer.java
index 2559fe2ad..61e122d7b 100644
--- a/java/dagger/internal/codegen/ProducerFromProviderFieldInitializer.java
+++ b/java/dagger/internal/codegen/ProducerFromProviderFieldInitializer.java
@@ -21,6 +21,7 @@
 
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
+import dagger.model.Key;
 import dagger.model.RequestKind;
 import dagger.producers.Producer;
 import java.util.Optional;
@@ -29,8 +30,7 @@
 final class ProducerFromProviderFieldInitializer extends FrameworkFieldInitializer {
 
   private final ComponentBindingExpressions componentBindingExpressions;
-  // TODO(ronshapiro): add Binding.bindingKey() and use that instead of taking a ResolvedBindings
-  private final ResolvedBindings resolvedBindings;
+  private final Key key;
 
   ProducerFromProviderFieldInitializer(
       ResolvedBindings resolvedBindings,
@@ -38,7 +38,7 @@
       ComponentBindingExpressions componentBindingExpressions) {
     super(generatedComponentModel, componentBindingExpressions, resolvedBindings);
     this.componentBindingExpressions = checkNotNull(componentBindingExpressions);
-    this.resolvedBindings = checkNotNull(resolvedBindings);
+    this.key = resolvedBindings.key();
   }
 
   @Override
@@ -47,8 +47,7 @@ protected CodeBlock getFieldInitialization() {
         RequestKind.PRODUCER,
         componentBindingExpressions
             .getDependencyExpression(
-                FrameworkDependency.create(resolvedBindings.key(), PROVISION),
-                generatedComponentModel.name())
+                FrameworkDependency.create(key, PROVISION), generatedComponentModel.name())
             .codeBlock());
   }
 
diff --git a/java/dagger/internal/codegen/ProviderOrProducerFieldInitializer.java b/java/dagger/internal/codegen/ProviderOrProducerFieldInitializer.java
index 45abc23f4..826d0d60a 100644
--- a/java/dagger/internal/codegen/ProviderOrProducerFieldInitializer.java
+++ b/java/dagger/internal/codegen/ProviderOrProducerFieldInitializer.java
@@ -84,7 +84,6 @@
 final class ProviderOrProducerFieldInitializer extends FrameworkFieldInitializer {
   private final SubcomponentNames subcomponentNames;
   private final ComponentRequirementFields componentRequirementFields;
-  // TODO(ronshapiro): add Binding.bindingKey() and use that instead of taking a ResolvedBindings
   private final ResolvedBindings resolvedBindings;
   private final CompilerOptions compilerOptions;
   private final BindingGraph graph;
diff --git a/java/dagger/internal/codegen/SubcomponentNames.java b/java/dagger/internal/codegen/SubcomponentNames.java
index 2fbc5d39f..c059ee3e1 100644
--- a/java/dagger/internal/codegen/SubcomponentNames.java
+++ b/java/dagger/internal/codegen/SubcomponentNames.java
@@ -36,7 +36,7 @@
 
 /**
  * Holds the unique simple names for all subcomponents, keyed by their {@link ComponentDescriptor}
- * and {@link BindingKey} of the subcomponent builder.
+ * and {@link Key} of the subcomponent builder.
  */
 final class SubcomponentNames {
   private static final Splitter QUALIFIED_NAME_SPLITTER = Splitter.on('.');
diff --git a/javatests/dagger/internal/codegen/GraphValidationTest.java b/javatests/dagger/internal/codegen/GraphValidationTest.java
index 2aa471a82..f9e0d9e51 100644
--- a/javatests/dagger/internal/codegen/GraphValidationTest.java
+++ b/javatests/dagger/internal/codegen/GraphValidationTest.java
@@ -731,6 +731,93 @@ public void selfReferentialBinds() {
         .onLine(7);
   }
 
+  @Test
+  public void cycleFromMembersInjectionMethod_WithSameKeyAsMembersInjectionMethod() {
+    JavaFileObject a =
+        JavaFileObjects.forSourceLines(
+            "test.A",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class A {",
+            "  @Inject A() {}",
+            "  @Inject B b;",
+            "}");
+    JavaFileObject b =
+        JavaFileObjects.forSourceLines(
+            "test.B",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class B {",
+            "  @Inject B() {}",
+            "  @Inject A a;",
+            "}");
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.CycleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface CycleComponent {",
+            "  void inject(A a);",
+            "}");
+
+    Compilation compilation = daggerCompiler().compile(a, b, component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(Joiner.on('\n')
+            .join(
+                "Found a dependency cycle:",
+                "      test.B is injected at",
+                "          test.A.b",
+                "      test.A is injected at",
+                "          test.B.a",
+                "      test.B is injected at",
+                "          test.A.b",
+                "      test.A is injected at",
+                "          test.CycleComponent.inject(a)"))
+        .inFile(component)
+        .onLineContaining("void inject(A a);");
+  }
+
+  @Test
+  public void missingBindingWithSameKeyAsMembersInjectionMethod() {
+    JavaFileObject self =
+        JavaFileObjects.forSourceLines(
+            "test.Self",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "import javax.inject.Provider;",
+            "",
+            "class Self {",
+            "  @Inject Provider<Self> selfProvider;",
+            "}");
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.SelfComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface SelfComponent {",
+            "  void inject(Self target);",
+            "}");
+
+    Compilation compilation = daggerCompiler().compile(self, component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("test.Self cannot be provided without an @Inject constructor")
+        .inFile(component)
+        .onLineContaining("void inject(Self target);");
+  }
+
   @Test public void duplicateExplicitBindings_ProvidesAndComponentProvision() {
     JavaFileObject component = JavaFileObjects.forSourceLines("test.Outer",
         "package test;",
