diff --git a/compiler/src/it/functional-tests/src/main/java/test/builder/ByteModule.java b/compiler/src/it/functional-tests/src/main/java/test/builder/ByteModule.java
new file mode 100644
index 000000000..8b85d606c
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/builder/ByteModule.java
@@ -0,0 +1,30 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.builder;
+
+import dagger.Module;
+import dagger.Provides;
+
+@Module
+class ByteModule {
+  final byte b;
+
+  ByteModule(byte b) {
+    this.b = b;
+  }
+  
+  @Provides byte b() { return b; }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builder/GenericParent.java b/compiler/src/it/functional-tests/src/main/java/test/builder/GenericParent.java
new file mode 100644
index 000000000..af196eeda
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/builder/GenericParent.java
@@ -0,0 +1,20 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.builder;
+
+interface GenericParent<B> {  
+  B subcomponentBuilder();
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builder/Grandchild.java b/compiler/src/it/functional-tests/src/main/java/test/builder/Grandchild.java
new file mode 100644
index 000000000..8cbf67b19
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/builder/Grandchild.java
@@ -0,0 +1,30 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.builder;
+
+import dagger.Subcomponent;
+
+@Subcomponent(modules = IntModuleIncludingDoubleAndFloat.class)
+interface Grandchild {
+  int i();
+  String s();
+
+  @Subcomponent.Builder
+  interface Builder {
+    Grandchild build();
+    Builder set(IntModuleIncludingDoubleAndFloat intModule);
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builder/MiddleChild.java b/compiler/src/it/functional-tests/src/main/java/test/builder/MiddleChild.java
new file mode 100644
index 000000000..59c29ab34
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/builder/MiddleChild.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.builder;
+
+import dagger.Subcomponent;
+
+@MiddleScope
+@Subcomponent(modules = StringModule.class)
+interface MiddleChild {
+  String s();
+  
+  Grandchild.Builder grandchildBuilder();
+  
+  @Subcomponent.Builder
+  interface Builder {
+    MiddleChild build();
+    Builder set(StringModule stringModule);
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builder/MiddleScope.java b/compiler/src/it/functional-tests/src/main/java/test/builder/MiddleScope.java
new file mode 100644
index 000000000..e2fbcaa42
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/builder/MiddleScope.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.builder;
+
+import java.lang.annotation.Retention;
+import javax.inject.Scope;
+
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+@Scope
+@Retention(RUNTIME)
+@interface MiddleScope {
+
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builder/OtherMiddleChild.java b/compiler/src/it/functional-tests/src/main/java/test/builder/OtherMiddleChild.java
new file mode 100644
index 000000000..28e43bafe
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/builder/OtherMiddleChild.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.builder;
+
+import dagger.Subcomponent;
+
+@MiddleScope
+@Subcomponent(modules = {StringModule.class, LongModule.class})
+interface OtherMiddleChild {
+  long l();
+  String s();
+  
+  Grandchild.Builder grandchildBuilder();
+  
+  @Subcomponent.Builder
+  interface Builder {
+    OtherMiddleChild build();
+    Builder set(StringModule stringModule);
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builder/ParentComponent.java b/compiler/src/it/functional-tests/src/main/java/test/builder/ParentComponent.java
new file mode 100644
index 000000000..f901b8863
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/builder/ParentComponent.java
@@ -0,0 +1,29 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.builder;
+
+import dagger.Component;
+import javax.inject.Singleton;
+
+@Singleton
+@Component
+interface ParentComponent {  
+  TestChildComponentWithBuilderAbstractClass.Builder childAbstractClassBuilder();
+  TestChildComponentWithBuilderInterface.Builder childInterfaceBuilder();
+  
+  MiddleChild.Builder middleBuilder();
+  OtherMiddleChild.Builder otherBuilder();
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builder/ParentOfGenericComponent.java b/compiler/src/it/functional-tests/src/main/java/test/builder/ParentOfGenericComponent.java
new file mode 100644
index 000000000..474c61701
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/builder/ParentOfGenericComponent.java
@@ -0,0 +1,23 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.builder;
+
+import dagger.Component;
+import javax.inject.Singleton;
+
+@Component(modules = StringModule.class)
+@Singleton
+interface ParentOfGenericComponent extends GenericParent<Grandchild.Builder> {}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builder/TestChildComponentWithBuilderAbstractClass.java b/compiler/src/it/functional-tests/src/main/java/test/builder/TestChildComponentWithBuilderAbstractClass.java
new file mode 100644
index 000000000..8f39c1401
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/builder/TestChildComponentWithBuilderAbstractClass.java
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.builder;
+
+import dagger.Subcomponent;
+
+@Subcomponent(modules = {StringModule.class, IntModuleIncludingDoubleAndFloat.class,
+    LongModule.class, ByteModule.class})
+interface TestChildComponentWithBuilderAbstractClass {
+  String s();
+  int i();
+  long l();
+  float f();
+  double d();
+  byte b();
+ 
+  abstract class SharedBuilder<B, C, M1, M2> {
+    abstract C build(); // Test resolving return type of build()
+    abstract B setM1(M1 m1); // Test resolving return type & param of setter
+    abstract SharedBuilder<B, C, M1, M2> setM2(M2 m2); // Test being overridden
+    abstract void setM3(DoubleModule doubleModule);  // Test being overridden
+    abstract SharedBuilder<B, C, M1, M2> set(FloatModule floatModule); // Test returning supertype.
+  }
+  
+  @Subcomponent.Builder
+  abstract class Builder extends SharedBuilder<Builder, TestChildComponentWithBuilderAbstractClass,
+      StringModule, IntModuleIncludingDoubleAndFloat> {
+    @Override abstract Builder setM2(IntModuleIncludingDoubleAndFloat m2); // Test covariance
+    @Override abstract void setM3(DoubleModule doubleModule); // Test simple overrides allowed    
+    abstract void set(ByteModule byteModule);
+    
+    // Note we're missing LongModule -- it's implicit
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builder/TestChildComponentWithBuilderInterface.java b/compiler/src/it/functional-tests/src/main/java/test/builder/TestChildComponentWithBuilderInterface.java
new file mode 100644
index 000000000..2add34ed5
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/builder/TestChildComponentWithBuilderInterface.java
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.builder;
+
+import dagger.Subcomponent;
+
+@Subcomponent(modules = {StringModule.class, IntModuleIncludingDoubleAndFloat.class,
+    LongModule.class, ByteModule.class})
+interface TestChildComponentWithBuilderInterface {
+  String s();
+  int i();
+  long l();
+  float f();
+  double d();
+  byte b();
+  
+  interface SharedBuilder<B, C, M1, M2> {
+    C build(); // Test resolving return type of build()
+    B setM1(M1 m1); // Test resolving return type & param of setter
+    SharedBuilder<B, C, M1, M2> setM2(M2 m2); // Test being overridden
+    void setM3(DoubleModule doubleModule);  // Test being overridden
+    SharedBuilder<B, C, M1, M2> set(FloatModule floatModule); // Test return type is supertype.
+  }
+  
+  @Subcomponent.Builder
+  interface Builder extends SharedBuilder<Builder, TestChildComponentWithBuilderInterface,
+      StringModule, IntModuleIncludingDoubleAndFloat> {
+    @Override Builder setM2(IntModuleIncludingDoubleAndFloat m2); // Test covariant overrides
+    @Override void setM3(DoubleModule doubleModule); // Test simple overrides allowed    
+    void set(ByteModule byteModule);
+    
+    // Note we're missing LongModule -- it's implicit
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/GenericParentComponent.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/GenericParentComponent.java
new file mode 100644
index 000000000..5580ab8d4
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/GenericParentComponent.java
@@ -0,0 +1,20 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.subcomponent;
+
+interface GenericParentComponent<B> {  
+  B subcomponent();
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentComponent.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentComponent.java
index 91c0bd717..ebb067d6f 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentComponent.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentComponent.java
@@ -16,17 +16,11 @@
 package test.subcomponent;
 
 import dagger.Component;
-import java.util.Set;
-import javax.inject.Provider;
 import javax.inject.Singleton;
 
 @Component(modules = ParentModule.class)
 @Singleton
-interface ParentComponent {
-  Provider<UnscopedType> getUnscopedTypeProvider();
-
-  Set<Object> objectSet();
-
+interface ParentComponent extends ParentGetters {
   ChildComponent newChildComponent();
 
   ChildAbstractClassComponent newChildAbstractClassComponent();
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentGetters.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentGetters.java
new file mode 100644
index 000000000..3ff855a9d
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentGetters.java
@@ -0,0 +1,26 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.subcomponent;
+
+import java.util.Set;
+import javax.inject.Provider;
+
+interface ParentGetters {
+  Provider<UnscopedType> getUnscopedTypeProvider();
+
+  Set<Object> objectSet();
+
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentOfGenericComponent.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentOfGenericComponent.java
new file mode 100644
index 000000000..bf8553772
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentOfGenericComponent.java
@@ -0,0 +1,24 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.subcomponent;
+
+import dagger.Component;
+import javax.inject.Singleton;
+
+@Component(modules = ParentModule.class)
+@Singleton
+interface ParentOfGenericComponent extends GenericParentComponent<ChildComponent>, ParentGetters {
+}
diff --git a/compiler/src/it/functional-tests/src/test/java/test/builder/BuilderTest.java b/compiler/src/it/functional-tests/src/test/java/test/builder/BuilderTest.java
index eb2abd66c..ba590d2d9 100644
--- a/compiler/src/it/functional-tests/src/test/java/test/builder/BuilderTest.java
+++ b/compiler/src/it/functional-tests/src/test/java/test/builder/BuilderTest.java
@@ -25,7 +25,7 @@
 @RunWith(JUnit4.class)
 public class BuilderTest {
 
-  @Test public void testInterfaceBuilder() {
+  @Test public void interfaceBuilder() {
     TestComponentWithBuilderInterface.Builder builder =
         DaggerTestComponentWithBuilderInterface.builder();
 
@@ -49,7 +49,7 @@
     assertThat(component.l()).isEqualTo(6L);
   }
 
-  @Test public void testAbstractClassBuilder() {
+  @Test public void abstractClassBuilder() {
     TestComponentWithBuilderAbstractClass.Builder builder =
         TestComponentWithBuilderAbstractClass.builder();
 
@@ -73,7 +73,7 @@
     assertThat(component.l()).isEqualTo(6L);
   }
 
-  @Test public void testInterfaceGenericBuilder() {
+  @Test public void interfaceGenericBuilder() {
     TestComponentWithGenericBuilderInterface.Builder builder =
         DaggerTestComponentWithGenericBuilderInterface.builder();
 
@@ -97,7 +97,7 @@
     assertThat(component.l()).isEqualTo(6L);
   }
 
-  @Test public void testAbstractClassGenericBuilder() {
+  @Test public void abstractClassGenericBuilder() {
     TestComponentWithGenericBuilderAbstractClass.Builder builder =
         DaggerTestComponentWithGenericBuilderAbstractClass.builder();
 
@@ -121,4 +121,105 @@
     assertThat(component.l()).isEqualTo(6L);
   }
   
+  @Test public void subcomponents_interface() {
+    ParentComponent parent = DaggerParentComponent.create();    
+    TestChildComponentWithBuilderInterface.Builder builder1 = parent.childInterfaceBuilder();
+    try {
+      builder1.build();
+      fail();
+    } catch(IllegalStateException expected) {}
+    
+    builder1.setM2(new IntModuleIncludingDoubleAndFloat(1))
+        .setM1(new StringModule("sam"))
+        .set(new ByteModule((byte)7));
+    builder1.set(new FloatModule());
+    TestChildComponentWithBuilderInterface child1 = builder1.build();
+    assertThat(child1.s()).isEqualTo("sam");
+    assertThat(child1.i()).isEqualTo(1);
+    assertThat(child1.d()).isWithin(0).of(4.2d);
+    assertThat(child1.f()).isEqualTo(5.5f);
+    assertThat(child1.l()).isEqualTo(6L);
+    assertThat(child1.b()).isEqualTo((byte)7);
+  }
+  
+  @Test public void subcomponents_abstractclass() {
+    ParentComponent parent = DaggerParentComponent.create();
+    TestChildComponentWithBuilderAbstractClass.Builder builder2 =
+        parent.childAbstractClassBuilder();
+    try {
+      builder2.build();
+      fail();
+    } catch(IllegalStateException expected) {}
+    
+    builder2.setM2(new IntModuleIncludingDoubleAndFloat(10))
+        .setM1(new StringModule("tara"))
+        .set(new ByteModule((byte)70));
+    builder2.set(new FloatModule());
+    TestChildComponentWithBuilderAbstractClass child2 = builder2.build();
+    assertThat(child2.s()).isEqualTo("tara");
+    assertThat(child2.i()).isEqualTo(10);
+    assertThat(child2.d()).isWithin(0).of(4.2d);
+    assertThat(child2.f()).isEqualTo(5.5f);
+    assertThat(child2.l()).isEqualTo(6L);
+    assertThat(child2.b()).isEqualTo((byte)70);
+  }
+  
+  @Test
+  public void grandchildren() {
+    ParentComponent parent = DaggerParentComponent.create();
+    MiddleChild middle1 = parent.middleBuilder().set(new StringModule("sam")).build();
+    Grandchild grandchild1 =
+        middle1.grandchildBuilder().set(new IntModuleIncludingDoubleAndFloat(21)).build();
+    Grandchild grandchild2 =
+        middle1.grandchildBuilder().set(new IntModuleIncludingDoubleAndFloat(22)).build();
+    
+    assertThat(middle1.s()).isEqualTo("sam");
+    assertThat(grandchild1.i()).isEqualTo(21);
+    assertThat(grandchild1.s()).isEqualTo("sam");
+    assertThat(grandchild2.i()).isEqualTo(22);
+    assertThat(grandchild2.s()).isEqualTo("sam");
+
+    // Make sure grandchildren from newer children have no relation to the older ones.
+    MiddleChild middle2 = parent.middleBuilder().set(new StringModule("tara")).build();
+    Grandchild grandchild3 =
+        middle2.grandchildBuilder().set(new IntModuleIncludingDoubleAndFloat(23)).build();
+    Grandchild grandchild4 =
+        middle2.grandchildBuilder().set(new IntModuleIncludingDoubleAndFloat(24)).build();
+    
+    assertThat(middle2.s()).isEqualTo("tara");
+    assertThat(grandchild3.i()).isEqualTo(23);
+    assertThat(grandchild3.s()).isEqualTo("tara");
+    assertThat(grandchild4.i()).isEqualTo(24);
+    assertThat(grandchild4.s()).isEqualTo("tara");
+  }
+  
+  @Test
+  public void diamondGrandchildren() {
+    ParentComponent parent = DaggerParentComponent.create();
+    MiddleChild middle = parent.middleBuilder().set(new StringModule("sam")).build();
+    OtherMiddleChild other = parent.otherBuilder().set(new StringModule("tara")).build();
+    
+    Grandchild middlegrand =
+        middle.grandchildBuilder().set(new IntModuleIncludingDoubleAndFloat(21)).build();
+    Grandchild othergrand =
+        other.grandchildBuilder().set(new IntModuleIncludingDoubleAndFloat(22)).build();
+    
+    assertThat(middle.s()).isEqualTo("sam");
+    assertThat(other.s()).isEqualTo("tara");
+    assertThat(middlegrand.s()).isEqualTo("sam");
+    assertThat(othergrand.s()).isEqualTo("tara");
+    assertThat(middlegrand.i()).isEqualTo(21);
+    assertThat(othergrand.i()).isEqualTo(22);
+  }
+  
+  @Test
+  public void genericSubcomponentMethod() {
+    ParentOfGenericComponent parent =
+        DaggerParentOfGenericComponent.builder().stringModule(new StringModule("sam")).build();
+    Grandchild.Builder builder = parent.subcomponentBuilder();
+    Grandchild child = builder.set(new IntModuleIncludingDoubleAndFloat(21)).build();
+    assertThat(child.s()).isEqualTo("sam");
+    assertThat(child.i()).isEqualTo(21);
+  }
+  
 }
diff --git a/compiler/src/it/functional-tests/src/test/java/test/subcomponent/SubcomponentTest.java b/compiler/src/it/functional-tests/src/test/java/test/subcomponent/SubcomponentTest.java
index de0e508af..cb6292513 100644
--- a/compiler/src/it/functional-tests/src/test/java/test/subcomponent/SubcomponentTest.java
+++ b/compiler/src/it/functional-tests/src/test/java/test/subcomponent/SubcomponentTest.java
@@ -15,36 +15,50 @@
  */
 package test.subcomponent;
 
+import java.util.Arrays;
+import java.util.Collection;
 import java.util.Set;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-import org.junit.experimental.theories.DataPoint;
-import org.junit.experimental.theories.Theories;
-import org.junit.experimental.theories.Theory;
+import org.junit.runners.Parameterized;
+import org.junit.runners.Parameterized.Parameters;
 
 import static com.google.common.collect.Sets.intersection;
 import static com.google.common.truth.Truth.assertThat;
 
-@RunWith(Theories.class)
+@RunWith(Parameterized.class)
 public class SubcomponentTest {
   private static final ParentComponent parentComponent = DaggerParentComponent.create();
-  @DataPoint
-  public static final ChildComponent childComponent = parentComponent.newChildComponent();;
-  @DataPoint
-  public static final ChildComponent childAbstractClassComponent =
-      parentComponent.newChildAbstractClassComponent();
+  private static final ParentOfGenericComponent parentOfGenericComponent =
+      DaggerParentOfGenericComponent.create();
+  
+  @Parameters
+  public static Collection<Object[]> parameters() {
+    return Arrays.asList(new Object[][] {
+        { parentComponent, parentComponent.newChildComponent() },
+        { parentComponent, parentComponent.newChildAbstractClassComponent() },
+        { parentOfGenericComponent, parentOfGenericComponent.subcomponent() }});
+  }        
+  
+  private final ParentGetters parentGetters;
+  private final ChildComponent childComponent;
+  
+  public SubcomponentTest(ParentGetters parentGetters, ChildComponent childComponent) {
+    this.parentGetters = parentGetters;
+    this.childComponent = childComponent;
+  }
+  
 
-  @Theory
-  public void scopePropagatesUpward_class(ChildComponent childComponent) {
+  @Test
+  public void scopePropagatesUpward_class() {
     assertThat(childComponent.requiresSingleton().singletonType())
         .isSameAs(childComponent.requiresSingleton().singletonType());
     assertThat(childComponent.requiresSingleton().singletonType())
         .isSameAs(childComponent.newGrandchildComponent().requiresSingleton().singletonType());
   }
 
-  @Theory
-  public void scopePropagatesUpward_provides(ChildComponent childComponent) {
+  @Test
+  public void scopePropagatesUpward_provides() {
     assertThat(childComponent
         .requiresSingleton().unscopedTypeBoundAsSingleton())
             .isSameAs(childComponent
@@ -55,9 +69,9 @@ public void scopePropagatesUpward_provides(ChildComponent childComponent) {
                 .requiresSingleton().unscopedTypeBoundAsSingleton());
   }
 
-  @Theory
-  public void multibindingContributions(ChildComponent childComponent) {
-    Set<Object> parentObjectSet = parentComponent.objectSet();
+  @Test
+  public void multibindingContributions() {
+    Set<Object> parentObjectSet = parentGetters.objectSet();
     assertThat(parentObjectSet).hasSize(2);
     Set<Object> childObjectSet = childComponent.objectSet();
     assertThat(childObjectSet).hasSize(3);
@@ -69,18 +83,18 @@ public void multibindingContributions(ChildComponent childComponent) {
     assertThat(intersection(childObjectSet, grandchildObjectSet)).hasSize(1);
   }
 
-  @Theory
-  public void unscopedProviders(ChildComponent childComponent) {
-    assertThat(parentComponent.getUnscopedTypeProvider())
+  @Test
+  public void unscopedProviders() {
+    assertThat(parentGetters.getUnscopedTypeProvider())
         .isSameAs(childComponent.getUnscopedTypeProvider());
-    assertThat(parentComponent.getUnscopedTypeProvider())
+    assertThat(parentGetters.getUnscopedTypeProvider())
         .isSameAs(childComponent
             .newGrandchildComponent()
             .getUnscopedTypeProvider());
   }
 
-  @Theory
-  public void passedModules(ChildComponent childComponent) {
+  @Test
+  public void passedModules() {
     ChildModuleWithState childModuleWithState = new ChildModuleWithState();
     ChildComponentRequiringModules childComponent1 =
         parentComponent.newChildComponentRequiringModules(
@@ -94,8 +108,8 @@ public void passedModules(ChildComponent childComponent) {
     assertThat(childComponent2.getInt()).isEqualTo(1);
   }
 
-  @Theory
-  public void dependenceisInASubcomponent(ChildComponent childComponent) {
+  @Test
+  public void dependenceisInASubcomponent() {
     assertThat(childComponent.newGrandchildComponent().needsAnInterface()).isNotNull();
-  }
+  }  
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
index 24b5ba27c..1b10497bc 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -65,8 +65,6 @@
 import static com.google.auto.common.MoreTypes.isTypeOf;
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
-import static dagger.internal.codegen.ErrorMessages.BUILDER_EXTRA_SETTERS;
-import static dagger.internal.codegen.ErrorMessages.BUILDER_MISSING_SETTERS;
 import static dagger.internal.codegen.ErrorMessages.INDENT;
 import static dagger.internal.codegen.ErrorMessages.MEMBERS_INJECTION_WITH_UNBOUNDED_TYPE;
 import static dagger.internal.codegen.ErrorMessages.NULLABLE_TO_NON_NULLABLE;
@@ -465,6 +463,8 @@ private void validateBuilders(BindingGraph subject, Builder<BindingGraph> report
     final BuilderSpec spec = componentDesc.builderSpec().get();
     Map<TypeElement, ExecutableElement> allSetters = spec.methodMap();
 
+    ErrorMessages.ComponentBuilderMessages msgs =
+        ErrorMessages.builderMsgsFor(subject.componentDescriptor().kind());
     Set<TypeElement> extraSetters = Sets.difference(allSetters.keySet(), allDependents);
     if (!extraSetters.isEmpty()) {
       Collection<ExecutableElement> excessMethods =
@@ -475,12 +475,13 @@ private void validateBuilders(BindingGraph subject, Builder<BindingGraph> report
               return methodSignatureFormatter.format(input,
                   Optional.of(MoreTypes.asDeclared(spec.builderDefinitionType().asType())));
             }});
-      reportBuilder.addItem(String.format(BUILDER_EXTRA_SETTERS, formatted), spec.builderDefinitionType());
+      reportBuilder.addItem(String.format(msgs.extraSetters(), formatted),
+          spec.builderDefinitionType());
     }
 
     Set<TypeElement> missingSetters = Sets.difference(requiredDependents, allSetters.keySet());
     if (!missingSetters.isEmpty()) {
-      reportBuilder.addItem(String.format(BUILDER_MISSING_SETTERS, missingSetters),
+      reportBuilder.addItem(String.format(msgs.missingSetters(), missingSetters),
           spec.builderDefinitionType());
     }
   }
diff --git a/compiler/src/main/java/dagger/internal/codegen/BuilderValidator.java b/compiler/src/main/java/dagger/internal/codegen/BuilderValidator.java
index 93367bafb..3bb85e3f9 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BuilderValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BuilderValidator.java
@@ -20,7 +20,7 @@
 import com.google.common.collect.Iterables;
 import com.google.common.collect.LinkedHashMultimap;
 import com.google.common.collect.Multimap;
-import dagger.Component;
+import java.lang.annotation.Annotation;
 import java.util.Collection;
 import java.util.List;
 import java.util.Map;
@@ -39,24 +39,6 @@
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.collect.Iterables.getOnlyElement;
-import static dagger.internal.codegen.ErrorMessages.BUILDER_BUILD_MUST_RETURN_COMPONENT_TYPE;
-import static dagger.internal.codegen.ErrorMessages.BUILDER_CXTOR_ONLY_ONE_AND_NO_ARGS;
-import static dagger.internal.codegen.ErrorMessages.BUILDER_GENERICS;
-import static dagger.internal.codegen.ErrorMessages.BUILDER_INHERITED_BUILD_MUST_RETURN_COMPONENT_TYPE;
-import static dagger.internal.codegen.ErrorMessages.BUILDER_INHERITED_METHODS_MAY_NOT_HAVE_TYPE_PARAMETERS;
-import static dagger.internal.codegen.ErrorMessages.BUILDER_INHERITED_METHODS_MUST_RETURN_VOID_OR_BUILDER;
-import static dagger.internal.codegen.ErrorMessages.BUILDER_INHERITED_METHOD_MUST_TAKE_ONE_ARG;
-import static dagger.internal.codegen.ErrorMessages.BUILDER_INHERITED_TWO_BUILD_METHODS;
-import static dagger.internal.codegen.ErrorMessages.BUILDER_METHODS_MAY_NOT_HAVE_TYPE_PARAMETERS;
-import static dagger.internal.codegen.ErrorMessages.BUILDER_METHODS_MUST_RETURN_VOID_OR_BUILDER;
-import static dagger.internal.codegen.ErrorMessages.BUILDER_METHOD_MUST_TAKE_ONE_ARG;
-import static dagger.internal.codegen.ErrorMessages.BUILDER_MISSING_BUILD_METHOD;
-import static dagger.internal.codegen.ErrorMessages.BUILDER_MUST_BE_ABSTRACT;
-import static dagger.internal.codegen.ErrorMessages.BUILDER_MUST_BE_CLASS_OR_INTERFACE;
-import static dagger.internal.codegen.ErrorMessages.BUILDER_MUST_BE_IN_COMPONENT;
-import static dagger.internal.codegen.ErrorMessages.BUILDER_MUST_BE_STATIC;
-import static dagger.internal.codegen.ErrorMessages.BUILDER_PRIVATE;
-import static dagger.internal.codegen.ErrorMessages.BUILDER_TWO_BUILD_METHODS;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.STATIC;
@@ -69,20 +51,25 @@
 class BuilderValidator implements Validator<TypeElement> {
   private final Elements elements;
   private final Types types;
-
-  BuilderValidator(Elements elements, Types types) {
+  private final ComponentDescriptor.Kind componentType;
+  
+  BuilderValidator(Elements elements, Types types, ComponentDescriptor.Kind componentType) {
     this.elements = elements;
     this.types = types;
+    this.componentType = componentType;
   }
 
   @Override public ValidationReport<TypeElement> validate(TypeElement subject) {
     ValidationReport.Builder<TypeElement> builder = ValidationReport.Builder.about(subject);
-    Component.Builder builderAnnotation = subject.getAnnotation(Component.Builder.class);
-    checkArgument(builderAnnotation != null);
 
     Element componentElement = subject.getEnclosingElement();
-    if (!isAnnotationPresent(componentElement, Component.class)) {
-      builder.addItem(BUILDER_MUST_BE_IN_COMPONENT, subject);
+    ErrorMessages.ComponentBuilderMessages msgs = ErrorMessages.builderMsgsFor(componentType);
+    Class<? extends Annotation> componentAnnotation = componentType.annotationType();
+    Class<? extends Annotation> builderAnnotation = componentType.builderAnnotationType();
+    checkArgument(subject.getAnnotation(builderAnnotation) != null);
+    
+    if (!isAnnotationPresent(componentElement, componentAnnotation)) {
+      builder.addItem(msgs.mustBeInComponent(), subject);
     }
 
     switch (subject.getKind()) {
@@ -90,32 +77,32 @@
         List<? extends Element> allElements = subject.getEnclosedElements();
         List<ExecutableElement> cxtors = ElementFilter.constructorsIn(allElements);
         if (cxtors.size() != 1 || getOnlyElement(cxtors).getParameters().size() != 0) {
-          builder.addItem(BUILDER_CXTOR_ONLY_ONE_AND_NO_ARGS, subject);
+          builder.addItem(msgs.cxtorOnlyOneAndNoArgs(), subject);
         }
         break;
       case INTERFACE:
         break;
       default:
         // If not the correct type, exit early since the rest of the messages will be bogus.
-        builder.addItem(BUILDER_MUST_BE_CLASS_OR_INTERFACE, subject);
+        builder.addItem(msgs.mustBeClassOrInterface(), subject);
         return builder.build(); 
     }    
 
     
     if (!subject.getTypeParameters().isEmpty()) {
-      builder.addItem(BUILDER_GENERICS, subject);
+      builder.addItem(msgs.generics(), subject);
     }
 
     Set<Modifier> modifiers = subject.getModifiers();
     if (modifiers.contains(PRIVATE)) {
-      builder.addItem(BUILDER_PRIVATE, subject);
+      builder.addItem(msgs.isPrivate(), subject);
     }
     if (!modifiers.contains(STATIC)) {
-      builder.addItem(BUILDER_MUST_BE_STATIC, subject);
+      builder.addItem(msgs.mustBeStatic(), subject);
     }
     // Note: Must be abstract, so no need to check for final.
     if (!modifiers.contains(ABSTRACT)) {
-      builder.addItem(BUILDER_MUST_BE_ABSTRACT, subject);
+      builder.addItem(msgs.mustBeAbstract(), subject);
     }
     
     ExecutableElement buildMethod = null;
@@ -124,30 +111,29 @@
     for (ExecutableElement method : Util.getUnimplementedMethods(elements, subject)) {
       ExecutableType resolvedMethodType =
           MoreTypes.asExecutable(types.asMemberOf(MoreTypes.asDeclared(subject.asType()), method));
-      TypeMirror returnType = resolvedMethodType.getReturnType();      
+      TypeMirror returnType = resolvedMethodType.getReturnType();
       if (method.getParameters().size() == 0) {
         // If this is potentially a build() method, validate it returns the correct type.
         if (types.isSameType(returnType, componentElement.asType())) {
           if (buildMethod != null) {
             // If we found more than one build-like method, fail.
-            error(builder, method, BUILDER_TWO_BUILD_METHODS, BUILDER_INHERITED_TWO_BUILD_METHODS,
+            error(builder, method, msgs.twoBuildMethods(), msgs.inheritedTwoBuildMethods(),
                 buildMethod);
           }
         } else {
-          error(builder, method, BUILDER_BUILD_MUST_RETURN_COMPONENT_TYPE,
-              BUILDER_INHERITED_BUILD_MUST_RETURN_COMPONENT_TYPE);
+          error(builder, method, msgs.buildMustReturnComponentType(),
+              msgs.inheritedBuildMustReturnComponentType());
         }
         // We set the buildMethod regardless of the return type to reduce error spam.
         buildMethod = method;
       } else if (method.getParameters().size() > 1) {
         // If this is a setter, make sure it has one arg.
-        error(builder, method, BUILDER_METHOD_MUST_TAKE_ONE_ARG,
-            BUILDER_INHERITED_METHOD_MUST_TAKE_ONE_ARG);
+        error(builder, method, msgs.methodsMustTakeOneArg(), msgs.inheritedMethodsMustTakeOneArg());
       } else if (returnType.getKind() != TypeKind.VOID
           && !types.isSubtype(subject.asType(), returnType)) {
         // If this correctly had one arg, make sure the return types are valid.
-        error(builder, method, BUILDER_METHODS_MUST_RETURN_VOID_OR_BUILDER,
-            BUILDER_INHERITED_METHODS_MUST_RETURN_VOID_OR_BUILDER);
+        error(builder, method, msgs.methodsMustReturnVoidOrBuilder(),
+            msgs.inheritedMethodsMustReturnVoidOrBuilder());
       } else {
         // If the return types are valid, record the method.
         methodsPerParam.put(
@@ -157,13 +143,13 @@
       }
       
       if (!method.getTypeParameters().isEmpty()) {
-        error(builder, method, BUILDER_METHODS_MAY_NOT_HAVE_TYPE_PARAMETERS,
-            BUILDER_INHERITED_METHODS_MAY_NOT_HAVE_TYPE_PARAMETERS);
+        error(builder, method, msgs.methodsMayNotHaveTypeParameters(),
+            msgs.inheritedMethodsMayNotHaveTypeParameters());
       }
     }
     
     if (buildMethod == null) {
-      builder.addItem(BUILDER_MISSING_BUILD_METHOD, subject);
+      builder.addItem(msgs.missingBuildMethod(), subject);
     }
     
     // Go back through each recorded method per param type.  If we had more than one method
@@ -172,9 +158,7 @@
         methodsPerParam.asMap().entrySet()) {
       if (entry.getValue().size() > 1) {
         TypeMirror type = entry.getKey().get();
-        builder.addItem(
-            String.format(ErrorMessages.BUILDER_MANY_METHODS_FOR_TYPE, type, entry.getValue()),
-            subject);
+        builder.addItem(String.format(msgs.manyMethodsForType(), type, entry.getValue()), subject);
       }
     }
     
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
index 012985370..6c514f99c 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
@@ -21,7 +21,7 @@
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Equivalence;
 import com.google.common.base.Optional;
-import com.google.common.base.Verify;
+import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.util.concurrent.ListenableFuture;
@@ -46,6 +46,7 @@
 import javax.lang.model.util.Types;
 
 import static com.google.auto.common.MoreElements.getAnnotationMirror;
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static com.google.common.base.Verify.verify;
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static dagger.internal.codegen.ConfigurationAnnotations.enclosedBuilders;
@@ -68,18 +69,25 @@
   ComponentDescriptor() {}
 
   enum Kind {
-    COMPONENT(Component.class),
-    PRODUCTION_COMPONENT(ProductionComponent.class);
+    COMPONENT(Component.class, Component.Builder.class),
+    SUBCOMPONENT(Subcomponent.class, Subcomponent.Builder.class),
+    PRODUCTION_COMPONENT(ProductionComponent.class, null);
 
     private final Class<? extends Annotation> annotationType;
+    private final Class<? extends Annotation> builderType;
 
-    Kind(Class<? extends Annotation> annotationType) {
+    Kind(Class<? extends Annotation> annotationType, Class<? extends Annotation> builderType) {
       this.annotationType = annotationType;
+      this.builderType = builderType;
     }
 
     Class<? extends Annotation> annotationType() {
       return annotationType;
     }
+    
+    Class<? extends Annotation> builderAnnotationType() {
+      return builderType;
+    }
   }
 
   abstract Kind kind();
@@ -143,6 +151,7 @@
     PRODUCTION,
     MEMBERS_INJECTION,
     SUBCOMPONENT,
+    SUBCOMPONENT_BUILDER,
   }
   
   @AutoValue
@@ -150,6 +159,7 @@
     abstract TypeElement builderDefinitionType();
     abstract Map<TypeElement, ExecutableElement> methodMap();
     abstract ExecutableElement buildMethod();
+    abstract TypeMirror componentType();
   }
 
   static final class Factory {
@@ -172,6 +182,7 @@ ComponentDescriptor forProductionComponent(TypeElement componentDefinitionType)
     }
 
     private ComponentDescriptor create(TypeElement componentDefinitionType, Kind kind) {
+      DeclaredType declaredComponentType = MoreTypes.asDeclared(componentDefinitionType.asType());
       AnnotationMirror componentMirror =
           getAnnotationMirror(componentDefinitionType, kind.annotationType())
               .or(getAnnotationMirror(componentDefinitionType, Subcomponent.class))
@@ -208,18 +219,32 @@ private ComponentDescriptor create(TypeElement componentDefinitionType, Kind kin
       ImmutableMap.Builder<ExecutableElement, ComponentDescriptor> subcomponentDescriptors =
           ImmutableMap.builder();
       for (ExecutableElement componentMethod : unimplementedMethods) {
+        ExecutableType resolvedMethod =
+            MoreTypes.asExecutable(types.asMemberOf(declaredComponentType, componentMethod));
         ComponentMethodDescriptor componentMethodDescriptor =
             getDescriptorForComponentMethod(componentDefinitionType, kind, componentMethod);
         componentMethodsBuilder.add(componentMethodDescriptor);
-        if (componentMethodDescriptor.kind().equals(ComponentMethodKind.SUBCOMPONENT)) {
-          subcomponentDescriptors.put(componentMethod,
-              create(MoreElements.asType(MoreTypes.asElement(componentMethod.getReturnType())),
-                  Kind.COMPONENT));
+        switch (componentMethodDescriptor.kind()) {
+          case SUBCOMPONENT:
+            subcomponentDescriptors.put(componentMethod,
+                create(MoreElements.asType(MoreTypes.asElement(resolvedMethod.getReturnType())),
+                    Kind.SUBCOMPONENT));
+            break;
+          case SUBCOMPONENT_BUILDER:
+            subcomponentDescriptors.put(componentMethod, create(MoreElements.asType(
+                MoreTypes.asElement(resolvedMethod.getReturnType()).getEnclosingElement()),
+                    Kind.SUBCOMPONENT));
+            break;
+          default: // nothing special to do for other methods.
         }
+        
       }
       
-      Optional<DeclaredType> builderType = Optional.fromNullable(
-          getOnlyElement(enclosedBuilders(componentDefinitionType), null));
+      ImmutableList<DeclaredType> enclosedBuilders = kind.builderAnnotationType() == null
+          ? ImmutableList.<DeclaredType>of()
+          : enclosedBuilders(componentDefinitionType, kind.builderAnnotationType());
+      Optional<DeclaredType> builderType =
+          Optional.fromNullable(getOnlyElement(enclosedBuilders, null));        
 
       Optional<AnnotationMirror> scope = getScopeAnnotation(componentDefinitionType);
       return new AutoValue_ComponentDescriptor(
@@ -256,12 +281,17 @@ private ComponentMethodDescriptor getDescriptorForComponentMethod(TypeElement co
                   componentMethod,
                   resolvedComponentMethod)),
               componentMethod);
-        } else if (getAnnotationMirror(MoreTypes.asElement(returnType), Subcomponent.class)
-            .isPresent()) {
+        } else if (isAnnotationPresent(MoreTypes.asElement(returnType), Subcomponent.class)) {
           return new AutoValue_ComponentDescriptor_ComponentMethodDescriptor(
               ComponentMethodKind.SUBCOMPONENT,
               Optional.<DependencyRequest>absent(),
               componentMethod);
+        } else if (isAnnotationPresent(MoreTypes.asElement(returnType),
+            Subcomponent.Builder.class)) {
+          return new AutoValue_ComponentDescriptor_ComponentMethodDescriptor(
+              ComponentMethodKind.SUBCOMPONENT_BUILDER,
+              Optional.<DependencyRequest>absent(),
+              componentMethod);
         }
       }
 
@@ -270,6 +300,7 @@ private ComponentMethodDescriptor getDescriptorForComponentMethod(TypeElement co
           && !componentMethod.getReturnType().getKind().equals(VOID)) {
         switch (componentKind) {
           case COMPONENT:
+          case SUBCOMPONENT:
             return new AutoValue_ComponentDescriptor_ComponentMethodDescriptor(
                 ComponentMethodKind.PROVISON,
                 Optional.of(dependencyRequestFactory.forComponentProvisionMethod(componentMethod,
@@ -319,8 +350,8 @@ private ComponentMethodDescriptor getDescriptorForComponentMethod(TypeElement co
         }
       }
       verify(buildMethod != null); // validation should have ensured this.
-      return Optional.<BuilderSpec>of(
-          new AutoValue_ComponentDescriptor_BuilderSpec(element, map.build(), buildMethod));
+      return Optional.<BuilderSpec>of(new AutoValue_ComponentDescriptor_BuilderSpec(element,
+          map.build(), buildMethod, element.getEnclosingElement().asType()));
     }
   }
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
index 2e1538e4a..62fd4f46d 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
@@ -24,6 +24,7 @@
 import com.google.common.base.Functions;
 import com.google.common.base.Joiner;
 import com.google.common.base.Optional;
+import com.google.common.base.Predicate;
 import com.google.common.base.Predicates;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
@@ -236,13 +237,45 @@ Snippet getSnippetFor(ClassName usingClass) {
     return ImmutableSet.copyOf(javaWriters);
   }
 
-  private ImmutableMap<BindingKey, MemberSelect> writeComponent(
-      BindingGraph input, ClassName componentDefinitionTypeName, ClassWriter componentWriter,
-      Set<JavaWriter> proxyWriters) {
-    ClassWriter builderWriter = componentWriter.addNestedClass("Builder");
-    builderWriter.addModifiers(STATIC, FINAL);
-    builderWriter.addConstructor().addModifiers(PRIVATE);
+  /**
+   * Writes out a builder for a component or subcomponent.
+   *
+   * @param input the component or subcomponent
+   * @param componentApiName the API name of the component we're building (not our impl)
+   * @param componentImplName the implementation name of the component we're building
+   * @param componentWriter the class we're adding this builder to
+   * @param componentContributionFields a map of member selects so we can later use the fields
+   */
+  private ClassWriter writeBuilder(BindingGraph input, ClassName componentApiName,
+      ClassName componentImplName, ClassWriter componentWriter,
+      Map<TypeElement, MemberSelect> componentContributionFields) {
+    ClassWriter builderWriter;
     Optional<BuilderSpec> builderSpec = input.componentDescriptor().builderSpec();
+    switch (input.componentDescriptor().kind()) {
+      case COMPONENT:
+      case PRODUCTION_COMPONENT:
+        builderWriter = componentWriter.addNestedClass("Builder");
+        builderWriter.addModifiers(STATIC);
+
+        // Only top-level components have the factory builder() method.
+        // Mirror the user's builder API type if they had one.
+        MethodWriter builderFactoryMethod = builderSpec.isPresent()
+            ? componentWriter.addMethod(
+                builderSpec.get().builderDefinitionType().asType(), "builder")
+            : componentWriter.addMethod(builderWriter, "builder");
+        builderFactoryMethod.addModifiers(PUBLIC, STATIC);
+        builderFactoryMethod.body().addSnippet("return new %s();", builderWriter.name());
+        break;
+      case SUBCOMPONENT:
+        verify(builderSpec.isPresent()); // we only write subcomponent builders if there was a spec
+        builderWriter =
+            componentWriter.addNestedClass(componentApiName.simpleName() + "Builder");
+        break;
+      default:
+        throw new IllegalStateException();
+    }
+    builderWriter.addModifiers(FINAL);
+    builderWriter.addConstructor().addModifiers(PRIVATE);
     if (builderSpec.isPresent()) {
       builderWriter.addModifiers(PRIVATE);
       TypeElement builderType = builderSpec.get().builderDefinitionType();
@@ -260,14 +293,6 @@ Snippet getSnippetFor(ClassName usingClass) {
       builderWriter.addModifiers(PUBLIC);
     }
 
-    MethodWriter builderFactoryMethod;
-    // If the user gave us a builder API, the factory method should return that (not our subclass).
-    builderFactoryMethod = builderSpec.isPresent()
-        ? componentWriter.addMethod(builderSpec.get().builderDefinitionType().asType(), "builder")
-        : componentWriter.addMethod(builderWriter, "builder");
-    builderFactoryMethod.addModifiers(PUBLIC, STATIC);
-    builderFactoryMethod.body().addSnippet("return new %s();", builderWriter.name());
-
     // the full set of types that calling code uses to construct a component instance
     ImmutableMap<TypeElement, String> componentContributionNames =
         ImmutableMap.copyOf(Maps.asMap(
@@ -284,36 +309,27 @@ Snippet getSnippetFor(ClassName usingClass) {
                   }
                 })));
 
-    ConstructorWriter constructorWriter = componentWriter.addConstructor();
-    constructorWriter.addModifiers(PRIVATE);
-    constructorWriter.addParameter(builderWriter, "builder");
-    constructorWriter.body().addSnippet("assert builder != null;");
-
     MethodWriter buildMethod;
     if (builderSpec.isPresent()) {
       ExecutableElement specBuildMethod = builderSpec.get().buildMethod();
       // Note: we don't use the specBuildMethod.getReturnType() as the return type
       // because it might be a type variable.  We make use of covariant returns to allow
       // us to return the component type, which will always be valid.
-      buildMethod = builderWriter.addMethod(componentDefinitionTypeName,
+      buildMethod = builderWriter.addMethod(componentApiName,
           specBuildMethod.getSimpleName().toString());
       buildMethod.annotate(Override.class);
     } else {
-      buildMethod = builderWriter.addMethod(componentDefinitionTypeName, "build");
+      buildMethod = builderWriter.addMethod(componentApiName, "build");
     }
     buildMethod.addModifiers(PUBLIC);
 
-    boolean requiresBuilder = false;
-
-    Map<TypeElement, MemberSelect> componentContributionFields = Maps.newHashMap();
-
     for (Entry<TypeElement, String> entry : componentContributionNames.entrySet()) {
       TypeElement contributionElement = entry.getKey();
       String contributionName = entry.getValue();
       FieldWriter builderField = builderWriter.addField(contributionElement, contributionName);
       builderField.addModifiers(PRIVATE);
       componentContributionFields.put(contributionElement, MemberSelect.instanceSelect(
-          componentWriter.name(), Snippet.format("builder.%s", builderField.name())));
+          componentImplName, Snippet.format("builder.%s", builderField.name())));
       if (componentCanMakeNewInstances(contributionElement)) {
         buildMethod.body()
             .addSnippet("if (%s == null) {", builderField.name())
@@ -321,7 +337,6 @@ Snippet getSnippetFor(ClassName usingClass) {
                 builderField.name(), ClassName.fromTypeElement(contributionElement))
             .addSnippet("}");
       } else {
-        requiresBuilder = true;
         buildMethod.body()
             .addSnippet("if (%s == null) {", builderField.name())
             .addSnippet("  throw new IllegalStateException(\"%s must be set\");",
@@ -364,14 +379,41 @@ Snippet getSnippetFor(ClassName usingClass) {
         builderMethod.body().addSnippet("return this;");
       }
     }
+    buildMethod.body().addSnippet("return new %s(this);", componentImplName);
+    return builderWriter;
+  }
 
-    if (!requiresBuilder) {
+  /** Returns true if the graph has any dependents that can't be automatically constructed. */
+  private boolean requiresUserSuppliedDependents(BindingGraph input) {
+    Set<TypeElement> allDependents =
+        Sets.union(
+            Sets.union(
+                input.transitiveModules().keySet(),
+                input.componentDescriptor().dependencies()),
+            input.componentDescriptor().executorDependency().asSet());
+    Set<TypeElement> userRequiredDependents =
+        Sets.filter(allDependents, new Predicate<TypeElement>() {
+          @Override public boolean apply(TypeElement input) {
+            return !Util.componentCanMakeNewInstances(input);
+          }
+        });
+    return !userRequiredDependents.isEmpty();
+  }
+
+  private ImmutableMap<BindingKey, MemberSelect> writeComponent(
+      BindingGraph input, ClassName componentDefinitionTypeName, ClassWriter componentWriter,
+      Set<JavaWriter> proxyWriters) {
+    Map<TypeElement, MemberSelect> componentContributionFields = Maps.newHashMap();
+    ClassWriter builderWriter = writeBuilder(input, componentDefinitionTypeName,
+        componentWriter.name(), componentWriter, componentContributionFields);
+    if (!requiresUserSuppliedDependents(input)) {
       MethodWriter factoryMethod = componentWriter.addMethod(componentDefinitionTypeName, "create");
       factoryMethod.addModifiers(PUBLIC, STATIC);
       // TODO(gak): replace this with something that doesn't allocate a builder
       factoryMethod.body().addSnippet("return builder().%s();",
-          builderSpec.isPresent()
-              ? builderSpec.get().buildMethod().getSimpleName() : "build");
+          input.componentDescriptor().builderSpec().isPresent()
+              ? input.componentDescriptor().builderSpec().get().buildMethod().getSimpleName()
+              : "build");
     }
 
     Map<BindingKey, MemberSelect> memberSelectSnippetsBuilder = Maps.newHashMap();
@@ -389,14 +431,16 @@ Snippet getSnippetFor(ClassName usingClass) {
         enumBindingKeysBuilder,
         packageProxies);
 
-    buildMethod.body().addSnippet("return new %s(this);", componentWriter.name());
-
     ImmutableMap<BindingKey, MemberSelect> memberSelectSnippets =
         ImmutableMap.copyOf(memberSelectSnippetsBuilder);
     ImmutableMap<ContributionBinding, Snippet> multibindingContributionSnippets =
         ImmutableMap.copyOf(multibindingContributionSnippetsBuilder);
     ImmutableSet<BindingKey> enumBindingKeys = enumBindingKeysBuilder.build();
 
+    ConstructorWriter constructorWriter = componentWriter.addConstructor();
+    constructorWriter.addModifiers(PRIVATE);
+    constructorWriter.addParameter(builderWriter, "builder");
+    constructorWriter.body().addSnippet("assert builder != null;");
     initializeFrameworkTypes(input,
         componentWriter,
         constructorWriter,
@@ -410,6 +454,7 @@ Snippet getSnippetFor(ClassName usingClass) {
 
     for (Entry<ExecutableElement, BindingGraph> subgraphEntry : input.subgraphs().entrySet()) {
       writeSubcomponent(componentWriter,
+          MoreTypes.asDeclared(input.componentDescriptor().componentDefinitionType().asType()),
           proxyWriters,
           componentContributionFields,
           memberSelectSnippets,
@@ -422,19 +467,62 @@ Snippet getSnippetFor(ClassName usingClass) {
   }
 
   private void writeSubcomponent(ClassWriter componentWriter,
+      DeclaredType containingComponent,
       Set<JavaWriter> proxyWriters,
       Map<TypeElement, MemberSelect> parentContributionFields,
       ImmutableMap<BindingKey, MemberSelect> parentMemberSelectSnippets,
       ImmutableMap<ContributionBinding, Snippet> parentMultibindingContributionSnippets,
       ExecutableElement subcomponentFactoryMethod,
       BindingGraph subgraph) {
-    TypeMirror subcomponentType = subcomponentFactoryMethod.getReturnType();
-    TypeName subcomponentTypeName = TypeNames.forTypeMirror(subcomponentType);
+    ClassName subcomponentApiName =
+        ClassName.fromTypeElement(subgraph.componentDescriptor().componentDefinitionType());
+    ClassWriter subcomponentWriter =
+        componentWriter.addNestedClass(subcomponentApiName.simpleName() + "Impl");
+    subcomponentWriter.addModifiers(PRIVATE, FINAL);
 
-    ClassWriter subcomponentWriter = componentWriter.addNestedClass(
-        subgraph.componentDescriptor().componentDefinitionType().getSimpleName() + "Impl");
+    ConstructorWriter constructorWriter = subcomponentWriter.addConstructor();
+    constructorWriter.addModifiers(PRIVATE);
+    constructorWriter.body();
 
-    subcomponentWriter.addModifiers(PRIVATE, FINAL);
+    Map<TypeElement, MemberSelect> componentContributionFields =
+        Maps.newHashMap(parentContributionFields);
+    ImmutableList.Builder<Snippet> subcomponentConstructorParameters = ImmutableList.builder();
+
+    TypeMirror subcomponentType;
+    MethodWriter componentMethod;
+    Optional<ClassName> builderName;
+    if (subgraph.componentDescriptor().builderSpec().isPresent()) {
+      BuilderSpec spec = subgraph.componentDescriptor().builderSpec().get();
+      subcomponentType = spec.componentType();
+      componentMethod = componentWriter.addMethod(
+          ClassName.fromTypeElement(spec.builderDefinitionType()),
+          subcomponentFactoryMethod.getSimpleName().toString());
+      ClassWriter builderWriter = writeBuilder(subgraph, subcomponentApiName,
+          subcomponentWriter.name(), componentWriter, componentContributionFields);
+      builderName = Optional.of(builderWriter.name());
+      constructorWriter.addParameter(builderWriter, "builder");
+      constructorWriter.body().addSnippet("assert builder != null;");
+      componentMethod.body().addSnippet("return new %s();", builderWriter.name());
+    } else {
+      builderName = Optional.absent();
+      ExecutableType resolvedMethod =
+          MoreTypes.asExecutable(types.asMemberOf(containingComponent, subcomponentFactoryMethod));
+      subcomponentType = resolvedMethod.getReturnType();
+      componentMethod = componentWriter.addMethod(subcomponentType,
+          subcomponentFactoryMethod.getSimpleName().toString());
+      writeSubcomponentWithoutBuilder(subcomponentFactoryMethod,
+          subgraph,
+          subcomponentWriter,
+          constructorWriter,
+          componentContributionFields,
+          subcomponentConstructorParameters,
+          componentMethod,
+          resolvedMethod);
+    }
+    componentMethod.addModifiers(PUBLIC);
+    componentMethod.annotate(Override.class);
+
+    TypeName subcomponentTypeName = TypeNames.forTypeMirror(subcomponentType);
     Element subcomponentElement = MoreTypes.asElement(subcomponentType);
     switch (subcomponentElement.getKind()) {
       case CLASS:
@@ -448,69 +536,6 @@ private void writeSubcomponent(ClassWriter componentWriter,
         throw new IllegalStateException();
     }
 
-    MethodWriter componentMethod = componentWriter.addMethod(subcomponentTypeName,
-        subcomponentFactoryMethod.getSimpleName().toString());
-    componentMethod.addModifiers(PUBLIC);
-    componentMethod.annotate(Override.class);
-
-    ConstructorWriter constructorWriter = subcomponentWriter.addConstructor();
-    constructorWriter.addModifiers(PRIVATE);
-    constructorWriter.body();
-
-    Map<TypeElement, MemberSelect> componentContributionFields =
-        Maps.newHashMap(parentContributionFields);
-    ImmutableList.Builder<Snippet> subcomponentConstructorParameters = ImmutableList.builder();
-
-    for (VariableElement moduleVariable : subcomponentFactoryMethod.getParameters()) {
-      // safe because this passed validation
-      TypeElement moduleType = MoreTypes.asTypeElement(moduleVariable.asType());
-      verify(subgraph.transitiveModules().containsKey(moduleType));
-      componentMethod.addParameter(
-          TypeNames.forTypeMirror(moduleVariable.asType()),
-          moduleVariable.getSimpleName().toString());
-      if (!componentContributionFields.containsKey(moduleType)) {
-        String preferredModuleName = CaseFormat.UPPER_CAMEL.to(LOWER_CAMEL,
-            moduleType.getSimpleName().toString());
-        FieldWriter contributionField =
-            subcomponentWriter.addField(moduleType, preferredModuleName);
-        contributionField.addModifiers(PRIVATE, FINAL);
-        String actualModuleName = contributionField.name();
-        constructorWriter.addParameter(
-            TypeNames.forTypeMirror(moduleVariable.asType()), actualModuleName);
-        constructorWriter.body().addSnippet(Snippet.format(Joiner.on('\n').join(
-            "if (%s == null) {",
-            "  throw new NullPointerException();",
-            "}"), actualModuleName));
-        constructorWriter.body().addSnippet(
-            Snippet.format("this.%1$s = %1$s;", actualModuleName));
-        MemberSelect moduleSelect = MemberSelect.instanceSelect(
-            subcomponentWriter.name(), Snippet.format(actualModuleName));
-        componentContributionFields.put(moduleType, moduleSelect);
-        subcomponentConstructorParameters.add(Snippet.format("%s", moduleVariable.getSimpleName()));
-      }
-    }
-
-    SetView<TypeElement> uninitializedModules = Sets.difference(
-        subgraph.transitiveModules().keySet(), componentContributionFields.keySet());
-    for (TypeElement moduleType : uninitializedModules) {
-      String preferredModuleName = CaseFormat.UPPER_CAMEL.to(LOWER_CAMEL,
-          moduleType.getSimpleName().toString());
-      FieldWriter contributionField =
-          subcomponentWriter.addField(moduleType, preferredModuleName);
-      contributionField.addModifiers(PRIVATE, FINAL);
-      String actualModuleName = contributionField.name();
-      constructorWriter.body().addSnippet(
-          Snippet.format("this.%s = new %s();", actualModuleName,
-              ClassName.fromTypeElement(moduleType)));
-      MemberSelect moduleSelect = MemberSelect.instanceSelect(
-          subcomponentWriter.name(), Snippet.format(actualModuleName));
-      componentContributionFields.put(moduleType, moduleSelect);
-    }
-
-    componentMethod.body().addSnippet("return new %s(%s);",
-        subcomponentWriter.name(),
-        Snippet.makeParametersSnippet(subcomponentConstructorParameters.build()));
-
     Map<BindingKey, MemberSelect> memberSelectSnippetsBuilder = Maps.newHashMap();
 
     Map<ContributionBinding, Snippet> multibindingContributionSnippetsBuilder = Maps.newHashMap();
@@ -543,7 +568,7 @@ private void writeSubcomponent(ClassWriter componentWriter,
     initializeFrameworkTypes(subgraph,
         subcomponentWriter,
         constructorWriter,
-        Optional.<ClassName>absent(),
+        builderName,
         componentContributionFields,
         memberSelectSnippets,
         parentMultibindingContributionSnippets,
@@ -553,6 +578,7 @@ private void writeSubcomponent(ClassWriter componentWriter,
 
     for (Entry<ExecutableElement, BindingGraph> subgraphEntry : subgraph.subgraphs().entrySet()) {
       writeSubcomponent(subcomponentWriter,
+          MoreTypes.asDeclared(subgraph.componentDescriptor().componentDefinitionType().asType()),
           proxyWriters,
           componentContributionFields,
           memberSelectSnippets,
@@ -565,6 +591,66 @@ private void writeSubcomponent(ClassWriter componentWriter,
     }
   }
 
+  private void writeSubcomponentWithoutBuilder(ExecutableElement subcomponentFactoryMethod,
+      BindingGraph subgraph,
+      ClassWriter subcomponentWriter,
+      ConstructorWriter constructorWriter,
+      Map<TypeElement, MemberSelect> componentContributionFields,
+      ImmutableList.Builder<Snippet> subcomponentConstructorParameters,
+      MethodWriter componentMethod,
+      ExecutableType resolvedMethod) {
+    List<? extends VariableElement> params = subcomponentFactoryMethod.getParameters();
+    List<? extends TypeMirror> paramTypes = resolvedMethod.getParameterTypes();
+    for (int i = 0; i < params.size(); i++) {
+      VariableElement moduleVariable = params.get(i);
+      TypeElement moduleTypeElement = MoreTypes.asTypeElement(paramTypes.get(i));
+      TypeName moduleType = TypeNames.forTypeMirror(paramTypes.get(i));
+      verify(subgraph.transitiveModules().containsKey(moduleTypeElement));
+      componentMethod.addParameter(moduleType, moduleVariable.getSimpleName().toString());
+      if (!componentContributionFields.containsKey(moduleTypeElement)) {
+        String preferredModuleName = CaseFormat.UPPER_CAMEL.to(LOWER_CAMEL,
+            moduleTypeElement.getSimpleName().toString());
+        FieldWriter contributionField =
+            subcomponentWriter.addField(moduleTypeElement, preferredModuleName);
+        contributionField.addModifiers(PRIVATE, FINAL);
+        String actualModuleName = contributionField.name();
+        constructorWriter.addParameter(moduleType, actualModuleName);
+        constructorWriter.body().addSnippet(Snippet.format(Joiner.on('\n').join(
+            "if (%s == null) {",
+            "  throw new NullPointerException();",
+            "}"), actualModuleName));
+        constructorWriter.body().addSnippet(
+            Snippet.format("this.%1$s = %1$s;", actualModuleName));
+        MemberSelect moduleSelect = MemberSelect.instanceSelect(
+            subcomponentWriter.name(), Snippet.format(actualModuleName));
+        componentContributionFields.put(moduleTypeElement, moduleSelect);
+        subcomponentConstructorParameters.add(
+            Snippet.format("%s", moduleVariable.getSimpleName()));
+      }
+    }
+
+    SetView<TypeElement> uninitializedModules = Sets.difference(
+        subgraph.transitiveModules().keySet(), componentContributionFields.keySet());
+    for (TypeElement moduleType : uninitializedModules) {
+      String preferredModuleName = CaseFormat.UPPER_CAMEL.to(LOWER_CAMEL,
+          moduleType.getSimpleName().toString());
+      FieldWriter contributionField =
+          subcomponentWriter.addField(moduleType, preferredModuleName);
+      contributionField.addModifiers(PRIVATE, FINAL);
+      String actualModuleName = contributionField.name();
+      constructorWriter.body().addSnippet(
+          Snippet.format("this.%s = new %s();", actualModuleName,
+              ClassName.fromTypeElement(moduleType)));
+      MemberSelect moduleSelect = MemberSelect.instanceSelect(
+          subcomponentWriter.name(), Snippet.format(actualModuleName));
+      componentContributionFields.put(moduleType, moduleSelect);
+    }
+
+    componentMethod.body().addSnippet("return new %s(%s);",
+        subcomponentWriter.name(),
+        Snippet.makeParametersSnippet(subcomponentConstructorParameters.build()));
+  }
+
   private void writeFields(BindingGraph input,
       ClassWriter componentWriter,
       Set<JavaWriter> proxyWriters,
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java
index 691fe0835..bfb2f5654 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java
@@ -21,7 +21,9 @@
 import com.google.common.collect.Maps;
 import com.google.common.collect.SetMultimap;
 import dagger.Component;
+import dagger.Subcomponent;
 import dagger.internal.codegen.ComponentDescriptor.Factory;
+import dagger.internal.codegen.ComponentValidator.ComponentValidationReport;
 import java.lang.annotation.Annotation;
 import java.util.Map;
 import java.util.Set;
@@ -38,7 +40,9 @@
 final class ComponentProcessingStep implements ProcessingStep {
   private final Messager messager;
   private final ComponentValidator componentValidator;
-  private final BuilderValidator builderValidator;
+  private final ComponentValidator subcomponentValidator;
+  private final BuilderValidator componentBuilderValidator;
+  private final BuilderValidator subcomponentBuilderValidator;
   private final BindingGraphValidator bindingGraphValidator;
   private final ComponentDescriptor.Factory componentDescriptorFactory;
   private final BindingGraph.Factory bindingGraphFactory;
@@ -47,15 +51,19 @@
   ComponentProcessingStep(
       Messager messager,
       ComponentValidator componentValidator,
-      BuilderValidator builderValidator,
+      ComponentValidator subcomponentValidator,
+      BuilderValidator componentBuilderValidator,
+      BuilderValidator subcomponentBuilderValidator,
       BindingGraphValidator bindingGraphValidator,
       Factory componentDescriptorFactory,
       BindingGraph.Factory bindingGraphFactory,
       ComponentGenerator componentGenerator) {
     this.messager = messager;
     this.componentValidator = componentValidator;
+    this.subcomponentValidator = subcomponentValidator;
+    this.componentBuilderValidator = componentBuilderValidator;
+    this.subcomponentBuilderValidator = subcomponentBuilderValidator;
     this.bindingGraphValidator = bindingGraphValidator;
-    this.builderValidator = builderValidator;
     this.componentDescriptorFactory = componentDescriptorFactory;
     this.bindingGraphFactory = bindingGraphFactory;
     this.componentGenerator = componentGenerator;
@@ -63,28 +71,50 @@
 
   @Override
   public Set<Class<? extends Annotation>> annotations() {
-    return ImmutableSet.<Class<? extends Annotation>>of(Component.class, Component.Builder.class);
+    return ImmutableSet.<Class<? extends Annotation>>of(Component.class, Component.Builder.class,
+        Subcomponent.class, Subcomponent.Builder.class);
   }
 
   @Override
   public void process(SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
-    Set<? extends Element> builderElements = elementsByAnnotation.get(Component.Builder.class);
+    Set<? extends Element> componentBuilderElements =
+        elementsByAnnotation.get(Component.Builder.class);
     Map<Element, ValidationReport<TypeElement>> builderReportsByComponent = Maps.newHashMap();
-    for (Element element : builderElements) {
-      ValidationReport<TypeElement> builderReport =
-          builderValidator.validate(MoreElements.asType(element));
-      builderReport.printMessagesTo(messager);
-      builderReportsByComponent.put(element.getEnclosingElement(), builderReport);
+    for (Element element : componentBuilderElements) {
+      ValidationReport<TypeElement> report =
+          componentBuilderValidator.validate(MoreElements.asType(element));
+      report.printMessagesTo(messager);
+      builderReportsByComponent.put(element.getEnclosingElement(), report);
+    }
+    
+    Set<? extends Element> subcomponentBuilderElements =
+        elementsByAnnotation.get(Subcomponent.Builder.class);
+    Map<Element, ValidationReport<TypeElement>> builderReportsBySubcomponent = Maps.newHashMap();
+    for (Element element : subcomponentBuilderElements) {
+      ValidationReport<TypeElement> report =
+          subcomponentBuilderValidator.validate(MoreElements.asType(element));
+      report.printMessagesTo(messager);
+      builderReportsBySubcomponent.put(element, report);
+    }
+    
+    Set<? extends Element> subcomponentElements =
+        elementsByAnnotation.get(Subcomponent.class);
+    Map<Element, ValidationReport<TypeElement>> reportsBySubcomponent = Maps.newHashMap();
+    for (Element element : subcomponentElements) {
+      ComponentValidationReport report = subcomponentValidator.validate(
+          MoreElements.asType(element), subcomponentElements, subcomponentBuilderElements);
+      report.report().printMessagesTo(messager);
+      reportsBySubcomponent.put(element, report.report());
     }
     
     Set<? extends Element> componentElements = elementsByAnnotation.get(Component.class);
     for (Element element : componentElements) {
       TypeElement componentTypeElement = MoreElements.asType(element);
-      ValidationReport<TypeElement> componentReport =
-          componentValidator.validate(componentTypeElement);
-      componentReport.printMessagesTo(messager);
-      ValidationReport<TypeElement> builderReport = builderReportsByComponent.get(element);
-      if (componentReport.isClean() && (builderReport == null || builderReport.isClean())) {
+      ComponentValidationReport report = componentValidator.validate(
+          componentTypeElement, subcomponentElements, subcomponentBuilderElements);
+      report.report().printMessagesTo(messager);
+      if (isClean(report, builderReportsByComponent, reportsBySubcomponent,
+          builderReportsBySubcomponent)) {
         ComponentDescriptor componentDescriptor =
             componentDescriptorFactory.forComponent(componentTypeElement);
         BindingGraph bindingGraph = bindingGraphFactory.create(componentDescriptor);
@@ -101,4 +131,34 @@ public void process(SetMultimap<Class<? extends Annotation>, Element> elementsBy
       }
     }
   }
+
+  /**
+   * Returns true if the component's report is clean, its builder report is clean, and all
+   * referenced subcomponent reports & subcomponent builder reports are clean.
+   */
+  private boolean isClean(ComponentValidationReport report,
+      Map<Element, ValidationReport<TypeElement>> builderReportsByComponent,
+      Map<Element, ValidationReport<TypeElement>> reportsBySubcomponent,
+      Map<Element, ValidationReport<TypeElement>> builderReportsBySubcomponent) {
+    Element component = report.report().subject();
+    ValidationReport<?> componentReport = report.report();
+    if (!componentReport.isClean()) {
+      return false;
+    }
+    ValidationReport<?> builderReport = builderReportsByComponent.get(component);
+    if (builderReport != null && !builderReport.isClean()) {
+      return false;
+    }
+    for (Element element : report.referencedSubcomponents()) {
+      ValidationReport<?> subcomponentBuilderReport = builderReportsBySubcomponent.get(element);
+      if (subcomponentBuilderReport != null && !subcomponentBuilderReport.isClean()) {
+        return false;
+      }
+      ValidationReport<?> subcomponentReport = reportsBySubcomponent.get(element);
+      if (subcomponentReport != null && !subcomponentReport.isClean()) {
+        return false;
+      }
+    }
+    return true;    
+  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
index 8b452b68f..1214684ec 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -86,9 +86,14 @@ public SourceVersion getSupportedSourceVersion() {
     ModuleValidator moduleValidator = new ModuleValidator(types, elements, methodSignatureFormatter,
         Module.class, Provides.class);
     ProvidesMethodValidator providesMethodValidator = new ProvidesMethodValidator(elements);
-    ComponentValidator componentValidator =
-        new ComponentValidator(elements, types, moduleValidator);
-    BuilderValidator builderValidator = new BuilderValidator(elements, types);
+    BuilderValidator componentBuilderValidator =
+        new BuilderValidator(elements, types, ComponentDescriptor.Kind.COMPONENT);
+    BuilderValidator subcomponentBuilderValidator =
+        new BuilderValidator(elements, types, ComponentDescriptor.Kind.SUBCOMPONENT);
+    ComponentValidator subcomponentValidator = ComponentValidator.createForSubcomponent(elements,
+        types, moduleValidator, subcomponentBuilderValidator);
+    ComponentValidator componentValidator = ComponentValidator.createForComponent(elements, types,
+        moduleValidator, subcomponentValidator, subcomponentBuilderValidator);
     MapKeyValidator mapKeyValidator = new MapKeyValidator();
     ModuleValidator producerModuleValidator = new ModuleValidator(types, elements,
         methodSignatureFormatter, ProducerModule.class, Produces.class);
@@ -159,7 +164,9 @@ public SourceVersion getSupportedSourceVersion() {
         new ComponentProcessingStep(
             messager,
             componentValidator,
-            builderValidator,
+            subcomponentValidator,
+            componentBuilderValidator,
+            subcomponentBuilderValidator,
             bindingGraphValidator,
             componentDescriptorFactory,
             bindingGraphFactory,
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
index 1d32a6cc5..469b37591 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
@@ -17,6 +17,7 @@
 
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
+import com.google.auto.value.AutoValue;
 import com.google.common.base.Joiner;
 import com.google.common.base.Optional;
 import com.google.common.base.Predicate;
@@ -24,12 +25,17 @@
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
+import com.google.common.collect.LinkedHashMultimap;
+import com.google.common.collect.Multimap;
 import com.google.common.collect.Sets;
 import com.google.common.collect.Sets.SetView;
 import dagger.Component;
 import dagger.Module;
 import dagger.Subcomponent;
+import java.lang.annotation.Annotation;
+import java.util.Collection;
 import java.util.List;
+import java.util.Map;
 import java.util.Set;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
@@ -37,6 +43,7 @@
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.ExecutableType;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.ElementFilter;
 import javax.lang.model.util.Elements;
@@ -47,7 +54,6 @@
 import static dagger.internal.codegen.ConfigurationAnnotations.enclosedBuilders;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentModules;
 import static dagger.internal.codegen.ConfigurationAnnotations.getTransitiveModules;
-import static dagger.internal.codegen.ErrorMessages.BUILDER_MORE_THAN_ONE;
 import static dagger.internal.codegen.Util.componentCanMakeNewInstances;
 import static javax.lang.model.element.ElementKind.CLASS;
 import static javax.lang.model.element.ElementKind.INTERFACE;
@@ -59,51 +65,126 @@
  *
  * @author Gregory Kick
  */
-final class ComponentValidator implements Validator<TypeElement> {
+final class ComponentValidator {
   private final Elements elements;
   private final Types types;
+  private final ComponentDescriptor.Kind componentType;
   private final ModuleValidator moduleValidator;
+  private final ComponentValidator subcomponentValidator;
+  private final BuilderValidator subcomponentBuilderValidator;
+  
+  private ComponentValidator(Elements elements,
+      Types types,
+      ModuleValidator moduleValidator,
+      BuilderValidator subcomponentBuilderValidator) {
+    this.elements = elements;
+    this.types = types;
+    this.componentType = ComponentDescriptor.Kind.SUBCOMPONENT;
+    this.moduleValidator = moduleValidator;
+    this.subcomponentValidator = this;
+    this.subcomponentBuilderValidator = subcomponentBuilderValidator;
+  }
 
-  ComponentValidator(Elements elements, Types types, ModuleValidator moduleValidator) {
+  private ComponentValidator(Elements elements,
+      Types types,
+      ModuleValidator moduleValidator,
+      ComponentValidator subcomponentValidator,
+      BuilderValidator subcomponentBuilderValidator) {
     this.elements = elements;
     this.types = types;
+    this.componentType = ComponentDescriptor.Kind.COMPONENT;
     this.moduleValidator = moduleValidator;
+    this.subcomponentValidator = subcomponentValidator;
+    this.subcomponentBuilderValidator = subcomponentBuilderValidator;
+  }
+  
+  static ComponentValidator createForComponent(Elements elements,
+      Types types,
+      ModuleValidator moduleValidator,
+      ComponentValidator subcomponentValidator,
+      BuilderValidator subcomponentBuilderValidator) {
+    return new ComponentValidator(elements,
+        types,
+        moduleValidator,
+        subcomponentValidator,
+        subcomponentBuilderValidator);
+  }
+  
+  static ComponentValidator createForSubcomponent(Elements elements,
+      Types types,
+      ModuleValidator moduleValidator,
+      BuilderValidator subcomponentBuilderValidator) {
+    return new ComponentValidator(elements,
+        types,
+        moduleValidator,
+        subcomponentBuilderValidator);
+  }
+  
+  @AutoValue
+  static abstract class ComponentValidationReport {
+    abstract Set<Element> referencedSubcomponents();
+    abstract ValidationReport<TypeElement> report();
   }
 
-  @Override public ValidationReport<TypeElement> validate(final TypeElement subject) {
-    final ValidationReport.Builder<TypeElement> builder = ValidationReport.Builder.about(subject);
+  /**
+   * Validates the given component subject. Also validates any referenced subcomponents that aren't
+   * already included in the {@code validatedSubcomponents} set.
+   */
+  public ComponentValidationReport validate(final TypeElement subject,
+      Set<? extends Element> validatedSubcomponents,
+      Set<? extends Element> validatedSubcomponentBuilders) {
+    ValidationReport.Builder<TypeElement> builder = ValidationReport.Builder.about(subject);
 
     if (!subject.getKind().equals(INTERFACE)
         && !(subject.getKind().equals(CLASS) && subject.getModifiers().contains(ABSTRACT))) {
-      builder.addItem("@Component may only be applied to an interface or abstract class", subject);
+      builder.addItem(String.format("@%s may only be applied to an interface or abstract class",
+          componentType.annotationType().getSimpleName()), subject);
     }
     
-    ImmutableList<DeclaredType> builders = enclosedBuilders(subject);
+    ImmutableList<DeclaredType> builders =
+        enclosedBuilders(subject, componentType.builderAnnotationType());
     if (builders.size() > 1) {
-      builder.addItem(String.format(BUILDER_MORE_THAN_ONE, builders), subject);
+      builder.addItem(
+          String.format(ErrorMessages.builderMsgsFor(componentType).moreThanOne(), builders),
+          subject);
     }
+    
+    DeclaredType subjectType = MoreTypes.asDeclared(subject.asType());
 
+    // TODO(gak): This should use Util.findLocalAndInheritedMethods, otherwise
+    // it can return a logical method multiple times (including overrides, etc.)
     List<? extends Element> members = elements.getAllMembers(subject);
+    Multimap<Element, ExecutableElement> referencedSubcomponents = LinkedHashMultimap.create();
     for (ExecutableElement method : ElementFilter.methodsIn(members)) {
       if (method.getModifiers().contains(ABSTRACT)) {
+        ExecutableType resolvedMethod =
+            MoreTypes.asExecutable(types.asMemberOf(subjectType, method));
+        List<? extends TypeMirror> parameterTypes = resolvedMethod.getParameterTypes();
         List<? extends VariableElement> parameters = method.getParameters();
-        TypeMirror returnType = method.getReturnType();
+        TypeMirror returnType = resolvedMethod.getReturnType();
 
         // abstract methods are ones we have to implement, so they each need to be validated
         // first, check the return type.  if it's a subcomponent, validate that method as such.
-        Optional<AnnotationMirror> subcomponentAnnotation  = returnType.accept(
-            new SimpleTypeVisitor6<Optional<AnnotationMirror>, Void>() {
-              @Override protected Optional<AnnotationMirror> defaultAction(TypeMirror e, Void p) {
-                return Optional.absent();
-              }
-
-              @Override public Optional<AnnotationMirror> visitDeclared(DeclaredType t, Void p) {
-                return MoreElements.getAnnotationMirror(t.asElement(), Subcomponent.class);
-              }
-            }, null);
+        Optional<AnnotationMirror> subcomponentAnnotation =
+            checkForAnnotation(returnType, Subcomponent.class);
+        Optional<AnnotationMirror> subcomponentBuilderAnnotation =
+            checkForAnnotation(returnType, Subcomponent.Builder.class);
         if (subcomponentAnnotation.isPresent()) {
-          validateSubcomponentMethod(
-              builder, method, parameters, returnType, subcomponentAnnotation);
+          referencedSubcomponents.put(MoreTypes.asElement(returnType), method);
+          validateSubcomponentMethod(builder,
+              method,
+              parameters,
+              parameterTypes,
+              returnType,
+              subcomponentAnnotation);
+        } else if (subcomponentBuilderAnnotation.isPresent()) {
+          referencedSubcomponents.put(MoreTypes.asElement(returnType).getEnclosingElement(),
+              method);
+          validateSubcomponentBuilderMethod(builder,
+              method,
+              parameters,
+              returnType,
+              validatedSubcomponentBuilders);
         } else {
           // if it's not a subcomponent...
           switch (parameters.size()) {
@@ -113,9 +194,9 @@
               break;
             case 1:
               // one parameter means that it's a members injection method
-              VariableElement onlyParameter = Iterables.getOnlyElement(parameters);
+              TypeMirror onlyParameter = Iterables.getOnlyElement(parameterTypes);
               if (!(returnType.getKind().equals(VOID)
-                  || types.isSameType(returnType, onlyParameter.asType()))) {
+                  || types.isSameType(returnType, onlyParameter))) {
                 builder.addItem(
                     "Members injection methods may only return the injected type or void.",
                     method);
@@ -131,15 +212,47 @@
         }
       }
     }
+    
+    for (Map.Entry<Element, Collection<ExecutableElement>> entry :
+        referencedSubcomponents.asMap().entrySet()) {
+      if (entry.getValue().size() > 1) {
+        builder.addItem(
+            String.format(
+                ErrorMessages.SubcomponentBuilderMessages.INSTANCE.moreThanOneRefToSubcomponent(),
+                entry.getKey(), entry.getValue()),
+            subject);
+      }
+    }
 
-    AnnotationMirror componentMirror = getAnnotationMirror(subject, Component.class).get();
+    AnnotationMirror componentMirror =
+        getAnnotationMirror(subject, componentType.annotationType()).get();
     ImmutableList<TypeMirror> moduleTypes = getComponentModules(componentMirror);
     moduleValidator.validateReferencedModules(subject, builder, moduleTypes);
-    return builder.build();
+    
+    // Make sure we validate any subcomponents we're referencing, unless we know we validated
+    // them already in this pass.
+    // TODO(sameb): If subcomponents refer to each other and both aren't in
+    //              'validatedSubcomponents' (e.g, both aren't compiled in this pass),
+    //              then this can loop forever.
+    ImmutableSet.Builder<Element> allSubcomponents =
+        ImmutableSet.<Element>builder().addAll(referencedSubcomponents.keySet());
+    for (Element subcomponent :
+        Sets.difference(referencedSubcomponents.keySet(), validatedSubcomponents)) {
+      ComponentValidationReport subreport = subcomponentValidator.validate(
+          MoreElements.asType(subcomponent), validatedSubcomponents, validatedSubcomponentBuilders);
+      builder.addItems(subreport.report().items());
+      allSubcomponents.addAll(subreport.referencedSubcomponents());
+    }
+    
+    return new AutoValue_ComponentValidator_ComponentValidationReport(allSubcomponents.build(),
+        builder.build());
   }
 
   private void validateSubcomponentMethod(final ValidationReport.Builder<TypeElement> builder,
-      ExecutableElement method, List<? extends VariableElement> parameters, TypeMirror returnType,
+      ExecutableElement method,
+      List<? extends VariableElement> parameters,
+      List<? extends TypeMirror> parameterTypes,
+      TypeMirror returnType,
       Optional<AnnotationMirror> subcomponentAnnotation) {
     ImmutableSet<TypeElement> moduleTypes =
         MoreTypes.asTypeElements(getComponentModules(subcomponentAnnotation.get()));
@@ -158,8 +271,10 @@ private void validateSubcomponentMethod(final ValidationReport.Builder<TypeEleme
 
     Set<TypeElement> variableTypes = Sets.newHashSet();
 
-    for (VariableElement parameter : parameters) {
-      Optional<TypeElement> moduleType = parameter.asType().accept(
+    for (int i = 0; i < parameterTypes.size(); i++) {
+      VariableElement parameter = parameters.get(i);
+      TypeMirror parameterType = parameterTypes.get(i);
+      Optional<TypeElement> moduleType = parameterType.accept(
           new SimpleTypeVisitor6<Optional<TypeElement>, Void>() {
             @Override protected Optional<TypeElement> defaultAction(TypeMirror e, Void p) {
               return Optional.absent();
@@ -193,7 +308,7 @@ private void validateSubcomponentMethod(final ValidationReport.Builder<TypeEleme
         builder.addItem(
             String.format(
                 "Subcomponent factory methods may only accept modules, but %s is not.",
-                parameter.asType()),
+                parameterType),
             parameter);
       }
     }
@@ -210,4 +325,39 @@ private void validateSubcomponentMethod(final ValidationReport.Builder<TypeEleme
           method);
     }
   }
+
+  private void validateSubcomponentBuilderMethod(ValidationReport.Builder<TypeElement> builder,
+      ExecutableElement method, List<? extends VariableElement> parameters, TypeMirror returnType,
+      Set<? extends Element> validatedSubcomponentBuilders) {
+
+    if (!parameters.isEmpty()) {
+      builder.addItem(
+          ErrorMessages.SubcomponentBuilderMessages.INSTANCE.builderMethodRequiresNoArgs(), method);
+    }
+    
+    // If we haven't already validated the subcomponent builder itself, validate it now.
+    TypeElement builderElement = MoreTypes.asTypeElement(returnType);
+    if (!validatedSubcomponentBuilders.contains(builderElement)) {
+      // TODO(sameb): The builder validator right now assumes the element is being compiled
+      // in this pass, which isn't true here.  We should change error messages to spit out
+      // this method as the subject and add the original subject to the message output.
+      builder.addItems(subcomponentBuilderValidator.validate(builderElement).items());
+    }
+  }
+
+  
+  private Optional<AnnotationMirror> checkForAnnotation(TypeMirror type,
+      final Class<? extends Annotation> annotation) {
+    return type.accept(new SimpleTypeVisitor6<Optional<AnnotationMirror>, Void>() {
+      @Override
+      protected Optional<AnnotationMirror> defaultAction(TypeMirror e, Void p) {
+        return Optional.absent();
+      }
+
+      @Override
+      public Optional<AnnotationMirror> visitDeclared(DeclaredType t, Void p) {
+        return MoreElements.getAnnotationMirror(t.asElement(), annotation);
+      }
+    }, null);
+  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java b/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
index d533b5021..176755d3f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
@@ -31,6 +31,7 @@
 import dagger.Subcomponent;
 import dagger.producers.ProducerModule;
 import dagger.producers.ProductionComponent;
+import java.lang.annotation.Annotation;
 import java.util.List;
 import java.util.Queue;
 import java.util.Set;
@@ -41,7 +42,6 @@
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
-import javax.lang.model.type.TypeVisitor;
 import javax.lang.model.util.ElementFilter;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.SimpleTypeVisitor6;
@@ -154,11 +154,12 @@ static boolean isComponent(TypeElement componentDefinitionType) {
     return ImmutableSet.copyOf(moduleElements);
   }
   
-  /** Returns the enclosed elements annotated with {@link dagger.Component.Builder}. */
-  static ImmutableList<DeclaredType> enclosedBuilders(TypeElement typeElement) {
+  /** Returns the enclosed elements annotated with the given annotation type. */
+  static ImmutableList<DeclaredType> enclosedBuilders(TypeElement typeElement,
+      final Class<? extends Annotation> annotation) {
     final ImmutableList.Builder<DeclaredType> builders = ImmutableList.builder();
     for (TypeElement element : ElementFilter.typesIn(typeElement.getEnclosedElements())) {
-      if (MoreElements.isAnnotationPresent(element, Component.Builder.class)) {
+      if (MoreElements.isAnnotationPresent(element, annotation)) {
         builders.add(MoreTypes.asDeclared(element.asType()));
       }
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
index 4c9e9d574..a55dce46d 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
@@ -214,76 +214,142 @@
   static final String CANNOT_RETURN_NULL_FROM_NON_NULLABLE_PROVIDES_METHOD =
       "Cannot return null from a non-@Nullable @Provides method";
   
-  /** Errors for component builders. */
-  static final String BUILDER_MORE_THAN_ONE = "@Component has more than one @Component.Builder: %s";
-  
-  static final String BUILDER_CXTOR_ONLY_ONE_AND_NO_ARGS =
-      "@Component.Builder classes must have exactly one constructor,"
-      + " and it must not have any parameters";
-  
-  static final String BUILDER_GENERICS =
-      "@Component.Builder types must not have any generic types";
-  
-  static final String BUILDER_MUST_BE_IN_COMPONENT =
-      "@Component.Builder types must be nested within a @Component";
-  
-  static final String BUILDER_MUST_BE_CLASS_OR_INTERFACE =
-      "@Component.Builder types must be abstract classes or interfaces";
-  
-  static final String BUILDER_PRIVATE = "@Component.Builder types must not be private";
-  
-  static final String BUILDER_MUST_BE_STATIC = "@Component.Builder types must be static";
-  
-  static final String BUILDER_MUST_BE_ABSTRACT = "@Component.Builder types must be abstract";
-  
-  static final String BUILDER_MISSING_BUILD_METHOD =
-      "@Component.Builder types must have exactly one no-args method that returns the"
-      + " @Component type.";
-  
-  static final String BUILDER_MANY_METHODS_FOR_TYPE =
-      "@Component.Builder types must not have more than one setter method per type, but %s"
-      + " is set by %s";
-  
-  static final String BUILDER_EXTRA_SETTERS =
-      "@Component.Builder has setters for modules or components that aren't required: %s";
-  
-  static final String BUILDER_MISSING_SETTERS =
-      "@Component.Builder is missing setters for required modules or components: %s";
-  
-  static final String BUILDER_TWO_BUILD_METHODS =
-      "@Component.Builder types must have exactly one zero-arg method, and that"
-      + " method must return the @Component type. Already found: %s";
-  
-  static final String BUILDER_INHERITED_TWO_BUILD_METHODS =
-      "@Component.Builder types must have exactly one zero-arg method, and that"
-      + " method must return the @Component type. Found %s and %s";
-  
-  static final String BUILDER_BUILD_MUST_RETURN_COMPONENT_TYPE =
-      "@Component.Builder methods that have no arguments must return the @Component type";
-      
-  static final String BUILDER_INHERITED_BUILD_MUST_RETURN_COMPONENT_TYPE =
-      "@Component.Builder methods that have no arguments must return the @Component type"
-      + " Inherited method: %s";
-  
-  static final String BUILDER_METHOD_MUST_TAKE_ONE_ARG =
-      "@Component.Builder methods must not have more than one argument.";
-  
-  static final String BUILDER_INHERITED_METHOD_MUST_TAKE_ONE_ARG =
-      "@Component.Builder methods must not have more than one argument. Inherited method: %s";
-  
-  static final String BUILDER_METHODS_MUST_RETURN_VOID_OR_BUILDER =
-      "@Component.Builder setter methods must return void, the builder,"
-      + " or a supertype of the builder";
-  
-  static final String BUILDER_INHERITED_METHODS_MUST_RETURN_VOID_OR_BUILDER =
-      "@Component.Builder setter methods must return void, the builder,"
-      + "or a supertype of the builder. Inherited method: %s";
-  
-  static final String BUILDER_METHODS_MAY_NOT_HAVE_TYPE_PARAMETERS =
-      "@Component.Builder methods must not have type parameters";
-  
-  static final String BUILDER_INHERITED_METHODS_MAY_NOT_HAVE_TYPE_PARAMETERS =
-      "@Component.Builder methods must not have type parameters. Inherited method: %s";
+  static ComponentBuilderMessages builderMsgsFor(ComponentDescriptor.Kind kind) {
+    switch(kind) {
+      case COMPONENT:
+        return ComponentBuilderMessages.INSTANCE;
+      case SUBCOMPONENT:
+        return SubcomponentBuilderMessages.INSTANCE;
+      default:
+        throw new IllegalStateException(kind.toString());
+    }
+  }
+
+  static class ComponentBuilderMessages {
+    static final ComponentBuilderMessages INSTANCE = new ComponentBuilderMessages();
+
+    protected String process(String s) { return s; }
+    
+    /** Errors for component builders. */
+    final String moreThanOne() {
+      return process("@Component has more than one @Component.Builder: %s");
+    }
+    
+    final String cxtorOnlyOneAndNoArgs() {
+      return process("@Component.Builder classes must have exactly one constructor,"
+          + " and it must not have any parameters");
+    }
+    
+    final String generics() {
+      return process("@Component.Builder types must not have any generic types");
+    }
+    
+    final String mustBeInComponent() {
+      return process("@Component.Builder types must be nested within a @Component");
+    }
+    
+    final String mustBeClassOrInterface() {
+      return process("@Component.Builder types must be abstract classes or interfaces");
+    }
+    
+    final String isPrivate() {
+      return process("@Component.Builder types must not be private");
+    }
+    
+    final String mustBeStatic() {
+      return process("@Component.Builder types must be static");
+    }
+    
+    final String mustBeAbstract() {
+      return process("@Component.Builder types must be abstract");
+    }
+    
+    final String missingBuildMethod() {
+      return process("@Component.Builder types must have exactly one no-args method that "
+          + " returns the @Component type");
+    }
+    
+    final String manyMethodsForType() {
+      return process("@Component.Builder types must not have more than one setter method per type,"
+          + " but %s is set by %s");
+    }
+    
+    final String extraSetters() {
+      return process(
+          "@Component.Builder has setters for modules or components that aren't required: %s");
+    }
+    
+    final String missingSetters() {
+      return process(
+          "@Component.Builder is missing setters for required modules or components: %s");
+    }
+    
+    final String twoBuildMethods() {
+      return process("@Component.Builder types must have exactly one zero-arg method, and that"
+          + " method must return the @Component type. Already found: %s");
+    }
+    
+    final String inheritedTwoBuildMethods() {
+      return process("@Component.Builder types must have exactly one zero-arg method, and that"
+          + " method must return the @Component type. Found %s and %s");
+    }
+    
+    final String buildMustReturnComponentType() {
+      return process(
+          "@Component.Builder methods that have no arguments must return the @Component type");
+    }
+    
+    final String inheritedBuildMustReturnComponentType() {
+      return process(
+          "@Component.Builder methods that have no arguments must return the @Component type"
+          + " Inherited method: %s");
+    }
+    
+    final String methodsMustTakeOneArg() {
+      return process("@Component.Builder methods must not have more than one argument");
+    }
+    
+    final String inheritedMethodsMustTakeOneArg() {
+      return process(
+          "@Component.Builder methods must not have more than one argument. Inherited method: %s");
+    }
+    
+    final String methodsMustReturnVoidOrBuilder() {
+      return process("@Component.Builder setter methods must return void, the builder,"
+          + " or a supertype of the builder");
+    }
+    
+    final String inheritedMethodsMustReturnVoidOrBuilder() {
+      return process("@Component.Builder setter methods must return void, the builder,"
+          + "or a supertype of the builder. Inherited method: %s");
+    }
+    
+    final String methodsMayNotHaveTypeParameters() {
+      return process("@Component.Builder methods must not have type parameters");
+    }
+
+    final String inheritedMethodsMayNotHaveTypeParameters() {
+      return process(
+          "@Component.Builder methods must not have type parameters. Inherited method: %s");
+    }
+  }
+
+  static final class SubcomponentBuilderMessages extends ComponentBuilderMessages {
+    @SuppressWarnings("hiding")
+    static final SubcomponentBuilderMessages INSTANCE = new SubcomponentBuilderMessages();
+    
+    @Override protected String process(String s) {
+      return s.replaceAll("component", "subcomponent").replaceAll("Component", "Subcomponent");
+    }
+
+    String builderMethodRequiresNoArgs() {
+      return "Methods returning a @Subcomponent.Builder must have no arguments";
+    }
+    
+    String moreThanOneRefToSubcomponent() {
+      return "Only one method can create a given subcomponent. %s is created by: %s";
+    }
+  }
 
   /**
    * A regular expression to match a small list of specific packages deemed to
diff --git a/compiler/src/main/java/dagger/internal/codegen/ValidationReport.java b/compiler/src/main/java/dagger/internal/codegen/ValidationReport.java
index 6f1be009f..d9e9daef7 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ValidationReport.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ValidationReport.java
@@ -89,6 +89,11 @@ private Builder(T subject) {
     T getSubject() {
       return subject;
     }
+    
+    Builder<T> addItems(Iterable<Item> newItems) {
+      items.addAll(newItems);
+      return this;
+    }
 
     Builder<T> addItem(String message, Element element) {
       addItem(message, ERROR, element, Optional.<AnnotationMirror>absent());
diff --git a/compiler/src/test/java/dagger/internal/codegen/ComponentBuilderTest.java b/compiler/src/test/java/dagger/internal/codegen/ComponentBuilderTest.java
index e4f335bbd..de59af6ec 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ComponentBuilderTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ComponentBuilderTest.java
@@ -25,14 +25,14 @@
 import static com.google.common.truth.Truth.assertAbout;
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
-import static dagger.internal.codegen.ErrorMessages.BUILDER_INHERITED_BUILD_MUST_RETURN_COMPONENT_TYPE;
-import static dagger.internal.codegen.ErrorMessages.BUILDER_INHERITED_METHODS_MUST_RETURN_VOID_OR_BUILDER;
-import static dagger.internal.codegen.ErrorMessages.BUILDER_INHERITED_METHOD_MUST_TAKE_ONE_ARG;
 
 /** Tests for {@link dagger.Component.Builder} */
 @RunWith(JUnit4.class)
 public class ComponentBuilderTest {
   
+  private static final ErrorMessages.ComponentBuilderMessages MSGS =
+      ErrorMessages.ComponentBuilderMessages.INSTANCE;
+  
   @Test
   public void testEmptyBuilder() {
     JavaFileObject injectableTypeFile = JavaFileObjects.forSourceLines("test.SomeInjectableType",
@@ -328,7 +328,7 @@ public void testMoreThanOneBuilderFails() {
     assertAbout(javaSource()).that(componentFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
-        .withErrorContaining(String.format(ErrorMessages.BUILDER_MORE_THAN_ONE,
+        .withErrorContaining(String.format(MSGS.moreThanOne(),
             "[test.SimpleComponent.Builder, test.SimpleComponent.Builder2]"))
         .in(componentFile);
   }
@@ -352,7 +352,7 @@ public void testBuilderGenericsFails() {
     assertAbout(javaSource()).that(componentFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
-        .withErrorContaining(ErrorMessages.BUILDER_GENERICS)
+        .withErrorContaining(MSGS.generics())
         .in(componentFile);
   }
   
@@ -368,7 +368,7 @@ public void testBuilderNotInComponentFails() {
     assertAbout(javaSource()).that(builder)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
-        .withErrorContaining(ErrorMessages.BUILDER_MUST_BE_IN_COMPONENT)
+        .withErrorContaining(MSGS.mustBeInComponent())
         .in(builder);
   }
   
@@ -389,7 +389,7 @@ public void testBuilderMissingBuildMethodFails() {
     assertAbout(javaSource()).that(componentFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
-        .withErrorContaining(ErrorMessages.BUILDER_MISSING_BUILD_METHOD)
+        .withErrorContaining(MSGS.missingBuildMethod())
         .in(componentFile);
   }
   
@@ -410,7 +410,7 @@ public void testPrivateBuilderFails() {
     assertAbout(javaSource()).that(componentFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
-        .withErrorContaining(ErrorMessages.BUILDER_PRIVATE)
+        .withErrorContaining(MSGS.isPrivate())
         .in(componentFile);
   }
   
@@ -431,7 +431,7 @@ public void testNonStaticBuilderFails() {
     assertAbout(javaSource()).that(componentFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
-        .withErrorContaining(ErrorMessages.BUILDER_MUST_BE_STATIC)
+        .withErrorContaining(MSGS.mustBeStatic())
         .in(componentFile);
   }
   
@@ -452,7 +452,7 @@ public void testNonAbstractBuilderFails() {
     assertAbout(javaSource()).that(componentFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
-        .withErrorContaining(ErrorMessages.BUILDER_MUST_BE_ABSTRACT);
+        .withErrorContaining(MSGS.mustBeAbstract());
   }
   
   @Test
@@ -474,7 +474,7 @@ public void testBuilderOneCxtorWithArgsFails() {
     assertAbout(javaSource()).that(componentFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
-        .withErrorContaining(ErrorMessages.BUILDER_CXTOR_ONLY_ONE_AND_NO_ARGS)
+        .withErrorContaining(MSGS.cxtorOnlyOneAndNoArgs())
         .in(componentFile);
   }
   
@@ -498,7 +498,7 @@ public void testBuilderMoreThanOneCxtorFails() {
     assertAbout(javaSource()).that(componentFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
-        .withErrorContaining(ErrorMessages.BUILDER_CXTOR_ONLY_ONE_AND_NO_ARGS)
+        .withErrorContaining(MSGS.cxtorOnlyOneAndNoArgs())
         .in(componentFile);
   }
   
@@ -519,7 +519,7 @@ public void testBuilderEnumFails() {
     assertAbout(javaSource()).that(componentFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
-        .withErrorContaining(ErrorMessages.BUILDER_MUST_BE_CLASS_OR_INTERFACE)
+        .withErrorContaining(MSGS.mustBeClassOrInterface())
         .in(componentFile);
   }
   
@@ -542,7 +542,7 @@ public void testBuilderBuildReturnsWrongTypeFails() {
     assertAbout(javaSource()).that(componentFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
-        .withErrorContaining(ErrorMessages.BUILDER_BUILD_MUST_RETURN_COMPONENT_TYPE)
+        .withErrorContaining(MSGS.buildMustReturnComponentType())
             .in(componentFile).onLine(11);
   }
   
@@ -568,7 +568,7 @@ public void testInheritedBuilderBuildReturnsWrongTypeFails() {
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(
-            String.format(BUILDER_INHERITED_BUILD_MUST_RETURN_COMPONENT_TYPE, "build"))
+            String.format(MSGS.inheritedBuildMustReturnComponentType(), "build"))
             .in(componentFile).onLine(14);
   }
   
@@ -592,7 +592,7 @@ public void testTwoBuildMethodsFails() {
     assertAbout(javaSource()).that(componentFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
-        .withErrorContaining(String.format(ErrorMessages.BUILDER_TWO_BUILD_METHODS, "build()"))
+        .withErrorContaining(String.format(MSGS.twoBuildMethods(), "build()"))
             .in(componentFile).onLine(12);
   }
   
@@ -619,7 +619,7 @@ public void testInheritedTwoBuildMethodsFails() {
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(
-            String.format(ErrorMessages.BUILDER_INHERITED_TWO_BUILD_METHODS, "create()", "build()"))
+            String.format(MSGS.inheritedTwoBuildMethods(), "create()", "build()"))
             .in(componentFile).onLine(15);
   }
   
@@ -644,9 +644,9 @@ public void testMoreThanOneArgFails() {
     assertAbout(javaSource()).that(componentFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
-        .withErrorContaining(ErrorMessages.BUILDER_METHOD_MUST_TAKE_ONE_ARG)
+        .withErrorContaining(MSGS.methodsMustTakeOneArg())
             .in(componentFile).onLine(12)
-        .and().withErrorContaining(ErrorMessages.BUILDER_METHOD_MUST_TAKE_ONE_ARG)
+        .and().withErrorContaining(MSGS.methodsMustTakeOneArg())
             .in(componentFile).onLine(13);
   }
   
@@ -673,7 +673,7 @@ public void testInheritedMoreThanOneArgFails() {
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(
-            String.format(BUILDER_INHERITED_METHOD_MUST_TAKE_ONE_ARG,
+            String.format(MSGS.inheritedMethodsMustTakeOneArg(),
                 "set1(java.lang.String,java.lang.Integer)"))
             .in(componentFile).onLine(15);
   }
@@ -698,7 +698,7 @@ public void testSetterReturningNonVoidOrBuilderFails() {
     assertAbout(javaSource()).that(componentFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
-        .withErrorContaining(ErrorMessages.BUILDER_METHODS_MUST_RETURN_VOID_OR_BUILDER)
+        .withErrorContaining(MSGS.methodsMustReturnVoidOrBuilder())
             .in(componentFile).onLine(12);
   }
   
@@ -725,7 +725,7 @@ public void testInheritedSetterReturningNonVoidOrBuilderFails() {
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(
-            String.format(BUILDER_INHERITED_METHODS_MUST_RETURN_VOID_OR_BUILDER,
+            String.format(MSGS.inheritedMethodsMustReturnVoidOrBuilder(),
                 "set(java.lang.Integer)"))
             .in(componentFile).onLine(15);    
   }
@@ -750,7 +750,7 @@ public void testGenericsOnSetterMethodFails() {
     assertAbout(javaSource()).that(componentFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
-        .withErrorContaining(ErrorMessages.BUILDER_METHODS_MAY_NOT_HAVE_TYPE_PARAMETERS)
+        .withErrorContaining(MSGS.methodsMayNotHaveTypeParameters())
             .in(componentFile).onLine(12);
   }
   
@@ -777,8 +777,7 @@ public void testGenericsOnInheritedSetterMethodFails() {
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(
-            String.format(ErrorMessages.BUILDER_INHERITED_METHODS_MAY_NOT_HAVE_TYPE_PARAMETERS,
-                "<T>set(T)"))
+            String.format(MSGS.inheritedMethodsMayNotHaveTypeParameters(), "<T>set(T)"))
             .in(componentFile).onLine(15);    
   }
   
@@ -804,7 +803,7 @@ public void testMultipleSettersPerTypeFails() {
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(
-            String.format(ErrorMessages.BUILDER_MANY_METHODS_FOR_TYPE,
+            String.format(MSGS.manyMethodsForType(),
                   "java.lang.String", "[set1(java.lang.String), set2(java.lang.String)]"))
             .in(componentFile).onLine(10);
   }
@@ -834,7 +833,7 @@ public void testMultipleSettersPerTypeIncludingResolvedGenericsFails() {
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(
-            String.format(ErrorMessages.BUILDER_MANY_METHODS_FOR_TYPE,
+            String.format(MSGS.manyMethodsForType(),
                   "java.lang.String", "[set1(T), set2(java.lang.String)]"))
             .in(componentFile).onLine(14);
   }
@@ -861,7 +860,7 @@ public void testExtraSettersFails() {
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(
-            String.format(ErrorMessages.BUILDER_EXTRA_SETTERS,
+            String.format(MSGS.extraSetters(),
                   "[void test.SimpleComponent.Builder.set1(String),"
                   + " void test.SimpleComponent.Builder.set2(Integer)]"))
             .in(componentFile).onLine(10);
@@ -932,7 +931,7 @@ public void testMissingSettersFail() {
         .withErrorContaining(
             // Ignores Test2Module because we can construct it ourselves.
             // TODO(sameb): Ignore Test3Module because it's not used within transitive dependencies.
-            String.format(ErrorMessages.BUILDER_MISSING_SETTERS,
+            String.format(MSGS.missingSetters(),
                 "[test.TestModule, test.Test3Module, test.OtherComponent]"))
             .in(componentFile).onLine(12);
   }
diff --git a/compiler/src/test/java/dagger/internal/codegen/SubcomponentBuilderValidationTest.java b/compiler/src/test/java/dagger/internal/codegen/SubcomponentBuilderValidationTest.java
new file mode 100644
index 000000000..6311a90ca
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/SubcomponentBuilderValidationTest.java
@@ -0,0 +1,742 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.common.collect.ImmutableList;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assertAbout;
+import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+
+/** Tests for {@link dagger.Subcomponent.Builder} validation. */
+@RunWith(JUnit4.class)
+public class SubcomponentBuilderValidationTest {
+  
+  private static final ErrorMessages.SubcomponentBuilderMessages MSGS =
+      new ErrorMessages.SubcomponentBuilderMessages();
+  
+  @Test
+  public void testRefSubcomponentAndSubBuilderFails() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.ParentComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "interface ParentComponent {",
+        "  ChildComponent child();",
+        "  ChildComponent.Builder builder();",        
+        "}");
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "interface ChildComponent {",
+        "  @Subcomponent.Builder",
+        "  static interface Builder {",
+        "    ChildComponent build();",
+        "  }",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(componentFile, childComponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(String.format(MSGS.moreThanOneRefToSubcomponent(),
+            "test.ChildComponent", "[child(), builder()]"))
+        .in(componentFile);
+  }
+  
+  @Test
+  public void testRefSubBuilderTwiceFails() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.ParentComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "interface ParentComponent {",
+        "  ChildComponent.Builder builder1();",
+        "  ChildComponent.Builder builder2();",        
+        "}");
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "interface ChildComponent {",
+        "  @Subcomponent.Builder",
+        "  static interface Builder {",
+        "    ChildComponent build();",
+        "  }",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(componentFile, childComponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(String.format(MSGS.moreThanOneRefToSubcomponent(),
+            "test.ChildComponent", "[builder1(), builder2()]"))
+        .in(componentFile);
+  }
+  
+  @Test
+  public void testMoreThanOneBuilderFails() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.ParentComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "interface ParentComponent {",
+        "  ChildComponent.Builder1 build();",        
+        "}");
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "interface ChildComponent {",
+        "  @Subcomponent.Builder",
+        "  static interface Builder1 {",
+        "    ChildComponent build();",
+        "  }",
+        "",
+        "  @Subcomponent.Builder",
+        "  static interface Builder2 {",
+        "    ChildComponent build();",
+        "  }",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(componentFile, childComponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(String.format(MSGS.moreThanOne(),
+            "[test.ChildComponent.Builder1, test.ChildComponent.Builder2]"))
+        .in(childComponentFile);
+  }
+  
+  @Test
+  public void testBuilderGenericsFails() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.ParentComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "interface ParentComponent {",
+        "  ChildComponent.Builder1 build();",        
+        "}");
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "interface ChildComponent {",
+        "  @Subcomponent.Builder",
+        "  interface Builder<T> {",
+        "     ChildComponent build();",
+        "  }",           
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(componentFile, childComponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(MSGS.generics())
+        .in(childComponentFile);
+  }
+  
+  @Test
+  public void testBuilderNotInComponentFails() {
+    JavaFileObject builder = JavaFileObjects.forSourceLines("test.Builder",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent.Builder",
+        "interface Builder {}");
+    assertAbout(javaSource()).that(builder)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(MSGS.mustBeInComponent())
+        .in(builder);
+  }
+  
+  @Test
+  public void testBuilderMissingBuildMethodFails() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.ParentComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "interface ParentComponent {",
+        "  ChildComponent.Builder1 build();",        
+        "}");
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "interface ChildComponent {",
+        "  @Subcomponent.Builder",
+        "  interface Builder {}",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(componentFile, childComponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(MSGS.missingBuildMethod())
+        .in(childComponentFile);
+  }
+  
+  @Test
+  public void testPrivateBuilderFails() {
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "abstract class ChildComponent {",
+        "  @Subcomponent.Builder",
+        "  private interface Builder {}",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(MSGS.isPrivate())
+        .in(childComponentFile);
+  }
+  
+  @Test
+  public void testNonStaticBuilderFails() {
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "abstract class ChildComponent {",
+        "  @Subcomponent.Builder",
+        "  abstract class Builder {}",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(MSGS.mustBeStatic())
+        .in(childComponentFile);
+  }
+  
+  @Test
+  public void testNonAbstractBuilderFails() {
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "abstract class ChildComponent {",
+        "  @Subcomponent.Builder",
+        "  static class Builder {}",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(MSGS.mustBeAbstract())
+        .in(childComponentFile);
+  }
+  
+  @Test
+  public void testBuilderOneCxtorWithArgsFails() {
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "abstract class ChildComponent {",
+        "  @Subcomponent.Builder",
+        "  static abstract class Builder {",
+        "    Builder(String unused) {}",
+        "  }",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(MSGS.cxtorOnlyOneAndNoArgs())
+        .in(childComponentFile);
+  }
+  
+  @Test
+  public void testBuilderMoreThanOneCxtorFails() {
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "abstract class ChildComponent {",
+        "  @Subcomponent.Builder",
+        "  static abstract class Builder {",
+        "    Builder() {}",
+        "    Builder(String unused) {}",
+        "  }",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(MSGS.cxtorOnlyOneAndNoArgs())
+        .in(childComponentFile);
+  }
+  
+  @Test
+  public void testBuilderEnumFails() {
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "abstract class ChildComponent {",
+        "  @Subcomponent.Builder",
+        "  enum Builder {}",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(MSGS.mustBeClassOrInterface())
+        .in(childComponentFile);
+  }
+  
+  @Test
+  public void testBuilderBuildReturnsWrongTypeFails() {
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "abstract class ChildComponent {",
+        "  @Subcomponent.Builder",
+        "  interface Builder {",
+        "    String build();",
+        "  }",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(MSGS.buildMustReturnComponentType())
+            .in(childComponentFile).onLine(9);
+  }
+  
+  @Test
+  public void testInheritedBuilderBuildReturnsWrongTypeFails() {
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "abstract class ChildComponent {",
+        "  interface Parent {",
+        "    String build();",
+        "  }",
+        "",
+        "  @Subcomponent.Builder",
+        "  interface Builder extends Parent {}",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            String.format(MSGS.inheritedBuildMustReturnComponentType(), "build"))
+            .in(childComponentFile).onLine(12);
+  }
+  
+  @Test
+  public void testTwoBuildMethodsFails() {
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "abstract class ChildComponent {",
+        "  @Subcomponent.Builder",
+        "  interface Builder {",
+        "    ChildComponent build();",
+        "    ChildComponent create();",
+        "  }",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(String.format(MSGS.twoBuildMethods(), "build()"))
+            .in(childComponentFile).onLine(10);
+  }
+  
+  @Test
+  public void testInheritedTwoBuildMethodsFails() {
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "abstract class ChildComponent {",
+        "  interface Parent {",
+        "    ChildComponent build();",
+        "    ChildComponent create();",
+        "  }",
+        "",
+        "  @Subcomponent.Builder",
+        "  interface Builder extends Parent {}",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            String.format(MSGS.inheritedTwoBuildMethods(), "create()", "build()"))
+            .in(childComponentFile).onLine(13);
+  }
+  
+  @Test
+  public void testMoreThanOneArgFails() {
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "abstract class ChildComponent {",
+        "  @Subcomponent.Builder",
+        "  interface Builder {",
+        "    ChildComponent build();",
+        "    Builder set(String s, Integer i);",
+        "    Builder set(Number n, Double d);",
+        "  }",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(MSGS.methodsMustTakeOneArg())
+            .in(childComponentFile).onLine(10)
+        .and().withErrorContaining(MSGS.methodsMustTakeOneArg())
+            .in(childComponentFile).onLine(11);
+  }
+  
+  @Test
+  public void testInheritedMoreThanOneArgFails() {
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "abstract class ChildComponent {",
+        "  interface Parent {",
+        "    ChildComponent build();",
+        "    Builder set1(String s, Integer i);",
+        "  }",
+        "",
+        "  @Subcomponent.Builder",
+        "  interface Builder extends Parent {}",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            String.format(MSGS.inheritedMethodsMustTakeOneArg(),
+                "set1(java.lang.String,java.lang.Integer)"))
+            .in(childComponentFile).onLine(13);
+  }
+  
+  @Test
+  public void testSetterReturningNonVoidOrBuilderFails() {
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "abstract class ChildComponent {",
+        "  @Subcomponent.Builder",
+        "  interface Builder {",
+        "    ChildComponent build();",
+        "    String set(Integer i);",
+        "  }",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(MSGS.methodsMustReturnVoidOrBuilder())
+            .in(childComponentFile).onLine(10);
+  }
+  
+  @Test
+  public void testInheritedSetterReturningNonVoidOrBuilderFails() {
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "abstract class ChildComponent {",
+        "  interface Parent {",
+        "    ChildComponent build();",
+        "    String set(Integer i);",
+        "  }",
+        "",
+        "  @Subcomponent.Builder",
+        "  interface Builder extends Parent {}",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            String.format(MSGS.inheritedMethodsMustReturnVoidOrBuilder(),
+                "set(java.lang.Integer)"))
+            .in(childComponentFile).onLine(13);    
+  }
+  
+  @Test
+  public void testGenericsOnSetterMethodFails() {
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "abstract class ChildComponent {",
+        "  @Subcomponent.Builder",
+        "  interface Builder {",
+        "    ChildComponent build();",
+        "    <T> Builder set(T t);",
+        "  }",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(MSGS.methodsMayNotHaveTypeParameters())
+            .in(childComponentFile).onLine(10);
+  }
+  
+  @Test
+  public void testGenericsOnInheritedSetterMethodFails() {
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "abstract class ChildComponent {",
+        "  interface Parent {",
+        "    ChildComponent build();",
+        "    <T> Builder set(T t);",
+        "  }",
+        "",
+        "  @Subcomponent.Builder",
+        "  interface Builder extends Parent {}",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            String.format(MSGS.inheritedMethodsMayNotHaveTypeParameters(), "<T>set(T)"))
+            .in(childComponentFile).onLine(13);    
+  }
+  
+  @Test
+  public void testMultipleSettersPerTypeFails() {
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "abstract class ChildComponent {",
+        "  @Subcomponent.Builder",
+        "  interface Builder {",
+        "    ChildComponent build();",
+        "    void set1(String s);",
+        "    void set2(String s);",
+        "  }",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            String.format(MSGS.manyMethodsForType(),
+                  "java.lang.String", "[set1(java.lang.String), set2(java.lang.String)]"))
+            .in(childComponentFile).onLine(8);
+  }
+  
+  @Test
+  public void testMultipleSettersPerTypeIncludingResolvedGenericsFails() {
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "abstract class ChildComponent {",
+        "  interface Parent<T> {",
+        "    void set1(T t);",
+        "  }",
+        "",
+        "  @Subcomponent.Builder",
+        "  interface Builder extends Parent<String> {",
+        "    ChildComponent build();",
+        "    void set2(String s);",
+        "  }",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            String.format(MSGS.manyMethodsForType(),
+                  "java.lang.String", "[set1(T), set2(java.lang.String)]"))
+            .in(childComponentFile).onLine(12);
+  }
+  
+  @Test
+  public void testExtraSettersFails() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.ParentComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "interface ParentComponent {",
+        "  ChildComponent.Builder build();",        
+        "}");
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "interface ChildComponent {",
+        "  @Subcomponent.Builder",
+        "  interface Builder {",
+        "    ChildComponent build();",
+        "    void set1(String s);",
+        "    void set2(Integer s);",
+        "  }",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(componentFile, childComponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            String.format(MSGS.extraSetters(),
+                  "[void test.ChildComponent.Builder.set1(String),"
+                  + " void test.ChildComponent.Builder.set2(Integer)]"))
+            .in(childComponentFile).onLine(8);
+    
+  }
+  
+  @Test
+  public void testMissingSettersFail() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "final class TestModule {",
+        "  TestModule(String unused) {}",
+        "  @Provides String s() { return null; }",
+        "}");
+    JavaFileObject module2File = JavaFileObjects.forSourceLines("test.Test2Module",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "final class Test2Module {",
+        "  @Provides Integer i() { return null; }",
+        "}");
+    JavaFileObject module3File = JavaFileObjects.forSourceLines("test.Test3Module",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "final class Test3Module {",
+        "  Test3Module(String unused) {}",
+        "  @Provides Double d() { return null; }",
+        "}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.ParentComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "interface ParentComponent {",
+        "  ChildComponent.Builder build();",        
+        "}");
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent(modules = {TestModule.class, Test2Module.class, Test3Module.class})",
+        "interface ChildComponent {",
+        "  String string();",
+        "  Integer integer();",
+        "",
+        "  @Subcomponent.Builder",
+        "  interface Builder {",
+        "    ChildComponent create();",
+        "  }",
+        "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(moduleFile,
+            module2File,
+            module3File,
+            componentFile,
+            childComponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            // Ignores Test2Module because we can construct it ourselves.
+            // TODO(sameb): Ignore Test3Module because it's not used within transitive dependencies.
+            String.format(MSGS.missingSetters(), "[test.TestModule, test.Test3Module]"))
+            .in(childComponentFile).onLine(11);
+  }
+}
diff --git a/compiler/src/test/java/dagger/internal/codegen/SubcomponentValidationTest.java b/compiler/src/test/java/dagger/internal/codegen/SubcomponentValidationTest.java
index cf15210ee..af6b43d12 100644
--- a/compiler/src/test/java/dagger/internal/codegen/SubcomponentValidationTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/SubcomponentValidationTest.java
@@ -192,4 +192,18 @@
             "java.lang.Integer cannot be provided without an @Inject constructor or from an "
                 + "@Provides-annotated method");
   }
+
+  @Test public void subcomponentOnConcreteType() {
+    JavaFileObject subcomponentFile = JavaFileObjects.forSourceLines("test.NotASubcomponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "final class NotASubcomponent {}");
+    assertAbout(javaSources()).that(ImmutableList.of(subcomponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("interface");
+  }
 }
diff --git a/core/src/main/java/dagger/Subcomponent.java b/core/src/main/java/dagger/Subcomponent.java
index 1c8799515..0ef47011f 100644
--- a/core/src/main/java/dagger/Subcomponent.java
+++ b/core/src/main/java/dagger/Subcomponent.java
@@ -38,4 +38,14 @@
    * here.
    */
   Class<?>[] modules() default {};
+  
+  /**
+   * A builder for a subcomponent.  This follows all the rules of {@link Component.Builder}, except
+   * it must appear in classes annotated with {@link Subcomponent} instead of {@code Component}.
+   * Components can have methods that return a {@link Subcomponent.Builder}-annotated type,
+   * allowing the user to set modules on the subcomponent using their defined API.
+   */
+  @Target(TYPE)
+  @Documented
+  @interface Builder {}
 }
