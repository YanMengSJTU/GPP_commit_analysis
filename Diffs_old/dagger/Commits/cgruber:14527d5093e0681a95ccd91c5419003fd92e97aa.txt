diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
index 77fc3c220..212ac5cc1 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -61,15 +61,12 @@
 import dagger.producers.internal.SetProducer;
 import java.util.Collection;
 import java.util.EnumSet;
-import java.util.HashSet;
 import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
 import javax.annotation.Generated;
 import javax.inject.Provider;
-import javax.lang.model.element.Element;
-import javax.lang.model.element.ElementKind;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.Name;
@@ -78,8 +75,6 @@
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.ExecutableType;
 import javax.lang.model.type.TypeKind;
-import javax.lang.model.type.TypeMirror;
-import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 import javax.tools.Diagnostic;
 import javax.tools.Diagnostic.Kind;
@@ -100,7 +95,7 @@
 import static dagger.internal.codegen.SourceFiles.factoryNameForProductionBinding;
 import static dagger.internal.codegen.SourceFiles.factoryNameForProvisionBinding;
 import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
-import static dagger.internal.codegen.SourceFiles.membersInjectorNameForType;
+import static dagger.internal.codegen.SourceFiles.membersInjectorNameForMembersInjectionBinding;
 import static dagger.internal.codegen.Util.componentCanMakeNewInstances;
 import static dagger.internal.codegen.Util.getKeyTypeOfMap;
 import static dagger.internal.codegen.Util.getProvidedValueTypeOfMap;
@@ -119,9 +114,8 @@
 abstract class AbstractComponentWriter {
 
   // TODO(dpb): Make all these fields private after refactoring is complete.
-  protected final Elements elements;
+
   protected final Types types;
-  protected final Key.Factory keyFactory;
   protected final Kind nullableValidationType;
   protected final Set<JavaWriter> javaWriters = new LinkedHashSet<>();
   protected final ClassName name;
@@ -151,15 +145,8 @@
   protected final Map<TypeElement, MemberSelect> componentContributionFields = Maps.newHashMap();
 
   AbstractComponentWriter(
-      Types types,
-      Elements elements,
-      Key.Factory keyFactory,
-      Diagnostic.Kind nullableValidationType,
-      ClassName name,
-      BindingGraph graph) {
+      Types types, Diagnostic.Kind nullableValidationType, ClassName name, BindingGraph graph) {
     this.types = types;
-    this.elements = elements;
-    this.keyFactory = keyFactory;
     this.nullableValidationType = nullableValidationType;
     this.name = name;
     this.graph = graph;
@@ -534,6 +521,7 @@ private void addField(
 
   private void implementInterfaceMethods() {
     Set<MethodSignature> interfaceMethods = Sets.newHashSet();
+
     for (ComponentMethodDescriptor componentMethod :
         graph.componentDescriptor().componentMethods()) {
       if (componentMethod.dependencyRequest().isPresent()) {
@@ -870,7 +858,7 @@ private Snippet initializeFactoryForProvisionBinding(ProvisionBinding binding) {
             && !binding.bindingElement().getModifiers().contains(STATIC)) {
           parameters.add(getComponentContributionSnippet(binding.contributedBy().get()));
         }
-        parameters.addAll(getDependencyParameters(binding));
+        parameters.addAll(getDependencyParameters(binding.implicitDependencies()));
 
         Snippet factorySnippet =
             Snippet.format(
@@ -915,7 +903,7 @@ private Snippet initializeFactoryForProductionBinding(ProductionBinding binding)
         parameters.add(
             getComponentContributionSnippet(
                 graph.componentDescriptor().executorDependency().get()));
-        parameters.addAll(getProducerDependencyParameters(binding));
+        parameters.addAll(getProducerDependencyParameters(binding.dependencies()));
 
         return Snippet.format(
             "new %s(%s)",
@@ -930,75 +918,54 @@ private Snippet initializeMembersInjectorForBinding(MembersInjectionBinding bind
     switch (binding.injectionStrategy()) {
       case NO_OP:
         return Snippet.format("%s.noOp()", ClassName.fromClass(MembersInjectors.class));
+      case DELEGATE:
+        DependencyRequest parentInjectorRequest = binding.parentInjectorRequest().get();
+        return Snippet.format(
+            "%s.delegatingTo(%s)",
+            ClassName.fromClass(MembersInjectors.class),
+            getMemberSelectSnippet(parentInjectorRequest.bindingKey()));
       case INJECT_MEMBERS:
-        List<Snippet> parameters = getDependencyParameters(binding);
+        List<Snippet> parameters = getDependencyParameters(binding.implicitDependencies());
         return Snippet.format(
             "%s.create(%s)",
-            membersInjectorNameForType(binding.bindingElement()),
+            membersInjectorNameForMembersInjectionBinding(binding),
             Snippet.makeParametersSnippet(parameters));
       default:
         throw new AssertionError();
     }
   }
 
-  private List<Snippet> getDependencyParameters(Binding binding) {
+  private List<Snippet> getDependencyParameters(Iterable<DependencyRequest> dependencies) {
     ImmutableList.Builder<Snippet> parameters = ImmutableList.builder();
-    Set<Key> keysSeen = new HashSet<>();
     for (Collection<DependencyRequest> requestsForKey :
-        SourceFiles.indexDependenciesByUnresolvedKey(types, binding.implicitDependencies())
-            .asMap()
-            .values()) {
-      Set<BindingKey> requestedBindingKeys = new HashSet<>();
-      for (DependencyRequest dependencyRequest : requestsForKey) {
-        Element requestElement = dependencyRequest.requestElement();
-        TypeMirror typeMirror = typeMirrorAsMemberOf(binding.bindingTypeElement(), requestElement);
-        Key key = keyFactory.forQualifiedType(dependencyRequest.key().qualifier(), typeMirror);
-        if (keysSeen.add(key)) {
-          requestedBindingKeys.add(dependencyRequest.bindingKey());
-        }
-      }
-      if (!requestedBindingKeys.isEmpty()) {
-        BindingKey key = Iterables.getOnlyElement(requestedBindingKeys);
-        if (bindingKeysWithDelegates.contains(key)) {
-          parameters.add(delegateFactoryVariableSnippet(key));
-        } else {
-          parameters.add(getMemberSelect(key).getSnippetWithRawTypeCastFor(name));
-        }
+        SourceFiles.indexDependenciesByUnresolvedKey(types, dependencies).asMap().values()) {
+      BindingKey key = Iterables.getOnlyElement(FluentIterable.from(requestsForKey)
+          .transform(new Function<DependencyRequest, BindingKey>() {
+            @Override public BindingKey apply(DependencyRequest request) {
+              return request.bindingKey();
+            }
+          })
+          .toSet());
+      if (bindingKeysWithDelegates.contains(key)) {
+        parameters.add(delegateFactoryVariableSnippet(key));
+      } else {
+        parameters.add(getMemberSelect(key).getSnippetWithRawTypeCastFor(name));
       }
     }
     return parameters.build();
   }
 
-  // TODO(dpb): Investigate use of asMemberOf here.
-  private TypeMirror typeMirrorAsMemberOf(TypeElement bindingTypeElement, Element requestElement) {
-    TypeMirror requestType = requestElement.asType();
-    if (requestType.getKind() == TypeKind.TYPEVAR) {
-      return types.asMemberOf(
-          MoreTypes.asDeclared(bindingTypeElement.asType()),
-          (requestElement.getKind() == ElementKind.PARAMETER)
-              ? MoreTypes.asElement(requestType)
-              : requestElement);
-    } else {
-      return requestType;
-    }
-  }
-
-  private List<Snippet> getProducerDependencyParameters(Binding binding) {
+  private List<Snippet> getProducerDependencyParameters(
+      Iterable<DependencyRequest> dependencies) {
     ImmutableList.Builder<Snippet> parameters = ImmutableList.builder();
     for (Collection<DependencyRequest> requestsForKey :
-        SourceFiles.indexDependenciesByUnresolvedKey(types, binding.dependencies())
-            .asMap()
-            .values()) {
-      BindingKey key =
-          Iterables.getOnlyElement(
-              FluentIterable.from(requestsForKey)
-                  .transform(
-                      new Function<DependencyRequest, BindingKey>() {
-                        @Override
-                        public BindingKey apply(DependencyRequest request) {
-                          return request.bindingKey();
-                        }
-                      }));
+        SourceFiles.indexDependenciesByUnresolvedKey(types, dependencies).asMap().values()) {
+      BindingKey key = Iterables.getOnlyElement(FluentIterable.from(requestsForKey)
+          .transform(new Function<DependencyRequest, BindingKey>() {
+            @Override public BindingKey apply(DependencyRequest request) {
+              return request.bindingKey();
+            }
+          }));
       ResolvedBindings resolvedBindings = graph.resolvedBindings().get(key);
       Class<?> frameworkClass =
           DependencyRequestMapper.FOR_PRODUCER.getFrameworkClass(requestsForKey);
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
index 7bd476a33..2e5d869b1 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
@@ -55,7 +55,7 @@
 import static dagger.internal.codegen.ComponentDescriptor.isComponentProductionMethod;
 import static dagger.internal.codegen.ComponentDescriptor.Kind.PRODUCTION_COMPONENT;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
-import static dagger.internal.codegen.MembersInjectionBinding.Strategy.INJECT_MEMBERS;
+import static dagger.internal.codegen.MembersInjectionBinding.Strategy.DELEGATE;
 import static dagger.internal.codegen.MembersInjectionBinding.Strategy.NO_OP;
 
 /**
@@ -350,11 +350,9 @@ private MembersInjectionBinding rollUpMembersInjectionBindings(Key key) {
         MembersInjectionBinding membersInjectionBinding =
             injectBindingRegistry.getOrFindMembersInjectionBinding(key);
 
-        if (membersInjectionBinding.parentInjectorRequest().isPresent()
-            && membersInjectionBinding.injectionStrategy().equals(INJECT_MEMBERS)) {
-          MembersInjectionBinding parentBinding =
-              rollUpMembersInjectionBindings(
-                  membersInjectionBinding.parentInjectorRequest().get().key());
+        if (membersInjectionBinding.injectionStrategy().equals(DELEGATE)) {
+          MembersInjectionBinding parentBinding = rollUpMembersInjectionBindings(
+              membersInjectionBinding.parentInjectorRequest().get().key());
           if (parentBinding.injectionStrategy().equals(NO_OP)) {
             return membersInjectionBinding.withoutParentInjectorRequest();
           }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
index b5212f6bf..f79f0bc99 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
@@ -27,7 +27,6 @@
 import dagger.internal.codegen.writer.TypeName;
 import javax.annotation.processing.Filer;
 import javax.lang.model.element.Element;
-import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 import javax.tools.Diagnostic;
 
@@ -39,20 +38,11 @@
  */
 final class ComponentGenerator extends SourceFileGenerator<BindingGraph> {
   private final Types types;
-  private final Elements elements;
-  private final Key.Factory keyFactory;
   private final Diagnostic.Kind nullableValidationType;
 
-  ComponentGenerator(
-      Filer filer,
-      Elements elements,
-      Types types,
-      Key.Factory keyFactory,
-      Diagnostic.Kind nullableValidationType) {
+  ComponentGenerator(Filer filer, Types types, Diagnostic.Kind nullableValidationType) {
     super(filer);
     this.types = types;
-    this.elements = elements;
-    this.keyFactory = keyFactory;
     this.nullableValidationType = nullableValidationType;
   }
 
@@ -125,14 +115,14 @@ Snippet getSnippetWithRawTypeCastFor(ClassName usingClass) {
     }
 
     Snippet getSnippetFor(ClassName usingClass) {
-      return owningClass().equals(usingClass) ? snippet() : qualifiedSelectSnippet();
+      return owningClass().equals(usingClass)
+          ? snippet()
+          : qualifiedSelectSnippet();
     }
   }
 
   @Override
   ImmutableSet<JavaWriter> write(ClassName componentName, BindingGraph input) {
-    return new ComponentWriter(
-            types, elements, keyFactory, nullableValidationType, componentName, input)
-        .write();
+    return new ComponentWriter(types, nullableValidationType, componentName, input).write();
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
index 785fe8117..ec90b08e6 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -114,9 +114,9 @@ public SourceVersion getSupportedSourceVersion() {
     this.factoryGenerator =
         new FactoryGenerator(filer, DependencyRequestMapper.FOR_PROVIDER, nullableDiagnosticType);
     this.membersInjectorGenerator =
-        new MembersInjectorGenerator(filer, DependencyRequestMapper.FOR_PROVIDER);
+        new MembersInjectorGenerator(filer, elements, types, DependencyRequestMapper.FOR_PROVIDER);
     ComponentGenerator componentGenerator =
-        new ComponentGenerator(filer, elements, types, keyFactory, nullableDiagnosticType);
+        new ComponentGenerator(filer, types, nullableDiagnosticType);
     ProducerFactoryGenerator producerFactoryGenerator =
         new ProducerFactoryGenerator(filer, DependencyRequestMapper.FOR_PRODUCER);
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java
index 5221cf0a2..8690b3967 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java
@@ -23,7 +23,6 @@
 import dagger.internal.codegen.writer.MethodWriter;
 import javax.annotation.Generated;
 import javax.lang.model.element.TypeElement;
-import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 import javax.tools.Diagnostic.Kind;
 
@@ -38,13 +37,8 @@
 class ComponentWriter extends AbstractComponentWriter {
 
   ComponentWriter(
-      Types types,
-      Elements elements,
-      Key.Factory keyFactory,
-      Kind nullableValidationType,
-      ClassName name,
-      BindingGraph graph) {
-    super(types, elements, keyFactory, nullableValidationType, name, graph);
+      Types types, Kind nullableValidationType, ClassName name, BindingGraph graph) {
+    super(types, nullableValidationType, name, graph);
   }
 
   @Override
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java b/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
index a876f445c..071ce6982 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
@@ -45,7 +45,6 @@
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
-import static dagger.internal.codegen.SourceFiles.membersInjectorNameForType;
 
 /**
  * Maintains the collection of provision bindings from {@link Inject} constructors and members
@@ -192,7 +191,8 @@ private ProvisionBinding registerBinding(ProvisionBinding binding, boolean expli
    */
   private MembersInjectionBinding registerBinding(
       MembersInjectionBinding binding, boolean explicit) {
-    ClassName membersInjectorName = membersInjectorNameForType(binding.bindingTypeElement());
+    ClassName membersInjectorName =
+        SourceFiles.membersInjectorNameForMembersInjectionBinding(binding);
     if (binding.injectionSites().isEmpty()) {
       // empty members injection bindings are special and don't need source files.
       // so, we just pretend
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
index 1212e5aa2..d11d7ef3e 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
@@ -24,17 +24,11 @@
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ImmutableSortedSet;
-import com.google.common.collect.LinkedHashMultimap;
-import com.google.common.collect.SetMultimap;
-import java.util.ArrayList;
-import java.util.Comparator;
-import java.util.HashSet;
-import java.util.List;
+import com.google.common.collect.Ordering;
 import java.util.Set;
 import javax.inject.Inject;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ElementKind;
-import javax.lang.model.element.ElementVisitor;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
@@ -62,7 +56,7 @@
 @AutoValue
 abstract class MembersInjectionBinding extends Binding {
   @Override abstract TypeElement bindingElement();
-        
+
   /** The set of individual sites where {@link Inject} is applied. */
   abstract ImmutableSortedSet<InjectionSite> injectionSites();
 
@@ -70,11 +64,18 @@
 
   enum Strategy {
     NO_OP,
+    DELEGATE,
     INJECT_MEMBERS,
   }
 
   Strategy injectionStrategy() {
-    return injectionSites().isEmpty() ? Strategy.NO_OP : Strategy.INJECT_MEMBERS;
+    if (injectionSites().isEmpty()) {
+      return parentInjectorRequest().isPresent()
+          ? Strategy.DELEGATE
+          : Strategy.NO_OP;
+    } else {
+      return Strategy.INJECT_MEMBERS;
+    }
   }
 
   MembersInjectionBinding withoutParentInjectorRequest() {
@@ -89,6 +90,27 @@ MembersInjectionBinding withoutParentInjectorRequest() {
           Optional.<DependencyRequest>absent());
   }
 
+  private static final Ordering<InjectionSite> INJECTION_ORDERING =
+      new Ordering<InjectionSite>() {
+        @Override
+        public int compare(InjectionSite left, InjectionSite right) {
+          checkArgument(left.element().getEnclosingElement()
+              .equals(right.element().getEnclosingElement()));
+          return ComparisonChain.start()
+              // fields before methods
+              .compare(left.element().getKind(), right.element().getKind())
+              // then sort by whichever element comes first in the parent
+              // this isn't necessary, but makes the processor nice and predictable
+              .compare(targetIndexInEnclosing(left), targetIndexInEnclosing(right))
+              .result();
+        }
+
+        private int targetIndexInEnclosing(InjectionSite injectionSite)  {
+          return injectionSite.element().getEnclosingElement().getEnclosedElements()
+              .indexOf(injectionSite.element());
+        }
+      };
+
   @AutoValue
   abstract static class InjectionSite {
     enum Kind {
@@ -101,14 +123,6 @@ MembersInjectionBinding withoutParentInjectorRequest() {
     abstract Element element();
 
     abstract ImmutableSet<DependencyRequest> dependencies();
-    
-    protected int indexAmongSiblingMembers(InjectionSite injectionSite) {
-      return injectionSite
-          .element()
-          .getEnclosingElement()
-          .getEnclosedElements()
-          .indexOf(injectionSite.element());
-    }
   }
 
   static final class Factory {
@@ -125,33 +139,33 @@ protected int indexAmongSiblingMembers(InjectionSite injectionSite) {
       this.dependencyRequestFactory = checkNotNull(dependencyRequestFactory);
     }
 
-    private InjectionSite injectionSiteForInjectMethod(
-        ExecutableElement methodElement, DeclaredType containingType) {
+    private InjectionSite injectionSiteForInjectMethod(ExecutableElement methodElement,
+        DeclaredType containingType) {
       checkNotNull(methodElement);
       checkArgument(methodElement.getKind().equals(ElementKind.METHOD));
+      checkArgument(isAnnotationPresent(methodElement, Inject.class));
       ExecutableType resolved =
           MoreTypes.asExecutable(types.asMemberOf(containingType, methodElement));
-      return new AutoValue_MembersInjectionBinding_InjectionSite(
-          InjectionSite.Kind.METHOD,
+      return new AutoValue_MembersInjectionBinding_InjectionSite(InjectionSite.Kind.METHOD,
           methodElement,
           dependencyRequestFactory.forRequiredResolvedVariables(
-              containingType, methodElement.getParameters(), resolved.getParameterTypes()));
+              containingType,
+              methodElement.getParameters(),
+              resolved.getParameterTypes()));
     }
 
-    private InjectionSite injectionSiteForInjectField(
-        VariableElement fieldElement, DeclaredType containingType) {
+    private InjectionSite injectionSiteForInjectField(VariableElement fieldElement,
+        DeclaredType containingType) {
       checkNotNull(fieldElement);
       checkArgument(fieldElement.getKind().equals(ElementKind.FIELD));
       checkArgument(isAnnotationPresent(fieldElement, Inject.class));
       TypeMirror resolved = types.asMemberOf(containingType, fieldElement);
-      return new AutoValue_MembersInjectionBinding_InjectionSite(
-          InjectionSite.Kind.FIELD,
+      return new AutoValue_MembersInjectionBinding_InjectionSite(InjectionSite.Kind.FIELD,
           fieldElement,
-          ImmutableSet.of(
-              dependencyRequestFactory.forRequiredResolvedVariable(
-                  containingType, fieldElement, resolved)));
+          ImmutableSet.of(dependencyRequestFactory.forRequiredResolvedVariable(
+              containingType, fieldElement, resolved)));
     }
-
+  
     /** Returns an unresolved version of this binding. */
     MembersInjectionBinding unresolve(MembersInjectionBinding binding) {
       checkState(binding.hasNonDefaultTypeParameters());
@@ -164,146 +178,76 @@ MembersInjectionBinding unresolve(MembersInjectionBinding binding) {
      * this will return a resolved binding, with the key & type resolved to the given type (using
      * {@link Types#asMemberOf(DeclaredType, Element)}).
      */
-    MembersInjectionBinding forInjectedType(
-        DeclaredType declaredType, Optional<TypeMirror> resolvedType) {
+    MembersInjectionBinding forInjectedType(DeclaredType type, Optional<TypeMirror> resolvedType) {
       // If the class this is injecting has some type arguments, resolve everything.
-      if (!declaredType.getTypeArguments().isEmpty() && resolvedType.isPresent()) {
+      if (!type.getTypeArguments().isEmpty() && resolvedType.isPresent()) {
         DeclaredType resolved = MoreTypes.asDeclared(resolvedType.get());
         // Validate that we're resolving from the correct type.
-        checkState(
-            types.isSameType(types.erasure(resolved), types.erasure(declaredType)),
+        checkState(types.isSameType(types.erasure(resolved), types.erasure(type)),
             "erased expected type: %s, erased actual type: %s",
-            types.erasure(resolved),
-            types.erasure(declaredType));
-        declaredType = resolved;
+            types.erasure(resolved), types.erasure(type));
+        type = resolved;
       }
-      ImmutableSortedSet<InjectionSite> injectionSites = getInjectionSites(declaredType);
-      ImmutableSet<DependencyRequest> dependencies =
-          FluentIterable.from(injectionSites)
-              .transformAndConcat(
-                  new Function<InjectionSite, Set<DependencyRequest>>() {
-                    @Override
-                    public Set<DependencyRequest> apply(InjectionSite input) {
-                      return input.dependencies();
-                    }
-                  })
-              .toSet();
 
-      Optional<DependencyRequest> parentInjectorRequest =
-          MoreTypes.nonObjectSuperclass(types, elements, declaredType)
-              .transform(
-                  new Function<DeclaredType, DependencyRequest>() {
-                    @Override
-                    public DependencyRequest apply(DeclaredType input) {
-                      return dependencyRequestFactory.forMembersInjectedType(input);
-                    }
-                  });
+      TypeElement typeElement = MoreElements.asType(type.asElement());
+      final DeclaredType resolved = type;
+      ImmutableSortedSet.Builder<InjectionSite> injectionSitesBuilder =
+          ImmutableSortedSet.orderedBy(INJECTION_ORDERING);
+      for (Element enclosedElement : typeElement.getEnclosedElements()) {
+        injectionSitesBuilder.addAll(enclosedElement.accept(
+            new ElementKindVisitor6<Optional<InjectionSite>, Void>(
+                Optional.<InjectionSite>absent()) {
+                  @Override
+                  public Optional<InjectionSite> visitExecutableAsMethod(ExecutableElement e,
+                      Void p) {
+                    return isAnnotationPresent(e, Inject.class) && modifiersSupported(e)
+                        ? Optional.of(injectionSiteForInjectMethod(e, resolved))
+                        : Optional.<InjectionSite>absent();
+                  }
+
+                  @Override
+                  public Optional<InjectionSite> visitVariableAsField(VariableElement e, Void p) {
+                    return isAnnotationPresent(e, Inject.class) && modifiersSupported(e)
+                        ? Optional.of(injectionSiteForInjectField(e, resolved))
+                        : Optional.<InjectionSite>absent();
+                  }
+                }, null).asSet());
+      }
+      ImmutableSortedSet<InjectionSite> injectionSites = injectionSitesBuilder.build();
+
+      ImmutableSet<DependencyRequest> dependencies = FluentIterable.from(injectionSites)
+          .transformAndConcat(new Function<InjectionSite, Set<DependencyRequest>>() {
+            @Override public Set<DependencyRequest> apply(InjectionSite input) {
+              return input.dependencies();
+            }
+          })
+          .toSet();
 
-      Key key = keyFactory.forMembersInjectedType(declaredType);
-      TypeElement typeElement = MoreElements.asType(declaredType.asElement());
+      Optional<DependencyRequest> parentInjectorRequest =
+          MoreTypes.nonObjectSuperclass(types, elements, type)
+              .transform(new Function<DeclaredType, DependencyRequest>() {
+                @Override public DependencyRequest apply(DeclaredType input) {
+                  return dependencyRequestFactory.forMembersInjectedType(input);
+                }
+              });
+
+      Key key = keyFactory.forMembersInjectedType(type);
       return new AutoValue_MembersInjectionBinding(
           key,
           dependencies,
-          dependencies,
+          new ImmutableSet.Builder<DependencyRequest>()
+              .addAll(parentInjectorRequest.asSet())
+              .addAll(dependencies)
+              .build(),
           findBindingPackage(key),
           hasNonDefaultTypeParameters(typeElement, key.type(), types),
           typeElement,
           injectionSites,
           parentInjectorRequest);
     }
-
-    private ImmutableSortedSet<InjectionSite> getInjectionSites(DeclaredType declaredType) {
-      Set<InjectionSite> injectionSites = new HashSet<>();
-      final List<TypeElement> ancestors = new ArrayList<>();
-      SetMultimap<String, ExecutableElement> overriddenMethodMap = LinkedHashMultimap.create();
-      for (Optional<DeclaredType> currentType = Optional.of(declaredType);
-          currentType.isPresent();
-          currentType = MoreTypes.nonObjectSuperclass(types, elements, currentType.get())) {
-        final DeclaredType type = currentType.get();
-        ancestors.add(MoreElements.asType(type.asElement()));
-        for (Element enclosedElement : type.asElement().getEnclosedElements()) {
-          Optional<InjectionSite> maybeInjectionSite =
-              injectionSiteVisitor.visit(enclosedElement, type);
-          if (maybeInjectionSite.isPresent()) {
-            InjectionSite injectionSite = maybeInjectionSite.get();
-            if (shouldBeInjected(injectionSite.element(), overriddenMethodMap)) {
-              injectionSites.add(injectionSite);
-            }
-            if (injectionSite.kind() == InjectionSite.Kind.METHOD) {
-              ExecutableElement injectionSiteMethod =
-                  MoreElements.asExecutable(injectionSite.element());
-              overriddenMethodMap.put(
-                  injectionSiteMethod.getSimpleName().toString(), injectionSiteMethod);
-            }
-          }
-        }
-      }
-      return ImmutableSortedSet.copyOf(
-          new Comparator<InjectionSite>() {
-            @Override
-            public int compare(InjectionSite left, InjectionSite right) {
-              return ComparisonChain.start()
-                  // supertypes before subtypes
-                  .compare(
-                      ancestors.indexOf(right.element().getEnclosingElement()),
-                      ancestors.indexOf(left.element().getEnclosingElement()))
-                  // fields before methods
-                  .compare(left.element().getKind(), right.element().getKind())
-                  // then sort by whichever element comes first in the parent
-                  // this isn't necessary, but makes the processor nice and predictable
-                  .compare(
-                      left.indexAmongSiblingMembers(left), right.indexAmongSiblingMembers(right))
-                  .result();
-            }
-          },
-          injectionSites);
-    }
-
-    private boolean shouldBeInjected(
-        Element injectionSite, SetMultimap<String, ExecutableElement> overriddenMethodMap) {
-      if (!isAnnotationPresent(injectionSite, Inject.class)
-          || injectionSite.getModifiers().contains(PRIVATE)
-          || injectionSite.getModifiers().contains(STATIC)) {
-        return false;
-      }
-
-      if (injectionSite.getKind().isField()) { // Inject all fields (self and ancestors)
-        return true;
-      }
-
-      // For each method with the same name belonging to any descendant class, return false if any
-      // method has already overridden the injectionSite method. To decrease the number of methods
-      // that are checked, we store the already injected methods in a SetMultimap and only
-      // check the methods with the same name.
-      ExecutableElement injectionSiteMethod = MoreElements.asExecutable(injectionSite);
-      TypeElement injectionSiteType = MoreElements.asType(injectionSite.getEnclosingElement());
-      for (ExecutableElement method :
-          overriddenMethodMap.get(injectionSiteMethod.getSimpleName().toString())) {
-        if (elements.overrides(method, injectionSiteMethod, injectionSiteType)) {
-          return false;
-        }
-      }
-      return true;
+    
+    protected boolean modifiersSupported(Element e) {
+      return !e.getModifiers().contains(PRIVATE) && !e.getModifiers().contains(STATIC);
     }
-
-    private final ElementVisitor<Optional<InjectionSite>, DeclaredType> injectionSiteVisitor =
-        new ElementKindVisitor6<Optional<InjectionSite>, DeclaredType>(
-            Optional.<InjectionSite>absent()) {
-          @Override
-          public Optional<InjectionSite> visitExecutableAsMethod(
-              ExecutableElement e, DeclaredType type) {
-            return Optional.of(injectionSiteForInjectMethod(e, type));
-          }
-
-          @Override
-          public Optional<InjectionSite> visitVariableAsField(
-              VariableElement e, DeclaredType type) {
-            return (isAnnotationPresent(e, Inject.class)
-                    && !e.getModifiers().contains(PRIVATE)
-                    && !e.getModifiers().contains(STATIC))
-                ? Optional.of(injectionSiteForInjectField(e, type))
-                : Optional.<InjectionSite>absent();
-          }
-        };
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
index 429b4007f..c4d0db6cc 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
@@ -15,8 +15,7 @@
  */
 package dagger.internal.codegen;
 
-import com.google.auto.common.MoreElements;
-import com.google.common.base.CaseFormat;
+import com.google.auto.common.MoreTypes;
 import com.google.common.base.Function;
 import com.google.common.base.Joiner;
 import com.google.common.base.Optional;
@@ -40,25 +39,25 @@
 import dagger.internal.codegen.writer.TypeNames;
 import dagger.internal.codegen.writer.TypeVariableName;
 import dagger.internal.codegen.writer.VoidName;
-import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Map.Entry;
-import java.util.Set;
 import javax.annotation.Generated;
 import javax.annotation.processing.Filer;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.TypeParameterElement;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
 
+import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
 import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
-import static dagger.internal.codegen.SourceFiles.membersInjectorNameForType;
 import static dagger.internal.codegen.SourceFiles.parameterizedMembersInjectorNameForMembersInjectionBinding;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.PUBLIC;
-import static javax.lang.model.element.Modifier.STATIC;
 
 /**
  * Generates {@link MembersInjector} implementations from {@link MembersInjectionBinding} instances.
@@ -67,18 +66,24 @@
  * @since 2.0
  */
 final class MembersInjectorGenerator extends SourceFileGenerator<MembersInjectionBinding> {
+  private final Elements elements;
+  private final Types types;
   private final DependencyRequestMapper dependencyRequestMapper;
 
   MembersInjectorGenerator(
       Filer filer,
+      Elements elements,
+      Types types,
       DependencyRequestMapper dependencyRequestMapper) {
     super(filer);
+    this.elements = checkNotNull(elements);
+    this.types = checkNotNull(types);
     this.dependencyRequestMapper = dependencyRequestMapper;
   }
 
   @Override
   ClassName nameGeneratedType(MembersInjectionBinding binding) {
-    return membersInjectorNameForType(binding.bindingElement());
+    return SourceFiles.membersInjectorNameForMembersInjectionBinding(binding);
   }
 
   @Override
@@ -100,10 +105,8 @@ ClassName nameGeneratedType(MembersInjectionBinding binding) {
 
   @Override
   ImmutableSet<JavaWriter> write(ClassName generatedTypeName, MembersInjectionBinding binding) {
-    Set<String> delegateMethods = new HashSet<>();
-
     // We don't want to write out resolved bindings -- we want to write out the generic version.
-    checkState(!binding.hasNonDefaultTypeParameters()); 
+    checkState(!binding.hasNonDefaultTypeParameters());
 
     TypeName injectedTypeName = TypeNames.forTypeMirror(binding.key().type());
     JavaWriter writer = JavaWriter.inPackage(generatedTypeName.packageName());
@@ -132,6 +135,21 @@ ClassName nameGeneratedType(MembersInjectionBinding binding) {
         "  throw new NullPointerException(\"Cannot inject members into a null reference\");",
         "}"));
 
+    Optional<DeclaredType> supertype =
+        MoreTypes.nonObjectSuperclass(types, elements, MoreTypes.asDeclared(binding.key().type()));
+    if (supertype.isPresent()) {
+      ParameterizedTypeName supertypeMemebersInjectorType = ParameterizedTypeName.create(
+          MembersInjector.class, TypeNames.forTypeMirror(supertype.get()));
+      injectorWriter
+          .addField(supertypeMemebersInjectorType, "supertypeInjector")
+          .addModifiers(PRIVATE, FINAL);
+      constructorWriter.addParameter(supertypeMemebersInjectorType, "supertypeInjector");
+      constructorWriter.body()
+          .addSnippet("assert supertypeInjector != null;")
+          .addSnippet("this.supertypeInjector = supertypeInjector;");
+      injectMembersWriter.body().addSnippet("supertypeInjector.injectMembers(instance);");
+    }
+
     ImmutableMap<BindingKey, FrameworkField> fields =
         SourceFiles.generateBindingFieldsForDependencies(
             dependencyRequestMapper, ImmutableSet.copyOf(binding.dependencies()));
@@ -164,123 +182,35 @@ ClassName nameGeneratedType(MembersInjectionBinding binding) {
         parameterizedMembersInjectorNameForMembersInjectionBinding(binding),
         Joiner.on(", ").join(params.keySet()));
     
-    ImmutableMap<BindingKey, FieldWriter> dependencyFields = dependencyFieldsBuilder.build();
+    ImmutableMap<BindingKey, FieldWriter> depedencyFields = dependencyFieldsBuilder.build();
     for (InjectionSite injectionSite : binding.injectionSites()) {
-      Element injectionSiteElement = injectionSite.element();
-      ImmutableList.Builder<Snippet> parameters = ImmutableList.builder();
-      if (!visibleTo(binding, injectionSite)) {
-        parameters.add(Snippet.format("instance"));
-      }
       switch (injectionSite.kind()) {
         case FIELD:
           DependencyRequest fieldDependency =
               Iterables.getOnlyElement(injectionSite.dependencies());
-          FieldWriter singleField = dependencyFields.get(fieldDependency.bindingKey());
-          parameters.add(
-              frameworkTypeUsageStatement(
-                  Snippet.format("%s", singleField.name()), fieldDependency.kind()));
+          FieldWriter singleField = depedencyFields.get(
+              fieldDependency.bindingKey());
+          injectMembersWriter.body().addSnippet("instance.%s = %s;",
+              injectionSite.element().getSimpleName(),
+              frameworkTypeUsageStatement(Snippet.format(singleField.name()),
+                  fieldDependency.kind()));
           break;
         case METHOD:
+          ImmutableList.Builder<Snippet> parameters = ImmutableList.builder();
           for (DependencyRequest methodDependency : injectionSite.dependencies()) {
-            FieldWriter field = dependencyFields.get(methodDependency.bindingKey());
-            parameters.add(
-                frameworkTypeUsageStatement(
-                    Snippet.format("%s", field.name()), methodDependency.kind()));
+            FieldWriter field = depedencyFields.get(
+                methodDependency.bindingKey());
+            parameters.add(frameworkTypeUsageStatement(Snippet.format(field.name()),
+                methodDependency.kind()));
           }
+          injectMembersWriter.body().addSnippet("instance.%s(%s);",
+              injectionSite.element().getSimpleName(),
+              Snippet.makeParametersSnippet(parameters.build()));
           break;
         default:
           throw new AssertionError();
       }
-      injectMembersWriter
-          .body()
-          .addSnippet(
-              injectMemberSnippet(
-                  injectionSite, binding, Snippet.makeParametersSnippet(parameters.build())));
-      if (!injectionSiteElement.getModifiers().contains(PUBLIC)
-          && injectionSiteElement.getEnclosingElement().equals(binding.bindingElement())
-          && delegateMethods.add(injectionSiteDelegateMethodName(injectionSiteElement))) {
-        writeInjectorMethodForSubclasses(
-            injectorWriter,
-            typeParameters,
-            injectedTypeName,
-            injectionSiteElement,
-            injectionSite.dependencies());
-      }
     }
     return ImmutableSet.of(writer);
   }
-  
-  private boolean visibleTo(Binding binding, InjectionSite injectionSite) {
-    return MoreElements.getPackage(injectionSite.element())
-            .equals(MoreElements.getPackage(binding.bindingElement()))
-        || injectionSite.element().getModifiers().contains(PUBLIC);
-  }
-
-  private Snippet injectMemberSnippet(
-      InjectionSite injectionSite, MembersInjectionBinding binding, Snippet parametersSnippet) {
-
-    if (visibleTo(binding, injectionSite)) {
-      return Snippet.format(
-          (injectionSite.element().getKind().isField()) ? "%s.%s = %s;" : "%s.%s(%s);",
-          getInstanceSnippetWithPotentialCast(
-              injectionSite.element().getEnclosingElement(), binding.bindingElement()),
-          injectionSite.element().getSimpleName(),
-          parametersSnippet);
-    } else {
-      return Snippet.format(
-          "%s.%s(%s);",
-          membersInjectorNameForType(
-              MoreElements.asType(injectionSite.element().getEnclosingElement())),
-          injectionSiteDelegateMethodName(injectionSite.element()),
-          parametersSnippet);
-    }
-  }
-
-  private Snippet getInstanceSnippetWithPotentialCast(
-      Element injectionSiteElement, Element bindingElement) {
-    return (injectionSiteElement.equals(bindingElement))
-        ? Snippet.format("instance")
-        : Snippet.format("((%s)instance)", injectionSiteElement);
-  }
-
-  private String injectionSiteDelegateMethodName(Element injectionSiteElement) {
-    return "inject"
-        + CaseFormat.LOWER_CAMEL.to(
-            CaseFormat.UPPER_CAMEL, injectionSiteElement.getSimpleName().toString());
-  }
-
-  private void writeInjectorMethodForSubclasses(
-      ClassWriter injectorWriter,
-      List<TypeVariableName> typeParameters,
-      TypeName injectedTypeName,
-      Element injectionElement,
-      ImmutableSet<DependencyRequest> dependencies) {
-    MethodWriter methodWriter =
-        injectorWriter.addMethod(VoidName.VOID, injectionSiteDelegateMethodName(injectionElement));
-    methodWriter.addModifiers(PUBLIC, STATIC);
-    methodWriter.addParameter(injectedTypeName, "instance");
-    methodWriter.addTypeParameters(typeParameters);
-    ImmutableList.Builder<Snippet> providedParameters = ImmutableList.builder();
-    for (DependencyRequest methodDependency : dependencies) {
-      Element requestElement = methodDependency.requestElement();
-      methodWriter.addParameter(
-          TypeNames.forTypeMirror(requestElement.asType()), requestElement.toString());
-      providedParameters.add(Snippet.format("%s", requestElement));
-    }
-    if (injectionElement.getKind().isField()) {
-      methodWriter
-          .body()
-          .addSnippet(
-              "instance.%s = %s;",
-              injectionElement.getSimpleName(),
-              Iterables.getOnlyElement(providedParameters.build()));
-    } else {
-      methodWriter
-          .body()
-          .addSnippet(
-              "instance.%s(%s);",
-              injectionElement.getSimpleName(),
-              Snippet.makeParametersSnippet(providedParameters.build()));
-    }
-  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
index 890d3553b..57c815b23 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
@@ -251,7 +251,7 @@ static ClassName factoryNameForProductionBinding(ProductionBinding binding) {
    */
   static TypeName parameterizedMembersInjectorNameForMembersInjectionBinding(
       MembersInjectionBinding binding) {
-    ClassName factoryName = membersInjectorNameForType(binding.bindingElement());
+    ClassName factoryName = membersInjectorNameForMembersInjectionBinding(binding);
     TypeName bindingName = TypeNames.forTypeMirror(binding.key().type());
     // If the binding is parameterized, parameterize the MembersInjector.
     if (bindingName instanceof ParameterizedTypeName) {
@@ -261,11 +261,10 @@ static TypeName parameterizedMembersInjectorNameForMembersInjectionBinding(
     return factoryName;
   }
 
-  static ClassName membersInjectorNameForType(TypeElement typeElement) {
-    ClassName injectedClassName = ClassName.fromTypeElement(typeElement);
-    return injectedClassName
-        .topLevelClassName()
-        .peerNamed(injectedClassName.classFileName() + "_MembersInjector");
+  static ClassName membersInjectorNameForMembersInjectionBinding(MembersInjectionBinding binding) {
+    ClassName injectedClassName = ClassName.fromTypeElement(binding.bindingElement());
+    return injectedClassName.topLevelClassName().peerNamed(
+        injectedClassName.classFileName() + "_MembersInjector");
   }
 
   private static String factoryPrefix(ProvisionBinding binding) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/SubcomponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/SubcomponentWriter.java
index 3aab845aa..908ee8eea 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SubcomponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SubcomponentWriter.java
@@ -58,8 +58,6 @@ public SubcomponentWriter(
       BindingGraph subgraph) {
     super(
         parent.types,
-        parent.elements,
-        parent.keyFactory,
         parent.nullableValidationType,
         parent.name.nestedClassNamed(subcomponentSimpleName(subgraph)),
         subgraph);
diff --git a/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java b/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java
index a10d8d7c0..25762ea94 100644
--- a/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java
@@ -141,57 +141,59 @@ public void parentClass_injectedMembersInSupertype() {
         "interface TestComponent {",
         "  Child child();",
         "}");
-    JavaFileObject generatedComponent =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerTestComponent",
-            "package test;",
-            "",
-            "import dagger.MembersInjector;",
-            "import javax.annotation.Generated;",
-            "import javax.inject.Provider;",
-            "",
-            "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-            "public final class DaggerTestComponent implements TestComponent {",
-            "  private MembersInjector<Child> childMembersInjector;",
-            "  private Provider<Child> childProvider;",
-            "",
-            "  private DaggerTestComponent(Builder builder) {",
-            "    assert builder != null;",
-            "    initialize(builder);",
-            "  }",
-            "",
-            "  public static Builder builder() {",
-            "    return new Builder();",
-            "  }",
-            "",
-            "  public static TestComponent create() {",
-            "    return builder().build();",
-            "  }",
-            "",
-            "  private void initialize(final Builder builder) {",
-            "    this.childMembersInjector = Child_MembersInjector.create(Dep_Factory.create());",
-            "    this.childProvider = Child_Factory.create(childMembersInjector);",
-            "  }",
-            "",
-            "  @Override",
-            "  public Child child() {",
-            "    return childProvider.get();",
-            "  }",
-            "",
-            "  public static final class Builder {",
-            "    private Builder() {}",
-            "",
-            "    public TestComponent build() {",
-            "      return new DaggerTestComponent(this);",
-            "    }",
-            "  }",
-            "}");
+    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
+        "test.DaggerTestComponent",
+        "package test;",
+        "",
+        "import dagger.MembersInjector;",
+        "import dagger.internal.MembersInjectors;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class DaggerTestComponent implements TestComponent {",
+        "  private MembersInjector<Parent> parentMembersInjector;",
+        "  private MembersInjector<Child> childMembersInjector;",
+        "  private Provider<Child> childProvider;",
+        "",
+        "  private DaggerTestComponent(Builder builder) {",
+        "    assert builder != null;",
+        "    initialize(builder);",
+        "  }",
+        "",
+        "  public static Builder builder() {",
+        "    return new Builder();",
+        "  }",
+        "",
+        "  public static TestComponent create() {",
+        "    return builder().build();",
+        "  }",
+        "",
+        "  private void initialize(final Builder builder) {",
+        "    this.parentMembersInjector = Parent_MembersInjector.create(Dep_Factory.create());",
+        "    this.childMembersInjector = MembersInjectors.delegatingTo(parentMembersInjector);",
+        "    this.childProvider = Child_Factory.create(childMembersInjector);",
+        "  }",
+        "",
+        "  @Override",
+        "  public Child child() {",
+        "    return childProvider.get();",
+        "  }",
+        "",
+        "  public static final class Builder {",
+        "    private Builder() {",
+        "    }",
+        "",
+        "    public TestComponent build() {",
+        "      return new DaggerTestComponent(this);",
+        "    }",
+        "  }",
+        "}");
     assertAbout(javaSources())
         .that(ImmutableList.of(childFile, parentFile, depFile, componentFile))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
-        .and()
-        .generatesSources(generatedComponent);
+        .and().generatesSources(generatedComponent);
   }
 
   @Test public void fieldAndMethodGenerics() {
@@ -207,8 +209,7 @@ public void parentClass_injectedMembersInSupertype() {
         "",
         " @Inject void register(B b) {}",
         "}");
-    JavaFileObject expected = JavaFileObjects.forSourceLines(
-        "test.GenericClass_MembersInjector",
+    JavaFileObject expected = JavaFileObjects.forSourceLines("test.GenericClass_MembersInjector",
         "package test;",
         "",
         "import dagger.MembersInjector;",
@@ -231,32 +232,21 @@ public void parentClass_injectedMembersInSupertype() {
         "  @Override",
         "  public void injectMembers(GenericClass<A, B> instance) {",
         "    if (instance == null) {",
-        "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
+        "      throw new NullPointerException(\"Cannot inject members into a null reference\")",
         "    }",
         "    instance.a = aProvider.get();",
-        "    instance.register(bProvider.get());",
+        "    instance.register(bProvider.get())",
         "  }",
         "",
         "  public static <A, B> MembersInjector<GenericClass<A, B>> create(",
         "      Provider<A> aProvider, Provider<B> bProvider) {",
-        "      return new GenericClass_MembersInjector<A, B>(aProvider, bProvider);",
+        "    return new GenericClass_MembersInjector<A, B>(aProvider, bProvider);",
         "  }",
-        "",
-        "  public static <A, B> void injectA(GenericClass<A, B> instance, A a) {",
-        "    instance.a = a;",
-        "  }",
-        "",
-        "  public static <A, B> void injectRegister(GenericClass<A, B> instance, B b) {",
-        "    instance.register(b);",
-        "  }",
-        "",
         "}");
-    assertAbout(javaSource())
-        .that(file)
+    assertAbout(javaSource()).that(file)
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
-        .and()
-        .generatesSources(expected);
+        .and().generatesSources(expected);
   }
 
   @Test public void subclassedGenericMembersInjectors() {
@@ -299,8 +289,7 @@ public void parentClass_injectedMembersInSupertype() {
         "",
         "  @Inject Child() {}",
         "}");
-    JavaFileObject expected = JavaFileObjects.forSourceLines(
-        "test.Child_MembersInjector",
+    JavaFileObject expected = JavaFileObjects.forSourceLines("test.GenericClass_MembersInjector",
         "package test;",
         "",
         "import dagger.MembersInjector;",
@@ -310,51 +299,41 @@ public void parentClass_injectedMembersInSupertype() {
         "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
         "public final class Child_MembersInjector<T>",
         "    implements MembersInjector<Child<T>> {",
-        "  private final Provider<T> tAndXProvider;",
-        "  private final Provider<A> aAndYProvider;",
-        "  private final Provider<A2> a2Provider;",
+        "  private final MembersInjector<Parent<T, A>> supertypeInjector;",
+        "  private final Provider<A> aProvider;",
+        "  private final Provider<T> tProvider;",
         "",
         "  public Child_MembersInjector(",
-        "      Provider<T> tAndXProvider, Provider<A> aAndYProvider, Provider<A2> a2Provider) {",
-        "    assert tAndXProvider != null;",
-        "    this.tAndXProvider = tAndXProvider;",
-        "    assert aAndYProvider != null;",
-        "    this.aAndYProvider = aAndYProvider;",
-        "    assert a2Provider != null;",
-        "    this.a2Provider = a2Provider;",
+        "      MembersInjector<Parent<T, A>> supertypeInjector, ",
+        "      Provider<A> aProvider, Provider<T> tProvider) {",
+        "    assert supertypeInjector != null;",
+        "    this.supertypeInjector = supertypeInjector;",
+        "    assert aProvider != null;",
+        "    this.aProvider = aProvider;",
+        "    assert tProvider != null;",
+        "    this.tProvider = tProvider;",
         "  }",
         "",
         "  @Override",
         "  public void injectMembers(Child<T> instance) {",
         "    if (instance == null) {",
-        "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
+        "      throw new NullPointerException(\"Cannot inject members into a null reference\")",
         "    }",
-        "    ((test.Parent) instance).x = tAndXProvider.get();",
-        "    ((test.Parent) instance).y = aAndYProvider.get();",
-        "    ((test.Parent) instance).a2 = a2Provider.get();",
-        "    instance.a = aAndYProvider.get();",
-        "    instance.t = tAndXProvider.get();",
+        "    supertypeInjector.injectMembers(instance);",
+        "    instance.a = aProvider.get();",
+        "    instance.t = tProvider.get();",
         "  }",
         "",
         "  public static <T> MembersInjector<Child<T>> create(",
-        "      Provider<T> tAndXProvider, Provider<A> aAndYProvider, Provider<A2> a2Provider) {",
-        "    return new Child_MembersInjector<T>(tAndXProvider, aAndYProvider, a2Provider);",
-        "  }",
-        "",
-        "  public static <T> void injectA(Child<T> instance, A a) {",
-        "    instance.a = a;",
-        "  }",
-        "",
-        "  public static <T> void injectT(Child<T> instance, T t) {",
-        "    instance.t = t;",
+        "      MembersInjector<Parent<T, A>> supertypeInjector, ",
+        "      Provider<A> aProvider, Provider<T> tProvider) {",
+        "    return new Child_MembersInjector<T>(supertypeInjector, aProvider, tProvider);",
         "  }",
         "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(a, a2, parent, child))
+    assertAbout(javaSources()).that(ImmutableList.of(a, a2, parent, child))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
-        .and()
-        .generatesSources(expected);
+        .and().generatesSources(expected);
   }
 
   @Test public void fieldInjection() {
@@ -370,19 +349,18 @@ public void parentClass_injectedMembersInSupertype() {
         "  @Inject Lazy<String> lazyString;",
         "  @Inject Provider<String> stringProvider;",
         "}");
-    JavaFileObject expected = JavaFileObjects.forSourceLines(
-        "test.FieldInjection_MembersInjector",
+    JavaFileObject expected = JavaFileObjects.forSourceLines("test.FieldInjection_MembersInjector",
         "package test;",
         "",
-        "import dagger.Lazy;",
         "import dagger.MembersInjector;",
         "import dagger.internal.DoubleCheckLazy;",
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
         "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class FieldInjection_MembersInjector",
+        "public final class FieldInjection_MembersInjector ",
         "    implements MembersInjector<FieldInjection> {",
+        "",
         "  private final Provider<String> stringProvider;",
         "",
         "  public FieldInjection_MembersInjector(Provider<String> stringProvider) {",
@@ -390,8 +368,7 @@ public void parentClass_injectedMembersInSupertype() {
         "    this.stringProvider = stringProvider;",
         "  }",
         "",
-        "  @Override",
-        "  public void injectMembers(FieldInjection instance) {",
+        "  @Override public void injectMembers(FieldInjection instance) {",
         "    if (instance == null) {",
         "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
         "    }",
@@ -400,30 +377,14 @@ public void parentClass_injectedMembersInSupertype() {
         "    instance.stringProvider = stringProvider;",
         "  }",
         "",
-        "  public static MembersInjector<FieldInjection> create(Provider<String> stringProvider) {",
+        "  public static MembersInjector<FieldInjection> create(",
+        "      Provider<String> stringProvider) {",
         "    return new FieldInjection_MembersInjector(stringProvider);",
         "  }",
-        "",
-        "  public static void injectString(FieldInjection instance, String string) {",
-        "    instance.string = string;",
-        "  }",
-        "",
-        "  public static void injectLazyString(",
-        "      FieldInjection instance, Lazy<String> lazyString) {",
-        "    instance.lazyString = lazyString;",
-        "  }",
-        "",
-        "  public static void injectStringProvider(",
-        "      FieldInjection instance, Provider<String> stringProvider) {",
-        "    instance.stringProvider = stringProvider;",
-        "  }",
         "}");
-    assertAbout(javaSource())
-        .that(file)
-        .processedWith(new ComponentProcessor())
+    assertAbout(javaSource()).that(file).processedWith(new ComponentProcessor())
         .compilesWithoutError()
-        .and()
-        .generatesSources(expected);
+        .and().generatesSources(expected);
   }
 
   @Test public void methodInjection() {
@@ -444,15 +405,14 @@ public void parentClass_injectedMembersInSupertype() {
         "test.MethodInjection_MembersInjector",
         "package test;",
         "",
-        "import dagger.Lazy;",
         "import dagger.MembersInjector;",
         "import dagger.internal.DoubleCheckLazy;",
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
         "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class MethodInjection_MembersInjector",
-        "     implements MembersInjector<MethodInjection> {",
+        "public final class MethodInjection_MembersInjector ",
+        "    implements MembersInjector<MethodInjection> {",
         "",
         "  private final Provider<String> stringProvider;",
         "",
@@ -461,8 +421,7 @@ public void parentClass_injectedMembersInSupertype() {
         "    this.stringProvider = stringProvider;",
         "  }",
         "",
-        "  @Override",
-        "  public void injectMembers(MethodInjection instance) {",
+        "  @Override public void injectMembers(MethodInjection instance) {",
         "    if (instance == null) {",
         "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
         "    }",
@@ -476,35 +435,14 @@ public void parentClass_injectedMembersInSupertype() {
         "      Provider<String> stringProvider) {",
         "    return new MethodInjection_MembersInjector(stringProvider);",
         "  }",
-        "",
-        "  public static void injectNoArgs(MethodInjection instance) {",
-        "    instance.noArgs();",
-        "  }",
-        "",
-        "  public static void injectOneArg(MethodInjection instance, String string) {",
-        "    instance.oneArg(string);",
-        "  }",
-        "",
-        "  public static void injectManyArgs(",
-        "      MethodInjection instance,",
-        "      String string,",
-        "      Lazy<String> lazyString,",
-        "      Provider<String> stringProvider) {",
-        "    instance.manyArgs(string, lazyString, stringProvider);",
-        "  }",
         "}");
-    assertAbout(javaSource())
-        .that(file)
-        .processedWith(new ComponentProcessor())
+    assertAbout(javaSource()).that(file).processedWith(new ComponentProcessor())
         .compilesWithoutError()
-        .and()
-        .generatesSources(expected);
+        .and().generatesSources(expected);
   }
 
-  @Test
-  public void mixedMemberInjection() {
-    JavaFileObject file = JavaFileObjects.forSourceLines(
-        "test.MixedMemberInjection",
+  @Test public void mixedMemberInjection() {
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.MixedMemberInjection",
         "package test;",
         "",
         "import dagger.Lazy;",
@@ -526,14 +464,13 @@ public void mixedMemberInjection() {
         "import javax.inject.Provider;",
         "",
         "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class MixedMemberInjection_MembersInjector",
+        "public final class MixedMemberInjection_MembersInjector ",
         "    implements MembersInjector<MixedMemberInjection> {",
         "",
         "  private final Provider<String> stringAndSProvider;",
         "  private final Provider<Object> objectAndOProvider;",
         "",
-        "  public MixedMemberInjection_MembersInjector(",
-        "      Provider<String> stringAndSProvider,",
+        "  public MixedMemberInjection_MembersInjector(Provider<String> stringAndSProvider,",
         "      Provider<Object> objectAndOProvider) {",
         "    assert stringAndSProvider != null;",
         "    this.stringAndSProvider = stringAndSProvider;",
@@ -541,8 +478,7 @@ public void mixedMemberInjection() {
         "    this.objectAndOProvider = objectAndOProvider;",
         "  }",
         "",
-        "  @Override",
-        "  public void injectMembers(MixedMemberInjection instance) {",
+        "  @Override public void injectMembers(MixedMemberInjection instance) {",
         "    if (instance == null) {",
         "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
         "    }",
@@ -558,28 +494,10 @@ public void mixedMemberInjection() {
         "    return new MixedMemberInjection_MembersInjector(",
         "        stringAndSProvider, objectAndOProvider);",
         "  }",
-        "  public static void injectString(MixedMemberInjection instance, String string) {",
-        "    instance.string = string;",
-        "  }",
-        "",
-        "  public static void injectObject(MixedMemberInjection instance, Object object) {",
-        "    instance.object = object;",
-        "  }",
-        "",
-        "  public static void injectSetString(MixedMemberInjection instance, String s) {",
-        "    instance.setString(s);",
-        "  }",
-        "",
-        "  public static void injectSetObject(MixedMemberInjection instance, Object o) {",
-        "    instance.setObject(o);",
-        "  }",
         "}");
-    assertAbout(javaSource())
-        .that(file)
-        .processedWith(new ComponentProcessor())
+    assertAbout(javaSource()).that(file).processedWith(new ComponentProcessor())
         .compilesWithoutError()
-        .and()
-        .generatesSources(expected);
+        .and().generatesSources(expected);
   }
 
   @Test public void injectConstructorAndMembersInjection() {
@@ -612,8 +530,7 @@ public void mixedMemberInjection() {
         "    this.sProvider = sProvider;",
         "  }",
         "",
-        "  @Override",
-        "  public void injectMembers(AllInjections instance) {",
+        "  @Override public void injectMembers(AllInjections instance) {",
         "    if (instance == null) {",
         "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
         "    }",
@@ -622,16 +539,10 @@ public void mixedMemberInjection() {
         "  }",
         "",
         "  public static MembersInjector<AllInjections> create(Provider<String> sProvider) {",
-        "      return new AllInjections_MembersInjector(sProvider);",
-        "  }",
-        "",
-        "  public static void injectS(AllInjections instance, String s) {",
-        "    instance.s = s;",
+        "    return new AllInjections_MembersInjector(sProvider);",
         "  }",
         "}");
-    assertAbout(javaSource())
-        .that(file)
-        .processedWith(new ComponentProcessor())
+    assertAbout(javaSource()).that(file).processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and()
         .generatesSources(expectedMembersInjector);
@@ -659,98 +570,93 @@ public void mixedMemberInjection() {
         "import javax.inject.Provider;",
         "",
         "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class B_MembersInjector implements MembersInjector<B> {",
+        "public final class B_MembersInjector ",
+        "    implements MembersInjector<B> {",
+        "",
+        "  private final MembersInjector<A> supertypeInjector;",
         "  private final Provider<String> sProvider;",
         "",
-        "  public B_MembersInjector(Provider<String> sProvider) {",
+        "  public B_MembersInjector(MembersInjector<A> supertypeInjector,",
+        "      Provider<String> sProvider) {",
+        "    assert supertypeInjector != null;",
+        "    this.supertypeInjector = supertypeInjector;",
         "    assert sProvider != null;",
         "    this.sProvider = sProvider;",
         "  }",
         "",
-        "  @Override",
-        "  public void injectMembers(B instance) {",
+        "  @Override public void injectMembers(B instance) {",
         "    if (instance == null) {",
         "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
         "    }",
+        "    supertypeInjector.injectMembers(instance);",
         "    instance.s = sProvider.get();",
         "  }",
         "",
-        "  public static MembersInjector<B> create(Provider<String> sProvider) {",
-        "      return new B_MembersInjector(sProvider);",
-        "  }",
-        "  public static void injectS(B instance, String s) {",
-        "    instance.s = s;",
+        "  public static MembersInjector<B> create(",
+        "      MembersInjector<A> supertypeInjector,",
+        "      Provider<String> sProvider) {",
+        "    return new B_MembersInjector(supertypeInjector, sProvider);",
         "  }",
         "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(aFile, bFile))
+    assertAbout(javaSources()).that(ImmutableList.of(aFile, bFile))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
-        .and()
-        .generatesSources(expectedMembersInjector);
+        .and().generatesSources(expectedMembersInjector);
   }
 
-  @Test
-  public void simpleComponentWithNesting() {
-    JavaFileObject nestedTypesFile = JavaFileObjects.forSourceLines(
-          "test.OuterType",
-          "package test;",
-          "",
-          "import dagger.Component;",
-          "import javax.inject.Inject;",
-          "",
-          "final class OuterType {",
-          "  static class A {",
-          "    @Inject A() {}",
-          "  }",
-          "  static class B {",
-          "    @Inject A a;",
-          "  }",
-          "  @Component interface SimpleComponent {",
-          "    A a();",
-          "    void inject(B b);",
-          "  }",
-          "}");
+  @Test public void simpleComponentWithNesting() {
+    JavaFileObject nestedTypesFile = JavaFileObjects.forSourceLines("test.OuterType",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import javax.inject.Inject;",
+        "",
+        "final class OuterType {",
+        "  static class A {",
+        "    @Inject A() {}",
+        "  }",
+        "  static class B {",
+        "    @Inject A a;",
+        "  }",
+        "  @Component interface SimpleComponent {",
+        "    A a();",
+        "    void inject(B b);",
+        "  }",
+        "}");
     JavaFileObject bMembersInjector = JavaFileObjects.forSourceLines(
-          "test.OuterType$B_MembersInjector",
-          "package test;",
-          "",
-          "import dagger.MembersInjector;",
-          "import javax.annotation.Generated;",
-          "import javax.inject.Provider;",
-          "import test.OuterType.A;",
-          "import test.OuterType.B;",
-          "",
-          "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-          "public final class OuterType$B_MembersInjector implements MembersInjector<B> {",
-          "  private final Provider<A> aProvider;",
-          "",
-          "  public OuterType$B_MembersInjector(Provider<A> aProvider) {",
-          "    assert aProvider != null;",
-          "    this.aProvider = aProvider;",
-          "  }",
-          "",
-          "  @Override",
-          "  public void injectMembers(B instance) {",
-          "    if (instance == null) {",
-          "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
-          "    }",
-          "    instance.a = aProvider.get();",
-          "  }",
-          "",
-          "  public static MembersInjector<B> create(Provider<A> aProvider) {",
-          "    return new OuterType$B_MembersInjector(aProvider);",
-          "  }",
-          "",
-          "  public static void injectA(B instance, A a) {",
-          "    instance.a = a;",
-          "  }",
-          "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(nestedTypesFile))
+        "test.OuterType$B_MembersInjector",
+        "package test;",
+        "",
+        "import dagger.MembersInjector;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "import test.OuterType.A;",
+        "import test.OuterType.B;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class OuterType$B_MembersInjector implements MembersInjector<B> {",
+        "  private final Provider<A> aProvider;",
+        "",
+        "  public OuterType$B_MembersInjector(Provider<A> aProvider) {",
+        "    assert aProvider != null;",
+        "    this.aProvider = aProvider;",
+        "  }",
+         "",
+        "  @Override",
+        "  public void injectMembers(B instance) {",
+        "    if (instance == null) {",
+        "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
+        "    }",
+        "    instance.a = aProvider.get();",
+        "  }",
+        "",
+        "  public static MembersInjector<B> create(Provider<A> aProvider) {",
+        "    return new OuterType$B_MembersInjector(aProvider);",
+        "  }",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(nestedTypesFile))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
-        .and()
-        .generatesSources(bMembersInjector);
+        .and().generatesSources(bMembersInjector);
   }
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/PackageProxyTest.java b/compiler/src/test/java/dagger/internal/codegen/PackageProxyTest.java
index 8df80d19b..40ceb7ede 100644
--- a/compiler/src/test/java/dagger/internal/codegen/PackageProxyTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/PackageProxyTest.java
@@ -184,49 +184,62 @@
         "interface TestComponent {",
         "  void injectA(A a);",
         "}");
-    JavaFileObject generatedComponent =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerTestComponent",
-            "package test;",
-            "",
-            "import dagger.MembersInjector;",
-            "import javax.annotation.Generated;",
-            "",
-            "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-            "public final class DaggerTestComponent implements TestComponent {",
-            "  private MembersInjector<A> aMembersInjector;",
-            "",
-            "  private DaggerTestComponent(Builder builder) {",
-            "    assert builder != null;",
-            "    initialize(builder);",
-            "  }",
-            "",
-            "  public static Builder builder() {",
-            "    return new Builder();",
-            "  }",
-            "",
-            "  public static TestComponent create() {",
-            "    return builder().build();",
-            "  }",
-            "",
-            "  private void initialize(final Builder builder) {",
-            "     this.aMembersInjector = A_MembersInjector.create(NoDepClass_Factory.create());",
-            "  }",
-            "",
-            "  @Override",
-            "  public void injectA(A a) {",
-            "    aMembersInjector.injectMembers(a);",
-            "  }",
-            "",
-            "  public static final class Builder {",
-            "    private Builder() {",
-            "    }",
-            "",
-            "    public TestComponent build() {",
-            "      return new DaggerTestComponent(this);",
-            "    }",
-            "  }",
-            "}");
+    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
+        "test.DaggerTestComponent",
+        "package test;",
+        "",
+        "import dagger.MembersInjector;",
+        "import foreign.B;",
+        "import foreign.B_MembersInjector;",
+        "import foreign.C_MembersInjector;",
+        "import foreign.DaggerTestComponent_PackageProxy;",
+        "import javax.annotation.Generated;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class DaggerTestComponent implements TestComponent {",
+        "  private MembersInjector<D> dMembersInjector;",
+        "  private final DaggerTestComponent_PackageProxy foreign_Proxy =",
+        "      new DaggerTestComponent_PackageProxy();",
+        "  private MembersInjector<B> bMembersInjector;",
+        "  private MembersInjector<A> aMembersInjector;",
+        "",
+        "  private DaggerTestComponent(Builder builder) {",
+        "    assert builder != null;",
+        "    initialize(builder);",
+        "  }",
+        "",
+        "  public static Builder builder() {",
+        "    return new Builder();",
+        "  }",
+        "",
+        "  public static TestComponent create() {",
+        "    return builder().build();",
+        "  }",
+        "",
+        "  private void initialize(final Builder builder) {",
+        "    this.dMembersInjector = D_MembersInjector.create(NoDepClass_Factory.create());",
+        "    this.foreign_Proxy.cMembersInjector =",
+        "        C_MembersInjector.create(dMembersInjector, NoDepClass_Factory.create());",
+        "    this.bMembersInjector = B_MembersInjector.create(",
+        "        foreign_Proxy.cMembersInjector, NoDepClass_Factory.create());",
+        "    this.aMembersInjector = A_MembersInjector.create(",
+        "        bMembersInjector, NoDepClass_Factory.create());",
+        "  }",
+        "",
+        "  @Override",
+        "  public void injectA(A a) {",
+        "    aMembersInjector.injectMembers(a);",
+        "  }",
+        "",
+        "  public static final class Builder {",
+        "    private Builder() {",
+        "    }",
+        "",
+        "    public TestComponent build() {",
+        "      return new DaggerTestComponent(this);",
+        "    }",
+        "  }",
+        "}");
     assert_().about(javaSources())
         .that(ImmutableList.of(
             noDepClassFile,
