diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
index 003b98ee6..cc49cd2cd 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
@@ -57,6 +57,7 @@
 import javax.lang.model.util.Elements;
 
 import static com.google.auto.common.MoreElements.getAnnotationMirror;
+import static com.google.auto.common.MoreElements.hasModifiers;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Predicates.in;
 import static com.google.common.base.Predicates.not;
@@ -72,6 +73,8 @@
 import static dagger.internal.codegen.ContributionBinding.Kind.IS_SYNTHETIC_MULTIBINDING_KIND;
 import static dagger.internal.codegen.Key.indexByKey;
 import static dagger.internal.codegen.Scope.reusableScope;
+import static javax.lang.model.element.Modifier.ABSTRACT;
+import static javax.lang.model.element.Modifier.STATIC;
 
 /**
  * The canonical representation of a full-resolved graph.
@@ -112,8 +115,8 @@
    * The types for which the component needs instances.
    * <ul>
    * <li>component dependencies
-   * <li>{@linkplain #ownedModules() owned modules} with instance bindings that are used in the
-   *     graph
+   * <li>{@linkplain #ownedModules() owned modules} with concrete instance bindings that are used in
+   *     the graph
    * </ul>
    */
   ImmutableSet<TypeElement> componentRequirements() {
@@ -122,7 +125,8 @@
         .transformAndConcat(RESOLVED_BINDINGS)
         .transformAndConcat(ResolvedBindings.CONTRIBUTION_BINDINGS)
         .transform(HasSourceElement.SOURCE_ELEMENT)
-        .filter(not(SourceElement.IS_STATIC))
+        .filter(not(SourceElement.hasModifier(STATIC)))
+        .filter(not(SourceElement.hasModifier(ABSTRACT)))
         .transformAndConcat(SourceElement.CONTRIBUTING_CLASS)
         .filter(in(ownedModuleTypes()))
         .append(componentDescriptor().dependencies())
@@ -154,10 +158,10 @@ public ComponentDescriptor apply(BindingGraph graph) {
   }
 
   ImmutableSet<TypeElement> availableDependencies() {
-    return new ImmutableSet.Builder<TypeElement>()
-        .addAll(componentDescriptor().transitiveModuleTypes())
-        .addAll(componentDescriptor().dependencies())
-        .build();
+    return FluentIterable.from(componentDescriptor().transitiveModuleTypes())
+        .filter(not(hasModifiers(ABSTRACT)))
+        .append(componentDescriptor().dependencies())
+        .toSet();
   }
 
   static final class Factory {
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceElement.java b/compiler/src/main/java/dagger/internal/codegen/SourceElement.java
index c1205a82e..b03072a08 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SourceElement.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceElement.java
@@ -23,13 +23,12 @@
 import java.util.Set;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ElementVisitor;
+import javax.lang.model.element.Modifier;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.SimpleElementVisitor6;
 import javax.lang.model.util.Types;
 
-import static javax.lang.model.element.Modifier.STATIC;
-
 /**
  * An {@link Element}, optionally contributed by a subtype of the type that encloses it.
  */
@@ -102,12 +101,13 @@ static SourceElement forElement(Element element, TypeElement contributedBy) {
           return sourceElement.contributedBy().asSet();
         }
       };
-
-  static final Predicate<SourceElement> IS_STATIC =
-      new Predicate<SourceElement>() {
-        @Override
-        public boolean apply(SourceElement sourceElement) {
-          return sourceElement.element().getModifiers().contains(STATIC);
-        }
-      };
+      
+  static Predicate<SourceElement> hasModifier(final Modifier modifier) {
+    return new Predicate<SourceElement>() {
+      @Override
+      public boolean apply(SourceElement sourceElement) {
+        return sourceElement.element().getModifiers().contains(modifier);
+      }
+    };
+  }
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/ComponentBuilderTest.java b/compiler/src/test/java/dagger/internal/codegen/ComponentBuilderTest.java
index 2a39030b4..3623d76d2 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ComponentBuilderTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ComponentBuilderTest.java
@@ -832,31 +832,44 @@ public void testMultipleSettersPerTypeIncludingResolvedGenericsFails() {
 
   @Test
   public void testExtraSettersFails() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "abstract class SimpleComponent {",
-        "  @Component.Builder",
-        "  interface Builder {",
-        "    SimpleComponent build();",
-        "    void set1(String s);",
-        "    void set2(Integer s);",
-        "  }",
-        "}");
-    assertAbout(javaSource()).that(componentFile)
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "import javax.inject.Provider;",
+            "",
+            "@Component(modules = AbstractModule.class)",
+            "abstract class SimpleComponent {",
+            "  @Component.Builder",
+            "  interface Builder {",
+            "    SimpleComponent build();",
+            "    void abstractModule(AbstractModule abstractModule);",
+            "    void other(String s);",
+            "  }",
+            "}");
+    JavaFileObject abstractModule =
+        JavaFileObjects.forSourceLines(
+            "test.AbstractModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "",
+            "@Module",
+            "abstract class AbstractModule {}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(componentFile, abstractModule))
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(
-            String.format(MSGS.extraSetters(),
-                  "[void test.SimpleComponent.Builder.set1(String),"
-                  + " void test.SimpleComponent.Builder.set2(Integer)]"))
-            .in(componentFile).onLine(10);
-
+            String.format(
+                MSGS.extraSetters(),
+                "[void test.SimpleComponent.Builder.abstractModule(test.AbstractModule), "
+                    + "void test.SimpleComponent.Builder.other(String)]"))
+        .in(componentFile)
+        .onLine(10);
   }
 
   @Test
diff --git a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
index a9ff10681..fc1779e68 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
@@ -514,6 +514,115 @@
         .and().generatesSources(generatedComponent);
   }
 
+  @Test
+  public void componentWithAbstractModule() {
+    JavaFileObject aFile =
+        JavaFileObjects.forSourceLines(
+            "test.A",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "final class A {",
+            "  @Inject A(B b) {}",
+            "}");
+    JavaFileObject bFile =
+        JavaFileObjects.forSourceLines("test.B",
+            "package test;",
+            "",
+            "interface B {}");
+    JavaFileObject cFile =
+        JavaFileObjects.forSourceLines(
+            "test.C",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "final class C {",
+            "  @Inject C() {}",
+            "}");
+
+    JavaFileObject moduleFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "abstract class TestModule {",
+            "  @Provides static B b(C c) { return null; }",
+            "}");
+
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "import javax.inject.Provider;",
+            "",
+            "@Component(modules = TestModule.class)",
+            "interface TestComponent {",
+            "  A a();",
+            "}");
+    JavaFileObject generatedComponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerTestComponent",
+            "package test;",
+            "",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerTestComponent implements TestComponent {",
+            "  private Provider<B> bProvider;",
+            "  private Provider<A> aProvider;",
+            "",
+            "  private DaggerTestComponent(Builder builder) {",
+            "    assert builder != null;",
+            "    initialize(builder);",
+            "  }",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static TestComponent create() {",
+            "    return builder().build();",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize(final Builder builder) {",
+            "    this.bProvider = TestModule_BFactory.create(C_Factory.create());",
+            "    this.aProvider = A_Factory.create(bProvider);",
+            "  }",
+            "",
+            "  @Override",
+            "  public A a() {",
+            "    return aProvider.get();",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "",
+            "    private Builder() {",
+            "    }",
+            "",
+            "    public TestComponent build() {",
+            "      return new DaggerTestComponent(this);",
+            "    }",
+            "  }",
+            "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(aFile, bFile, cFile, moduleFile, componentFile))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and()
+        .generatesSources(generatedComponent);
+  }
+
   @Test public void transitiveModuleDeps() {
     JavaFileObject always = JavaFileObjects.forSourceLines("test.AlwaysIncluded",
         "package test;",
