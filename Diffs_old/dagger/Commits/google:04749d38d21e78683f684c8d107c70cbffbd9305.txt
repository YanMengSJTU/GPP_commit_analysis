diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
index ea56b661e..fbdef346f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
@@ -47,6 +47,7 @@
 
 import static com.google.auto.common.MoreElements.getAnnotationMirror;
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
+import static com.google.common.base.Preconditions.checkState;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.type.TypeKind.VOID;
 
@@ -142,7 +143,8 @@
       return ImmutableSet.copyOf(moduleElements);
     }
 
-    ComponentDescriptor create(TypeElement componentDefinitionType) {
+    ComponentDescriptor create(TypeElement componentDefinitionType)
+        throws SourceFileGenerationException {
       AnnotationMirror componentMirror =
           getAnnotationMirror(componentDefinitionType, Component.class).get();
       ImmutableSet<TypeElement> moduleTypes = MoreTypes.asTypeElements(types,
@@ -256,7 +258,8 @@ private void resolveRequest(DependencyRequest request,
         ImmutableSetMultimap<Key, ProvisionBinding> explicitBindings,
         SetMultimap<FrameworkKey, Binding> resolvedBindings,
         ImmutableSetMultimap.Builder<Key, ProvisionBinding> resolvedProvisionsBindingBuilder,
-        ImmutableMap.Builder<Key, MembersInjectionBinding> resolvedMembersIjectionBindingsBuilder) {
+        ImmutableMap.Builder<Key, MembersInjectionBinding> resolvedMembersIjectionBindingsBuilder)
+            throws SourceFileGenerationException {
       FrameworkKey frameworkKey = FrameworkKey.forDependencyRequest(request);
       Key requestKey = request.key();
       if (resolvedBindings.containsKey(frameworkKey)) {
@@ -272,23 +275,19 @@ private void resolveRequest(DependencyRequest request,
           if (explicitBindingsForKey.isEmpty()) {
             // no explicit binding, look it up
             Optional<ProvisionBinding> provisionBinding =
-                injectBindingRegistry.getProvisionBindingForKey(requestKey);
-            if (provisionBinding.isPresent()) {
-              // found a binding, resolve its deps and then mark it resolved
-              for (DependencyRequest dependency : Iterables.concat(
-                  provisionBinding.get().dependencies(),
-                  provisionBinding.get().memberInjectionRequest().asSet())) {
-                resolveRequest(dependency, explicitBindings, resolvedBindings,
-                    resolvedProvisionsBindingBuilder, resolvedMembersIjectionBindingsBuilder);
-              }
-              resolvedBindings.put(frameworkKey, provisionBinding.get());
-              resolvedProvisionsBindingBuilder.put(requestKey, provisionBinding.get());
-            } else {
-              throw new UnsupportedOperationException(
-                  "@Injected classes that weren't run with the compoenent processor are "
-                      + "(briefly) unsupported: " + requestKey);
-
+                injectBindingRegistry.getOrFindOrCreateProvisionBindingForKey(requestKey);
+            checkState(provisionBinding.isPresent(),
+                "could not find a provision binding for %s. this should not have passed validation",
+                requestKey);
+            // found a binding, resolve its deps and then mark it resolved
+            for (DependencyRequest dependency : Iterables.concat(
+                provisionBinding.get().dependencies(),
+                provisionBinding.get().memberInjectionRequest().asSet())) {
+              resolveRequest(dependency, explicitBindings, resolvedBindings,
+                  resolvedProvisionsBindingBuilder, resolvedMembersIjectionBindingsBuilder);
             }
+            resolvedBindings.put(frameworkKey, provisionBinding.get());
+            resolvedProvisionsBindingBuilder.put(requestKey, provisionBinding.get());
           } else {
             // we found explicit bindings. resolve the deps and them mark them resolved
             for (ProvisionBinding explicitBinding : explicitBindingsForKey) {
@@ -302,21 +301,18 @@ private void resolveRequest(DependencyRequest request,
           }
           break;
         case MEMBERS_INJECTOR:
-          // no explicit deps for members injection, so just look it up
-          Optional<MembersInjectionBinding> membersInjectionBinding =
-              injectBindingRegistry.getMembersInjectionBindingForKey(requestKey);
-          if (membersInjectionBinding.isPresent()) {
-            // found a binding, resolve its deps and then mark it resolved
-            for (DependencyRequest dependency : membersInjectionBinding.get().dependencies()) {
-              resolveRequest(dependency, explicitBindings, resolvedBindings,
-                  resolvedProvisionsBindingBuilder, resolvedMembersIjectionBindingsBuilder);
-            }
-            resolvedBindings.put(frameworkKey, membersInjectionBinding.get());
-            resolvedMembersIjectionBindingsBuilder.put(requestKey, membersInjectionBinding.get());
-          } else {
-            // TOOD(gak): make an implicit injector for cases where we need one, but it has no
-            // members
+         // no explicit deps for members injection, so just look it up
+          MembersInjectionBinding membersInjectionBinding =
+              injectBindingRegistry.getOrFindOrCreateMembersInjectionBindingForKey(requestKey);
+          //resolve its deps and then mark it resolved
+          for (DependencyRequest dependency : Iterables.concat(
+              membersInjectionBinding.dependencies(),
+              membersInjectionBinding.parentInjectorRequest().asSet())) {
+            resolveRequest(dependency, explicitBindings, resolvedBindings,
+                resolvedProvisionsBindingBuilder, resolvedMembersIjectionBindingsBuilder);
           }
+          resolvedBindings.put(frameworkKey, membersInjectionBinding);
+          resolvedMembersIjectionBindingsBuilder.put(requestKey, membersInjectionBinding);
           break;
         default:
           throw new AssertionError();
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
index 711332d6a..848aed12b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
@@ -34,6 +34,7 @@
 import dagger.MembersInjector;
 import dagger.internal.InstanceFactory;
 import dagger.internal.MapProviderFactory;
+import dagger.internal.MembersInjectors;
 import dagger.internal.ScopedProvider;
 import dagger.internal.SetFactory;
 import dagger.internal.codegen.ProvisionBinding.BindingsType;
@@ -424,11 +425,25 @@ private Snippet initializeFactoryForBinding(ProvisionBinding binding,
   private static Snippet initializeMembersInjectorForBinding(
       MembersInjectionBinding binding,
       ImmutableMap<FrameworkKey, Snippet> memberSelectSnippets) {
-    List<Snippet> parameters = getDependencyParameters(ImmutableSet.copyOf(binding.dependencies()),
-        memberSelectSnippets);
-    return Snippet.format("new %s(%s)",
-       membersInjectorNameForMembersInjectionBinding(binding).toString(),
-        Joiner.on(", ").join(parameters));
+    if (binding.injectionSites().isEmpty()) {
+      if (binding.parentInjectorRequest().isPresent()) {
+        DependencyRequest parentInjectorRequest = binding.parentInjectorRequest().get();
+        return Snippet.format("%s.delegatingTo(%s)",
+            ClassName.fromClass(MembersInjectors.class),
+            memberSelectSnippets.get(
+                FrameworkKey.forDependencyRequest(parentInjectorRequest)));
+      } else {
+        return Snippet.format("%s.noOp()",
+            ClassName.fromClass(MembersInjectors.class));
+      }
+    } else {
+      List<Snippet> parameters = getDependencyParameters(
+          Sets.union(binding.parentInjectorRequest().asSet(), binding.dependencies()),
+          memberSelectSnippets);
+      return Snippet.format("new %s(%s)",
+          membersInjectorNameForMembersInjectionBinding(binding).toString(),
+          Joiner.on(", ").join(parameters));
+    }
   }
 
   private static List<Snippet> getDependencyParameters(Iterable<DependencyRequest> dependencies,
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
index 9f0ec9c1a..41bc547c3 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -20,7 +20,6 @@
 import dagger.Component;
 import dagger.Module;
 import dagger.Provides;
-import dagger.internal.codegen.MembersInjectionBinding.InjectionSite;
 import java.util.Set;
 import javax.annotation.processing.AbstractProcessor;
 import javax.annotation.processing.Filer;
@@ -78,23 +77,27 @@ public synchronized void init(ProcessingEnvironment processingEnv) {
 
     Key.Factory keyFactory = new Key.Factory(types, elements);
 
-    InjectBindingRegistry injectBindingRegistry = new InjectBindingRegistry(keyFactory);
+    FactoryGenerator factoryGenerator = new FactoryGenerator(filer);
+    MembersInjectorGenerator membersInjectorGenerator =
+        new MembersInjectorGenerator(filer, elements, types);
+    ComponentGenerator componentGenerator = new ComponentGenerator(filer);
 
     DependencyRequest.Factory dependencyRequestFactory =
         new DependencyRequest.Factory(elements, types, keyFactory);
     ProvisionBinding.Factory provisionBindingFactory =
         new ProvisionBinding.Factory(elements, types, keyFactory, dependencyRequestFactory);
-    InjectionSite.Factory injectionSiteFactory =
-        new InjectionSite.Factory(dependencyRequestFactory);
+
+    MembersInjectionBinding.Factory membersInjectionBindingFactory =
+        new MembersInjectionBinding.Factory(elements, types, dependencyRequestFactory);
+
+    InjectBindingRegistry injectBindingRegistry = new InjectBindingRegistry(
+        elements, types, messager, provisionBindingFactory, factoryGenerator,
+        membersInjectionBindingFactory, membersInjectorGenerator, keyFactory);
+
     ComponentDescriptor.Factory componentDescriptorFactory =
         new ComponentDescriptor.Factory(elements, types, injectBindingRegistry,
             provisionBindingFactory, dependencyRequestFactory);
 
-    FactoryGenerator factoryGenerator = new FactoryGenerator(filer);
-    MembersInjectorGenerator membersInjectorGenerator =
-        new MembersInjectorGenerator(filer, elements, types);
-    ComponentGenerator componentGenerator = new ComponentGenerator(filer);
-
     this.processingSteps = ImmutableList.<ProcessingStep>of(
         new MapKeyProcessingStep(
             messager,
@@ -106,7 +109,7 @@ public synchronized void init(ProcessingEnvironment processingEnv) {
             injectMethodValidator,
             provisionBindingFactory,
             factoryGenerator,
-            injectionSiteFactory,
+            membersInjectionBindingFactory,
             membersInjectorGenerator,
             injectBindingRegistry),
         new ModuleProcessingStep(
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
index 87fc35115..41aefbf1d 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
@@ -30,6 +30,7 @@
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeMirror;
@@ -111,9 +112,11 @@ DependencyRequest forComponentMembersInjectionMethod(ExecutableElement membersIn
           membersInjectionMethod);
     }
 
-    DependencyRequest forMembersInjectedType(TypeMirror type) {
-      return new AutoValue_DependencyRequest(Kind.MEMBERS_INJECTOR, keyFactory.forType(type),
-          types.asElement(type));
+    DependencyRequest forMembersInjectedType(TypeElement type) {
+      return new AutoValue_DependencyRequest(Kind.MEMBERS_INJECTOR,
+          // TODO(gak): handle this better
+          keyFactory.forType(types.erasure(type.asType())),
+          type);
     }
 
     private DependencyRequest newDependencyRequest(Element requestElement, TypeMirror type,
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java b/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
index 836d33cca..6f02fc350 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
@@ -15,11 +15,26 @@
  */
 package dagger.internal.codegen;
 
+import com.google.auto.common.MoreElements;
 import com.google.common.base.Optional;
+import com.google.common.base.Predicate;
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Maps;
+import dagger.internal.codegen.writer.ClassName;
+import java.util.List;
 import java.util.Map;
+import javax.annotation.processing.Messager;
 import javax.inject.Inject;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.util.ElementFilter;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
+import javax.tools.Diagnostic.Kind;
 
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
+import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
 
@@ -30,11 +45,32 @@
  * @author Gregory Kick
  */
 final class InjectBindingRegistry {
+  private final Elements elements;
+  private final Types types;
+  private final Messager messager;
+  private final ProvisionBinding.Factory provisionBindingFactory;
+  private final FactoryGenerator factoryGenerator;
+  private final MembersInjectionBinding.Factory membersInjectionBindingFactory;
+  private final MembersInjectorGenerator membersInjectorGenerator;
+  private final Key.Factory keyFactory;
   private final Map<Key, ProvisionBinding> provisionBindingsByKey;
   private final Map<Key, MembersInjectionBinding> membersInjectionBindingsByKey;
-  private final Key.Factory keyFactory;
 
-  InjectBindingRegistry(Key.Factory keyFactory) {
+  InjectBindingRegistry(Elements elements,
+      Types types,
+      Messager messager,
+      ProvisionBinding.Factory provisionBindingFactory,
+      FactoryGenerator factoryGenerator,
+      MembersInjectionBinding.Factory membersInjectionBindingFactory,
+      MembersInjectorGenerator membersInjectorGenerator,
+      Key.Factory keyFactory) {
+    this.elements = elements;
+    this.types = types;
+    this.messager = messager;
+    this.provisionBindingFactory = provisionBindingFactory;
+    this.factoryGenerator = factoryGenerator;
+    this.membersInjectionBindingFactory = membersInjectionBindingFactory;
+    this.membersInjectorGenerator = membersInjectorGenerator;
     this.provisionBindingsByKey = Maps.newLinkedHashMap();
     this.membersInjectionBindingsByKey = Maps.newLinkedHashMap();
     this.keyFactory = keyFactory;
@@ -42,20 +78,77 @@
 
   void registerProvisionBinding(ProvisionBinding binding) {
     ProvisionBinding previousValue = provisionBindingsByKey.put(binding.providedKey(), binding);
-    checkState(previousValue == null);
+    checkState(previousValue == null, "couldn't register %s. %s was already registered", binding,
+        previousValue);
   }
 
   void registerMembersInjectionBinding(MembersInjectionBinding binding) {
     MembersInjectionBinding previousValue = membersInjectionBindingsByKey.put(
         keyFactory.forType(binding.bindingElement().asType()), binding);
-    checkState(previousValue == null);
+    checkState(previousValue == null, "couldn't register %s. %s was already registered", binding,
+        previousValue);
   }
 
-  Optional<ProvisionBinding> getProvisionBindingForKey(Key key) {
-    return Optional.fromNullable(provisionBindingsByKey.get(checkNotNull(key)));
+  Optional<ProvisionBinding> getOrFindOrCreateProvisionBindingForKey(Key key)
+      throws SourceFileGenerationException {
+    checkNotNull(key);
+    checkArgument(!key.qualifier().isPresent());
+    ProvisionBinding bindingFromThisProcessor = provisionBindingsByKey.get(key);
+    if (bindingFromThisProcessor != null) {
+      return Optional.of(bindingFromThisProcessor);
+    }
+    // ok, let's see if we can find an @Inject constructor
+    TypeElement element = MoreElements.asType(types.asElement(key.type()));
+    List<ExecutableElement> constructors =
+        ElementFilter.constructorsIn(element.getEnclosedElements());
+    ImmutableSet<ExecutableElement> injectConstructors = FluentIterable.from(constructors)
+        .filter(new Predicate<ExecutableElement>() {
+          @Override public boolean apply(ExecutableElement input) {
+            return isAnnotationPresent(input, Inject.class);
+          }
+        }).toSet();
+    switch (injectConstructors.size()) {
+      case 0:
+        return Optional.absent();
+      case 1:
+        ProvisionBinding constructorBinding = provisionBindingFactory.forInjectConstructor(
+            injectConstructors.iterator().next());
+        registerProvisionBinding(constructorBinding);
+        ClassName factoryName = SourceFiles.factoryNameForProvisionBinding(constructorBinding);
+        if (elements.getTypeElement(factoryName.canonicalName()) == null) {
+          // does not exist.  generate
+          factoryGenerator.generate(constructorBinding);
+          messager.printMessage(Kind.NOTE, String.format("Generating a Factory for %s. "
+              + "Prefer to run the dagger processor over that class instead.", key.type()));
+        }
+        return Optional.of(constructorBinding);
+      default:
+        throw new IllegalStateException("Found multiple @Inject constructors: "
+            + injectConstructors);
+    }
   }
 
-  Optional<MembersInjectionBinding> getMembersInjectionBindingForKey(Key key) {
-    return Optional.fromNullable(membersInjectionBindingsByKey.get(checkNotNull(key)));
+    MembersInjectionBinding getOrFindOrCreateMembersInjectionBindingForKey(Key key)
+      throws SourceFileGenerationException {
+    checkNotNull(key);
+    checkArgument(!key.qualifier().isPresent());
+    MembersInjectionBinding bindingFromThisProcessor = membersInjectionBindingsByKey.get(key);
+    if (bindingFromThisProcessor != null) {
+      return bindingFromThisProcessor;
+    }
+    TypeElement element = MoreElements.asType(types.asElement(key.type()));
+    MembersInjectionBinding binding = membersInjectionBindingFactory.forInjectedType(element);
+    if (!binding.injectionSites().isEmpty()) {
+      ClassName membersInjectorName =
+          SourceFiles.membersInjectorNameForMembersInjectionBinding(binding);
+      if (elements.getTypeElement(membersInjectorName.canonicalName()) == null) {
+        // does not exist.  generate
+        membersInjectorGenerator.generate(binding);
+        messager.printMessage(Kind.NOTE, String.format("Generating a MembersInjector for %s. "
+            + "Prefer to run the dagger processor over that class instead.", key.type()));
+        registerMembersInjectionBinding(binding);
+      }
+    }
+    return binding;
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/InjectProcessingStep.java
index 5779026f8..92183c5ca 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectProcessingStep.java
@@ -17,12 +17,7 @@
 
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.SuperficialValidation;
-import com.google.common.base.Function;
-import com.google.common.collect.ImmutableListMultimap;
 import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.Multimaps;
-import dagger.internal.codegen.MembersInjectionBinding.InjectionSite;
-import java.util.Collection;
 import java.util.Set;
 import javax.annotation.processing.Messager;
 import javax.annotation.processing.RoundEnvironment;
@@ -47,7 +42,7 @@
   private final InjectMethodValidator methodValidator;
   private final ProvisionBinding.Factory provisionBindingFactory;
   private final FactoryGenerator factoryGenerator;
-  private final InjectionSite.Factory injectionSiteFactory;
+  private final MembersInjectionBinding.Factory membersInjectionBindingFactory;
   private final MembersInjectorGenerator membersInjectorWriter;
   private final InjectBindingRegistry injectBindingRegistry;
 
@@ -57,7 +52,7 @@
       InjectMethodValidator methodValidator,
       ProvisionBinding.Factory provisionBindingFactory,
       FactoryGenerator factoryGenerator,
-      InjectionSite.Factory injectionSiteFactory,
+      MembersInjectionBinding.Factory membersInjectionBindingFactory,
       MembersInjectorGenerator membersInjectorWriter,
       InjectBindingRegistry factoryRegistrar) {
     this.messager = messager;
@@ -66,7 +61,7 @@
     this.methodValidator = methodValidator;
     this.provisionBindingFactory = provisionBindingFactory;
     this.factoryGenerator = factoryGenerator;
-    this.injectionSiteFactory = injectionSiteFactory;
+    this.membersInjectionBindingFactory = membersInjectionBindingFactory;
     this.membersInjectorWriter = membersInjectorWriter;
     this.injectBindingRegistry = factoryRegistrar;
   }
@@ -75,7 +70,8 @@
   public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
     // TODO(gak): add some error handling for bad source files
     final ImmutableSet.Builder<ProvisionBinding> provisions = ImmutableSet.builder();
-    final ImmutableSet.Builder<InjectionSite> memberInjectionSites = ImmutableSet.builder();
+    // TODO(gak): instead, we should collect reports by type and check later
+    final ImmutableSet.Builder<TypeElement> membersInjectedTypes = ImmutableSet.builder();
 
     for (Element injectElement : roundEnv.getElementsAnnotatedWith(Inject.class)) {
       if (SuperficialValidation.validateElement(injectElement)) {
@@ -103,7 +99,7 @@ public Void visitVariableAsField(VariableElement fieldElement, Void p) {
                 report.printMessagesTo(messager);
 
                 if (report.isClean()) {
-                  memberInjectionSites.add(injectionSiteFactory.forInjectField(fieldElement));
+                  membersInjectedTypes.add(MoreElements.asType(fieldElement.getEnclosingElement()));
                 }
 
                 return null;
@@ -117,7 +113,8 @@ public Void visitExecutableAsMethod(ExecutableElement methodElement, Void p) {
                 report.printMessagesTo(messager);
 
                 if (report.isClean()) {
-                  memberInjectionSites.add(injectionSiteFactory.forInjectMethod(methodElement));
+                  membersInjectedTypes.add(
+                      MoreElements.asType(methodElement.getEnclosingElement()));
                 }
 
                 return null;
@@ -126,17 +123,10 @@ public Void visitExecutableAsMethod(ExecutableElement methodElement, Void p) {
       }
     }
 
-    ImmutableListMultimap<TypeElement, InjectionSite> membersInjectionsByType =
-        Multimaps.index(memberInjectionSites.build(),
-            new Function<InjectionSite, TypeElement>() {
-              @Override public TypeElement apply(InjectionSite injectionSite) {
-                return MoreElements.asType(injectionSite.element().getEnclosingElement());
-              }
-            });
-
-    for (Collection<InjectionSite> injectionSites : membersInjectionsByType.asMap().values()) {
+    for (TypeElement injectedType : membersInjectedTypes.build()) {
       try {
-        MembersInjectionBinding binding = MembersInjectionBinding.create(injectionSites);
+        MembersInjectionBinding binding =
+            membersInjectionBindingFactory.forInjectedType(injectedType);
         membersInjectorWriter.generate(binding);
         injectBindingRegistry.registerMembersInjectionBinding(binding);
       } catch (SourceFileGenerationException e) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
index 918731f75..98b21c7cd 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
@@ -23,7 +23,6 @@
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ImmutableSortedSet;
-import com.google.common.collect.Iterables;
 import com.google.common.collect.Ordering;
 import java.util.Set;
 import javax.inject.Inject;
@@ -32,11 +31,15 @@
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.ElementKindVisitor6;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
 
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
-import static javax.lang.model.element.Modifier.PUBLIC;
+import static javax.lang.model.type.TypeKind.NONE;
 
 /**
  * Represents the full members injection of a particular type. This does not pay attention to
@@ -49,42 +52,11 @@
 abstract class MembersInjectionBinding extends Binding {
   @Override abstract TypeElement bindingElement();
 
-  @Override ImmutableSet<DependencyRequest> implicitDependencies() {
-    return dependencies();
-  }
-
-  /**
-   * Creates a {@link MembersInjectionBinding} for the given bindings.
-   *
-   * @throws IllegalArgumentException if the bindings are not all associated with the same type.
-   */
-  static MembersInjectionBinding create(Iterable<InjectionSite> injectionSites) {
-    ImmutableSortedSet<InjectionSite> injectionSiteSet =
-        ImmutableSortedSet.copyOf(INJECTION_ORDERING, injectionSites);
-    TypeElement injectedTypeElement = Iterables.getOnlyElement(FluentIterable.from(injectionSiteSet)
-        .transform(new Function<InjectionSite, TypeElement>() {
-          @Override public TypeElement apply(InjectionSite injectionSite) {
-            return MoreElements.asType(injectionSite.element().getEnclosingElement());
-          }
-        })
-        .toSet());
-    ImmutableSet<DependencyRequest> dependencies = FluentIterable.from(injectionSiteSet)
-        .transformAndConcat(new Function<InjectionSite, Set<DependencyRequest>>() {
-          @Override public Set<DependencyRequest> apply(InjectionSite input) {
-            return input.dependencies();
-          }
-        })
-        .toSet();
-    Optional<String> bindingPackage = injectedTypeElement.getModifiers().contains(PUBLIC)
-        ? Optional.<String>absent()
-        : Optional.of(MoreElements.getPackage(injectedTypeElement).getQualifiedName().toString());
-    return new AutoValue_MembersInjectionBinding(
-        dependencies, bindingPackage, injectedTypeElement, injectionSiteSet);
-  }
-
   /** The set of individual sites where {@link Inject} is applied. */
   abstract ImmutableSortedSet<InjectionSite> injectionSites();
 
+  abstract Optional<DependencyRequest> parentInjectorRequest();
+
   private static final Ordering<InjectionSite> INJECTION_ORDERING =
       new Ordering<InjectionSite>() {
         @Override
@@ -118,29 +90,97 @@ private int targetIndexInEnclosing(InjectionSite injectionSite)  {
     abstract Element element();
 
     abstract ImmutableSet<DependencyRequest> dependencies();
+  }
 
-    static final class Factory {
-      private final DependencyRequest.Factory dependencyRequestFactory;
+  static final class Factory {
+    private final Elements elements;
+    private final Types types;
+    private final DependencyRequest.Factory dependencyRequestFactory;
 
-      Factory(DependencyRequest.Factory dependencyRequestFactory) {
-        this.dependencyRequestFactory = checkNotNull(dependencyRequestFactory);
-      }
+    Factory(Elements elements, Types types, DependencyRequest.Factory dependencyRequestFactory) {
+      this.elements = checkNotNull(elements);
+      this.types = checkNotNull(types);
+      this.dependencyRequestFactory = checkNotNull(dependencyRequestFactory);
+    }
 
-      InjectionSite forInjectMethod(ExecutableElement methodElement) {
-        checkNotNull(methodElement);
-        checkArgument(methodElement.getKind().equals(ElementKind.METHOD));
-        checkArgument(isAnnotationPresent(methodElement, Inject.class));
-        return new AutoValue_MembersInjectionBinding_InjectionSite(Kind.METHOD, methodElement,
-            dependencyRequestFactory.forRequiredVariables(methodElement.getParameters()));
-      }
+    private InjectionSite injectionSiteForInjectMethod(ExecutableElement methodElement) {
+      checkNotNull(methodElement);
+      checkArgument(methodElement.getKind().equals(ElementKind.METHOD));
+      checkArgument(isAnnotationPresent(methodElement, Inject.class));
+      return new AutoValue_MembersInjectionBinding_InjectionSite(InjectionSite.Kind.METHOD,
+          methodElement,
+          dependencyRequestFactory.forRequiredVariables(methodElement.getParameters()));
+    }
 
-      InjectionSite forInjectField(VariableElement fieldElement) {
-        checkNotNull(fieldElement);
-        checkArgument(fieldElement.getKind().equals(ElementKind.FIELD));
-        checkArgument(isAnnotationPresent(fieldElement, Inject.class));
-        return new AutoValue_MembersInjectionBinding_InjectionSite(Kind.FIELD, fieldElement,
-            ImmutableSet.of(dependencyRequestFactory.forRequiredVariable(fieldElement)));
+    private InjectionSite injectionSiteForInjectField(VariableElement fieldElement) {
+      checkNotNull(fieldElement);
+      checkArgument(fieldElement.getKind().equals(ElementKind.FIELD));
+      checkArgument(isAnnotationPresent(fieldElement, Inject.class));
+      return new AutoValue_MembersInjectionBinding_InjectionSite(InjectionSite.Kind.FIELD,
+          fieldElement,
+          ImmutableSet.of(dependencyRequestFactory.forRequiredVariable(fieldElement)));
+    }
+
+    MembersInjectionBinding forInjectedType(TypeElement typeElement) {
+      ImmutableSortedSet.Builder<InjectionSite> injectionSitesBuilder =
+          ImmutableSortedSet.orderedBy(INJECTION_ORDERING);
+      for (Element enclosedElement : typeElement.getEnclosedElements()) {
+        injectionSitesBuilder.addAll(enclosedElement.accept(
+            new ElementKindVisitor6<Optional<InjectionSite>, Void>(
+                Optional.<InjectionSite>absent()) {
+                  @Override
+                  public Optional<InjectionSite> visitExecutableAsMethod(ExecutableElement e,
+                      Void p) {
+                    return isAnnotationPresent(e, Inject.class)
+                        ? Optional.of(injectionSiteForInjectMethod(e))
+                        : Optional.<InjectionSite>absent();
+                  }
+
+                  @Override
+                  public Optional<InjectionSite> visitVariableAsField(VariableElement e, Void p) {
+                    return isAnnotationPresent(e, Inject.class)
+                        ? Optional.of(injectionSiteForInjectField(e))
+                        : Optional.<InjectionSite>absent();
+                  }
+                }, null).asSet());
       }
+      ImmutableSortedSet<InjectionSite> injectionSites = injectionSitesBuilder.build();
+
+      ImmutableSet<DependencyRequest> dependencies = FluentIterable.from(injectionSites)
+          .transformAndConcat(new Function<InjectionSite, Set<DependencyRequest>>() {
+            @Override public Set<DependencyRequest> apply(InjectionSite input) {
+              return input.dependencies();
+            }
+          })
+          .toSet();
+
+      Optional<DependencyRequest> parentInjectorRequest = nonObjectSupertype(typeElement)
+          .transform(new Function<TypeElement, DependencyRequest>() {
+            @Override public DependencyRequest apply(TypeElement input) {
+              return dependencyRequestFactory.forMembersInjectedType(input);
+            }
+          });
+
+      return new AutoValue_MembersInjectionBinding(
+          dependencies,
+          new ImmutableSet.Builder<DependencyRequest>()
+              .addAll(dependencies)
+              .addAll(parentInjectorRequest.asSet())
+              .build(),
+          Optional.of(MoreElements.getPackage(typeElement).getQualifiedName().toString()),
+          typeElement,
+          injectionSites,
+          parentInjectorRequest);
+    }
+
+    private Optional<TypeElement> nonObjectSupertype(TypeElement type) {
+      TypeMirror superclass = type.getSuperclass();
+      boolean nonObjectSuperclass = !superclass.getKind().equals(NONE)
+          && !types.isSameType(
+              elements.getTypeElement(Object.class.getCanonicalName()).asType(), superclass);
+      return nonObjectSuperclass
+          ? Optional.of(MoreElements.asType(types.asElement(superclass)))
+          : Optional.<TypeElement>absent();
     }
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
index b2aae3a8b..c8837740b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
@@ -49,14 +49,14 @@
 import static dagger.Provides.Type.MAP;
 import static dagger.Provides.Type.SET;
 import static dagger.Provides.Type.SET_VALUES;
+import static dagger.internal.codegen.ErrorMessages.INVALID_COLLECTIONBINDING;
+import static dagger.internal.codegen.ErrorMessages.NON_MAPBINDING;
+import static dagger.internal.codegen.ErrorMessages.NON_SETBINDING;
 import static dagger.internal.codegen.InjectionAnnotations.getScopeAnnotation;
 import static javax.lang.model.element.ElementKind.CONSTRUCTOR;
 import static javax.lang.model.element.ElementKind.FIELD;
 import static javax.lang.model.element.ElementKind.METHOD;
 import static javax.lang.model.element.Modifier.PUBLIC;
-import static dagger.internal.codegen.ErrorMessages.NON_SETBINDING;
-import static dagger.internal.codegen.ErrorMessages.NON_MAPBINDING;
-import static dagger.internal.codegen.ErrorMessages.INVALID_COLLECTIONBINDING;
 
 /**
  * A value object representing the mechanism by which a {@link Key} can be provided. New instances
@@ -106,17 +106,16 @@
 
   private static ImmutableSet<Provides.Type> SET_BINDING_TYPES = immutableEnumSet(SET, SET_VALUES);
   private static ImmutableSet<Provides.Type> MAP_BINDING_TYPES = immutableEnumSet(MAP);
-  
-  
+
   static enum BindingsType {
     /** Represents set bindings. */
-    SET_BINDING, 
+    SET_BINDING,
     /** Represents map bindings. */
-    MAP_BINDING, 
+    MAP_BINDING,
     /** Represents a valid non-collection binding. */
     SINGULAR_BINDING,
   }
-  
+
   /**
    * Returns {@code BindingsType} for bindings, which can be {@code SETBINDING} if the given
    * bindings are all contributors to a set binding. Returns {@code MAPBINDING} if the given
@@ -165,7 +164,7 @@ static BindingsType getBindingsType(Iterable<ProvisionBinding> bindings) {
         throw new IllegalStateException(INVALID_COLLECTIONBINDING);
     }
   }
-  
+
   static final class Factory {
     private final Elements elements;
     private final Types types;
@@ -263,12 +262,12 @@ ProvisionBinding forInjectConstructor(ExecutableElement constructorElement) {
     private Optional<DependencyRequest> membersInjectionRequest(TypeElement type) {
       if (!types.isSameType(elements.getTypeElement(Object.class.getCanonicalName()).asType(),
           type.getSuperclass())) {
-        return Optional.of(dependencyRequestFactory.forMembersInjectedType(type.asType()));
+        return Optional.of(dependencyRequestFactory.forMembersInjectedType(type));
       }
       for (Element enclosedElement : type.getEnclosedElements()) {
         if (MEMBER_KINDS.contains(enclosedElement.getKind())
             && (isAnnotationPresent(enclosedElement, Inject.class))) {
-          return Optional.of(dependencyRequestFactory.forMembersInjectedType(type.asType()));
+          return Optional.of(dependencyRequestFactory.forMembersInjectedType(type));
         }
       }
       return Optional.absent();
diff --git a/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java b/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java
new file mode 100644
index 000000000..178cb1c72
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java
@@ -0,0 +1,175 @@
+package dagger.internal.codegen;
+
+import com.google.common.collect.ImmutableList;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assert_;
+import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+
+@RunWith(JUnit4.class)
+public class MembersInjectionTest {
+  @Test
+  public void parentClass_noInjectedMembers() {
+    JavaFileObject childFile = JavaFileObjects.forSourceLines("test.Child",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "public final class Child extends Parent {",
+        "  @Inject Child() {}",
+        "}");
+    JavaFileObject parentFile = JavaFileObjects.forSourceLines("test.Parent",
+        "package test;",
+        "",
+        "public abstract class Parent {}");
+
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "",
+        "@Component",
+        "interface TestComponent {",
+        "  Child child();",
+        "}");
+    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
+        "test.Dagger_TestComponent",
+        "package test;",
+        "",
+        "import dagger.MembersInjector;",
+        "import dagger.internal.MembersInjectors;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class Dagger_TestComponent implements TestComponent {",
+        "  private final MembersInjector<Parent> parentMembersInjector;",
+        "  private final MembersInjector<Child> childMembersInjector;",
+        "  private final Provider<Child> childProvider;",
+        "",
+        "  private Dagger_TestComponent(Builder builder) {",
+        "    assert builder != null;",
+        "    this.parentMembersInjector = MembersInjectors.noOp();",
+        "    this.childMembersInjector = MembersInjectors.delegatingTo(parentMembersInjector);",
+        "    this.childProvider = new Child$$Factory(childMembersInjector);",
+        "  }",
+        "",
+        "  public static Builder builder() {",
+        "    return new Builder();",
+        "  }",
+        "",
+        "  public static TestComponent create() {",
+        "    return builder().build();",
+        "  }",
+        "",
+        "  @Override public Child child() {",
+        "    return childProvider.get();",
+        "  }",
+        "",
+        "  public static final class Builder {",
+        "    private Builder() {}",
+        "",
+        "    public TestComponent build() {",
+        "      return new Dagger_TestComponent(this);",
+        "    }",
+        "  }",
+        "}");
+    assert_().about(javaSources())
+        .that(ImmutableList.of(childFile, parentFile, componentFile))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(generatedComponent);
+  }
+
+  @Test
+  public void parentClass_injectedMembersInSupertype() {
+    JavaFileObject childFile = JavaFileObjects.forSourceLines("test.Child",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "public final class Child extends Parent {",
+        "  @Inject Child() {}",
+        "}");
+    JavaFileObject parentFile = JavaFileObjects.forSourceLines("test.Parent",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "public abstract class Parent {",
+        "  @Inject Dep dep;",
+        "}");
+    JavaFileObject depFile = JavaFileObjects.forSourceLines("test.Dep",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class Dep {",
+        "  @Inject Dep() {}",
+        "}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "",
+        "@Component",
+        "interface TestComponent {",
+        "  Child child();",
+        "}");
+    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
+        "test.Dagger_TestComponent",
+        "package test;",
+        "",
+        "import dagger.MembersInjector;",
+        "import dagger.internal.MembersInjectors;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class Dagger_TestComponent implements TestComponent {",
+        "  private final Provider<Dep> depProvider;",
+        "  private final MembersInjector<Parent> parentMembersInjector;",
+        "  private final MembersInjector<Child> childMembersInjector;",
+        "  private final Provider<Child> childProvider;",
+        "",
+        "  private Dagger_TestComponent(Builder builder) {",
+        "    assert builder != null;",
+        "    this.depProvider = new Dep$$Factory();",
+        "    this.parentMembersInjector = new Parent$$MembersInjector(depProvider);",
+        "    this.childMembersInjector = MembersInjectors.delegatingTo(parentMembersInjector);",
+        "    this.childProvider = new Child$$Factory(childMembersInjector);",
+        "  }",
+        "",
+        "  public static Builder builder() {",
+        "    return new Builder();",
+        "  }",
+        "",
+        "  public static TestComponent create() {",
+        "    return builder().build();",
+        "  }",
+        "",
+        "  @Override public Child child() {",
+        "    return childProvider.get();",
+        "  }",
+        "",
+        "  public static final class Builder {",
+        "    private Builder() {}",
+        "",
+        "    public TestComponent build() {",
+        "      return new Dagger_TestComponent(this);",
+        "    }",
+        "  }",
+        "}");
+    assert_().about(javaSources())
+        .that(ImmutableList.of(childFile, parentFile, depFile, componentFile))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(generatedComponent);
+  }
+}
