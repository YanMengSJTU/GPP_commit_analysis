diff --git a/compiler/src/main/java/dagger/internal/codegen/CodeBlocks.java b/compiler/src/main/java/dagger/internal/codegen/CodeBlocks.java
index 41d6570c0..0bb43f65a 100644
--- a/compiler/src/main/java/dagger/internal/codegen/CodeBlocks.java
+++ b/compiler/src/main/java/dagger/internal/codegen/CodeBlocks.java
@@ -19,6 +19,7 @@
 import com.squareup.javapoet.CodeBlock;
 import com.squareup.javapoet.ParameterSpec;
 import java.util.Iterator;
+import javax.lang.model.type.TypeMirror;
 
 final class CodeBlocks {
 
@@ -43,6 +44,14 @@ static CodeBlock join(Iterable<CodeBlock> codeBlocks, String delimiter) {
     return builder.build();
   }
 
+  static final Function<TypeMirror, CodeBlock> TYPE_MIRROR_TO_CODE_BLOCK =
+      new Function<TypeMirror, CodeBlock>() {
+        @Override
+        public CodeBlock apply(TypeMirror typeMirror) {
+          return CodeBlocks.format("$T", typeMirror);
+        }
+      };
+
   static Function<ParameterSpec, CodeBlock> PARAMETER_NAME =
       new Function<ParameterSpec, CodeBlock>() {
           @Override
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
index 83c22eb9a..d4539a8f6 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
@@ -51,6 +51,9 @@
 import static com.google.auto.common.MoreElements.getPackage;
 import static com.google.common.base.Preconditions.checkState;
 import static com.google.common.collect.Iterables.getOnlyElement;
+import static com.squareup.javapoet.MethodSpec.constructorBuilder;
+import static com.squareup.javapoet.MethodSpec.methodBuilder;
+import static com.squareup.javapoet.TypeSpec.classBuilder;
 import static dagger.internal.codegen.AnnotationSpecs.SUPPRESS_WARNINGS_RAWTYPES;
 import static dagger.internal.codegen.AnnotationSpecs.SUPPRESS_WARNINGS_UNCHECKED;
 import static dagger.internal.codegen.TypeNames.membersInjectorOf;
@@ -100,7 +103,7 @@ ClassName nameGeneratedType(MembersInjectionBinding binding) {
 
     ImmutableList<TypeVariableName> typeParameters = bindingTypeElementTypeVariableNames(binding);
     TypeSpec.Builder injectorTypeBuilder =
-        TypeSpec.classBuilder(generatedTypeName.simpleName())
+        classBuilder(generatedTypeName.simpleName())
             .addModifiers(PUBLIC, FINAL)
             .addTypeVariables(typeParameters);
 
@@ -109,7 +112,7 @@ ClassName nameGeneratedType(MembersInjectionBinding binding) {
     injectorTypeBuilder.addSuperinterface(implementedType);
 
     MethodSpec.Builder injectMembersBuilder =
-        MethodSpec.methodBuilder("injectMembers")
+        methodBuilder("injectMembers")
             .returns(TypeName.VOID)
             .addModifiers(PUBLIC)
             .addAnnotation(Override.class)
@@ -126,13 +129,13 @@ ClassName nameGeneratedType(MembersInjectionBinding binding) {
 
     ImmutableMap.Builder<BindingKey, FieldSpec> dependencyFieldsBuilder = ImmutableMap.builder();
 
-    MethodSpec.Builder constructorBuilder = MethodSpec.constructorBuilder().addModifiers(PUBLIC);
+    MethodSpec.Builder constructorBuilder = constructorBuilder().addModifiers(PUBLIC);
 
     // We use a static create method so that generated components can avoid having
     // to refer to the generic types of the factory.
     // (Otherwise they may have visibility problems referring to the types.)
     MethodSpec.Builder createMethodBuilder =
-        MethodSpec.methodBuilder("create")
+        methodBuilder("create")
             .returns(implementedType)
             .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
             .addTypeVariables(typeParameters);
@@ -310,7 +313,7 @@ private MethodSpec injectorMethodForSubclasses(
       Element injectionElement,
       ImmutableSet<DependencyRequest> dependencies) {
     MethodSpec.Builder methodBuilder =
-        MethodSpec.methodBuilder(injectionSiteDelegateMethodName(injectionElement))
+        methodBuilder(injectionSiteDelegateMethodName(injectionElement))
             .addModifiers(PUBLIC, STATIC)
             .addParameter(injectedTypeName, "instance")
             .addTypeVariables(typeParameters);
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
index 56cb6d25a..182c9a8d1 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
@@ -22,39 +22,41 @@
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
-import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
-import com.google.common.util.concurrent.AsyncFunction;
-import com.google.common.util.concurrent.Futures;
-import com.google.common.util.concurrent.ListenableFuture;
-import dagger.internal.codegen.writer.ClassName;
-import dagger.internal.codegen.writer.ClassWriter;
-import dagger.internal.codegen.writer.ConstructorWriter;
-import dagger.internal.codegen.writer.FieldWriter;
-import dagger.internal.codegen.writer.JavaWriter;
-import dagger.internal.codegen.writer.MethodWriter;
-import dagger.internal.codegen.writer.ParameterizedTypeName;
-import dagger.internal.codegen.writer.Snippet;
-import dagger.internal.codegen.writer.TypeName;
-import dagger.internal.codegen.writer.TypeNames;
-import dagger.producers.Produced;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.MethodSpec;
+import com.squareup.javapoet.TypeName;
+import com.squareup.javapoet.TypeSpec;
 import dagger.producers.Producer;
 import dagger.producers.Produces;
 import dagger.producers.Produces.Type;
-import dagger.producers.internal.AbstractProducer;
-import dagger.producers.internal.Producers;
 import dagger.producers.monitoring.ProducerMonitor;
-import dagger.producers.monitoring.ProducerToken;
 import java.util.List;
-import java.util.concurrent.Executor;
 import javax.annotation.processing.Filer;
 import javax.lang.model.element.Element;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
 
+import static com.squareup.javapoet.ClassName.OBJECT;
+import static com.squareup.javapoet.MethodSpec.constructorBuilder;
+import static com.squareup.javapoet.MethodSpec.methodBuilder;
+import static com.squareup.javapoet.TypeSpec.classBuilder;
+import static dagger.internal.codegen.AnnotationSpecs.SUPPRESS_WARNINGS_UNCHECKED;
+import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
 import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
-import static dagger.internal.codegen.SourceFiles.generatedClassNameForBinding;
-import static dagger.internal.codegen.writer.Snippet.makeParametersSnippet;
+import static dagger.internal.codegen.SourceFiles.javapoetGeneratedClassNameForBinding;
+import static dagger.internal.codegen.TypeNames.abstractProducerOf;
+import static dagger.internal.codegen.TypeNames.listOf;
+import static dagger.internal.codegen.TypeNames.listenableFutureOf;
+import static dagger.internal.codegen.TypeNames.ASYNC_FUNCTION;
+import static dagger.internal.codegen.TypeNames.EXECUTOR;
+import static dagger.internal.codegen.TypeNames.FUTURES;
+import static dagger.internal.codegen.TypeNames.IMMUTABLE_SET;
+import static dagger.internal.codegen.TypeNames.PRODUCER_TOKEN;
+import static dagger.internal.codegen.TypeNames.PRODUCERS;
+import static dagger.internal.codegen.TypeNames.VOID_CLASS;
+import static dagger.internal.codegen.TypeNames.producedOf;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.PROTECTED;
@@ -67,7 +69,8 @@
  * @author Jesse Beder
  * @since 2.0
  */
-final class ProducerFactoryGenerator extends JavaWriterSourceFileGenerator<ProductionBinding> {
+final class ProducerFactoryGenerator extends JavaPoetSourceFileGenerator<ProductionBinding> {
+
   private final DependencyRequestMapper dependencyRequestMapper;
 
   ProducerFactoryGenerator(
@@ -78,12 +81,7 @@
 
   @Override
   ClassName nameGeneratedType(ProductionBinding binding) {
-    return generatedClassNameForBinding(binding);
-  }
-
-  @Override
-  Iterable<? extends Element> getOriginatingElements(ProductionBinding binding) {
-    return ImmutableSet.of(binding.bindingElement());
+    return javapoetGeneratedClassNameForBinding(binding);
   }
 
   @Override
@@ -92,65 +90,43 @@ ClassName nameGeneratedType(ProductionBinding binding) {
   }
 
   @Override
-  ImmutableSet<JavaWriter> write(ClassName generatedTypeName, ProductionBinding binding) {
+  Optional<TypeSpec.Builder> write(ClassName generatedTypeName, ProductionBinding binding) {
     TypeMirror keyType =
         binding.productionType().equals(Type.MAP)
             ? MapType.from(binding.key().type()).unwrappedValueType(Producer.class)
             : binding.key().type();
-    TypeName providedTypeName = TypeNames.forTypeMirror(keyType);
-    TypeName futureTypeName = ParameterizedTypeName.create(
-        ClassName.fromClass(ListenableFuture.class), providedTypeName);
-    JavaWriter writer = JavaWriter.inPackage(generatedTypeName.packageName());
+    TypeName providedTypeName = TypeName.get(keyType);
+    TypeName futureTypeName = listenableFutureOf(providedTypeName);
 
-    ClassWriter factoryWriter = writer.addClass(generatedTypeName.simpleName());
-    ConstructorWriter constructorWriter = factoryWriter.addConstructor();
-    constructorWriter.addModifiers(PUBLIC);
+    TypeSpec.Builder factoryBuilder =
+        classBuilder(generatedTypeName.simpleName())
+            .addModifiers(PUBLIC, FINAL)
+            .superclass(abstractProducerOf(providedTypeName));
 
     ImmutableMap<BindingKey, FrameworkField> fields =
         SourceFiles.generateBindingFieldsForDependencies(dependencyRequestMapper, binding);
 
-    constructorWriter
-        .body()
-        .addSnippet(
-            "super(%s, %s.create(%s.class));",
-            fields.get(binding.monitorRequest().get().bindingKey()).name(),
-            ClassName.fromClass(ProducerToken.class),
-            factoryWriter.name());
+    MethodSpec.Builder constructorBuilder =
+        constructorBuilder()
+            .addModifiers(PUBLIC)
+            .addStatement(
+                "super($L, $T.create($T.class))",
+                fields.get(binding.monitorRequest().get().bindingKey()).name(),
+                PRODUCER_TOKEN,
+                generatedTypeName);
 
     if (!binding.bindingElement().getModifiers().contains(STATIC)) {
-      factoryWriter.addField(binding.bindingTypeElement(), "module")
-          .addModifiers(PRIVATE, FINAL);
-      constructorWriter.addParameter(binding.bindingTypeElement(), "module");
-      constructorWriter.body()
-          .addSnippet("assert module != null;")
-          .addSnippet("this.module = module;");
+      TypeName moduleType = TypeName.get(binding.bindingTypeElement().asType());
+      addFieldAndConstructorParameter(
+          factoryBuilder, constructorBuilder, "module", moduleType);
     }
 
-    factoryWriter.addField(Executor.class, "executor")
-        .addModifiers(PRIVATE, FINAL);
-    constructorWriter.addParameter(Executor.class, "executor");
-    constructorWriter.body()
-        .addSnippet("assert executor != null;")
-        .addSnippet("this.executor = executor;");
-
-    factoryWriter.addModifiers(PUBLIC);
-    factoryWriter.addModifiers(FINAL);
-    factoryWriter.setSuperclass(
-        ParameterizedTypeName.create(AbstractProducer.class, providedTypeName));
-
-    MethodWriter computeMethodWriter = factoryWriter.addMethod(futureTypeName, "compute");
-    computeMethodWriter.annotate(Override.class);
-    computeMethodWriter.addModifiers(PROTECTED);
-    computeMethodWriter.addParameter(ProducerMonitor.class, "monitor").addModifiers(FINAL);
+    addFieldAndConstructorParameter(factoryBuilder, constructorBuilder, "executor", EXECUTOR);
 
     for (FrameworkField bindingField : fields.values()) {
-      TypeName fieldType = bindingField.frameworkType();
-      FieldWriter field = factoryWriter.addField(fieldType, bindingField.name());
-      field.addModifiers(PRIVATE, FINAL);
-      constructorWriter.addParameter(field.type(), field.name());
-      constructorWriter.body()
-          .addSnippet("assert %s != null;", field.name())
-          .addSnippet("this.%1$s = %1$s;", field.name());
+      TypeName fieldType = bindingField.javapoetFrameworkType();
+      addFieldAndConstructorParameter(
+          factoryBuilder, constructorBuilder, bindingField.name(), fieldType);
     }
 
     boolean returnsFuture =
@@ -166,58 +142,69 @@ public boolean apply(DependencyRequest dependency) {
                 })
             .toList();
 
+    MethodSpec.Builder computeMethodBuilder =
+        methodBuilder("compute")
+            .returns(futureTypeName)
+            .addAnnotation(Override.class)
+            .addModifiers(PROTECTED)
+            .addParameter(ProducerMonitor.class, "monitor", FINAL);
+
     for (DependencyRequest dependency : asyncDependencies) {
-      ParameterizedTypeName futureType = ParameterizedTypeName.create(
-          ClassName.fromClass(ListenableFuture.class),
-          asyncDependencyType(dependency));
-      String name = fields.get(dependency.bindingKey()).name();
-      Snippet futureAccess = Snippet.format("%s.get()", name);
-      computeMethodWriter
-          .body()
-          .addSnippet(
-              "%s %s = %s;",
-              futureType,
-              dependencyFutureName(dependency),
-              dependency.kind().equals(DependencyRequest.Kind.PRODUCED)
-                  ? Snippet.format(
-                      "%s.createFutureProduced(%s)",
-                      ClassName.fromClass(Producers.class),
-                      futureAccess)
-                  : futureAccess);
+      TypeName futureType = listenableFutureOf(asyncDependencyType(dependency));
+      CodeBlock futureAccess =
+          CodeBlocks.format("$L.get()", fields.get(dependency.bindingKey()).name());
+      computeMethodBuilder.addStatement(
+          "$T $L = $L",
+          futureType,
+          dependencyFutureName(dependency),
+          dependency.kind().equals(DependencyRequest.Kind.PRODUCED)
+              ? CodeBlocks.format("$T.createFutureProduced($L)", PRODUCERS, futureAccess)
+              : futureAccess);
     }
-
     FutureTransform futureTransform = FutureTransform.create(fields, binding, asyncDependencies);
-    Snippet transformSnippet =
-        Snippet.format(
+    CodeBlock transformCodeBlock =
+        CodeBlocks.format(
             Joiner.on('\n')
                 .join(
-                    "new %1$s<%2$s, %3$s>() {",
-                    "  %4$s",
-                    "  @Override public %5$s apply(%2$s %6$s) %7$s {",
-                    "    %8$s",
+                    "new $1T<$2T, $3T>() {",
+                    "  $4L",
+                    "  @Override public $5T apply($2T $6L) $7L {",
+                    "    $8L",
                     "  }",
                     "}"),
-            ClassName.fromClass(AsyncFunction.class),
+            ASYNC_FUNCTION,
             futureTransform.applyArgType(),
             providedTypeName,
             futureTransform.hasUncheckedCast()
-                ? "@SuppressWarnings(\"unchecked\")  // safe by specification"
+                ? CodeBlocks.format("$L // safe by specification", SUPPRESS_WARNINGS_UNCHECKED)
                 : "",
             futureTypeName,
             futureTransform.applyArgName(),
             getThrowsClause(binding.thrownTypes()),
-            getInvocationSnippet(
-                !returnsFuture, binding, providedTypeName, futureTransform.parameterSnippets()));
-    computeMethodWriter
-        .body()
-        .addSnippet(
-            "return %s.transform(%s, %s, executor);",
-            ClassName.fromClass(Futures.class),
-            futureTransform.futureSnippet(),
-            transformSnippet);
+            getInvocationCodeBlock(
+                !returnsFuture, binding, providedTypeName, futureTransform.parameterCodeBlocks()));
+    computeMethodBuilder.addStatement(
+        "return $T.transform($L, $L, executor)",
+        FUTURES, futureTransform.futureCodeBlock(), transformCodeBlock);
+
+    factoryBuilder.addMethod(constructorBuilder.build());
+    factoryBuilder.addMethod(computeMethodBuilder.build());
 
     // TODO(gak): write a sensible toString
-    return ImmutableSet.of(writer);
+    return Optional.of(factoryBuilder);
+  }
+
+  // TODO(ronshapiro): consolidate versions of these
+  private static void addFieldAndConstructorParameter(
+      TypeSpec.Builder typeBuilder,
+      MethodSpec.Builder constructorBuilder,
+      String variableName,
+      TypeName variableType) {
+    typeBuilder.addField(variableType, variableName, PRIVATE, FINAL);
+    constructorBuilder
+        .addParameter(variableType, variableName)
+        .addStatement("assert $L != null", variableName)
+        .addStatement("this.$1L = $1L", variableName);
   }
 
   /** Returns a name of the variable representing this dependency's future. */
@@ -235,8 +222,8 @@ private static String dependencyFutureName(DependencyRequest dependency) {
       this.binding = binding;
     }
 
-    /** The snippet representing the future that should be transformed. */
-    abstract Snippet futureSnippet();
+    /** The code block representing the future that should be transformed. */
+    abstract CodeBlock futureCodeBlock();
 
     /** The type of the argument to the apply method. */
     abstract TypeName applyArgType();
@@ -244,8 +231,8 @@ private static String dependencyFutureName(DependencyRequest dependency) {
     /** The name of the argument to the apply method */
     abstract String applyArgName();
 
-    /** The snippets to be passed to the produces method itself. */
-    abstract ImmutableList<Snippet> parameterSnippets();
+    /** The code blocks to be passed to the produces method itself. */
+    abstract ImmutableList<CodeBlock> parameterCodeBlocks();
 
     /** Whether the transform method has an unchecked cast. */
     boolean hasUncheckedCast() {
@@ -274,16 +261,13 @@ static FutureTransform create(
     }
 
     @Override
-    Snippet futureSnippet() {
-      return Snippet.format(
-          "%s.<%s>immediateFuture(null)",
-          ClassName.fromClass(Futures.class),
-          ClassName.fromClass(Void.class));
+    CodeBlock futureCodeBlock() {
+      return CodeBlocks.format("$T.<$T>immediateFuture(null)", FUTURES, VOID_CLASS);
     }
 
     @Override
     TypeName applyArgType() {
-      return ClassName.fromClass(Void.class);
+      return VOID_CLASS;
     }
 
     @Override
@@ -292,15 +276,15 @@ String applyArgName() {
     }
 
     @Override
-    ImmutableList<Snippet> parameterSnippets() {
-      ImmutableList.Builder<Snippet> parameterSnippets = ImmutableList.builder();
+    ImmutableList<CodeBlock> parameterCodeBlocks() {
+      ImmutableList.Builder<CodeBlock> parameterCodeBlocks = ImmutableList.builder();
       for (DependencyRequest dependency : binding.dependencies()) {
-        parameterSnippets.add(
+        parameterCodeBlocks.add(
             frameworkTypeUsageStatement(
-                Snippet.format(
-                    "%s", fields.get(dependency.bindingKey()).name()), dependency.kind()));
+                CodeBlocks.format("$L", fields.get(dependency.bindingKey()).name()),
+                dependency.kind()));
       }
-      return parameterSnippets.build();
+      return parameterCodeBlocks.build();
     }
   }
 
@@ -316,8 +300,8 @@ String applyArgName() {
     }
 
     @Override
-    Snippet futureSnippet() {
-      return Snippet.format("%s", dependencyFutureName(asyncDependency));
+    CodeBlock futureCodeBlock() {
+      return CodeBlocks.format("$L", dependencyFutureName(asyncDependency));
     }
 
     @Override
@@ -331,21 +315,22 @@ String applyArgName() {
     }
 
     @Override
-    ImmutableList<Snippet> parameterSnippets() {
-      ImmutableList.Builder<Snippet> parameterSnippets = ImmutableList.builder();
+    ImmutableList<CodeBlock> parameterCodeBlocks() {
+      ImmutableList.Builder<CodeBlock> parameterCodeBlocks = ImmutableList.builder();
       for (DependencyRequest dependency : binding.dependencies()) {
         // We really want to compare instances here, because asyncDependency is an element in the
         // set binding.dependencies().
         if (dependency == asyncDependency) {
-          parameterSnippets.add(Snippet.format("%s", applyArgName()));
+          parameterCodeBlocks.add(CodeBlocks.format("$L", applyArgName()));
         } else {
-          parameterSnippets.add(
+          parameterCodeBlocks.add(
+              // TODO(ronshapiro) extract this into a method shared by FutureTransform subclasses
               frameworkTypeUsageStatement(
-                  Snippet.format(
-                      "%s", fields.get(dependency.bindingKey()).name()), dependency.kind()));
+                  CodeBlocks.format("$L", fields.get(dependency.bindingKey()).name()),
+                  dependency.kind()));
         }
       }
-      return parameterSnippets.build();
+      return parameterCodeBlocks.build();
     }
   }
 
@@ -361,26 +346,25 @@ String applyArgName() {
     }
 
     @Override
-    Snippet futureSnippet() {
-      return Snippet.format(
-          "%s.<%s>allAsList(%s)",
-          ClassName.fromClass(Futures.class),
-          ClassName.fromClass(Object.class),
-          makeParametersSnippet(
+    CodeBlock futureCodeBlock() {
+      return CodeBlocks.format(
+          "$T.<$T>allAsList($L)",
+          FUTURES,
+          OBJECT,
+          makeParametersCodeBlock(
               FluentIterable.from(asyncDependencies)
                   .transform(
-                      new Function<DependencyRequest, Snippet>() {
+                      new Function<DependencyRequest, CodeBlock>() {
                         @Override
-                        public Snippet apply(DependencyRequest dependency) {
-                          return Snippet.format("%s", dependencyFutureName(dependency));
+                        public CodeBlock apply(DependencyRequest dependency) {
+                          return CodeBlocks.format("$L", dependencyFutureName(dependency));
                         }
                       })));
     }
 
     @Override
     TypeName applyArgType() {
-      return ParameterizedTypeName.create(
-          ClassName.fromClass(List.class), ClassName.fromClass(Object.class));
+      return listOf(OBJECT);
     }
 
     @Override
@@ -389,8 +373,8 @@ String applyArgName() {
     }
 
     @Override
-    ImmutableList<Snippet> parameterSnippets() {
-      return getParameterSnippets(binding, fields, applyArgName());
+    ImmutableList<CodeBlock> parameterCodeBlocks() {
+      return getParameterCodeBlocks(binding, fields, applyArgName());
     }
 
     @Override
@@ -410,119 +394,113 @@ private static boolean isAsyncDependency(DependencyRequest dependency) {
   }
 
   private static TypeName asyncDependencyType(DependencyRequest dependency) {
-    TypeName keyName = TypeNames.forTypeMirror(dependency.key().type());
+    TypeName keyName = TypeName.get(dependency.key().type());
     switch (dependency.kind()) {
       case INSTANCE:
         return keyName;
       case PRODUCED:
-        return ParameterizedTypeName.create(ClassName.fromClass(Produced.class), keyName);
+        return producedOf(keyName);
       default:
         throw new AssertionError();
     }
   }
 
-  private static ImmutableList<Snippet> getParameterSnippets(
+  private static ImmutableList<CodeBlock> getParameterCodeBlocks(
       ProductionBinding binding,
       ImmutableMap<BindingKey, FrameworkField> fields,
       String listArgName) {
     int argIndex = 0;
-    ImmutableList.Builder<Snippet> snippets = ImmutableList.builder();
+    ImmutableList.Builder<CodeBlock> codeBlocks = ImmutableList.builder();
     for (DependencyRequest dependency : binding.dependencies()) {
       if (isAsyncDependency(dependency)) {
-        snippets.add(Snippet.format(
-            "(%s) %s.get(%s)",
+        codeBlocks.add(CodeBlocks.format(
+            "($T) $L.get($L)",
             asyncDependencyType(dependency),
             listArgName,
             argIndex));
         argIndex++;
       } else {
-        snippets.add(frameworkTypeUsageStatement(
-            Snippet.format("%s", fields.get(dependency.bindingKey()).name()), dependency.kind()));
+        codeBlocks.add(frameworkTypeUsageStatement(
+            CodeBlocks.format("$L", fields.get(dependency.bindingKey()).name()),
+            dependency.kind()));
       }
     }
-    return snippets.build();
+    return codeBlocks.build();
   }
 
   /**
-   * Creates a snippet for the invocation of the producer method from the module, which should be
+   * Creates a code block for the invocation of the producer method from the module, which should be
    * used entirely within a method body.
    *
    * @param wrapWithFuture If true, wraps the result of the call to the producer method
    *        in an immediate future.
-   * @param binding The binding to generate the invocation snippet for.
+   * @param binding The binding to generate the invocation code block for.
    * @param providedTypeName The type name that should be provided by this producer.
-   * @param parameterSnippets The snippets for all the parameters to the producer method.
+   * @param parameterCodeBlocks The code blocks for all the parameters to the producer method.
    */
-  private Snippet getInvocationSnippet(
+  private CodeBlock getInvocationCodeBlock(
       boolean wrapWithFuture,
       ProductionBinding binding,
       TypeName providedTypeName,
-      ImmutableList<Snippet> parameterSnippets) {
-     Snippet moduleSnippet = Snippet.format("%s.%s(%s)",
+      ImmutableList<CodeBlock> parameterCodeBlocks) {
+    CodeBlock moduleCodeBlock = CodeBlocks.format("$L.$L($L)",
         binding.bindingElement().getModifiers().contains(STATIC)
-            ? ClassName.fromTypeElement(binding.bindingTypeElement())
+            ? CodeBlocks.format("$T", ClassName.get(binding.bindingTypeElement()))
             : "module",
         binding.bindingElement().getSimpleName(),
-        makeParametersSnippet(parameterSnippets));
+        makeParametersCodeBlock(parameterCodeBlocks));
 
-    // NOTE(beder): We don't worry about catching exeptions from the monitor methods themselves
+    // NOTE(beder): We don't worry about catching exceptions from the monitor methods themselves
     // because we'll wrap all monitoring in non-throwing monitors before we pass them to the
     // factories.
-    ImmutableList.Builder<Snippet> snippets = ImmutableList.builder();
-    snippets.add(Snippet.format("monitor.methodStarting();"));
+    ImmutableList.Builder<CodeBlock> codeBlocks = ImmutableList.builder();
+    codeBlocks.add(CodeBlocks.format("monitor.methodStarting();"));
 
-    final Snippet valueSnippet;
+    final CodeBlock valueCodeBlock;
     if (binding.productionType().equals(Produces.Type.SET)) {
       if (binding.bindingKind().equals(ContributionBinding.Kind.FUTURE_PRODUCTION)) {
-        valueSnippet =
-            Snippet.format(
-                "%s.createFutureSingletonSet(%s)",
-                ClassName.fromClass(Producers.class),
-                moduleSnippet);
+        valueCodeBlock =
+            CodeBlocks.format("$T.createFutureSingletonSet($L)", PRODUCERS, moduleCodeBlock);
       } else {
-        valueSnippet =
-            Snippet.format("%s.of(%s)", ClassName.fromClass(ImmutableSet.class), moduleSnippet);
+        valueCodeBlock =
+            CodeBlocks.format("$T.of($L)", IMMUTABLE_SET, moduleCodeBlock);
       }
     } else {
-      valueSnippet = moduleSnippet;
+      valueCodeBlock = moduleCodeBlock;
     }
-    Snippet returnSnippet =
+    CodeBlock returnCodeBlock =
         wrapWithFuture
-            ? Snippet.format(
-                "%s.<%s>immediateFuture(%s)",
-                ClassName.fromClass(Futures.class),
+            ? CodeBlocks.format(
+                "$T.<$T>immediateFuture($L)",
+                FUTURES,
                 providedTypeName,
-                valueSnippet)
-            : valueSnippet;
-    return Snippet.format(
+                valueCodeBlock)
+            : valueCodeBlock;
+    return CodeBlocks.format(
         Joiner.on('\n')
             .join(
                 "monitor.methodStarting();",
                 "try {",
-                "  return %s;",
+                "  return $L;",
                 "} finally {",
                 "  monitor.methodFinished();",
                 "}"),
-        returnSnippet);
+        returnCodeBlock);
   }
 
   /**
-   * Creates a Snippet for the throws clause.
+   * Creates a CodeBlock for the throws clause.
    *
    * @param thrownTypes the list of thrown types.
    */
-  private Snippet getThrowsClause(List<? extends TypeMirror> thrownTypes) {
+  private CodeBlock getThrowsClause(List<? extends TypeMirror> thrownTypes) {
     if (thrownTypes.isEmpty()) {
-      return Snippet.format("");
+      return CodeBlocks.format("");
     }
-    return Snippet.format("throws %s ",
-        Snippet.makeParametersSnippet(FluentIterable
-            .from(thrownTypes)
-            .transform(new Function<TypeMirror, Snippet>() {
-              @Override public Snippet apply(TypeMirror thrownType) {
-                return Snippet.format("%s", TypeNames.forTypeMirror(thrownType));
-              }
-            })
-            .toList()));
+    return CodeBlocks.format(
+        "throws $L",
+        CodeBlocks.join(
+            FluentIterable.from(thrownTypes)
+                .transform(CodeBlocks.TYPE_MIRROR_TO_CODE_BLOCK), ", "));
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/TypeNames.java b/compiler/src/main/java/dagger/internal/codegen/TypeNames.java
index d51a78b09..80d83efba 100644
--- a/compiler/src/main/java/dagger/internal/codegen/TypeNames.java
+++ b/compiler/src/main/java/dagger/internal/codegen/TypeNames.java
@@ -15,14 +15,24 @@
  */
 package dagger.internal.codegen;
 
+import com.google.common.collect.ImmutableSet;
+import com.google.common.util.concurrent.AsyncFunction;
+import com.google.common.util.concurrent.Futures;
+import com.google.common.util.concurrent.ListenableFuture;
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.ParameterizedTypeName;
 import com.squareup.javapoet.TypeName;
 import dagger.MembersInjector;
 import dagger.internal.DoubleCheckLazy;
 import dagger.internal.Factory;
+import dagger.producers.Produced;
+import dagger.producers.internal.AbstractProducer;
+import dagger.producers.internal.Producers;
+import dagger.producers.monitoring.ProducerToken;
 import dagger.producers.monitoring.ProductionComponentMonitor;
+import java.util.List;
 import java.util.Set;
+import java.util.concurrent.Executor;
 import javax.inject.Provider;
 
 /**
@@ -30,13 +40,46 @@
  */
 final class TypeNames {
 
-  static final TypeName SET_OF_FACTORIES =
-      ParameterizedTypeName.get(
-          ClassName.get(Set.class), ClassName.get(ProductionComponentMonitor.Factory.class));
-  static final ClassName PROVIDER = ClassName.get(Provider.class);
+  static final ClassName ABSTRACT_PRODUCER = ClassName.get(AbstractProducer.class);
+  static final ClassName ASYNC_FUNCTION = ClassName.get(AsyncFunction.class);
   static final ClassName DOUBLE_CHECK_LAZY = ClassName.get(DoubleCheckLazy.class);
+  static final ClassName EXECUTOR = ClassName.get(Executor.class);
   static final ClassName FACTORY = ClassName.get(Factory.class);
+  static final ClassName FUTURES = ClassName.get(Futures.class);
+  static final ClassName IMMUTABLE_SET = ClassName.get(ImmutableSet.class);
+  static final ClassName LIST = ClassName.get(List.class);
+  static final ClassName LISTENABLE_FUTURE = ClassName.get(ListenableFuture.class);
   static final ClassName MEMBERS_INJECTOR = ClassName.get(MembersInjector.class);
+  static final ClassName PRODUCER_TOKEN = ClassName.get(ProducerToken.class);
+  static final ClassName PRODUCED = ClassName.get(Produced.class);
+  static final ClassName PRODUCERS = ClassName.get(Producers.class);
+  static final ClassName PROVIDER = ClassName.get(Provider.class);
+
+  /**
+   * {@link TypeName#VOID} is lowercase-v {@code void} whereas this represents the class, {@link
+   * Void}.
+   */
+  static final ClassName VOID_CLASS = ClassName.get(Void.class);
+
+  static final TypeName SET_OF_FACTORIES =
+      ParameterizedTypeName.get(
+          ClassName.get(Set.class), ClassName.get(ProductionComponentMonitor.Factory.class));
+
+  static ParameterizedTypeName listOf(TypeName typeName) {
+    return ParameterizedTypeName.get(LIST, typeName);
+  }
+
+  static ParameterizedTypeName abstractProducerOf(TypeName typeName) {
+    return ParameterizedTypeName.get(ABSTRACT_PRODUCER, typeName);
+  }
+
+  static ParameterizedTypeName producedOf(TypeName typeName) {
+    return ParameterizedTypeName.get(PRODUCED, typeName);
+  }
+
+  static ParameterizedTypeName listenableFutureOf(TypeName typeName) {
+    return ParameterizedTypeName.get(LISTENABLE_FUTURE, typeName);
+  }
 
   static ParameterizedTypeName providerOf(TypeName typeName) {
     return ParameterizedTypeName.get(PROVIDER, typeName);
diff --git a/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java b/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
index dd9e53863..87984c8bd 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
@@ -38,7 +38,7 @@
 import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_SET_VALUES_RETURN_SET;
 import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_THROWS;
 import static dagger.internal.codegen.ErrorMessages.PROVIDES_OR_PRODUCES_METHOD_MULTIPLE_QUALIFIERS;
-import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
+import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION_JAVAPOET;
 
 @RunWith(JUnit4.class)
 public class ProducerModuleFactoryGeneratorTest {
@@ -510,7 +510,7 @@ public void publicModuleNonPublicIncludes() {
             "import javax.annotation.Generated;",
             "import javax.inject.Provider;",
             "",
-            GENERATED_ANNOTATION,
+            GENERATED_ANNOTATION_JAVAPOET,
             "public final class TestModule_ProduceStringFactory extends AbstractProducer<String> {",
             "  private final TestModule module;",
             "  private final Executor executor;",
