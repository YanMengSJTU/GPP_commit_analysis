diff --git a/compiler/src/it/functional-tests/src/main/java/test/BasicComponent.java b/compiler/src/it/functional-tests/src/main/java/test/BasicComponent.java
new file mode 100644
index 000000000..cd9dbdbf1
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/BasicComponent.java
@@ -0,0 +1,53 @@
+/*
+* Copyright (C) 2014 Google, Inc.
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package test;
+
+import dagger.Component;
+
+@Component(modules = PrimitivesModule.class)
+interface BasicComponent {
+  byte getByte();
+  char getChar();
+  short getShort();
+  int getInt();
+  long getLong();
+  boolean getBoolean();
+  float getFloat();
+  double getDouble();
+
+  Byte getBoxedByte();
+  Character getBoxedChar();
+  Short getBoxedShort();
+  Integer getBoxedInt();
+  Long getBoxedLong();
+  Boolean getBoxedBoolean();
+  Float getBoxedFloat();
+  Double getBoxedDouble();
+
+  byte[] getByteArray();
+  char[] getCharArray();
+  short[] getShortArray();
+  int[] getIntArray();
+  long[] getLongArray();
+  boolean[] getBooleanArray();
+  float[] getFloatArray();
+  double[] getDoubleArray();
+
+  Object noOpMembersInjection(Object obviouslyDoesNotHaveMembersToInject);
+
+  Thing thing();
+  TypeWithInheritedMembersInjection typeWithInheritedMembersInjection();
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/PrimitivesModule.java b/compiler/src/it/functional-tests/src/main/java/test/PrimitivesModule.java
new file mode 100644
index 000000000..907287dd3
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/PrimitivesModule.java
@@ -0,0 +1,93 @@
+package test;
+
+import dagger.Module;
+import dagger.Provides;
+
+@Module
+final class PrimitivesModule {
+  static final byte BOUND_BYTE = -41;
+  static final char BOUND_CHAR = 'g';
+  static final short BOUND_SHORT = 21840;
+  static final int BOUND_INT = 1894833693;
+  static final long BOUND_LONG = -4369839828653523584L;
+  static final boolean BOUND_BOOLEAN = true;
+  static final float BOUND_FLOAT = (float) 0.9964542;
+  static final double BOUND_DOUBLE = 0.12681322049667765;
+
+  /*
+   * While we can't ensure that these constants stay constant, this is a test so we're just going to
+   * keep our fingers crossed that we're not going to be jerks.
+   */
+  static final byte[] BOUND_BYTE_ARRAY =  {1, 2, 3};
+  static final char[] BOUND_CHAR_ARRAY = {'g', 'a', 'k'};
+  static final short[] BOUND_SHORT_ARRAY = {2, 4};
+  static final int[] BOUND_INT_ARRAY = {3, 1, 2};
+  static final long[] BOUND_LONG_ARRAY = {1, 1, 2, 3, 5};
+  static final boolean[] BOUND_BOOLEAN_ARRAY = {false, true, false, false};
+  static final float[] BOUND_FLOAT_ARRAY = {(float) 0.1, (float) 0.01, (float) 0.001};
+  static final double[] BOUND_DOUBLE_ARRAY = {0.2, 0.02, 0.002};
+
+  @Provides byte provideByte() {
+    return BOUND_BYTE;
+  }
+
+  @Provides char provideChar() {
+    return BOUND_CHAR;
+  }
+
+  @Provides short provideShort() {
+    return BOUND_SHORT;
+  }
+
+  @Provides int provideInt() {
+    return BOUND_INT;
+  }
+
+  @Provides long provideLong() {
+    return BOUND_LONG;
+  }
+
+  @Provides boolean provideBoolean() {
+    return BOUND_BOOLEAN;
+  }
+
+  @Provides float provideFloat() {
+    return BOUND_FLOAT;
+  }
+
+  @Provides double boundDouble() {
+    return BOUND_DOUBLE;
+  }
+
+  @Provides byte[] provideByteArray() {
+    return BOUND_BYTE_ARRAY;
+  }
+
+  @Provides char[] provideCharArray() {
+    return BOUND_CHAR_ARRAY;
+  }
+
+  @Provides short[] provideShortArray() {
+    return BOUND_SHORT_ARRAY;
+  }
+
+  @Provides int[] provideIntArray() {
+    return BOUND_INT_ARRAY;
+  }
+
+  @Provides long[] provideLongArray() {
+    return BOUND_LONG_ARRAY;
+  }
+
+  @Provides boolean[] provideBooleanArray() {
+    return BOUND_BOOLEAN_ARRAY;
+  }
+
+  @Provides float[] provideFloatArray() {
+    return BOUND_FLOAT_ARRAY;
+  }
+
+  @Provides double[] boundDoubleArray() {
+    return BOUND_DOUBLE_ARRAY;
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/ThingComponent.java b/compiler/src/it/functional-tests/src/main/java/test/ThingComponent.java
deleted file mode 100644
index 0b16afc04..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/ThingComponent.java
+++ /dev/null
@@ -1,24 +0,0 @@
-/*
-* Copyright (C) 2014 Google, Inc.
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
-*
-* http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS,
-* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-* See the License for the specific language governing permissions and
-* limitations under the License.
-*/
-package test;
-
-import dagger.Component;
-
-@Component
-interface ThingComponent {
-  Thing thing();
-  TypeWithInheritedMembersInjection typeWithInheritedMembersInjection();
-}
diff --git a/compiler/src/it/functional-tests/src/test/java/test/BasicTest.java b/compiler/src/it/functional-tests/src/test/java/test/BasicTest.java
new file mode 100644
index 000000000..45dd924ae
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/test/java/test/BasicTest.java
@@ -0,0 +1,93 @@
+/*
+* Copyright (C) 2014 Google, Inc.
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package test;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assertThat;
+import static test.PrimitivesModule.BOUND_BOOLEAN;
+import static test.PrimitivesModule.BOUND_BOOLEAN_ARRAY;
+import static test.PrimitivesModule.BOUND_BYTE;
+import static test.PrimitivesModule.BOUND_BYTE_ARRAY;
+import static test.PrimitivesModule.BOUND_CHAR;
+import static test.PrimitivesModule.BOUND_CHAR_ARRAY;
+import static test.PrimitivesModule.BOUND_DOUBLE;
+import static test.PrimitivesModule.BOUND_DOUBLE_ARRAY;
+import static test.PrimitivesModule.BOUND_FLOAT;
+import static test.PrimitivesModule.BOUND_FLOAT_ARRAY;
+import static test.PrimitivesModule.BOUND_INT;
+import static test.PrimitivesModule.BOUND_INT_ARRAY;
+import static test.PrimitivesModule.BOUND_LONG;
+import static test.PrimitivesModule.BOUND_LONG_ARRAY;
+import static test.PrimitivesModule.BOUND_SHORT;
+import static test.PrimitivesModule.BOUND_SHORT_ARRAY;
+
+@RunWith(JUnit4.class)
+public class BasicTest {
+  @Test public void primitives() {
+    BasicComponent basicComponent = Dagger_BasicComponent.create();
+    assertThat(basicComponent.getByte()).isEqualTo(BOUND_BYTE);
+    assertThat(basicComponent.getChar()).isEqualTo(BOUND_CHAR);
+    assertThat(basicComponent.getShort()).isEqualTo(BOUND_SHORT);
+    assertThat(basicComponent.getInt()).isEqualTo(BOUND_INT);
+    assertThat(basicComponent.getLong()).isEqualTo(BOUND_LONG);
+    assertThat(basicComponent.getBoolean()).isEqualTo(BOUND_BOOLEAN);
+    assertThat(basicComponent.getFloat()).isEqualTo(BOUND_FLOAT);
+    assertThat(basicComponent.getDouble()).isEqualTo(BOUND_DOUBLE);
+  }
+
+  @Test public void boxedPrimitives() {
+    BasicComponent basicComponent = Dagger_BasicComponent.create();
+    assertThat(basicComponent.getBoxedByte()).isEqualTo(new Byte(BOUND_BYTE));
+    assertThat(basicComponent.getBoxedChar()).isEqualTo(new Character(BOUND_CHAR));
+    assertThat(basicComponent.getBoxedShort()).isEqualTo(new Short(BOUND_SHORT));
+    assertThat(basicComponent.getBoxedInt()).isEqualTo(new Integer(BOUND_INT));
+    assertThat(basicComponent.getBoxedLong()).isEqualTo(new Long(BOUND_LONG));
+    assertThat(basicComponent.getBoxedBoolean()).isEqualTo(new Boolean(BOUND_BOOLEAN));
+    assertThat(basicComponent.getBoxedFloat()).isEqualTo(new Float(BOUND_FLOAT));
+    assertThat(basicComponent.getBoxedDouble()).isEqualTo(new Double(BOUND_DOUBLE));
+  }
+
+  @Test public void primitiveArrays() {
+    BasicComponent basicComponent = Dagger_BasicComponent.create();
+    assertThat(basicComponent.getByteArray()).isSameAs(BOUND_BYTE_ARRAY);
+    assertThat(basicComponent.getCharArray()).isSameAs(BOUND_CHAR_ARRAY);
+    assertThat(basicComponent.getShortArray()).isSameAs(BOUND_SHORT_ARRAY);
+    assertThat(basicComponent.getIntArray()).isSameAs(BOUND_INT_ARRAY);
+    assertThat(basicComponent.getLongArray()).isSameAs(BOUND_LONG_ARRAY);
+    assertThat(basicComponent.getBooleanArray()).isSameAs(BOUND_BOOLEAN_ARRAY);
+    assertThat(basicComponent.getFloatArray()).isSameAs(BOUND_FLOAT_ARRAY);
+    assertThat(basicComponent.getDoubleArray()).isSameAs(BOUND_DOUBLE_ARRAY);
+  }
+
+  @Test public void noOpMembersInjection() {
+    BasicComponent basicComponent = Dagger_BasicComponent.create();
+    Object object = new Object();
+    assertThat(basicComponent.noOpMembersInjection(object)).isSameAs(object);
+  }
+
+  @Test public void basicObject_noDeps() {
+    BasicComponent basicComponent = Dagger_BasicComponent.create();
+    assertThat(basicComponent.thing()).isNotNull();
+  }
+
+  @Test public void inheritedMembersInjection() {
+    BasicComponent basicComponent = Dagger_BasicComponent.create();
+    assertThat(basicComponent.typeWithInheritedMembersInjection().thing).isNotNull();
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/test/java/test/SimpleTest.java b/compiler/src/it/functional-tests/src/test/java/test/SimpleTest.java
deleted file mode 100644
index 799b14993..000000000
--- a/compiler/src/it/functional-tests/src/test/java/test/SimpleTest.java
+++ /dev/null
@@ -1,36 +0,0 @@
-/*
-* Copyright (C) 2014 Google, Inc.
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
-*
-* http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS,
-* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-* See the License for the specific language governing permissions and
-* limitations under the License.
-*/
-package test;
-
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-import static com.google.common.truth.Truth.assertThat;
-
-@RunWith(JUnit4.class)
-public class SimpleTest {
-  @Test public void testAThing() {
-    ThingComponent thingComponent = Dagger_ThingComponent.create();
-    assertThat(thingComponent).isNotNull();
-    assertThat(thingComponent.thing()).isNotNull();
-  }
-
-  @Test public void inheritedMembersInjection() {
-    ThingComponent thingComponent = Dagger_ThingComponent.create();
-    assertThat(thingComponent.typeWithInheritedMembersInjection().thing).isNotNull();
-  }
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
index efe7e39eb..c44e4f69b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
@@ -153,13 +153,26 @@ static ProxyClassAndField create(ClassWriter proxyWriter, FieldWriter proxyField
 
   @AutoValue static abstract class MemberSelect {
     static MemberSelect instanceSelect(ClassName owningClass, Snippet snippet) {
-      return new AutoValue_ComponentGenerator_MemberSelect(owningClass, false, snippet);
+      return new AutoValue_ComponentGenerator_MemberSelect(
+          Optional.<TypeName> absent(), owningClass, false, snippet);
     }
 
     static MemberSelect staticSelect(ClassName owningClass, Snippet snippet) {
-      return new AutoValue_ComponentGenerator_MemberSelect(owningClass, true, snippet);
+      return new AutoValue_ComponentGenerator_MemberSelect(
+          Optional.<TypeName> absent(), owningClass, true, snippet);
     }
 
+    static MemberSelect staticMethodInvocationWithCast(
+        ClassName owningClass, Snippet snippet, TypeName castType) {
+      return new AutoValue_ComponentGenerator_MemberSelect(
+          Optional.of(castType), owningClass, true, snippet);
+    }
+
+    /**
+     * This exists only to facilitate edge cases in which we need to select a member, but that
+     * member uses a type parameter that can't be inferred.
+     */
+    abstract Optional<TypeName> selectedCast();
     abstract ClassName owningClass();
     abstract boolean staticMember();
     abstract Snippet snippet();
@@ -170,6 +183,13 @@ private Snippet qualifiedSelectSnippet() {
           owningClass(), snippet());
     }
 
+    Snippet getSnippetWithRawTypeCastFor(ClassName usingClass) {
+      Snippet snippet = getSnippetFor(usingClass);
+      return selectedCast().isPresent()
+          ? Snippet.format("(%s) %s", selectedCast().get(), snippet)
+          : snippet;
+    }
+
     Snippet getSnippetFor(ClassName usingClass) {
       return owningClass().equals(usingClass)
           ? snippet()
@@ -479,12 +499,14 @@ private void writeFields(BindingGraph input,
           MembersInjectionBinding membersInjectionBinding =
               Iterables.getOnlyElement(resolvedBindings.membersInjectionBindings());
           if (membersInjectionBinding.injectionStrategy().equals(NO_OP)) {
-            // TODO(gak): refactory to use enumBindingKeys throughout the generator
+            // TODO(gak): refactor to use enumBindingKeys throughout the generator
             enumBindingKeysBuilder.add(bindingKey);
+            // TODO(gak): suppress the warnings in a reasonable place
             memberSelectSnippetsBuilder.put(bindingKey,
-                MemberSelect.staticSelect(
+                MemberSelect.staticMethodInvocationWithCast(
                     ClassName.fromClass(MembersInjectors.class),
-                    Snippet.format("noOp()")));
+                    Snippet.format("noOp()"),
+                    ClassName.fromClass(MembersInjector.class)));
             continue;
           }
         }
@@ -604,7 +626,10 @@ private void writeInterfaceMethods(BindingGraph input, ClassWriter componentWrit
                 TypeNames.forTypeMirror(parameter.asType()), parameterName.toString());
             interfaceMethod.body()
                 .addSnippet("%s.injectMembers(%s);",
-                    membersInjectorSelect.getSnippetFor(componentWriter.name()), parameterName);
+                    // in this case we know we won't need the cast because we're never going to pass
+                    // the reference to anything
+                    membersInjectorSelect.getSnippetFor(componentWriter.name()),
+                    parameterName);
             if (!requestElement.getReturnType().getKind().equals(VOID)) {
               interfaceMethod.body().addSnippet("return %s;", parameterName);
             }
@@ -765,8 +790,7 @@ private void initializeFrameworkTypes(BindingGraph input,
           case MEMBERS_INJECTION:
             MembersInjectionBinding binding = Iterables.getOnlyElement(
                 input.resolvedBindings().get(bindingKey).membersInjectionBindings());
-            if (!binding.injectionSites().isEmpty()
-                || binding.parentInjectorRequest().isPresent()) {
+            if (!binding.injectionStrategy().equals(MembersInjectionBinding.Strategy.NO_OP)) {
               initializeMethod.body().addSnippet("this.%s = %s;",
                   memberSelectSnippet,
                   initializeMembersInjectorForBinding(
@@ -946,22 +970,17 @@ private Snippet initializeFactoryForProvisionBinding(ProvisionBinding binding,
           parameters.add(contributionFields.get(binding.contributedBy().get())
               .getSnippetFor(componentName));
         }
-        if (binding.memberInjectionRequest().isPresent()) {
-          parameters.add(memberSelectSnippets.get(
-              BindingKey.forDependencyRequest(binding.memberInjectionRequest().get()))
-                  .getSnippetFor(componentName));
-        }
-        parameters.addAll(getDependencyParameters(componentName, binding.dependencies(),
+        parameters.addAll(getDependencyParameters(componentName, binding.implicitDependencies(),
             memberSelectSnippets));
 
+        Snippet factorySnippet = Snippet.format("%s.create(%s)",
+            factoryNameForProvisionBinding(binding),
+            Snippet.makeParametersSnippet(parameters));
         return binding.scope().isPresent()
-            ? Snippet.format("%s.create(%s.create(%s))",
+            ? Snippet.format("%s.create(%s)",
                 ClassName.fromClass(ScopedProvider.class),
-                factoryNameForProvisionBinding(binding),
-                Snippet.makeParametersSnippet(parameters))
-            : Snippet.format("%s.create(%s)",
-                factoryNameForProvisionBinding(binding),
-                Snippet.makeParametersSnippet(parameters));
+                factorySnippet)
+            : factorySnippet;
       default:
         throw new AssertionError();
     }
@@ -1024,7 +1043,7 @@ private static Snippet initializeMembersInjectorForBinding(
       case INJECT_MEMBERS:
         List<Snippet> parameters = getDependencyParameters(
             componentName,
-            Sets.union(binding.parentInjectorRequest().asSet(), binding.dependencies()),
+            binding.implicitDependencies(),
             memberSelectSnippets);
         return Snippet.format("%s.create(%s)",
             membersInjectorNameForMembersInjectionBinding(binding),
@@ -1048,7 +1067,7 @@ private static Snippet initializeMembersInjectorForBinding(
             }
           })
           .toSet());
-      parameters.add(memberSelectSnippets.get(key).getSnippetFor(componentName));
+      parameters.add(memberSelectSnippets.get(key).getSnippetWithRawTypeCastFor(componentName));
     }
     return parameters.build();
   }
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
index ff432603c..4f48d8d59 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
@@ -234,8 +234,8 @@ MembersInjectionBinding forInjectedType(DeclaredType type, Optional<TypeMirror>
           key,
           dependencies,
           new ImmutableSet.Builder<DependencyRequest>()
-              .addAll(dependencies)
               .addAll(parentInjectorRequest.asSet())
+              .addAll(dependencies)
               .build(),
           findBindingPackage(key),
           hasNonDefaultTypeParameters(typeElement, key.type(), types),
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
index f63eb1422..ba5aaed38 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
@@ -23,10 +23,7 @@
 import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Sets;
-import dagger.Component;
 import dagger.Provides;
-import dagger.Subcomponent;
-import dagger.producers.ProductionComponent;
 import javax.inject.Inject;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
@@ -65,8 +62,8 @@
   @Override
   ImmutableSet<DependencyRequest> implicitDependencies() {
     return new ImmutableSet.Builder<DependencyRequest>()
-        .addAll(dependencies())
         .addAll(memberInjectionRequest().asSet())
+        .addAll(dependencies())
         .build();
   }
 
@@ -194,7 +191,7 @@ ProvisionBinding forInjectConstructor(ExecutableElement constructorElement,
           membersInjectionRequest(enclosingCxtorType);
       Optional<AnnotationMirror> scope =
           getScopeAnnotation(constructorElement.getEnclosingElement());
-      
+
       TypeElement bindingTypeElement =
           MoreElements.asType(constructorElement.getEnclosingElement());
 
diff --git a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
index 2a1c020cf..b2fae4a13 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
@@ -33,7 +33,7 @@
 public class ComponentProcessorTest {
   private static final StringLiteral NPE_LITERAL =
       StringLiteral.forValue(ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD);
-  
+
   @Test public void componentOnConcreteClass() {
     JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.NotAComponent",
         "package test;",
@@ -1115,6 +1115,7 @@
         "test.Dagger_SimpleComponent",
         "package test;",
         "",
+        "import dagger.MembersInjector;",
         "import dagger.internal.MembersInjectors;",
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
@@ -1138,7 +1139,7 @@
         "",
         "  private void initialize() {",
         "    this.someInjectableTypeProvider =",
-        "        SomeInjectableType$$Factory.create(MembersInjectors.noOp());",
+        "        SomeInjectableType$$Factory.create((MembersInjector) MembersInjectors.noOp());",
         "  }",
         "",
         "  @Override",
@@ -1736,7 +1737,7 @@
         .withErrorContaining(
             "test.B<? extends test.A> cannot be provided without an @Provides-annotated method");
   }
- 
+
   @Test
   @Ignore // modify this test as necessary while debugging for your situation.
   @SuppressWarnings("unused")
diff --git a/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java b/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
index 7a67567e9..19b9c9419 100644
--- a/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
@@ -34,7 +34,7 @@
   private final JavaFileObject NULLABLE = JavaFileObjects.forSourceLines("test.Nullable",
       "package test;",
       "public @interface Nullable {}");
-  
+
   @Test public void componentOnConcreteClass() {
     JavaFileObject component = JavaFileObjects.forSourceLines("test.MyComponent",
         "package test;",
@@ -547,8 +547,8 @@
         + "          [parameter: test.TestClass.DImpl impl]\n"
         + "      test.TestClass.DImpl.<init>(test.TestClass.C c, test.TestClass.B b)\n"
         + "          [parameter: test.TestClass.C c]\n"
-        + "      test.TestClass.C.<init>(test.TestClass.B b)\n"
-        + "          [parameter: test.TestClass.B b]\n"
+        + "      test.TestClass.C.b\n"
+        + "          [injected field of type: test.TestClass.B b]\n"
         + "      test.TestClass.B.<init>(test.TestClass.A a)\n"
         + "          [parameter: test.TestClass.A a]";
     String secondError = errorText
@@ -562,7 +562,7 @@
         .withErrorContaining(firstError).in(component).onLine(33)
         .and().withErrorContaining(secondError).in(component).onLine(34);
   }
-  
+
   @Test public void resolvedParametersInDependencyTrace() {
     JavaFileObject generic = JavaFileObjects.forSourceLines("test.Generic",
         "package test;",
@@ -601,18 +601,18 @@
         "}");
     String expectedMsg = Joiner.on("\n").join(
         "java.util.List cannot be provided without an @Provides-annotated method.",
-        "      test.UsesTest.<init>(test.Generic<test.TestClass> genericTestClass)", 
-        "          [parameter: test.Generic<test.TestClass> genericTestClass]", 
-        "      test.Generic.<init>(test.TestClass t)", 
-        "          [parameter: test.TestClass t]", 
-        "      test.TestClass.<init>(java.util.List list)", 
+        "      test.UsesTest.<init>(test.Generic<test.TestClass> genericTestClass)",
+        "          [parameter: test.Generic<test.TestClass> genericTestClass]",
+        "      test.Generic.<init>(test.TestClass t)",
+        "          [parameter: test.TestClass t]",
+        "      test.TestClass.<init>(java.util.List list)",
         "          [parameter: java.util.List list]");
     assertAbout(javaSources()).that(ImmutableList.of(generic, testClass, usesTest, component))
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(expectedMsg);
   }
-  
+
   @Test public void resolvedVariablesInDependencyTrace() {
     JavaFileObject generic = JavaFileObjects.forSourceLines("test.Generic",
         "package test;",
@@ -652,18 +652,18 @@
         "}");
     String expectedMsg = Joiner.on("\n").join(
         "java.util.List cannot be provided without an @Provides-annotated method.",
-        "      test.UsesTest.<init>(test.Generic<test.TestClass> genericTestClass)", 
-        "          [parameter: test.Generic<test.TestClass> genericTestClass]", 
+        "      test.UsesTest.<init>(test.Generic<test.TestClass> genericTestClass)",
+        "          [parameter: test.Generic<test.TestClass> genericTestClass]",
         "      test.Generic.t",
-        "          [injected field of type: test.TestClass t]", 
-        "      test.TestClass.<init>(java.util.List list)", 
+        "          [injected field of type: test.TestClass t]",
+        "      test.TestClass.<init>(java.util.List list)",
         "          [parameter: java.util.List list]");
     assertAbout(javaSources()).that(ImmutableList.of(generic, testClass, usesTest, component))
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(expectedMsg);
   }
-  
+
   @Test public void nullCheckForConstructorParameters() {
     JavaFileObject a = JavaFileObjects.forSourceLines("test.A",
         "package test;",
diff --git a/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java b/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java
index cb8a8adf1..19a2c29d0 100644
--- a/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java
@@ -57,6 +57,7 @@ public void parentClass_noInjectedMembers() {
         "test.Dagger_TestComponent",
         "package test;",
         "",
+        "import dagger.MembersInjector;",
         "import dagger.internal.MembersInjectors;",
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
@@ -79,7 +80,8 @@ public void parentClass_noInjectedMembers() {
         "  }",
         "",
         "  private void initialize() {",
-        "    this.childProvider = Child$$Factory.create(MembersInjectors.noOp());",
+        "    this.childProvider =",
+        "        Child$$Factory.create((MembersInjector) MembersInjectors.noOp());",
         "  }",
         "",
         "  @Override",
