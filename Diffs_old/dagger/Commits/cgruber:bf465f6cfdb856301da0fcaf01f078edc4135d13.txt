diff --git a/compiler/pom.xml b/compiler/pom.xml
index 8c674618d..59c213953 100644
--- a/compiler/pom.xml
+++ b/compiler/pom.xml
@@ -36,6 +36,11 @@
       <artifactId>dagger</artifactId>
       <version>${project.version}</version>
     </dependency>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>dagger-producers</artifactId>
+      <version>${project.version}</version>
+    </dependency>
     <dependency>
       <groupId>com.google.auto</groupId>
       <artifactId>auto-common</artifactId>
diff --git a/core/pom.xml b/core/pom.xml
index 3551075be..73da51c47 100644
--- a/core/pom.xml
+++ b/core/pom.xml
@@ -26,6 +26,11 @@
   <artifactId>dagger</artifactId>
   <name>Dagger</name>
 
+  <properties>
+    <!-- Runtime must remain Java6 to support android. -->
+    <java.version>1.6</java.version>
+  </properties>
+
   <dependencies>
     <dependency>
       <groupId>javax.inject</groupId>
@@ -64,7 +69,7 @@
         <configuration>
           <signature>
             <groupId>org.codehaus.mojo.signature</groupId>
-            <artifactId>java15</artifactId>
+            <artifactId>java16</artifactId>
             <version>1.0</version>
           </signature>
         </configuration>
diff --git a/pom.xml b/pom.xml
index 81ea56864..2d00eb0f5 100644
--- a/pom.xml
+++ b/pom.xml
@@ -34,13 +34,15 @@
   <modules>
     <module>compiler</module>
     <module>core</module>
+    <module>examples</module>
+    <module>producers</module>
   </modules>
 
   <properties>
     <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
 
     <!-- Compilation -->
-    <java.version>1.6</java.version>
+    <java.version>1.7</java.version>
     <javax.inject.version>1</javax.inject.version>
     <javawriter.version>2.5.0</javawriter.version>
     <auto.common.version>1.0-SNAPSHOT</auto.common.version>
diff --git a/producers/pom.xml b/producers/pom.xml
new file mode 100644
index 000000000..1dda109a7
--- /dev/null
+++ b/producers/pom.xml
@@ -0,0 +1,53 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+ Copyright (C) 2014 Google, Inc.
+
+  Licensed under the Apache License, Version 2.0 (the "License");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>com.google.dagger</groupId>
+    <artifactId>dagger-parent</artifactId>
+    <version>2.0-SNAPSHOT</version>
+  </parent>
+
+  <artifactId>dagger-producers</artifactId>
+  <name>Dagger Production Graphs</name>
+  <description>
+    An asynchronous dependency injection system that extends JSR-330.
+  </description>
+
+  <dependencies>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>dagger</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>com.google.guava</groupId>
+      <artifactId>guava</artifactId>
+    </dependency>
+    <dependency>
+      <groupId>junit</groupId>
+      <artifactId>junit</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>com.google.truth</groupId>
+      <artifactId>truth</artifactId>
+      <scope>test</scope>
+    </dependency>
+  </dependencies>
+</project>
diff --git a/producers/src/main/java/dagger/producers/Produced.java b/producers/src/main/java/dagger/producers/Produced.java
new file mode 100644
index 000000000..137244bad
--- /dev/null
+++ b/producers/src/main/java/dagger/producers/Produced.java
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2014 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.producers;
+
+import java.util.concurrent.ExecutionException;
+
+/**
+ * An interface that represents the result of a {@linkplain Producer production} of type {@code T},
+ * or an exception that was thrown during that production. For any type {@code T} that can be
+ * injected, you can also inject {@code Produced<T>}, which enables handling of any exceptions that
+ * were thrown during the production of {@code T}.
+ *
+ * <p>For example: <pre>   {@code
+ *
+ *   @Produces Html getResponse(UserInfo criticalInfo, Produced<ExtraInfo> noncriticalInfo) {
+ *     try {
+ *       return new Html(criticalInfo, noncriticalInfo.get());
+ *     } catch (ExecutionException e) {
+ *       logger.warning(e, "Noncritical info");
+ *       return new Html(criticalInfo);
+ *     }
+ *   }}</pre>
+ *
+ * @author Jesse Beder
+ */
+public interface Produced<T> {
+  /**
+   * Returns the result of a production.
+   *
+   * @throws ExecutionException if the production threw an exception
+   */
+  T get() throws ExecutionException;
+}
diff --git a/producers/src/main/java/dagger/producers/Producer.java b/producers/src/main/java/dagger/producers/Producer.java
new file mode 100644
index 000000000..cccf78376
--- /dev/null
+++ b/producers/src/main/java/dagger/producers/Producer.java
@@ -0,0 +1,100 @@
+/*
+ * Copyright (C) 2014 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.producers;
+
+import com.google.common.util.concurrent.ListenableFuture;
+
+/**
+ * An interface that represents the production of a type {@code T}. You can also inject
+ * {@code Producer<T>} instead of {@code T}, which will delay the execution of any code that
+ * produces the {@code T} until {@link #get} is called.
+ *
+ * <p>For example, you might inject {@code Producer} to lazily choose between several different
+ * implementations of some type: <pre>   {@code
+ *
+ *   @Produces ListenableFuture<Heater> getHeater(
+ *       HeaterFlag flag,
+ *       @Electric Producer<Heater> electricHeater,
+ *       @Gas Producer<Heater> gasHeater) {
+ *     return flag.useElectricHeater() ? electricHeater.get() : gasHeater.get();
+ *   }}</pre>
+ *
+ * <p>Here is a complete example that demonstrates how calling {@code get()} will cause each
+ * method to be executed: <pre>   {@code
+ *
+ *   @ProducerModule
+ *   final class MyModule {
+ *     @Produces ListenableFuture<A> a() {
+ *       System.out.println("a");
+ *       return Futures.immediateFuture(new A());
+ *     }
+ *
+ *     @Produces ListenableFuture<B> b(A a) {
+ *       System.out.println("b");
+ *       return Futures.immediateFuture(new B(a));
+ *     }
+ *
+ *     @Produces ListenableFuture<C> c(B b) {
+ *       System.out.println("c");
+ *       return Futures.immediateFuture(new C(b));
+ *     }
+ *
+ *     @Produces @Delayed ListenableFuture<C> delayedC(A a, Producer<C> c) {
+ *       System.out.println("delayed c");
+ *       return c.get();
+ *     }
+ *   }
+ *
+ *   @ProductionComponent(modules = MyModule.class)
+ *   interface MyComponent {
+ *     @Delayed ListenableFuture<C> delayedC();
+ *   }}</pre>
+ * Suppose we instantiate the generated implementation of this component and call
+ * {@code delayedC()}: <pre>   {@code
+ *
+ *   MyComponent component = Dagger_MyComponent
+ *       .builder()
+ *       .executor(MoreExecutors.directExecutor())
+ *       .build();
+ *   System.out.println("Constructed component");
+ *   ListenableFuture<C> cFuture = component.delayedC();
+ *   System.out.println("Retrieved future");
+ *   C c = cFuture.get();
+ *   System.out.println("Retrieved c");}</pre>
+ * Here, we're using {@code MoreExecutors.directExecutor} in order to illustrate how each call
+ * directly causes code to execute. The above code will print: <pre>   {@code
+ *   Constructed component
+ *   a
+ *   delayed c
+ *   b
+ *   c
+ *   Retrieved future
+ *   Retrieved c}</pre>
+ *
+ * @author Jesse Beder
+ */
+public interface Producer<T> {
+  /**
+   * Returns a future representing a running task that produces a value. Calling this method will
+   * trigger the submission of this task to the executor, if it has not already been triggered. In
+   * order to trigger this task's submission, the transitive dependencies required to produce the
+   * {@code T} will be submitted to the executor, as their dependencies become available.
+   *
+   * <p>If the key is bound to a {@link Produces} method, then calling this method multiple times
+   * will return the same future.
+   */
+  ListenableFuture<T> get();
+}
diff --git a/producers/src/main/java/dagger/producers/ProducerModule.java b/producers/src/main/java/dagger/producers/ProducerModule.java
new file mode 100644
index 000000000..5a677a40f
--- /dev/null
+++ b/producers/src/main/java/dagger/producers/ProducerModule.java
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2014 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.producers;
+
+import dagger.Module;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Target;
+
+import static java.lang.annotation.ElementType.TYPE;
+
+/**
+ * Annotates a class that contributes {@link Produces} bindings to the production component.
+ *
+ * @author Jesse Beder
+ */
+@Documented @Target(TYPE)
+public @interface ProducerModule {
+  /**
+   * Additional {@code @ProducerModule}- or {@link Module}-annotated classes from which this module
+   * is composed. The de-duplicated contributions of the modules in {@code includes}, and of their
+   * inclusions recursively, are all contributed to the object graph.
+   */
+  Class<?>[] includes() default {};
+}
diff --git a/producers/src/main/java/dagger/producers/Produces.java b/producers/src/main/java/dagger/producers/Produces.java
new file mode 100644
index 000000000..6f77c3c2d
--- /dev/null
+++ b/producers/src/main/java/dagger/producers/Produces.java
@@ -0,0 +1,67 @@
+/*
+ * Copyright (C) 2014 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.producers;
+
+import com.google.common.util.concurrent.ListenableFuture;
+import java.lang.annotation.Documented;
+import java.lang.annotation.Target;
+
+import static java.lang.annotation.ElementType.METHOD;
+
+/**
+ * Annotates methods of a producer module to create a production binding. If the method returns
+ * a {@link ListenableFuture}, then the parameter type of the future is bound to the value that the
+ * future provides; otherwise, the return type is bound to the returned value. The production
+ * component will pass dependencies to the method as parameters.
+ *
+ * @author Jesse Beder
+ */
+@Documented @Target(METHOD)
+public @interface Produces {
+  /** The type of binding into which the return type of the annotated method contributes. */
+  enum Type {
+    /**
+     * The method is the only one which can produce the value for the specified type. This is the
+     * default behavior.
+     */
+    UNIQUE,
+
+    /**
+     * The method's resulting type forms the generic type argument of a {@code Set<T>}, and the
+     * returned value or future is contributed to the set. The {@code Set<T>} produced from the
+     * accumulation of values will be immutable.
+     */
+    SET,
+
+    /**
+     * Like {@link #SET}, except the method's return type is either {@code Set<T>} or
+     * {@code Set<ListenableFuture<T>>}, where any values are contributed to the set. An example use
+     * is to provide a default empty set binding, which is otherwise not possible using
+     * {@link #SET}.
+     */
+    SET_VALUES,
+
+    /**
+     * The method's return type forms the type argument for the value of a
+     * {@code Map<K, Producer<V>>}, and the combination of the annotated key and the returned value
+     * is contributed to the map as a key/value pair. The {@code Map<K, Producer<V>>} produced from
+     * the accumulation of values will be immutable.
+     */
+    MAP;
+  }
+
+  Type type() default Type.UNIQUE;
+}
diff --git a/producers/src/main/java/dagger/producers/ProductionComponent.java b/producers/src/main/java/dagger/producers/ProductionComponent.java
new file mode 100644
index 000000000..d9e71e3fc
--- /dev/null
+++ b/producers/src/main/java/dagger/producers/ProductionComponent.java
@@ -0,0 +1,80 @@
+/*
+ * Copyright (C) 2014 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.producers;
+
+import dagger.Module;
+import dagger.Provides;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Target;
+import javax.inject.Inject;
+import javax.inject.Qualifier;
+
+import static java.lang.annotation.ElementType.TYPE;
+
+/**
+ * Annotates an interface or abstract class for which a fully-formed, dependency-injected
+ * implementation is to be generated from a set of {@linkplain #modules}. The generated class will
+ * have the name of the type annotated with {@code @ProductionComponent} prepended with
+ * {@code Dagger_}.  For example, {@code @ProductionComponent interface MyComponent {...}} will
+ * produce an implementation named {@code Dagger_MyComponent}.
+ *
+ * <p>Each {@link Produces} method that contributes to the component will be called at most once per
+ * component instance, no matter how many times that binding is used as a dependency.
+ * TODO(user): Decide on how scope works for producers.
+ *
+ * <h2>Component methods</h2>
+ *
+ * <p>Every type annotated with {@code @ProductionComponent} must contain at least one abstract
+ * component method. Component methods must represent {@linkplain Producer production}.
+ *
+ * Production methods have no arguments and return either a {@link ListenableFuture} or
+ * {@link Producer} of a type that is {@link Inject injected}, {@link Provides provided}, or
+ * {@link Produces produced}. Each may have a {@link Qualifier} annotation as well. The following
+ * are all valid production method declarations: <pre>   {@code
+ *
+ *   ListenableFuture<SomeType> getSomeType();
+ *   Producer<Set<SomeType>> getSomeTypes();
+ *   @Response ListenableFuture<Html> getResponse();}</pre>
+ *
+ * <h2>Exceptions</h2>
+ *
+ * <p>When a producer throws an exception, the exception will be propagated to its downstream
+ * producers in the following way: if the downstream producer injects a type {@code T}, then that
+ * downstream producer will be skipped, and the exception propagated to its downstream producers;
+ * and if the downstream producer injects a {@code Produced<T>}, then the downstream producer will
+ * be run with the exception stored in the {@code Produced<T>}.
+ *
+ * <p>If a non-execution exception is thrown (e.g., an {@code InterruptedException} or
+ * {@code CancellationException}), then exception is handled as in
+ * {@link com.google.common.util.concurrent.Futures#transform}.
+ * TODO(user): Explain this more thoroughly, and possibly update the javadocs of those utilities.
+ *
+ * @author Jesse Beder
+ */
+@Documented @Target(TYPE)
+public @interface ProductionComponent {
+  /**
+   * A list of classes annotated with {@link Module} or {@link ProducerModule} whose bindings are
+   * used to generate the component implementation.
+   */
+  Class<?>[] modules() default {};
+
+  /**
+   * A list of types that are to be used as component dependencies.
+   */
+  Class<?>[] dependencies() default {};
+}
diff --git a/producers/src/main/java/dagger/producers/internal/Producers.java b/producers/src/main/java/dagger/producers/internal/Producers.java
new file mode 100644
index 000000000..7d051601a
--- /dev/null
+++ b/producers/src/main/java/dagger/producers/internal/Producers.java
@@ -0,0 +1,104 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.producers.internal;
+
+import com.google.common.base.Function;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.util.concurrent.FutureFallback;
+import com.google.common.util.concurrent.Futures;
+import com.google.common.util.concurrent.ListenableFuture;
+import com.google.common.util.concurrent.ListenableFutureTask;
+import dagger.producers.Produced;
+import java.util.Set;
+import java.util.concurrent.Callable;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.Executor;
+
+/**
+ * Utility methods for use in generated producer code.
+ *
+ * @author Jesse Beder
+ * @since 2.0
+ */
+public final class Producers {
+  /**
+   * Returns a future of {@link Produced} that represents the completion (either success or failure)
+   * of the given future. If the input future succeeds, then the resulting future also succeeds with
+   * a successful {@code Produced}; if the input future fails, then the resulting future succeeds
+   * with a failing {@code Produced}.
+   *
+   * <p>Cancelling the resulting future will propagate the cancellation to the input future; but
+   * cancelling the input future will trigger the resulting future to succeed with a failing
+   * {@code Produced}.
+   */
+  // TODO(user): Document what happens with an InterruptedException after you figure out how to
+  // trigger one in a test.
+  public static <T> ListenableFuture<Produced<T>> createFutureProduced(ListenableFuture<T> future) {
+    return Futures.withFallback(
+        Futures.transform(future, new Function<T, Produced<T>>() {
+          @Override public Produced<T> apply(final T value) {
+            return new Produced<T>() {
+              @Override public T get() {
+                return value;
+              }
+            };
+          }
+        }), futureFallbackForProduced());
+  }
+
+  private static final FutureFallback<Produced<Object>> FUTURE_FALLBACK_FOR_PRODUCED =
+      new FutureFallback<Produced<Object>>() {
+    @Override public ListenableFuture<Produced<Object>> create(final Throwable t) {
+      return Futures.immediateFuture(new Produced<Object>() {
+        @Override public Object get() throws ExecutionException {
+          throw new ExecutionException(t);
+        }
+      });
+    }
+  };
+
+  @SuppressWarnings("unchecked")  // bivariant implementation
+  private static <T> FutureFallback<Produced<T>> futureFallbackForProduced() {
+    return (FutureFallback<Produced<T>>) (Object) FUTURE_FALLBACK_FOR_PRODUCED;
+  }
+
+  /**
+   * Returns a future of a {@code Set} that contains a single element: the result of the input
+   * future.
+   */
+  public static <T> ListenableFuture<Set<T>> createFutureSingletonSet(ListenableFuture<T> future) {
+    return Futures.transform(future, new Function<T, Set<T>>() {
+      @Override public Set<T> apply(T value) {
+        return ImmutableSet.of(value);
+      }
+    });
+  }
+
+  /**
+   * Submits a callable to an executor, returning the future representing the task. This mirrors
+   * {@link com.google.common.util.concurrent.ListeningExecutorService#submit}, but only requires an
+   * {@link Executor}.
+   *
+   * @throws RejectedExecutionException if this task cannot be accepted for execution.
+   */
+  public static <T> ListenableFuture<T> submitToExecutor(Callable<T> callable, Executor executor) {
+    ListenableFutureTask<T> future = ListenableFutureTask.create(callable);
+    executor.execute(future);
+    return future;
+  }
+
+  private Producers() {}
+}
diff --git a/producers/src/test/java/dagger/producers/internal/ProducersTest.java b/producers/src/test/java/dagger/producers/internal/ProducersTest.java
new file mode 100644
index 000000000..ee2e0b9f6
--- /dev/null
+++ b/producers/src/test/java/dagger/producers/internal/ProducersTest.java
@@ -0,0 +1,108 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.producers.internal;
+
+import com.google.common.util.concurrent.Futures;
+import com.google.common.util.concurrent.ListenableFuture;
+import com.google.common.util.concurrent.MoreExecutors;
+import com.google.common.util.concurrent.SettableFuture;
+import dagger.producers.Produced;
+import java.util.Set;
+import java.util.concurrent.Callable;
+import java.util.concurrent.CancellationException;
+import java.util.concurrent.ExecutionException;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+
+/**
+ * Tests {@link Producers}.
+ */
+@RunWith(JUnit4.class)
+public class ProducersTest {
+  @Test public void createFutureProduced_success() throws Exception {
+    ListenableFuture<String> future = Futures.immediateFuture("monkey");
+    ListenableFuture<Produced<String>> producedFuture = Producers.createFutureProduced(future);
+    assertThat(producedFuture.isDone()).isTrue();
+    assertThat(producedFuture.get().get()).isEqualTo("monkey");
+  }
+
+  @Test public void createFutureProduced_failure() throws Exception {
+    ListenableFuture<String> future = Futures.immediateFailedFuture(new RuntimeException("monkey"));
+    ListenableFuture<Produced<String>> producedFuture = Producers.createFutureProduced(future);
+    assertThat(producedFuture.isDone()).isTrue();
+    assertThat(getProducedException(producedFuture.get()).getCause()).hasMessage("monkey");
+  }
+
+  @Test public void createFutureProduced_cancelPropagatesBackwards() throws Exception {
+    ListenableFuture<String> future = SettableFuture.create();
+    ListenableFuture<Produced<String>> producedFuture = Producers.createFutureProduced(future);
+    assertThat(producedFuture.isDone()).isFalse();
+    producedFuture.cancel(false);
+    assertThat(future.isCancelled()).isTrue();
+  }
+
+  @Test public void createFutureProduced_cancelDoesNotPropagateForwards() throws Exception {
+    ListenableFuture<String> future = SettableFuture.create();
+    ListenableFuture<Produced<String>> producedFuture = Producers.createFutureProduced(future);
+    assertThat(producedFuture.isDone()).isFalse();
+    future.cancel(false);
+    assertThat(producedFuture.isCancelled()).isFalse();
+    assertThat(getProducedException(producedFuture.get()).getCause())
+        .isInstanceOf(CancellationException.class);
+  }
+
+  private <T> ExecutionException getProducedException(Produced<T> produced) {
+    try {
+      produced.get();
+      throw new IllegalArgumentException("produced did not throw");
+    } catch (ExecutionException e) {
+      return e;
+    }
+  }
+
+  @Test public void createFutureSingletonSet_success() throws Exception {
+    ListenableFuture<String> future = Futures.immediateFuture("monkey");
+    ListenableFuture<Set<String>> setFuture = Producers.createFutureSingletonSet(future);
+    assertThat(setFuture.isDone()).isTrue();
+    assertThat(setFuture.get()).containsExactly("monkey");
+  }
+
+  @Test public void createFutureSingletonSet_failure() throws Exception {
+    ListenableFuture<String> future = Futures.immediateFailedFuture(new RuntimeException("monkey"));
+    ListenableFuture<Set<String>> setFuture = Producers.createFutureSingletonSet(future);
+    assertThat(setFuture.isDone()).isTrue();
+    try {
+      setFuture.get();
+      fail();
+    } catch (ExecutionException e) {
+      assertThat(e.getCause()).hasMessage("monkey");
+    }
+  }
+
+  @Test public void submitToExecutor() throws Exception {
+    ListenableFuture<Integer> future = Producers.submitToExecutor(new Callable<Integer>() {
+      @Override public Integer call() {
+        return 42;
+      }
+    }, MoreExecutors.directExecutor());
+    assertThat(future.isDone()).isTrue();
+    assertThat(future.get()).isEqualTo(42);
+  }
+}
