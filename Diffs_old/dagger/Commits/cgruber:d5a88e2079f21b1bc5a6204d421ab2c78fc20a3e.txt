diff --git a/compiler/src/main/java/dagger/internal/codegen/KeyVariableNamer.java b/compiler/src/main/java/dagger/internal/codegen/BindingVariableNamer.java
similarity index 51%
rename from compiler/src/main/java/dagger/internal/codegen/KeyVariableNamer.java
rename to compiler/src/main/java/dagger/internal/codegen/BindingVariableNamer.java
index 5fe12b102..4ed87ebc5 100644
--- a/compiler/src/main/java/dagger/internal/codegen/KeyVariableNamer.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingVariableNamer.java
@@ -15,7 +15,6 @@
  */
 package dagger.internal.codegen;
 
-import com.google.common.base.Function;
 import java.util.Iterator;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeMirror;
@@ -25,42 +24,54 @@
 import static com.google.common.base.CaseFormat.UPPER_CAMEL;
 
 /**
- * Suggests a variable name for a type based on a {@link Key}. Prefer
+ * Suggests a variable name for a type based on a {@link Binding}. Prefer
  * {@link DependencyVariableNamer} for cases where a specific {@link DependencyRequest} is present.
  *
  * @author Gregory Kick
  * @since 2.0
  */
-enum KeyVariableNamer implements Function<Key, String> {
-  INSTANCE;
+final class BindingVariableNamer {
 
-  @Override
-  public String apply(Key key) {
+  private BindingVariableNamer() {}
+
+  static String name(Binding binding) {
     StringBuilder builder = new StringBuilder();
 
+    Key key = binding.key();
     if (key.qualifier().isPresent()) {
       // TODO(gak): Use a better name for fields with qualifiers with members.
       builder.append(key.qualifier().get().getAnnotationType().asElement().getSimpleName());
     }
 
-    key.type().accept(new SimpleTypeVisitor6<Void, StringBuilder>() {
-      @Override
-      public Void visitDeclared(DeclaredType t, StringBuilder builder) {
-        builder.append(t.asElement().getSimpleName());
-        Iterator<? extends TypeMirror> argumentIterator = t.getTypeArguments().iterator();
-        if (argumentIterator.hasNext()) {
-          builder.append("Of");
-          TypeMirror first = argumentIterator.next();
-          first.accept(this, builder);
-          while (argumentIterator.hasNext()) {
-            builder.append("And");
-            argumentIterator.next().accept(this, builder);
+    TypeMirror type = typeToName(binding);
+    type.accept(
+        new SimpleTypeVisitor6<Void, StringBuilder>() {
+          @Override
+          public Void visitDeclared(DeclaredType t, StringBuilder builder) {
+            builder.append(t.asElement().getSimpleName());
+            Iterator<? extends TypeMirror> argumentIterator = t.getTypeArguments().iterator();
+            if (argumentIterator.hasNext()) {
+              builder.append("Of");
+              TypeMirror first = argumentIterator.next();
+              first.accept(this, builder);
+              while (argumentIterator.hasNext()) {
+                builder.append("And");
+                argumentIterator.next().accept(this, builder);
+              }
+            }
+            return null;
           }
-        }
-        return null;
-      }
-    }, builder);
+        },
+        builder);
 
     return UPPER_CAMEL.to(LOWER_CAMEL, builder.toString());
   }
+
+  private static TypeMirror typeToName(Binding binding) {
+    if (binding instanceof ContributionBinding
+        && ((ContributionBinding) binding).contributionType().equals(ContributionType.SET)) {
+      return SetType.from(binding.key().type()).elementType();
+    }
+    return binding.key().type();
+  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java b/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java
index 87d626b5d..a508eded3 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java
@@ -95,7 +95,7 @@ private static String frameworkFieldName(ResolvedBindings resolvedBindings) {
         return BINDING_ELEMENT_NAME.visit(binding.bindingElement(), binding);
       }
     }
-    return KeyVariableNamer.INSTANCE.apply(resolvedBindings.key());
+    return BindingVariableNamer.name(resolvedBindings.binding());
   }
 
   private static final ElementVisitor<String, Binding> BINDING_ELEMENT_NAME =
diff --git a/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java b/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
index 0503ddcb5..6b5c00510 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
@@ -101,6 +101,16 @@ public Key key() {
     }
   }
 
+  /**
+   * Returns the single binding.
+   *
+   * @throws IllegalStateException if there is not exactly one element in {@link #bindings()},
+   *     which will never happen for contributions in valid graphs
+   */
+  Binding binding() {
+    return getOnlyElement(bindings());
+  }
+
   /**
    * All bindings for {@link #bindingKey()}, together with the component in which they were
    * resolved.
