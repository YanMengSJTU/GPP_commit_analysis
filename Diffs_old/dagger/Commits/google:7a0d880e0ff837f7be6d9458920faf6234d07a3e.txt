diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
index 847e85d4c..04647c97d 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -925,15 +925,13 @@ private StringBuilder requiresErrorMessageBase(Deque<ResolvedRequest> path) {
 
     private void reportMissingBinding(Deque<ResolvedRequest> path) {
       StringBuilder errorMessage = requiresErrorMessageBase(path);
-      ImmutableList<String> printableDependencyPath =
+      FluentIterable<String> printableDependencyPath =
           FluentIterable.from(path)
-              .filter(Predicates.not(SYNTHETIC_BINDING))
+              .filter(Predicates.not(PREVIOUS_REQUEST_WAS_SYNTHETIC))
               .transform(REQUEST_FROM_RESOLVED_REQUEST)
               .transform(dependencyRequestFormatter)
-              .filter(Predicates.not(Predicates.equalTo("")))
-              .toList()
-              .reverse();
-      for (String dependency : Iterables.skip(printableDependencyPath, 1)) {
+              .filter(Predicates.not(Predicates.equalTo("")));
+      for (String dependency : printableDependencyPath) {
         errorMessage.append('\n').append(dependency);
       }
       for (String suggestion : MissingBindingSuggestions.forKey(topLevelGraph(),
@@ -1096,7 +1094,7 @@ private void reportCycle(
               rootRequestElement.getSimpleName(),
               FluentIterable.from(bindingPath) // TODO(dpb): Resolve with similar code above.
                   .skip(1)
-                  .filter(Predicates.not(SYNTHETIC_BINDING))
+                  .filter(Predicates.not(PREVIOUS_REQUEST_WAS_SYNTHETIC))
                   .transform(REQUEST_FROM_RESOLVED_REQUEST)
                   .append(request)
                   .transform(dependencyRequestFormatter)
@@ -1285,11 +1283,16 @@ public DependencyRequest apply(ResolvedRequest resolvedRequest) {
         }
       };
 
-  private static final Predicate<ResolvedRequest> SYNTHETIC_BINDING =
+  private static final Predicate<ResolvedRequest> PREVIOUS_REQUEST_WAS_SYNTHETIC =
       new Predicate<ResolvedRequest>() {
+
+        boolean previousRequestWasSynthetic;
+
         @Override
-        public boolean apply(ResolvedRequest request) {
-          return request.binding().isSyntheticContribution();
+        public boolean apply(ResolvedRequest resolvedRequest) {
+          boolean returnValue = previousRequestWasSynthetic;
+          previousRequestWasSynthetic = resolvedRequest.binding().isSyntheticContribution();
+          return returnValue;
         }
       };
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
index 3d439dd47..77a63cfd3 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -63,7 +63,8 @@ public SourceVersion getSupportedSourceVersion() {
     MethodSignatureFormatter methodSignatureFormatter = new MethodSignatureFormatter(types);
     HasSourceElementFormatter hasSourceElementFormatter =
         new HasSourceElementFormatter(methodSignatureFormatter);
-    DependencyRequestFormatter dependencyRequestFormatter = new DependencyRequestFormatter(types);
+    DependencyRequestFormatter dependencyRequestFormatter =
+        new DependencyRequestFormatter(types, elements);
     KeyFormatter keyFormatter = new KeyFormatter(methodSignatureFormatter);
 
     InjectConstructorValidator injectConstructorValidator = new InjectConstructorValidator();
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyRequestFormatter.java b/compiler/src/main/java/dagger/internal/codegen/DependencyRequestFormatter.java
index bbebdee3c..db8fc8aef 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DependencyRequestFormatter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyRequestFormatter.java
@@ -16,137 +16,192 @@
 package dagger.internal.codegen;
 
 import com.google.auto.common.MoreElements;
-import com.google.auto.common.MoreTypes;
 import com.google.common.base.Optional;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
-import java.util.List;
+import dagger.Provides;
+import dagger.producers.Produces;
+import javax.inject.Inject;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
-import javax.lang.model.element.ElementKind;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
-import javax.lang.model.type.ExecutableType;
 import javax.lang.model.type.TypeMirror;
-import javax.lang.model.util.SimpleElementVisitor6;
+import javax.lang.model.util.ElementKindVisitor7;
+import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 
-import static com.google.common.base.Preconditions.checkState;
-import static com.google.common.collect.Iterables.getOnlyElement;
+import static com.google.auto.common.MoreElements.asExecutable;
 import static dagger.internal.codegen.ErrorMessages.INDENT;
 
 /**
  * Formats a {@link DependencyRequest} into a {@link String} suitable for an error message listing
  * a chain of dependencies.
- *
- * @author Christian Gruber
- * @since 2.0
+ * 
+ * <dl>
+ * <dt>For component provision methods
+ * <dd>{@code ComponentType.method() injects @Qualifier SomeType}
+ * 
+ * <dt>For component injection methods
+ * <dd>{@code ComponentType.method(foo) injects SomeType}
+ * 
+ * <dt>For parameters to {@link Provides @Provides}, {@link Produces @Produces}, or
+ * {@link Inject @Inject} methods:
+ * <dd>{@code EnclosingType.method([…, ]param[, …]) injects @Qualified ResolvedType}
+ * 
+ * <dt>For parameters to {@link Inject @Inject} constructors:
+ * <dd>{@code EnclosingType.<init>([…, ]param[, …]) injects @Qualified ResolvedType}
+ * 
+ * <dt>For {@link Inject @Inject} fields:
+ * <dd>{@code EnclosingType.field injects @Qualified ResolvedType}
+ * </dl>
  */
 final class DependencyRequestFormatter extends Formatter<DependencyRequest> {
+
   private final Types types;
+  private final Elements elements;
 
-  DependencyRequestFormatter(Types types) {
+  DependencyRequestFormatter(Types types, Elements elements) {
     this.types = types;
+    this.elements = elements;
   }
 
   // TODO(cgruber): Sweep this class for TypeMirror.toString() usage and do some preventive format.
   // TODO(cgruber): consider returning a small structure containing strings to be indented later.
-  @Override public String format(final DependencyRequest request) {
-    Element requestElement = request.requestElement();
-    Optional<AnnotationMirror> qualifier = InjectionAnnotations.getQualifier(requestElement);
-    return requestElement.accept(new SimpleElementVisitor6<String, Optional<AnnotationMirror>>(){
-
-      /* Handle component methods */
-      @Override public String visitExecutable(
-          ExecutableElement method, Optional<AnnotationMirror> qualifier) {
-        StringBuilder builder = new StringBuilder(INDENT);
-        if (method.getParameters().isEmpty()) {
-          // some.package.name.MyComponent.myMethod()
-          //     [component method with return type: @other.package.Qualifier some.package.name.Foo]
-          appendEnclosingTypeAndMemberName(method, builder).append("()\n")
-              .append(INDENT).append(INDENT).append("[component method with return type: ");
-          if (qualifier.isPresent()) {
-            // TODO(cgruber) use chenying's annotation mirror stringifier
-            builder.append(qualifier.get()).append(' ');
-          }
-          builder.append(method.getReturnType()).append(']');
-        } else {
-          // some.package.name.MyComponent.myMethod(some.package.name.Foo foo)
-          //     [component injection method for type: some.package.name.Foo]
-          VariableElement componentMethodParameter = getOnlyElement(method.getParameters());
-          appendEnclosingTypeAndMemberName(method, builder).append("(");
-          appendParameter(componentMethodParameter, componentMethodParameter.asType(), builder);
-          builder.append(")\n");
-          builder.append(INDENT).append(INDENT).append("[component injection method for type: ")
-              .append(componentMethodParameter.asType())
-              .append(']');
-        }
-        return builder.toString();
-      }
-
-      /* Handle injected fields or method/constructor parameter injection. */
-      @Override public String visitVariable(
-          VariableElement variable, Optional<AnnotationMirror> qualifier) {
-        StringBuilder builder = new StringBuilder(INDENT);
-        TypeMirror resolvedVariableType =
-            MoreTypes.asMemberOf(types, request.enclosingType(), variable);
-        if (variable.getKind().equals(ElementKind.PARAMETER)) {
-          // some.package.name.MyClass.myMethod(some.package.name.Foo arg0, some.package.Bar arg1)
-          //     [parameter: @other.package.Qualifier some.package.name.Foo arg0]
-          ExecutableElement methodOrConstructor =
-              MoreElements.asExecutable(variable.getEnclosingElement());
-          ExecutableType resolvedMethodOrConstructor = MoreTypes.asExecutable(
-              types.asMemberOf(request.enclosingType(), methodOrConstructor));
-          appendEnclosingTypeAndMemberName(methodOrConstructor, builder).append('(');
-          List<? extends VariableElement> parameters = methodOrConstructor.getParameters();
-          List<? extends TypeMirror> parameterTypes =
-              resolvedMethodOrConstructor.getParameterTypes();
-          checkState(parameters.size() == parameterTypes.size());
-          for (int i = 0; i < parameters.size(); i++) {
-            appendParameter(parameters.get(i), parameterTypes.get(i), builder);
-            if (i != parameters.size() - 1) {
-              builder.append(", ");
-            }
-          }
-          builder.append(")\n").append(INDENT).append(INDENT).append("[parameter: ");
-        } else {
-          // some.package.name.MyClass.myField
-          //     [injected field of type: @other.package.Qualifier some.package.name.Foo myField]
-          appendEnclosingTypeAndMemberName(variable, builder).append("\n")
-              .append(INDENT).append(INDENT).append("[injected field of type: ");
-        }
-        if (qualifier.isPresent()) {
-          // TODO(cgruber) use chenying's annotation mirror stringifier
-          builder.append(qualifier.get()).append(' ');
-        }
-        builder.append(resolvedVariableType)
-            .append(' ')
-            .append(variable.getSimpleName())
-            .append(']');
-        return builder.toString();
-      }
-
-      @Override
-      public String visitType(TypeElement e, Optional<AnnotationMirror> p) {
-        return ""; // types by themselves provide no useful information.
-      }
-
-      @Override protected String defaultAction(Element element, Optional<AnnotationMirror> ignore) {
-        throw new IllegalStateException(
-            "Invalid request " + element.getKind() +  " element " + element);
-      }
-    }, qualifier);
+  @Override
+  public String format(DependencyRequest request) {
+    return request
+        .requestElement()
+        .accept(
+            new ElementKindVisitor7<String, DependencyRequest>() {
+
+              /** Returns the description for component methods. */
+              @Override
+              public String visitExecutableAsMethod(
+                  ExecutableElement method, DependencyRequest request) {
+                StringBuilder builder = new StringBuilder(INDENT);
+                appendEnclosingTypeAndMemberName(method, builder);
+                builder.append('(');
+                for (VariableElement parameter : method.getParameters()) {
+                  builder.append(parameter.getSimpleName());
+                }
+                builder.append(')');
+                appendRequest(
+                    builder,
+                    componentMethodRequestVerb(request),
+                    request.key().qualifier(),
+                    request.key().type());
+                return builder.toString();
+              }
+
+              /**
+               * Returns the description for {@link javax.inject.Inject @Inject} constructor and
+               * method parameters and for {@link dagger.Provides @Provides} and
+               * {@link dagger.producers.Produces @Produces} method parameters.
+               */
+              @Override
+              public String visitVariableAsParameter(
+                  final VariableElement variable, DependencyRequest request) {
+                StringBuilder builder = new StringBuilder(INDENT);
+                ExecutableElement methodOrConstructor =
+                    asExecutable(variable.getEnclosingElement());
+
+                appendEnclosingTypeAndMemberName(methodOrConstructor, builder).append('(');
+                int parameterIndex = methodOrConstructor.getParameters().indexOf(variable);
+                if (parameterIndex > 0) {
+                  builder.append("…, ");
+                }
+                builder.append(variable.getSimpleName());
+                if (parameterIndex < methodOrConstructor.getParameters().size() - 1) {
+                  builder.append(", …");
+                }
+                builder.append(')');
+                appendRequest(builder, request);
+                return builder.toString();
+              }
+
+              /** Returns the description for {@link javax.inject.Inject @Inject} fields. */
+              @Override
+              public String visitVariableAsField(
+                  VariableElement variable, DependencyRequest request) {
+                StringBuilder builder = new StringBuilder(INDENT);
+                appendEnclosingTypeAndMemberName(variable, builder);
+                appendRequest(builder, request);
+                return builder.toString();
+              }
+
+              @Override
+              public String visitType(TypeElement e, DependencyRequest request) {
+                return ""; // types by themselves provide no useful information.
+              }
+
+              @Override
+              protected String defaultAction(Element element, DependencyRequest request) {
+                throw new IllegalStateException(
+                    "Invalid request " + element.getKind() + " element " + element);
+              }
+            },
+            request);
   }
 
-  @CanIgnoreReturnValue
-  private StringBuilder appendParameter(
-      VariableElement parameter, TypeMirror type, StringBuilder builder) {
-    return builder.append(type).append(' ').append(parameter.getSimpleName());
+  private void appendRequest(StringBuilder builder, DependencyRequest request) {
+    appendRequest(
+        builder, "injects", request.key().qualifier(), requestedTypeWithFrameworkClass(request));
+  }
+
+  private void appendRequest(
+      StringBuilder builder, String verb, Optional<AnnotationMirror> qualifier, TypeMirror type) {
+    builder.append("\n    ").append(INDENT).append(verb).append(' ');
+    appendQualifiedType(builder, qualifier, type);
   }
 
+  private TypeMirror requestedTypeWithFrameworkClass(DependencyRequest request) {
+    Optional<Class<?>> requestFrameworkClass = request.kind().frameworkClass;
+    if (requestFrameworkClass.isPresent()) {
+      return types.getDeclaredType(
+          elements.getTypeElement(requestFrameworkClass.get().getCanonicalName()),
+          request.key().type());
+    }
+    return request.key().type();
+  }
+
+  private void appendQualifiedType(
+      StringBuilder builder, Optional<AnnotationMirror> qualifier, TypeMirror type) {
+    if (qualifier.isPresent()) {
+      builder.append(qualifier.get()).append(' ');
+    }
+    builder.append(type);
+  }
+
+  /**
+   * Returns the verb for a component method dependency request. Returns "produces", "provides", or
+   * "injects", depending on the kind of request.
+   */
+  private String componentMethodRequestVerb(DependencyRequest request) {
+    switch (request.kind()) {
+      case FUTURE:
+      case PRODUCER:
+        return "produces";
+
+      case INSTANCE:
+      case LAZY:
+      case PROVIDER:
+        return "provides";
+
+      case MEMBERS_INJECTOR:
+        return "injects";
+
+      case PRODUCED:
+      default:
+        throw new AssertionError("illegal request kind for method: " + request);
+    }
+  }
+
+  @CanIgnoreReturnValue
   private StringBuilder appendEnclosingTypeAndMemberName(Element member, StringBuilder builder) {
     TypeElement type = MoreElements.asType(member.getEnclosingElement());
-    return builder.append(type.getQualifiedName())
+    return builder
+        .append(type.getQualifiedName())
         .append('.')
         .append(member.getSimpleName());
   }
diff --git a/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java b/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
index dd31751cb..ce284d511 100644
--- a/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
@@ -188,13 +188,16 @@
         "  }",
         "}");
 
-    String expectedError = "test.Outer.CComponent.getC() contains a dependency cycle:\n"
-        + "      test.Outer.C.<init>(test.Outer.B bParam)\n"
-        + "          [parameter: test.Outer.B bParam]\n"
-        + "      test.Outer.B.<init>(test.Outer.A aParam)\n"
-        + "          [parameter: test.Outer.A aParam]\n"
-        + "      test.Outer.A.<init>(test.Outer.C cParam)\n"
-        + "          [parameter: test.Outer.C cParam]";
+    String expectedError =
+        Joiner.on('\n')
+            .join(
+                "test.Outer.CComponent.getC() contains a dependency cycle:",
+                "      test.Outer.C.<init>(bParam)",
+                "          injects test.Outer.B",
+                "      test.Outer.B.<init>(aParam)",
+                "          injects test.Outer.A",
+                "      test.Outer.A.<init>(cParam)",
+                "          injects test.Outer.C");
 
     assertAbout(javaSource()).that(component)
         .processedWith(new ComponentProcessor())
@@ -236,15 +239,18 @@
             "  }",
             "}");
 
-    String expectedError = "test.Outer.DComponent.getD() contains a dependency cycle:\n"
-        + "      test.Outer.D.<init>(test.Outer.C cParam)\n"
-        + "          [parameter: test.Outer.C cParam]\n"
-        + "      test.Outer.C.<init>(test.Outer.B bParam)\n"
-        + "          [parameter: test.Outer.B bParam]\n"
-        + "      test.Outer.B.<init>(test.Outer.A aParam)\n"
-        + "          [parameter: test.Outer.A aParam]\n"
-        + "      test.Outer.A.<init>(test.Outer.C cParam)\n"
-        + "          [parameter: test.Outer.C cParam]";
+    String expectedError =
+        Joiner.on('\n')
+            .join(
+                "test.Outer.DComponent.getD() contains a dependency cycle:",
+                "      test.Outer.D.<init>(cParam)",
+                "          injects test.Outer.C",
+                "      test.Outer.C.<init>(bParam)",
+                "          injects test.Outer.B",
+                "      test.Outer.B.<init>(aParam)",
+                "          injects test.Outer.A",
+                "      test.Outer.A.<init>(cParam)",
+                "          injects test.Outer.C");
 
     assertAbout(javaSource())
         .that(component)
@@ -306,14 +312,14 @@ public void cyclicDependencyNotBrokenByMapBinding() {
         Joiner.on('\n')
             .join(
                 "test.Outer.CComponent.getC() contains a dependency cycle:",
-                "      test.Outer.C.<init>(test.Outer.B bParam)",
-                "          [parameter: test.Outer.B bParam]",
-                "      test.Outer.B.<init>(test.Outer.A aParam)",
-                "          [parameter: test.Outer.A aParam]",
-                "      test.Outer.A.<init>(java.util.Map<java.lang.String,test.Outer.C> cMap)",
-                "          [parameter: java.util.Map<java.lang.String,test.Outer.C> cMap]",
-                "      test.Outer.CModule.c(test.Outer.C c)",
-                "          [parameter: test.Outer.C c]");
+                "      test.Outer.C.<init>(bParam)",
+                "          injects test.Outer.B",
+                "      test.Outer.B.<init>(aParam)",
+                "          injects test.Outer.A",
+                "      test.Outer.A.<init>(cMap)",
+                "          injects java.util.Map<java.lang.String,test.Outer.C>",
+                "      test.Outer.CModule.c(c)",
+                "          injects test.Outer.C");
 
     assertAbout(javaSource())
         .that(component)
@@ -368,14 +374,15 @@ public void cyclicDependencyWithSetBinding() {
         Joiner.on('\n')
             .join(
                 "test.Outer.CComponent.getC() contains a dependency cycle:",
-                "      test.Outer.C.<init>(test.Outer.B bParam)",
-                "          [parameter: test.Outer.B bParam]",
-                "      test.Outer.B.<init>(test.Outer.A aParam)",
-                "          [parameter: test.Outer.A aParam]",
-                "      test.Outer.A.<init>(java.util.Set<test.Outer.C> cSet)",
-                "          [parameter: java.util.Set<test.Outer.C> cSet]",
-                "      test.Outer.CModule.c(test.Outer.C c)",
-                "          [parameter: test.Outer.C c]");
+                "      test.Outer.C.<init>(bParam)",
+                "          injects test.Outer.B",
+                "      test.Outer.B.<init>(aParam)",
+                "          injects test.Outer.A",
+                "      test.Outer.A.<init>(cSet)",
+                "          injects java.util.Set<test.Outer.C>",
+                "      test.Outer.CModule.c(c)",
+                "          injects test.Outer.C"
+                );
 
     assertAbout(javaSource())
         .that(component)
@@ -423,15 +430,17 @@ public void falsePositiveCyclicDependencyIndirectionDetected() {
             "}");
 
     String expectedError =
-        "test.Outer.DComponent.getD() contains a dependency cycle:\n"
-            + "      test.Outer.D.<init>(javax.inject.Provider<test.Outer.C> cParam)\n"
-            + "          [parameter: javax.inject.Provider<test.Outer.C> cParam]\n"
-            + "      test.Outer.C.<init>(test.Outer.B bParam)\n"
-            + "          [parameter: test.Outer.B bParam]\n"
-            + "      test.Outer.B.<init>(test.Outer.A aParam)\n"
-            + "          [parameter: test.Outer.A aParam]\n"
-            + "      test.Outer.A.<init>(test.Outer.C cParam)\n"
-            + "          [parameter: test.Outer.C cParam]";
+        Joiner.on('\n')
+            .join(
+                "test.Outer.DComponent.getD() contains a dependency cycle:",
+                "      test.Outer.D.<init>(cParam)",
+                "          injects javax.inject.Provider<test.Outer.C>",
+                "      test.Outer.C.<init>(bParam)",
+                "          injects test.Outer.B",
+                "      test.Outer.B.<init>(aParam)",
+                "          injects test.Outer.A",
+                "      test.Outer.A.<init>(cParam)",
+                "          injects test.Outer.C");
 
     assertAbout(javaSource())
         .that(component)
@@ -789,64 +798,86 @@ public void duplicateExplicitBindings_UniqueBindingAndMultibindingDeclaration()
   }
 
   @Test public void longChainOfDependencies() {
-    JavaFileObject component = JavaFileObjects.forSourceLines("test.TestClass",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "import javax.inject.Inject;",
-        "",
-        "final class TestClass {",
-        "  interface A {}",
-        "",
-        "  static class B {",
-        "    @Inject B(A a) {}",
-        "  }",
-        "",
-        "  static class C {",
-        "    @Inject B b;",
-        "    @Inject C(B b) {}",
-        "  }",
-        "",
-        "  interface D { }",
-        "",
-        "  static class DImpl implements D {",
-        "    @Inject DImpl(C c, B b) {}",
-        "  }",
-        "",
-        "  @Module",
-        "  static class DModule {",
-        "    @Provides D d(DImpl impl) { return impl; }",
-        "  }",
-        "",
-        "  @Component(modules = { DModule.class })",
-        "  interface AComponent {",
-        "    D getFoo();",
-        "    C injectC(C c);",
-        "  }",
-        "}");
-    String errorText =
-        "test.TestClass.A cannot be provided without an @Provides-annotated method.\n";
-    String firstError = errorText
-        + "      test.TestClass.DModule.d(test.TestClass.DImpl impl)\n"
-        + "          [parameter: test.TestClass.DImpl impl]\n"
-        + "      test.TestClass.DImpl.<init>(test.TestClass.C c, test.TestClass.B b)\n"
-        + "          [parameter: test.TestClass.C c]\n"
-        + "      test.TestClass.C.b\n"
-        + "          [injected field of type: test.TestClass.B b]\n"
-        + "      test.TestClass.B.<init>(test.TestClass.A a)\n"
-        + "          [parameter: test.TestClass.A a]";
-    String secondError = errorText
-        + "      test.TestClass.C.b\n"
-        + "          [injected field of type: test.TestClass.B b]\n"
-        + "      test.TestClass.B.<init>(test.TestClass.A a)\n"
-        + "          [parameter: test.TestClass.A a]";
-    assertAbout(javaSource()).that(component)
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestClass",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import javax.inject.Inject;",
+            "import javax.inject.Named;",
+            "",
+            "final class TestClass {",
+            "  interface A {}",
+            "",
+            "  static class B {",
+            "    @Inject B(A a) {}",
+            "  }",
+            "",
+            "  static class C {",
+            "    @Inject B b;",
+            "    @Inject C(X x, B b) {}",
+            "  }",
+            "",
+            "  interface D { }",
+            "",
+            "  static class DImpl implements D {",
+            "    @Inject DImpl(C c, B b) {}",
+            "  }",
+            "",
+            "  static class X {",
+            "    @Inject X() {}",
+            "  }",
+            "",
+            "  @Module",
+            "  static class DModule {",
+            "    @Provides @Named(\"slim shady\") D d(X x1, DImpl impl, X x2) { return impl; }",
+            "  }",
+            "",
+            "  @Component(modules = { DModule.class })",
+            "  interface AComponent {",
+            "    @Named(\"slim shady\") D getFoo();",
+            "    C injectC(C c);",
+            "  }",
+            "}");
+    String errorText = "test.TestClass.A cannot be provided without an @Provides-annotated method.";
+    String firstError =
+        Joiner.on('\n')
+            .join(
+                errorText,
+                "      test.TestClass.B.<init>(a)",
+                "          injects test.TestClass.A",
+                "      test.TestClass.C.b",
+                "          injects test.TestClass.B",
+                "      test.TestClass.DImpl.<init>(c, …)",
+                "          injects test.TestClass.C",
+                "      test.TestClass.DModule.d(…, impl, …)",
+                "          injects test.TestClass.DImpl",
+                "      test.TestClass.AComponent.getFoo()",
+                "          provides @javax.inject.Named(\"slim shady\") test.TestClass.D");
+    String secondError =
+        Joiner.on('\n')
+            .join(
+                errorText,
+                "      test.TestClass.B.<init>(a)",
+                "          injects test.TestClass.A",
+                "      test.TestClass.C.b",
+                "          injects test.TestClass.B",
+                "      test.TestClass.AComponent.injectC(c)",
+                "          injects test.TestClass.C");
+    assertAbout(javaSource())
+        .that(component)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
-        .withErrorContaining(firstError).in(component).onLine(33)
-        .and().withErrorContaining(secondError).in(component).onLine(34);
+        .withErrorContaining(firstError)
+        .in(component)
+        .onLine(38)
+        .and()
+        .withErrorContaining(secondError)
+        .in(component)
+        .onLine(39);
   }
 
   @Test public void resolvedParametersInDependencyTrace() {
@@ -885,14 +916,18 @@ public void duplicateExplicitBindings_UniqueBindingAndMultibindingDeclaration()
         "interface TestComponent {",
         "  UsesTest usesTest();",
         "}");
-    String expectedMsg = Joiner.on("\n").join(
-        "java.util.List cannot be provided without an @Provides-annotated method.",
-        "      test.UsesTest.<init>(test.Generic<test.TestClass> genericTestClass)",
-        "          [parameter: test.Generic<test.TestClass> genericTestClass]",
-        "      test.Generic.<init>(test.TestClass t)",
-        "          [parameter: test.TestClass t]",
-        "      test.TestClass.<init>(java.util.List list)",
-        "          [parameter: java.util.List list]");
+    String expectedMsg =
+        Joiner.on("\n")
+            .join(
+                "java.util.List cannot be provided without an @Provides-annotated method.",
+                "      test.TestClass.<init>(list)",
+                "          injects java.util.List",
+                "      test.Generic.<init>(t)",
+                "          injects test.TestClass",
+                "      test.UsesTest.<init>(genericTestClass)",
+                "          injects test.Generic<test.TestClass>",
+                "      test.TestComponent.usesTest()",
+                "          provides test.UsesTest");
     assertAbout(javaSources()).that(ImmutableList.of(generic, testClass, usesTest, component))
         .processedWith(new ComponentProcessor())
         .failsToCompile()
@@ -936,14 +971,18 @@ public void duplicateExplicitBindings_UniqueBindingAndMultibindingDeclaration()
         "interface TestComponent {",
         "  UsesTest usesTest();",
         "}");
-    String expectedMsg = Joiner.on("\n").join(
-        "java.util.List cannot be provided without an @Provides-annotated method.",
-        "      test.UsesTest.<init>(test.Generic<test.TestClass> genericTestClass)",
-        "          [parameter: test.Generic<test.TestClass> genericTestClass]",
-        "      test.Generic.t",
-        "          [injected field of type: test.TestClass t]",
-        "      test.TestClass.<init>(java.util.List list)",
-        "          [parameter: java.util.List list]");
+    String expectedMsg =
+        Joiner.on("\n")
+            .join(
+                "java.util.List cannot be provided without an @Provides-annotated method.",
+                "      test.TestClass.<init>(list)",
+                "          injects java.util.List",
+                "      test.Generic.t",
+                "          injects test.TestClass",
+                "      test.UsesTest.<init>(genericTestClass)",
+                "          injects test.Generic<test.TestClass>",
+                "      test.TestComponent.usesTest()",
+                "          provides test.UsesTest");
     assertAbout(javaSources()).that(ImmutableList.of(generic, testClass, usesTest, component))
         .processedWith(new ComponentProcessor())
         .failsToCompile()
