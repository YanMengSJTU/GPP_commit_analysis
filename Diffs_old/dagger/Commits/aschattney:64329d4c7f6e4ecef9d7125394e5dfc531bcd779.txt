diff --git a/android/pom.xml b/android/pom.xml
index 021058b3b..5d6dc0655 100644
--- a/android/pom.xml
+++ b/android/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.google.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>2.9</version>
+    <version>3.0</version>
   </parent>
 
   <artifactId>dagger-android</artifactId>
@@ -59,6 +59,11 @@
       <groupId>com.android.support</groupId>
       <artifactId>support-annotations</artifactId>
     </dependency>
+      <dependency>
+          <groupId>com.google.android</groupId>
+          <artifactId>android</artifactId>
+          <version>4.1.1.4</version>
+      </dependency>
   </dependencies>
 
   <build>
diff --git a/compiler/pom.xml b/compiler/pom.xml
index f97ddc83e..4be1384d3 100644
--- a/compiler/pom.xml
+++ b/compiler/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.google.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>2.9</version>
+    <version>3.0</version>
   </parent>
 
   <artifactId>dagger-compiler</artifactId>
@@ -76,13 +76,13 @@
       <artifactId>junit</artifactId>
       <scope>test</scope>
     </dependency>
-    <dependency>
+    <!--<dependency>
       <groupId>${project.groupId}</groupId>
       <artifactId>dagger</artifactId>
       <classifier>tests</classifier>
       <version>${project.version}</version>
       <scope>test</scope>
-    </dependency>
+    </dependency>-->
     <dependency>
       <groupId>com.google.testing.compile</groupId>
       <artifactId>compile-testing</artifactId>
@@ -129,20 +129,32 @@
                 <annotationProcessor>com.google.auto.value.processor.AutoValueProcessor</annotationProcessor>
                 <annotationProcessor>com.google.auto.service.processor.AutoServiceProcessor</annotationProcessor>
               </annotationProcessors>
+              <compilerArguments>
+                <!-- enable the next line to have the output of the processor shown on console -->
+                <Xlint/>
+                <Averbose>true</Averbose>
+              </compilerArguments>
+              <!-- set the next to true to enable verbose output of the compiler plugin -->
+              <verbose>true</verbose>
             </configuration>
           </execution>
-          <execution>
+          <!--<execution>
             <id>default-test-compile</id>
             <goals><goal>testCompile</goal></goals>
             <configuration>
               <annotationProcessors>
                 <annotationProcessor>dagger.internal.codegen.ComponentProcessor</annotationProcessor>
               </annotationProcessors>
+              <compilerArguments>
+                <Xlint/>
+                <Averbose>true</Averbose>
+              </compilerArguments>
+              <verbose>true</verbose>
             </configuration>
-          </execution>
+          </execution>-->
         </executions>
       </plugin>
-      <plugin>
+      <!--<plugin>
         <artifactId>maven-invoker-plugin</artifactId>
         <configuration>
           <addTestClassPath>true</addTestClassPath>
@@ -166,7 +178,7 @@
             </goals>
           </execution>
         </executions>
-      </plugin>
+      </plugin>-->
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-shade-plugin</artifactId>
diff --git a/compiler/src/it/functional-tests/pom.xml b/compiler/src/it/functional-tests/pom.xml
index f9cf90c18..cbebf0960 100644
--- a/compiler/src/it/functional-tests/pom.xml
+++ b/compiler/src/it/functional-tests/pom.xml
@@ -22,7 +22,7 @@ limitations under the License.
   <parent>
     <groupId>com.google.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>2.9</version>
+    <version>3.0</version>
   </parent>
   <groupId>dagger.tests</groupId>
   <artifactId>functional-tests</artifactId>
diff --git a/compiler/src/it/guava-functional-tests/pom.xml b/compiler/src/it/guava-functional-tests/pom.xml
index 5c172dde9..9287e210d 100644
--- a/compiler/src/it/guava-functional-tests/pom.xml
+++ b/compiler/src/it/guava-functional-tests/pom.xml
@@ -22,7 +22,7 @@ limitations under the License.
   <parent>
     <groupId>com.google.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>2.9</version>
+    <version>3.0</version>
   </parent>
   <groupId>dagger.tests</groupId>
   <artifactId>guava-functional-tests</artifactId>
diff --git a/compiler/src/it/producers-functional-tests/pom.xml b/compiler/src/it/producers-functional-tests/pom.xml
index 06e7ff344..72d3840ce 100644
--- a/compiler/src/it/producers-functional-tests/pom.xml
+++ b/compiler/src/it/producers-functional-tests/pom.xml
@@ -22,7 +22,7 @@ limitations under the License.
   <parent>
     <groupId>com.google.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>2.9</version>
+    <version>3.0</version>
   </parent>
   <groupId>dagger.tests</groupId>
   <artifactId>producers-functional-tests</artifactId>
diff --git a/compiler/src/it/tck/pom.xml b/compiler/src/it/tck/pom.xml
index 59fc4e2e7..c6afae2b1 100644
--- a/compiler/src/it/tck/pom.xml
+++ b/compiler/src/it/tck/pom.xml
@@ -22,7 +22,7 @@ limitations under the License.
   <parent>
     <groupId>com.google.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>2.9</version>
+    <version>3.0</version>
   </parent>
   <groupId>dagger.tests</groupId>
   <artifactId>tck</artifactId>
diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
index 0a7828496..24d6744e6 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -41,6 +41,7 @@
 import static dagger.internal.codegen.MemberSelect.localField;
 import static dagger.internal.codegen.MemberSelect.noOpMembersInjector;
 import static dagger.internal.codegen.MemberSelect.staticMethod;
+import static dagger.internal.codegen.Util.*;
 import static dagger.internal.codegen.MoreAnnotationMirrors.getTypeValue;
 import static dagger.internal.codegen.Scope.reusableScope;
 import static dagger.internal.codegen.SourceFiles.bindingTypeElementTypeVariableNames;
@@ -123,13 +124,9 @@
 import java.util.Map;
 import java.util.Optional;
 import java.util.Set;
+import java.util.*;
 import javax.inject.Provider;
-import javax.lang.model.element.AnnotationMirror;
-import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.Modifier;
-import javax.lang.model.element.Name;
-import javax.lang.model.element.TypeElement;
-import javax.lang.model.element.VariableElement;
+import javax.lang.model.element.*;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.ExecutableType;
 import javax.lang.model.type.TypeKind;
@@ -160,6 +157,7 @@
   private final RequestFulfillmentRegistry requestFulfillmentRegistry;
   protected final MethodSpec.Builder constructor = constructorBuilder().addModifiers(PRIVATE);
   protected Optional<ClassName> builderName = Optional.empty();
+  private Map<Key, String> delegateFieldNames = new HashMap<>();
   private final OptionalFactories optionalFactories;
   private boolean done;
 
@@ -183,6 +181,7 @@
    * indexed by their {@link CanReleaseReferences @CanReleaseReferences} scope.
    */
   private ImmutableMap<Scope, MemberSelect> referenceReleasingProviderManagerFields;
+  private List<MethodSpec> initializationMethods;
 
   AbstractComponentWriter(
       Types types,
@@ -301,7 +300,6 @@ private void setInitializationState(BindingKey bindingKey, InitializationState s
   protected CodeBlock getReferenceReleasingProviderManagerExpression(Scope scope) {
     return referenceReleasingProviderManagerFields.get(scope).getExpressionFor(name);
   }
-
   /**
    * Constructs a {@link TypeSpec.Builder} that models the {@link BindingGraph} for this component.
    * This is only intended to be called once (and will throw on successive invocations). If the
@@ -320,6 +318,9 @@ protected CodeBlock getReferenceReleasingProviderManagerExpression(Scope scope)
     component.addMethod(constructor.build());
     if (graph.componentDescriptor().kind().isTopLevel()) {
       optionalFactories.addMembers(component);
+    }
+    for (MethodSpec initializationMethod : initializationMethods) {
+
     }
     done = true;
     return component;
@@ -341,7 +342,7 @@ protected void addBuilder() {
 
     Optional<BuilderSpec> builderSpec = graph.componentDescriptor().builderSpec();
     if (builderSpec.isPresent()) {
-      componentBuilder.addModifiers(PRIVATE);
+      componentBuilder.addModifiers(PUBLIC);
       addSupertype(componentBuilder, builderSpec.get().builderDefinitionType());
     } else {
       componentBuilder
@@ -381,6 +382,11 @@ protected void addBuilder() {
       componentBuilder.addField(builderField);
       builderFields.put(componentRequirement, builderField);
     }
+
+    for (ContributionBinding contributionBinding : graph.delegateRequirements()) {
+      createDelegateFieldAndMethod(builderName(), componentBuilder, contributionBinding, delegateFieldNames);
+    }
+
     return builderFields.build();
   }
 
@@ -610,11 +616,13 @@ private FieldSpec referenceReleasingProxyManagerField(Scope scope) {
 
   private void addFrameworkFields() {
     graph.resolvedBindings().values().forEach(this::addField);
+    for (ContributionBinding contributionBinding : graph.delegateRequirements()) {
+      createDelegateField(component, contributionBinding, delegateFieldNames);
+    }
   }
 
   private void addField(ResolvedBindings resolvedBindings) {
     BindingKey bindingKey = resolvedBindings.bindingKey();
-
     // If the binding can be satisfied with a static method call without dependencies or state,
     // no field is necessary.
     Optional<MemberSelect> staticMemberSelect = staticMemberSelect(resolvedBindings);
@@ -654,7 +662,6 @@ private FieldSpec addFrameworkField(
     if (useRawType) {
       contributionField.addAnnotation(AnnotationSpecs.suppressWarnings(RAWTYPES));
     }
-
     FieldSpec field = contributionField.build();
     component.addField(field);
     return field;
@@ -802,12 +809,11 @@ private static ClassName frameworkMapFactoryClassName(BindingType bindingType) {
 
   private void implementInterfaceMethods() {
     Set<MethodSignature> interfaceMethods = Sets.newHashSet();
-    for (ComponentMethodDescriptor componentMethod :
-        graph.componentDescriptor().componentMethods()) {
+    final ImmutableSet<ComponentMethodDescriptor> componentMethodDescriptors = graph.componentDescriptor().componentMethods();
+    for (ComponentMethodDescriptor componentMethod : componentMethodDescriptors) {
       if (componentMethod.dependencyRequest().isPresent()) {
         DependencyRequest interfaceRequest = componentMethod.dependencyRequest().get();
-        ExecutableElement methodElement =
-            MoreElements.asExecutable(componentMethod.methodElement());
+        ExecutableElement methodElement = MoreElements.asExecutable(componentMethod.methodElement());
         ExecutableType requestType =
             MoreTypes.asExecutable(
                 types.asMemberOf(
@@ -836,7 +842,19 @@ private void implementInterfaceMethods() {
               }
               // fall through
             default:
+              CodeBlock.Builder builder = CodeBlock.builder();
+              final boolean supportsTestDelegate = !componentMethod.methodElement().getReturnType().toString().equals(void.class.getName());
+              if (supportsTestDelegate) {
+                final String fieldName = getDelegateFieldName(interfaceRequest.key());
+                builder.beginControlFlow("if ($L != null)", CodeBlock.of(fieldName))
+                        .add("return $L.get($L)", CodeBlock.of(fieldName), codeBlock)
+                        .nextControlFlow("else");
+              }
               interfaceMethod.addStatement("return $L", codeBlock);
+              if (supportsTestDelegate) {
+                builder.endControlFlow();
+              }
+
               break;
           }
           component.addMethod(interfaceMethod.build());
@@ -894,12 +912,17 @@ private void addSubcomponents() {
 
   private void initializeFrameworkTypes() {
     ImmutableList.Builder<CodeBlock> codeBlocks = ImmutableList.builder();
+
+    codeBlocks.add(initDelegateFields());
+
     for (BindingKey bindingKey : graph.resolvedBindings().keySet()) {
       initializeFrameworkType(bindingKey).ifPresent(codeBlocks::add);
     }
     List<List<CodeBlock>> partitions =
         Lists.partition(codeBlocks.build(), INITIALIZATIONS_PER_INITIALIZE_METHOD);
 
+    initializationMethods = new ArrayList<>();
+
     UniqueNameSet methodNames = new UniqueNameSet();
     for (List<CodeBlock> partition : partitions) {
       String methodName = methodNames.getUniqueName("initialize");
@@ -918,8 +941,21 @@ private void initializeFrameworkTypes() {
       } else {
         constructor.addStatement("$L()", methodName);
       }
-      component.addMethod(initializeMethod.build());
+      final MethodSpec method = initializeMethod.build();
+      initializationMethods.add(method);
+      component.addMethod(method);
+    }
+  }
+
+  private CodeBlock initDelegateFields() {
+    List<CodeBlock> codeBlocks = new ArrayList<>();
+    for (ContributionBinding contributionBinding : graph.delegateRequirements()) {
+      try {
+          final String delegateFieldName = Util.getDelegateFieldName(contributionBinding.key());
+          codeBlocks.add(CodeBlock.of("this.$L = builder.$L;", delegateFieldName, delegateFieldName));
+      }catch(Exception e){}
     }
+    return CodeBlocks.concat(codeBlocks);
   }
 
   /**
@@ -1021,15 +1057,13 @@ private CodeBlock initializeDeferredDependencies(Binding binding) {
   private CodeBlock initializeDelegateFactoriesForUninitializedDependencies(Binding binding) {
     ImmutableList.Builder<CodeBlock> initializations = ImmutableList.builder();
 
-    for (BindingKey dependencyKey :
-        FluentIterable.from(binding.dependencies())
+    final ImmutableSet<BindingKey> bindingKeys = FluentIterable.from(binding.dependencies())
             .transform(DependencyRequest::bindingKey)
-            .toSet()) {
-      if (!getMemberSelect(dependencyKey).staticMember()
-          && getInitializationState(dependencyKey).equals(UNINITIALIZED)) {
-        initializations.add(
-            CodeBlock.of(
-                "this.$L = new $T();", getMemberSelectExpression(dependencyKey), DELEGATE_FACTORY));
+            .toSet();
+    for (BindingKey dependencyKey : bindingKeys) {
+      if (!getMemberSelect(dependencyKey).staticMember() && getInitializationState(dependencyKey).equals(UNINITIALIZED)) {
+        final CodeBlock codeBlock = CodeBlock.of("this.$L = new $T();", getMemberSelectExpression(dependencyKey), DELEGATE_FACTORY);
+        initializations.add(codeBlock);
         setInitializationState(dependencyKey, DELEGATED);
       }
     }
@@ -1092,6 +1126,7 @@ private CodeBlock delegateFactoryVariableExpression(BindingKey key) {
 
   private CodeBlock initializeFactoryForContributionBinding(ContributionBinding binding) {
     TypeName bindingKeyTypeName = TypeName.get(binding.key().type());
+    final String delegateFieldName = delegateFieldNames.get(binding.key());
     switch (binding.bindingKind()) {
       case COMPONENT:
         return CodeBlock.of(
@@ -1116,15 +1151,10 @@ private CodeBlock initializeFactoryForContributionBinding(ContributionBinding bi
           // We can easily include the raw type (no generics) + annotation type (no values),
           // using .class & String.format -- but that wouldn't be the whole story.
           // What should we do?
-          CodeBlock getMethodBody =
-              binding.nullableType().isPresent()
-                      || compilerOptions.nullableValidationKind().equals(Diagnostic.Kind.WARNING)
-                  ? CodeBlock.of("return $L;", callFactoryMethod)
-                  : CodeBlock.of(
-                      "return $T.checkNotNull($L, $S);",
-                      Preconditions.class,
-                      callFactoryMethod,
-                      CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD);
+
+          CodeBlock.Builder getMethodBodyBuilder = CodeBlock.builder();
+          getMethodBodyBuilder.add(getCodeBlock(binding, callFactoryMethod));
+
           return CodeBlock.of(
               Joiner.on('\n')
                   .join(
@@ -1141,7 +1171,7 @@ private CodeBlock initializeFactoryForContributionBinding(ContributionBinding bi
               /* 4 */ nullableAnnotation(binding.nullableType()),
               /* 5 */ TypeName.get(dependencyType.asType()),
               /* 6 */ dependencyVariable,
-              /* 7 */ getMethodBody);
+              /* 7 */ getMethodBodyBuilder.build());
         }
 
       case SUBCOMPONENT_BUILDER:
@@ -1163,17 +1193,19 @@ private CodeBlock initializeFactoryForContributionBinding(ContributionBinding bi
             /* 3 */ subcomponentName);
 
       case BUILDER_BINDING:
+        final CodeBlock parameter = getComponentContributionExpression(ComponentRequirement.forBinding(binding));
+        CodeBlock parameterDecision = CodeBlock.of("$L == null ? $L : $L.get()", delegateFieldName, parameter, delegateFieldName);
         return CodeBlock.of(
             "$T.$L($L)",
             InstanceFactory.class,
             binding.nullableType().isPresent() ? "createNullable" : "create",
-            getComponentContributionExpression(ComponentRequirement.forBinding(binding)));
+                parameterDecision);
 
       case INJECTION:
       case PROVISION:
         {
           List<CodeBlock> arguments =
-              Lists.newArrayListWithCapacity(binding.explicitDependencies().size() + 1);
+              Lists.newArrayListWithCapacity(binding.explicitDependencies().size() + 2);
           if (binding.requiresModuleInstance()) {
             arguments.add(
                 getComponentContributionExpression(
@@ -1181,6 +1213,10 @@ private CodeBlock initializeFactoryForContributionBinding(ContributionBinding bi
           }
           arguments.addAll(getDependencyArguments(binding));
 
+          if (delegateFieldName != null && bindingSupportsTestDelegate(binding)) {
+            arguments.add(0, CodeBlock.of(delegateFieldName));
+          }
+
           CodeBlock factoryCreate =
               CodeBlock.of(
                   "$T.create($L)",
@@ -1259,6 +1295,16 @@ private CodeBlock initializeFactoryForContributionBinding(ContributionBinding bi
     }
   }
 
+  private CodeBlock getCodeBlock(ContributionBinding binding, CodeBlock callFactoryMethod) {
+    return binding.nullableType().isPresent()
+            || compilerOptions.nullableValidationKind().equals(Diagnostic.Kind.WARNING)
+        ? CodeBlock.of("return $L;", callFactoryMethod)
+        : CodeBlock.of("return $T.checkNotNull($L, $S);",
+            Preconditions.class,
+            callFactoryMethod,
+            CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD);
+  }
+
   private TypeElement dependencyTypeForBinding(ContributionBinding binding) {
     return graph.componentDescriptor().dependencyMethodIndex().get(binding.bindingElement().get());
   }
@@ -1291,6 +1337,20 @@ private CodeBlock initializeMembersInjectorForBinding(MembersInjectionBinding bi
             "$T.create($L)",
             membersInjectorNameForType(binding.membersInjectedType()),
             makeParametersCodeBlock(getDependencyArguments(binding)));
+/*
+    switch (binding.injectionStrategy()) {
+      case NO_OP:
+        return CodeBlock.of("$T.noOp()", MEMBERS_INJECTORS);
+      case INJECT_MEMBERS:
+        final ImmutableList<CodeBlock> arguments = getDependencyArguments(binding);
+        return CodeBlock.of(
+            "$T.create($L)",
+            membersInjectorNameForType(binding.membersInjectedType()),
+            makeParametersCodeBlock(arguments));
+      default:
+        throw new AssertionError();
+    }
+*/
   }
 
   /**
@@ -1537,6 +1597,10 @@ private CodeBlock initializeFactoryForSyntheticOptionalBinding(ContributionBindi
     }
   }
 
+  public static String simpleVariableName(Element typeElement) {
+    return UPPER_CAMEL.to(LOWER_CAMEL, typeElement.getSimpleName().toString());
+  }
+
   /**
    * Initialization state for a factory field.
    */
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
index 8b695fda3..cf07ab0a5 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
@@ -24,6 +24,7 @@
 import static dagger.internal.codegen.ComponentDescriptor.Kind.PRODUCTION_COMPONENT;
 import static dagger.internal.codegen.ComponentDescriptor.isComponentContributionMethod;
 import static dagger.internal.codegen.ComponentDescriptor.isComponentProductionMethod;
+import static dagger.internal.codegen.ContributionBinding.Kind.PROVISION;
 import static dagger.internal.codegen.ContributionBinding.Kind.SYNTHETIC_MULTIBOUND_KINDS;
 import static dagger.internal.codegen.ContributionBinding.Kind.SYNTHETIC_OPTIONAL_BINDING;
 import static dagger.internal.codegen.Key.indexByKey;
@@ -35,6 +36,7 @@
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
 import com.google.auto.value.extension.memoized.Memoized;
+import com.google.common.base.Predicate;
 import com.google.common.base.VerifyException;
 import com.google.common.cache.Cache;
 import com.google.common.cache.CacheBuilder;
@@ -56,16 +58,8 @@
 import dagger.internal.codegen.Key.HasKey;
 import dagger.producers.Produced;
 import dagger.producers.Producer;
-import java.util.ArrayDeque;
-import java.util.Collection;
-import java.util.Deque;
-import java.util.HashSet;
-import java.util.LinkedHashSet;
-import java.util.List;
-import java.util.Map;
-import java.util.Optional;
-import java.util.Queue;
-import java.util.Set;
+
+import java.util.*;
 import java.util.concurrent.ExecutionException;
 import java.util.stream.Stream;
 import java.util.stream.StreamSupport;
@@ -173,7 +167,19 @@ TypeElement componentType() {
     }
     return requirements.build();
   }
-  /** Returns the {@link ComponentDescriptor}s for this component and its subcomponents. */
+
+  ImmutableSet<ContributionBinding> delegateRequirements() {
+    return SUBGRAPH_TRAVERSER
+            .preOrderTraversal(this)
+            .transformAndConcat(graph -> graph.resolvedBindings().values())
+            .filter(resolvedBindings -> resolvedBindings != null && resolvedBindings.owningComponent().equals(componentDescriptor()))
+            .transformAndConcat(ResolvedBindings::ownedContributionBindings)
+            .filter(Util::bindingSupportsTestDelegate)
+            .toSet();
+  }
+  /**
+   * Returns the {@link ComponentDescriptor}s for this component and its subcomponents.
+   */
   ImmutableSet<ComponentDescriptor> componentDescriptors() {
     return SUBGRAPH_TRAVERSER
         .preOrderTraversal(this)
@@ -337,6 +343,7 @@ private BindingGraph create(
       for (ComponentDescriptor subcomponent :
           Iterables.consumingIterable(requestResolver.subcomponentsToResolve)) {
         if (resolvedSubcomponents.add(subcomponent)) {
+          subcomponent.setParentDescriptor(componentDescriptor);
           subgraphs.add(create(Optional.of(requestResolver), subcomponent));
         }
       }
diff --git a/compiler/src/main/java/dagger/internal/codegen/BuilderModuleStatement.java b/compiler/src/main/java/dagger/internal/codegen/BuilderModuleStatement.java
new file mode 100644
index 000000000..290146399
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/BuilderModuleStatement.java
@@ -0,0 +1,129 @@
+package dagger.internal.codegen;
+
+import com.google.common.collect.ImmutableSet;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+import dagger.internal.Preconditions;
+
+import javax.lang.model.element.*;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Types;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.function.Function;
+import java.util.stream.Collectors;
+
+import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
+
+/**
+ * Created by Andy on 06.05.2017.
+ */
+public class BuilderModuleStatement extends ModuleStatement implements InitializationStatement {
+
+    private ExecutableElement executableElement;
+
+    public BuilderModuleStatement(Types types, TypeElement injector, ComponentDescriptor descriptor, Map<TypeElement, ExecutableElement> moduleMethodMap, Map<Key, VariableElement> providedParams) {
+        super(types, injector, descriptor, moduleMethodMap, providedParams);
+    }
+
+    public void setExecutableElement(ExecutableElement executableElement) {
+        this.executableElement = executableElement;
+    }
+
+    @Override
+    public CodeBlock get() {
+        List<CodeBlock> moduleInitStatements = new ArrayList<>();
+        final ImmutableSet<ModuleDescriptor> modules = descriptor.modules();
+
+        if (isSubComponent() && !descriptor.builderSpec().isPresent()) {
+
+            final Map<Key, ModuleDescriptor> moduleDescriptorMap = modules.stream()
+                    .collect(Collectors.toMap(p -> Key.builder(p.moduleElement().asType()).build(), Function.identity()));
+
+            final List<? extends VariableElement> parameters = executableElement.getParameters();
+            for (VariableElement parameter : parameters) {
+                final Key key = Key.builder(parameter.asType()).build();
+                if (!moduleDescriptorMap.containsKey(key)) {
+                    throw new IllegalStateException(String.format("%s | %s not found", moduleDescriptorMap.entrySet().toString(), parameter.asType().toString()));
+                }
+                final ModuleDescriptor moduleDescriptor = moduleDescriptorMap.get(key);
+                moduleInitStatements.add(processModule(moduleDescriptor));
+            }
+        }
+
+        return makeParametersCodeBlock(moduleInitStatements);
+    }
+
+    private CodeBlock processModule(ModuleDescriptor moduleDescriptor) {
+        final CodeBlock.Builder codeBuilder = CodeBlock.builder();
+        final TypeElement moduleElement = moduleDescriptor.moduleElement();
+        final ExecutableElement method = moduleMethodMap.get(moduleElement);
+        Map<Key, VariableElement> parameterMap;
+        if (method != null) {
+            parameterMap = buildParameterMapWithProvidingModuleMethod(method);
+        }else {
+            parameterMap = getConstructorParameterMap(moduleElement);
+        }
+        final List<CodeBlock> arguments = new ArrayList<>();
+        for (Map.Entry<Key, VariableElement> entry : parameterMap.entrySet()) {
+            if (resolvesToInjectorType(entry)) {
+                arguments.add(CodeBlock.of("$L", "this"));
+            } else {
+                final VariableElement variableElement = providedParams.get(entry.getKey());
+                if (variableElement == null) {
+                    throw new IllegalStateException("parameter is null in providedParams in ModuleStatement for param:" + entry.getValue().asType().toString() + " in module: " + moduleElement.getSimpleName().toString());
+                }
+                arguments.add(CodeBlock.of("$L", variableElement.getSimpleName().toString()));
+            }
+        }
+
+        if (method != null) {
+            codeBuilder.add("this.$L($L)",
+                    method.getSimpleName().toString(),
+                    makeParametersCodeBlock(arguments)
+            );
+        }else {
+            codeBuilder.add("new $T($L)",
+                    ClassName.get(moduleElement),
+                    makeParametersCodeBlock(arguments)
+            );
+        }
+        return codeBuilder.build();
+    }
+
+    private boolean isSubComponent() {
+        return descriptor.kind() == ComponentDescriptor.Kind.SUBCOMPONENT;
+    }
+
+    private Map<Key, VariableElement> buildParameterMapWithProvidingModuleMethod(ExecutableElement providingModuleMethod) {
+        return getMethodParameterMap(providingModuleMethod);
+    }
+
+    private boolean resolvesToInjectorType(Map.Entry<Key, VariableElement> entry) {
+        final TypeMirror type = entry.getKey().type();
+        return types.isAssignable(injector.asType(), type);
+    }
+
+    private Map<Key, VariableElement> getMethodParameterMap(ExecutableElement element) {
+        return element.getParameters()
+                .stream()
+                .collect(Collectors.toMap(e -> Key.builder(e.asType()).build(), Function.identity()));
+    }
+
+    private Map<Key, VariableElement> getConstructorParameterMap(TypeElement element) {
+        Map<Key, VariableElement> result = new HashMap<>();
+        final List<? extends Element> enclosedElements = element.getEnclosedElements();
+        for (Element enclosedElement : enclosedElements) {
+            if (enclosedElement.getKind() == ElementKind.CONSTRUCTOR) {
+                ExecutableElement executableElement = (ExecutableElement) enclosedElement;
+                final List<? extends VariableElement> parameters = executableElement.getParameters();
+                for (VariableElement parameter : parameters) {
+                    result.put(Key.builder(parameter.asType()).build(), parameter);
+                }
+            }
+        }
+        return result;
+    }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/BuilderStatement.java b/compiler/src/main/java/dagger/internal/codegen/BuilderStatement.java
new file mode 100644
index 000000000..1b316faf0
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/BuilderStatement.java
@@ -0,0 +1,94 @@
+package dagger.internal.codegen;
+
+import com.google.auto.common.MoreElements;
+import com.google.auto.common.MoreTypes;
+import com.google.common.collect.ImmutableBiMap;
+import com.google.common.collect.ImmutableSet;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+import dagger.Component;
+import dagger.Subcomponent;
+
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.TypeMirror;
+import java.util.List;
+
+public class BuilderStatement implements InitializationStatement {
+
+    private final BindingGraph.Factory graphFactory;
+    private ComponentDescriptor descriptor;
+    private ExecutableElement providingMethod;
+    private BuilderModuleStatement builderModuleStatement;
+
+    public BuilderStatement(ComponentDescriptor descriptor, ExecutableElement providingMethod, BuilderModuleStatement builderModuleStatement, BindingGraph.Factory graphFactory) {
+        this.descriptor = descriptor;
+        this.providingMethod = providingMethod;
+        this.builderModuleStatement = builderModuleStatement;
+        this.graphFactory = graphFactory;
+    }
+
+    @Override
+    public CodeBlock get() {
+        if (descriptor.kind() == ComponentDescriptor.Kind.SUBCOMPONENT) {
+            CodeBlock.Builder codeBlockBuilder = CodeBlock.builder();
+            final ComponentDescriptor parentDescriptor = descriptor.getParentDescriptor();
+            final String subComponentClassName = resolveClassName(descriptor);
+            final ClassName className = ClassName.bestGuess(subComponentClassName);
+            codeBlockBuilder.add("(($T)", className);
+            final List<? extends VariableElement> parameters = providingMethod.getParameters();
+            for (VariableElement parameter : parameters) {
+                final TypeElement element = MoreTypes.asTypeElement(parameter.asType());
+                if (isComponentOrSubcomponent(element)) {
+                    final ImmutableSet<ComponentDescriptor.ComponentMethodDescriptor> componentMethodDescriptors = parentDescriptor.componentMethods();
+                    for (ComponentDescriptor.ComponentMethodDescriptor componentMethodDescriptor : componentMethodDescriptors) {
+                        final ExecutableElement executableElement = componentMethodDescriptor.methodElement();
+                        TypeMirror typeToSearch = descriptor.componentDefinitionType().asType();
+                        if (descriptor.builderSpec().isPresent()) {
+                            typeToSearch = descriptor.builderSpec().get().builderDefinitionType().asType();
+                        }
+                        if (executableElement.getReturnType().toString().equals(typeToSearch.toString())) {
+                            final String parameterName = parameter.getSimpleName().toString();
+                            final String methodName = executableElement.getSimpleName().toString();
+                            if (!descriptor.builderSpec().isPresent() ) {
+                                // check if method has parameters ...
+                                builderModuleStatement.setExecutableElement(executableElement);
+                                return codeBlockBuilder.add("$L.$L($L))\n", parameterName, methodName, builderModuleStatement.get()).build();
+                            }else {
+                                return codeBlockBuilder.add("$L.$L()\n", parameterName, methodName).build();
+                            }
+                        }
+                    }
+                }
+            }
+        }
+        final ClassName componentClassName = Util.getDaggerComponentClassName(descriptor.componentDefinitionType());
+        return CodeBlock.of("(($T)$T.builder()\n", componentClassName, componentClassName);
+    }
+
+    private String resolveClassName(ComponentDescriptor descriptor) {
+        if (descriptor.kind() == ComponentDescriptor.Kind.COMPONENT) {
+            final ClassName daggerComponentClassName = Util.getDaggerComponentClassName(descriptor.componentDefinitionType());
+            return daggerComponentClassName.packageName() + "." + daggerComponentClassName.simpleName();
+        }else if (descriptor.kind() == ComponentDescriptor.Kind.SUBCOMPONENT) {
+            final String parentClassName = resolveClassName(descriptor.getParentDescriptor());
+            final BindingGraph parentGraph = graphFactory.create(descriptor.getParentDescriptor());
+            final ImmutableBiMap<ComponentDescriptor, String> subcomponentNamesMap =
+                    new ComponentWriter.UniqueSubcomponentNamesGenerator(parentGraph).generate();
+            final String s = subcomponentNamesMap.get(descriptor);
+            if (s == null) {
+                throw new NullPointerException("s is null | " + subcomponentNamesMap.values().toString() + "|" + descriptor.componentDefinitionType().asType().toString());
+            }
+            return parentClassName + "." + s + "Impl";
+        }else {
+            throw new IllegalStateException("unknown");
+        }
+    }
+
+    private boolean isComponentOrSubcomponent(TypeElement element) {
+        return MoreElements.isAnnotationPresent(element, Component.class) || MoreElements.isAnnotationPresent(element, Subcomponent.class);
+    }
+
+
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
index 86f4a48ba..d2e226726 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
@@ -79,7 +79,10 @@
  * @since 2.0
  */
 @AutoValue
-abstract class ComponentDescriptor {
+public abstract class ComponentDescriptor {
+
+  private ComponentDescriptor parent;
+
   ComponentDescriptor() {}
 
   enum Kind {
@@ -287,6 +290,14 @@ private static void addTransitiveModules(
   abstract ImmutableBiMap<ComponentMethodDescriptor, ComponentDescriptor>
       subcomponentsByFactoryMethod();
 
+  void setParentDescriptor(ComponentDescriptor parent) {
+      this.parent = parent;
+  }
+
+  ComponentDescriptor getParentDescriptor() {
+      return this.parent;
+  }
+
   /**
    * All {@linkplain Subcomponent direct child} components that are declared by a subcomponent
    * builder method.
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
index dadb44639..b04d2c401 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
@@ -39,11 +39,11 @@
   private final CompilerOptions compilerOptions;
 
   ComponentGenerator(
-      Filer filer,
-      Elements elements,
-      Types types,
-      Key.Factory keyFactory,
-      CompilerOptions compilerOptions) {
+          Filer filer,
+          Elements elements,
+          Types types,
+          Key.Factory keyFactory,
+          CompilerOptions compilerOptions) {
     super(filer, elements);
     this.types = types;
     this.elements = elements;
@@ -54,9 +54,7 @@
   @Override
   ClassName nameGeneratedType(BindingGraph input) {
     ClassName componentDefinitionClassName = ClassName.get(input.componentType());
-    String componentName =
-        "Dagger" + Joiner.on('_').join(componentDefinitionClassName.simpleNames());
-    return componentDefinitionClassName.topLevelClassName().peerClass(componentName);
+    return Util.getDaggerComponentClassName(componentDefinitionClassName);
   }
 
   @Override
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentInfo.java b/compiler/src/main/java/dagger/internal/codegen/ComponentInfo.java
new file mode 100644
index 000000000..1e94307dc
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentInfo.java
@@ -0,0 +1,172 @@
+package dagger.internal.codegen;
+
+import com.google.common.collect.ImmutableSet;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.TypeSpec;
+import dagger.Module;
+
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ElementKind;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
+import java.util.ArrayList;
+import java.util.List;
+
+import static dagger.internal.codegen.AbstractComponentWriter.simpleVariableName;
+
+/**
+ * Created by Andy on 12.05.2017.
+ */
+public abstract class ComponentInfo {
+
+    protected final TypeElement component;
+    protected final ComponentDescriptor descriptor;
+    protected final BindingGraph bindingGraph;
+    protected List<ComponentInfo> infos = new ArrayList<>();
+
+    public static ComponentInfo forSpec(TypeElement component, ComponentDescriptor.Factory componentDescriptorFactory, BindingGraph.Factory bindingGraphFactory) {
+        return createSpecComponentInfo(component, componentDescriptorFactory, bindingGraphFactory);
+    }
+
+    public static ComponentInfo forGenerator(TypeElement component, ComponentDescriptor.Factory componentDescriptorFactory, BindingGraph.Factory bindingGraphFactory) {
+        return createGeneratorComponentInfo(component, componentDescriptorFactory, bindingGraphFactory);
+    }
+
+    public static TriggerComponentInfo forTrigger(TypeElement component, ComponentDescriptor.Factory componentDescriptorFactory, BindingGraph.Factory bindingGraphFactory) {
+        return createTriggerComponentInfo(component, componentDescriptorFactory, bindingGraphFactory);
+    }
+
+    private static TriggerComponentInfo createTriggerComponentInfo(TypeElement component,
+                                                         ComponentDescriptor.Factory componentDescriptorFactory,
+                                                         BindingGraph.Factory bindingGraphFactory) {
+        final ComponentDescriptor descriptor = componentDescriptorFactory.forComponent(component);
+        final BindingGraph bindingGraph = bindingGraphFactory.create(descriptor);
+        final TriggerComponentInfo componentInfo = new TriggerComponentInfo(component, descriptor, bindingGraph, bindingGraphFactory);
+        for (BindingGraph subGraph : bindingGraph.subgraphs()) {
+            componentInfo.add(new TriggerComponentInfo(subGraph.componentType(), subGraph.componentDescriptor(), subGraph, bindingGraphFactory));
+            createTriggerSubcomponentInfo(subGraph, componentInfo, bindingGraphFactory);
+        }
+        return componentInfo;
+    }
+
+    private static void createTriggerSubcomponentInfo(BindingGraph bindingGraph, ComponentInfo componentMethodOverrider, BindingGraph.Factory factory) {
+        for (BindingGraph subGraph : bindingGraph.subgraphs()) {
+            ComponentDescriptor subcomponentDescriptor = subGraph.componentDescriptor();
+            final ComponentInfo componentInfo =
+                    new TriggerComponentInfo(subcomponentDescriptor.componentDefinitionType(), subcomponentDescriptor, subGraph, factory);
+            componentMethodOverrider.add(componentInfo);
+            createTriggerSubcomponentInfo(subGraph, componentInfo, factory);
+        }
+    }
+
+    private static ComponentInfo createSpecComponentInfo(TypeElement component,
+                                                         ComponentDescriptor.Factory componentDescriptorFactory,
+                                                         BindingGraph.Factory bindingGraphFactory) {
+        final ComponentDescriptor descriptor = componentDescriptorFactory.forComponent(component);
+        final BindingGraph bindingGraph = bindingGraphFactory.create(descriptor);
+        final ComponentInfo componentMethodOverrider = new SpecComponentInfo(component, descriptor, bindingGraph);
+        createSpecSubcomponentInfo(descriptor, bindingGraphFactory, componentMethodOverrider);
+        return componentMethodOverrider;
+    }
+
+    private static void createSpecSubcomponentInfo(ComponentDescriptor descriptor, BindingGraph.Factory bindingGraphFactory, ComponentInfo componentMethodOverrider) {
+        final ImmutableSet<ComponentDescriptor> subcomponents = descriptor.subcomponents();
+        for (ComponentDescriptor subcomponentDescriptor : subcomponents) {
+            final BindingGraph bindingGraph = bindingGraphFactory.create(subcomponentDescriptor);
+            final ComponentInfo subcomponentOverrider =
+                    new SpecComponentInfo(subcomponentDescriptor.componentDefinitionType(), subcomponentDescriptor, bindingGraph);
+            componentMethodOverrider.add(subcomponentOverrider);
+            createSpecSubcomponentInfo(subcomponentDescriptor, bindingGraphFactory, subcomponentOverrider);
+        }
+    }
+
+    private static ComponentInfo createGeneratorComponentInfo(TypeElement component,
+                                                     ComponentDescriptor.Factory componentDescriptorFactory,
+                                                     BindingGraph.Factory bindingGraphFactory) {
+        final ComponentDescriptor descriptor = componentDescriptorFactory.forComponent(component);
+        final BindingGraph bindingGraph = bindingGraphFactory.create(descriptor);
+        final ComponentInfo componentInfo = new GeneratorComponentInfo(component, descriptor, bindingGraph);
+        for (BindingGraph subGraph : bindingGraph.subgraphs()) {
+            final ComponentDescriptor subDescriptor = subGraph.componentDescriptor();
+            componentInfo.add(new GeneratorComponentInfo(subDescriptor.componentDefinitionType(), subDescriptor, subGraph));
+            createGeneratorSubcomponentInfo(subGraph, componentInfo);
+        }
+        return componentInfo;
+    }
+
+    private static void createGeneratorSubcomponentInfo(BindingGraph bindingGraph, ComponentInfo componentInfo) {
+        for (BindingGraph subGraph : bindingGraph.subgraphs()) {
+            final ComponentDescriptor subDescriptor = subGraph.componentDescriptor();
+            final ComponentInfo subcomponentInfo =
+                    new GeneratorComponentInfo(subDescriptor.componentDefinitionType(), subDescriptor, subGraph);
+            componentInfo.add(subcomponentInfo);
+            createGeneratorSubcomponentInfo(subGraph, subcomponentInfo);
+        }
+    }
+
+    protected ComponentInfo(TypeElement component, ComponentDescriptor descriptor, BindingGraph bindingGraph) {
+        this.component = component;
+        this.descriptor = descriptor;
+        this.bindingGraph = bindingGraph;
+    }
+
+    public void add(ComponentInfo info) {
+        this.infos.add(info);
+    }
+
+    public void process(TypeSpec.Builder builder) {
+        for (ComponentInfo info : infos) {
+            info.process(builder);
+        }
+    }
+
+    public TypeElement getComponent() {
+        return component;
+    }
+
+    public ComponentDescriptor getDescriptor() {
+        return descriptor;
+    }
+
+    public BindingGraph getBindingGraph() {
+        return bindingGraph;
+    }
+
+    protected boolean autoCreate(TypeElement moduleElement) {
+        final Module moduleAnnotation = moduleElement.getAnnotation(Module.class);
+        return moduleAnnotation != null && moduleAnnotation.autoCreate();
+    }
+
+    protected boolean hasNotOnlyNoArgConstructor(TypeElement typeElement, boolean autoCreate) {
+        if (!autoCreate) {
+            return true;
+        }
+        for (Element element : typeElement.getEnclosedElements()) {
+            if (element.getKind() == ElementKind.CONSTRUCTOR) {
+                ExecutableElement executableElement = (ExecutableElement) element;
+                if (!executableElement.getParameters().isEmpty()) {
+                    return true;
+                }
+            }
+        }
+        return false;
+    }
+
+    protected ClassName getBuilderClassName(TypeElement component) {
+        ClassName builderClassName;
+        if (descriptor.kind() == ComponentDescriptor.Kind.COMPONENT) {
+            if (descriptor.builderSpec().isPresent()) {
+                builderClassName = ClassName.get(descriptor.builderSpec().get().builderDefinitionType());
+            }else {
+                builderClassName = Util.getDaggerComponentClassName(ClassName.get(component)).nestedClass("Builder");
+            }
+        }else {
+            if (descriptor.builderSpec().isPresent()) {
+                builderClassName = ClassName.get(descriptor.builderSpec().get().builderDefinitionType());
+            }else {
+                throw new IllegalStateException("builder spec missing for: " + simpleVariableName(component));
+            }
+        }
+        return builderClassName;
+    }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java
index 46b07dce3..44f8b81cf 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java
@@ -25,18 +25,19 @@
 import com.google.common.collect.Multimaps;
 import com.google.common.collect.SetMultimap;
 import dagger.Component;
+import dagger.Config;
 import dagger.Subcomponent;
 import dagger.internal.codegen.ComponentDescriptor.Factory;
 import dagger.internal.codegen.ComponentValidator.ComponentValidationReport;
 import dagger.producers.ProductionComponent;
 import dagger.producers.ProductionSubcomponent;
 import java.lang.annotation.Annotation;
+import java.util.HashSet;
 import java.util.Map;
 import java.util.Set;
 import javax.annotation.processing.Messager;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.TypeElement;
-import javax.tools.Diagnostic.Kind;
 
 /**
  * A {@link ProcessingStep} that is responsible for dealing with a component or production component
@@ -56,6 +57,11 @@
   private final BindingGraph.Factory bindingGraphFactory;
   private final ComponentGenerator componentGenerator;
 
+  public static Set<TypeElement> allComponents = new HashSet<>();
+  public static TypeElement appClass;
+
+  public static boolean generatedAllComponents = true;
+
   ComponentProcessingStep(
       ComponentDescriptor.Kind componentKind,
       Messager messager,
@@ -82,6 +88,7 @@
   @Override
   public Set<Class<? extends Annotation>> annotations() {
     return ImmutableSet.of(
+        Config.class,
         Component.class,
         Component.Builder.class,
         ProductionComponent.class,
@@ -95,6 +102,14 @@
   @Override
   public final ImmutableSet<Element> process(
       SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
+
+    if (appClass == null) {
+      final Set<Element> elements = elementsByAnnotation.get(Config.class);
+      if (!elements.isEmpty()) {
+        appClass = MoreElements.asType(elements.iterator().next());
+      }
+    }
+
     ImmutableSet.Builder<Element> rejectedElements = ImmutableSet.builder();
 
     Map<Element, ValidationReport<TypeElement>> builderReportsByComponent =
@@ -116,7 +131,9 @@
     Map<Element, ValidationReport<TypeElement>> reportsBySubcomponent =
         processSubcomponents(subcomponentElements, subcomponentBuilderElements);
 
-    for (Element element : elementsByAnnotation.get(componentKind.annotationType())) {
+
+    final Set<Element> elements = elementsByAnnotation.get(componentKind.annotationType());
+    for (Element element : elements) {
       TypeElement componentTypeElement = MoreElements.asType(element);
       try {
         ComponentValidationReport validationReport =
@@ -143,11 +160,19 @@
             }
           }
         }
+        allComponents.add(componentTypeElement);
       } catch (TypeNotPresentException e) {
         rejectedElements.add(componentTypeElement);
       }
     }
-    return rejectedElements.build();
+
+    final ImmutableSet<Element> failedElements = rejectedElements.build();
+
+    if (elements.isEmpty() && failedElements.isEmpty()) {
+      generatedAllComponents = true;
+    }
+
+    return failedElements;
   }
 
   private void generateComponent(BindingGraph bindingGraph) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
index b47fbf983..6bb5dd98d 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -21,14 +21,26 @@
 
 import com.google.auto.common.BasicAnnotationProcessor;
 import com.google.auto.service.AutoService;
+import com.google.common.collect.HashMultimap;
+import com.google.common.collect.HashMultiset;
 import com.google.common.collect.ImmutableList;
+import com.google.common.collect.MultimapBuilder;
 import com.google.googlejavaformat.java.filer.FormattingFiler;
+import com.squareup.javapoet.JavaFile;
+import dagger.Component;
+import dagger.Config;
+import dagger.Injector;
+
+import java.lang.annotation.Annotation;
+import java.util.Arrays;
 import java.util.Set;
 import javax.annotation.processing.Filer;
 import javax.annotation.processing.Messager;
 import javax.annotation.processing.Processor;
 import javax.annotation.processing.RoundEnvironment;
 import javax.lang.model.SourceVersion;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.TypeElement;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 
@@ -46,6 +58,15 @@
   private InjectBindingRegistry injectBindingRegistry;
   private FactoryGenerator factoryGenerator;
   private MembersInjectorGenerator membersInjectorGenerator;
+  private StubGenerator stubGenerator;
+  private TestRegistry testRegistry = new TestRegistry();
+  private MultipleSourceFileGenerator<ProvisionBinding> multipleGenerator;
+  private ComponentDescriptor.Factory componentDescriptorFactory;
+  private Types types;
+  private Elements elements;
+  private Filer filer;
+  private Messager messager;
+  private BindingGraph.Factory bindingGraphFactory;
 
   @Override
   public SourceVersion getSupportedSourceVersion() {
@@ -59,11 +80,11 @@ public SourceVersion getSupportedSourceVersion() {
 
   @Override
   protected Iterable<? extends ProcessingStep> initSteps() {
-    Messager messager = processingEnv.getMessager();
-    Types types = processingEnv.getTypeUtils();
-    Elements elements = processingEnv.getElementUtils();
+    messager = processingEnv.getMessager();
+    types = processingEnv.getTypeUtils();
+    elements = processingEnv.getElementUtils();
+    filer = new FormattingFiler(processingEnv.getFiler());
     CompilerOptions compilerOptions = CompilerOptions.create(processingEnv, elements);
-    Filer filer =  new FormattingFiler(processingEnv.getFiler());
 
     KeyFormatter keyFormatter = new KeyFormatter();
     MethodSignatureFormatter methodSignatureFormatter = new MethodSignatureFormatter(types);
@@ -76,6 +97,18 @@ public SourceVersion getSupportedSourceVersion() {
 
     InjectValidator injectValidator = new InjectValidator(types, elements, compilerOptions);
     InjectValidator injectValidatorWhenGeneratingCode = injectValidator.whenGeneratingCode();
+/*
+    ModuleValidator moduleValidator =
+        new ModuleValidator(types, elements, methodSignatureFormatter);
+    BuilderValidator builderValidator = new BuilderValidator(elements, types);
+    ComponentValidator subcomponentValidator =
+        ComponentValidator.createForSubcomponent(
+                elements, types, moduleValidator, builderValidator);
+    ComponentValidator componentValidator =
+        ComponentValidator.createForComponent(
+                elements, types, moduleValidator, subcomponentValidator, builderValidator);
+    MapKeyValidator mapKeyValidator = new MapKeyValidator();
+*/
     ProvidesMethodValidator providesMethodValidator = new ProvidesMethodValidator(elements, types);
     ProducesMethodValidator producesMethodValidator = new ProducesMethodValidator(elements, types);
     BindsMethodValidator bindsMethodValidator = new BindsMethodValidator(elements, types);
@@ -94,8 +127,8 @@ public SourceVersion getSupportedSourceVersion() {
             bindsOptionalOfMethodValidator);
     MultibindingsValidator multibindingsValidator =
         new MultibindingsValidator(
-            elements,
-            types,
+                elements,
+                types,
             keyFactory,
             keyFormatter,
             methodSignatureFormatter,
@@ -116,8 +149,11 @@ public SourceVersion getSupportedSourceVersion() {
             elements, types, moduleValidator, subcomponentValidator, builderValidator);
     MapKeyValidator mapKeyValidator = new MapKeyValidator();
 
+    this.stubGenerator =
+            new StubGenerator(filer, elements, types);
     this.factoryGenerator =
         new FactoryGenerator(filer, elements, compilerOptions, injectValidatorWhenGeneratingCode);
+    this.multipleGenerator = new MultipleSourceFileGenerator<>(filer, elements, Arrays.asList(this.stubGenerator, this.factoryGenerator));
     this.membersInjectorGenerator =
         new MembersInjectorGenerator(filer, elements, injectValidatorWhenGeneratingCode);
     ComponentGenerator componentGenerator =
@@ -150,9 +186,9 @@ public SourceVersion getSupportedSourceVersion() {
 
     this.injectBindingRegistry =
         new InjectBindingRegistry(
-            elements,
-            types,
-            messager,
+                elements,
+                types,
+                messager,
             injectValidator,
             keyFactory,
             provisionBindingFactory,
@@ -161,7 +197,7 @@ public SourceVersion getSupportedSourceVersion() {
 
     ModuleDescriptor.Factory moduleDescriptorFactory =
         new ModuleDescriptor.Factory(
-            elements,
+                elements,
             provisionBindingFactory,
             productionBindingFactory,
             multibindingDeclarationFactory,
@@ -169,16 +205,15 @@ public SourceVersion getSupportedSourceVersion() {
             subcomponentDeclarationFactory,
             optionalBindingDeclarationFactory);
 
-    ComponentDescriptor.Factory componentDescriptorFactory = new ComponentDescriptor.Factory(
-        elements, types, dependencyRequestFactory, moduleDescriptorFactory);
+    componentDescriptorFactory = new ComponentDescriptor.Factory(
+            elements, types, dependencyRequestFactory, moduleDescriptorFactory);
 
-    BindingGraph.Factory bindingGraphFactory =
-        new BindingGraph.Factory(
+    bindingGraphFactory = new BindingGraph.Factory(
             elements,
-            injectBindingRegistry,
-            keyFactory,
-            provisionBindingFactory,
-            productionBindingFactory);
+        injectBindingRegistry,
+        keyFactory,
+        provisionBindingFactory,
+        productionBindingFactory);
 
     AnnotationCreatorGenerator annotationCreatorGenerator =
         new AnnotationCreatorGenerator(filer, elements);
@@ -190,8 +225,8 @@ public SourceVersion getSupportedSourceVersion() {
         new ComponentHierarchyValidator(compilerOptions, elements);
     BindingGraphValidator bindingGraphValidator =
         new BindingGraphValidator(
-            elements,
-            types,
+                elements,
+                types,
             compilerOptions,
             injectValidatorWhenGeneratingCode,
             injectBindingRegistry,
@@ -203,37 +238,41 @@ public SourceVersion getSupportedSourceVersion() {
 
     return ImmutableList.of(
         new MapKeyProcessingStep(
-            messager, types, mapKeyValidator, annotationCreatorGenerator, unwrappedMapKeyGenerator),
+                messager, types, mapKeyValidator, annotationCreatorGenerator, unwrappedMapKeyGenerator),
         new ForReleasableReferencesValidator(messager),
         new CanReleaseReferencesProcessingStep(
-            messager, canReleaseReferencesValidator, annotationCreatorGenerator),
+                messager, canReleaseReferencesValidator, annotationCreatorGenerator),
         new InjectProcessingStep(injectBindingRegistry),
         new MonitoringModuleProcessingStep(messager, monitoringModuleGenerator),
         new ProductionExecutorModuleProcessingStep(messager, productionExecutorModuleGenerator),
         new MultibindingAnnotationsProcessingStep(messager),
         new BindsInstanceProcessingStep(messager),
-        moduleProcessingStep(messager, moduleValidator, provisionBindingFactory, factoryGenerator),
+        moduleProcessingStep(
+                messager,
+            moduleValidator,
+            provisionBindingFactory,
+            this.multipleGenerator),
         new ComponentProcessingStep(
             ComponentDescriptor.Kind.COMPONENT,
-            messager,
+                messager,
             componentValidator,
             subcomponentValidator,
             builderValidator,
             componentHierarchyValidator,
             bindingGraphValidator,
-            componentDescriptorFactory,
-            bindingGraphFactory,
+                componentDescriptorFactory,
+                bindingGraphFactory,
             componentGenerator),
         producerModuleProcessingStep(
-            messager,
+                messager,
             moduleValidator,
             provisionBindingFactory,
-            factoryGenerator,
+            this.multipleGenerator,
             productionBindingFactory,
             producerFactoryGenerator),
         new ComponentProcessingStep(
             ComponentDescriptor.Kind.PRODUCTION_COMPONENT,
-            messager,
+                messager,
             componentValidator,
             subcomponentValidator,
             builderValidator,
@@ -243,7 +282,18 @@ public SourceVersion getSupportedSourceVersion() {
             bindingGraphFactory,
             componentGenerator),
         new MultibindingsProcessingStep(messager, multibindingsValidator),
-        new BindingMethodProcessingStep(messager, anyBindingMethodValidator));
+        new BindingMethodProcessingStep(messager, anyBindingMethodValidator),
+            new InjectorProcessingStep(
+                    types,
+                    messager,
+                    new InjectorGenerator(filer, types, elements, componentDescriptorFactory, bindingGraphFactory, new TestClassGenerator(filer, elements), testRegistry, new Decorator.Factory(filer, elements, bindingGraphFactory, testRegistry)),
+                    ComponentDescriptor.Kind.COMPONENT,
+                    bindingGraphFactory,
+                    componentDescriptorFactory,
+                    new DependencySpecGenerator(filer, elements, componentDescriptorFactory, bindingGraphFactory),
+                    new DependencyInjectorGenerator(filer, elements, bindingGraphFactory, componentDescriptorFactory)
+            )
+    );
   }
 
   @Override
@@ -251,7 +301,7 @@ protected void postRound(RoundEnvironment roundEnv) {
     if (!roundEnv.processingOver()) {
       try {
         injectBindingRegistry.generateSourcesForRequiredBindings(
-            factoryGenerator, membersInjectorGenerator);
+            multipleGenerator, membersInjectorGenerator);
       } catch (SourceFileGenerationException e) {
         e.printMessageTo(processingEnv.getMessager());
       }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentRequirement.java b/compiler/src/main/java/dagger/internal/codegen/ComponentRequirement.java
index 428deef86..cee962d32 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentRequirement.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentRequirement.java
@@ -25,6 +25,8 @@
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Equivalence;
+import dagger.Module;
+
 import java.util.Optional;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.TypeMirror;
@@ -108,22 +110,28 @@ NullPolicy nullPolicy(Elements elements, Types types) {
   /** Returns the name for this requirement that could be used as a variable. */
   abstract String variableName();
 
+  abstract boolean autoCreate();
+
   static ComponentRequirement forDependency(TypeMirror type) {
     return new AutoValue_ComponentRequirement(
         Kind.DEPENDENCY,
         MoreTypes.equivalence().wrap(checkNotNull(type)),
         Optional.empty(),
         Optional.empty(),
-        simpleVariableName(MoreTypes.asTypeElement(type)));
+        simpleVariableName(MoreTypes.asTypeElement(type)),
+        false);
   }
 
   static ComponentRequirement forModule(TypeMirror type) {
+    final Module annotation = MoreTypes.asTypeElement(type).getAnnotation(Module.class);
     return new AutoValue_ComponentRequirement(
         Kind.MODULE,
         MoreTypes.equivalence().wrap(checkNotNull(type)),
         Optional.empty(),
         Optional.empty(),
-        simpleVariableName(MoreTypes.asTypeElement(type)));
+        simpleVariableName(MoreTypes.asTypeElement(type)),
+            annotation != null && annotation.autoCreate()
+    );
   }
 
   static ComponentRequirement forBinding(Key key, boolean nullable, String variableName) {
@@ -132,7 +140,8 @@ static ComponentRequirement forBinding(Key key, boolean nullable, String variabl
         key.wrappedType(),
         nullable ? Optional.of(NullPolicy.ALLOW) : Optional.empty(),
         Optional.of(key),
-        variableName);
+        variableName,
+        false);
   }
 
   static ComponentRequirement forBinding(ContributionBinding binding) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentStatement.java b/compiler/src/main/java/dagger/internal/codegen/ComponentStatement.java
new file mode 100644
index 000000000..eb5c23a56
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentStatement.java
@@ -0,0 +1,70 @@
+package dagger.internal.codegen;
+
+import com.google.common.collect.ImmutableSet;
+import com.google.errorprone.annotations.Var;
+import com.squareup.javapoet.CodeBlock;
+
+import javax.lang.model.element.*;
+import javax.lang.model.util.Types;
+import java.util.*;
+
+import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
+
+/**
+ * Created by Andy on 06.05.2017.
+ */
+public class ComponentStatement implements InitializationStatement{
+
+    private Types types;
+    private TypeElement injector;
+    private ComponentDescriptor.Factory factory;
+    private ComponentDescriptor componentDescriptor;
+    private Map<Key, VariableElement> providedParams;
+
+    public ComponentStatement(Types types, TypeElement injector, ComponentDescriptor.Factory factory, ComponentDescriptor componentDescriptor, Map<Key, VariableElement> providedParams) {
+        this.types = types;
+        this.injector = injector;
+        this.factory = factory;
+        this.componentDescriptor = componentDescriptor;
+        this.providedParams = providedParams;
+    }
+
+    @Override
+    public CodeBlock get() {
+        final CodeBlock.Builder builder = CodeBlock.builder();
+        return builder.build();
+        /*final ImmutableSet<TypeElement> dependencies = componentDescriptor.dependencies();
+        for (TypeElement element : dependencies) {
+            final ComponentDescriptor dependencyComponentDescriptor = factory.forComponent(element);
+            final Optional<ComponentDescriptor.BuilderSpec> builderSpec = dependencyComponentDescriptor.builderSpec();
+            String methodName = builderSpec.isPresent() ? builderSpec.get().methodMap().get(element).getSimpleName().toString() : Util.lowerCaseFirstLetter(element.getSimpleName().toString());
+            final HashMap<String, ExecutableElement> providingMethods = Util.findProvidingMethods(types, injector);
+            if (!providingMethods.containsKey(element.toString())) {
+                throw new IllegalStateException(String.format("providing method not found for component: %s", element.getSimpleName().toString()));
+            }
+
+            final Key componentKey = Key.builder(element.asType()).build();
+            if (providedParams.containsKey(componentKey)) {
+                builder.add(".$L($L)", CodeBlock.of(methodName), CodeBlock.of(providedParams.get(componentKey).getSimpleName().toString()));
+                continue;
+            }
+
+            final ExecutableElement executableElement = providingMethods.get(element.asType().toString());
+
+            List<CodeBlock> arguments = new ArrayList<>();
+            final List<? extends VariableElement> parameters = executableElement.getParameters();
+            for (VariableElement parameter : parameters) {
+                final Key key = Key.builder(parameter.asType()).build();
+                if (!providedParams.containsKey(key)) {
+                    throw new IllegalStateException(String.format("parameter '%s' not found", parameter.getSimpleName().toString()));
+                }
+                final VariableElement variableElement = providedParams.get(key);
+                arguments.add(CodeBlock.of("$L", CodeBlock.of(variableElement.getSimpleName().toString())));
+            }
+
+            builder.add(".$L(this.$L($L))\n", CodeBlock.of(methodName), CodeBlock.of(executableElement.getSimpleName().toString()), makeParametersCodeBlock(arguments));
+        }
+        return builder.build();*/
+    }
+
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java
index 67ffa5e5e..9b40783a7 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java
@@ -48,12 +48,12 @@
 final class ComponentWriter extends AbstractComponentWriter {
 
   ComponentWriter(
-      Types types,
-      Elements elements,
-      Key.Factory keyFactory,
-      CompilerOptions compilerOptions,
-      ClassName name,
-      BindingGraph graph) {
+          Types types,
+          Elements elements,
+          Key.Factory keyFactory,
+          CompilerOptions compilerOptions,
+          ClassName name,
+          BindingGraph graph) {
     super(
         types,
         elements,
@@ -69,7 +69,7 @@
    * Generates a map of unique simple names for all subcomponents, keyed by their {@link
    * ComponentDescriptor}.
    */
-  private static class UniqueSubcomponentNamesGenerator {
+  public static class UniqueSubcomponentNamesGenerator {
 
     private static final Splitter QUALIFIED_NAME_SPLITTER = Splitter.on('.');
     private static final Joiner QUALIFIED_NAME_JOINER = Joiner.on('_');
@@ -79,7 +79,7 @@
         componentDescriptorsBySimpleName;
     private final ImmutableListMultimap<ComponentDescriptor, String> componentQualifiedNamePieces;
 
-    private UniqueSubcomponentNamesGenerator(BindingGraph graph) {
+    public UniqueSubcomponentNamesGenerator(BindingGraph graph) {
       this.graph = graph;
       componentDescriptorsBySimpleName =
           Multimaps.index(
@@ -89,7 +89,7 @@ private UniqueSubcomponentNamesGenerator(BindingGraph graph) {
       componentQualifiedNamePieces = qualifiedNames(graph.componentDescriptors());
     }
 
-    private ImmutableBiMap<ComponentDescriptor, String> generate() {
+    public ImmutableBiMap<ComponentDescriptor, String> generate() {
       Map<ComponentDescriptor, String> subcomponentImplSimpleNames = new LinkedHashMap<>();
       for (Entry<String, Collection<ComponentDescriptor>> componentEntry :
           componentDescriptorsBySimpleName.asMap().entrySet()) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
index ee6edd717..afd226f2d 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
@@ -61,6 +61,10 @@
   /** Returns the type that specifies this' nullability, absent if not nullable. */
   abstract Optional<DeclaredType> nullableType();
 
+  abstract boolean genericParameter();
+
+  abstract boolean ignoreStubGeneration();
+
   abstract Optional<Equivalence.Wrapper<AnnotationMirror>> wrappedMapKey();
 
   final Optional<AnnotationMirror> mapKey() {
@@ -213,12 +217,12 @@ FactoryCreationStrategy factoryCreationStrategy() {
         return DELEGATE;
       case PROVISION:
         return dependencies().isEmpty() && !requiresModuleInstance()
-            ? SINGLETON_INSTANCE
+            ? CLASS_CONSTRUCTOR
             : CLASS_CONSTRUCTOR;
       case INJECTION:
       case SYNTHETIC_MULTIBOUND_SET:
       case SYNTHETIC_MULTIBOUND_MAP:
-        return dependencies().isEmpty() ? SINGLETON_INSTANCE : CLASS_CONSTRUCTOR;
+        return dependencies().isEmpty() ? CLASS_CONSTRUCTOR : CLASS_CONSTRUCTOR;
       default:
         return CLASS_CONSTRUCTOR;
     }
@@ -285,6 +289,10 @@ final TypeMirror contributedType() {
 
     abstract B key(Key key);
 
+    abstract B genericParameter(boolean generic);
+
+    abstract B ignoreStubGeneration(boolean ignore);
+
     abstract B explicitDependencies(Iterable<DependencyRequest> dependencies);
 
     abstract B explicitDependencies(DependencyRequest... dependencies);
diff --git a/compiler/src/main/java/dagger/internal/codegen/DI.java b/compiler/src/main/java/dagger/internal/codegen/DI.java
new file mode 100644
index 000000000..a7ea36dbc
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/DI.java
@@ -0,0 +1,39 @@
+package dagger.internal.codegen;
+
+import com.squareup.javapoet.ClassName;
+
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+public class DI {
+    private TypeElement appClass;
+    private Set<TypeElement> components;
+    private List<InjectorType> injectorTypes;
+
+    public DI(TypeElement appClass, Set<TypeElement> components, List<InjectorType> injectorTypes) {
+        this.appClass = appClass;
+        this.components = components;
+        this.injectorTypes = injectorTypes;
+    }
+
+    public ClassName getClassName() {
+        final ClassName className = ClassName.bestGuess(appClass.asType().toString());
+        return className.topLevelClassName().peerClass("Test" + className.simpleName());
+    }
+
+    public List<InjectorType> getInjectorTypes() {
+        return injectorTypes;
+    }
+
+    public Set<TypeElement> getComponents() {
+        return components;
+    }
+
+    public TypeElement getAppClass() {
+        return appClass;
+    }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/Decorator.java b/compiler/src/main/java/dagger/internal/codegen/Decorator.java
new file mode 100644
index 000000000..aac848ff9
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/Decorator.java
@@ -0,0 +1,123 @@
+package dagger.internal.codegen;
+
+import java.util.Optional;
+import com.squareup.javapoet.*;
+
+import javax.annotation.processing.Filer;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.util.Elements;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Set;
+import java.util.stream.Collector;
+import java.util.stream.Collectors;
+
+public class Decorator  extends SourceFileGenerator<BindingGraph>{
+
+    private BindingGraph.Factory factory;
+    private ClassName appClass;
+    private TestRegistry testRegistry;
+
+    private Decorator(Filer filer, Elements elements, BindingGraph.Factory factory, ClassName appClass, TestRegistry testRegistry) {
+        super(filer, elements);
+        this.factory = factory;
+        this.appClass = appClass;
+        this.testRegistry = testRegistry;
+    }
+
+    @Override
+    ClassName nameGeneratedType(BindingGraph input) {
+        return getClassName(input);
+    }
+
+    private ClassName getClassName(BindingGraph input) {
+        final TypeElement component = input.componentDescriptor().componentDefinitionType();
+        return ClassName.bestGuess("factories." + component.getSimpleName().toString() + "Decorator");
+    }
+
+    @Override
+    Optional<? extends Element> getElementForErrorReporting(BindingGraph input) {
+        return Optional.of(input.componentDescriptor().componentDefinitionType());
+    }
+
+    @Override
+    Optional<TypeSpec.Builder> write(ClassName generatedTypeName, BindingGraph input) {
+        final TypeSpec.Builder builder = TypeSpec.classBuilder(generatedTypeName)
+                .addModifiers(Modifier.PUBLIC);
+
+        final String daggerBuilderClassName = TriggerComponentInfo.resolveClassName(factory, input.componentDescriptor());
+
+        builder.addField(appClass, "app", Modifier.PRIVATE);
+
+        addDecoratorType(builder, generatedTypeName, daggerBuilderClassName, input);
+
+        return Optional.of(builder);
+    }
+
+    private void addDecoratorType(TypeSpec.Builder builder, ClassName returnType, String className, BindingGraph bindingGraph) {
+
+        builder.addModifiers(Modifier.PUBLIC);
+        builder.addMethod(MethodSpec.constructorBuilder()
+                .addModifiers(Modifier.PUBLIC)
+                .addParameter(appClass, "app")
+                .addStatement("this.app = app")
+                .build());
+
+        List<CodeBlock> statements = new ArrayList<>();
+        for (ContributionBinding contributionBinding : bindingGraph.delegateRequirements()) {
+            Util.createDelegateFieldAndMethod(returnType, builder, contributionBinding, new HashMap<>(1));
+            final String delegateFieldName = Util.getDelegateFieldName(contributionBinding.key());
+            final ClassName delegateTypeName = Util.getDelegateTypeName(contributionBinding.key());
+            statements.add(CodeBlock.of("builder.$L(this.$L);", Util.getDelegateMethodName(delegateTypeName), delegateFieldName));
+        }
+
+        builder.addMethod(MethodSpec.methodBuilder("and")
+                .addModifiers(Modifier.PUBLIC)
+                .addStatement("return app")
+                .returns(appClass)
+                .build());
+
+        builder.addMethod(MethodSpec.methodBuilder("decorate")
+                .addModifiers(Modifier.PUBLIC)
+                .addParameter(ClassName.bestGuess(className), "builder")
+                .addCode("$L", statements.stream().collect(CodeBlocks.joiningCodeBlocks("\n")))
+                .returns(void.class)
+                .build());
+    }
+
+    @Override
+    void generate(BindingGraph input) throws SourceFileGenerationException {
+        final ClassName generatedTypeName = getClassName(input);
+        final Optional<TypeSpec.Builder> builder = write(generatedTypeName, input);
+        try {
+            testRegistry.addEncodedClass(generatedTypeName, buildJavaFile(generatedTypeName, builder.get()));
+        } catch (IOException e) {
+            throw new IllegalStateException(e);
+        }
+    }
+
+    public static class Factory {
+
+        private final Filer filer;
+        private final Elements elements;
+        private final BindingGraph.Factory bindingGraphFactory;
+        private TestRegistry testRegistry;
+
+        Factory(Filer filer, Elements elements, BindingGraph.Factory bindingGraphFactory, TestRegistry testRegistry) {
+            this.filer = filer;
+            this.elements = elements;
+            this.bindingGraphFactory = bindingGraphFactory;
+            this.testRegistry = testRegistry;
+        }
+
+        public Decorator create(ClassName appClass) {
+            return new Decorator(filer, elements, bindingGraphFactory, appClass, testRegistry);
+        }
+
+    }
+
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/DelegateInitialization.java b/compiler/src/main/java/dagger/internal/codegen/DelegateInitialization.java
new file mode 100644
index 000000000..d75a8e8bb
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/DelegateInitialization.java
@@ -0,0 +1,46 @@
+package dagger.internal.codegen;
+
+import com.google.common.base.Optional;
+import com.google.common.collect.ImmutableCollection;
+import com.google.common.collect.ImmutableList;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.FieldSpec;
+import com.squareup.javapoet.MethodSpec;
+
+import javax.lang.model.element.Modifier;
+
+import java.util.HashMap;
+
+import static dagger.internal.codegen.Util.bindingSupportsTestDelegate;
+import static dagger.internal.codegen.Util.getDelegateTypeName;
+
+/**
+ * Created by Andy on 06.05.2017.
+ */
+public class DelegateInitialization implements InitializationStatement {
+
+    private ComponentDescriptor descriptor;
+    private final BindingGraph graph;
+
+    public DelegateInitialization(ComponentDescriptor descriptor, BindingGraph graph) {
+        this.descriptor = descriptor;
+        this.graph = graph;
+    }
+
+    @Override
+    public CodeBlock get() {
+        final CodeBlock.Builder codeBuilder = CodeBlock.builder();
+        final ImmutableCollection<ContributionBinding> values = graph.delegateRequirements();
+        for (ContributionBinding binding : values) {
+            try {
+                final String delegateFieldName = Util.getDelegateFieldName(binding.key());
+                final ClassName delegateType = getDelegateTypeName(binding.key());
+                final String methodName = Util.getDelegateMethodName(delegateType);
+                codeBuilder.add(".$L($L)\n", methodName, delegateFieldName);
+            } catch (Exception e) {
+            }
+        }
+        return codeBuilder.build();
+    }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/DelegateRegistry.java b/compiler/src/main/java/dagger/internal/codegen/DelegateRegistry.java
new file mode 100644
index 000000000..8c1ef3e9a
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/DelegateRegistry.java
@@ -0,0 +1,39 @@
+package dagger.internal.codegen;
+
+import com.google.auto.common.MoreTypes;
+import com.squareup.javapoet.ClassName;
+
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * Created by Andy on 07.05.2017.
+ */
+public class DelegateRegistry {
+
+    UniqueNameSet uniqueNameSet = new UniqueNameSet();
+    private Map<Key, String> fieldMap = new HashMap<>();
+    private Map<Key, ClassName> typeMap = new HashMap<>();
+
+    String getDelegateFieldName(Key key) {
+        if (fieldMap.containsKey(key)) {
+            return fieldMap.get(key);
+        }
+        final String s = MoreTypes.asTypeElement(key.type()).getSimpleName().toString();
+        final String uniqueName = uniqueNameSet.getUniqueName(s + "Delegate");
+        fieldMap.put(key, uniqueName);
+        return uniqueName;
+    }
+
+    ClassName getDelegateTypeName(Key key) {
+        if (typeMap.containsKey(key)) {
+            return typeMap.get(key);
+        }
+        final String s = key.type().toString();
+        final String uniqueName = uniqueNameSet.getUniqueName(s + "Delegate");
+        final ClassName className = ClassName.bestGuess(uniqueName);
+        typeMap.put(key, className);
+        return className;
+    }
+
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyInjectorGenerator.java b/compiler/src/main/java/dagger/internal/codegen/DependencyInjectorGenerator.java
new file mode 100644
index 000000000..c968d3832
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyInjectorGenerator.java
@@ -0,0 +1,63 @@
+package dagger.internal.codegen;
+
+import java.util.Optional;
+import com.google.common.collect.ImmutableBiMap;
+import com.google.common.collect.ImmutableSet;
+import com.squareup.javapoet.*;
+
+import javax.annotation.processing.Filer;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Elements;
+import java.util.ArrayList;
+import java.util.List;
+
+import static dagger.internal.codegen.AbstractComponentWriter.simpleVariableName;
+import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
+
+/**
+ * Created by Andy on 11.05.2017.
+ */
+public class DependencyInjectorGenerator extends SourceFileGenerator<DI> {
+
+    private final BindingGraph.Factory bindingGraphFactory;
+    private final ComponentDescriptor.Factory componentDescriptorFactory;
+
+    DependencyInjectorGenerator(Filer filer, Elements elements, BindingGraph.Factory bindingGraphFactory, ComponentDescriptor.Factory componentDescriptorFactory) {
+        super(filer, elements);
+        this.bindingGraphFactory = bindingGraphFactory;
+        this.componentDescriptorFactory = componentDescriptorFactory;
+    }
+
+    @Override
+    ClassName nameGeneratedType(DI input) {
+        return ClassName.bestGuess("injector.Injector");
+    }
+
+    @Override
+    Optional<? extends Element> getElementForErrorReporting(DI input) {
+        return Optional.empty();
+    }
+
+    @Override
+    Optional<TypeSpec.Builder> write(ClassName generatedTypeName, DI input) {
+        final TypeSpec.Builder builder = TypeSpec.classBuilder(generatedTypeName).addModifiers(Modifier.PUBLIC);
+        final ClassName appType = ClassName.get(input.getAppClass());
+        builder.addMethod(MethodSpec.constructorBuilder()
+                .addModifiers(Modifier.PUBLIC)
+                .addParameter(appType, "app")
+                .addStatement("this.app = app")
+                .build());
+        builder.addField(appType, "app", Modifier.PRIVATE);
+        for (TypeElement typeElement : input.getComponents()) {
+            final ComponentInfo info = ComponentInfo.forGenerator(typeElement, componentDescriptorFactory, bindingGraphFactory);
+            info.process(builder);
+        }
+        return Optional.of(builder);
+    }
+
+
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
index fb0420218..fe8e27a72 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
@@ -70,7 +70,7 @@
 @AutoValue
 abstract class DependencyRequest {
 
-  enum Kind {
+    enum Kind {
     /** A default request for an instance.  E.g.: {@code Blah} */
     INSTANCE,
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencySpecGenerator.java b/compiler/src/main/java/dagger/internal/codegen/DependencySpecGenerator.java
new file mode 100644
index 000000000..4caab7d4b
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencySpecGenerator.java
@@ -0,0 +1,65 @@
+package dagger.internal.codegen;
+
+import com.google.auto.common.MoreTypes;
+import com.google.common.collect.ImmutableBiMap;
+import com.google.common.collect.ImmutableSet;
+import com.squareup.javapoet.*;
+import dagger.Component;
+
+import javax.annotation.processing.Filer;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.util.Elements;
+import java.util.*;
+import java.util.function.Function;
+import java.util.stream.Collectors;
+
+import static dagger.internal.codegen.AbstractComponentWriter.simpleVariableName;
+
+public class DependencySpecGenerator extends SourceFileGenerator<Set<TypeElement>> {
+
+    private ComponentDescriptor.Factory componentDescriptorFactory;
+    private BindingGraph.Factory bindingGraphFactory;
+
+    DependencySpecGenerator(Filer filer, Elements elements, ComponentDescriptor.Factory componentDescriptorFactory, BindingGraph.Factory bindingGraphFactory) {
+        super(filer, elements);
+        this.componentDescriptorFactory = componentDescriptorFactory;
+        this.bindingGraphFactory = bindingGraphFactory;
+    }
+
+    @Override
+    ClassName nameGeneratedType(Set<TypeElement> input) {
+        return ClassName.bestGuess("injector.InjectorSpec");
+    }
+
+    @Override
+    Optional<? extends Element> getElementForErrorReporting(Set<TypeElement> input) {
+        return Optional.empty();
+    }
+
+    @Override
+    Optional<TypeSpec.Builder> write(ClassName generatedTypeName, Set<TypeElement> input) {
+
+        final TypeSpec.Builder builder = TypeSpec.interfaceBuilder(generatedTypeName)
+                .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT);
+
+        final List<ComponentInfo> info = input
+                .stream()
+                .map(typeElement -> ComponentInfo.forSpec(typeElement, componentDescriptorFactory, bindingGraphFactory))
+                .collect(Collectors.toList());
+
+        for (ComponentInfo componentInfo : info) {
+            componentInfo.process(builder);
+        }
+
+        builder.addMethod(MethodSpec.methodBuilder("getInjector")
+                .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT)
+                .returns(ClassName.bestGuess("injector.Injector"))
+                .build());
+
+        return Optional.of(builder);
+    }
+
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
index 95024f4d5..1e4cff071 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
@@ -35,6 +35,9 @@
 import static dagger.internal.codegen.SourceFiles.generatedClassNameForBinding;
 import static dagger.internal.codegen.SourceFiles.parameterizedGeneratedTypeNameForBinding;
 import static dagger.internal.codegen.TypeNames.factoryOf;
+import static dagger.internal.codegen.TypeNames.providerOf;
+import static dagger.internal.codegen.Util.getDelegateFieldName;
+import static dagger.internal.codegen.Util.getDelegateTypeName;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.PUBLIC;
@@ -62,8 +65,10 @@
 import java.util.Optional;
 import javax.annotation.processing.Filer;
 import javax.inject.Inject;
+import javax.inject.Named;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
 import javax.tools.Diagnostic;
 
@@ -80,10 +85,10 @@
   private final InjectValidator injectValidator;
 
   FactoryGenerator(
-      Filer filer,
-      Elements elements,
-      CompilerOptions compilerOptions,
-      InjectValidator injectValidator) {
+          Filer filer,
+          Elements elements,
+          CompilerOptions compilerOptions,
+          InjectValidator injectValidator) {
     super(filer, elements);
     this.compilerOptions = compilerOptions;
     this.injectValidator = injectValidator;
@@ -140,15 +145,25 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
         break;
       case CLASS_CONSTRUCTOR:
         constructorBuilder = Optional.of(constructorBuilder().addModifiers(PUBLIC));
+        if (Util.bindingSupportsTestDelegate(binding)) {
+          addConstructorParameterAndTypeField(
+                  getDelegateTypeName(binding.key()),
+                  getDelegateFieldName(binding.key()),
+                  factoryBuilder,
+                  constructorBuilder.get(),
+                  false
+          );
+        }
         if (binding.requiresModuleInstance()) {
+
           addConstructorParameterAndTypeField(
               TypeName.get(binding.bindingTypeElement().get().asType()),
               "module",
               factoryBuilder,
-              constructorBuilder.get());
+              constructorBuilder.get(),
+              true);
         }
-        for (Map.Entry<BindingKey, FrameworkField> entry :
-            generateBindingFieldsForDependencies(binding).entrySet()) {
+        for (Map.Entry<BindingKey, FrameworkField> entry : generateBindingFieldsForDependencies(binding).entrySet()) {
           BindingKey bindingKey = entry.getKey();
           FrameworkField bindingField = entry.getValue();
           FieldSpec field =
@@ -156,7 +171,8 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
                   bindingField.type(),
                   uniqueFieldNames.getUniqueName(bindingField.name()),
                   factoryBuilder,
-                  constructorBuilder.get());
+                  constructorBuilder.get(),
+                  true);
           fieldsBuilder.put(bindingKey, field);
         }
         break;
@@ -234,19 +250,32 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
             .addAnnotation(Override.class)
             .addModifiers(PUBLIC);
 
+    final CodeBlock codeBlock = CodeBlock.of(getDelegateFieldName(binding.key()));
     if (binding.bindingKind().equals(PROVISION)) {
+      if (Util.bindingSupportsTestDelegate(binding)) {
+        final String delegateFieldName = Util.getDelegateFieldName(binding.key());
+        getMethodBuilder.beginControlFlow("if ($L != null)", CodeBlock.of(delegateFieldName));
+        getMethodBuilder.addStatement("return $L.get($L)", CodeBlock.of(delegateFieldName), parametersCodeBlock);
+        getMethodBuilder.nextControlFlow("else");
+      }
       CodeBlock.Builder providesMethodInvocationBuilder = CodeBlock.builder();
       if (binding.requiresModuleInstance()) {
         providesMethodInvocationBuilder.add("module");
       } else {
         providesMethodInvocationBuilder.add(
-            "$T", ClassName.get(binding.bindingTypeElement().get()));
+                "$T", ClassName.get(binding.bindingTypeElement().get()));
       }
       providesMethodInvocationBuilder.add(
-          ".$L($L)", binding.bindingElement().get().getSimpleName(), parametersCodeBlock);
+              ".$L($L)", binding.bindingElement().get().getSimpleName(), parametersCodeBlock);
+
       CodeBlock providesMethodInvocation = providesMethodInvocationBuilder.build();
+      getMethodBuilder.addStatement("return $L", providesMethodInvocation);
+
+      if (Util.bindingSupportsTestDelegate(binding)) {
+        getMethodBuilder.endControlFlow();
+      }
 
-      if (binding.nullableType().isPresent()
+      /*if (binding.nullableType().isPresent()
           || compilerOptions.nullableValidationKind().equals(Diagnostic.Kind.WARNING)) {
         if (binding.nullableType().isPresent()) {
           getMethodBuilder.addAnnotation((ClassName) TypeName.get(binding.nullableType().get()));
@@ -257,16 +286,38 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
             Preconditions.class,
             providesMethodInvocation,
             CANNOT_RETURN_NULL_FROM_NON_NULLABLE_PROVIDES_METHOD);
-      }
+      }*/
     } else if (binding.membersInjectionRequest().isPresent()) {
+
+      if (Util.bindingSupportsTestDelegate(binding)) {
+        getMethodBuilder.beginControlFlow("if ($L != null)", codeBlock);
+        getMethodBuilder.addStatement(
+                "return $T.injectMembers($N, $L.get($L))",
+                MembersInjectors.class,
+                fields.get(binding.membersInjectionRequest().get().bindingKey()),
+                codeBlock,
+                parametersCodeBlock);
+        getMethodBuilder.nextControlFlow("else");
+      }
       getMethodBuilder.addStatement(
           "return $T.injectMembers($N, new $T($L))",
           MembersInjectors.class,
           fields.get(binding.membersInjectionRequest().get().bindingKey()),
           providedTypeName,
           parametersCodeBlock);
+      if (Util.bindingSupportsTestDelegate(binding)) {
+        getMethodBuilder.endControlFlow();
+      }
     } else {
+      if (Util.bindingSupportsTestDelegate(binding)) {
+        getMethodBuilder.beginControlFlow("if ($L != null)", codeBlock);
+        getMethodBuilder.addStatement("return $L.get($L)", codeBlock, parametersCodeBlock);
+        getMethodBuilder.nextControlFlow("else");
+      }
       getMethodBuilder.addStatement("return new $T($L)", providedTypeName, parametersCodeBlock);
+      if (Util.bindingSupportsTestDelegate(binding)) {
+        getMethodBuilder.endControlFlow();
+      }
     }
 
     factoryBuilder.addMethod(getMethodBuilder.build());
@@ -299,12 +350,17 @@ private FieldSpec addConstructorParameterAndTypeField(
       TypeName typeName,
       String variableName,
       TypeSpec.Builder factoryBuilder,
-      MethodSpec.Builder constructorBuilder) {
+      MethodSpec.Builder constructorBuilder,
+      boolean assertCheck) {
     FieldSpec field = FieldSpec.builder(typeName, variableName, PRIVATE, FINAL).build();
     factoryBuilder.addField(field);
     ParameterSpec parameter = ParameterSpec.builder(typeName, variableName).build();
     constructorBuilder.addParameter(parameter);
-    constructorBuilder.addCode("assert $1N != null; this.$2N = $1N;", parameter, field);
+    if (assertCheck) {
+      constructorBuilder.addCode("assert $1N != null; this.$2N = $1N;", parameter, field);
+    }else {
+      constructorBuilder.addCode("this.$2N = $1N;", parameter, field);
+    }
     return field;
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/FinishBuilderStatement.java b/compiler/src/main/java/dagger/internal/codegen/FinishBuilderStatement.java
new file mode 100644
index 000000000..114924586
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/FinishBuilderStatement.java
@@ -0,0 +1,26 @@
+package dagger.internal.codegen;
+
+import java.util.Optional;
+import com.squareup.javapoet.CodeBlock;
+
+/**
+ * Created by Andy on 06.05.2017.
+ */
+public class FinishBuilderStatement implements InitializationStatement{
+
+    private ComponentDescriptor descriptor;
+
+    public FinishBuilderStatement(ComponentDescriptor descriptor) {
+        this.descriptor = descriptor;
+    }
+
+    @Override
+    public CodeBlock get() {
+        final CodeBlock.Builder builder = CodeBlock.builder();
+        if (descriptor.kind() == ComponentDescriptor.Kind.SUBCOMPONENT) {
+            final Optional<ComponentDescriptor.BuilderSpec> builderSpec = this.descriptor.builderSpec();
+            return (builderSpec.isPresent()) ? builder.add(".$L())\n", builderSpec.get().buildMethod().getSimpleName().toString()).build() : builder.build();
+        }
+        return CodeBlock.of(".build())\n");
+    }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java b/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java
index 18c1126dd..7dcffcac2 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java
@@ -126,4 +126,5 @@ public String visitType(TypeElement e, Binding p) {
 
   abstract ParameterizedTypeName type();
   abstract String name();
+
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/GeneratorComponentInfo.java b/compiler/src/main/java/dagger/internal/codegen/GeneratorComponentInfo.java
new file mode 100644
index 000000000..db756fc13
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/GeneratorComponentInfo.java
@@ -0,0 +1,134 @@
+package dagger.internal.codegen;
+
+import com.google.common.collect.ImmutableSet;
+import com.squareup.javapoet.*;
+
+import javax.lang.model.element.*;
+import javax.lang.model.type.TypeMirror;
+import java.util.ArrayList;
+import java.util.List;
+
+import static dagger.internal.codegen.AbstractComponentWriter.simpleVariableName;
+import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
+
+public class GeneratorComponentInfo extends ComponentInfo {
+
+    protected GeneratorComponentInfo(TypeElement component, ComponentDescriptor descriptor, BindingGraph bindingGraph) {
+        super(component, descriptor, bindingGraph);
+    }
+
+    @Override
+    public void process(TypeSpec.Builder builder) {
+        super.process(builder);
+
+        final String name = simpleVariableName(component);
+        final MethodSpec.Builder methodBuilder = MethodSpec.methodBuilder(name)
+                .addModifiers(Modifier.PUBLIC);
+
+        methodBuilder.returns(ClassName.get(component));
+
+        List<ParameterSpec> parameterSpecs = new ArrayList<>();
+        if (descriptor.kind() == ComponentDescriptor.Kind.SUBCOMPONENT) {
+            final TypeElement component = descriptor.getParentDescriptor().componentDefinitionType();
+            parameterSpecs.add(ParameterSpec.builder(ClassName.get(component), simpleVariableName(component)).build());
+        }
+
+        if (descriptor.builderSpec().isPresent()) {
+            for (ComponentDescriptor.BuilderRequirementMethod requirementMethod : descriptor.builderSpec().get().requirementMethods()) {
+                final ComponentRequirement requirement = requirementMethod.requirement();
+                final TypeElement typeElement = requirement.typeElement();
+                if ((requirement.kind() == ComponentRequirement.Kind.MODULE &&
+                        hasNotOnlyNoArgConstructor(typeElement, requirement.autoCreate()))
+                        || requirement.kind() != ComponentRequirement.Kind.MODULE) {
+                    parameterSpecs.add(ParameterSpec.builder(ClassName.get(typeElement), simpleVariableName(typeElement)).build());
+                }
+            }
+        } else {
+            for (ModuleDescriptor moduleDescriptor : descriptor.modules()) {
+                final TypeElement moduleElement = moduleDescriptor.moduleElement();
+                if (hasNotOnlyNoArgConstructor(moduleElement, autoCreate(moduleElement))) {
+                    parameterSpecs.add(ParameterSpec.builder(ClassName.get(moduleElement), simpleVariableName(moduleElement)).build());
+                }
+            }
+
+            for (TypeElement typeElement : descriptor.dependencies()) {
+                parameterSpecs.add(ParameterSpec.builder(ClassName.get(typeElement), simpleVariableName(typeElement)).build());
+            }
+        }
+
+        methodBuilder.addParameters(parameterSpecs);
+
+        CodeBlock builderInit = getBuilderInitStatement(descriptor, descriptor.getParentDescriptor());
+
+        final List<CodeBlock> statementParams = new ArrayList<>();
+
+        List<CodeBlock> moduleConstructorStatements = new ArrayList<>();
+
+        if (descriptor.builderSpec().isPresent()) {
+            for (ComponentDescriptor.BuilderRequirementMethod requirementMethod : descriptor.builderSpec().get().requirementMethods()) {
+                final ComponentRequirement requirement = requirementMethod.requirement();
+                final TypeElement typeElement = requirement.typeElement();
+                final boolean hasNotOnlyNoArgConstructor = hasNotOnlyNoArgConstructor(typeElement, requirement.autoCreate());
+                if ((requirement.kind() == ComponentRequirement.Kind.MODULE &&
+                        hasNotOnlyNoArgConstructor) || requirement.kind() != ComponentRequirement.Kind.MODULE) {
+                    statementParams.add(CodeBlock.of("$L", simpleVariableName(typeElement)));
+                }else if (requirement.kind() == ComponentRequirement.Kind.MODULE && !hasNotOnlyNoArgConstructor) {
+                    final String methodName = requirementMethod.method().getSimpleName().toString();
+                    moduleConstructorStatements.add(CodeBlock.of(".$L(new $T())",
+                            methodName, ClassName.get(requirement.typeElement())));
+                }
+            }
+        } else {
+            for (ModuleDescriptor moduleDescriptor : descriptor.modules()) {
+                final TypeElement typeElement = moduleDescriptor.moduleElement();
+                if (hasNotOnlyNoArgConstructor(typeElement, autoCreate(typeElement))) {
+                    statementParams.add(CodeBlock.of("$L", simpleVariableName(typeElement)));
+                }
+            }
+
+            for (TypeElement typeElement : descriptor.dependencies()) {
+                statementParams.add(CodeBlock.of("$L", simpleVariableName(typeElement)));
+            }
+        }
+
+        CodeBlock modulesCodeBlock = moduleConstructorStatements
+                .stream()
+                .collect(CodeBlocks.joiningCodeBlocks(""));
+
+        if (statementParams.isEmpty()) {
+            methodBuilder.addStatement("return this.app.$L($L)$L.build()", name, builderInit, modulesCodeBlock);
+        } else {
+            methodBuilder.addStatement("return this.app.$L($L, $L)$L.build()",
+                    name, builderInit, makeParametersCodeBlock(statementParams), modulesCodeBlock);
+        }
+
+        builder.addMethod(methodBuilder.build());
+    }
+
+    private CodeBlock getBuilderInitStatement(ComponentDescriptor descriptor, ComponentDescriptor parentDescriptor) {
+        if (descriptor.kind() == ComponentDescriptor.Kind.SUBCOMPONENT) {
+            final ImmutableSet<ComponentDescriptor.ComponentMethodDescriptor> componentMethodDescriptors = parentDescriptor.componentMethods();
+            for (ComponentDescriptor.ComponentMethodDescriptor componentMethodDescriptor : componentMethodDescriptors) {
+                final ExecutableElement executableElement = componentMethodDescriptor.methodElement();
+                TypeMirror typeToSearch = descriptor.componentDefinitionType().asType();
+                if (descriptor.builderSpec().isPresent()) {
+                    typeToSearch = descriptor.builderSpec().get().builderDefinitionType().asType();
+                }
+                if (executableElement.getReturnType().toString().equals(typeToSearch.toString())) {
+                    final String methodName = executableElement.getSimpleName().toString();
+                    if (!descriptor.builderSpec().isPresent()) {
+                        // check if method has parameters ...
+                        //builderModuleStatement.setExecutableElement(executableElement);
+                        //return codeBlockBuilder.add("$L.$L($L))\n", builderName, methodName, builderModuleStatement.get()).build();
+                        break;
+                    } else {
+                        return CodeBlock.of("$L.$L()\n", simpleVariableName(parentDescriptor.componentDefinitionType()), methodName);
+                    }
+                }
+            }
+        }
+        final ClassName componentClassName = Util.getDaggerComponentClassName(ClassName.get(descriptor.componentDefinitionType()));
+        return CodeBlock.of("$T.builder()\n", componentClassName);
+    }
+
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/InitializationStatement.java b/compiler/src/main/java/dagger/internal/codegen/InitializationStatement.java
new file mode 100644
index 000000000..c476fa4e3
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/InitializationStatement.java
@@ -0,0 +1,7 @@
+package dagger.internal.codegen;
+
+import com.squareup.javapoet.CodeBlock;
+
+public interface InitializationStatement {
+    CodeBlock get();
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java b/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
index 2169c4ba5..24054f930 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
@@ -171,10 +171,10 @@ private void tryToCacheBinding(B binding) {
    * {@linkplain #registerBinding explicitly} or implicitly via
    * {@link #getOrFindMembersInjectionBinding} or {@link #getOrFindProvisionBinding}) are generated.
    */
-  void generateSourcesForRequiredBindings(FactoryGenerator factoryGenerator,
-      MembersInjectorGenerator membersInjectorGenerator) throws SourceFileGenerationException {
-    provisionBindings.generateBindings(factoryGenerator);
+  void generateSourcesForRequiredBindings(SourceFileGenerator<ProvisionBinding> factoryGenerator,
+                                          MembersInjectorGenerator membersInjectorGenerator) throws SourceFileGenerationException {
     membersInjectionBindings.generateBindings(membersInjectorGenerator);
+    provisionBindings.generateBindings(factoryGenerator);
   }
 
   /**
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectorGenerator.java b/compiler/src/main/java/dagger/internal/codegen/InjectorGenerator.java
new file mode 100644
index 000000000..56e89d4a1
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectorGenerator.java
@@ -0,0 +1,137 @@
+package dagger.internal.codegen;
+
+import com.google.auto.common.MoreTypes;
+import java.util.Optional;
+import com.squareup.javapoet.*;
+
+import javax.annotation.processing.Filer;
+import javax.lang.model.element.*;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
+import java.io.IOException;
+import java.util.*;
+
+public class InjectorGenerator extends SourceFileGenerator<DI>{
+
+    private Types types;
+    private Elements elements;
+    private final ComponentDescriptor.Factory componentDescriptorFactory;
+    private final BindingGraph.Factory bindingGraphFactory;
+    private TestClassGenerator testClassGenerator;
+    private final TestRegistry registry;
+    private Decorator.Factory decoratorFactory;
+
+    InjectorGenerator(Filer filer, Types types, Elements elements, ComponentDescriptor.Factory componentDescriptorFactory, BindingGraph.Factory bindingGraphFactory, TestClassGenerator testClassGenerator, TestRegistry registry, Decorator.Factory decoratorFactory) {
+        super(filer, elements);
+        this.types = types;
+        this.elements = elements;
+        this.componentDescriptorFactory = componentDescriptorFactory;
+        this.bindingGraphFactory = bindingGraphFactory;
+        this.testClassGenerator = testClassGenerator;
+        this.registry = registry;
+        this.decoratorFactory = decoratorFactory;
+    }
+
+    @Override
+    ClassName nameGeneratedType(DI input) {
+        return input.getClassName();
+    }
+
+    @Override
+    Optional<? extends Element> getElementForErrorReporting(DI input) {
+        return Optional.empty();
+    }
+
+    @Override
+    Optional<TypeSpec.Builder> write(ClassName generatedTypeName, DI input) {
+        final TypeSpec.Builder builder = TypeSpec.classBuilder(generatedTypeName)
+                .addModifiers(Modifier.PUBLIC);
+
+        final Set<TypeElement> components = input.getComponents();
+
+        builder.superclass(ClassName.get(input.getAppClass()));
+
+        final java.util.Optional<ExecutableElement> onCreateMethod = findOnCreateMethod(input.getAppClass());
+        if (!onCreateMethod.isPresent()) {
+            throw new IllegalStateException("onCreate method not found!");
+        }
+        final MethodSpec.Builder overriding = MethodSpec.overriding(onCreateMethod.get());
+        createDecoratorClasses(builder, overriding, components, input.getAppClass());
+        overriding.addStatement("super.onCreate()");
+
+        //builder.addMethod(overriding.build());
+
+        for (TypeElement component : components) {
+            final TriggerComponentInfo componentInfo =
+                    ComponentInfo.forTrigger(component, componentDescriptorFactory, bindingGraphFactory);
+            componentInfo.process(builder);
+        }
+
+        return Optional.of(builder);
+    }
+
+    private void createDecoratorClasses(TypeSpec.Builder builder, MethodSpec.Builder methodBuilder, Set<TypeElement> components, TypeElement appClass) {
+        for (TypeElement component : components) {
+            ComponentDescriptor componentDescriptor = componentDescriptorFactory.forComponent(component);
+            final BindingGraph bindingGraph = bindingGraphFactory.create(componentDescriptor);
+            createDecoratorClass(builder, methodBuilder, bindingGraph, appClass);
+        }
+    }
+
+    private void createDecoratorClass(TypeSpec.Builder builder, MethodSpec.Builder methodBuilder, BindingGraph bindingGraph, TypeElement appClass) {
+        final ClassName appClassName = ClassName.get(appClass);
+        ClassName testAppClassName = appClassName.topLevelClassName().peerClass("Test" + appClassName.simpleName());
+        final Decorator decorator = decoratorFactory.create(testAppClassName);
+        try {
+            decorator.generate(bindingGraph);
+            final ClassName decoratorName = decorator.nameGeneratedType(bindingGraph);
+            final String fieldName = Util.lowerCaseFirstLetter(decoratorName.simpleName());
+            final String methodName = "decorate" + Util.capitalize(fieldName.replaceAll("Decorator$", ""));
+            final FieldSpec.Builder fieldBuilder = FieldSpec.builder(decoratorName, fieldName, Modifier.PRIVATE);
+            fieldBuilder.addAnnotation(AnnotationSpec.builder(ClassName.bestGuess("android.support.annotation.NonNull")).build());
+            final FieldSpec field = fieldBuilder.initializer("new $T(this)", decoratorName).build();
+            builder.addField(field);
+            builder.addMethod(MethodSpec.methodBuilder(methodName)
+                    .addModifiers(Modifier.PUBLIC)
+                    .returns(decoratorName)
+                    .addStatement("return this.$L", fieldName)
+                    .build());
+        } catch (SourceFileGenerationException e) {
+            throw new IllegalStateException("Exception while generating decorator: " + e);
+        }
+        for (BindingGraph subGraph : bindingGraph.subgraphs()) {
+            createDecoratorClass(builder, methodBuilder, subGraph, appClass);
+        }
+    }
+
+    private java.util.Optional<ExecutableElement> findOnCreateMethod(TypeElement applicationClass) {
+        final java.util.Optional<ExecutableElement> onCreateMethod = applicationClass.getEnclosedElements().stream()
+                .filter(e -> e.getKind() == ElementKind.METHOD)
+                .map(e -> (ExecutableElement) e)
+                .filter(e -> e.getSimpleName().toString().equals("onCreate"))
+                .findFirst();
+        final com.google.common.base.Optional<DeclaredType> declaredTypeOptional = MoreTypes.nonObjectSuperclass(types, elements, MoreTypes.asDeclared(applicationClass.asType()));
+        if (!onCreateMethod.isPresent() && declaredTypeOptional.isPresent()) {
+            return findOnCreateMethod(MoreTypes.asTypeElement(declaredTypeOptional.get()));
+        }
+        else
+            return onCreateMethod;
+    }
+
+    @Override
+    void generate(DI input) throws SourceFileGenerationException {
+        final Optional<TypeSpec.Builder> builder = write(input.getClassName(), input);
+        try {
+            registry.addEncodedClass(input.getClassName(), buildJavaFile(input.getClassName(), builder.get()));
+            final Set<TypeElement> components = input.getComponents();
+            testClassGenerator.setComponents(components);
+            testClassGenerator.setInjector(input.getAppClass());
+            testClassGenerator.generate(registry);
+        } catch (IOException e) {
+            throw new IllegalStateException(e);
+        }
+
+    }
+
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectorProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/InjectorProcessingStep.java
new file mode 100644
index 000000000..66ca481e8
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectorProcessingStep.java
@@ -0,0 +1,153 @@
+package dagger.internal.codegen;
+
+import com.google.auto.common.BasicAnnotationProcessor;
+import com.google.auto.common.MoreElements;
+import com.google.auto.common.MoreTypes;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.SetMultimap;
+import com.squareup.javapoet.TypeName;
+import dagger.*;
+
+import javax.annotation.processing.Messager;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.MirroredTypeException;
+import javax.lang.model.util.Types;
+import javax.tools.Diagnostic;
+import java.lang.annotation.Annotation;
+import java.util.*;
+import java.util.function.Function;
+import java.util.stream.Collectors;
+
+/**
+ * Created by Andy on 05.05.2017.
+ */
+public class InjectorProcessingStep implements BasicAnnotationProcessor.ProcessingStep {
+
+    private Types types;
+    private final Messager messager;
+    private final InjectorGenerator injectorGenerator;
+    private final ComponentDescriptor.Kind component;
+    private final BindingGraph.Factory bindingGraphFactory;
+    private final ComponentDescriptor.Factory componentDescriptorFactory;
+    private DependencySpecGenerator dependencySpecGenerator;
+    private DependencyInjectorGenerator dependencyInjectorGenerator;
+    private Map<TypeElement, ExecutableElement> componentMethodMap;
+    private Map<TypeElement, ExecutableElement> moduleMethodMap;
+    private Map<TypeElement, ExecutableElement> subcomponentMethodMap;
+    private HashSet<TypeElement> components = new HashSet<>();
+    private TypeElement appClass;
+    private static boolean done = false;
+
+    public InjectorProcessingStep(Types types, Messager messager,
+                                  InjectorGenerator injectorGenerator,
+                                  ComponentDescriptor.Kind component, BindingGraph.Factory bindingGraphFactory,
+                                  ComponentDescriptor.Factory componentDescriptorFactory,
+                                  DependencySpecGenerator dependencySpecGenerator,
+                                  DependencyInjectorGenerator dependencyInjectorGenerator) {
+        this.types = types;
+        this.messager = messager;
+        this.injectorGenerator = injectorGenerator;
+        this.component = component;
+        this.bindingGraphFactory = bindingGraphFactory;
+        this.componentDescriptorFactory = componentDescriptorFactory;
+        this.dependencySpecGenerator = dependencySpecGenerator;
+        this.dependencyInjectorGenerator = dependencyInjectorGenerator;
+    }
+
+    @Override
+    public Set<? extends Class<? extends Annotation>> annotations() {
+        return ImmutableSet.of(Config.class, Component.class);
+    }
+
+    @Override
+    public Set<Element> process(SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
+
+        if (done) {
+            return new HashSet<>();
+        }
+
+        done = true;
+
+        final Iterator<Element> it = elementsByAnnotation.get(Config.class).iterator();
+        if (!it.hasNext()) {
+            return ImmutableSet.of();
+        }
+
+        if (appClass == null) {
+            try {
+                it.next().getAnnotation(Config.class).applicationClass();
+            } catch (MirroredTypeException e) {
+                try {
+                    appClass = MoreTypes.asTypeElement(e.getTypeMirror());
+                } catch (TypeNotPresentException ex) {
+                    throw new IllegalStateException("application class could not be extracted: " + ex.toString());
+                }
+            } catch (Exception e) {
+                throw new IllegalStateException("application class could not be extracted");
+            }
+        }
+
+        Set<Element> rejectedElements = new LinkedHashSet<>();
+
+        components.addAll(elementsByAnnotation.get(Component.class).stream()
+                .map(element -> (TypeElement) element).collect(Collectors.toSet()));
+
+            /*this.moduleMethodMap =
+                    this.buildProvideMethodMap(elementsByAnnotation.get(ProvidesModule.class));
+
+            this.subcomponentMethodMap =
+                    this.buildProvideMethodMap(elementsByAnnotation.get(ProvidesSubcomponent.class));
+
+            this.componentMethodMap =
+                    this.buildProvideMethodMap(elementsByAnnotation.get(ProvidesComponent.class));*/
+
+/*        final Map<TypeElement, ProvidingMethodOverrider> componentOverriderMap =
+                this.buildProvideComponentMethodMap(elementsByAnnotation.get(ProvidesComponent.class), injector);*/
+
+        List<InjectorType> injectorTypeList = new ArrayList<>();
+        for (Element element : elementsByAnnotation.get(component.annotationType())) {
+            TypeElement componentTypeElement = (TypeElement) element;
+            ComponentDescriptor componentDescriptor = componentDescriptorFactory.forComponent(componentTypeElement);
+            BindingGraph bindingGraph = bindingGraphFactory.create(componentDescriptor);
+            InjectorType injectorType = new InjectorType(componentTypeElement, bindingGraph, componentDescriptor);
+            injectorTypeList.add(injectorType);
+        }
+        if (rejectedElements.isEmpty()) {
+            final DI di = new DI(appClass, components, injectorTypeList);
+            this.dependencyInjectorGenerator.generate(di, messager);
+            this.dependencySpecGenerator.generate(components, messager);
+            this.injectorGenerator.generate(di, messager);
+        } else {
+            throw new IllegalStateException(rejectedElements.toString());
+        }
+
+        return rejectedElements;
+    }
+
+    private Map<Key, VariableElement> toParameterMap(List<? extends VariableElement> parameters) {
+        return parameters.stream()
+                .collect(Collectors.toMap(p -> Key.builder(p.asType()).build(), Function.identity()));
+    }
+
+    private List<InitializationStatement> createInitializationsStatements(TypeElement injector,
+                                                                          ComponentDescriptor componentDescriptor,
+                                                                          Map<TypeElement, ExecutableElement> moduleMethodMap,
+                                                                          ExecutableElement providingMethod,
+                                                                          BindingGraph bindingGraph) {
+
+        Map<Key, VariableElement> providedParams = toParameterMap(providingMethod.getParameters());
+        BuilderModuleStatement builderModuleStatement =
+                new BuilderModuleStatement(this.types, injector, componentDescriptor, moduleMethodMap, providedParams);
+        return ImmutableList.of(
+                new BuilderStatement(componentDescriptor, providingMethod, builderModuleStatement, bindingGraphFactory),
+                new ComponentStatement(this.types, injector, componentDescriptorFactory, componentDescriptor, providedParams),
+                new ModuleStatement(this.types, injector, componentDescriptor, moduleMethodMap, providedParams),
+                new FinishBuilderStatement(componentDescriptor),
+                new DelegateInitialization(componentDescriptor, bindingGraph)
+        );
+    }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectorType.java b/compiler/src/main/java/dagger/internal/codegen/InjectorType.java
new file mode 100644
index 000000000..860a96420
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectorType.java
@@ -0,0 +1,31 @@
+package dagger.internal.codegen;
+
+import javax.lang.model.element.TypeElement;
+
+/**
+ * Created by Andy on 05.05.2017.
+ */
+public class InjectorType {
+
+    private TypeElement element;
+    private BindingGraph bindingGraph;
+    private ComponentDescriptor componentDescriptor;
+
+    public InjectorType(TypeElement element, BindingGraph bindingGraph, ComponentDescriptor componentDescriptor) {
+        this.element = element;
+        this.bindingGraph = bindingGraph;
+        this.componentDescriptor = componentDescriptor;
+    }
+
+    public BindingGraph getBindingGraph() {
+        return bindingGraph;
+    }
+
+    public TypeElement getElement() {
+        return element;
+    }
+
+    public ComponentDescriptor getComponentDescriptor() {
+        return componentDescriptor;
+    }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/Key.java b/compiler/src/main/java/dagger/internal/codegen/Key.java
index 058c09f60..f2f3f1399 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Key.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Key.java
@@ -16,6 +16,7 @@
 
 package dagger.internal.codegen;
 
+import static com.google.auto.common.MoreElements.asPackage;
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static com.google.auto.common.MoreTypes.asExecutable;
 import static com.google.auto.common.MoreTypes.isType;
@@ -39,15 +40,14 @@
 import com.google.auto.value.extension.memoized.Memoized;
 import com.google.common.base.Equivalence;
 import com.google.common.base.Joiner;
-import com.google.common.collect.ImmutableMap;
-import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.ImmutableSetMultimap;
-import com.google.common.collect.Multimaps;
+import com.google.common.collect.*;
 import com.google.common.util.concurrent.ListenableFuture;
+import com.squareup.javapoet.ClassName;
 import dagger.Binds;
 import dagger.BindsOptionalOf;
+import dagger.MapKey;
 import dagger.Multibindings;
-import dagger.multibindings.Multibinds;
+import dagger.multibindings.*;
 import dagger.producers.Produced;
 import dagger.producers.Producer;
 import dagger.producers.Production;
@@ -56,18 +56,17 @@
 import dagger.releasablereferences.ForReleasableReferences;
 import dagger.releasablereferences.ReleasableReferenceManager;
 import dagger.releasablereferences.TypedReleasableReferenceManager;
+
+import java.io.Serializable;
 import java.util.Map;
 import java.util.Optional;
 import java.util.Set;
 import java.util.concurrent.Executor;
 import java.util.stream.Stream;
+import javax.inject.Named;
 import javax.inject.Provider;
 import javax.inject.Qualifier;
-import javax.lang.model.element.AnnotationMirror;
-import javax.lang.model.element.ElementKind;
-import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.Modifier;
-import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.*;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.ExecutableType;
 import javax.lang.model.type.PrimitiveType;
@@ -84,10 +83,10 @@
  * @author Gregory Kick
  */
 @AutoValue
-abstract class Key {
+abstract class Key implements Serializable{
 
   /** An object that is associated with a {@link Key}. */
-  interface HasKey {
+  interface HasKey extends Serializable {
     /** The key associated with this object. */
     Key key();
   }
@@ -175,9 +174,13 @@ abstract Builder multibindingContributionIdentifier(
    */
   static final class MultibindingContributionIdentifier {
     private final String identifierString;
+    private final ExecutableElement bindingMethod;
+    private final TypeElement contributingModule;
 
     MultibindingContributionIdentifier(
         ExecutableElement bindingMethod, TypeElement contributingModule) {
+      this.bindingMethod = bindingMethod;
+      this.contributingModule = contributingModule;
       this.identifierString =
           String.format(
               "%s#%s", contributingModule.getQualifiedName(), bindingMethod.getSimpleName());
@@ -194,6 +197,90 @@ public String toString() {
       return identifierString;
     }
 
+    public ClassName getDelegateTypeName() {
+      final TypeMirror returnType = bindingMethod.getReturnType();
+      final Named annotation = bindingMethod.getAnnotation(Named.class);
+      final ClassName name = ClassName.bestGuess(Util.typeToString(returnType));
+      final String packageName = name.packageName();
+      if (annotation != null) {
+          return ClassName.bestGuess("swagger" + "." + capitalizeFirstLetter(annotation.value()) + "Delegate");
+      }else {
+        final java.util.Optional<? extends AnnotationMirror> annotationMirror = getAnnotationMirror(bindingMethod);
+        if(annotationMirror.isPresent()) {
+          String capitalizedAnnotationValue = getCapitalizedAnnotationValue(annotationMirror.get());
+          if (isInteger(capitalizedAnnotationValue)) {
+            final String annotationName = annotationMirror.get().getAnnotationType().asElement().getSimpleName().toString();
+            capitalizedAnnotationValue = annotationName + capitalizedAnnotationValue;
+          }
+          return ClassName.bestGuess("swagger" + "." + capitalizedAnnotationValue + "In" + contributingModule.getSimpleName().toString() + "Delegate");
+        }else {
+          return ClassName.bestGuess("swagger" + "." + capitalizeFirstLetter(bindingMethod.getSimpleName().toString()) + "For" + contributingModule.getSimpleName().toString() + "Delegate");
+        }
+      }
+    }
+
+    private boolean isInteger(String str) {
+      try{
+        Integer.parseInt(str);
+        return true;
+      } catch (Exception e) {
+        return false;
+      }
+    }
+
+    public String getDelegateFieldName() {
+      final TypeMirror returnType = bindingMethod.getReturnType();
+      final Named annotation = bindingMethod.getAnnotation(Named.class);
+      if (annotation != null) {
+        return Util.lowerCaseFirstLetter(annotation.value())  + "Delegate";
+      }else {
+        final java.util.Optional<? extends AnnotationMirror> annotationMirror = getAnnotationMirror(returnType);
+        if(annotationMirror.isPresent()) {
+          return Util.lowerCaseFirstLetter(getCapitalizedAnnotationValue(annotationMirror.get())) + "Delegate";
+        }else {
+          return bindingMethod.getSimpleName().toString() + "For" + contributingModule.getSimpleName().toString() + "Delegate";
+        }
+      }
+    }
+
+    private static String getCapitalizedAnnotationValue(AnnotationMirror annotation) {
+      final Map<? extends ExecutableElement, ? extends AnnotationValue> elementValues = annotation.getElementValues();
+      for (Map.Entry<? extends ExecutableElement, ? extends AnnotationValue> entry : elementValues.entrySet()) {
+        if (entry.getKey().getSimpleName().toString().equals("value")) {
+          final String original = entry.getValue().getValue().toString();
+          if (!original.isEmpty()) {
+            return capitalizeFirstLetter(original);
+          }
+        }
+      }
+      throw new IllegalStateException("value not found");
+    }
+
+    private static String capitalizeFirstLetter(String original) {
+      if (original == null || original.length() == 0) {
+        return original;
+      }
+      return original.substring(0, 1).toUpperCase() + original.substring(1);
+    }
+
+    private static java.util.Optional<? extends AnnotationMirror> getAnnotationMirror(TypeMirror typeMirror) {
+      final ImmutableList<String> annotations =
+              ImmutableList.of(Named.class.getName(), StringKey.class.getName(), IntKey.class.getName(), LongKey.class.getName(), MapKey.class.getName(), ClassKey.class.getName());
+
+      return typeMirror.getAnnotationMirrors().stream()
+              .filter(e -> Util.isAnnotationPresent(MoreTypes.asElement(typeMirror), e.getAnnotationType()))
+              .findFirst();
+    }
+
+    private static java.util.Optional<? extends AnnotationMirror> getAnnotationMirror(ExecutableElement method) {
+      final ImmutableList<String> annotations =
+              ImmutableList.of(Named.class.getName(), StringKey.class.getName(), IntKey.class.getName(), LongKey.class.getName(), MapKey.class.getName(), ClassKey.class.getName());
+
+      return method.getAnnotationMirrors().stream()
+              .filter(e -> annotations.contains(e.getAnnotationType().toString()))
+              .findFirst();
+    }
+
     @Override
     public boolean equals(Object obj) {
       return obj instanceof MultibindingContributionIdentifier
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/ModuleProcessingStep.java
index 28bac6826..80150627c 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleProcessingStep.java
@@ -50,13 +50,14 @@ static ModuleProcessingStep moduleProcessingStep(
       Messager messager,
       ModuleValidator moduleValidator,
       ProvisionBinding.Factory provisionBindingFactory,
-      FactoryGenerator factoryGenerator) {
+      MultipleSourceFileGenerator<ProvisionBinding> multipleSourceFileGenerator) {
     return new ModuleProcessingStep(
         messager,
         Module.class,
         moduleValidator,
-        ImmutableSet.of(
-            new ProvisionModuleMethodFactoryGenerator(provisionBindingFactory, factoryGenerator)));
+        ImmutableSet.<ModuleMethodFactoryGenerator>of(
+            new ProvisionModuleMethodFactoryGenerator(provisionBindingFactory, multipleSourceFileGenerator))
+    );
   }
 
   /**
@@ -67,7 +68,7 @@ static ModuleProcessingStep producerModuleProcessingStep(
       Messager messager,
       ModuleValidator moduleValidator,
       ProvisionBinding.Factory provisionBindingFactory,
-      FactoryGenerator factoryGenerator,
+      MultipleSourceFileGenerator<ProvisionBinding> multipleSourceFileGenerator,
       ProductionBinding.Factory productionBindingFactory,
       ProducerFactoryGenerator producerFactoryGenerator) {
     return new ModuleProcessingStep(
@@ -75,7 +76,7 @@ static ModuleProcessingStep producerModuleProcessingStep(
         ProducerModule.class,
         moduleValidator,
         ImmutableSet.of(
-            new ProvisionModuleMethodFactoryGenerator(provisionBindingFactory, factoryGenerator),
+            new ProvisionModuleMethodFactoryGenerator(provisionBindingFactory, multipleSourceFileGenerator),
             new ProductionModuleMethodFactoryGenerator(
                 productionBindingFactory, producerFactoryGenerator)));
   }
@@ -146,10 +147,10 @@ private void processModule(TypeElement module) {
       implements ModuleMethodFactoryGenerator {
 
     private final ProvisionBinding.Factory provisionBindingFactory;
-    private final FactoryGenerator factoryGenerator;
+    private final MultipleSourceFileGenerator<ProvisionBinding> factoryGenerator;
 
     ProvisionModuleMethodFactoryGenerator(
-        ProvisionBinding.Factory provisionBindingFactory, FactoryGenerator factoryGenerator) {
+        ProvisionBinding.Factory provisionBindingFactory, MultipleSourceFileGenerator<ProvisionBinding> factoryGenerator) {
       this.provisionBindingFactory = provisionBindingFactory;
       this.factoryGenerator = factoryGenerator;
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleStatement.java b/compiler/src/main/java/dagger/internal/codegen/ModuleStatement.java
new file mode 100644
index 000000000..757bcba41
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleStatement.java
@@ -0,0 +1,135 @@
+package dagger.internal.codegen;
+
+import com.google.common.collect.ImmutableSet;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+import dagger.Injector;
+import dagger.internal.Preconditions;
+
+import javax.inject.Inject;
+import javax.lang.model.element.*;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Types;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.function.Function;
+import java.util.stream.Collectors;
+
+import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
+
+/**
+ * Created by Andy on 06.05.2017.
+ */
+public class ModuleStatement implements InitializationStatement {
+
+    protected Types types;
+    protected TypeElement injector;
+    protected ComponentDescriptor descriptor;
+    protected Map<TypeElement, ExecutableElement> moduleMethodMap;
+    protected Map<Key, VariableElement> providedParams;
+
+    public ModuleStatement(Types types, TypeElement injector, ComponentDescriptor descriptor, Map<TypeElement, ExecutableElement> moduleMethodMap, Map<Key, VariableElement> providedParams) {
+        Preconditions.checkNotNull(types, "types is null!");
+        this.types = types;
+        Preconditions.checkNotNull(injector, "injector is null!");
+        this.injector = injector;
+        Preconditions.checkNotNull(descriptor, "descriptor is null!");
+        this.descriptor = descriptor;
+        Preconditions.checkNotNull(moduleMethodMap, "moduleMethodMap is null!");
+        this.moduleMethodMap = moduleMethodMap;
+        Preconditions.checkNotNull(providedParams, "providedParams is null!");
+        this.providedParams = providedParams;
+    }
+
+    @Override
+    public CodeBlock get() {
+        final CodeBlock.Builder codeBuilder = CodeBlock.builder();
+        return codeBuilder.build();
+        /*final ImmutableSet<ModuleDescriptor> modules = descriptor.modules();
+
+        if (isSubComponent() && !descriptor.builderSpec().isPresent()) {
+            return CodeBlock.builder().build();
+        }
+
+        for (ModuleDescriptor moduleDescriptor : modules) {
+            final TypeElement moduleElement = moduleDescriptor.moduleElement();
+            final ExecutableElement method = moduleMethodMap.get(moduleElement);
+            Map<Key, VariableElement> parameterMap;
+            if (method != null) {
+                parameterMap = buildParameterMapWithProvidingModuleMethod(method);
+            }else {
+                parameterMap = getConstructorParameterMap(moduleElement);
+            }
+            final List<CodeBlock> arguments = new ArrayList<>();
+            for (Map.Entry<Key, VariableElement> entry : parameterMap.entrySet()) {
+                if (resolvesToInjectorType(entry)) {
+                    arguments.add(CodeBlock.of("$L", "this"));
+                } else {
+                    final VariableElement variableElement = providedParams.get(entry.getKey());
+                    if (variableElement == null) {
+                        throw new IllegalStateException("parameter is null in providedParams in ModuleStatement for param:" + entry.getValue().asType().toString() + " in module: " + moduleElement.getSimpleName().toString());
+                    }
+                    arguments.add(CodeBlock.of("$L", variableElement.getSimpleName().toString()));
+                }
+            }
+
+            String methodName = Util.lowerCaseFirstLetter(moduleElement.getSimpleName().toString());
+
+            if (descriptor.builderSpec().isPresent()) {
+                final ExecutableElement executableElement = descriptor.builderSpec().get().methodMap().get(moduleElement);
+                methodName = executableElement.getSimpleName().toString();
+            }
+
+            if (method != null) {
+                codeBuilder.add(".$L(this.$L($L))\n",
+                        methodName,
+                        method.getSimpleName().toString(),
+                        makeParametersCodeBlock(arguments)
+                );
+            }else {
+                codeBuilder.add(".$L(new $T($L))\n",
+                        methodName,
+                        ClassName.get(moduleElement),
+                        makeParametersCodeBlock(arguments)
+                );
+            }
+        }
+        return codeBuilder.build();*/
+    }
+
+    private boolean isSubComponent() {
+        return descriptor.kind() == ComponentDescriptor.Kind.SUBCOMPONENT;
+    }
+
+    private Map<Key, VariableElement> buildParameterMapWithProvidingModuleMethod(ExecutableElement providingModuleMethod) {
+        return getMethodParameterMap(providingModuleMethod);
+    }
+
+    private boolean resolvesToInjectorType(Map.Entry<Key, VariableElement> entry) {
+        final TypeMirror type = entry.getKey().type();
+        return types.isAssignable(injector.asType(), type);
+    }
+
+    private Map<Key, VariableElement> getMethodParameterMap(ExecutableElement element) {
+        return element.getParameters()
+                .stream()
+                .collect(Collectors.toMap(e -> Key.builder(e.asType()).build(), Function.identity()));
+    }
+
+    private Map<Key, VariableElement> getConstructorParameterMap(TypeElement element) {
+        Map<Key, VariableElement> result = new HashMap<>();
+        final List<? extends Element> enclosedElements = element.getEnclosedElements();
+        for (Element enclosedElement : enclosedElements) {
+            if (enclosedElement.getKind() == ElementKind.CONSTRUCTOR) {
+                ExecutableElement executableElement = (ExecutableElement) enclosedElement;
+                final List<? extends VariableElement> parameters = executableElement.getParameters();
+                for (VariableElement parameter : parameters) {
+                    result.put(Key.builder(parameter.asType()).build(), parameter);
+                }
+            }
+        }
+        return result;
+    }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java b/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java
index 6d24a5c9e..fd0a59a09 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java
@@ -394,12 +394,14 @@ private void validateProvidesOverrides(
           if (!failedMethods.contains(providesMethod)
               && elements.overrides(providesMethod, superclassMethod, subject)) {
             failedMethods.add(providesMethod);
+            /**
             builder.addError(
                 String.format(
                     PROVIDES_METHOD_OVERRIDES_ANOTHER,
                     moduleKind.methodAnnotation().getSimpleName(),
                     methodSignatureFormatter.format(superclassMethod)),
                 providesMethod);
+             **/
           }
         }
         // For each @Provides method in superclass, confirm our methods don't override it.
diff --git a/compiler/src/main/java/dagger/internal/codegen/MultipleSourceFileGenerator.java b/compiler/src/main/java/dagger/internal/codegen/MultipleSourceFileGenerator.java
new file mode 100644
index 000000000..cb79ebacc
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/MultipleSourceFileGenerator.java
@@ -0,0 +1,46 @@
+package dagger.internal.codegen;
+
+import java.util.Optional;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.TypeSpec;
+
+import javax.annotation.processing.Filer;
+import javax.lang.model.element.Element;
+import javax.lang.model.util.Elements;
+import java.util.Iterator;
+import java.util.List;
+
+public class MultipleSourceFileGenerator<T> extends SourceFileGenerator<T> {
+
+    private List<SourceFileGenerator<T>> generators;
+    private SourceFileGenerator<T> current;
+
+    MultipleSourceFileGenerator(Filer filer, Elements elements, List<SourceFileGenerator<T>> generators) {
+        super(filer, elements);
+        this.generators = generators;
+    }
+
+    @Override
+    ClassName nameGeneratedType(T input) {
+        return current.nameGeneratedType(input);
+    }
+
+    @Override
+    Optional<? extends Element> getElementForErrorReporting(T input) {
+        return current.getElementForErrorReporting(input);
+    }
+
+    @Override
+    Optional<TypeSpec.Builder> write(ClassName generatedTypeName, T input) {
+        return current.write(generatedTypeName, input);
+    }
+
+    @Override
+    void generate(T input) throws SourceFileGenerationException {
+        final Iterator<SourceFileGenerator<T>> it = generators.iterator();
+        while(it.hasNext()) {
+            current = it.next();
+            current.generate(input);
+        }
+    }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
index dd9f3a18b..a63dc8e5a 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
@@ -103,6 +103,7 @@ public BindingType bindingType() {
   private static Builder builder() {
     return new AutoValue_ProductionBinding.Builder()
         .explicitDependencies(ImmutableList.<DependencyRequest>of())
+        .genericParameter(false)
         .thrownTypes(ImmutableList.<TypeMirror>of());
   }
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvidingMethodOverrider.java b/compiler/src/main/java/dagger/internal/codegen/ProvidingMethodOverrider.java
new file mode 100644
index 000000000..9e68702fd
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvidingMethodOverrider.java
@@ -0,0 +1,82 @@
+package dagger.internal.codegen;
+
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.MethodSpec;
+import com.squareup.javapoet.TypeSpec;
+
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+
+import static dagger.internal.codegen.Util.createDelegateFieldAndMethod;
+
+/**
+ * Created by Andy on 06.05.2017.
+ */
+public class ProvidingMethodOverrider {
+
+    private final TypeElement component;
+    private final ComponentDescriptor descriptor;
+    private final ExecutableElement executableElement;
+    private List<InitializationStatement> statements;
+    private BindingGraph bindingGraph;
+    private List<ProvidingMethodOverrider> subcomponentOverriders = new ArrayList<>();
+
+    public ProvidingMethodOverrider(TypeElement component, ComponentDescriptor descriptor, ExecutableElement executableElement, List<InitializationStatement> statements, BindingGraph bindingGraph) {
+        this.component = component;
+        this.descriptor = descriptor;
+        this.executableElement = executableElement;
+        this.statements = statements;
+        this.bindingGraph = bindingGraph;
+    }
+
+    public TypeElement getComponent() {
+        return component;
+    }
+
+    public ComponentDescriptor getDescriptor() {
+        return descriptor;
+    }
+
+    public ExecutableElement getExecutableElement() {
+        return executableElement;
+    }
+
+    public List<InitializationStatement> getStatements() {
+        return statements;
+    }
+
+    public void add(ProvidingMethodOverrider providingMethodOverrider) {
+        subcomponentOverriders.add(providingMethodOverrider);
+    }
+
+    public void process(TypeSpec.Builder builder, ClassName generatedTypeName, Map<Key, String> delegateFieldNames) {
+        for (ProvidingMethodOverrider subcomponentOverrider : subcomponentOverriders) {
+            subcomponentOverrider.process(builder, generatedTypeName, delegateFieldNames);
+        }
+
+        this.getBindingGraph().resolvedBindings().values().forEach(resolvedBindings -> {
+            if (!resolvedBindings.isEmpty() && resolvedBindings.bindingType() == BindingType.PROVISION && Util.bindingSupportsTestDelegate(resolvedBindings.contributionBinding())) {
+                if (!delegateFieldNames.containsKey(resolvedBindings.key())) {
+                    createDelegateFieldAndMethod(generatedTypeName, builder, resolvedBindings, delegateFieldNames);
+                }
+            }
+        });
+
+        final MethodSpec.Builder methodSpec = MethodSpec.overriding(this.getExecutableElement());
+        final List<InitializationStatement> statements = this.getStatements();
+        final CodeBlock.Builder codeBuilder = CodeBlock.builder();
+        for (InitializationStatement statement : statements) {
+            codeBuilder.add(statement.get());
+        }
+        methodSpec.addStatement("return $L", codeBuilder.build());
+        builder.addMethod(methodSpec.build());
+    }
+
+    public BindingGraph getBindingGraph() {
+        return bindingGraph;
+    }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
index 5de760e93..79265877d 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
@@ -37,6 +37,8 @@
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import dagger.internal.codegen.ComponentDescriptor.BuilderRequirementMethod;
 import java.util.Optional;
+import dagger.IgnoreStubGeneration;
+import java.util.Set;
 import javax.annotation.CheckReturnValue;
 import javax.inject.Inject;
 import javax.inject.Provider;
@@ -84,6 +86,8 @@ public BindingType bindingType() {
 
   private static Builder builder() {
     return new AutoValue_ProvisionBinding.Builder()
+        .genericParameter(false)
+        .ignoreStubGeneration(false)
         .explicitDependencies(ImmutableSet.<DependencyRequest>of());
   }
   
@@ -155,6 +159,7 @@ ProvisionBinding forInjectConstructor(
           ProvisionBinding.builder()
               .contributionType(ContributionType.UNIQUE)
               .bindingElement(constructorElement)
+              .ignoreStubGeneration(constructorElement.getAnnotation(IgnoreStubGeneration.class) != null)
               .key(key)
               .explicitDependencies(dependencies)
               .membersInjectionRequest(membersInjectionRequest)
@@ -190,6 +195,8 @@ ProvisionBinding forInjectConstructor(
     ProvisionBinding forProvidesMethod(
         ExecutableElement providesMethod, TypeElement contributedBy) {
       checkArgument(providesMethod.getKind().equals(METHOD));
+      final DeclaredType declaredType = (DeclaredType) contributedBy.asType();
+      boolean genericParameter = !declaredType.getTypeArguments().isEmpty();
       ExecutableType resolvedMethod =
           MoreTypes.asExecutable(
               types.asMemberOf(MoreTypes.asDeclared(contributedBy.asType()), providesMethod));
@@ -201,8 +208,10 @@ ProvisionBinding forProvidesMethod(
       return ProvisionBinding.builder()
           .contributionType(ContributionType.fromBindingMethod(providesMethod))
           .bindingElement(providesMethod)
+          .ignoreStubGeneration(providesMethod.getAnnotation(IgnoreStubGeneration.class) != null)
           .contributingModule(contributedBy)
           .key(key)
+          .genericParameter(genericParameter)
           .explicitDependencies(dependencies)
           .nullableType(ConfigurationAnnotations.getNullableType(providesMethod))
           .wrappedMapKey(wrapOptionalInEquivalence(getMapKey(providesMethod)))
@@ -277,6 +286,7 @@ ProvisionBinding forBuilderBinding(BuilderRequirementMethod method) {
       return ProvisionBinding.builder()
           .contributionType(ContributionType.UNIQUE)
           .bindingElement(builderMethod)
+          .ignoreStubGeneration(builderMethod.getAnnotation(IgnoreStubGeneration.class) != null)
           .key(method.requirement().key().get())
           .nullableType(ConfigurationAnnotations.getNullableType(parameterElement))
           .bindingKind(Kind.BUILDER_BINDING)
@@ -291,6 +301,7 @@ ProvisionBinding forSubcomponentBuilderMethod(
       DeclaredType declaredContainer = asDeclared(contributedBy.asType());
       return ProvisionBinding.builder()
           .contributionType(ContributionType.UNIQUE)
+          .ignoreStubGeneration(subcomponentBuilderMethod.getAnnotation(IgnoreStubGeneration.class) != null)
           .bindingElement(subcomponentBuilderMethod)
           .key(
               keyFactory.forSubcomponentBuilderMethod(subcomponentBuilderMethod, declaredContainer))
diff --git a/compiler/src/main/java/dagger/internal/codegen/SimpleMethodRequestFulfillment.java b/compiler/src/main/java/dagger/internal/codegen/SimpleMethodRequestFulfillment.java
index 8c7fb6dfb..492b6b9e4 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SimpleMethodRequestFulfillment.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SimpleMethodRequestFulfillment.java
@@ -111,7 +111,7 @@ private CodeBlock invokeMethod(ClassName requestingClass) {
     ExecutableElement method = asExecutable(provisionBinding.bindingElement().get());
     switch (method.getKind()) {
       case CONSTRUCTOR:
-        return CodeBlock.of("new $T($L)", provisionBinding.key().type(), parametersCodeBlock);
+          return CodeBlock.of("new $T($L)", provisionBinding.key().type(), parametersCodeBlock);
       case METHOD:
         checkState(method.getModifiers().contains(STATIC));
         return CodeBlock.of(
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerator.java b/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerator.java
index 436a7484e..54aa888f3 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerator.java
@@ -17,18 +17,17 @@
 package dagger.internal.codegen;
 
 import static com.google.common.base.Preconditions.checkNotNull;
-
 import com.google.common.base.Throwables;
 import com.squareup.javapoet.AnnotationSpec;
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.JavaFile;
 import com.squareup.javapoet.TypeSpec;
-import java.util.Optional;
 import javax.annotation.Generated;
 import javax.annotation.processing.Filer;
 import javax.annotation.processing.Messager;
 import javax.lang.model.element.Element;
 import javax.lang.model.util.Elements;
+import java.util.Optional;
 
 /**
  * A template class that provides a framework for properly handling IO while generating source files
@@ -74,7 +73,8 @@ void generate(T input) throws SourceFileGenerationException {
       return;
     }
     try {
-      buildJavaFile(generatedTypeName, type.get()).writeTo(filer);
+      final JavaFile javaFile = buildJavaFile(generatedTypeName, type.get());
+      javaFile.writeTo(filer);
     } catch (Exception e) {
       // if the code above threw a SFGE, use that
       Throwables.propagateIfPossible(e, SourceFileGenerationException.class);
@@ -84,7 +84,7 @@ void generate(T input) throws SourceFileGenerationException {
     }
   }
 
-  private JavaFile buildJavaFile(
+  protected JavaFile buildJavaFile(
       ClassName generatedTypeName, TypeSpec.Builder typeSpecBuilder) {
     if (generatedAnnotationAvailable) {
       typeSpecBuilder.addAnnotation(GENERATED);
diff --git a/compiler/src/main/java/dagger/internal/codegen/SpecComponentInfo.java b/compiler/src/main/java/dagger/internal/codegen/SpecComponentInfo.java
new file mode 100644
index 000000000..8159ab845
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/SpecComponentInfo.java
@@ -0,0 +1,62 @@
+package dagger.internal.codegen;
+
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.MethodSpec;
+import com.squareup.javapoet.ParameterSpec;
+import com.squareup.javapoet.TypeSpec;
+
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.TypeElement;
+import java.util.ArrayList;
+import java.util.List;
+
+import static dagger.internal.codegen.AbstractComponentWriter.simpleVariableName;
+
+/**
+ * Created by Andy on 12.05.2017.
+ */
+public class SpecComponentInfo extends ComponentInfo {
+
+    protected SpecComponentInfo(TypeElement component, ComponentDescriptor descriptor, BindingGraph bindingGraph) {
+        super(component, descriptor, bindingGraph);
+    }
+
+    @Override
+    public void process(TypeSpec.Builder builder) {
+        super.process(builder);
+
+        final MethodSpec.Builder methodBuilder = MethodSpec.methodBuilder(simpleVariableName(component))
+                .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT);
+
+        ClassName builderClassName = getBuilderClassName(component);
+        methodBuilder.returns(builderClassName);
+        List<ParameterSpec> parameterSpecs = new ArrayList<>();
+
+        ParameterSpec builderParameter = ParameterSpec.builder(builderClassName, "builder").build();
+
+        parameterSpecs.add(builderParameter);
+
+        if (descriptor.builderSpec().isPresent()) {
+            for (ComponentDescriptor.BuilderRequirementMethod requirementMethod : descriptor.builderSpec().get().requirementMethods()) {
+                final ComponentRequirement requirement = requirementMethod.requirement();
+                final TypeElement typeElement = requirement.typeElement();
+                if ((requirement.kind() == ComponentRequirement.Kind.MODULE && hasNotOnlyNoArgConstructor(typeElement, requirement.autoCreate())) || requirement.kind() != ComponentRequirement.Kind.MODULE) {
+                    parameterSpecs.add(ParameterSpec.builder(ClassName.get(typeElement), simpleVariableName(typeElement)).build());
+                }
+            }
+        } else {
+            for (ModuleDescriptor moduleDescriptor : descriptor.modules()) {
+                final TypeElement typeElement = moduleDescriptor.moduleElement();
+                if (hasNotOnlyNoArgConstructor(typeElement, autoCreate(typeElement))) {
+                    parameterSpecs.add(ParameterSpec.builder(ClassName.get(typeElement), simpleVariableName(typeElement)).build());
+                }
+            }
+
+            for (TypeElement typeElement : descriptor.dependencies()) {
+                parameterSpecs.add(ParameterSpec.builder(ClassName.get(typeElement), simpleVariableName(typeElement)).build());
+            }
+        }
+
+        builder.addMethod(methodBuilder.addParameters(parameterSpecs).build());
+    }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/StubGenerator.java b/compiler/src/main/java/dagger/internal/codegen/StubGenerator.java
new file mode 100644
index 000000000..a3449951b
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/StubGenerator.java
@@ -0,0 +1,100 @@
+package dagger.internal.codegen;
+
+import com.google.auto.common.BasicAnnotationProcessor;
+import java.util.Optional;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.SetMultimap;
+import com.squareup.javapoet.*;
+import dagger.Lazy;
+
+import javax.annotation.processing.Filer;
+import javax.inject.Provider;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
+import java.lang.annotation.Annotation;
+import java.util.*;
+
+import static dagger.internal.codegen.SourceFiles.DEPENDENCY_ORDERING;
+import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
+import static dagger.internal.codegen.SourceFiles.generateBindingFieldsForDependencies;
+import static dagger.internal.codegen.TypeNames.*;
+
+
+public class StubGenerator extends SourceFileGenerator<ProvisionBinding> {
+
+    private final Types types;
+
+    private final List<String> generated = new ArrayList<>();
+
+    StubGenerator(Filer filer, Elements elements, Types types) {
+        super(filer, elements);
+        this.types = types;
+    }
+
+    @Override
+    ClassName nameGeneratedType(ProvisionBinding input) {
+        return Util.getDelegateTypeName(input.key());
+    }
+
+    @Override
+    Optional<? extends Element> getElementForErrorReporting(ProvisionBinding input) {
+        return input.bindingElement();
+    }
+
+    @Override
+    Optional<TypeSpec.Builder> write(ClassName generatedTypeName, ProvisionBinding input) {
+        final String o = generatedTypeName.packageName() + "." + generatedTypeName.simpleName();
+        if (generated.contains(o) || !Util.bindingSupportsTestDelegate(input)) {
+            return Optional.empty();
+        }
+        generated.add(o);
+        final MethodSpec.Builder methodBuilder = MethodSpec.methodBuilder("get");
+        methodBuilder.addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT);
+        final TypeName contributedTypeName = ClassName.get(input.contributedType());
+        methodBuilder.returns(contributedTypeName);
+        List<ParameterSpec> parameterSpecList = new ArrayList<>();
+        HashMap<BindingKey, FrameworkField> fields = new HashMap<>();
+        for (Map.Entry<BindingKey, FrameworkField> entry : generateBindingFieldsForDependencies(input).entrySet()) {
+            FrameworkField bindingField = entry.getValue();
+            fields.put(entry.getKey(), bindingField);
+        }
+
+        for (DependencyRequest request : input.explicitDependencies()) {
+            final FrameworkField frameworkField = fields.get(request.bindingKey());
+            TypeName typeName = request.kind() == DependencyRequest.Kind.INSTANCE ?
+                    frameworkField.type().typeArguments.get(0) :
+                    frameworkTypeUsageStatement(frameworkField.type().typeArguments.get(0), request.kind());
+
+            final String name = request.kind() == DependencyRequest.Kind.INSTANCE ?
+                    frameworkField.name().replaceAll("Provider$", "") :
+                    frameworkField.name();
+            parameterSpecList.add(ParameterSpec.builder(typeName, name).build());
+        }
+
+        return Optional.of(TypeSpec.interfaceBuilder(generatedTypeName)
+                .addModifiers(Modifier.PUBLIC)
+                .addMethod(methodBuilder.addParameters(parameterSpecList).build()));
+    }
+
+    static TypeName frameworkTypeUsageStatement(TypeName type, DependencyRequest.Kind dependencyKind) {
+        switch (dependencyKind) {
+            case LAZY:
+                return ParameterizedTypeName.get(LAZY, type);
+            case INSTANCE:
+                return type;
+            case PROVIDER:
+                return ParameterizedTypeName.get(PROVIDER, type);
+            case PRODUCER:
+                return ParameterizedTypeName.get(PRODUCER, type);
+            case MEMBERS_INJECTOR:
+                return ParameterizedTypeName.get(MEMBERS_INJECTOR, type);
+            case PROVIDER_OF_LAZY:
+                return ParameterizedTypeName.get(PROVIDER_OF_LAZY, type);
+            default:
+                return ParameterizedTypeName.get(PROVIDER, type);
+        }
+    }
+
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/SubcomponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/SubcomponentWriter.java
index 8f143819c..1b276ebf5 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SubcomponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SubcomponentWriter.java
@@ -119,7 +119,7 @@ private ExecutableType resolvedSubcomponentFactoryMethod() {
 
   @Override
   protected void decorateComponent() {
-    component.addModifiers(PRIVATE, FINAL);
+    component.addModifiers(PUBLIC, FINAL);
     addSupertype(
         component,
         MoreTypes.asTypeElement(
diff --git a/compiler/src/main/java/dagger/internal/codegen/TestClassGenerator.java b/compiler/src/main/java/dagger/internal/codegen/TestClassGenerator.java
new file mode 100644
index 000000000..b734cdacf
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/TestClassGenerator.java
@@ -0,0 +1,75 @@
+package dagger.internal.codegen;
+
+import com.google.auto.common.MoreTypes;
+import java.util.Optional;
+import com.squareup.javapoet.*;
+import dagger.Trigger;
+
+import javax.annotation.processing.Filer;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.util.Elements;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.Set;
+import java.util.UUID;
+
+/**
+ * Created by Andy on 07.05.2017.
+ */
+public class TestClassGenerator extends SourceFileGenerator<TestRegistry> {
+
+    private Set<TypeElement> components;
+    private TypeElement injector;
+
+    TestClassGenerator(Filer filer, Elements elements) {
+        super(filer, elements);
+    }
+
+    @Override
+    ClassName nameGeneratedType(TestRegistry input) {
+        return input.getClassName();
+    }
+
+    @Override
+    Optional<? extends Element> getElementForErrorReporting(TestRegistry input) {
+        return Optional.empty();
+    }
+
+    @Override
+    Optional<TypeSpec.Builder> write(ClassName generatedTypeName, TestRegistry input) {
+        final TypeSpec.Builder builder = TypeSpec.classBuilder(generatedTypeName);
+        final Iterator<TestRegistry.EncodedClass> it = input.iterator();
+        UniqueNameSet uniqueNameSet = new UniqueNameSet();
+        while(it.hasNext()) {
+            final TestRegistry.EncodedClass encodedClass = it.next();
+            final String randomString = UUID.randomUUID().toString().replace("-", "_");
+            final String randomMethodName = uniqueNameSet.getUniqueName("Method_" + randomString);
+            builder.addMethod(MethodSpec.methodBuilder(randomMethodName)
+                                .addAnnotation(AnnotationSpec.builder(Trigger.class)
+                                    .addMember("value", CodeBlock.of("$S", encodedClass.encoded))
+                                    .addMember("qualifiedName", CodeBlock.of("$S", encodedClass.qualifiedName))
+                                    .build())
+                                .build()
+            );
+        }
+
+        builder.addAnnotation(AnnotationSpec.builder(Trigger.class)
+            .addMember("value", CodeBlock.of("$S", "injector"))
+            .addMember("qualifiedName", CodeBlock.of("$S", injector.getQualifiedName().toString()))
+            .build());
+
+        return Optional.of(builder);
+    }
+
+    public void setComponents(Set<TypeElement> components) {
+        if (components == null) {
+            components = new HashSet<>();
+        }
+        this.components = components;
+    }
+
+    public void setInjector(TypeElement injector) {
+        this.injector = injector;
+    }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/TestRegistry.java b/compiler/src/main/java/dagger/internal/codegen/TestRegistry.java
new file mode 100644
index 000000000..be2bcd5f6
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/TestRegistry.java
@@ -0,0 +1,52 @@
+package dagger.internal.codegen;
+
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.JavaFile;
+import javax.tools.JavaFileObject;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.ArrayList;
+import java.util.Base64;
+import java.util.Iterator;
+import java.util.List;
+
+import static com.google.common.io.ByteStreams.toByteArray;
+
+/**
+ * Created by Andy on 07.05.2017.
+ */
+public class TestRegistry {
+
+    private List<EncodedClass> encodedClasses = new ArrayList<>();
+
+    public void addEncodedClass(ClassName className, JavaFile javaFile) throws IOException {
+        final JavaFileObject javaFileObject = javaFile.toJavaFileObject();
+        final InputStream inputStream = javaFileObject.openInputStream();
+        final String encodedClass = java.util.Base64.getEncoder().encodeToString(toByteArray(inputStream));
+        final String name = className.packageName() + "." + className.simpleName();
+        encodedClasses.add(new EncodedClass(name, encodedClass));
+    }
+
+    public ClassName getClassName() {
+        return ClassName.bestGuess("dagger.TestTrigger");
+    }
+
+    public Iterator<EncodedClass> iterator() {
+        return encodedClasses.iterator();
+    }
+
+    public byte[] decodeClass(String value) {
+        return Base64.getDecoder().decode(value);
+    }
+
+    public static class EncodedClass {
+
+        public EncodedClass(String qualifiedName, String encoded) {
+            this.qualifiedName = qualifiedName;
+            this.encoded = encoded;
+        }
+
+        public String qualifiedName;
+        public String encoded;
+    }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/TriggerComponentInfo.java b/compiler/src/main/java/dagger/internal/codegen/TriggerComponentInfo.java
new file mode 100644
index 000000000..ab17af175
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/TriggerComponentInfo.java
@@ -0,0 +1,128 @@
+package dagger.internal.codegen;
+
+import com.google.common.collect.ImmutableBiMap;
+import com.google.common.collect.ImmutableCollection;
+import com.squareup.javapoet.*;
+
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.TypeElement;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.stream.Collectors;
+
+import static dagger.internal.codegen.AbstractComponentWriter.simpleVariableName;
+import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
+import static dagger.internal.codegen.Util.bindingSupportsTestDelegate;
+import static dagger.internal.codegen.Util.getDelegateTypeName;
+
+
+public class TriggerComponentInfo extends ComponentInfo {
+
+    private final BindingGraph.Factory bindingGraphFactory;
+
+    protected TriggerComponentInfo(TypeElement typeElement, ComponentDescriptor descriptor,
+                                   BindingGraph bindingGraph, BindingGraph.Factory bindingGraphFactory) {
+        super(typeElement, descriptor, bindingGraph);
+        this.bindingGraphFactory = bindingGraphFactory;
+    }
+
+    @Override
+    public void process(TypeSpec.Builder builder) {
+        super.process(builder);
+
+        final TypeElement component = descriptor.componentDefinitionType();
+        String methodName = simpleVariableName(component);
+        final MethodSpec.Builder methodBuilder = MethodSpec.methodBuilder(methodName)
+                .addAnnotation(Override.class)
+                .addModifiers(Modifier.PUBLIC);
+
+        ClassName builderClassName = getBuilderClassName(component);
+        methodBuilder.returns(builderClassName);
+        List<ParameterSpec> parameterSpecs = new ArrayList<>();
+
+        ParameterSpec builderParameter = ParameterSpec.builder(builderClassName, "builder").build();
+
+        parameterSpecs.add(builderParameter);
+
+        if(descriptor.builderSpec().isPresent()) {
+            final ComponentDescriptor.BuilderSpec builderSpec = descriptor.builderSpec().get();
+            for (ComponentDescriptor.BuilderRequirementMethod builderRequirementMethod : builderSpec.requirementMethods()) {
+                final ComponentRequirement requirement = builderRequirementMethod.requirement();
+                final TypeElement typeElement = requirement.typeElement();
+                if ((requirement.kind() == ComponentRequirement.Kind.MODULE &&
+                        hasNotOnlyNoArgConstructor(typeElement, requirement.autoCreate())) || requirement.kind() != ComponentRequirement.Kind.MODULE) {
+                    parameterSpecs.add(ParameterSpec.builder(ClassName.get(typeElement), simpleVariableName(typeElement)).build());
+                }
+            }
+        }else {
+            for (ModuleDescriptor moduleDescriptor : descriptor.modules()) {
+                final TypeElement typeElement = moduleDescriptor.moduleElement();
+                if (hasNotOnlyNoArgConstructor(typeElement, autoCreate(typeElement))) {
+                    parameterSpecs.add(ParameterSpec.builder(ClassName.get(typeElement), simpleVariableName(typeElement)).build());
+                }
+            }
+        }
+
+        methodBuilder.addParameters(parameterSpecs);
+
+        final List<CodeBlock> params = parameterSpecs.stream()
+                .map(parameterSpec -> CodeBlock.of("$L", parameterSpec.name))
+                .collect(Collectors.toList());
+
+        String className = resolveClassName(bindingGraphFactory, descriptor);
+
+        final ClassName name = ClassName.bestGuess(className);
+        methodBuilder.addStatement("$T componentBuilder = ($T) super.$L($L)\n",
+                name, name, methodName, makeParametersCodeBlock(params));
+
+        final String decoratorName = Util.lowerCaseFirstLetter(component.getSimpleName().toString()) + "Decorator";
+
+        methodBuilder.addStatement("this.$L.decorate(componentBuilder)", decoratorName);
+
+        methodBuilder.addStatement("return componentBuilder");
+
+        builder.addMethod(methodBuilder.build());
+    }
+
+    public static String resolveClassName(BindingGraph.Factory bindingGraphFactory, ComponentDescriptor descriptor) {
+        if (descriptor.kind() == ComponentDescriptor.Kind.COMPONENT) {
+            final ClassName daggerComponentClassName = Util.getDaggerComponentClassName(descriptor.componentDefinitionType());
+            return daggerComponentClassName.packageName() + "." + daggerComponentClassName.simpleName() + ".Builder";
+        }else if (descriptor.kind() == ComponentDescriptor.Kind.SUBCOMPONENT) {
+            final ComponentDescriptor parentDescriptor = descriptor.getParentDescriptor();
+            final String parentClassName = resolveClassName2(parentDescriptor, bindingGraphFactory);
+            final BindingGraph parentGraph = bindingGraphFactory.create(parentDescriptor);
+            final ImmutableBiMap<ComponentDescriptor, String> subcomponentNamesMap =
+                    new ComponentWriter.UniqueSubcomponentNamesGenerator(parentGraph).generate();
+            final String s = subcomponentNamesMap.get(descriptor);
+            if (s == null) {
+                throw new NullPointerException("s is null | " + subcomponentNamesMap.values().toString() + "|" + descriptor.componentDefinitionType().asType().toString());
+            }
+            return parentClassName + "." + s + "Builder";
+        }else {
+            throw new IllegalStateException("unknown");
+        }
+    }
+
+    public static String resolveClassName2(ComponentDescriptor descriptor, BindingGraph.Factory bindingGraphFactory) {
+        if (descriptor.kind() == ComponentDescriptor.Kind.COMPONENT) {
+            final ClassName daggerComponentClassName = Util.getDaggerComponentClassName(descriptor.componentDefinitionType());
+            return daggerComponentClassName.packageName() + "." + daggerComponentClassName.simpleName();
+        }else if (descriptor.kind() == ComponentDescriptor.Kind.SUBCOMPONENT) {
+            final ComponentDescriptor parentDescriptor = descriptor.getParentDescriptor();
+            final String parentClassName = resolveClassName2(parentDescriptor, bindingGraphFactory);
+            final BindingGraph parentGraph = bindingGraphFactory.create(parentDescriptor);
+            final ImmutableBiMap<ComponentDescriptor, String> subcomponentNamesMap =
+                    new ComponentWriter.UniqueSubcomponentNamesGenerator(parentGraph).generate();
+            final String s = subcomponentNamesMap.get(descriptor);
+            if (s == null) {
+                throw new NullPointerException("s is null | " + subcomponentNamesMap.values().toString() + "|" + descriptor.componentDefinitionType().asType().toString());
+            }
+            return parentClassName + "." + s + "Impl";
+        }else {
+            throw new IllegalStateException("unknown");
+        }
+    }
+
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/TriggerProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/TriggerProcessingStep.java
new file mode 100644
index 000000000..796ff67ac
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/TriggerProcessingStep.java
@@ -0,0 +1,59 @@
+package dagger.internal.codegen;
+
+import com.google.auto.common.BasicAnnotationProcessor;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.SetMultimap;
+import dagger.Trigger;
+import javax.annotation.processing.Filer;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ExecutableElement;
+import javax.tools.JavaFileObject;
+import java.io.IOException;
+import java.io.OutputStream;
+import java.lang.annotation.Annotation;
+import java.util.List;
+import java.util.Set;
+import java.util.stream.Collectors;
+
+/**
+ * Created by Andy on 07.05.2017.
+ */
+public class TriggerProcessingStep implements BasicAnnotationProcessor.ProcessingStep {
+
+    private TestRegistry testRegistry;
+    private Filer filer;
+
+    public TriggerProcessingStep(TestRegistry testRegistry, Filer filer) {
+        this.testRegistry = testRegistry;
+        this.filer = filer;
+    }
+
+    @Override
+    public Set<? extends Class<? extends Annotation>> annotations() {
+        return ImmutableSet.of(Trigger.class);
+    }
+
+    @Override
+    public Set<Element> process(SetMultimap<Class<? extends Annotation>, Element> setMultimap) {
+        final Set<Element> elements = setMultimap.get(Trigger.class);
+        final List<ExecutableElement> executableElements = elements.stream()
+                .map(element -> (ExecutableElement) element)
+                .collect(Collectors.toList());
+
+        for (ExecutableElement executableElement : executableElements) {
+            final Trigger annotation = executableElement.getAnnotation(Trigger.class);
+            final String value = annotation.value();
+            try {
+                byte[] decodedClass = testRegistry.decodeClass(value);
+                final JavaFileObject sourceFile = filer.createSourceFile(annotation.qualifiedName());
+                final OutputStream os = sourceFile.openOutputStream();
+                os.write(decodedClass);
+                os.flush();
+                os.close();
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+        }
+        return ImmutableSet.of();
+    }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/Util.java b/compiler/src/main/java/dagger/internal/codegen/Util.java
index 0c6046e37..d6206b8ed 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Util.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Util.java
@@ -17,7 +17,9 @@
 package dagger.internal.codegen;
 
 import static com.google.auto.common.MoreElements.getLocalAndInheritedMethods;
-import static dagger.internal.codegen.DaggerElements.isAnyAnnotationPresent;
+import static com.google.auto.common.MoreElements.hasModifiers;
+import static com.google.auto.common.MoreTypes.asDeclared;
+import static com.google.common.collect.Lists.asList;
 import static java.util.stream.Collectors.collectingAndThen;
 import static java.util.stream.Collectors.toList;
 import static javax.lang.model.element.ElementKind.CONSTRUCTOR;
@@ -26,90 +28,167 @@
 import static javax.lang.model.element.Modifier.STATIC;
 
 import com.google.auto.common.MoreElements;
+import com.google.auto.common.MoreTypes;
+import com.google.common.base.Function;
+import com.google.common.base.Joiner;
+import java.util.Optional;
+import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
-import dagger.Binds;
-import dagger.Provides;
+import com.squareup.javapoet.*;
+import dagger.*;
+import dagger.multibindings.ClassKey;
+import dagger.multibindings.IntKey;
+import dagger.multibindings.LongKey;
+import dagger.multibindings.StringKey;
 import dagger.producers.Produces;
 import java.util.stream.Collector;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.util.Elements;
+import java.lang.annotation.Annotation;
+import java.util.Comparator;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.stream.Collector;
+import javax.inject.Named;
+import javax.lang.model.element.*;
+import javax.lang.model.type.*;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.SimpleElementVisitor6;
+import javax.lang.model.util.SimpleTypeVisitor6;
 import javax.lang.model.util.Types;
 
 /**
  * Utilities for handling types in annotation processors
  */
 final class Util {
-  /**
-   * Returns true if the passed {@link TypeElement} requires a passed instance in order to be used
-   * within a component.
-   */
-  static boolean requiresAPassedInstance(Elements elements, Types types, TypeElement typeElement) {
-    ImmutableSet<ExecutableElement> methods =
-        getLocalAndInheritedMethods(typeElement, types, elements);
-    boolean foundInstanceMethod = false;
-    for (ExecutableElement method : methods) {
-      if (method.getModifiers().contains(ABSTRACT)
-          && !MoreElements.isAnnotationPresent(method, Binds.class)) {
+    /**
+     * Returns true if the passed {@link TypeElement} requires a passed instance in order to be used
+     * within a component.
+     */
+    static boolean requiresAPassedInstance(Elements elements, Types types, TypeElement typeElement) {
+        ImmutableSet<ExecutableElement> methods =
+                getLocalAndInheritedMethods(typeElement, types, elements);
+        boolean foundInstanceMethod = false;
+        for (ExecutableElement method : methods) {
+            if (method.getModifiers().contains(ABSTRACT)
+                    && !MoreElements.isAnnotationPresent(method, Binds.class)) {
         /* We found an abstract method that isn't a @Binds method.  That automatically means that
          * a user will have to provide an instance because we don't know which subclass to use. */
-        return true;
-      } else if (!method.getModifiers().contains(STATIC)
-          && isAnyAnnotationPresent(method, Provides.class, Produces.class)) {
-        foundInstanceMethod = true;
-      }
-    }
+                return true;
+            } else if (!method.getModifiers().contains(STATIC)
+                    && isAnyAnnotationPresent(method, Provides.class, Produces.class)) {
+                foundInstanceMethod = true;
+            }
+        }
+
+        if (foundInstanceMethod) {
+            return !componentCanMakeNewInstances(typeElement);
+        }
 
-    if (foundInstanceMethod) {
-      return !componentCanMakeNewInstances(typeElement);
+        return false;
     }
 
-    return false;
-  }
+    /**
+     * Returns true if and only if a component can instantiate new instances (typically of a module)
+     * rather than requiring that they be passed.
+     */
+    static boolean componentCanMakeNewInstances(TypeElement typeElement) {
+        switch (typeElement.getKind()) {
+            case CLASS:
+                break;
+            case ENUM:
+            case ANNOTATION_TYPE:
+            case INTERFACE:
+                return false;
+            default:
+                throw new AssertionError("TypeElement cannot have kind: " + typeElement.getKind());
+        }
+
+        if (typeElement.getModifiers().contains(ABSTRACT)) {
+            return false;
+        }
+
+        if (requiresEnclosingInstance(typeElement)) {
+            return false;
+        }
+
+        for (Element enclosed : typeElement.getEnclosedElements()) {
+            if (enclosed.getKind().equals(CONSTRUCTOR)
+                    && ((ExecutableElement) enclosed).getParameters().isEmpty()
+                    && !enclosed.getModifiers().contains(PRIVATE)) {
+                return true;
+            }
+        }
+
+        // TODO(gak): still need checks for visibility
 
-  /**
-   * Returns true if and only if a component can instantiate new instances (typically of a module)
-   * rather than requiring that they be passed.
-   */
-  static boolean componentCanMakeNewInstances(TypeElement typeElement) {
-    switch (typeElement.getKind()) {
-      case CLASS:
-        break;
-      case ENUM:
-      case ANNOTATION_TYPE:
-      case INTERFACE:
         return false;
-      default:
-        throw new AssertionError("TypeElement cannot have kind: " + typeElement.getKind());
     }
 
-    if (typeElement.getModifiers().contains(ABSTRACT)) {
-      return false;
+    private static boolean requiresEnclosingInstance(TypeElement typeElement) {
+        switch (typeElement.getNestingKind()) {
+            case TOP_LEVEL:
+                return false;
+            case MEMBER:
+                return !typeElement.getModifiers().contains(STATIC);
+            case ANONYMOUS:
+            case LOCAL:
+                return true;
+            default:
+                throw new AssertionError(
+                        "TypeElement cannot have nesting kind: " + typeElement.getNestingKind());
+        }
     }
 
-    if (requiresEnclosingInstance(typeElement)) {
-      return false;
+    static ImmutableSet<ExecutableElement> getUnimplementedMethods(
+            Elements elements, Types types, TypeElement type) {
+        return FluentIterable.from(getLocalAndInheritedMethods(type, types, elements))
+                .filter(hasModifiers(ABSTRACT))
+                .toSet();
     }
 
-    for (Element enclosed : typeElement.getEnclosedElements()) {
-      if (enclosed.getKind().equals(CONSTRUCTOR)
-          && ((ExecutableElement) enclosed).getParameters().isEmpty()
-          && !enclosed.getModifiers().contains(PRIVATE)) {
-        return true;
-      }
-    }
+    /**
+     * A function that returns the input as a {@link DeclaredType}.
+     */
+    static final Function<TypeElement, DeclaredType> AS_DECLARED_TYPE =
+            typeElement -> asDeclared(typeElement.asType());
 
-    // TODO(gak): still need checks for visibility
+    /**
+     * A visitor that returns the input or the closest enclosing element that is a
+     * {@link TypeElement}.
+     */
+    static final ElementVisitor<TypeElement, Void> ENCLOSING_TYPE_ELEMENT =
+            new SimpleElementVisitor6<TypeElement, Void>() {
+                @Override
+                protected TypeElement defaultAction(Element e, Void p) {
+                    return visit(e.getEnclosingElement());
+                }
 
-    return false;
-  }
+                @Override
+                public TypeElement visitType(TypeElement e, Void p) {
+                    return e;
+                }
+            };
 
-  private static boolean requiresEnclosingInstance(TypeElement typeElement) {
-    switch (typeElement.getNestingKind()) {
-      case TOP_LEVEL:
+    /**
+     * Returns {@code true} iff the given element has an {@link AnnotationMirror} whose
+     * {@linkplain AnnotationMirror#getAnnotationType() annotation type} has the same canonical name
+     * as any of that of {@code annotationClasses}.
+     */
+    // TODO(dpb): Move to MoreElements.
+    static boolean isAnyAnnotationPresent(
+            Element element, Iterable<? extends Class<? extends Annotation>> annotationClasses) {
+        for (Class<? extends Annotation> annotation : annotationClasses) {
+            if (MoreElements.isAnnotationPresent(element, annotation)) {
+                return true;
+            }
+        }
         return false;
+/*
       case MEMBER:
         return !typeElement.getModifiers().contains(STATIC);
       case ANONYMOUS:
@@ -118,7 +197,7 @@ private static boolean requiresEnclosingInstance(TypeElement typeElement) {
       default:
         throw new AssertionError(
             "TypeElement cannot have nesting kind: " + typeElement.getNestingKind());
-    }
+    }*/
   }
 
   /**
@@ -134,8 +213,493 @@ private static boolean requiresEnclosingInstance(TypeElement typeElement) {
    * ImmutableSet}, in encounter order.
    */
   static <T> Collector<T, ?, ImmutableSet<T>> toImmutableSet() {
-    return collectingAndThen(toList(), ImmutableSet::copyOf);
+      return collectingAndThen(toList(), ImmutableSet::copyOf);
   }
 
-  private Util() {}
+    @SafeVarargs
+    static boolean isAnyAnnotationPresent(
+            Element element,
+            Class<? extends Annotation> first,
+            Class<? extends Annotation>... otherAnnotations) {
+        return isAnyAnnotationPresent(element, asList(first, otherAnnotations));
+    }
+
+    /**
+     * Returns {@code true} iff the given element has an {@link AnnotationMirror} whose {@linkplain
+     * AnnotationMirror#getAnnotationType() annotation type} is equivalent to {@code annotationType}.
+     */
+    // TODO(dpb): Move to MoreElements.
+    static boolean isAnnotationPresent(Element element, TypeMirror annotationType) {
+        return element
+                .getAnnotationMirrors()
+                .stream()
+                .map(AnnotationMirror::getAnnotationType)
+                .anyMatch(candidate -> MoreTypes.equivalence().equivalent(candidate, annotationType));
+    }
+
+    /**
+     * The elements in {@code elements} that are annotated with an annotation of type
+     * {@code annotation}.
+     */
+    static <E extends Element> FluentIterable<E> elementsWithAnnotation(
+            Iterable<E> elements, final Class<? extends Annotation> annotation) {
+        return FluentIterable.from(elements)
+                .filter(element -> MoreElements.isAnnotationPresent(element, annotation));
+    }
+
+    /**
+     * A function that returns the simple name of an element.
+     */
+    static final Function<Element, String> ELEMENT_SIMPLE_NAME =
+            element -> element.getSimpleName().toString();
+
+    /**
+     * A {@link Comparator} that puts absent {@link Optional}s before present ones, and compares
+     * present {@link Optional}s by their values.
+     */
+    static <C extends Comparable<C>> Comparator<Optional<C>> optionalComparator() {
+        return Comparator.comparing((Optional<C> optional) -> optional.isPresent())
+                .thenComparing(Optional::get);
+    }
+
+    public static String toParameterName(String simpleName) {
+        return Character.toLowerCase(simpleName.charAt(0)) + simpleName.substring(1);
+    }
+
+    public static String extractPackage(TypeMirror classType) {
+        return classType.toString().replaceAll("." + convertDataClassToString(classType), "");
+    }
+
+    public static String extractClassName(TypeMirror classType) {
+        return convertDataClassToString(classType);
+    }
+
+    public static String extractClassName(String s) {
+        int index = s.lastIndexOf(".");
+        return s.substring(index + 1);
+    }
+
+    public static String convertDataClassToString(TypeMirror dataClass) {
+        String s = dataClass.toString();
+        int index = s.lastIndexOf(".");
+        return s.substring(index + 1);
+    }
+
+    static ClassName getDelegateTypeName(Key key) {
+        if (!key.multibindingContributionIdentifier().isPresent()) {
+            if (key.qualifier().isPresent()) {
+                final java.util.Optional<String> qualifier = key.qualifier().get().getElementValues().values().stream()
+                        .map((java.util.function.Function<AnnotationValue, String>) annotationValue -> annotationValue.getValue().toString())
+                        .findFirst();
+                if (qualifier.isPresent()) {
+                    final PackageElement packageElement = getPackage(MoreTypes.asElement(key.type()));
+                    final String classNameString = "delegates" + "." + capitalize(qualifier.get()) + "Delegate";
+                    return ClassName.bestGuess(classNameString);
+                }
+            }
+            final TypeName typeName = ClassName.get(key.type());
+            if (typeName instanceof ClassName) {
+                final String s = ((ClassName) typeName).simpleName();
+                return ClassName.bestGuess("delegates" +  "." + s + "Delegate");
+            }
+            final ClassName name = ClassName.bestGuess(typeToString(key.type()));
+            return ClassName.bestGuess("delegates." + name.simpleName() + "Delegate");
+        }
+        return key.multibindingContributionIdentifier().get().getDelegateTypeName();
+    }
+
+    private static String extractPackageName(TypeMirror type) {
+        return getPackage(MoreTypes.asElement(type)).getSimpleName().toString();
+    }
+
+    static String getDelegateFieldName(Key key) {
+        if (!key.multibindingContributionIdentifier().isPresent()) {
+            if (key.qualifier().isPresent()) {
+                final java.util.Optional<String> qualifier = key.qualifier().get().getElementValues().values().stream()
+                        .map((java.util.function.Function<AnnotationValue, String>) annotationValue -> annotationValue.getValue().toString())
+                        .findFirst();
+                if (qualifier.isPresent()) {
+                    return lowerCaseFirstLetter(qualifier.get()) + "Delegate";
+                }
+            }
+            return toParameterName(extractClassName(typeToString(key.type()))) + "Delegate";
+        }
+        return key.multibindingContributionIdentifier().get().getDelegateFieldName();
+    }
+
+    /**
+     * Returns a string for {@code type}. Primitive types are always boxed.
+     */
+    public static String typeToString(TypeMirror type) {
+        StringBuilder result = new StringBuilder();
+        typeToString(type, result, '.', false);
+        return result.toString();
+    }
+
+    /**
+     * Returns a string for the raw type of {@code type}. Primitive types are always boxed.
+     */
+    public static String rawTypeToString(TypeMirror type, char innerClassSeparator) {
+        if (!(type instanceof DeclaredType)) {
+            throw new IllegalArgumentException("Unexpected type: " + type);
+        }
+        StringBuilder result = new StringBuilder();
+        DeclaredType declaredType = (DeclaredType) type;
+        rawTypeToString(result, (TypeElement) declaredType.asElement(), innerClassSeparator, false);
+        return result.toString();
+    }
+
+    public static PackageElement getPackage(Element type) {
+        while (type.getKind() != ElementKind.PACKAGE) {
+            type = type.getEnclosingElement();
+        }
+        return (PackageElement) type;
+    }
+
+    static void rawTypeToString(StringBuilder result, TypeElement type, char innerClassSeparator, boolean typeParam) {
+        if (typeParam) {
+            final String s = MoreElements.asType(type).getSimpleName().toString();
+            result.append(s);
+            return;
+        }
+
+        String packageName = getPackage(type).getQualifiedName().toString();
+        String qualifiedName = type.getQualifiedName().toString();
+        if (packageName.isEmpty()) {
+            result.append(qualifiedName.replace('.', innerClassSeparator));
+        } else {
+            result.append(packageName);
+            result.append('.');
+            result.append(
+                    qualifiedName.substring(packageName.length() + 1).replace('.', innerClassSeparator));
+        }
+    }
+
+    /**
+     * Appends a string for {@code type} to {@code result}. Primitive types are
+     * always boxed.
+     *
+     * @param innerClassSeparator either '.' or '$', which will appear in a
+     *                            class name like "java.lang.Map.Entry" or "java.lang.Map$Entry".
+     *                            Use '.' for references to existing types in code. Use '$' to define new
+     *                            class names and for strings that will be used by runtime reflection.
+     */
+    public static void typeToString(final TypeMirror type, final StringBuilder result, final char innerClassSeparator, boolean typeParam) {
+        type.accept(new SimpleTypeVisitor6<Void, Void>() {
+            @Override
+            public Void visitDeclared(DeclaredType declaredType, Void v) {
+                TypeElement typeElement = (TypeElement) declaredType.asElement();
+                rawTypeToString(result, typeElement, innerClassSeparator, typeParam);
+                List<? extends TypeMirror> typeArguments = declaredType.getTypeArguments();
+                if (!typeArguments.isEmpty()) {
+                    result.append("Of");
+                    for (int i = 0; i < typeArguments.size(); i++) {
+                        if (i != 0) {
+                            result.append("And");
+                        }
+                        typeToString(typeArguments.get(i), result, '\0', true);
+                    }
+                }
+                return null;
+            }
+
+            @Override
+            public Void visitPrimitive(PrimitiveType primitiveType, Void v) {
+                result.append(box((PrimitiveType) type));
+                return null;
+            }
+
+            @Override
+            public Void visitArray(ArrayType arrayType, Void v) {
+                TypeMirror type = arrayType.getComponentType();
+                if (type instanceof PrimitiveType) {
+                    result.append("ArrayOf" + extractClassName(type)); // Don't box, since this is an array.
+                } else {
+                    typeToString(arrayType.getComponentType(), result, innerClassSeparator, true);
+                }
+                result.append("_");
+                return null;
+            }
+
+            @Override
+            public Void visitTypeVariable(TypeVariable typeVariable, Void v) {
+                result.append(typeVariable.asElement().getSimpleName());
+                return null;
+            }
+
+            @Override
+            public Void visitError(ErrorType errorType, Void v) {
+                // Error type found, a type may not yet have been generated, but we need the type
+                // so we can generate the correct code in anticipation of the type being available
+                // to the compiler.
+
+                // Paramterized types which don't exist are returned as an error type whose name is "<any>"
+                if ("<any>".equals(errorType.toString())) {
+                    throw new IllegalStateException(
+                            "Type reported as <any> is likely a not-yet generated parameterized type.");
+                }
+                // TODO(cgruber): Figure out a strategy for non-FQCN cases.
+                result.append(errorType.toString());
+                return null;
+            }
+
+            @Override
+            protected Void defaultAction(TypeMirror typeMirror, Void v) {
+                throw new UnsupportedOperationException(
+                        "Unexpected TypeKind " + typeMirror.getKind() + " for " + typeMirror);
+            }
+        }, null);
+    }
+
+    static TypeName box(PrimitiveType primitiveType) {
+        switch (primitiveType.getKind()) {
+            case BYTE:
+                return ClassName.get(Byte.class);
+            case SHORT:
+                return ClassName.get(Short.class);
+            case INT:
+                return ClassName.get(Integer.class);
+            case LONG:
+                return ClassName.get(Long.class);
+            case FLOAT:
+                return ClassName.get(Float.class);
+            case DOUBLE:
+                return ClassName.get(Double.class);
+            case BOOLEAN:
+                return ClassName.get(Boolean.class);
+            case CHAR:
+                return ClassName.get(Character.class);
+            case VOID:
+                return ClassName.get(Void.class);
+            default:
+                throw new AssertionError();
+        }
+    }
+
+    private static java.util.Optional<? extends AnnotationMirror> getAnnotationMirror(Element element) {
+        final ImmutableList<String> annotations =
+                ImmutableList.of(Named.class.getName(), StringKey.class.getName(), IntKey.class.getName(), LongKey.class.getName(), MapKey.class.getName(), ClassKey.class.getName());
+
+        return element.getAnnotationMirrors().stream()
+                .filter(e -> annotations.contains(e.getAnnotationType().asElement().asType().toString()))
+                .findFirst();
+    }
+
+    private static java.util.Optional<? extends AnnotationMirror> getAnnotationMirror(TypeMirror typeMirror) {
+        final ImmutableList<String> annotations =
+                ImmutableList.of(Named.class.getName(), StringKey.class.getName(), IntKey.class.getName(), LongKey.class.getName(), MapKey.class.getName(), ClassKey.class.getName());
+
+        return typeMirror.getAnnotationMirrors().stream()
+                .filter(e -> annotations.contains(e.getAnnotationType().asElement().asType().toString()))
+                .findFirst();
+    }
+
+    private static String getCapitalizedAnnotationValue(AnnotationMirror annotation) {
+        final Map<? extends ExecutableElement, ? extends AnnotationValue> elementValues = annotation.getElementValues();
+        for (Map.Entry<? extends ExecutableElement, ? extends AnnotationValue> entry : elementValues.entrySet()) {
+            if (entry.getKey().getSimpleName().toString().equals("value")) {
+                final String original = entry.getValue().getValue().toString();
+                if (!original.isEmpty()) {
+                    return capitalize(original);
+                }
+            }
+        }
+        throw new IllegalStateException("value not found");
+    }
+
+    public static String capitalize(String original) {
+        if (original == null || original.length() == 0) {
+            return original;
+        }
+        return original.substring(0, 1).toUpperCase() + original.substring(1);
+    }
+
+    public static String lowerCaseFirstLetter(String original) {
+        if (original == null || original.length() == 0) {
+            return original;
+        }
+        return original.substring(0, 1).toLowerCase() + original.substring(1);
+    }
+
+    public static boolean bindingSupportsTestDelegate(ContributionBinding binding) {
+        final ImmutableList<ContributionBinding.Kind> kinds = ImmutableList.of(
+                ContributionBinding.Kind.PROVISION,
+                ContributionBinding.Kind.INJECTION,
+                ContributionBinding.Kind.BUILDER_BINDING
+        );
+        final ContributionBinding.Kind kind = binding.bindingKind();
+        return kinds.contains(kind) && !binding.genericParameter() && !binding.ignoreStubGeneration();
+    }
+
+    private Util() {
+    }
+
+    public static void createDelegateField(TypeSpec.Builder classBuilder, ContributionBinding binding, Map<Key, String> delegateFieldNames) {
+        try {
+            if (bindingSupportsTestDelegate(binding)) {
+                final String delegateFieldName = Util.getDelegateFieldName(binding.key());
+                final ClassName delegateType = getDelegateTypeName(binding.key());
+                final FieldSpec.Builder builder = FieldSpec.builder(delegateType, delegateFieldName);
+                delegateFieldNames.put(binding.key(), delegateFieldName);
+                final FieldSpec fieldSpec = builder.build();
+                classBuilder.addField(fieldSpec);
+            }
+        } catch (Exception e) {
+        }
+    }
+
+    public static void createDelegateFieldAndMethod(ClassName generatedTypeName, TypeSpec.Builder classBuilder, ContributionBinding binding, Map<Key, String> delegateFieldNames) {
+        try {
+            if (bindingSupportsTestDelegate(binding)) {
+                final String delegateFieldName = Util.getDelegateFieldName(binding.key());
+                final ClassName delegateType = getDelegateTypeName(binding.key());
+                final FieldSpec.Builder builder = FieldSpec.builder(delegateType, delegateFieldName);
+                delegateFieldNames.put(binding.key(), delegateFieldName);
+                final FieldSpec fieldSpec = builder.build();
+                classBuilder.addField(fieldSpec);
+                final String methodName = getDelegateMethodName(delegateType);
+                classBuilder.addMethod(MethodSpec.methodBuilder(methodName)
+                        .addModifiers(Modifier.PUBLIC)
+                        .returns(generatedTypeName)
+                        .addParameter(delegateType, delegateFieldName)
+                        .addStatement("this.$N = $L", fieldSpec, CodeBlock.of(delegateFieldName))
+                        .addStatement("return this")
+                        .build());
+            }
+        } catch (Exception e) {
+        }
+    }
+
+
+    public static void createDelegateFieldAndMethod(ClassName generatedTypeName, TypeSpec.Builder classBuilder, ResolvedBindings resolvedBindings, Map<Key, String> delegateFieldNames) {
+        if (resolvedBindings.isEmpty() || resolvedBindings.ownedBindings().isEmpty()) {
+            return;
+        }
+        try {
+            ContributionBinding binding = resolvedBindings.contributionBinding();
+            if (bindingSupportsTestDelegate(binding)) {
+                final String delegateFieldName = Util.getDelegateFieldName(binding.key());
+                final ClassName delegateType = getDelegateTypeName(binding.key());
+                final FieldSpec.Builder builder = FieldSpec.builder(delegateType, delegateFieldName);
+                delegateFieldNames.put(binding.key(), delegateFieldName);
+                final FieldSpec fieldSpec = builder.build();
+                classBuilder.addField(fieldSpec);
+                final String methodName = getDelegateMethodName(delegateType);
+                classBuilder.addMethod(MethodSpec.methodBuilder(methodName)
+                        .addModifiers(Modifier.PUBLIC)
+                        .returns(generatedTypeName)
+                        .addParameter(delegateType, delegateFieldName)
+                        .addStatement("this.$N = $L", fieldSpec, CodeBlock.of(delegateFieldName))
+                        .addStatement("return this")
+                        .build());
+            }
+        } catch (Exception e) {
+        }
+    }
+
+    public static String getDelegateMethodName(ClassName delegateType) {
+        return "with" + delegateType.simpleName().replaceAll("Delegate$", "");
+    }
+
+    public static ClassName getDaggerComponentClassName(ClassName componentDefinitionClassName) {
+       String componentName =
+                "Dagger" + Joiner.on('_').join(componentDefinitionClassName.simpleNames());
+        componentDefinitionClassName = ClassName.bestGuess("factories." + componentName);
+        return componentDefinitionClassName;//componentDefinitionClassName.topLevelClassName().peerClass(componentName);
+    }
+
+    public static ClassName getDaggerComponentClassName(Element component) {
+        return getDaggerComponentClassName(ClassName.bestGuess(typeToString(component.asType())));
+    }
+
+    public static HashMap<String, ExecutableElement> findProvidingMethodsOfModules(Types typeUtils, Element componentProvider) {
+        HashMap<String, ExecutableElement> providingMethods = new HashMap<>();
+        if (componentProvider.getKind() == ElementKind.CLASS) {
+            TypeElement typeElement = (TypeElement) componentProvider;
+            for (Map.Entry<String, ExecutableElement> e : findProvidingModuleMethodsInternal(typeElement, providingMethods).entrySet()) {
+                if (!providingMethods.containsKey(e.getKey())) providingMethods.put(e.getKey(), e.getValue());
+            }
+            typeElement = (TypeElement) typeUtils.asElement(typeElement.getSuperclass());
+            while (!typeElement.toString().equals(Object.class.getName())) {
+                for (Map.Entry<String, ExecutableElement> e : findProvidingModuleMethodsInternal(typeElement, providingMethods).entrySet()) {
+                    if (!providingMethods.containsKey(e.getKey())) providingMethods.put(e.getKey(), e.getValue());
+                }
+                typeElement = (TypeElement) typeUtils.asElement(typeElement.getSuperclass());
+            }
+        }
+        return providingMethods;
+    }
+
+    public static HashMap<String, ExecutableElement> findProvidingMethodsOfComponents(Types typeUtils, Element componentProvider) {
+        HashMap<String, ExecutableElement> providingMethods = new HashMap<>();
+        if (componentProvider.getKind() == ElementKind.CLASS) {
+            TypeElement typeElement = (TypeElement) componentProvider;
+            for (Map.Entry<String, ExecutableElement> e : findProvidingComponentMethodsInternal(typeElement, providingMethods).entrySet()) {
+                if (!providingMethods.containsKey(e.getKey()))
+                    providingMethods.put(e.getKey(), e.getValue());
+            }
+            typeElement = (TypeElement) typeUtils.asElement(typeElement.getSuperclass());
+            while (!typeElement.toString().equals(Object.class.getName())) {
+                for (Map.Entry<String, ExecutableElement> e : findProvidingComponentMethodsInternal(typeElement, providingMethods).entrySet()) {
+                    if (!providingMethods.containsKey(e.getKey()))
+                        providingMethods.put(e.getKey(), e.getValue());
+                }
+                typeElement = (TypeElement) typeUtils.asElement(typeElement.getSuperclass());
+            }
+        }
+        return providingMethods;
+    }
+
+    public static HashMap<String, ExecutableElement> findProvidingMethods(Types typeUtils, Element componentProvider) {
+        HashMap<String, ExecutableElement> providingMethods = new HashMap<>();
+        if (componentProvider.getKind() == ElementKind.CLASS) {
+            TypeElement typeElement = (TypeElement) componentProvider;
+            for (Map.Entry<String, ExecutableElement> e : findProvidingModuleMethodsInternal(typeElement, providingMethods).entrySet()) {
+                if (!providingMethods.containsKey(e.getKey())) providingMethods.put(e.getKey(), e.getValue());
+            }
+            for (Map.Entry<String, ExecutableElement> e : findProvidingComponentMethodsInternal(typeElement, providingMethods).entrySet()) {
+                if (!providingMethods.containsKey(e.getKey())) providingMethods.put(e.getKey(), e.getValue());
+            }
+            typeElement = (TypeElement) typeUtils.asElement(typeElement.getSuperclass());
+            while (!typeElement.toString().equals(Object.class.getName())) {
+                for (Map.Entry<String, ExecutableElement> e : findProvidingModuleMethodsInternal(typeElement, providingMethods).entrySet()) {
+                    if (!providingMethods.containsKey(e.getKey())) providingMethods.put(e.getKey(), e.getValue());
+                }
+                for (Map.Entry<String, ExecutableElement> e : findProvidingComponentMethodsInternal(typeElement, providingMethods).entrySet()) {
+                    if (!providingMethods.containsKey(e.getKey())) providingMethods.put(e.getKey(), e.getValue());
+                }
+                typeElement = (TypeElement) typeUtils.asElement(typeElement.getSuperclass());
+            }
+        }
+        return providingMethods;
+    }
+
+    private static HashMap<String, ExecutableElement> findProvidingModuleMethodsInternal(TypeElement element, HashMap<String, ExecutableElement> providingMethods) {
+        List<? extends Element> enclosedElements = element.getEnclosedElements();
+        for (Element enclosedElement : enclosedElements) {
+            if (enclosedElement.getKind() == ElementKind.METHOD) {
+                ProvidesModule providesModule = enclosedElement.getAnnotation(ProvidesModule.class);
+                if (providesModule != null) {
+                    ExecutableElement executableElement = (ExecutableElement) enclosedElement;
+                    providingMethods.put(executableElement.getReturnType().toString(), executableElement);
+                }
+            }
+        }
+        return providingMethods;
+    }
+
+    private static HashMap<String, ExecutableElement> findProvidingComponentMethodsInternal(TypeElement element, HashMap<String, ExecutableElement> providingMethods) {
+        List<? extends Element> enclosedElements = element.getEnclosedElements();
+        for (Element enclosedElement : enclosedElements) {
+            if (enclosedElement.getKind() == ElementKind.METHOD) {
+                ProvidesComponent providesComponent = enclosedElement.getAnnotation(ProvidesComponent.class);
+                if (providesComponent != null) {
+                    ExecutableElement executableElement = (ExecutableElement) enclosedElement;
+                    providingMethods.put(executableElement.getReturnType().toString(), executableElement);
+                }
+            }
+        }
+        return providingMethods;
+    }
+
 }
diff --git a/core/pom.xml b/core/pom.xml
index 6e78dd3a9..1a53f76a2 100644
--- a/core/pom.xml
+++ b/core/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.google.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>2.9</version>
+    <version>3.0</version>
   </parent>
 
   <artifactId>dagger</artifactId>
@@ -69,7 +69,7 @@
               <target>1.7</target>
             </configuration>
           </execution>
-          <execution>
+          <!--<execution>
             <id>default-testCompile</id>
             <goals>
               <goal>testCompile</goal>
@@ -78,13 +78,13 @@
               <source>1.8</source>
               <target>1.8</target>
             </configuration>
-          </execution>
+          </execution>-->
         </executions>
       </plugin>
-      <plugin>
+      <!--<plugin>
         <groupId>org.codehaus.mojo</groupId>
         <artifactId>animal-sniffer-maven-plugin</artifactId>
-        <version>1.8</version><!-- 1.9+ requires JDK7 on the build machine -->
+        <version>1.8</version>
         <executions>
           <execution>
             <id>sniff-api</id>
@@ -94,11 +94,11 @@
         <configuration>
           <signature>
             <groupId>org.codehaus.mojo.signature</groupId>
-            <artifactId>java16</artifactId>
+            <artifactId>java17</artifactId>
             <version>1.0</version>
           </signature>
         </configuration>
-      </plugin>
+      </plugin>-->
       <plugin>
         <artifactId>maven-javadoc-plugin</artifactId>
         <configuration>
@@ -117,7 +117,7 @@
           </execution>
         </executions>
       </plugin>
-      <plugin>
+      <!--<plugin>
         <artifactId>maven-jar-plugin</artifactId>
         <executions>
           <execution>
@@ -126,6 +126,14 @@
             </goals>
           </execution>
         </executions>
+      </plugin>-->
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-compiler-plugin</artifactId>
+        <configuration>
+          <source>1.8</source>
+          <target>1.8</target>
+        </configuration>
       </plugin>
     </plugins>
   </build>
diff --git a/core/src/main/java/dagger/Config.java b/core/src/main/java/dagger/Config.java
new file mode 100644
index 000000000..75f48b8b6
--- /dev/null
+++ b/core/src/main/java/dagger/Config.java
@@ -0,0 +1,15 @@
+package dagger;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+
+import static java.lang.annotation.ElementType.TYPE;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+@Retention(RUNTIME)
+@Target(TYPE)
+@Documented
+public @interface Config {
+    Class<?> applicationClass();
+}
diff --git a/core/src/main/java/dagger/IgnoreStubGeneration.java b/core/src/main/java/dagger/IgnoreStubGeneration.java
new file mode 100644
index 000000000..5ee236329
--- /dev/null
+++ b/core/src/main/java/dagger/IgnoreStubGeneration.java
@@ -0,0 +1,16 @@
+package dagger;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+
+import static java.lang.annotation.ElementType.CONSTRUCTOR;
+import static java.lang.annotation.ElementType.METHOD;
+import static java.lang.annotation.ElementType.TYPE;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+@Retention(RUNTIME)
+@Target({METHOD, CONSTRUCTOR})
+@Documented
+public @interface IgnoreStubGeneration {
+}
diff --git a/core/src/main/java/dagger/Injector.java b/core/src/main/java/dagger/Injector.java
new file mode 100644
index 000000000..5f5eb6a92
--- /dev/null
+++ b/core/src/main/java/dagger/Injector.java
@@ -0,0 +1,13 @@
+package dagger;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+
+import static java.lang.annotation.ElementType.TYPE;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+@Retention(RUNTIME)
+@Target(TYPE)
+@Documented
+public @interface Injector {}
diff --git a/core/src/main/java/dagger/Module.java b/core/src/main/java/dagger/Module.java
index 862be7aed..b004ef2b4 100644
--- a/core/src/main/java/dagger/Module.java
+++ b/core/src/main/java/dagger/Module.java
@@ -45,4 +45,6 @@
    */
   @Beta
   Class<?>[] subcomponents() default {};
+
+    boolean autoCreate() default true;
 }
diff --git a/core/src/main/java/dagger/ProvidesComponent.java b/core/src/main/java/dagger/ProvidesComponent.java
new file mode 100644
index 000000000..52aa468f8
--- /dev/null
+++ b/core/src/main/java/dagger/ProvidesComponent.java
@@ -0,0 +1,14 @@
+package dagger;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+
+import static java.lang.annotation.ElementType.METHOD;
+import static java.lang.annotation.ElementType.TYPE;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+@Retention(RUNTIME)
+@Target(METHOD)
+@Documented
+public @interface ProvidesComponent {}
diff --git a/core/src/main/java/dagger/ProvidesModule.java b/core/src/main/java/dagger/ProvidesModule.java
new file mode 100644
index 000000000..f87620177
--- /dev/null
+++ b/core/src/main/java/dagger/ProvidesModule.java
@@ -0,0 +1,13 @@
+package dagger;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+
+import static java.lang.annotation.ElementType.METHOD;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+@Retention(RUNTIME)
+@Target(METHOD)
+@Documented
+public @interface ProvidesModule {}
diff --git a/core/src/main/java/dagger/ProvidesSubcomponent.java b/core/src/main/java/dagger/ProvidesSubcomponent.java
new file mode 100644
index 000000000..7aeeceba9
--- /dev/null
+++ b/core/src/main/java/dagger/ProvidesSubcomponent.java
@@ -0,0 +1,13 @@
+package dagger;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+
+import static java.lang.annotation.ElementType.METHOD;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+@Retention(RUNTIME)
+@Target(METHOD)
+@Documented
+public @interface ProvidesSubcomponent {}
diff --git a/core/src/main/java/dagger/Trigger.java b/core/src/main/java/dagger/Trigger.java
new file mode 100644
index 000000000..24deb6e97
--- /dev/null
+++ b/core/src/main/java/dagger/Trigger.java
@@ -0,0 +1,20 @@
+package dagger;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+import static java.lang.annotation.ElementType.METHOD;
+import static java.lang.annotation.ElementType.TYPE;
+import static java.lang.annotation.RetentionPolicy.CLASS;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+import static java.lang.annotation.RetentionPolicy.SOURCE;
+
+@Retention(CLASS)
+@Target({METHOD, TYPE})
+@Documented
+public @interface Trigger {
+    String value();
+    String qualifiedName();
+}
diff --git a/examples/android-activity-graphs/pom.xml b/examples/android-activity-graphs/pom.xml
index a5b5adfb1..7a3c45c1b 100644
--- a/examples/android-activity-graphs/pom.xml
+++ b/examples/android-activity-graphs/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.google.dagger.example</groupId>
     <artifactId>dagger-example-parent</artifactId>
-    <version>2.9</version>
+    <version>3.0</version>
   </parent>
 
   <artifactId>android-activity-graphs</artifactId>
diff --git a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ActivityModule.java b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ActivityModule.java
index 1a2a5945e..a5761280f 100644
--- a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ActivityModule.java
+++ b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ActivityModule.java
@@ -19,6 +19,13 @@
 import android.app.Activity;
 import dagger.Module;
 import dagger.Provides;
+import dagger.multibindings.IntoMap;
+import dagger.multibindings.IntoSet;
+import dagger.multibindings.StringKey;
+
+import javax.inject.Named;
+import java.util.Arrays;
+import java.util.List;
 
 /**
  * A module to wrap the Activity state and expose it to the graph.
@@ -37,4 +44,35 @@ public ActivityModule(Activity activity) {
   @Provides @PerActivity Activity activity() {
     return activity;
   }
+
+  @Provides
+  @StringKey("AAA")
+  @IntoMap
+  public String aString() {
+    return "A";
+  }
+
+  @Provides
+  @StringKey("BBB")
+  @IntoMap
+  public String bString() {
+    return "B";
+  }
+
+  @Provides
+  @Named("AnyString")
+  public String cString() {
+    return "C";
+  }
+
+  @Provides
+  public String dString() {
+    return "D";
+  }
+
+  @Provides
+  public List<String> list() {
+    return Arrays.asList("A", "B", "C");
+  }
+
 }
diff --git a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/AppConfig.java b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/AppConfig.java
new file mode 100644
index 000000000..1b721ae1a
--- /dev/null
+++ b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/AppConfig.java
@@ -0,0 +1,7 @@
+package com.example.dagger.activitygraphs;
+
+import dagger.Config;
+
+@Config(applicationClass = DemoApplication.class)
+public class AppConfig {
+}
diff --git a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ApplicationComponent.java b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ApplicationComponent.java
index 37629ee3b..e57f8cea7 100644
--- a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ApplicationComponent.java
+++ b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ApplicationComponent.java
@@ -27,8 +27,6 @@
 @Singleton // Constraints this component to one-per-application or unscoped bindings.
 @Component(modules = DemoApplicationModule.class)
 public interface ApplicationComponent {
-  // Field injections of any dependencies of the DemoApplication
-  void inject(DemoApplication application);
 
   // Exported for child-components.
   Application application();
diff --git a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/DemoApplication.java b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/DemoApplication.java
index 1174a62bf..2ef7da478 100644
--- a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/DemoApplication.java
+++ b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/DemoApplication.java
@@ -16,11 +16,23 @@
 
 package com.example.dagger.activitygraphs;
 
+import android.app.Activity;
 import android.app.Application;
 import android.location.LocationManager;
+import com.example.dagger.activitygraphs.ui.HomeComponent;
+import dagger.Injector;
+import dagger.Provides;
+import dagger.ProvidesComponent;
+import dagger.ProvidesModule;
+import factories.DaggerAbstractActivityComponent;
+import factories.DaggerApplicationComponent;
+import factories.DaggerFragmentComponent;
+import factories.DaggerHomeComponent;
+import injector.InjectorSpec;
+
 import javax.inject.Inject;
 
-public class DemoApplication extends Application {
+public class DemoApplication extends Application implements InjectorSpec {
   private ApplicationComponent applicationComponent;
 
   // TODO(cgruber): Figure out a better example of something one might inject into the app.
@@ -36,4 +48,32 @@
   public ApplicationComponent component() {
     return applicationComponent;
   }
+
+  @Override
+  public DaggerFragmentComponent.Builder fragmentComponent(DaggerFragmentComponent.Builder builder,
+                                                           AbstractActivityComponent abstractActivityComponent) {
+    return builder.abstractActivityComponent(abstractActivityComponent);
+  }
+
+  @Override
+  public DaggerAbstractActivityComponent.Builder abstractActivityComponent(DaggerAbstractActivityComponent.Builder builder,
+                                                                           ActivityModule activityModule,
+                                                                           ApplicationComponent applicationComponent) {
+    return builder.applicationComponent(applicationComponent).activityModule(activityModule);
+  }
+
+  @Override
+  public DaggerHomeComponent.Builder homeComponent(DaggerHomeComponent.Builder builder, ActivityModule activityModule, ApplicationComponent applicationComponent) {
+    return null;
+  }
+
+  @Override
+  public DaggerApplicationComponent.Builder applicationComponent(DaggerApplicationComponent.Builder builder, DemoApplicationModule demoApplicationModule) {
+    return null;
+  }
+
+  @Override
+  public injector.Injector getInjector() {
+    return null;
+  }
 }
diff --git a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/FragmentComponent.java b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/FragmentComponent.java
new file mode 100644
index 000000000..8fff0004c
--- /dev/null
+++ b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/FragmentComponent.java
@@ -0,0 +1,8 @@
+package com.example.dagger.activitygraphs;
+
+import dagger.Component;
+
+@PerFragment
+@Component(dependencies = AbstractActivityComponent.class)
+public interface FragmentComponent {
+}
diff --git a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/PerFragment.java b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/PerFragment.java
new file mode 100644
index 000000000..a19da6203
--- /dev/null
+++ b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/PerFragment.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2013 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.example.dagger.activitygraphs;
+
+import javax.inject.Scope;
+import java.lang.annotation.Retention;
+
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+/**
+ * A scoping annotation to permit objects whose lifetime should
+ * conform to the life of the activity to be memoized in the
+ * correct component.
+ */
+@Scope
+@Retention(RUNTIME)
+public @interface PerFragment {
+}
diff --git a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/SomeClass.java b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/SomeClass.java
new file mode 100644
index 000000000..3fdcea951
--- /dev/null
+++ b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/SomeClass.java
@@ -0,0 +1,19 @@
+package com.example.dagger.activitygraphs;
+
+import dagger.Lazy;
+
+import javax.inject.Inject;
+import javax.inject.Named;
+import java.util.Set;
+
+/**
+ * Created by Andy on 07.05.2017.
+ */
+public class SomeClass {
+
+    @Inject
+    public SomeClass(Lazy<String> lazy) {
+
+    }
+
+}
diff --git a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ui/HomeActivity.java b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ui/HomeActivity.java
index dcdb1b885..2c31d5318 100644
--- a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ui/HomeActivity.java
+++ b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ui/HomeActivity.java
@@ -21,12 +21,31 @@
 import android.support.v4.app.FragmentActivity;
 import com.example.dagger.activitygraphs.ActivityModule;
 import com.example.dagger.activitygraphs.DemoApplication;
+import com.example.dagger.activitygraphs.SomeClass;
+import dagger.Lazy;
+import factories.DaggerHomeComponent;
+
 import javax.inject.Inject;
+import javax.inject.Named;
+import javax.inject.Provider;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
 
 public class HomeActivity extends FragmentActivity {
+
   @Inject LocationManager locationManager;
   private HomeComponent component;
 
+  @Inject
+  Lazy<SomeClass> someClass;
+
+  @Inject
+  Lazy<List<String>> list;
+
+  @Inject
+  Lazy<Map<String, String>> map;
+
   HomeComponent component() {
     if (component == null) {
       component = DaggerHomeComponent.builder()
diff --git a/examples/android-simple/pom.xml b/examples/android-simple/pom.xml
index a5c3f8ca8..540af05ce 100644
--- a/examples/android-simple/pom.xml
+++ b/examples/android-simple/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.google.dagger.example</groupId>
     <artifactId>dagger-example-parent</artifactId>
-    <version>2.9</version>
+    <version>3.0</version>
   </parent>
 
   <artifactId>android-simple</artifactId>
diff --git a/examples/android-simple/src/main/AndroidManifest.xml b/examples/android-simple/src/main/AndroidManifest.xml
index 53c83bfd3..245570178 100644
--- a/examples/android-simple/src/main/AndroidManifest.xml
+++ b/examples/android-simple/src/main/AndroidManifest.xml
@@ -9,7 +9,7 @@
 
   <application
       android:label="app_name"
-      android:name=".DemoApplication">
+      android:name=".DemoApplication1">
     <activity
         android:label="app_name"
         android:name=".ui.HomeActivity">
diff --git a/examples/android-simple/src/main/java/com/example/dagger/simple/AndroidModule.java b/examples/android-simple/src/main/java/com/example/dagger/simple/AndroidModule.java
index 574fa727c..6cf8c3c79 100644
--- a/examples/android-simple/src/main/java/com/example/dagger/simple/AndroidModule.java
+++ b/examples/android-simple/src/main/java/com/example/dagger/simple/AndroidModule.java
@@ -30,9 +30,9 @@
  */
 @Module
 public class AndroidModule {
-  private final DemoApplication application;
+  private final DemoApplication1 application;
 
-  public AndroidModule(DemoApplication application) {
+  public AndroidModule(DemoApplication1 application) {
     this.application = application;
   }
 
diff --git a/examples/android-simple/src/main/java/com/example/dagger/simple/AppConfig.java b/examples/android-simple/src/main/java/com/example/dagger/simple/AppConfig.java
new file mode 100644
index 000000000..50c50732d
--- /dev/null
+++ b/examples/android-simple/src/main/java/com/example/dagger/simple/AppConfig.java
@@ -0,0 +1,7 @@
+package com.example.dagger.simple;
+
+import dagger.Config;
+
+@Config(applicationClass = DemoApplication1.class)
+public class AppConfig {
+}
diff --git a/examples/android-simple/src/main/java/com/example/dagger/simple/Components.java b/examples/android-simple/src/main/java/com/example/dagger/simple/Components.java
new file mode 100644
index 000000000..85e702a66
--- /dev/null
+++ b/examples/android-simple/src/main/java/com/example/dagger/simple/Components.java
@@ -0,0 +1,25 @@
+package com.example.dagger.simple;
+
+import com.example.dagger.simple.ui.HomeActivity;
+import dagger.Component;
+import javax.inject.Singleton;
+
+
+public interface Components {
+
+    @Singleton
+    @Component(modules = {AndroidModule.class, SingletonModule.class})
+    public interface ApplicationComponent {
+        //void inject(DemoApplication1 application);
+        void inject(HomeActivity homeActivity);
+        void inject(DemoActivity demoActivity);
+        @Component.Builder
+        interface Builder {
+            Builder androidModule(AndroidModule module);
+            Builder singletonModule(SingletonModule module);
+            ApplicationComponent build();
+        }
+    }
+
+
+}
diff --git a/examples/android-simple/src/main/java/com/example/dagger/simple/DemoActivity.java b/examples/android-simple/src/main/java/com/example/dagger/simple/DemoActivity.java
index 4847b101c..507cf35ea 100644
--- a/examples/android-simple/src/main/java/com/example/dagger/simple/DemoActivity.java
+++ b/examples/android-simple/src/main/java/com/example/dagger/simple/DemoActivity.java
@@ -23,6 +23,6 @@
   @Override protected void onCreate(Bundle savedInstanceState) {
     super.onCreate(savedInstanceState);
     // Perform injection so that when this call returns all dependencies will be available for use.
-    ((DemoApplication) getApplication()).component().inject(this);
+    ((DemoApplication1) getApplication()).component().inject(this);
   }
 }
diff --git a/examples/android-simple/src/main/java/com/example/dagger/simple/DemoApplication.java b/examples/android-simple/src/main/java/com/example/dagger/simple/DemoApplication1.java
similarity index 50%
rename from examples/android-simple/src/main/java/com/example/dagger/simple/DemoApplication.java
rename to examples/android-simple/src/main/java/com/example/dagger/simple/DemoApplication1.java
index d6b3868f5..12a65a4f9 100644
--- a/examples/android-simple/src/main/java/com/example/dagger/simple/DemoApplication.java
+++ b/examples/android-simple/src/main/java/com/example/dagger/simple/DemoApplication1.java
@@ -18,34 +18,38 @@
 
 import android.app.Application;
 import android.location.LocationManager;
-import com.example.dagger.simple.ui.HomeActivity;
-import dagger.Component;
+import factories.DaggerComponents_ApplicationComponent;
+import injector.Injector;
+import injector.InjectorSpec;
+
 import javax.inject.Inject;
-import javax.inject.Singleton;
-
-public class DemoApplication extends Application {
-  
-  @Singleton
-  @Component(modules = AndroidModule.class)
-  public interface ApplicationComponent {
-    void inject(DemoApplication application);
-    void inject(HomeActivity homeActivity);
-    void inject(DemoActivity demoActivity);
-  }
-  
+import javax.inject.Named;
+
+public class DemoApplication1 extends Application implements InjectorSpec{
+
   @Inject LocationManager locationManager; // for some reason.
-  
-  private ApplicationComponent component;
+  @Inject @Named("apiKey") String someString;
+  @Inject @Named("apiKey1") String anotherString;
+  private Components.ApplicationComponent component;
+ // private Injector injector = new Injector(this);
 
   @Override public void onCreate() {
     super.onCreate();
-    component = DaggerDemoApplication_ApplicationComponent.builder()
-        .androidModule(new AndroidModule(this))
-        .build();
-    component().inject(this); // As of now, LocationManager should be injected into this.
+    //component = injector.applicationComponent(new AndroidModule(this), new SingletonModule());
+    //component.inject(this);
   }
 
-  public ApplicationComponent component() {
+  public Components.ApplicationComponent component() {
     return component;
   }
+
+  @Override
+  public Components.ApplicationComponent.Builder applicationComponent(Components.ApplicationComponent.Builder builder, AndroidModule androidModule) {
+    return builder.androidModule(androidModule);
+  }
+
+  @Override
+  public Injector getInjector() {
+    return null;
+  }
 }
diff --git a/examples/android-simple/src/main/java/com/example/dagger/simple/SingletonModule.java b/examples/android-simple/src/main/java/com/example/dagger/simple/SingletonModule.java
new file mode 100644
index 000000000..38db0e8d6
--- /dev/null
+++ b/examples/android-simple/src/main/java/com/example/dagger/simple/SingletonModule.java
@@ -0,0 +1,25 @@
+package com.example.dagger.simple;
+
+import dagger.Module;
+import dagger.Provides;
+
+import javax.inject.Named;
+
+/**
+ * Created by Andy on 04.05.2017.
+ */
+@Module
+public class SingletonModule {
+
+    @Provides
+    @Named("apiKey")
+    public String someString() {
+       return "";
+    }
+
+    @Provides
+    @Named("apiKey1")
+    public String secondString() {
+        return "";
+    }
+}
diff --git a/examples/android-simple/src/main/java/com/example/dagger/simple/ui/HomeActivity.java b/examples/android-simple/src/main/java/com/example/dagger/simple/ui/HomeActivity.java
index f0669c61d..a4c2c040d 100644
--- a/examples/android-simple/src/main/java/com/example/dagger/simple/ui/HomeActivity.java
+++ b/examples/android-simple/src/main/java/com/example/dagger/simple/ui/HomeActivity.java
@@ -20,7 +20,7 @@
 import android.os.Bundle;
 import android.util.Log;
 import com.example.dagger.simple.DemoActivity;
-import com.example.dagger.simple.DemoApplication;
+import com.example.dagger.simple.DemoApplication1;
 import javax.inject.Inject;
 
 public class HomeActivity extends DemoActivity {
@@ -28,7 +28,7 @@
 
   @Override protected void onCreate(Bundle savedInstanceState) {
     super.onCreate(savedInstanceState);
-    ((DemoApplication) getApplication()).component().inject(this);
+    ((DemoApplication1) getApplication()).component().inject(this);
 
     // TODO do something with the injected dependencies here!
     Log.d("HomeActivity", locationManager.toString());
diff --git a/examples/pom.xml b/examples/pom.xml
index 116fa9ad8..9044fe2bc 100644
--- a/examples/pom.xml
+++ b/examples/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.google.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>2.9</version>
+    <version>3.0</version>
   </parent>
 
   <groupId>com.google.dagger.example</groupId>
diff --git a/examples/simple/pom.xml b/examples/simple/pom.xml
index 163de8066..0f543b7fd 100644
--- a/examples/simple/pom.xml
+++ b/examples/simple/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.google.dagger.example</groupId>
     <artifactId>dagger-example-parent</artifactId>
-    <version>2.9</version>
+    <version>3.0</version>
   </parent>
 
   <artifactId>simple</artifactId>
diff --git a/examples/simple/src/main/java/coffee/AModule.java b/examples/simple/src/main/java/coffee/AModule.java
new file mode 100644
index 000000000..57aaa9372
--- /dev/null
+++ b/examples/simple/src/main/java/coffee/AModule.java
@@ -0,0 +1,17 @@
+package coffee;
+
+import dagger.Module;
+import dagger.Provides;
+
+/**
+ * Created by Andy on 06.05.2017.
+ */
+@Module
+public class AModule {
+
+    @Provides
+    public Integer integer() {
+        return 1;
+    }
+
+}
diff --git a/examples/simple/src/main/java/coffee/ActivityScope.java b/examples/simple/src/main/java/coffee/ActivityScope.java
new file mode 100644
index 000000000..9cd2e7c90
--- /dev/null
+++ b/examples/simple/src/main/java/coffee/ActivityScope.java
@@ -0,0 +1,17 @@
+package coffee;
+
+import javax.inject.Qualifier;
+import javax.inject.Scope;
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+import static java.lang.annotation.ElementType.TYPE;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+@Scope
+@Documented
+@Retention(RetentionPolicy.RUNTIME)
+public @interface ActivityScope {
+}
diff --git a/examples/simple/src/main/java/coffee/App.java b/examples/simple/src/main/java/coffee/App.java
new file mode 100644
index 000000000..3f329d94d
--- /dev/null
+++ b/examples/simple/src/main/java/coffee/App.java
@@ -0,0 +1,37 @@
+package coffee;
+
+import dagger.Injector;
+import dagger.ProvidesComponent;
+import dagger.ProvidesModule;
+import dagger.ProvidesSubcomponent;
+import factories.DaggerCoffeeApp_Coffee;
+import injector.InjectorSpec;
+
+public class App implements InjectorSpec {
+
+    @Override
+    public CoffeeApp.Bleu2.Builder bleu2(CoffeeApp.Bleu2.Builder builder, BModule bModule) {
+        return builder.someModule(bModule);
+    }
+
+    @Override
+    public CoffeeApp.Bleu.Builder bleu(CoffeeApp.Bleu.Builder builder, AModule aModule, BModule bModule) {
+        return builder.moduleA(aModule).moduleB(bModule);
+    }
+
+    @Override
+    public CoffeeApp.Coffee.Builder coffee(CoffeeApp.Coffee.Builder builder, DripCoffeeModule dripCoffeeModule) {
+        return builder.dripCoffeeModule(dripCoffeeModule);
+    }
+
+    public void onCreate() {
+
+    }
+
+    @Override
+    public injector.Injector getInjector() {
+        return new injector.Injector(this);
+    }
+
+
+}
diff --git a/examples/simple/src/main/java/coffee/AppConfig.java b/examples/simple/src/main/java/coffee/AppConfig.java
new file mode 100644
index 000000000..efd0946ca
--- /dev/null
+++ b/examples/simple/src/main/java/coffee/AppConfig.java
@@ -0,0 +1,7 @@
+package coffee;
+
+import dagger.Config;
+
+@Config(applicationClass = App.class)
+public class AppConfig {
+}
diff --git a/examples/simple/src/main/java/coffee/BModule.java b/examples/simple/src/main/java/coffee/BModule.java
new file mode 100644
index 000000000..4973ccea3
--- /dev/null
+++ b/examples/simple/src/main/java/coffee/BModule.java
@@ -0,0 +1,23 @@
+package coffee;
+
+import dagger.Module;
+import dagger.Provides;
+
+/**
+ * Created by Andy on 06.05.2017.
+ */
+@Module
+public class BModule {
+
+    private final double A;
+
+    public BModule (double A) {
+        this.A = A;
+    }
+
+    @Provides
+    public Double aDouble() {
+        return A;
+    }
+
+}
diff --git a/examples/simple/src/main/java/coffee/CoffeeApp.java b/examples/simple/src/main/java/coffee/CoffeeApp.java
index b0a93ec3c..bc83db8c4 100644
--- a/examples/simple/src/main/java/coffee/CoffeeApp.java
+++ b/examples/simple/src/main/java/coffee/CoffeeApp.java
@@ -1,6 +1,12 @@
 package coffee;
 
 import dagger.Component;
+import dagger.Module;
+import dagger.ProvidesModule;
+import dagger.Subcomponent;
+import factories.DaggerCoffeeApp_Coffee;
+
+import javax.inject.Named;
 import javax.inject.Singleton;
 
 public class CoffeeApp {
@@ -8,6 +14,37 @@
   @Component(modules = { DripCoffeeModule.class })
   public interface Coffee {
     CoffeeMaker maker();
+    Thermosiphon thermosiphon();
+    Bleu.Builder bleu();
+    @Component.Builder
+    interface Builder {
+      Builder dripCoffeeModule(DripCoffeeModule module);
+      Coffee build();
+    }
+
+  }
+
+  @ActivityScope
+  @Subcomponent(modules = {AModule.class, BModule.class})
+  public interface Bleu {
+    Integer integer();
+    Bleu2.Builder someComponent();
+    @Subcomponent.Builder
+    interface Builder {
+      Builder moduleA(AModule module);
+      Builder moduleB(BModule module);
+      Bleu build();
+    }
+  }
+
+  @Subcomponent(modules = {BModule.class})
+  public interface Bleu2 {
+    CoffeeMaker dou();
+    @Subcomponent.Builder
+    interface Builder {
+      Bleu2.Builder someModule(BModule whaaat);
+      Bleu2 build();
+    }
   }
 
   public static void main(String[] args) {
diff --git a/examples/simple/src/main/java/coffee/CoffeeMaker.java b/examples/simple/src/main/java/coffee/CoffeeMaker.java
index 6410336d0..67b9876c7 100644
--- a/examples/simple/src/main/java/coffee/CoffeeMaker.java
+++ b/examples/simple/src/main/java/coffee/CoffeeMaker.java
@@ -3,19 +3,20 @@
 import dagger.Lazy;
 import javax.inject.Inject;
 
-class CoffeeMaker {
-  private final Lazy<Heater> heater; // Create a possibly costly heater only when we use it.
+public class CoffeeMaker {
+
   private final Pump pump;
+  @Inject
+  Heater heater;
 
-  @Inject CoffeeMaker(Lazy<Heater> heater, Pump pump) {
-    this.heater = heater;
+  @Inject public CoffeeMaker(Pump pump) {
     this.pump = pump;
   }
 
   public void brew() {
-    heater.get().on();
+    heater.on();
     pump.pump();
     System.out.println(" [_]P coffee! [_]P ");
-    heater.get().off();
+    heater.off();
   }
 }
diff --git a/examples/simple/src/main/java/coffee/DripCoffeeModule.java b/examples/simple/src/main/java/coffee/DripCoffeeModule.java
index e50d249e1..99df0114c 100644
--- a/examples/simple/src/main/java/coffee/DripCoffeeModule.java
+++ b/examples/simple/src/main/java/coffee/DripCoffeeModule.java
@@ -5,8 +5,11 @@
 import javax.inject.Singleton;
 
 @Module(includes = PumpModule.class)
-class DripCoffeeModule {
+public class DripCoffeeModule {
   @Provides @Singleton Heater provideHeater() {
     return new ElectricHeater();
   }
+  @Provides @Singleton String provideString() {
+    return "";
+  }
 }
diff --git a/examples/simple/src/main/java/coffee/Heater.java b/examples/simple/src/main/java/coffee/Heater.java
index b5ddb6b88..80cc67afd 100644
--- a/examples/simple/src/main/java/coffee/Heater.java
+++ b/examples/simple/src/main/java/coffee/Heater.java
@@ -1,6 +1,6 @@
 package coffee;
 
-interface Heater {
+public interface Heater {
   void on();
   void off();
   boolean isHot();
diff --git a/examples/simple/src/main/java/coffee/Pump.java b/examples/simple/src/main/java/coffee/Pump.java
index e39434913..7358df8af 100644
--- a/examples/simple/src/main/java/coffee/Pump.java
+++ b/examples/simple/src/main/java/coffee/Pump.java
@@ -1,5 +1,5 @@
 package coffee;
 
-interface Pump {
+public interface Pump {
   void pump();
 }
diff --git a/examples/simple/src/main/java/coffee/PumpModule.java b/examples/simple/src/main/java/coffee/PumpModule.java
index df00b8624..d330d86de 100644
--- a/examples/simple/src/main/java/coffee/PumpModule.java
+++ b/examples/simple/src/main/java/coffee/PumpModule.java
@@ -4,7 +4,7 @@
 import dagger.Module;
 
 @Module
-abstract class PumpModule {
+public abstract class PumpModule {
   @Binds
   abstract Pump providePump(Thermosiphon pump);
 }
diff --git a/examples/simple/src/main/java/coffee/Thermosiphon.java b/examples/simple/src/main/java/coffee/Thermosiphon.java
index c9f9828b0..a20033ee3 100644
--- a/examples/simple/src/main/java/coffee/Thermosiphon.java
+++ b/examples/simple/src/main/java/coffee/Thermosiphon.java
@@ -1,17 +1,18 @@
 package coffee;
 
 import javax.inject.Inject;
+import javax.inject.Provider;
 
-class Thermosiphon implements Pump {
-  private final Heater heater;
+public class Thermosiphon implements Pump {
+  private final Provider<Heater> heater;
 
   @Inject
-  Thermosiphon(Heater heater) {
+  Thermosiphon(Provider<Heater> heater) {
     this.heater = heater;
   }
 
   @Override public void pump() {
-    if (heater.isHot()) {
+    if (heater.get().isHot()) {
       System.out.println("=> => pumping => =>");
     }
   }
diff --git a/gwt/pom.xml b/gwt/pom.xml
index 4666007fd..c427ac54f 100644
--- a/gwt/pom.xml
+++ b/gwt/pom.xml
@@ -22,7 +22,7 @@
   <parent>
     <groupId>com.google.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>2.9</version>
+    <version>3.0</version>
   </parent>
 
   <artifactId>dagger-gwt</artifactId>
diff --git a/pom.xml b/pom.xml
index 6828b61b2..d3e7557b8 100644
--- a/pom.xml
+++ b/pom.xml
@@ -26,7 +26,7 @@
   <groupId>com.google.dagger</groupId>
   <artifactId>dagger-parent</artifactId>
   <packaging>pom</packaging>
-  <version>2.9</version>
+  <version>3.0</version>
   <name>Dagger (Parent)</name>
   <description>A fast dependency injector for Android and Java.</description>
   <url>https://github.com/google/dagger</url>
diff --git a/producers/pom.xml b/producers/pom.xml
index 92b1a25a4..4fa7c4818 100644
--- a/producers/pom.xml
+++ b/producers/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.google.dagger</groupId>
     <artifactId>dagger-parent</artifactId>
-    <version>2.9</version>
+    <version>3.0</version>
   </parent>
 
   <artifactId>dagger-producers</artifactId>
diff --git a/sh.exe.stackdump b/sh.exe.stackdump
new file mode 100644
index 000000000..0ddc977ca
--- /dev/null
+++ b/sh.exe.stackdump
@@ -0,0 +1,4 @@
+Stack trace:
+Frame     Function  Args
+0028BCB8  6106D69F (00000000, 00000000, 00000000, 00000000)
+End of stack trace
