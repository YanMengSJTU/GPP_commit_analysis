diff --git a/compiler/src/it/functional-tests/src/main/java/test/MultibindingModule.java b/compiler/src/it/functional-tests/src/main/java/test/MultibindingModule.java
index b5ca08ed8..6f1766612 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/MultibindingModule.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/MultibindingModule.java
@@ -20,55 +20,86 @@
 import dagger.Provides;
 import dagger.multibindings.ClassKey;
 import dagger.multibindings.IntKey;
+import dagger.multibindings.IntoMap;
+import dagger.multibindings.IntoSet;
 import dagger.multibindings.LongKey;
 import dagger.multibindings.StringKey;
+
 import java.math.BigDecimal;
 import java.math.BigInteger;
 import java.util.Collection;
+import java.util.HashSet;
 import java.util.Map;
 import java.util.Set;
+
 import javax.inject.Named;
 import javax.inject.Provider;
 
 import static dagger.Provides.Type.MAP;
 import static dagger.Provides.Type.SET;
+import static dagger.Provides.Type.SET_VALUES;
 
 @Module
 class MultibindingModule {
-  @Provides(type = MAP)
+  @Provides
+  @IntoMap
   @StringKey("foo")
   static String provideFooKey(double doubleDependency) {
     return "foo value";
   }
 
   @Provides(type = MAP)
+  @StringKey("foo @Provides(type)")
+  static String provideFooProvidesTypeKey(double doubleDependency) {
+    return "foo @Provides(type) value";
+  }
+
+  @Provides
+  @IntoMap
   @StringKey("bar")
   static String provideBarKey() {
     return "bar value";
   }
 
-  @Provides(type = MAP)
+  @Provides
+  @IntoMap
   @StringKey("foo")
   static String[] provideFooArrayValue(double doubleDependency) {
     return new String[] {"foo1", "foo2"};
   }
 
-  @Provides(type = MAP)
+  @Provides
+  @IntoMap
   @StringKey("bar")
   static String[] provideBarArrayValue() {
     return new String[] {"bar1", "bar2"};
   }
 
-  @Provides(type = SET)
+  @Provides
+  @IntoSet
   static int provideFiveToSet() {
     return 5;
   }
 
-  @Provides(type = SET)
+  @Provides
+  @IntoSet
   static int provideSixToSet() {
     return 6;
   }
 
+  @Provides(type = SET)
+  static int provideIntoSetWithProvidesType() {
+    return -100;
+  }
+
+  @Provides(type = SET_VALUES)
+  static Set<Integer> provideElementsIntoSetWithProvidesType() {
+    Set<Integer> set = new HashSet<>();
+    set.add(-101);
+    set.add(-102);
+    return set;
+  }
+
   @Provides
   static Set<String> provideMapKeys(Map<String, Provider<String>> map) {
     return map.keySet();
@@ -79,91 +110,106 @@ static int provideSixToSet() {
     return map.values();
   }
 
-  @Provides(type = MAP)
+  @Provides
+  @IntoMap
   @NestedAnnotationContainer.NestedWrappedKey(Integer.class)
   static String valueForInteger() {
     return "integer";
   }
 
-  @Provides(type = MAP)
+  @Provides
+  @IntoMap
   @NestedAnnotationContainer.NestedWrappedKey(Long.class)
   static String valueForLong() {
     return "long";
   }
 
-  @Provides(type = MAP)
+  @Provides
+  @IntoMap
   @ClassKey(Integer.class)
   static String valueForClassInteger() {
     return "integer";
   }
 
-  @Provides(type = MAP)
+  @Provides
+  @IntoMap
   @ClassKey(Long.class)
   static String valueForClassLong() {
     return "long";
   }
 
-  @Provides(type = MAP)
+  @Provides
+  @IntoMap
   @NumberClassKey(BigDecimal.class)
   static String valueForNumberClassBigDecimal() {
     return "bigdecimal";
   }
 
-  @Provides(type = MAP)
+  @Provides
+  @IntoMap
   @NumberClassKey(BigInteger.class)
   static String valueForNumberClassBigInteger() {
     return "biginteger";
   }
 
-  @Provides(type = MAP)
+  @Provides
+  @IntoMap
   @LongKey(100)
   static String valueFor100Long() {
     return "100 long";
   }
 
-  @Provides(type = MAP)
+  @Provides
+  @IntoMap
   @IntKey(100)
   static String valueFor100Int() {
     return "100 int";
   }
 
-  @Provides(type = MAP)
+  @Provides
+  @IntoMap
   @ShortKey(100)
   static String valueFor100Short() {
     return "100 short";
   }
 
-  @Provides(type = MAP)
+  @Provides
+  @IntoMap
   @ByteKey(100)
   static String valueFor100Byte() {
     return "100 byte";
   }
 
-  @Provides(type = MAP)
+  @Provides
+  @IntoMap
   @BooleanKey(true)
   static String valueForTrue() {
     return "true";
   }
 
-  @Provides(type = MAP)
+  @Provides
+  @IntoMap
   @CharKey('a')
   static String valueForA() {
     return "a char";
   }
 
-  @Provides(type = MAP)
+  @Provides
+  @IntoMap
   @CharKey('\n')
   static String valueForNewline() {
     return "newline char";
   }
 
-  @Provides(type = MAP)
+  @Provides
+  @IntoMap
   @UnwrappedAnnotationKey(@StringKey("foo\n"))
   static String valueForUnwrappedAnnotationKeyFoo() {
     return "foo annotation";
   }
 
-  @Provides(type = MAP)
+  @Provides
+  @IntoMap
   @WrappedAnnotationKey(
     value = @StringKey("foo"),
     integers = {1, 2, 3},
@@ -174,30 +220,35 @@ static String valueForWrappedAnnotationKeyFoo() {
     return "wrapped foo annotation";
   }
 
-  @Provides(type = SET)
+  @Provides
+  @IntoSet
   @Named("complexQualifier")
   static String valueForComplexQualifierSet() {
     return "foo";
   }
 
-  @Provides(type = SET)
+  @Provides
+  @IntoSet
   static CharSequence setContribution() {
     return "foo";
   }
 
-  @Provides(type = SET)
+  @Provides
+  @IntoSet
   @Named("complexQualifier")
   static CharSequence qualifiedSetContribution() {
     return "qualified foo";
   }
 
-  @Provides(type = MAP)
+  @Provides
+  @IntoMap
   @StringKey("key")
   static CharSequence mapContribution() {
     return "foo value";
   }
 
-  @Provides(type = MAP)
+  @Provides
+  @IntoMap
   @Named("complexQualifier")
   @StringKey("key")
   static CharSequence qualifiedMapContribution() {
diff --git a/compiler/src/it/functional-tests/src/main/java/test/cycle/Cycles.java b/compiler/src/it/functional-tests/src/main/java/test/cycle/Cycles.java
index 95d6508cf..63bf45c87 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/cycle/Cycles.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/cycle/Cycles.java
@@ -20,13 +20,12 @@
 import dagger.Module;
 import dagger.Provides;
 import dagger.Subcomponent;
+import dagger.multibindings.IntoMap;
 import dagger.multibindings.StringKey;
 import java.util.Map;
 import javax.inject.Inject;
 import javax.inject.Provider;
 
-import static dagger.Provides.Type.MAP;
-
 /**
  * Cycle classes used for testing cyclic dependencies.
  * A <- (E <- D <- B <- C <- Provider<A>, Lazy<A>), (B <- C <- Provider<A>, Lazy<A>)
@@ -119,13 +118,15 @@ private Cycles() {}
 
   @Module
   static class CycleMapModule {
-    @Provides(type = MAP)
+    @Provides
+    @IntoMap
     @StringKey("X")
     static X x(X x) {
       return x;
     }
 
-    @Provides(type = MAP)
+    @Provides
+    @IntoMap
     @StringKey("Y")
     static Y y(Y y) {
       return y;
diff --git a/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/AModule.java b/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/AModule.java
index d62506a56..01208d919 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/AModule.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/AModule.java
@@ -18,12 +18,13 @@
 
 import dagger.Module;
 import dagger.Provides;
-
-import static dagger.Provides.Type.SET;
+import dagger.multibindings.IntoSet;
 
 @Module
 public final class AModule {
-  @Provides(type = SET) String provideString() {
+  @Provides
+  @IntoSet
+  static String provideString() {
     return "a";
   }
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/multipackage/b/BModule.java b/compiler/src/it/functional-tests/src/main/java/test/multipackage/b/BModule.java
index 4d817f153..6217bf830 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/multipackage/b/BModule.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/multipackage/b/BModule.java
@@ -18,12 +18,13 @@
 
 import dagger.Module;
 import dagger.Provides;
-
-import static dagger.Provides.Type.SET;
+import dagger.multibindings.IntoSet;
 
 @Module
 public final class BModule {
-  @Provides(type = SET) String provideString() {
+  @Provides
+  @IntoSet
+  static String provideString() {
     return "b";
   }
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/multipackage/c/CModule.java b/compiler/src/it/functional-tests/src/main/java/test/multipackage/c/CModule.java
index e608afb2c..edfb9233d 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/multipackage/c/CModule.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/multipackage/c/CModule.java
@@ -18,13 +18,13 @@
 
 import dagger.Module;
 import dagger.Provides;
-import java.util.Set;
-
-import static dagger.Provides.Type.SET;
+import dagger.multibindings.IntoSet;
 
 @Module
 public final class CModule {
-  @Provides(type = SET) String provideString() {
+  @Provides
+  @IntoSet
+  static String provideString() {
     return "c";
   }
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/multipackage/d/DModule.java b/compiler/src/it/functional-tests/src/main/java/test/multipackage/d/DModule.java
index 51f8ace76..7c9f4343e 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/multipackage/d/DModule.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/multipackage/d/DModule.java
@@ -18,13 +18,13 @@
 
 import dagger.Module;
 import dagger.Provides;
-import java.util.Set;
-
-import static dagger.Provides.Type.SET;
+import dagger.multibindings.IntoSet;
 
 @Module
 public final class DModule {
-  @Provides(type = SET) String provideString() {
+  @Provides
+  @IntoSet
+  static String provideString() {
     return "d";
   }
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/scope/BlueModule.java b/compiler/src/it/functional-tests/src/main/java/test/scope/BlueModule.java
index c5fa3fa68..f80824118 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/scope/BlueModule.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/scope/BlueModule.java
@@ -17,12 +17,12 @@
 
 import dagger.Module;
 import dagger.Provides;
-
-import static dagger.Provides.Type.SET;
+import dagger.multibindings.IntoSet;
 
 @Module
 final class BlueModule {
-  @Provides(type = SET)
+  @Provides
+  @IntoSet
   @BlueScope
   static Object blue() {
     return new Object();
diff --git a/compiler/src/it/functional-tests/src/main/java/test/scope/GreenModule.java b/compiler/src/it/functional-tests/src/main/java/test/scope/GreenModule.java
index 9a160ff4b..919a9a178 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/scope/GreenModule.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/scope/GreenModule.java
@@ -17,12 +17,12 @@
 
 import dagger.Module;
 import dagger.Provides;
-
-import static dagger.Provides.Type.SET;
+import dagger.multibindings.IntoSet;
 
 @Module
 final class GreenModule  {
-  @Provides(type = SET)
+  @Provides
+  @IntoSet
   @GreenScope
   static Object green() {
     return new Object();
diff --git a/compiler/src/it/functional-tests/src/main/java/test/scope/TurquoiseModule.java b/compiler/src/it/functional-tests/src/main/java/test/scope/TurquoiseModule.java
index 7947ccfbd..77af9e76a 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/scope/TurquoiseModule.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/scope/TurquoiseModule.java
@@ -17,18 +17,19 @@
 
 import dagger.Module;
 import dagger.Provides;
-
-import static dagger.Provides.Type.SET;
+import dagger.multibindings.IntoSet;
 
 @Module
 final class TurquoiseModule {
-  @Provides(type = SET)
+  @Provides
+  @IntoSet
   @BlueScope
   static Object blue() {
     return new Object();
   }
 
-  @Provides(type = SET)
+  @Provides
+  @IntoSet
   @GreenScope
   static Object green() {
     return new Object();
diff --git a/compiler/src/it/functional-tests/src/main/java/test/staticprovides/AllStaticModule.java b/compiler/src/it/functional-tests/src/main/java/test/staticprovides/AllStaticModule.java
index f47d36c6a..4844e0563 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/staticprovides/AllStaticModule.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/staticprovides/AllStaticModule.java
@@ -15,21 +15,26 @@
  */
 package test.staticprovides;
 
-import static dagger.Provides.Type.SET;
-import static dagger.Provides.Type.SET_VALUES;
 import static java.util.Collections.emptySet;
 
 import dagger.Module;
 import dagger.Provides;
+import dagger.multibindings.ElementsIntoSet;
+import dagger.multibindings.IntoSet;
+
 import java.util.Set;
 
 @Module
 final class AllStaticModule {
-  @Provides(type = SET) static String contributeString() {
+  @Provides
+  @IntoSet
+  static String contributeString() {
     return AllStaticModule.class + ".contributeString";
   }
 
-  @Provides(type = SET_VALUES) static Set<Integer> contibuteEmptyIntegerSet() {
+  @Provides
+  @ElementsIntoSet
+  static Set<Integer> contibuteEmptyIntegerSet() {
     return emptySet();
   }
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/staticprovides/SomeStaticModule.java b/compiler/src/it/functional-tests/src/main/java/test/staticprovides/SomeStaticModule.java
index 53ee14d95..05219de36 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/staticprovides/SomeStaticModule.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/staticprovides/SomeStaticModule.java
@@ -15,18 +15,21 @@
  */
 package test.staticprovides;
 
-import static dagger.Provides.Type.SET;
-
 import dagger.Module;
 import dagger.Provides;
+import dagger.multibindings.IntoSet;
 
 @Module
 final class SomeStaticModule {
-  @Provides(type = SET) static String contributeStringFromAStaticMethod() {
+  @Provides
+  @IntoSet
+  static String contributeStringFromAStaticMethod() {
     return SomeStaticModule.class + ".contributeStringFromAStaticMethod";
   }
 
-  @Provides(type = SET) String contributeStringFromAnInstanceMethod() {
+  @Provides
+  @IntoSet
+  static String contributeStringFromAnInstanceMethod() {
     return SomeStaticModule.class + ".contributeStringFromAnInstanceMethod";
   }
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/sub/ContributionsModule.java b/compiler/src/it/functional-tests/src/main/java/test/sub/ContributionsModule.java
index b10ac4533..953012ca6 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/sub/ContributionsModule.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/sub/ContributionsModule.java
@@ -17,25 +17,30 @@
 
 import dagger.Module;
 import dagger.Provides;
+import dagger.multibindings.ElementsIntoSet;
+import dagger.multibindings.IntoSet;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.LinkedHashSet;
 import java.util.Set;
 
-import static dagger.Provides.Type.SET;
-import static dagger.Provides.Type.SET_VALUES;
-
 @Module
 public final class ContributionsModule {
-  @Provides(type = SET) int contributeAnInt(double doubleDependency) {
+  @Provides
+  @IntoSet
+  static int contributeAnInt(double doubleDependency) {
     return 1742;
   }
 
-  @Provides(type = SET) int contributeAnotherInt() {
+  @Provides
+  @IntoSet
+  static int contributeAnotherInt() {
     return 832;
   }
 
-  @Provides(type = SET_VALUES) Set<Integer> contributeSomeInts() {
+  @Provides
+  @ElementsIntoSet
+  static Set<Integer> contributeSomeInts() {
     return Collections.unmodifiableSet(new LinkedHashSet<Integer>(Arrays.asList(-1, -90, -17)));
   }
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildModule.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildModule.java
index ef28bd47a..9ad2b5439 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildModule.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildModule.java
@@ -17,12 +17,13 @@
 
 import dagger.Module;
 import dagger.Provides;
-
-import static dagger.Provides.Type.SET;
+import dagger.multibindings.IntoSet;
 
 @Module
 final class ChildModule {
-  @Provides(type = SET) Object provideUnscopedObject() {
+  @Provides
+  @IntoSet
+  static Object provideUnscopedObject() {
     return new Object() {
       @Override public String toString() {
         return "unscoped in child";
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/GrandchildModule.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/GrandchildModule.java
index b2885412f..b74ad8beb 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/GrandchildModule.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/GrandchildModule.java
@@ -17,12 +17,13 @@
 
 import dagger.Module;
 import dagger.Provides;
-
-import static dagger.Provides.Type.SET;
+import dagger.multibindings.IntoSet;
 
 @Module
 final class GrandchildModule {
-  @Provides(type = SET) Object provideUnscopedObject() {
+  @Provides
+  @IntoSet
+  static Object provideUnscopedObject() {
     return new Object() {
       @Override public String toString() {
         return "unscoped in grandchild";
@@ -30,11 +31,13 @@
     };
   }
 
-  @Provides AnInterface provideAnInterface(ImplementsAnInterface implementsAnInterface) {
+  @Provides
+  static AnInterface provideAnInterface(ImplementsAnInterface implementsAnInterface) {
     return implementsAnInterface;
   }
 
-  @Provides NeedsAnInterface provideNeedsAnInterface(AnInterface anInterface) {
+  @Provides
+  static NeedsAnInterface provideNeedsAnInterface(AnInterface anInterface) {
     return new NeedsAnInterface(anInterface);
   }
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/MultibindingSubcomponents.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/MultibindingSubcomponents.java
index 4ecf8caf3..14abce625 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/MultibindingSubcomponents.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/MultibindingSubcomponents.java
@@ -19,15 +19,14 @@
 import dagger.Module;
 import dagger.Provides;
 import dagger.Subcomponent;
+import dagger.multibindings.IntoMap;
+import dagger.multibindings.IntoSet;
 import dagger.multibindings.StringKey;
 import java.util.Map;
 import java.util.Objects;
 import java.util.Set;
 import javax.inject.Inject;
 
-import static dagger.Provides.Type.MAP;
-import static dagger.Provides.Type.SET;
-
 final class MultibindingSubcomponents {
 
   /** Multibindings for this type are bound only in the parent component. */
@@ -86,23 +85,27 @@ public String toString() {
   @Module
   static final class ParentMultibindingModule {
 
-    @Provides(type = SET)
+    @Provides
+    @IntoSet
     static BoundInParent onlyInParentElement() {
       return BoundInParent.INSTANCE;
     }
 
-    @Provides(type = MAP)
+    @Provides
+    @IntoMap
     @StringKey("parent key")
     static BoundInParent onlyInParentEntry() {
       return BoundInParent.INSTANCE;
     }
 
-    @Provides(type = SET)
+    @Provides
+    @IntoSet
     static BoundInParentAndChild inParentAndChildElement() {
       return BoundInParentAndChild.IN_PARENT;
     }
 
-    @Provides(type = MAP)
+    @Provides
+    @IntoMap
     @StringKey("parent key")
     static BoundInParentAndChild inParentAndChildEntry() {
       return BoundInParentAndChild.IN_PARENT;
@@ -110,8 +113,9 @@ static BoundInParentAndChild inParentAndChildEntry() {
 
     /* This is not static because otherwise we have no tests that cover the case where a
      * subcomponent uses a module instance installed onto a parent component. */
-    @Provides(type = SET)
-    RequiresMultibindings<BoundInParentAndChild>
+    @Provides
+    @IntoSet
+    static RequiresMultibindings<BoundInParentAndChild>
         requiresMultibindingsInParentAndChildElement(
             RequiresMultibindings<BoundInParentAndChild> requiresMultibindingsInParentAndChild) {
       return requiresMultibindingsInParentAndChild;
@@ -121,23 +125,27 @@ static BoundInParentAndChild inParentAndChildEntry() {
   @Module
   static final class ChildMultibindingModule {
 
-    @Provides(type = SET)
+    @Provides
+    @IntoSet
     static BoundInParentAndChild inParentAndChildElement() {
       return BoundInParentAndChild.IN_CHILD;
     }
 
-    @Provides(type = MAP)
+    @Provides
+    @IntoMap
     @StringKey("child key")
     static BoundInParentAndChild inParentAndChildEntry() {
       return BoundInParentAndChild.IN_CHILD;
     }
 
-    @Provides(type = SET)
+    @Provides
+    @IntoSet
     static BoundInChild onlyInChildElement() {
       return BoundInChild.INSTANCE;
     }
 
-    @Provides(type = MAP)
+    @Provides
+    @IntoMap
     @StringKey("child key")
     static BoundInChild onlyInChildEntry() {
       return BoundInChild.INSTANCE;
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentModule.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentModule.java
index dbe1a534a..748db15b0 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentModule.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentModule.java
@@ -17,13 +17,14 @@
 
 import dagger.Module;
 import dagger.Provides;
+import dagger.multibindings.IntoSet;
 import javax.inject.Singleton;
 
-import static dagger.Provides.Type.SET;
-
 @Module
 final class ParentModule {
-  @Provides(type = SET) Object provideUnscopedObject() {
+  @Provides
+  @IntoSet
+  static Object provideUnscopedObject() {
     return new Object() {
       @Override public String toString() {
         return "unscoped in parent";
@@ -31,7 +32,10 @@
     };
   }
 
-  @Provides(type = SET) @Singleton Object provideSingletonObject() {
+  @Provides
+  @IntoSet
+  @Singleton
+  static Object provideSingletonObject() {
     return new Object() {
       @Override public String toString() {
         return "singleton";
@@ -39,8 +43,10 @@
     };
   }
 
-  @Provides @Singleton @BoundAsSingleton UnscopedType provideUnscopedTypeBoundAsSingleton(
-      UnscopedType unscopedType) {
+  @Provides
+  @Singleton
+  @BoundAsSingleton
+  static UnscopedType provideUnscopedTypeBoundAsSingleton(UnscopedType unscopedType) {
     return unscopedType;
   }
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/RepeatedModule.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/RepeatedModule.java
index d0997513d..e3da28032 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/RepeatedModule.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/RepeatedModule.java
@@ -17,8 +17,7 @@
 
 import dagger.Module;
 import dagger.Provides;
-
-import static dagger.Provides.Type.SET;
+import dagger.multibindings.IntoSet;
 
 @Module
 final class RepeatedModule {
@@ -34,7 +33,8 @@ static String provideString() {
     return "a string";
   }
 
-  @Provides(type = SET)
+  @Provides
+  @IntoSet
   static String contributeString() {
     return "a string in a set";
   }
diff --git a/compiler/src/it/functional-tests/src/test/java/test/MultibindingTest.java b/compiler/src/it/functional-tests/src/test/java/test/MultibindingTest.java
index a28110b91..33b9aed38 100644
--- a/compiler/src/it/functional-tests/src/test/java/test/MultibindingTest.java
+++ b/compiler/src/it/functional-tests/src/test/java/test/MultibindingTest.java
@@ -44,9 +44,10 @@
 
   @Test public void map() {
     Map<String, String> map = multibindingComponent.map();
-    assertThat(map).hasSize(2);
+    assertThat(map).hasSize(3);
     assertThat(map).containsEntry("foo", "foo value");
     assertThat(map).containsEntry("bar", "bar value");
+    assertThat(map).containsEntry("foo @Provides(type)", "foo @Provides(type) value");
   }
 
   @Test public void mapOfArrays() {
@@ -60,14 +61,18 @@
 
   @Test public void mapOfProviders() {
     Map<String, Provider<String>> mapOfProviders = multibindingComponent.mapOfProviders();
-    assertThat(mapOfProviders).hasSize(2);
+    assertThat(mapOfProviders).hasSize(3);
     assertThat(mapOfProviders.get("foo").get()).isEqualTo("foo value");
     assertThat(mapOfProviders.get("bar").get()).isEqualTo("bar value");
+    assertThat(mapOfProviders.get("foo @Provides(type)").get())
+        .isEqualTo("foo @Provides(type) value");
   }
 
   @Test public void mapKeysAndValues() {
-    assertThat(multibindingComponent.mapKeys()).containsExactly("foo", "bar");
-    assertThat(multibindingComponent.mapValues()).containsExactly("foo value", "bar value");
+    assertThat(multibindingComponent.mapKeys())
+        .containsExactly("foo", "bar", "foo @Provides(type)");
+    assertThat(multibindingComponent.mapValues())
+        .containsExactly("foo value", "bar value", "foo @Provides(type) value");
   }
 
   @Test public void nestedKeyMap() {
@@ -148,10 +153,12 @@ public void shortKeyMap() {
   }
 
   @Test public void setBindings() {
-    assertThat(multibindingComponent.set()).containsExactly(-90, -17, -1, 5, 6, 832, 1742);
+    assertThat(multibindingComponent.set())
+        .containsExactly(-90, -17, -1, 5, 6, 832, 1742, -100, -101, -102);
   }
 
-  @Test public void complexQualifierSet() {
+  @Test
+  public void complexQualifierSet() {
     assertThat(multibindingComponent.complexQualifierStringSet()).containsExactly("foo");
   }
 
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/SimpleProducerModule.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/SimpleProducerModule.java
index 63500ca0c..7e335cc3b 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/SimpleProducerModule.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/SimpleProducerModule.java
@@ -20,6 +20,8 @@
 import com.google.common.util.concurrent.ListenableFuture;
 import com.google.common.util.concurrent.SettableFuture;
 import dagger.Lazy;
+import dagger.multibindings.ElementsIntoSet;
+import dagger.multibindings.IntoSet;
 import dagger.producers.Produced;
 import dagger.producers.Producer;
 import dagger.producers.ProducerModule;
@@ -29,9 +31,6 @@
 import javax.inject.Provider;
 import javax.inject.Qualifier;
 
-import static dagger.producers.Produces.Type.SET;
-import static dagger.producers.Produces.Type.SET_VALUES;
-
 /**
  * A module that contains various signatures of produces methods. This is not used in any
  * components.
@@ -142,85 +141,101 @@ static String strWithFrameworkTypeArgs(
 
   // Set bindings.
 
-  @Produces(type = SET)
+  @Produces
+  @IntoSet
   static String setOfStrElement() {
     return "set of str element";
   }
 
-  @Produces(type = SET)
+  @Produces
+  @IntoSet
   static String setOfStrElementThrowingException() throws IOException {
     return "set of str element throwing exception";
   }
 
-  @Produces(type = SET)
+  @Produces
+  @IntoSet
   static ListenableFuture<String> setOfStrFutureElement() {
     return Futures.immediateFuture("set of str element");
   }
 
-  @Produces(type = SET)
+  @Produces
+  @IntoSet
   static ListenableFuture<String> setOfStrFutureElementThrowingException() throws IOException {
     return Futures.immediateFuture("set of str element throwing exception");
   }
 
-  @Produces(type = SET)
+  @Produces
+  @IntoSet
   static String setOfStrElementWithArg(int i) {
     return "set of str element with arg";
   }
 
-  @Produces(type = SET)
+  @Produces
+  @IntoSet
   static String setOfStrElementWithArgThrowingException(int i) throws IOException {
     return "set of str element with arg throwing exception";
   }
 
-  @Produces(type = SET)
+  @Produces
+  @IntoSet
   static ListenableFuture<String> setOfStrFutureElementWithArg(int i) {
     return Futures.immediateFuture("set of str element with arg");
   }
 
-  @Produces(type = SET)
+  @Produces
+  @IntoSet
   static ListenableFuture<String> setOfStrFutureElementWithArgThrowingException(int i)
       throws IOException {
     return Futures.immediateFuture("set of str element with arg throwing exception");
   }
 
-  @Produces(type = SET_VALUES)
+  @Produces
+  @ElementsIntoSet
   static Set<String> setOfStrValues() {
     return ImmutableSet.of("set of str 1", "set of str 2");
   }
 
-  @Produces(type = SET_VALUES)
+  @Produces
+  @ElementsIntoSet
   static Set<String> setOfStrValuesThrowingException() throws IOException {
     return ImmutableSet.of("set of str 1", "set of str 2 throwing exception");
   }
 
-  @Produces(type = SET_VALUES)
+  @Produces
+  @ElementsIntoSet
   static ListenableFuture<Set<String>> setOfStrFutureValues() {
     return Futures.<Set<String>>immediateFuture(ImmutableSet.of("set of str 1", "set of str 2"));
   }
 
-  @Produces(type = SET_VALUES)
+  @Produces
+  @ElementsIntoSet
   static ListenableFuture<Set<String>> setOfStrFutureValuesThrowingException() throws IOException {
     return Futures.<Set<String>>immediateFuture(
         ImmutableSet.of("set of str 1", "set of str 2 throwing exception"));
   }
 
-  @Produces(type = SET_VALUES)
+  @Produces
+  @ElementsIntoSet
   static Set<String> setOfStrValuesWithArg(int i) {
     return ImmutableSet.of("set of str with arg 1", "set of str with arg 2");
   }
 
-  @Produces(type = SET_VALUES)
+  @Produces
+  @ElementsIntoSet
   static Set<String> setOfStrValuesWithArgThrowingException(int i) throws IOException {
     return ImmutableSet.of("set of str with arg 1", "set of str with arg 2 throwing exception");
   }
 
-  @Produces(type = SET_VALUES)
+  @Produces
+  @ElementsIntoSet
   static ListenableFuture<Set<String>> setOfStrFutureValuesWithArg(int i) {
     return Futures.<Set<String>>immediateFuture(
         ImmutableSet.of("set of str with arg 1", "set of str with arg 2"));
   }
 
-  @Produces(type = SET_VALUES)
+  @Produces
+  @ElementsIntoSet
   static ListenableFuture<Set<String>> setOfStrFutureValuesWithArgThrowingException(int i)
       throws IOException {
     return Futures.<Set<String>>immediateFuture(
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/MonitoringModule.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/MonitoringModule.java
index 0c4209076..4b99c7a12 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/MonitoringModule.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/MonitoringModule.java
@@ -17,10 +17,9 @@
 
 import dagger.Module;
 import dagger.Provides;
+import dagger.multibindings.IntoSet;
 import dagger.producers.monitoring.ProductionComponentMonitor;
 
-import static dagger.Provides.Type.SET;
-
 @Module
 final class MonitoringModule {
   private final ProductionComponentMonitor.Factory monitorFactory;
@@ -29,7 +28,8 @@
     this.monitorFactory = monitorFactory;
   }
 
-  @Provides(type = SET)
+  @Provides
+  @IntoSet
   ProductionComponentMonitor.Factory monitorFactory() {
     return monitorFactory;
   }
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/MultibindingProducerModule.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/MultibindingProducerModule.java
index 8e311f8fe..6f182c0e6 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/MultibindingProducerModule.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/MultibindingProducerModule.java
@@ -19,7 +19,10 @@
 import com.google.common.util.concurrent.Futures;
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.Multibindings;
+import dagger.multibindings.ElementsIntoSet;
 import dagger.multibindings.IntKey;
+import dagger.multibindings.IntoMap;
+import dagger.multibindings.IntoSet;
 import dagger.producers.Produced;
 import dagger.producers.ProducerModule;
 import dagger.producers.Produces;
@@ -29,28 +32,28 @@
 import producerstest.multibindings.Qualifiers.PossiblyThrowingMap;
 import producerstest.multibindings.Qualifiers.PossiblyThrowingSet;
 
-import static dagger.producers.Produces.Type.MAP;
-import static dagger.producers.Produces.Type.SET;
-import static dagger.producers.Produces.Type.SET_VALUES;
-
 @ProducerModule
 final class MultibindingProducerModule {
-  @Produces(type = SET)
+  @Produces
+  @IntoSet
   static ListenableFuture<String> futureStr() {
     return Futures.immediateFuture("foo");
   }
 
-  @Produces(type = SET)
+  @Produces
+  @IntoSet
   static String str() {
     return "bar";
   }
 
-  @Produces(type = SET_VALUES)
+  @Produces
+  @ElementsIntoSet
   static ListenableFuture<Set<String>> futureStrs() {
     return Futures.<Set<String>>immediateFuture(ImmutableSet.of("foo1", "foo2"));
   }
 
-  @Produces(type = SET_VALUES)
+  @Produces
+  @ElementsIntoSet
   static Set<String> strs() {
     return ImmutableSet.of("bar1", "bar2");
   }
@@ -60,44 +63,51 @@ static int strCount(Set<String> strs) {
     return strs.size();
   }
 
-  @Produces(type = SET)
+  @Produces
+  @IntoSet
   @PossiblyThrowingSet
   static String successfulStringForSet() {
     return "singleton";
   }
 
-  @Produces(type = SET_VALUES)
+  @Produces
+  @ElementsIntoSet
   @PossiblyThrowingSet
   static Set<String> successfulStringsForSet() {
     return ImmutableSet.of("double", "ton");
   }
 
-  @Produces(type = SET)
+  @Produces
+  @IntoSet
   @PossiblyThrowingSet
   static String throwingStringForSet() {
     throw new RuntimeException("monkey");
   }
 
-  @Produces(type = MAP)
+  @Produces
+  @IntoMap
   @IntKey(42)
   static ListenableFuture<String> futureFor42() {
     return Futures.immediateFuture("forty two");
   }
 
-  @Produces(type = MAP)
+  @Produces
+  @IntoMap
   @IntKey(15)
   static String valueFor15() {
     return "fifteen";
   }
 
-  @Produces(type = MAP)
+  @Produces
+  @IntoMap
   @PossiblyThrowingMap
   @IntKey(42)
   static ListenableFuture<String> successfulFutureFor42() {
     return Futures.immediateFuture("forty two");
   }
 
-  @Produces(type = MAP)
+  @Produces
+  @IntoMap
   @PossiblyThrowingMap
   @IntKey(15)
   static String throwingValueFor15() {
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/scope/SetProducerModule.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/scope/SetProducerModule.java
index a5fc81e16..e930e2749 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/scope/SetProducerModule.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/scope/SetProducerModule.java
@@ -15,23 +15,24 @@
  */
 package producerstest.scope;
 
+import dagger.multibindings.IntoSet;
 import dagger.producers.ProducerModule;
 import dagger.producers.Produces;
 
-import static dagger.producers.Produces.Type.SET;
-
 /**
  * A module that provides two entries into a set; but since the inputs are scoped, the set should
  * only have one value.
  */
 @ProducerModule
 final class SetProducerModule {
-  @Produces(type = SET)
+  @Produces
+  @IntoSet
   static Object setValue1(Object value) {
     return value;
   }
 
-  @Produces(type = SET)
+  @Produces
+  @IntoSet
   static Object setValue2(Object value) {
     return value;
   }
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
index 70efa5aaf..17ed72d44 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -1264,6 +1264,7 @@ private String formatContributionType(ContributionType type) {
       case MAP:
         return "Map";
       case SET:
+      case SET_VALUES:
         return "Set";
       case UNIQUE:
         return "Unique";
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
index f808a49c1..b78e8d26b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -167,6 +167,7 @@ public SourceVersion getSupportedSourceVersion() {
         new MonitoringModuleProcessingStep(messager, monitoringModuleGenerator),
         new ProductionExecutorModuleProcessingStep(messager, productionExecutorModuleGenerator),
         new MultibindingsProcessingStep(messager, multibindingsValidator),
+        new MultibindingAnnotationsProcessingStep(messager),
         new ModuleProcessingStep(
             messager,
             moduleValidator,
diff --git a/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
index 250bed887..2d9298e14 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
@@ -204,21 +204,6 @@ static Kind forMultibindingRequest(DependencyRequest request) {
    */
   protected abstract Kind bindingKind();
 
-  /**
-   * A predicate that passes for bindings of a given kind.
-   */
-  static Predicate<ContributionBinding> isOfKind(Kind kind) {
-    return Predicates.compose(Predicates.equalTo(kind), KIND);
-  }
-
-  /** The provision type that was used to bind the key. */
-  abstract Provides.Type provisionType();
-
-  @Override
-  public ContributionType contributionType() {
-    return ContributionType.forProvisionType(provisionType());
-  }
-
   /**
    * The strategy for getting an instance of a factory for a {@link ContributionBinding}.
    */
diff --git a/compiler/src/main/java/dagger/internal/codegen/ContributionType.java b/compiler/src/main/java/dagger/internal/codegen/ContributionType.java
index a1033932a..b5966695a 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ContributionType.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ContributionType.java
@@ -18,6 +18,15 @@
 import com.google.common.base.Function;
 import com.google.common.collect.ImmutableListMultimap;
 import com.google.common.collect.Multimaps;
+import dagger.Provides;
+import dagger.multibindings.ElementsIntoSet;
+import dagger.multibindings.IntoMap;
+import dagger.multibindings.IntoSet;
+import dagger.producers.Produces;
+import javax.lang.model.element.ExecutableElement;
+
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
+import static com.google.common.base.Preconditions.checkArgument;
 
 /**
  * Whether a binding or declaration is for a unique contribution or a map or set multibinding.
@@ -27,6 +36,8 @@
   MAP,
   /** Represents set bindings. */
   SET,
+  /** Represents set values bindings. */
+  SET_VALUES,
   /** Represents a valid non-collection binding. */
   UNIQUE,
   ;
@@ -48,11 +59,12 @@ boolean isMultibinding() {
   }
 
   /** The contribution type for a given provision type. */
-  static ContributionType forProvisionType(dagger.Provides.Type provisionType) {
+  private static ContributionType forProvisionType(Provides.Type provisionType) {
     switch (provisionType) {
       case SET:
-      case SET_VALUES:
         return SET;
+      case SET_VALUES:
+        return SET_VALUES;
       case MAP:
         return MAP;
       case UNIQUE:
@@ -62,6 +74,47 @@ static ContributionType forProvisionType(dagger.Provides.Type provisionType) {
     }
   }
 
+  private static ContributionType forProductionType(Produces.Type productionType) {
+    switch (productionType) {
+      case SET:
+        return SET;
+      case SET_VALUES:
+        return SET_VALUES;
+      case MAP:
+        return MAP;
+      case UNIQUE:
+        return UNIQUE;
+      default:
+        throw new AssertionError("Unknown production type: " + productionType);
+    }
+  }
+
+  /**
+   * The contribution type from a binding method annotations. Presumes a well-formed binding method
+   * (only one of @IntoSet, @IntoMap, @ElementsIntoSet, @Provides.type or @Produces.type. {@link
+   * ProvidesMethodValidator} and {@link ProducesMethodValidator} validate correctness on their own.
+   */
+  static ContributionType fromBindingMethod(ExecutableElement method) {
+    checkArgument(
+        isAnnotationPresent(method, Provides.class)
+            || isAnnotationPresent(method, Produces.class));
+    if (isAnnotationPresent(method, IntoMap.class)) {
+      return ContributionType.MAP;
+    } else if (isAnnotationPresent(method, IntoSet.class)) {
+      return ContributionType.SET;
+    } else if (isAnnotationPresent(method, ElementsIntoSet.class)) {
+      return ContributionType.SET_VALUES;
+    }
+
+    if (isAnnotationPresent(method, Provides.class)) {
+      return forProvisionType(method.getAnnotation(Provides.class).type());
+    } else if (isAnnotationPresent(method, Produces.class)) {
+      return forProductionType(method.getAnnotation(Produces.class).type());
+    } else {
+      throw new AssertionError();
+    }
+  }
+
   /** Indexes objects by their contribution type. */
   static <T extends HasContributionType>
       ImmutableListMultimap<ContributionType, T> indexByContributionType(
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
index 8866cb570..b59d2caca 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
@@ -232,6 +232,7 @@ private Kind multibindingContributionRequestKind(ContributionBinding multibindin
               ? Kind.PRODUCER
               : Kind.PROVIDER;
         case SET:
+        case SET_VALUES:
           return Kind.INSTANCE;
         case UNIQUE:
           throw new IllegalArgumentException(
diff --git a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
index 333969e02..b8a439417 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
@@ -284,6 +284,16 @@ static String nullableToNonNullable(String typeName, String bindingString) {
   static final String CANNOT_RETURN_NULL_FROM_NON_NULLABLE_PROVIDES_METHOD =
       "Cannot return null from a non-@Nullable @Provides method";
 
+  /* Multibinding messages */
+  static final String MULTIBINDING_ANNOTATION_NOT_ON_PROVIDES_OR_PRODUCES =
+      "Multibinding annotations may only be on @Provides or @Produces methods";
+
+  static final String MULTIPLE_MULTIBINDING_ANNOTATIONS_ON_METHOD =
+      "Multiple multibinding annotations cannot be placed on the same %s method";
+
+  static final String MULTIBINDING_ANNOTATION_CONFLICTS_WITH_BINDING_ANNOTATION_ENUM =
+      "@%s.type cannot be used with multibinding annotations";
+
   static ComponentBuilderMessages builderMsgsFor(ComponentDescriptor.Kind kind) {
     switch(kind) {
       case COMPONENT:
diff --git a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
index 22203c0ff..f513e0148 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
@@ -29,6 +29,7 @@
 import com.squareup.javapoet.TypeName;
 import com.squareup.javapoet.TypeSpec;
 import com.squareup.javapoet.TypeVariableName;
+import dagger.Provides;
 import dagger.internal.Factory;
 import dagger.internal.MembersInjectors;
 import dagger.internal.Preconditions;
@@ -47,13 +48,13 @@
 import static com.squareup.javapoet.MethodSpec.methodBuilder;
 import static com.squareup.javapoet.TypeSpec.classBuilder;
 import static com.squareup.javapoet.TypeSpec.enumBuilder;
-import static dagger.Provides.Type.SET;
 import static dagger.internal.codegen.AnnotationSpecs.SUPPRESS_WARNINGS_RAWTYPES;
 import static dagger.internal.codegen.AnnotationSpecs.SUPPRESS_WARNINGS_UNCHECKED;
 import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
 import static dagger.internal.codegen.ContributionBinding.FactoryCreationStrategy.ENUM_INSTANCE;
 import static dagger.internal.codegen.ContributionBinding.Kind.INJECTION;
 import static dagger.internal.codegen.ContributionBinding.Kind.PROVISION;
+import static dagger.internal.codegen.ContributionType.SET;
 import static dagger.internal.codegen.ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_PROVIDES_METHOD;
 import static dagger.internal.codegen.SourceFiles.bindingTypeElementTypeVariableNames;
 import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
@@ -235,7 +236,7 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
           ".$L($L)", binding.bindingElement().getSimpleName(), parametersCodeBlock);
       CodeBlock providesMethodInvocation = providesMethodInvocationBuilder.build();
 
-      if (binding.provisionType().equals(SET)) {
+      if (binding.contributionType().equals(SET)) {
         TypeName paramTypeName = TypeName.get(
             MoreTypes.asDeclared(keyType).getTypeArguments().get(0));
         // TODO(cgruber): only be explicit with the parameter if paramType contains wildcards.
diff --git a/compiler/src/main/java/dagger/internal/codegen/Key.java b/compiler/src/main/java/dagger/internal/codegen/Key.java
index 5ebb1c5e1..a27593174 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Key.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Key.java
@@ -30,10 +30,8 @@
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.Binds;
 import dagger.Multibindings;
-import dagger.Provides;
 import dagger.producers.Produced;
 import dagger.producers.Producer;
-import dagger.producers.Produces;
 import dagger.producers.Production;
 import dagger.producers.internal.ProductionImplementation;
 import java.util.Map;
@@ -305,48 +303,29 @@ Key forSubcomponentBuilderMethod(
     }
 
     Key forProvidesMethod(SourceElement sourceElement) {
-      checkArgument(sourceElement.element().getKind().equals(METHOD));
-      ExecutableElement method = MoreElements.asExecutable(sourceElement.element());
-      ExecutableType methodType =
-          MoreTypes.asExecutable(sourceElement.asMemberOfContributingType(types));
-      Provides providesAnnotation = method.getAnnotation(Provides.class);
-      checkArgument(providesAnnotation != null);
-      TypeMirror returnType = normalize(types, methodType.getReturnType());
-      TypeMirror keyType =
-          providesOrProducesKeyType(
-              returnType,
-              method,
-              Optional.of(providesAnnotation.type()),
-              Optional.<Produces.Type>absent());
-      Key key = forMethod(method, keyType);
-      return providesAnnotation.type().equals(Provides.Type.UNIQUE)
-          ? key
-          : key.withBindingMethod(sourceElement);
+      return forProvidesOrProducesMethod(sourceElement, getProviderElement());
     }
 
-    // TODO(beder): Reconcile this method with forProvidesMethod when Provides.Type and
-    // Produces.Type are no longer different.
     Key forProducesMethod(SourceElement sourceElement) {
+      return forProvidesOrProducesMethod(sourceElement, getProducerElement());
+    }
+
+    private Key forProvidesOrProducesMethod(
+        SourceElement sourceElement, TypeElement frameworkType) {
       checkArgument(sourceElement.element().getKind().equals(METHOD));
       ExecutableElement method = MoreElements.asExecutable(sourceElement.element());
       ExecutableType methodType =
           MoreTypes.asExecutable(sourceElement.asMemberOfContributingType(types));
-      Produces producesAnnotation = method.getAnnotation(Produces.class);
-      checkArgument(producesAnnotation != null);
+      ContributionType contributionType = ContributionType.fromBindingMethod(method);
       TypeMirror returnType = normalize(types, methodType.getReturnType());
-      TypeMirror unfuturedType = returnType;
-      if (MoreTypes.isTypeOf(ListenableFuture.class, returnType)) {
-        unfuturedType =
-            Iterables.getOnlyElement(MoreTypes.asDeclared(returnType).getTypeArguments());
+      if (frameworkType.equals(getProducerElement())
+          && MoreTypes.isTypeOf(ListenableFuture.class, returnType)) {
+        returnType = Iterables.getOnlyElement(MoreTypes.asDeclared(returnType).getTypeArguments());
       }
       TypeMirror keyType =
-          providesOrProducesKeyType(
-              unfuturedType,
-              method,
-              Optional.<Provides.Type>absent(),
-              Optional.of(producesAnnotation.type()));
+          providesOrProducesKeyType(returnType, method, contributionType, frameworkType);
       Key key = forMethod(method, keyType);
-      return producesAnnotation.type().equals(Produces.Type.UNIQUE)
+      return contributionType.equals(ContributionType.UNIQUE)
           ? key
           : key.withBindingMethod(sourceElement);
     }
@@ -397,23 +376,18 @@ Key forBindParameter(SourceElement bindsMethodElement) {
     private TypeMirror providesOrProducesKeyType(
         TypeMirror returnType,
         ExecutableElement method,
-        Optional<Provides.Type> providesType,
-        Optional<Produces.Type> producesType) {
-      switch (providesType.isPresent()
-          ? providesType.get()
-          : Provides.Type.valueOf(producesType.get().name())) {
+        ContributionType contributionType,
+        TypeElement frameworkType) {
+      switch (contributionType) {
         case UNIQUE:
           return returnType;
         case SET:
           return types.getDeclaredType(getSetElement(), returnType);
         case MAP:
-          return mapOfFrameworkType(
-              mapKeyType(method),
-              providesType.isPresent() ? getProviderElement() : getProducerElement(),
-              returnType);
+          return mapOfFrameworkType(mapKeyType(method), frameworkType, returnType);
         case SET_VALUES:
           // TODO(gak): do we want to allow people to use "covariant return" here?
-          checkArgument(MoreTypes.isType(returnType) && MoreTypes.isTypeOf(Set.class, returnType));
+          checkArgument(SetType.isSet(returnType));
           return returnType;
         default:
           throw new AssertionError();
diff --git a/compiler/src/main/java/dagger/internal/codegen/MultibindingAnnotations.java b/compiler/src/main/java/dagger/internal/codegen/MultibindingAnnotations.java
new file mode 100644
index 000000000..b2ab200b7
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/MultibindingAnnotations.java
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.common.collect.ImmutableSet;
+import dagger.multibindings.ElementsIntoSet;
+import dagger.multibindings.IntoMap;
+import dagger.multibindings.IntoSet;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.ExecutableElement;
+
+import static com.google.auto.common.MoreElements.getAnnotationMirror;
+
+/**
+ * Utility methods related to processing {@link IntoSet}, {@link ElementsIntoSet}, and {@link
+ * IntoMap}.
+ */
+final class MultibindingAnnotations {
+  static ImmutableSet<AnnotationMirror> forMethod(ExecutableElement method) {
+    return ImmutableSet.<AnnotationMirror>builder()
+        .addAll(getAnnotationMirror(method, IntoSet.class).asSet())
+        .addAll(getAnnotationMirror(method, ElementsIntoSet.class).asSet())
+        .addAll(getAnnotationMirror(method, IntoMap.class).asSet())
+        .build();
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/MultibindingAnnotationsProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/MultibindingAnnotationsProcessingStep.java
new file mode 100644
index 000000000..108557e91
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/MultibindingAnnotationsProcessingStep.java
@@ -0,0 +1,77 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.common.BasicAnnotationProcessor.ProcessingStep;
+import com.google.common.base.Predicate;
+import com.google.common.base.Predicates;
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.SetMultimap;
+import dagger.Provides;
+import dagger.multibindings.ElementsIntoSet;
+import dagger.multibindings.IntoMap;
+import dagger.multibindings.IntoSet;
+import dagger.producers.Produces;
+import java.lang.annotation.Annotation;
+import java.util.Map.Entry;
+import java.util.Set;
+import javax.annotation.processing.Messager;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.Element;
+import javax.tools.Diagnostic.Kind;
+
+import static com.google.auto.common.MoreElements.getAnnotationMirror;
+import static dagger.internal.codegen.ErrorMessages.MULTIBINDING_ANNOTATION_NOT_ON_PROVIDES_OR_PRODUCES;
+import static dagger.internal.codegen.Util.hasAnnotationType;
+
+/**
+ * Processing step which verifies that {@link IntoSet @IntoSet}, {@link ElementsIntoSet
+ * @ElementsIntoSet} and {@link IntoMap @IntoMap} are not present on invalid elements.
+ */
+final class MultibindingAnnotationsProcessingStep implements ProcessingStep {
+
+  private final Messager messager;
+
+  MultibindingAnnotationsProcessingStep(Messager messager) {
+    this.messager = messager;
+  }
+
+  @Override
+  public Set<? extends Class<? extends Annotation>> annotations() {
+    return ImmutableSet.of(IntoSet.class, ElementsIntoSet.class, IntoMap.class);
+  }
+
+  @Override
+  public Set<Element> process(
+      SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
+    for (Entry<Class<? extends Annotation>, Element> entry : elementsByAnnotation.entries()) {
+      Element element = entry.getValue();
+      boolean onBindingMethod =
+          FluentIterable.from(element.getAnnotationMirrors()).anyMatch(providesOrProducesMethod());
+      if (!onBindingMethod) {
+        AnnotationMirror annotation = getAnnotationMirror(entry.getValue(), entry.getKey()).get();
+        messager.printMessage(
+            Kind.ERROR, MULTIBINDING_ANNOTATION_NOT_ON_PROVIDES_OR_PRODUCES, element, annotation);
+      }
+    }
+    return ImmutableSet.of();
+  }
+
+  private static Predicate<AnnotationMirror> providesOrProducesMethod() {
+    return Predicates.or(hasAnnotationType(Provides.class), hasAnnotationType(Produces.class));
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
index 6c15b50fb..bf1990792 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
@@ -29,8 +29,6 @@
 import com.squareup.javapoet.TypeName;
 import com.squareup.javapoet.TypeSpec;
 import dagger.producers.Producer;
-import dagger.producers.Produces;
-import dagger.producers.Produces.Type;
 import dagger.producers.monitoring.ProducerMonitor;
 import java.util.List;
 import javax.annotation.processing.Filer;
@@ -45,6 +43,7 @@
 import static dagger.internal.codegen.AnnotationSpecs.SUPPRESS_WARNINGS_UNCHECKED;
 import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
 import static dagger.internal.codegen.CodeBlocks.toCodeBlocks;
+import static dagger.internal.codegen.ContributionType.MAP;
 import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
 import static dagger.internal.codegen.SourceFiles.generatedClassNameForBinding;
 import static dagger.internal.codegen.TypeNames.ASYNC_FUNCTION;
@@ -90,7 +89,7 @@ ClassName nameGeneratedType(ProductionBinding binding) {
   @Override
   Optional<TypeSpec.Builder> write(ClassName generatedTypeName, ProductionBinding binding) {
     TypeMirror keyType =
-        binding.productionType().equals(Type.MAP)
+        binding.contributionType().equals(MAP)
             ? MapType.from(binding.key().type()).unwrappedValueType(Producer.class)
             : binding.key().type();
     TypeName providedTypeName = TypeName.get(keyType);
@@ -477,7 +476,7 @@ private CodeBlock getInvocationCodeBlock(
     codeBlocks.add(CodeBlocks.format("monitor.methodStarting();"));
 
     final CodeBlock valueCodeBlock;
-    if (binding.productionType().equals(Produces.Type.SET)) {
+    if (binding.contributionType().equals(ContributionType.SET)) {
       if (binding.bindingKind().equals(ContributionBinding.Kind.FUTURE_PRODUCTION)) {
         valueCodeBlock =
             CodeBlocks.format("$T.createFutureSingletonSet($L)", PRODUCERS, moduleCodeBlock);
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProducesMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/ProducesMethodValidator.java
index 6b05b6e6a..15b7a9619 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProducesMethodValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProducesMethodValidator.java
@@ -34,13 +34,11 @@
 import javax.lang.model.util.Types;
 
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
-import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_ABSTRACT;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_MUST_RETURN_A_VALUE;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_NOT_IN_MODULE;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_NOT_MAP_HAS_MAP_KEY;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_PRIVATE;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_SET_VALUES_RAW_SET;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_TYPE_PARAMETER;
@@ -52,6 +50,8 @@
 import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_SET_VALUES_RETURN_SET;
 import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_THROWS;
 import static dagger.internal.codegen.MapKeys.getMapKeys;
+import static dagger.internal.codegen.ProvidesMethodValidator.validateMapKey;
+import static dagger.internal.codegen.ProvidesMethodValidator.validateMultibindingSpecifiers;
 import static dagger.internal.codegen.Validation.validateMethodQualifiers;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.element.Modifier.PRIVATE;
@@ -84,9 +84,6 @@ private TypeElement getSetElement() {
     ValidationReport.Builder<ExecutableElement> builder =
         ValidationReport.about(producesMethodElement);
 
-    Produces producesAnnotation = producesMethodElement.getAnnotation(Produces.class);
-    checkArgument(producesAnnotation != null);
-
     Element enclosingElement = producesMethodElement.getEnclosingElement();
     if (!isAnnotationPresent(enclosingElement, ProducerModule.class)) {
       builder.addError(
@@ -131,17 +128,15 @@ private TypeElement getSetElement() {
       }
     }
 
-    // check mapkey is right
-    if (!producesAnnotation.type().equals(Produces.Type.MAP)
-        && !getMapKeys(producesMethodElement).isEmpty()) {
-      builder.addError(
-          formatErrorMessage(BINDING_METHOD_NOT_MAP_HAS_MAP_KEY), producesMethodElement);
-    }
+    ContributionType contributionType = ContributionType.fromBindingMethod(producesMethodElement);
+    validateMapKey(builder, producesMethodElement, contributionType, Produces.class);
+
+    validateMultibindingSpecifiers(builder, producesMethodElement, Produces.class);
 
     validateMethodQualifiers(builder, producesMethodElement);
 
-    switch (producesAnnotation.type()) {
-      case UNIQUE: // fall through
+    switch (contributionType) {
+      case UNIQUE:
       case SET:
         validateSingleReturnType(builder, returnType);
         break;
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
index 3cc8ceb83..554abf1e5 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
@@ -22,8 +22,6 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Sets;
 import com.google.common.util.concurrent.ListenableFuture;
-import dagger.Provides;
-import dagger.producers.Produces;
 import java.util.Set;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
@@ -56,11 +54,6 @@ public BindingType bindingType() {
     return Optional.absent();
   }
 
-  @Override
-  Provides.Type provisionType() {
-    return Provides.Type.valueOf(productionType().name());
-  }
-
   @Override
   Set<DependencyRequest> implicitDependencies() {
     // Similar optimizations to ContributionBinding.implicitDependencies().
@@ -73,9 +66,6 @@ public BindingType bindingType() {
     }
   }
 
-  /** Returns provision type that was used to bind the key. */
-  abstract Produces.Type productionType();
-
   /** Returns the list of types in the throws clause of the method. */
   abstract ImmutableList<? extends TypeMirror> thrownTypes();
 
@@ -100,8 +90,6 @@ public BindingType bindingType() {
     ProductionBinding forProducesMethod(
         ExecutableElement producesMethod, TypeElement contributedBy) {
       checkArgument(producesMethod.getKind().equals(METHOD));
-      Produces producesAnnotation = producesMethod.getAnnotation(Produces.class);
-      checkArgument(producesAnnotation != null);
       SourceElement sourceElement = SourceElement.forElement(producesMethod, contributedBy);
       Key key = keyFactory.forProducesMethod(sourceElement);
       ExecutableType resolvedMethod =
@@ -119,6 +107,7 @@ ProductionBinding forProducesMethod(
           ? Kind.FUTURE_PRODUCTION
           : Kind.IMMEDIATE;
       return new AutoValue_ProductionBinding(
+          ContributionType.fromBindingMethod(producesMethod),
           sourceElement,
           key,
           dependencies,
@@ -126,7 +115,6 @@ ProductionBinding forProducesMethod(
           Optional.<DeclaredType>absent(), // TODO(beder): Add nullability checking with Java 8.
           Optional.<DependencyRequest>absent(),
           kind,
-          producesAnnotation.type(),
           ImmutableList.copyOf(producesMethod.getThrownTypes()),
           Optional.of(executorRequest),
           Optional.of(monitorRequest));
@@ -149,6 +137,7 @@ ProductionBinding syntheticMapOfValuesOrProducedBinding(
           dependencyRequestFactory.forImplicitMapBinding(
               requestForMapOfValuesOrProduced, mapOfProducersKey.get());
       return new AutoValue_ProductionBinding(
+          ContributionType.UNIQUE,
           SourceElement.forElement(requestForMapOfProducers.requestElement()),
           requestForMapOfValuesOrProduced.key(),
           ImmutableSet.of(requestForMapOfProducers),
@@ -156,7 +145,6 @@ ProductionBinding syntheticMapOfValuesOrProducedBinding(
           Optional.<DeclaredType>absent(),
           Optional.<DependencyRequest>absent(),
           Kind.SYNTHETIC_MAP,
-          Produces.Type.UNIQUE,
           ImmutableList.<TypeMirror>of(),
           Optional.<DependencyRequest>absent(),
           Optional.<DependencyRequest>absent());
@@ -171,6 +159,7 @@ ProductionBinding syntheticMapOfValuesOrProducedBinding(
     ProductionBinding syntheticMultibinding(
         final DependencyRequest request, Iterable<ContributionBinding> multibindingContributions) {
       return new AutoValue_ProductionBinding(
+          ContributionType.UNIQUE,
           SourceElement.forElement(request.requestElement()),
           request.key(),
           dependencyRequestFactory.forMultibindingContributions(request, multibindingContributions),
@@ -178,7 +167,6 @@ ProductionBinding syntheticMultibinding(
           Optional.<DeclaredType>absent(),
           Optional.<DependencyRequest>absent(),
           Kind.forMultibindingRequest(request),
-          Produces.Type.UNIQUE,
           ImmutableList.<TypeMirror>of(),
           Optional.<DependencyRequest>absent(),
           Optional.<DependencyRequest>absent());
@@ -190,6 +178,7 @@ ProductionBinding forComponentMethod(ExecutableElement componentMethod) {
       checkArgument(componentMethod.getParameters().isEmpty());
       checkArgument(MoreTypes.isTypeOf(ListenableFuture.class, componentMethod.getReturnType()));
       return new AutoValue_ProductionBinding(
+          ContributionType.UNIQUE,
           SourceElement.forElement(componentMethod),
           keyFactory.forProductionComponentMethod(componentMethod),
           ImmutableSet.<DependencyRequest>of(),
@@ -197,7 +186,6 @@ ProductionBinding forComponentMethod(ExecutableElement componentMethod) {
           Optional.<DeclaredType>absent(),
           Optional.<DependencyRequest>absent(),
           Kind.COMPONENT_PRODUCTION,
-          Produces.Type.UNIQUE,
           ImmutableList.copyOf(componentMethod.getThrownTypes()),
           Optional.<DependencyRequest>absent(),
           Optional.<DependencyRequest>absent());
@@ -206,6 +194,7 @@ ProductionBinding forComponentMethod(ExecutableElement componentMethod) {
     ProductionBinding delegate(
         DelegateDeclaration delegateDeclaration, ProductionBinding delegateBinding) {
       return new AutoValue_ProductionBinding(
+          delegateBinding.contributionType(),
           delegateDeclaration.sourceElement(),
           delegateDeclaration.key(),
           ImmutableSet.of(delegateDeclaration.delegateRequest()),
@@ -213,7 +202,6 @@ ProductionBinding delegate(
           delegateBinding.nullableType(),
           Optional.<DependencyRequest>absent(),
           Kind.SYNTHETIC_DELEGATE_BINDING,
-          delegateBinding.productionType(),
           ImmutableList.<TypeMirror>of(),
           Optional.<DependencyRequest>absent(),
           Optional.<DependencyRequest>absent());
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java
index 785f43331..c435c3427 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java
@@ -19,6 +19,7 @@
 import com.google.common.collect.Iterables;
 import dagger.Module;
 import dagger.Provides;
+import java.lang.annotation.Annotation;
 import java.util.Set;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
@@ -32,8 +33,8 @@
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 
+import static com.google.auto.common.MoreElements.getAnnotationMirror;
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
-import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_ABSTRACT;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES;
@@ -45,6 +46,8 @@
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_TYPE_PARAMETER;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_WITH_MULTIPLE_MAP_KEY;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_WITH_NO_MAP_KEY;
+import static dagger.internal.codegen.ErrorMessages.MULTIBINDING_ANNOTATION_CONFLICTS_WITH_BINDING_ANNOTATION_ENUM;
+import static dagger.internal.codegen.ErrorMessages.MULTIPLE_MULTIBINDING_ANNOTATIONS_ON_METHOD;
 import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_SET_VALUES_RETURN_SET;
 import static dagger.internal.codegen.ErrorMessages.provisionMayNotDependOnProducerType;
 import static dagger.internal.codegen.MapKeys.getMapKeys;
@@ -79,11 +82,6 @@ private TypeElement getSetElement() {
     ValidationReport.Builder<ExecutableElement> builder =
         ValidationReport.about(providesMethodElement);
 
-    /* this cast isn't actually guaranteed to be safe, but since we've already run superficial
-     * validation, it shouldn't ever fail */
-    Provides providesAnnotation = providesMethodElement.getAnnotation(Provides.class);
-    checkArgument(providesAnnotation != null);
-
     Element enclosingElement = providesMethodElement.getEnclosingElement();
     if (!isAnnotationPresent(enclosingElement, Module.class)) {
       builder.addError(
@@ -117,16 +115,14 @@ private TypeElement getSetElement() {
       }
     }
 
-    // check mapkey is right
-    if (!providesAnnotation.type().equals(Provides.Type.MAP)
-        && !getMapKeys(providesMethodElement).isEmpty()) {
-      builder.addError(
-          formatErrorMessage(BINDING_METHOD_NOT_MAP_HAS_MAP_KEY), providesMethodElement);
-    }
+    ContributionType contributionType = ContributionType.fromBindingMethod(providesMethodElement);
+
+    validateMapKey(builder, providesMethodElement, contributionType, Provides.class);
 
     validateMethodQualifiers(builder, providesMethodElement);
 
-    switch (providesAnnotation.type()) {
+    validateMultibindingSpecifiers(builder, providesMethodElement, Provides.class);
+    switch (contributionType) {
       case UNIQUE:
         /* Validate that a unique binding is not attempting to bind a framework type. This
          * validation is only appropriate for unique bindings because multibindings may collect
@@ -182,11 +178,58 @@ private TypeElement getSetElement() {
     return builder.build();
   }
 
+  /** Validate that methods for map multibindings have a {@code @MapKey} annotation. */
+  static void validateMapKey(
+      ValidationReport.Builder<ExecutableElement> builder,
+      ExecutableElement method,
+      ContributionType contributionType,
+      Class<? extends Annotation> bindingAnnotation) {
+    if (!contributionType.equals(ContributionType.MAP) && !getMapKeys(method).isEmpty()) {
+      builder.addError(
+          String.format(BINDING_METHOD_NOT_MAP_HAS_MAP_KEY, bindingAnnotation.getSimpleName()),
+          method);
+    }
+  }
+
+  /**
+   * Validate that at most one multibinding annotation is used, and not in conflict with {@link
+   * Provides#type()}.
+   */
+  static void validateMultibindingSpecifiers(
+      ValidationReport.Builder<ExecutableElement> builder,
+      ExecutableElement method,
+      Class<? extends Annotation> bindingAnnotation) {
+    ImmutableSet<AnnotationMirror> multibindingAnnotations =
+        MultibindingAnnotations.forMethod(method);
+    if (multibindingAnnotations.size() > 1) {
+      for (AnnotationMirror annotation : multibindingAnnotations) {
+        builder.addError(
+            String.format(
+                MULTIPLE_MULTIBINDING_ANNOTATIONS_ON_METHOD, bindingAnnotation.getSimpleName()),
+            method,
+            annotation);
+      }
+    }
+
+    AnnotationMirror bindingAnnotationMirror = getAnnotationMirror(method, bindingAnnotation).get();
+    boolean usesProvidesType = false;
+    for (ExecutableElement member : bindingAnnotationMirror.getElementValues().keySet()) {
+      usesProvidesType |= member.getSimpleName().contentEquals("type");
+    }
+    if (usesProvidesType && !multibindingAnnotations.isEmpty()) {
+      builder.addError(
+          String.format(
+              MULTIBINDING_ANNOTATION_CONFLICTS_WITH_BINDING_ANNOTATION_ENUM,
+              bindingAnnotation.getSimpleName()),
+          method);
+    }
+  }
+
   private String formatErrorMessage(String msg) {
     return String.format(msg, Provides.class.getSimpleName());
   }
 
-  private String formatModuleErrorMessage(String msg) {
+  private static String formatModuleErrorMessage(String msg) {
     return String.format(msg, Provides.class.getSimpleName(), Module.class.getSimpleName());
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
index 7e935d30f..80b6d8230 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
@@ -21,7 +21,6 @@
 import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Sets;
-import dagger.Provides;
 import javax.inject.Inject;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ElementKind;
@@ -118,6 +117,7 @@ ProvisionBinding forInjectConstructor(ExecutableElement constructorElement,
           MoreElements.asType(constructorElement.getEnclosingElement());
 
       return new AutoValue_ProvisionBinding(
+          ContributionType.UNIQUE,
           SourceElement.forElement(constructorElement),
           key,
           dependencies,
@@ -125,7 +125,6 @@ ProvisionBinding forInjectConstructor(ExecutableElement constructorElement,
           Optional.<DeclaredType>absent(),
           membersInjectionRequest,
           Kind.INJECTION,
-          Provides.Type.UNIQUE,
           hasNonDefaultTypeParameters(bindingTypeElement, key.type(), types)
               ? Optional.of(forInjectConstructor(constructorElement, Optional.<TypeMirror>absent()))
               : Optional.<ProvisionBinding>absent(),
@@ -153,8 +152,6 @@ ProvisionBinding forInjectConstructor(ExecutableElement constructorElement,
     ProvisionBinding forProvidesMethod(
         ExecutableElement providesMethod, TypeElement contributedBy) {
       checkArgument(providesMethod.getKind().equals(METHOD));
-      Provides providesAnnotation = providesMethod.getAnnotation(Provides.class);
-      checkArgument(providesAnnotation != null);
       SourceElement sourceElement = SourceElement.forElement(providesMethod, contributedBy);
       ExecutableType resolvedMethod =
           MoreTypes.asExecutable(sourceElement.asMemberOfContributingType(types));
@@ -166,6 +163,7 @@ ProvisionBinding forProvidesMethod(
               resolvedMethod.getParameterTypes());
       Optional<Scope> scope = Scope.uniqueScopeOf(providesMethod);
       return new AutoValue_ProvisionBinding(
+          ContributionType.fromBindingMethod(providesMethod),
           sourceElement,
           key,
           dependencies,
@@ -173,7 +171,6 @@ ProvisionBinding forProvidesMethod(
           ConfigurationAnnotations.getNullableType(providesMethod),
           Optional.<DependencyRequest>absent(),
           Kind.PROVISION,
-          providesAnnotation.type(),
           Optional.<ProvisionBinding>absent(),
           scope);
     }
@@ -193,6 +190,7 @@ ProvisionBinding syntheticMapOfValuesBinding(DependencyRequest requestForMapOfVa
           dependencyRequestFactory.forImplicitMapBinding(
               requestForMapOfValues, mapOfProvidersKey.get());
       return new AutoValue_ProvisionBinding(
+          ContributionType.UNIQUE,
           SourceElement.forElement(requestForMapOfProviders.requestElement()),
           requestForMapOfValues.key(),
           ImmutableSet.of(requestForMapOfProviders),
@@ -200,7 +198,6 @@ ProvisionBinding syntheticMapOfValuesBinding(DependencyRequest requestForMapOfVa
           Optional.<DeclaredType>absent(),
           Optional.<DependencyRequest>absent(),
           Kind.SYNTHETIC_MAP,
-          Provides.Type.UNIQUE,
           Optional.<ProvisionBinding>absent(),
           Scope.uniqueScopeOf(requestForMapOfProviders.requestElement()));
     }
@@ -214,6 +211,7 @@ ProvisionBinding syntheticMapOfValuesBinding(DependencyRequest requestForMapOfVa
     ProvisionBinding syntheticMultibinding(
         final DependencyRequest request, Iterable<ContributionBinding> multibindingContributions) {
       return new AutoValue_ProvisionBinding(
+          ContributionType.UNIQUE,
           SourceElement.forElement(request.requestElement()),
           request.key(),
           dependencyRequestFactory.forMultibindingContributions(request, multibindingContributions),
@@ -221,7 +219,6 @@ ProvisionBinding syntheticMultibinding(
           Optional.<DeclaredType>absent(),
           Optional.<DependencyRequest>absent(),
           Kind.forMultibindingRequest(request),
-          Provides.Type.UNIQUE,
           Optional.<ProvisionBinding>absent(),
           Scope.uniqueScopeOf(request.requestElement()));
     }
@@ -229,6 +226,7 @@ ProvisionBinding syntheticMultibinding(
     ProvisionBinding forComponent(TypeElement componentDefinitionType) {
       checkNotNull(componentDefinitionType);
       return new AutoValue_ProvisionBinding(
+          ContributionType.UNIQUE,
           SourceElement.forElement(componentDefinitionType),
           keyFactory.forComponent(componentDefinitionType.asType()),
           ImmutableSet.<DependencyRequest>of(),
@@ -236,7 +234,6 @@ ProvisionBinding forComponent(TypeElement componentDefinitionType) {
           Optional.<DeclaredType>absent(),
           Optional.<DependencyRequest>absent(),
           Kind.COMPONENT,
-          Provides.Type.UNIQUE,
           Optional.<ProvisionBinding>absent(),
           Optional.<Scope>absent());
     }
@@ -247,6 +244,7 @@ ProvisionBinding forComponentMethod(ExecutableElement componentMethod) {
       checkArgument(componentMethod.getParameters().isEmpty());
       Optional<Scope> scope = Scope.uniqueScopeOf(componentMethod);
       return new AutoValue_ProvisionBinding(
+          ContributionType.UNIQUE,
           SourceElement.forElement(componentMethod),
           keyFactory.forComponentMethod(componentMethod),
           ImmutableSet.<DependencyRequest>of(),
@@ -254,7 +252,6 @@ ProvisionBinding forComponentMethod(ExecutableElement componentMethod) {
           ConfigurationAnnotations.getNullableType(componentMethod),
           Optional.<DependencyRequest>absent(),
           Kind.COMPONENT_PROVISION,
-          Provides.Type.UNIQUE,
           Optional.<ProvisionBinding>absent(),
           scope);
     }
@@ -266,6 +263,7 @@ ProvisionBinding forSubcomponentBuilderMethod(
       checkArgument(subcomponentBuilderMethod.getParameters().isEmpty());
       DeclaredType declaredContainer = asDeclared(contributedBy.asType());
       return new AutoValue_ProvisionBinding(
+          ContributionType.UNIQUE,
           SourceElement.forElement(subcomponentBuilderMethod, contributedBy),
           keyFactory.forSubcomponentBuilderMethod(subcomponentBuilderMethod, declaredContainer),
           ImmutableSet.<DependencyRequest>of(),
@@ -273,7 +271,6 @@ ProvisionBinding forSubcomponentBuilderMethod(
           Optional.<DeclaredType>absent(),
           Optional.<DependencyRequest>absent(),
           Kind.SUBCOMPONENT_BUILDER,
-          Provides.Type.UNIQUE,
           Optional.<ProvisionBinding>absent(),
           Optional.<Scope>absent());
     }
@@ -281,6 +278,7 @@ ProvisionBinding forSubcomponentBuilderMethod(
     ProvisionBinding delegate(
         DelegateDeclaration delegateDeclaration, ProvisionBinding delegate) {
       return new AutoValue_ProvisionBinding(
+          delegate.contributionType(),
           delegateDeclaration.sourceElement(),
           delegateDeclaration.key(),
           ImmutableSet.of(delegateDeclaration.delegateRequest()),
@@ -288,7 +286,6 @@ ProvisionBinding delegate(
           delegate.nullableType(),
           Optional.<DependencyRequest>absent(),
           Kind.SYNTHETIC_DELEGATE_BINDING,
-          delegate.provisionType(),
           Optional.<ProvisionBinding>absent(),
           Scope.uniqueScopeOf(delegateDeclaration.sourceElement().element()));
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/Util.java b/compiler/src/main/java/dagger/internal/codegen/Util.java
index 1bcda53ca..e7d9685e1 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Util.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Util.java
@@ -17,11 +17,15 @@
 package dagger.internal.codegen;
 
 import com.google.auto.common.MoreElements;
+import com.google.auto.common.MoreTypes;
+import com.google.common.base.Predicate;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableSet;
 import dagger.Binds;
 import dagger.Provides;
 import dagger.producers.Produces;
+import java.lang.annotation.Annotation;
+import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
@@ -125,5 +129,16 @@ private static boolean requiresEnclosingInstance(TypeElement typeElement) {
         .toSet();
   }
 
+  // TODO(ronshapiro): add into auto/common/AnnotationMirrors.java
+  static Predicate<AnnotationMirror> hasAnnotationType(
+      final Class<? extends Annotation> annotation) {
+    return new Predicate<AnnotationMirror>() {
+      @Override
+      public boolean apply(AnnotationMirror input) {
+        return MoreTypes.isTypeOf(annotation, input.getAnnotationType());
+      }
+    };
+  }
+
   private Util() {}
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
index a93b7b1e4..3e0d2b003 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
@@ -762,18 +762,17 @@ public void subcomponentOmitsInheritedBindings() {
             "",
             "import dagger.Module;",
             "import dagger.Provides;",
+            "import dagger.multibindings.IntoSet;",
+            "import dagger.multibindings.IntoMap;",
             "import dagger.multibindings.StringKey;",
             "",
-            "import static dagger.Provides.Type.SET;",
-            "import static dagger.Provides.Type.MAP;",
-            "",
             "@Module",
             "class ParentModule {",
-            "  @Provides(type = SET) static Object parentObject() {",
+            "  @Provides @IntoSet static Object parentObject() {",
             "    return \"parent object\";",
             "  }",
             "",
-            "  @Provides(type = MAP) @StringKey(\"parent key\") Object parentKeyObject() {",
+            "  @Provides @IntoMap @StringKey(\"parent key\") Object parentKeyObject() {",
             "    return \"parent value\";",
             "  }",
             "}");
@@ -930,24 +929,24 @@ public void subcomponentOmitsInheritedBindings() {
         "",
         "import dagger.Module;",
         "import dagger.Provides;",
+        "import dagger.multibindings.ElementsIntoSet;",
         "import java.util.Collections;",
         "import java.util.Set;",
         "",
         "@Module",
         "final class EmptySetModule {",
-        "  @Provides(type = SET_VALUES) Set<String> emptySet() { return Collections.emptySet(); }",
+        "  @Provides @ElementsIntoSet Set<String> emptySet() { return Collections.emptySet(); }",
         "}");
     JavaFileObject setModuleFile = JavaFileObjects.forSourceLines("test.SetModule",
         "package test;",
         "",
-        "import static dagger.Provides.Type.SET;",
-        "",
         "import dagger.Module;",
         "import dagger.Provides;",
+        "import dagger.multibindings.IntoSet;",
         "",
         "@Module",
         "final class SetModule {",
-        "  @Provides(type = SET) String string() { return \"\"; }",
+        "  @Provides @IntoSet String string() { return \"\"; }",
         "}");
     JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
         "package test;",
diff --git a/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java b/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
index e999a3414..0362ef195 100644
--- a/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
@@ -318,6 +318,7 @@ public void cyclicDependencyNotBrokenByMapBinding() {
             "import dagger.MapKey;",
             "import dagger.Module;",
             "import dagger.Provides;",
+            "import dagger.multibindings.IntoMap;",
             "import java.util.Map;",
             "import javax.inject.Inject;",
             "",
@@ -341,7 +342,7 @@ public void cyclicDependencyNotBrokenByMapBinding() {
             "",
             "  @Module",
             "  static class CModule {",
-            "    @Provides(type = Provides.Type.MAP)",
+            "    @Provides @IntoMap",
             "    @StringKey(\"C\")",
             "    static C c(C c) {",
             "      return c;",
@@ -375,7 +376,7 @@ public void cyclicDependencyNotBrokenByMapBinding() {
         .failsToCompile()
         .withErrorContaining(expectedError)
         .in(component)
-        .onLine(25);
+        .onLine(26);
   }
 
   @Test
@@ -388,6 +389,7 @@ public void cyclicDependencyWithSetBinding() {
             "import dagger.Component;",
             "import dagger.Module;",
             "import dagger.Provides;",
+            "import dagger.multibindings.IntoSet;",
             "import java.util.Set;",
             "import javax.inject.Inject;",
             "",
@@ -411,7 +413,7 @@ public void cyclicDependencyWithSetBinding() {
             "",
             "  @Module",
             "  static class CModule {",
-            "    @Provides(type = Provides.Type.SET)",
+            "    @Provides @IntoSet",
             "    static C c(C c) {",
             "      return c;",
             "    }",
@@ -439,7 +441,7 @@ public void cyclicDependencyWithSetBinding() {
         .failsToCompile()
         .withErrorContaining(expectedError)
         .in(component)
-        .onLine(24);
+        .onLine(25);
   }
 
   @Test
@@ -595,15 +597,14 @@ public void falsePositiveCyclicDependencyIndirectionDetected() {
         "import dagger.Module;",
         "import dagger.Provides;",
         "import dagger.MapKey;",
+        "import dagger.multibindings.IntoMap;",
+        "import dagger.multibindings.IntoSet;",
         "import java.util.HashMap;",
         "import java.util.HashSet;",
         "import java.util.Map;",
         "import java.util.Set;",
         "",
         "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
-        "import static dagger.Provides.Type.MAP;",
-        "import static dagger.Provides.Type.SET;",
-        "",
         "final class Outer {",
         "  @MapKey(unwrapValue = true)",
         "  @interface StringKey {",
@@ -612,11 +613,11 @@ public void falsePositiveCyclicDependencyIndirectionDetected() {
         "",
         "  @Module",
         "  static class TestModule1 {",
-        "    @Provides(type = MAP)",
+        "    @Provides @IntoMap",
         "    @StringKey(\"foo\")",
         "    String stringMapEntry() { return \"\"; }",
         "",
-        "    @Provides(type = SET) String stringSetElement() { return \"\"; }",
+        "    @Provides @IntoSet String stringSetElement() { return \"\"; }",
         "  }",
         "",
         "  @Module",
@@ -638,7 +639,8 @@ public void falsePositiveCyclicDependencyIndirectionDetected() {
     String expectedSetError =
         "java.util.Set<java.lang.String> has incompatible bindings or declarations:\n"
             + "      Set bindings and declarations:\n"
-            + "          @Provides(type=SET) String test.Outer.TestModule1.stringSetElement()\n"
+            + "          @Provides @dagger.multibindings.IntoSet String "
+            + "test.Outer.TestModule1.stringSetElement()\n"
             + "      Unique bindings and declarations:\n"
             + "          @Provides Set<String> test.Outer.TestModule2.stringSet()";
 
@@ -646,7 +648,8 @@ public void falsePositiveCyclicDependencyIndirectionDetected() {
         "java.util.Map<java.lang.String,java.lang.String> has incompatible bindings "
             + "or declarations:\n"
             + "      Map bindings and declarations:\n"
-            + "          @Provides(type=MAP) @test.Outer.StringKey(\"foo\") String"
+            + "          @Provides @dagger.multibindings.IntoMap "
+            + "@test.Outer.StringKey(\"foo\") String"
             + " test.Outer.TestModule1.stringMapEntry()\n"
             + "      Unique bindings and declarations:\n"
             + "          @Provides Map<String,String> test.Outer.TestModule2.stringMap()";
@@ -657,11 +660,11 @@ public void falsePositiveCyclicDependencyIndirectionDetected() {
         .failsToCompile()
         .withErrorContaining(expectedSetError)
         .in(component)
-        .onLine(43)
+        .onLine(42)
         .and()
         .withErrorContaining(expectedMapError)
         .in(component)
-        .onLine(44);
+        .onLine(43);
   }
 
   @Test
@@ -681,8 +684,6 @@ public void duplicateExplicitBindings_UniqueBindingAndMultibindingDeclaration()
             "import java.util.Set;",
             "",
             "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
-            "import static dagger.Provides.Type.MAP;",
-            "import static dagger.Provides.Type.SET;",
             "",
             "final class Outer {",
             "  @Module",
@@ -731,11 +732,11 @@ public void duplicateExplicitBindings_UniqueBindingAndMultibindingDeclaration()
         .failsToCompile()
         .withErrorContaining(expectedSetError)
         .in(component)
-        .onLine(37)
+        .onLine(35)
         .and()
         .withErrorContaining(expectedMapError)
         .in(component)
-        .onLine(38);
+        .onLine(36);
   }
   
   @Test public void duplicateBindings_TruncateAfterLimit() {
diff --git a/compiler/src/test/java/dagger/internal/codegen/KeyTest.java b/compiler/src/test/java/dagger/internal/codegen/KeyTest.java
index 0a5814765..8635fc713 100644
--- a/compiler/src/test/java/dagger/internal/codegen/KeyTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/KeyTest.java
@@ -23,6 +23,8 @@
 import com.google.testing.compile.CompilationRule;
 import dagger.Module;
 import dagger.Provides;
+import dagger.multibindings.IntoSet;
+import dagger.multibindings.ElementsIntoSet;
 import dagger.producers.ProducerModule;
 import dagger.producers.Produces;
 import java.util.Set;
@@ -43,8 +45,6 @@
 import org.junit.runners.JUnit4;
 
 import static com.google.common.truth.Truth.assertThat;
-import static dagger.Provides.Type.SET;
-import static dagger.Provides.Type.SET_VALUES;
 
 /**
  * Tests {@link Key}.
@@ -178,11 +178,11 @@ String provideQualifiedString() {
 
   @Module
   static final class SetProvidesMethodsModule {
-    @Provides(type = SET) String provideString() {
+    @Provides @IntoSet String provideString() {
       throw new UnsupportedOperationException();
     }
 
-    @Provides(type = SET_VALUES) Set<String> provideStrings() {
+    @Provides @ElementsIntoSet Set<String> provideStrings() {
       throw new UnsupportedOperationException();
     }
   }
@@ -270,19 +270,19 @@ String provideQualifiedString() {
 
   @ProducerModule
   static final class SetProducesMethodsModule {
-    @Produces(type = Produces.Type.SET) String produceString() {
+    @Produces @IntoSet String produceString() {
       throw new UnsupportedOperationException();
     }
 
-    @Produces(type = Produces.Type.SET) ListenableFuture<String> produceFutureString() {
+    @Produces @IntoSet ListenableFuture<String> produceFutureString() {
       throw new UnsupportedOperationException();
     }
 
-    @Produces(type = Produces.Type.SET_VALUES) Set<String> produceStrings() {
+    @Produces @ElementsIntoSet Set<String> produceStrings() {
       throw new UnsupportedOperationException();
     }
 
-    @Produces(type = Produces.Type.SET_VALUES)
+    @Produces @ElementsIntoSet
     ListenableFuture<Set<String>> produceFutureStrings() {
       throw new UnsupportedOperationException();
     }
diff --git a/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java
index a295f5098..df33d2a87 100644
--- a/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java
@@ -37,14 +37,13 @@ public void mapBindingsWithEnumKey() {
             .forSourceLines("test.MapModuleOne",
                 "package test;",
                 "",
-                "import static dagger.Provides.Type.MAP;",
-                "",
                 "import dagger.Module;",
                 "import dagger.Provides;",
+                "import dagger.multibindings.IntoMap;",
                 "",
                 "@Module",
                 "final class MapModuleOne {",
-                "  @Provides(type = MAP) @PathKey(PathEnum.ADMIN) Handler provideAdminHandler() {",
+                "  @Provides @IntoMap @PathKey(PathEnum.ADMIN) Handler provideAdminHandler() {",
                 "    return new AdminHandler();",
                 "  }",
                 "}");
@@ -53,14 +52,13 @@ public void mapBindingsWithEnumKey() {
             .forSourceLines("test.MapModuleTwo",
                 "package test;",
                 "",
-                "import static dagger.Provides.Type.MAP;",
-                "",
                 "import dagger.Module;",
                 "import dagger.Provides;",
+                "import dagger.multibindings.IntoMap;",
                 "",
                 "@Module",
                 "final class MapModuleTwo {",
-                "  @Provides(type = MAP) @PathKey(PathEnum.LOGIN) Handler provideLoginHandler() {",
+                "  @Provides @IntoMap @PathKey(PathEnum.LOGIN) Handler provideLoginHandler() {",
                 "    return new LoginHandler();",
                 "  }",
                 "}");
@@ -209,15 +207,14 @@ public void mapBindingsWithStringKey() {
             .forSourceLines("test.MapModuleOne",
                 "package test;",
                 "",
-                "import static dagger.Provides.Type.MAP;",
-                "",
                 "import dagger.Module;",
                 "import dagger.Provides;",
                 "import dagger.multibindings.StringKey;",
+                "import dagger.multibindings.IntoMap;",
                 "",
                 "@Module",
                 "final class MapModuleOne {",
-                "  @Provides(type = MAP) @StringKey(\"Admin\") Handler provideAdminHandler() {",
+                "  @Provides @IntoMap @StringKey(\"Admin\") Handler provideAdminHandler() {",
                 "    return new AdminHandler();",
                 "  }",
                 "}");
@@ -226,15 +223,14 @@ public void mapBindingsWithStringKey() {
             .forSourceLines("test.MapModuleTwo",
                 "package test;",
                 "",
-                "import static dagger.Provides.Type.MAP;",
-                "",
                 "import dagger.Module;",
                 "import dagger.Provides;",
+                "import dagger.multibindings.IntoMap;",
                 "import dagger.multibindings.StringKey;",
                 "",
                 "@Module",
                 "final class MapModuleTwo {",
-                "  @Provides(type = MAP) @StringKey(\"Login\") Handler provideLoginHandler() {",
+                "  @Provides @IntoMap @StringKey(\"Login\") Handler provideLoginHandler() {",
                 "    return new LoginHandler();",
                 "  }",
                 "}");
@@ -362,14 +358,13 @@ public void mapBindingsWithWrappedKey() {
             .forSourceLines("test.MapModuleOne",
                 "package test;",
                 "",
-                "import static dagger.Provides.Type.MAP;",
-                "",
                 "import dagger.Module;",
                 "import dagger.Provides;",
+                "import dagger.multibindings.IntoMap;",
                 "",
                 "@Module",
                 "final class MapModuleOne {",
-                "  @Provides(type = MAP)",
+                "  @Provides @IntoMap",
                 "  @WrappedClassKey(Integer.class) Handler provideAdminHandler() {",
                 "    return new AdminHandler();",
                 "  }",
@@ -379,14 +374,13 @@ public void mapBindingsWithWrappedKey() {
             .forSourceLines("test.MapModuleTwo",
                 "package test;",
                 "",
-                "import static dagger.Provides.Type.MAP;",
-                "",
                 "import dagger.Module;",
                 "import dagger.Provides;",
+                "import dagger.multibindings.IntoMap;",
                 "",
                 "@Module",
                 "final class MapModuleTwo {",
-                "  @Provides(type = MAP)",
+                "  @Provides @IntoMap",
                 "  @WrappedClassKey(Long.class) Handler provideLoginHandler() {",
                 "    return new LoginHandler();",
                 "  }",
@@ -527,28 +521,26 @@ public void mapBindingsWithNonProviderValue() {
     JavaFileObject mapModuleOneFile = JavaFileObjects.forSourceLines("test.MapModuleOne",
         "package test;",
         "",
-        "import static dagger.Provides.Type.MAP;",
-        "",
         "import dagger.Module;",
         "import dagger.Provides;",
+        "import dagger.multibindings.IntoMap;",
         "",
         "@Module",
         "final class MapModuleOne {",
-        "  @Provides(type = MAP) @PathKey(PathEnum.ADMIN) Handler provideAdminHandler() {",
+        "  @Provides @IntoMap @PathKey(PathEnum.ADMIN) Handler provideAdminHandler() {",
         "    return new AdminHandler();",
         "  }",
         "}");
     JavaFileObject mapModuleTwoFile = JavaFileObjects.forSourceLines("test.MapModuleTwo",
         "package test;",
         "",
-        "import static dagger.Provides.Type.MAP;",
-        "",
         "import dagger.Module;",
         "import dagger.Provides;",
+        "import dagger.multibindings.IntoMap;",
         "",
         "@Module",
         "final class MapModuleTwo {",
-        "  @Provides(type = MAP) @PathKey(PathEnum.LOGIN) Handler provideLoginHandler() {",
+        "  @Provides @IntoMap @PathKey(PathEnum.LOGIN) Handler provideLoginHandler() {",
         "    return new LoginHandler();",
         "  }",
         "}");
@@ -789,16 +781,15 @@ public void mapBindingsWithDuplicateKeys() {
             "import dagger.Module;",
             "import dagger.Provides;",
             "import dagger.multibindings.StringKey;",
-            "",
-            "import static dagger.Provides.Type.MAP;",
+            "import dagger.multibindings.IntoMap;",
             "",
             "@Module",
             "final class MapModule {",
-            "  @Provides(type = MAP) @StringKey(\"AKey\") Object provideObjectForAKey() {",
+            "  @Provides @IntoMap @StringKey(\"AKey\") Object provideObjectForAKey() {",
             "    return \"one\";",
             "  }",
             "",
-            "  @Provides(type = MAP) @StringKey(\"AKey\") Object provideObjectForAKeyAgain() {",
+            "  @Provides @IntoMap @StringKey(\"AKey\") Object provideObjectForAKeyAgain() {",
             "    return \"one again\";",
             "  }",
             "}");
@@ -838,16 +829,15 @@ public void mapBindingsWithInconsistentKeyAnnotations() {
             "import dagger.Module;",
             "import dagger.Provides;",
             "import dagger.multibindings.StringKey;",
-            "",
-            "import static dagger.Provides.Type.MAP;",
+            "import dagger.multibindings.IntoMap;",
             "",
             "@Module",
             "final class MapModule {",
-            "  @Provides(type = MAP) @StringKey(\"AKey\") Object provideObjectForAKey() {",
+            "  @Provides @IntoMap @StringKey(\"AKey\") Object provideObjectForAKey() {",
             "    return \"one\";",
             "  }",
             "",
-            "  @Provides(type = MAP) @StringKeyTwo(\"BKey\") Object provideObjectForBKey() {",
+            "  @Provides @IntoMap @StringKeyTwo(\"BKey\") Object provideObjectForBKey() {",
             "    return \"two\";",
             "  }",
             "}");
diff --git a/compiler/src/test/java/dagger/internal/codegen/MapKeyProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/MapKeyProcessorTest.java
index 1fbd7fd11..bd1cc483f 100644
--- a/compiler/src/test/java/dagger/internal/codegen/MapKeyProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/MapKeyProcessorTest.java
@@ -130,15 +130,16 @@ public void mapKeyComponentFileWithDisorderedKeyField() {
     JavaFileObject mapModuleOneFile = JavaFileObjects.forSourceLines("test.MapModuleOne",
         "package test;",
         "",
-        "import static dagger.Provides.Type.MAP;",
-        "",
         "import dagger.Module;",
         "import dagger.Provides;",
+        "import dagger.multibindings.IntoMap;",
         "",
         "@Module",
         "final class MapModuleOne {",
-        "  @Provides(type = MAP) @PathKey(relativePath = \"AdminPath\", value = PathEnum.ADMIN)",
-        "      Handler provideAdminHandler() {",
+        "  @Provides",
+        "  @IntoMap",
+        "  @PathKey(relativePath = \"AdminPath\", value = PathEnum.ADMIN)",
+        "  Handler provideAdminHandler() {",
         "    return new AdminHandler();",
         "  }",
         "}");
@@ -149,11 +150,14 @@ public void mapKeyComponentFileWithDisorderedKeyField() {
         "",
         "import dagger.Module;",
         "import dagger.Provides;",
+        "import dagger.multibindings.IntoMap;",
         "",
         "@Module",
         "final class MapModuleTwo {",
-        "  @Provides(type = MAP) @PathKey(value = PathEnum.LOGIN, relativePath = \"LoginPath\")",
-        "      Handler provideLoginHandler() {",
+        "  @Provides",
+        "  @IntoMap",
+        "  @PathKey(value = PathEnum.LOGIN, relativePath = \"LoginPath\")",
+        "  Handler provideLoginHandler() {",
         "    return new LoginHandler();",
         "  }",
         "}");
@@ -304,29 +308,31 @@ public void mapKeyComponentFileWithDefaultField() {
     JavaFileObject mapModuleOneFile = JavaFileObjects.forSourceLines("test.MapModuleOne",
         "package test;",
         "",
-        "import static dagger.Provides.Type.MAP;",
-        "",
         "import dagger.Module;",
         "import dagger.Provides;",
+        "import dagger.multibindings.IntoMap;",
         "",
         "@Module",
         "final class MapModuleOne {",
-        "  @Provides(type = MAP) @PathKey(value = PathEnum.ADMIN) Handler provideAdminHandler() {",
+        "  @Provides",
+        "  @IntoMap",
+        "  @PathKey(value = PathEnum.ADMIN) Handler provideAdminHandler() {",
         "    return new AdminHandler();",
         "  }",
         "}");
     JavaFileObject mapModuleTwoFile =JavaFileObjects.forSourceLines("test.MapModuleTwo",
         "package test;",
         "",
-        "import static dagger.Provides.Type.MAP;",
-        "",
         "import dagger.Module;",
         "import dagger.Provides;",
+        "import dagger.multibindings.IntoMap;",
         "",
         "@Module",
         "final class MapModuleTwo {",
-        "  @Provides(type = MAP) @PathKey(value = PathEnum.LOGIN, relativePath = \"LoginPath\")",
-        "      Handler provideLoginHandler() {",
+        "  @Provides",
+        "  @IntoMap",
+        "  @PathKey(value = PathEnum.LOGIN, relativePath = \"LoginPath\")",
+        "  Handler provideLoginHandler() {",
         "    return new LoginHandler();",
         "  }",
         "}");
diff --git a/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java b/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
index bd64e88e4..acc6bb6e4 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
@@ -196,16 +196,15 @@ private String formatModuleErrorMessage(String msg) {
     JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
         "package test;",
         "",
-        "import static dagger.Provides.Type.SET_VALUES;",
-        "",
         "import dagger.Module;",
         "import dagger.Provides;",
+        "import dagger.multibindings.ElementsIntoSet;",
         "",
         "import java.util.Set;",
         "",
         "@Module",
         "final class TestModule {",
-        "  @Provides(type = SET_VALUES) Set<?> provideWildcard() {",
+        "  @Provides @ElementsIntoSet Set<?> provideWildcard() {",
         "    return null;",
         "  }",
         "}");
@@ -219,16 +218,15 @@ private String formatModuleErrorMessage(String msg) {
     JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
         "package test;",
         "",
-        "import static dagger.Provides.Type.SET_VALUES;",
-        "",
         "import dagger.Module;",
         "import dagger.Provides;",
+        "import dagger.multibindings.ElementsIntoSet;",
         "",
         "import java.util.Set;",
         "",
         "@Module",
         "final class TestModule {",
-        "  @Provides(type = SET_VALUES) Set provideSomething() {",
+        "  @Provides @ElementsIntoSet Set provideSomething() {",
         "    return null;",
         "  }",
         "}");
@@ -242,16 +240,15 @@ private String formatModuleErrorMessage(String msg) {
     JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
         "package test;",
         "",
-        "import static dagger.Provides.Type.SET_VALUES;",
-        "",
         "import dagger.Module;",
         "import dagger.Provides;",
+        "import dagger.multibindings.ElementsIntoSet;",
         "",
         "import java.util.List;",
         "",
         "@Module",
         "final class TestModule {",
-        "  @Provides(type = SET_VALUES) List<String> provideStrings() {",
+        "  @Provides @ElementsIntoSet List<String> provideStrings() {",
         "    return null;",
         "  }",
         "}");
@@ -611,15 +608,14 @@ private String formatModuleErrorMessage(String msg) {
     JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
         "package test;",
         "",
-        "import static dagger.Provides.Type.SET;",
-        "",
         "import java.util.logging.Logger;",
         "import dagger.Module;",
         "import dagger.Provides;",
+        "import dagger.multibindings.IntoSet;",
         "",
         "@Module",
         "final class TestModule {",
-        "  @Provides(type = SET) String provideString() {",
+        "  @Provides @IntoSet String provideString() {",
         "    return \"\";",
         "  }",
         "}");
@@ -658,17 +654,16 @@ private String formatModuleErrorMessage(String msg) {
     JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
         "package test;",
         "",
-        "import static dagger.Provides.Type.SET;",
-        "",
         "import java.util.logging.Logger;",
         "import dagger.Module;",
         "import dagger.Provides;",
+        "import dagger.multibindings.IntoSet;",
         "import java.util.ArrayList;",
         "import java.util.List;",
         "",
         "@Module",
         "final class TestModule {",
-        "  @Provides(type = SET) List<List<?>> provideWildcardList() {",
+        "  @Provides @IntoSet List<List<?>> provideWildcardList() {",
         "    return new ArrayList<>();",
         "  }",
         "}");
@@ -710,15 +705,14 @@ private String formatModuleErrorMessage(String msg) {
     JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
         "package test;",
         "",
-        "import static dagger.Provides.Type.SET_VALUES;",
-        "",
         "import dagger.Module;",
         "import dagger.Provides;",
+        "import dagger.multibindings.ElementsIntoSet;",
         "import java.util.Set;",
         "",
         "@Module",
         "final class TestModule {",
-        "  @Provides(type = SET_VALUES) Set<String> provideStrings() {",
+        "  @Provides @ElementsIntoSet Set<String> provideStrings() {",
         "    return null;",
         "  }",
         "}");
@@ -949,13 +943,12 @@ public void genericSubclassedModule() {
             "",
             "import dagger.Module;",
             "import dagger.Provides;",
+            "import dagger.multibindings.IntoSet;",
+            "import dagger.multibindings.IntoMap;",
             "import dagger.multibindings.StringKey;",
             "import java.util.List;",
             "import java.util.ArrayList;",
             "",
-            "import static dagger.Provides.Type.MAP;",
-            "import static dagger.Provides.Type.SET;",
-            "",
             "@Module",
             "abstract class ParentModule<A extends CharSequence,",
             "                            B,",
@@ -966,11 +959,11 @@ public void genericSubclassedModule() {
             "    return list;",
             "  }",
             "",
-            "  @Provides(type = SET) B provideBElement(B b) {",
+            "  @Provides @IntoSet B provideBElement(B b) {",
             "    return b;",
             "  }",
             "",
-            "  @Provides(type = MAP) @StringKey(\"b\") B provideBEntry(B b) {",
+            "  @Provides @IntoMap @StringKey(\"b\") B provideBEntry(B b) {",
             "    return b;",
             "  }",
             "}");
diff --git a/compiler/src/test/java/dagger/internal/codegen/MultibindingTest.java b/compiler/src/test/java/dagger/internal/codegen/MultibindingTest.java
new file mode 100644
index 000000000..5b2728e88
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/MultibindingTest.java
@@ -0,0 +1,159 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.testing.compile.JavaSourcesSubject.assertThat;
+
+@RunWith(JUnit4.class)
+public class MultibindingTest {
+  @Test
+  public void providesTypeAndAnnotationOnSameMethod_failsToCompile() {
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.MultibindingModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntoSet;",
+            "",
+            "import static dagger.Provides.Type.SET;",
+            "import static dagger.Provides.Type.UNIQUE;",
+            "",
+            "@Module",
+            "class MultibindingModule {",
+            "  @Provides(type = SET) @IntoSet Integer provideInt() { ",
+            "    return 1;",
+            "  }",
+            "  @Provides(type = UNIQUE) @IntoSet Integer provideConflictingMultibindingTypes() { ",
+            "    return 2;",
+            "  }",
+            "}");
+
+    assertThat(module)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("@Provides.type cannot be used with multibinding annotations")
+        .in(module)
+        .onLine(12)
+        .and()
+        .withErrorContaining("@Provides.type cannot be used with multibinding annotations")
+        .in(module)
+        .onLine(15);
+  }
+
+  @Test
+  public void providesWithTwoMultibindingAnnotations_failsToCompile() {
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.MultibindingModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntoSet;",
+            "import dagger.multibindings.IntoMap;",
+            "",
+            "@Module",
+            "class MultibindingModule {",
+            "  @Provides @IntoSet @IntoMap Integer provideInt() { ",
+            "    return 1;",
+            "  }",
+            "}");
+
+    assertThat(module)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            "Multiple multibinding annotations cannot be placed on the same Provides method")
+        .in(module)
+        .onLine(10);
+  }
+
+  @Test
+  public void producesTypeAndAnnotationOnSameMethod_failsToCompile() {
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.MultibindingModule",
+            "package test;",
+            "",
+            "import dagger.producers.ProducerModule;",
+            "import dagger.producers.Produces;",
+            "import dagger.multibindings.IntoSet;",
+            "",
+            "import static dagger.producers.Produces.Type.SET;",
+            "",
+            "@ProducerModule",
+            "class MultibindingModule {",
+            "  @Produces(type = SET) @IntoSet Integer produceInt() { ",
+            "    return 1;",
+            "  }",
+            "}");
+
+    assertThat(module)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("@Produces.type cannot be used with multibinding annotations")
+        .in(module)
+        .onLine(11);
+  }
+
+  @Test
+  public void appliedOnInvalidMethods_failsToCompile() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.SomeType",
+            "package test;",
+            "",
+            "import java.util.Set;",
+            "import java.util.Map;",
+            "",
+            "import dagger.Component;",
+            "import dagger.multibindings.IntoSet;",
+            "import dagger.multibindings.ElementsIntoSet;",
+            "import dagger.multibindings.IntoMap;",
+            "",
+            "interface SomeType {",
+            "  @IntoSet Set<Integer> ints();",
+            "  @ElementsIntoSet Set<Double> doubles();",
+            "  @IntoMap Map<Integer, Double> map();",
+            "}");
+
+    assertThat(component)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            "Multibinding annotations may only be on @Provides or @Produces methods")
+        .in(component)
+        .onLine(12)
+        .and()
+        .withErrorContaining(
+            "Multibinding annotations may only be on @Provides or @Produces methods")
+        .in(component)
+        .onLine(13)
+        .and()
+        .withErrorContaining(
+            "Multibinding annotations may only be on @Provides or @Produces methods")
+        .in(component)
+        .onLine(14);
+  }
+}
diff --git a/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java b/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
index bee690f7d..5973a7bb3 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
@@ -219,8 +219,7 @@ private String formatModuleErrorMessage(String msg) {
     JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
         "package test;",
         "",
-        "import static dagger.producers.Produces.Type.SET_VALUES;",
-        "",
+        "import dagger.multibindings.ElementsIntoSet;",
         "import dagger.producers.ProducerModule;",
         "import dagger.producers.Produces;",
         "",
@@ -228,7 +227,7 @@ private String formatModuleErrorMessage(String msg) {
         "",
         "@ProducerModule",
         "final class TestModule {",
-        "  @Produces(type = SET_VALUES) Set<?> produceWildcard() {",
+        "  @Produces @ElementsIntoSet Set<?> produceWildcard() {",
         "    return null;",
         "  }",
         "}");
@@ -242,8 +241,7 @@ private String formatModuleErrorMessage(String msg) {
     JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
         "package test;",
         "",
-        "import static dagger.producers.Produces.Type.SET_VALUES;",
-        "",
+        "import dagger.multibindings.ElementsIntoSet;",
         "import dagger.producers.ProducerModule;",
         "import dagger.producers.Produces;",
         "",
@@ -251,7 +249,7 @@ private String formatModuleErrorMessage(String msg) {
         "",
         "@ProducerModule",
         "final class TestModule {",
-        "  @Produces(type = SET_VALUES) Set produceSomething() {",
+        "  @Produces @ElementsIntoSet Set produceSomething() {",
         "    return null;",
         "  }",
         "}");
@@ -265,8 +263,7 @@ private String formatModuleErrorMessage(String msg) {
     JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
         "package test;",
         "",
-        "import static dagger.producers.Produces.Type.SET_VALUES;",
-        "",
+        "import dagger.multibindings.ElementsIntoSet;",
         "import dagger.producers.ProducerModule;",
         "import dagger.producers.Produces;",
         "",
@@ -274,7 +271,7 @@ private String formatModuleErrorMessage(String msg) {
         "",
         "@ProducerModule",
         "final class TestModule {",
-        "  @Produces(type = SET_VALUES) List<String> produceStrings() {",
+        "  @Produces @ElementsIntoSet List<String> produceStrings() {",
         "    return null;",
         "  }",
         "}");
@@ -288,9 +285,8 @@ private String formatModuleErrorMessage(String msg) {
     JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
         "package test;",
         "",
-        "import static dagger.producers.Produces.Type.SET_VALUES;",
-        "",
         "import com.google.common.util.concurrent.ListenableFuture;",
+        "import dagger.multibindings.ElementsIntoSet;",
         "import dagger.producers.ProducerModule;",
         "import dagger.producers.Produces;",
         "",
@@ -298,7 +294,7 @@ private String formatModuleErrorMessage(String msg) {
         "",
         "@ProducerModule",
         "final class TestModule {",
-        "  @Produces(type = SET_VALUES) ListenableFuture<Set<?>> produceWildcard() {",
+        "  @Produces @ElementsIntoSet ListenableFuture<Set<?>> produceWildcard() {",
         "    return null;",
         "  }",
         "}");
@@ -312,9 +308,8 @@ private String formatModuleErrorMessage(String msg) {
     JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
         "package test;",
         "",
-        "import static dagger.producers.Produces.Type.SET_VALUES;",
-        "",
         "import com.google.common.util.concurrent.ListenableFuture;",
+        "import dagger.multibindings.ElementsIntoSet;",
         "import dagger.producers.ProducerModule;",
         "import dagger.producers.Produces;",
         "",
@@ -322,7 +317,7 @@ private String formatModuleErrorMessage(String msg) {
         "",
         "@ProducerModule",
         "final class TestModule {",
-        "  @Produces(type = SET_VALUES) ListenableFuture<Set> produceSomething() {",
+        "  @Produces @ElementsIntoSet ListenableFuture<Set> produceSomething() {",
         "    return null;",
         "  }",
         "}");
@@ -336,9 +331,8 @@ private String formatModuleErrorMessage(String msg) {
     JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
         "package test;",
         "",
-        "import static dagger.producers.Produces.Type.SET_VALUES;",
-        "",
         "import com.google.common.util.concurrent.ListenableFuture;",
+        "import dagger.multibindings.ElementsIntoSet;",
         "import dagger.producers.ProducerModule;",
         "import dagger.producers.Produces;",
         "",
@@ -346,7 +340,7 @@ private String formatModuleErrorMessage(String msg) {
         "",
         "@ProducerModule",
         "final class TestModule {",
-        "  @Produces(type = SET_VALUES) ListenableFuture<List<String>> produceStrings() {",
+        "  @Produces @ElementsIntoSet ListenableFuture<List<String>> produceStrings() {",
         "    return null;",
         "  }",
         "}");
diff --git a/compiler/src/test/java/dagger/internal/codegen/ProductionGraphValidationTest.java b/compiler/src/test/java/dagger/internal/codegen/ProductionGraphValidationTest.java
index 0d38a6103..0206ec7fd 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ProductionGraphValidationTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ProductionGraphValidationTest.java
@@ -189,19 +189,18 @@ public void monitoringDependsOnUnboundType() {
             "import com.google.common.util.concurrent.ListenableFuture;",
             "import dagger.Module;",
             "import dagger.Provides;",
+            "import dagger.multibindings.IntoSet;",
             "import dagger.producers.ProducerModule;",
             "import dagger.producers.Produces;",
             "import dagger.producers.ProductionComponent;",
             "import dagger.producers.monitoring.ProductionComponentMonitor;",
             "",
-            "import static dagger.Provides.Type.SET;",
-            "",
             "final class TestClass {",
             "  interface A {}",
             "",
             "  @Module",
             "  final class MonitoringModule {",
-            "    @Provides(type = SET)",
+            "    @Provides @IntoSet",
             "    ProductionComponentMonitor.Factory monitorFactory(A unbound) {",
             "      return null;",
             "    }",
@@ -228,7 +227,7 @@ public void monitoringDependsOnUnboundType() {
         .failsToCompile()
         .withErrorContaining(expectedError)
         .in(component)
-        .onLine(35);
+        .onLine(34);
   }
 
   @Test
@@ -241,19 +240,18 @@ public void monitoringDependsOnProduction() {
             "import com.google.common.util.concurrent.ListenableFuture;",
             "import dagger.Module;",
             "import dagger.Provides;",
+            "import dagger.multibindings.IntoSet;",
             "import dagger.producers.ProducerModule;",
             "import dagger.producers.Produces;",
             "import dagger.producers.ProductionComponent;",
             "import dagger.producers.monitoring.ProductionComponentMonitor;",
             "",
-            "import static dagger.Provides.Type.SET;",
-            "",
             "final class TestClass {",
             "  interface A {}",
             "",
             "  @Module",
             "  final class MonitoringModule {",
-            "    @Provides(type = SET) ProductionComponentMonitor.Factory monitorFactory(A a) {",
+            "    @Provides @IntoSet ProductionComponentMonitor.Factory monitorFactory(A a) {",
             "      return null;",
             "    }",
             "  }",
@@ -277,7 +275,8 @@ public void monitoringDependsOnProduction() {
             "  }",
             "}");
     String expectedError =
-        "@Provides(type=SET) dagger.producers.monitoring.ProductionComponentMonitor.Factory"
+        "@Provides @dagger.multibindings.IntoSet"
+            + " dagger.producers.monitoring.ProductionComponentMonitor.Factory"
             + " test.TestClass.MonitoringModule.monitorFactory(test.TestClass.A) is a provision,"
             + " which cannot depend on a production.";
     assertAbout(javaSources()).that(ImmutableList.of(EXECUTOR_MODULE, component))
@@ -285,7 +284,7 @@ public void monitoringDependsOnProduction() {
         .failsToCompile()
         .withErrorContaining(expectedError)
         .in(component)
-        .onLine(38);
+        .onLine(37);
   }
   
   @Test
@@ -309,9 +308,9 @@ public void cycleNotBrokenByMap() {
             "",
             "import dagger.producers.ProducerModule;",
             "import dagger.producers.Produces;",
+            "import dagger.multibindings.IntoMap;",
             "import dagger.multibindings.StringKey;",
             "import java.util.Map;",
-            "import static dagger.producers.Produces.Type.MAP;",
             "",
             "@ProducerModule",
             "final class TestModule {",
@@ -319,7 +318,7 @@ public void cycleNotBrokenByMap() {
             "    return \"string\";",
             "  }",
             "",
-            "  @Produces(type = MAP) @StringKey(\"key\")",
+            "  @Produces @IntoMap @StringKey(\"key\")",
             "  static String entry(String string) {",
             "    return string;",
             "  }",
@@ -356,8 +355,8 @@ public void cycleNotBrokenByProducerMap() {
             "import dagger.producers.ProducerModule;",
             "import dagger.producers.Produces;",
             "import dagger.multibindings.StringKey;",
+            "import dagger.multibindings.IntoMap;",
             "import java.util.Map;",
-            "import static dagger.producers.Produces.Type.MAP;",
             "",
             "@ProducerModule",
             "final class TestModule {",
@@ -365,7 +364,7 @@ public void cycleNotBrokenByProducerMap() {
             "    return \"string\";",
             "  }",
             "",
-            "  @Produces(type = MAP) @StringKey(\"key\")",
+            "  @Produces @IntoMap @StringKey(\"key\")",
             "  static String entry(String string) {",
             "    return string;",
             "  }",
diff --git a/core/src/main/java/dagger/MapKey.java b/core/src/main/java/dagger/MapKey.java
index dfcfc139e..a169e0731 100644
--- a/core/src/main/java/dagger/MapKey.java
+++ b/core/src/main/java/dagger/MapKey.java
@@ -26,9 +26,10 @@
 
 /**
  * Identifies annotation types that are used to associate keys with values returned by
- * {@linkplain Provides provider methods} in order to compose a {@linkplain Provides.Type#MAP map}.
+ * {@linkplain Provides provider methods} in order to compose a {@linkplain
+ * dagger.multibindings.IntoMap map}.
  *
- * <p>Every provider method annotated with {@code @Provides(type = MAP)} must also have an
+ * <p>Every provider method annotated with {@code @Provides} and {@code @IntoMap} must also have an
  * annotation that identifies the key for that map entry. That annotation's type must be annotated
  * with {@code @MapKey}.
  *
@@ -45,7 +46,8 @@
  *
  * {@literal @}Module
  * class SomeModule {
- *   {@literal @}Provides(type = MAP)
+ *   {@literal @}Provides
+ *   {@literal @}IntoMap
  *   {@literal @}SomeEnumKey(SomeEnum.FOO)
  *   Integer provideFooValue() {
  *     return 2;
@@ -80,7 +82,8 @@
  *
  * {@literal @}Module
  * class SomeModule {
- *   {@literal @}Provides(type = MAP)
+ *   {@literal @}Provides
+ *   {@literal @}IntoMap
  *   {@literal @}MyMapKey(someString = "foo", someEnum = BAR)
  *   Integer provideFooBarValue() {
  *     return 2;
diff --git a/core/src/main/java/dagger/multibindings/ElementsIntoSet.java b/core/src/main/java/dagger/multibindings/ElementsIntoSet.java
new file mode 100644
index 000000000..8ff7dd97c
--- /dev/null
+++ b/core/src/main/java/dagger/multibindings/ElementsIntoSet.java
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.multibindings;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+
+import static java.lang.annotation.ElementType.METHOD;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+/**
+ * The method's return type is {@code Set<T>} and all values are contributed to the set. The {@code
+ * Set<T>} produced from the accumulation of values will be immutable. An example use is to provide
+ * a default empty set binding, which is otherwise not possible using {@link IntoSet}.
+ *
+ * @see <a href=google.github.io/dagger/multibindings#set-multibindings>Set multibinding</a>
+ */
+@Documented
+@Target(METHOD)
+@Retention(RUNTIME)
+public @interface ElementsIntoSet {}
diff --git a/core/src/main/java/dagger/multibindings/IntoMap.java b/core/src/main/java/dagger/multibindings/IntoMap.java
new file mode 100644
index 000000000..4dc3427a3
--- /dev/null
+++ b/core/src/main/java/dagger/multibindings/IntoMap.java
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.multibindings;
+
+import dagger.internal.Beta;
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+
+import static java.lang.annotation.ElementType.METHOD;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+/**
+ * The method's return type forms the type argument for the value of a
+ * {@code Map<K, Provider<V>>}, and the combination of the annotated key and the returned value
+ * is contributed to the map as a key/value pair. The {@code Map<K, Provider<V>>} produced from
+ * the accumulation of values will be immutable.
+ *
+ * @see <a href=google.github.io/dagger/multibindings#map-multibindings>Map multibinding</a>
+ */
+@Documented
+@Target(METHOD)
+@Retention(RUNTIME)
+@Beta
+public @interface IntoMap {}
diff --git a/core/src/main/java/dagger/multibindings/IntoSet.java b/core/src/main/java/dagger/multibindings/IntoSet.java
new file mode 100644
index 000000000..c98a957a9
--- /dev/null
+++ b/core/src/main/java/dagger/multibindings/IntoSet.java
@@ -0,0 +1,36 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.multibindings;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+
+import static java.lang.annotation.ElementType.METHOD;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+/**
+ * The method's return type forms the generic type argument of a {@code Set<T>}, and the
+ * returned value is contributed to the set. The object graph will pass dependencies to the
+ * method as parameters. The {@code Set<T>} produced from the accumulation of values will be
+ * immutable.
+ *
+ * @see <a href=google.github.io/dagger/multibindings#set-multibindings>Set multibinding</a>
+ */
+@Documented
+@Target(METHOD)
+@Retention(RUNTIME)
+public @interface IntoSet {}
diff --git a/producers/src/main/java/dagger/producers/monitoring/ProductionComponentMonitor.java b/producers/src/main/java/dagger/producers/monitoring/ProductionComponentMonitor.java
index 90e6d856a..af3164bac 100644
--- a/producers/src/main/java/dagger/producers/monitoring/ProductionComponentMonitor.java
+++ b/producers/src/main/java/dagger/producers/monitoring/ProductionComponentMonitor.java
@@ -28,7 +28,7 @@
  * <p>For example: <pre><code>
  *   {@literal @Module}
  *   final class MyMonitorModule {
- *     {@literal @Provides(type = SET)} ProductionComponentMonitor.Factory provideMonitorFactory(
+ *     {@literal @Provides @IntoSet} ProductionComponentMonitor.Factory provideMonitorFactory(
  *         MyProductionComponentMonitor.Factory monitorFactory) {
  *       return monitorFactory;
  *     }
