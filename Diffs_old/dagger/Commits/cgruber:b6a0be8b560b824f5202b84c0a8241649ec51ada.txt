diff --git a/compiler/pom.xml b/compiler/pom.xml
index b10668842..ee261a4f2 100644
--- a/compiler/pom.xml
+++ b/compiler/pom.xml
@@ -40,6 +40,11 @@
       <groupId>com.squareup</groupId>
       <artifactId>javawriter</artifactId>
     </dependency>
+    <dependency>
+      <groupId>com.google.guava</groupId>
+      <artifactId>guava</artifactId>
+      <version>15.0</version>
+    </dependency>
 
     <dependency>
       <groupId>junit</groupId>
@@ -64,12 +69,6 @@
       <version>0.3</version>
       <scope>test</scope>
     </dependency>
-    <dependency>
-      <groupId>com.google.guava</groupId>
-      <artifactId>guava</artifactId>
-      <version>15.0</version>
-      <scope>test</scope>
-    </dependency>
     <dependency>
       <groupId>org.truth0</groupId>
       <artifactId>truth</artifactId>
diff --git a/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisProcessor.java b/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisProcessor.java
index 8be0c9645..ec18fbf2e 100644
--- a/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/GraphAnalysisProcessor.java
@@ -15,12 +15,16 @@
  */
 package dagger.internal.codegen;
 
+import com.google.common.collect.ImmutableList;
 import dagger.Module;
+import dagger.ObjectGraph;
 import dagger.Provides;
 import dagger.internal.Binding;
+import dagger.internal.BindingsGroup;
 import dagger.internal.Binding.InvalidBindingException;
 import dagger.internal.Linker;
 import dagger.internal.ProblemDetector;
+import dagger.internal.ProvidesBinding;
 import dagger.internal.SetBinding;
 import dagger.internal.codegen.Util.CodeGenerationIncompleteException;
 import java.io.IOException;
@@ -56,10 +60,10 @@
 
 import static dagger.Provides.Type.SET;
 import static dagger.Provides.Type.SET_VALUES;
+import static dagger.internal.codegen.Util.className;
 import static dagger.internal.codegen.Util.getAnnotation;
 import static dagger.internal.codegen.Util.getPackage;
 import static dagger.internal.codegen.Util.isInterface;
-import static dagger.internal.codegen.Util.methodName;
 import static java.util.Arrays.asList;
 
 /**
@@ -172,13 +176,21 @@ private void error(String message, Element element) {
     // We know statically that we're single threaded, but we synchronize anyway
     // to make the linker happy.
     synchronized (linker) {
-      Map<String, Binding<?>> baseBindings = new LinkedHashMap<String, Binding<?>>();
-      Map<String, Binding<?>> overrideBindings = new LinkedHashMap<String, Binding<?>>();
+      BindingsGroup baseBindings = new BindingsGroup() {
+        @Override public final Binding<?> contributeSetBinding(String key, SetBinding<?> value) {
+          return super.put(key, value);
+        }
+      };
+      BindingsGroup overrideBindings = new BindingsGroup() {
+        @Override public final Binding<?> contributeSetBinding(String key, SetBinding<?> value) {
+          throw new IllegalStateException("Module overrides cannot contribute set bindings.");
+        }
+      };
       for (TypeElement module : allModules.values()) {
         Map<String, Object> annotation = getAnnotation(Module.class, module);
         boolean overrides = (Boolean) annotation.get("overrides");
         boolean library = (Boolean) annotation.get("library");
-        Map<String, Binding<?>> addTo = overrides ? overrideBindings : baseBindings;
+        BindingsGroup addTo = overrides ? overrideBindings : baseBindings;
 
         // Gather the injectable types from the annotation.
         Set<String> injectsProvisionKeys = new LinkedHashSet<String>();
@@ -208,9 +220,9 @@ private void error(String message, Element element) {
           }
           ExecutableElement providerMethod = (ExecutableElement) enclosed;
           String key = GeneratorKeys.get(providerMethod);
-          Binding binding = new ProviderMethodBinding(key, providerMethod, library);
+          ProvidesBinding<?> binding = new ProviderMethodBinding(key, providerMethod, library);
 
-          Binding previous = addTo.get(key);
+          Binding<?> previous = addTo.get(key);
           if (previous != null) {
             if ((provides.type() == SET || provides.type() == SET_VALUES)
                 && previous instanceof SetBinding) {
@@ -230,7 +242,11 @@ private void error(String message, Element element) {
               if (injectsProvisionKeys.contains(binding.provideKey)) {
                 binding.setDependedOn(true);
               }
-              addTo.put(key, binding);
+              try {
+                addTo.contributeProvidesBinding(key, binding);
+              } catch (IllegalStateException ise) { 
+                throw new ModuleValidationException(ise.getMessage(), providerMethod);
+              }
               break;
 
             case SET:
@@ -264,11 +280,6 @@ private Elements elements() {
     return processingEnv.getElementUtils();
   }
 
-  private String shortMethodName(ExecutableElement method) {
-    return method.getEnclosingElement().getSimpleName().toString()
-        + "." + method.getSimpleName() + "()";
-  }
-
   void collectIncludesRecursively(
       TypeElement module, Map<String, TypeElement> result, Deque<String> path) {
     Map<String, Object> annotation = getAnnotation(Module.class, module);
@@ -317,12 +328,13 @@ void collectIncludesRecursively(
     }
   }
 
-  static class ProviderMethodBinding extends Binding<Object> {
+  static class ProviderMethodBinding extends ProvidesBinding<Object> {
     private final ExecutableElement method;
     private final Binding<?>[] parameters;
 
     protected ProviderMethodBinding(String provideKey, ExecutableElement method, boolean library) {
-      super(provideKey, null, method.getAnnotation(Singleton.class) != null, methodName(method));
+      super(provideKey, method.getAnnotation(Singleton.class) != null,
+          className(method), method.getSimpleName().toString());
       this.method = method;
       this.parameters = new Binding[method.getParameters().size()];
       setLibrary(library);
@@ -348,6 +360,11 @@ protected ProviderMethodBinding(String provideKey, ExecutableElement method, boo
     @Override public void getDependencies(Set<Binding<?>> get, Set<Binding<?>> injectMembers) {
       Collections.addAll(get, parameters);
     }
+
+    @Override public String toString() {
+      return "ProvidesBinding[key=" + provideKey
+          + " method=" + moduleClass + "." + method.getSimpleName() + "()";
+    }
   }
 
   void writeDotFile(TypeElement module, Map<String, Binding<?>> bindings) throws IOException {
@@ -363,9 +380,9 @@ void writeDotFile(TypeElement module, Map<String, Binding<?>> bindings) throws I
   }
 
   static class ModuleValidationException extends IllegalStateException {
-    final TypeElement source;
+    final Element source;
 
-    public ModuleValidationException(String message, TypeElement source) {
+    public ModuleValidationException(String message, Element source) {
       super(message);
       this.source = source;
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/GraphVisualizer.java b/compiler/src/main/java/dagger/internal/codegen/GraphVisualizer.java
index 26394b6bd..bfa9418c7 100644
--- a/compiler/src/main/java/dagger/internal/codegen/GraphVisualizer.java
+++ b/compiler/src/main/java/dagger/internal/codegen/GraphVisualizer.java
@@ -125,7 +125,7 @@ String shortName(String key) {
     return result.toString();
   }
 
-  /** A Comparator for Bindings so we can insure a consistent ordering of output. */
+  /** A Comparator for BindingsGroup so we can insure a consistent ordering of output. */
   private static class BindingComparator implements Comparator<Binding<?>> {
     @Override
     public int compare(Binding<?> left, Binding<?> right) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java
index ff87d24aa..f4b7882a6 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java
@@ -20,8 +20,10 @@
 import dagger.Module;
 import dagger.Provides;
 import dagger.internal.Binding;
+import dagger.internal.BindingsGroup;
 import dagger.internal.Linker;
 import dagger.internal.ModuleAdapter;
+import dagger.internal.ProvidesBinding;
 import dagger.internal.SetBinding;
 import dagger.internal.codegen.Util.CodeGenerationIncompleteException;
 import java.io.IOException;
@@ -81,8 +83,7 @@
  */
 @SupportedAnnotationTypes({ "*" })
 public final class ModuleAdapterProcessor extends AbstractProcessor {
-  private static final String BINDINGS_MAP = JavaWriter.type(
-      Map.class, String.class.getCanonicalName(), Binding.class.getCanonicalName() + "<?>");
+  private static final String BINDINGS_MAP = JavaWriter.type(BindingsGroup.class);
   private static final List<String> INVALID_RETURN_TYPES =
       Arrays.asList(Provider.class.getCanonicalName(), Lazy.class.getCanonicalName());
 
@@ -323,7 +324,7 @@ private void generateModuleAdapter(Writer ioWriter, String adapterName, TypeElem
       writer.emitEmptyLine();
       writer.emitJavadoc(AdapterJavadocs.GET_DEPENDENCIES_METHOD);
       writer.emitAnnotation(Override.class);
-      writer.beginMethod("void", "getBindings", EnumSet.of(PUBLIC), BINDINGS_MAP, "map",
+      writer.beginMethod("void", "getBindings", EnumSet.of(PUBLIC), BINDINGS_MAP, "bindings",
           typeName, "module");
 
       for (ExecutableElement providerMethod : providerMethods) {
@@ -331,20 +332,20 @@ private void generateModuleAdapter(Writer ioWriter, String adapterName, TypeElem
         switch (provides.type()) {
           case UNIQUE: {
             String key = GeneratorKeys.get(providerMethod);
-            writer.emitStatement("map.put(%s, new %s(module))", JavaWriter.stringLiteral(key),
+            writer.emitStatement("bindings.contributeProvidesBinding(%s, new %s(module))", JavaWriter.stringLiteral(key),
                 bindingClassName(providerMethod, methodToClassName, methodNameToNextId));
             break;
           }
           case SET: {
             String key = GeneratorKeys.getSetKey(providerMethod);
-            writer.emitStatement("SetBinding.add(map, %s, new %s(module))",
+            writer.emitStatement("SetBinding.add(bindings, %s, new %s(module))",
                 JavaWriter.stringLiteral(key),
                 bindingClassName(providerMethod, methodToClassName, methodNameToNextId));
             break;
           }
           case SET_VALUES: {
             String key = GeneratorKeys.get(providerMethod);
-            writer.emitStatement("SetBinding.add(map, %s, new %s(module))",
+            writer.emitStatement("SetBinding.add(bindings, %s, new %s(module))",
                 JavaWriter.stringLiteral(key),
                 bindingClassName(providerMethod, methodToClassName, methodNameToNextId));
             break;
@@ -369,13 +370,14 @@ private void generateModuleAdapter(Writer ioWriter, String adapterName, TypeElem
     Set<String> imports = new LinkedHashSet<String>();
     imports.add(ModuleAdapter.class.getCanonicalName());
     if (providers) {
-      imports.add(Binding.class.getCanonicalName());
-      imports.add(Map.class.getCanonicalName());
+      imports.add(BindingsGroup.class.getCanonicalName());
       imports.add(Provider.class.getCanonicalName());
+      imports.add(ProvidesBinding.class.getCanonicalName());
     }
     if (dependencies) {
       imports.add(Linker.class.getCanonicalName());
       imports.add(Set.class.getCanonicalName());
+      imports.add(Binding.class.getCanonicalName());
     }
     if (multibindings) {
       imports.add(SetBinding.class.getCanonicalName());
@@ -439,7 +441,7 @@ private void generateProvidesAdapter(JavaWriter writer, ExecutableElement provid
     writer.emitEmptyLine();
     writer.emitJavadoc(bindingTypeDocs(returnType, false, false, dependent));
     writer.beginType(className, "class", EnumSet.of(PUBLIC, STATIC, FINAL),
-        JavaWriter.type(Binding.class, returnType),
+        JavaWriter.type(ProvidesBinding.class, returnType),
         JavaWriter.type(Provider.class, returnType));
     writer.emitField(moduleType, "module", EnumSet.of(PRIVATE, FINAL));
     for (Element parameter : parameters) {
@@ -452,10 +454,10 @@ private void generateProvidesAdapter(JavaWriter writer, ExecutableElement provid
     writer.beginMethod(null, className, EnumSet.of(PUBLIC), moduleType, "module");
     boolean singleton = providerMethod.getAnnotation(Singleton.class) != null;
     String key = JavaWriter.stringLiteral(GeneratorKeys.get(providerMethod));
-    String membersKey = null;
     writer.emitStatement("super(%s, %s, %s, %s)",
-        key, membersKey, (singleton ? "IS_SINGLETON" : "NOT_SINGLETON"),
-        JavaWriter.stringLiteral(moduleType + "." + methodName + "()"));
+        key, (singleton ? "IS_SINGLETON" : "NOT_SINGLETON"),
+        JavaWriter.stringLiteral(moduleType),
+        JavaWriter.stringLiteral(methodName));
     writer.emitStatement("this.module = module");
     writer.emitStatement("setLibrary(%s)", library);
     writer.endMethod();
diff --git a/compiler/src/main/java/dagger/internal/codegen/Util.java b/compiler/src/main/java/dagger/internal/codegen/Util.java
index 0f8b36c24..86d587e18 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Util.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Util.java
@@ -322,13 +322,12 @@ public static boolean isCallableConstructor(ExecutableElement constructor) {
         || type.getModifiers().contains(Modifier.STATIC);
   }
 
+
   /**
-   * Returns a user-presentable string like {@code
-   * coffee.CoffeeModule#provideHeater()}.
+   * Returns a user-presentable string like {@code coffee.CoffeeModule}.
    */
-  public static String methodName(ExecutableElement method) {
-    return ((TypeElement) method.getEnclosingElement()).getQualifiedName()
-        + "." + method.getSimpleName() + "()";
+  public static String className(ExecutableElement method) {
+    return ((TypeElement) method.getEnclosingElement()).getQualifiedName().toString();
   }
 
   public static boolean isInterface(TypeMirror typeMirror) {
diff --git a/compiler/src/test/java/dagger/tests/integration/validation/CyclicDependencyTest.java b/compiler/src/test/java/dagger/tests/integration/validation/CyclicDependencyTest.java
index a18762d52..1afd4d9b6 100644
--- a/compiler/src/test/java/dagger/tests/integration/validation/CyclicDependencyTest.java
+++ b/compiler/src/test/java/dagger/tests/integration/validation/CyclicDependencyTest.java
@@ -76,10 +76,10 @@
         "}"));
 
     ASSERT.about(javaSource()).that(sourceFile).processedWith(daggerProcessors()).failsToCompile()
-        .withErrorContaining("0. CyclicDeps$A bound by Provider").in(sourceFile).onLine(9).and()
-        .withErrorContaining("1. CyclicDeps$D bound by Provider").in(sourceFile).onLine(9).and()
-        .withErrorContaining("2. CyclicDeps$C bound by Provider").in(sourceFile).onLine(9).and()
-        .withErrorContaining("3. CyclicDeps$B bound by Provider").in(sourceFile).onLine(9);
+        .withErrorContaining("0. CyclicDeps$A bound by Provides").in(sourceFile).onLine(9).and()
+        .withErrorContaining("1. CyclicDeps$D bound by Provides").in(sourceFile).onLine(9).and()
+        .withErrorContaining("2. CyclicDeps$C bound by Provides").in(sourceFile).onLine(9).and()
+        .withErrorContaining("3. CyclicDeps$B bound by Provides").in(sourceFile).onLine(9);
   }
 
 }
diff --git a/core/src/main/java/dagger/ObjectGraph.java b/core/src/main/java/dagger/ObjectGraph.java
index bbe7b0061..d0d3c3b60 100644
--- a/core/src/main/java/dagger/ObjectGraph.java
+++ b/core/src/main/java/dagger/ObjectGraph.java
@@ -17,6 +17,7 @@
 package dagger;
 
 import dagger.internal.Binding;
+import dagger.internal.BindingsGroup;
 import dagger.internal.FailoverLoader;
 import dagger.internal.Keys;
 import dagger.internal.Linker;
@@ -27,8 +28,9 @@
 import dagger.internal.SetBinding;
 import dagger.internal.StaticInjection;
 import dagger.internal.ThrowingErrorHandler;
-import dagger.internal.UniqueMap;
+import java.util.ArrayList;
 import java.util.LinkedHashMap;
+import java.util.List;
 import java.util.Map;
 import java.util.Map.Entry;
 
@@ -132,40 +134,45 @@ static ObjectGraph createWith(Loader loader, Object... modules) {
     return DaggerObjectGraph.makeGraph(null, loader, modules);
   }
 
+  // TODO(cgruber): Move this internal implementation of ObjectGraph into the internal package.
   static class DaggerObjectGraph extends ObjectGraph {
     private final DaggerObjectGraph base;
     private final Linker linker;
     private final Loader plugin;
     private final Map<Class<?>, StaticInjection> staticInjections;
     private final Map<String, Class<?>> injectableTypes;
+    private final List<SetBinding<?>> setBindings;
 
     DaggerObjectGraph(DaggerObjectGraph base,
         Linker linker,
         Loader plugin,
         Map<Class<?>, StaticInjection> staticInjections,
-        Map<String, Class<?>> injectableTypes) {
-      if (linker == null) throw new NullPointerException("linker");
-      if (plugin == null) throw new NullPointerException("plugin");
-      if (staticInjections == null) throw new NullPointerException("staticInjections");
-      if (injectableTypes == null) throw new NullPointerException("injectableTypes");
+        Map<String, Class<?>> injectableTypes,
+        List<SetBinding<?>> setBindings) {
 
       this.base = base;
-      this.linker = linker;
-      this.plugin = plugin;
-      this.staticInjections = staticInjections;
-      this.injectableTypes = injectableTypes;
+      this.linker = checkNotNull(linker, "linker");
+      this.plugin = checkNotNull(plugin, "plugin");
+      this.staticInjections = checkNotNull(staticInjections, "staticInjections");
+      this.injectableTypes = checkNotNull(injectableTypes, "injectableTypes");
+      this.setBindings = checkNotNull(setBindings, "setBindings");
+    }
+
+    private static <T> T checkNotNull(T object, String label) {
+      if (object == null) throw new NullPointerException(label);
+      return object;
     }
 
     private static ObjectGraph makeGraph(DaggerObjectGraph base, Loader plugin, Object... modules) {
       Map<String, Class<?>> injectableTypes = new LinkedHashMap<String, Class<?>>();
       Map<Class<?>, StaticInjection> staticInjections
           = new LinkedHashMap<Class<?>, StaticInjection>();
-      UniqueMap<String, Binding<?>> baseBindings = initBaseBindings(base);
-      UniqueMap<String, Binding<?>> overrideBindings = initOverrideBindings();
+      StandardBindings baseBindings =
+          (base == null) ? new StandardBindings() : new StandardBindings(base.setBindings);
+      BindingsGroup overrideBindings = new OverridesBindings();
 
       Map<ModuleAdapter<?>, Object> loadedModules = Modules.loadModules(plugin, modules);
       for (Entry<ModuleAdapter<?>, Object> loadedModule : loadedModules.entrySet()) {
-        @SuppressWarnings("unchecked")
         ModuleAdapter<Object> moduleAdapter = (ModuleAdapter<Object>) loadedModule.getKey();
         for (int i = 0; i < moduleAdapter.injectableTypes.length; i++) {
           injectableTypes.put(moduleAdapter.injectableTypes[i], moduleAdapter.moduleClass);
@@ -174,7 +181,7 @@ private static ObjectGraph makeGraph(DaggerObjectGraph base, Loader plugin, Obje
           staticInjections.put(moduleAdapter.staticInjections[i], null);
         }
         try {
-          Map<String, Binding<?>> addTo = moduleAdapter.overrides ? overrideBindings : baseBindings;
+          BindingsGroup addTo = moduleAdapter.overrides ? overrideBindings : baseBindings;
           moduleAdapter.getBindings(addTo, loadedModule.getValue());
         } catch (IllegalArgumentException e) {
           throw new IllegalArgumentException(moduleAdapter.moduleClass.getSimpleName()
@@ -188,46 +195,12 @@ private static ObjectGraph makeGraph(DaggerObjectGraph base, Loader plugin, Obje
       linker.installBindings(baseBindings);
       linker.installBindings(overrideBindings);
 
-      return new DaggerObjectGraph(base, linker, plugin, staticInjections, injectableTypes);
-    }
-
-    /**
-     * Returns an empty {@code UniqueMap} which will throw errors if a SetBinding is added
-     * to it.
-     */
-    private static UniqueMap<String, Binding<?>> initOverrideBindings() {
-      return new UniqueMap<String, Binding<?>>() {
-        @Override public Binding<?> put(String key, Binding<?> value) {
-          if (value instanceof SetBinding) {
-            throw new IllegalArgumentException("Module overrides cannot contribute set bindings.");
-          }
-          return super.put(key, value);
-        }
-      };
-    }
-
-    /**
-     * Extract bindings in the 'base' and 'overrides' set. Within each set no
-     * duplicates are permitted.  Set-bindings are propagated (and cloned) from the parent
-     * to ensure that parent graph participants only see parent bindings, but the child
-     * graph sees parent+child contributions.
-     */
-    private static UniqueMap<String, Binding<?>> initBaseBindings(
-        DaggerObjectGraph base) {
-      UniqueMap<String, Binding<?>> baseBindings = new UniqueMap<String, Binding<?>>();
-      if (base != null) {
-        Map<String, Binding<?>> parentBindings = base.linkEverything();
-        for (Map.Entry<String, Binding<?>> bindingEntry : parentBindings.entrySet()) {
-          if (bindingEntry.getValue() instanceof SetBinding) {
-            baseBindings.put(bindingEntry.getKey(),
-                new SetBinding<Object>((SetBinding<Object>) bindingEntry.getValue()));
-          }
-        }
-      }
-      return baseBindings;
+      return new DaggerObjectGraph(
+          base, linker, plugin, staticInjections, injectableTypes, baseBindings.setBindings);
     }
 
     @Override public ObjectGraph plus(Object... modules) {
+      linkEverything();
       return makeGraph(this, plugin, modules);
     }
 
@@ -341,4 +314,44 @@ private void linkInjectableTypes() {
     }
   }
 
+
+  /**
+   * A BindingsGroup which fails when existing values are clobbered and sets aside
+   * {@link SetBinding}.
+   */
+  private static final class StandardBindings extends BindingsGroup {
+    private final List<SetBinding<?>> setBindings;
+
+    public StandardBindings() {
+      setBindings = new ArrayList<SetBinding<?>>();
+    }
+
+    public StandardBindings(List<SetBinding<?>> baseSetBindings) {
+      setBindings = new ArrayList<SetBinding<?>>(baseSetBindings.size());
+      for (SetBinding<?> sb : baseSetBindings) {
+        @SuppressWarnings("rawtypes")
+        SetBinding<?> child = new SetBinding(sb);
+        setBindings.add(child);
+        put(child.provideKey, child);
+      }
+    }
+
+    @Override public final Binding<?> contributeSetBinding(String key, SetBinding<?> value) {
+      setBindings.add(value);
+      return super.put(key, value);
+    }
+  }
+
+  /**
+   * A BindingsGroup which throws an {@link IllegalArgumentException} when a
+   * {@link SetBinding} is contributed, since overrides modules cannot contribute such
+   * bindings.
+   */
+  private static final class OverridesBindings extends BindingsGroup {
+    OverridesBindings() { }
+
+    @Override public final Binding<?> contributeSetBinding(String key, SetBinding<?> value) {
+      throw new IllegalArgumentException("Module overrides cannot contribute set bindings.");
+    }
+  }
 }
diff --git a/core/src/main/java/dagger/internal/BindingsGroup.java b/core/src/main/java/dagger/internal/BindingsGroup.java
new file mode 100644
index 000000000..4bd21b735
--- /dev/null
+++ b/core/src/main/java/dagger/internal/BindingsGroup.java
@@ -0,0 +1,57 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ * Copyright (C) 2013 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.Set;
+
+/**
+ * A grouping of bindings that fails when existing values are clobbered, to be used in collecting
+ * the initial set of bindings for a graph (from provides methods).
+ */
+public abstract class BindingsGroup {
+  private final Map<String, Binding<?>> bindings = new HashMap<String, Binding<?>>();
+
+  public abstract Binding<?> contributeSetBinding(String key, SetBinding<?> value);
+
+  public Binding<?> contributeProvidesBinding(String key, ProvidesBinding<?> value) {
+    return put(key, value);
+  }
+
+  protected Binding<?> put(String key, Binding<?> value) {
+    Binding<?> clobbered = bindings.put(key, value);
+    if (clobbered != null) {
+      bindings.put(key, clobbered); // Put things back as they were.
+      throw new IllegalArgumentException("Duplicate:\n    " + clobbered + "\n    " + value);
+    }
+    return null;
+  }
+
+  public Binding<?> get(String key) {
+    return bindings.get(key);
+  }
+
+  public final Set<Entry<String, Binding<?>>> entrySet() {
+    return bindings.entrySet();
+  }
+
+  @Override public String toString() {
+    return getClass().getSimpleName() + bindings.toString();
+  }
+}
diff --git a/core/src/main/java/dagger/internal/Keys.java b/core/src/main/java/dagger/internal/Keys.java
index dc360202c..0a2a78759 100644
--- a/core/src/main/java/dagger/internal/Keys.java
+++ b/core/src/main/java/dagger/internal/Keys.java
@@ -35,7 +35,7 @@
  *       qualified by the annotation.
  *   <li>{@code members/com.square.Foo}: injects members of Foo.
  * </ol>
- * Bindings from {@code @Provides} methods are of the first two types. Bindings
+ * BindingsGroup from {@code @Provides} methods are of the first two types. BindingsGroup
  * created from {@code @Inject}-annotated members of a class are of the first
  * and last types.
  */
diff --git a/core/src/main/java/dagger/internal/Linker.java b/core/src/main/java/dagger/internal/Linker.java
index aacb7a9d3..bea961eda 100644
--- a/core/src/main/java/dagger/internal/Linker.java
+++ b/core/src/main/java/dagger/internal/Linker.java
@@ -38,7 +38,7 @@
    */
   private final Linker base;
 
-  /** Bindings requiring a call to attach(). May contain deferred bindings. */
+  /** BindingsGroup requiring a call to attach(). May contain deferred bindings. */
   private final Queue<Binding<?>> toLink = new LinkedList<Binding<?>>();
 
   /** True unless calls to requestBinding() were unable to satisfy the binding. */
@@ -77,9 +77,9 @@ public Linker(Linker base, Loader plugin, ErrorHandler errorHandler) {
    * bindings can be used.
    *
    * This method may only be called before {@link #linkAll()}. Subsequent calls to
-   * {@link #installBindings()} will throw an {@link IllegalStateException}.
+   * {@link #installBindings(BindingsGroup)} will throw an {@link IllegalStateException}.
    */
-  public void installBindings(Map<String, ? extends Binding<?>> toInstall) {
+  public void installBindings(BindingsGroup toInstall) {
     if (linkedBindings != null) {
       throw new IllegalStateException("Cannot install further bindings after calling linkAll().");
     }
diff --git a/core/src/main/java/dagger/internal/ModuleAdapter.java b/core/src/main/java/dagger/internal/ModuleAdapter.java
index dfe09b236..2986ad66a 100644
--- a/core/src/main/java/dagger/internal/ModuleAdapter.java
+++ b/core/src/main/java/dagger/internal/ModuleAdapter.java
@@ -17,8 +17,6 @@
 package dagger.internal;
 
 
-import java.util.Map;
-
 /**
  * Extracts bindings from an {@code @Module}-annotated class.
  */
@@ -47,8 +45,8 @@ protected ModuleAdapter(Class<T> moduleClass, String[] injectableTypes,
    * Returns bindings for the {@code @Provides} methods of {@code module}. The
    * returned bindings must be linked before they can be used to inject values.
    */
-  public void getBindings(@SuppressWarnings("unused") Map<String, Binding<?>> map,
-      @SuppressWarnings("unused") T module) {
+  @SuppressWarnings("unused")
+  public void getBindings(BindingsGroup map, T module) {
     // no-op;
   }
 
diff --git a/core/src/main/java/dagger/internal/ProvidesBinding.java b/core/src/main/java/dagger/internal/ProvidesBinding.java
new file mode 100644
index 000000000..2e6f98922
--- /dev/null
+++ b/core/src/main/java/dagger/internal/ProvidesBinding.java
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2013 Google, Inc.
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal;
+
+/**
+ * A {@code Binding<T>} which delegates to a module method.
+ */
+public abstract class ProvidesBinding<T> extends Binding<T> {
+  protected final String moduleClass;
+
+  protected final String methodName;
+
+  /**
+   * Creates a new {@code ProvidesBinding} with the given "provides" key, a flag as to whether
+   * this binding should be scoped, and the requiredBy object for traceability.
+   */
+  public ProvidesBinding(String key, boolean singleton, String moduleClass, String methodName) {
+    // Set requiredBy as fullMethodName to preserve older debugging meaning.
+    super(key, null, singleton, moduleClass + "." + methodName + "()");
+    this.moduleClass = moduleClass;
+    this.methodName = methodName;
+  }
+
+  /**
+   * A provides binding is responsible for implementing storage of the module instance, and
+   * delegation to that module instance's method.
+   */
+  @Override
+  public abstract T get();
+
+  @Override public String toString() {
+    return getClass().getName() + "[key=" + provideKey
+        + " method=" + moduleClass + "." + methodName + "()" + "]";
+  }
+}
diff --git a/core/src/main/java/dagger/internal/SetBinding.java b/core/src/main/java/dagger/internal/SetBinding.java
index ed0c5f71a..92d02adf6 100644
--- a/core/src/main/java/dagger/internal/SetBinding.java
+++ b/core/src/main/java/dagger/internal/SetBinding.java
@@ -16,9 +16,10 @@
  */
 package dagger.internal;
 
+import java.util.ArrayList;
 import java.util.Collections;
 import java.util.LinkedHashSet;
-import java.util.Map;
+import java.util.List;
 import java.util.Set;
 
 /**
@@ -28,13 +29,13 @@
  */
 public final class SetBinding<T> extends Binding<Set<T>> {
 
-  public static <T> void add(Map<String, Binding<?>> bindings, String setKey, Binding<?> binding) {
+  public static <T> void add(BindingsGroup bindings, String setKey, Binding<?> binding) {
     prepareSetBinding(bindings, setKey, binding).contributors.add(Linker.scope(binding));
   }
 
   @SuppressWarnings("unchecked")
   private static <T> SetBinding<T> prepareSetBinding(
-      Map<String, Binding<?>> bindings, String setKey, Binding<?> binding) {
+      BindingsGroup bindings, String setKey, Binding<?> binding) {
     Binding<?> previous = bindings.get(setKey);
     SetBinding<T> setBinding;
     if (previous instanceof SetBinding) {
@@ -46,12 +47,21 @@
     } else {
       setBinding = new SetBinding<T>(setKey, binding.requiredBy);
       setBinding.setLibrary(binding.library());
-      bindings.put(setKey, setBinding);
+      bindings.contributeSetBinding(setKey, setBinding);
       return (SetBinding<T>) bindings.get(setKey); // BindingMap.put() copies SetBindings.
     }
   }
 
-  private final Set<Binding<?>> contributors;
+  /**
+   * A {@link SetBinding} with whose contributing bindings this set-binding provides a union
+   * view.
+   */
+  private final SetBinding<T> parent;
+
+  /**
+   * A {@link Set} of {@link Binding} instances which contribute values to the injected set.
+   */
+  private final List<Binding<?>> contributors;
 
   /**
    * Creates a new {@code SetBinding} with the given "provides" key, and the requiredBy object
@@ -59,7 +69,8 @@
    */
   public SetBinding(String key, Object requiredBy) {
     super(key, null, false, requiredBy);
-    contributors = new LinkedHashSet<Binding<?>>();
+    parent = null;
+    contributors = new ArrayList<Binding<?>>();
   }
 
   /**
@@ -68,9 +79,10 @@ public SetBinding(String key, Object requiredBy) {
    */
   public SetBinding(SetBinding<T> original) {
     super(original.provideKey, null, false, original.requiredBy);
+    parent = original;
     this.setLibrary(original.library());
     this.setDependedOn(original.dependedOn());
-    contributors = new LinkedHashSet<Binding<?>>(original.contributors);
+    contributors = new ArrayList<Binding<?>>();
   }
 
   @Override public void attach(Linker linker) {
@@ -79,30 +91,54 @@ public SetBinding(SetBinding<T> original) {
     }
   }
 
+  public int size() {
+    int size = 0;
+    for (SetBinding<T> binding = this; binding != null; binding = binding.parent) {
+      size += binding.contributors.size();
+    }
+    return size;
+  }
+
   @SuppressWarnings("unchecked") // Only Binding<T> and Set<T> are added to contributors.
   @Override public Set<T> get() {
-    Set<T> result = new LinkedHashSet<T>(contributors.size());
-    for (Binding<?> contributor : contributors) {
-      Object contribution = contributor.get(); // Let runtime exceptions through.
-      if (contributor.provideKey.equals(provideKey)) {
-        result.addAll((Set<T>) contribution);
-      } else {
-        result.add((T) contribution);
+    List<T> result = new ArrayList<T>();
+    for (SetBinding<T> setBinding = this; setBinding != null; setBinding = setBinding.parent) {
+      for (Binding<?> contributor : setBinding.contributors) {
+        Object contribution = contributor.get(); // Let runtime exceptions through.
+        if (contributor.provideKey.equals(provideKey)) {
+          result.addAll((Set<T>) contribution);
+        } else {
+          result.add((T) contribution);
+        }
       }
     }
-    return Collections.unmodifiableSet(result);
+    return Collections.unmodifiableSet(new LinkedHashSet<T>(result));
   }
 
   @Override public void getDependencies(
       Set<Binding<?>> getBindings, Set<Binding<?>> injectMembersBindings) {
-    getBindings.addAll(contributors);
+    for (SetBinding<T> binding = this; binding != null; binding = binding.parent) {
+      getBindings.addAll(binding.contributors);
+    }
   }
 
   @Override public void injectMembers(Set<T> t) {
-    throw new UnsupportedOperationException("Cannot inject into a Set binding");
+    throw new UnsupportedOperationException("Cannot inject members on a contributed Set<T>.");
   }
 
   @Override public String toString() {
-    return "SetBinding" + contributors;
+    boolean first = true;
+    StringBuilder builder = new StringBuilder("SetBinding[");
+    for (SetBinding<T> setBinding = this; setBinding != null; setBinding = setBinding.parent) {
+      for (Binding<?> contributor : setBinding.contributors) {
+        if (!first) {
+          builder.append(",");
+        }
+        builder.append(contributor);
+        first = false;
+      }
+    }
+    builder.append("]");
+    return builder.toString();
   }
 }
diff --git a/core/src/main/java/dagger/internal/UniqueMap.java b/core/src/main/java/dagger/internal/UniqueMap.java
deleted file mode 100644
index 04a42a718..000000000
--- a/core/src/main/java/dagger/internal/UniqueMap.java
+++ /dev/null
@@ -1,38 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal;
-
-import java.util.LinkedHashMap;
-import java.util.Map;
-
-/**
- * A map that fails when existing values are clobbered.
- */
-public class UniqueMap<K, V> extends LinkedHashMap<K, V> {
-  @Override public V put(K key, V value) {
-    V clobbered = super.put(key, value);
-    if (clobbered != null) {
-      super.put(key, clobbered); // Put things back as they were.
-      throw new IllegalArgumentException("Duplicate:\n    " + clobbered + "\n    " + value);
-    }
-    return null;
-  }
-  @Override public void putAll(Map<? extends K, ? extends V> map) {
-    for (Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {
-      put(entry.getKey(), entry.getValue());
-    }
-  }
-}
diff --git a/core/src/test/java/dagger/InjectionTest.java b/core/src/test/java/dagger/InjectionTest.java
index ece39029b..ef5b275fe 100644
--- a/core/src/test/java/dagger/InjectionTest.java
+++ b/core/src/test/java/dagger/InjectionTest.java
@@ -868,10 +868,10 @@ BoundTwoWays provideBoundTwoWays() {
     @Inject C c; // Singleton.
   }
 
-  @Module(complete=false, injects =C.class)
+  @Module(complete = false, injects = C.class)
   static class RootModule { }
 
-  @Module(addsTo=RootModule.class, injects =SingletonLinkedFromExtension.class)
+  @Module(addsTo = RootModule.class, injects = SingletonLinkedFromExtension.class)
   static class ExtensionModule { }
 
   @Test public void testSingletonLinkingThroughExtensionGraph() {
diff --git a/core/src/test/java/dagger/SetBindingTest.java b/core/src/test/java/dagger/SetBindingTest.java
index cf5dccb08..6a029060a 100644
--- a/core/src/test/java/dagger/SetBindingTest.java
+++ b/core/src/test/java/dagger/SetBindingTest.java
@@ -209,6 +209,22 @@ public void doStuff() {
     assertThat(logoutput.get()).contains("NullPointerException");
   }
 
+  @Test public void duplicateValuesContributed() {
+    class TestEntryPoint {
+      @Inject Set<String> strings;
+    }
+
+    @Module(injects = TestEntryPoint.class)
+    class TestModule {
+      @Provides(type=SET) String provideString1() { return "a"; }
+      @Provides(type=SET) String provideString2() { return "a"; }
+      @Provides(type=SET) String provideString3() { return "b"; }
+    }
+
+    TestEntryPoint ep = injectWithModule(new TestEntryPoint(), new TestModule());
+    assertThat(ep.strings).containsOnly("a", "b");
+  }
+
   @Test public void validateSetBinding() {
     class TestEntryPoint {
       @Inject Set<String> strings;
diff --git a/core/src/test/java/dagger/internal/TestingModuleAdapter.java b/core/src/test/java/dagger/internal/TestingModuleAdapter.java
index eed43e973..b5d54f095 100644
--- a/core/src/test/java/dagger/internal/TestingModuleAdapter.java
+++ b/core/src/test/java/dagger/internal/TestingModuleAdapter.java
@@ -24,7 +24,6 @@
 import java.lang.reflect.Method;
 import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
-import java.util.Map;
 import java.util.Set;
 import javax.inject.Provider;
 import javax.inject.Singleton;
@@ -53,7 +52,7 @@ public TestingModuleAdapter(Class<M> moduleClass, Module annotation) {
     return result;
   }
 
-  @Override public void getBindings(Map<String, Binding<?>> bindings, M module) {
+  @Override public void getBindings(BindingsGroup bindings, M module) {
     for (Class<?> c = moduleClass; !c.equals(Object.class); c = c.getSuperclass()) {
       for (Method method : c.getDeclaredMethods()) {
         Provides provides = method.getAnnotation(Provides.class);
@@ -98,15 +97,17 @@ public TestingModuleAdapter(Class<M> moduleClass, Module annotation) {
     }
   }
 
-  private void handleBindings(Map<String, Binding<?>> bindings, M module, Method method, String key,
+  private void handleBindings(BindingsGroup bindings, M module, Method method, String key,
       boolean library) {
-    bindings.put(key, new ProviderMethodBinding<M>(method, key, module, library));
+    bindings.contributeProvidesBinding(key,
+        new ReflectiveProvidesBinding<M>(method, key, moduleClass.getName(), module, library));
   }
 
-  private void handleSetBindings(Map<String, Binding<?>> bindings, M module, Method method,
+  private void handleSetBindings(BindingsGroup bindings, M module, Method method,
       String setKey, String providerKey, boolean library) {
     SetBinding.<M>add(bindings, setKey,
-        new ProviderMethodBinding<M>(method, providerKey, module, library));
+        new ReflectiveProvidesBinding<M>(
+            method, providerKey, moduleClass.getName(), module, library));
   }
 
   @Override public M newModule() {
@@ -149,14 +150,14 @@ private void handleSetBindings(Map<String, Binding<?>> bindings, M module, Metho
   /**
    * Invokes a method to provide a value. The method's parameters are injected.
    */
-  private final class ProviderMethodBinding<T> extends Binding<T> {
+  private static final class ReflectiveProvidesBinding<T> extends ProvidesBinding<T> {
     private Binding<?>[] parameters;
     private final Method method;
     private final Object instance;
 
-    public ProviderMethodBinding(Method method, String key, Object instance, boolean library) {
-      super(key, null, method.isAnnotationPresent(Singleton.class),
-          moduleClass.getName() + "." + method.getName() + "()");
+    public ReflectiveProvidesBinding(Method method, String key, String moduleClass,
+        Object instance, boolean library) {
+      super(key, method.isAnnotationPresent(Singleton.class), moduleClass, method.getName());
       this.method = method;
       this.instance = instance;
       method.setAccessible(true);
@@ -199,9 +200,5 @@ public ProviderMethodBinding(Method method, String key, Object instance, boolean
     @Override public void injectMembers(T t) {
       throw new AssertionError("Provides method bindings are not MembersInjectors");
     }
-
-    @Override public String toString() {
-      return method.toString();
-    }
   }
 }
