diff --git a/core/src/main/java/dagger/internal/DoubleCheckLazy.java b/core/src/main/java/dagger/internal/DoubleCheckLazy.java
index 6db11f381..d0f102896 100644
--- a/core/src/main/java/dagger/internal/DoubleCheckLazy.java
+++ b/core/src/main/java/dagger/internal/DoubleCheckLazy.java
@@ -57,6 +57,16 @@ public T get() {
     if (provider == null) {
       throw new NullPointerException();
     }
+    if (provider instanceof Lazy) {
+      @SuppressWarnings("unchecked")
+      final Lazy<T> lazy = (Lazy<T>) provider;
+      // Avoids memoizing a value that is already memoized.
+      // NOTE: There is a pathological case where Provider<P> may implement Lazy<L>, but P and L
+      // are different types using covariant return on get(). Right now this is used with
+      // ScopedProvider<T> exclusively, which is implemented such that P and L are always the same
+      // so it will be fine for that case.
+      return lazy;
+    }
     return new DoubleCheckLazy<T>(provider);
   }
 }
diff --git a/core/src/main/java/dagger/internal/ScopedProvider.java b/core/src/main/java/dagger/internal/ScopedProvider.java
index 15917dd27..b25db380a 100644
--- a/core/src/main/java/dagger/internal/ScopedProvider.java
+++ b/core/src/main/java/dagger/internal/ScopedProvider.java
@@ -15,6 +15,7 @@
  */
 package dagger.internal;
 
+import dagger.Lazy;
 import javax.inject.Provider;
 
 /**
@@ -23,7 +24,7 @@
  * @author Gregory Kick
  * @since 2.0
  */
-public final class ScopedProvider<T> implements Provider<T> {
+public final class ScopedProvider<T> implements Provider<T>, Lazy<T> {
   private static final Object UNINITIALIZED = new Object();
 
   private final Factory<T> factory;
