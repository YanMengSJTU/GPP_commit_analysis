diff --git a/java/dagger/internal/codegen/BindingGraphFactory.java b/java/dagger/internal/codegen/BindingGraphFactory.java
index f074f17c7..5d033484b 100644
--- a/java/dagger/internal/codegen/BindingGraphFactory.java
+++ b/java/dagger/internal/codegen/BindingGraphFactory.java
@@ -28,6 +28,7 @@
 import static dagger.internal.codegen.RequestKinds.getRequestKind;
 import static dagger.internal.codegen.Util.reentrantComputeIfAbsent;
 import static dagger.model.BindingKind.DELEGATE;
+import static dagger.model.BindingKind.INJECTION;
 import static dagger.model.BindingKind.OPTIONAL;
 import static dagger.model.BindingKind.SUBCOMPONENT_BUILDER;
 import static java.util.function.Predicate.isEqual;
@@ -523,6 +524,23 @@ private boolean isResolvedInParent(Key requestKey, ContributionBinding binding)
     }
 
     private Optional<Resolver> getOwningResolver(ContributionBinding binding) {
+      // TODO(ronshapiro): extract the different pieces of this method into their own methods
+      if (binding.scope().isPresent() && binding.scope().get().isProductionScope()) {
+        for (Resolver requestResolver : getResolverLineage()) {
+          // Resolve @Inject @ProductionScope bindings at the highest production component.
+          if (binding.kind().equals(INJECTION)
+              && requestResolver.componentDescriptor.kind().isProducer()) {
+            return Optional.of(requestResolver);
+          }
+
+          // Resolve explicit @ProductionScope bindings at the highest component that installs
+          // the binding.
+          if (requestResolver.containsExplicitBinding(binding)) {
+            return Optional.of(requestResolver);
+          }
+        }
+      }
+
       if (binding.scope().isPresent() && binding.scope().get().isReusable()) {
         for (Resolver requestResolver : getResolverLineage().reverse()) {
           // If a @Reusable binding was resolved in an ancestor, use that component.
@@ -537,9 +555,7 @@ private boolean isResolvedInParent(Key requestKey, ContributionBinding binding)
       }
 
       for (Resolver requestResolver : getResolverLineage().reverse()) {
-        if (requestResolver.explicitBindingsSet.contains(binding)
-            || resolverContainsDelegateDeclarationForBinding(requestResolver, binding)
-            || requestResolver.subcomponentDeclarations.containsKey(binding.key())) {
+        if (requestResolver.containsExplicitBinding(binding)) {
           return Optional.of(requestResolver);
         }
       }
@@ -557,6 +573,12 @@ private boolean isResolvedInParent(Key requestKey, ContributionBinding binding)
       return Optional.empty();
     }
 
+    private boolean containsExplicitBinding(ContributionBinding binding) {
+      return explicitBindingsSet.contains(binding)
+          || resolverContainsDelegateDeclarationForBinding(this, binding)
+          || subcomponentDeclarations.containsKey(binding.key());
+    }
+
     /**
      * Returns true if {@code binding} was installed in a module in this resolver's component. If
      * {@link CompilerOptions#floatingBindsMethods()} is enabled, calls {@link
diff --git a/javatests/dagger/internal/codegen/ProductionComponentProcessorTest.java b/javatests/dagger/internal/codegen/ProductionComponentProcessorTest.java
index f0e9b4f94..7e891560b 100644
--- a/javatests/dagger/internal/codegen/ProductionComponentProcessorTest.java
+++ b/javatests/dagger/internal/codegen/ProductionComponentProcessorTest.java
@@ -583,4 +583,137 @@ public void simpleComponent() {
         .inFile(component)
         .onLine(36);
   }
+
+  @Test
+  public void productionScope_provides() {
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.producers.ProductionScope;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "class TestModule {",
+            "  @Provides",
+            "  @ProductionScope",
+            "  static int i() {",
+            "    return 1;",
+            "  }",
+            "}");
+    JavaFileObject parent =
+        JavaFileObjects.forSourceLines(
+            "test.Parent",
+            "package test;",
+            "",
+            "import dagger.producers.ProductionComponent;",
+            "",
+            "@ProductionComponent(modules = TestModule.class)",
+            "interface Parent {",
+            "  Child child();",
+            "}");
+    JavaFileObject child =
+        JavaFileObjects.forSourceLines(
+            "test.Child",
+            "package test;",
+            "",
+            "import dagger.producers.ProductionSubcomponent;",
+            "",
+            "@ProductionSubcomponent(modules = TestModule.class)",
+            "interface Child {",
+            "  int i();",
+            "}");
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(module, parent, child);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerParent")
+        .containsElementsIn(
+            new JavaFileBuilder(compilerMode, "test.DaggerRoot")
+                .addLines(
+                    "package test;",
+                    GENERATED_ANNOTATION,
+                    "public final class DaggerParent implements Parent, CancellationListener {",
+                    "  private final class ChildImpl implements Child, CancellationListener {",
+                    "    @Override",
+                    "    public int i() {")
+                .addLinesIn(
+                    CompilerMode.DEFAULT_MODE, //
+                    "      return DaggerParent.this.iProvider.get();")
+                .addLinesIn(
+                    CompilerMode.FAST_INIT_MODE, //
+                    "      return DaggerParent.this.getInteger();")
+                .addLines(
+                    "    }", //
+                    "  }", //
+                    "}")
+                .build());
+  }
+
+  @Test
+  public void productionScope_injectConstructor() {
+    JavaFileObject productionScoped =
+        JavaFileObjects.forSourceLines(
+            "test.ProductionScoped",
+            "package test;",
+            "",
+            "import dagger.producers.ProductionScope;",
+            "import javax.inject.Inject;",
+            "",
+            "@ProductionScope",
+            "class ProductionScoped {",
+            "  @Inject ProductionScoped() {}",
+            "}");
+    JavaFileObject parent =
+        JavaFileObjects.forSourceLines(
+            "test.Parent",
+            "package test;",
+            "",
+            "import dagger.producers.ProductionComponent;",
+            "",
+            "@ProductionComponent",
+            "interface Parent {",
+            "  Child child();",
+            "}");
+    JavaFileObject child =
+        JavaFileObjects.forSourceLines(
+            "test.Child",
+            "package test;",
+            "",
+            "import dagger.producers.ProductionSubcomponent;",
+            "",
+            "@ProductionSubcomponent",
+            "interface Child {",
+            "  ProductionScoped productionScoped();",
+            "}");
+    Compilation compilation =
+        daggerCompiler()
+            .withOptions(compilerMode.javacopts())
+            .compile(productionScoped, parent, child);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerParent")
+        .containsElementsIn(
+            new JavaFileBuilder(compilerMode, "test.DaggerRoot")
+                .addLines(
+                    "package test;",
+                    GENERATED_ANNOTATION,
+                    "public final class DaggerParent implements Parent, CancellationListener {",
+                    "  private final class ChildImpl implements Child, CancellationListener {",
+                    "    @Override",
+                    "    public ProductionScoped productionScoped() {")
+                .addLinesIn(
+                    CompilerMode.DEFAULT_MODE, //
+                    "      return DaggerParent.this.productionScopedProvider.get();")
+                .addLinesIn(
+                    CompilerMode.FAST_INIT_MODE, //
+                    "      return DaggerParent.this.getProductionScoped();")
+                .addLines(
+                    "    }", //
+                    "  }", //
+                    "}")
+                .build());
+  }
 }
