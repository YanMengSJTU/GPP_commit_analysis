diff --git a/compiler/src/main/java/dagger/internal/codegen/Util.java b/compiler/src/main/java/dagger/internal/codegen/Util.java
index eb8fef2f6..7742067c0 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Util.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Util.java
@@ -16,26 +16,24 @@
  */
 package dagger.internal.codegen;
 
+import static com.google.auto.common.MoreElements.getLocalAndInheritedMethods;
+
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.common.base.Equivalence;
 import com.google.common.base.Equivalence.Wrapper;
 import com.google.common.base.Optional;
-import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.Lists;
-import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
+import java.util.Set;
 import javax.inject.Provider;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.DeclaredType;
-import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
-import javax.lang.model.util.ElementFilter;
 import javax.lang.model.util.Elements;
 
 import static com.google.auto.common.MoreTypes.asDeclared;
@@ -159,67 +157,10 @@ static boolean componentCanMakeNewInstances(TypeElement typeElement) {
     return false;
   }
 
-  /*
-   * Borrowed from AutoValue and slightly modified. TODO(gak): reconcile and put in autocommon.
-   */
-  private static ImmutableList<ExecutableElement> findLocalAndInheritedMethods(Elements elements,
-      TypeElement type) {
-    List<ExecutableElement> methods = Lists.newArrayList();
-    TypeElement objectType = elements.getTypeElement(Object.class.getName());
-    findLocalAndInheritedMethodsRecursive(objectType, elements, type, methods);
-    return ImmutableList.copyOf(methods);
-  }
-
-  private static void findLocalAndInheritedMethodsRecursive(
-      TypeElement objectType,
-      Elements elements,
-      TypeElement type,
-      List<ExecutableElement> methods) {
-    if (objectType.equals(type)) {
-      return;
-    }
-
-    for (TypeMirror superInterface : type.getInterfaces()) {
-      findLocalAndInheritedMethodsRecursive(objectType,
-          elements, MoreElements.asType(MoreTypes.asElement(superInterface)), methods);
-    }
-    if (type.getSuperclass().getKind() != TypeKind.NONE) {
-      // Visit the superclass after superinterfaces so we will always see the implementation of a
-      // method after any interfaces that declared it.
-      findLocalAndInheritedMethodsRecursive(objectType,
-          elements, MoreElements.asType(MoreTypes.asElement(type.getSuperclass())), methods);
-    }
-    // Add each method of this class, and in so doing remove any inherited method it overrides.
-    // This algorithm is quadratic in the number of methods but it's hard to see how to improve
-    // that while still using Elements.overrides.
-    List<ExecutableElement> theseMethods = ElementFilter.methodsIn(type.getEnclosedElements());
-    for (ExecutableElement method : theseMethods) {
-      if (!method.getModifiers().contains(Modifier.PRIVATE)) {
-        boolean alreadySeen = false;
-        for (Iterator<ExecutableElement> methodIter = methods.iterator(); methodIter.hasNext();) {
-          ExecutableElement otherMethod = methodIter.next();
-          if (elements.overrides(method, otherMethod, type)) {
-            methodIter.remove();
-          } else if (method.getSimpleName().equals(otherMethod.getSimpleName())
-              && method.getParameters().equals(otherMethod.getParameters())) {
-            // If we inherit this method on more than one path, we don't want to add it twice.
-            alreadySeen = true;
-          }
-        }
-        if (!alreadySeen) {
-          methods.add(method);
-        }
-      }
-    }
-  }
-
-  /*
-   * Borrowed from AutoValue and slightly modified. TODO(gak): reconcile and put in autocommon.
-   */
   static ImmutableSet<ExecutableElement> getUnimplementedMethods(
       Elements elements, TypeElement type) {
     ImmutableSet.Builder<ExecutableElement> unimplementedMethods = ImmutableSet.builder();
-    List<ExecutableElement> methods = findLocalAndInheritedMethods(elements, type);
+    Set<ExecutableElement> methods = getLocalAndInheritedMethods(type, elements);
     for (ExecutableElement method : methods) {
       if (method.getModifiers().contains(Modifier.ABSTRACT)) {
         unimplementedMethods.add(method);
