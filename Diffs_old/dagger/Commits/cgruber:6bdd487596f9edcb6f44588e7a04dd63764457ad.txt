diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/builder/DepComponent.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/builder/DepComponent.java
new file mode 100644
index 000000000..dadde7b05
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/builder/DepComponent.java
@@ -0,0 +1,22 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package producerstest.builder;
+
+import com.google.common.util.concurrent.ListenableFuture;
+
+interface DepComponent {
+  ListenableFuture<Double> d();
+}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/builder/IntModule.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/builder/IntModule.java
new file mode 100644
index 000000000..7f99836d3
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/builder/IntModule.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package producerstest.builder;
+
+import dagger.Module;
+import dagger.Provides;
+
+@Module
+final class IntModule {
+  @Provides
+  static int i() {
+    return 42;
+  }
+}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/builder/StringModule.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/builder/StringModule.java
new file mode 100644
index 000000000..cdf0793da
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/builder/StringModule.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package producerstest.builder;
+
+import dagger.producers.ProducerModule;
+import dagger.producers.Produces;
+
+@ProducerModule
+final class StringModule {
+  @Produces
+  static String str(int i) {
+    return "arg: " + i;
+  }
+}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/builder/TestComponentWithBuilder.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/builder/TestComponentWithBuilder.java
new file mode 100644
index 000000000..16dc9bad7
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/builder/TestComponentWithBuilder.java
@@ -0,0 +1,37 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package producerstest.builder;
+
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.producers.ProductionComponent;
+import java.util.concurrent.Executor;
+
+@ProductionComponent(
+  modules = {StringModule.class, IntModule.class},
+  dependencies = DepComponent.class
+)
+interface TestComponentWithBuilder {
+  ListenableFuture<String> s();
+  ListenableFuture<Double> d();
+
+  @ProductionComponent.Builder
+  interface Builder {
+    Builder depComponent(DepComponent depComponent);
+    Builder strModule(StringModule strModule);
+    Builder executor(Executor executor);
+    TestComponentWithBuilder build();
+  }
+}
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/builder/ProductionComponentBuilderTest.java b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/builder/ProductionComponentBuilderTest.java
new file mode 100644
index 000000000..715761df4
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/builder/ProductionComponentBuilderTest.java
@@ -0,0 +1,78 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package producerstest.builder;
+
+import com.google.common.util.concurrent.Futures;
+import com.google.common.util.concurrent.ListenableFuture;
+import com.google.common.util.concurrent.MoreExecutors;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assertThat;
+
+/** Tests for {@link dagger.producers.ProductionComponent.Builder}. */
+@RunWith(JUnit4.class)
+public final class ProductionComponentBuilderTest {
+
+  @Test
+  public void successfulBuild() throws Exception {
+    TestComponentWithBuilder component =
+        DaggerTestComponentWithBuilder.builder()
+            .executor(MoreExecutors.directExecutor())
+            .depComponent(depComponent(15.3))
+            .strModule(new StringModule())
+            .build();
+    assertThat(component.s().get()).isEqualTo("arg: 42");
+    assertThat(component.d().get()).isEqualTo(15.3);
+  }
+
+  @Test
+  public void successfulBuild_withMissingZeroArgModule() throws Exception {
+    TestComponentWithBuilder component =
+        DaggerTestComponentWithBuilder.builder()
+            .executor(MoreExecutors.directExecutor())
+            .depComponent(depComponent(15.3))
+            .build();
+    assertThat(component.s().get()).isEqualTo("arg: 42");
+    assertThat(component.d().get()).isEqualTo(15.3);
+  }
+
+  @Test(expected = IllegalStateException.class)
+  public void missingExecutor() {
+    DaggerTestComponentWithBuilder.builder()
+        .depComponent(depComponent(15.3))
+        .strModule(new StringModule())
+        .build();
+  }
+
+  @Test(expected = IllegalStateException.class)
+  public void missingDepComponent() {
+    DaggerTestComponentWithBuilder.builder()
+        .executor(MoreExecutors.directExecutor())
+        .strModule(new StringModule())
+        .build();
+  }
+
+  private static DepComponent depComponent(final double value) {
+    return new DepComponent() {
+      @Override
+      public ListenableFuture<Double> d() {
+        return Futures.immediateFuture(value);
+      }
+    };
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
index 7a5c13520..a292d03a7 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
@@ -73,7 +73,7 @@
   enum Kind {
     COMPONENT(Component.class, Component.Builder.class, true),
     SUBCOMPONENT(Subcomponent.class, Subcomponent.Builder.class, false),
-    PRODUCTION_COMPONENT(ProductionComponent.class, null, true);
+    PRODUCTION_COMPONENT(ProductionComponent.class, ProductionComponent.Builder.class, true);
 
     private final Class<? extends Annotation> annotationType;
     private final Class<? extends Annotation> builderType;
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
index 92fe05913..23a889b33 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -120,6 +120,8 @@ public SourceVersion getSupportedSourceVersion() {
             Produces.class);
     ProducesMethodValidator producesMethodValidator = new ProducesMethodValidator(elements);
     ProductionComponentValidator productionComponentValidator = new ProductionComponentValidator();
+    BuilderValidator productionComponentBuilderValidator =
+        new BuilderValidator(elements, types, ComponentDescriptor.Kind.PRODUCTION_COMPONENT);
 
     Key.Factory keyFactory = new Key.Factory(types, elements);
 
@@ -206,6 +208,7 @@ public SourceVersion getSupportedSourceVersion() {
         new ProductionComponentProcessingStep(
             messager,
             productionComponentValidator,
+            productionComponentBuilderValidator,
             componentHierarchyValidator,
             bindingGraphValidator,
             componentDescriptorFactory,
diff --git a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
index 5a923da45..1f52aca98 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
@@ -243,6 +243,8 @@ static ComponentBuilderMessages builderMsgsFor(ComponentDescriptor.Kind kind) {
         return ComponentBuilderMessages.INSTANCE;
       case SUBCOMPONENT:
         return SubcomponentBuilderMessages.INSTANCE;
+      case PRODUCTION_COMPONENT:
+        return ProductionComponentBuilderMessages.INSTANCE;
       default:
         throw new IllegalStateException(kind.toString());
     }
@@ -374,6 +376,17 @@ String moreThanOneRefToSubcomponent() {
     }
   }
 
+  static final class ProductionComponentBuilderMessages extends ComponentBuilderMessages {
+    @SuppressWarnings("hiding")
+    static final ProductionComponentBuilderMessages INSTANCE =
+        new ProductionComponentBuilderMessages();
+
+    @Override protected String process(String s) {
+      return s.replaceAll("component", "production component")
+          .replaceAll("Component", "ProductionComponent");
+    }
+  }
+
   /**
    * A regular expression to match a small list of specific packages deemed to
    * be unhelpful to display in fully qualified types in error messages.
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProductionComponentProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/ProductionComponentProcessingStep.java
index 56f8ccb17..0581b1bb1 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProductionComponentProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProductionComponentProcessingStep.java
@@ -16,10 +16,13 @@
 package dagger.internal.codegen;
 
 import com.google.auto.common.BasicAnnotationProcessor.ProcessingStep;
+import com.google.auto.common.MoreElements;
 import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Maps;
 import com.google.common.collect.SetMultimap;
 import dagger.producers.ProductionComponent;
 import java.lang.annotation.Annotation;
+import java.util.Map;
 import java.util.Set;
 import javax.annotation.processing.Messager;
 import javax.lang.model.element.Element;
@@ -32,11 +35,14 @@
  * @author Jesse Beder
  */
 final class ProductionComponentProcessingStep extends AbstractComponentProcessingStep {
-  private final ComponentElementValidator componentElementValidator;
+  private final Messager messager;
+  private final ProductionComponentValidator componentValidator;
+  private final BuilderValidator componentBuilderValidator;
 
   ProductionComponentProcessingStep(
       Messager messager,
-      final ProductionComponentValidator componentValidator,
+      ProductionComponentValidator componentValidator,
+      BuilderValidator componentBuilderValidator,
       ComponentHierarchyValidator componentHierarchyValidator,
       BindingGraphValidator bindingGraphValidator,
       ComponentDescriptor.Factory componentDescriptorFactory,
@@ -50,26 +56,48 @@
         componentDescriptorFactory,
         bindingGraphFactory,
         componentGenerator);
-    this.componentElementValidator =
-        new ComponentElementValidator() {
-          @Override
-          boolean validateComponent(TypeElement componentTypeElement, Messager messager) {
-            ValidationReport<TypeElement> validationReport =
-                componentValidator.validate(componentTypeElement);
-            validationReport.printMessagesTo(messager);
-            return validationReport.isClean();
-          }
-        };
+    this.messager = messager;
+    this.componentValidator = componentValidator;
+    this.componentBuilderValidator = componentBuilderValidator;
   }
 
   @Override
   public Set<Class<? extends Annotation>> annotations() {
-    return ImmutableSet.<Class<? extends Annotation>>of(ProductionComponent.class);
+    return ImmutableSet.<Class<? extends Annotation>>of(
+        ProductionComponent.class, ProductionComponent.Builder.class);
   }
 
+  // TODO(beder): Move common logic into the AbstractComponentProcessingStep when implementing
+  // production subcomponents.
   @Override
   protected ComponentElementValidator componentElementValidator(
       SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
-    return componentElementValidator;
+    final Map<Element, ValidationReport<TypeElement>> builderReportsByComponent =
+        processComponentBuilders(elementsByAnnotation.get(ProductionComponent.Builder.class));
+    return new ComponentElementValidator() {
+      @Override
+      boolean validateComponent(TypeElement componentTypeElement, Messager messager) {
+        ValidationReport<TypeElement> validationReport =
+            componentValidator.validate(componentTypeElement);
+        validationReport.printMessagesTo(messager);
+        if (!validationReport.isClean()) {
+          return false;
+        }
+        ValidationReport<?> builderReport = builderReportsByComponent.get(componentTypeElement);
+        return builderReport == null || builderReport.isClean();
+      }
+    };
+  }
+
+  private Map<Element, ValidationReport<TypeElement>> processComponentBuilders(
+      Set<? extends Element> componentBuilderElements) {
+    Map<Element, ValidationReport<TypeElement>> builderReportsByComponent = Maps.newHashMap();
+    for (Element element : componentBuilderElements) {
+      ValidationReport<TypeElement> report =
+          componentBuilderValidator.validate(MoreElements.asType(element));
+      report.printMessagesTo(messager);
+      builderReportsByComponent.put(element.getEnclosingElement(), report);
+    }
+    return builderReportsByComponent;
   }
 }
diff --git a/producers/src/main/java/dagger/producers/ProductionComponent.java b/producers/src/main/java/dagger/producers/ProductionComponent.java
index a6009c5b3..8ccdb4433 100644
--- a/producers/src/main/java/dagger/producers/ProductionComponent.java
+++ b/producers/src/main/java/dagger/producers/ProductionComponent.java
@@ -80,4 +80,42 @@
    * A list of types that are to be used as component dependencies.
    */
   Class<?>[] dependencies() default {};
+
+  /**
+   * A builder for a component. Components may have a single nested static abstract class or
+   * interface annotated with {@code @ProductionComponent.Builder}. If they do, then the component's
+   * generated builder will match the API in the type.  Builders must follow some rules:
+   * <ul>
+   * <li> A single abstract method with no arguments must exist, and must return the component.
+   *      (This is typically the {@code build()} method.)
+   * <li> All other abstract methods must take a single argument and must return void,
+   *      the builder type, or a supertype of the builder.
+   * <li> There <b>must</b> be an abstract method whose parameter is
+   *      {@link java.util.concurrent.Executor}.
+   * <li> Each component dependency <b>must</b> have an abstract setter method.
+   * <li> Each module dependency that Dagger can't instantiate itself (i.e., the module
+   *      doesn't have a visible no-args constructor) <b>must</b> have an abstract setter method.
+   *      Other module dependencies (ones that Dagger can instantiate) are allowed, but not
+   *      required.
+   * <li> Non-abstract methods are allowed, but ignored as far as validation and builder generation
+   *      are concerned.
+   * </ul>
+   *
+   * For example, this could be a valid {@code ProductionComponent} with a builder: <pre><code>
+   * {@literal @}ProductionComponent(modules = {BackendModule.class, FrontendModule.class})
+   * interface MyComponent {
+   *   {@literal ListenableFuture<MyWidget>} myWidget();
+   *
+   *   {@literal @}ProductionComponent.Builder
+   *   interface Builder {
+   *     MyComponent build();
+   *     Builder executor(Executor executor);
+   *     Builder backendModule(BackendModule bm);
+   *     Builder frontendModule(FrontendModule fm);
+   *   }
+   * }</code></pre>
+   */
+  @Target(TYPE)
+  @Documented
+  @interface Builder {}
 }
