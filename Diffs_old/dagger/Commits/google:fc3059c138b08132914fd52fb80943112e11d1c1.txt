diff --git a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
index 2b53bb55d..333969e02 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
@@ -153,6 +153,9 @@ static String inconsistentMapKeyAnnotationsError(String key) {
   static final String BINDING_METHOD_MUST_RETURN_A_VALUE =
       "@%s methods must return a value (not void).";
 
+  static final String BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES =
+      "@%s methods must not return framework types.";
+
   static final String BINDING_METHOD_ABSTRACT = "@%s methods cannot be abstract";
 
   static final String BIND_METHOD_NOT_ABSTRACT = "@Bind methods must be abstract";
diff --git a/compiler/src/main/java/dagger/internal/codegen/FrameworkTypes.java b/compiler/src/main/java/dagger/internal/codegen/FrameworkTypes.java
index e565da792..84aca3bb7 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FrameworkTypes.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FrameworkTypes.java
@@ -17,26 +17,43 @@
 
 import com.google.auto.common.MoreTypes;
 import com.google.common.collect.ImmutableSet;
+import dagger.Lazy;
+import dagger.MembersInjector;
 import dagger.producers.Produced;
 import dagger.producers.Producer;
+import java.util.Set;
+import javax.inject.Provider;
 import javax.lang.model.type.TypeMirror;
 
+import static com.google.auto.common.MoreTypes.isType;
+
 /**
  * A collection of utility methods for dealing with Dagger framework types. A framework type is any
  * type that the framework itself defines.
  */
 final class FrameworkTypes {
+  private static final ImmutableSet<Class<?>> PROVISION_TYPES =
+      ImmutableSet.of(Provider.class, Lazy.class, MembersInjector.class);
+
   // NOTE(beder): ListenableFuture is not considered a producer framework type because it is not
   // defined by the framework, so we can't treat it specially in ordinary Dagger.
-  private static final ImmutableSet<Class<?>> PRODUCER_TYPES =
+  private static final ImmutableSet<Class<?>> PRODUCTION_TYPES =
       ImmutableSet.of(Produced.class, Producer.class);
 
   /** Returns true if the type represents a producer-related framework type. */
   static boolean isProducerType(TypeMirror type) {
-    if (!MoreTypes.isType(type)) {
-      return false;
-    }
-    for (Class<?> clazz : PRODUCER_TYPES) {
+    return isType(type) && typeIsOneOf(PRODUCTION_TYPES, type);
+  }
+
+  /** Returns true if the type represents a framework type. */
+  static boolean isFrameworkType(TypeMirror type) {
+    return isType(type)
+        && (typeIsOneOf(PROVISION_TYPES, type)
+            || typeIsOneOf(PRODUCTION_TYPES, type));
+  }
+
+  private static boolean typeIsOneOf(Set<Class<?>> classes, TypeMirror type) {
+    for (Class<?> clazz : classes) {
       if (MoreTypes.isTypeOf(clazz, type)) {
         return true;
       }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProducesMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/ProducesMethodValidator.java
index 2771aa161..6b05b6e6a 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProducesMethodValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProducesMethodValidator.java
@@ -37,6 +37,7 @@
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_ABSTRACT;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_MUST_RETURN_A_VALUE;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_NOT_IN_MODULE;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_NOT_MAP_HAS_MAP_KEY;
@@ -116,6 +117,11 @@ private TypeElement getSetElement() {
           formatErrorMessage(BINDING_METHOD_MUST_RETURN_A_VALUE), producesMethodElement);
     }
 
+    if (FrameworkTypes.isFrameworkType(returnType)) {
+      builder.addError(
+          formatErrorMessage(BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES), producesMethodElement);
+    }
+
     TypeMirror exceptionType = elements.getTypeElement(Exception.class.getCanonicalName()).asType();
     TypeMirror errorType = elements.getTypeElement(Error.class.getCanonicalName()).asType();
     for (TypeMirror thrownType : producesMethodElement.getThrownTypes()) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java
index 43b8562ea..785f43331 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvidesMethodValidator.java
@@ -36,6 +36,7 @@
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_ABSTRACT;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_MUST_RETURN_A_VALUE;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_NOT_IN_MODULE;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_NOT_MAP_HAS_MAP_KEY;
@@ -78,6 +79,8 @@ private TypeElement getSetElement() {
     ValidationReport.Builder<ExecutableElement> builder =
         ValidationReport.about(providesMethodElement);
 
+    /* this cast isn't actually guaranteed to be safe, but since we've already run superficial
+     * validation, it shouldn't ever fail */
     Provides providesAnnotation = providesMethodElement.getAnnotation(Provides.class);
     checkArgument(providesAnnotation != null);
 
@@ -124,7 +127,16 @@ private TypeElement getSetElement() {
     validateMethodQualifiers(builder, providesMethodElement);
 
     switch (providesAnnotation.type()) {
-      case UNIQUE: // fall through
+      case UNIQUE:
+        /* Validate that a unique binding is not attempting to bind a framework type. This
+         * validation is only appropriate for unique bindings because multibindings may collect
+         * framework types.  E.g. Set<Provider<Foo>> is perfectly reasonable. */
+        if (FrameworkTypes.isFrameworkType(returnType)) {
+          builder.addError(
+              formatErrorMessage(BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES),
+              providesMethodElement);
+        }
+        // fall through
       case SET:
         validateReturnType(Provides.class, builder, returnType);
         break;
diff --git a/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java b/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
index 0ecf8c017..04a5dccc0 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
@@ -30,6 +30,7 @@
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_ABSTRACT;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_MULTIPLE_QUALIFIERS;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_MUST_RETURN_A_VALUE;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_NOT_IN_MODULE;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_PRIVATE;
@@ -133,6 +134,45 @@ private String formatModuleErrorMessage(String msg) {
         .withErrorContaining(formatErrorMessage(BINDING_METHOD_MUST_RETURN_A_VALUE));
   }
 
+  @Test public void providesMethodFrameworkType() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.Lazy;",
+        "import dagger.MembersInjector;",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import dagger.producers.Producer;",
+        "import dagger.producers.Produced;",
+        "import javax.inject.Provider;",
+        "",
+        "@Module",
+        "final class TestModule {",
+        "  @Provides Provider<String> provideProvider() {}",
+        "  @Provides Lazy<String> provideLazy() {}",
+        "  @Provides MembersInjector<String> provideMembersInjector() {}",
+        "  @Provides Producer<String> provideProducer() {}",
+        "  @Provides Produced<String> provideProduced() {}",
+        "}");
+    assertAbout(javaSource()).that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(formatErrorMessage(BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES))
+        .in(moduleFile).onLine(13)
+        .and()
+        .withErrorContaining(formatErrorMessage(BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES))
+        .in(moduleFile).onLine(14)
+        .and()
+        .withErrorContaining(formatErrorMessage(BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES))
+        .in(moduleFile).onLine(15)
+        .and()
+        .withErrorContaining(formatErrorMessage(BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES))
+        .in(moduleFile).onLine(16)
+        .and()
+        .withErrorContaining(formatErrorMessage(BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES))
+        .in(moduleFile).onLine(17);
+  }
+
   @Test public void providesMethodWithTypeParameter() {
     JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
         "package test;",
diff --git a/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java b/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
index e5da7cce1..bee690f7d 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
@@ -28,6 +28,7 @@
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_ABSTRACT;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_MULTIPLE_QUALIFIERS;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_MUST_RETURN_A_VALUE;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_NOT_IN_MODULE;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_PRIVATE;
@@ -120,6 +121,45 @@ private String formatModuleErrorMessage(String msg) {
         .withErrorContaining(formatErrorMessage(BINDING_METHOD_MUST_RETURN_A_VALUE));
   }
 
+  @Test public void producesMethodFrameworkType() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.Lazy;",
+        "import dagger.MembersInjector;",
+        "import dagger.producers.ProducerModule;",
+        "import dagger.producers.Produced;",
+        "import dagger.producers.Producer;",
+        "import dagger.producers.Produces;",
+        "import javax.inject.Provider;",
+        "",
+        "@ProducerModule",
+        "final class TestModule {",
+        "  @Produces Provider<String> produceProvider() {}",
+        "  @Produces Lazy<String> produceLazy() {}",
+        "  @Produces MembersInjector<String> produceMembersInjector() {}",
+        "  @Produces Producer<String> produceProducer() {}",
+        "  @Produces Produced<String> produceProduced() {}",
+        "}");
+    assertAbout(javaSource()).that(moduleFile)
+    .processedWith(new ComponentProcessor())
+    .failsToCompile()
+    .withErrorContaining(formatErrorMessage(BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES))
+    .in(moduleFile).onLine(13)
+    .and()
+    .withErrorContaining(formatErrorMessage(BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES))
+    .in(moduleFile).onLine(14)
+    .and()
+    .withErrorContaining(formatErrorMessage(BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES))
+    .in(moduleFile).onLine(15)
+    .and()
+    .withErrorContaining(formatErrorMessage(BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES))
+    .in(moduleFile).onLine(16)
+    .and()
+    .withErrorContaining(formatErrorMessage(BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES))
+    .in(moduleFile).onLine(17);
+  }
+
   @Test public void producesMethodReturnRawFuture() {
     JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
         "package test;",
