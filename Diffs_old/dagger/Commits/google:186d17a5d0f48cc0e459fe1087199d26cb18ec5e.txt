diff --git a/java/dagger/internal/codegen/AbstractComponentWriter.java b/java/dagger/internal/codegen/AbstractComponentWriter.java
index b930315cb..8ba636373 100644
--- a/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -595,22 +595,14 @@ private void writeInitializeAndInterfaceMethods() {
     component.addMethods(interfaceMethods);
   }
 
-  // TODO(user): Instead of this method knowing about all BindingExpression types, move this
-  // onto a method on different BindingExpression subtypes.
+  // TODO(user): Move this method onto FieldBasedBindingExpression or subtypes of it.
   @Override
-  public CodeBlock getFieldInitialization(BindingExpression bindingExpression) {
-    // If there is no field, don't initialize it.
-    checkState(bindingExpression.hasFieldSpec());
-
+  public CodeBlock getFieldInitialization(FrameworkInstanceBindingExpression bindingExpression) {
     if (bindingExpression.isProducerFromProvider()) {
       return getRequestFulfillment(
           FrameworkDependency.create(bindingExpression.bindingKey(), PRODUCTION));
     }
 
-    // We don't have to check whether we own the field because this method is called only for
-    // the bindingExpressions map values). That map is only populated for bindings we own, while
-    // getBindingExpression(BindingKey) may return those owned by parents.
-
     switch (bindingExpression.bindingKey().kind()) {
       case CONTRIBUTION:
         return contributionBindingInitialization(bindingExpression);
diff --git a/java/dagger/internal/codegen/BindingExpression.java b/java/dagger/internal/codegen/BindingExpression.java
index d84c86a85..0aa1cc973 100644
--- a/java/dagger/internal/codegen/BindingExpression.java
+++ b/java/dagger/internal/codegen/BindingExpression.java
@@ -16,11 +16,9 @@
 
 package dagger.internal.codegen;
 
-import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static dagger.internal.codegen.AnnotationSpecs.Suppression.RAWTYPES;
 import static dagger.internal.codegen.MemberSelect.staticMemberSelect;
-import static dagger.internal.codegen.TypeNames.DELEGATE_FACTORY;
 import static dagger.internal.codegen.TypeNames.PRODUCER;
 import static javax.lang.model.element.Modifier.PRIVATE;
 
@@ -28,152 +26,35 @@
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
 import com.squareup.javapoet.FieldSpec;
-import dagger.internal.DelegateFactory;
 import java.util.Optional;
 import javax.lang.model.util.Elements;
 
 /** The code expressions to declare, initialize, and/or access a binding in a component. */
-final class BindingExpression extends RequestFulfillment {
-  private final Optional<FieldSpec> fieldSpec;
-  private final RequestFulfillment requestFulfillmentDelegate;
-  private final HasBindingExpressions hasBindingExpressions;
-  private final boolean isProducerFromProvider;
-  private InitializationState fieldInitializationState = InitializationState.UNINITIALIZED;
+abstract class BindingExpression {
+  private final BindingKey bindingKey;
 
-  private BindingExpression(
-      RequestFulfillment requestFulfillmentDelegate,
-      Optional<FieldSpec> fieldSpec,
-      HasBindingExpressions hasBindingExpressions,
-      boolean isProducerFromProvider) {
-    super(requestFulfillmentDelegate.bindingKey());
-    this.requestFulfillmentDelegate = requestFulfillmentDelegate;
-    this.fieldSpec = fieldSpec;
-    this.hasBindingExpressions = hasBindingExpressions;
-    this.isProducerFromProvider = isProducerFromProvider;
+  BindingExpression(BindingKey bindingKey) {
+    this.bindingKey = checkNotNull(bindingKey);
   }
 
-  @Override
-  CodeBlock getSnippetForDependencyRequest(DependencyRequest request, ClassName requestingClass) {
-    // TODO(user): We don't always have to initialize ourselves depending on the request and
-    // inlining.
-    maybeInitializeField();
-    return requestFulfillmentDelegate.getSnippetForDependencyRequest(request, requestingClass);
-  }
-
-  @Override
-  CodeBlock getSnippetForFrameworkDependency(
-      FrameworkDependency frameworkDependency, ClassName requestingClass) {
-    maybeInitializeField();
-    return requestFulfillmentDelegate.getSnippetForFrameworkDependency(
-        frameworkDependency, requestingClass);
-  }
-
-  /** Returns {@code true} if this binding expression has a field. */
-  boolean hasFieldSpec() {
-    return fieldSpec.isPresent();
+  /** The key for which this instance can fulfill requests. */
+  final BindingKey bindingKey() {
+    return bindingKey;
   }
 
   /**
-   * Returns the name of the binding's underlying field.
-   *
-   * @throws UnsupportedOperationException if {@link #hasFieldSpec()} is {@code false}
+   * Returns the {@link CodeBlock} that implements the operation represented by the {@link
+   * DependencyRequest request} from the {@code requestingClass}.
    */
-  private String fieldName() {
-    checkHasField();
-    return fieldSpec.get().name;
-  }
-
-  /** Returns true if this binding expression represents a producer from provider. */
-  // TODO(user): remove this and represent this via a subtype of BindingExpression
-  boolean isProducerFromProvider() {
-    return isProducerFromProvider;
-  }
+  abstract CodeBlock getSnippetForDependencyRequest(
+      DependencyRequest request, ClassName requestingClass);
 
   /**
-   * Sets the initialization state for the binding's underlying field. Only valid for field types.
-   *
-   * @throws UnsupportedOperationException if {@link #hasFieldSpec()} is {@code false}
+   * Returns the {@link CodeBlock} that references the {@link FrameworkDependency} as accessed from
+   * the {@code requestingClass}.
    */
-  private void setFieldInitializationState(InitializationState fieldInitializationState) {
-    checkHasField();
-    checkArgument(this.fieldInitializationState.compareTo(fieldInitializationState) < 0);
-    this.fieldInitializationState = fieldInitializationState;
-  }
-
-  private void checkHasField() {
-    if (!hasFieldSpec()) {
-      throw new UnsupportedOperationException();
-    }
-  }
-
-  // Adds our field and initialization of our field to the component.
-  private void maybeInitializeField() {
-    if (!hasFieldSpec()) {
-      return;
-    }
-    switch (fieldInitializationState) {
-      case UNINITIALIZED:
-        // Change our state in case we are recursively invoked via initializeBindingExpression
-        setFieldInitializationState(InitializationState.INITIALIZING);
-        CodeBlock.Builder codeBuilder = CodeBlock.builder();
-        CodeBlock initCode =
-            CodeBlock.of(
-                "this.$L = $L;",
-                fieldName(),
-                checkNotNull(hasBindingExpressions.getFieldInitialization(this)));
-
-        if (fieldInitializationState == InitializationState.DELEGATED) {
-          // If we were recursively invoked, set the delegate factory as part of our initialization
-          String delegateFactoryVariable = fieldName() + "Delegate";
-          codeBuilder
-              .add("$1T $2L = ($1T) $3L;", DELEGATE_FACTORY, delegateFactoryVariable, fieldName())
-              .add(initCode)
-              .add("$L.setDelegatedProvider($L);", delegateFactoryVariable, fieldName())
-              .build();
-        } else {
-          codeBuilder.add(initCode);
-        }
-        hasBindingExpressions.addInitialization(codeBuilder.build());
-        hasBindingExpressions.addField(fieldSpec.get());
-
-        setFieldInitializationState(InitializationState.INITIALIZED);
-        break;
-
-      case INITIALIZING:
-        // We were recursively invoked, so create a delegate factory instead
-        hasBindingExpressions.addInitialization(
-            CodeBlock.of("this.$L = new $T();", fieldName(), DELEGATE_FACTORY));
-        setFieldInitializationState(InitializationState.DELEGATED);
-        break;
-
-      case DELEGATED:
-      case INITIALIZED:
-        break;
-      default:
-        throw new AssertionError("Unhandled initialization state: " + fieldInitializationState);
-    }
-  }
-
-  /** Initialization state for a factory field. */
-  enum InitializationState {
-    /** The field is {@code null}. */
-    UNINITIALIZED,
-
-    /**
-     * The field's dependencies are being set up. If the field is needed in this state, use a {@link
-     * DelegateFactory}.
-     */
-    INITIALIZING,
-
-    /**
-     * The field's dependencies are being set up, but the field can be used because it has already
-     * been set to a {@link DelegateFactory}.
-     */
-    DELEGATED,
-
-    /** The field is set to an undelegated factory. */
-    INITIALIZED;
-  }
+  abstract CodeBlock getSnippetForFrameworkDependency(
+      FrameworkDependency frameworkDependency, ClassName requestingClass);
 
   /** Factory for building a {@link BindingExpression}. */
   static final class Factory {
@@ -206,33 +87,26 @@ private void maybeInitializeField() {
     BindingExpression forField(ResolvedBindings resolvedBindings) {
       FieldSpec fieldSpec = generateFrameworkField(resolvedBindings, Optional.empty());
       MemberSelect memberSelect = MemberSelect.localField(componentName, fieldSpec.name);
-      return new BindingExpression(
-          createRequestFulfillment(resolvedBindings, memberSelect),
-          Optional.of(fieldSpec),
-          hasBindingExpressions,
-          false);
+      return create(resolvedBindings, Optional.of(fieldSpec), memberSelect);
     }
 
     BindingExpression forProducerFromProviderField(ResolvedBindings resolvedBindings) {
       FieldSpec fieldSpec = generateFrameworkField(resolvedBindings, Optional.of(PRODUCER));
       MemberSelect memberSelect = MemberSelect.localField(componentName, fieldSpec.name);
-      return new BindingExpression(
-          new ProducerFieldRequestFulfillment(resolvedBindings.bindingKey(), memberSelect),
+      return new ProducerBindingExpression(
+          resolvedBindings.bindingKey(),
           Optional.of(fieldSpec),
           hasBindingExpressions,
+          memberSelect,
           true);
     }
 
-    /** Creates a binding expression for a static method call. */
+    /**
+     * Creates a binding expression for a static method call.
+     */
     Optional<BindingExpression> forStaticMethod(ResolvedBindings resolvedBindings) {
-      Optional<MemberSelect> memberSelect = staticMemberSelect(resolvedBindings);
-      return memberSelect.map(
-          value ->
-              new BindingExpression(
-                  createRequestFulfillment(resolvedBindings, value),
-                  Optional.empty(),
-                  hasBindingExpressions,
-                  false));
+      return staticMemberSelect(resolvedBindings)
+          .map(memberSelect -> create(resolvedBindings, Optional.empty(), memberSelect));
     }
 
     /**
@@ -265,54 +139,54 @@ private boolean useRawType(ResolvedBindings resolvedBindings) {
           && !bindingPackage.get().equals(componentName.packageName());
     }
 
-    private RequestFulfillment createRequestFulfillment(
-        ResolvedBindings resolvedBindings, MemberSelect memberSelect) {
+    private BindingExpression create(
+        ResolvedBindings resolvedBindings,
+        Optional<FieldSpec> fieldSpec,
+        MemberSelect memberSelect) {
       BindingKey bindingKey = resolvedBindings.bindingKey();
       switch (resolvedBindings.bindingType()) {
         case MEMBERS_INJECTION:
-          return new MembersInjectorRequestFulfillment(bindingKey, memberSelect);
+          return new MembersInjectorBindingExpression(
+              bindingKey, fieldSpec, hasBindingExpressions, memberSelect);
         case PRODUCTION:
-          return new ProducerFieldRequestFulfillment(bindingKey, memberSelect);
+          return new ProducerBindingExpression(
+              bindingKey, fieldSpec, hasBindingExpressions, memberSelect, false);
         case PROVISION:
           ProvisionBinding provisionBinding =
               (ProvisionBinding) resolvedBindings.contributionBinding();
 
-          ProviderFieldRequestFulfillment providerFieldRequestFulfillment =
-              new ProviderFieldRequestFulfillment(bindingKey, memberSelect);
+          ProviderBindingExpression providerBindingExpression =
+              new ProviderBindingExpression(
+                  bindingKey, fieldSpec, hasBindingExpressions, memberSelect);
 
           switch (provisionBinding.bindingKind()) {
             case SUBCOMPONENT_BUILDER:
-              return new SubcomponentBuilderRequestFulfillment(
-                  bindingKey, providerFieldRequestFulfillment, subcomponentNames.get(bindingKey));
+              return new SubcomponentBuilderBindingExpression(
+                  providerBindingExpression, subcomponentNames.get(bindingKey));
             case SYNTHETIC_MULTIBOUND_SET:
-              return new SetBindingRequestFulfillment(
-                  bindingKey,
+              return new SetBindingExpression(
                   provisionBinding,
                   graph,
                   hasBindingExpressions,
-                  providerFieldRequestFulfillment,
+                  providerBindingExpression,
                   elements);
             case SYNTHETIC_OPTIONAL_BINDING:
-              return new OptionalBindingRequestFulfillment(
-                  bindingKey,
-                  provisionBinding,
-                  providerFieldRequestFulfillment,
-                  hasBindingExpressions);
+              return new OptionalBindingExpression(
+                  provisionBinding, providerBindingExpression, hasBindingExpressions);
             case INJECTION:
             case PROVISION:
               if (!provisionBinding.scope().isPresent()
                   && !provisionBinding.requiresModuleInstance()
                   && provisionBinding.bindingElement().isPresent()) {
-                return new SimpleMethodRequestFulfillment(
+                return new SimpleMethodBindingExpression(
                     compilerOptions,
-                    bindingKey,
                     provisionBinding,
-                    providerFieldRequestFulfillment,
+                    providerBindingExpression,
                     hasBindingExpressions);
               }
               // fall through
             default:
-              return providerFieldRequestFulfillment;
+              return providerBindingExpression;
           }
         default:
           throw new AssertionError();
diff --git a/java/dagger/internal/codegen/FrameworkInstanceBindingExpression.java b/java/dagger/internal/codegen/FrameworkInstanceBindingExpression.java
new file mode 100644
index 000000000..2cd0b9118
--- /dev/null
+++ b/java/dagger/internal/codegen/FrameworkInstanceBindingExpression.java
@@ -0,0 +1,163 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.base.Preconditions.checkArgument;
+import static dagger.internal.Preconditions.checkNotNull;
+import static dagger.internal.codegen.TypeNames.DELEGATE_FACTORY;
+
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.FieldSpec;
+import dagger.internal.DelegateFactory;
+import java.util.Optional;
+
+/**
+ * A {@link BindingExpression} that is always satisfied in components by using an instance of a
+ * {@link FrameworkType}.
+ */
+// TODO(user): consider removing this class and making it a strategy that is created by
+// {Provider,Producer,MembersInjector}BindingExpression
+abstract class FrameworkInstanceBindingExpression extends BindingExpression {
+  private final Optional<FieldSpec> fieldSpec;
+  private final HasBindingExpressions hasBindingExpressions;
+  private final MemberSelect memberSelect;
+  private InitializationState fieldInitializationState = InitializationState.UNINITIALIZED;
+
+  protected FrameworkInstanceBindingExpression(
+      BindingKey bindingKey,
+      Optional<FieldSpec> fieldSpec,
+      HasBindingExpressions hasBindingExpressions,
+      MemberSelect memberSelect) {
+    super(bindingKey);
+    this.hasBindingExpressions = hasBindingExpressions;
+    this.memberSelect = memberSelect;
+    this.fieldSpec = fieldSpec;
+  }
+
+  /**
+   * The expression for the framework instance for this binding. If the instance comes from a
+   * component field, it will be {@link HasBindingExpressions#addInitialization(CodeBlock)
+   * initialized} and {@link HasBindingExpressions#addField(FieldSpec) added} to the component the
+   * first time this method is invoked.
+   */
+  final CodeBlock getFrameworkTypeInstance(ClassName requestingClass) {
+    maybeInitializeField();
+    return memberSelect.getExpressionFor(requestingClass);
+  }
+
+  /**
+   * Returns the name of the binding's underlying field.
+   *
+   * @throws UnsupportedOperationException if no field exists
+   */
+  // TODO(ronshapiro): remove this in favor of $N in a CodeBlock
+  private String fieldName() {
+    checkHasField();
+    return fieldSpec.get().name;
+  }
+
+  /** Returns true if this binding expression represents a producer from provider. */
+  // TODO(user): remove this and represent this via a subtype of BindingExpression
+  abstract boolean isProducerFromProvider();
+
+  /**
+   * Sets the initialization state for the binding's underlying field. Only valid for field types.
+   *
+   * @throws UnsupportedOperationException if no field exists
+   */
+  private void setFieldInitializationState(InitializationState fieldInitializationState) {
+    checkHasField();
+    checkArgument(this.fieldInitializationState.compareTo(fieldInitializationState) < 0);
+    this.fieldInitializationState = fieldInitializationState;
+  }
+
+  private void checkHasField() {
+    if (!fieldSpec.isPresent()) {
+      throw new UnsupportedOperationException();
+    }
+  }
+
+  // Adds our field and initialization of our field to the component.
+  private void maybeInitializeField() {
+    if (!fieldSpec.isPresent()) {
+      return;
+    }
+    switch (fieldInitializationState) {
+      case UNINITIALIZED:
+        // Change our state in case we are recursively invoked via initializeBindingExpression
+        setFieldInitializationState(InitializationState.INITIALIZING);
+        CodeBlock.Builder codeBuilder = CodeBlock.builder();
+        CodeBlock initCode =
+            CodeBlock.of(
+                "this.$L = $L;",
+                fieldName(),
+                checkNotNull(hasBindingExpressions.getFieldInitialization(this)));
+
+        if (fieldInitializationState == InitializationState.DELEGATED) {
+          // If we were recursively invoked, set the delegate factory as part of our initialization
+          String delegateFactoryVariable = fieldName() + "Delegate";
+          codeBuilder
+              .add("$1T $2L = ($1T) $3L;", DELEGATE_FACTORY, delegateFactoryVariable, fieldName())
+              .add(initCode)
+              .add("$L.setDelegatedProvider($L);", delegateFactoryVariable, fieldName())
+              .build();
+        } else {
+          codeBuilder.add(initCode);
+        }
+        hasBindingExpressions.addInitialization(codeBuilder.build());
+        hasBindingExpressions.addField(fieldSpec.get());
+
+        setFieldInitializationState(InitializationState.INITIALIZED);
+        break;
+
+      case INITIALIZING:
+        // We were recursively invoked, so create a delegate factory instead
+        hasBindingExpressions.addInitialization(
+            CodeBlock.of("this.$L = new $T();", fieldName(), DELEGATE_FACTORY));
+        setFieldInitializationState(InitializationState.DELEGATED);
+        break;
+
+      case DELEGATED:
+      case INITIALIZED:
+        break;
+      default:
+        throw new AssertionError("Unhandled initialization state: " + fieldInitializationState);
+    }
+  }
+
+  /** Initialization state for a factory field. */
+  private enum InitializationState {
+    /** The field is {@code null}. */
+    UNINITIALIZED,
+
+    /**
+     * The field's dependencies are being set up. If the field is needed in this state, use a {@link
+     * DelegateFactory}.
+     */
+    INITIALIZING,
+
+    /**
+     * The field's dependencies are being set up, but the field can be used because it has already
+     * been set to a {@link DelegateFactory}.
+     */
+    DELEGATED,
+
+    /** The field is set to an undelegated factory. */
+    INITIALIZED;
+  }
+}
diff --git a/java/dagger/internal/codegen/HasBindingExpressions.java b/java/dagger/internal/codegen/HasBindingExpressions.java
index 49fb9db76..b27705f0e 100644
--- a/java/dagger/internal/codegen/HasBindingExpressions.java
+++ b/java/dagger/internal/codegen/HasBindingExpressions.java
@@ -44,7 +44,7 @@ CodeBlock getRequestFulfillmentWithPossibleRawtypeCast(
       DependencyRequest dependencyRequest, ClassName requestingClass);
 
   /** Returns the expression used to initialize a binding expression field. */
-  CodeBlock getFieldInitialization(BindingExpression bindingExpression);
+  CodeBlock getFieldInitialization(FrameworkInstanceBindingExpression bindingExpression);
 
   /** Adds the given field to the component. */
   void addField(FieldSpec fieldSpec);
diff --git a/java/dagger/internal/codegen/MembersInjectorRequestFulfillment.java b/java/dagger/internal/codegen/MembersInjectorBindingExpression.java
similarity index 65%
rename from java/dagger/internal/codegen/MembersInjectorRequestFulfillment.java
rename to java/dagger/internal/codegen/MembersInjectorBindingExpression.java
index 4f9e9550c..11851938e 100644
--- a/java/dagger/internal/codegen/MembersInjectorRequestFulfillment.java
+++ b/java/dagger/internal/codegen/MembersInjectorBindingExpression.java
@@ -17,34 +17,38 @@
 package dagger.internal.codegen;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static dagger.internal.codegen.BindingKey.Kind.MEMBERS_INJECTION;
 
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.FieldSpec;
 import dagger.internal.codegen.DependencyRequest.Kind;
+import java.util.Optional;
 
-/** Fulfills requests for {@link MembersInjectionBinding} instances. */
-final class MembersInjectorRequestFulfillment extends RequestFulfillment {
-  private final MemberSelect membersInjectorFieldSelect;
-
-  MembersInjectorRequestFulfillment(
-      BindingKey bindingKey, MemberSelect membersInjectorFieldSelect) {
-    super(bindingKey);
-    checkArgument(bindingKey.kind().equals(MEMBERS_INJECTION));
-    this.membersInjectorFieldSelect = membersInjectorFieldSelect;
+final class MembersInjectorBindingExpression extends FrameworkInstanceBindingExpression {
+  MembersInjectorBindingExpression(
+      BindingKey bindingKey,
+      Optional<FieldSpec> fieldSpec,
+      HasBindingExpressions hasBindingExpressions,
+      MemberSelect memberSelect) {
+    super(bindingKey, fieldSpec, hasBindingExpressions, memberSelect);
   }
 
   @Override
   public CodeBlock getSnippetForDependencyRequest(
       DependencyRequest request, ClassName requestingClass) {
     checkArgument(request.kind().equals(Kind.MEMBERS_INJECTOR));
-    return membersInjectorFieldSelect.getExpressionFor(requestingClass);
+    return getFrameworkTypeInstance(requestingClass);
   }
 
   @Override
   CodeBlock getSnippetForFrameworkDependency(
       FrameworkDependency frameworkDependency, ClassName requestingClass) {
     checkArgument(frameworkDependency.bindingType().equals(BindingType.MEMBERS_INJECTION));
-    return membersInjectorFieldSelect.getExpressionFor(requestingClass);
+    return getFrameworkTypeInstance(requestingClass);
+  }
+
+  @Override
+  boolean isProducerFromProvider() {
+    return false;
   }
 }
diff --git a/java/dagger/internal/codegen/OptionalBindingRequestFulfillment.java b/java/dagger/internal/codegen/OptionalBindingExpression.java
similarity index 88%
rename from java/dagger/internal/codegen/OptionalBindingRequestFulfillment.java
rename to java/dagger/internal/codegen/OptionalBindingExpression.java
index ed64787d0..822e0afe7 100644
--- a/java/dagger/internal/codegen/OptionalBindingRequestFulfillment.java
+++ b/java/dagger/internal/codegen/OptionalBindingExpression.java
@@ -24,19 +24,18 @@
 import dagger.internal.codegen.OptionalType.OptionalKind;
 
 /**
- * A {@link RequestFulfillment} for {@link
- * dagger.internal.codegen.ContributionBinding.Kind#SYNTHETIC_OPTIONAL_BINDING}
+ * A {@link BindingExpression} for {@link
+ * ContributionBinding.Kind#SYNTHETIC_OPTIONAL_BINDING}
  */
-final class OptionalBindingRequestFulfillment extends SimpleInvocationRequestFulfillment {
+final class OptionalBindingExpression extends SimpleInvocationBindingExpression {
   private final ProvisionBinding binding;
   private final HasBindingExpressions hasBindingExpressions;
 
-  OptionalBindingRequestFulfillment(
-      BindingKey bindingKey,
+  OptionalBindingExpression(
       ProvisionBinding binding,
-      RequestFulfillment delegate,
+      BindingExpression delegate,
       HasBindingExpressions hasBindingExpressions) {
-    super(bindingKey, delegate);
+    super(delegate);
     this.binding = binding;
     this.hasBindingExpressions = hasBindingExpressions;
   }
diff --git a/java/dagger/internal/codegen/ProducerFieldRequestFulfillment.java b/java/dagger/internal/codegen/ProducerBindingExpression.java
similarity index 57%
rename from java/dagger/internal/codegen/ProducerFieldRequestFulfillment.java
rename to java/dagger/internal/codegen/ProducerBindingExpression.java
index a0c61c85c..a39365dda 100644
--- a/java/dagger/internal/codegen/ProducerFieldRequestFulfillment.java
+++ b/java/dagger/internal/codegen/ProducerBindingExpression.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 The Dagger Authors.
+ * Copyright (C) 2017 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -17,27 +17,30 @@
 package dagger.internal.codegen;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static dagger.internal.codegen.BindingKey.Kind.CONTRIBUTION;
 import static dagger.internal.codegen.BindingType.PRODUCTION;
 
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.FieldSpec;
+import java.util.Optional;
 
-/** Fulfills requests for {@link ProductionBinding} instances. */
-final class ProducerFieldRequestFulfillment extends RequestFulfillment {
-  private final MemberSelect producerFieldSelect;
+final class ProducerBindingExpression extends FrameworkInstanceBindingExpression {
+  private final boolean isProducerFromProvider;
 
-  ProducerFieldRequestFulfillment(BindingKey bindingKey, MemberSelect producerFieldSelect) {
-    super(bindingKey);
-    checkArgument(bindingKey.kind().equals(CONTRIBUTION));
-    this.producerFieldSelect = producerFieldSelect;
+  ProducerBindingExpression(
+      BindingKey bindingKey,
+      Optional<FieldSpec> fieldSpec,
+      HasBindingExpressions hasBindingExpressions,
+      MemberSelect memberSelect,
+      boolean isProducerFromProvider) {
+    super(bindingKey, fieldSpec, hasBindingExpressions, memberSelect);
+    this.isProducerFromProvider = isProducerFromProvider;
   }
 
   @Override
-  public CodeBlock getSnippetForDependencyRequest(
+  CodeBlock getSnippetForDependencyRequest(
       DependencyRequest request, ClassName requestingClass) {
-    return FrameworkType.PRODUCER.to(
-        request.kind(), producerFieldSelect.getExpressionFor(requestingClass));
+    return FrameworkType.PRODUCER.to(request.kind(), getFrameworkTypeInstance(requestingClass));
   }
 
   @Override
@@ -47,6 +50,11 @@ CodeBlock getSnippetForFrameworkDependency(
         frameworkDependency.bindingType().equals(PRODUCTION),
         "%s is not a production dependency",
         frameworkDependency);
-    return producerFieldSelect.getExpressionFor(requestingClass);
+    return getFrameworkTypeInstance(requestingClass);
+  }
+
+  @Override
+  boolean isProducerFromProvider() {
+    return isProducerFromProvider;
   }
 }
diff --git a/java/dagger/internal/codegen/ProviderFieldRequestFulfillment.java b/java/dagger/internal/codegen/ProviderBindingExpression.java
similarity index 57%
rename from java/dagger/internal/codegen/ProviderFieldRequestFulfillment.java
rename to java/dagger/internal/codegen/ProviderBindingExpression.java
index d17c2e54a..accd39148 100644
--- a/java/dagger/internal/codegen/ProviderFieldRequestFulfillment.java
+++ b/java/dagger/internal/codegen/ProviderBindingExpression.java
@@ -16,28 +16,24 @@
 
 package dagger.internal.codegen;
 
-import static com.google.common.base.Preconditions.checkArgument;
-import static dagger.internal.codegen.BindingKey.Kind.CONTRIBUTION;
-
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.FieldSpec;
 import dagger.producers.internal.Producers;
+import java.util.Optional;
 
-/** Fulfills requests for {@link ProvisionBinding} instances. */
-final class ProviderFieldRequestFulfillment extends RequestFulfillment {
-  private final MemberSelect providerFieldSelect;
-
-  ProviderFieldRequestFulfillment(BindingKey bindingKey, MemberSelect frameworkFieldSelect) {
-    super(bindingKey);
-    checkArgument(bindingKey.kind().equals(CONTRIBUTION));
-    this.providerFieldSelect = frameworkFieldSelect;
+final class ProviderBindingExpression extends FrameworkInstanceBindingExpression {
+  ProviderBindingExpression(
+      BindingKey bindingKey,
+      Optional<FieldSpec> fieldSpec,
+      HasBindingExpressions hasBindingExpressions,
+      MemberSelect memberSelect) {
+    super(bindingKey, fieldSpec, hasBindingExpressions, memberSelect);
   }
 
   @Override
-  public CodeBlock getSnippetForDependencyRequest(
-      DependencyRequest request, ClassName requestingClass) {
-    return FrameworkType.PROVIDER.to(
-        request.kind(), providerFieldSelect.getExpressionFor(requestingClass));
+  CodeBlock getSnippetForDependencyRequest(DependencyRequest request, ClassName requestingClass) {
+    return FrameworkType.PROVIDER.to(request.kind(), getFrameworkTypeInstance(requestingClass));
   }
 
   @Override
@@ -45,16 +41,21 @@ CodeBlock getSnippetForFrameworkDependency(
       FrameworkDependency frameworkDependency, ClassName requestingClass) {
     switch (frameworkDependency.bindingType()) {
       case PROVISION:
-        return providerFieldSelect.getExpressionFor(requestingClass);
+        return getFrameworkTypeInstance(requestingClass);
       case MEMBERS_INJECTION:
         throw new IllegalArgumentException();
       case PRODUCTION:
         return CodeBlock.of(
             "$T.producerFromProvider($L)",
             Producers.class,
-            providerFieldSelect.getExpressionFor(requestingClass));
+            getFrameworkTypeInstance(requestingClass));
       default:
         throw new AssertionError();
     }
   }
+
+  @Override
+  boolean isProducerFromProvider() {
+    return false;
+  }
 }
diff --git a/java/dagger/internal/codegen/RequestFulfillment.java b/java/dagger/internal/codegen/RequestFulfillment.java
deleted file mode 100644
index db296c066..000000000
--- a/java/dagger/internal/codegen/RequestFulfillment.java
+++ /dev/null
@@ -1,53 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal.codegen;
-
-import static com.google.common.base.Preconditions.checkNotNull;
-
-import com.squareup.javapoet.ClassName;
-import com.squareup.javapoet.CodeBlock;
-
-/**
- * A strategy interface for generating a {@link CodeBlock} that represents how a {@link Binding} is
- * used to satisfy a given {@link DependencyRequest}.
- */
-abstract class RequestFulfillment {
-  private final BindingKey bindingKey;
-
-  RequestFulfillment(BindingKey bindingKey) {
-    this.bindingKey = checkNotNull(bindingKey);
-  }
-
-  /** The key for which this instance can fulfill requests. */
-  final BindingKey bindingKey() {
-    return bindingKey;
-  }
-
-  /**
-   * Returns the {@link CodeBlock} that implements the operation represented by the {@link
-   * DependencyRequest request} from the {@code requestingClass}.
-   */
-  abstract CodeBlock getSnippetForDependencyRequest(
-      DependencyRequest request, ClassName requestingClass);
-
-  /**
-   * Returns the {@link CodeBlock} that references the {@link FrameworkDependency} as accessed from
-   * the {@code requestingClass}.
-   */
-  abstract CodeBlock getSnippetForFrameworkDependency(
-      FrameworkDependency frameworkDependency, ClassName requestingClass);
-}
diff --git a/java/dagger/internal/codegen/SetBindingRequestFulfillment.java b/java/dagger/internal/codegen/SetBindingExpression.java
similarity index 94%
rename from java/dagger/internal/codegen/SetBindingRequestFulfillment.java
rename to java/dagger/internal/codegen/SetBindingExpression.java
index 502a15b41..d0ca01526 100644
--- a/java/dagger/internal/codegen/SetBindingRequestFulfillment.java
+++ b/java/dagger/internal/codegen/SetBindingExpression.java
@@ -32,23 +32,22 @@
 import javax.lang.model.util.Elements;
 
 /**
- * A {@link RequestFulfillment} for {@link
- * dagger.internal.codegen.ContributionBinding.Kind#SYNTHETIC_MULTIBOUND_SET}
+ * A {@link BindingExpression} for {@link
+ * ContributionBinding.Kind#SYNTHETIC_MULTIBOUND_SET}
  */
-final class SetBindingRequestFulfillment extends SimpleInvocationRequestFulfillment {
+final class SetBindingExpression extends SimpleInvocationBindingExpression {
   private final ProvisionBinding binding;
   private final BindingGraph graph;
   private final HasBindingExpressions hasBindingExpressions;
   private final Elements elements;
 
-  SetBindingRequestFulfillment(
-      BindingKey bindingKey,
+  SetBindingExpression(
       ProvisionBinding binding,
       BindingGraph graph,
       HasBindingExpressions hasBindingExpressions,
-      RequestFulfillment delegate,
+      BindingExpression delegate,
       Elements elements) {
-    super(bindingKey, delegate);
+    super(delegate);
     this.binding = binding;
     this.graph = graph;
     this.hasBindingExpressions = hasBindingExpressions;
diff --git a/java/dagger/internal/codegen/SimpleInvocationRequestFulfillment.java b/java/dagger/internal/codegen/SimpleInvocationBindingExpression.java
similarity index 87%
rename from java/dagger/internal/codegen/SimpleInvocationRequestFulfillment.java
rename to java/dagger/internal/codegen/SimpleInvocationBindingExpression.java
index 94e19bd92..644b4308c 100644
--- a/java/dagger/internal/codegen/SimpleInvocationRequestFulfillment.java
+++ b/java/dagger/internal/codegen/SimpleInvocationBindingExpression.java
@@ -21,14 +21,14 @@
 import com.squareup.javapoet.CodeBlock;
 
 /**
- * A {@link RequestFulfillment} that can fulfill its request with a simple call when possible, and
+ * A {@link BindingExpression} that can fulfill its request with a simple call when possible, and
  * otherwise delegates to a backing provider field.
  */
-abstract class SimpleInvocationRequestFulfillment extends RequestFulfillment {
-  private final RequestFulfillment delegate;
+abstract class SimpleInvocationBindingExpression extends BindingExpression {
+  private final BindingExpression delegate;
 
-  SimpleInvocationRequestFulfillment(BindingKey bindingKey, RequestFulfillment delegate) {
-    super(bindingKey);
+  SimpleInvocationBindingExpression(BindingExpression delegate) {
+    super(delegate.bindingKey());
     this.delegate = delegate;
   }
 
diff --git a/java/dagger/internal/codegen/SimpleMethodRequestFulfillment.java b/java/dagger/internal/codegen/SimpleMethodBindingExpression.java
similarity index 96%
rename from java/dagger/internal/codegen/SimpleMethodRequestFulfillment.java
rename to java/dagger/internal/codegen/SimpleMethodBindingExpression.java
index 4844d61c2..c53a9164d 100644
--- a/java/dagger/internal/codegen/SimpleMethodRequestFulfillment.java
+++ b/java/dagger/internal/codegen/SimpleMethodBindingExpression.java
@@ -40,18 +40,17 @@
  * requests whenever possible. In cases where direct invocation is not possible, this implementation
  * delegates to one that uses a {@link javax.inject.Provider}.
  */
-final class SimpleMethodRequestFulfillment extends SimpleInvocationRequestFulfillment {
+final class SimpleMethodBindingExpression extends SimpleInvocationBindingExpression {
   private final CompilerOptions compilerOptions;
   private final ProvisionBinding provisionBinding;
   private final HasBindingExpressions hasBindingExpressions;
 
-  SimpleMethodRequestFulfillment(
+  SimpleMethodBindingExpression(
       CompilerOptions compilerOptions,
-      BindingKey bindingKey,
       ProvisionBinding provisionBinding,
-      RequestFulfillment providerDelegate,
+      BindingExpression delegate,
       HasBindingExpressions hasBindingExpressions) {
-    super(bindingKey, providerDelegate);
+    super(delegate);
     this.compilerOptions = compilerOptions;
     checkArgument(
         provisionBinding.implicitDependencies().isEmpty(),
diff --git a/java/dagger/internal/codegen/SubcomponentBuilderRequestFulfillment.java b/java/dagger/internal/codegen/SubcomponentBuilderBindingExpression.java
similarity index 79%
rename from java/dagger/internal/codegen/SubcomponentBuilderRequestFulfillment.java
rename to java/dagger/internal/codegen/SubcomponentBuilderBindingExpression.java
index 6afb95a9f..0fa51950f 100644
--- a/java/dagger/internal/codegen/SubcomponentBuilderRequestFulfillment.java
+++ b/java/dagger/internal/codegen/SubcomponentBuilderBindingExpression.java
@@ -19,12 +19,11 @@
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
 
-final class SubcomponentBuilderRequestFulfillment extends SimpleInvocationRequestFulfillment {
+final class SubcomponentBuilderBindingExpression extends SimpleInvocationBindingExpression {
   private final String subcomponentBuilderName;
 
-  SubcomponentBuilderRequestFulfillment(
-      BindingKey bindingKey, RequestFulfillment delegate, String subcomponentBuilderName) {
-    super(bindingKey, delegate);
+  SubcomponentBuilderBindingExpression(BindingExpression delegate, String subcomponentBuilderName) {
+    super(delegate);
     this.subcomponentBuilderName = subcomponentBuilderName;
   }
 
diff --git a/javatests/dagger/internal/codegen/ComponentProcessorTest.java b/javatests/dagger/internal/codegen/ComponentProcessorTest.java
index 7a6ef8b94..b13957443 100644
--- a/javatests/dagger/internal/codegen/ComponentProcessorTest.java
+++ b/javatests/dagger/internal/codegen/ComponentProcessorTest.java
@@ -520,7 +520,6 @@ public void componentWithInvalidModule() {
             GENERATED_ANNOTATION,
             "public final class DaggerTestComponent implements TestComponent {",
             "  private Provider<B> bProvider;",
-            "  private Provider<A> aProvider;",
             "",
             "  private DaggerTestComponent(Builder builder) {",
             "    initialize(builder);",
@@ -538,7 +537,6 @@ public void componentWithInvalidModule() {
             "  private void initialize(final Builder builder) {",
             "    this.bProvider = TestModule_BFactory.create(builder.testModule,",
             "        C_Factory.create());",
-            "    this.aProvider = A_Factory.create(bProvider);",
             "  }",
             "",
             "  @Override",
@@ -620,7 +618,6 @@ public void componentWithAbstractModule() {
             "package test;",
             "",
             "import dagger.Component;",
-            "import javax.inject.Provider;",
             "",
             "@Component(modules = TestModule.class)",
             "interface TestComponent {",
@@ -633,16 +630,10 @@ public void componentWithAbstractModule() {
             "",
             "import dagger.internal.Preconditions;",
             "import javax.annotation.Generated;",
-            "import javax.inject.Provider;",
             "",
             GENERATED_ANNOTATION,
             "public final class DaggerTestComponent implements TestComponent {",
-            "  private Provider<B> bProvider;",
-            "  private Provider<A> aProvider;",
-            "",
-            "  private DaggerTestComponent(Builder builder) {",
-            "    initialize(builder);",
-            "  }",
+            "  private DaggerTestComponent(Builder builder) {}",
             "",
             "  public static Builder builder() {",
             "    return new Builder();",
@@ -652,12 +643,6 @@ public void componentWithAbstractModule() {
             "    return new Builder().build();",
             "  }",
             "",
-            "  @SuppressWarnings(\"unchecked\")",
-            "  private void initialize(final Builder builder) {",
-            "    this.bProvider = TestModule_BFactory.create(C_Factory.create());",
-            "    this.aProvider = A_Factory.create(bProvider);",
-            "  }",
-            "",
             "  @Override",
             "  public A a() {",
             "    return new A(Preconditions.checkNotNull(",
@@ -744,7 +729,6 @@ public void componentWithAbstractModule() {
         "package test;",
         "",
         "import dagger.Component;",
-        "import javax.inject.Provider;",
         "",
         "@Component(modules = TestModule.class)",
         "interface TestComponent {",
@@ -1136,7 +1120,6 @@ public void testDefaultPackage() {
             GENERATED_ANNOTATION,
             "public final class DaggerSimpleComponent implements SimpleComponent {",
             "  private Provider<SimpleComponent> simpleComponentProvider;",
-            "  private Provider<SomeInjectableType> someInjectableTypeProvider;",
             "",
             "  private DaggerSimpleComponent(Builder builder) {",
             "    initialize(builder);",
@@ -1153,8 +1136,6 @@ public void testDefaultPackage() {
             "  @SuppressWarnings(\"unchecked\")",
             "  private void initialize(final Builder builder) {",
             "    this.simpleComponentProvider = InstanceFactory.<SimpleComponent>create(this);",
-            "    this.someInjectableTypeProvider =",
-            "        SomeInjectableType_Factory.create(simpleComponentProvider);",
             "  }",
             "",
             "  @Override",
@@ -1211,15 +1192,10 @@ public void testDefaultPackage() {
         "",
         "import com.google.errorprone.annotations.CanIgnoreReturnValue;",
         "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
         "",
         GENERATED_ANNOTATION,
         "public final class DaggerSimpleComponent implements SimpleComponent {",
-        "  private Provider<SomeInjectedType> someInjectedTypeProvider;",
-        "",
-        "  private DaggerSimpleComponent(Builder builder) {",
-        "    initialize(builder);",
-        "  }",
+        "  private DaggerSimpleComponent(Builder builder) {}",
         "",
         "  public static Builder builder() {",
         "    return new Builder();",
@@ -1229,12 +1205,6 @@ public void testDefaultPackage() {
         "    return new Builder().build();",
         "  }",
         "",
-        "  @SuppressWarnings(\"unchecked\")",
-        "  private void initialize(final Builder builder) {",
-        "    this.someInjectedTypeProvider =",
-        "        SomeInjectedType_Factory.create(SomeInjectableType_Factory.create());",
-        "  }",
-        "",
         "  @Override",
         "  public SomeInjectedType createAndInject() {",
         "    return injectSomeInjectedType(",
@@ -1379,7 +1349,6 @@ public void testDefaultPackage() {
             GENERATED_ANNOTATION,
             "public final class DaggerBComponent implements BComponent {",
             "  private Provider<A> aProvider;",
-            "  private Provider<B> bProvider;",
             "",
             "  private DaggerBComponent(Builder builder) {",
             "    initialize(builder);",
@@ -1392,7 +1361,6 @@ public void testDefaultPackage() {
             "  @SuppressWarnings(\"unchecked\")",
             "  private void initialize(final Builder builder) {",
             "    this.aProvider = new test_AComponent_a(builder.aComponent);",
-            "    this.bProvider = B_Factory.create(aProvider);",
             "  }",
             "",
             "  @Override",
@@ -1613,17 +1581,10 @@ public void testDefaultPackage() {
             "package test;",
             "",
             "import javax.annotation.Generated;",
-            "import javax.inject.Provider;",
             "",
             GENERATED_ANNOTATION,
             "public final class DaggerTestComponent implements TestComponent {",
-            "  private Provider<B> bProvider;",
-            "  private Provider<A> aProvider;",
-            "  private Provider<X> xProvider;",
-            "",
-            "  private DaggerTestComponent(Builder builder) {",
-            "    initialize(builder);",
-            "  }",
+            "  private DaggerTestComponent(Builder builder) {}",
             "",
             "  public static Builder builder() {",
             "    return new Builder();",
@@ -1633,13 +1594,6 @@ public void testDefaultPackage() {
             "    return new Builder().build();",
             "  }",
             "",
-            "  @SuppressWarnings(\"unchecked\")",
-            "  private void initialize(final Builder builder) {",
-            "    this.bProvider = B_Factory.create(C_Factory.create());",
-            "    this.aProvider = A_Factory.create(bProvider);",
-            "    this.xProvider = X_Factory.create(C_Factory.create());",
-            "  }",
-            "",
             "  @Override",
             "  public A a() {",
             "    return new A(new B(new C()));",
diff --git a/javatests/dagger/internal/codegen/ElidedFactoriesTest.java b/javatests/dagger/internal/codegen/ElidedFactoriesTest.java
new file mode 100644
index 000000000..9a03e3824
--- /dev/null
+++ b/javatests/dagger/internal/codegen/ElidedFactoriesTest.java
@@ -0,0 +1,323 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static dagger.internal.codegen.Compilers.daggerCompiler;
+import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
+
+import com.google.testing.compile.Compilation;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public class ElidedFactoriesTest {
+  @Test
+  public void simpleComponent() {
+    JavaFileObject injectedType =
+        JavaFileObjects.forSourceLines(
+            "test.InjectedType",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "final class InjectedType {",
+            "  @Inject InjectedType() {}",
+            "}");
+
+    JavaFileObject dependsOnInjected =
+        JavaFileObjects.forSourceLines(
+            "test.InjectedType",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "final class DependsOnInjected {",
+            "  @Inject DependsOnInjected(InjectedType injected) {}",
+            "}");
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface SimpleComponent {",
+            "  DependsOnInjected dependsOnInjected();",
+            "}");
+    JavaFileObject generatedComponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerSimpleComponent",
+            "package test;",
+            "",
+            "import javax.annotation.Generated;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerSimpleComponent implements SimpleComponent {",
+            "  private DaggerSimpleComponent(Builder builder) {}",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static SimpleComponent create() {",
+            "    return new Builder().build();",
+            "  }",
+            "",
+            "  @Override",
+            "  public DependsOnInjected dependsOnInjected() {",
+            "    return new DependsOnInjected(new InjectedType());",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private Builder() {",
+            "    }",
+            "",
+            "    public SimpleComponent build() {",
+            "      return new DaggerSimpleComponent(this);",
+            "    }",
+            "  }",
+            "}");
+    Compilation compilation =
+        daggerCompiler().compile(injectedType, dependsOnInjected, componentFile);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerSimpleComponent")
+        .hasSourceEquivalentTo(generatedComponent);
+  }
+
+  @Test
+  public void simpleComponent_injectsProviderOf_dependsOnScoped() {
+    JavaFileObject scopedType =
+        JavaFileObjects.forSourceLines(
+            "test.ScopedType",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "import javax.inject.Singleton;",
+            "",
+            "@Singleton",
+            "final class ScopedType {",
+            "  @Inject ScopedType() {}",
+            "}");
+
+    JavaFileObject dependsOnScoped =
+        JavaFileObjects.forSourceLines(
+            "test.ScopedType",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "import javax.inject.Provider;",
+            "",
+            "final class DependsOnScoped {",
+            "  @Inject DependsOnScoped(ScopedType scoped) {}",
+            "}");
+
+    JavaFileObject needsProvider =
+        JavaFileObjects.forSourceLines(
+            "test.NeedsProvider",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "import javax.inject.Provider;",
+            "",
+            "class NeedsProvider {",
+            "  @Inject NeedsProvider(Provider<DependsOnScoped> provider) {}",
+            "}");
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Singleton;",
+            "",
+            "@Singleton",
+            "@Component",
+            "interface SimpleComponent {",
+            "  NeedsProvider needsProvider();",
+            "}");
+    JavaFileObject generatedComponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerSimpleComponent",
+            "package test;",
+            "",
+            "import dagger.internal.DoubleCheck;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerSimpleComponent implements SimpleComponent {",
+            "  private Provider<ScopedType> scopedTypeProvider;",
+            "  private Provider<DependsOnScoped> dependsOnScopedProvider;",
+            "  private DaggerSimpleComponent(Builder builder) {",
+            "    initialize(builder);",
+            "  }",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static SimpleComponent create() {",
+            "    return new Builder().build();",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize(final Builder builder) {",
+            "    this.scopedTypeProvider = DoubleCheck.provider(ScopedType_Factory.create());",
+            "    this.dependsOnScopedProvider = ",
+            "        DependsOnScoped_Factory.create(scopedTypeProvider);",
+            "  }",
+            "",
+            "  @Override",
+            "  public NeedsProvider needsProvider() {",
+            "    return new NeedsProvider(dependsOnScopedProvider);",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private Builder() {",
+            "    }",
+            "",
+            "    public SimpleComponent build() {",
+            "      return new DaggerSimpleComponent(this);",
+            "    }",
+            "  }",
+            "}");
+    Compilation compilation =
+        daggerCompiler().compile(scopedType, dependsOnScoped, componentFile, needsProvider);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerSimpleComponent")
+        .hasSourceEquivalentTo(generatedComponent);
+  }
+
+  @Test
+  public void scopedBinding_onlyUsedInSubcomponent() {
+    JavaFileObject scopedType =
+        JavaFileObjects.forSourceLines(
+            "test.ScopedType",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "import javax.inject.Singleton;",
+            "",
+            "@Singleton",
+            "final class ScopedType {",
+            "  @Inject ScopedType() {}",
+            "}");
+
+    JavaFileObject dependsOnScoped =
+        JavaFileObjects.forSourceLines(
+            "test.ScopedType",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "import javax.inject.Provider;",
+            "",
+            "final class DependsOnScoped {",
+            "  @Inject DependsOnScoped(ScopedType scoped) {}",
+            "}");
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Singleton;",
+            "",
+            "@Singleton",
+            "@Component",
+            "interface SimpleComponent {",
+            "  Sub sub();",
+            "}");
+    JavaFileObject subcomponentFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent",
+            "interface Sub {",
+            "  DependsOnScoped dependsOnScoped();",
+            "}");
+
+    JavaFileObject generatedComponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerSimpleComponent",
+            "package test;",
+            "",
+            "import dagger.internal.DoubleCheck;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerSimpleComponent implements SimpleComponent {",
+            "  private Provider<ScopedType> scopedTypeProvider;",
+            "",
+            "  private DaggerSimpleComponent(Builder builder) {",
+            "    initialize(builder);",
+            "  }",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static SimpleComponent create() {",
+            "    return new Builder().build();",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize(final Builder builder) {",
+            "    this.scopedTypeProvider = DoubleCheck.provider(ScopedType_Factory.create());",
+            "  }",
+            "",
+            "  @Override",
+            "  public Sub sub() {",
+            "    return new SubImpl();",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private Builder() {}",
+            "",
+            "    public SimpleComponent build() {",
+            "      return new DaggerSimpleComponent(this);",
+            "    }",
+            "  }",
+            "",
+            "  private final class SubImpl implements Sub {",
+            "    private SubImpl() {}",
+            "",
+            "    @Override",
+            "    public DependsOnScoped dependsOnScoped() {",
+            "      return new DependsOnScoped(",
+            "          DaggerSimpleComponent.this.scopedTypeProvider.get());",
+            "    }",
+            "  }",
+            "}");
+    Compilation compilation =
+        daggerCompiler().compile(scopedType, dependsOnScoped, componentFile, subcomponentFile);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerSimpleComponent")
+        .hasSourceEquivalentTo(generatedComponent);
+  }
+}
diff --git a/javatests/dagger/internal/codegen/InaccessibleTypeTest.java b/javatests/dagger/internal/codegen/InaccessibleTypeTest.java
index 6228d4355..0d885f15c 100644
--- a/javatests/dagger/internal/codegen/InaccessibleTypeTest.java
+++ b/javatests/dagger/internal/codegen/InaccessibleTypeTest.java
@@ -85,19 +85,10 @@
             "import foreign.PublicClass;",
             "import foreign.PublicClass_Factory;",
             "import javax.annotation.Generated;",
-            "import javax.inject.Provider;",
             "",
             GENERATED_ANNOTATION,
             "public final class DaggerTestComponent implements TestComponent {",
-            "  @SuppressWarnings(\"rawtypes\")",
-            "  private Provider nonPublicClass1Provider;",
-            "  @SuppressWarnings(\"rawtypes\")",
-            "  private Provider nonPublicClass2Provider;",
-            "  private Provider<PublicClass> publicClassProvider;",
-            "",
-            "  private DaggerTestComponent(Builder builder) {",
-            "    initialize(builder);",
-            "  }",
+            "  private DaggerTestComponent(Builder builder) {}",
             "",
             "  public static Builder builder() {",
             "    return new Builder();",
@@ -107,18 +98,6 @@
             "    return new Builder().build();",
             "  }",
             "",
-            "  @SuppressWarnings(\"unchecked\")",
-            "  private void initialize(final Builder builder) {",
-            "    this.nonPublicClass1Provider =",
-            "        NonPublicClass1_Factory.create(NoDepClass_Factory.create());",
-            "    this.nonPublicClass2Provider =",
-            "        NonPublicClass2_Factory.create(NoDepClass_Factory.create());",
-            "    this.publicClassProvider = PublicClass_Factory.create(",
-            "        nonPublicClass1Provider,",
-            "        nonPublicClass2Provider,",
-            "        NoDepClass_Factory.create());",
-            "  }",
-            "",
             "  @Override",
             "  public PublicClass publicClass() {",
             "    return PublicClass_Factory.newPublicClass(",
diff --git a/javatests/dagger/internal/codegen/MembersInjectionTest.java b/javatests/dagger/internal/codegen/MembersInjectionTest.java
index 4e660341a..95dd46f66 100644
--- a/javatests/dagger/internal/codegen/MembersInjectionTest.java
+++ b/javatests/dagger/internal/codegen/MembersInjectionTest.java
@@ -149,15 +149,10 @@ public void parentClass_injectedMembersInSupertype() {
             "",
             "import com.google.errorprone.annotations.CanIgnoreReturnValue;",
             "import javax.annotation.Generated;",
-            "import javax.inject.Provider;",
             "",
             GENERATED_ANNOTATION,
             "public final class DaggerTestComponent implements TestComponent {",
-            "  private Provider<Child> childProvider;",
-            "",
-            "  private DaggerTestComponent(Builder builder) {",
-            "    initialize(builder);",
-            "  }",
+            "  private DaggerTestComponent(Builder builder) {}",
             "",
             "  public static Builder builder() {",
             "    return new Builder();",
@@ -167,11 +162,6 @@ public void parentClass_injectedMembersInSupertype() {
             "    return new Builder().build();",
             "  }",
             "",
-            "  @SuppressWarnings(\"unchecked\")",
-            "  private void initialize(final Builder builder) {",
-            "    this.childProvider = Child_Factory.create(Dep_Factory.create());",
-            "  }",
-            "",
             "  @Override",
             "  public Child child() {",
             "    return injectChild(Child_Factory.newChild());",
@@ -1256,7 +1246,6 @@ public void accessibility() {
                 "",
                 "import com.google.errorprone.annotations.CanIgnoreReturnValue;",
                 "import javax.annotation.Generated;",
-                "import javax.inject.Provider;",
                 "import other.Foo_Factory;",
                 "import other.Inaccessible_Factory;",
                 "import other.Inaccessible_MembersInjector;",
@@ -1265,14 +1254,7 @@ public void accessibility() {
                 "",
                 GENERATED_ANNOTATION,
                 "public final class DaggerTestComponent implements TestComponent {",
-                "  @SuppressWarnings(\"rawtypes\")",
-                "  private Provider inaccessibleProvider;",
-                "",
-                "  private Provider<UsesInaccessible> usesInaccessibleProvider;",
-                "",
-                "  private DaggerTestComponent(Builder builder) {",
-                "    initialize(builder);",
-                "  }",
+                "  private DaggerTestComponent(Builder builder) {}",
                 "",
                 "  public static Builder builder() {",
                 "    return new Builder();",
@@ -1282,14 +1264,6 @@ public void accessibility() {
                 "    return new Builder().build();",
                 "  }",
                 "",
-                "  @SuppressWarnings(\"unchecked\")",
-                "  private void initialize(final Builder builder) {",
-                "    this.inaccessibleProvider = ",
-                "        Inaccessible_Factory.create(Foo_Factory.create());",
-                "    this.usesInaccessibleProvider = ",
-                "        UsesInaccessible_Factory.create(inaccessibleProvider);",
-                "  }",
-                "",
                 "  @Override",
                 "  public UsesInaccessible usesInaccessible() {",
                 "    return UsesInaccessible_Factory.newUsesInaccessible(",
@@ -1398,8 +1372,6 @@ public void accessibleRawType_ofInaccessibleType() {
                 "  @SuppressWarnings(\"rawtypes\")",
                 "  private Provider inaccessiblesProvider;",
                 "",
-                "  private Provider<UsesInaccessibles> usesInaccessiblesProvider;",
-                "",
                 "  private DaggerTestComponent(Builder builder) {",
                 "    initialize(builder);",
                 "  }",
@@ -1416,8 +1388,6 @@ public void accessibleRawType_ofInaccessibleType() {
                 "  private void initialize(final Builder builder) {",
                 "    this.inaccessiblesProvider =",
                 "        DoubleCheck.provider(InaccessiblesModule_InaccessiblesFactory.create());",
-                "    this.usesInaccessiblesProvider = ",
-                "        UsesInaccessibles_Factory.create(inaccessiblesProvider);",
                 "  }",
                 "",
                 "  @Override",
@@ -1516,7 +1486,6 @@ public void publicSupertypeHiddenSubtype() {
                 "",
                 "import com.google.errorprone.annotations.CanIgnoreReturnValue;",
                 "import javax.annotation.Generated;",
-                "import javax.inject.Provider;",
                 "import other.Foo_Factory;",
                 "import other.InjectsSubtype;",
                 "import other.InjectsSubtype_Factory;",
@@ -1526,14 +1495,7 @@ public void publicSupertypeHiddenSubtype() {
                 "",
                 GENERATED_ANNOTATION,
                 "public final class DaggerTestComponent implements TestComponent {",
-                "  @SuppressWarnings(\"rawtypes\")",
-                "  private Provider subtypeProvider;",
-                "",
-                "  private Provider<InjectsSubtype> injectsSubtypeProvider;",
-                "",
-                "  private DaggerTestComponent(Builder builder) {",
-                "    initialize(builder);",
-                "  }",
+                "  private DaggerTestComponent(Builder builder) {}",
                 "",
                 "  public static Builder builder() {",
                 "    return new Builder();",
@@ -1543,12 +1505,6 @@ public void publicSupertypeHiddenSubtype() {
                 "    return new Builder().build();",
                 "  }",
                 "",
-                "  @SuppressWarnings(\"unchecked\")",
-                "  private void initialize(final Builder builder) {",
-                "    this.subtypeProvider = Subtype_Factory.create(Foo_Factory.create());",
-                "    this.injectsSubtypeProvider = InjectsSubtype_Factory.create(subtypeProvider);",
-                "  }",
-                "",
                 "  @Override",
                 "  public InjectsSubtype injectsSubtype() {",
                 "    return InjectsSubtype_Factory.newInjectsSubtype(",
diff --git a/javatests/dagger/internal/codegen/OptionalBindingRequestFulfillmentTest.java b/javatests/dagger/internal/codegen/OptionalBindingRequestFulfillmentTest.java
index 69a834d26..fe75207cf 100644
--- a/javatests/dagger/internal/codegen/OptionalBindingRequestFulfillmentTest.java
+++ b/javatests/dagger/internal/codegen/OptionalBindingRequestFulfillmentTest.java
@@ -98,7 +98,6 @@ public void inlinedOptionalBindings() {
             "",
             "import com.google.common.base.Optional;",
             "import dagger.Lazy;",
-            "import dagger.internal.InstanceFactory;",
             "import dagger.internal.Preconditions;",
             "import dagger.internal.ProviderOfLazy;",
             "import javax.annotation.Generated;",
@@ -109,23 +108,7 @@ public void inlinedOptionalBindings() {
             "",
             GENERATED_ANNOTATION,
             "public final class DaggerTestComponent implements TestComponent {",
-            "  @SuppressWarnings(\"rawtypes\")",
-            "  private static final Provider ABSENT_GUAVA_OPTIONAL_PROVIDER =",
-            "      InstanceFactory.create(Optional.absent());",
-            "",
-            "  private Provider<Optional<Maybe>> optionalOfMaybeProvider;",
-            "",
-            "  private Provider<Optional<Provider<Lazy<Maybe>>>> ",
-            "      optionalOfProviderOfLazyOfMaybeProvider;",
-            "",
-            "  private Provider<Optional<DefinitelyNot>> optionalOfDefinitelyNotProvider;",
-            "",
-            "  private Provider<Optional<Provider<Lazy<DefinitelyNot>>>>",
-            "      optionalOfProviderOfLazyOfDefinitelyNotProvider;",
-            "",
-            "  private DaggerTestComponent(Builder builder) {",
-            "    initialize(builder);",
-            "  }",
+            "  private DaggerTestComponent(Builder builder) {}",
             "",
             "  public static Builder builder() {",
             "    return new Builder();",
@@ -135,23 +118,6 @@ public void inlinedOptionalBindings() {
             "    return new Builder().build();",
             "  }",
             "",
-            "  @SuppressWarnings(\"unchecked\")",
-            "  private void initialize(final Builder builder) {",
-            "",
-            "    this.optionalOfMaybeProvider =",
-            "        PresentGuavaOptionalInstanceProvider.of(",
-            "            Maybe_MaybeModule_ProvideMaybeFactory.create());",
-            "",
-            "    this.optionalOfProviderOfLazyOfMaybeProvider =",
-            "        PresentGuavaOptionalProviderOfLazyProvider.of(",
-            "            Maybe_MaybeModule_ProvideMaybeFactory.create());",
-            "",
-            "    this.optionalOfDefinitelyNotProvider = absentGuavaOptionalProvider();",
-            "",
-            "    this.optionalOfProviderOfLazyOfDefinitelyNotProvider = ",
-            "        absentGuavaOptionalProvider();",
-            "  }",
-            "",
             "  @Override",
             "  public Optional<Maybe> maybe() {",
             "    return Optional.of(",
@@ -175,13 +141,6 @@ public void inlinedOptionalBindings() {
             "    return Optional.absent();",
             "  }",
             "",
-            "  private static <T> Provider<Optional<T>> absentGuavaOptionalProvider() {",
-            "    @SuppressWarnings(\"unchecked\")",
-            "    Provider<Optional<T>> provider = ",
-            "        (Provider<Optional<T>>) ABSENT_GUAVA_OPTIONAL_PROVIDER;",
-            "    return provider;",
-            "  }",
-            "",
             "  public static final class Builder {",
             "    private Builder() {}",
             "",
@@ -189,43 +148,6 @@ public void inlinedOptionalBindings() {
             "      return new DaggerTestComponent(this);",
             "    }",
             "  }",
-            "",
-            "  private static final class PresentGuavaOptionalInstanceProvider<T>",
-            "      implements Provider<Optional<T>> {",
-            "    private final Provider<T> delegate;",
-            "",
-            "    private PresentGuavaOptionalInstanceProvider(Provider<T> delegate) {",
-            "      this.delegate = Preconditions.checkNotNull(delegate);",
-            "    }",
-            "",
-            "    @Override",
-            "    public Optional<T> get() {",
-            "      return Optional.of(delegate.get());",
-            "    }",
-            "",
-            "    private static <T> Provider<Optional<T>> of(Provider<T> delegate) {",
-            "      return new PresentGuavaOptionalInstanceProvider<T>(delegate);",
-            "    }",
-            "  }",
-            "",
-            "  private static final class PresentGuavaOptionalProviderOfLazyProvider<T>",
-            "      implements Provider<Optional<Provider<Lazy<T>>>> {",
-            "    private final Provider<T> delegate;",
-            "",
-            "    private PresentGuavaOptionalProviderOfLazyProvider(Provider<T> delegate) {",
-            "      this.delegate = Preconditions.checkNotNull(delegate);",
-            "    }",
-            "",
-            "    @Override",
-            "    public Optional<Provider<Lazy<T>>> get() {",
-            "      return Optional.of(ProviderOfLazy.create(delegate));",
-            "    }",
-            "",
-            "    private static <T> Provider<Optional<Provider<Lazy<T>>>> of(",
-            "        Provider<T> delegate) {",
-            "      return new PresentGuavaOptionalProviderOfLazyProvider<T>(delegate);",
-            "    }",
-            "  }",
             "}");
     Compilation compilation =
         daggerCompiler().compile(module, maybe, definitelyNot, component);
@@ -298,25 +220,14 @@ public void requestForFuture() {
             "import com.google.common.base.Optional;",
             "import com.google.common.util.concurrent.Futures;",
             "import com.google.common.util.concurrent.ListenableFuture;",
-            "import dagger.internal.InstanceFactory;",
             "import dagger.internal.Preconditions;",
             "import javax.annotation.Generated;",
-            "import javax.inject.Provider;",
             "import other.DefinitelyNot;",
             "import other.Maybe;",
-            "import other.Maybe_MaybeModule_ProvideMaybeFactory;",
             "",
             GENERATED_ANNOTATION,
-            "  public final class DaggerTestComponent implements TestComponent {",
-            "    @SuppressWarnings(\"rawtypes\")",
-            "    private static final Provider ABSENT_GUAVA_OPTIONAL_PROVIDER =",
-            "        InstanceFactory.create(Optional.absent());",
-            "    private Provider<Optional<Maybe>> optionalOfMaybeProvider;",
-            "    private Provider<Optional<DefinitelyNot>> optionalOfDefinitelyNotProvider;",
-            "",
-            "  private DaggerTestComponent(Builder builder) {",
-            "      initialize(builder);",
-            "    }",
+            "public final class DaggerTestComponent implements TestComponent {",
+            "  private DaggerTestComponent(Builder builder) {}",
             "",
             "  public static Builder builder() {",
             "    return new Builder();",
@@ -326,14 +237,6 @@ public void requestForFuture() {
             "    return new Builder().build();",
             "  }",
             "",
-            "  @SuppressWarnings(\"unchecked\")",
-            "  private void initialize(final Builder builder) {",
-            "    this.optionalOfMaybeProvider =",
-            "        PresentGuavaOptionalInstanceProvider.of(",
-            "            Maybe_MaybeModule_ProvideMaybeFactory.create());",
-            "    this.optionalOfDefinitelyNotProvider = absentGuavaOptionalProvider();",
-            "  }",
-            "",
             "  @Override",
             "  public ListenableFuture<Optional<Maybe>> maybe() {",
             "    return Futures.immediateFuture(Optional.of(Preconditions.checkNotNull(",
@@ -344,13 +247,6 @@ public void requestForFuture() {
             "  public ListenableFuture<Optional<DefinitelyNot>> definitelyNot() {",
             "    return Futures.immediateFuture(Optional.<DefinitelyNot>absent());",
 
-            "  }",
-            "",
-            "  private static <T> Provider<Optional<T>> absentGuavaOptionalProvider() {",
-            "    @SuppressWarnings(\"unchecked\")",
-            "        Provider<Optional<T>> provider = ",
-            "            (Provider<Optional<T>>) ABSENT_GUAVA_OPTIONAL_PROVIDER;",
-            "    return provider;",
             "  }",
             "",
             "  public static final class Builder {",
@@ -368,24 +264,6 @@ public void requestForFuture() {
             "      return this;",
             "    }",
             "  }",
-            "",
-            "  private static final class PresentGuavaOptionalInstanceProvider<T>",
-            "      implements Provider<Optional<T>> {",
-            "    private final Provider<T> delegate;",
-            "",
-            "    private PresentGuavaOptionalInstanceProvider(Provider<T> delegate) {",
-            "      this.delegate = Preconditions.checkNotNull(delegate);",
-            "    }",
-            "",
-            "    @Override",
-            "    public Optional<T> get() {",
-            "      return Optional.of(delegate.get());",
-            "    }",
-            "",
-            "    private static <T> Provider<Optional<T>> of(Provider<T> delegate) {",
-            "      return new PresentGuavaOptionalInstanceProvider<T>(delegate);",
-            "    }",
-            "  }",
             "}");
     Compilation compilation =
         daggerCompiler().compile(module, maybe, definitelyNot, component);
diff --git a/javatests/dagger/internal/codegen/SetBindingRequestFulfillmentTest.java b/javatests/dagger/internal/codegen/SetBindingRequestFulfillmentTest.java
index 4d1d08448..1cadddbd7 100644
--- a/javatests/dagger/internal/codegen/SetBindingRequestFulfillmentTest.java
+++ b/javatests/dagger/internal/codegen/SetBindingRequestFulfillmentTest.java
@@ -90,19 +90,13 @@ public void setBindings() {
             "",
             "import dagger.internal.Preconditions;",
             "import dagger.internal.SetBuilder;",
-            "import dagger.internal.SetFactory;",
             "import java.util.Collections;",
             "import java.util.Set;",
             "import javax.annotation.Generated;",
-            "import javax.inject.Provider;",
             "",
             GENERATED_ANNOTATION,
             "public final class DaggerTestComponent implements TestComponent {",
-            "  private Provider<Set<String>> setOfStringProvider;",
-            "",
-            "  private DaggerTestComponent(Builder builder) {",
-            "    initialize(builder);",
-            "  }",
+            "  private DaggerTestComponent(Builder builder) {}",
             "",
             "  public static Builder builder() {",
             "    return new Builder();",
@@ -112,15 +106,6 @@ public void setBindings() {
             "    return new Builder().build();",
             "  }",
             "",
-            "  @SuppressWarnings(\"unchecked\")",
-            "  private void initialize(final Builder builder) {",
-            "    this.setOfStringProvider = ",
-            "        SetFactory.<String>builder(1, 1)",
-            "            .addCollectionProvider(EmptySetModule_EmptySetFactory.create())",
-            "            .addProvider(SetModule_StringFactory.create())",
-            "            .build();",
-            "  }",
-            "",
             "  @Override",
             "  public Set<String> strings() {",
             "    return SetBuilder.<String>newSetBuilder(2)",
@@ -225,27 +210,18 @@ public void inaccessible() {
             "test.DaggerTestComponent",
             "package test;",
             "",
-            "import dagger.internal.Factory;",
             "import dagger.internal.Preconditions;",
             "import dagger.internal.SetBuilder;",
-            "import dagger.internal.SetFactory;",
             "import java.util.Collections;",
             "import java.util.Set;",
             "import javax.annotation.Generated;",
-            "import javax.inject.Provider;",
             "import other.TestModule_EmptySetFactory;",
             "import other.UsesInaccessible;",
             "import other.UsesInaccessible_Factory;",
             "",
             GENERATED_ANNOTATION,
             "public final class DaggerTestComponent implements TestComponent {",
-            "  @SuppressWarnings(\"rawtypes\")",
-            "  private Provider setOfInaccessible2Provider;",
-            "  private Provider<UsesInaccessible> usesInaccessibleProvider;",
-            "",
-            "  private DaggerTestComponent(Builder builder) {",
-            "    initialize(builder);",
-            "  }",
+            "  private DaggerTestComponent(Builder builder) {}",
             "",
             "  public static Builder builder() {",
             "    return new Builder();",
@@ -255,17 +231,6 @@ public void inaccessible() {
             "    return new Builder().build();",
             "  }",
             "",
-            "  @SuppressWarnings(\"unchecked\")",
-            "  private void initialize(final Builder builder) {",
-            "    this.setOfInaccessible2Provider =",
-            "        SetFactory.builder(0, 1)",
-            "            .addCollectionProvider((Provider) TestModule_EmptySetFactory.create())",
-            "            .build();",
-            "    this.usesInaccessibleProvider =",
-            "        UsesInaccessible_Factory.create(",
-            "            ((Factory) SetFactory.empty()), setOfInaccessible2Provider);",
-            "  }",
-            "",
             "  @Override",
             "  public UsesInaccessible usesInaccessible() {",
             "    return UsesInaccessible_Factory.newUsesInaccessible(",
@@ -278,8 +243,7 @@ public void inaccessible() {
             "  }",
             "",
             "  public static final class Builder {",
-            "    private Builder() {",
-            "    }",
+            "    private Builder() {}",
             "",
             "    public TestComponent build() {",
             "      return new DaggerTestComponent(this);",
@@ -350,7 +314,6 @@ public void subcomponentOmitsInheritedBindings() {
             "import dagger.internal.MapFactory;",
             "import dagger.internal.MapProviderFactory;",
             "import dagger.internal.Preconditions;",
-            "import dagger.internal.SetFactory;",
             "import java.util.Collections;",
             "import java.util.Map;",
             "import java.util.Set;",
@@ -403,7 +366,6 @@ public void subcomponentOmitsInheritedBindings() {
             "  }",
             "",
             "  private final class ChildImpl implements Child {",
-            "    private Provider<Set<Object>> setOfObjectProvider;",
             "    private Provider<Map<String, Provider<Object>>>",
             "        mapOfStringAndProviderOfObjectProvider;",
             "    private Provider<Map<String, Object>> mapOfStringAndObjectProvider;",
@@ -414,8 +376,6 @@ public void subcomponentOmitsInheritedBindings() {
             "",
             "    @SuppressWarnings(\"unchecked\")",
             "    private void initialize() {",
-            "      this.setOfObjectProvider = SetFactory.<Object>builder(1, 0)",
-            "          .addProvider(ParentModule_ParentObjectFactory.create()).build();",
             "      this.mapOfStringAndProviderOfObjectProvider =",
             "          MapProviderFactory.<String, Object>builder(1)",
             "              .put(\"parent key\", DaggerParent.this.parentKeyObjectProvider)",
diff --git a/javatests/dagger/internal/codegen/SetBindingRequestFulfillmentWithGuavaTest.java b/javatests/dagger/internal/codegen/SetBindingRequestFulfillmentWithGuavaTest.java
index 29288007f..1312e096e 100644
--- a/javatests/dagger/internal/codegen/SetBindingRequestFulfillmentWithGuavaTest.java
+++ b/javatests/dagger/internal/codegen/SetBindingRequestFulfillmentWithGuavaTest.java
@@ -90,19 +90,12 @@ public void setBindings() {
             "",
             "import com.google.common.collect.ImmutableSet;",
             "import dagger.internal.Preconditions;",
-            "import dagger.internal.SetFactory;",
             "import java.util.Set;",
             "import javax.annotation.Generated;",
-            "import javax.inject.Provider;",
             "",
             GENERATED_ANNOTATION,
             "public final class DaggerTestComponent implements TestComponent {",
-            "  private Provider<Set<String>> setOfStringProvider;",
-            "  private Provider<Set<Integer>> setOfIntegerProvider;",
-            "",
-            "  private DaggerTestComponent(Builder builder) {",
-            "    initialize(builder);",
-            "  }",
+            "  private DaggerTestComponent(Builder builder) {}",
             "",
             "  public static Builder builder() {",
             "    return new Builder();",
@@ -112,20 +105,6 @@ public void setBindings() {
             "    return new Builder().build();",
             "  }",
             "",
-            "  @SuppressWarnings(\"unchecked\")",
-            "  private void initialize(final Builder builder) {",
-            "    this.setOfStringProvider = ",
-            "        SetFactory.<String>builder(1, 1)",
-            "            .addCollectionProvider(EmptySetModule_EmptySetFactory.create())",
-            "            .addProvider(SetModule_StringFactory.create())",
-            "            .build();",
-            "    this.setOfIntegerProvider = ",
-            "        SetFactory.<Integer>builder(0, 1)",
-            "            .addCollectionProvider(",
-            "                EmptySetModule_OnlyContributionIsElementsIntoSetFactory.create())",
-            "            .build();",
-            "  }",
-            "",
             "  @Override",
             "  public Set<String> strings() {",
             "    return ImmutableSet.<String>builder()",
@@ -240,25 +219,16 @@ public void inaccessible() {
             "package test;",
             "",
             "import com.google.common.collect.ImmutableSet;",
-            "import dagger.internal.Factory;",
             "import dagger.internal.Preconditions;",
-            "import dagger.internal.SetFactory;",
             "import java.util.Set;",
             "import javax.annotation.Generated;",
-            "import javax.inject.Provider;",
             "import other.TestModule_EmptySetFactory;",
             "import other.UsesInaccessible;",
             "import other.UsesInaccessible_Factory;",
             "",
             GENERATED_ANNOTATION,
             "public final class DaggerTestComponent implements TestComponent {",
-            "  @SuppressWarnings(\"rawtypes\")",
-            "  private Provider setOfInaccessible2Provider;",
-            "  private Provider<UsesInaccessible> usesInaccessibleProvider;",
-            "",
-            "  private DaggerTestComponent(Builder builder) {",
-            "    initialize(builder);",
-            "  }",
+            "  private DaggerTestComponent(Builder builder) {}",
             "",
             "  public static Builder builder() {",
             "    return new Builder();",
@@ -268,17 +238,6 @@ public void inaccessible() {
             "    return new Builder().build();",
             "  }",
             "",
-            "  @SuppressWarnings(\"unchecked\")",
-            "  private void initialize(final Builder builder) {",
-            "    this.setOfInaccessible2Provider =",
-            "        SetFactory.builder(0, 1)",
-            "            .addCollectionProvider((Provider) TestModule_EmptySetFactory.create())",
-            "            .build();",
-            "    this.usesInaccessibleProvider =",
-            "        UsesInaccessible_Factory.create(",
-            "            ((Factory) SetFactory.empty()), setOfInaccessible2Provider);",
-            "  }",
-            "",
             "  @Override",
             "  public UsesInaccessible usesInaccessible() {",
             "    return UsesInaccessible_Factory.newUsesInaccessible(",
@@ -290,8 +249,7 @@ public void inaccessible() {
             "  }",
             "",
             "  public static final class Builder {",
-            "    private Builder() {",
-            "    }",
+            "    private Builder() {}",
             "",
             "    public TestComponent build() {",
             "      return new DaggerTestComponent(this);",
@@ -364,7 +322,6 @@ public void subcomponentOmitsInheritedBindings() {
             "import dagger.internal.MapFactory;",
             "import dagger.internal.MapProviderFactory;",
             "import dagger.internal.Preconditions;",
-            "import dagger.internal.SetFactory;",
             "import java.util.Map;",
             "import java.util.Set;",
             "import javax.annotation.Generated;",
@@ -416,7 +373,6 @@ public void subcomponentOmitsInheritedBindings() {
             "  }",
             "",
             "  private final class ChildImpl implements Child {",
-            "    private Provider<Set<Object>> setOfObjectProvider;",
             "    private Provider<Map<String, Provider<Object>>>",
             "        mapOfStringAndProviderOfObjectProvider;",
             "    private Provider<Map<String, Object>> mapOfStringAndObjectProvider;",
@@ -427,8 +383,6 @@ public void subcomponentOmitsInheritedBindings() {
             "",
             "    @SuppressWarnings(\"unchecked\")",
             "    private void initialize() {",
-            "      this.setOfObjectProvider = SetFactory.<Object>builder(1, 0)",
-            "          .addProvider(ParentModule_ParentObjectFactory.create()).build();",
             "      this.mapOfStringAndProviderOfObjectProvider =",
             "          MapProviderFactory.<String, Object>builder(1)",
             "              .put(\"parent key\", DaggerParent.this.parentKeyObjectProvider)",
@@ -494,18 +448,12 @@ public void productionComponents() {
             "import com.google.common.util.concurrent.Futures;",
             "import com.google.common.util.concurrent.ListenableFuture;",
             "import dagger.internal.Preconditions;",
-            "import dagger.internal.SetFactory;",
             "import java.util.Set;",
             "import javax.annotation.Generated;",
-            "import javax.inject.Provider;",
             "",
             GENERATED_ANNOTATION,
             "public final class DaggerTestComponent implements TestComponent {",
-            "  private Provider<Set<String>> setOfStringProvider;",
-            "",
-            "  private DaggerTestComponent(Builder builder) {",
-            "    initialize(builder);",
-            "  }",
+            "  private DaggerTestComponent(Builder builder) {}",
             "",
             "  public static Builder builder() {",
             "    return new Builder();",
@@ -515,14 +463,6 @@ public void productionComponents() {
             "    return new Builder().build();",
             "  }",
             "",
-            "  @SuppressWarnings(\"unchecked\")",
-            "  private void initialize(final Builder builder) {",
-            "    this.setOfStringProvider =",
-            "        SetFactory.<String>builder(0, 1)",
-            "            .addCollectionProvider(EmptySetModule_EmptySetFactory.create())",
-            "            .build();",
-            "  }",
-            "",
             "  @Override",
             "  public ListenableFuture<Set<String>> strings() {",
             "    return Futures.<Set<String>>immediateFuture(",
diff --git a/javatests/dagger/internal/codegen/SubcomponentBuilderRequestFulfillmentTest.java b/javatests/dagger/internal/codegen/SubcomponentBuilderRequestFulfillmentTest.java
index 35494aa39..5d6c7ed61 100644
--- a/javatests/dagger/internal/codegen/SubcomponentBuilderRequestFulfillmentTest.java
+++ b/javatests/dagger/internal/codegen/SubcomponentBuilderRequestFulfillmentTest.java
@@ -74,16 +74,10 @@ public void testInlinedSubcomponentBuilders_componentMethod() {
             "package test;",
             "",
             "import javax.annotation.Generated;",
-            "import javax.inject.Provider;",
             "",
             GENERATED_ANNOTATION,
             "public final class DaggerC implements C {",
-            "  private Provider<Sub.Builder> sBuilderProvider;",
-            "  private Provider<UsesSubcomponent> usesSubcomponentProvider;",
-            "",
-            "  private DaggerC(Builder builder) {",
-            "    initialize(builder);",
-            "  }",
+            "  private DaggerC(Builder builder) {}",
             "",
             "  public static Builder builder() {",
             "    return new Builder();",
@@ -93,18 +87,6 @@ public void testInlinedSubcomponentBuilders_componentMethod() {
             "    return new Builder().build();",
             "  }",
             "",
-            "  @SuppressWarnings(\"unchecked\")",
-            "  private void initialize(final Builder builder) {",
-            "    this.sBuilderProvider =",
-            "        new dagger.internal.Factory<Sub.Builder>() {",
-            "          @Override",
-            "          public Sub.Builder get() {",
-            "            return new SubBuilder();",
-            "          }",
-            "        };",
-            "   this.usesSubcomponentProvider = UsesSubcomponent_Factory.create(sBuilderProvider);",
-            "  }",
-            "",
             "  @Override",
             "  public Sub.Builder sBuilder() {",
             "    return new SubBuilder();",
diff --git a/javatests/dagger/internal/codegen/SubcomponentValidationTest.java b/javatests/dagger/internal/codegen/SubcomponentValidationTest.java
index 26d181181..f749f085b 100644
--- a/javatests/dagger/internal/codegen/SubcomponentValidationTest.java
+++ b/javatests/dagger/internal/codegen/SubcomponentValidationTest.java
@@ -955,17 +955,11 @@ public void subcomponentBuilderNamesShouldNotConflict() {
             "package test;",
             "",
             "import javax.annotation.Generated;",
-            "import javax.inject.Provider;",
             "",
             GENERATED_ANNOTATION,
             "public final class DaggerC implements C {",
             "",
-            "  private Provider<C.Foo.Sub.Builder> fooBuilderProvider;",
-            "  private Provider<C.Bar.Sub.Builder> barBuilderProvider;",
-            "",
-            "  private DaggerC(Builder builder) {",
-            "    initialize(builder);",
-            "  }",
+            "  private DaggerC(Builder builder) {}",
             "",
             "  public static Builder builder() {",
             "    return new Builder();",
@@ -975,25 +969,6 @@ public void subcomponentBuilderNamesShouldNotConflict() {
             "    return new Builder().build();",
             "  }",
             "",
-            "  @SuppressWarnings(\"unchecked\")",
-            "  private void initialize(final Builder builder) {",
-            "    this.fooBuilderProvider = ",
-            "        new dagger.internal.Factory<C.Foo.Sub.Builder>() {",
-            "          @Override",
-            "          public C.Foo.Sub.Builder get() {",
-            "            return new F_SubBuilder();",
-            "          }",
-            "        };",
-            "",
-            "    this.barBuilderProvider = ",
-            "        new dagger.internal.Factory<C.Bar.Sub.Builder>() {",
-            "          @Override",
-            "          public C.Bar.Sub.Builder get() {",
-            "            return new B_SubBuilder();",
-            "          }",
-            "        };",
-            "  }",
-            "",
             "  @Override",
             "  public C.Foo.Sub.Builder fooBuilder() {",
             "    return new F_SubBuilder();",
