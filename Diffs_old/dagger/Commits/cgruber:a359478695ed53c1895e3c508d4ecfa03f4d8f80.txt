diff --git a/compiler/src/it/producers-functional-tests/pom.xml b/compiler/src/it/producers-functional-tests/pom.xml
index fa44a2ef6..bc1c3c7b5 100644
--- a/compiler/src/it/producers-functional-tests/pom.xml
+++ b/compiler/src/it/producers-functional-tests/pom.xml
@@ -59,6 +59,11 @@ limitations under the License.
       <groupId>com.google.guava</groupId>
       <artifactId>guava</artifactId>
     </dependency>
+    <dependency>
+      <groupId>org.mockito</groupId>
+      <artifactId>mockito-core</artifactId>
+      <scope>test</scope>
+    </dependency>
   </dependencies>
   <build>
     <plugins>
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/test/SimpleProducerModule.java b/compiler/src/it/producers-functional-tests/src/main/java/test/SimpleProducerModule.java
index 92912785d..98f3cfb56 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/test/SimpleProducerModule.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/test/SimpleProducerModule.java
@@ -18,66 +18,202 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.util.concurrent.Futures;
 import com.google.common.util.concurrent.ListenableFuture;
+import com.google.common.util.concurrent.SettableFuture;
+import dagger.producers.Produced;
+import dagger.producers.Producer;
 import dagger.producers.ProducerModule;
 import dagger.producers.Produces;
+import java.io.IOException;
 import java.util.Set;
+import javax.inject.Provider;
 import javax.inject.Qualifier;
 
 import static dagger.producers.Produces.Type.SET;
 import static dagger.producers.Produces.Type.SET_VALUES;
 
+/**
+ * A module that contains various signatures of produces methods. This is not used in any
+ * components.
+ */
 @ProducerModule
 final class SimpleProducerModule {
   @Qualifier @interface Qual {
     int value();
   }
 
-  @Produces @Qual(0) String str() {
+  // Unique bindings.
+
+  @Produces
+  @Qual(-2)
+  static ListenableFuture<String> throwingProducer() {
+    throw new RuntimeException("monkey");
+  }
+
+  @Produces
+  @Qual(-1)
+  static ListenableFuture<String> settableFutureStr(SettableFuture<String> future) {
+    return future;
+  }
+
+  @Produces
+  @Qual(0)
+  static String str() {
     return "str";
   }
 
-  @Produces @Qual(1) ListenableFuture<String> futureStr() {
+  @Produces
+  @Qual(1)
+  static ListenableFuture<String> futureStr() {
     return Futures.immediateFuture("future str");
   }
 
-  @Produces @Qual(2) String strWithArg(int i) {
+  @Produces
+  @Qual(2)
+  static String strWithArg(int i) {
     return "str with arg";
   }
 
-  @Produces @Qual(3) ListenableFuture<String> futureStrWithArg(int i) {
+  @Produces
+  @Qual(3)
+  static ListenableFuture<String> futureStrWithArg(int i) {
     return Futures.immediateFuture("future str with arg");
   }
 
-  @Produces(type = SET) String setOfStrElement() {
+  @Produces
+  @Qual(4)
+  static String strThrowingException() throws IOException {
+    return "str throwing exception";
+  }
+
+  @Produces
+  @Qual(5)
+  static ListenableFuture<String> futureStrThrowingException() throws IOException {
+    return Futures.immediateFuture("future str throwing exception");
+  }
+
+  @Produces
+  @Qual(6)
+  static String strWithArgThrowingException(int i) throws IOException {
+    return "str with arg throwing exception";
+  }
+
+  @Produces
+  @Qual(7)
+  static ListenableFuture<String> futureStrWithArgThrowingException(int i) throws IOException {
+    return Futures.immediateFuture("future str with arg throwing exception");
+  }
+
+  @Produces
+  @Qual(8)
+  static String strWithArgs(int i, Produced<Double> b, Producer<Object> c, Provider<Boolean> d) {
+    return "str with args";
+  }
+
+  @Produces
+  @Qual(9)
+  static String strWithArgsThrowingException(
+      int i, Produced<Double> b, Producer<Object> c, Provider<Boolean> d) throws IOException {
+    return "str with args throwing exception";
+  }
+
+  @Produces
+  @Qual(10)
+  static ListenableFuture<String> futureStrWithArgs(
+      int i, Produced<Double> b, Producer<Object> c, Provider<Boolean> d) {
+    return Futures.immediateFuture("future str with args");
+  }
+
+  @Produces
+  @Qual(11)
+  static ListenableFuture<String> futureStrWithArgsThrowingException(
+      int i, Produced<Double> b, Producer<Object> c, Provider<Boolean> d) throws IOException {
+    return Futures.immediateFuture("str with args throwing exception");
+  }
+
+  // Set bindings.
+
+  @Produces(type = SET)
+  static String setOfStrElement() {
     return "set of str element";
   }
 
-  @Produces(type = SET) ListenableFuture<String> setOfStrFutureElement() {
+  @Produces(type = SET)
+  static String setOfStrElementThrowingException() throws IOException {
+    return "set of str element throwing exception";
+  }
+
+  @Produces(type = SET)
+  static ListenableFuture<String> setOfStrFutureElement() {
     return Futures.immediateFuture("set of str element");
   }
 
-  @Produces(type = SET) String setOfStrElementWithArg(int i) {
+  @Produces(type = SET)
+  static ListenableFuture<String> setOfStrFutureElementThrowingException() throws IOException {
+    return Futures.immediateFuture("set of str element throwing exception");
+  }
+
+  @Produces(type = SET)
+  static String setOfStrElementWithArg(int i) {
     return "set of str element with arg";
   }
 
-  @Produces(type = SET) ListenableFuture<String> setOfStrFutureElementWithArg(int i) {
+  @Produces(type = SET)
+  static String setOfStrElementWithArgThrowingException(int i) throws IOException {
+    return "set of str element with arg throwing exception";
+  }
+
+  @Produces(type = SET)
+  static ListenableFuture<String> setOfStrFutureElementWithArg(int i) {
     return Futures.immediateFuture("set of str element with arg");
   }
 
-  @Produces(type = SET_VALUES) Set<String> setOfStrValues() {
+  @Produces(type = SET)
+  static ListenableFuture<String> setOfStrFutureElementWithArgThrowingException(int i)
+      throws IOException {
+    return Futures.immediateFuture("set of str element with arg throwing exception");
+  }
+
+  @Produces(type = SET_VALUES)
+  static Set<String> setOfStrValues() {
     return ImmutableSet.of("set of str 1", "set of str 2");
   }
 
-  @Produces(type = SET_VALUES) ListenableFuture<Set<String>> setOfStrFutureValues() {
+  @Produces(type = SET_VALUES)
+  static Set<String> setOfStrValuesThrowingException() throws IOException {
+    return ImmutableSet.of("set of str 1", "set of str 2 throwing exception");
+  }
+
+  @Produces(type = SET_VALUES)
+  static ListenableFuture<Set<String>> setOfStrFutureValues() {
     return Futures.<Set<String>>immediateFuture(ImmutableSet.of("set of str 1", "set of str 2"));
   }
 
-  @Produces(type = SET_VALUES) Set<String> setOfStrValuesWithArg(int i) {
+  @Produces(type = SET_VALUES)
+  static ListenableFuture<Set<String>> setOfStrFutureValuesThrowingException() throws IOException {
+    return Futures.<Set<String>>immediateFuture(
+        ImmutableSet.of("set of str 1", "set of str 2 throwing exception"));
+  }
+
+  @Produces(type = SET_VALUES)
+  static Set<String> setOfStrValuesWithArg(int i) {
     return ImmutableSet.of("set of str with arg 1", "set of str with arg 2");
   }
 
-  @Produces(type = SET_VALUES) ListenableFuture<Set<String>> setOfStrFutureValuesWithArg(int i) {
-    return Futures.<Set<String>>immediateFuture(ImmutableSet.of(
-        "set of str with arg 1", "set of str with arg 2"));
+  @Produces(type = SET_VALUES)
+  static Set<String> setOfStrValuesWithArgThrowingException(int i) throws IOException {
+    return ImmutableSet.of("set of str with arg 1", "set of str with arg 2 throwing exception");
+  }
+
+  @Produces(type = SET_VALUES)
+  static ListenableFuture<Set<String>> setOfStrFutureValuesWithArg(int i) {
+    return Futures.<Set<String>>immediateFuture(
+        ImmutableSet.of("set of str with arg 1", "set of str with arg 2"));
+  }
+
+  @Produces(type = SET_VALUES)
+  static ListenableFuture<Set<String>> setOfStrFutureValuesWithArgThrowingException(int i)
+      throws IOException {
+    return Futures.<Set<String>>immediateFuture(
+        ImmutableSet.of("set of str with arg 1", "set of str with arg 2 throwing exception"));
   }
 }
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/test/ProducerFactoryTest.java b/compiler/src/it/producers-functional-tests/src/test/java/test/ProducerFactoryTest.java
index 5a37593d8..45e298a05 100644
--- a/compiler/src/it/producers-functional-tests/src/test/java/test/ProducerFactoryTest.java
+++ b/compiler/src/it/producers-functional-tests/src/test/java/test/ProducerFactoryTest.java
@@ -19,32 +19,176 @@
 import com.google.common.util.concurrent.MoreExecutors;
 import com.google.common.util.concurrent.SettableFuture;
 import dagger.producers.Producer;
+import dagger.producers.monitoring.ProducerMonitor;
+import dagger.producers.monitoring.ProducerToken;
+import dagger.producers.monitoring.ProductionComponentMonitor;
+import java.util.concurrent.ExecutionException;
+import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
+import org.mockito.InOrder;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
 
 import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+import static org.mockito.Mockito.any;
+import static org.mockito.Mockito.inOrder;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.verifyZeroInteractions;
+import static org.mockito.Mockito.when;
 
 @RunWith(JUnit4.class)
 public class ProducerFactoryTest {
-  @Test public void noArgMethod() throws Exception {
+  @Mock private ProductionComponentMonitor componentMonitor;
+  @Mock private ProducerMonitor monitor;
+
+  @Before
+  public void setUpMocks() {
+    MockitoAnnotations.initMocks(this);
+    when(componentMonitor.producerMonitorFor(any(ProducerToken.class))).thenReturn(monitor);
+  }
+
+  @Test
+  public void noArgMethod() throws Exception {
+    ProducerToken token = ProducerToken.create(SimpleProducerModule_StrFactory.class);
     SimpleProducerModule module = new SimpleProducerModule();
     Producer<String> producer =
-        new SimpleProducerModule_StrFactory(module, MoreExecutors.directExecutor());
+        new SimpleProducerModule_StrFactory(
+            componentMonitor, module, MoreExecutors.directExecutor());
     assertThat(producer.get().get()).isEqualTo("str");
+    InOrder order = inOrder(componentMonitor, monitor);
+    order.verify(componentMonitor).producerMonitorFor(token);
+    order.verify(monitor).methodStarting();
+    order.verify(monitor).methodFinished();
+    order.verify(monitor).succeeded("str");
+    order.verifyNoMoreInteractions();
   }
 
   @Test public void singleArgMethod() throws Exception {
     SimpleProducerModule module = new SimpleProducerModule();
     SettableFuture<Integer> intFuture = SettableFuture.create();
     Producer<Integer> intProducer = producerOfFuture(intFuture);
-    Producer<String> producer = new SimpleProducerModule_StrWithArgFactory(
-        module, MoreExecutors.directExecutor(), intProducer);
+    Producer<String> producer =
+        new SimpleProducerModule_StrWithArgFactory(
+            componentMonitor, module, MoreExecutors.directExecutor(), intProducer);
     assertThat(producer.get().isDone()).isFalse();
     intFuture.set(42);
     assertThat(producer.get().get()).isEqualTo("str with arg");
   }
 
+  @Test
+  public void successMonitor() throws Exception {
+    ProducerToken token = ProducerToken.create(SimpleProducerModule_SettableFutureStrFactory.class);
+
+    SimpleProducerModule module = new SimpleProducerModule();
+    SettableFuture<String> strFuture = SettableFuture.create();
+    SettableFuture<SettableFuture<String>> strFutureFuture = SettableFuture.create();
+    Producer<SettableFuture<String>> strFutureProducer = producerOfFuture(strFutureFuture);
+    Producer<String> producer =
+        new SimpleProducerModule_SettableFutureStrFactory(
+            componentMonitor, module, MoreExecutors.directExecutor(), strFutureProducer);
+    assertThat(producer.get().isDone()).isFalse();
+
+    InOrder order = inOrder(componentMonitor, monitor);
+    order.verify(componentMonitor).producerMonitorFor(token);
+
+    strFutureFuture.set(strFuture);
+    order.verify(monitor).methodStarting();
+    order.verify(monitor).methodFinished();
+    assertThat(producer.get().isDone()).isFalse();
+
+    strFuture.set("monkey");
+    assertThat(producer.get().get()).isEqualTo("monkey");
+    order.verify(monitor).succeeded("monkey");
+
+    order.verifyNoMoreInteractions();
+  }
+
+  @Test
+  public void failureMonitor() throws Exception {
+    ProducerToken token = ProducerToken.create(SimpleProducerModule_SettableFutureStrFactory.class);
+
+    SimpleProducerModule module = new SimpleProducerModule();
+    SettableFuture<String> strFuture = SettableFuture.create();
+    SettableFuture<SettableFuture<String>> strFutureFuture = SettableFuture.create();
+    Producer<SettableFuture<String>> strFutureProducer = producerOfFuture(strFutureFuture);
+    Producer<String> producer =
+        new SimpleProducerModule_SettableFutureStrFactory(
+            componentMonitor, module, MoreExecutors.directExecutor(), strFutureProducer);
+    assertThat(producer.get().isDone()).isFalse();
+
+    InOrder order = inOrder(componentMonitor, monitor);
+    order.verify(componentMonitor).producerMonitorFor(token);
+
+    strFutureFuture.set(strFuture);
+    order.verify(monitor).methodStarting();
+    order.verify(monitor).methodFinished();
+    assertThat(producer.get().isDone()).isFalse();
+
+    Throwable t = new RuntimeException("monkey");
+    strFuture.setException(t);
+    try {
+      producer.get().get();
+      fail();
+    } catch (ExecutionException e) {
+      assertThat(e.getCause()).isSameAs(t);
+      order.verify(monitor).failed(t);
+    }
+
+    order.verifyNoMoreInteractions();
+  }
+
+  @Test
+  public void failureMonitorDueToThrowingProducer() throws Exception {
+    ProducerToken token = ProducerToken.create(SimpleProducerModule_ThrowingProducerFactory.class);
+
+    SimpleProducerModule module = new SimpleProducerModule();
+    Producer<String> producer =
+        new SimpleProducerModule_ThrowingProducerFactory(
+            componentMonitor, module, MoreExecutors.directExecutor());
+    assertThat(producer.get().isDone()).isTrue();
+
+    InOrder order = inOrder(componentMonitor, monitor);
+    order.verify(componentMonitor).producerMonitorFor(token);
+
+    order.verify(monitor).methodStarting();
+    order.verify(monitor).methodFinished();
+
+    try {
+      producer.get().get();
+      fail();
+    } catch (ExecutionException e) {
+      order.verify(monitor).failed(e.getCause());
+    }
+
+    order.verifyNoMoreInteractions();
+  }
+
+  @Test
+  public void nullComponentMonitor() throws Exception {
+    SimpleProducerModule module = new SimpleProducerModule();
+    Producer<String> producer =
+        new SimpleProducerModule_StrFactory(null, module, MoreExecutors.directExecutor());
+    assertThat(producer.get().get()).isEqualTo("str");
+    verifyZeroInteractions(componentMonitor, monitor);
+  }
+
+  @Test
+  public void nullMonitor() throws Exception {
+    when(componentMonitor.producerMonitorFor(any(ProducerToken.class))).thenReturn(null);
+
+    ProducerToken token = ProducerToken.create(SimpleProducerModule_StrFactory.class);
+    SimpleProducerModule module = new SimpleProducerModule();
+    Producer<String> producer =
+        new SimpleProducerModule_StrFactory(
+            componentMonitor, module, MoreExecutors.directExecutor());
+    assertThat(producer.get().get()).isEqualTo("str");
+    verify(componentMonitor).producerMonitorFor(token);
+    verifyZeroInteractions(monitor);
+  }
+
   private static <T> Producer<T> producerOfFuture(final ListenableFuture<T> future) {
     return new Producer<T>() {
       @Override public ListenableFuture<T> get() {
diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
index d6bffaeaa..10d4214b9 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -963,7 +963,9 @@ private Snippet initializeFactoryForProductionBinding(ProductionBinding binding)
       case IMMEDIATE:
       case FUTURE_PRODUCTION:
         List<Snippet> parameters =
-            Lists.newArrayListWithCapacity(binding.dependencies().size() + 2);
+            Lists.newArrayListWithCapacity(binding.dependencies().size() + 3);
+        // TODO(beder): Pass the actual ProductionComponentMonitor.
+        parameters.add(Snippet.format("null"));
         parameters.add(getComponentContributionSnippet(binding.bindingTypeElement()));
         parameters.add(
             getComponentContributionSnippet(
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
index a4bf62c82..4a81f538d 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
@@ -15,7 +15,9 @@
  */
 package dagger.internal.codegen;
 
+import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
+import com.google.auto.value.AutoValue;
 import com.google.common.base.Function;
 import com.google.common.base.Joiner;
 import com.google.common.base.Optional;
@@ -44,10 +46,13 @@
 import dagger.producers.Produces;
 import dagger.producers.internal.AbstractProducer;
 import dagger.producers.internal.Producers;
+import dagger.producers.monitoring.ProducerToken;
+import dagger.producers.monitoring.ProductionComponentMonitor;
 import java.util.List;
 import java.util.concurrent.Callable;
 import java.util.concurrent.Executor;
 import javax.annotation.Generated;
+import javax.annotation.Nullable;
 import javax.annotation.processing.Filer;
 import javax.lang.model.element.Element;
 import javax.lang.model.type.TypeMirror;
@@ -103,8 +108,18 @@ ClassName nameGeneratedType(ProductionBinding binding) {
     ConstructorWriter constructorWriter = factoryWriter.addConstructor();
     constructorWriter.addModifiers(PUBLIC);
 
-    factoryWriter.addField(binding.bindingTypeElement(), "module")
-        .addModifiers(PRIVATE, FINAL);
+    constructorWriter
+        .addParameter(ProductionComponentMonitor.class, "componentMonitor")
+        .annotate(Nullable.class);
+    constructorWriter
+        .body()
+        .addSnippet(
+            "super(%s.producerMonitorFor(componentMonitor, %s.create(%s.class)));",
+            ClassName.fromClass(Producers.class),
+            ClassName.fromClass(ProducerToken.class),
+            factoryWriter.name());
+
+    factoryWriter.addField(binding.bindingTypeElement(), "module").addModifiers(PRIVATE, FINAL);
     constructorWriter.addParameter(binding.bindingTypeElement(), "module");
     constructorWriter.body()
         .addSnippet("assert module != null;")
@@ -173,30 +188,38 @@ ClassName nameGeneratedType(ProductionBinding binding) {
             Snippet.format(fields.get(dependency.bindingKey()).name()), dependency.kind()));
       }
       final boolean wrapWithFuture = false;  // since submitToExecutor will create the future
-      Snippet invocationSnippet = getInvocationSnippet(wrapWithFuture, binding,
-          parameterSnippets.build());
+      InvocationSnippets invocationSnippets =
+          getInvocationSnippets(wrapWithFuture, binding, parameterSnippets.build());
       TypeName callableReturnType = returnsFuture ? futureTypeName : providedTypeName;
       Snippet throwsClause = getThrowsClause(binding.thrownTypes());
-      Snippet callableSnippet = Snippet.format(Joiner.on('\n').join(
-          "new %1$s<%2$s>() {",
-          "  @Override public %2$s call() %3$s{",
-          "    return %4$s;",
-          "  }",
-          "}"),
-          ClassName.fromClass(Callable.class),
-          callableReturnType,
-          throwsClause,
-          invocationSnippet);
-      getMethodWriter.body().addSnippet("%s future = %s.submitToExecutor(%s, executor);",
-          ParameterizedTypeName.create(
-              ClassName.fromClass(ListenableFuture.class),
-              callableReturnType),
-          ClassName.fromClass(Producers.class),
-          callableSnippet);
-      getMethodWriter.body().addSnippet("return %s;",
-          returnsFuture
-              ? Snippet.format("%s.dereference(future)", ClassName.fromClass(Futures.class))
-              : "future");
+      Snippet callableSnippet =
+          Snippet.format(
+              Joiner.on('\n')
+                  .join(
+                      "new %1$s<%2$s>() {",
+                      "  @Override public %2$s call() %3$s{",
+                      "    %4$s",
+                      "  }",
+                      "}"),
+              ClassName.fromClass(Callable.class),
+              callableReturnType,
+              throwsClause,
+              invocationSnippets.asMethodBody());
+      getMethodWriter
+          .body()
+          .addSnippet(
+              "%s future = %s.submitToExecutor(%s, executor);",
+              ParameterizedTypeName.create(
+                  ClassName.fromClass(ListenableFuture.class), callableReturnType),
+              ClassName.fromClass(Producers.class),
+              callableSnippet);
+      getMethodWriter
+          .body()
+          .addSnippet(
+              "return %s;",
+              returnsFuture
+                  ? Snippet.format("%s.dereference(future)", ClassName.fromClass(Futures.class))
+                  : "future");
     } else {
       final Snippet futureSnippet;
       final Snippet transformSnippet;
@@ -218,22 +241,25 @@ ClassName nameGeneratedType(ProductionBinding binding) {
           }
         }
         boolean wrapWithFuture = !returnsFuture;  // only wrap if we don't already have a future
-        Snippet invocationSnippet = getInvocationSnippet(wrapWithFuture, binding,
-            parameterSnippets.build());
+        InvocationSnippets invocationSnippets =
+            getInvocationSnippets(wrapWithFuture, binding, parameterSnippets.build());
         Snippet throwsClause = getThrowsClause(binding.thrownTypes());
-        transformSnippet = Snippet.format(Joiner.on('\n').join(
-            "new %1$s<%2$s, %3$s>() {",
-            "  @Override public %4$s apply(%2$s %5$s) %6$s{",
-            "    return %7$s;",
-            "  }",
-            "}"),
-            ClassName.fromClass(AsyncFunction.class),
-            asyncDependencyType(asyncDependency),
-            providedTypeName,
-            futureTypeName,
-            argName,
-            throwsClause,
-            invocationSnippet);
+        transformSnippet =
+            Snippet.format(
+                Joiner.on('\n')
+                    .join(
+                        "new %1$s<%2$s, %3$s>() {",
+                        "  @Override public %4$s apply(%2$s %5$s) %6$s{",
+                        "    %7$s",
+                        "  }",
+                        "}"),
+                ClassName.fromClass(AsyncFunction.class),
+                asyncDependencyType(asyncDependency),
+                providedTypeName,
+                futureTypeName,
+                argName,
+                throwsClause,
+                invocationSnippets.asMethodBody());
       } else {
         futureSnippet = Snippet.format("%s.<%s>allAsList(%s)",
             ClassName.fromClass(Futures.class),
@@ -248,24 +274,28 @@ ClassName nameGeneratedType(ProductionBinding binding) {
                 })));
         ImmutableList<Snippet> parameterSnippets = getParameterSnippets(binding, fields, "args");
         boolean wrapWithFuture = !returnsFuture;  // only wrap if we don't already have a future
-        Snippet invocationSnippet = getInvocationSnippet(wrapWithFuture, binding,
-            parameterSnippets);
-        ParameterizedTypeName listOfObject = ParameterizedTypeName.create(
-            ClassName.fromClass(List.class), ClassName.fromClass(Object.class));
+        InvocationSnippets invocationSnippets =
+            getInvocationSnippets(wrapWithFuture, binding, parameterSnippets);
+        ParameterizedTypeName listOfObject =
+            ParameterizedTypeName.create(
+                ClassName.fromClass(List.class), ClassName.fromClass(Object.class));
         Snippet throwsClause = getThrowsClause(binding.thrownTypes());
-        transformSnippet = Snippet.format(Joiner.on('\n').join(
-            "new %1$s<%2$s, %3$s>() {",
-            "  @SuppressWarnings(\"unchecked\")  // safe by specification",
-            "  @Override public %4$s apply(%2$s args) %5$s{",
-            "    return %6$s;",
-            "  }",
-            "}"),
-            ClassName.fromClass(AsyncFunction.class),
-            listOfObject,
-            providedTypeName,
-            futureTypeName,
-            throwsClause,
-            invocationSnippet);
+        transformSnippet =
+            Snippet.format(
+                Joiner.on('\n')
+                    .join(
+                        "new %1$s<%2$s, %3$s>() {",
+                        "  @SuppressWarnings(\"unchecked\")  // safe by specification",
+                        "  @Override public %4$s apply(%2$s args) %5$s{",
+                        "    %6$s",
+                        "  }",
+                        "}"),
+                ClassName.fromClass(AsyncFunction.class),
+                listOfObject,
+                providedTypeName,
+                futureTypeName,
+                throwsClause,
+                invocationSnippets.asMethodBody());
       }
       getMethodWriter.body().addSnippet("return %s.%s(%s, %s, executor);",
           ClassName.fromClass(Futures.class),
@@ -321,40 +351,82 @@ private TypeName asyncDependencyType(DependencyRequest dependency) {
     return snippets.build();
   }
 
+  /** A collection of snippets for invoking a producer method. */
+  @AutoValue
+  abstract static class InvocationSnippets {
+    /** A list of statements forming a code block that must be called in succession. */
+    abstract ImmutableList<Snippet> setupSnippets();
+
+    /** An expression that represents the wrapped value resulting from invoking the method. */
+    abstract Snippet expressionSnippet();
+
+    /** Returns this invocation as a self-contained method body. */
+    Snippet asMethodBody() {
+      return Snippet.format(
+          "%s return %s;", Snippet.join(Joiner.on('\n'), setupSnippets()), expressionSnippet());
+    }
+
+    static InvocationSnippets create(
+        ImmutableList<Snippet> setupSnippets, Snippet expressionSnippet) {
+      return new AutoValue_ProducerFactoryGenerator_InvocationSnippets(
+          setupSnippets, expressionSnippet);
+    }
+  }
+
   /**
-   * Creates a Snippet for the invocation of the producer method from the module.
+   * Creates snippets for the invocation of the producer method from the module.
    *
    * @param wrapWithFuture If true, wraps the result of the call to the producer method
    *        in an immediate future.
    * @param binding The binding to generate the invocation snippet for.
    * @param parameterSnippets The snippets for all the parameters to the producer method.
    */
-  private Snippet getInvocationSnippet(boolean wrapWithFuture, ProductionBinding binding,
-      ImmutableList<Snippet> parameterSnippets) {
-    Snippet moduleSnippet = Snippet.format("module.%s(%s)",
-        binding.bindingElement().getSimpleName(),
-        makeParametersSnippet(parameterSnippets));
+  private InvocationSnippets getInvocationSnippets(
+      boolean wrapWithFuture, ProductionBinding binding, ImmutableList<Snippet> parameterSnippets) {
+    // NOTE(beder): We don't worry about catching exeptions from the monitor methods themselves
+    // because we'll wrap all monitoring in non-throwing monitors before we pass them to the
+    // factories.
+    ImmutableList.Builder<Snippet> snippets = ImmutableList.builder();
+    snippets.add(Snippet.format("if (monitor != null) { monitor.methodStarting(); }"));
+    snippets.add(
+        Snippet.format(
+            "final %s value;",
+            TypeNames.forTypeMirror(
+                MoreElements.asExecutable(binding.bindingElement()).getReturnType())));
+    snippets.add(
+        Snippet.format(
+            Joiner.on('\n')
+                .join(
+                    "try {",
+                    "  value = module.%s(%s);",
+                    "} finally {",
+                    "  if (monitor != null) { monitor.methodFinished(); }",
+                    "}"),
+            binding.bindingElement().getSimpleName(),
+            makeParametersSnippet(parameterSnippets)));
     final Snippet valueSnippet;
     if (binding.productionType().equals(Produces.Type.SET)) {
       if (binding.bindingKind().equals(ProductionBinding.Kind.FUTURE_PRODUCTION)) {
-        valueSnippet = Snippet.format("%s.createFutureSingletonSet(%s)",
-            ClassName.fromClass(Producers.class),
-            moduleSnippet);
+        valueSnippet =
+            Snippet.format(
+                "%s.createFutureSingletonSet(%s)", ClassName.fromClass(Producers.class), "value");
       } else {
-        valueSnippet = Snippet.format("%s.of(%s)",
-            ClassName.fromClass(ImmutableSet.class),
-            moduleSnippet);
+        valueSnippet =
+            Snippet.format("%s.of(%s)", ClassName.fromClass(ImmutableSet.class), "value");
       }
     } else {
-      valueSnippet = moduleSnippet;
+      valueSnippet = Snippet.format("value");
     }
     if (wrapWithFuture) {
-      return Snippet.format("%s.<%s>immediateFuture(%s)",
-          ClassName.fromClass(Futures.class),
-          TypeNames.forTypeMirror(binding.key().type()),
-          valueSnippet);
+      return InvocationSnippets.create(
+          snippets.build(),
+          Snippet.format(
+              "%s.<%s>immediateFuture(%s)",
+              ClassName.fromClass(Futures.class),
+              TypeNames.forTypeMirror(binding.key().type()),
+              valueSnippet));
     } else {
-      return valueSnippet;
+      return InvocationSnippets.create(snippets.build(), valueSnippet);
     }
   }
 
diff --git a/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java b/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
index fa466a630..ceba430a7 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+// TODO(beder): Merge the error-handling tests with the ModuleFactoryGeneratorTest.
 package dagger.internal.codegen;
 
 import com.google.common.collect.ImmutableList;
@@ -465,699 +466,68 @@ public void publicModuleNonPublicIncludes() {
         "    return null;",
         "  }",
         "}");
-    JavaFileObject factoryFile = JavaFileObjects.forSourceLines("TestModule_ProduceStringFactory",
-        "package test;",
-        "",
-        "import com.google.common.util.concurrent.Futures;",
-        "import com.google.common.util.concurrent.ListenableFuture;",
-        "import dagger.producers.internal.AbstractProducer;",
-        "import dagger.producers.internal.Producers;",
-        "import java.util.concurrent.Callable;",
-        "import java.util.concurrent.Executor;",
-        "import javax.annotation.Generated;",
-        "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class TestModule_ProduceStringFactory extends AbstractProducer<String> {",
-        "  private final TestModule module;",
-        "  private final Executor executor;",
-        "",
-        "  public TestModule_ProduceStringFactory(TestModule module, Executor executor) {",
-        "    assert module != null;",
-        "    this.module = module;",
-        "    assert executor != null;",
-        "    this.executor = executor;",
-        "  }",
-        "",
-        "  @Override protected ListenableFuture<String> compute() {",
-        "    ListenableFuture<ListenableFuture<String>> future = Producers.submitToExecutor(",
-        "      new Callable<ListenableFuture<String>>() {",
-        "        @Override public ListenableFuture<String> call() {",
-        "          return module.produceString();",
-        "        }",
-        "      }, executor);",
-        "    return Futures.dereference(future);",
-        "  }",
-        "}");
-    assertAbout(javaSource()).that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError()
-        .and().generatesSources(factoryFile);
-  }
-
-  @Test public void singleProducesMethodNoArgsFutureSet() {
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import com.google.common.util.concurrent.ListenableFuture;",
-        "import dagger.producers.ProducerModule;",
-        "import dagger.producers.Produces;",
-        "",
-        "@ProducerModule",
-        "final class TestModule {",
-        "  @Produces(type = Produces.Type.SET)",
-        "  ListenableFuture<String> produceString() {",
-        "    return null;",
-        "  }",
-        "}");
-    JavaFileObject factoryFile = JavaFileObjects.forSourceLines("TestModule_ProduceStringFactory",
-        "package test;",
-        "",
-        "import com.google.common.util.concurrent.Futures;",
-        "import com.google.common.util.concurrent.ListenableFuture;",
-        "import dagger.producers.internal.AbstractProducer;",
-        "import dagger.producers.internal.Producers;",
-        "import java.util.Set;",
-        "import java.util.concurrent.Callable;",
-        "import java.util.concurrent.Executor;",
-        "import javax.annotation.Generated;",
-        "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class TestModule_ProduceStringFactory",
-        "    extends AbstractProducer<Set<String>> {",
-        "  private final TestModule module;",
-        "  private final Executor executor;",
-        "",
-        "  public TestModule_ProduceStringFactory(TestModule module, Executor executor) {  ",
-        "    assert module != null;",
-        "    this.module = module;",
-        "    assert executor != null;",
-        "    this.executor = executor;",
-        "  }",
-        "",
-        "  @Override",
-        "  protected ListenableFuture<Set<String>> compute() {  ",
-        "    ListenableFuture<ListenableFuture<Set<String>>> future =",
-        "        Producers.submitToExecutor(new Callable<ListenableFuture<Set<String>>>() {",
-        "      @Override public ListenableFuture<Set<String>> call() {",
-        "        return Producers.createFutureSingletonSet(module.produceString());",
-        "      }",
-        "    }, executor);",
-        "    return Futures.dereference(future);",
-        "  }",
-        "}");
-    assertAbout(javaSource()).that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError()
-        .and().generatesSources(factoryFile);
-  }
-
-  @Test public void singleProducesMethodNoArgsNoFuture() {
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import dagger.producers.ProducerModule;",
-        "import dagger.producers.Produces;",
-        "",
-        "@ProducerModule",
-        "final class TestModule {",
-        "  @Produces String produceString() {",
-        "    return \"\";",
-        "  }",
-        "}");
-    JavaFileObject factoryFile = JavaFileObjects.forSourceLines("TestModule_ProduceStringFactory",
-        "package test;",
-        "",
-        "import com.google.common.util.concurrent.ListenableFuture;",
-        "import dagger.producers.internal.AbstractProducer;",
-        "import dagger.producers.internal.Producers;",
-        "import java.util.concurrent.Callable;",
-        "import java.util.concurrent.Executor;",
-        "import javax.annotation.Generated;",
-        "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class TestModule_ProduceStringFactory extends AbstractProducer<String> {",
-        "  private final TestModule module;",
-        "  private final Executor executor;",
-        "",
-        "  public TestModule_ProduceStringFactory(TestModule module, Executor executor) {",
-        "    assert module != null;",
-        "    this.module = module;",
-        "    assert executor != null;",
-        "    this.executor = executor;",
-        "  }",
-        "",
-        "  @Override protected ListenableFuture<String> compute() {",
-        "    ListenableFuture<String> future = Producers.submitToExecutor(",
-        "      new Callable<String>() {",
-        "        @Override public String call() {",
-        "          return module.produceString();",
-        "        }",
-        "      }, executor);",
-        "    return future;",
-        "  }",
-        "}");
-    assertAbout(javaSource()).that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError()
-        .and().generatesSources(factoryFile);
-  }
-
-  @Test public void singleProducesMethodNoArgsNoFutureSet() {
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import dagger.producers.ProducerModule;",
-        "import dagger.producers.Produces;",
-        "",
-        "@ProducerModule",
-        "final class TestModule {",
-        "  @Produces(type = Produces.Type.SET)",
-        "  String produceString() {",
-        "    return \"\";",
-        "  }",
-        "}");
-    JavaFileObject factoryFile = JavaFileObjects.forSourceLines("TestModule_ProduceStringFactory",
-        "package test;",
-        "",
-        "import com.google.common.collect.ImmutableSet;",
-        "import com.google.common.util.concurrent.ListenableFuture;",
-        "import dagger.producers.internal.AbstractProducer;",
-        "import dagger.producers.internal.Producers;",
-        "import java.util.Set;",
-        "import java.util.concurrent.Callable;",
-        "import java.util.concurrent.Executor;",
-        "import javax.annotation.Generated;",
-        "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class TestModule_ProduceStringFactory",
-        "    extends AbstractProducer<Set<String>> {",
-        "  private final TestModule module;",
-        "  private final Executor executor;",
-        "",
-        "  public TestModule_ProduceStringFactory(TestModule module, Executor executor) {  ",
-        "    assert module != null;",
-        "    this.module = module;",
-        "    assert executor != null;",
-        "    this.executor = executor;",
-        "  }",
-        "",
-        "  @Override",
-        "  protected ListenableFuture<Set<String>> compute() {  ",
-        "    ListenableFuture<Set<String>> future =",
-        "        Producers.submitToExecutor(new Callable<Set<String>>() {",
-        "      @Override public Set<String> call() {",
-        "        return ImmutableSet.of(module.produceString());",
-        "      }",
-        "    }, executor);",
-        "    return future;",
-        "  }",
-        "}");
-    assertAbout(javaSource()).that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError()
-        .and().generatesSources(factoryFile);
-  }
-
-  @Test public void singleProducesMethodArgsFuture() {
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import com.google.common.util.concurrent.ListenableFuture;",
-        "import dagger.producers.Produced;",
-        "import dagger.producers.Producer;",
-        "import dagger.producers.ProducerModule;",
-        "import dagger.producers.Produces;",
-        "import javax.inject.Provider;",
-        "",
-        "@ProducerModule",
-        "final class TestModule {",
-        "  @Produces ListenableFuture<String> produceString(",
-        "      int a, Produced<Double> b, Producer<Object> c, Provider<Boolean> d) {",
-        "    return null;",
-        "  }",
-        "}");
-    JavaFileObject factoryFile = JavaFileObjects.forSourceLines("TestModule_ProduceStringFactory",
-        "package test;",
-        "",
-        "import com.google.common.util.concurrent.AsyncFunction;",
-        "import com.google.common.util.concurrent.Futures;",
-        "import com.google.common.util.concurrent.ListenableFuture;",
-        "import dagger.producers.Produced;",
-        "import dagger.producers.Producer;",
-        "import dagger.producers.internal.AbstractProducer;",
-        "import dagger.producers.internal.Producers;",
-        "import java.util.List;",
-        "import java.util.concurrent.Executor;",
-        "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
-        "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class TestModule_ProduceStringFactory extends AbstractProducer<String> {",
-        "  private final TestModule module;",
-        "  private final Executor executor;",
-        "  private final Producer<Integer> aProducer;",
-        "  private final Producer<Double> bProducer;",
-        "  private final Producer<Object> cProducer;",
-        "  private final Provider<Boolean> dProvider;",
-        "",
-        "  public TestModule_ProduceStringFactory(",
-        "      TestModule module,",
-        "      Executor executor,",
-        "      Producer<Integer> aProducer,",
-        "      Producer<Double> bProducer,",
-        "      Producer<Object> cProducer,",
-        "      Provider<Boolean> dProvider) {",
-        "    assert module != null;",
-        "    this.module = module;",
-        "    assert executor != null;",
-        "    this.executor = executor;",
-        "    assert aProducer != null;",
-        "    this.aProducer = aProducer;",
-        "    assert bProducer != null;",
-        "    this.bProducer = bProducer;",
-        "    assert cProducer != null;",
-        "    this.cProducer = cProducer;",
-        "    assert dProvider != null;",
-        "    this.dProvider = dProvider;",
-        "  }",
-        "",
-        "  @Override protected ListenableFuture<String> compute() {",
-        "    ListenableFuture<Integer> aProducerFuture = aProducer.get();",
-        "    ListenableFuture<Produced<Double>> bProducerFuture =",
-        "        Producers.createFutureProduced(bProducer.get());",
-        "    return Futures.transform(",
-        "        Futures.<Object>allAsList(aProducerFuture, bProducerFuture),",
-        "        new AsyncFunction<List<Object>, String>() {",
-        "          @SuppressWarnings(\"unchecked\")  // safe by specification",
-        "          @Override public ListenableFuture<String> apply(List<Object> args) {",
-        "            return module.produceString(",
-        "                (Integer) args.get(0),",
-        "                (Produced<Double>) args.get(1),",
-        "                cProducer,",
-        "                dProvider);",
-        "          }",
-        "        }, executor);",
-        "  }",
-        "}");
-    assertAbout(javaSource()).that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError()
-        .and().generatesSources(factoryFile);
-  }
-
-  @Test public void singleProducesMethodArgsNoFuture() {
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import dagger.producers.Produced;",
-        "import dagger.producers.Producer;",
-        "import dagger.producers.ProducerModule;",
-        "import dagger.producers.Produces;",
-        "import javax.inject.Provider;",
-        "",
-        "@ProducerModule",
-        "final class TestModule {",
-        "  @Produces String produceString(",
-        "      int a, Produced<Double> b, Producer<Object> c, Provider<Boolean> d) {",
-        "    return \"\";",
-        "  }",
-        "}");
-    JavaFileObject factoryFile = JavaFileObjects.forSourceLines("TestModule_ProduceStringFactory",
-        "package test;",
-        "",
-        "import com.google.common.util.concurrent.AsyncFunction;",
-        "import com.google.common.util.concurrent.Futures;",
-        "import com.google.common.util.concurrent.ListenableFuture;",
-        "import dagger.producers.Produced;",
-        "import dagger.producers.Producer;",
-        "import dagger.producers.internal.AbstractProducer;",
-        "import dagger.producers.internal.Producers;",
-        "import java.util.List;",
-        "import java.util.concurrent.Executor;",
-        "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
-        "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class TestModule_ProduceStringFactory extends AbstractProducer<String> {",
-        "  private final TestModule module;",
-        "  private final Executor executor;",
-        "  private final Producer<Integer> aProducer;",
-        "  private final Producer<Double> bProducer;",
-        "  private final Producer<Object> cProducer;",
-        "  private final Provider<Boolean> dProvider;",
-        "",
-        "  public TestModule_ProduceStringFactory(",
-        "      TestModule module,",
-        "      Executor executor,",
-        "      Producer<Integer> aProducer,",
-        "      Producer<Double> bProducer,",
-        "      Producer<Object> cProducer,",
-        "      Provider<Boolean> dProvider) {",
-        "    assert module != null;",
-        "    this.module = module;",
-        "    assert executor != null;",
-        "    this.executor = executor;",
-        "    assert aProducer != null;",
-        "    this.aProducer = aProducer;",
-        "    assert bProducer != null;",
-        "    this.bProducer = bProducer;",
-        "    assert cProducer != null;",
-        "    this.cProducer = cProducer;",
-        "    assert dProvider != null;",
-        "    this.dProvider = dProvider;",
-        "  }",
-        "",
-        "  @Override protected ListenableFuture<String> compute() {",
-        "    ListenableFuture<Integer> aProducerFuture = aProducer.get();",
-        "    ListenableFuture<Produced<Double>> bProducerFuture =",
-        "        Producers.createFutureProduced(bProducer.get());",
-        "    return Futures.transform(",
-        "        Futures.<Object>allAsList(aProducerFuture, bProducerFuture),",
-        "        new AsyncFunction<List<Object>, String>() {",
-        "          @SuppressWarnings(\"unchecked\")  // safe by specification",
-        "          @Override public ListenableFuture<String> apply(List<Object> args) {",
-        "            return Futures.<String>immediateFuture(module.produceString(",
-        "                (Integer) args.get(0),",
-        "                (Produced<Double>) args.get(1),",
-        "                cProducer,",
-        "                dProvider));",
-        "          }",
-        "        }, executor);",
-        "  }",
-        "}");
-    assertAbout(javaSource()).that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError()
-        .and().generatesSources(factoryFile);
-  }
-
-  @Test public void singleProducesMethodSingleArgsFuture() {
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import com.google.common.util.concurrent.ListenableFuture;",
-        "import dagger.producers.ProducerModule;",
-        "import dagger.producers.Produces;",
-        "",
-        "@ProducerModule",
-        "final class TestModule {",
-        "  @Produces ListenableFuture<String> produceString(int a) {",
-        "    return null;",
-        "  }",
-        "}");
-    JavaFileObject factoryFile = JavaFileObjects.forSourceLines("TestModule_ProduceStringFactory",
-        "package test;",
-        "",
-        "import com.google.common.util.concurrent.AsyncFunction;",
-        "import com.google.common.util.concurrent.Futures;",
-        "import com.google.common.util.concurrent.ListenableFuture;",
-        "import dagger.producers.Producer;",
-        "import dagger.producers.internal.AbstractProducer;",
-        "import java.util.concurrent.Executor;",
-        "import javax.annotation.Generated;",
-        "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class TestModule_ProduceStringFactory extends AbstractProducer<String> {",
-        "  private final TestModule module;",
-        "  private final Executor executor;",
-        "  private final Producer<Integer> aProducer;",
-        "",
-        "  public TestModule_ProduceStringFactory(",
-        "      TestModule module,",
-        "      Executor executor,",
-        "      Producer<Integer> aProducer) {",
-        "    assert module != null;",
-        "    this.module = module;",
-        "    assert executor != null;",
-        "    this.executor = executor;",
-        "    assert aProducer != null;",
-        "    this.aProducer = aProducer;",
-        "  }",
-        "",
-        "  @Override protected ListenableFuture<String> compute() {",
-        "    ListenableFuture<Integer> aProducerFuture = aProducer.get();",
-        "    return Futures.transform(aProducerFuture,",
-        "        new AsyncFunction<Integer, String>() {",
-        "          @Override public ListenableFuture<String> apply(Integer a) {",
-        "            return module.produceString(a);",
-        "          }",
-        "        }, executor);",
-        "  }",
-        "}");
-    assertAbout(javaSource()).that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError()
-        .and().generatesSources(factoryFile);
-  }
-
-  @Test public void singleProducesMethodCheckedException() {
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import com.google.common.util.concurrent.ListenableFuture;",
-        "import dagger.producers.ProducerModule;",
-        "import dagger.producers.Produces;",
-        "import java.io.IOException;",
-        "",
-        "@ProducerModule",
-        "final class TestModule {",
-        "  @Produces ListenableFuture<String> produceString()",
-        "      throws InterruptedException, IOException {",
-        "    return null;",
-        "  }",
-        "}");
-    JavaFileObject factoryFile = JavaFileObjects.forSourceLines("TestModule_ProduceStringFactory",
-        "package test;",
-        "",
-        "import com.google.common.util.concurrent.Futures;",
-        "import com.google.common.util.concurrent.ListenableFuture;",
-        "import dagger.producers.internal.AbstractProducer;",
-        "import dagger.producers.internal.Producers;",
-        "import java.io.IOException;",
-        "import java.util.concurrent.Callable;",
-        "import java.util.concurrent.Executor;",
-        "import javax.annotation.Generated;",
-        "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class TestModule_ProduceStringFactory extends AbstractProducer<String> {",
-        "  private final TestModule module;",
-        "  private final Executor executor;",
-        "",
-        "  public TestModule_ProduceStringFactory(TestModule module, Executor executor) {",
-        "    assert module != null;",
-        "    this.module = module;",
-        "    assert executor != null;",
-        "    this.executor = executor;",
-        "  }",
-        "",
-        "  @Override protected ListenableFuture<String> compute() {",
-        "    ListenableFuture<ListenableFuture<String>> future = Producers.submitToExecutor(",
-        "      new Callable<ListenableFuture<String>>() {",
-        "        @Override public ListenableFuture<String> call()",
-        "            throws InterruptedException, IOException {",
-        "          return module.produceString();",
-        "        }",
-        "      }, executor);",
-        "    return Futures.dereference(future);",
-        "  }",
-        "}");
-    assertAbout(javaSource()).that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError()
-        .and().generatesSources(factoryFile);
-  }
-
-  @Test public void singleProducesMethodCheckedExceptionNoFuture() {
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import dagger.producers.ProducerModule;",
-        "import dagger.producers.Produces;",
-        "import java.io.IOException;",
-        "",
-        "@ProducerModule",
-        "final class TestModule {",
-        "  @Produces String produceString() throws IOException {",
-        "    return \"\";",
-        "  }",
-        "}");
-    JavaFileObject factoryFile = JavaFileObjects.forSourceLines("TestModule_ProduceStringFactory",
-        "package test;",
-        "",
-        "import com.google.common.util.concurrent.ListenableFuture;",
-        "import dagger.producers.internal.AbstractProducer;",
-        "import dagger.producers.internal.Producers;",
-        "import java.io.IOException;",
-        "import java.util.concurrent.Callable;",
-        "import java.util.concurrent.Executor;",
-        "import javax.annotation.Generated;",
-        "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class TestModule_ProduceStringFactory extends AbstractProducer<String> {",
-        "  private final TestModule module;",
-        "  private final Executor executor;",
-        "",
-        "  public TestModule_ProduceStringFactory(TestModule module, Executor executor) {",
-        "    assert module != null;",
-        "    this.module = module;",
-        "    assert executor != null;",
-        "    this.executor = executor;",
-        "  }",
-        "",
-        "  @Override protected ListenableFuture<String> compute() {",
-        "    ListenableFuture<String> future = Producers.submitToExecutor(",
-        "      new Callable<String>() {",
-        "        @Override public String call() throws IOException {",
-        "          return module.produceString();",
-        "        }",
-        "      }, executor);",
-        "    return future;",
-        "  }",
-        "}");
-    assertAbout(javaSource()).that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError()
-        .and().generatesSources(factoryFile);
-  }
-
-  @Test public void singleProducesMethodCheckedExceptionFuture() {
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import com.google.common.util.concurrent.ListenableFuture;",
-        "import dagger.producers.Produced;",
-        "import dagger.producers.Producer;",
-        "import dagger.producers.ProducerModule;",
-        "import dagger.producers.Produces;",
-        "import java.io.IOException;",
-        "import javax.inject.Provider;",
-        "",
-        "@ProducerModule",
-        "final class TestModule {",
-        "  @Produces ListenableFuture<String> produceString(",
-        "      int a, Produced<Double> b, Producer<Object> c, Provider<Boolean> d)",
-        "          throws IOException {",
-        "    return null;",
-        "  }",
-        "}");
-    JavaFileObject factoryFile = JavaFileObjects.forSourceLines("TestModule_ProduceStringFactory",
-        "package test;",
-        "",
-        "import com.google.common.util.concurrent.AsyncFunction;",
-        "import com.google.common.util.concurrent.Futures;",
-        "import com.google.common.util.concurrent.ListenableFuture;",
-        "import dagger.producers.Produced;",
-        "import dagger.producers.Producer;",
-        "import dagger.producers.internal.AbstractProducer;",
-        "import dagger.producers.internal.Producers;",
-        "import java.io.IOException;",
-        "import java.util.List;",
-        "import java.util.concurrent.Executor;",
-        "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
-        "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class TestModule_ProduceStringFactory extends AbstractProducer<String> {",
-        "  private final TestModule module;",
-        "  private final Executor executor;",
-        "  private final Producer<Integer> aProducer;",
-        "  private final Producer<Double> bProducer;",
-        "  private final Producer<Object> cProducer;",
-        "  private final Provider<Boolean> dProvider;",
-        "",
-        "  public TestModule_ProduceStringFactory(",
-        "      TestModule module,",
-        "      Executor executor,",
-        "      Producer<Integer> aProducer,",
-        "      Producer<Double> bProducer,",
-        "      Producer<Object> cProducer,",
-        "      Provider<Boolean> dProvider) {",
-        "    assert module != null;",
-        "    this.module = module;",
-        "    assert executor != null;",
-        "    this.executor = executor;",
-        "    assert aProducer != null;",
-        "    this.aProducer = aProducer;",
-        "    assert bProducer != null;",
-        "    this.bProducer = bProducer;",
-        "    assert cProducer != null;",
-        "    this.cProducer = cProducer;",
-        "    assert dProvider != null;",
-        "    this.dProvider = dProvider;",
-        "  }",
-        "",
-        "  @Override protected ListenableFuture<String> compute() {",
-        "    ListenableFuture<Integer> aProducerFuture = aProducer.get();",
-        "    ListenableFuture<Produced<Double>> bProducerFuture =",
-        "        Producers.createFutureProduced(bProducer.get());",
-        "    return Futures.transform(",
-        "        Futures.<Object>allAsList(aProducerFuture, bProducerFuture),",
-        "        new AsyncFunction<List<Object>, String>() {",
-        "          @SuppressWarnings(\"unchecked\")  // safe by specification",
-        "          @Override public ListenableFuture<String> apply(List<Object> args)",
-        "              throws IOException {",
-        "            return module.produceString(",
-        "                (Integer) args.get(0),",
-        "                (Produced<Double>) args.get(1),",
-        "                cProducer,",
-        "                dProvider);",
-        "          }",
-        "        }, executor);",
-        "  }",
-        "}");
-    assertAbout(javaSource()).that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError()
-        .and().generatesSources(factoryFile);
-  }
-
-  @Test public void singleProducesMethodCheckedExceptionNoArgsFutureSet() {
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import com.google.common.util.concurrent.ListenableFuture;",
-        "import dagger.producers.ProducerModule;",
-        "import dagger.producers.Produces;",
-        "import java.io.IOException;",
-        "",
-        "@ProducerModule",
-        "final class TestModule {",
-        "  @Produces(type = Produces.Type.SET)",
-        "  ListenableFuture<String> produceString() throws IOException {",
-        "    return null;",
-        "  }",
-        "}");
-    JavaFileObject factoryFile = JavaFileObjects.forSourceLines("TestModule_ProduceStringFactory",
-        "package test;",
-        "",
-        "import com.google.common.util.concurrent.Futures;",
-        "import com.google.common.util.concurrent.ListenableFuture;",
-        "import dagger.producers.internal.AbstractProducer;",
-        "import dagger.producers.internal.Producers;",
-        "import java.io.IOException;",
-        "import java.util.Set;",
-        "import java.util.concurrent.Callable;",
-        "import java.util.concurrent.Executor;",
-        "import javax.annotation.Generated;",
-        "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class TestModule_ProduceStringFactory",
-        "    extends AbstractProducer<Set<String>> {",
-        "  private final TestModule module;",
-        "  private final Executor executor;",
-        "",
-        "  public TestModule_ProduceStringFactory(TestModule module, Executor executor) {  ",
-        "    assert module != null;",
-        "    this.module = module;",
-        "    assert executor != null;",
-        "    this.executor = executor;",
-        "  }",
-        "",
-        "  @Override",
-        "  protected ListenableFuture<Set<String>> compute() {  ",
-        "    ListenableFuture<ListenableFuture<Set<String>>> future =",
-        "        Producers.submitToExecutor(new Callable<ListenableFuture<Set<String>>>() {",
-        "      @Override public ListenableFuture<Set<String>> call() throws IOException {",
-        "        return Producers.createFutureSingletonSet(module.produceString());",
-        "      }",
-        "    }, executor);",
-        "    return Futures.dereference(future);",
-        "  }",
-        "}");
-    assertAbout(javaSource()).that(moduleFile)
+    JavaFileObject factoryFile =
+        JavaFileObjects.forSourceLines(
+            "TestModule_ProduceStringFactory",
+            "package test;",
+            "",
+            "import com.google.common.util.concurrent.Futures;",
+            "import com.google.common.util.concurrent.ListenableFuture;",
+            "import dagger.producers.internal.AbstractProducer;",
+            "import dagger.producers.internal.Producers;",
+            "import dagger.producers.monitoring.ProducerToken;",
+            "import dagger.producers.monitoring.ProductionComponentMonitor;",
+            "import java.util.concurrent.Callable;",
+            "import java.util.concurrent.Executor;",
+            "import javax.annotation.Generated;",
+            "import javax.annotation.Nullable;",
+            "",
+            "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+            "public final class TestModule_ProduceStringFactory extends AbstractProducer<String> {",
+            "  private final TestModule module;",
+            "  private final Executor executor;",
+            "",
+            "  public TestModule_ProduceStringFactory(",
+            "      @Nullable ProductionComponentMonitor componentMonitor,",
+            "      TestModule module,",
+            "      Executor executor) {",
+            "    super(",
+            "        Producers.producerMonitorFor(",
+            "            componentMonitor,",
+            "            ProducerToken.create(TestModule_ProduceStringFactory.class)));",
+            "    assert module != null;",
+            "    this.module = module;",
+            "    assert executor != null;",
+            "    this.executor = executor;",
+            "  }",
+            "",
+            "  @Override protected ListenableFuture<String> compute() {",
+            "    ListenableFuture<ListenableFuture<String>> future = Producers.submitToExecutor(",
+            "      new Callable<ListenableFuture<String>>() {",
+            "        @Override public ListenableFuture<String> call() {",
+            "          if (monitor != null) {",
+            "            monitor.methodStarting();",
+            "          }",
+            "          final ListenableFuture<String> value;",
+            "          try {",
+            "            value = module.produceString();",
+            "          } finally {",
+            "            if (monitor != null) {",
+            "              monitor.methodFinished();",
+            "            }",
+            "          }",
+            "          return value;",
+            "        }",
+            "      }, executor);",
+            "    return Futures.dereference(future);",
+            "  }",
+            "}");
+    assertAbout(javaSource())
+        .that(moduleFile)
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
-        .and().generatesSources(factoryFile);
+        .and()
+        .generatesSources(factoryFile);
   }
 
   private static final JavaFileObject QUALIFIER_A =
diff --git a/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java
index b5ebd972b..4128539eb 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java
@@ -123,97 +123,103 @@
         "    ListenableFuture<A> a();",
         "  }",
         "}");
-    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
-        "test.DaggerTestClass_SimpleComponent",
-        "package test;",
-        "",
-        "import com.google.common.util.concurrent.ListenableFuture;",
-        "import dagger.producers.Producer;",
-        "import dagger.producers.internal.Producers;",
-        "import java.util.concurrent.Executor;",
-        "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
-        "import test.TestClass.A;",
-        "import test.TestClass.AModule;",
-        "import test.TestClass.B;",
-        "import test.TestClass.BModule;",
-        "import test.TestClass.SimpleComponent;",
-        "",
-        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class DaggerTestClass_SimpleComponent implements SimpleComponent {",
-        "  private Provider<B> bProvider;",
-        "  private Producer<A> aProducer;",
-        "",
-        "  private DaggerTestClass_SimpleComponent(Builder builder) {",
-        "    assert builder != null;",
-        "    initialize(builder);",
-        "  }",
-        "",
-        "  public static Builder builder() {",
-        "    return new Builder();",
-        "  }",
-        "",
-        "  private void initialize(final Builder builder) {",
-        "    this.bProvider = TestClass$BModule_BFactory.create(",
-        "        builder.bModule, TestClass$C_Factory.create());",
-        "    this.aProducer = new TestClass$AModule_AFactory(",
-        "        builder.aModule, builder.executor, Producers.producerFromProvider(bProvider));",
-        "  }",
-        "",
-        "  @Override",
-        "  public ListenableFuture<A> a() {",
-        "    return aProducer.get();",
-        "  }",
-        "",
-        "  public static final class Builder {",
-        "    private AModule aModule;",
-        "    private BModule bModule;",
-        "    private Executor executor;",
-        "",
-        "    private Builder() {",
-        "    }",
-        "",
-        "    public SimpleComponent build() {",
-        "      if (aModule == null) {",
-        "        this.aModule = new AModule();",
-        "      }",
-        "      if (bModule == null) {",
-        "        this.bModule = new BModule();",
-        "      }",
-        "      if (executor == null) {",
-        "        throw new IllegalStateException(\"executor must be set\");",
-        "      }",
-        "      return new DaggerTestClass_SimpleComponent(this);",
-        "    }",
-        "",
-        "    public Builder aModule(AModule aModule) {",
-        "      if (aModule == null) {",
-        "        throw new NullPointerException(\"aModule\");",
-        "      }",
-        "      this.aModule = aModule;",
-        "      return this;",
-        "    }",
-        "",
-        "    public Builder bModule(BModule bModule) {",
-        "      if (bModule == null) {",
-        "        throw new NullPointerException(\"bModule\");",
-        "      }",
-        "      this.bModule = bModule;",
-        "      return this;",
-        "    }",
-        "",
-        "    public Builder executor(Executor executor) {",
-        "      if (executor == null) {",
-        "        throw new NullPointerException(\"executor\");",
-        "      }",
-        "      this.executor = executor;",
-        "      return this;",
-        "    }",
-        "  }",
-        "}");
-    assertAbout(javaSource()).that(component)
+    JavaFileObject generatedComponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerTestClass_SimpleComponent",
+            "package test;",
+            "",
+            "import com.google.common.util.concurrent.ListenableFuture;",
+            "import dagger.producers.Producer;",
+            "import dagger.producers.internal.Producers;",
+            "import java.util.concurrent.Executor;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "import test.TestClass.A;",
+            "import test.TestClass.AModule;",
+            "import test.TestClass.B;",
+            "import test.TestClass.BModule;",
+            "import test.TestClass.SimpleComponent;",
+            "",
+            "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+            "public final class DaggerTestClass_SimpleComponent implements SimpleComponent {",
+            "  private Provider<B> bProvider;",
+            "  private Producer<A> aProducer;",
+            "",
+            "  private DaggerTestClass_SimpleComponent(Builder builder) {",
+            "    assert builder != null;",
+            "    initialize(builder);",
+            "  }",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  private void initialize(final Builder builder) {",
+            "    this.bProvider = TestClass$BModule_BFactory.create(",
+            "        builder.bModule, TestClass$C_Factory.create());",
+            "    this.aProducer = new TestClass$AModule_AFactory(",
+            "        null,",
+            "        builder.aModule,",
+            "        builder.executor,",
+            "        Producers.producerFromProvider(bProvider));",
+            "  }",
+            "",
+            "  @Override",
+            "  public ListenableFuture<A> a() {",
+            "    return aProducer.get();",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private AModule aModule;",
+            "    private BModule bModule;",
+            "    private Executor executor;",
+            "",
+            "    private Builder() {",
+            "    }",
+            "",
+            "    public SimpleComponent build() {",
+            "      if (aModule == null) {",
+            "        this.aModule = new AModule();",
+            "      }",
+            "      if (bModule == null) {",
+            "        this.bModule = new BModule();",
+            "      }",
+            "      if (executor == null) {",
+            "        throw new IllegalStateException(\"executor must be set\");",
+            "      }",
+            "      return new DaggerTestClass_SimpleComponent(this);",
+            "    }",
+            "",
+            "    public Builder aModule(AModule aModule) {",
+            "      if (aModule == null) {",
+            "        throw new NullPointerException(\"aModule\");",
+            "      }",
+            "      this.aModule = aModule;",
+            "      return this;",
+            "    }",
+            "",
+            "    public Builder bModule(BModule bModule) {",
+            "      if (bModule == null) {",
+            "        throw new NullPointerException(\"bModule\");",
+            "      }",
+            "      this.bModule = bModule;",
+            "      return this;",
+            "    }",
+            "",
+            "    public Builder executor(Executor executor) {",
+            "      if (executor == null) {",
+            "        throw new NullPointerException(\"executor\");",
+            "      }",
+            "      this.executor = executor;",
+            "      return this;",
+            "    }",
+            "  }",
+            "}");
+    assertAbout(javaSource())
+        .that(component)
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
-        .and().generatesSources(generatedComponent);
+        .and()
+        .generatesSources(generatedComponent);
   }
 }
diff --git a/producers/pom.xml b/producers/pom.xml
index 32ecaf0a5..1ee555b97 100644
--- a/producers/pom.xml
+++ b/producers/pom.xml
@@ -49,5 +49,10 @@
       <artifactId>truth</artifactId>
       <scope>test</scope>
     </dependency>
+    <dependency>
+      <groupId>org.mockito</groupId>
+      <artifactId>mockito-core</artifactId>
+      <scope>test</scope>
+    </dependency>
   </dependencies>
 </project>
diff --git a/producers/src/main/java/dagger/producers/internal/AbstractProducer.java b/producers/src/main/java/dagger/producers/internal/AbstractProducer.java
index 43659980b..7843b2094 100644
--- a/producers/src/main/java/dagger/producers/internal/AbstractProducer.java
+++ b/producers/src/main/java/dagger/producers/internal/AbstractProducer.java
@@ -15,8 +15,12 @@
  */
 package dagger.producers.internal;
 
+import com.google.common.util.concurrent.FutureCallback;
+import com.google.common.util.concurrent.Futures;
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.producers.Producer;
+import dagger.producers.monitoring.ProducerMonitor;
+import javax.annotation.Nullable;
 
 /**
  * An abstract {@link Producer} implementation that memoizes the result of its compute method.
@@ -25,8 +29,17 @@
  * @since 2.0
  */
 public abstract class AbstractProducer<T> implements Producer<T> {
+  @Nullable protected final ProducerMonitor monitor;
   private volatile ListenableFuture<T> instance = null;
 
+  protected AbstractProducer() {
+    this(null);
+  }
+
+  protected AbstractProducer(@Nullable ProducerMonitor monitor) {
+    this.monitor = monitor;
+  }
+
   /** Computes this producer's future, which is then cached in {@link #get}. */
   protected abstract ListenableFuture<T> compute();
 
@@ -42,6 +55,21 @@
           if (result == null) {
             throw new NullPointerException("compute returned null");
           }
+          if (monitor != null) {
+            Futures.addCallback(
+                result,
+                new FutureCallback<T>() {
+                  @Override
+                  public void onSuccess(T value) {
+                    monitor.succeeded(value);
+                  }
+
+                  @Override
+                  public void onFailure(Throwable t) {
+                    monitor.failed(t);
+                  }
+                });
+          }
         }
       }
     }
diff --git a/producers/src/main/java/dagger/producers/internal/Producers.java b/producers/src/main/java/dagger/producers/internal/Producers.java
index 983834249..6cd06d40e 100644
--- a/producers/src/main/java/dagger/producers/internal/Producers.java
+++ b/producers/src/main/java/dagger/producers/internal/Producers.java
@@ -23,10 +23,14 @@
 import com.google.common.util.concurrent.ListenableFutureTask;
 import dagger.producers.Produced;
 import dagger.producers.Producer;
+import dagger.producers.monitoring.ProducerMonitor;
+import dagger.producers.monitoring.ProducerToken;
+import dagger.producers.monitoring.ProductionComponentMonitor;
 import java.util.Set;
 import java.util.concurrent.Callable;
 import java.util.concurrent.Executor;
 import java.util.concurrent.RejectedExecutionException;
+import javax.annotation.Nullable;
 import javax.inject.Provider;
 
 import static com.google.common.base.Preconditions.checkNotNull;
@@ -105,11 +109,22 @@
   public static <T> Producer<T> producerFromProvider(final Provider<T> provider) {
     checkNotNull(provider);
     return new AbstractProducer<T>() {
-      @Override protected ListenableFuture<T> compute() {
+      @Override
+      protected ListenableFuture<T> compute() {
         return Futures.immediateFuture(provider.get());
       }
     };
   }
 
+  /** Lifts {@link ProductionComponentMonitor#producerMonitorFor} to nullable types. */
+  @Nullable
+  public static ProducerMonitor producerMonitorFor(
+      @Nullable ProductionComponentMonitor componentMonitor, ProducerToken token) {
+    if (componentMonitor != null) {
+      return componentMonitor.producerMonitorFor(token);
+    }
+    return null;
+  }
+
   private Producers() {}
 }
diff --git a/producers/src/main/java/dagger/producers/internal/SetProducer.java b/producers/src/main/java/dagger/producers/internal/SetProducer.java
index 399dbd031..ba3312882 100644
--- a/producers/src/main/java/dagger/producers/internal/SetProducer.java
+++ b/producers/src/main/java/dagger/producers/internal/SetProducer.java
@@ -45,6 +45,7 @@
   private final Set<Producer<Set<T>>> contributingProducers;
 
   private SetProducer(Set<Producer<Set<T>>> contributingProducers) {
+    super();
     this.contributingProducers = contributingProducers;
   }
 
diff --git a/producers/src/test/java/dagger/producers/internal/AbstractProducerTest.java b/producers/src/test/java/dagger/producers/internal/AbstractProducerTest.java
index e307166f5..15a64bd1f 100644
--- a/producers/src/test/java/dagger/producers/internal/AbstractProducerTest.java
+++ b/producers/src/test/java/dagger/producers/internal/AbstractProducerTest.java
@@ -17,25 +17,38 @@
 
 import com.google.common.util.concurrent.Futures;
 import com.google.common.util.concurrent.ListenableFuture;
+import com.google.common.util.concurrent.SettableFuture;
 import dagger.producers.Producer;
+import dagger.producers.monitoring.ProducerMonitor;
+import java.util.concurrent.ExecutionException;
+import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
 
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.fail;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.verifyNoMoreInteractions;
+import static org.mockito.Mockito.verifyZeroInteractions;
 
 /**
  * Tests {@link AbstractProducer}.
  */
 @RunWith(JUnit4.class)
 public class AbstractProducerTest {
-  @Test public void get_nullPointerException() {
-    Producer<Object> producer = new AbstractProducer<Object>() {
-      @Override public ListenableFuture<Object> compute() {
-        return null;
-      }
-    };
+  @Mock private ProducerMonitor monitor;
+
+  @Before
+  public void initMocks() {
+    MockitoAnnotations.initMocks(this);
+  }
+
+  @Test
+  public void get_nullPointerException() {
+    Producer<Object> producer = new DelegateProducer<>(monitor, null);
     try {
       producer.get();
       fail();
@@ -44,15 +57,71 @@
   }
 
   @Test public void get() throws Exception {
-    Producer<Integer> producer = new AbstractProducer<Integer>() {
-      int i = 0;
+    Producer<Integer> producer =
+        new AbstractProducer<Integer>(monitor) {
+          int i = 0;
 
-      @Override public ListenableFuture<Integer> compute() {
-        return Futures.immediateFuture(i++);
-      }
-    };
+          @Override
+          public ListenableFuture<Integer> compute() {
+            return Futures.immediateFuture(i++);
+          }
+        };
     assertThat(producer.get().get()).isEqualTo(0);
     assertThat(producer.get().get()).isEqualTo(0);
     assertThat(producer.get().get()).isEqualTo(0);
   }
+
+  @Test
+  public void monitor_success() throws Exception {
+    SettableFuture<Integer> delegateFuture = SettableFuture.create();
+    Producer<Integer> producer = new DelegateProducer<>(monitor, delegateFuture);
+
+    ListenableFuture<Integer> future = producer.get();
+    assertThat(future.isDone()).isFalse();
+    verifyZeroInteractions(monitor);
+    delegateFuture.set(-42);
+    assertThat(future.get()).isEqualTo(-42);
+    verify(monitor).succeeded(-42);
+    verifyNoMoreInteractions(monitor);
+  }
+
+  @Test
+  public void monitor_failure() throws Exception {
+    SettableFuture<Integer> delegateFuture = SettableFuture.create();
+    Producer<Integer> producer = new DelegateProducer<>(monitor, delegateFuture);
+
+    ListenableFuture<Integer> future = producer.get();
+    assertThat(future.isDone()).isFalse();
+    verifyZeroInteractions(monitor);
+    Throwable t = new RuntimeException("monkey");
+    delegateFuture.setException(t);
+    try {
+      future.get();
+      fail();
+    } catch (ExecutionException e) {
+      assertThat(e.getCause()).isSameAs(t);
+    }
+    verify(monitor).failed(t);
+    verifyNoMoreInteractions(monitor);
+  }
+
+  @Test
+  public void monitor_null() throws Exception {
+    Producer<Integer> producer = new DelegateProducer<>(null, Futures.immediateFuture(42));
+    assertThat(producer.get().get()).isEqualTo(42);
+  }
+
+  static final class DelegateProducer<T> extends AbstractProducer<T> {
+    private final ListenableFuture<T> delegate;
+
+    DelegateProducer(ProducerMonitor monitor, ListenableFuture<T> delegate) {
+      super(monitor);
+      this.delegate = delegate;
+    }
+
+    @Override
+    public ListenableFuture<T> compute() {
+      return delegate;
+    }
+  }
 }
