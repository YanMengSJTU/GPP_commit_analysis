diff --git a/compiler/src/main/java/dagger/internal/codegen/ClassName.java b/compiler/src/main/java/dagger/internal/codegen/ClassName.java
index ff94ae117..89ce24e96 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ClassName.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ClassName.java
@@ -83,7 +83,7 @@ String suggestedVariableName() {
         CaseFormat.UPPER_CAMEL.to(CaseFormat.LOWER_CAMEL, simpleName()));
   }
 
-  ClassName nameOfTopLevelClass() {
+  ClassName topLevelClassName() {
     Iterator<String> enclosingIterator = enclosingSimpleNames().iterator();
     return enclosingIterator.hasNext()
         ? new AutoValue_ClassName(packageName(), ImmutableList.<String>of(),
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
index 6805bab47..1ae4a0724 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
@@ -22,7 +22,6 @@
 import com.google.common.base.Optional;
 import com.google.common.collect.Collections2;
 import com.google.common.collect.ImmutableBiMap;
-import com.google.common.collect.ImmutableCollection;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
@@ -101,8 +100,8 @@
   ClassName nameGeneratedType(ComponentDescriptor input) {
     ClassName componentDefinitionClassName =
         ClassName.fromTypeElement(input.componentDefinitionType());
-    return componentDefinitionClassName.peerNamed(
-        "Dagger_" + componentDefinitionClassName.simpleName());
+    return componentDefinitionClassName.topLevelClassName().peerNamed(
+        "Dagger_" + componentDefinitionClassName.classFileName());
   }
 
   @Override
@@ -120,8 +119,7 @@ void write(ClassName componentName, JavaWriter writer, ComponentDescriptor input
       throws IOException {
     writer.emitPackage(componentName.packageName());
 
-    writeImports(writer, componentName, input.interfaceRequests(),
-        input.resolvedProvisionBindings().values());
+    writeImports(writer, componentName, input);
 
     writer.emitAnnotation(Generated.class, stringLiteral(ComponentProcessor.class.getName()));
     writer.beginType(componentName.simpleName(), "class", EnumSet.of(PUBLIC, FINAL), null,
@@ -159,14 +157,20 @@ void write(ClassName componentName, JavaWriter writer, ComponentDescriptor input
   }
 
   private void writeImports(JavaWriter writer, ClassName factoryClassName,
-      ImmutableList<DependencyRequest> interfaceRequests,
-      ImmutableCollection<ProvisionBinding> bindings) throws IOException {
+      ComponentDescriptor input) throws IOException {
+
     ImmutableSortedSet.Builder<ClassName> importsBuilder =
         ImmutableSortedSet.<ClassName>naturalOrder()
-            .addAll(collectImportsFromDependencies(factoryClassName, interfaceRequests))
+            .addAll(collectImportsFromDependencies(factoryClassName, input.interfaceRequests()))
             .add(ClassName.fromClass(Generated.class))
             .add(ClassName.fromClass(Provider.class));
-    for (ProvisionBinding binding : bindings) {
+
+    ClassName componentClassName = ClassName.fromTypeElement(input.componentDefinitionType());
+    if (!componentClassName.enclosingSimpleNames().isEmpty()) {
+      importsBuilder.add(componentClassName);
+    }
+
+    for (ProvisionBinding binding : input.resolvedProvisionBindings().values()) {
       if (binding.scope().isPresent()) {
         importsBuilder.add(ClassName.fromClass(ScopedProvider.class));
       }
diff --git a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
index d90f839e6..a847b782c 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
@@ -144,6 +144,10 @@ private void writeImports(JavaWriter writer, ClassName factoryClassName, Provisi
             .addAll(collectImportsFromDependencies(factoryClassName, binding.dependencies()))
             .add(ClassName.fromClass(Factory.class))
             .add(ClassName.fromClass(Generated.class));
+    ClassName bindingClassName = ClassName.fromTypeElement(binding.bindingTypeElement());
+    if(!bindingClassName.enclosingSimpleNames().isEmpty()) {
+      importsBuilder.add(bindingClassName);
+    }
     if (binding.provisionType().equals(Provides.Type.SET)) {
       importsBuilder.add(ClassName.fromClass(Collections.class));
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
index 28ab5f31d..c72f15f30 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
@@ -80,8 +80,7 @@
 
   @Override
   ClassName nameGeneratedType(MembersInjectionBinding binding) {
-    ClassName injectedClassName = ClassName.fromTypeElement(binding.injectedType());
-    return injectedClassName.peerNamed(injectedClassName.simpleName() + "$$MembersInjector");
+    return SourceFiles.membersInjectorNameForMembersInjectionBinding(binding);
   }
 
   @Override
@@ -115,6 +114,9 @@ void write(ClassName injectorClassName, JavaWriter writer, MembersInjectionBindi
     importsBuilder.addAll(collectImportsFromDependencies(injectorClassName, dependencies));
     importsBuilder.add(ClassName.fromClass(MembersInjector.class));
     importsBuilder.add(ClassName.fromClass(Generated.class));
+    if(!injectedClassName.enclosingSimpleNames().isEmpty()) {
+      importsBuilder.add(injectedClassName);
+    }
     if (supertype.isPresent()) {
       ClassName supertypeClassName = ClassName.fromTypeElement(supertype.get());
       if (!supertypeClassName.packageName().equals(injectorClassName.packageName())) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
index eb8b74a7e..e42aaf972 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
@@ -97,7 +97,7 @@
         // don't include classes in java.lang or the same package
         if (!packagesToSkip.contains(className.packageName())
             // or that are members of the same top-level class
-            && !className.nameOfTopLevelClass().equals(topLevelClassName)) {
+            && !className.topLevelClassName().equals(topLevelClassName)) {
           builder.add(className);
         }
       }
@@ -255,17 +255,17 @@ static ClassName factoryNameForProvisionBinding(ProvisionBinding binding) {
     switch (binding.bindingKind()) {
       case INJECTION:
       case PROVISION:
-        return enclosingClassName.peerNamed(
-            enclosingClassName.simpleName() + "$$" + factoryPrefix(binding) + "Factory");
+        return enclosingClassName.topLevelClassName().peerNamed(
+            enclosingClassName.classFileName() + "$$" + factoryPrefix(binding) + "Factory");
       default:
         throw new AssertionError();
     }
   }
 
   static ClassName membersInjectorNameForMembersInjectionBinding(MembersInjectionBinding binding) {
-    TypeElement injectedTypeElement = binding.injectedType();
-    ClassName injectedClassName = ClassName.fromTypeElement(injectedTypeElement);
-    return injectedClassName.peerNamed(injectedClassName.classFileName() + "$$MembersInjector");
+    ClassName injectedClassName = ClassName.fromTypeElement(binding.injectedType());
+    return injectedClassName.topLevelClassName().peerNamed(
+        injectedClassName.classFileName() + "$$MembersInjector");
   }
 
   private static String factoryPrefix(ProvisionBinding binding) {
diff --git a/compiler/src/test/java/dagger/internal/codegen/ClassNameTest.java b/compiler/src/test/java/dagger/internal/codegen/ClassNameTest.java
index 8895aff5e..eb50e9795 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ClassNameTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ClassNameTest.java
@@ -16,8 +16,14 @@
 package dagger.internal.codegen;
 
 import com.google.common.collect.ImmutableList;
+import com.google.testing.compile.CompilationRule;
+import dagger.internal.codegen.ClassNameTest.OuterClass.InnerClass;
 import java.util.Map;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
 import org.junit.Test;
+import org.junit.Rule;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
@@ -26,6 +32,8 @@
 
 @RunWith(JUnit4.class)
 public class ClassNameTest {
+  @Rule public CompilationRule compilationRule = new CompilationRule();
+
   @Test public void bestGuessForString_simpleClass() {
     ASSERT.that(ClassName.bestGuessFromString(String.class.getName()))
         .isEqualTo(ClassName.create("java.lang", "String"));
@@ -67,4 +75,38 @@
       fail();
     } catch (IllegalArgumentException expected) {}
   }
+
+  @Test public void classNameFromTypeElement() {
+    Elements elements = compilationRule.getElements();
+    TypeElement element = elements.getTypeElement(Object.class.getCanonicalName());
+    ASSERT.that(ClassName.fromTypeElement(element).fullyQualifiedName())
+        .isEqualTo("java.lang.Object");
+  }
+
+  @Test public void peerNamed_topLevelClass() {
+    Elements elements = compilationRule.getElements();
+    TypeElement element = elements.getTypeElement(ClassNameTest.class.getCanonicalName());
+    ClassName className = ClassName.fromTypeElement(element);
+    ClassName peerName = className.peerNamed("Foo");
+    ASSERT.that(peerName.fullyQualifiedName())
+        .isEqualTo("dagger.internal.codegen.Foo");
+  }
+
+  @Test public void peerNamed_nestedClass() {
+    Elements elements = compilationRule.getElements();
+    TypeElement element = elements.getTypeElement(OuterClass.class.getCanonicalName());
+    ClassName className = ClassName.fromTypeElement(element);
+    ClassName peerName = className.peerNamed("Foo");
+    ASSERT.that(peerName.fullyQualifiedName())
+        .isEqualTo("dagger.internal.codegen.ClassNameTest.Foo");
+  }
+
+  @Test public void peerNamed_deeplyNestedClass() {
+    Elements elements = compilationRule.getElements();
+    TypeElement element = elements.getTypeElement(InnerClass.class.getCanonicalName());
+    ClassName className = ClassName.fromTypeElement(element);
+    ClassName peerName = className.peerNamed("Foo");
+    ASSERT.that(peerName.fullyQualifiedName())
+        .isEqualTo("dagger.internal.codegen.ClassNameTest.OuterClass.Foo");
+  }
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
index f938b422b..d67eda327 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
@@ -207,6 +207,98 @@
         .and().generatesSources(generatedComponent);
   }
 
+  @Test public void simpleComponentWithNesting() {
+    JavaFileObject nestedTypesFile = JavaFileObjects.forSourceLines("test.OuterType",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import javax.inject.Inject;",
+        "",
+        "final class OuterType {",
+        "  static class A {",
+        "    @Inject A() {}",
+        "  }",
+        "  static class B {",
+        "    @Inject A a;",
+        "  }",
+        "  @Component interface SimpleComponent {",
+        "    A a();",
+        "    void inject(B b);",
+        "  }",
+        "}");
+    JavaFileObject aFactory = JavaFileObjects.forSourceLines(
+        "test.OuterType$A$$Factory",
+        "package test;",
+        "",
+        "import dagger.Factory;",
+        "import javax.annotation.Generated;",
+        "import test.OuterType.A;",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class OuterType$A$$Factory implements Factory<A> {",
+        "",
+        "  @Override public A get() {",
+        "    return new A();",
+        "  }",
+        "}");
+    JavaFileObject bMembersInjector = JavaFileObjects.forSourceLines(
+        "test.OuterType$B$$MembersInjector",
+        "package test;",
+        "",
+        "import dagger.MembersInjector;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "import test.OuterType.B;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "final class OuterType$B$$MembersInjector implements MembersInjector<B> {",
+        "  private final Provider<OuterType.A> aProvider;",
+         "",
+        "  OuterType$B$$MembersInjector(Provider<OuterType.A> aProvider) {",
+        "    assert aProvider != null;",
+        "    this.aProvider = aProvider;",
+        "  }",
+         "",
+        "  @Override",
+        "  public void injectMembers(B instance) {",
+        "    if (instance == null) {",
+        "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
+        "    }",
+        "    instance.a = aProvider.get();",
+        "  }",
+        "}");
+
+    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
+        "test.Dagger_OuterType$SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.MembersInjector;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "import test.OuterType.SimpleComponent;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class Dagger_OuterType$SimpleComponent implements SimpleComponent {",
+        "  private final Provider<OuterType.A> aProvider;",
+        "  private final MembersInjector<OuterType.B> bMembersInjector;",
+        "",
+        "  public Dagger_OuterType$SimpleComponent() {",
+        "    this.aProvider = new OuterType$A$$Factory();",
+        "    this.bMembersInjector = new OuterType$B$$MembersInjector(aProvider);",
+        "  }",
+        "",
+        "  @Override public OuterType.A a() {",
+        "    return aProvider.get();",
+        "  }",
+        "  @Override public void inject(OuterType.B b) {",
+        "    bMembersInjector.injectMembers(b);",
+        "  }",
+        "}");
+     ASSERT.about(javaSources()).that(ImmutableList.of(nestedTypesFile))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(aFactory, bMembersInjector, generatedComponent);
+  }
+
   @Test public void componentWithModule() {
     JavaFileObject aFile = JavaFileObjects.forSourceLines("test.A",
         "package test;",
