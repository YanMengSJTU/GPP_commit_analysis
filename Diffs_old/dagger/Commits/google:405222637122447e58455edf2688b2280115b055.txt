diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
index e01cc2043..df57561c2 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
@@ -30,14 +30,11 @@
 import com.google.common.collect.Sets;
 import dagger.Component;
 import dagger.MembersInjector;
-import dagger.Module;
 import dagger.Provides;
 import java.util.Deque;
-import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Map.Entry;
-import java.util.Queue;
 import java.util.Set;
 import javax.inject.Provider;
 import javax.lang.model.element.AnnotationMirror;
@@ -53,6 +50,7 @@
 import static com.google.auto.common.MoreElements.getAnnotationMirror;
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static com.google.common.base.Preconditions.checkState;
+import static dagger.internal.codegen.ConfigurationAnnotations.getTransitiveModules;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.type.TypeKind.VOID;
 
@@ -136,26 +134,6 @@
       this.dependencyRequestFactory = dependencyRequestFactory;
     }
 
-    private ImmutableSet<TypeElement> getTransitiveModules(ImmutableSet<TypeElement> seedModules) {
-      Queue<TypeElement> moduleQueue = Queues.newArrayDeque(seedModules);
-      LinkedHashSet<TypeElement> moduleElements = Sets.newLinkedHashSet();
-      for (TypeElement moduleElement = moduleQueue.poll();
-          moduleElement != null;
-          moduleElement = moduleQueue.poll()) {
-        moduleElements.add(moduleElement);
-        AnnotationMirror moduleMirror =
-            getAnnotationMirror(moduleElement, Module.class).get();
-        ImmutableSet<TypeElement> moduleDependencies = MoreTypes.asTypeElements(types,
-            ConfigurationAnnotations.getModuleIncludes(elements, moduleMirror));
-        for (TypeElement dependencyType : moduleDependencies) {
-          if (!moduleElements.contains(dependencyType)) {
-            moduleQueue.add(dependencyType);
-          }
-        }
-      }
-      return ImmutableSet.copyOf(moduleElements);
-    }
-
     ComponentDescriptor create(TypeElement componentDefinitionType)
         throws SourceFileGenerationException {
       AnnotationMirror componentMirror =
@@ -164,7 +142,8 @@ ComponentDescriptor create(TypeElement componentDefinitionType)
           ConfigurationAnnotations.getComponentModules(elements, componentMirror));
       ImmutableSet<TypeElement> componentDependencyTypes = MoreTypes.asTypeElements(types,
           ConfigurationAnnotations.getComponentDependencies(elements, componentMirror));
-      ImmutableSet<TypeElement> transitiveModules = getTransitiveModules(moduleTypes);
+      ImmutableSet<TypeElement> transitiveModules =
+          getTransitiveModules(elements, types, moduleTypes);
 
       ProvisionBinding componentBinding =
           provisionBindingFactory.forComponent(componentDefinitionType);
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
index ea1406b2d..7e8f1b2c8 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
@@ -66,7 +66,6 @@
 import javax.lang.model.element.AnnotationValue;
 import javax.lang.model.element.AnnotationValueVisitor;
 import javax.lang.model.element.Element;
-import javax.lang.model.element.ElementKind;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.Name;
@@ -87,11 +86,15 @@
 import static dagger.internal.codegen.SourceFiles.generateMembersInjectorNamesForBindings;
 import static dagger.internal.codegen.SourceFiles.generateProviderNamesForBindings;
 import static dagger.internal.codegen.SourceFiles.membersInjectorNameForMembersInjectionBinding;
+import static javax.lang.model.element.ElementKind.CONSTRUCTOR;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.PUBLIC;
 import static javax.lang.model.element.Modifier.STATIC;
+import static javax.lang.model.element.NestingKind.MEMBER;
+import static javax.lang.model.element.NestingKind.TOP_LEVEL;
 import static javax.lang.model.type.TypeKind.VOID;
+
 /**
  * Generates the implementation of the abstract types annotated with {@link Component}.
  *
@@ -198,18 +201,18 @@ ClassName nameGeneratedType(ComponentDescriptor input) {
           .addSnippet("}")
           .addSnippet("this.%s = %s;", builderField.name(), contributionName)
           .addSnippet("return this;");
-      if (getNoArgsConstructor(contributionElement) == null) {
-        requiresBuilder = true;
+      if (hasNoArgsConstructor(contributionElement)) {
         buildMethod.body()
             .addSnippet("if (%s == null) {", builderField.name())
-            .addSnippet("  throw new IllegalStateException(\"%s must be set\");",
-                builderField.name())
+            .addSnippet("  this.%s = new %s();",
+                builderField.name(), ClassName.fromTypeElement(contributionElement))
             .addSnippet("}");
       } else {
+        requiresBuilder = true;
         buildMethod.body()
             .addSnippet("if (%s == null) {", builderField.name())
-            .addSnippet("  this.%s = new %s();",
-                builderField.name(), ClassName.fromTypeElement(contributionElement))
+            .addSnippet("  throw new IllegalStateException(\"%s must be set\");",
+                builderField.name())
             .addSnippet("}");
       }
     }
@@ -605,16 +608,17 @@ private boolean isNonProviderMap(ProvisionBinding binding) {
     return false;
   }
 
-  private ExecutableElement getNoArgsConstructor(TypeElement type) {
-    for (Element enclosed : type.getEnclosedElements()) {
-      if (enclosed.getKind() != ElementKind.CONSTRUCTOR) {
-        continue;
-      }
-      ExecutableElement constructor = (ExecutableElement) enclosed;
-      if (constructor.getParameters().isEmpty()) {
-        return constructor;
+  private boolean hasNoArgsConstructor(TypeElement type) {
+    if (type.getNestingKind().equals(TOP_LEVEL)
+        || type.getNestingKind().equals(MEMBER) && type.getModifiers().contains(STATIC)) {
+      for (Element enclosed : type.getEnclosedElements()) {
+        if (enclosed.getKind().equals(CONSTRUCTOR)) {
+          if (((ExecutableElement) enclosed).getParameters().isEmpty()) {
+            return true;
+          }
+        }
       }
     }
-    return null;
+    return false;
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
index d6fcaba2a..3a889ade7 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -72,7 +72,7 @@ public synchronized void init(ProcessingEnvironment processingEnv) {
     InjectConstructorValidator injectConstructorValidator = new InjectConstructorValidator();
     InjectFieldValidator injectFieldValidator = new InjectFieldValidator();
     InjectMethodValidator injectMethodValidator = new InjectMethodValidator();
-    ModuleValidator moduleValidator = new ModuleValidator();
+    ModuleValidator moduleValidator = new ModuleValidator(elements, types);
     ProvidesMethodValidator providesMethodValidator = new ProvidesMethodValidator(elements);
     ComponentValidator componentValidator = new ComponentValidator(elements);
     MapKeyValidator mapKeyValidator = new MapKeyValidator();
diff --git a/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java b/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
index 0cec6d033..ae0cafeb8 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
@@ -15,16 +15,25 @@
  */
 package dagger.internal.codegen;
 
+import com.google.auto.common.MoreTypes;
+import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Queues;
+import com.google.common.collect.Sets;
 import dagger.Component;
 import dagger.MapKey;
 import dagger.Module;
+import java.util.Queue;
+import java.util.Set;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
+import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
 
+import static com.google.auto.common.MoreElements.getAnnotationMirror;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static dagger.internal.codegen.AnnotationMirrors.getAttributeAsListOfTypes;
 /**
@@ -69,10 +78,37 @@
     checkNotNull(moduleAnnotation);
     return getAttributeAsListOfTypes(elements, moduleAnnotation, INJECTS_ATTRIBUTE);
   }
-  
+
   static ImmutableSet<? extends AnnotationMirror> getMapKeys(Element element) {
     return AnnotationMirrors.getAnnotatedAnnotations(element, MapKey.class);
   }
 
+  /**
+   * Returns the full set of modules transitively {@linkplain Module#includes included} from the
+   * given seed modules.  If a module is malformed and a type listed in {@link Module#includes}
+   * is not annotated with {@link Module}, it is ignored.
+   */
+  static ImmutableSet<TypeElement> getTransitiveModules(Elements elements, Types types,
+      ImmutableSet<TypeElement> seedModules) {
+    Queue<TypeElement> moduleQueue = Queues.newArrayDeque(seedModules);
+    Set<TypeElement> moduleElements = Sets.newLinkedHashSet();
+    for (TypeElement moduleElement = moduleQueue.poll();
+        moduleElement != null;
+        moduleElement = moduleQueue.poll()) {
+      moduleElements.add(moduleElement);
+      Optional<AnnotationMirror> moduleMirror = getAnnotationMirror(moduleElement, Module.class);
+      if (moduleMirror.isPresent()) {
+        ImmutableSet<TypeElement> moduleDependencies = MoreTypes.asTypeElements(types,
+            ConfigurationAnnotations.getModuleIncludes(elements, moduleMirror.get()));
+        for (TypeElement dependencyType : moduleDependencies) {
+          if (!moduleElements.contains(dependencyType)) {
+            moduleQueue.add(dependencyType);
+          }
+        }
+      }
+    }
+    return ImmutableSet.copyOf(moduleElements);
+  }
+
   private ConfigurationAnnotations() {}
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/FrameworkKey.java b/compiler/src/main/java/dagger/internal/codegen/FrameworkKey.java
index e82f17b88..a8104979d 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FrameworkKey.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FrameworkKey.java
@@ -18,6 +18,7 @@
 import com.google.auto.value.AutoValue;
 import dagger.MembersInjector;
 import javax.inject.Provider;
+
 import static com.google.common.base.Preconditions.checkNotNull;
 
 /**
diff --git a/compiler/src/main/java/dagger/internal/codegen/GraphValidator.java b/compiler/src/main/java/dagger/internal/codegen/GraphValidator.java
index 03724b4ec..fde1298e1 100644
--- a/compiler/src/main/java/dagger/internal/codegen/GraphValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/GraphValidator.java
@@ -25,16 +25,13 @@
 import com.google.common.collect.ImmutableSetMultimap;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Queues;
-import com.google.common.collect.Sets;
 import dagger.Component;
-import dagger.Module;
 import dagger.Provides;
 import dagger.internal.codegen.ValidationReport.Builder;
 import java.util.Deque;
 import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Map;
-import java.util.Queue;
 import java.util.Set;
 import javax.inject.Provider;
 import javax.lang.model.element.AnnotationMirror;
@@ -54,6 +51,7 @@
 import static com.google.auto.common.MoreElements.getAnnotationMirror;
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentModules;
+import static dagger.internal.codegen.ConfigurationAnnotations.getTransitiveModules;
 import static dagger.internal.codegen.ErrorMessages.REQUIRES_AT_INJECT_CONSTRUCTOR_OR_PROVIDER_FORMAT;
 import static dagger.internal.codegen.ErrorMessages.REQUIRES_PROVIDER_FORMAT;
 import static javax.lang.model.type.TypeKind.VOID;
@@ -92,28 +90,6 @@
     return reportBuilder.build();
   }
 
-  private ImmutableSet<TypeElement> getTransitiveModules(ImmutableSet<TypeElement> seedModules) {
-    // TODO(user): Detect and report module cycles.
-    Queue<TypeElement> moduleQueue = Queues.newArrayDeque(seedModules);
-    LinkedHashSet<TypeElement> moduleElements = Sets.newLinkedHashSet();
-    for (TypeElement moduleElement = moduleQueue.poll();
-        moduleElement != null;
-        moduleElement = moduleQueue.poll()) {
-      moduleElements.add(moduleElement);
-      Optional<AnnotationMirror> moduleMirror = getAnnotationMirror(moduleElement, Module.class);
-      if (moduleMirror.isPresent()) {
-        ImmutableSet<TypeElement> moduleDependencies = MoreTypes.asTypeElements(types,
-            ConfigurationAnnotations.getModuleIncludes(elements, moduleMirror.get()));
-        for (TypeElement dependencyType : moduleDependencies) {
-          if (!moduleElements.contains(dependencyType)) {
-            moduleQueue.add(dependencyType);
-          }
-        }
-      }
-    }
-    return ImmutableSet.copyOf(moduleElements);
-  }
-
   void validateGraph(TypeElement component,
       ValidationReport.Builder<TypeElement> reportBuilder) {
     AnnotationMirror componentMirror =
@@ -145,7 +121,8 @@ void validateGraph(TypeElement component,
     // Collect transitive modules provisions.
     ImmutableSet<TypeElement> moduleTypes =
         MoreTypes.asTypeElements(types, getComponentModules(elements, componentMirror));
-    for (TypeElement module : getTransitiveModules(moduleTypes)) {
+
+    for (TypeElement module : getTransitiveModules(elements, types, moduleTypes)) {
       // traverse the modules, collect the bindings
       List<ExecutableElement> moduleMethods = methodsIn(elements.getAllMembers(module));
       for (ExecutableElement moduleMethod : moduleMethods) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java b/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java
index bbec9ccb9..00465243f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java
@@ -15,17 +15,31 @@
  */
 package dagger.internal.codegen;
 
+import com.google.auto.common.MoreElements;
+import com.google.auto.common.Visibility;
+import com.google.common.base.Function;
+import com.google.common.base.Joiner;
+import com.google.common.base.Predicate;
+import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableListMultimap;
+import com.google.common.collect.ImmutableSet;
 import dagger.Module;
 import dagger.Provides;
 import java.util.Collection;
 import java.util.List;
 import java.util.Map.Entry;
+import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.ElementFilter;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
 
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
+import static com.google.auto.common.Visibility.PRIVATE;
+import static com.google.auto.common.Visibility.PUBLIC;
+import static com.google.auto.common.Visibility.effectiveVisibilityOfElement;
 import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_WITH_SAME_NAME;
 
 /**
@@ -35,9 +49,20 @@
  * @since 2.0
  */
 final class ModuleValidator implements Validator<TypeElement> {
+  private final Elements elements;
+  private final Types types;
+
+  ModuleValidator(Elements elements, Types types) {
+    this.elements =  elements;
+    this.types = types;
+  }
+
   @Override
   public ValidationReport<TypeElement> validate(TypeElement subject) {
     ValidationReport.Builder<TypeElement> builder = ValidationReport.Builder.about(subject);
+
+    validateModuleVisibility(subject, builder);
+
     List<ExecutableElement> moduleMethods = ElementFilter.methodsIn(subject.getEnclosedElements());
     ImmutableListMultimap.Builder<String, ExecutableElement> providesMethodsByName =
         ImmutableListMultimap.builder();
@@ -54,7 +79,68 @@
         }
       }
     }
-    // TODO(gak): port the dagger 1 module validation
+    // TODO(gak): port the dagger 1 module validation?
     return builder.build();
   }
+
+  private void validateModuleVisibility(final TypeElement moduleElement,
+      final ValidationReport.Builder<?> reportBuilder) {
+    Visibility moduleVisibility = Visibility.ofElement(moduleElement);
+    if (moduleVisibility.equals(PRIVATE)) {
+      reportBuilder.addItem("Modules cannot be private.", moduleElement);
+    } else if (effectiveVisibilityOfElement(moduleElement).equals(PRIVATE)) {
+      reportBuilder.addItem("Modules cannot be enclosed in private types.", moduleElement);
+    }
+
+    switch (moduleElement.getNestingKind()) {
+      case ANONYMOUS:
+        throw new IllegalStateException("Can't apply @Module to an anonymous class");
+      case LOCAL:
+        throw new IllegalStateException("Local classes shouldn't show up in the processor");
+      case MEMBER:
+      case TOP_LEVEL:
+        if (moduleVisibility.equals(PUBLIC)) {
+          ImmutableSet<Element> nonPublicModules =
+              FluentIterable.from(ConfigurationAnnotations.getModuleIncludes(elements,
+                  MoreElements.getAnnotationMirror(moduleElement, Module.class).get()))
+                      .transform(new Function<TypeMirror, Element>() {
+                        @Override public Element apply(TypeMirror input) {
+                          return types.asElement(input);
+                        }
+                      })
+                      .filter(new Predicate<Element>() {
+                        @Override public boolean apply(Element input) {
+                          return effectiveVisibilityOfElement(input).compareTo(PUBLIC) < 0;
+                        }
+                      })
+                      .toSet();
+          if (!nonPublicModules.isEmpty()) {
+            reportBuilder.addItem(
+                String.format(
+                    "This module is public, but it includes non-public "
+                        + "(or effectively non-public) modules. "
+                        + "Either reduce the visibility of this module or make %s public.",
+                    formatListForErrorMessage(nonPublicModules.asList())),
+                moduleElement);
+          }
+        }
+        break;
+      default:
+        throw new AssertionError();
+    }
+  }
+
+  private static String formatListForErrorMessage(List<?> things) {
+    switch (things.size()) {
+      case 0:
+        return "";
+      case 1:
+        return things.get(0).toString();
+      default:
+        StringBuilder output = new StringBuilder();
+        Joiner.on(", ").appendTo(output, things.subList(0, things.size() - 1));
+        output.append(" and ").append(things.get(things.size() - 1));
+        return output.toString();
+    }
+  }
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java b/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
index b1bb0ef43..cdf270a1d 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
@@ -515,4 +515,92 @@ public void providedTypes() {
         .processedWith(new ComponentProcessor())
         .compilesWithoutError();
   }
+
+  @Test
+  public void privateModule() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.Enclosing",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "",
+        "final class Enclosing {",
+        "  @Module private static final class PrivateModule {",
+        "  }",
+        "}");
+    assert_().about(javaSource())
+        .that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("Modules cannot be private.")
+        .in(moduleFile).onLine(6);
+  }
+
+  @Test
+  public void enclosedInPrivateModule() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.Enclosing",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "",
+        "final class Enclosing {",
+        "  private static final class PrivateEnclosing {",
+        "    @Module static final class TestModule {",
+        "    }",
+        "  }",
+        "}");
+    assert_().about(javaSource())
+        .that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("Modules cannot be enclosed in private types.")
+        .in(moduleFile).onLine(7);
+  }
+
+  @Test
+  public void publicModuleNonPublicIncludes() {
+    JavaFileObject publicModuleFile = JavaFileObjects.forSourceLines("test.PublicModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "",
+        "@Module(includes = {",
+        "    NonPublicModule1.class, OtherPublicModule.class, NonPublicModule2.class",
+        "})",
+        "public final class PublicModule {",
+        "}");
+    JavaFileObject nonPublicModule1File = JavaFileObjects.forSourceLines("test.NonPublicModule1",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "",
+        "@Module",
+        "final class NonPublicModule1 {",
+        "}");
+    JavaFileObject nonPublicModule2File = JavaFileObjects.forSourceLines("test.NonPublicModule2",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "",
+        "@Module",
+        "final class NonPublicModule2 {",
+        "}");
+    JavaFileObject otherPublicModuleFile = JavaFileObjects.forSourceLines("test.OtherPublicModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "",
+        "@Module",
+        "public final class OtherPublicModule {",
+        "}");
+    assert_().about(javaSources())
+        .that(ImmutableList.of(
+            publicModuleFile, nonPublicModule1File, nonPublicModule2File, otherPublicModuleFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("This module is public, but it includes non-public "
+            + "(or effectively non-public) modules. "
+            + "Either reduce the visibility of this module or make "
+            + "test.NonPublicModule1 and test.NonPublicModule2 public.")
+        .in(publicModuleFile).onLine(8);
+  }
 }
