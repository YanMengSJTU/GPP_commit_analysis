diff --git a/compiler/src/main/java/dagger/internal/codegen/AnnotationMirrors.java b/compiler/src/main/java/dagger/internal/codegen/AnnotationMirrors.java
deleted file mode 100644
index 64889e2fe..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/AnnotationMirrors.java
+++ /dev/null
@@ -1,159 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen;
-
-import com.google.auto.common.MoreElements;
-import com.google.auto.common.MoreTypes;
-import com.google.common.base.Equivalence;
-import com.google.common.base.Predicate;
-import com.google.common.collect.FluentIterable;
-import com.google.common.collect.ImmutableList;
-import com.google.common.collect.ImmutableMap;
-import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.Maps;
-import java.lang.annotation.Annotation;
-import java.util.Arrays;
-import java.util.List;
-import java.util.Map;
-import java.util.Map.Entry;
-import javax.lang.model.element.AnnotationMirror;
-import javax.lang.model.element.AnnotationValue;
-import javax.lang.model.element.Element;
-import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.type.DeclaredType;
-import javax.lang.model.type.TypeMirror;
-import javax.lang.model.util.ElementFilter;
-import javax.lang.model.util.Elements;
-
-import static com.google.auto.common.MoreElements.isAnnotationPresent;
-import static com.google.common.base.Preconditions.checkNotNull;
-
-/**
- * A utility class for working with {@link AnnotationMirror} instances.
- *
- * @author Gregory Kick
- */
-final class AnnotationMirrors {
-  /**
-   * Takes a {@link Map} like that returned from {@link Elements#getElementValuesWithDefaults} and
-   * key it by the member name rather than the {@link ExecutableElement}.
-   */
-  static ImmutableMap<String, AnnotationValue> simplifyAnnotationValueMap(
-      Map<? extends ExecutableElement, ? extends AnnotationValue> annotationValueMap) {
-    ImmutableMap.Builder<String, AnnotationValue> builder = ImmutableMap.builder();
-    for (Entry<? extends ExecutableElement, ? extends AnnotationValue> entry
-        : annotationValueMap.entrySet()) {
-      builder.put(entry.getKey().getSimpleName().toString(), entry.getValue());
-    }
-    return builder.build();
-  }
-
-  static ImmutableList<TypeMirror> getAttributeAsListOfTypes(AnnotationMirror annotationMirror,
-      String attributeName) {
-    checkNotNull(annotationMirror);
-    checkNotNull(attributeName);
-    ImmutableMap<String, AnnotationValue> valueMap =
-        simplifyAnnotationValueMap(getAnnotationValuesWithDefaults(annotationMirror));
-    ImmutableList.Builder<TypeMirror> builder = ImmutableList.builder();
-
-    @SuppressWarnings("unchecked") // that's the whole point of this method
-    List<? extends AnnotationValue> typeValues =
-        (List<? extends AnnotationValue>) valueMap.get(attributeName).getValue();
-    for (AnnotationValue typeValue : typeValues) {
-      builder.add((TypeMirror) typeValue.getValue());
-    }
-    return builder.build();
-  }
-
-  private static final Equivalence<AnnotationMirror> ANNOTATION_MIRROR_EQUIVALENCE =
-      new Equivalence<AnnotationMirror>() {
-        @Override
-        protected boolean doEquivalent(AnnotationMirror left, AnnotationMirror right) {
-          return MoreTypes.equivalence().equivalent(left.getAnnotationType(),
-              right.getAnnotationType()) && AnnotationValues.equivalence().pairwise().equivalent(
-              getAnnotationValuesWithDefaults(left).values(),
-              getAnnotationValuesWithDefaults(right).values());
-        }
-        @Override
-        protected int doHash(AnnotationMirror annotation) {
-          DeclaredType type = annotation.getAnnotationType();
-          Iterable<AnnotationValue> annotationValues =
-              getAnnotationValuesWithDefaults(annotation).values();
-          return Arrays.hashCode(new int[] {MoreTypes.equivalence().hash(type),
-              AnnotationValues.equivalence().pairwise().hash(annotationValues)});
-        }
-    };
-
-  /**
-   * Returns an {@link Equivalence} for {@link AnnotationMirror} as some implementations
-   * delegate equality tests to {@link Object#equals} whereas the documentation explicitly
-   * states that instance/reference equality is not the proper test.
-   *
-   * Note: The contract of this equivalence is not quite that described in the javadoc, as
-   * hash code values returned by {@link Equivalence#hash} are not the same as would
-   * be returned from {@link AnnotationMirror#hashCode}, though the proper invariants
-   * relating hashCode() and equals() hold for {@code hash(T)} and {@code equivalent(T, T)}.
-   */
-  static Equivalence<AnnotationMirror> equivalence() {
-    return ANNOTATION_MIRROR_EQUIVALENCE;
-  }
-
-  /**
-   * Returns the {@link AnnotationMirror}'s map of {@link AnnotationValue} indexed by
-   * {@link ExecutableElement}, supplying default values from the annotation if the
-   * annotation property has not been set.  This is equivalent to
-   * {@link Elements#getElementValuesWithDefaults(AnnotationMirror)} but can be called
-   * statically without an {@Elements} instance.
-   */
-  static Map<ExecutableElement, AnnotationValue> getAnnotationValuesWithDefaults(
-      AnnotationMirror annotation) {
-    Map<ExecutableElement, AnnotationValue> values = Maps.newLinkedHashMap();
-    Map<? extends ExecutableElement, ? extends AnnotationValue> declaredValues =
-        annotation.getElementValues();
-    for (ExecutableElement method :
-        ElementFilter.methodsIn(annotation.getAnnotationType().asElement().getEnclosedElements())) {
-      // Must iterate and put in this order, to ensure consistency in generated code.
-      if (declaredValues.containsKey(method)) {
-        values.put(method, declaredValues.get(method));
-      } else if (method.getDefaultValue() != null) {
-        values.put(method, method.getDefaultValue());
-      } else {
-        throw new IllegalStateException(
-            "Unset annotation value without default should never happen: "
-            + MoreElements.asType(method.getEnclosingElement()).getQualifiedName()
-            + '.' + method.getSimpleName() + "()");
-      }
-    }
-    return values;
-  }
-
-  /**
-   * Returns all {@linkplain AnnotationMirror annotations} that are present on the given
-   * {@link Element} which are themselves annotated with {@code annotationType}.
-   */
-  static ImmutableSet<? extends AnnotationMirror> getAnnotatedAnnotations(Element element,
-      final Class<? extends Annotation> annotationType) {
-    List<? extends AnnotationMirror> annotations = element.getAnnotationMirrors();
-    return FluentIterable.from(annotations)
-        .filter(new Predicate<AnnotationMirror>() {
-          @Override public boolean apply(AnnotationMirror input) {
-            return isAnnotationPresent(input.getAnnotationType().asElement(), annotationType);
-          }
-        })
-        .toSet();
-  }
-  private AnnotationMirrors() {}
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/AnnotationValues.java b/compiler/src/main/java/dagger/internal/codegen/AnnotationValues.java
deleted file mode 100644
index d578180fe..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/AnnotationValues.java
+++ /dev/null
@@ -1,127 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen;
-
-import com.google.auto.common.MoreTypes;
-import com.google.common.base.Equivalence;
-import java.util.List;
-import javax.lang.model.element.AnnotationMirror;
-import javax.lang.model.element.AnnotationValue;
-import javax.lang.model.type.TypeMirror;
-import javax.lang.model.util.SimpleAnnotationValueVisitor6;
-
-/**
- * A utility class for working with {@link AnnotationValue} instances.
- *
- * @author Christian Gruber
- */
-final class AnnotationValues {
-  private static final Equivalence<AnnotationValue> ANNOTATION_VALUE_EQUIVALENCE =
-      new Equivalence<AnnotationValue>() {
-        @Override protected boolean doEquivalent(AnnotationValue left, AnnotationValue right) {
-          return left.accept(new SimpleAnnotationValueVisitor6<Boolean, AnnotationValue>() {
-            // LHS is not an annotation or array of annotation values, so just test equality.
-            @Override protected Boolean defaultAction(Object left, AnnotationValue right) {
-              return left.equals(right.accept(
-                  new SimpleAnnotationValueVisitor6<Object, Void>() {
-                    @Override protected Object defaultAction(Object object, Void unused) {
-                      return object;
-                    }
-                  }, null));
-            }
-
-            // LHS is an annotation mirror so test equivalence for RHS annotation mirrors
-            // and false for other types.
-            @Override public Boolean visitAnnotation(AnnotationMirror left, AnnotationValue right) {
-              return right.accept(
-                  new SimpleAnnotationValueVisitor6<Boolean, AnnotationMirror>() {
-                    @Override protected Boolean defaultAction(Object right, AnnotationMirror left) {
-                      return false; // Not an annotation mirror, so can't be equal to such.
-                    }
-                    @Override
-                    public Boolean visitAnnotation(AnnotationMirror right, AnnotationMirror left) {
-                      return AnnotationMirrors.equivalence().equivalent(left, right);
-                    }
-                  }, left);
-            }
-
-            // LHS is a list of annotation values have to collect-test equivalences, or false
-            // for any other types.
-            @Override
-            public Boolean visitArray(List<? extends AnnotationValue> left, AnnotationValue right) {
-              return right.accept(
-                  new SimpleAnnotationValueVisitor6<Boolean, List<? extends AnnotationValue>>() {
-                    @Override protected Boolean defaultAction(
-                        Object ignored, List<? extends AnnotationValue> alsoIgnored) {
-                      return false; // Not an annotation mirror, so can't be equal to such.
-                    }
-
-                    @SuppressWarnings("unchecked") // safe covariant cast
-                    @Override public Boolean visitArray(
-                        List<? extends AnnotationValue> right ,
-                        List<? extends AnnotationValue> left) {
-                      return AnnotationValues.equivalence().pairwise().equivalent(
-                          (List<AnnotationValue>) left, (List<AnnotationValue>) right);
-                    }
-                  }, left);
-            }
-
-            @Override
-            public Boolean visitType(TypeMirror left, AnnotationValue right) {
-              return right.accept(
-                  new SimpleAnnotationValueVisitor6<Boolean, TypeMirror>() {
-                    @Override protected Boolean defaultAction(
-                        Object ignored, TypeMirror alsoIgnored) {
-                      return false; // Not an annotation mirror, so can't be equal to such.
-                    }
-
-                    @Override public Boolean visitType(TypeMirror right, TypeMirror left) {
-                      return MoreTypes.equivalence().equivalent(left, right);
-                    }
-                  }, left);
-            }
-          }, right);
-        }
-
-        @Override protected int doHash(AnnotationValue value) {
-          return value.accept(new SimpleAnnotationValueVisitor6<Integer, Void>() {
-            @Override public Integer visitAnnotation(AnnotationMirror value, Void ignore) {
-              return AnnotationMirrors.equivalence().hash(value);
-            }
-
-            @SuppressWarnings("unchecked") // safe covariant cast
-            @Override public Integer visitArray(
-                List<? extends AnnotationValue> values, Void ignore) {
-              return AnnotationValues.equivalence().pairwise().hash((List<AnnotationValue>) values);
-            }
-
-            @Override public Integer visitType(TypeMirror value, Void ignore) {
-              return MoreTypes.equivalence().hash(value);
-            }
-
-            @Override protected Integer defaultAction(Object value, Void ignored) {
-              return value.hashCode();
-            }
-          }, null);
-        }
-      };
-
-  static Equivalence<AnnotationValue> equivalence() {
-    return ANNOTATION_VALUE_EQUIVALENCE;
-  }
-
-  private AnnotationValues() {}
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/BasicAnnotationProcessor.java b/compiler/src/main/java/dagger/internal/codegen/BasicAnnotationProcessor.java
deleted file mode 100644
index 2b55c8e36..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/BasicAnnotationProcessor.java
+++ /dev/null
@@ -1,287 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen;
-
-import com.google.auto.common.MoreElements;
-import com.google.common.base.Ascii;
-import com.google.common.base.Optional;
-import com.google.common.base.Predicates;
-import com.google.common.collect.ImmutableList;
-import com.google.common.collect.ImmutableMap;
-import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.ImmutableSetMultimap;
-import com.google.common.collect.Multimaps;
-import com.google.common.collect.SetMultimap;
-import com.google.common.collect.Sets;
-import java.lang.annotation.Annotation;
-import java.util.Map;
-import java.util.Map.Entry;
-import java.util.Set;
-import javax.annotation.processing.AbstractProcessor;
-import javax.annotation.processing.Messager;
-import javax.annotation.processing.ProcessingEnvironment;
-import javax.annotation.processing.Processor;
-import javax.annotation.processing.RoundEnvironment;
-import javax.lang.model.element.Element;
-import javax.lang.model.element.PackageElement;
-import javax.lang.model.element.TypeElement;
-import javax.lang.model.type.ErrorType;
-import javax.lang.model.util.Elements;
-import javax.lang.model.util.SimpleElementVisitor6;
-
-import static com.google.auto.common.SuperficialValidation.validateElement;
-import static com.google.common.base.Preconditions.checkState;
-import static javax.lang.model.element.ElementKind.PACKAGE;
-import static javax.tools.Diagnostic.Kind.ERROR;
-
-/**
- * An abstract {@link Processor} implementation that ensures that top-level {@link Element}
- * instances are well-formed before attempting to perform processing on any of their children. In
- * the event that they are not, the element will be enqueued for processing in a subsequent round.
- * This ensures that processors will avoid many common pitfalls like {@link ErrorType} instances,
- * {@link ClassCastException}s and badly coerced types.
- *
- * <p>The primary disadvantage to this processor is that any {@link Element} that forms a circular
- * dependency with a type generated by a subclass of this processor will never compile because the
- * given {@link Element} will never be fully complete. All such compilations will fail with an error
- * message on the offending type that describes the issue.
- *
- * <p>Subclasses should put their processing logic in {@link ProcessingStep} implementations. The
- * steps are passed to the processor by returning them in the {@link #initSteps()} method - access
- * the {@link ProcessingEnvironment} using {@link #processingEnv}. Finally, any logic that needs to
- * happen once per round can be specified by overriding {@link #postProcess()}.
- *
- * @author Gregory Kick
- */
-abstract class BasicAnnotationProcessor extends AbstractProcessor {
-  /*
-   * It's unfortunate that we have to track types and packages separately, but since there are two
-   * different methods to look them up in Elements, we end up with a lot of parallel logic. :(
-   * Packages declared (and annotated) in package-info.java are tracked as deferred packages while
-   * all other elements are tracked via the top-level type.
-   */
-  private final Set<String> deferredPackageNames = Sets.newLinkedHashSet();
-  private final Set<String> deferredTypeNames = Sets.newLinkedHashSet();
-  private final String processorName = getClass().getCanonicalName();
-
-  private Elements elements;
-  private Messager messager;
-  private ImmutableList<? extends ProcessingStep> steps;
-
-  @Override
-  public final synchronized void init(ProcessingEnvironment processingEnv) {
-    super.init(processingEnv);
-    this.elements = processingEnv.getElementUtils();
-    this.messager = processingEnv.getMessager();
-    this.steps = ImmutableList.copyOf(initSteps());
-  }
-
-  /**
-   * The mechanism by which {@linkplain ProcessingStep processing steps} are associated with the
-   * processor. #processinEnv is guaranteed to be set when this method is invoked.
-   */
-  protected abstract Iterable<? extends ProcessingStep> initSteps();
-
-  /** An optional hook for logic to be executed at the end of each round. */
-  protected void postProcess() {}
-
-  private ImmutableSet<? extends Class<? extends Annotation>> getSupportedAnnotationClasses() {
-    checkState(steps != null);
-    ImmutableSet.Builder<Class<? extends Annotation>> builder = ImmutableSet.builder();
-    for (ProcessingStep step : steps) {
-      builder.addAll(step.annotations());
-    }
-    return builder.build();
-  }
-
-  @Override
-  public final ImmutableSet<String> getSupportedAnnotationTypes() {
-    ImmutableSet.Builder<String> builder = ImmutableSet.builder();
-    for (Class<? extends Annotation> annotationClass : getSupportedAnnotationClasses()) {
-      builder.add(annotationClass.getCanonicalName());
-    }
-    return builder.build();
-  }
-
-  private static final String INVALID_ELEMENT_MESSAGE_FORMAT = "%s was unable to process %s"
-      + " because not all of its dependencies could be resolved. Check for compilation errors or a"
-      + " circular dependency with generated code.";
-
-  @Override
-  public final boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
-    checkState(elements != null);
-    checkState(messager != null);
-    checkState(steps != null);
-
-    // First, collect all of the deferred elements and clear out the state from the previous rounds
-    ImmutableMap.Builder<String, Optional<? extends Element>> deferredElementsBuilder =
-        ImmutableMap.builder();
-    for (String deferredTypeName : deferredTypeNames) {
-      deferredElementsBuilder.put(deferredTypeName,
-          Optional.fromNullable(elements.getTypeElement(deferredTypeName)));
-    }
-    for (String deferredPackageName : deferredPackageNames) {
-      deferredElementsBuilder.put(deferredPackageName,
-          Optional.fromNullable(elements.getPackageElement(deferredPackageName)));
-    }
-    ImmutableMap<String, Optional<? extends Element>> deferredElements =
-        deferredElementsBuilder.build();
-
-    deferredTypeNames.clear();
-    deferredPackageNames.clear();
-
-    // If this is the last round, report all of the missing elements
-    if (roundEnv.processingOver()) {
-      reportMissingElements(deferredElements);
-      return false;
-    }
-
-    // For all of the elements that were deferred, find the annotated elements therein.  If we don't
-    // find any, something is messed up and we just defer them again.
-    ImmutableSetMultimap.Builder<Class<? extends Annotation>, Element>
-        deferredElementsByAnnotationBuilder = ImmutableSetMultimap.builder();
-    for (Entry<String, Optional<? extends Element>> deferredTypeElementEntry :
-        deferredElements.entrySet()) {
-      Optional<? extends Element> deferredElement = deferredTypeElementEntry.getValue();
-      if (deferredElement.isPresent()) {
-        findAnnotatedElements(deferredElement.get(), getSupportedAnnotationClasses(),
-            deferredElementsByAnnotationBuilder);
-      } else {
-        deferredTypeNames.add(deferredTypeElementEntry.getKey());
-      }
-    }
-
-    ImmutableSetMultimap<Class<? extends Annotation>, Element> deferredElementsByAnnotation =
-        deferredElementsByAnnotationBuilder.build();
-
-    ImmutableSetMultimap.Builder<Class<? extends Annotation>, Element> elementsByAnnotationBuilder =
-        ImmutableSetMultimap.builder();
-
-    Set<String> validPackageNames = Sets.newLinkedHashSet();
-    Set<String> validTypeNames = Sets.newLinkedHashSet();
-
-    // Look at the elements we've found and the new elements from this round and validate them.
-    for (Class<? extends Annotation> annotationClass : getSupportedAnnotationClasses()) {
-      for (Element annotatedElement : Sets.union(
-          roundEnv.getElementsAnnotatedWith(annotationClass),
-          deferredElementsByAnnotation.get(annotationClass))) {
-        if (annotatedElement.getKind().equals(PACKAGE)) {
-          PackageElement annotatedPackageElement = (PackageElement) annotatedElement;
-          String annotatedPackageName = annotatedPackageElement.getQualifiedName().toString();
-          boolean validPackage = validPackageNames.contains(annotatedPackageName)
-              || (!deferredPackageNames.contains(annotatedPackageName)
-                  && validateElement(annotatedPackageElement));
-          if (validPackage) {
-            elementsByAnnotationBuilder.put(annotationClass, annotatedPackageElement);
-            validPackageNames.add(annotatedPackageName);
-          } else {
-            deferredPackageNames.add(annotatedPackageName);
-          }
-        } else {
-          TypeElement enclosingType = getEnclosingType(annotatedElement);
-          String enclosingTypeName = enclosingType.getQualifiedName().toString();
-          boolean validEnclosingType = validTypeNames.contains(enclosingTypeName)
-              || (!deferredTypeNames.contains(enclosingTypeName)
-                  && validateElement(enclosingType));
-          if (validEnclosingType) {
-            elementsByAnnotationBuilder.put(annotationClass, annotatedElement);
-            validTypeNames.add(enclosingTypeName);
-          } else {
-            deferredTypeNames.add(enclosingTypeName);
-          }
-        }
-      }
-    }
-
-    ImmutableSetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation =
-        elementsByAnnotationBuilder.build();
-
-    // Finally, process the valid elements
-    for (ProcessingStep step : steps) {
-      SetMultimap<Class<? extends Annotation>, Element> filteredMap =
-          Multimaps.filterKeys(elementsByAnnotation, Predicates.in(step.annotations()));
-      if (!filteredMap.isEmpty()) {
-        step.process(filteredMap);
-      }
-    }
-
-    postProcess();
-
-    return false;
-  }
-
-  private void reportMissingElements(
-      Map<String, ? extends Optional<? extends Element>> missingElements) {
-    for (Entry<String, ? extends Optional<? extends Element>> missingElementEntry :
-        missingElements.entrySet()) {
-      Optional<? extends Element> missingElement = missingElementEntry.getValue();
-      if (missingElement.isPresent()) {
-        processingEnv.getMessager().printMessage(ERROR,
-            String.format(INVALID_ELEMENT_MESSAGE_FORMAT, processorName,
-                "this " + Ascii.toLowerCase(missingElement.get().getKind().name())),
-                missingElement.get());
-      } else {
-        processingEnv.getMessager().printMessage(ERROR,
-            String.format(INVALID_ELEMENT_MESSAGE_FORMAT, processorName,
-                missingElementEntry.getKey()));
-      }
-    }
-  }
-
-  private static void findAnnotatedElements(Element element,
-      ImmutableSet<? extends Class<? extends Annotation>> annotationClasses,
-      ImmutableSetMultimap.Builder<Class<? extends Annotation>, Element> builder) {
-    for (Element enclosedElement : element.getEnclosedElements()) {
-      findAnnotatedElements(enclosedElement, annotationClasses, builder);
-    }
-    for (Class<? extends Annotation> annotationClass : annotationClasses) {
-      if (MoreElements.isAnnotationPresent(element, annotationClass)) {
-        builder.put(annotationClass, element);
-      }
-    }
-  }
-
-  private static TypeElement getEnclosingType(Element element) {
-    return element.accept(new SimpleElementVisitor6<TypeElement, Void>() {
-      @Override protected TypeElement defaultAction(Element e, Void p) {
-        return e.getEnclosingElement().accept(this, p);
-      }
-
-      @Override public TypeElement visitType(TypeElement e, Void p) {
-        return e;
-      }
-
-      @Override public TypeElement visitPackage(PackageElement e, Void p) {
-        throw new IllegalArgumentException();
-      }
-    }, null);
-  }
-
-  /**
-   * The unit of processing logic that runs under the guarantee that all elements are complete and
-   * well-formed.
-   */
-  interface ProcessingStep {
-    /** The set of annotation types processed by this step. */
-    Set<? extends Class<? extends Annotation>> annotations();
-
-    /**
-     * The implementation of processing logic for the step. It is guaranteed that the keys in
-     * {@code elementsByAnnotation} will be a subset of the set returned by {@link #annotations()}.
-     */
-    void process(SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation);
-  }
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
index b17591f11..b9016b071 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -1,5 +1,6 @@
 package dagger.internal.codegen;
 
+import com.google.auto.common.AnnotationMirrors;
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.common.base.Equivalence;
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
index f54b0e8d5..adb25639e 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
@@ -15,6 +15,7 @@
  */
 package dagger.internal.codegen;
 
+import com.google.auto.common.AnnotationMirrors;
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Equivalence;
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
index a771ec1b9..acd1a10b8 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
@@ -15,6 +15,7 @@
  */
 package dagger.internal.codegen;
 
+import com.google.auto.common.AnnotationMirrors;
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java
index 664c64204..b458ee322 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java
@@ -15,11 +15,11 @@
  */
 package dagger.internal.codegen;
 
+import com.google.auto.common.BasicAnnotationProcessor.ProcessingStep;
 import com.google.auto.common.MoreElements;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.SetMultimap;
 import dagger.Component;
-import dagger.internal.codegen.BasicAnnotationProcessor.ProcessingStep;
 import dagger.internal.codegen.ComponentDescriptor.Factory;
 import java.lang.annotation.Annotation;
 import java.util.Set;
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
index ae274e141..e68ef156a 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -15,6 +15,8 @@
  */
 package dagger.internal.codegen;
 
+import com.google.auto.common.BasicAnnotationProcessor;
+import com.google.auto.common.BasicAnnotationProcessor.ProcessingStep;
 import com.google.auto.service.AutoService;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
diff --git a/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java b/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
index 58d72fea6..bfe77faff 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
@@ -15,27 +15,35 @@
  */
 package dagger.internal.codegen;
 
+import static com.google.auto.common.AnnotationMirrors.getAnnotationValue;
+import static com.google.auto.common.MoreElements.getAnnotationMirror;
+import static com.google.common.base.Preconditions.checkNotNull;
+
+import com.google.auto.common.AnnotationMirrors;
 import com.google.auto.common.MoreTypes;
+import com.google.common.base.Function;
 import com.google.common.base.Optional;
+import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Maps;
 import com.google.common.collect.Queues;
+
 import dagger.Component;
 import dagger.MapKey;
 import dagger.Module;
+
+import java.util.List;
 import java.util.Map;
 import java.util.Queue;
+
 import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.AnnotationValue;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Types;
-
-import static com.google.auto.common.MoreElements.getAnnotationMirror;
-import static com.google.common.base.Preconditions.checkNotNull;
-import static dagger.internal.codegen.AnnotationMirrors.getAttributeAsListOfTypes;
 /**
  * Utility methods related to dagger configuration annotations (e.g.: {@link Component}
  * and {@link Module}).
@@ -47,34 +55,46 @@
 
   static ImmutableList<TypeMirror> getComponentModules(AnnotationMirror componentAnnotation) {
     checkNotNull(componentAnnotation);
-    return getAttributeAsListOfTypes(componentAnnotation, MODULES_ATTRIBUTE);
+    return convertClassArrayToListOfTypes(componentAnnotation, MODULES_ATTRIBUTE);
   }
 
   private static final String DEPENDENCIES_ATTRIBUTE = "dependencies";
 
   static ImmutableList<TypeMirror> getComponentDependencies(AnnotationMirror componentAnnotation) {
     checkNotNull(componentAnnotation);
-    return getAttributeAsListOfTypes(componentAnnotation, DEPENDENCIES_ATTRIBUTE);
+    return convertClassArrayToListOfTypes(componentAnnotation, DEPENDENCIES_ATTRIBUTE);
   }
 
   private static final String INCLUDES_ATTRIBUTE = "includes";
 
   static ImmutableList<TypeMirror> getModuleIncludes(AnnotationMirror moduleAnnotation) {
     checkNotNull(moduleAnnotation);
-    return getAttributeAsListOfTypes(moduleAnnotation, INCLUDES_ATTRIBUTE);
+    return convertClassArrayToListOfTypes(moduleAnnotation, INCLUDES_ATTRIBUTE);
   }
 
   private static final String INJECTS_ATTRIBUTE = "injects";
 
   static ImmutableList<TypeMirror> getModuleInjects(AnnotationMirror moduleAnnotation) {
     checkNotNull(moduleAnnotation);
-    return getAttributeAsListOfTypes(moduleAnnotation, INJECTS_ATTRIBUTE);
+    return convertClassArrayToListOfTypes(moduleAnnotation, INJECTS_ATTRIBUTE);
   }
 
   static ImmutableSet<? extends AnnotationMirror> getMapKeys(Element element) {
     return AnnotationMirrors.getAnnotatedAnnotations(element, MapKey.class);
   }
 
+  static ImmutableList<TypeMirror> convertClassArrayToListOfTypes(
+      AnnotationMirror annotationMirror, final String elementName) {
+    @SuppressWarnings("unchecked") // that's the whole point of this method
+    List<? extends AnnotationValue> listValue = (List<? extends AnnotationValue>)
+        getAnnotationValue(annotationMirror, elementName).getValue();
+    return FluentIterable.from(listValue).transform(new Function<AnnotationValue, TypeMirror>() {
+      @Override public TypeMirror apply(AnnotationValue typeValue) {
+        return (TypeMirror) typeValue.getValue();
+      }
+    }).toList();
+  }
+
   /**
    * Returns the full set of modules transitively {@linkplain Module#includes included} from the
    * given seed modules.  If a module is malformed and a type listed in {@link Module#includes}
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/InjectProcessingStep.java
index 532b01d40..a8cd537f7 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectProcessingStep.java
@@ -15,6 +15,7 @@
  */
 package dagger.internal.codegen;
 
+import com.google.auto.common.BasicAnnotationProcessor;
 import com.google.auto.common.MoreElements;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.SetMultimap;
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectionAnnotations.java b/compiler/src/main/java/dagger/internal/codegen/InjectionAnnotations.java
index f35001436..b3b245dfb 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectionAnnotations.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectionAnnotations.java
@@ -15,6 +15,7 @@
  */
 package dagger.internal.codegen;
 
+import com.google.auto.common.AnnotationMirrors;
 import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableSet;
 import javax.inject.Qualifier;
diff --git a/compiler/src/main/java/dagger/internal/codegen/Key.java b/compiler/src/main/java/dagger/internal/codegen/Key.java
index 8f41e7e95..5fff1b8b2 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Key.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Key.java
@@ -15,6 +15,7 @@
  */
 package dagger.internal.codegen;
 
+import com.google.auto.common.AnnotationMirrors;
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Equivalence;
diff --git a/compiler/src/main/java/dagger/internal/codegen/MapKeyProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/MapKeyProcessingStep.java
index 6d830d9a6..488f031c1 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MapKeyProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MapKeyProcessingStep.java
@@ -15,6 +15,7 @@
  */
 package dagger.internal.codegen;
 
+import com.google.auto.common.BasicAnnotationProcessor;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.SetMultimap;
 import dagger.MapKey;
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/ModuleProcessingStep.java
index f0f45042a..a7d06a6a6 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleProcessingStep.java
@@ -15,6 +15,7 @@
  */
 package dagger.internal.codegen;
 
+import com.google.auto.common.BasicAnnotationProcessor;
 import com.google.auto.common.MoreElements;
 import com.google.common.base.Function;
 import com.google.common.collect.FluentIterable;
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProducerModuleProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/ProducerModuleProcessingStep.java
index 28c361121..9fd3161a3 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProducerModuleProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProducerModuleProcessingStep.java
@@ -15,6 +15,7 @@
  */
 package dagger.internal.codegen;
 
+import com.google.auto.common.BasicAnnotationProcessor.ProcessingStep;
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.SuperficialValidation;
 import com.google.common.base.Function;
@@ -22,7 +23,6 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.SetMultimap;
 import com.google.common.collect.Sets;
-import dagger.internal.codegen.BasicAnnotationProcessor.ProcessingStep;
 import dagger.producers.ProducerModule;
 import dagger.producers.Produces;
 import java.lang.annotation.Annotation;
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProductionComponentProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/ProductionComponentProcessingStep.java
index 20fe2bc78..7e2c667d3 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProductionComponentProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProductionComponentProcessingStep.java
@@ -15,10 +15,10 @@
  */
 package dagger.internal.codegen;
 
+import com.google.auto.common.BasicAnnotationProcessor.ProcessingStep;
 import com.google.auto.common.MoreElements;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.SetMultimap;
-import dagger.internal.codegen.BasicAnnotationProcessor.ProcessingStep;
 import dagger.producers.ProductionComponent;
 import java.lang.annotation.Annotation;
 import java.util.Set;
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
index a2d452846..eb788142e 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
@@ -15,6 +15,7 @@
  */
 package dagger.internal.codegen;
 
+import com.google.auto.common.AnnotationMirrors;
 import com.google.auto.common.MoreElements;
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Equivalence;
diff --git a/compiler/src/test/java/dagger/internal/codegen/AnnotationMirrorsTest.java b/compiler/src/test/java/dagger/internal/codegen/AnnotationMirrorsTest.java
deleted file mode 100644
index 5e277284a..000000000
--- a/compiler/src/test/java/dagger/internal/codegen/AnnotationMirrorsTest.java
+++ /dev/null
@@ -1,185 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen;
-
-import com.google.common.testing.EquivalenceTester;
-import com.google.testing.compile.CompilationRule;
-import javax.lang.model.element.AnnotationMirror;
-import javax.lang.model.element.AnnotationValue;
-import javax.lang.model.util.Elements;
-import javax.lang.model.util.SimpleAnnotationValueVisitor6;
-import org.junit.Before;
-import org.junit.Rule;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-import static com.google.common.collect.Iterables.getOnlyElement;
-import static com.google.common.truth.Truth.assert_;
-import static dagger.internal.codegen.AnnotationMirrorsTest.SimpleEnum.BLAH;
-import static dagger.internal.codegen.AnnotationMirrorsTest.SimpleEnum.FOO;
-
-/**
- * Tests {@link AnnotationMirrors}.
- */
-@RunWith(JUnit4.class)
-public class AnnotationMirrorsTest {
-  @Rule public CompilationRule compilationRule = new CompilationRule();
-
-  private Elements elements;
-
-  @Before public void setUp() {
-    this.elements = compilationRule.getElements();
-  }
-
-  @interface SimpleAnnotation {}
-
-  @SimpleAnnotation class SimplyAnnotated {}
-  @SimpleAnnotation class AlsoSimplyAnnotated {}
-
-  enum SimpleEnum{
-    BLAH, FOO
-  }
-
-  @interface Outer {
-    SimpleEnum value();
-  }
-
-  @Outer(BLAH) static class TestClassBlah {}
-  @Outer(BLAH) static class TestClassBlah2 {}
-  @Outer(FOO) static class TestClassFoo {}
-
-  @interface DefaultingOuter {
-    SimpleEnum value() default SimpleEnum.BLAH;
-  }
-
-  @DefaultingOuter class TestWithDefaultingOuterDefault {}
-  @DefaultingOuter(BLAH) class TestWithDefaultingOuterBlah {}
-  @DefaultingOuter(FOO) class TestWithDefaultingOuterFoo {}
-
-  @interface AnnotatedOuter {
-    DefaultingOuter value();
-  }
-
-  @AnnotatedOuter(@DefaultingOuter) class TestDefaultNestedAnnotated {}
-  @AnnotatedOuter(@DefaultingOuter(BLAH)) class TestBlahNestedAnnotated {}
-  @AnnotatedOuter(@DefaultingOuter(FOO)) class TestFooNestedAnnotated {}
-
-  @interface OuterWithValueArray {
-    DefaultingOuter[] value() default {};
-  }
-
-  @OuterWithValueArray class TestValueArrayWithDefault {}
-  @OuterWithValueArray({}) class TestValueArrayWithEmpty {}
-
-  @OuterWithValueArray({@DefaultingOuter}) class TestValueArrayWithOneDefault {}
-  @OuterWithValueArray(@DefaultingOuter(BLAH)) class TestValueArrayWithOneBlah {}
-  @OuterWithValueArray(@DefaultingOuter(FOO)) class TestValueArrayWithOneFoo {}
-
-  @OuterWithValueArray({@DefaultingOuter(FOO), @DefaultingOuter})
-  class TestValueArrayWithFooAndDefaultBlah {}
-  @OuterWithValueArray({@DefaultingOuter(FOO), @DefaultingOuter(BLAH)})
-  class TestValueArrayWithFooBlah {}
-  @OuterWithValueArray({@DefaultingOuter(FOO), @DefaultingOuter(BLAH)})
-  class TestValueArrayWithFooBlah2 {} // Different instances than on TestValueArrayWithFooBlah.
-  @OuterWithValueArray({@DefaultingOuter(BLAH), @DefaultingOuter(FOO)})
-  class TestValueArrayWithBlahFoo {}
-
-  @Test public void testEquivalences() {
-    EquivalenceTester<AnnotationMirror> tester =
-        EquivalenceTester.of(AnnotationMirrors.equivalence());
-
-    tester.addEquivalenceGroup(
-        annotationOn(SimplyAnnotated.class),
-        annotationOn(AlsoSimplyAnnotated.class));
-
-    tester.addEquivalenceGroup(
-        annotationOn(TestClassBlah.class),
-        annotationOn(TestClassBlah2.class));
-
-    tester.addEquivalenceGroup(
-        annotationOn(TestClassFoo.class));
-
-    tester.addEquivalenceGroup(
-        annotationOn(TestWithDefaultingOuterDefault.class),
-        annotationOn(TestWithDefaultingOuterBlah.class));
-
-    tester.addEquivalenceGroup(
-        annotationOn(TestWithDefaultingOuterFoo.class));
-
-    tester.addEquivalenceGroup(
-        annotationOn(TestDefaultNestedAnnotated.class),
-        annotationOn(TestBlahNestedAnnotated.class));
-
-    tester.addEquivalenceGroup(
-        annotationOn(TestFooNestedAnnotated.class));
-
-    tester.addEquivalenceGroup(
-        annotationOn(TestValueArrayWithDefault.class),
-        annotationOn(TestValueArrayWithEmpty.class));
-
-    tester.addEquivalenceGroup(
-        annotationOn(TestValueArrayWithOneDefault.class),
-        annotationOn(TestValueArrayWithOneBlah.class));
-
-    tester.addEquivalenceGroup(
-        annotationOn(TestValueArrayWithOneFoo.class));
-
-    tester.addEquivalenceGroup(
-        annotationOn(TestValueArrayWithFooAndDefaultBlah.class),
-        annotationOn(TestValueArrayWithFooBlah.class),
-        annotationOn(TestValueArrayWithFooBlah2.class));
-
-    tester.addEquivalenceGroup(
-        annotationOn(TestValueArrayWithBlahFoo.class));
-
-    tester.test();
-  }
-
-  @interface Stringy {
-    String value() default "default";
-  }
-
-  @Stringy class StringyUnset {}
-  @Stringy("foo") class StringySet {}
-
-  @Test public void testGetDefaultValuesUnset() {
-    assert_().that(annotationOn(StringyUnset.class).getElementValues()).isEmpty();
-    Iterable<AnnotationValue> values = AnnotationMirrors.getAnnotationValuesWithDefaults(
-        annotationOn(StringyUnset.class)).values();
-    String value = getOnlyElement(values).accept(new SimpleAnnotationValueVisitor6<String, Void>() {
-          @Override public String visitString(String value, Void ignored) {
-            return value;
-          }
-        }, null);
-    assert_().that(value).isEqualTo("default");
-  }
-
-  @Test public void testGetDefaultValuesSet() {
-    Iterable<AnnotationValue> values = AnnotationMirrors.getAnnotationValuesWithDefaults(
-        annotationOn(StringySet.class)).values();
-    String value = getOnlyElement(values).accept(new SimpleAnnotationValueVisitor6<String, Void>() {
-          @Override public String visitString(String value, Void ignored) {
-            return value;
-          }
-        }, null);
-    assert_().that(value).isEqualTo("foo");
-  }
-
-  private AnnotationMirror annotationOn(Class<?> clazz) {
-    return getOnlyElement(elements.getTypeElement(clazz.getCanonicalName()).getAnnotationMirrors());
-  }
-}
diff --git a/compiler/src/test/java/dagger/internal/codegen/BasicAnnotationProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/BasicAnnotationProcessorTest.java
deleted file mode 100644
index 0d840ecb7..000000000
--- a/compiler/src/test/java/dagger/internal/codegen/BasicAnnotationProcessorTest.java
+++ /dev/null
@@ -1,181 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen;
-
-import com.google.common.collect.ImmutableList;
-import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.SetMultimap;
-import com.google.testing.compile.JavaFileObjects;
-import java.io.IOException;
-import java.io.PrintWriter;
-import java.lang.annotation.Annotation;
-import java.lang.annotation.Retention;
-import java.lang.annotation.RetentionPolicy;
-import java.util.Set;
-import javax.lang.model.SourceVersion;
-import javax.lang.model.element.Element;
-import javax.tools.JavaFileObject;
-import javax.tools.StandardLocation;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-import static com.google.common.truth.Truth.assertAbout;
-import static com.google.common.truth.Truth.assertThat;
-import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
-
-@RunWith(JUnit4.class)
-public class BasicAnnotationProcessorTest {
-  @Retention(RetentionPolicy.SOURCE)
-  public @interface RequiresGeneratedCode {}
-
-  /** Asserts that the code generated by {@link GeneratesCode} and its processor is present.  */
-  public static class RequiresGeneratedCodeProcessor extends BasicAnnotationProcessor {
-    boolean processed = false;
-
-    @Override
-    public SourceVersion getSupportedSourceVersion() {
-      return SourceVersion.latestSupported();
-    }
-
-    @Override
-    protected Iterable<? extends ProcessingStep> initSteps() {
-      return ImmutableSet.of(new ProcessingStep() {
-        @Override
-        public void process(
-            SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
-          processed = true;
-          try {
-            processingEnv.getFiler()
-                .getResource(StandardLocation.SOURCE_OUTPUT, "test", "SomeGeneratedClass");
-          } catch (IOException e) {
-            throw new AssertionError(e);
-          }
-        }
-
-        @Override
-        public Set<? extends Class<? extends Annotation>> annotations() {
-          return ImmutableSet.of(RequiresGeneratedCode.class);
-        }
-      });
-    }
-  }
-
-  @Retention(RetentionPolicy.SOURCE)
-  public @interface GeneratesCode {}
-
-  /** Generates a class called {@code test.SomeGeneratedClass}. */
-  public static class GeneratesCodeProcessor extends BasicAnnotationProcessor {
-    @Override
-    public SourceVersion getSupportedSourceVersion() {
-      return SourceVersion.latestSupported();
-    }
-
-    @Override
-    protected Iterable<? extends ProcessingStep> initSteps() {
-      return ImmutableSet.of(new ProcessingStep() {
-        @Override
-        public void process(
-            SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
-          for (Element element : elementsByAnnotation.values()) {
-            try {
-              generateClass(element);
-            } catch (IOException e) {
-              throw new RuntimeException(e);
-            }
-          }
-        }
-
-        @Override
-        public Set<? extends Class<? extends Annotation>> annotations() {
-          return ImmutableSet.of(GeneratesCode.class);
-        }
-      });
-    }
-
-    private void generateClass(Element sourceType) throws IOException {
-      JavaFileObject source =
-          processingEnv.getFiler().createSourceFile("test.SomeGeneratedClass", sourceType);
-      PrintWriter writer = new PrintWriter(source.openWriter());
-      writer.println("package test;");
-      writer.println("public class SomeGeneratedClass {}");
-      writer.close();
-    }
-  }
-
-  @Test public void properlyDefersProcessing_typeElement() {
-    JavaFileObject classAFileObject = JavaFileObjects.forSourceLines("test.ClassA",
-        "package test;",
-        "",
-        "@" + RequiresGeneratedCode.class.getCanonicalName(),
-        "public class ClassA {",
-        "  SomeGeneratedClass sgc;",
-        "}");
-    JavaFileObject classBFileObject = JavaFileObjects.forSourceLines("test.ClassB",
-        "package test;",
-        "",
-        "@" + GeneratesCode.class.getCanonicalName(),
-        "public class ClassB {}");
-    RequiresGeneratedCodeProcessor requiresGeneratedCodeProcessor =
-        new RequiresGeneratedCodeProcessor();
-    assertAbout(javaSources())
-        .that(ImmutableList.of(classAFileObject, classBFileObject))
-        .processedWith(requiresGeneratedCodeProcessor, new GeneratesCodeProcessor())
-        .compilesWithoutError();
-    assertThat(requiresGeneratedCodeProcessor.processed).isTrue();
-  }
-
-  @Retention(RetentionPolicy.SOURCE)
-  public @interface ReferencesAClass {
-    Class<?> value();
-  }
-
-  @Test public void properlyDefersProcessing_packageElement() {
-    JavaFileObject classAFileObject = JavaFileObjects.forSourceLines("test.ClassA",
-        "package test;",
-        "",
-        "@" + GeneratesCode.class.getCanonicalName(),
-        "public class ClassA {",
-        "}");
-    JavaFileObject packageFileObject = JavaFileObjects.forSourceLines("test.package-info",
-        "@" + RequiresGeneratedCode.class.getCanonicalName(),
-        "@" + ReferencesAClass.class.getCanonicalName() + "(SomeGeneratedClass.class)",
-        "package test;");
-    RequiresGeneratedCodeProcessor requiresGeneratedCodeProcessor =
-        new RequiresGeneratedCodeProcessor();
-    assertAbout(javaSources())
-        .that(ImmutableList.of(classAFileObject, packageFileObject))
-        .processedWith(requiresGeneratedCodeProcessor, new GeneratesCodeProcessor())
-        .compilesWithoutError();
-    assertThat(requiresGeneratedCodeProcessor.processed).isTrue();
-  }
-
-  @Test public void reportsMissingType() {
-    JavaFileObject classAFileObject = JavaFileObjects.forSourceLines("test.ClassA",
-        "package test;",
-        "",
-        "@" + RequiresGeneratedCode.class.getCanonicalName(),
-        "public class ClassA {",
-        "  SomeGeneratedClass bar;",
-        "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(classAFileObject))
-        .processedWith(new RequiresGeneratedCodeProcessor())
-        .failsToCompile()
-        .withErrorContaining(RequiresGeneratedCodeProcessor.class.getCanonicalName())
-        .in(classAFileObject).onLine(4);
-  }
-}
diff --git a/compiler/src/test/java/dagger/internal/codegen/ElementUtilTest.java b/compiler/src/test/java/dagger/internal/codegen/ElementUtilTest.java
deleted file mode 100644
index 2f638f21c..000000000
--- a/compiler/src/test/java/dagger/internal/codegen/ElementUtilTest.java
+++ /dev/null
@@ -1,53 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen;
-
-import com.google.auto.common.MoreElements;
-import com.google.testing.compile.CompilationRule;
-import javax.lang.model.element.Element;
-import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.TypeElement;
-import javax.lang.model.util.ElementFilter;
-import org.junit.Rule;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-import static com.google.common.truth.Truth.assert_;
-import static org.junit.Assert.fail;
-
-@RunWith(JUnit4.class)
-public class ElementUtilTest {
-  @Rule public CompilationRule compilation = new CompilationRule();
-
-  @Test public void asTypeElement() {
-    Element typeElement =
-        compilation.getElements().getTypeElement(String.class.getCanonicalName());
-    assert_().that(MoreElements.asType(typeElement)).isEqualTo(typeElement);
-  }
-
-  @Test public void asTypeElement_notATypeElement() {
-    TypeElement typeElement =
-        compilation.getElements().getTypeElement(String.class.getCanonicalName());
-    for (ExecutableElement e : ElementFilter.methodsIn(typeElement.getEnclosedElements())) {
-      try {
-        MoreElements.asType(e);
-        fail();
-      } catch (IllegalArgumentException expected) {
-      }
-    }
-  }
-}
