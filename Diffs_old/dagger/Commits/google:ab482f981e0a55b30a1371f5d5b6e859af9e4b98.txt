diff --git a/compiler/src/it/functional-tests/src/main/java/test/ModuleWithConflictingNames.java b/compiler/src/it/functional-tests/src/main/java/test/ModuleWithConflictingNames.java
new file mode 100644
index 000000000..2ec4f387d
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/ModuleWithConflictingNames.java
@@ -0,0 +1,48 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package test;
+
+import dagger.Module;
+import dagger.Provides;
+import javax.inject.Inject;
+import javax.inject.Provider;
+
+/**
+ * Module with bindings that might result in generated factories with conflicting field and
+ * parameter names.
+ */
+@Module
+final class ModuleWithConflictingNames {
+  @Provides
+  static Object object(int foo, Provider<String> fooProvider) {
+    return foo + fooProvider.get();
+  }
+
+  /**
+   * A class that might result in a generated factory with conflicting field and parameter names.
+   */
+  static class InjectedClassWithConflictingNames {
+    final int foo;
+    final Provider<String> fooProvider;
+
+    @Inject
+    InjectedClassWithConflictingNames(int foo, Provider<String> fooProvider) {
+      this.foo = foo;
+      this.fooProvider = fooProvider;
+    }
+  }
+}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/SimpleProducerModule.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/SimpleProducerModule.java
index 0485075e6..a06c059a9 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/SimpleProducerModule.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/SimpleProducerModule.java
@@ -269,4 +269,13 @@ static String setOfStrElementWithArgThrowingException(int i) throws IOException
     return Futures.<Set<String>>immediateFuture(
         ImmutableSet.of("set of str with arg 1", "set of str with arg 2 throwing exception"));
   }
+
+  /**
+   * A binding method that might result in a generated factory with conflicting field and parameter
+   * names.
+   */
+  @Produces
+  static Object object(int foo, Provider<String> fooProvider) {
+    return foo + fooProvider.get();
+  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
index 21d4156b3..0796afb42 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
@@ -43,6 +43,7 @@
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.Lists;
+import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
 import com.squareup.javapoet.FieldSpec;
@@ -56,6 +57,7 @@
 import dagger.internal.MembersInjectors;
 import dagger.internal.Preconditions;
 import java.util.List;
+import java.util.Map;
 import javax.annotation.processing.Filer;
 import javax.inject.Inject;
 import javax.lang.model.element.Element;
@@ -111,7 +113,9 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
     TypeSpec.Builder factoryBuilder;
     Optional<MethodSpec.Builder> constructorBuilder = Optional.absent();
     ImmutableList<TypeVariableName> typeParameters = bindingTypeElementTypeVariableNames(binding);
-    ImmutableMap<BindingKey, FrameworkField> fields = generateBindingFieldsForDependencies(binding);
+    UniqueNameSet uniqueFieldNames = new UniqueNameSet();
+    ImmutableMap.Builder<BindingKey, FieldSpec> fieldsBuilder = ImmutableMap.builder();
+
     boolean useRawType =
         binding.factoryCreationStrategy() == ENUM_INSTANCE
             && binding.bindingKind() == INJECTION
@@ -139,12 +143,17 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
               factoryBuilder,
               constructorBuilder.get());
         }
-        for (FrameworkField bindingField : fields.values()) {
-          addConstructorParameterAndTypeField(
-              bindingField.type(),
-              bindingField.name(),
-              factoryBuilder,
-              constructorBuilder.get());
+        for (Map.Entry<BindingKey, FrameworkField> entry :
+            generateBindingFieldsForDependencies(binding).entrySet()) {
+          BindingKey bindingKey = entry.getKey();
+          FrameworkField bindingField = entry.getValue();
+          FieldSpec field =
+              addConstructorParameterAndTypeField(
+                  bindingField.type(),
+                  uniqueFieldNames.getUniqueName(bindingField.name()),
+                  factoryBuilder,
+                  constructorBuilder.get());
+          fieldsBuilder.put(bindingKey, field);
         }
         break;
       case DELEGATE:
@@ -152,6 +161,7 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
       default:
         throw new AssertionError();
     }
+    ImmutableMap<BindingKey, FieldSpec> fields = fieldsBuilder.build();
 
     factoryBuilder
         .addModifiers(PUBLIC)
@@ -214,8 +224,7 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
     for (DependencyRequest dependency : binding.dependencies()) {
       parameters.add(
           frameworkTypeUsageStatement(
-              CodeBlock.of("$L", fields.get(dependency.bindingKey()).name()),
-              dependency.kind()));
+              CodeBlock.of("$N", fields.get(dependency.bindingKey())), dependency.kind()));
     }
     CodeBlock parametersCodeBlock = makeParametersCodeBlock(parameters);
 
@@ -250,9 +259,10 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
             CANNOT_RETURN_NULL_FROM_NON_NULLABLE_PROVIDES_METHOD);
       }
     } else if (binding.membersInjectionRequest().isPresent()) {
-      getMethodBuilder.addStatement("return $T.injectMembers($L, new $T($L))",
+      getMethodBuilder.addStatement(
+          "return $T.injectMembers($N, new $T($L))",
           MembersInjectors.class,
-          fields.get(binding.membersInjectionRequest().get().bindingKey()).name(),
+          fields.get(binding.membersInjectionRequest().get().bindingKey()),
           providedTypeName,
           parametersCodeBlock);
     } else {
@@ -268,7 +278,8 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
     return Optional.of(factoryBuilder);
   }
 
-  private void addConstructorParameterAndTypeField(
+  @CanIgnoreReturnValue
+  private FieldSpec addConstructorParameterAndTypeField(
       TypeName typeName,
       String variableName,
       TypeSpec.Builder factoryBuilder,
@@ -278,5 +289,6 @@ private void addConstructorParameterAndTypeField(
     ParameterSpec parameter = ParameterSpec.builder(typeName, variableName).build();
     constructorBuilder.addParameter(parameter);
     constructorBuilder.addCode("assert $1N != null; this.$2N = $1N;", parameter, field);
+    return field;
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
index 7e362d7ba..1921b6baf 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
@@ -24,6 +24,7 @@
 import static dagger.internal.codegen.AnnotationSpecs.SUPPRESS_WARNINGS_UNCHECKED;
 import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
 import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
+import static dagger.internal.codegen.SourceFiles.generateBindingFieldsForDependencies;
 import static dagger.internal.codegen.SourceFiles.generatedClassNameForBinding;
 import static dagger.internal.codegen.TypeNames.ASYNC_FUNCTION;
 import static dagger.internal.codegen.TypeNames.FUTURES;
@@ -49,11 +50,13 @@
 import com.google.common.collect.Iterables;
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.FieldSpec;
 import com.squareup.javapoet.MethodSpec;
 import com.squareup.javapoet.ParameterizedTypeName;
 import com.squareup.javapoet.TypeName;
 import com.squareup.javapoet.TypeSpec;
 import dagger.producers.Producer;
+import java.util.Map;
 import javax.annotation.processing.Filer;
 import javax.lang.model.element.Element;
 import javax.lang.model.type.TypeMirror;
@@ -95,25 +98,46 @@ ClassName nameGeneratedType(ProductionBinding binding) {
             .addModifiers(PUBLIC, FINAL)
             .superclass(abstractProducerOf(providedTypeName));
 
-    ImmutableMap<BindingKey, FrameworkField> fields =
-        SourceFiles.generateBindingFieldsForDependencies(binding);
+    UniqueNameSet uniqueFieldNames = new UniqueNameSet();
+    ImmutableMap.Builder<BindingKey, FieldSpec> fieldsBuilder = ImmutableMap.builder();
+
+    MethodSpec.Builder constructorBuilder = constructorBuilder().addModifiers(PUBLIC);
+
+    Optional<FieldSpec> moduleField =
+        binding.requiresModuleInstance()
+            ? Optional.of(
+                addFieldAndConstructorParameter(
+                    factoryBuilder,
+                    constructorBuilder,
+                    uniqueFieldNames.getUniqueName("module"),
+                    TypeName.get(binding.bindingTypeElement().get().asType())))
+            : Optional.<FieldSpec>absent();
+
+    for (Map.Entry<BindingKey, FrameworkField> entry :
+        generateBindingFieldsForDependencies(binding).entrySet()) {
+      BindingKey bindingKey = entry.getKey();
+      FrameworkField bindingField = entry.getValue();
+      FieldSpec field =
+          addFieldAndConstructorParameter(
+              factoryBuilder,
+              constructorBuilder,
+              uniqueFieldNames.getUniqueName(bindingField.name()),
+              bindingField.type());
+      fieldsBuilder.put(bindingKey, field);
+    }
+    ImmutableMap<BindingKey, FieldSpec> fields = fieldsBuilder.build();
 
-    MethodSpec.Builder constructorBuilder =
-        constructorBuilder()
-            .addModifiers(PUBLIC)
-            .addStatement(
-                "super($L, $L)",
-                fields.get(binding.monitorRequest().get().bindingKey()).name(),
-                producerTokenConstruction(generatedTypeName, binding));
+    constructorBuilder.addStatement(
+        "super($N, $L)",
+        fields.get(binding.monitorRequest().get().bindingKey()),
+        producerTokenConstruction(generatedTypeName, binding));
 
     if (binding.requiresModuleInstance()) {
-      TypeName moduleType = TypeName.get(binding.bindingTypeElement().get().asType());
-      addFieldAndConstructorParameter(factoryBuilder, constructorBuilder, "module", moduleType);
+      assignField(constructorBuilder, moduleField.get());
     }
-
-    for (FrameworkField bindingField : fields.values()) {
-      addFieldAndConstructorParameter(
-          factoryBuilder, constructorBuilder, bindingField.name(), bindingField.type());
+    
+    for (FieldSpec field : fields.values()) {
+      assignField(constructorBuilder, field);
     }
 
     MethodSpec.Builder computeMethodBuilder =
@@ -125,8 +149,7 @@ ClassName nameGeneratedType(ProductionBinding binding) {
     ImmutableList<DependencyRequest> asyncDependencies = asyncDependencies(binding);
     for (DependencyRequest dependency : asyncDependencies) {
       TypeName futureType = listenableFutureOf(asyncDependencyType(dependency));
-      CodeBlock futureAccess =
-          CodeBlock.of("$L.get()", fields.get(dependency.bindingKey()).name());
+      CodeBlock futureAccess = CodeBlock.of("$N.get()", fields.get(dependency.bindingKey()));
       computeMethodBuilder.addStatement(
           "$T $L = $L",
           futureType,
@@ -178,16 +201,21 @@ ClassName nameGeneratedType(ProductionBinding binding) {
   }
 
   // TODO(ronshapiro): consolidate versions of these
-  private static void addFieldAndConstructorParameter(
+  private static FieldSpec addFieldAndConstructorParameter(
       TypeSpec.Builder typeBuilder,
       MethodSpec.Builder constructorBuilder,
       String variableName,
       TypeName variableType) {
-    typeBuilder.addField(variableType, variableName, PRIVATE, FINAL);
+    FieldSpec field = FieldSpec.builder(variableType, variableName, PRIVATE, FINAL).build();
+    typeBuilder.addField(field);
+    constructorBuilder.addParameter(field.type, field.name);
+    return field;
+  }
+
+  private static void assignField(MethodSpec.Builder constructorBuilder, FieldSpec field) {
     constructorBuilder
-        .addParameter(variableType, variableName)
-        .addStatement("assert $L != null", variableName)
-        .addStatement("this.$1L = $1L", variableName);
+        .addStatement("assert $N != null", field)
+        .addStatement("this.$1N = $1N", field);
   }
 
   /** Returns a list of dependencies that are generated asynchronously. */
@@ -231,10 +259,10 @@ private static String dependencyFutureName(DependencyRequest dependency) {
 
   /** Represents the transformation of an input future by a producer method. */
   abstract static class FutureTransform {
-    protected final ImmutableMap<BindingKey, FrameworkField> fields;
+    protected final ImmutableMap<BindingKey, FieldSpec> fields;
     protected final ProductionBinding binding;
 
-    FutureTransform(ImmutableMap<BindingKey, FrameworkField> fields, ProductionBinding binding) {
+    FutureTransform(ImmutableMap<BindingKey, FieldSpec> fields, ProductionBinding binding) {
       this.fields = fields;
       this.binding = binding;
     }
@@ -257,7 +285,7 @@ boolean hasUncheckedCast() {
     }
 
     static FutureTransform create(
-        ImmutableMap<BindingKey, FrameworkField> fields,
+        ImmutableMap<BindingKey, FieldSpec> fields,
         ProductionBinding binding,
         ImmutableList<DependencyRequest> asyncDependencies) {
       if (asyncDependencies.isEmpty()) {
@@ -272,8 +300,7 @@ static FutureTransform create(
   }
 
   static final class NoArgFutureTransform extends FutureTransform {
-    NoArgFutureTransform(
-        ImmutableMap<BindingKey, FrameworkField> fields, ProductionBinding binding) {
+    NoArgFutureTransform(ImmutableMap<BindingKey, FieldSpec> fields, ProductionBinding binding) {
       super(fields, binding);
     }
 
@@ -298,8 +325,7 @@ String applyArgName() {
       for (DependencyRequest dependency : binding.dependencies()) {
         parameterCodeBlocks.add(
             frameworkTypeUsageStatement(
-                CodeBlock.of("$L", fields.get(dependency.bindingKey()).name()),
-                dependency.kind()));
+                CodeBlock.of("$N", fields.get(dependency.bindingKey())), dependency.kind()));
       }
       return parameterCodeBlocks.build();
     }
@@ -309,7 +335,7 @@ String applyArgName() {
     private final DependencyRequest asyncDependency;
 
     SingleArgFutureTransform(
-        ImmutableMap<BindingKey, FrameworkField> fields,
+        ImmutableMap<BindingKey, FieldSpec> fields,
         ProductionBinding binding,
         DependencyRequest asyncDependency) {
       super(fields, binding);
@@ -343,8 +369,7 @@ String applyArgName() {
           parameterCodeBlocks.add(
               // TODO(ronshapiro) extract this into a method shared by FutureTransform subclasses
               frameworkTypeUsageStatement(
-                  CodeBlock.of("$L", fields.get(dependency.bindingKey()).name()),
-                  dependency.kind()));
+                  CodeBlock.of("$N", fields.get(dependency.bindingKey())), dependency.kind()));
         }
       }
       return parameterCodeBlocks.build();
@@ -355,7 +380,7 @@ String applyArgName() {
     private final ImmutableList<DependencyRequest> asyncDependencies;
 
     MultiArgFutureTransform(
-        ImmutableMap<BindingKey, FrameworkField> fields,
+        ImmutableMap<BindingKey, FieldSpec> fields,
         ProductionBinding binding,
         ImmutableList<DependencyRequest> asyncDependencies) {
       super(fields, binding);
@@ -423,9 +448,7 @@ private static TypeName asyncDependencyType(DependencyRequest dependency) {
   }
 
   private static ImmutableList<CodeBlock> getParameterCodeBlocks(
-      ProductionBinding binding,
-      ImmutableMap<BindingKey, FrameworkField> fields,
-      String listArgName) {
+      ProductionBinding binding, ImmutableMap<BindingKey, FieldSpec> fields, String listArgName) {
     int argIndex = 0;
     ImmutableList.Builder<CodeBlock> codeBlocks = ImmutableList.builder();
     for (DependencyRequest dependency : binding.dependencies()) {
@@ -437,8 +460,7 @@ private static TypeName asyncDependencyType(DependencyRequest dependency) {
       } else {
         codeBlocks.add(
             frameworkTypeUsageStatement(
-                CodeBlock.of("$L", fields.get(dependency.bindingKey()).name()),
-                dependency.kind()));
+                CodeBlock.of("$N", fields.get(dependency.bindingKey())), dependency.kind()));
       }
     }
     return codeBlocks.build();
