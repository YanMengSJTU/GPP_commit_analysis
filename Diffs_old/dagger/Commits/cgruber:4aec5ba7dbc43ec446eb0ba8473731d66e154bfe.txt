diff --git a/compiler/src/main/java/dagger/internal/codegen/Binding.java b/compiler/src/main/java/dagger/internal/codegen/Binding.java
index 8296341ce..dc3641ff1 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Binding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Binding.java
@@ -21,6 +21,7 @@
 
 import javax.lang.model.element.Element;
 import javax.lang.model.element.TypeElement;
+import javax.lang.model.util.SimpleElementVisitor6;
 
 /**
  * An abstract type for classes representing a Dagger binding.  Particularly, contains the
@@ -36,8 +37,18 @@
   abstract Element bindingElement();
 
   /** The type enclosing the binding {@link #bindingElement()}. */
-  TypeElement enclosingType() {
-    return MoreElements.asType(bindingElement().getEnclosingElement());
+  TypeElement bindingTypeElement() {
+    return bindingElement().accept(new SimpleElementVisitor6<TypeElement, Void>() {
+      @Override
+      protected TypeElement defaultAction(Element e, Void p) {
+        return MoreElements.asType(bindingElement().getEnclosingElement());
+      }
+
+      @Override
+      public TypeElement visitType(TypeElement e, Void p) {
+        return e;
+      }
+    }, null);
   }
 
   /**
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
index 3080bea69..07d85ebc7 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
@@ -20,11 +20,11 @@
 
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Optional;
-import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ImmutableSetMultimap;
-import com.google.common.collect.Iterables;
+import com.google.common.collect.LinkedHashMultimap;
 import com.google.common.collect.Queues;
+import com.google.common.collect.SetMultimap;
 import com.google.common.collect.Sets;
 
 import dagger.Component;
@@ -32,7 +32,6 @@
 import dagger.Provides;
 
 import java.util.Deque;
-import java.util.LinkedHashMap;
 import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Queue;
@@ -85,7 +84,7 @@
    * Returns the mapping from {@link Key} to {@link ProvisionBinding} that represents the full
    * adjacency matrix for the object graph.
    */
-  abstract ImmutableMap<Key, ProvisionBinding> resolvedBindings();
+  abstract ImmutableSetMultimap<Key, ProvisionBinding> resolvedBindings();
 
   static final class Factory {
     private final Elements elements;
@@ -149,8 +148,6 @@ ComponentDescriptor create(TypeElement componentDefinitionType) {
 
       ImmutableSetMultimap<Key, ProvisionBinding> explicitBindings = bindingIndexBuilder.build();
 
-      // TODO(gak): coalesce contributing bindings
-
       ImmutableSet.Builder<DependencyRequest> provisionRequestsBuilder = ImmutableSet.builder();
       ImmutableSet.Builder<DependencyRequest> membersInjectionRequestsBuilder =
           ImmutableSet.builder();
@@ -180,8 +177,7 @@ ComponentDescriptor create(TypeElement componentDefinitionType) {
         }
       }
 
-      LinkedHashMap<Key, ProvisionBinding> resolvedBindings =
-          new LinkedHashMap<Key, ProvisionBinding>();
+      SetMultimap<Key, ProvisionBinding> resolvedBindings = LinkedHashMultimap.create();
 
       for (DependencyRequest requestToResolve = requestsToResolve.pollLast();
           requestToResolve != null;
@@ -196,13 +192,16 @@ ComponentDescriptor create(TypeElement componentDefinitionType) {
               requestsToResolve.addAll(injectBinding.get().dependencies());
               resolvedBindings.put(key, injectBinding.get());
             } else {
-              // uh oh
+              // TODO(gak): generate a factory for an @Inject dependency that wasn't run with the
+              // processor
+              throw new UnsupportedOperationException("@Injected classes that weren't run with the "
+                  + "compoenent processor are (briefly) unsupported.");
             }
           } else {
-            for (ProvisionBinding explicitBinding : explicitBindingsForKey) {
-              requestsToResolve.addAll(explicitBinding.dependencies());
-            }
-            resolvedBindings.put(key, Iterables.getOnlyElement(explicitBindingsForKey));
+            resolvedBindings.putAll(key, explicitBindingsForKey);
+          }
+          for (ProvisionBinding binding : explicitBindingsForKey) {
+            requestsToResolve.addAll(binding.dependencies());
           }
         }
       }
@@ -212,7 +211,7 @@ ComponentDescriptor create(TypeElement componentDefinitionType) {
           provisionRequestsBuilder.build(),
           membersInjectionRequestsBuilder.build(),
           moduleTypes,
-          ImmutableMap.copyOf(resolvedBindings));
+          ImmutableSetMultimap.copyOf(resolvedBindings));
     }
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
index 9aa5220a6..630b8f16a 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
@@ -17,7 +17,9 @@
 
 import static com.google.common.base.CaseFormat.LOWER_CAMEL;
 import static com.squareup.javawriter.JavaWriter.stringLiteral;
-import static dagger.internal.codegen.ProvisionBinding.Type.PROVIDES;
+import static dagger.Provides.Type.SET;
+import static dagger.Provides.Type.SET_VALUES;
+import static dagger.internal.codegen.ProvisionBinding.Kind.PROVISION;
 import static dagger.internal.codegen.SourceFiles.collectImportsFromDependencies;
 import static dagger.internal.codegen.SourceFiles.factoryNameForProvisionBinding;
 import static dagger.internal.codegen.SourceFiles.flattenVariableMap;
@@ -36,22 +38,26 @@
 import com.google.common.collect.Collections2;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableBiMap;
+import com.google.common.collect.ImmutableCollection;
 import com.google.common.collect.ImmutableList;
-import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.ImmutableSetMultimap;
 import com.google.common.collect.ImmutableSortedSet;
+import com.google.common.collect.Iterables;
 import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
 import com.google.common.collect.Sets;
 import com.squareup.javawriter.JavaWriter;
 
 import dagger.Component;
+import dagger.internal.SetFactory;
 
 import java.io.IOException;
 import java.util.EnumSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Map.Entry;
+import java.util.Set;
 
 import javax.annotation.Generated;
 import javax.annotation.processing.Filer;
@@ -98,13 +104,13 @@ void write(ClassName componentName, JavaWriter writer, ComponentDescriptor input
     writer.emitPackage(componentName.packageName());
 
     writeImports(writer, componentName, input.provisionRequests(),
-        input.resolvedBindings().keySet());
+        input.resolvedBindings().values());
 
     writer.emitAnnotation(Generated.class, stringLiteral(ComponentProcessor.class.getName()));
     writer.beginType(componentName.simpleName(), "class", EnumSet.of(PUBLIC, FINAL), null,
         input.componentDefinitionType().getQualifiedName().toString());
 
-    ImmutableMap<Key, ProvisionBinding> resolvedBindings = input.resolvedBindings();
+    ImmutableSetMultimap<Key, ProvisionBinding> resolvedBindings = input.resolvedBindings();
 
     ImmutableBiMap<Key, String> providerNames = generateProviderNamesForBindings(resolvedBindings);
 
@@ -112,8 +118,7 @@ void write(ClassName componentName, JavaWriter writer, ComponentDescriptor input
         ImmutableBiMap.copyOf(Maps.asMap(input.moduleDependencies(), Functions.compose(
             CaseFormat.UPPER_CAMEL.converterTo(LOWER_CAMEL),
             new Function<TypeElement, String>() {
-              @Override
-              public String apply(TypeElement input) {
+              @Override public String apply(TypeElement input) {
                 return input.getSimpleName().toString();
               }
             })));
@@ -130,14 +135,17 @@ public String apply(TypeElement input) {
 
   private void writeImports(JavaWriter writer, ClassName factoryClassName,
       ImmutableSet<DependencyRequest> provisionRequests,
-      ImmutableSet<Key> requiredKeys) throws IOException {
+      ImmutableCollection<ProvisionBinding> bindings) throws IOException {
     ImmutableSortedSet.Builder<ClassName> importsBuilder =
         ImmutableSortedSet.<ClassName>naturalOrder()
             .addAll(collectImportsFromDependencies(factoryClassName, provisionRequests))
             .add(ClassName.fromClass(Generated.class))
             .add(ClassName.fromClass(Provider.class));
-    for (Key requiredKey : requiredKeys) {
-      for (TypeElement referencedType : MoreTypes.referencedTypes(requiredKey.type())) {
+    for (ProvisionBinding binding : bindings) {
+      if (binding.provisionType().equals(SET) || binding.provisionType().equals(SET_VALUES)) {
+        importsBuilder.add(ClassName.fromClass(SetFactory.class));
+      }
+      for (TypeElement referencedType : MoreTypes.referencedTypes(binding.providedKey().type())) {
         ClassName className = ClassName.fromTypeElement(referencedType);
         if (!className.packageName().equals("java.lang")
             && !className.packageName().equals(factoryClassName.packageName()))
@@ -170,7 +178,7 @@ private void writeProviderFields(JavaWriter writer, ImmutableBiMap<Key, String>
   }
 
   private void writeConstructor(final JavaWriter writer,
-      Map<Key, ProvisionBinding> resolvedBindings,
+      ImmutableSetMultimap<Key, ProvisionBinding> resolvedBindings,
       ImmutableBiMap<Key, String> providerNames,
       ImmutableBiMap<TypeElement, String> moduleNames)
           throws IOException {
@@ -193,26 +201,42 @@ public String apply(TypeElement input) {
 
     for (Entry<String, Key> providerFieldEntry
         : Lists.reverse(providerNames.inverse().entrySet().asList())) {
-      ProvisionBinding binding = resolvedBindings.get(providerFieldEntry.getValue());
-      List<String> parameters =
-          Lists.newArrayListWithCapacity(binding.dependenciesByKey().size() + 1);
-      if (binding.type().equals(PROVIDES)) {
-        parameters.add(moduleNames.get(binding.bindingElement().getEnclosingElement()));
+      Set<ProvisionBinding> bindings = resolvedBindings.get(providerFieldEntry.getValue());
+      if (ProvisionBinding.isSetBindingCollection(bindings)) {
+        ImmutableList.Builder<String> setFactoryParameters = ImmutableList.builder();
+        for (ProvisionBinding binding : bindings) {
+          setFactoryParameters.add(
+              initializeFactoryForBinding(writer, binding, moduleNames, providerNames));
+        }
+        writer.emitStatement("this.%s = SetFactory.create(%n%s)",
+            providerFieldEntry.getKey(),
+            Joiner.on(",\n").join(setFactoryParameters.build()));
+      } else {
+        ProvisionBinding binding = Iterables.getOnlyElement(bindings);
+        writer.emitStatement("this.%s = %s",
+            providerFieldEntry.getKey(),
+            initializeFactoryForBinding(writer, binding, moduleNames, providerNames));
       }
-      FluentIterable.from(binding.dependenciesByKey().keySet())
-          .transform(Functions.forMap(providerNames))
-          .copyInto(parameters);
-      writer.emitStatement("this.%s = new %s(%s)",
-          providerFieldEntry.getKey(),
-          writer.compressType(
-              factoryNameForProvisionBinding(binding)
-                  .toString()),
-          Joiner.on(", ").join(parameters));
     }
 
     writer.endConstructor().emitEmptyLine();
   }
 
+  private static String initializeFactoryForBinding(JavaWriter writer, ProvisionBinding binding,
+      ImmutableBiMap<TypeElement, String> moduleNames,
+      ImmutableBiMap<Key, String> providerNames) {
+    List<String> parameters = Lists.newArrayListWithCapacity(binding.dependencies().size() + 1);
+    if (binding.bindingKind().equals(PROVISION)) {
+      parameters.add(moduleNames.get(binding.bindingElement().getEnclosingElement()));
+    }
+    FluentIterable.from(binding.dependenciesByKey().keySet())
+        .transform(Functions.forMap(providerNames))
+        .copyInto(parameters);
+    return String.format("new %s(%s)",
+        writer.compressType(factoryNameForProvisionBinding(binding).toString()),
+        Joiner.on(", ").join(parameters));
+  }
+
   private void writeProvisionMethods(JavaWriter writer,
       ImmutableSet<DependencyRequest> provisionRequests,
       ImmutableBiMap<Key, String> providerNames) throws IOException {
diff --git a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
index c43b6bf64..0e8d8a0bd 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
@@ -17,7 +17,7 @@
 
 import static com.squareup.javawriter.JavaWriter.stringLiteral;
 import static com.squareup.javawriter.JavaWriter.type;
-import static dagger.internal.codegen.ProvisionBinding.Type.PROVIDES;
+import static dagger.internal.codegen.ProvisionBinding.Kind.PROVISION;
 import static dagger.internal.codegen.SourceFiles.collectImportsFromDependencies;
 import static dagger.internal.codegen.SourceFiles.factoryNameForProvisionBinding;
 import static dagger.internal.codegen.SourceFiles.flattenVariableMap;
@@ -42,8 +42,10 @@
 import com.squareup.javawriter.JavaWriter;
 import dagger.Factory;
 import dagger.MembersInjector;
+import dagger.Provides;
 import java.io.IOException;
 import java.util.ArrayList;
+import java.util.Collections;
 import java.util.EnumSet;
 import java.util.List;
 import java.util.Map;
@@ -104,8 +106,8 @@ void write(ClassName factoryClassName, JavaWriter writer, ProvisionBinding bindi
 
     ImmutableMap.Builder<String, String> variableMapBuilder =
         new ImmutableMap.Builder<String, String>();
-    if (binding.type().equals(PROVIDES)) {
-      variableMapBuilder.put("module", binding.enclosingType().getQualifiedName().toString());
+    if (binding.bindingKind().equals(PROVISION)) {
+      variableMapBuilder.put("module", binding.bindingTypeElement().getQualifiedName().toString());
     }
     if (binding.requiresMemberInjection()) {
       variableMapBuilder.put("membersInjector", type(MembersInjector.class, providedTypeString));
@@ -117,8 +119,8 @@ void write(ClassName factoryClassName, JavaWriter writer, ProvisionBinding bindi
     if (binding.requiresMemberInjection()) {
       writeMembersInjectorField(writer, providedTypeString);
     }
-    if (binding.type().equals(PROVIDES)) {
-      writeModuleField(writer, binding.enclosingType());
+    if (binding.bindingKind().equals(PROVISION)) {
+      writeModuleField(writer, binding.bindingTypeElement());
     }
     writeProviderFields(writer, providerNames);
 
@@ -138,6 +140,9 @@ private void writeImports(JavaWriter writer, ClassName factoryClassName, Provisi
             .addAll(collectImportsFromDependencies(factoryClassName, binding.dependencies()))
             .add(ClassName.fromClass(Factory.class))
             .add(ClassName.fromClass(Generated.class));
+    if (binding.provisionType().equals(Provides.Type.SET)) {
+      importsBuilder.add(ClassName.fromClass(Collections.class));
+    }
     if (binding.requiresMemberInjection()) {
       importsBuilder.add(ClassName.fromClass(MembersInjector.class));
     }
@@ -201,9 +206,20 @@ private void writeGetMethod(JavaWriter writer, ProvisionBinding binding,
                 return providerUsageStatement(providerNames.get(input.key()), input.kind());
               }
             }));
-    if (binding.type().equals(PROVIDES)) {
-      writer.emitStatement("return module.%s(%s)",
-          binding.bindingElement().getSimpleName(), parameterString);
+    if (binding.bindingKind().equals(PROVISION)) {
+      switch (binding.provisionType()) {
+        case UNIQUE:
+        case SET_VALUES:
+          writer.emitStatement("return module.%s(%s)",
+              binding.bindingElement().getSimpleName(), parameterString);
+          break;
+        case SET:
+          writer.emitStatement("return Collections.singleton(module.%s(%s))",
+              binding.bindingElement().getSimpleName(), parameterString);
+          break;
+        default:
+          throw new AssertionError();
+      }
     } else if (binding.requiresMemberInjection()) {
       writer.emitStatement("%1$s instance = new %1$s(%2$s)",
           writer.compressType(providedTypeString), parameterString);
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/InjectProcessingStep.java
index 9b40fa9b2..b0f80db7d 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectProcessingStep.java
@@ -132,7 +132,7 @@ public Void visitExecutableAsMethod(ExecutableElement methodElement, Void p) {
         Multimaps.index(membersInjections.build(),
             new Function<MembersInjectionBinding, TypeElement>() {
               @Override public TypeElement apply(MembersInjectionBinding binding) {
-                return binding.enclosingType();
+                return binding.bindingTypeElement();
               }
             });
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/KeyVariableNamer.java b/compiler/src/main/java/dagger/internal/codegen/KeyVariableNamer.java
new file mode 100644
index 000000000..67adb4798
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/KeyVariableNamer.java
@@ -0,0 +1,69 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import static com.google.common.base.CaseFormat.LOWER_CAMEL;
+import static com.google.common.base.CaseFormat.UPPER_CAMEL;
+
+import com.google.common.base.Function;
+
+import java.util.Iterator;
+
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.SimpleTypeVisitor6;
+
+/**
+ * Suggests a variable name for a type based on a {@link Key}. Prefer
+ * {@link DependencyVariableNamer} for cases where a specific {@link DependencyRequest} is present.
+ *
+ * @author Gregory Kick
+ * @since 2.0
+ */
+final class KeyVariableNamer implements Function<Key, String> {
+  @Override
+  public String apply(Key key) {
+    StringBuilder builder = new StringBuilder();
+
+    if (key.qualifier().isPresent()) {
+      if (!key.qualifier().get().getElementValues().isEmpty()) {
+        // TODO(gak): obviously we need to support this
+        throw new UnsupportedOperationException();
+      }
+      builder.append(key.qualifier().get().getAnnotationType().asElement().getSimpleName());
+    }
+
+    key.type().accept(new SimpleTypeVisitor6<Void, StringBuilder>() {
+      @Override
+      public Void visitDeclared(DeclaredType t, StringBuilder builder) {
+        builder.append(t.asElement().getSimpleName());
+        Iterator<? extends TypeMirror> argumentIterator = t.getTypeArguments().iterator();
+        if (argumentIterator.hasNext()) {
+          builder.append("Of");
+          TypeMirror first = argumentIterator.next();
+          first.accept(this, builder);
+          while (argumentIterator.hasNext()) {
+            builder.append("And");
+            argumentIterator.next().accept(this, builder);
+          }
+        }
+        return null;
+      }
+    }, builder);
+
+    return UPPER_CAMEL.to(LOWER_CAMEL, builder.toString());
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
index 7008c91a5..67974b3ed 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
@@ -41,7 +41,7 @@
   /**
    * Returns an {@link Ordering} suitable for sorting bindings into an ordering that abides by the
    * injection ordering specified in {@link Inject}. This ordering should not be used with bindings
-   * from different {@link #enclosingType() types}.
+   * from different {@link #bindingTypeElement() types}.
    */
   static Ordering<MembersInjectionBinding> injectionOrdering() {
     return INJECTION_ORDERING;
@@ -62,7 +62,7 @@ public int compare(MembersInjectionBinding left, MembersInjectionBinding right)
       };
 
   private static int targetIndexInEnclosing(MembersInjectionBinding binding)  {
-    return binding.enclosingType().getEnclosedElements().indexOf(binding.bindingElement());
+    return binding.bindingTypeElement().getEnclosedElements().indexOf(binding.bindingElement());
   }
 
   /**
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorDescriptor.java
index ce8845bfd..ed0640340 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorDescriptor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorDescriptor.java
@@ -50,7 +50,7 @@ static MembersInjectorDescriptor create(Iterable<MembersInjectionBinding> bindin
     TypeElement injectedTypeElement = Iterables.getOnlyElement(FluentIterable.from(bindings)
         .transform(new Function<MembersInjectionBinding, TypeElement>() {
           @Override public TypeElement apply(MembersInjectionBinding binding) {
-            return binding.enclosingType();
+            return binding.bindingTypeElement();
           }
         })
         .toSet());
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
index 86d0ef356..ed2197c45 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
@@ -17,7 +17,9 @@
 
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
-import static dagger.Provides.Type.UNIQUE;
+import static com.google.common.collect.Sets.immutableEnumSet;
+import static dagger.Provides.Type.SET;
+import static dagger.Provides.Type.SET_VALUES;
 import static dagger.internal.codegen.InjectionAnnotations.getScopeAnnotation;
 import static javax.lang.model.element.ElementKind.CONSTRUCTOR;
 import static javax.lang.model.element.ElementKind.FIELD;
@@ -31,6 +33,8 @@
 
 import dagger.Provides;
 
+import java.util.Iterator;
+
 import javax.inject.Inject;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
@@ -47,13 +51,21 @@
  */
 @AutoValue
 abstract class ProvisionBinding extends Binding {
-  enum Type {
-    INJECT,
-    PROVIDES
+  enum Kind {
+    /** Represents an {@link Inject} binding. */
+    INJECTION,
+    /** Represents a binding configured by {@link Provides}. */
+    PROVISION,
   }
 
-  /** The type of binding ({@link Inject} or {@link Provides}). */
-  abstract Type type();
+  /**
+   * The type of binding ({@link Inject} or {@link Provides}). For the particular type of provision,
+   * use {@link #provisionType}.
+   */
+  abstract Kind bindingKind();
+
+  /** Returns provision type that was used to bind the key. */
+  abstract Provides.Type provisionType();
 
   /** The {@link Key} that is provided by this binding. */
   abstract Key providedKey();
@@ -64,19 +76,34 @@
   /** Returns {@code true} if this provision binding requires members to be injected implicitly. */
   abstract boolean requiresMemberInjection();
 
+  private static ImmutableSet<Provides.Type> SET_BINDING_TYPES = immutableEnumSet(SET, SET_VALUES);
+
   /**
-   * Returns {@code true} if this binding contributes to a single logical binding. I.e. multiple
-   * bindings are allowed for the same {@link Key}.
+   * Returns {@code true} if the given bindings are all contributors to a set binding.
+   *
+   * @throws IllegalArgumentException if some of the bindings are set bindings and some are not.
    */
-  abstract boolean contributingBinding();
+  static boolean isSetBindingCollection(Iterable<ProvisionBinding> bindings) {
+    checkNotNull(bindings);
+    Iterator<ProvisionBinding> iterator = bindings.iterator();
+    checkArgument(iterator.hasNext(), "no bindings");
+    boolean setBinding = SET_BINDING_TYPES.contains(iterator.next().provisionType());
+    while (iterator.hasNext()) {
+      checkArgument(setBinding,
+          "more than one binding present, but found a non-set binding");
+      checkArgument(SET_BINDING_TYPES.contains(iterator.next().provisionType()),
+          "more than one binding present, but found a non-set binding");
+    }
+    return setBinding;
+  }
 
   static final class Factory {
     private final Key.Factory keyFactory;
-    private final DependencyRequest.Factory keyRequestFactory;
+    private final DependencyRequest.Factory dependencyRequestFactory;
 
-    Factory(Key.Factory keyFactory, DependencyRequest.Factory keyRequestFactory) {
+    Factory(Key.Factory keyFactory, DependencyRequest.Factory dependencyRequestFactory) {
       this.keyFactory = keyFactory;
-      this.keyRequestFactory = keyRequestFactory;
+      this.dependencyRequestFactory = dependencyRequestFactory;
     }
 
     ProvisionBinding forInjectConstructor(ExecutableElement constructorElement) {
@@ -87,13 +114,13 @@ ProvisionBinding forInjectConstructor(ExecutableElement constructorElement) {
       checkArgument(!key.qualifier().isPresent());
       return new AutoValue_ProvisionBinding(
           constructorElement,
-          keyRequestFactory.forRequiredVariables(constructorElement.getParameters()),
-          Type.INJECT,
+          dependencyRequestFactory.forRequiredVariables(constructorElement.getParameters()),
+          Kind.INJECTION,
+          Provides.Type.UNIQUE,
           key,
           getScopeAnnotation(constructorElement.getEnclosingElement()),
           requiresMemeberInjection(
-              MoreElements.asType(constructorElement.getEnclosingElement())),
-          false);
+              MoreElements.asType(constructorElement.getEnclosingElement())));
     }
 
     private static final ImmutableSet<ElementKind> MEMBER_KINDS =
@@ -116,12 +143,12 @@ ProvisionBinding forProvidesMethod(ExecutableElement providesMethod) {
       checkArgument(providesAnnotation != null);
       return new AutoValue_ProvisionBinding(
           providesMethod,
-          keyRequestFactory.forRequiredVariables(providesMethod.getParameters()),
-          Type.PROVIDES,
+          dependencyRequestFactory.forRequiredVariables(providesMethod.getParameters()),
+          Kind.PROVISION,
+          providesAnnotation.type(),
           keyFactory.forProvidesMethod(providesMethod),
           getScopeAnnotation(providesMethod),
-          false,
-          !providesAnnotation.type().equals(UNIQUE));
+          false);
     }
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
index 798fe22e7..71cc0d1bf 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
@@ -30,6 +30,7 @@
 import com.google.common.collect.ImmutableSortedSet;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Ordering;
+import com.google.common.collect.SetMultimap;
 import com.squareup.javawriter.JavaWriter;
 
 import dagger.Lazy;
@@ -42,7 +43,6 @@
 import java.util.Map.Entry;
 
 import javax.inject.Provider;
-import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.util.ElementKindVisitor6;
@@ -187,24 +187,37 @@
 
   // TODO(gak): this needs to suck less
   static ImmutableBiMap<Key, String> generateProviderNamesForBindings(
-      Map<Key, ProvisionBinding> bindings) {
+      SetMultimap<Key, ProvisionBinding> bindings) {
     BiMap<Key, String> providerNames = HashBiMap.create(bindings.size());
-    for (Entry<Key, ProvisionBinding> entry : bindings.entrySet()) {
-      // collect together all of the names that we would want to call the provider
-      String bindingElementName = entry.getValue().bindingElement().accept(
-          new ElementKindVisitor6<String, Void>() {
-            @Override
-            public String visitExecutableAsConstructor(ExecutableElement e, Void p) {
-              return CaseFormat.UPPER_CAMEL
-                  .to(CaseFormat.LOWER_CAMEL, e.getEnclosingElement().getSimpleName().toString());
-            }
-
-            @Override
-            public String visitExecutableAsMethod(ExecutableElement e, Void p) {
-              return e.getSimpleName().toString();
-            }
-          }, null) + "Provider";
-      providerNames.put(entry.getKey(), bindingElementName);
+    for (Entry<Key, Collection<ProvisionBinding>> entry : bindings.asMap().entrySet()) {
+      Collection<ProvisionBinding> bindingsForKey = entry.getValue();
+      final String name;
+      if (ProvisionBinding.isSetBindingCollection(bindingsForKey)) {
+        name = new KeyVariableNamer().apply(entry.getKey()) + "Provider";
+      } else {
+        ProvisionBinding binding = Iterables.getOnlyElement(bindingsForKey);
+        switch (binding.bindingKind()) {
+          case INJECTION:
+          case PROVISION:
+            name = binding.bindingElement().accept(
+                new ElementKindVisitor6<String, Void>() {
+                  @Override
+                  public String visitExecutableAsConstructor(ExecutableElement e, Void p) {
+                    return CaseFormat.UPPER_CAMEL.to(CaseFormat.LOWER_CAMEL,
+                        e.getEnclosingElement().getSimpleName().toString());
+                  }
+
+                  @Override
+                  public String visitExecutableAsMethod(ExecutableElement e, Void p) {
+                    return e.getSimpleName().toString();
+                  }
+                }, null) + "Provider";
+            break;
+          default:
+            throw new AssertionError();
+        }
+      }
+      providerNames.put(entry.getKey(), name);
     }
     // return the map so that it is sorted by name
     return ImmutableBiMap.copyOf(ImmutableSortedMap.copyOf(providerNames.inverse())).inverse();
@@ -226,25 +239,28 @@ static String providerUsageStatement(String providerName,
   }
 
   static ClassName factoryNameForProvisionBinding(ProvisionBinding binding) {
-    TypeElement enclosingTypeElement = binding.enclosingType();
+    TypeElement enclosingTypeElement = binding.bindingTypeElement();
     ClassName enclosingClassName = ClassName.fromTypeElement(enclosingTypeElement);
-    String factoryPrefix = binding.bindingElement().accept(new ElementKindVisitor6<String, Void>() {
-      @Override protected String defaultAction(Element e, Void p) {
-        throw new IllegalStateException();
-      }
+    switch (binding.bindingKind()) {
+      case INJECTION:
+      case PROVISION:
+        return enclosingClassName.peerNamed(
+            enclosingClassName.simpleName() + "$$" + factoryPrefix(binding) + "Factory");
+      default:
+        throw new AssertionError();
+    }
+  }
 
-      @Override
-      public String visitExecutableAsConstructor(ExecutableElement e, Void p) {
+  private static String factoryPrefix(ProvisionBinding binding) {
+    switch (binding.bindingKind()) {
+      case INJECTION:
         return "";
-      }
-
-      @Override
-      public String visitExecutableAsMethod(ExecutableElement e, Void p) {
-        return CaseFormat.LOWER_CAMEL.to(UPPER_CAMEL, e.getSimpleName().toString());
-      }
-    }, null);
-    return enclosingClassName.peerNamed(
-        enclosingClassName.simpleName() + "$$" + factoryPrefix + "Factory");
+      case PROVISION:
+        return CaseFormat.LOWER_CAMEL.to(UPPER_CAMEL,
+            ((ExecutableElement) binding.bindingElement()).getSimpleName().toString());
+      default:
+        throw new IllegalArgumentException();
+    }
   }
 
   private SourceFiles() {}
diff --git a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
index a0fe4b7f0..9f26ab4df 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
@@ -224,4 +224,83 @@
         .compilesWithoutError()
         .and().generatesSources(generatedComponent);
   }
+
+  @Test public void setBindings() {
+    JavaFileObject emptySetModuleFile = JavaFileObjects.forSourceLines("test.EmptySetModule",
+        "package test;",
+        "",
+        "import static dagger.Provides.Type.SET_VALUES;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import java.util.Collections;",
+        "import java.util.Set;",
+        "",
+        "@Module",
+        "final class EmptySetModule {",
+        "  @Provides(type = SET_VALUES) Set<String> emptySet() { return Collections.emptySet(); }",
+        "}");
+    JavaFileObject setModuleFile = JavaFileObjects.forSourceLines("test.SetModule",
+        "package test;",
+        "",
+        "import static dagger.Provides.Type.SET;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "final class SetModule {",
+        "  @Provides(type = SET) String string() { return \"\"; }",
+        "}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import java.util.Set;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component(modules = {EmptySetModule.class, SetModule.class})",
+        "interface TestComponent {",
+        "  Set<String> strings();",
+        "}");
+    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
+        "test.Dagger_TestComponent",
+        "package test;",
+        "",
+        "import dagger.internal.SetFactory;",
+        "import java.util.Set;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class Dagger_TestComponent implements TestComponent {",
+        "  private final EmptySetModule emptySetModule;",
+        "  private final SetModule setModule;",
+        "  private final Provider<Set<String>> setOfStringProvider;",
+        "",
+        "  public Dagger_TestComponent(EmptySetModule emptySetModule, SetModule setModule) {",
+        "    if (emptySetModule == null) {",
+        "      throw new NullPointerException(\"emptySetModule\");",
+        "    }",
+        "    this.emptySetModule = emptySetModule;",
+        "    if (setModule == null) {",
+        "      throw new NullPointerException(\"setModule\");",
+        "    }",
+        "    this.setModule = setModule;",
+        "    this.setOfStringProvider = SetFactory.create(",
+        "        new EmptySetModule$$EmptySetFactory(emptySetModule),",
+        "        new SetModule$$StringFactory(setModule));",
+        "  }",
+        "",
+        "  @Override public Set<String> strings() {",
+        "    return setOfStringProvider.get();",
+        "  }",
+        "}");
+    ASSERT.about(javaSources())
+        .that(ImmutableList.of(emptySetModuleFile, setModuleFile, componentFile))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(generatedComponent);
+  }
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/ModuleProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ModuleProcessorTest.java
index bcc2b33fa..a834625e4 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ModuleProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ModuleProcessorTest.java
@@ -330,4 +330,88 @@
         .compilesWithoutError()
         .and().generatesSources(listFactoryFile);
   }
+
+  @Test public void proviesSetElement() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import static dagger.Provides.Type.SET;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "final class TestModule {",
+        "  @Provides(type = SET) String provideString() {",
+        "    return \"\";",
+        "  }",
+        "}");
+    JavaFileObject factoryFile = JavaFileObjects.forSourceLines("TestModule$$ProvideStringFactory",
+        "package test;",
+        "",
+        "import dagger.Factory;",
+        "import java.util.Collections;",
+        "import java.util.Set;",
+        "import javax.annotation.Generated;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class TestModule$$ProvideStringFactory implements Factory<Set<String>> {",
+        "  private final TestModule module;",
+        "",
+        "  public TestModule$$ProvideStringFactory(TestModule module) {",
+        "    assert module != null;",
+        "    this.module = module;",
+        "  }",
+        "",
+        "  @Override public Set<String> get() {",
+        "    return Collections.singleton(module.provideString());",
+        "  }",
+        "}");
+    ASSERT.about(javaSource()).that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(factoryFile);
+  }
+
+  @Test public void proviesSetValues() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import static dagger.Provides.Type.SET_VALUES;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import java.util.Set;",
+        "",
+        "@Module",
+        "final class TestModule {",
+        "  @Provides(type = SET_VALUES) Set<String> provideStrings() {",
+        "    return null;",
+        "  }",
+        "}");
+    JavaFileObject factoryFile = JavaFileObjects.forSourceLines("TestModule$$ProvideStringsFactory",
+        "package test;",
+        "",
+        "import dagger.Factory;",
+        "import java.util.Set;",
+        "import javax.annotation.Generated;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class TestModule$$ProvideStringsFactory implements Factory<Set<String>> {",
+        "  private final TestModule module;",
+        "",
+        "  public TestModule$$ProvideStringsFactory(TestModule module) {",
+        "    assert module != null;",
+        "    this.module = module;",
+        "  }",
+        "",
+        "  @Override public Set<String> get() {",
+        "    return module.provideStrings();",
+        "  }",
+        "}");
+    ASSERT.about(javaSource()).that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(factoryFile);
+  }
 }
diff --git a/core/src/main/java/dagger/internal/SetFactory.java b/core/src/main/java/dagger/internal/SetFactory.java
new file mode 100644
index 000000000..4da6a7752
--- /dev/null
+++ b/core/src/main/java/dagger/internal/SetFactory.java
@@ -0,0 +1,110 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal;
+
+import static java.util.Collections.unmodifiableSet;
+
+import dagger.Factory;
+
+import java.util.ArrayList;
+import java.util.LinkedHashSet;
+import java.util.List;
+import java.util.Set;
+
+import javax.inject.Provider;
+
+/**
+ * A {@link Factory} implementation used to implement {@link Set} bindings. This factory always
+ * returns a new {@link Set} instance for each call to {@link #get} (as required by {@link Factory})
+ * whose elements are populated by subsequent calls to their {@link Provider#get} methods.
+ *
+ * @author Gregory Kick
+ * @since 2.0
+ */
+public final class SetFactory<T> implements Factory<Set<T>> {
+  /**
+   * Returns a new factory that creates {@link Set} instances that from the union of the given
+   * {@link Provider} instances.
+   */
+  public static <T> Factory<Set<T>> create(Provider<Set<T>> first,
+      @SuppressWarnings("unchecked") Provider<Set<T>>... rest) {
+    if (first == null) {
+      throw new NullPointerException();
+    }
+    if (rest == null) {
+      throw new NullPointerException();
+    }
+    Set<Provider<Set<T>>> contributingProviders = newLinkedHashSetWithExpectedSize(1 + rest.length);
+    contributingProviders.add(first);
+    for (Provider<Set<T>> provider : rest) {
+      if (provider == null) {
+        throw new NullPointerException();
+      }
+      contributingProviders.add(provider);
+    }
+    return new SetFactory<T>(contributingProviders);
+  }
+
+  private final Set<Provider<Set<T>>> contributingProviders;
+
+  private SetFactory(Set<Provider<Set<T>>> contributingProviders) {
+    this.contributingProviders = contributingProviders;
+  }
+
+  /**
+   * Returns a {@link Set} whose iteration order is that of the elements given by each of the
+   * providers, which are invoked in the order given at creation.
+   *
+   * @throws NullPointerException if any of the delegate {@link Set} instances or elements therein
+   *     are {@code null}
+   */
+  @Override
+  public Set<T> get() {
+    List<Set<T>> providedSets = new ArrayList<Set<T>>(contributingProviders.size());
+    for (Provider<Set<T>> provider : contributingProviders) {
+      Set<T> providedSet = provider.get();
+      if (providedSet == null) {
+        throw new NullPointerException(provider + " returned null");
+      }
+      providedSets.add(providedSet);
+    }
+    int size = 0;
+    for (Set<T> providedSet : providedSets) {
+      size += providedSet.size();
+    }
+    Set<T> result = newLinkedHashSetWithExpectedSize(size);
+    for (Set<T> s : providedSets) {
+      for (T element : s) {
+        if (element == null) {
+          throw new NullPointerException("a null element was provided");
+        }
+        result.add(element);
+      }
+    }
+    return unmodifiableSet(result);
+  }
+
+  // TODO(gak): consider whether (expectedSize, 1.0f) is better for this use case since callers are
+  // typically only going to iterate
+  private static <E> LinkedHashSet<E> newLinkedHashSetWithExpectedSize(int expectedSize) {
+    int initialCapacity = (expectedSize < 3)
+        ? expectedSize + 1
+        : (expectedSize < (1 << (Integer.SIZE - 2)))
+            ? expectedSize + expectedSize / 3
+            : Integer.MAX_VALUE;
+    return new LinkedHashSet<E>(initialCapacity);
+  }
+}
diff --git a/core/src/test/java/dagger/internal/SetFactoryTest.java b/core/src/test/java/dagger/internal/SetFactoryTest.java
new file mode 100644
index 000000000..08d45f310
--- /dev/null
+++ b/core/src/test/java/dagger/internal/SetFactoryTest.java
@@ -0,0 +1,134 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal;
+
+import static com.google.common.collect.DiscreteDomain.integers;
+import static org.truth0.Truth.ASSERT;
+
+import com.google.common.collect.ContiguousSet;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Range;
+
+import dagger.Factory;
+
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.ExpectedException;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import java.util.LinkedHashSet;
+import java.util.Set;
+import java.util.concurrent.atomic.AtomicInteger;
+
+import javax.inject.Provider;
+
+@RunWith(JUnit4.class)
+@SuppressWarnings("unchecked")
+public class SetFactoryTest {
+  @Rule public ExpectedException thrown = ExpectedException.none();
+
+  @Test
+  public void nullFirstProvider() {
+    thrown.expect(NullPointerException.class);
+    SetFactory.create(null);
+  }
+
+  @Test
+  public void nullRest() {
+    thrown.expect(NullPointerException.class);
+    SetFactory.create(incrementingIntegerProvider(1),
+        (Provider<Set<Integer>>[]) null);
+  }
+
+  @Test
+  public void nullProviderInRest() {
+    thrown.expect(NullPointerException.class);
+    SetFactory.create(
+        incrementingIntegerProvider(1),
+        incrementingIntegerProvider(2),
+        null,
+        incrementingIntegerProvider(3));
+  }
+
+  @Test
+  public void providerReturnsNullSet() {
+    Factory<Set<Integer>> factory = SetFactory.create(new Provider<Set<Integer>>() {
+      @Override
+      public Set<Integer> get() {
+        return null;
+      }
+    });
+    thrown.expect(NullPointerException.class);
+    factory.get();
+  }
+
+  @Test
+  public void providerReturnsSetWithNullElement() {
+    Factory<Set<Integer>> factory = SetFactory.create(new Provider<Set<Integer>>() {
+      @Override
+      public Set<Integer> get() {
+        LinkedHashSet<Integer> result = new LinkedHashSet<Integer>();
+        result.add(1);
+        result.add(null);
+        result.add(3);
+        return result;
+      }
+    });
+    thrown.expect(NullPointerException.class);
+    factory.get();
+  }
+
+  @Test
+  public void invokesProvidersEverytTime() {
+    Factory<Set<Integer>> factory = SetFactory.create(
+        incrementingIntegerProvider(0),
+        incrementingIntegerProvider(10),
+        incrementingIntegerProvider(20));
+    ASSERT.that(factory.get()).has().exactly(0, 10, 20);
+    ASSERT.that(factory.get()).has().exactly(1, 11, 21);
+    ASSERT.that(factory.get()).has().exactly(2, 12, 22);
+  }
+
+  @Test
+  public void iterationOrder() {
+    Factory<Set<Integer>> factory = SetFactory.create(
+        integerSetProvider(Range.closed(5, 9)),
+        integerSetProvider(Range.closed(3, 6)),
+        integerSetProvider(Range.closed(0, 5)));
+    ASSERT.that(factory.get()).iteratesAs(5, 6, 7, 8, 9, 3, 4, 0, 1, 2);
+  }
+
+  private static Provider<Set<Integer>> incrementingIntegerProvider(int seed) {
+    final AtomicInteger value = new AtomicInteger(seed);
+    return new Provider<Set<Integer>>() {
+      @Override
+      public Set<Integer> get() {
+        return ImmutableSet.of(value.getAndIncrement());
+      }
+    };
+  }
+
+  private static Provider<Set<Integer>> integerSetProvider(Range<Integer> range) {
+    final ContiguousSet<Integer> set = ContiguousSet.create(range, integers());
+    return new Provider<Set<Integer>>() {
+      @Override
+      public Set<Integer> get() {
+        return set;
+      }
+    };
+  }
+}
