diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
index 1fc1bc7ba..f2a96204f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -105,7 +105,8 @@
 import static dagger.internal.codegen.Util.componentCanMakeNewInstances;
 import static javax.tools.Diagnostic.Kind.ERROR;
 
-public class BindingGraphValidator {
+/** Reports errors in the shape of the binding graph. */
+final class BindingGraphValidator {
 
   private final Elements elements;
   private final Types types;
@@ -143,7 +144,7 @@
 
   /** A dependency path from an entry point. */
   static final class DependencyPath {
-    final Deque<ResolvedRequest> requestPath = new ArrayDeque<>();
+    private final Deque<ResolvedRequest> requestPath = new ArrayDeque<>();
     private final LinkedHashMultiset<BindingKey> keyPath = LinkedHashMultiset.create();
     private final Set<DependencyRequest> resolvedRequests = new HashSet<>();
 
@@ -224,12 +225,19 @@ int size() {
       return requestPath.size();
     }
 
-    /** The nonsynthetic dependency requests in this path, starting with the entry point. */
-    FluentIterable<DependencyRequest> nonsyntheticRequests() {
-      return FluentIterable.from(requestPath)
-          .filter(Predicates.not(new PreviousBindingWasSynthetic()))
-          .transform(REQUEST_FROM_RESOLVED_REQUEST);
+    /** The dependency requests in this path, starting with the entry point. */
+    FluentIterable<DependencyRequest> requests() {
+      return FluentIterable.from(requestPath).transform(REQUEST_FROM_RESOLVED_REQUEST);
     }
+
+    private static final Function<ResolvedRequest, DependencyRequest>
+        REQUEST_FROM_RESOLVED_REQUEST =
+            new Function<ResolvedRequest, DependencyRequest>() {
+              @Override
+              public DependencyRequest apply(ResolvedRequest resolvedRequest) {
+                return resolvedRequest.request();
+              }
+            };
   }
 
   private final class Validation {
@@ -1304,24 +1312,4 @@ static ResolvedRequest create(DependencyRequest request, BindingGraph graph) {
               : resolvedBindings);
     }
   }
-
-  private static final Function<ResolvedRequest, DependencyRequest> REQUEST_FROM_RESOLVED_REQUEST =
-      new Function<ResolvedRequest, DependencyRequest>() {
-        @Override
-        public DependencyRequest apply(ResolvedRequest resolvedRequest) {
-          return resolvedRequest.request();
-        }
-      };
-
-  private static final class PreviousBindingWasSynthetic implements Predicate<ResolvedRequest> {
-    private ResolvedBindings previousBinding;
-
-    @Override
-    public boolean apply(ResolvedRequest resolvedRequest) {
-      boolean previousBindingWasSynthetic =
-          previousBinding != null && previousBinding.isSyntheticContribution();
-      previousBinding = resolvedRequest.binding();
-      return previousBindingWasSynthetic;
-    }
-  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
index 3dff2bf99..3cdf9832e 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
@@ -20,6 +20,7 @@
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Function;
 import com.google.common.base.Optional;
+import com.google.common.base.Predicate;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
@@ -160,6 +161,18 @@ BindingKey bindingKey() {
    * use a name derived from {@link #requestElement}.
    */
   abstract Optional<String> overriddenVariableName();
+  
+  /** {@code true} if this is a synthetic request, which should not appear in dependency traces. */
+  abstract boolean isSynthetic();
+
+  /** A predicate that passes for synthetic requests. */
+  static final Predicate<DependencyRequest> IS_SYNTHETIC =
+      new Predicate<DependencyRequest>() {
+        @Override
+        public boolean apply(DependencyRequest request) {
+          return request.isSynthetic();
+        }
+      };
 
   /**
    * Factory for {@link DependencyRequest}s.
@@ -215,7 +228,8 @@ DependencyRequest forImplicitMapBinding(
           mapOfFactoryKey,
           mapOfValueRequest.requestElement(),
           false /* doesn't allow null */,
-          Optional.<String>absent());
+          Optional.<String>absent(),
+          true /* synthetic */);
     }
 
     /**
@@ -233,7 +247,8 @@ DependencyRequest forMultibindingContribution(
           multibindingContribution.key(),
           request.requestElement(),
           false /* doesn't allow null */,
-          Optional.<String>absent());
+          Optional.<String>absent(),
+          true /* synthetic */);
     }
 
     private Kind multibindingContributionRequestKind(ContributionBinding multibindingContribution) {
@@ -319,7 +334,8 @@ DependencyRequest forComponentProductionMethod(ExecutableElement productionMetho
                 qualifier, Iterables.getOnlyElement(((DeclaredType) type).getTypeArguments())),
             productionMethod,
             false /* doesn't allow null */,
-            Optional.<String>absent());
+            Optional.<String>absent(),
+            false /* not synthetic */);
       } else {
         return newDependencyRequest(productionMethod, type, qualifier, Optional.<String>absent());
       }
@@ -342,7 +358,8 @@ DependencyRequest forComponentMembersInjectionMethod(ExecutableElement membersIn
           keyFactory.forMembersInjectedType(membersInjectedType),
           membersInjectionMethod,
           false /* doesn't allow null */,
-          Optional.<String>absent());
+          Optional.<String>absent(),
+          false /* not synthetic */);
     }
 
     DependencyRequest forMembersInjectedType(DeclaredType type) {
@@ -351,7 +368,8 @@ DependencyRequest forMembersInjectedType(DeclaredType type) {
           keyFactory.forMembersInjectedType(type),
           type.asElement(),
           false /* doesn't allow null */,
-          Optional.<String>absent());
+          Optional.<String>absent(),
+          false /* not synthetic */);
     }
 
     DependencyRequest forProductionImplementationExecutor() {
@@ -361,7 +379,8 @@ DependencyRequest forProductionImplementationExecutor() {
           key,
           MoreTypes.asElement(key.type()),
           false /* doesn't allow null */,
-          Optional.<String>absent());
+          Optional.<String>absent(),
+          false /* not synthetic */);
     }
 
     DependencyRequest forProductionComponentMonitorProvider() {
@@ -394,11 +413,12 @@ private DependencyRequest newDependencyRequest(
           keyFactory.forQualifiedType(qualifier, kindAndType.type()),
           requestElement,
           allowsNull,
-          name);
+          name,
+          false /* not synthetic */);
     }
 
     @AutoValue
-    static abstract class KindAndType {
+    abstract static class KindAndType {
       abstract Kind kind();
       abstract TypeMirror type();
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyRequestFormatter.java b/compiler/src/main/java/dagger/internal/codegen/DependencyRequestFormatter.java
index cd783be2a..9c3c65b92 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DependencyRequestFormatter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyRequestFormatter.java
@@ -72,13 +72,14 @@
   /**
    * A string representation of the dependency trace, starting with the
    * {@linkplain DependencyPath#currentDependencyRequest() current request} and ending with the
-   * entry point.
+   * entry point, excluding {@linkplain DependencyRequest#isSynthetic() synthetic} requests.
    */
   String toDependencyTrace(DependencyPath dependencyPath) {
     return Joiner.on('\n')
         .join(
             dependencyPath
-                .nonsyntheticRequests()
+                .requests()
+                .filter(Predicates.not(DependencyRequest.IS_SYNTHETIC))
                 .transform(this)
                 .filter(Predicates.not(Predicates.equalTo("")))
                 .toList()
diff --git a/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java b/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
index 2c19b554c..f81916ff5 100644
--- a/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
@@ -31,9 +31,9 @@
 
 @RunWith(JUnit4.class)
 public class GraphValidationTest {
-  private final JavaFileObject NULLABLE = JavaFileObjects.forSourceLines("test.Nullable",
-      "package test;",
-      "public @interface Nullable {}");
+  private static final JavaFileObject NULLABLE =
+      JavaFileObjects.forSourceLines(
+          "test.Nullable", "package test;", "public @interface Nullable {}");
 
   @Test public void componentOnConcreteClass() {
     JavaFileObject component = JavaFileObjects.forSourceLines("test.MyComponent",
@@ -932,6 +932,56 @@ public void duplicateExplicitBindings_UniqueBindingAndMultibindingDeclaration()
         .onLine(39);
   }
 
+  @Test
+  public void bindsMethodAppearsInTrace() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "TestComponent",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = TestModule.class)",
+            "interface TestComponent {",
+            "  TestInterface testInterface();",
+            "}");
+    JavaFileObject interfaceFile =
+        JavaFileObjects.forSourceLines("TestInterface", "interface TestInterface {}");
+    JavaFileObject implementationFile =
+        JavaFileObjects.forSourceLines(
+            "TestImplementation",
+            "import javax.inject.Inject;",
+            "",
+            "final class TestImplementation implements TestInterface {",
+            "  @Inject TestImplementation(String missingBinding) {}",
+            "}");
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "TestModule",
+            "import dagger.Binds;",
+            "import dagger.Module;",
+            "",
+            "@Module",
+            "interface TestModule {",
+            "  @Binds abstract TestInterface bindTestInterface(TestImplementation implementation);",
+            "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(component, module, interfaceFile, implementationFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            Joiner.on("\n      ")
+                .join(
+                    "java.lang.String cannot be provided without an @Inject constructor or from "
+                        + "an @Provides-annotated method.",
+                    "java.lang.String is injected at",
+                    "    TestImplementation.<init>(missingBinding)",
+                    "TestImplementation is injected at",
+                    "    TestModule.bindTestInterface(implementation)",
+                    "TestInterface is provided at",
+                    "    TestComponent.testInterface()"))
+        .in(component)
+        .onLine(5);
+  }
+
   @Test public void resolvedParametersInDependencyTrace() {
     JavaFileObject generic = JavaFileObjects.forSourceLines("test.Generic",
         "package test;",
