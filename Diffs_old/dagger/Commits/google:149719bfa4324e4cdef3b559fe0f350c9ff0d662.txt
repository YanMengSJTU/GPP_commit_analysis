diff --git a/java/dagger/internal/codegen/SourceFileGeneratorsModule.java b/java/dagger/internal/codegen/SourceFileGeneratorsModule.java
index bfc0bd8ff..b51c97ca2 100644
--- a/java/dagger/internal/codegen/SourceFileGeneratorsModule.java
+++ b/java/dagger/internal/codegen/SourceFileGeneratorsModule.java
@@ -27,8 +27,8 @@
 import dagger.internal.codegen.writing.FactoryGenerator;
 import dagger.internal.codegen.writing.HjarSourceFileGenerator;
 import dagger.internal.codegen.writing.MembersInjectorGenerator;
-import dagger.internal.codegen.writing.ModuleConstructorProxyGenerator;
 import dagger.internal.codegen.writing.ModuleGenerator;
+import dagger.internal.codegen.writing.ModuleProxies.ModuleConstructorProxyGenerator;
 import dagger.internal.codegen.writing.ProducerFactoryGenerator;
 import javax.lang.model.element.TypeElement;
 
diff --git a/java/dagger/internal/codegen/writing/ModuleConstructorProxyGenerator.java b/java/dagger/internal/codegen/writing/ModuleConstructorProxyGenerator.java
deleted file mode 100644
index 4520f4ed3..000000000
--- a/java/dagger/internal/codegen/writing/ModuleConstructorProxyGenerator.java
+++ /dev/null
@@ -1,86 +0,0 @@
-/*
- * Copyright (C) 2018 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal.codegen.writing;
-
-import static com.squareup.javapoet.MethodSpec.constructorBuilder;
-import static com.squareup.javapoet.MethodSpec.methodBuilder;
-import static com.squareup.javapoet.TypeSpec.classBuilder;
-import static dagger.internal.codegen.binding.ModuleKind.checkIsModule;
-import static dagger.internal.codegen.writing.ModuleProxies.nonPublicNullaryConstructor;
-import static javax.lang.model.element.Modifier.FINAL;
-import static javax.lang.model.element.Modifier.PRIVATE;
-import static javax.lang.model.element.Modifier.PUBLIC;
-import static javax.lang.model.element.Modifier.STATIC;
-
-import com.squareup.javapoet.ClassName;
-import com.squareup.javapoet.TypeSpec;
-import dagger.internal.codegen.base.SourceFileGenerator;
-import dagger.internal.codegen.langmodel.DaggerElements;
-import java.util.Optional;
-import javax.annotation.processing.Filer;
-import javax.inject.Inject;
-import javax.lang.model.SourceVersion;
-import javax.lang.model.element.Element;
-import javax.lang.model.element.TypeElement;
-
-/**
- * Generates a {@code public static} method that calls {@code new SomeModule()} for modules that
- * don't have {@linkplain ModuleProxies#nonPublicNullaryConstructor(TypeElement, DaggerElements)
- * publicly accessible constructors}.
- */
-// TODO(dpb): See if this can become a SourceFileGenerator<ModuleDescriptor> instead. Doing so may
-// cause ModuleProcessingStep to defer elements multiple times.
-public final class ModuleConstructorProxyGenerator extends SourceFileGenerator<TypeElement> {
-  private final DaggerElements elements;
-
-  @Inject
-  ModuleConstructorProxyGenerator(
-      Filer filer, DaggerElements elements, SourceVersion sourceVersion) {
-    super(filer, elements, sourceVersion);
-    this.elements = elements;
-  }
-
-  @Override
-  public ClassName nameGeneratedType(TypeElement moduleElement) {
-    return ModuleProxies.constructorProxyTypeName(moduleElement);
-  }
-
-  @Override
-  public Element originatingElement(TypeElement moduleElement) {
-    return moduleElement;
-  }
-
-  @Override
-  public Optional<TypeSpec.Builder> write(TypeElement moduleElement) {
-    checkIsModule(moduleElement);
-    return nonPublicNullaryConstructor(moduleElement, elements).isPresent()
-        ? Optional.of(buildProxy(nameGeneratedType(moduleElement), moduleElement))
-        : Optional.empty();
-  }
-
-  private TypeSpec.Builder buildProxy(ClassName generatedTypeName, TypeElement moduleElement) {
-    return classBuilder(generatedTypeName)
-        .addModifiers(PUBLIC, FINAL)
-        .addMethod(constructorBuilder().addModifiers(PRIVATE).build())
-        .addMethod(
-            methodBuilder("newInstance")
-                .addModifiers(PUBLIC, STATIC)
-                .returns(ClassName.get(moduleElement))
-                .addStatement("return new $T()", moduleElement)
-                .build());
-  }
-}
diff --git a/java/dagger/internal/codegen/writing/ModuleProxies.java b/java/dagger/internal/codegen/writing/ModuleProxies.java
index 13c4f222d..b01b58f13 100644
--- a/java/dagger/internal/codegen/writing/ModuleProxies.java
+++ b/java/dagger/internal/codegen/writing/ModuleProxies.java
@@ -16,26 +16,83 @@
 
 package dagger.internal.codegen.writing;
 
+import static com.squareup.javapoet.MethodSpec.constructorBuilder;
+import static com.squareup.javapoet.MethodSpec.methodBuilder;
+import static com.squareup.javapoet.TypeSpec.classBuilder;
 import static dagger.internal.codegen.langmodel.Accessibility.isElementAccessibleFrom;
 import static javax.lang.model.element.Modifier.ABSTRACT;
+import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
+import static javax.lang.model.element.Modifier.PUBLIC;
 import static javax.lang.model.element.Modifier.STATIC;
 import static javax.lang.model.util.ElementFilter.constructorsIn;
 
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.TypeSpec;
+import dagger.internal.codegen.base.SourceFileGenerator;
 import dagger.internal.codegen.binding.ModuleKind;
 import dagger.internal.codegen.binding.SourceFiles;
 import dagger.internal.codegen.langmodel.Accessibility;
 import dagger.internal.codegen.langmodel.DaggerElements;
 import java.util.Optional;
+import javax.annotation.processing.Filer;
+import javax.inject.Inject;
+import javax.lang.model.SourceVersion;
+import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 
 /** Convenience methods for generating and using module constructor proxy methods. */
 public final class ModuleProxies {
+
+  /** Generates a {@code public static} proxy method for constructing module instances. */
+  // TODO(dpb): See if this can become a SourceFileGenerator<ModuleDescriptor> instead. Doing so may
+  // cause ModuleProcessingStep to defer elements multiple times.
+  public static final class ModuleConstructorProxyGenerator
+      extends SourceFileGenerator<TypeElement> {
+    private final DaggerElements elements;
+
+    @Inject
+    ModuleConstructorProxyGenerator(
+        Filer filer, DaggerElements elements, SourceVersion sourceVersion) {
+      super(filer, elements, sourceVersion);
+      this.elements = elements;
+    }
+
+    @Override
+    public ClassName nameGeneratedType(TypeElement moduleElement) {
+      return constructorProxyTypeName(moduleElement);
+    }
+
+    @Override
+    public Element originatingElement(TypeElement moduleElement) {
+      return moduleElement;
+    }
+
+    @Override
+    public Optional<TypeSpec.Builder> write(TypeElement moduleElement) {
+      ModuleKind.checkIsModule(moduleElement);
+      return nonPublicNullaryConstructor(moduleElement, elements).isPresent()
+          ? Optional.of(buildProxy(moduleElement))
+          : Optional.empty();
+    }
+
+    private TypeSpec.Builder buildProxy(TypeElement moduleElement) {
+      return classBuilder(nameGeneratedType(moduleElement))
+          .addModifiers(PUBLIC, FINAL)
+          .addMethod(constructorBuilder().addModifiers(PRIVATE).build())
+          .addMethod(
+              methodBuilder("newInstance")
+                  .addModifiers(PUBLIC, STATIC)
+                  .returns(ClassName.get(moduleElement))
+                  .addStatement("return new $T()", moduleElement)
+                  .build());
+    }
+  }
+
   /** The name of the class that hosts the module constructor proxy method. */
-  static ClassName constructorProxyTypeName(TypeElement moduleElement) {
+  private static ClassName constructorProxyTypeName(TypeElement moduleElement) {
     ModuleKind.checkIsModule(moduleElement);
     ClassName moduleClassName = ClassName.get(moduleElement);
     return moduleClassName
@@ -49,7 +106,7 @@ static ClassName constructorProxyTypeName(TypeElement moduleElement) {
    * abstract, no proxy method can be generated.
    */
   // TODO(ronshapiro): make this an @Injectable class that injects DaggerElements
-  static Optional<ExecutableElement> nonPublicNullaryConstructor(
+  private static Optional<ExecutableElement> nonPublicNullaryConstructor(
       TypeElement moduleElement, DaggerElements elements) {
     ModuleKind.checkIsModule(moduleElement);
     if (moduleElement.getModifiers().contains(ABSTRACT)
