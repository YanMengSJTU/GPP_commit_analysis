diff --git a/java/dagger/internal/codegen/BUILD b/java/dagger/internal/codegen/BUILD
index 60db476d3..acb94f359 100644
--- a/java/dagger/internal/codegen/BUILD
+++ b/java/dagger/internal/codegen/BUILD
@@ -109,8 +109,9 @@ java_library(
         "AnnotationExpression.java",
         "Binding.java",
         "BindingDeclaration.java",
+        "BindingFactory.java",
         "BindingGraph.java",
-        "BindingGraphPlugin.java",  # TODO(ronshapiro): this should move to it's own model target
+        "BindingGraphPlugin.java",  # TODO(ronshapiro): this should move to its own model target
         "BindingNetwork.java",
         "BindingType.java",
         "BindingTypeMapper.java",
diff --git a/java/dagger/internal/codegen/BindingFactory.java b/java/dagger/internal/codegen/BindingFactory.java
new file mode 100644
index 000000000..5517e8440
--- /dev/null
+++ b/java/dagger/internal/codegen/BindingFactory.java
@@ -0,0 +1,677 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
+import static com.google.auto.common.MoreTypes.asDeclared;
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.base.Preconditions.checkState;
+import static com.google.common.collect.Iterables.getOnlyElement;
+import static dagger.internal.codegen.Binding.hasNonDefaultTypeParameters;
+import static dagger.internal.codegen.ComponentDescriptor.Kind.PRODUCTION_COMPONENT;
+import static dagger.internal.codegen.ComponentDescriptor.isComponentProductionMethod;
+import static dagger.internal.codegen.ConfigurationAnnotations.getNullableType;
+import static dagger.internal.codegen.ContributionBinding.bindingKindForMultibindingKey;
+import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
+import static dagger.internal.codegen.InjectionAnnotations.getQualifier;
+import static dagger.internal.codegen.MapKeys.getMapKey;
+import static dagger.internal.codegen.MoreAnnotationMirrors.wrapOptionalInEquivalence;
+import static dagger.internal.codegen.Scopes.uniqueScopeOf;
+import static dagger.model.BindingKind.BOUND_INSTANCE;
+import static dagger.model.BindingKind.COMPONENT;
+import static dagger.model.BindingKind.COMPONENT_DEPENDENCY;
+import static dagger.model.BindingKind.COMPONENT_PRODUCTION;
+import static dagger.model.BindingKind.COMPONENT_PROVISION;
+import static dagger.model.BindingKind.DELEGATE;
+import static dagger.model.BindingKind.INJECTION;
+import static dagger.model.BindingKind.MEMBERS_INJECTOR;
+import static dagger.model.BindingKind.OPTIONAL;
+import static dagger.model.BindingKind.PRODUCTION;
+import static dagger.model.BindingKind.PROVISION;
+import static dagger.model.BindingKind.RELEASABLE_REFERENCE_MANAGER;
+import static dagger.model.BindingKind.RELEASABLE_REFERENCE_MANAGERS;
+import static dagger.model.BindingKind.SUBCOMPONENT_BUILDER;
+import static javax.lang.model.element.ElementKind.CONSTRUCTOR;
+import static javax.lang.model.element.ElementKind.METHOD;
+import static javax.lang.model.element.Modifier.PRIVATE;
+import static javax.lang.model.element.Modifier.STATIC;
+
+import com.google.auto.common.MoreElements;
+import com.google.auto.common.MoreTypes;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.ImmutableSortedSet;
+import com.google.common.collect.Iterables;
+import com.google.common.collect.LinkedHashMultimap;
+import com.google.common.collect.SetMultimap;
+import dagger.Module;
+import dagger.internal.codegen.ComponentDescriptor.BuilderRequirementMethod;
+import dagger.internal.codegen.MembersInjectionBinding.InjectionSite;
+import dagger.internal.codegen.ProductionBinding.ProductionKind;
+import dagger.model.DependencyRequest;
+import dagger.model.Key;
+import dagger.model.RequestKind;
+import dagger.model.Scope;
+import dagger.producers.Produced;
+import dagger.producers.Producer;
+import java.util.ArrayList;
+import java.util.Comparator;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Optional;
+import java.util.Set;
+import java.util.function.BiFunction;
+import javax.inject.Inject;
+import javax.inject.Provider;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ElementKind;
+import javax.lang.model.element.ElementVisitor;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.ExecutableType;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.ElementKindVisitor6;
+
+/** A factory for {@link Binding} objects. */
+final class BindingFactory {
+  private final DaggerTypes types;
+  private final KeyFactory keyFactory;
+  private final DependencyRequestFactory dependencyRequestFactory;
+  private final DaggerElements elements;
+
+  @Inject
+  BindingFactory(
+      DaggerTypes types,
+      DaggerElements elements,
+      KeyFactory keyFactory,
+      DependencyRequestFactory dependencyRequestFactory) {
+    this.types = types;
+    this.elements = elements;
+    this.keyFactory = keyFactory;
+    this.dependencyRequestFactory = dependencyRequestFactory;
+  }
+
+  /**
+   * Returns an {@link dagger.model.BindingKind#INJECTION} binding.
+   *
+   * @param constructorElement the {@code @Inject}-annotated constructor
+   * @param resolvedType the parameterized type if the constructor is for a generic class and the
+   *     binding should be for the parameterized type
+   */
+  // TODO(dpb): See if we can just pass the parameterized type and not also the constructor.
+  ProvisionBinding injectionBinding(
+      ExecutableElement constructorElement, Optional<TypeMirror> resolvedType) {
+    checkArgument(constructorElement.getKind().equals(CONSTRUCTOR));
+    checkArgument(isAnnotationPresent(constructorElement, Inject.class));
+    checkArgument(!getQualifier(constructorElement).isPresent());
+
+    ExecutableType constructorType = MoreTypes.asExecutable(constructorElement.asType());
+    DeclaredType constructedType =
+        MoreTypes.asDeclared(constructorElement.getEnclosingElement().asType());
+    // If the class this is constructing has some type arguments, resolve everything.
+    if (!constructedType.getTypeArguments().isEmpty() && resolvedType.isPresent()) {
+      DeclaredType resolved = MoreTypes.asDeclared(resolvedType.get());
+      // Validate that we're resolving from the correct type.
+      checkState(
+          types.isSameType(types.erasure(resolved), types.erasure(constructedType)),
+          "erased expected type: %s, erased actual type: %s",
+          types.erasure(resolved),
+          types.erasure(constructedType));
+      constructorType = MoreTypes.asExecutable(types.asMemberOf(resolved, constructorElement));
+      constructedType = resolved;
+    }
+
+    Key key = keyFactory.forInjectConstructorWithResolvedType(constructedType);
+    ImmutableSet<DependencyRequest> provisionDependencies =
+        dependencyRequestFactory.forRequiredResolvedVariables(
+            constructorElement.getParameters(), constructorType.getParameterTypes());
+
+    ProvisionBinding.Builder builder =
+        ProvisionBinding.builder()
+            .contributionType(ContributionType.UNIQUE)
+            .bindingElement(constructorElement)
+            .key(key)
+            .provisionDependencies(provisionDependencies)
+            .injectionSites(getInjectionSites(constructedType))
+            .kind(INJECTION)
+            .scope(uniqueScopeOf(constructorElement.getEnclosingElement()));
+
+    TypeElement bindingTypeElement = MoreElements.asType(constructorElement.getEnclosingElement());
+    if (hasNonDefaultTypeParameters(bindingTypeElement, key.type(), types)) {
+      builder.unresolved(injectionBinding(constructorElement, Optional.empty()));
+    }
+    return builder.build();
+  }
+
+  /**
+   * Returns a {@link dagger.model.BindingKind#PROVISION} binding for a {@code @Provides}-annotated
+   * method.
+   *
+   * @param contributedBy the installed module that declares or inherits the method
+   */
+  ProvisionBinding providesMethodBinding(
+      ExecutableElement providesMethod, TypeElement contributedBy) {
+    return setMethodBindingProperties(
+            ProvisionBinding.builder(),
+            providesMethod,
+            contributedBy,
+            keyFactory.forProvidesMethod(providesMethod, contributedBy),
+            this::providesMethodBinding)
+        .kind(PROVISION)
+        .scope(uniqueScopeOf(providesMethod))
+        .nullableType(getNullableType(providesMethod))
+        .build();
+  }
+
+  /**
+   * Returns a {@link dagger.model.BindingKind#PRODUCTION} binding for a {@code @Produces}-annotated
+   * method.
+   *
+   * @param contributedBy the installed module that declares or inherits the method
+   */
+  ProductionBinding producesMethodBinding(
+      ExecutableElement producesMethod, TypeElement contributedBy) {
+    // TODO(beder): Add nullability checking with Java 8.
+    ProductionBinding.Builder builder =
+        setMethodBindingProperties(
+                ProductionBinding.builder(),
+                producesMethod,
+                contributedBy,
+                keyFactory.forProducesMethod(producesMethod, contributedBy),
+                this::producesMethodBinding)
+            .kind(PRODUCTION)
+            .productionKind(ProductionKind.fromProducesMethod(producesMethod))
+            .thrownTypes(producesMethod.getThrownTypes())
+            .executorRequest(dependencyRequestFactory.forProductionImplementationExecutor())
+            .monitorRequest(dependencyRequestFactory.forProductionComponentMonitor());
+    return builder.build();
+  }
+
+  private <C extends ContributionBinding, B extends ContributionBinding.Builder<C, B>>
+      B setMethodBindingProperties(
+          B builder,
+          ExecutableElement method,
+          TypeElement contributedBy,
+          Key key,
+          BiFunction<ExecutableElement, TypeElement, C> create) {
+    checkArgument(method.getKind().equals(METHOD));
+    ExecutableType methodType =
+        MoreTypes.asExecutable(
+            types.asMemberOf(MoreTypes.asDeclared(contributedBy.asType()), method));
+    if (!types.isSameType(methodType, method.asType())) {
+      builder.unresolved(create.apply(method, MoreElements.asType(method.getEnclosingElement())));
+    }
+    return builder
+        .contributionType(ContributionType.fromBindingMethod(method))
+        .bindingElement(method)
+        .contributingModule(contributedBy)
+        .key(key)
+        .dependencies(
+            dependencyRequestFactory.forRequiredResolvedVariables(
+                method.getParameters(), methodType.getParameterTypes()))
+        .wrappedMapKey(wrapOptionalInEquivalence(getMapKey(method)));
+  }
+
+  /**
+   * Returns a {@link dagger.model.BindingKind#MULTIBOUND_MAP} or {@link
+   * dagger.model.BindingKind#MULTIBOUND_SET} binding given a set of multibinding contribution
+   * bindings.
+   *
+   * @param key a key that may be satisfied by a multibinding
+   */
+  ContributionBinding syntheticMultibinding(
+      Key key, Iterable<ContributionBinding> multibindingContributions) {
+    ContributionBinding.Builder<?, ?> builder =
+        multibindingRequiresProduction(key, multibindingContributions)
+            ? ProductionBinding.builder()
+            : ProvisionBinding.builder();
+    return builder
+        .contributionType(ContributionType.UNIQUE)
+        .key(key)
+        .dependencies(
+            dependencyRequestFactory.forMultibindingContributions(key, multibindingContributions))
+        .kind(bindingKindForMultibindingKey(key))
+        .build();
+  }
+
+  private boolean multibindingRequiresProduction(
+      Key key, Iterable<ContributionBinding> multibindingContributions) {
+    if (MapType.isMap(key)) {
+      MapType mapType = MapType.from(key);
+      if (mapType.valuesAreTypeOf(Producer.class) || mapType.valuesAreTypeOf(Produced.class)) {
+        return true;
+      }
+    } else if (SetType.isSet(key) && SetType.from(key).elementsAreTypeOf(Produced.class)) {
+      return true;
+    }
+    return Iterables.any(
+        multibindingContributions, binding -> binding.bindingType().equals(BindingType.PRODUCTION));
+  }
+
+  /** Returns a {@link dagger.model.BindingKind#COMPONENT} binding for the component. */
+  ProvisionBinding componentBinding(TypeElement componentDefinitionType) {
+    checkNotNull(componentDefinitionType);
+    return ProvisionBinding.builder()
+        .contributionType(ContributionType.UNIQUE)
+        .bindingElement(componentDefinitionType)
+        .key(keyFactory.forType(componentDefinitionType.asType()))
+        .kind(COMPONENT)
+        .build();
+  }
+
+  /**
+   * Returns a {@link dagger.model.BindingKind#COMPONENT_DEPENDENCY} binding for a component's
+   * dependency.
+   */
+  ProvisionBinding componentDependencyBinding(ComponentRequirement dependency) {
+    checkNotNull(dependency);
+    return ProvisionBinding.builder()
+        .contributionType(ContributionType.UNIQUE)
+        .bindingElement(dependency.typeElement())
+        .key(keyFactory.forType(dependency.type()))
+        .kind(COMPONENT_DEPENDENCY)
+        .build();
+  }
+
+  /**
+   * Returns a {@link dagger.model.BindingKind#COMPONENT_PROVISION} or {@link
+   * dagger.model.BindingKind#COMPONENT_PRODUCTION} binding for a method on a component's
+   * dependency.
+   *
+   * @param componentDescriptor the component with the dependency, not the dependency that has the
+   *     method
+   */
+  ContributionBinding componentDependencyMethodBinding(
+      ComponentDescriptor componentDescriptor, ExecutableElement dependencyMethod) {
+    checkArgument(dependencyMethod.getKind().equals(METHOD));
+    checkArgument(dependencyMethod.getParameters().isEmpty());
+    ContributionBinding.Builder<?, ?> builder;
+    if (componentDescriptor.kind().equals(PRODUCTION_COMPONENT)
+        && isComponentProductionMethod(elements, dependencyMethod)) {
+      builder =
+          ProductionBinding.builder()
+              .key(keyFactory.forProductionComponentMethod(dependencyMethod))
+              .kind(COMPONENT_PRODUCTION)
+              .thrownTypes(dependencyMethod.getThrownTypes());
+    } else {
+      builder =
+          ProvisionBinding.builder()
+              .key(keyFactory.forComponentMethod(dependencyMethod))
+              .nullableType(getNullableType(dependencyMethod))
+              .kind(COMPONENT_PROVISION)
+              .scope(uniqueScopeOf(dependencyMethod));
+    }
+    return builder
+        .contributionType(ContributionType.UNIQUE)
+        .bindingElement(dependencyMethod)
+        .build();
+  }
+
+  /**
+   * Returns a {@link dagger.model.BindingKind#BOUND_INSTANCE} binding for a
+   * {@code @BindsInstance}-annotated builder method.
+   */
+  ProvisionBinding boundInstanceBinding(BuilderRequirementMethod bindsInstanceMethod) {
+    checkArgument(bindsInstanceMethod.method().getKind().equals(METHOD));
+    checkArgument(bindsInstanceMethod.method().getParameters().size() == 1);
+    return ProvisionBinding.builder()
+        .contributionType(ContributionType.UNIQUE)
+        .bindingElement(bindsInstanceMethod.method())
+        .key(bindsInstanceMethod.requirement().key().get())
+        .nullableType(getNullableType(getOnlyElement(bindsInstanceMethod.method().getParameters())))
+        .kind(BOUND_INSTANCE)
+        .build();
+  }
+
+  /**
+   * Returns a {@link dagger.model.BindingKind#SUBCOMPONENT_BUILDER} binding declared by a component
+   * method that returns a subcomponent builder. Use {{@link
+   * #subcomponentBuilderBinding(ImmutableSet)}} for bindings declared using {@link
+   * Module#subcomponents()}.
+   *
+   * @param component the component that declares or inherits the method
+   */
+  ProvisionBinding subcomponentBuilderBinding(
+      ExecutableElement subcomponentBuilderMethod, TypeElement component) {
+    checkArgument(subcomponentBuilderMethod.getKind().equals(METHOD));
+    checkArgument(subcomponentBuilderMethod.getParameters().isEmpty());
+    Key key =
+        keyFactory.forSubcomponentBuilderMethod(
+            subcomponentBuilderMethod, asDeclared(component.asType()));
+    return ProvisionBinding.builder()
+        .contributionType(ContributionType.UNIQUE)
+        .bindingElement(subcomponentBuilderMethod)
+        .key(key)
+        .kind(SUBCOMPONENT_BUILDER)
+        .build();
+  }
+
+  /**
+   * Returns a {@link dagger.model.BindingKind#SUBCOMPONENT_BUILDER} binding declared using {@link
+   * Module#subcomponents()}.
+   */
+  ProvisionBinding subcomponentBuilderBinding(
+      ImmutableSet<SubcomponentDeclaration> subcomponentDeclarations) {
+    SubcomponentDeclaration subcomponentDeclaration = subcomponentDeclarations.iterator().next();
+    return ProvisionBinding.builder()
+        .contributionType(ContributionType.UNIQUE)
+        .key(subcomponentDeclaration.key())
+        .kind(SUBCOMPONENT_BUILDER)
+        .build();
+  }
+
+  /**
+   * Returns a {@link dagger.model.BindingKind#DELEGATE} binding.
+   *
+   * @param delegateDeclaration the {@code @Binds}-annotated declaration
+   * @param actualBinding the binding that satisfies the {@code @Binds} declaration
+   */
+  ContributionBinding delegateBinding(
+      DelegateDeclaration delegateDeclaration, ContributionBinding actualBinding) {
+    switch (actualBinding.bindingType()) {
+      case PRODUCTION:
+        return buildDelegateBinding(
+            ProductionBinding.builder().nullableType(actualBinding.nullableType()),
+            delegateDeclaration,
+            Producer.class);
+
+      case PROVISION:
+        return buildDelegateBinding(
+            ProvisionBinding.builder()
+                .scope(uniqueScopeOf(delegateDeclaration.bindingElement().get()))
+                .nullableType(actualBinding.nullableType()),
+            delegateDeclaration,
+            Provider.class);
+
+      case MEMBERS_INJECTION: // fall-through to throw
+    }
+    throw new AssertionError("bindingType: " + actualBinding);
+  }
+
+  /**
+   * Returns a {@link dagger.model.BindingKind#DELEGATE} binding used when there is no binding that
+   * satisfies the {@code @Binds} declaration.
+   */
+  ContributionBinding missingDelegateBinding(DelegateDeclaration delegateDeclaration) {
+    return buildDelegateBinding(
+        ProvisionBinding.builder().scope(uniqueScopeOf(delegateDeclaration.bindingElement().get())),
+        delegateDeclaration,
+        Provider.class);
+  }
+
+  private ContributionBinding buildDelegateBinding(
+      ContributionBinding.Builder<?, ?> builder,
+      DelegateDeclaration delegateDeclaration,
+      Class<?> frameworkType) {
+    return builder
+        .contributionType(delegateDeclaration.contributionType())
+        .bindingElement(delegateDeclaration.bindingElement().get())
+        .contributingModule(delegateDeclaration.contributingModule().get())
+        .key(keyFactory.forDelegateBinding(delegateDeclaration, frameworkType))
+        .dependencies(delegateDeclaration.delegateRequest())
+        .wrappedMapKey(delegateDeclaration.wrappedMapKey())
+        .kind(DELEGATE)
+        .build();
+  }
+
+  /**
+   * Returns a {@link dagger.model.BindingKind#RELEASABLE_REFERENCE_MANAGER} binding for a {@code
+   * ReleasableReferenceManager}.
+   */
+  ProvisionBinding releasableReferenceManagerBinding(Scope scope) {
+    return ProvisionBinding.builder()
+        .contributionType(ContributionType.UNIQUE)
+        .key(keyFactory.forReleasableReferenceManager(scope))
+        .kind(RELEASABLE_REFERENCE_MANAGER)
+        .build();
+  }
+
+  /**
+   * Returns a {@link dagger.model.BindingKind#RELEASABLE_REFERENCE_MANAGER} binding for a {@code
+   * TypedReleasableReferenceManager<M>}.
+   */
+  ProvisionBinding typedReleasableReferenceManagerBinding(Scope scope, DeclaredType metadataType) {
+    return releasableReferenceManagerBinding(scope)
+        .toBuilder()
+        .key(keyFactory.forTypedReleasableReferenceManager(scope, metadataType))
+        .build();
+  }
+
+  /**
+   * Returns a {@link dagger.model.BindingKind#RELEASABLE_REFERENCE_MANAGERS} binding for a set of
+   * {@code ReleasableReferenceManager}s.
+   */
+  ProvisionBinding setOfReleasableReferenceManagersBinding() {
+    return ProvisionBinding.builder()
+        .contributionType(ContributionType.UNIQUE)
+        .key(keyFactory.forSetOfReleasableReferenceManagers())
+        .kind(RELEASABLE_REFERENCE_MANAGERS)
+        .build();
+  }
+
+  /**
+   * Returns a {@link dagger.model.BindingKind#RELEASABLE_REFERENCE_MANAGERS} binding for a set of
+   * {@code TypedReleasableReferenceManager<M>}s.
+   */
+  ProvisionBinding setOfTypedReleasableReferenceManagersBinding(DeclaredType metadataType) {
+    return setOfReleasableReferenceManagersBinding()
+        .toBuilder()
+        .key(keyFactory.forSetOfTypedReleasableReferenceManagers(metadataType))
+        .build();
+  }
+
+  /**
+   * Returns an {@link dagger.model.BindingKind#OPTIONAL} binding for {@code key}.
+   *
+   * @param requestKind the kind of request for the optional binding
+   * @param underlyingKeyBindings the possibly empty set of bindings that exist in the component for
+   *     the underlying (non-optional) key
+   */
+  ContributionBinding syntheticOptionalBinding(
+      Key key, RequestKind requestKind, ResolvedBindings underlyingKeyBindings) {
+    ContributionBinding.Builder<?, ?> builder =
+        syntheticOptionalBindingBuilder(requestKind, underlyingKeyBindings)
+            .contributionType(ContributionType.UNIQUE)
+            .key(key)
+            .kind(OPTIONAL);
+    if (!underlyingKeyBindings.isEmpty()) {
+      builder.dependencies(
+          dependencyRequestFactory.forSyntheticPresentOptionalBinding(key, requestKind));
+    }
+    return builder.build();
+  }
+
+  private ContributionBinding.Builder<?, ?> syntheticOptionalBindingBuilder(
+      RequestKind requestKind, ResolvedBindings underlyingKeyBindings) {
+    return !underlyingKeyBindings.isEmpty()
+            && (underlyingKeyBindings.bindingTypes().contains(BindingType.PRODUCTION)
+                || requestKind.equals(RequestKind.PRODUCER) // handles producerFromProvider cases
+                || requestKind.equals(RequestKind.PRODUCED)) // handles producerFromProvider cases
+        ? ProductionBinding.builder()
+        : ProvisionBinding.builder();
+  }
+
+  /** Returns a {@link dagger.model.BindingKind#MEMBERS_INJECTOR} binding. */
+  ProvisionBinding membersInjectorBinding(
+      Key key, MembersInjectionBinding membersInjectionBinding) {
+    return ProvisionBinding.builder()
+        .key(key)
+        .contributionType(ContributionType.UNIQUE)
+        .kind(MEMBERS_INJECTOR)
+        .bindingElement(MoreTypes.asTypeElement(membersInjectionBinding.key().type()))
+        .provisionDependencies(membersInjectionBinding.dependencies())
+        .injectionSites(membersInjectionBinding.injectionSites())
+        .build();
+  }
+
+  /**
+   * Returns a {@link dagger.model.BindingKind#MEMBERS_INJECTION} binding.
+   *
+   * @param resolvedType if {@code declaredType} is a generic class and {@code resolvedType} is a
+   *     parameterization of that type, the returned binding will be for the resolved type
+   */
+  // TODO(dpb): See if we can just pass one nongeneric/parameterized type.
+  MembersInjectionBinding membersInjectionBinding(
+      DeclaredType declaredType, Optional<TypeMirror> resolvedType) {
+    // If the class this is injecting has some type arguments, resolve everything.
+    if (!declaredType.getTypeArguments().isEmpty() && resolvedType.isPresent()) {
+      DeclaredType resolved = asDeclared(resolvedType.get());
+      // Validate that we're resolving from the correct type.
+      checkState(
+          types.isSameType(types.erasure(resolved), types.erasure(declaredType)),
+          "erased expected type: %s, erased actual type: %s",
+          types.erasure(resolved),
+          types.erasure(declaredType));
+      declaredType = resolved;
+    }
+    ImmutableSortedSet<InjectionSite> injectionSites = getInjectionSites(declaredType);
+    ImmutableSet<DependencyRequest> dependencies =
+        injectionSites
+            .stream()
+            .flatMap(injectionSite -> injectionSite.dependencies().stream())
+            .collect(toImmutableSet());
+
+    Optional<Key> parentKey =
+        types.nonObjectSuperclass(declaredType).map(keyFactory::forMembersInjectedType);
+
+    Key key = keyFactory.forMembersInjectedType(declaredType);
+    TypeElement typeElement = MoreElements.asType(declaredType.asElement());
+    return new AutoValue_MembersInjectionBinding(
+        key,
+        dependencies,
+        typeElement,
+        hasNonDefaultTypeParameters(typeElement, key.type(), types)
+            ? Optional.of(
+                membersInjectionBinding(asDeclared(typeElement.asType()), Optional.empty()))
+            : Optional.empty(),
+        injectionSites,
+        parentKey);
+  }
+
+  private final ElementVisitor<Optional<InjectionSite>, DeclaredType> injectionSiteVisitor =
+      new ElementKindVisitor6<Optional<InjectionSite>, DeclaredType>(Optional.empty()) {
+        @Override
+        public Optional<InjectionSite> visitExecutableAsMethod(
+            ExecutableElement e, DeclaredType type) {
+          return Optional.of(injectionSiteForInjectMethod(e, type));
+        }
+
+        @Override
+        public Optional<InjectionSite> visitVariableAsField(VariableElement e, DeclaredType type) {
+          return (isAnnotationPresent(e, Inject.class)
+                  && !e.getModifiers().contains(PRIVATE)
+                  && !e.getModifiers().contains(STATIC))
+              ? Optional.of(injectionSiteForInjectField(e, type))
+              : Optional.empty();
+        }
+      };
+
+  private ImmutableSortedSet<InjectionSite> getInjectionSites(DeclaredType declaredType) {
+    Set<InjectionSite> injectionSites = new HashSet<>();
+    List<TypeElement> ancestors = new ArrayList<>();
+    SetMultimap<String, ExecutableElement> overriddenMethodMap = LinkedHashMultimap.create();
+    for (Optional<DeclaredType> currentType = Optional.of(declaredType);
+        currentType.isPresent();
+        currentType = types.nonObjectSuperclass(currentType.get())) {
+      DeclaredType type = currentType.get();
+      ancestors.add(MoreElements.asType(type.asElement()));
+      for (Element enclosedElement : type.asElement().getEnclosedElements()) {
+        Optional<InjectionSite> maybeInjectionSite =
+            injectionSiteVisitor.visit(enclosedElement, type);
+        if (maybeInjectionSite.isPresent()) {
+          InjectionSite injectionSite = maybeInjectionSite.get();
+          if (shouldBeInjected(injectionSite.element(), overriddenMethodMap)) {
+            injectionSites.add(injectionSite);
+          }
+          if (injectionSite.kind().equals(InjectionSite.Kind.METHOD)) {
+            ExecutableElement injectionSiteMethod =
+                MoreElements.asExecutable(injectionSite.element());
+            overriddenMethodMap.put(
+                injectionSiteMethod.getSimpleName().toString(), injectionSiteMethod);
+          }
+        }
+      }
+    }
+    return ImmutableSortedSet.copyOf(
+        // supertypes before subtypes
+        Comparator.comparing(
+                (InjectionSite injectionSite) ->
+                    ancestors.indexOf(injectionSite.element().getEnclosingElement()))
+            .reversed()
+            // fields before methods
+            .thenComparing(injectionSite -> injectionSite.element().getKind())
+            // then sort by whichever element comes first in the parent
+            // this isn't necessary, but makes the processor nice and predictable
+            .thenComparing(InjectionSite::indexAmongSiblingMembers),
+        injectionSites);
+  }
+
+  private boolean shouldBeInjected(
+      Element injectionSite, SetMultimap<String, ExecutableElement> overriddenMethodMap) {
+    if (!isAnnotationPresent(injectionSite, Inject.class)
+        || injectionSite.getModifiers().contains(PRIVATE)
+        || injectionSite.getModifiers().contains(STATIC)) {
+      return false;
+    }
+
+    if (injectionSite.getKind().isField()) { // Inject all fields (self and ancestors)
+      return true;
+    }
+
+    // For each method with the same name belonging to any descendant class, return false if any
+    // method has already overridden the injectionSite method. To decrease the number of methods
+    // that are checked, we store the already injected methods in a SetMultimap and only
+    // check the methods with the same name.
+    ExecutableElement injectionSiteMethod = MoreElements.asExecutable(injectionSite);
+    TypeElement injectionSiteType = MoreElements.asType(injectionSite.getEnclosingElement());
+    for (ExecutableElement method :
+        overriddenMethodMap.get(injectionSiteMethod.getSimpleName().toString())) {
+      if (elements.overrides(method, injectionSiteMethod, injectionSiteType)) {
+        return false;
+      }
+    }
+    return true;
+  }
+
+  private InjectionSite injectionSiteForInjectMethod(
+      ExecutableElement methodElement, DeclaredType containingType) {
+    checkNotNull(methodElement);
+    checkArgument(methodElement.getKind().equals(ElementKind.METHOD));
+    ExecutableType resolved =
+        MoreTypes.asExecutable(types.asMemberOf(containingType, methodElement));
+    return new AutoValue_MembersInjectionBinding_InjectionSite(
+        InjectionSite.Kind.METHOD,
+        methodElement,
+        dependencyRequestFactory.forRequiredResolvedVariables(
+            methodElement.getParameters(), resolved.getParameterTypes()));
+  }
+
+  private InjectionSite injectionSiteForInjectField(
+      VariableElement fieldElement, DeclaredType containingType) {
+    checkNotNull(fieldElement);
+    checkArgument(fieldElement.getKind().equals(ElementKind.FIELD));
+    checkArgument(isAnnotationPresent(fieldElement, Inject.class));
+    TypeMirror resolved = types.asMemberOf(containingType, fieldElement);
+    return new AutoValue_MembersInjectionBinding_InjectionSite(
+        InjectionSite.Kind.FIELD,
+        fieldElement,
+        ImmutableSet.of(
+            dependencyRequestFactory.forRequiredResolvedVariable(fieldElement, resolved)));
+  }
+}
diff --git a/java/dagger/internal/codegen/BindingGraph.java b/java/dagger/internal/codegen/BindingGraph.java
index 200b0647a..f390d65c0 100644
--- a/java/dagger/internal/codegen/BindingGraph.java
+++ b/java/dagger/internal/codegen/BindingGraph.java
@@ -23,9 +23,7 @@
 import static com.google.common.base.Verify.verify;
 import static com.google.common.collect.Iterables.any;
 import static com.google.common.collect.Iterables.isEmpty;
-import static dagger.internal.codegen.ComponentDescriptor.Kind.PRODUCTION_COMPONENT;
 import static dagger.internal.codegen.ComponentDescriptor.isComponentContributionMethod;
-import static dagger.internal.codegen.ComponentDescriptor.isComponentProductionMethod;
 import static dagger.internal.codegen.ComponentRequirement.Kind.BOUND_INSTANCE;
 import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
 import static dagger.internal.codegen.RequestKinds.getRequestKind;
@@ -254,21 +252,18 @@ TypeElement componentType() {
     private final Elements elements;
     private final InjectBindingRegistry injectBindingRegistry;
     private final KeyFactory keyFactory;
-    private final ProvisionBinding.Factory provisionBindingFactory;
-    private final ProductionBinding.Factory productionBindingFactory;
+    private final BindingFactory bindingFactory;
 
     @Inject
     Factory(
         Elements elements,
         InjectBindingRegistry injectBindingRegistry,
         KeyFactory keyFactory,
-        ProvisionBinding.Factory provisionBindingFactory,
-        ProductionBinding.Factory productionBindingFactory) {
+        BindingFactory bindingFactory) {
       this.elements = elements;
       this.injectBindingRegistry = injectBindingRegistry;
       this.keyFactory = keyFactory;
-      this.provisionBindingFactory = provisionBindingFactory;
-      this.productionBindingFactory = productionBindingFactory;
+      this.bindingFactory = bindingFactory;
     }
 
     BindingGraph create(ComponentDescriptor componentDescriptor) {
@@ -283,21 +278,18 @@ private BindingGraph create(
 
       // binding for the component itself
       explicitBindingsBuilder.add(
-          provisionBindingFactory.forComponent(componentDescriptor.componentDefinitionType()));
+          bindingFactory.componentBinding(componentDescriptor.componentDefinitionType()));
 
       // Collect Component dependencies.
       for (ComponentRequirement dependency : componentDescriptor.dependencies()) {
-        explicitBindingsBuilder.add(provisionBindingFactory.forComponentDependency(dependency));
+        explicitBindingsBuilder.add(bindingFactory.componentDependencyBinding(dependency));
         List<ExecutableElement> dependencyMethods =
             methodsIn(elements.getAllMembers(dependency.typeElement()));
         for (ExecutableElement method : dependencyMethods) {
           // MembersInjection methods aren't "provided" explicitly, so ignore them.
           if (isComponentContributionMethod(elements, method)) {
             explicitBindingsBuilder.add(
-                componentDescriptor.kind().equals(PRODUCTION_COMPONENT)
-                        && isComponentProductionMethod(elements, method)
-                    ? productionBindingFactory.forComponentMethod(method)
-                    : provisionBindingFactory.forComponentMethod(method));
+                bindingFactory.componentDependencyMethodBinding(componentDescriptor, method));
           }
         }
       }
@@ -307,7 +299,7 @@ private BindingGraph create(
         for (BuilderRequirementMethod method :
             componentDescriptor.builderSpec().get().requirementMethods()) {
           if (method.requirement().kind().equals(BOUND_INSTANCE)) {
-            explicitBindingsBuilder.add(provisionBindingFactory.forBuilderBinding(method));
+            explicitBindingsBuilder.add(bindingFactory.boundInstanceBinding(method));
           }
         }
       }
@@ -319,9 +311,8 @@ private BindingGraph create(
         ComponentDescriptor subcomponentDescriptor = componentMethodAndSubcomponent.getValue();
         if (!componentDescriptor.subcomponentsFromModules().contains(subcomponentDescriptor)) {
           explicitBindingsBuilder.add(
-              provisionBindingFactory.forSubcomponentBuilderMethod(
-                  componentMethod.methodElement(),
-                  componentDescriptor.componentDefinitionType()));
+              bindingFactory.subcomponentBuilderBinding(
+                  componentMethod.methodElement(), componentDescriptor.componentDefinitionType()));
         }
       }
 
@@ -409,18 +400,18 @@ private BindingGraph create(
       // none?
       for (Scope scope : componentDescriptor.releasableReferencesScopes()) {
         // Add a binding for @ForReleasableReferences(scope) ReleasableReferenceManager.
-        bindings.put(scope, provisionBindingFactory.provideReleasableReferenceManager(scope));
+        bindings.put(scope, bindingFactory.releasableReferenceManagerBinding(scope));
 
         /* Add a binding for Set<ReleasableReferenceManager>. Even if these are added more than
          * once, each instance will be equal to the rest. Since they're being added to a set, there
          * will be only one instance. */
-        bindings.put(scope, provisionBindingFactory.provideSetOfReleasableReferenceManagers());
+        bindings.put(scope, bindingFactory.setOfReleasableReferenceManagersBinding());
 
         for (AnnotationMirror metadata : scope.releasableReferencesMetadata()) {
           // Add a binding for @ForReleasableReferences(scope) TypedReleasableReferenceManager<M>.
           bindings.put(
               scope,
-              provisionBindingFactory.provideTypedReleasableReferenceManager(
+              bindingFactory.typedReleasableReferenceManagerBinding(
                   scope, metadata.getAnnotationType()));
 
           /* Add a binding for Set<TypedReleasableReferenceManager<M>>. Even if these are added more
@@ -428,7 +419,7 @@ private BindingGraph create(
            * there will be only one instance. */
           bindings.put(
               scope,
-              provisionBindingFactory.provideSetOfTypedReleasableReferenceManagers(
+              bindingFactory.setOfTypedReleasableReferenceManagersBinding(
                   metadata.getAnnotationType()));
         }
       }
@@ -625,37 +616,16 @@ private void addSubcomponentToOwningResolver(ProvisionBinding subcomponentBuilde
           Key key,
           Iterable<ContributionBinding> multibindingContributions,
           Iterable<MultibindingDeclaration> multibindingDeclarations) {
-        if (isEmpty(multibindingContributions) && isEmpty(multibindingDeclarations)) {
-          return Optional.empty();
-        } else if (multibindingsRequireProduction(multibindingContributions, key)) {
-          return Optional.of(
-              productionBindingFactory.syntheticMultibinding(key, multibindingContributions));
-        } else {
-          return Optional.of(
-              provisionBindingFactory.syntheticMultibinding(key, multibindingContributions));
-        }
-      }
-
-      private boolean multibindingsRequireProduction(
-          Iterable<ContributionBinding> multibindingContributions, Key key) {
-        if (MapType.isMap(key)) {
-          MapType mapType = MapType.from(key);
-          if (mapType.valuesAreTypeOf(Producer.class) || mapType.valuesAreTypeOf(Produced.class)) {
-            return true;
-          }
-        } else if (SetType.isSet(key) && SetType.from(key).elementsAreTypeOf(Produced.class)) {
-          return true;
-        }
-        return Iterables.any(multibindingContributions,
-            binding -> binding.bindingType().equals(BindingType.PRODUCTION));
+        return isEmpty(multibindingContributions) && isEmpty(multibindingDeclarations)
+            ? Optional.empty()
+            : Optional.of(bindingFactory.syntheticMultibinding(key, multibindingContributions));
       }
 
       private Optional<ProvisionBinding> syntheticSubcomponentBuilderBinding(
           ImmutableSet<SubcomponentDeclaration> subcomponentDeclarations) {
         return subcomponentDeclarations.isEmpty()
             ? Optional.empty()
-            : Optional.of(
-                provisionBindingFactory.syntheticSubcomponentBuilder(subcomponentDeclarations));
+            : Optional.of(bindingFactory.subcomponentBuilderBinding(subcomponentDeclarations));
       }
 
       /**
@@ -670,22 +640,13 @@ private boolean multibindingsRequireProduction(
        */
       private Optional<ContributionBinding> syntheticOptionalBinding(
           Key key, ImmutableSet<OptionalBindingDeclaration> optionalBindingDeclarations) {
-        if (optionalBindingDeclarations.isEmpty()) {
-          return Optional.empty();
-        }
-        RequestKind requestKind = getRequestKind(OptionalType.from(key).valueType());
-        ResolvedBindings underlyingKeyBindings =
-            lookUpBindings(keyFactory.unwrapOptional(key).get());
-        if (underlyingKeyBindings.isEmpty()) {
-          return Optional.of(provisionBindingFactory.syntheticAbsentBinding(key));
-        } else if (underlyingKeyBindings.bindingTypes().contains(BindingType.PRODUCTION)
-            // handles producerFromProvider cases
-            || requestKind.equals(RequestKind.PRODUCER)
-            || requestKind.equals(RequestKind.PRODUCED)) {
-          return Optional.of(productionBindingFactory.syntheticPresentBinding(key, requestKind));
-        } else {
-          return Optional.of(provisionBindingFactory.syntheticPresentBinding(key, requestKind));
-        }
+        return optionalBindingDeclarations.isEmpty()
+            ? Optional.empty()
+            : Optional.of(
+                bindingFactory.syntheticOptionalBinding(
+                    key,
+                    getRequestKind(OptionalType.from(key).valueType()),
+                    lookUpBindings(keyFactory.unwrapOptional(key).get())));
       }
 
       private ImmutableSet<ContributionBinding> createDelegateBindings(
@@ -706,7 +667,7 @@ private boolean multibindingsRequireProduction(
       private ContributionBinding createDelegateBinding(DelegateDeclaration delegateDeclaration) {
         Key delegateKey = delegateDeclaration.delegateRequest().key();
         if (cycleStack.contains(delegateKey)) {
-          return provisionBindingFactory.missingDelegate(delegateDeclaration);
+          return bindingFactory.missingDelegateBinding(delegateDeclaration);
         }
 
         ResolvedBindings resolvedDelegate;
@@ -726,22 +687,13 @@ private ContributionBinding createDelegateBinding(DelegateDeclaration delegateDe
           // is needed.
           // TODO(gak): revisit how we model missing delegates if/when we clean up how we model
           // binding declarations
-          return provisionBindingFactory.missingDelegate(delegateDeclaration);
+          return bindingFactory.missingDelegateBinding(delegateDeclaration);
         }
         // It doesn't matter which of these is selected, since they will later on produce a
         // duplicate binding error.
         ContributionBinding explicitDelegate =
             resolvedDelegate.contributionBindings().iterator().next();
-        switch (explicitDelegate.bindingType()) {
-          case PRODUCTION:
-            return productionBindingFactory.delegate(
-                delegateDeclaration, (ProductionBinding) explicitDelegate);
-          case PROVISION:
-            return provisionBindingFactory.delegate(
-                delegateDeclaration, (ProvisionBinding) explicitDelegate);
-          default:
-            throw new AssertionError("bindingType: " + explicitDelegate);
-        }
+        return bindingFactory.delegateBinding(delegateDeclaration, explicitDelegate);
       }
 
       // TODO(dpb,ronshapiro): requestKey appears to be interchangeable with each binding's .key(),
diff --git a/java/dagger/internal/codegen/ContributionBinding.java b/java/dagger/internal/codegen/ContributionBinding.java
index e573c72ea..145ad64f5 100644
--- a/java/dagger/internal/codegen/ContributionBinding.java
+++ b/java/dagger/internal/codegen/ContributionBinding.java
@@ -21,6 +21,7 @@
 import static dagger.internal.codegen.ContributionBinding.FactoryCreationStrategy.SINGLETON_INSTANCE;
 import static dagger.internal.codegen.MapKeys.unwrapValue;
 import static dagger.internal.codegen.MoreAnnotationMirrors.unwrapOptionalEquivalence;
+import static java.util.Arrays.asList;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.element.Modifier.STATIC;
 
@@ -31,9 +32,11 @@
 import com.google.common.collect.ImmutableSetMultimap;
 import com.google.common.collect.Multimaps;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
+import com.google.errorprone.annotations.CheckReturnValue;
 import dagger.MapKey;
 import dagger.internal.codegen.ContributionType.HasContributionType;
 import dagger.model.BindingKind;
+import dagger.model.DependencyRequest;
 import dagger.model.Key;
 import java.util.Optional;
 import java.util.Set;
@@ -202,11 +205,19 @@ static BindingKind bindingKindForMultibindingKey(Key key) {
   }
 
   /**
-   * Base builder for {@link com.google.auto.value.AutoValue @AutoValue} subclasses of
-   * {@link ContributionBinding}.
+   * Base builder for {@link com.google.auto.value.AutoValue @AutoValue} subclasses of {@link
+   * ContributionBinding}.
    */
   @CanIgnoreReturnValue
-  abstract static class Builder<B extends Builder<B>> {
+  abstract static class Builder<C extends ContributionBinding, B extends Builder<C, B>> {
+    abstract B dependencies(Iterable<DependencyRequest> dependencies);
+
+    B dependencies(DependencyRequest... dependencies) {
+      return dependencies(asList(dependencies));
+    }
+
+    abstract B unresolved(C unresolved);
+
     abstract B contributionType(ContributionType contributionType);
 
     abstract B bindingElement(Element bindingElement);
@@ -220,5 +231,8 @@ static BindingKind bindingKindForMultibindingKey(Key key) {
     abstract B wrappedMapKey(Optional<Equivalence.Wrapper<AnnotationMirror>> wrappedMapKey);
 
     abstract B kind(BindingKind kind);
+
+    @CheckReturnValue
+    abstract C build();
   }
 }
diff --git a/java/dagger/internal/codegen/InjectBindingRegistryImpl.java b/java/dagger/internal/codegen/InjectBindingRegistryImpl.java
index c6940ca85..355d7503e 100644
--- a/java/dagger/internal/codegen/InjectBindingRegistryImpl.java
+++ b/java/dagger/internal/codegen/InjectBindingRegistryImpl.java
@@ -66,8 +66,7 @@
   private final InjectValidator injectValidator;
   private final InjectValidator injectValidatorWhenGeneratingCode;
   private final KeyFactory keyFactory;
-  private final ProvisionBinding.Factory provisionBindingFactory;
-  private final MembersInjectionBinding.Factory membersInjectionBindingFactory;
+  private final BindingFactory bindingFactory;
   private final CompilerOptions compilerOptions;
 
   final class BindingsCollection<B extends Binding> {
@@ -161,8 +160,7 @@ private void tryToCacheBinding(B binding) {
       Messager messager,
       InjectValidator injectValidator,
       KeyFactory keyFactory,
-      ProvisionBinding.Factory provisionBindingFactory,
-      MembersInjectionBinding.Factory membersInjectionBindingFactory,
+      BindingFactory bindingFactory,
       CompilerOptions compilerOptions) {
     this.elements = elements;
     this.types = types;
@@ -170,8 +168,7 @@ private void tryToCacheBinding(B binding) {
     this.injectValidator = injectValidator;
     this.injectValidatorWhenGeneratingCode = injectValidator.whenGeneratingCode();
     this.keyFactory = keyFactory;
-    this.provisionBindingFactory = provisionBindingFactory;
-    this.membersInjectionBindingFactory = membersInjectionBindingFactory;
+    this.bindingFactory = bindingFactory;
     this.compilerOptions = compilerOptions;
   }
 
@@ -243,10 +240,9 @@ private void registerBinding(MembersInjectionBinding binding, boolean warnIfNotA
     ValidationReport<TypeElement> report = injectValidator.validateConstructor(constructorElement);
     report.printMessagesTo(messager);
     if (report.isClean()) {
-      ProvisionBinding binding =
-          provisionBindingFactory.forInjectConstructor(constructorElement, resolvedType);
+      ProvisionBinding binding = bindingFactory.injectionBinding(constructorElement, resolvedType);
       registerBinding(binding, warnIfNotAlreadyGenerated);
-      if (membersInjectionBindingFactory.hasInjectedMembersIn(type)) {
+      if (!binding.injectionSites().isEmpty()) {
         tryRegisterMembersInjectedType(typeElement, resolvedType, warnIfNotAlreadyGenerated);
       }
       return Optional.of(binding);
@@ -275,8 +271,7 @@ private void registerBinding(MembersInjectionBinding binding, boolean warnIfNotA
         injectValidator.validateMembersInjectionType(typeElement);
     report.printMessagesTo(messager);
     if (report.isClean()) {
-      MembersInjectionBinding binding =
-          membersInjectionBindingFactory.forInjectedType(type, resolvedType);
+      MembersInjectionBinding binding = bindingFactory.membersInjectionBinding(type, resolvedType);
       registerBinding(binding, warnIfNotAlreadyGenerated);
       if (binding.parentKey().isPresent() && !binding.injectionSites().isEmpty()) {
         getOrFindMembersInjectionBinding(binding.parentKey().get());
@@ -337,6 +332,6 @@ private void registerBinding(MembersInjectionBinding binding, boolean warnIfNotA
     }
     Key membersInjectionKey = keyFactory.forMembersInjectedType(types.unwrapType(key.type()));
     return getOrFindMembersInjectionBinding(membersInjectionKey)
-        .map(binding -> provisionBindingFactory.forMembersInjector(key, binding));
+        .map(binding -> bindingFactory.membersInjectorBinding(key, binding));
   }
 }
diff --git a/java/dagger/internal/codegen/KytheBindingGraphFactory.java b/java/dagger/internal/codegen/KytheBindingGraphFactory.java
index 27bd22b7a..0c809f0fe 100644
--- a/java/dagger/internal/codegen/KytheBindingGraphFactory.java
+++ b/java/dagger/internal/codegen/KytheBindingGraphFactory.java
@@ -63,13 +63,8 @@
     KeyFactory keyFactory = new KeyFactory(types, elements);
     DependencyRequestFactory dependencyRequestFactory =
         new DependencyRequestFactory(keyFactory, types);
-    MembersInjectionBinding.Factory membersInjectionBindingFactory =
-        new MembersInjectionBinding.Factory(elements, types, keyFactory, dependencyRequestFactory);
-    ProvisionBinding.Factory provisionBindingFactory =
-        new ProvisionBinding.Factory(
-            types, keyFactory, dependencyRequestFactory, membersInjectionBindingFactory);
-    ProductionBinding.Factory productionBindingFactory =
-        new ProductionBinding.Factory(types, keyFactory, dependencyRequestFactory);
+    BindingFactory provisionBindingFactory =
+        new BindingFactory(types, elements, keyFactory, dependencyRequestFactory);
     MultibindingDeclaration.Factory multibindingDeclarationFactory =
         new MultibindingDeclaration.Factory(types, keyFactory);
     DelegateDeclaration.Factory bindingDelegateDeclarationFactory =
@@ -83,7 +78,6 @@
         new ModuleDescriptor.Factory(
             elements,
             provisionBindingFactory,
-            productionBindingFactory,
             multibindingDeclarationFactory,
             bindingDelegateDeclarationFactory,
             subcomponentDeclarationFactory,
@@ -111,13 +105,8 @@
             .experimentalAndroidMode(false)
             .build();
 
-    MembersInjectionBinding.Factory membersInjectionBindingFactory =
-        new MembersInjectionBinding.Factory(elements, types, keyFactory, dependencyRequestFactory);
-    ProvisionBinding.Factory provisionBindingFactory =
-        new ProvisionBinding.Factory(
-            types, keyFactory, dependencyRequestFactory, membersInjectionBindingFactory);
-    ProductionBinding.Factory productionBindingFactory =
-        new ProductionBinding.Factory(types, keyFactory, dependencyRequestFactory);
+    BindingFactory bindingFactory =
+        new BindingFactory(types, elements, keyFactory, dependencyRequestFactory);
 
     InjectValidator injectMethodValidator = new InjectValidator(types, elements, compilerOptions);
 
@@ -128,16 +117,10 @@
             messager,
             injectMethodValidator,
             keyFactory,
-            provisionBindingFactory,
-            membersInjectionBindingFactory,
+            bindingFactory,
             compilerOptions);
 
-    return new BindingGraph.Factory(
-        elements,
-        injectBindingRegistry,
-        keyFactory,
-        provisionBindingFactory,
-        productionBindingFactory);
+    return new BindingGraph.Factory(elements, injectBindingRegistry, keyFactory, bindingFactory);
   }
 
   private static class NullMessager implements Messager {
diff --git a/java/dagger/internal/codegen/MembersInjectionBinding.java b/java/dagger/internal/codegen/MembersInjectionBinding.java
index 01183c394..f92d2e2c4 100644
--- a/java/dagger/internal/codegen/MembersInjectionBinding.java
+++ b/java/dagger/internal/codegen/MembersInjectionBinding.java
@@ -17,45 +17,20 @@
 package dagger.internal.codegen;
 
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
-import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
-import static com.google.common.base.Preconditions.checkState;
 import static java.util.stream.Collectors.toList;
-import static javax.lang.model.element.Modifier.PRIVATE;
-import static javax.lang.model.element.Modifier.STATIC;
 
-import com.google.auto.common.MoreElements;
-import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
 import com.google.auto.value.extension.memoized.Memoized;
-import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ImmutableSortedSet;
-import com.google.common.collect.LinkedHashMultimap;
-import com.google.common.collect.SetMultimap;
 import dagger.model.BindingKind;
 import dagger.model.DependencyRequest;
 import dagger.model.Key;
-import java.util.ArrayList;
-import java.util.Comparator;
-import java.util.HashSet;
-import java.util.List;
 import java.util.Optional;
-import java.util.Set;
 import javax.inject.Inject;
 import javax.lang.model.element.Element;
-import javax.lang.model.element.ElementKind;
-import javax.lang.model.element.ElementVisitor;
-import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.TypeElement;
-import javax.lang.model.element.VariableElement;
-import javax.lang.model.type.DeclaredType;
-import javax.lang.model.type.ExecutableType;
-import javax.lang.model.type.TypeMirror;
-import javax.lang.model.util.ElementKindVisitor6;
-import javax.lang.model.util.Elements;
-import javax.lang.model.util.Types;
 
 /**
  * Represents the full members injection of a particular type.
@@ -155,183 +130,4 @@ int indexAmongAtInjectMembersWithSameSimpleName() {
           .indexOf(element());
     }
   }
-
-  /* TODO(dpb): Combine ProvisionBinding.Factory, ProductionBinding.Factory, and
-   * MembersInjectionBinding.Factory into one BindingFactory class.*/
-  static final class Factory {
-    private final Elements elements;
-    private final DaggerTypes types;
-    private final KeyFactory keyFactory;
-    private final DependencyRequestFactory dependencyRequestFactory;
-
-    @Inject
-    Factory(
-        Elements elements,
-        DaggerTypes types,
-        KeyFactory keyFactory,
-        DependencyRequestFactory dependencyRequestFactory) {
-      this.elements = checkNotNull(elements);
-      this.types = checkNotNull(types);
-      this.keyFactory = checkNotNull(keyFactory);
-      this.dependencyRequestFactory = checkNotNull(dependencyRequestFactory);
-    }
-
-    private InjectionSite injectionSiteForInjectMethod(
-        ExecutableElement methodElement, DeclaredType containingType) {
-      checkNotNull(methodElement);
-      checkArgument(methodElement.getKind().equals(ElementKind.METHOD));
-      ExecutableType resolved =
-          MoreTypes.asExecutable(types.asMemberOf(containingType, methodElement));
-      return new AutoValue_MembersInjectionBinding_InjectionSite(
-          InjectionSite.Kind.METHOD,
-          methodElement,
-          dependencyRequestFactory.forRequiredResolvedVariables(
-              methodElement.getParameters(), resolved.getParameterTypes()));
-    }
-
-    private InjectionSite injectionSiteForInjectField(
-        VariableElement fieldElement, DeclaredType containingType) {
-      checkNotNull(fieldElement);
-      checkArgument(fieldElement.getKind().equals(ElementKind.FIELD));
-      checkArgument(isAnnotationPresent(fieldElement, Inject.class));
-      TypeMirror resolved = types.asMemberOf(containingType, fieldElement);
-      return new AutoValue_MembersInjectionBinding_InjectionSite(
-          InjectionSite.Kind.FIELD,
-          fieldElement,
-          ImmutableSet.of(
-              dependencyRequestFactory.forRequiredResolvedVariable(fieldElement, resolved)));
-    }
-
-    /** Returns true if the type has some injected members in itself or any of its super classes. */
-    boolean hasInjectedMembersIn(DeclaredType declaredType) {
-      return !getInjectionSites(declaredType).isEmpty();
-    }
-
-    /**
-     * Returns a MembersInjectionBinding for the given type. If {@code resolvedType} is present,
-     * this will return a resolved binding, with the key and type resolved to the given type (using
-     * {@link Types#asMemberOf(DeclaredType, Element)}).
-     */
-    MembersInjectionBinding forInjectedType(
-        DeclaredType declaredType, Optional<TypeMirror> resolvedType) {
-      // If the class this is injecting has some type arguments, resolve everything.
-      if (!declaredType.getTypeArguments().isEmpty() && resolvedType.isPresent()) {
-        DeclaredType resolved = MoreTypes.asDeclared(resolvedType.get());
-        // Validate that we're resolving from the correct type.
-        checkState(
-            types.isSameType(types.erasure(resolved), types.erasure(declaredType)),
-            "erased expected type: %s, erased actual type: %s",
-            types.erasure(resolved),
-            types.erasure(declaredType));
-        declaredType = resolved;
-      }
-      ImmutableSortedSet<InjectionSite> injectionSites = getInjectionSites(declaredType);
-      ImmutableSet<DependencyRequest> dependencies =
-          FluentIterable.from(injectionSites)
-              .transformAndConcat(InjectionSite::dependencies)
-              .toSet();
-
-      Optional<Key> parentKey =
-          types.nonObjectSuperclass(declaredType).map(keyFactory::forMembersInjectedType);
-
-      Key key = keyFactory.forMembersInjectedType(declaredType);
-      TypeElement typeElement = MoreElements.asType(declaredType.asElement());
-      return new AutoValue_MembersInjectionBinding(
-          key,
-          dependencies,
-          typeElement,
-          hasNonDefaultTypeParameters(typeElement, key.type(), types)
-              ? Optional.of(
-                  forInjectedType(MoreTypes.asDeclared(typeElement.asType()), Optional.empty()))
-              : Optional.empty(),
-          injectionSites,
-          parentKey);
-    }
-
-    private ImmutableSortedSet<InjectionSite> getInjectionSites(DeclaredType declaredType) {
-      Set<InjectionSite> injectionSites = new HashSet<>();
-      final List<TypeElement> ancestors = new ArrayList<>();
-      SetMultimap<String, ExecutableElement> overriddenMethodMap = LinkedHashMultimap.create();
-      for (Optional<DeclaredType> currentType = Optional.of(declaredType);
-          currentType.isPresent();
-          currentType = types.nonObjectSuperclass(currentType.get())) {
-        final DeclaredType type = currentType.get();
-        ancestors.add(MoreElements.asType(type.asElement()));
-        for (Element enclosedElement : type.asElement().getEnclosedElements()) {
-          Optional<InjectionSite> maybeInjectionSite =
-              injectionSiteVisitor.visit(enclosedElement, type);
-          if (maybeInjectionSite.isPresent()) {
-            InjectionSite injectionSite = maybeInjectionSite.get();
-            if (shouldBeInjected(injectionSite.element(), overriddenMethodMap)) {
-              injectionSites.add(injectionSite);
-            }
-            if (injectionSite.kind().equals(InjectionSite.Kind.METHOD)) {
-              ExecutableElement injectionSiteMethod =
-                  MoreElements.asExecutable(injectionSite.element());
-              overriddenMethodMap.put(
-                  injectionSiteMethod.getSimpleName().toString(), injectionSiteMethod);
-            }
-          }
-        }
-      }
-      return ImmutableSortedSet.copyOf(
-          // supertypes before subtypes
-          Comparator.comparing(
-                  (InjectionSite injectionSite) ->
-                      ancestors.indexOf(injectionSite.element().getEnclosingElement()))
-              .reversed()
-              // fields before methods
-              .thenComparing(injectionSite -> injectionSite.element().getKind())
-              // then sort by whichever element comes first in the parent
-              // this isn't necessary, but makes the processor nice and predictable
-              .thenComparing(InjectionSite::indexAmongSiblingMembers),
-          injectionSites);
-    }
-
-    private boolean shouldBeInjected(
-        Element injectionSite, SetMultimap<String, ExecutableElement> overriddenMethodMap) {
-      if (!isAnnotationPresent(injectionSite, Inject.class)
-          || injectionSite.getModifiers().contains(PRIVATE)
-          || injectionSite.getModifiers().contains(STATIC)) {
-        return false;
-      }
-
-      if (injectionSite.getKind().isField()) { // Inject all fields (self and ancestors)
-        return true;
-      }
-
-      // For each method with the same name belonging to any descendant class, return false if any
-      // method has already overridden the injectionSite method. To decrease the number of methods
-      // that are checked, we store the already injected methods in a SetMultimap and only
-      // check the methods with the same name.
-      ExecutableElement injectionSiteMethod = MoreElements.asExecutable(injectionSite);
-      TypeElement injectionSiteType = MoreElements.asType(injectionSite.getEnclosingElement());
-      for (ExecutableElement method :
-          overriddenMethodMap.get(injectionSiteMethod.getSimpleName().toString())) {
-        if (elements.overrides(method, injectionSiteMethod, injectionSiteType)) {
-          return false;
-        }
-      }
-      return true;
-    }
-
-    private final ElementVisitor<Optional<InjectionSite>, DeclaredType> injectionSiteVisitor =
-        new ElementKindVisitor6<Optional<InjectionSite>, DeclaredType>(Optional.empty()) {
-          @Override
-          public Optional<InjectionSite> visitExecutableAsMethod(
-              ExecutableElement e, DeclaredType type) {
-            return Optional.of(injectionSiteForInjectMethod(e, type));
-          }
-
-          @Override
-          public Optional<InjectionSite> visitVariableAsField(
-              VariableElement e, DeclaredType type) {
-            return (isAnnotationPresent(e, Inject.class)
-                    && !e.getModifiers().contains(PRIVATE)
-                    && !e.getModifiers().contains(STATIC))
-                ? Optional.of(injectionSiteForInjectField(e, type))
-                : Optional.empty();
-          }
-        };
-  }
 }
diff --git a/java/dagger/internal/codegen/ModuleDescriptor.java b/java/dagger/internal/codegen/ModuleDescriptor.java
index a8082fefa..3735f8e5e 100644
--- a/java/dagger/internal/codegen/ModuleDescriptor.java
+++ b/java/dagger/internal/codegen/ModuleDescriptor.java
@@ -138,8 +138,7 @@
 
   static final class Factory {
     private final DaggerElements elements;
-    private final ProvisionBinding.Factory provisionBindingFactory;
-    private final ProductionBinding.Factory productionBindingFactory;
+    private final BindingFactory bindingFactory;
     private final MultibindingDeclaration.Factory multibindingDeclarationFactory;
     private final DelegateDeclaration.Factory bindingDelegateDeclarationFactory;
     private final SubcomponentDeclaration.Factory subcomponentDeclarationFactory;
@@ -148,15 +147,13 @@
     @Inject
     Factory(
         DaggerElements elements,
-        ProvisionBinding.Factory provisionBindingFactory,
-        ProductionBinding.Factory productionBindingFactory,
+        BindingFactory bindingFactory,
         MultibindingDeclaration.Factory multibindingDeclarationFactory,
         DelegateDeclaration.Factory bindingDelegateDeclarationFactory,
         SubcomponentDeclaration.Factory subcomponentDeclarationFactory,
         OptionalBindingDeclaration.Factory optionalBindingDeclarationFactory) {
       this.elements = elements;
-      this.provisionBindingFactory = provisionBindingFactory;
-      this.productionBindingFactory = productionBindingFactory;
+      this.bindingFactory = bindingFactory;
       this.multibindingDeclarationFactory = multibindingDeclarationFactory;
       this.bindingDelegateDeclarationFactory = bindingDelegateDeclarationFactory;
       this.subcomponentDeclarationFactory = subcomponentDeclarationFactory;
@@ -173,10 +170,10 @@ ModuleDescriptor create(TypeElement moduleElement) {
 
       for (ExecutableElement moduleMethod : methodsIn(elements.getAllMembers(moduleElement))) {
         if (isAnnotationPresent(moduleMethod, Provides.class)) {
-          bindings.add(provisionBindingFactory.forProvidesMethod(moduleMethod, moduleElement));
+          bindings.add(bindingFactory.providesMethodBinding(moduleMethod, moduleElement));
         }
         if (isAnnotationPresent(moduleMethod, Produces.class)) {
-          bindings.add(productionBindingFactory.forProducesMethod(moduleMethod, moduleElement));
+          bindings.add(bindingFactory.producesMethodBinding(moduleMethod, moduleElement));
         }
         if (isAnnotationPresent(moduleMethod, Binds.class)) {
           delegates.add(bindingDelegateDeclarationFactory.create(moduleMethod, moduleElement));
diff --git a/java/dagger/internal/codegen/ModuleProcessingStep.java b/java/dagger/internal/codegen/ModuleProcessingStep.java
index dfd313a62..b67a399b2 100644
--- a/java/dagger/internal/codegen/ModuleProcessingStep.java
+++ b/java/dagger/internal/codegen/ModuleProcessingStep.java
@@ -44,9 +44,8 @@
 final class ModuleProcessingStep implements ProcessingStep {
   private final Messager messager;
   private final ModuleValidator moduleValidator;
-  private final ProvisionBinding.Factory provisionBindingFactory;
+  private final BindingFactory bindingFactory;
   private final FactoryGenerator factoryGenerator;
-  private final ProductionBinding.Factory productionBindingFactory;
   private final ProducerFactoryGenerator producerFactoryGenerator;
   private final Set<TypeElement> processedModuleElements = Sets.newLinkedHashSet();
 
@@ -54,15 +53,13 @@
   ModuleProcessingStep(
       Messager messager,
       ModuleValidator moduleValidator,
-      ProvisionBinding.Factory provisionBindingFactory,
+      BindingFactory bindingFactory,
       FactoryGenerator factoryGenerator,
-      ProductionBinding.Factory productionBindingFactory,
       ProducerFactoryGenerator producerFactoryGenerator) {
     this.messager = messager;
     this.moduleValidator = moduleValidator;
-    this.provisionBindingFactory = provisionBindingFactory;
+    this.bindingFactory = bindingFactory;
     this.factoryGenerator = factoryGenerator;
-    this.productionBindingFactory = productionBindingFactory;
     this.producerFactoryGenerator = producerFactoryGenerator;
   }
 
@@ -90,11 +87,10 @@ private void processModule(TypeElement module) {
     if (report.isClean()) {
       for (ExecutableElement method : methodsIn(module.getEnclosedElements())) {
         if (isAnnotationPresent(method, Provides.class)) {
-          factoryGenerator.generate(
-              provisionBindingFactory.forProvidesMethod(method, module), messager);
+          factoryGenerator.generate(bindingFactory.providesMethodBinding(method, module), messager);
         } else if (isAnnotationPresent(method, Produces.class)) {
           producerFactoryGenerator.generate(
-              productionBindingFactory.forProducesMethod(method, module), messager);
+              bindingFactory.producesMethodBinding(method, module), messager);
         }
       }
     }
diff --git a/java/dagger/internal/codegen/ProductionBinding.java b/java/dagger/internal/codegen/ProductionBinding.java
index 3ee9667bc..fb6dbfabe 100644
--- a/java/dagger/internal/codegen/ProductionBinding.java
+++ b/java/dagger/internal/codegen/ProductionBinding.java
@@ -16,41 +16,22 @@
 
 package dagger.internal.codegen;
 
-import static com.google.auto.common.MoreElements.asType;
-import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
 import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
 import static dagger.internal.codegen.DaggerTypes.isFutureType;
-import static dagger.internal.codegen.MapKeys.getMapKey;
-import static dagger.internal.codegen.MoreAnnotationMirrors.wrapOptionalInEquivalence;
-import static dagger.model.BindingKind.COMPONENT_PRODUCTION;
-import static dagger.model.BindingKind.DELEGATE;
-import static dagger.model.BindingKind.OPTIONAL;
-import static dagger.model.BindingKind.PRODUCTION;
-import static javax.lang.model.element.ElementKind.METHOD;
 
-import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
-import com.google.errorprone.annotations.CheckReturnValue;
 import dagger.model.DependencyRequest;
 import dagger.model.Key;
-import dagger.model.RequestKind;
-import dagger.producers.Producer;
 import java.util.Optional;
 import java.util.stream.Stream;
-import javax.inject.Inject;
 import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.TypeElement;
-import javax.lang.model.type.ExecutableType;
 import javax.lang.model.type.TypeMirror;
-import javax.lang.model.util.Types;
 
 /**
- * A value object representing the mechanism by which a {@link Key} can be produced. New instances
- * should be created using an instance of the {@link Factory}.
+ * A value object representing the mechanism by which a {@link Key} can be produced.
  *
  * @author Jesse Beder
  * @since 2.0
@@ -74,7 +55,7 @@ public BindingType bindingType() {
         .collect(toImmutableSet());
   }
 
-  /** What kind of object this produces method returns. */
+  /** What kind of object a {@code @Produces}-annotated method returns. */
   enum ProductionKind {
     /** A value. */
     IMMEDIATE,
@@ -82,6 +63,19 @@ public BindingType bindingType() {
     FUTURE,
     /** A {@code Set<ListenableFuture<T>>}. */
     SET_OF_FUTURE;
+
+    /** Returns the kind of object a {@code @Produces}-annotated method returns. */
+    static ProductionKind fromProducesMethod(ExecutableElement producesMethod) {
+      if (isFutureType(producesMethod.getReturnType())) {
+        return FUTURE;
+      } else if (ContributionType.fromBindingMethod(producesMethod)
+              .equals(ContributionType.SET_VALUES)
+          && isFutureType(SetType.from(producesMethod.getReturnType()).elementType())) {
+        return SET_OF_FUTURE;
+      } else {
+        return IMMEDIATE;
+      }
+    }
   }
 
   /**
@@ -107,7 +101,7 @@ public BindingType bindingType() {
    */
   abstract Optional<DependencyRequest> monitorRequest();
 
-  private static Builder builder() {
+  static Builder builder() {
     return new AutoValue_ProductionBinding.Builder()
         .explicitDependencies(ImmutableList.<DependencyRequest>of())
         .thrownTypes(ImmutableList.<TypeMirror>of());
@@ -120,13 +114,18 @@ public final boolean isProduction() {
 
   @AutoValue.Builder
   @CanIgnoreReturnValue
-  abstract static class Builder extends ContributionBinding.Builder<Builder> {
-    abstract Builder explicitDependencies(Iterable<DependencyRequest> dependencies);
+  abstract static class Builder extends ContributionBinding.Builder<ProductionBinding, Builder> {
 
-    abstract Builder explicitDependencies(DependencyRequest... dependencies);
+    @Override
+    Builder dependencies(Iterable<DependencyRequest> dependencies) {
+      return explicitDependencies(dependencies);
+    }
+
+    abstract Builder explicitDependencies(Iterable<DependencyRequest> dependencies);
 
     abstract Builder productionKind(ProductionKind productionKind);
 
+    @Override
     abstract Builder unresolved(ProductionBinding unresolved);
 
     abstract Builder thrownTypes(Iterable<? extends TypeMirror> thrownTypes);
@@ -134,126 +133,5 @@ public final boolean isProduction() {
     abstract Builder executorRequest(DependencyRequest executorRequest);
 
     abstract Builder monitorRequest(DependencyRequest monitorRequest);
-
-    @CheckReturnValue
-    abstract ProductionBinding build();
-  }
-
-  /* TODO(dpb): Combine ProvisionBinding.Factory, ProductionBinding.Factory, and
-   * MembersInjectionBinding.Factory into one BindingFactory class.*/
-  static final class Factory {
-    private final Types types;
-    private final KeyFactory keyFactory;
-    private final DependencyRequestFactory dependencyRequestFactory;
-
-    @Inject
-    Factory(Types types, KeyFactory keyFactory, DependencyRequestFactory dependencyRequestFactory) {
-      this.types = types;
-      this.keyFactory = keyFactory;
-      this.dependencyRequestFactory = dependencyRequestFactory;
-    }
-
-    ProductionBinding forProducesMethod(
-        ExecutableElement producesMethod, TypeElement contributedBy) {
-      checkArgument(producesMethod.getKind().equals(METHOD));
-      ContributionType contributionType = ContributionType.fromBindingMethod(producesMethod);
-      Key key = keyFactory.forProducesMethod(producesMethod, contributedBy);
-      ExecutableType methodType =
-          MoreTypes.asExecutable(
-              types.asMemberOf(MoreTypes.asDeclared(contributedBy.asType()), producesMethod));
-      ImmutableSet<DependencyRequest> dependencies =
-          dependencyRequestFactory.forRequiredResolvedVariables(
-              producesMethod.getParameters(), methodType.getParameterTypes());
-      DependencyRequest executorRequest =
-          dependencyRequestFactory.forProductionImplementationExecutor();
-      DependencyRequest monitorRequest = dependencyRequestFactory.forProductionComponentMonitor();
-      final ProductionKind productionKind;
-      if (isFutureType(producesMethod.getReturnType())) {
-        productionKind = ProductionKind.FUTURE;
-      } else if (contributionType.equals(ContributionType.SET_VALUES)
-          && isFutureType(SetType.from(producesMethod.getReturnType()).elementType())) {
-        productionKind = ProductionKind.SET_OF_FUTURE;
-      } else {
-        productionKind = ProductionKind.IMMEDIATE;
-      }
-      // TODO(beder): Add nullability checking with Java 8.
-      ProductionBinding.Builder builder =
-          ProductionBinding.builder()
-              .contributionType(contributionType)
-              .bindingElement(producesMethod)
-              .contributingModule(contributedBy)
-              .key(key)
-              .explicitDependencies(dependencies)
-              .wrappedMapKey(wrapOptionalInEquivalence(getMapKey(producesMethod)))
-              .kind(PRODUCTION)
-              .productionKind(productionKind)
-              .thrownTypes(producesMethod.getThrownTypes())
-              .executorRequest(executorRequest)
-              .monitorRequest(monitorRequest);
-      if (!types.isSameType(methodType, producesMethod.asType())) {
-        builder.unresolved(
-            forProducesMethod(producesMethod, asType(producesMethod.getEnclosingElement())));
-      }
-      return builder.build();
-    }
-
-    /**
-     * A synthetic binding that depends explicitly on a set of individual provision or production
-     * multibinding contribution methods.
-     *
-     * <p>Note that these could be set multibindings or map multibindings.
-     */
-    ProductionBinding syntheticMultibinding(
-        Key key, Iterable<ContributionBinding> multibindingContributions) {
-      return ProductionBinding.builder()
-          .contributionType(ContributionType.UNIQUE)
-          .key(key)
-          .explicitDependencies(
-              dependencyRequestFactory.forMultibindingContributions(key, multibindingContributions))
-          .kind(bindingKindForMultibindingKey(key))
-          .build();
-    }
-
-    ProductionBinding forComponentMethod(ExecutableElement componentMethod) {
-      checkNotNull(componentMethod);
-      checkArgument(componentMethod.getKind().equals(METHOD));
-      checkArgument(componentMethod.getParameters().isEmpty());
-      checkArgument(isFutureType(componentMethod.getReturnType()));
-      return ProductionBinding.builder()
-          .contributionType(ContributionType.UNIQUE)
-          .bindingElement(componentMethod)
-          .key(keyFactory.forProductionComponentMethod(componentMethod))
-          .kind(COMPONENT_PRODUCTION)
-          .thrownTypes(componentMethod.getThrownTypes())
-          .build();
-    }
-
-    ProductionBinding delegate(
-        DelegateDeclaration delegateDeclaration, ProductionBinding delegateBinding) {
-      return ProductionBinding.builder()
-          .contributionType(delegateDeclaration.contributionType())
-          .bindingElement(delegateDeclaration.bindingElement().get())
-          .contributingModule(delegateDeclaration.contributingModule().get())
-          .key(keyFactory.forDelegateBinding(delegateDeclaration, Producer.class))
-          .explicitDependencies(delegateDeclaration.delegateRequest())
-          .nullableType(delegateBinding.nullableType())
-          .wrappedMapKey(delegateDeclaration.wrappedMapKey())
-          .kind(DELEGATE)
-          .build();
-    }
-
-    /**
-     * Returns a synthetic binding for an {@linkplain dagger.BindsOptionalOf optional binding} in a
-     * component with a binding for the underlying key.
-     */
-    ProductionBinding syntheticPresentBinding(Key key, RequestKind kind) {
-      return ProductionBinding.builder()
-          .contributionType(ContributionType.UNIQUE)
-          .key(key)
-          .kind(OPTIONAL)
-          .explicitDependencies(
-              dependencyRequestFactory.forSyntheticPresentOptionalBinding(key, kind))
-          .build();
-    }
   }
 }
diff --git a/java/dagger/internal/codegen/ProvisionBinding.java b/java/dagger/internal/codegen/ProvisionBinding.java
index a00069f19..33e10384d 100644
--- a/java/dagger/internal/codegen/ProvisionBinding.java
+++ b/java/dagger/internal/codegen/ProvisionBinding.java
@@ -16,62 +16,24 @@
 
 package dagger.internal.codegen;
 
-import static com.google.auto.common.MoreElements.isAnnotationPresent;
-import static com.google.auto.common.MoreTypes.asDeclared;
-import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
-import static com.google.common.base.Preconditions.checkState;
 import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
-import static dagger.internal.codegen.InjectionAnnotations.getQualifier;
-import static dagger.internal.codegen.MapKeys.getMapKey;
-import static dagger.internal.codegen.MoreAnnotationMirrors.wrapOptionalInEquivalence;
-import static dagger.internal.codegen.Scopes.uniqueScopeOf;
-import static dagger.model.BindingKind.BOUND_INSTANCE;
-import static dagger.model.BindingKind.COMPONENT;
-import static dagger.model.BindingKind.COMPONENT_DEPENDENCY;
 import static dagger.model.BindingKind.COMPONENT_PROVISION;
-import static dagger.model.BindingKind.DELEGATE;
-import static dagger.model.BindingKind.INJECTION;
-import static dagger.model.BindingKind.MEMBERS_INJECTOR;
-import static dagger.model.BindingKind.OPTIONAL;
 import static dagger.model.BindingKind.PROVISION;
-import static dagger.model.BindingKind.RELEASABLE_REFERENCE_MANAGER;
-import static dagger.model.BindingKind.RELEASABLE_REFERENCE_MANAGERS;
-import static dagger.model.BindingKind.SUBCOMPONENT_BUILDER;
-import static javax.lang.model.element.ElementKind.CONSTRUCTOR;
-import static javax.lang.model.element.ElementKind.METHOD;
 
-import com.google.auto.common.MoreElements;
-import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
 import com.google.auto.value.extension.memoized.Memoized;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ImmutableSortedSet;
-import com.google.common.collect.Iterables;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
-import com.google.errorprone.annotations.CheckReturnValue;
-import dagger.internal.codegen.ComponentDescriptor.BuilderRequirementMethod;
 import dagger.internal.codegen.MembersInjectionBinding.InjectionSite;
 import dagger.model.BindingKind;
 import dagger.model.DependencyRequest;
 import dagger.model.Key;
-import dagger.model.RequestKind;
 import dagger.model.Scope;
 import java.util.Optional;
-import javax.inject.Inject;
-import javax.inject.Provider;
-import javax.lang.model.element.Element;
-import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.TypeElement;
-import javax.lang.model.element.VariableElement;
-import javax.lang.model.type.DeclaredType;
-import javax.lang.model.type.ExecutableType;
-import javax.lang.model.type.TypeMirror;
-import javax.lang.model.util.Types;
 
 /**
- * A value object representing the mechanism by which a {@link Key} can be provided. New instances
- * should be created using an instance of the {@link Factory}.
+ * A value object representing the mechanism by which a {@link Key} can be provided.
  *
  * @author Gregory Kick
  * @since 2.0
@@ -120,7 +82,7 @@ public BindingType bindingType() {
   @Override
   public abstract Optional<Scope> scope();
 
-  private static Builder builder() {
+  static Builder builder() {
     return new AutoValue_ProvisionBinding.Builder()
         .provisionDependencies(ImmutableSet.of())
         .injectionSites(ImmutableSortedSet.of());
@@ -145,320 +107,21 @@ public final boolean isProduction() {
 
   @AutoValue.Builder
   @CanIgnoreReturnValue
-  abstract static class Builder extends ContributionBinding.Builder<Builder> {
-    abstract Builder provisionDependencies(DependencyRequest... provisionDependencies);
-    abstract Builder provisionDependencies(ImmutableSet<DependencyRequest> provisionDependencies);
+  abstract static class Builder extends ContributionBinding.Builder<ProvisionBinding, Builder> {
+
+    @Override
+    Builder dependencies(Iterable<DependencyRequest> dependencies) {
+      return provisionDependencies(dependencies);
+    }
+
+    abstract Builder provisionDependencies(Iterable<DependencyRequest> provisionDependencies);
 
     abstract Builder injectionSites(ImmutableSortedSet<InjectionSite> injectionSites);
 
+    @Override
     abstract Builder unresolved(ProvisionBinding unresolved);
 
     abstract Builder scope(Optional<Scope> scope);
-
-    @CheckReturnValue
-    abstract ProvisionBinding build();
   }
 
-  /* TODO(dpb): Combine ProvisionBinding.Factory, ProductionBinding.Factory, and
-   * MembersInjectionBinding.Factory into one BindingFactory class.*/
-  static final class Factory {
-    private final DaggerTypes types;
-    private final KeyFactory keyFactory;
-    private final DependencyRequestFactory dependencyRequestFactory;
-    private final MembersInjectionBinding.Factory membersInjectionBindingFactory;
-
-    @Inject
-    Factory(
-        DaggerTypes types,
-        KeyFactory keyFactory,
-        DependencyRequestFactory dependencyRequestFactory,
-        MembersInjectionBinding.Factory membersInjectionBindingFactory) {
-      this.types = types;
-      this.keyFactory = keyFactory;
-      this.dependencyRequestFactory = dependencyRequestFactory;
-      this.membersInjectionBindingFactory = membersInjectionBindingFactory;
-    }
-
-    /**
-     * Returns a ProvisionBinding for the given element. If {@code resolvedType} is present, this
-     * will return a resolved binding, with the key and type resolved to the given type (using
-     * {@link Types#asMemberOf(DeclaredType, Element)}).
-     */
-    ProvisionBinding forInjectConstructor(
-        ExecutableElement constructorElement, Optional<TypeMirror> resolvedType) {
-      checkNotNull(constructorElement);
-      checkArgument(constructorElement.getKind().equals(CONSTRUCTOR));
-      checkArgument(isAnnotationPresent(constructorElement, Inject.class));
-      checkArgument(!getQualifier(constructorElement).isPresent());
-
-      ExecutableType cxtorType = MoreTypes.asExecutable(constructorElement.asType());
-      DeclaredType enclosingCxtorType =
-          MoreTypes.asDeclared(constructorElement.getEnclosingElement().asType());
-      // If the class this is constructing has some type arguments, resolve everything.
-      if (!enclosingCxtorType.getTypeArguments().isEmpty() && resolvedType.isPresent()) {
-        DeclaredType resolved = MoreTypes.asDeclared(resolvedType.get());
-        // Validate that we're resolving from the correct type.
-        checkState(types.isSameType(types.erasure(resolved), types.erasure(enclosingCxtorType)),
-            "erased expected type: %s, erased actual type: %s",
-            types.erasure(resolved), types.erasure(enclosingCxtorType));
-        cxtorType = MoreTypes.asExecutable(types.asMemberOf(resolved, constructorElement));
-        enclosingCxtorType = resolved;
-      }
-
-      Key key = keyFactory.forInjectConstructorWithResolvedType(enclosingCxtorType);
-      checkArgument(!key.qualifier().isPresent());
-      ImmutableSet<DependencyRequest> provisionDependencies =
-          dependencyRequestFactory.forRequiredResolvedVariables(
-              constructorElement.getParameters(), cxtorType.getParameterTypes());
-      // TODO(ronshapiro): instead of creating a MembersInjectionBinding just to retrieve the
-      // injection sites, create an InjectionSite.Factory and pass that in here.
-      ImmutableSortedSet<InjectionSite> injectionSites =
-          membersInjectionBindingFactory
-              .forInjectedType(enclosingCxtorType, Optional.empty())
-              .injectionSites();
-
-      ProvisionBinding.Builder builder =
-          ProvisionBinding.builder()
-              .contributionType(ContributionType.UNIQUE)
-              .bindingElement(constructorElement)
-              .key(key)
-              .provisionDependencies(provisionDependencies)
-              .injectionSites(injectionSites)
-              .kind(INJECTION)
-              .scope(uniqueScopeOf(constructorElement.getEnclosingElement()));
-
-      TypeElement bindingTypeElement =
-          MoreElements.asType(constructorElement.getEnclosingElement());
-      if (hasNonDefaultTypeParameters(bindingTypeElement, key.type(), types)) {
-        builder.unresolved(forInjectConstructor(constructorElement, Optional.empty()));
-      }
-      return builder.build();
-    }
-
-    ProvisionBinding forProvidesMethod(
-        ExecutableElement providesMethod, TypeElement contributedBy) {
-      checkArgument(providesMethod.getKind().equals(METHOD));
-      ExecutableType methodType =
-          MoreTypes.asExecutable(
-              types.asMemberOf(MoreTypes.asDeclared(contributedBy.asType()), providesMethod));
-      Key key = keyFactory.forProvidesMethod(providesMethod, contributedBy);
-      ImmutableSet<DependencyRequest> dependencies =
-          dependencyRequestFactory.forRequiredResolvedVariables(
-              providesMethod.getParameters(), methodType.getParameterTypes());
-      ProvisionBinding.Builder builder =
-          ProvisionBinding.builder()
-              .contributionType(ContributionType.fromBindingMethod(providesMethod))
-              .bindingElement(providesMethod)
-              .contributingModule(contributedBy)
-              .key(key)
-              .provisionDependencies(dependencies)
-              .nullableType(ConfigurationAnnotations.getNullableType(providesMethod))
-              .wrappedMapKey(wrapOptionalInEquivalence(getMapKey(providesMethod)))
-              .kind(PROVISION)
-              .scope(uniqueScopeOf(providesMethod));
-      if (!types.isSameType(methodType, providesMethod.asType())) {
-        builder.unresolved(
-            forProvidesMethod(
-                providesMethod, MoreElements.asType(providesMethod.getEnclosingElement())));
-      }
-      return builder.build();
-    }
-
-    /**
-     * A synthetic binding that depends explicitly on a set of individual provision multibinding
-     * contribution methods.
-     *
-     * <p>Note that these could be set multibindings or map multibindings.
-     */
-    ProvisionBinding syntheticMultibinding(
-        Key key, Iterable<ContributionBinding> multibindingContributions) {
-      return ProvisionBinding.builder()
-          .contributionType(ContributionType.UNIQUE)
-          .key(key)
-          .provisionDependencies(
-              dependencyRequestFactory.forMultibindingContributions(key, multibindingContributions))
-          .kind(bindingKindForMultibindingKey(key))
-          .build();
-    }
-
-    ProvisionBinding forComponent(TypeElement componentDefinitionType) {
-      checkNotNull(componentDefinitionType);
-      return ProvisionBinding.builder()
-          .contributionType(ContributionType.UNIQUE)
-          .bindingElement(componentDefinitionType)
-          .key(keyFactory.forType(componentDefinitionType.asType()))
-          .kind(COMPONENT)
-          .build();
-    }
-
-    ProvisionBinding forComponentDependency(ComponentRequirement dependency) {
-      checkNotNull(dependency);
-      return ProvisionBinding.builder()
-          .contributionType(ContributionType.UNIQUE)
-          .bindingElement(dependency.typeElement())
-          .key(keyFactory.forType(dependency.type()))
-          .kind(COMPONENT_DEPENDENCY)
-          .build();
-    }
-
-    ProvisionBinding forComponentMethod(ExecutableElement componentMethod) {
-      checkNotNull(componentMethod);
-      checkArgument(componentMethod.getKind().equals(METHOD));
-      checkArgument(componentMethod.getParameters().isEmpty());
-      return ProvisionBinding.builder()
-          .contributionType(ContributionType.UNIQUE)
-          .bindingElement(componentMethod)
-          .key(keyFactory.forComponentMethod(componentMethod))
-          .nullableType(ConfigurationAnnotations.getNullableType(componentMethod))
-          .kind(COMPONENT_PROVISION)
-          .scope(uniqueScopeOf(componentMethod))
-          .build();
-    }
-
-    ProvisionBinding forBuilderBinding(BuilderRequirementMethod method) {
-      ExecutableElement builderMethod = method.method();
-
-      checkNotNull(builderMethod);
-      checkArgument(builderMethod.getKind().equals(METHOD));
-      checkArgument(builderMethod.getParameters().size() == 1);
-      VariableElement parameterElement = Iterables.getOnlyElement(builderMethod.getParameters());
-      return ProvisionBinding.builder()
-          .contributionType(ContributionType.UNIQUE)
-          .bindingElement(builderMethod)
-          .key(method.requirement().key().get())
-          .nullableType(ConfigurationAnnotations.getNullableType(parameterElement))
-          .kind(BOUND_INSTANCE)
-          .build();
-    }
-
-    ProvisionBinding forSubcomponentBuilderMethod(
-        ExecutableElement subcomponentBuilderMethod, TypeElement contributedBy) {
-      checkNotNull(subcomponentBuilderMethod);
-      checkArgument(subcomponentBuilderMethod.getKind().equals(METHOD));
-      checkArgument(subcomponentBuilderMethod.getParameters().isEmpty());
-      DeclaredType declaredContainer = asDeclared(contributedBy.asType());
-      return ProvisionBinding.builder()
-          .contributionType(ContributionType.UNIQUE)
-          .bindingElement(subcomponentBuilderMethod)
-          .key(
-              keyFactory.forSubcomponentBuilderMethod(subcomponentBuilderMethod, declaredContainer))
-          .kind(SUBCOMPONENT_BUILDER)
-          .build();
-    }
-
-    ProvisionBinding syntheticSubcomponentBuilder(
-        ImmutableSet<SubcomponentDeclaration> subcomponentDeclarations) {
-      SubcomponentDeclaration subcomponentDeclaration = subcomponentDeclarations.iterator().next();
-      return ProvisionBinding.builder()
-          .contributionType(ContributionType.UNIQUE)
-          .key(subcomponentDeclaration.key())
-          .kind(SUBCOMPONENT_BUILDER)
-          .build();
-    }
-
-    ProvisionBinding delegate(
-        DelegateDeclaration delegateDeclaration, ProvisionBinding delegate) {
-      return delegateBuilder(delegateDeclaration).nullableType(delegate.nullableType()).build();
-    }
-
-    /**
-     * A form of {@link #delegate(DelegateDeclaration, ProvisionBinding)} when the right-hand-side
-     * of a {@link dagger.Binds} method cannot be resolved.
-     */
-    ProvisionBinding missingDelegate(DelegateDeclaration delegateDeclaration) {
-      return delegateBuilder(delegateDeclaration).build();
-    }
-
-    private ProvisionBinding.Builder delegateBuilder(DelegateDeclaration delegateDeclaration) {
-      return ProvisionBinding.builder()
-          .contributionType(delegateDeclaration.contributionType())
-          .bindingElement(delegateDeclaration.bindingElement().get())
-          .contributingModule(delegateDeclaration.contributingModule().get())
-          .key(keyFactory.forDelegateBinding(delegateDeclaration, Provider.class))
-          .provisionDependencies(delegateDeclaration.delegateRequest())
-          .wrappedMapKey(delegateDeclaration.wrappedMapKey())
-          .kind(DELEGATE)
-          .scope(uniqueScopeOf(delegateDeclaration.bindingElement().get()));
-    }
-
-    /**
-     * Returns a synthetic binding for a {@code @ForReleasableReferences(scope)
-     * ReleasableReferenceManager} that provides the component-instantiated object.
-     */
-    ProvisionBinding provideReleasableReferenceManager(Scope scope) {
-      return ProvisionBinding.builder()
-          .contributionType(ContributionType.UNIQUE)
-          .key(keyFactory.forReleasableReferenceManager(scope))
-          .kind(RELEASABLE_REFERENCE_MANAGER)
-          .build();
-    }
-
-    /**
-     * Returns a synthetic binding for a {@code @ForReleasableReferences(scope)
-     * TypedReleasableReferenceManager<metadataType>} that provides the component-instantiated
-     * object.
-     */
-    ProvisionBinding provideTypedReleasableReferenceManager(
-        Scope scope, DeclaredType metadataType) {
-      return provideReleasableReferenceManager(scope)
-          .toBuilder()
-          .key(keyFactory.forTypedReleasableReferenceManager(scope, metadataType))
-          .build();
-    }
-
-    /** Returns a synthetic binding for {@code Set<ReleasableReferenceManager>}. */
-    ProvisionBinding provideSetOfReleasableReferenceManagers() {
-      return ProvisionBinding.builder()
-          .contributionType(ContributionType.UNIQUE)
-          .key(keyFactory.forSetOfReleasableReferenceManagers())
-          .kind(RELEASABLE_REFERENCE_MANAGERS)
-          .build();
-    }
-
-    /**
-     * Returns a synthetic binding for {@code Set<TypedReleasableReferenceManager<metadataType>}.
-     */
-    ProvisionBinding provideSetOfTypedReleasableReferenceManagers(DeclaredType metadataType) {
-      return provideSetOfReleasableReferenceManagers()
-          .toBuilder()
-          .key(keyFactory.forSetOfTypedReleasableReferenceManagers(metadataType))
-          .build();
-    }
-
-    /**
-     * Returns a synthetic binding for an {@linkplain dagger.BindsOptionalOf optional binding} in a
-     * component with no binding for the underlying key.
-     */
-    ProvisionBinding syntheticAbsentBinding(Key key) {
-      return ProvisionBinding.builder()
-          .contributionType(ContributionType.UNIQUE)
-          .key(key)
-          .kind(OPTIONAL)
-          .build();
-    }
-
-    /**
-     * Returns a synthetic binding for an {@linkplain dagger.BindsOptionalOf optional binding} in a
-     * component with a binding for the underlying key.
-     */
-    ProvisionBinding syntheticPresentBinding(Key key, RequestKind kind) {
-      return syntheticAbsentBinding(key)
-          .toBuilder()
-          .provisionDependencies(
-              dependencyRequestFactory.forSyntheticPresentOptionalBinding(key, kind))
-          .build();
-    }
-
-    /** Returns a binding for a {@link dagger.MembersInjector} wrapper type. */
-    ProvisionBinding forMembersInjector(Key key, MembersInjectionBinding membersInjectionBinding) {
-      return ProvisionBinding.builder()
-          .key(key)
-          .contributionType(ContributionType.UNIQUE)
-          .kind(MEMBERS_INJECTOR)
-          .bindingElement(MoreTypes.asTypeElement(membersInjectionBinding.key().type()))
-          .provisionDependencies(membersInjectionBinding.dependencies())
-          .injectionSites(membersInjectionBinding.injectionSites())
-          .build();
-    }
-  }
 }
