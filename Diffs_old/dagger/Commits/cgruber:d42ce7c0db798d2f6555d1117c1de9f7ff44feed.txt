diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
index 1c0030a35..667a1d0b1 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -1180,7 +1180,7 @@ private CodeBlock initializeFactoryForMapMultibinding(ContributionBinding bindin
       codeBlocks.add(
           CodeBlock.of(
               ".put($L, $L)",
-              getMapKeyExpression(contributionBinding.bindingElement()),
+              getMapKeyExpression(contributionBinding.mapKey().get()),
               potentiallyCast(
                   useRawTypes,
                   frameworkDependency.frameworkClass(),
diff --git a/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
index bd3d859c9..27b6c7442 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
@@ -41,8 +41,8 @@
 
 import static com.google.common.collect.Sets.immutableEnumSet;
 import static dagger.internal.codegen.ContributionBinding.Kind.IS_SYNTHETIC_KIND;
-import static dagger.internal.codegen.MapKeys.getMapKey;
 import static dagger.internal.codegen.MapKeys.unwrapValue;
+import static dagger.internal.codegen.MoreAnnotationMirrors.unwrapOptionalEquivalence;
 import static javax.lang.model.element.Modifier.STATIC;
 
 /**
@@ -90,6 +90,12 @@ public Kind apply(ContributionBinding binding) {
   /** If this provision requires members injection, this will be the corresponding request. */
   abstract Optional<DependencyRequest> membersInjectionRequest();
 
+  abstract Optional<Equivalence.Wrapper<AnnotationMirror>> wrappedMapKey();
+
+  final Optional<AnnotationMirror> mapKey() {
+    return unwrapOptionalEquivalence(wrappedMapKey());
+  }
+
   /**
    * The kind of contribution this binding represents. Defines which elements can specify this kind
    * of contribution.
@@ -262,7 +268,7 @@ final TypeMirror factoryType() {
             new Function<ContributionBinding, Object>() {
               @Override
               public Object apply(ContributionBinding mapBinding) {
-                AnnotationMirror mapKey = getMapKey(mapBinding.bindingElement()).get();
+                AnnotationMirror mapKey = mapBinding.mapKey().get();
                 Optional<? extends AnnotationValue> unwrappedValue = unwrapValue(mapKey);
                 return unwrappedValue.isPresent() ? unwrappedValue.get().getValue() : mapKey;
               }
@@ -281,7 +287,7 @@ public Object apply(ContributionBinding mapBinding) {
               @Override
               public Equivalence.Wrapper<DeclaredType> apply(ContributionBinding mapBinding) {
                 return MoreTypes.equivalence()
-                    .wrap(getMapKey(mapBinding.bindingElement()).get().getAnnotationType());
+                    .wrap(mapBinding.mapKey().get().getAnnotationType());
               }
             }));
   }
diff --git a/compiler/src/main/java/dagger/internal/codegen/Key.java b/compiler/src/main/java/dagger/internal/codegen/Key.java
index f955b31ea..339453553 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Key.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Key.java
@@ -60,6 +60,8 @@
 import static dagger.internal.codegen.InjectionAnnotations.getQualifier;
 import static dagger.internal.codegen.MapKeys.getMapKey;
 import static dagger.internal.codegen.MapKeys.getUnwrappedMapKeyType;
+import static dagger.internal.codegen.MoreAnnotationMirrors.unwrapOptionalEquivalence;
+import static dagger.internal.codegen.MoreAnnotationMirrors.wrapOptionalInEquivalence;
 import static javax.lang.model.element.ElementKind.METHOD;
 
 /**
@@ -242,27 +244,6 @@ public Key apply(HasKey hasKey) {
             }));
   }
 
-  /**
-   * Wraps an {@link Optional} of a type in an {@code Optional} of a {@link Wrapper} for that type.
-   */
-  private static <T> Optional<Equivalence.Wrapper<T>> wrapOptionalInEquivalence(
-      Equivalence<T> equivalence, Optional<T> optional) {
-    return optional.isPresent()
-        ? Optional.of(equivalence.wrap(optional.get()))
-        : Optional.<Equivalence.Wrapper<T>>absent();
-  }
-
-  /**
-   * Unwraps an {@link Optional} of a {@link Wrapper} into an {@code Optional} of the underlying
-   * type.
-   */
-  private static <T> Optional<T> unwrapOptionalEquivalence(
-      Optional<Equivalence.Wrapper<T>> wrappedOptional) {
-    return wrappedOptional.isPresent()
-        ? Optional.of(wrappedOptional.get().get())
-        : Optional.<T>absent();
-  }
-
   static final class Factory {
     private final Types types;
     private final Elements elements;
@@ -416,7 +397,7 @@ private TypeMirror mapKeyType(ExecutableElement method) {
 
     private Key forMethod(ExecutableElement method, TypeMirror keyType) {
       return new AutoValue_Key(
-          wrapOptionalInEquivalence(AnnotationMirrors.equivalence(), getQualifier(method)),
+          wrapOptionalInEquivalence(getQualifier(method)),
           MoreTypes.equivalence().wrap(keyType),
           Optional.<BindingMethodIdentifier>absent());
     }
@@ -444,7 +425,7 @@ Key forMembersInjectedType(TypeMirror type) {
 
     Key forQualifiedType(Optional<AnnotationMirror> qualifier, TypeMirror type) {
       return new AutoValue_Key(
-          wrapOptionalInEquivalence(AnnotationMirrors.equivalence(), qualifier),
+          wrapOptionalInEquivalence(qualifier),
           MoreTypes.equivalence().wrap(normalize(types, type)),
           Optional.<BindingMethodIdentifier>absent());
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/MapKeys.java b/compiler/src/main/java/dagger/internal/codegen/MapKeys.java
index 099397369..b0cb00db0 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MapKeys.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MapKeys.java
@@ -62,7 +62,7 @@
    * @throws IllegalArgumentException if the element is annotated with more than one {@code MapKey}
    *     annotation
    */
-  static Optional<? extends AnnotationMirror> getMapKey(Element bindingElement) {
+  static Optional<AnnotationMirror> getMapKey(Element bindingElement) {
     ImmutableSet<? extends AnnotationMirror> mapKeys = getMapKeys(bindingElement);
     return mapKeys.isEmpty()
         ? Optional.<AnnotationMirror>absent()
@@ -150,8 +150,7 @@ public static ClassName getMapKeyCreatorClassName(TypeElement mapKeyType) {
    * @throws IllegalStateException if {@code bindingElement} is not annotated with a {@code MapKey}
    *     annotation
    */
-  static CodeBlock getMapKeyExpression(Element bindingElement) {
-    AnnotationMirror mapKey = getMapKey(bindingElement).get();
+  static CodeBlock getMapKeyExpression(AnnotationMirror mapKey) {
     ClassName mapKeyCreator =
         getMapKeyCreatorClassName(MoreTypes.asTypeElement(mapKey.getAnnotationType()));
     Optional<? extends AnnotationValue> unwrappedValue = unwrapValue(mapKey);
diff --git a/compiler/src/main/java/dagger/internal/codegen/MoreAnnotationMirrors.java b/compiler/src/main/java/dagger/internal/codegen/MoreAnnotationMirrors.java
new file mode 100644
index 000000000..e81076af4
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/MoreAnnotationMirrors.java
@@ -0,0 +1,52 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.common.AnnotationMirrors;
+import com.google.common.base.Equivalence;
+import com.google.common.base.Optional;
+import javax.lang.model.element.AnnotationMirror;
+
+/**
+ * A utility class for working with {@link AnnotationMirror} instances, similar to {@link
+ * AnnotationMirrors}.
+ */
+final class MoreAnnotationMirrors {
+
+  private MoreAnnotationMirrors() {}
+
+  /**
+   * Wraps an {@link Optional} of a type in an {@code Optional} of a {@link Equivalence.Wrapper} for
+   * that type.
+   */
+  static Optional<Equivalence.Wrapper<AnnotationMirror>> wrapOptionalInEquivalence(
+      Optional<AnnotationMirror> optional) {
+    return optional.isPresent()
+        ? Optional.of(AnnotationMirrors.equivalence().wrap(optional.get()))
+        : Optional.<Equivalence.Wrapper<AnnotationMirror>>absent();
+  }
+
+  /**
+   * Unwraps an {@link Optional} of a {@link Equivalence.Wrapper} into an {@code Optional} of the
+   * underlying type.
+   */
+  static Optional<AnnotationMirror> unwrapOptionalEquivalence(
+      Optional<Equivalence.Wrapper<AnnotationMirror>> wrappedOptional) {
+    return wrappedOptional.isPresent()
+        ? Optional.of(wrappedOptional.get().get())
+        : Optional.<AnnotationMirror>absent();
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
index 268bfafab..38830b8a3 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
@@ -17,12 +17,15 @@
 
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
+import com.google.common.base.Equivalence;
 import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Sets;
 import com.google.common.util.concurrent.ListenableFuture;
 import java.util.Set;
+
+import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.DeclaredType;
@@ -32,6 +35,8 @@
 
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
+import static dagger.internal.codegen.MapKeys.getMapKey;
+import static dagger.internal.codegen.MoreAnnotationMirrors.wrapOptionalInEquivalence;
 import static javax.lang.model.element.ElementKind.METHOD;
 
 /**
@@ -114,6 +119,7 @@ ProductionBinding forProducesMethod(
           findBindingPackage(key),
           Optional.<DeclaredType>absent(), // TODO(beder): Add nullability checking with Java 8.
           Optional.<DependencyRequest>absent(),
+          wrapOptionalInEquivalence(getMapKey(producesMethod)),
           kind,
           ImmutableList.copyOf(producesMethod.getThrownTypes()),
           Optional.of(executorRequest),
@@ -145,6 +151,7 @@ ProductionBinding syntheticMapOfValuesOrProducedBinding(
           findBindingPackage(requestForMapOfValuesOrProduced.key()),
           Optional.<DeclaredType>absent(),
           Optional.<DependencyRequest>absent(),
+          wrapOptionalInEquivalence(getMapKey(requestForMapOfProducers.requestElement())),
           Kind.SYNTHETIC_MAP,
           ImmutableList.<TypeMirror>of(),
           Optional.<DependencyRequest>absent(),
@@ -168,6 +175,7 @@ ProductionBinding syntheticMultibinding(
           findBindingPackage(request.key()),
           Optional.<DeclaredType>absent(),
           Optional.<DependencyRequest>absent(),
+          Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
           Kind.forMultibindingRequest(request),
           ImmutableList.<TypeMirror>of(),
           Optional.<DependencyRequest>absent(),
@@ -188,6 +196,7 @@ ProductionBinding forComponentMethod(ExecutableElement componentMethod) {
           Optional.<String>absent(),
           Optional.<DeclaredType>absent(),
           Optional.<DependencyRequest>absent(),
+          Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
           Kind.COMPONENT_PRODUCTION,
           ImmutableList.copyOf(componentMethod.getThrownTypes()),
           Optional.<DependencyRequest>absent(),
@@ -205,6 +214,7 @@ ProductionBinding delegate(
           findBindingPackage(delegateDeclaration.key()),
           delegateBinding.nullableType(),
           Optional.<DependencyRequest>absent(),
+          Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
           Kind.SYNTHETIC_DELEGATE_BINDING,
           ImmutableList.<TypeMirror>of(),
           Optional.<DependencyRequest>absent(),
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
index 13e8ba9ab..7a61391ce 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
@@ -18,10 +18,12 @@
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
+import com.google.common.base.Equivalence;
 import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Sets;
 import javax.inject.Inject;
+import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ElementKind;
 import javax.lang.model.element.ExecutableElement;
@@ -38,6 +40,8 @@
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
 import static dagger.internal.codegen.InjectionAnnotations.getQualifier;
+import static dagger.internal.codegen.MapKeys.getMapKey;
+import static dagger.internal.codegen.MoreAnnotationMirrors.wrapOptionalInEquivalence;
 import static javax.lang.model.element.ElementKind.CONSTRUCTOR;
 import static javax.lang.model.element.ElementKind.FIELD;
 import static javax.lang.model.element.ElementKind.METHOD;
@@ -124,6 +128,7 @@ ProvisionBinding forInjectConstructor(ExecutableElement constructorElement,
           findBindingPackage(key),
           Optional.<DeclaredType>absent(),
           membersInjectionRequest,
+          Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
           Kind.INJECTION,
           hasNonDefaultTypeParameters(bindingTypeElement, key.type(), types)
               ? Optional.of(forInjectConstructor(constructorElement, Optional.<TypeMirror>absent()))
@@ -170,6 +175,7 @@ ProvisionBinding forProvidesMethod(
           findBindingPackage(key),
           ConfigurationAnnotations.getNullableType(providesMethod),
           Optional.<DependencyRequest>absent(),
+          wrapOptionalInEquivalence(getMapKey(providesMethod)),
           Kind.PROVISION,
           Optional.<ProvisionBinding>absent(),
           scope);
@@ -198,6 +204,7 @@ ProvisionBinding syntheticMapOfValuesBinding(DependencyRequest requestForMapOfVa
           findBindingPackage(requestForMapOfValues.key()),
           Optional.<DeclaredType>absent(),
           Optional.<DependencyRequest>absent(),
+          wrapOptionalInEquivalence(getMapKey(requestForMapOfProviders.requestElement())),
           Kind.SYNTHETIC_MAP,
           Optional.<ProvisionBinding>absent(),
           Scope.uniqueScopeOf(requestForMapOfProviders.requestElement()));
@@ -220,6 +227,7 @@ ProvisionBinding syntheticMultibinding(
           findBindingPackage(request.key()),
           Optional.<DeclaredType>absent(),
           Optional.<DependencyRequest>absent(),
+          Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
           Kind.forMultibindingRequest(request),
           Optional.<ProvisionBinding>absent(),
           Scope.uniqueScopeOf(request.requestElement()));
@@ -236,6 +244,7 @@ ProvisionBinding forComponent(TypeElement componentDefinitionType) {
           Optional.<String>absent(),
           Optional.<DeclaredType>absent(),
           Optional.<DependencyRequest>absent(),
+          Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
           Kind.COMPONENT,
           Optional.<ProvisionBinding>absent(),
           Optional.<Scope>absent());
@@ -255,6 +264,7 @@ ProvisionBinding forComponentMethod(ExecutableElement componentMethod) {
           Optional.<String>absent(),
           ConfigurationAnnotations.getNullableType(componentMethod),
           Optional.<DependencyRequest>absent(),
+          Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
           Kind.COMPONENT_PROVISION,
           Optional.<ProvisionBinding>absent(),
           scope);
@@ -275,6 +285,7 @@ ProvisionBinding forSubcomponentBuilderMethod(
           Optional.<String>absent(),
           Optional.<DeclaredType>absent(),
           Optional.<DependencyRequest>absent(),
+          Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
           Kind.SUBCOMPONENT_BUILDER,
           Optional.<ProvisionBinding>absent(),
           Optional.<Scope>absent());
@@ -291,6 +302,8 @@ ProvisionBinding delegate(
           findBindingPackage(delegateDeclaration.key()),
           delegate.nullableType(),
           Optional.<DependencyRequest>absent(),
+          // TODO(ronshapiro): for @Binds @IntoMap, this should be delegateDeclaration.mapKey()
+          Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
           Kind.SYNTHETIC_DELEGATE_BINDING,
           Optional.<ProvisionBinding>absent(),
           Scope.uniqueScopeOf(delegateDeclaration.bindingElement()));
