diff --git a/compiler/src/it/functional-tests/src/main/java/test/cycle/Cycles.java b/compiler/src/it/functional-tests/src/main/java/test/cycle/Cycles.java
new file mode 100644
index 000000000..ec0fae769
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/cycle/Cycles.java
@@ -0,0 +1,106 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.cycle;
+
+import dagger.Component;
+import dagger.Lazy;
+import javax.inject.Inject;
+import javax.inject.Provider;
+
+/**
+ * Cycle classes used for testing cyclic dependencies.
+ * A <- (E <- D <- B <- C <- Provider<A>, Lazy<A>), (B <- C <- Provider<A>, Lazy<A>)
+ * S <- Provider<S>, Lazy<S>
+ *
+ * @author Tony Bentancur
+ * @since 2.0
+ */
+
+final class Cycles {
+  private Cycles() {}
+
+  static class A {
+    public final B b;
+    public final E e;
+
+    @Inject
+    A(E e, B b) {
+      this.e = e;
+      this.b = b;
+    }
+  }
+
+  static class B {
+    public final C c;
+
+    @Inject
+    B(C c) {
+      this.c = c;
+    }
+  }
+
+  static class C {
+    public final Provider<A> aProvider;
+    @Inject public Lazy<A> aLazy;
+
+    @Inject
+    C(Provider<A> aProvider) {
+      this.aProvider = aProvider;
+    }
+  }
+
+  static class D {
+    public final B b;
+
+    @Inject
+    D(B b) {
+      this.b = b;
+    }
+  }
+
+  static class E {
+    public final D d;
+
+    @Inject
+    E(D d) {
+      this.d = d;
+    }
+  }
+
+  static class S {
+    public final Provider<S> sProvider;
+    @Inject public Lazy<S> sLazy;
+
+    @Inject
+    S(Provider<S> sProvider) {
+      this.sProvider = sProvider;
+    }
+  }
+
+  @SuppressWarnings("dependency-cycle")
+  @Component
+  interface CycleComponent {
+    A a();
+
+    C c();
+  }
+
+  @SuppressWarnings("dependency-cycle")
+  @Component
+  interface SelfCycleComponent {
+    S s();
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/test/java/test/cycle/CycleTest.java b/compiler/src/it/functional-tests/src/test/java/test/cycle/CycleTest.java
new file mode 100644
index 000000000..c3f20452a
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/test/java/test/cycle/CycleTest.java
@@ -0,0 +1,64 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.cycle;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import test.cycle.Cycles.A;
+import test.cycle.Cycles.C;
+import test.cycle.Cycles.CycleComponent;
+import test.cycle.Cycles.S;
+import test.cycle.Cycles.SelfCycleComponent;
+
+import static com.google.common.truth.Truth.assertThat;
+
+@RunWith(JUnit4.class)
+public class CycleTest {
+  @Test
+  public void providerIndirectionSelfCycle() {
+    SelfCycleComponent selfCycleComponent = DaggerCycles_SelfCycleComponent.create();
+    S s = selfCycleComponent.s();
+    assertThat(s.sProvider.get()).isNotNull();
+  }
+
+  @Test
+  public void providerIndirectionCycle() {
+    CycleComponent cycleComponent = DaggerCycles_CycleComponent.create();
+    A a = cycleComponent.a();
+    C c = cycleComponent.c();
+    assertThat(c.aProvider.get()).isNotNull();
+    assertThat(a.b.c.aProvider.get()).isNotNull();
+    assertThat(a.e.d.b.c.aProvider.get()).isNotNull();
+  }
+
+  @Test
+  public void lazyIndirectionSelfCycle() {
+    SelfCycleComponent selfCycleComponent = DaggerCycles_SelfCycleComponent.create();
+    S s = selfCycleComponent.s();
+    assertThat(s.sLazy.get()).isNotNull();
+  }
+
+  @Test
+  public void lazyIndirectionCycle() {
+    CycleComponent cycleComponent = DaggerCycles_CycleComponent.create();
+    A a = cycleComponent.a();
+    C c = cycleComponent.c();
+    assertThat(c.aLazy.get()).isNotNull();
+    assertThat(a.b.c.aLazy.get()).isNotNull();
+    assertThat(a.e.d.b.c.aLazy.get()).isNotNull();
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
index 2b38b5ab6..c6cdcb73d 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -40,6 +40,7 @@
 import dagger.internal.codegen.ContributionBinding.BindingType;
 import dagger.internal.codegen.writer.TypeNames;
 import java.util.ArrayDeque;
+import java.util.Arrays;
 import java.util.Collection;
 import java.util.Deque;
 import java.util.Formatter;
@@ -48,6 +49,7 @@
 import java.util.Set;
 import javax.inject.Singleton;
 import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.ArrayType;
@@ -57,6 +59,7 @@
 import javax.lang.model.util.SimpleTypeVisitor6;
 import javax.lang.model.util.Types;
 import javax.tools.Diagnostic;
+import javax.tools.Diagnostic.Kind;
 
 import static com.google.auto.common.MoreElements.getAnnotationMirror;
 import static com.google.auto.common.MoreTypes.isTypeOf;
@@ -699,19 +702,26 @@ private void reportMultipleBindingTypes(Deque<ResolvedRequest> path) {
       reportBuilder.addItem(builder.toString(), path.getLast().request().requestElement());
     }
 
-    private void reportCycle(DependencyRequest request, Deque<ResolvedRequest> path) {
+    private void reportCycle(DependencyRequest request, Deque<ResolvedRequest> bindingPath) {
       ImmutableList<DependencyRequest> pathElements = ImmutableList.<DependencyRequest>builder()
           .add(request)
-          .addAll(Iterables.transform(path, REQUEST_FROM_RESOLVED_REQUEST))
+          .addAll(Iterables.transform(bindingPath, REQUEST_FROM_RESOLVED_REQUEST))
           .build();
       ImmutableList<String> printableDependencyPath = FluentIterable.from(pathElements)
           .transform(dependencyRequestFormatter)
           .filter(Predicates.not(Predicates.equalTo("")))
           .toList()
           .reverse();
-      DependencyRequest rootRequest = path.getLast().request();
+      DependencyRequest rootRequest = bindingPath.getLast().request();
       TypeElement componentType =
           MoreElements.asType(rootRequest.requestElement().getEnclosingElement());
+      Kind kind = cycleHasProviderOrLazy(pathElements) ? Kind.WARNING : Kind.ERROR;
+      Element requestElement = rootRequest.requestElement();
+      if (kind == Kind.WARNING 
+          && (suppressCycleWarnings(requestElement) 
+              || suppressCycleWarnings(requestElement.getEnclosingElement()))) {
+        return;
+      }
       // TODO(cgruber): Restructure to provide a hint for the start and end of the cycle.
       reportBuilder.addItem(
           String.format(ErrorMessages.CONTAINS_DEPENDENCY_CYCLE_FORMAT,
@@ -719,8 +729,24 @@ private void reportCycle(DependencyRequest request, Deque<ResolvedRequest> path)
               rootRequest.requestElement().getSimpleName(),
               Joiner.on("\n")
                   .join(printableDependencyPath.subList(1, printableDependencyPath.size()))),
+          kind,
           rootRequest.requestElement());
     }
+
+    private boolean cycleHasProviderOrLazy(ImmutableList<DependencyRequest> pathElements) {
+      for (DependencyRequest dependencyRequest : pathElements) {
+        if (dependencyRequest.kind() == DependencyRequest.Kind.PROVIDER
+            || dependencyRequest.kind() == DependencyRequest.Kind.LAZY) {
+          return true;
+        }
+      }
+      return false;
+    }
+  }
+
+  private boolean suppressCycleWarnings(Element requestElement) {
+    SuppressWarnings suppressions = requestElement.getAnnotation(SuppressWarnings.class);
+    return suppressions != null && Arrays.asList(suppressions.value()).contains("dependency-cycle");
   }
 
   @Override
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java
index 3ca661522..db30d57cd 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java
@@ -34,6 +34,7 @@
 import com.google.common.collect.Sets;
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.MembersInjector;
+import dagger.internal.DelegateFactory;
 import dagger.internal.Factory;
 import dagger.internal.InstanceFactory;
 import dagger.internal.MapFactory;
@@ -128,6 +129,8 @@
   protected ImmutableSet<BindingKey> enumBindingKeys;
   protected ConstructorWriter constructorWriter;
   protected final Map<TypeElement, MemberSelect> componentContributionFields = Maps.newHashMap();
+  private final Set<BindingKey> bindingKeysWithInitializedProviders = Sets.newHashSet();
+  private final Set<BindingKey> bindingKeysWithDelegates = Sets.newHashSet();
 
   ComponentWriter(
       Types types,
@@ -604,7 +607,7 @@ protected void initializeFrameworkTypes(Optional<ClassName> builderName) {
       } else {
         constructorWriter.body().addSnippet("%s();", initializeMethod.name());
       }
-
+      bindingKeysWithDelegates.clear();
       for (BindingKey bindingKey : partitions.get(i)) {
         Snippet memberSelectSnippet = getMemberSelectSnippet(bindingKey);
         ResolvedBindings resolvedBindings = graph.resolvedBindings().get(bindingKey);
@@ -669,6 +672,7 @@ protected void initializeFrameworkTypes(Optional<ClassName> builderName) {
                   ContributionBinding binding = Iterables.getOnlyElement(bindings);
                   if (binding instanceof ProvisionBinding) {
                     ProvisionBinding provisionBinding = (ProvisionBinding) binding;
+                    initializeDelegateFactories(binding, initializeMethod);
                     if (!provisionBinding.factoryCreationStrategy().equals(ENUM_INSTANCE)
                         || provisionBinding.scope().isPresent()) {
                       initializeMethod.body().addSnippet("this.%s = %s;",
@@ -693,16 +697,61 @@ protected void initializeFrameworkTypes(Optional<ClassName> builderName) {
             MembersInjectionBinding binding = Iterables.getOnlyElement(
                 resolvedBindings.membersInjectionBindings());
             if (!binding.injectionStrategy().equals(MembersInjectionBinding.Strategy.NO_OP)) {
+              initializeDelegateFactories(binding, initializeMethod);
               initializeMethod.body().addSnippet("this.%s = %s;",
-                  memberSelectSnippet, initializeMembersInjectorForBinding(binding));
+                  memberSelectSnippet, 
+                  initializeMembersInjectorForBinding(binding));
             }
             break;
           default:
             throw new AssertionError();
         }
+        bindingKeysWithInitializedProviders.add(bindingKey);
+      }
+      for (BindingKey key : bindingKeysWithDelegates) {
+        initializeMethod.body().addSnippet(
+                "%s.setDelegatedProvider(%s);",
+                delegateFactoryVariableSnippet(key),
+                getMemberSelectSnippet(key));
+      }
+    }
+  }
+  
+  private void initializeDelegateFactories(Binding binding, MethodWriter initializeMethod) {
+    for (Collection<DependencyRequest> requestsForKey :
+        SourceFiles.indexDependenciesByUnresolvedKey(types, binding.dependencies())
+            .asMap()
+            .values()) {
+      BindingKey dependencyKey =
+          Iterables.getOnlyElement(
+                  FluentIterable.from(requestsForKey)
+                      .transform(
+                          new Function<DependencyRequest, BindingKey>() {
+                            @Override
+                            public BindingKey apply(DependencyRequest request) {
+                              return request.bindingKey();
+                            }
+                          })
+                      .toSet());
+      if (!getMemberSelect(dependencyKey).staticMember()
+          && !bindingKeysWithInitializedProviders.contains(dependencyKey)
+          && !bindingKeysWithDelegates.contains(dependencyKey)) {
+        initializeMethod
+            .body()
+            .addSnippet(
+                "%s %s = new %s();",
+                ClassName.fromClass(DelegateFactory.class),
+                delegateFactoryVariableSnippet(dependencyKey),
+                ClassName.fromClass(DelegateFactory.class));
+        bindingKeysWithDelegates.add(dependencyKey);
       }
     }
   }
+  
+  private Snippet delegateFactoryVariableSnippet(BindingKey key){
+    return Snippet.format(
+        "%sDelegate", getMemberSelectSnippet(key).toString().replace('.', '_'));
+  }
 
   private Snippet initializeFactoryForContributionBinding(ContributionBinding binding) {
     if (binding instanceof ProvisionBinding) {
@@ -876,7 +925,11 @@ private Snippet initializeMembersInjectorForBinding(MembersInjectionBinding bind
             }
           })
           .toSet());
-      parameters.add(getMemberSelect(key).getSnippetWithRawTypeCastFor(name));
+      if (bindingKeysWithDelegates.contains(key)) {
+        parameters.add(delegateFactoryVariableSnippet(key));
+      } else {
+        parameters.add(getMemberSelect(key).getSnippetWithRawTypeCastFor(name));
+      }
     }
     return parameters.build();
   }
@@ -943,3 +996,4 @@ private Snippet initializeMapBinding(Set<ProvisionBinding> bindings) {
     return Snippet.join(Joiner.on('\n'), snippets.build());
   }
 }
+
diff --git a/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java b/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
index 19b9c9419..bf98445ce 100644
--- a/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
@@ -20,6 +20,7 @@
 import com.google.testing.compile.JavaFileObjects;
 import java.util.Arrays;
 import javax.tools.JavaFileObject;
+import org.junit.Ignore;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
@@ -233,10 +234,103 @@
 
     assertAbout(javaSource()).that(component)
         .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(expectedError).in(component).onLine(26);
+        .failsToCompile().withErrorContaining(expectedError).in(component).onLine(26);
+  }
+
+  @Ignore @Test public void cyclicDependencySimpleProviderIndirectionWarning() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.Outer",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import javax.inject.Inject;",
+            "import javax.inject.Provider;",
+            "",
+            "final class Outer {",
+            "  static class A {",
+            "    @Inject A(B bParam) {}",
+            "  }",
+            "",
+            "  static class B {",
+            "    @Inject B(C bParam, D dParam) {}",
+            "  }",
+            "",
+            "  static class C {",
+            "    @Inject C(Provider<A> aParam) {}",
+            "  }",
+            "",
+            "  static class D {",
+            "    @Inject D() {}",
+            "  }",
+            "",
+            "  @Component()",
+            "  interface CComponent {",
+            "    C get();",
+            "  }",
+            "}");
+
+    /* String expectedWarning =
+     "test.Outer.CComponent.get() contains a dependency cycle:"
+     + "      test.Outer.C.<init>(javax.inject.Provider<test.Outer.A> aParam)"
+     + "          [parameter: javax.inject.Provider<test.Outer.A> aParam]"
+     + "      test.Outer.A.<init>(test.Outer.B bParam)"
+     + "          [parameter: test.Outer.B bParam]"
+     + "      test.Outer.B.<init>(test.Outer.C bParam, test.Outer.D dParam)"
+     + "          [parameter: test.Outer.C bParam]";
+     */
+    assertAbout(javaSource()) // TODO(cgruber): Implement warning checks.
+        .that(component)
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError();
+        //.withWarningContaining(expectedWarning).in(component).onLine(X);
   }
 
+  @Ignore @Test public void cyclicDependencySimpleProviderIndirectionWarningSuppressed() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.Outer",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import javax.inject.Inject;",
+            "import javax.inject.Provider;",
+            "",
+            "final class Outer {",
+            "  static class A {",
+            "    @Inject A(B bParam) {}",
+            "  }",
+            "",
+            "  static class B {",
+            "    @Inject B(C bParam, D dParam) {}",
+            "  }",
+            "",
+            "  static class C {",
+            "    @Inject C(Provider<A> aParam) {}",
+            "  }",
+            "",
+            "  static class D {",
+            "    @Inject D() {}",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"dependency-cycle\")",
+            "  @Component()",
+            "  interface CComponent {",
+            "    C get();",
+            "  }",
+            "}");
+
+    assertAbout(javaSource())
+        .that(component)
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError();
+        //.compilesWithoutWarning(); //TODO(cgruber)
+  }
+  
   @Test public void duplicateExplicitBindings_ProvidesAndComponentProvision() {
     JavaFileObject component = JavaFileObjects.forSourceLines("test.Outer",
         "package test;",
@@ -320,7 +414,7 @@
         .failsToCompile()
         .withErrorContaining(expectedError).in(component).onLine(24);
   }
-
+  
   @Test public void duplicateExplicitBindings_MultipleProvisionTypes() {
     JavaFileObject component = JavaFileObjects.forSourceLines("test.Outer",
         "package test;",
@@ -391,7 +485,7 @@
         .withErrorContaining(expectedSetError).in(component).onLine(43)
         .and().withErrorContaining(expectedMapError).in(component).onLine(44);
   }
-
+  
   @Test public void duplicateBindings_TruncateAfterLimit() {
     JavaFileObject component = JavaFileObjects.forSourceLines("test.Outer",
         "package test;",
diff --git a/core/src/main/java/dagger/internal/DelegateFactory.java b/core/src/main/java/dagger/internal/DelegateFactory.java
new file mode 100644
index 000000000..d1e864d17
--- /dev/null
+++ b/core/src/main/java/dagger/internal/DelegateFactory.java
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal;
+
+import javax.inject.Provider;
+
+/**
+ * A DelegateFactory that is used to stitch Provider/Lazy indirection based dependency cycles.
+ * 
+ * @since 2.0.1
+ */
+public final class DelegateFactory<T> implements Factory<T> {
+  private Provider<T> delegate;
+
+  @Override
+  public T get() {
+    if (delegate == null) {
+      throw new IllegalStateException();
+    }
+    return delegate.get();
+  }
+
+  public void setDelegatedProvider(Provider<T> delegate) {
+    if (delegate == null) {
+      throw new IllegalArgumentException();
+    }
+    if (this.delegate != null) {
+      throw new IllegalStateException();
+    }
+    this.delegate = delegate;
+  }
+}
+
