diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
index 139c9a833..65bd4dbab 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -38,6 +38,7 @@
 import static dagger.internal.codegen.MemberSelect.staticMethod;
 import static dagger.internal.codegen.MembersInjectionBinding.Strategy.NO_OP;
 import static dagger.internal.codegen.Scope.reusableScope;
+import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
 import static dagger.internal.codegen.SourceFiles.generatedClassNameForBinding;
 import static dagger.internal.codegen.SourceFiles.membersInjectorNameForType;
 import static dagger.internal.codegen.TypeNames.DELEGATE_FACTORY;
@@ -110,6 +111,7 @@
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.Name;
 import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.ExecutableType;
 import javax.lang.model.type.TypeKind;
@@ -139,7 +141,6 @@
   private final UniqueNameSet componentFieldNames = new UniqueNameSet();
   private final Map<BindingKey, MemberSelect> memberSelects = new HashMap<>();
   private final Map<BindingKey, MemberSelect> producerFromProviderMemberSelects = new HashMap<>();
-  private final Map<BindingKey, RequestFulfillment> requestFulfillments = Maps.newLinkedHashMap();
   protected final MethodSpec.Builder constructor = constructorBuilder().addModifiers(PRIVATE);
   protected Optional<ClassName> builderName = Optional.absent();
 
@@ -653,33 +654,6 @@ private static ClassName frameworkMapFactoryClassName(BindingType bindingType) {
         ? MAP_OF_PRODUCER_PRODUCER : MAP_PROVIDER_FACTORY;
   }
 
-  // TODO(gak): extract this into a proper factory class
-  private RequestFulfillment getOrCreateRequestFulfillment(BindingKey bindingKey) {
-    RequestFulfillment requestFulfillment = requestFulfillments.get(bindingKey);
-    if (requestFulfillment == null) {
-      /* TODO(gak): it is super convoluted that we create the member selects separately and then
-       * look them up again this way. Now that we have RequestFulfillment, the next step is to
-       * create it and the MemberSelect and the field on demand rather than in a first pass. */
-      MemberSelect memberSelect = getMemberSelect(bindingKey);
-      ResolvedBindings resolvedBindings = graph.resolvedBindings().get(bindingKey);
-      switch (resolvedBindings.bindingType()) {
-        case MEMBERS_INJECTION:
-          requestFulfillment = new MembersInjectorRequestFulfillment(bindingKey, memberSelect);
-          break;
-        case PRODUCTION:
-          requestFulfillment = new ProducerFieldRequestFulfillment(bindingKey, memberSelect);
-          break;
-        case PROVISION:
-          requestFulfillment = new ProviderFieldRequestFulfillment(bindingKey, memberSelect);
-          break;
-        default:
-          throw new AssertionError();
-      }
-      requestFulfillments.put(bindingKey, requestFulfillment);
-    }
-    return requestFulfillment;
-  }
-
   private void implementInterfaceMethods() {
     Set<MethodSignature> interfaceMethods = Sets.newHashSet();
     for (ComponentMethodDescriptor componentMethod :
@@ -688,36 +662,51 @@ private void implementInterfaceMethods() {
         DependencyRequest interfaceRequest = componentMethod.dependencyRequest().get();
         ExecutableElement requestElement =
             MoreElements.asExecutable(interfaceRequest.requestElement());
-        DeclaredType declaringType = MoreTypes.asDeclared(componentDefinitionType().asType());
-        ExecutableType requestType =
-            MoreTypes.asExecutable(types.asMemberOf(declaringType, requestElement));
+        ExecutableType requestType = MoreTypes.asExecutable(types.asMemberOf(
+            MoreTypes.asDeclared(componentDefinitionType().asType()), requestElement));
         MethodSignature signature = MethodSignature.fromExecutableType(
             requestElement.getSimpleName().toString(), requestType);
         if (!interfaceMethods.contains(signature)) {
           interfaceMethods.add(signature);
           MethodSpec.Builder interfaceMethod =
-              MethodSpec.overriding(requestElement, declaringType, types);
-          RequestFulfillment fulfillment =
-              getOrCreateRequestFulfillment(interfaceRequest.bindingKey());
-          CodeBlock codeBlock = fulfillment.getSnippetForDependencyRequest(interfaceRequest, name);
-          switch (componentMethod.kind()) {
-              /* TODO(gak): we should figure out a way to avoid having to special-case members
-               * injection */
-            case MEMBERS_INJECTION:
-              if (requestElement.getParameters().isEmpty()) {
-                interfaceMethod.addStatement("return $L", codeBlock);
+              methodBuilder(requestElement.getSimpleName().toString())
+                  .addAnnotation(Override.class)
+                  .addModifiers(PUBLIC)
+                  .returns(TypeName.get(requestType.getReturnType()));
+          BindingKey bindingKey = interfaceRequest.bindingKey();
+          MemberSelect memberSelect = getMemberSelect(bindingKey);
+          CodeBlock memberSelectCodeBlock = memberSelect.getExpressionFor(name);
+          switch (interfaceRequest.kind()) {
+            case MEMBERS_INJECTOR:
+              List<? extends VariableElement> parameters = requestElement.getParameters();
+              if (parameters.isEmpty()) {
+                // we're returning the framework type
+                interfaceMethod.addStatement("return $L", memberSelectCodeBlock);
               } else {
-                Name parameterName =
-                    Iterables.getOnlyElement(requestElement.getParameters()).getSimpleName();
-                interfaceMethod.addStatement("$L.injectMembers($L)", codeBlock, parameterName);
+                Name parameterName = Iterables.getOnlyElement(parameters).getSimpleName();
+                interfaceMethod.addParameter(
+                    TypeName.get(Iterables.getOnlyElement(requestType.getParameterTypes())),
+                    parameterName.toString());
+                interfaceMethod.addStatement(
+                    "$L.injectMembers($L)", memberSelectCodeBlock, parameterName);
                 if (!requestType.getReturnType().getKind().equals(VOID)) {
                   interfaceMethod.addStatement("return $L", parameterName);
                 }
               }
               break;
-            default:
-              interfaceMethod.addStatement("return $L", codeBlock);
+            case INSTANCE:
+            case LAZY:
+            case PRODUCED:
+            case PRODUCER:
+            case PROVIDER:
+            case PROVIDER_OF_LAZY:
+            case FUTURE:
+              interfaceMethod.addStatement(
+                  "return $L",
+                  frameworkTypeUsageStatement(memberSelectCodeBlock, interfaceRequest.kind()));
               break;
+            default:
+              throw new AssertionError();
           }
           component.addMethod(interfaceMethod.build());
         }
diff --git a/compiler/src/main/java/dagger/internal/codegen/CodeBlocks.java b/compiler/src/main/java/dagger/internal/codegen/CodeBlocks.java
index 1404536ab..d5f4880c5 100644
--- a/compiler/src/main/java/dagger/internal/codegen/CodeBlocks.java
+++ b/compiler/src/main/java/dagger/internal/codegen/CodeBlocks.java
@@ -40,8 +40,8 @@ static CodeBlock concat(Iterable<CodeBlock> codeBlocks) {
     return join(codeBlocks, "\n");
   }
 
-  static CodeBlock.Builder join(
-      CodeBlock.Builder builder, Iterable<CodeBlock> codeBlocks, String delimiter) {
+  static CodeBlock join(Iterable<CodeBlock> codeBlocks, String delimiter) {
+    CodeBlock.Builder builder = CodeBlock.builder();
     Iterator<CodeBlock> iterator = codeBlocks.iterator();
     while (iterator.hasNext()) {
       builder.add(iterator.next());
@@ -49,11 +49,7 @@ static CodeBlock concat(Iterable<CodeBlock> codeBlocks) {
         builder.add(delimiter);
       }
     }
-    return builder;
-  }
-
-  static CodeBlock join(Iterable<CodeBlock> codeBlocks, String delimiter) {
-    return join(CodeBlock.builder(), codeBlocks, delimiter).build();
+    return builder.build();
   }
 
   static FluentIterable<CodeBlock> toCodeBlocks(Iterable<? extends TypeMirror> typeMirrors) {
@@ -72,12 +68,12 @@ public CodeBlock apply(TypeMirror typeMirror) {
         }
       };
 
-  static final Function<ParameterSpec, CodeBlock> PARAMETER_NAME =
+  static Function<ParameterSpec, CodeBlock> PARAMETER_NAME =
       new Function<ParameterSpec, CodeBlock>() {
-        @Override
-        public CodeBlock apply(ParameterSpec input) {
-          return CodeBlock.of("$N", input);
-        }
+          @Override
+          public CodeBlock apply(ParameterSpec input) {
+            return CodeBlock.of("$N", input);
+          }
       };
 
   private CodeBlocks() {}
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorRequestFulfillment.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorRequestFulfillment.java
deleted file mode 100644
index bece3fad9..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorRequestFulfillment.java
+++ /dev/null
@@ -1,43 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal.codegen;
-
-import static com.google.common.base.Preconditions.checkArgument;
-import static dagger.internal.codegen.BindingKey.Kind.MEMBERS_INJECTION;
-
-import com.squareup.javapoet.ClassName;
-import com.squareup.javapoet.CodeBlock;
-import dagger.internal.codegen.DependencyRequest.Kind;
-
-/** Fulfills requests for {@link MembersInjectionBinding} instances. */
-final class MembersInjectorRequestFulfillment extends RequestFulfillment {
-  private final MemberSelect membersInjectorFieldSelect;
-
-  MembersInjectorRequestFulfillment(
-      BindingKey bindingKey, MemberSelect membersInjectorFieldSelect) {
-    super(bindingKey);
-    checkArgument(bindingKey.kind().equals(MEMBERS_INJECTION));
-    this.membersInjectorFieldSelect = membersInjectorFieldSelect;
-  }
-
-  @Override
-  public CodeBlock getSnippetForDependencyRequest(
-      DependencyRequest request, ClassName requestingClass) {
-    checkArgument(request.kind().equals(Kind.MEMBERS_INJECTOR));
-    return membersInjectorFieldSelect.getExpressionFor(requestingClass);
-  }
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProducerFieldRequestFulfillment.java b/compiler/src/main/java/dagger/internal/codegen/ProducerFieldRequestFulfillment.java
deleted file mode 100644
index ea1d1d5cf..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/ProducerFieldRequestFulfillment.java
+++ /dev/null
@@ -1,68 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal.codegen;
-
-import static com.google.common.base.Preconditions.checkArgument;
-import static dagger.internal.codegen.BindingKey.Kind.CONTRIBUTION;
-
-import com.squareup.javapoet.ClassName;
-import com.squareup.javapoet.CodeBlock;
-import dagger.MembersInjector;
-import dagger.producers.Producer;
-import javax.inject.Provider;
-
-/** Fulfills requests for {@link ProductionBinding} instances. */
-final class ProducerFieldRequestFulfillment extends RequestFulfillment {
-  private final MemberSelect producerFieldSelect;
-
-  ProducerFieldRequestFulfillment(BindingKey bindingKey, MemberSelect producerFieldSelect) {
-    super(bindingKey);
-    checkArgument(bindingKey.kind().equals(CONTRIBUTION));
-    this.producerFieldSelect = producerFieldSelect;
-  }
-
-  @Override
-  public CodeBlock getSnippetForDependencyRequest(
-      DependencyRequest request, ClassName requestingClass) {
-    switch (request.kind()) {
-      case FUTURE:
-        return CodeBlock.of("$L.get()", producerFieldSelect.getExpressionFor(requestingClass));
-      case PRODUCER:
-        return CodeBlock.of("$L", producerFieldSelect.getExpressionFor(requestingClass));
-      case INSTANCE:
-      case LAZY:
-      case PRODUCED:
-      case PROVIDER_OF_LAZY:
-        throw new IllegalArgumentException(
-            String.format(
-                "The framework should never request a %s from a producer: %s",
-                request.kind(), request));
-      case MEMBERS_INJECTOR:
-        throw new IllegalArgumentException(
-            String.format(
-                "Cannot request a %s from a %s",
-                MembersInjector.class.getSimpleName(), Producer.class.getSimpleName()));
-      case PROVIDER:
-        throw new IllegalArgumentException(
-            String.format(
-                "Cannot request a %s from a %s",
-                Provider.class.getSimpleName(), Producer.class.getSimpleName()));
-      default:
-        throw new AssertionError(request.kind().toString());
-    }
-  }
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProviderFieldRequestFulfillment.java b/compiler/src/main/java/dagger/internal/codegen/ProviderFieldRequestFulfillment.java
deleted file mode 100644
index 0733192e1..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/ProviderFieldRequestFulfillment.java
+++ /dev/null
@@ -1,84 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal.codegen;
-
-import static com.google.common.base.Preconditions.checkArgument;
-import static dagger.internal.codegen.BindingKey.Kind.CONTRIBUTION;
-import static dagger.internal.codegen.TypeNames.PROVIDER_OF_LAZY;
-
-import com.google.common.util.concurrent.Futures;
-import com.squareup.javapoet.ClassName;
-import com.squareup.javapoet.CodeBlock;
-import dagger.MembersInjector;
-import dagger.internal.DoubleCheck;
-import dagger.producers.Produced;
-import dagger.producers.internal.Producers;
-import javax.inject.Provider;
-
-/** Fulfills requests for {@link ProvisionBinding} instances. */
-final class ProviderFieldRequestFulfillment extends RequestFulfillment {
-  private final MemberSelect providerFieldSelect;
-
-  ProviderFieldRequestFulfillment(BindingKey bindingKey, MemberSelect frameworkFieldSelect) {
-    super(bindingKey);
-    checkArgument(bindingKey.kind().equals(CONTRIBUTION));
-    this.providerFieldSelect = frameworkFieldSelect;
-  }
-
-  @Override
-  public CodeBlock getSnippetForDependencyRequest(
-      DependencyRequest request, ClassName requestingClass) {
-    switch (request.kind()) {
-      case FUTURE:
-        return CodeBlock.of(
-            "$T.immediateFuture($L.get())",
-            Futures.class,
-            providerFieldSelect.getExpressionFor(requestingClass));
-      case INSTANCE:
-        return CodeBlock.of("$L.get()", providerFieldSelect.getExpressionFor(requestingClass));
-      case LAZY:
-        return CodeBlock.of(
-            "$T.lazy($L)",
-            DoubleCheck.class,
-            providerFieldSelect.getExpressionFor(requestingClass));
-      case MEMBERS_INJECTOR:
-        throw new IllegalArgumentException(
-            String.format(
-                "Cannot request a %s from a %s",
-                MembersInjector.class.getSimpleName(), Provider.class.getSimpleName()));
-      case PRODUCED:
-        return CodeBlock.of(
-            "$T.successful($L.get())",
-            Produced.class,
-            providerFieldSelect.getExpressionFor(requestingClass));
-      case PRODUCER:
-        return CodeBlock.of(
-            "$T.producerFromProvider($L)",
-            Producers.class,
-            providerFieldSelect.getExpressionFor(requestingClass));
-      case PROVIDER:
-        return CodeBlock.of("$L", providerFieldSelect.getExpressionFor(requestingClass));
-      case PROVIDER_OF_LAZY:
-        return CodeBlock.of(
-            "$T.create($L)",
-            PROVIDER_OF_LAZY,
-            providerFieldSelect.getExpressionFor(requestingClass));
-      default:
-        throw new AssertionError();
-    }
-  }
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/RequestFulfillment.java b/compiler/src/main/java/dagger/internal/codegen/RequestFulfillment.java
deleted file mode 100644
index 40764ee7b..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/RequestFulfillment.java
+++ /dev/null
@@ -1,46 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal.codegen;
-
-import static com.google.common.base.Preconditions.checkNotNull;
-
-import com.squareup.javapoet.ClassName;
-import com.squareup.javapoet.CodeBlock;
-
-/**
- * A strategy interface for generating a {@link CodeBlock} that represents how a {@link Binding} is
- * used to satisfy a given {@link DependencyRequest}.
- */
-abstract class RequestFulfillment {
-  private final BindingKey bindingKey;
-
-  RequestFulfillment(BindingKey bindingKey) {
-    this.bindingKey = checkNotNull(bindingKey);
-  }
-
-  /** The key for which this instance can fulfill requests. */
-  final BindingKey bindingKey() {
-    return bindingKey;
-  }
-
-  /**
-   * Returns the {@link CodeBlock} that implements the operation represented by the {@link
-   * DependencyRequest request} from the {@code requestingClass}.
-   */
-  abstract CodeBlock getSnippetForDependencyRequest(
-      DependencyRequest request, ClassName requestingClass);
-}
