diff --git a/java/dagger/internal/codegen/BuilderValidator.java b/java/dagger/internal/codegen/BuilderValidator.java
index f69806ddf..543cd5691 100644
--- a/java/dagger/internal/codegen/BuilderValidator.java
+++ b/java/dagger/internal/codegen/BuilderValidator.java
@@ -19,6 +19,7 @@
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.collect.Iterables.getOnlyElement;
+import static dagger.internal.codegen.DaggerElements.isAnyAnnotationPresent;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.STATIC;
@@ -27,6 +28,7 @@
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.common.collect.ImmutableSet;
+import dagger.BindsInstance;
 import dagger.internal.codegen.ErrorMessages.ComponentBuilderMessages;
 import java.lang.annotation.Annotation;
 import java.util.Arrays;
@@ -110,51 +112,66 @@
       ExecutableType resolvedMethodType =
           MoreTypes.asExecutable(types.asMemberOf(MoreTypes.asDeclared(subject.asType()), method));
       TypeMirror returnType = resolvedMethodType.getReturnType();
-      if (method.getParameters().size() == 0) {
-        // If this is potentially a build() method, validate it returns the correct type.
-        if (types.isSubtype(componentElement.asType(), returnType)) {
-          validateBuildMethodReturnType(
-              builder,
-              // since types.isSubtype() passed, componentElement cannot be a PackageElement
-              MoreElements.asType(componentElement),
-              msgs,
-              method,
-              returnType);
-          if (buildMethod != null) {
-            // If we found more than one build-like method, fail.
+      switch (method.getParameters().size()) {
+        case 0: // If this is potentially a build() method, validate it returns the correct type.
+          if (types.isSubtype(componentElement.asType(), returnType)) {
+            validateBuildMethodReturnType(
+                builder,
+                // since types.isSubtype() passed, componentElement cannot be a PackageElement
+                MoreElements.asType(componentElement),
+                msgs,
+                method,
+                returnType);
+            if (buildMethod != null) {
+              // If we found more than one build-like method, fail.
+              error(
+                  builder,
+                  method,
+                  msgs.twoBuildMethods(),
+                  msgs.inheritedTwoBuildMethods(),
+                  buildMethod);
+            }
+          } else {
             error(
                 builder,
                 method,
-                msgs.twoBuildMethods(),
-                msgs.inheritedTwoBuildMethods(),
-                buildMethod);
+                msgs.buildMustReturnComponentType(),
+                msgs.inheritedBuildMustReturnComponentType());
           }
-        } else {
+          // We set the buildMethod regardless of the return type to reduce error spam.
+          buildMethod = method;
+          break;
+
+        case 1: // If this correctly had one parameter, make sure the return types are valid.
+          if (returnType.getKind() != TypeKind.VOID
+              && !types.isSubtype(subject.asType(), returnType)) {
+            error(
+                builder,
+                method,
+                msgs.methodsMustReturnVoidOrBuilder(),
+                msgs.inheritedMethodsMustReturnVoidOrBuilder());
+          }
+          if (!method.getTypeParameters().isEmpty()) {
+            error(
+                builder,
+                method,
+                msgs.methodsMayNotHaveTypeParameters(),
+                msgs.inheritedMethodsMayNotHaveTypeParameters());
+          }
+          if (!isAnyAnnotationPresent(method, BindsInstance.class)
+              && method.getParameters().get(0).asType().getKind().isPrimitive()) {
+            error(
+                builder,
+                method,
+                msgs.nonBindsInstanceMethodsMayNotTakePrimitives(),
+                msgs.inheritedNonBindsInstanceMethodsMayNotTakePrimitives());
+          }
+          break;
+
+        default: // more than one parameter
           error(
-              builder,
-              method,
-              msgs.buildMustReturnComponentType(),
-              msgs.inheritedBuildMustReturnComponentType());
-        }
-        // We set the buildMethod regardless of the return type to reduce error spam.
-        buildMethod = method;
-      } else if (method.getParameters().size() > 1) {
-        // If this is a setter, make sure it has one arg.
-        error(builder, method, msgs.methodsMustTakeOneArg(), msgs.inheritedMethodsMustTakeOneArg());
-      } else if (returnType.getKind() != TypeKind.VOID
-          && !types.isSubtype(subject.asType(), returnType)) {
-        // If this correctly had one arg, make sure the return types are valid.
-        error(
-            builder,
-            method,
-            msgs.methodsMustReturnVoidOrBuilder(),
-            msgs.inheritedMethodsMustReturnVoidOrBuilder());
-      } else if (!method.getTypeParameters().isEmpty()) {
-        error(
-            builder,
-            method,
-            msgs.methodsMayNotHaveTypeParameters(),
-            msgs.inheritedMethodsMayNotHaveTypeParameters());
+              builder, method, msgs.methodsMustTakeOneArg(), msgs.inheritedMethodsMustTakeOneArg());
+          break;
       }
     }
 
diff --git a/java/dagger/internal/codegen/ErrorMessages.java b/java/dagger/internal/codegen/ErrorMessages.java
index 909b4f5ab..f7b143eb5 100644
--- a/java/dagger/internal/codegen/ErrorMessages.java
+++ b/java/dagger/internal/codegen/ErrorMessages.java
@@ -149,6 +149,16 @@ final String inheritedMethodsMayNotHaveTypeParameters() {
           "@Component.Builder methods must not have type parameters. Inherited method: %s");
     }
 
+    final String nonBindsInstanceMethodsMayNotTakePrimitives() {
+      return process(
+          "@Component.Builder methods that are not annotated with @BindsInstance "
+              + "must take either a module or a component dependency, not a primitive");
+    }
+
+    final String inheritedNonBindsInstanceMethodsMayNotTakePrimitives() {
+      return nonBindsInstanceMethodsMayNotTakePrimitives() + process(". Inherited method: %s");
+    }
+
     final String buildMethodReturnsSupertypeWithMissingMethods(
         TypeElement component,
         TypeElement componentBuilder,
diff --git a/javatests/dagger/internal/codegen/ComponentBuilderTest.java b/javatests/dagger/internal/codegen/ComponentBuilderTest.java
index e5bc11202..d04c359a7 100644
--- a/javatests/dagger/internal/codegen/ComponentBuilderTest.java
+++ b/javatests/dagger/internal/codegen/ComponentBuilderTest.java
@@ -616,6 +616,36 @@ public void testBuilderBuildReturnsWrongTypeFails() {
         .onLineContaining("String build();");
   }
 
+  @Test
+  public void builderMethodTakesPrimitive() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface TestComponent {",
+            "  Object object();",
+            "",
+            "  @Component.Builder",
+            "  interface Builder {",
+            "    Builder primitive(long l);",
+            "    TestComponent build();",
+            "  }",
+            "}");
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            "@Component.Builder methods that are not annotated with @BindsInstance must take "
+                + "either a module or a component dependency, not a primitive")
+        .inFile(component)
+        .onLineContaining("primitive(long l);");
+  }
+
   @Test
   public void testInheritedBuilderBuildReturnsWrongTypeFails() {
     JavaFileObject componentFile =
