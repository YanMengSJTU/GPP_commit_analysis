diff --git a/.travis.yml b/.travis.yml
index 447fde716..c135891c9 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -36,7 +36,9 @@ before_install:
   - ln -s $(which g++-4.8) travis_bin/g++
   - export PATH="${PWD}/travis_bin:${PATH}"
 
-script: bazel test --test_output errors //...
+script:
+  - bazel test --test_output errors //...
+  - pushd examples && mvn compile && popd
 
 env:
   global:
@@ -44,7 +46,7 @@ env:
     - secure: LTzrlqcSNeZTOV52D3ibY9RBdxY4Yu8dUOYhAonrWLE+eDTzuoyCzcPw8pEcYVNUi1rG6Q7v3QBDTnBztsPoCbcN5tEGjw5cQEbfEzSTkWaNCFjncWn36cLwx9lgbF+5Db/L0mYJ36unDKUpKVC8AgOtxQibfv/ffugfxxj8ohY=
     - secure: PEdRiHTy+xVFPnlBwOhr7RVW/QIFSgd4hO0LESRBeF7KGIjxTZWtKPjnYrysZFm6tozMk6WBVJO6avOss0v7L64nemwpCnSspNYBa6pRGPgQ3rv/wgdPSzqDDmABmpPC18EHbUtF94KVdRX3Cr4kmwKQyD+YUKNRCY11Txt+xfo=
     - JDK_FOR_PUBLISHING: *jdk_for_publishing
-    - BAZEL_VERSION="0.8.0"
+    - BAZEL_VERSION="0.16.1"
 
 after_success:
   - util/generate-latest-docs.sh
diff --git a/BUILD b/BUILD
index a204e6ad3..cd0e40c54 100644
--- a/BUILD
+++ b/BUILD
@@ -19,13 +19,7 @@ package_group(
     packages = ["//..."],
 )
 
-load("//tools:javadoc.bzl", "javadoc_library")
-
-py_test(
-    name = "maven_sha1_test",
-    srcs = ["maven_sha1_test.py"],
-    data = ["WORKSPACE"],
-)
+load("@google_bazel_common//tools/javadoc:javadoc.bzl", "javadoc_library")
 
 java_library(
     name = "dagger_with_compiler",
@@ -55,15 +49,16 @@ android_library(
     ],
 )
 
-load("//tools:jarjar.bzl", "jarjar_library")
+load("@google_bazel_common//tools/jarjar:jarjar.bzl", "jarjar_library")
+
+SHADE_RULES = ["rule com.google.auto.common.** dagger.shaded.auto.common.@1"]
 
 jarjar_library(
     name = "shaded_compiler",
-    rules_file = "shade_rules.txt",
-    deps = [
+    jars = [
         "//java/dagger/internal/codegen:base",
         "//java/dagger/internal/codegen:binding",
-        "//java/dagger/internal/codegen:internal_validation",
+        "//java/dagger/internal/codegen:binding_graph_validation",
         "//java/dagger/internal/codegen:processor",
         "//java/dagger/internal/codegen:shared-with-spi",
         "//java/dagger/internal/codegen:validation",
@@ -71,15 +66,15 @@ jarjar_library(
         "//java/dagger/model:internal-proxies",
         "@com_google_auto_auto_common//jar",
     ],
+    rules = SHADE_RULES,
 )
 
 jarjar_library(
     name = "shaded_compiler_src",
-    rules_file = "merge_all_rules.txt",
-    deps = [
+    jars = [
         "//java/dagger/internal/codegen:libbase-src.jar",
         "//java/dagger/internal/codegen:libbinding-src.jar",
-        "//java/dagger/internal/codegen:libinternal_validation-src.jar",
+        "//java/dagger/internal/codegen:libbinding_graph_validation-src.jar",
         "//java/dagger/internal/codegen:libprocessor-src.jar",
         "//java/dagger/internal/codegen:libshared-with-spi-src.jar",
         "//java/dagger/internal/codegen:libvalidation-src.jar",
@@ -89,19 +84,18 @@ jarjar_library(
 
 jarjar_library(
     name = "shaded_spi",
-    rules_file = "shade_rules.txt",
-    deps = [
+    jars = [
         "//java/dagger/internal/codegen:shared-with-spi",
         "//java/dagger/model",
         "//java/dagger/spi",
         "@com_google_auto_auto_common//jar",
     ],
+    rules = SHADE_RULES,
 )
 
 jarjar_library(
     name = "shaded_spi_src",
-    rules_file = "merge_all_rules.txt",
-    deps = [
+    jars = [
         "//java/dagger/internal/codegen:libshared-with-spi-src.jar",
         "//java/dagger/model:libmodel-src.jar",
         "//java/dagger/spi:libspi-src.jar",
@@ -126,20 +120,20 @@ javadoc_library(
 
 jarjar_library(
     name = "shaded_android_processor",
-    rules_file = "shade_rules.txt",
-    deps = [
+    jars = [
         "//java/dagger/android/processor",
         "@com_google_auto_auto_common//jar",
     ],
+    rules = SHADE_RULES,
 )
 
 jarjar_library(
     name = "shaded_grpc_server_processor",
-    rules_file = "shade_rules.txt",
-    deps = [
+    jars = [
         "//java/dagger/grpc/server/processor",
         "@com_google_auto_auto_common//jar",
     ],
+    rules = SHADE_RULES,
 )
 
 # coalesced javadocs used for the gh-pages site
diff --git a/README.md b/README.md
index 16a47ba8f..13523c06c 100644
--- a/README.md
+++ b/README.md
@@ -1,6 +1,6 @@
 # Dagger 2
 
-[![Maven Central][mavenbadge-svg]][mavenbadge]
+[![Maven Central][mavenbadge-svg]][mavencentral]
 
 A fast dependency injector for Android and Java.
 
@@ -14,7 +14,7 @@ removing the traditional ObjectGraph/Injector in favor of user-specified
 
 This github project represents the Dagger 2 development stream.  The earlier
 [project page][square] (Square, Inc's repository) represents the earlier 1.0
-development stream. Both versions have benefitted from strong involvement from
+development stream. Both versions have benefited from strong involvement from
 Square, Google, and other contributors.
 
 Dagger is currently in active development, primarily internally at Google,
@@ -46,7 +46,7 @@ Given the following `WORKSPACE` definition, you can reference dagger via
 
 ```python
 http_archive(
-    name = "com_google_dagger"
+    name = "com_google_dagger",
     urls = ["https://github.com/google/dagger/archive/dagger-<version>.zip"],
 )
 ```
@@ -190,7 +190,7 @@ gradle.projectsEvaluated {
 
 If you do not use maven, gradle, ivy, or other build systems that consume
 maven-style binary artifacts, they can be downloaded directly via the
-[Maven Central Repository][mavensearch].
+[Maven Central Repository][mavencentral].
 
 Developer snapshots are available from Sonatype's
 [snapshot repository][dagger-snap], and are built on a clean build of
@@ -227,8 +227,7 @@ install a copy in your local maven repository with the version `LOCAL-SNAPSHOT`.
 [gaktalk]: https://www.youtube.com/watch?v=oK_XtfXPkqw
 [latestapi]: https://google.github.io/dagger/api/latest/
 [mavenbadge-svg]: https://maven-badges.herokuapp.com/maven-central/com.google.dagger/dagger/badge.svg
-[mavenbadge]: https://maven-badges.herokuapp.com/maven-central/com.google.dagger/dagger
-[mavensearch]: http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.google.dagger%22
+[mavencentral]: https://search.maven.org/artifact/com.google.dagger/dagger
 [project]: http://github.com/google/dagger/
 [proposal]: https://github.com/square/dagger/issues/366
 [square]: http://github.com/square/dagger/
diff --git a/WORKSPACE b/WORKSPACE
index fc67247a9..f27e36f2f 100644
--- a/WORKSPACE
+++ b/WORKSPACE
@@ -12,205 +12,12 @@
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
-android_sdk_repository(
-    name = "androidsdk",
-    api_level = 26,
-    build_tools_version = "26.0.2",
-)
-
-bind(
-    name = "android_sdk_for_testing",
-    actual = "@androidsdk//:files",
-)
-
-maven_jar(
-    name = "javax_annotation_jsr250_api",
-    artifact = "javax.annotation:jsr250-api:1.0",
-    sha1 = "5025422767732a1ab45d93abfea846513d742dcf",
-)
-
-maven_jar(
-    name = "com_google_code_findbugs_jsr305",
-    artifact = "com.google.code.findbugs:jsr305:3.0.1",
-    sha1 = "f7be08ec23c21485b9b5a1cf1654c2ec8c58168d",
-)
-
-maven_jar(
-    name = "javax_inject_javax_inject",
-    artifact = "javax.inject:javax.inject:1",
-    sha1 = "6975da39a7040257bd51d21a231b76c915872d38",
-)
-
-maven_jar(
-    name = "javax_inject_javax_inject_tck",
-    artifact = "javax.inject:javax.inject-tck:1",
-    sha1 = "bb0090d50219c265be40fcc8e034dae37fa7be99",
-)
-
-maven_jar(
-    name = "com_google_guava_guava",
-    artifact = "com.google.guava:guava:23.3-jre",
-    sha1 = "9124c2675a9de3ba953f66d62339cf62f8e1a143",
-)
-
-maven_jar(
-    name = "com_google_guava_guava_testlib",
-    artifact = "com.google.guava:guava-testlib:23.3-jre",
-    sha1 = "5dd4cc9849497042d84b782f8a1eed2b7dae290c",
-)
-
-maven_jar(
-    name = "com_google_errorprone_javac",
-    artifact = "com.google.errorprone:javac-shaded:9-dev-r4023-3",
-    sha1 = "72b688efd290280a0afde5f9892b0fde6f362d1d",
-)
-
-maven_jar(
-    name = "com_google_googlejavaformat_google_java_format",
-    artifact = "com.google.googlejavaformat:google-java-format:1.4",
-    sha1 = "c2f8925850e17caa6da0ed1891a9e9de9414c062",
-)
-
-maven_jar(
-    name = "com_google_auto_auto_common",
-    artifact = "com.google.auto:auto-common:0.10",
-    sha1 = "c8f153ebe04a17183480ab4016098055fb474364",
-)
-
-maven_jar(
-    name = "com_google_auto_factory_auto_factory",
-    artifact = "com.google.auto.factory:auto-factory:1.0-beta5",
-    sha1 = "78b93b2334d0e2fb0d65c00127d4dcce261a83fc",
-)
-
-maven_jar(
-    name = "com_google_auto_service_auto_service",
-    artifact = "com.google.auto.service:auto-service:1.0-rc4",
-    sha1 = "44954d465f3b9065388bbd2fc08a3eb8fd07917c",
-)
-
-maven_jar(
-    name = "com_google_auto_value_auto_value",
-    artifact = "com.google.auto.value:auto-value:1.4-rc1",
-    sha1 = "9347939002003a7a3c3af48271fc2c18734528a4",
-)
-
-maven_jar(
-    name = "com_google_errorprone_error_prone_annotations",
-    artifact = "com.google.errorprone:error_prone_annotations:2.1.3",
-    sha1 = "39b109f2cd352b2d71b52a3b5a1a9850e1dc304b",
-)
-
-maven_jar(
-    name = "junit_junit",
-    artifact = "junit:junit:4.11",
-    sha1 = "4e031bb61df09069aeb2bffb4019e7a5034a4ee0",
-)
-
-maven_jar(
-    name = "com_google_testing_compile_compile_testing",
-    artifact = "com.google.testing.compile:compile-testing:0.14",
-    sha1 = "3d9e885e2dfe4e6ceabc4402419abf3879c7429e",
-)
-
-maven_jar(
-    name = "org_mockito_mockito_core",
-    artifact = "org.mockito:mockito-core:1.9.5",
-    sha1 = "c3264abeea62c4d2f367e21484fbb40c7e256393",
-)
-
-maven_jar(
-    name = "org_hamcrest_hamcrest_core",
-    artifact = "org.hamcrest:hamcrest-core:1.3",
-    sha1 = "42a25dc3219429f0e5d060061f71acb49bf010a0",
-)
-
-maven_jar(
-    name = "org_objenesis_objenesis",
-    artifact = "org.objenesis:objenesis:1.0",
-    sha1 = "9b473564e792c2bdf1449da1f0b1b5bff9805704",
-)
-
-maven_jar(
-    name = "com_google_truth_truth",
-    artifact = "com.google.truth:truth:0.40",
-    sha1 = "0d74e716afec045cc4a178dbbfde2a8314ae5574",
-)
-
-maven_jar(
-    name = "com_google_truth_extensions_truth_java8_extension",
-    artifact = "com.google.truth.extensions:truth-java8-extension:0.40",
-    sha1 = "636e49d675bc28e0b3ae0edd077d6acbbb159166",
-)
-
-maven_jar(
-    name = "com_squareup_javapoet",
-    artifact = "com.squareup:javapoet:1.8.0",
-    sha1 = "e858dc62ef484048540d27d36f3ec2177a3fa9b1",
-)
-
-maven_jar(
-    name = "io_grpc_grpc_core",
-    artifact = "io.grpc:grpc-core:1.2.0",
-    sha1 = "f12a213e2b59a0615df2cc9bed35dc15fd2fee37",
-)
-
-maven_jar(
-    name = "io_grpc_grpc_netty",
-    artifact = "io.grpc:grpc-netty:1.2.0",
-    sha1 = "e2682d2dc052898f87433e7a6d03d104ef98df74",
-)
-
-maven_jar(
-    name = "io_grpc_grpc_context",
-    artifact = "io.grpc:grpc-context:1.2.0",
-    sha1 = "1932db544cbb427bc18f902c7ebbb3f7e44991df",
-)
-
-maven_jar(
-    name = "io_grpc_grpc_protobuf",
-    artifact = "io.grpc:grpc-protobuf:1.2.0",
-    sha1 = "2676852d2dbd20155d9b1a940a456eae5b7445f0",
-)
-
-maven_jar(
-    name = "io_grpc_grpc_stub",
-    artifact = "io.grpc:grpc-stub:1.2.0",
-    sha1 = "964dda53b3085bfd17c7aaf51495f9efc8bda36c",
-)
-
-maven_jar(
-    name = "io_grpc_grpc_all",
-    artifact = "io.grpc:grpc-all:1.2.0",
-    sha1 = "f32006a1245dfa2d68bf92a1b4cc01831889c95b",
-)
-
-maven_jar(
-    name = "com_google_protobuf_protobuf_java",
-    artifact = "com.google.protobuf:protobuf-java:3.5.0",
-    sha1 = "200fb936907fbab5e521d148026f6033d4aa539e",
-)
-
-http_archive(
-    name = "com_google_protobuf",
-    sha256 = "cef7f1b5a7c5fba672bec2a319246e8feba471f04dcebfe362d55930ee7c1c30",
-    strip_prefix = "protobuf-3.5.0",
-    urls = ["https://github.com/google/protobuf/archive/v3.5.0.zip"],
-)
-
 http_archive(
-    name = "com_google_protobuf_java",
-    sha256 = "cef7f1b5a7c5fba672bec2a319246e8feba471f04dcebfe362d55930ee7c1c30",
-    strip_prefix = "protobuf-3.5.0",
-    urls = ["https://github.com/google/protobuf/archive/v3.5.0.zip"],
+    name = "google_bazel_common",
+    strip_prefix = "bazel-common-aafb9b64f25f66b5ab6b9b991331160ef4130626",
+    urls = ["https://github.com/google/bazel-common/archive/aafb9b64f25f66b5ab6b9b991331160ef4130626.zip"],
 )
 
-load("//tools:jarjar.bzl", "jarjar_deps")
+load("@google_bazel_common//:workspace_defs.bzl", "google_common_workspace_rules")
 
-jarjar_deps()
-
-maven_jar(
-    name = "org_checkerframework_checker_compat_qual",
-    artifact = "org.checkerframework:checker-compat-qual:2.3.0",
-    sha1 = "69cb4fea55a9d89b8827d107f17c985cc1a76052",
-)
+google_common_workspace_rules()
diff --git a/examples/pom.xml b/examples/pom.xml
index c3361f89a..c12050d10 100644
--- a/examples/pom.xml
+++ b/examples/pom.xml
@@ -18,15 +18,16 @@
   <modelVersion>4.0.0</modelVersion>
 
   <parent>
-    <groupId>com.google.dagger</groupId>
-    <artifactId>dagger-parent</artifactId>
-    <version>HEAD-SNAPSHOT</version>
+    <groupId>org.sonatype.oss</groupId>
+    <artifactId>oss-parent</artifactId>
+    <version>9</version>
   </parent>
 
   <groupId>com.google.dagger.example</groupId>
   <artifactId>dagger-example-parent</artifactId>
   <packaging>pom</packaging>
   <name>Examples</name>
+  <version>2.17</version>
 
   <modules>
     <module>simple</module>
@@ -45,6 +46,11 @@
         <artifactId>dagger-compiler</artifactId>
         <version>${project.version}</version>
       </dependency>
+      <dependency>
+        <groupId>com.google.guava</groupId>
+        <artifactId>guava</artifactId>
+        <version>26.0-jre</version>
+      </dependency>
     </dependencies>
   </dependencyManagement>
 
diff --git a/examples/simple/pom.xml b/examples/simple/pom.xml
index 145c5e22b..ffc99dc15 100644
--- a/examples/simple/pom.xml
+++ b/examples/simple/pom.xml
@@ -20,7 +20,7 @@
   <parent>
     <groupId>com.google.dagger.example</groupId>
     <artifactId>dagger-example-parent</artifactId>
-    <version>HEAD-SNAPSHOT</version>
+    <version>2.17</version>
   </parent>
 
   <artifactId>simple</artifactId>
@@ -36,10 +36,24 @@
       <groupId>com.google.dagger</groupId>
       <artifactId>dagger</artifactId>
     </dependency>
-    <dependency>
-      <groupId>com.google.dagger</groupId>
-      <artifactId>dagger-compiler</artifactId>
-      <optional>true</optional>
-    </dependency>
   </dependencies>
+
+  <build>
+    <plugins>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-compiler-plugin</artifactId>
+        <version>3.6.1</version>
+        <configuration>
+          <annotationProcessorPaths>
+            <path>
+              <groupId>com.google.dagger</groupId>
+              <artifactId>dagger-compiler</artifactId>
+              <version>${project.version}</version>
+            </path>
+          </annotationProcessorPaths>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
 </project>
diff --git a/gwt/BUILD b/gwt/BUILD
index b348e06b3..da730138f 100644
--- a/gwt/BUILD
+++ b/gwt/BUILD
@@ -17,8 +17,34 @@
 
 package(default_visibility = ["//:src"])
 
+load("//tools:maven.bzl", "pom_file", "POM_VERSION")
+
 java_library(
     name = "gwt",
     resource_strip_prefix = "gwt/",
     resources = glob(["**/*.gwt.xml"]),
+    tags = ["maven_coordinates=com.google.dagger:dagger-gwt:" + POM_VERSION],
+    exports = [
+        ":manual_deps",
+        "//java/dagger:core",
+    ],
+)
+
+java_library(
+    name = "manual_deps",
+    tags = [
+        "maven_coordinates=com.google.dagger:dagger:%s:jar:sources" % POM_VERSION,
+        "maven_coordinates=javax.inject:javax.inject:1:jar:sources",
+    ],
+    visibility = ["//visibility:private"],
+)
+
+pom_file(
+    name = "pom",
+    artifact_id = "dagger-gwt",
+    artifact_name = "Dagger GWT",
+    targets = [
+        ":gwt",
+        ":manual_deps",
+    ],
 )
diff --git a/java/dagger/BUILD b/java/dagger/BUILD
index 9b980d416..5f5cfbf67 100644
--- a/java/dagger/BUILD
+++ b/java/dagger/BUILD
@@ -22,13 +22,22 @@ load(
     "DOCLINT_HTML_AND_SYNTAX",
     "SOURCE_7_TARGET_7",
 )
+load("//tools:maven.bzl", "POM_VERSION", "pom_file")
 
 java_library(
     name = "core",
     srcs = glob(["**/*.java"]),
     javacopts = SOURCE_7_TARGET_7 + DOCLINT_HTML_AND_SYNTAX,
-    exports = ["//third_party:jsr330_inject"],
-    deps = ["//third_party:jsr330_inject"],
+    tags = ["maven_coordinates=com.google.dagger:dagger:" + POM_VERSION],
+    exports = ["@google_bazel_common//third_party/java/jsr330_inject"],
+    deps = ["@google_bazel_common//third_party/java/jsr330_inject"],
+)
+
+pom_file(
+    name = "pom",
+    artifact_id = "dagger",
+    artifact_name = "Dagger",
+    targets = [":core"],
 )
 
 filegroup(
@@ -36,12 +45,12 @@ filegroup(
     srcs = glob(["**/*"]),
 )
 
-load("//tools:javadoc.bzl", "javadoc_library")
+load("@google_bazel_common//tools/javadoc:javadoc.bzl", "javadoc_library")
 
 javadoc_library(
     name = "core-javadoc",
     srcs = [":javadoc-srcs"],
     exclude_packages = ["dagger.internal"],
     root_packages = ["dagger"],
-    deps = ["//third_party:jsr330_inject"],
+    deps = ["@google_bazel_common//third_party/java/jsr330_inject"],
 )
diff --git a/java/dagger/android/AndroidInjectionKey.java b/java/dagger/android/AndroidInjectionKey.java
new file mode 100644
index 000000000..d4a5d72c2
--- /dev/null
+++ b/java/dagger/android/AndroidInjectionKey.java
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android;
+
+import static java.lang.annotation.ElementType.METHOD;
+
+import dagger.MapKey;
+import dagger.internal.Beta;
+import java.lang.annotation.Documented;
+import java.lang.annotation.Target;
+
+/**
+ * {@link MapKey} annotation to key {@link AndroidInjector.Factory} bindings. The {@linkplain
+ * #value() value} of the annotation is the canonical name of the class that will be passed to
+ * {@link AndroidInjector#inject(Object)}.
+ *
+ * <p>All key strings will be obfuscated by ProGuard/R8/AppReduce if the named class is obfuscated.
+ *
+ * <p>
+ * You should only use this annotation if you are using a version of ProGuard/R8/AppReduce that
+ * supports the {@code -identifiernamestring} flag.
+ */
+@Beta
+@MapKey
+@Target(METHOD)
+@Documented
+public @interface AndroidInjectionKey {
+  /** The fully qualified class name of the type to be injected. */
+  String value();
+}
diff --git a/java/dagger/android/AndroidInjectionModule.java b/java/dagger/android/AndroidInjectionModule.java
index 224e07f71..05f1adae3 100644
--- a/java/dagger/android/AndroidInjectionModule.java
+++ b/java/dagger/android/AndroidInjectionModule.java
@@ -38,23 +38,42 @@
   abstract Map<Class<? extends Activity>, AndroidInjector.Factory<? extends Activity>>
       activityInjectorFactories();
 
+  @Multibinds
+  abstract Map<String, AndroidInjector.Factory<? extends Activity>>
+      activityInjectorFactoriesWithStringKeys();
+
   @Multibinds
   abstract Map<Class<? extends Fragment>, AndroidInjector.Factory<? extends Fragment>>
       fragmentInjectorFactories();
 
+  @Multibinds
+  abstract Map<String, AndroidInjector.Factory<? extends Fragment>>
+      fragmentInjectorFactoriesWithStringKeys();
+
   @Multibinds
   abstract Map<Class<? extends Service>, AndroidInjector.Factory<? extends Service>>
       serviceInjectorFactories();
 
+  @Multibinds
+  abstract Map<String, AndroidInjector.Factory<? extends Service>>
+      serviceInjectorFactoriesWithStringKeys();
+
   @Multibinds
   abstract Map<
           Class<? extends BroadcastReceiver>, AndroidInjector.Factory<? extends BroadcastReceiver>>
       broadcastReceiverInjectorFactories();
 
   @Multibinds
-  abstract Map<
-          Class<? extends ContentProvider>, AndroidInjector.Factory<? extends ContentProvider>>
+  abstract Map<String, AndroidInjector.Factory<? extends BroadcastReceiver>>
+      broadcastReceiverInjectorFactoriesWithStringKeys();
+
+  @Multibinds
+  abstract Map<Class<? extends ContentProvider>, AndroidInjector.Factory<? extends ContentProvider>>
       contentProviderInjectorFactories();
 
+  @Multibinds
+  abstract Map<String, AndroidInjector.Factory<? extends ContentProvider>>
+      contentProviderInjectorFactoriesWithStringKeys();
+
   private AndroidInjectionModule() {}
 }
diff --git a/java/dagger/android/BUILD b/java/dagger/android/BUILD
index 8f38cae11..6dfa1c5e3 100644
--- a/java/dagger/android/BUILD
+++ b/java/dagger/android/BUILD
@@ -23,10 +23,14 @@ load(
     "DOCLINT_REFERENCES",
     "SOURCE_7_TARGET_7",
 )
+load("//tools:maven.bzl", "pom_file", "POM_VERSION")
 
 # Work around b/70476182 which prevents Kythe from connecting :producers to the .java files it
 # contains.
-SRCS = glob(["*.java"])
+SRCS = glob([
+    "*.java",
+    "internal/*.java",
+])
 
 filegroup(
     name = "android-srcs",
@@ -39,20 +43,49 @@ android_library(
     javacopts = SOURCE_7_TARGET_7 + DOCLINT_HTML_AND_SYNTAX + DOCLINT_REFERENCES,
     manifest = "AndroidManifest.xml",
     proguard_specs = ["proguard.cfg"],
+    tags = ["maven_coordinates=com.google.dagger:dagger-android:" + POM_VERSION],
     deps = [
+        ":manual-maven-deps",
         "//:dagger_with_compiler",
-        "//third_party:auto_value",
-        "//third_party:error_prone_annotations",
+        "@google_bazel_common//third_party/java/auto:value",
+        "@google_bazel_common//third_party/java/error_prone:annotations",
+    ],
+)
+
+# Our pom.xml generator does not have a way to add manual maven deps. This target exports the
+# targets that don't have the necessary maven_coordinates tags.
+android_library(
+    name = "manual-maven-deps",
+    tags = ["maven_coordinates=com.android.support:support-annotations:25.0.0"],
+    visibility = ["//visibility:private"],
+    exports = [
         "@androidsdk//com.android.support:support-annotations-25.0.0",
     ],
 )
 
-load("//tools:javadoc.bzl", "javadoc_library")
+pom_file(
+    name = "pom",
+    artifact_id = "dagger-android",
+    artifact_name = "Dagger Android",
+    packaging = "aar",
+    targets = [":android"],
+)
+
+# b/37741866 and https://github.com/google/dagger/issues/715
+pom_file(
+    name = "jarimpl-pom",
+    artifact_id = "dagger-android-jarimpl",
+    artifact_name = "Dagger Android",
+    targets = [":android"],
+)
+
+load("@google_bazel_common//tools/javadoc:javadoc.bzl", "javadoc_library")
 
 javadoc_library(
     name = "android-javadoc",
     srcs = [":android-srcs"],
     android_api_level = 26,
+    exclude_packages = ["dagger.android.internal"],
     root_packages = ["dagger.android"],
     deps = [":android"],
 )
diff --git a/java/dagger/android/DaggerFragment.java b/java/dagger/android/DaggerFragment.java
index df0b0d6d5..c95c457ce 100644
--- a/java/dagger/android/DaggerFragment.java
+++ b/java/dagger/android/DaggerFragment.java
@@ -25,8 +25,13 @@
  * A {@link Fragment} that injects its members in {@link #onAttach(Context)} and can be used to
  * inject child {@link Fragment}s attached to it. Note that when this fragment gets reattached, its
  * members will be injected again.
+ *
+ * @deprecated Framework fragments are deprecated in Android P; prefer {@code
+ *     dagger.android.support.DaggerFragment} to use a support-library-friendly {@code
+ *     dagger.android} fragment implementation.
  */
 @Beta
+@Deprecated
 public abstract class DaggerFragment extends Fragment implements HasFragmentInjector {
 
   @Inject DispatchingAndroidInjector<Fragment> childFragmentInjector;
diff --git a/java/dagger/android/DispatchingAndroidInjector.java b/java/dagger/android/DispatchingAndroidInjector.java
index 3c9b7775b..9b011dd13 100644
--- a/java/dagger/android/DispatchingAndroidInjector.java
+++ b/java/dagger/android/DispatchingAndroidInjector.java
@@ -16,6 +16,7 @@
 
 package dagger.android;
 
+import static dagger.internal.DaggerCollections.newLinkedHashMapWithExpectedSize;
 import static dagger.internal.Preconditions.checkNotNull;
 
 import android.app.Activity;
@@ -26,6 +27,7 @@
 import java.util.Collections;
 import java.util.List;
 import java.util.Map;
+import java.util.Map.Entry;
 import javax.inject.Inject;
 import javax.inject.Provider;
 
@@ -47,13 +49,39 @@
       "No injector factory bound for Class<%1$s>. Injector factories were bound for supertypes "
           + "of %1$s: %2$s. Did you mean to bind an injector factory for the subtype?";
 
-  private final Map<Class<? extends T>, Provider<AndroidInjector.Factory<? extends T>>>
-      injectorFactories;
+  private final Map<String, Provider<AndroidInjector.Factory<? extends T>>> injectorFactories;
 
   @Inject
   DispatchingAndroidInjector(
-      Map<Class<? extends T>, Provider<AndroidInjector.Factory<? extends T>>> injectorFactories) {
-    this.injectorFactories = injectorFactories;
+      Map<Class<? extends T>, Provider<Factory<? extends T>>> injectorFactoriesWithClassKeys,
+      Map<String, Provider<Factory<? extends T>>> injectorFactoriesWithStringKeys) {
+    this.injectorFactories = merge(injectorFactoriesWithClassKeys, injectorFactoriesWithStringKeys);
+  }
+
+  /**
+   * Merges the two maps into one by transforming the values of the {@code classKeyedMap} with
+   * {@link Class#getName()}.
+   *
+   * <p>An SPI plugin verifies the logical uniqueness of the keysets of these two maps so we're
+   * assured there's no overlap.
+   *
+   * <p>Ideally we could achieve this with a generic {@code @Provides} method, but we'd need to have
+   * <i>N</i> modules that each extend one base module.
+   */
+  private static <C, V> Map<String, V> merge(
+      Map<Class<? extends C>, V> classKeyedMap, Map<String, V> stringKeyedMap) {
+    if (classKeyedMap.isEmpty()) {
+      return stringKeyedMap;
+    }
+
+    Map<String, V> merged =
+        newLinkedHashMapWithExpectedSize(classKeyedMap.size() + stringKeyedMap.size());
+    merged.putAll(stringKeyedMap);
+    for (Entry<Class<? extends C>, V> entry : classKeyedMap.entrySet()) {
+      merged.put(entry.getKey().getName(), entry.getValue());
+    }
+
+    return Collections.unmodifiableMap(merged);
   }
 
   /**
@@ -66,7 +94,7 @@
   @CanIgnoreReturnValue
   public boolean maybeInject(T instance) {
     Provider<AndroidInjector.Factory<? extends T>> factoryProvider =
-        injectorFactories.get(instance.getClass());
+        injectorFactories.get(instance.getClass().getName());
     if (factoryProvider == null) {
       return false;
     }
@@ -119,13 +147,12 @@ public void inject(T instance) {
 
   /** Returns an error message with the class names that are supertypes of {@code instance}. */
   private String errorMessageSuggestions(T instance) {
-    List<String> suggestions = new ArrayList<String>();
-    for (Class<? extends T> activityClass : injectorFactories.keySet()) {
-      if (activityClass.isInstance(instance)) {
-        suggestions.add(activityClass.getCanonicalName());
+    List<String> suggestions = new ArrayList<>();
+    for (Class<?> clazz = instance.getClass(); clazz != null; clazz = clazz.getSuperclass()) {
+      if (injectorFactories.containsKey(clazz.getCanonicalName())) {
+        suggestions.add(clazz.getCanonicalName());
       }
     }
-    Collections.sort(suggestions);
 
     return suggestions.isEmpty()
         ? String.format(NO_SUPERTYPES_BOUND_FORMAT, instance.getClass().getCanonicalName())
diff --git a/java/dagger/android/internal/AndroidInjectionKeys.java b/java/dagger/android/internal/AndroidInjectionKeys.java
new file mode 100644
index 000000000..f30b92cdd
--- /dev/null
+++ b/java/dagger/android/internal/AndroidInjectionKeys.java
@@ -0,0 +1,37 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.internal;
+
+/**
+ * An internal implementation detail of Dagger's generated code. This is not guaranteed to remain
+ * consistent from version to version.
+ */
+public final class AndroidInjectionKeys {
+  /**
+   * Accepts the fully qualified name of a class that is injected with {@code dagger.android}.
+   *
+   * <p>From a runtime perspective, this method does nothing except return its single argument. It
+   * is used as a signal to bytecode shrinking tools that its argument should be rewritten if it
+   * corresponds to a class that has been obfuscated/relocated. Once it is done so, it is expected
+   * that the argument will be inlined and this method will go away.
+   */
+  public static String of(String mapKey) {
+    return mapKey;
+  }
+
+  private AndroidInjectionKeys() {}
+}
diff --git a/java/dagger/android/processor/AndroidInjectorDescriptor.java b/java/dagger/android/processor/AndroidInjectorDescriptor.java
index 1deb3c3fd..1e0d93f6a 100644
--- a/java/dagger/android/processor/AndroidInjectorDescriptor.java
+++ b/java/dagger/android/processor/AndroidInjectorDescriptor.java
@@ -78,8 +78,8 @@
   /** The {@link Module} that contains the {@link ContributesAndroidInjector} method. */
   abstract ClassName enclosingModule();
 
-  /** Simple name of the {@link ContributesAndroidInjector} method. */
-  abstract String methodName();
+  /** The method annotated with {@link ContributesAndroidInjector}. */
+  abstract ExecutableElement method();
 
   @AutoValue.Builder
   abstract static class Builder {
@@ -95,7 +95,7 @@
 
     abstract Builder enclosingModule(ClassName enclosingModule);
 
-    abstract Builder methodName(String methodName);
+    abstract Builder method(ExecutableElement method);
 
     abstract AndroidInjectorDescriptor build();
   }
@@ -126,8 +126,8 @@
         reporter.reportError("@ContributesAndroidInjector methods cannot have parameters");
       }
 
-      AndroidInjectorDescriptor.Builder builder = new AutoValue_AndroidInjectorDescriptor.Builder();
-      builder.methodName(method.getSimpleName().toString());
+      AndroidInjectorDescriptor.Builder builder =
+          new AutoValue_AndroidInjectorDescriptor.Builder().method(method);
       TypeElement enclosingElement = MoreElements.asType(method.getEnclosingElement());
       if (!isAnnotationPresent(enclosingElement, Module.class)) {
         reporter.reportError("@ContributesAndroidInjector methods must be in a @Module");
diff --git a/java/dagger/android/processor/AndroidMapKeyValidator.java b/java/dagger/android/processor/AndroidMapKeyValidator.java
index a6c8a80f0..4084ff4e2 100644
--- a/java/dagger/android/processor/AndroidMapKeyValidator.java
+++ b/java/dagger/android/processor/AndroidMapKeyValidator.java
@@ -17,11 +17,11 @@
 package dagger.android.processor;
 
 import static com.google.auto.common.AnnotationMirrors.getAnnotatedAnnotations;
-import static com.google.auto.common.AnnotationMirrors.getAnnotationValue;
 import static com.google.auto.common.MoreElements.getAnnotationMirror;
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static dagger.android.processor.AndroidMapKeys.annotationsAndFrameworkTypes;
+import static dagger.android.processor.AndroidMapKeys.injectedTypeFromMapKey;
 
 import com.google.auto.common.BasicAnnotationProcessor.ProcessingStep;
 import com.google.auto.common.MoreElements;
@@ -29,6 +29,7 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.SetMultimap;
 import dagger.Binds;
+import dagger.android.AndroidInjectionKey;
 import dagger.android.AndroidInjector;
 import java.lang.annotation.Annotation;
 import java.util.Set;
@@ -62,7 +63,10 @@
 
   @Override
   public Set<? extends Class<? extends Annotation>> annotations() {
-    return annotationsAndFrameworkTypes(elements).keySet();
+    return ImmutableSet.<Class<? extends Annotation>>builder()
+        .addAll(annotationsAndFrameworkTypes(elements).keySet())
+        .add(AndroidInjectionKey.class)
+        .build();
   }
 
   @Override
@@ -84,7 +88,7 @@ private void validateMethod(Class<? extends Annotation> annotation, ExecutableEl
       return;
     }
 
-    TypeMirror frameworkType = annotationsAndFrameworkTypes(elements).get(annotation);
+    TypeMirror frameworkType = frameworkTypeForMapKey(method, annotation);
 
     if (!getAnnotatedAnnotations(method, Scope.class).isEmpty()) {
       SuppressWarnings suppressedWarnings = method.getAnnotation(SuppressWarnings.class);
@@ -102,11 +106,16 @@ private void validateMethod(Class<? extends Annotation> annotation, ExecutableEl
 
     DeclaredType intendedReturnType = injectorFactoryOf(types.getWildcardType(frameworkType, null));
     if (!MoreTypes.equivalence().equivalent(returnType, intendedReturnType)) {
+      String subject =
+          annotation.equals(AndroidInjectionKey.class)
+              ? method.toString()
+              : String.format("@%s methods", annotation.getCanonicalName());
+
       messager.printMessage(
           Kind.ERROR,
           String.format(
-              "@%s methods should bind %s, not %s. See https://google.github.io/dagger/android",
-              annotation.getCanonicalName(), intendedReturnType, returnType),
+              "%s should bind %s, not %s. See https://google.github.io/dagger/android",
+              subject, intendedReturnType, returnType),
           method);
     }
 
@@ -135,16 +144,30 @@ private void validateMapKeyMatchesBindsParameter(
       Class<? extends Annotation> annotation, ExecutableElement method) {
     TypeMirror parameterType = getOnlyElement(method.getParameters()).asType();
     AnnotationMirror annotationMirror = getAnnotationMirror(method, annotation).get();
-    TypeMirror mapKeyValue = (TypeMirror) getAnnotationValue(annotationMirror, "value").getValue();
-    if (!types.isAssignable(parameterType, injectorFactoryOf(mapKeyValue))) {
+    TypeMirror mapKeyType =
+        elements.getTypeElement(injectedTypeFromMapKey(annotationMirror).get()).asType();
+    if (!types.isAssignable(parameterType, injectorFactoryOf(mapKeyType))) {
       messager.printMessage(
           Kind.ERROR,
-          String.format("%s does not implement AndroidInjector<%s>", parameterType, mapKeyValue),
+          String.format("%s does not implement AndroidInjector<%s>", parameterType, mapKeyType),
           method,
           annotationMirror);
     }
   }
 
+  private TypeMirror frameworkTypeForMapKey(
+      ExecutableElement method, Class<? extends Annotation> annotation) {
+    AnnotationMirror annotationMirror = getAnnotationMirror(method, annotation).get();
+    TypeMirror mapKeyType =
+        elements.getTypeElement(injectedTypeFromMapKey(annotationMirror).get()).asType();
+    return annotationsAndFrameworkTypes(elements)
+        .values()
+        .stream()
+        .filter(frameworkType -> types.isAssignable(mapKeyType, frameworkType))
+        .findFirst()
+        .get();
+  }
+
   /** Returns a {@link DeclaredType} for {@code AndroidInjector.Factory<implementationType>}. */
   private DeclaredType injectorFactoryOf(TypeMirror implementationType) {
     return types.getDeclaredType(factoryElement(), implementationType);
diff --git a/java/dagger/android/processor/AndroidMapKeys.java b/java/dagger/android/processor/AndroidMapKeys.java
index 61eee8e75..64682070a 100644
--- a/java/dagger/android/processor/AndroidMapKeys.java
+++ b/java/dagger/android/processor/AndroidMapKeys.java
@@ -16,6 +16,7 @@
 
 package dagger.android.processor;
 
+import static com.google.auto.common.AnnotationMirrors.getAnnotationValue;
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static java.util.stream.Collectors.toMap;
@@ -25,9 +26,12 @@
 import com.google.auto.common.MoreTypes;
 import com.google.common.collect.ImmutableMap;
 import dagger.MapKey;
+import dagger.android.AndroidInjectionKey;
 import java.lang.annotation.Annotation;
 import java.util.List;
+import java.util.Optional;
 import java.util.stream.Stream;
+import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.TypeMirror;
@@ -50,12 +54,17 @@
                 elements.getPackageElement("dagger.android.support"))
             .filter(packageElement -> packageElement != null)
             .flatMap(packageElement -> typesIn(packageElement.getEnclosedElements()).stream())
+            .filter(AndroidMapKeys::isNotAndroidInjectionKey)
             .filter(type -> isAnnotationPresent(type, MapKey.class))
             .filter(mapKey -> mapKey.getAnnotation(MapKey.class).unwrapValue())
             .flatMap(AndroidMapKeys::classForAnnotationElement)
             .collect(toMap(key -> key, key -> mapKeyValue(key, elements))));
   }
 
+  private static boolean isNotAndroidInjectionKey(TypeElement type) {
+    return !type.getQualifiedName().contentEquals(AndroidInjectionKey.class.getCanonicalName());
+  }
+
   private static Stream<Class<? extends Annotation>> classForAnnotationElement(TypeElement type) {
     try {
       @SuppressWarnings("unchecked")
@@ -75,4 +84,21 @@ private static TypeMirror mapKeyValue(Class<? extends Annotation> annotation, El
     return ((WildcardType) getOnlyElement(MoreTypes.asDeclared(returnType).getTypeArguments()))
         .getExtendsBound();
   }
+
+  /**
+   * If {@code mapKey} is {@link AndroidInjectionKey}, returns the string value for the map key. If
+   * it's {@link dagger.android.ActivityKey} or one of the other class-based keys, returns the
+   * fully-qualified class name of the annotation value. Otherwise returns {@link Optional#empty()}.
+   */
+  static Optional<String> injectedTypeFromMapKey(AnnotationMirror mapKey) {
+    Object mapKeyClass = getAnnotationValue(mapKey, "value").getValue();
+    if (mapKeyClass instanceof String) {
+      return Optional.of((String) mapKeyClass);
+    } else if (mapKeyClass instanceof TypeMirror) {
+      TypeElement type = MoreTypes.asTypeElement((TypeMirror) mapKeyClass);
+      return Optional.of(type.getQualifiedName().toString());
+    } else {
+      return Optional.empty();
+    }
+  }
 }
diff --git a/java/dagger/android/processor/AndroidProcessor.java b/java/dagger/android/processor/AndroidProcessor.java
index 5db7fabeb..c46817018 100644
--- a/java/dagger/android/processor/AndroidProcessor.java
+++ b/java/dagger/android/processor/AndroidProcessor.java
@@ -16,13 +16,23 @@
 
 package dagger.android.processor;
 
+import static javax.tools.Diagnostic.Kind.ERROR;
+import static javax.tools.StandardLocation.CLASS_OUTPUT;
+
 import com.google.auto.common.BasicAnnotationProcessor;
 import com.google.auto.service.AutoService;
+import com.google.common.base.Ascii;
+import com.google.common.base.Joiner;
 import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
 import com.google.googlejavaformat.java.filer.FormattingFiler;
+import java.io.IOException;
+import java.io.Writer;
+import java.util.Set;
 import javax.annotation.processing.Filer;
 import javax.annotation.processing.Messager;
 import javax.annotation.processing.Processor;
+import javax.annotation.processing.RoundEnvironment;
 import javax.lang.model.SourceVersion;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
@@ -30,9 +40,22 @@
 /**
  * An {@linkplain javax.annotation.processing.Processor annotation processor} to verify usage of
  * {@code dagger.android} code.
+ *
+ * <p>Additionally, if {@code -Adagger.android.experimentalUseStringKeys} is passed to the
+ * compilation, a file will be generated to support obfuscated injected Android types used with
+ * {@code @AndroidInjectionKey}. The fact that this is generated is deliberate: not all versions of
+ * ProGuard/R8 support {@code -identifiernamestring}, so we can't include a ProGuard file in the
+ * dagger-android artifact Instead, we generate the file in {@code META-INF/proguard} only when
+ * users enable the flag. They should only be enabling it if their shrinker supports those files,
+ * and any version that does so will also support {@code -identifiernamestring}. This was added to
+ * R8 in <a href="https://r8.googlesource.com/r8/+/389123dfcc11e6dda0eec31ab62e1b7eb0da80d2">May
+ * 2018</a>.
  */
 @AutoService(Processor.class)
 public final class AndroidProcessor extends BasicAnnotationProcessor {
+  private static final String FLAG_EXPERIMENTAL_USE_STRING_KEYS =
+      "dagger.android.experimentalUseStringKeys";
+
   @Override
   protected Iterable<? extends ProcessingStep> initSteps() {
     Filer filer = new FormattingFiler(processingEnv.getFiler());
@@ -44,11 +67,61 @@
         new AndroidMapKeyValidator(elements, types, messager),
         new ContributesAndroidInjectorGenerator(
             new AndroidInjectorDescriptor.Validator(types, elements, messager),
+            useStringKeys(),
             filer,
             elements,
             processingEnv.getSourceVersion()));
   }
 
+  private boolean useStringKeys() {
+    if (!processingEnv.getOptions().containsKey(FLAG_EXPERIMENTAL_USE_STRING_KEYS)) {
+      return false;
+    }
+    String flagValue = processingEnv.getOptions().get(FLAG_EXPERIMENTAL_USE_STRING_KEYS);
+    if (flagValue == null || Ascii.equalsIgnoreCase(flagValue, "true")) {
+      return true;
+    } else if (Ascii.equalsIgnoreCase(flagValue, "false")) {
+      return false;
+    } else {
+      processingEnv
+          .getMessager()
+          .printMessage(
+              ERROR,
+              String.format(
+                  "Unknown flag value: %s. %s must be set to either 'true' or 'false'.",
+                  flagValue, FLAG_EXPERIMENTAL_USE_STRING_KEYS));
+      return false;
+    }
+  }
+
+  @Override
+  protected void postRound(RoundEnvironment roundEnv) {
+    if (roundEnv.processingOver() && useStringKeys()) {
+      try (Writer writer = createProguardFile()){
+        writer.write(
+            Joiner.on("\n")
+                .join(
+                    "-identifiernamestring class dagger.android.internal.AndroidInjectionKeys {",
+                    "  java.lang.String of(java.lang.String);",
+                    "}"));
+      } catch (IOException e) {
+        e.printStackTrace();
+      }
+    }
+  }
+
+  private Writer createProguardFile() throws IOException {
+    return processingEnv
+        .getFiler()
+        .createResource(CLASS_OUTPUT, "", "META-INF/proguard/dagger.android.AndroidInjectionKeys")
+        .openWriter();
+  }
+
+  @Override
+  public Set<String> getSupportedOptions() {
+    return ImmutableSet.of(FLAG_EXPERIMENTAL_USE_STRING_KEYS);
+  }
+
   @Override
   public SourceVersion getSupportedSourceVersion() {
     return SourceVersion.latestSupported();
diff --git a/java/dagger/android/processor/BUILD b/java/dagger/android/processor/BUILD
index e764e4bc8..7b2948fc7 100644
--- a/java/dagger/android/processor/BUILD
+++ b/java/dagger/android/processor/BUILD
@@ -22,6 +22,8 @@ load(
     "DOCLINT_HTML_AND_SYNTAX",
     "DOCLINT_REFERENCES",
 )
+load("//tools:maven.bzl", "pom_file", "POM_VERSION")
+load("//tools:simple_jar.bzl", "simple_jar")
 
 filegroup(
     name = "srcs",
@@ -32,18 +34,53 @@ java_library(
     name = "processor",
     srcs = [":srcs"],
     javacopts = DOCLINT_HTML_AND_SYNTAX + DOCLINT_REFERENCES,
+    resource_jars = [":processor_manifest_files.jar"],
+    tags = ["maven_coordinates=com.google.dagger:dagger-android-processor:" + POM_VERSION],
     deps = [
-        "//third_party:guava",
-        "//third_party:auto_service",
-        "//third_party:auto_value",
-        "//third_party:auto_common",
-        "//third_party:javapoet",
-        "//third_party:google_java_format",
+        "@google_bazel_common//third_party/java/guava",
+        "@google_bazel_common//third_party/java/auto:service",
+        "@google_bazel_common//third_party/java/auto:value",
+        "@google_bazel_common//third_party/java/auto:common",
+        "@google_bazel_common//third_party/java/javapoet",
+        "@google_bazel_common//third_party/java/google_java_format",
         "//java/dagger:core",
+        "//java/dagger/model",
+        "//java/dagger/spi",
         # https://github.com/bazelbuild/bazel/issues/2517
+        ":dagger-android-jars",
+    ],
+)
+
+# https://github.com/bazelbuild/bazel/issues/2517
+# This target serves two (related) purposes:
+# 1. Bazel does not allow a java_library to depend on an android_library, even if that java_library
+# will be used in a java_plugin.
+# 2. It stores the metadata for the "jarimpl" targets that we use to work-around Gradle not loading
+# aar artifacts that are declared as deps of an annotation processor. Our pom.xml generator reads
+# the tags and includes them apppropriately.
+java_import(
+    name = "dagger-android-jars",
+    jars = [
         "//java/dagger/android:libandroid.jar",
         "//java/dagger/android/support:libsupport.jar",
     ],
+    tags = [
+        "maven_coordinates=com.google.dagger:dagger-android-jarimpl:" + POM_VERSION,
+        "maven_coordinates=com.google.dagger:dagger-android-support-jarimpl:" + POM_VERSION,
+    ],
+    visibility = ["//visibility:private"],
+)
+
+simple_jar(
+    name = "processor_manifest_files",
+    srcs = glob(["META-INF/**"]),
+)
+
+pom_file(
+    name = "pom",
+    artifact_id = "dagger-android-processor",
+    artifact_name = "Dagger Android Processor",
+    targets = [":processor"],
 )
 
 java_plugin(
@@ -53,7 +90,7 @@ java_plugin(
     deps = [":processor"],
 )
 
-load("//tools:javadoc.bzl", "javadoc_library")
+load("@google_bazel_common//tools/javadoc:javadoc.bzl", "javadoc_library")
 
 javadoc_library(
     name = "processor-javadoc",
diff --git a/java/dagger/android/processor/ContributesAndroidInjectorGenerator.java b/java/dagger/android/processor/ContributesAndroidInjectorGenerator.java
index 2d1023abc..4f022c229 100644
--- a/java/dagger/android/processor/ContributesAndroidInjectorGenerator.java
+++ b/java/dagger/android/processor/ContributesAndroidInjectorGenerator.java
@@ -46,6 +46,7 @@
 import dagger.Module;
 import dagger.Subcomponent;
 import dagger.Subcomponent.Builder;
+import dagger.android.AndroidInjectionKey;
 import dagger.android.AndroidInjector;
 import dagger.android.ContributesAndroidInjector;
 import dagger.android.processor.AndroidInjectorDescriptor.Validator;
@@ -65,12 +66,18 @@
   private final AndroidInjectorDescriptor.Validator validator;
   private final Filer filer;
   private final Elements elements;
+  private final boolean useStringKeys;
   private final SourceVersion sourceVersion;
 
   ContributesAndroidInjectorGenerator(
-      Validator validator, Filer filer, Elements elements, SourceVersion sourceVersion) {
-    this.filer = filer;
+      Validator validator,
+      boolean useStringKeys,
+      Filer filer,
+      Elements elements,
+      SourceVersion sourceVersion) {
     this.validator = validator;
+    this.useStringKeys = useStringKeys;
+    this.filer = filer;
     this.elements = elements;
     this.sourceVersion = sourceVersion;
   }
@@ -97,7 +104,7 @@ private void generate(AndroidInjectorDescriptor descriptor) {
             .peerClass(
                 Joiner.on('_').join(descriptor.enclosingModule().simpleNames())
                     + "_"
-                    + LOWER_CAMEL.to(UPPER_CAMEL, descriptor.methodName()));
+                    + LOWER_CAMEL.to(UPPER_CAMEL, descriptor.method().getSimpleName().toString()));
 
     String baseName = descriptor.injectedType().simpleName();
     ClassName subcomponentName = moduleName.nestedClass(baseName + "Subcomponent");
@@ -105,6 +112,7 @@ private void generate(AndroidInjectorDescriptor descriptor) {
 
     TypeSpec.Builder module =
         classBuilder(moduleName)
+            .addOriginatingElement(descriptor.method())
             .addAnnotation(
                 AnnotationSpec.builder(Module.class)
                     .addMember("subcomponents", "$T.class", subcomponentName)
@@ -131,10 +139,7 @@ private MethodSpec bindAndroidInjectorFactory(
     return methodBuilder("bindAndroidInjectorFactory")
         .addAnnotation(Binds.class)
         .addAnnotation(IntoMap.class)
-        .addAnnotation(
-            AnnotationSpec.builder(descriptor.mapKeyType())
-                .addMember("value", "$T.class", descriptor.injectedType())
-                .build())
+        .addAnnotation(androidInjectorMapKey(descriptor))
         .addModifiers(ABSTRACT)
         .returns(
             parameterizedTypeName(
@@ -144,6 +149,17 @@ private MethodSpec bindAndroidInjectorFactory(
         .build();
   }
 
+  private AnnotationSpec androidInjectorMapKey(AndroidInjectorDescriptor descriptor) {
+    if (useStringKeys) {
+      return AnnotationSpec.builder(AndroidInjectionKey.class)
+          .addMember("value", "$S", descriptor.injectedType().toString())
+          .build();
+    }
+    return AnnotationSpec.builder(descriptor.mapKeyType())
+        .addMember("value", "$T.class", descriptor.injectedType())
+        .build();
+  }
+
   private TypeSpec subcomponent(
       AndroidInjectorDescriptor descriptor,
       ClassName subcomponentName,
diff --git a/java/dagger/android/processor/DuplicateAndroidInjectorsChecker.java b/java/dagger/android/processor/DuplicateAndroidInjectorsChecker.java
new file mode 100644
index 000000000..0e8c0cca7
--- /dev/null
+++ b/java/dagger/android/processor/DuplicateAndroidInjectorsChecker.java
@@ -0,0 +1,156 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.processor;
+
+import static com.google.auto.common.AnnotationMirrors.getAnnotatedAnnotations;
+import static com.google.common.collect.Iterables.getOnlyElement;
+import static dagger.android.processor.AndroidMapKeys.injectedTypeFromMapKey;
+import static java.util.stream.Collectors.collectingAndThen;
+import static java.util.stream.Collectors.toList;
+import static javax.tools.Diagnostic.Kind.ERROR;
+
+import com.google.auto.common.MoreTypes;
+import com.google.auto.service.AutoService;
+import com.google.common.collect.ImmutableListMultimap;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Maps;
+import com.google.common.collect.Multimaps;
+import dagger.MapKey;
+import dagger.android.AndroidInjector;
+import dagger.android.DispatchingAndroidInjector;
+import dagger.model.BindingGraph;
+import dagger.model.BindingGraph.BindingNode;
+import dagger.model.BindingKind;
+import dagger.model.Key;
+import dagger.spi.BindingGraphPlugin;
+import dagger.spi.DiagnosticReporter;
+import java.util.Formatter;
+import java.util.List;
+import java.util.Map;
+import java.util.Optional;
+import java.util.stream.Stream;
+import javax.inject.Provider;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.type.TypeKind;
+import javax.lang.model.type.TypeMirror;
+
+/**
+ * Validates that the two maps that {@link DispatchingAndroidInjector} injects have logically
+ * different keys. If a contribution exists for the same {@code FooActivity} with
+ * {@code @ActivityKey(FooActivity.class)} and
+ * {@code @AndroidInjectionKey("com.example.FooActivity")}, report an error.
+ */
+@AutoService(BindingGraphPlugin.class)
+public final class DuplicateAndroidInjectorsChecker implements BindingGraphPlugin {
+  @Override
+  public void visitGraph(BindingGraph graph, DiagnosticReporter diagnosticReporter) {
+    for (BindingNode node : graph.bindingNodes()) {
+      if (isDispatchingAndroidInjector(node)) {
+        validateMapKeyUniqueness(node, graph, diagnosticReporter);
+      }
+    }
+  }
+
+  private boolean isDispatchingAndroidInjector(BindingNode node) {
+    Key key = node.key();
+    return MoreTypes.isTypeOf(DispatchingAndroidInjector.class, key.type())
+        && !key.qualifier().isPresent();
+  }
+
+  private void validateMapKeyUniqueness(
+      BindingNode dispatchingAndroidInjectorNode,
+      BindingGraph graph,
+      DiagnosticReporter diagnosticReporter) {
+    ImmutableSet<BindingNode> injectorFactories =
+        injectorMapDependencies(dispatchingAndroidInjectorNode, graph)
+            .flatMap(injectorFactoryMap -> dependencies(injectorFactoryMap, graph))
+            .collect(collectingAndThen(toList(), ImmutableSet::copyOf));
+
+    ImmutableListMultimap.Builder<String, BindingNode> mapKeyIndex =
+        ImmutableListMultimap.builder();
+    for (BindingNode injectorFactory : injectorFactories) {
+      AnnotationMirror mapKey = mapKey(injectorFactory).get();
+      Optional<String> injectedType = injectedTypeFromMapKey(mapKey);
+      if (injectedType.isPresent()) {
+        mapKeyIndex.put(injectedType.get(), injectorFactory);
+      } else {
+        diagnosticReporter.reportBinding(
+            ERROR, injectorFactory, "Unrecognized class: %s", mapKey);
+      }
+    }
+
+    Map<String, List<BindingNode>> duplicates =
+        Maps.filterValues(
+            Multimaps.asMap(mapKeyIndex.build()), bindingNodes -> bindingNodes.size() > 1);
+    if (!duplicates.isEmpty()) {
+      StringBuilder errorMessage =
+          new StringBuilder("Multiple injector factories bound for the same type:\n");
+      Formatter formatter = new Formatter(errorMessage);
+      duplicates.forEach(
+          (injectedType, duplicateFactories) -> {
+            formatter.format("  %s:\n", injectedType);
+            duplicateFactories.forEach(duplicate -> formatter.format("    %s\n", duplicate));
+          });
+      diagnosticReporter.reportBinding(
+          ERROR, dispatchingAndroidInjectorNode, errorMessage.toString());
+    }
+  }
+
+  private Stream<BindingNode> dependencies(BindingNode bindingNode, BindingGraph graph) {
+    return graph.network().successors(bindingNode).stream()
+        // TODO(ronshapiro): reuse DaggerStreams.instancesOf()?
+        .filter(BindingNode.class::isInstance)
+        .map(BindingNode.class::cast);
+  }
+
+  /**
+   * Returns a stream of the dependencies of {@code bindingNode} that have a key type of {@code
+   * Map<K, Provider<AndroidInjector.Factory<?>>}.
+   */
+  private Stream<BindingNode> injectorMapDependencies(BindingNode bindingNode, BindingGraph graph) {
+    return dependencies(bindingNode, graph)
+        .filter(node -> node.binding().kind().equals(BindingKind.MULTIBOUND_MAP))
+        .filter(
+            node -> {
+              TypeMirror valueType =
+                  MoreTypes.asDeclared(node.key().type()).getTypeArguments().get(1);
+              if (!MoreTypes.isTypeOf(Provider.class, valueType)
+                  || !valueType.getKind().equals(TypeKind.DECLARED)) {
+                return false;
+              }
+              TypeMirror providedType = MoreTypes.asDeclared(valueType).getTypeArguments().get(0);
+              return MoreTypes.isTypeOf(AndroidInjector.Factory.class, providedType);
+            });
+  }
+
+  private Optional<AnnotationMirror> mapKey(BindingNode bindingNode) {
+    return bindingNode
+        .binding()
+        .bindingElement()
+        .map(bindingElement -> getAnnotatedAnnotations(bindingElement, MapKey.class))
+        .flatMap(
+            annotations ->
+                annotations.isEmpty()
+                    ? Optional.empty()
+                    : Optional.of(getOnlyElement(annotations)));
+  }
+
+  @Override
+  public String pluginName() {
+    return "Dagger/Android/DuplicateAndroidInjectors";
+  }
+}
diff --git a/java/dagger/android/processor/META-INF/gradle/incremental.annotation.processors b/java/dagger/android/processor/META-INF/gradle/incremental.annotation.processors
new file mode 100644
index 000000000..22b8a9509
--- /dev/null
+++ b/java/dagger/android/processor/META-INF/gradle/incremental.annotation.processors
@@ -0,0 +1 @@
+dagger.android.processor.AndroidProcessor,isolating
diff --git a/java/dagger/android/support/AndroidSupportInjectionModule.java b/java/dagger/android/support/AndroidSupportInjectionModule.java
index 6349afb67..85b277a97 100644
--- a/java/dagger/android/support/AndroidSupportInjectionModule.java
+++ b/java/dagger/android/support/AndroidSupportInjectionModule.java
@@ -36,5 +36,9 @@
   abstract Map<Class<? extends Fragment>, AndroidInjector.Factory<? extends Fragment>>
       supportFragmentInjectorFactories();
 
+  @Multibinds
+  abstract Map<String, AndroidInjector.Factory<? extends Fragment>>
+      supportFragmentInjectorFactoriesWithStringKeys();
+
   private AndroidSupportInjectionModule() {}
 }
diff --git a/java/dagger/android/support/BUILD b/java/dagger/android/support/BUILD
index 3dcbd8a9b..e4b06560f 100644
--- a/java/dagger/android/support/BUILD
+++ b/java/dagger/android/support/BUILD
@@ -18,6 +18,7 @@
 package(default_visibility = ["//:src"])
 
 load("//:build_defs.bzl", "SOURCE_7_TARGET_7")
+load("//tools:maven.bzl", "pom_file", "POM_VERSION")
 
 filegroup(
     name = "support-srcs",
@@ -29,17 +30,49 @@ android_library(
     srcs = glob(["*.java"]),
     javacopts = SOURCE_7_TARGET_7,
     manifest = "AndroidManifest.xml",
+    tags = ["maven_coordinates=com.google.dagger:dagger-android-support:" + POM_VERSION],
     deps = [
+        ":manual-maven-deps",
         "//:dagger_with_compiler",
         "//java/dagger/android",
-        "//third_party:error_prone_annotations",
+        "@google_bazel_common//third_party/java/error_prone:annotations",
+    ],
+)
+
+# Our pom.xml generator does not have a way to add manual maven deps. This target exports the
+# targets that don't have the necessary maven_coordinates tags.
+android_library(
+    name = "manual-maven-deps",
+    tags = [
+        "maven_coordinates=com.android.support:appcompat-v7:25.0.0",
+        "maven_coordinates=com.android.support:support-annotations:25.0.0",
+        "maven_coordinates=com.android.support:support-fragment:25.0.0",
+    ],
+    visibility = ["//visibility:private"],
+    exports = [
         "@androidsdk//com.android.support:appcompat-v7-25.0.0",
         "@androidsdk//com.android.support:support-annotations-25.0.0",
         "@androidsdk//com.android.support:support-fragment-25.0.0",
     ],
 )
 
-load("//tools:javadoc.bzl", "javadoc_library")
+pom_file(
+    name = "pom",
+    artifact_id = "dagger-android-support",
+    artifact_name = "Dagger Android Support",
+    packaging = "aar",
+    targets = [":support"],
+)
+
+# b/37741866 and https://github.com/google/dagger/issues/715
+pom_file(
+    name = "jarimpl-pom",
+    artifact_id = "dagger-android-support-jarimpl",
+    artifact_name = "Dagger Android Support",
+    targets = [":support"],
+)
+
+load("@google_bazel_common//tools/javadoc:javadoc.bzl", "javadoc_library")
 
 javadoc_library(
     name = "support-javadoc",
diff --git a/java/dagger/example/android/simple/BUILD b/java/dagger/example/android/simple/BUILD
index 1c9d9f522..7396744f9 100644
--- a/java/dagger/example/android/simple/BUILD
+++ b/java/dagger/example/android/simple/BUILD
@@ -34,6 +34,7 @@ android_library(
 
 android_binary(
     name = "simple",
+    aapt_version = "aapt",
     manifest = "AndroidManifest.xml",
     deps = [
         ":simple_lib",
diff --git a/java/dagger/example/spi/BUILD b/java/dagger/example/spi/BUILD
index b5edd40ad..84b4a87d8 100644
--- a/java/dagger/example/spi/BUILD
+++ b/java/dagger/example/spi/BUILD
@@ -23,9 +23,9 @@ java_plugin(
     deps = [
         "//java/dagger/model",
         "//java/dagger/spi",
-        "//third_party:auto_service",
-        "//third_party:error_prone_annotations",
-        "//third_party:guava",
-        "//third_party:javapoet",
+        "@google_bazel_common//third_party/java/auto:service",
+        "@google_bazel_common//third_party/java/error_prone:annotations",
+        "@google_bazel_common//third_party/java/guava",
+        "@google_bazel_common//third_party/java/javapoet",
     ],
 )
diff --git a/java/dagger/example/spi/BindingGraphVisualizer.java b/java/dagger/example/spi/BindingGraphVisualizer.java
index 43a8ca009..379e9733f 100644
--- a/java/dagger/example/spi/BindingGraphVisualizer.java
+++ b/java/dagger/example/spi/BindingGraphVisualizer.java
@@ -33,6 +33,8 @@
 import dagger.model.BindingGraph.ChildFactoryMethodEdge;
 import dagger.model.BindingGraph.DependencyEdge;
 import dagger.model.BindingGraph.Edge;
+import dagger.model.BindingGraph.MaybeBindingNode;
+import dagger.model.BindingGraph.MissingBindingNode;
 import dagger.model.BindingGraph.Node;
 import dagger.model.BindingGraph.SubcomponentBuilderBindingEdge;
 import dagger.model.BindingKind;
@@ -56,7 +58,7 @@
 import javax.tools.StandardLocation;
 
 /**
- * Experimental network visualizer used as a proof-of-concept for {@link BindingGraphPlugin}.
+ * Experimental visualizer used as a proof-of-concept for {@link BindingGraphPlugin}.
  *
  * <p>For each component, writes a <a href=http://www.graphviz.org/content/dot-language>DOT file</a>
  * in the same package. The file name is the name of the component type (with enclosing type names,
@@ -222,9 +224,7 @@ private static String quote(String string) {
     DotGraph graph() {
       if (nodeIds.isEmpty()) {
         Iterator<String> colors = Iterators.cycle(COMPONENT_COLORS);
-        bindingGraph
-            .nodes()
-            .stream()
+        bindingGraph.network().nodes().stream()
             .collect(groupingBy(Node::componentPath))
             .forEach(
                 (component, networkNodes) -> {
@@ -239,7 +239,7 @@ DotGraph graph() {
                     subgraph.add(dotNode(node));
                   }
                 });
-        for (Edge edge : bindingGraph.edges()) {
+        for (Edge edge : bindingGraph.network().edges()) {
           dotEdge(edge).ifPresent(graph::add);
         }
       }
@@ -257,7 +257,7 @@ UUID nodeId(Node node) {
     }
 
     Optional<DotEdge> dotEdge(Edge edge) {
-      EndpointPair<Node> incidentNodes = bindingGraph.incidentNodes(edge);
+      EndpointPair<Node> incidentNodes = bindingGraph.network().incidentNodes(edge);
       DotEdge dotEdge = new DotEdge(nodeId(incidentNodes.source()), nodeId(incidentNodes.target()));
       if (edge instanceof DependencyEdge) {
         if (((DependencyEdge) edge).isEntryPoint()) {
@@ -278,25 +278,34 @@ UUID nodeId(Node node) {
 
     DotNode dotNode(Node node) {
       DotNode dotNode = new DotNode(nodeId(node));
-      if (node instanceof BindingNode) {
-        dagger.model.Binding binding = ((BindingNode) node).binding();
-        if (binding.kind().equals(BindingKind.MEMBERS_INJECTION)) {
-          dotNode.addAttributeFormat("label", "inject(%s)", binding.key());
-        } else if (binding.isProduction()) {
-          dotNode.addAttributeFormat("label", "@Produces %s", binding.key());
-        } else {
-          dotNode.addAttribute("label", binding.key());
-        }
+      if (node instanceof MaybeBindingNode) {
         dotNode.addAttribute("tooltip", "");
         if (bindingGraph.entryPointBindingNodes().contains(node)) {
           dotNode.addAttribute("penwidth", 3);
         }
+        if (node instanceof BindingNode) {
+          dotNode.addAttribute("label", label((BindingNode) node));
+        }
+        if (node instanceof MissingBindingNode) {
+          dotNode.addAttributeFormat(
+              "label", "missing binding for %s", ((MissingBindingNode) node).key());
+        }
       } else {
         dotNode.addAttribute("style", "invis").addAttribute("shape", "point");
       }
       return dotNode;
     }
 
+    private String label(BindingNode bindingNode) {
+      if (bindingNode.binding().kind().equals(BindingKind.MEMBERS_INJECTION)) {
+        return String.format("inject(%s)", bindingNode.key());
+      } else if (bindingNode.binding().isProduction()) {
+        return String.format("@Produces %s", bindingNode.key());
+      } else {
+        return bindingNode.key().toString();
+      }
+    }
+
     private static String clusterName(ComponentPath owningComponentPath) {
       return "cluster" + owningComponentPath;
     }
diff --git a/java/dagger/grpc/server/BUILD b/java/dagger/grpc/server/BUILD
index e0357103d..1c57807c7 100644
--- a/java/dagger/grpc/server/BUILD
+++ b/java/dagger/grpc/server/BUILD
@@ -3,6 +3,7 @@
 package(default_visibility = ["//:src"])
 
 load("//:build_defs.bzl", "DOCLINT_HTML_AND_SYNTAX", "DOCLINT_REFERENCES")
+load("//tools:maven.bzl", "pom_file", "POM_VERSION")
 
 ANNOTATIONS_SRCS = [
     "CallScoped.java",
@@ -14,8 +15,9 @@ java_library(
     name = "annotations",
     srcs = ANNOTATIONS_SRCS,
     javacopts = DOCLINT_HTML_AND_SYNTAX,
+    tags = ["maven_coordinates=com.google.dagger:dagger-grpc-server-annotations:" + POM_VERSION],
     deps = [
-        "//third_party:jsr330_inject",
+        "@google_bazel_common//third_party/java/jsr330_inject",
     ],
 )
 
@@ -28,26 +30,41 @@ java_library(
     ),
     exported_plugins = ["//java/dagger/grpc/server/processor:plugin"],
     javacopts = DOCLINT_HTML_AND_SYNTAX + DOCLINT_REFERENCES,
+    tags = ["maven_coordinates=com.google.dagger:dagger-grpc-server:" + POM_VERSION],
     exports = [":annotations"],
     deps = [
         "//:dagger_with_compiler",
-        "//third_party:auto_value",
-        "//third_party:grpc_context",
-        "//third_party:grpc_core",
-        "//third_party:grpc_netty",
-        "//third_party:grpc_protobuf",
-        "//third_party:guava",
-        "//third_party:jsr330_inject",
-        "//third_party:protobuf",
+        "@google_bazel_common//third_party/java/auto:value",
+        "@google_bazel_common//third_party/java/grpc:context",
+        "@google_bazel_common//third_party/java/grpc:core",
+        "@google_bazel_common//third_party/java/grpc:netty",
+        "@google_bazel_common//third_party/java/grpc:protobuf",
+        "@google_bazel_common//third_party/java/guava",
+        "@google_bazel_common//third_party/java/jsr330_inject",
+        "@google_bazel_common//third_party/java/protobuf",
     ],
 )
 
+pom_file(
+    name = "annotations-pom",
+    artifact_id = "dagger-grpc-server-annotations",
+    artifact_name = "Dagger gRPC Server Annotations",
+    targets = [":annotations"],
+)
+
+pom_file(
+    name = "server-pom",
+    artifact_id = "dagger-grpc-server",
+    artifact_name = "Dagger gRPC Server",
+    targets = [":server"],
+)
+
 filegroup(
     name = "javadoc-srcs",
     srcs = glob(["*.java"]),
 )
 
-load("//tools:javadoc.bzl", "javadoc_library")
+load("@google_bazel_common//tools/javadoc:javadoc.bzl", "javadoc_library")
 
 javadoc_library(
     name = "javadoc",
diff --git a/java/dagger/grpc/server/processor/BUILD b/java/dagger/grpc/server/processor/BUILD
index 5e89d3e2e..ce02b0635 100644
--- a/java/dagger/grpc/server/processor/BUILD
+++ b/java/dagger/grpc/server/processor/BUILD
@@ -1,23 +1,32 @@
 package(default_visibility = ["//:src"])
 
 load("//:build_defs.bzl", "DOCLINT_HTML_AND_SYNTAX")
+load("//tools:maven.bzl", "pom_file", "POM_VERSION")
 
 java_library(
     name = "processor",
     srcs = glob(["*.java"]),
     javacopts = DOCLINT_HTML_AND_SYNTAX,
+    tags = ["maven_coordinates=com.google.dagger:dagger-grpc-server-processor:" + POM_VERSION],
     deps = [
         "//:dagger_with_compiler",
         "//java/dagger/grpc/server:annotations",
-        "//third_party:auto_common",
-        "//third_party:auto_service",
-        "//third_party:google_java_format",
-        "//third_party:guava",
-        "//third_party:javapoet",
-        "//third_party:jsr250_annotations",
+        "@google_bazel_common//third_party/java/auto:common",
+        "@google_bazel_common//third_party/java/auto:service",
+        "@google_bazel_common//third_party/java/google_java_format",
+        "@google_bazel_common//third_party/java/guava",
+        "@google_bazel_common//third_party/java/javapoet",
+        "@google_bazel_common//third_party/java/jsr250_annotations",
     ],
 )
 
+pom_file(
+    name = "pom",
+    artifact_id = "dagger-grpc-server-processor",
+    artifact_name = "Dagger gRPC Server Processor",
+    targets = [":processor"],
+)
+
 java_plugin(
     name = "plugin",
     generates_api = 1,
@@ -30,7 +39,7 @@ filegroup(
     srcs = glob(["*.java"]),
 )
 
-load("//tools:javadoc.bzl", "javadoc_library")
+load("@google_bazel_common//tools/javadoc:javadoc.bzl", "javadoc_library")
 
 javadoc_library(
     name = "javadoc",
diff --git a/java/dagger/internal/DaggerCollections.java b/java/dagger/internal/DaggerCollections.java
index 3d47a8497..cebca42d2 100644
--- a/java/dagger/internal/DaggerCollections.java
+++ b/java/dagger/internal/DaggerCollections.java
@@ -70,7 +70,7 @@ public static boolean hasDuplicates(List<?> list) {
    * Creates a {@link LinkedHashMap} instance, with a high enough "initial capacity" that it
    * <em>should</em> hold {@code expectedSize} elements without growth.
    */
-  static <K, V> LinkedHashMap<K, V> newLinkedHashMapWithExpectedSize(int expectedSize) {
+  public static <K, V> LinkedHashMap<K, V> newLinkedHashMapWithExpectedSize(int expectedSize) {
     return new LinkedHashMap<K, V>(calculateInitialCapacity(expectedSize));
   }
 
diff --git a/java/dagger/internal/DoubleCheck.java b/java/dagger/internal/DoubleCheck.java
index 6313bb0db..ea07528bf 100644
--- a/java/dagger/internal/DoubleCheck.java
+++ b/java/dagger/internal/DoubleCheck.java
@@ -62,7 +62,7 @@ public T get() {
    */
   public static Object reentrantCheck(Object currentInstance, Object newInstance) {
     boolean isReentrant = !(currentInstance == UNINITIALIZED
-        // This check is needed for AndroidMode's implementation, which uses MemoizedSentinel types.
+        // This check is needed for fastInit's implementation, which uses MemoizedSentinel types.
         || currentInstance instanceof MemoizedSentinel);
 
     if (isReentrant && currentInstance != newInstance) {
diff --git a/java/dagger/internal/MapBuilder.java b/java/dagger/internal/MapBuilder.java
index 1560491b1..25e2b5b86 100644
--- a/java/dagger/internal/MapBuilder.java
+++ b/java/dagger/internal/MapBuilder.java
@@ -44,6 +44,11 @@ private MapBuilder(int size) {
     return this;
   }
 
+  public MapBuilder<K, V> putAll(Map<K, V> map) {
+    contributions.putAll(map);
+    return this;
+  }
+
   public Map<K, V> build() {
     switch (contributions.size()) {
       case 0:
diff --git a/java/dagger/internal/SetFactory.java b/java/dagger/internal/SetFactory.java
index 3f3ad0d51..349399b3e 100644
--- a/java/dagger/internal/SetFactory.java
+++ b/java/dagger/internal/SetFactory.java
@@ -101,8 +101,7 @@ private SetFactory(
   }
 
   /**
-   * Returns a {@link Set} whose iteration order is that of the elements given by each of the
-   * providers, which are invoked in the order given at creation.
+   * Returns a {@link Set} that contains the elements given by each of the providers.
    *
    * @throws NullPointerException if any of the delegate {@link Set} instances or elements therein
    *     are {@code null}
diff --git a/java/dagger/internal/SingleCheck.java b/java/dagger/internal/SingleCheck.java
index d94a32353..41280699d 100644
--- a/java/dagger/internal/SingleCheck.java
+++ b/java/dagger/internal/SingleCheck.java
@@ -18,14 +18,13 @@
 
 import static dagger.internal.Preconditions.checkNotNull;
 
-import dagger.Lazy;
 import javax.inject.Provider;
 
 /**
  * A {@link Provider} implementation that memoizes the result of another {@link Provider} using
  * simple lazy initialization, not the double-checked lock pattern.
  */
-public final class SingleCheck<T> implements Provider<T>, Lazy<T> {
+public final class SingleCheck<T> implements Provider<T> {
   private static final Object UNINITIALIZED = new Object();
 
   private volatile Provider<T> provider;
diff --git a/java/dagger/internal/codegen/AnnotationCreatorGenerator.java b/java/dagger/internal/codegen/AnnotationCreatorGenerator.java
index 859fbf8c5..8c0a3ad7e 100644
--- a/java/dagger/internal/codegen/AnnotationCreatorGenerator.java
+++ b/java/dagger/internal/codegen/AnnotationCreatorGenerator.java
@@ -91,8 +91,8 @@ ClassName nameGeneratedType(TypeElement annotationType) {
   }
 
   @Override
-  Optional<? extends Element> getElementForErrorReporting(TypeElement annotationType) {
-    return Optional.of(annotationType);
+  Element originatingElement(TypeElement annotationType) {
+    return annotationType;
   }
 
   @Override
diff --git a/java/dagger/internal/codegen/BUILD b/java/dagger/internal/codegen/BUILD
index 0354caf45..aa03b6756 100644
--- a/java/dagger/internal/codegen/BUILD
+++ b/java/dagger/internal/codegen/BUILD
@@ -18,6 +18,8 @@
 package(default_visibility = ["//:src"])
 
 load("//:build_defs.bzl", "DOCLINT_HTML_AND_SYNTAX", "DOCLINT_REFERENCES")
+load("//tools:maven.bzl", "pom_file", "POM_VERSION")
+load("//tools:simple_jar.bzl", "simple_jar")
 
 EXPERIMENTAL_VISUALIZER_SRCS = ["BindingNetworkVisualizer.java"]
 
@@ -34,15 +36,15 @@ CODEGEN_SRCS = glob(
 CODEGEN_PLUGINS = [":bootstrap_compiler_plugin"]
 
 CODEGEN_SHARED_DEPS = [
-    "//third_party:auto_service",
-    "//third_party:auto_value",
-    "//third_party:auto_common",
-    "//third_party:error_prone_annotations",
-    "//third_party:google_java_format",
-    "//third_party:javapoet",
+    "@google_bazel_common//third_party/java/auto:service",
+    "@google_bazel_common//third_party/java/auto:value",
+    "@google_bazel_common//third_party/java/auto:common",
+    "@google_bazel_common//third_party/java/error_prone:annotations",
+    "@google_bazel_common//third_party/java/google_java_format",
+    "@google_bazel_common//third_party/java/javapoet",
     "@local_jdk//:lib/tools.jar",
-    "//third_party:jsr250_annotations",
-    "//third_party:jsr330_inject",
+    "@google_bazel_common//third_party/java/jsr250_annotations",
+    "@google_bazel_common//third_party/java/jsr330_inject",
     "//java/dagger:core",
     "//java/dagger/producers",
     "//java/dagger/model",
@@ -51,7 +53,7 @@ CODEGEN_SHARED_DEPS = [
 ]
 
 CODEGEN_DEPS = CODEGEN_SHARED_DEPS + [
-    "//third_party:guava",
+    "@google_bazel_common//third_party/java/guava",
     ":shared-with-spi",
 ]
 
@@ -63,7 +65,7 @@ java_library(
     plugins = CODEGEN_PLUGINS,
     tags = ["maven:merged"],
     deps = [
-        "//third_party:guava",
+        "@google_bazel_common//third_party/java/guava",
     ],
 )
 
@@ -122,22 +124,26 @@ java_library(
         "BindingFactory.java",
         "BindingGraph.java",
         "BindingNodeImpl.java",
+        "BindingRequest.java",
         "BindingType.java",
-        "BindingTypeMapper.java",
         "BindingVariableNamer.java",  # needed by FrameworkField
         "BindsTypeChecker.java",
+        "ChildFactoryMethodEdgeImpl.java",
         "ComponentDescriptor.java",
+        "ComponentNodeImpl.java",
         "ComponentRequirement.java",
         "ComponentTreeTraverser.java",
         "ConfigurationAnnotations.java",  # Uses ModuleDescriptors
         "ContributionBinding.java",
         "DelegateDeclaration.java",
+        "DependencyEdgeImpl.java",
         "DependencyRequestFactory.java",
         "DependencyVariableNamer.java",  # Used by SourceFiles
         "ErrorMessages.java",  # Consider splitting this up as it pulls in too much
         "FrameworkDependency.java",
         "FrameworkField.java",  # Used by SourceFiles
         "FrameworkType.java",
+        "FrameworkTypeMapper.java",
         "InjectBindingRegistry.java",
         "KeyFactory.java",
         "MapKeys.java",
@@ -150,6 +156,7 @@ java_library(
         "ProvisionBinding.java",
         "ResolvedBindings.java",
         "SourceFiles.java",  # Consider splitting this up?
+        "SubcomponentBuilderBindingEdgeImpl.java",
         "SubcomponentDeclaration.java",
     ],
     plugins = CODEGEN_PLUGINS,
@@ -163,7 +170,6 @@ java_library(
     srcs = [
         "AnyBindingMethodValidator.java",
         "BindingDeclarationFormatter.java",
-        "BindingGraphValidator.java",
         "BindingMethodProcessingStep.java",
         "BindingMethodValidator.java",
         "BindsInstanceProcessingStep.java",
@@ -171,12 +177,15 @@ java_library(
         "BindsOptionalOfMethodValidator.java",
         "BuilderValidator.java",
         "CanReleaseReferencesValidator.java",
+        "ComponentDescriptorValidator.java",
         "ComponentHierarchyValidator.java",
         "ComponentValidator.java",
         "DependencyRequestFormatter.java",
+        "DependencyRequestValidator.java",
         "ForReleasableReferencesValidator.java",
         "InjectValidator.java",
         "MapKeyValidator.java",
+        "MembersInjectionValidator.java",
         "MethodSignatureFormatter.java",
         "ModuleValidator.java",
         "MultibindingAnnotationsProcessingStep.java",
@@ -194,19 +203,23 @@ java_library(
 )
 
 java_library(
-    name = "internal_validation",
+    name = "binding_graph_validation",
     srcs = [
         "BindingGraphValidationModule.java",
-        "DuplicateBindingsValidation.java",
-        "IncompatiblyScopedBindingsValidation.java",
-        "InjectBindingValidation.java",
-        "MapMultibindingValidation.java",
-        "MembersInjectionBindingValidation.java",
-        "MissingBindingValidation.java",
-        "NonNullableRequestForNullableBindingValidation.java",
-        "ProvisionDependencyOnProducerBindingValidation.java",
+        "DependencyCycleValidator.java",
+        "DependsOnProductionExecutorValidator.java",
+        "DuplicateBindingsValidator.java",
+        "IncompatiblyScopedBindingsValidator.java",
+        "IncorrectlyInstalledBindsMethodsValidator.java",
+        "InjectBindingValidator.java",
+        "MapMultibindingValidator.java",
+        "MissingBindingValidator.java",
+        "NullableBindingValidator.java",
+        "ProvisionDependencyOnProducerBindingValidator.java",
+        "SubcomponentFactoryMethodValidator.java",
         "Validation.java",
     ],
+    plugins = CODEGEN_PLUGINS,
     tags = ["maven:merged"],
     deps = CODEGEN_DEPS + [
         ":base",
@@ -223,26 +236,25 @@ java_library(
         "BindingExpression.java",
         "BindingMethodImplementation.java",
         "ComponentBindingExpressions.java",
-        "ComponentBuilder.java",
-        "ComponentGenerator.java",
         "ComponentInstanceBindingExpression.java",
         "ComponentMethodBindingExpression.java",
         "ComponentProvisionBindingExpression.java",
         "ComponentRequirementBindingExpression.java",
         "ComponentRequirementField.java",
         "ComponentRequirementFields.java",
-        "ComponentWriter.java",
         "DelegateBindingExpression.java",
         "DelegatingFrameworkInstanceCreationExpression.java",
         "DependencyMethodProducerCreationExpression.java",
         "DependencyMethodProviderCreationExpression.java",
-        "DerivedFromProviderBindingExpression.java",
+        "DerivedFromFrameworkInstanceBindingExpression.java",
         "DoubleCheckedMethodImplementation.java",
         "FactoryGenerator.java",
         "FrameworkFieldInitializer.java",
         "FrameworkInstanceBindingExpression.java",
         "FrameworkInstanceSupplier.java",
+        "GeneratedComponentBuilderModel.java",
         "GeneratedComponentModel.java",
+        "GeneratedInstanceBindingExpression.java",
         "GwtCompatibility.java",
         "ImmediateFutureBindingExpression.java",
         "InaccessibleMapKeyProxyGenerator.java",
@@ -258,8 +270,15 @@ java_library(
         "MembersInjectorGenerator.java",
         "MembersInjectorProviderCreationExpression.java",
         "MethodBindingExpression.java",
+        "MissingBindingExpression.java",
+        "ModifiableAbstractMethodBindingExpression.java",
+        "ModifiableBindingExpressions.java",
+        "ModifiableBindingMethods.java",
+        "ModifiableBindingType.java",
+        "ModifiableConcreteMethodBindingExpression.java",
         "MonitoringModuleGenerator.java",
         "MonitoringModuleProcessingStep.java",
+        "MultibindingExpression.java",
         "OptionalBindingExpression.java",
         "OptionalFactories.java",
         "OptionalFactoryInstanceCreationExpression.java",
@@ -267,7 +286,9 @@ java_library(
         "ProducerCreationExpression.java",
         "ProducerFactoryGenerator.java",
         "ProducerFromProviderCreationExpression.java",
+        "ProducerNodeInstanceBindingExpression.java",
         "ProductionExecutorModuleGenerator.java",
+        "ProviderInstanceBindingExpression.java",
         "ReferenceReleasingManagerFields.java",
         "ReleasableReferenceManagerProviderCreationExpression.java",
         "ReleasableReferenceManagerSetProviderCreationExpression.java",
@@ -291,6 +312,11 @@ java_library(
     ],
 )
 
+simple_jar(
+    name = "processor_manifest_files",
+    srcs = glob(["META-INF/**"]),
+)
+
 # The processor's "main", if you will
 java_library(
     name = "processor",
@@ -301,7 +327,9 @@ java_library(
         "BindingGraphPluginsModule.java",
         "BindingMethodValidatorsModule.java",
         "CanReleaseReferencesProcessingStep.java",
+        "ComponentGenerator.java",
         "ComponentHjarProcessingStep.java",
+        "ComponentModelBuilder.java",
         "ComponentProcessingStep.java",
         "ComponentProcessor.java",
         "DiagnosticReporterFactory.java",
@@ -314,10 +342,26 @@ java_library(
         "ProductionExecutorModuleProcessingStep.java",
     ],
     plugins = CODEGEN_PLUGINS,
+    resource_jars = [":processor_manifest_files.jar"],
+    tags = ["maven_coordinates=com.google.dagger:dagger-compiler:" + POM_VERSION],
     deps = CODEGEN_DEPS + [
         ":base",
         ":binding",
-        ":internal_validation",
+        ":binding_graph_validation",
+        ":writing",
+        ":validation",
+    ],
+)
+
+pom_file(
+    name = "pom",
+    artifact_id = "dagger-compiler",
+    artifact_name = "Dagger Compiler",
+    targets = [
+        ":processor",
+        ":base",
+        ":binding",
+        ":binding_graph_validation",
         ":writing",
         ":validation",
     ],
@@ -330,19 +374,30 @@ java_library(
     deps = [
         ":base",
         ":binding",
+        ":binding_graph_validation",
+        ":kythe_plugin",
         ":processor",
         ":validation",
         "//java/dagger:core",
         "//java/dagger/model",
         "//java/dagger/producers",
-        "//third_party:auto_common",
-        "//third_party:auto_service",
-        "//third_party:guava",
-        "//third_party:kythe_plugin",
         "@bazel_tools//third_party/java/jdk/langtools:javac",
+        "@google_bazel_common//third_party/java/auto:common",
+        "@google_bazel_common//third_party/java/auto:service",
+        "@google_bazel_common//third_party/java/guava",
     ],
 )
 
+# A _deploy.jar consisting of the java_librarys in https://github.com/google/kythe needed to build a
+# Kythe plugin
+# TODO(ronshapiro): replace this with a http_archive of the next release in
+# https://github.com/google/kythe/releases
+java_import(
+    name = "kythe_plugin",
+    jars = ["kythe_plugin_deploy.jar"],
+    neverlink = 1,
+)
+
 java_import(
     name = "bootstrap_compiler",
     jars = ["bootstrap_compiler_deploy.jar"],
@@ -357,7 +412,7 @@ java_plugin(
     deps = [":bootstrap_compiler"],
 )
 
-load("//tools:javadoc.bzl", "javadoc_library")
+load("@google_bazel_common//tools/javadoc:javadoc.bzl", "javadoc_library")
 
 javadoc_library(
     name = "codegen-javadoc",
diff --git a/java/dagger/internal/codegen/Binding.java b/java/dagger/internal/codegen/Binding.java
index 6254b73ca..f3fd84a4a 100644
--- a/java/dagger/internal/codegen/Binding.java
+++ b/java/dagger/internal/codegen/Binding.java
@@ -28,15 +28,16 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ImmutableSetMultimap;
 import com.google.common.collect.Lists;
+import com.google.common.collect.Multimaps;
 import com.google.common.collect.Sets;
 import dagger.model.DependencyRequest;
 import dagger.model.Key;
 import dagger.model.Scope;
-import java.util.Collection;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Optional;
+import java.util.Set;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.TypeParameterElement;
@@ -157,15 +158,16 @@ static DependencyAssociation create(
   private final Supplier<ImmutableList<DependencyAssociation>> dependencyAssociations =
       memoize(
           () -> {
-            BindingTypeMapper bindingTypeMapper = BindingTypeMapper.forBindingType(bindingType());
+            FrameworkTypeMapper frameworkTypeMapper =
+                FrameworkTypeMapper.forBindingType(bindingType());
             ImmutableList.Builder<DependencyAssociation> list = ImmutableList.builder();
-            for (Collection<DependencyRequest> requests : groupByUnresolvedKey()) {
+            for (Set<DependencyRequest> requests : groupByUnresolvedKey()) {
               list.add(
                   DependencyAssociation.create(
                       FrameworkDependency.create(
                           getOnlyElement(
                               requests.stream().map(DependencyRequest::key).collect(toSet())),
-                          bindingTypeMapper.getBindingType(requests)),
+                          frameworkTypeMapper.getFrameworkType(requests)),
                       requests));
             }
             return list.build();
@@ -212,7 +214,7 @@ static DependencyAssociation create(
    * Groups {@code binding}'s implicit dependencies by their binding key, using the dependency keys
    * from the {@link Binding#unresolved()} binding if it exists.
    */
-  private ImmutableList<Collection<DependencyRequest>> groupByUnresolvedKey() {
+  private ImmutableList<Set<DependencyRequest>> groupByUnresolvedKey() {
     ImmutableSetMultimap.Builder<Key, DependencyRequest> dependenciesByKeyBuilder =
         ImmutableSetMultimap.builder();
     Iterator<DependencyRequest> dependencies = dependencies().iterator();
@@ -222,10 +224,8 @@ static DependencyAssociation create(
       dependenciesByKeyBuilder.put(unresolvedDependencies.next().key(), dependencies.next());
     }
     return ImmutableList.copyOf(
-        dependenciesByKeyBuilder
-            .orderValuesBy(SourceFiles.DEPENDENCY_ORDERING)
-            .build()
-            .asMap()
+        Multimaps.asMap(
+                dependenciesByKeyBuilder.orderValuesBy(SourceFiles.DEPENDENCY_ORDERING).build())
             .values());
   }
 
diff --git a/java/dagger/internal/codegen/BindingExpression.java b/java/dagger/internal/codegen/BindingExpression.java
index d92cd97e0..c4cd5c119 100644
--- a/java/dagger/internal/codegen/BindingExpression.java
+++ b/java/dagger/internal/codegen/BindingExpression.java
@@ -19,6 +19,7 @@
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
+import dagger.internal.codegen.ModifiableBindingMethods.ModifiableBindingMethod;
 
 /** A factory of code expressions used to access a single request for a binding in a component. */
 // TODO(user): Rename this to RequestExpression?
@@ -32,6 +33,16 @@
    */
   abstract Expression getDependencyExpression(ClassName requestingClass);
 
+  /**
+   * Equivalent to {@link #getDependencyExpression} that is used only when the request is for an
+   * implementation of a component method. By default, just delegates to {@link
+   * #getDependencyExpression}.
+   */
+  Expression getDependencyExpressionForComponentMethod(
+      ComponentMethodDescriptor componentMethod, GeneratedComponentModel component) {
+    return getDependencyExpression(component.name());
+  }
+
   /** Returns {@code true} if this binding expression should be encapsulated in a method. */
   boolean requiresMethodEncapsulation() {
     return false;
@@ -40,11 +51,22 @@ boolean requiresMethodEncapsulation() {
   /**
    * Returns an expression for the implementation of a component method with the given request.
    *
-   * @param componentName the component that will contain the implemented method
+   * @param component the component that will contain the implemented method
    */
   CodeBlock getComponentMethodImplementation(
-      ComponentMethodDescriptor componentMethod, ClassName componentName) {
+      ComponentMethodDescriptor componentMethod, GeneratedComponentModel component) {
     // By default, just delegate to #getDependencyExpression().
-    return CodeBlock.of("return $L;", getDependencyExpression(componentName).codeBlock());
+    return CodeBlock.of(
+        "return $L;",
+        getDependencyExpressionForComponentMethod(componentMethod, component).codeBlock());
+  }
+
+  /**
+   * Returns an expression for the implementation of a modifiable binding method for the given
+   * component model.
+   */
+  CodeBlock getModifiableBindingMethodImplementation(
+      ModifiableBindingMethod modifiableBindingMethod, GeneratedComponentModel component) {
+    return CodeBlock.of("return $L;", getDependencyExpression(component.name()).codeBlock());
   }
 }
diff --git a/java/dagger/internal/codegen/BindingFactory.java b/java/dagger/internal/codegen/BindingFactory.java
index 23e0745c7..9406467c2 100644
--- a/java/dagger/internal/codegen/BindingFactory.java
+++ b/java/dagger/internal/codegen/BindingFactory.java
@@ -27,6 +27,7 @@
 import static dagger.internal.codegen.ComponentDescriptor.isComponentProductionMethod;
 import static dagger.internal.codegen.ConfigurationAnnotations.getNullableType;
 import static dagger.internal.codegen.ContributionBinding.bindingKindForMultibindingKey;
+import static dagger.internal.codegen.DaggerElements.DECLARATION_ORDER;
 import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
 import static dagger.internal.codegen.InjectionAnnotations.getQualifier;
 import static dagger.internal.codegen.MapKeys.getMapKey;
@@ -614,7 +615,7 @@ MembersInjectionBinding membersInjectionBinding(
             .thenComparing(injectionSite -> injectionSite.element().getKind())
             // then sort by whichever element comes first in the parent
             // this isn't necessary, but makes the processor nice and predictable
-            .thenComparing(InjectionSite::indexAmongSiblingMembers),
+            .thenComparing(InjectionSite::element, DECLARATION_ORDER),
         injectionSites);
   }
 
diff --git a/java/dagger/internal/codegen/BindingGraph.java b/java/dagger/internal/codegen/BindingGraph.java
index a76a1fb68..9ec4d2aea 100644
--- a/java/dagger/internal/codegen/BindingGraph.java
+++ b/java/dagger/internal/codegen/BindingGraph.java
@@ -18,8 +18,8 @@
 
 import static com.google.common.base.Preconditions.checkState;
 import static dagger.internal.codegen.ComponentRequirement.Kind.BOUND_INSTANCE;
+import static dagger.internal.codegen.DaggerStreams.presentValues;
 import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
-import static javax.lang.model.element.Modifier.ABSTRACT;
 
 import com.google.auto.value.AutoValue;
 import com.google.auto.value.extension.memoized.Memoized;
@@ -36,7 +36,6 @@
 import dagger.releasablereferences.CanReleaseReferences;
 import dagger.releasablereferences.ReleasableReferenceManager;
 import java.util.Optional;
-import java.util.stream.Stream;
 import java.util.stream.StreamSupport;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
@@ -63,15 +62,16 @@
   abstract ImmutableMap<Key, ResolvedBindings> membersInjectionBindings();
 
   /**
-   * Returns the {@link ResolvedBindings resolved bindings} instance for {@code key}. If {@code
-   * requestKind} is {@link RequestKind#MEMBERS_INJECTION}, a {@link ResolvedBindings} with
-   * {@linkplain #membersInjectionBindings() members injection bindings} will be returned, otherwise
-   * a {@link ResolvedBindings} with {@link #contributionBindings()} will be returned.
+   * Returns the {@link ResolvedBindings resolved bindings} instance for {@code
+   * bindingExpressionKey}. If the bindings will be used for members injection, a {@link
+   * ResolvedBindings} with {@linkplain #membersInjectionBindings() members injection bindings} will
+   * be returned, otherwise a {@link ResolvedBindings} with {@link #contributionBindings()} will be
+   * returned.
    */
-  final ResolvedBindings resolvedBindings(RequestKind requestKind, Key key) {
-    return requestKind.equals(RequestKind.MEMBERS_INJECTION)
-        ? membersInjectionBindings().get(key)
-        : contributionBindings().get(key);
+  final ResolvedBindings resolvedBindings(BindingRequest request) {
+    return request.isRequestKind(RequestKind.MEMBERS_INJECTION)
+        ? membersInjectionBindings().get(request.key())
+        : contributionBindings().get(request.key());
   }
 
   @Memoized
@@ -91,7 +91,7 @@ final ResolvedBindings resolvedBindings(RequestKind requestKind, Key key) {
    * <ul>
    *   <li>{@code @ForReleasableReferences(scope)} {@link ReleasableReferenceManager}
    *   <li>{@code @ForReleasableReferences(scope)} {@code TypedReleasableReferenceManager<M>}, where
-   *       {@code M} is the releasable-references metatadata type for {@code scope}
+   *       {@code M} is the releasable-references metadata type for {@code scope}
    *   <li>{@code Set<ReleasableReferenceManager>}
    *   <li>{@code Set<TypedReleasableReferenceManager<M>>}, where {@code M} is the metadata type for
    *       the scope
@@ -189,19 +189,15 @@ TypeElement componentType() {
         .flatMap(graph -> graph.contributionBindings().values().stream())
         .flatMap(bindings -> bindings.contributionBindings().stream())
         .filter(ContributionBinding::requiresModuleInstance)
-        .map(bindingDeclaration -> bindingDeclaration.contributingModule())
-        .filter(Optional::isPresent)
-        .map(Optional::get)
+        .map(ContributionBinding::contributingModule)
+        .flatMap(presentValues())
         .filter(module -> ownedModuleTypes().contains(module))
         .map(module -> ComponentRequirement.forModule(module.asType()))
         .forEach(requirements::add);
     if (factoryMethod().isPresent()) {
       factoryMethodParameters().keySet().forEach(requirements::add);
     }
-    componentDescriptor()
-        .dependencies()
-        .stream()
-        .forEach(requirements::add);
+    requirements.addAll(componentDescriptor().dependencies());
     if (componentDescriptor().builderSpec().isPresent()) {
       componentDescriptor()
           .builderSpec()
@@ -222,17 +218,6 @@ TypeElement componentType() {
         .toSet();
   }
 
-  ImmutableSet<ComponentRequirement> availableDependencies() {
-    return Stream.concat(
-            componentDescriptor()
-                .transitiveModuleTypes()
-                .stream()
-                .filter(dep -> !dep.getModifiers().contains(ABSTRACT))
-                .map(module -> ComponentRequirement.forModule(module.asType())),
-            componentDescriptor().dependencies().stream())
-        .collect(toImmutableSet());
-  }
-
   @Memoized
   @Override
   public abstract int hashCode();
diff --git a/java/dagger/internal/codegen/BindingGraphConverter.java b/java/dagger/internal/codegen/BindingGraphConverter.java
index f35b5ce7f..4d3ad971b 100644
--- a/java/dagger/internal/codegen/BindingGraphConverter.java
+++ b/java/dagger/internal/codegen/BindingGraphConverter.java
@@ -16,14 +16,18 @@
 
 package dagger.internal.codegen;
 
+import static com.google.auto.common.MoreTypes.asTypeElement;
+import static dagger.internal.codegen.BindingRequest.bindingRequest;
+import static dagger.internal.codegen.DaggerGraphs.unreachableNodes;
 import static dagger.internal.codegen.DaggerStreams.instancesOf;
-import static dagger.model.BindingGraphProxies.childFactoryMethodEdge;
-import static dagger.model.BindingGraphProxies.componentNode;
-import static dagger.model.BindingGraphProxies.dependencyEdge;
+import static dagger.internal.codegen.DaggerStreams.presentValues;
+import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
+import static dagger.model.BindingKind.SUBCOMPONENT_BUILDER;
 
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
 import com.google.common.graph.MutableNetwork;
+import com.google.common.graph.Network;
 import com.google.common.graph.NetworkBuilder;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
 import dagger.model.BindingGraph.BindingNode;
@@ -36,15 +40,20 @@
 import dagger.model.DependencyRequest;
 import javax.inject.Inject;
 import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.TypeMirror;
 
 /** Converts {@link dagger.internal.codegen.BindingGraph}s to {@link dagger.model.BindingGraph}s. */
 final class BindingGraphConverter {
 
   private final BindingDeclarationFormatter bindingDeclarationFormatter;
+  private final CompilerOptions compilerOptions;
 
   @Inject
-  BindingGraphConverter(BindingDeclarationFormatter bindingDeclarationFormatter) {
+  BindingGraphConverter(
+      BindingDeclarationFormatter bindingDeclarationFormatter, CompilerOptions compilerOptions) {
     this.bindingDeclarationFormatter = bindingDeclarationFormatter;
+    this.compilerOptions = compilerOptions;
   }
 
   /**
@@ -54,9 +63,26 @@
   dagger.model.BindingGraph convert(BindingGraph rootGraph) {
     Traverser traverser = new Traverser(rootGraph);
     traverser.traverseComponents();
+
+    // When bindings are copied down into child graphs because they transitively depend on local
+    // multibindings or optional bindings, the parent-owned binding is still there. If that
+    // parent-owned binding is not reachable from its component, it doesn't need to be in the graph
+    // because it will never be used. So remove all nodes that are not reachable from the root
+    // component.
+    unreachableNodes(traverser.network.asGraph(), rootComponentNode(traverser.network))
+        .forEach(traverser.network::removeNode);
+
     return BindingGraphProxies.bindingGraph(traverser.network);
   }
 
+  // TODO(dpb): Example of BindingGraph logic applied to derived networks.
+  private ComponentNode rootComponentNode(Network<Node, Edge> network) {
+    return (ComponentNode)
+        Iterables.find(
+            network.nodes(),
+            node -> node instanceof ComponentNode && node.componentPath().atRoot());
+  }
+
   private final class Traverser extends ComponentTreeTraverser {
 
     private final MutableNetwork<Node, Edge> network =
@@ -66,7 +92,7 @@
     private ComponentNode currentComponent;
 
     Traverser(BindingGraph graph) {
-      super(graph);
+      super(graph, compilerOptions);
     }
 
     @Override
@@ -74,10 +100,8 @@ protected void visitComponent(BindingGraph graph) {
       ComponentNode grandparentComponent = parentComponent;
       parentComponent = currentComponent;
       currentComponent =
-          componentNode(
-              componentTreePath().toComponentPath(),
-              graph.componentDescriptor().entryPoints(),
-              graph.componentDescriptor().scopes());
+          ComponentNodeImpl.create(
+              componentTreePath().toComponentPath(), graph.componentDescriptor());
 
       network.addNode(currentComponent);
 
@@ -86,7 +110,17 @@ protected void visitComponent(BindingGraph graph) {
       }
 
       for (ResolvedBindings resolvedBindings : graph.resolvedBindings()) {
-        bindingNodes(resolvedBindings).forEach(node -> addBindingNode(node));
+        for (BindingNode node : bindingNodes(resolvedBindings)) {
+          addBindingNode(node);
+          if (node.binding().kind().equals(SUBCOMPONENT_BUILDER)
+              && node.componentPath().equals(currentComponent.componentPath())) {
+            network.addEdge(
+                node,
+                subcomponentNode(node.key().type(), graph),
+                new SubcomponentBuilderBindingEdgeImpl(
+                    subcomponentDeclaringModules(resolvedBindings)));
+          }
+        }
       }
 
       super.visitComponent(graph);
@@ -98,7 +132,8 @@ protected void visitComponent(BindingGraph graph) {
     @Override
     protected void visitSubcomponentFactoryMethod(
         BindingGraph graph, BindingGraph parent, ExecutableElement factoryMethod) {
-      network.addEdge(parentComponent, currentComponent, childFactoryMethodEdge(factoryMethod));
+      network.addEdge(
+          parentComponent, currentComponent, new ChildFactoryMethodEdgeImpl(factoryMethod));
       super.visitSubcomponentFactoryMethod(graph, parent, factoryMethod);
     }
 
@@ -122,7 +157,9 @@ private void addDependencyEdge(
       network.addNode(dependency);
       if (!hasDependencyEdge(source, dependency, dependencyRequest)) {
         network.addEdge(
-            source, dependency, dependencyEdge(dependencyRequest, source instanceof ComponentNode));
+            source,
+            dependency,
+            new DependencyEdgeImpl(dependencyRequest, source instanceof ComponentNode));
       }
     }
 
@@ -140,7 +177,7 @@ private ResolvedBindings resolvedDependencies(
       return componentTreePath()
           .pathFromRootToAncestor(source.componentPath().currentComponent())
           .currentGraph()
-          .resolvedBindings(dependencyRequest.kind(), dependencyRequest.key());
+          .resolvedBindings(bindingRequest(dependencyRequest));
     }
 
     /** Adds a binding node and edges for all its dependencies. */
@@ -191,5 +228,24 @@ private MissingBindingNode missingBindingNode(ResolvedBindings dependencies) {
               .toComponentPath(),
           dependencies.key());
     }
+
+    private ComponentNode subcomponentNode(TypeMirror subcomponentBuilderType, BindingGraph graph) {
+      TypeElement subcomponentBuilderElement = asTypeElement(subcomponentBuilderType);
+      ComponentDescriptor subcomponent =
+          graph.componentDescriptor().subcomponentsByBuilderType().get(subcomponentBuilderElement);
+      return ComponentNodeImpl.create(
+          componentTreePath().childPath(subcomponent.componentDefinitionType()).toComponentPath(),
+          subcomponent);
+    }
+
+    private ImmutableSet<TypeElement> subcomponentDeclaringModules(
+        ResolvedBindings resolvedBindings) {
+      return resolvedBindings
+          .subcomponentDeclarations()
+          .stream()
+          .map(SubcomponentDeclaration::contributingModule)
+          .flatMap(presentValues())
+          .collect(toImmutableSet());
+    }
   }
 }
diff --git a/java/dagger/internal/codegen/BindingGraphFactory.java b/java/dagger/internal/codegen/BindingGraphFactory.java
index 6647eb6c2..318f334bc 100644
--- a/java/dagger/internal/codegen/BindingGraphFactory.java
+++ b/java/dagger/internal/codegen/BindingGraphFactory.java
@@ -27,6 +27,7 @@
 import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
 import static dagger.internal.codegen.RequestKinds.getRequestKind;
 import static dagger.internal.codegen.Util.reentrantComputeIfAbsent;
+import static dagger.model.BindingKind.DELEGATE;
 import static dagger.model.BindingKind.OPTIONAL;
 import static dagger.model.BindingKind.SUBCOMPONENT_BUILDER;
 import static java.util.function.Predicate.isEqual;
@@ -47,6 +48,7 @@
 import dagger.internal.codegen.ComponentDescriptor.BuilderRequirementMethod;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodKind;
+import dagger.model.ComponentPath;
 import dagger.model.DependencyRequest;
 import dagger.model.Key;
 import dagger.model.Scope;
@@ -79,22 +81,29 @@
   private final InjectBindingRegistry injectBindingRegistry;
   private final KeyFactory keyFactory;
   private final BindingFactory bindingFactory;
+  private final IncorrectlyInstalledBindsMethodsValidator incorrectlyInstalledBindsMethodsValidator;
+  private final CompilerOptions compilerOptions;
 
   @Inject
   BindingGraphFactory(
       DaggerElements elements,
       InjectBindingRegistry injectBindingRegistry,
       KeyFactory keyFactory,
-      BindingFactory bindingFactory) {
+      BindingFactory bindingFactory,
+      IncorrectlyInstalledBindsMethodsValidator incorrectlyInstalledBindsMethodsValidator,
+      CompilerOptions compilerOptions) {
     this.elements = elements;
     this.injectBindingRegistry = injectBindingRegistry;
     this.keyFactory = keyFactory;
     this.bindingFactory = bindingFactory;
+    this.incorrectlyInstalledBindsMethodsValidator = incorrectlyInstalledBindsMethodsValidator;
+    this.compilerOptions = compilerOptions;
   }
 
   /** Creates a binding graph for a root component. */
   BindingGraph create(ComponentDescriptor componentDescriptor) {
-    checkArgument(componentDescriptor.kind().isTopLevel());
+    checkArgument(
+        componentDescriptor.kind().isTopLevel() || compilerOptions.aheadOfTimeSubcomponents());
     return create(Optional.empty(), componentDescriptor);
   }
 
@@ -593,7 +602,9 @@ private boolean isResolvedInParent(Key requestKey, ContributionBinding binding)
       if (binding.scope().isPresent() && binding.scope().get().isReusable()) {
         for (Resolver requestResolver : getResolverLineage().reverse()) {
           // If a @Reusable binding was resolved in an ancestor, use that component.
-          if (requestResolver.resolvedContributionBindings.containsKey(binding.key())) {
+          ResolvedBindings resolvedBindings =
+              requestResolver.resolvedContributionBindings.get(binding.key());
+          if (resolvedBindings != null && resolvedBindings.bindings().contains(binding)) {
             return Optional.of(requestResolver);
           }
         }
@@ -603,6 +614,7 @@ private boolean isResolvedInParent(Key requestKey, ContributionBinding binding)
 
       for (Resolver requestResolver : getResolverLineage().reverse()) {
         if (requestResolver.explicitBindingsSet.contains(binding)
+            || resolverContainsDelegateDeclarationForBinding(requestResolver, binding)
             || requestResolver.subcomponentDeclarations.containsKey(binding.key())) {
           return Optional.of(requestResolver);
         }
@@ -621,6 +633,71 @@ private boolean isResolvedInParent(Key requestKey, ContributionBinding binding)
       return Optional.empty();
     }
 
+    /**
+     * Returns true if {@code binding} was installed in a module in this resolver's component. If
+     * {@link CompilerOptions#floatingBindsMethods()} is enabled, calls {@link
+     * #recordFloatingBindsMethod(Resolver, ContributionBinding)} and returns false.
+     */
+    private boolean resolverContainsDelegateDeclarationForBinding(
+        Resolver resolver, ContributionBinding binding) {
+      // TODO(ronshapiro): remove the flag once we feel enough time has passed, and return this
+      // value directly. At that point, this can be remove the resolver parameter and become a
+      // method invoked on a particular resolver
+      boolean resolverContainsDeclaration =
+          binding.kind().equals(DELEGATE)
+              && resolver
+                  .delegateDeclarations
+                  .get(binding.key())
+                  .stream()
+                  .anyMatch(
+                      declaration ->
+                          declaration.contributingModule().equals(binding.contributingModule())
+                              && declaration.bindingElement().equals(binding.bindingElement()));
+      if (resolverContainsDeclaration && compilerOptions.floatingBindsMethods()) {
+        recordFloatingBindsMethod(resolver, binding);
+        return false;
+      }
+      return resolverContainsDeclaration;
+    }
+
+    /**
+     * Records binds methods that are resolved in the wrong component due to b/79859714. These will
+     * be reported later on in {@link IncorrectlyInstalledBindsMethodsValidator}.
+     */
+    private void recordFloatingBindsMethod(Resolver idealResolver, ContributionBinding binding) {
+      Resolver actualResolver = this;
+      if (binding.scope().isPresent()) {
+        for (Resolver requestResolver : getResolverLineage().reverse()) {
+          if (requestResolver.componentDescriptor.scopes().contains(binding.scope().get())) {
+            actualResolver = requestResolver;
+            break;
+          }
+        }
+      }
+      if (actualResolver != idealResolver) {
+        incorrectlyInstalledBindsMethodsValidator.recordBinding(
+            componentPath(idealResolver), binding);
+      }
+    }
+
+    /**
+     * Constructs a {@link ComponentPath} from the root component of this resolver to a {@code
+     * destination}.
+     */
+    private ComponentPath componentPath(Resolver destination) {
+      ImmutableList.Builder<TypeElement> path = ImmutableList.builder();
+      for (Resolver resolver : getResolverLineage()) {
+        path.add(resolver.componentDescriptor.componentDefinitionType());
+        if (resolver == destination) {
+          return ComponentPath.create(path.build());
+        }
+      }
+      throw new AssertionError(
+          String.format(
+              "%s not found in %s",
+              destination.componentDescriptor.componentDefinitionType(), path.build()));
+    }
+
     /** Returns the resolver lineage from parent to child. */
     private ImmutableList<Resolver> getResolverLineage() {
       List<Resolver> resolverList = Lists.newArrayList();
@@ -806,8 +883,8 @@ void resolve(Key key) {
       cycleStack.push(key);
       try {
         ResolvedBindings bindings = lookUpBindings(key);
-        resolveDependencies(bindings);
         resolvedContributionBindings.put(key, bindings);
+        resolveDependencies(bindings);
       } finally {
         cycleStack.pop();
       }
diff --git a/java/dagger/internal/codegen/BindingGraphPlugins.java b/java/dagger/internal/codegen/BindingGraphPlugins.java
index f21abac4f..9b2a38b8c 100644
--- a/java/dagger/internal/codegen/BindingGraphPlugins.java
+++ b/java/dagger/internal/codegen/BindingGraphPlugins.java
@@ -22,6 +22,7 @@
 import static java.lang.annotation.ElementType.METHOD;
 import static java.lang.annotation.ElementType.PARAMETER;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
+import static javax.tools.Diagnostic.Kind.ERROR;
 
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Maps;
@@ -110,4 +111,9 @@ private void initializePlugin(BindingGraphPlugin plugin) {
     }
     return diagnosticKinds.build();
   }
+
+  /** Returns {@code true} if any errors are reported by any of the plugins for {@code graph}. */
+  boolean pluginsReportErrors(BindingGraph graph) {
+    return visitGraph(graph).contains(ERROR);
+  }
 }
diff --git a/java/dagger/internal/codegen/BindingGraphValidationModule.java b/java/dagger/internal/codegen/BindingGraphValidationModule.java
index 54c245a1f..63e1fa255 100644
--- a/java/dagger/internal/codegen/BindingGraphValidationModule.java
+++ b/java/dagger/internal/codegen/BindingGraphValidationModule.java
@@ -28,41 +28,51 @@
   @Binds
   @IntoSet
   @Validation
-  BindingGraphPlugin duplicateBindings(DuplicateBindingsValidation validation);
+  BindingGraphPlugin dependencyCycle(DependencyCycleValidator validation);
 
   @Binds
   @IntoSet
   @Validation
-  BindingGraphPlugin incompatiblyScopedBindings(IncompatiblyScopedBindingsValidation validation);
+  BindingGraphPlugin dependsOnProductionExecutor(DependsOnProductionExecutorValidator validation);
 
   @Binds
   @IntoSet
   @Validation
-  BindingGraphPlugin injectBinding(InjectBindingValidation validation);
+  BindingGraphPlugin duplicateBindings(DuplicateBindingsValidator validation);
 
   @Binds
   @IntoSet
   @Validation
-  BindingGraphPlugin mapMultibinding(MapMultibindingValidation validation);
+  BindingGraphPlugin incompatiblyScopedBindings(IncompatiblyScopedBindingsValidator validation);
 
   @Binds
   @IntoSet
   @Validation
-  BindingGraphPlugin membersInjection(MembersInjectionBindingValidation validation);
+  BindingGraphPlugin injectBinding(InjectBindingValidator validation);
 
   @Binds
   @IntoSet
   @Validation
-  BindingGraphPlugin missingBinding(MissingBindingValidation validation);
+  BindingGraphPlugin mapMultibinding(MapMultibindingValidator validation);
 
   @Binds
   @IntoSet
   @Validation
-  BindingGraphPlugin nullable(NonNullableRequestForNullableBindingValidation validation);
+  BindingGraphPlugin missingBinding(MissingBindingValidator validation);
 
   @Binds
   @IntoSet
   @Validation
-  BindingGraphPlugin providerDependsOnProducer(
-      ProvisionDependencyOnProducerBindingValidation validation);
+  BindingGraphPlugin nullableBinding(NullableBindingValidator validation);
+
+  @Binds
+  @IntoSet
+  @Validation
+  BindingGraphPlugin provisionDependencyOnProducerBinding(
+      ProvisionDependencyOnProducerBindingValidator validation);
+
+  @Binds
+  @IntoSet
+  @Validation
+  BindingGraphPlugin subcomponentFactoryMethod(SubcomponentFactoryMethodValidator validation);
 }
diff --git a/java/dagger/internal/codegen/BindingMethodImplementation.java b/java/dagger/internal/codegen/BindingMethodImplementation.java
index b1d8aaae0..a3d9b3220 100644
--- a/java/dagger/internal/codegen/BindingMethodImplementation.java
+++ b/java/dagger/internal/codegen/BindingMethodImplementation.java
@@ -27,19 +27,19 @@
 /** Defines a method body and return type for a given {@link BindingExpression}. */
 class BindingMethodImplementation {
   private final ContributionBinding binding;
-  private final RequestKind requestKind;
+  private final BindingRequest request;
   private final BindingExpression bindingExpression;
   private final ClassName componentName;
   private final DaggerTypes types;
 
   BindingMethodImplementation(
       ResolvedBindings resolvedBindings,
-      RequestKind requestKind,
+      BindingRequest request,
       BindingExpression bindingExpression,
       ClassName componentName,
       DaggerTypes types) {
     this.binding = resolvedBindings.contributionBinding();
-    this.requestKind = checkNotNull(requestKind);
+    this.request = checkNotNull(request);
     this.bindingExpression = checkNotNull(bindingExpression);
     this.componentName = checkNotNull(componentName);
     this.types = checkNotNull(types);
@@ -62,11 +62,18 @@ protected final CodeBlock simpleBindingExpression() {
 
   /** Returns the return type for the dependency request. */
   final TypeMirror returnType() {
-    if (requestKind.equals(RequestKind.INSTANCE)
+    if (request.isRequestKind(RequestKind.INSTANCE)
         && binding.contributedPrimitiveType().isPresent()) {
       return binding.contributedPrimitiveType().get();
     }
-    return types.accessibleType(
-        requestType(requestKind, binding.contributedType(), types), componentName);
+    return types.accessibleType(requestedType(), componentName);
+  }
+
+  private TypeMirror requestedType() {
+    if (request.requestKind().isPresent()) {
+      return requestType(request.requestKind().get(), binding.contributedType(), types);
+    }
+    return types.wrapType(
+        binding.contributedType(), request.frameworkType().get().frameworkClass());
   }
 }
diff --git a/java/dagger/internal/codegen/BindingMethodValidator.java b/java/dagger/internal/codegen/BindingMethodValidator.java
index 3c18ebe73..32bc9f0fc 100644
--- a/java/dagger/internal/codegen/BindingMethodValidator.java
+++ b/java/dagger/internal/codegen/BindingMethodValidator.java
@@ -20,6 +20,7 @@
 import static dagger.internal.codegen.DaggerElements.isAnyAnnotationPresent;
 import static dagger.internal.codegen.InjectionAnnotations.getQualifiers;
 import static dagger.internal.codegen.MapKeys.getMapKeys;
+import static dagger.internal.codegen.Scopes.scopesOf;
 import static dagger.internal.codegen.Util.reentrantComputeIfAbsent;
 import static java.util.stream.Collectors.joining;
 import static javax.lang.model.element.Modifier.ABSTRACT;
@@ -34,6 +35,7 @@
 import com.google.errorprone.annotations.OverridingMethodsMustInvokeSuper;
 import dagger.MapKey;
 import dagger.Provides;
+import dagger.model.Scope;
 import dagger.multibindings.ElementsIntoSet;
 import dagger.multibindings.IntoMap;
 import dagger.producers.Produces;
@@ -44,6 +46,7 @@
 import javax.inject.Qualifier;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Types;
@@ -53,6 +56,7 @@
 
   private final DaggerElements elements;
   private final Types types;
+  private final DependencyRequestValidator dependencyRequestValidator;
   private final Class<? extends Annotation> methodAnnotation;
   private final ImmutableSet<? extends Class<? extends Annotation>> enclosingElementAnnotations;
   private final Abstractness abstractness;
@@ -70,6 +74,7 @@
   protected BindingMethodValidator(
       DaggerElements elements,
       Types types,
+      DependencyRequestValidator dependencyRequestValidator,
       Class<? extends Annotation> methodAnnotation,
       Class<? extends Annotation> enclosingElementAnnotation,
       Abstractness abstractness,
@@ -80,6 +85,7 @@ protected BindingMethodValidator(
         types,
         methodAnnotation,
         ImmutableSet.of(enclosingElementAnnotation),
+        dependencyRequestValidator,
         abstractness,
         exceptionSuperclass,
         allowsMultibindings);
@@ -97,6 +103,7 @@ protected BindingMethodValidator(
       Types types,
       Class<? extends Annotation> methodAnnotation,
       Iterable<? extends Class<? extends Annotation>> enclosingElementAnnotations,
+      DependencyRequestValidator dependencyRequestValidator,
       Abstractness abstractness,
       ExceptionSuperclass exceptionSuperclass,
       AllowsMultibindings allowsMultibindings) {
@@ -104,6 +111,7 @@ protected BindingMethodValidator(
     this.types = types;
     this.methodAnnotation = methodAnnotation;
     this.enclosingElementAnnotations = ImmutableSet.copyOf(enclosingElementAnnotations);
+    this.dependencyRequestValidator = dependencyRequestValidator;
     this.abstractness = abstractness;
     this.exceptionSuperclass = exceptionSuperclass;
     this.allowsMultibindings = allowsMultibindings;
@@ -150,6 +158,8 @@ protected void checkMethod(ValidationReport.Builder<ExecutableElement> builder)
     checkQualifiers(builder);
     checkMapKeys(builder);
     checkMultibindings(builder);
+    checkScopes(builder);
+    checkParameters(builder);
   }
 
   /**
@@ -297,7 +307,10 @@ protected void checkQualifiers(ValidationReport.Builder<ExecutableElement> build
     ImmutableSet<? extends AnnotationMirror> qualifiers = getQualifiers(builder.getSubject());
     if (qualifiers.size() > 1) {
       for (AnnotationMirror qualifier : qualifiers) {
-        builder.addError("Cannot use more than one @Qualifier", builder.getSubject(), qualifier);
+        builder.addError(
+            bindingMethods("may not use more than one @Qualifier"),
+            builder.getSubject(),
+            qualifier);
       }
     }
   }
@@ -360,6 +373,33 @@ protected void checkMultibindings(ValidationReport.Builder<ExecutableElement> bu
     }
   }
 
+  /** Adds an error if the method has more than one {@linkplain Scope scope} annotation. */
+  protected void checkScopes(ValidationReport.Builder<ExecutableElement> builder) {
+    ImmutableSet<Scope> scopes = scopesOf(builder.getSubject());
+    if (scopes.size() > 1) {
+      for (Scope scope : scopes) {
+        builder.addError(
+            "Cannot use more than one @Scope", builder.getSubject(), scope.scopeAnnotation());
+      }
+    }
+  }
+
+  /** Adds errors for the method parameters. */
+  protected void checkParameters(ValidationReport.Builder<ExecutableElement> builder) {
+    for (VariableElement parameter : builder.getSubject().getParameters()) {
+      checkParameter(builder, parameter);
+    }
+  }
+
+  /**
+   * Adds errors for a method parameter. This implementation reports an error if the parameter has
+   * more than one qualifier.
+   */
+  protected void checkParameter(
+      ValidationReport.Builder<ExecutableElement> builder, VariableElement parameter) {
+    dependencyRequestValidator.validateDependencyRequest(builder, parameter, parameter.asType());
+  }
+
   /** Adds an error if the method returns a {@linkplain FrameworkTypes framework type}. */
   protected void checkFrameworkType(ValidationReport.Builder<ExecutableElement> builder) {
     if (FrameworkTypes.isFrameworkType(builder.getSubject().getReturnType())) {
diff --git a/java/dagger/internal/codegen/BindingRequest.java b/java/dagger/internal/codegen/BindingRequest.java
new file mode 100644
index 000000000..5bf1d9319
--- /dev/null
+++ b/java/dagger/internal/codegen/BindingRequest.java
@@ -0,0 +1,101 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static dagger.internal.codegen.RequestKinds.requestTypeName;
+
+import com.google.auto.value.AutoValue;
+import com.squareup.javapoet.TypeName;
+import dagger.model.DependencyRequest;
+import dagger.model.Key;
+import dagger.model.RequestKind;
+import java.util.Optional;
+
+/**
+ * A request for a binding, which may be in the form of a request for a dependency to pass to a
+ * constructor or module method ({@link RequestKind}) or an internal request for a framework
+ * instance ({@link FrameworkType}).
+ */
+@AutoValue
+abstract class BindingRequest {
+
+  /** Creates a {@link BindingRequest} for the given {@link DependencyRequest}. */
+  static BindingRequest bindingRequest(DependencyRequest dependencyRequest) {
+    return bindingRequest(dependencyRequest.key(), dependencyRequest.kind());
+  }
+
+  /**
+   * Creates a {@link BindingRequest} for a normal dependency request for the given {@link Key} and
+   * {@link RequestKind}.
+   */
+  static BindingRequest bindingRequest(Key key, RequestKind requestKind) {
+    // When there's a request that has a 1:1 mapping to a FrameworkType, the request should be
+    // associated with that FrameworkType as well, because we want to ensure that if a request
+    // comes in for that as a dependency first and as a framework instance later, they resolve to
+    // the same binding expression.
+    // TODO(cgdecker): Instead of doing this, make ComponentBindingExpressions create a
+    // BindingExpression for the RequestKind that simply delegates to the BindingExpression for the
+    // FrameworkType. Then there are separate BindingExpressions, but we don't end up doing weird
+    // things like creating two fields when there should only be one.
+    return new AutoValue_BindingRequest(
+        key, Optional.of(requestKind), FrameworkType.forRequestKind(requestKind));
+  }
+
+  /**
+   * Creates a {@link BindingRequest} for a request for a framework instance for the given {@link
+   * Key} with the given {@link FrameworkType}.
+   */
+  static BindingRequest bindingRequest(Key key, FrameworkType frameworkType) {
+    return new AutoValue_BindingRequest(
+        key, frameworkType.requestKind(), Optional.of(frameworkType));
+  }
+
+  /** Creates a {@link BindingRequest} for the given {@link FrameworkDependency}. */
+  static BindingRequest bindingRequest(FrameworkDependency frameworkDependency) {
+    return bindingRequest(frameworkDependency.key(), frameworkDependency.frameworkType());
+  }
+
+  /** Returns the {@link Key} for the requested binding. */
+  abstract Key key();
+
+  /** Returns the request kind associated with this request, if any. */
+  abstract Optional<RequestKind> requestKind();
+
+  /** Returns the framework type associated with this request, if any. */
+  abstract Optional<FrameworkType> frameworkType();
+
+  /** Returns whether this request is of the given kind. */
+  final boolean isRequestKind(RequestKind requestKind) {
+    return requestKind.equals(requestKind().orElse(null));
+  }
+
+  /** Returns the type name for the requested type. */
+  final TypeName typeName() {
+    TypeName keyTypeName = TypeName.get(key().type());
+    if (requestKind().isPresent()) {
+      return requestTypeName(requestKind().get(), keyTypeName);
+    }
+    return frameworkType().get().frameworkClassOf(keyTypeName);
+  }
+
+  /** Returns a name that can be used for the kind of request this is. */
+  final String kindName() {
+    Object requestKindObject =
+        requestKind().isPresent() ? requestKind().get() : frameworkType().get();
+    return requestKindObject.toString();
+  }
+}
diff --git a/java/dagger/internal/codegen/BindingType.java b/java/dagger/internal/codegen/BindingType.java
index 696f00e76..37109c73b 100644
--- a/java/dagger/internal/codegen/BindingType.java
+++ b/java/dagger/internal/codegen/BindingType.java
@@ -16,51 +16,16 @@
 
 package dagger.internal.codegen;
 
-import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.Sets;
-import com.squareup.javapoet.ClassName;
-import com.squareup.javapoet.ParameterizedTypeName;
-import com.squareup.javapoet.TypeName;
 import dagger.MembersInjector;
-import dagger.producers.Producer;
-import javax.inject.Provider;
 
 /** Whether a binding or declaration is for provision, production, or a {@link MembersInjector}. */
-// TODO(dpb): Merge with FrameworkType?
 enum BindingType {
   /** A binding with this type is a {@link ProvisionBinding}. */
-  PROVISION(Provider.class, FrameworkType.PROVIDER),
+  PROVISION,
 
   /** A binding with this type is a {@link MembersInjectionBinding}. */
-  MEMBERS_INJECTION(MembersInjector.class, FrameworkType.MEMBERS_INJECTOR),
+  MEMBERS_INJECTION,
 
   /** A binding with this type is a {@link ProductionBinding}. */
-  PRODUCTION(Producer.class, FrameworkType.PRODUCER),
-  ;
-
-  static final ImmutableSet<BindingType> CONTRIBUTION_TYPES =
-      Sets.immutableEnumSet(PROVISION, PRODUCTION);
-
-  private final Class<?> frameworkClass;
-  private final FrameworkType frameworkType;
-
-  private BindingType(Class<?> frameworkClass, FrameworkType frameworkType) {
-    this.frameworkClass = frameworkClass;
-    this.frameworkType = frameworkType;
-  }
-
-  /** The framework class associated with bindings of this type. */
-  Class<?> frameworkClass() {
-    return frameworkClass;
-  }
-
-  /** The framework type used to represent bindings of this type. */
-  FrameworkType frameworkType() {
-    return frameworkType;
-  }
-
-  /** Returns the {@link #frameworkClass()} parameterized with a type. */
-  ParameterizedTypeName frameworkClassOf(TypeName valueType) {
-    return ParameterizedTypeName.get(ClassName.get(frameworkClass()), valueType);
-  }
+  PRODUCTION,
 }
diff --git a/java/dagger/internal/codegen/BindsMethodValidator.java b/java/dagger/internal/codegen/BindsMethodValidator.java
index 78909e84e..a9b15d135 100644
--- a/java/dagger/internal/codegen/BindsMethodValidator.java
+++ b/java/dagger/internal/codegen/BindsMethodValidator.java
@@ -16,7 +16,6 @@
 
 package dagger.internal.codegen;
 
-import static com.google.common.collect.Iterables.getOnlyElement;
 import static dagger.internal.codegen.BindingMethodValidator.Abstractness.MUST_BE_ABSTRACT;
 import static dagger.internal.codegen.BindingMethodValidator.AllowsMultibindings.ALLOWS_MULTIBINDINGS;
 import static dagger.internal.codegen.BindingMethodValidator.ExceptionSuperclass.RUNTIME_EXCEPTION;
@@ -26,7 +25,6 @@
 import dagger.Binds;
 import dagger.Module;
 import dagger.producers.ProducerModule;
-import java.util.List;
 import javax.inject.Inject;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.VariableElement;
@@ -41,12 +39,14 @@
   private final BindsTypeChecker bindsTypeChecker;
 
   @Inject
-  BindsMethodValidator(DaggerElements elements, Types types) {
+  BindsMethodValidator(
+      DaggerElements elements, Types types, DependencyRequestValidator dependencyRequestValidator) {
     super(
         elements,
         types,
         Binds.class,
         ImmutableSet.of(Module.class, ProducerModule.class),
+        dependencyRequestValidator,
         MUST_BE_ABSTRACT,
         RUNTIME_EXCEPTION,
         ALLOWS_MULTIBINDINGS);
@@ -60,29 +60,36 @@ protected void checkMethod(ValidationReport.Builder<ExecutableElement> builder)
     checkParameters(builder);
   }
 
-  private void checkParameters(ValidationReport.Builder<ExecutableElement> builder) {
+  @Override
+  protected void checkParameters(ValidationReport.Builder<ExecutableElement> builder) {
     ExecutableElement method = builder.getSubject();
-    List<? extends VariableElement> parameters = method.getParameters();
-    if (parameters.size() == 1) {
-      VariableElement parameter = getOnlyElement(parameters);
-      TypeMirror leftHandSide = boxIfNecessary(method.getReturnType());
-      TypeMirror rightHandSide = parameter.asType();
-      ContributionType contributionType = ContributionType.fromBindingMethod(method);
-      if (contributionType.equals(ContributionType.SET_VALUES) && !SetType.isSet(leftHandSide)) {
-        builder.addError(
-            "@Binds @ElementsIntoSet methods must return a Set and take a Set parameter");
-      }
-
-      if (!bindsTypeChecker.isAssignable(rightHandSide, leftHandSide, contributionType)) {
-        // TODO(ronshapiro): clarify this error message for @ElementsIntoSet cases, where the
-        // right-hand-side might not be assignable to the left-hand-side, but still compatible with
-        // Set.addAll(Collection<? extends E>)
-        builder.addError("@Binds methods' parameter type must be assignable to the return type");
-      }
+    if (method.getParameters().size() != 1) {
+      builder.addError(
+          bindingMethods(
+              "must have exactly one parameter, whose type is assignable to the return type"));
     } else {
+      super.checkParameters(builder);
+    }
+  }
+
+  @Override
+  protected void checkParameter(
+      ValidationReport.Builder<ExecutableElement> builder, VariableElement parameter) {
+    super.checkParameter(builder, parameter);
+    ExecutableElement method = builder.getSubject();
+    TypeMirror leftHandSide = boxIfNecessary(method.getReturnType());
+    TypeMirror rightHandSide = parameter.asType();
+    ContributionType contributionType = ContributionType.fromBindingMethod(method);
+    if (contributionType.equals(ContributionType.SET_VALUES) && !SetType.isSet(leftHandSide)) {
       builder.addError(
-          "@Binds methods must have exactly one parameter, "
-              + "whose type is assignable to the return type");
+          "@Binds @ElementsIntoSet methods must return a Set and take a Set parameter");
+    }
+
+    if (!bindsTypeChecker.isAssignable(rightHandSide, leftHandSide, contributionType)) {
+      // TODO(ronshapiro): clarify this error message for @ElementsIntoSet cases, where the
+      // right-hand-side might not be assignable to the left-hand-side, but still compatible with
+      // Set.addAll(Collection<? extends E>)
+      builder.addError("@Binds methods' parameter type must be assignable to the return type");
     }
   }
 
diff --git a/java/dagger/internal/codegen/BindsOptionalOfMethodValidator.java b/java/dagger/internal/codegen/BindsOptionalOfMethodValidator.java
index 1210ed6d6..c12dd78d7 100644
--- a/java/dagger/internal/codegen/BindsOptionalOfMethodValidator.java
+++ b/java/dagger/internal/codegen/BindsOptionalOfMethodValidator.java
@@ -22,12 +22,14 @@
 import static dagger.internal.codegen.InjectionAnnotations.getQualifiers;
 import static dagger.internal.codegen.InjectionAnnotations.injectedConstructors;
 import static dagger.internal.codegen.Keys.isValidImplicitProvisionKey;
+import static dagger.internal.codegen.Scopes.scopesOf;
 
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.common.collect.ImmutableSet;
 import dagger.BindsOptionalOf;
 import dagger.Module;
+import dagger.model.Scope;
 import dagger.producers.ProducerModule;
 import javax.inject.Inject;
 import javax.lang.model.element.ExecutableElement;
@@ -40,12 +42,14 @@
   private final Types types;
 
   @Inject
-  BindsOptionalOfMethodValidator(DaggerElements elements, Types types) {
+  BindsOptionalOfMethodValidator(
+      DaggerElements elements, Types types, DependencyRequestValidator dependencyRequestValidator) {
     super(
         elements,
         types,
         BindsOptionalOf.class,
         ImmutableSet.of(Module.class, ProducerModule.class),
+        dependencyRequestValidator,
         MUST_BE_ABSTRACT,
         NO_EXCEPTIONS,
         NO_MULTIBINDINGS);
@@ -72,9 +76,20 @@ protected void checkKeyType(
     }
   }
 
-  private void checkParameters(ValidationReport.Builder<ExecutableElement> builder) {
+  @Override
+  protected void checkParameters(ValidationReport.Builder<ExecutableElement> builder) {
     if (!builder.getSubject().getParameters().isEmpty()) {
       builder.addError("@BindsOptionalOf methods cannot have parameters");
     }
   }
+
+  @Override
+  protected void checkScopes(ValidationReport.Builder<ExecutableElement> builder) {
+    for (Scope scope : scopesOf(builder.getSubject())) {
+      builder.addError(
+          "@BindsOptionalOf methods cannot be scoped",
+          builder.getSubject(),
+          scope.scopeAnnotation());
+    }
+  }
 }
diff --git a/java/dagger/internal/codegen/BuilderValidator.java b/java/dagger/internal/codegen/BuilderValidator.java
index 2d6906f5d..543cd5691 100644
--- a/java/dagger/internal/codegen/BuilderValidator.java
+++ b/java/dagger/internal/codegen/BuilderValidator.java
@@ -19,6 +19,7 @@
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.collect.Iterables.getOnlyElement;
+import static dagger.internal.codegen.DaggerElements.isAnyAnnotationPresent;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.STATIC;
@@ -27,6 +28,7 @@
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.common.collect.ImmutableSet;
+import dagger.BindsInstance;
 import dagger.internal.codegen.ErrorMessages.ComponentBuilderMessages;
 import java.lang.annotation.Annotation;
 import java.util.Arrays;
@@ -110,51 +112,66 @@
       ExecutableType resolvedMethodType =
           MoreTypes.asExecutable(types.asMemberOf(MoreTypes.asDeclared(subject.asType()), method));
       TypeMirror returnType = resolvedMethodType.getReturnType();
-      if (method.getParameters().size() == 0) {
-        // If this is potentially a build() method, validate it returns the correct type.
-        if (types.isSubtype(componentElement.asType(), returnType)) {
-          validateBuildMethodReturnType(
-              builder,
-              // since types.isSubtype() passed, componentElement cannot be a PackageElement
-              MoreElements.asType(componentElement),
-              msgs,
-              method,
-              returnType);
-          if (buildMethod != null) {
-            // If we found more than one build-like method, fail.
+      switch (method.getParameters().size()) {
+        case 0: // If this is potentially a build() method, validate it returns the correct type.
+          if (types.isSubtype(componentElement.asType(), returnType)) {
+            validateBuildMethodReturnType(
+                builder,
+                // since types.isSubtype() passed, componentElement cannot be a PackageElement
+                MoreElements.asType(componentElement),
+                msgs,
+                method,
+                returnType);
+            if (buildMethod != null) {
+              // If we found more than one build-like method, fail.
+              error(
+                  builder,
+                  method,
+                  msgs.twoBuildMethods(),
+                  msgs.inheritedTwoBuildMethods(),
+                  buildMethod);
+            }
+          } else {
             error(
                 builder,
                 method,
-                msgs.twoBuildMethods(),
-                msgs.inheritedTwoBuildMethods(),
-                buildMethod);
+                msgs.buildMustReturnComponentType(),
+                msgs.inheritedBuildMustReturnComponentType());
           }
-        } else {
+          // We set the buildMethod regardless of the return type to reduce error spam.
+          buildMethod = method;
+          break;
+
+        case 1: // If this correctly had one parameter, make sure the return types are valid.
+          if (returnType.getKind() != TypeKind.VOID
+              && !types.isSubtype(subject.asType(), returnType)) {
+            error(
+                builder,
+                method,
+                msgs.methodsMustReturnVoidOrBuilder(),
+                msgs.inheritedMethodsMustReturnVoidOrBuilder());
+          }
+          if (!method.getTypeParameters().isEmpty()) {
+            error(
+                builder,
+                method,
+                msgs.methodsMayNotHaveTypeParameters(),
+                msgs.inheritedMethodsMayNotHaveTypeParameters());
+          }
+          if (!isAnyAnnotationPresent(method, BindsInstance.class)
+              && method.getParameters().get(0).asType().getKind().isPrimitive()) {
+            error(
+                builder,
+                method,
+                msgs.nonBindsInstanceMethodsMayNotTakePrimitives(),
+                msgs.inheritedNonBindsInstanceMethodsMayNotTakePrimitives());
+          }
+          break;
+
+        default: // more than one parameter
           error(
-              builder,
-              method,
-              msgs.buildMustReturnComponentType(),
-              msgs.inheritedBuildMustReturnComponentType());
-        }
-        // We set the buildMethod regardless of the return type to reduce error spam.
-        buildMethod = method;
-      } else if (method.getParameters().size() > 1) {
-        // If this is a setter, make sure it has one arg.
-        error(builder, method, msgs.methodsMustTakeOneArg(), msgs.inheritedMethodsMustTakeOneArg());
-      } else if (returnType.getKind() != TypeKind.VOID
-          && !types.isSubtype(subject.asType(), returnType)) {
-        // If this correctly had one arg, make sure the return types are valid.
-        error(
-            builder,
-            method,
-            msgs.methodsMustReturnVoidOrBuilder(),
-            msgs.inheritedMethodsMustReturnVoidOrBuilder());
-      } else if (!method.getTypeParameters().isEmpty()) {
-        error(
-            builder,
-            method,
-            msgs.methodsMayNotHaveTypeParameters(),
-            msgs.inheritedMethodsMayNotHaveTypeParameters());
+              builder, method, msgs.methodsMustTakeOneArg(), msgs.inheritedMethodsMustTakeOneArg());
+          break;
       }
     }
 
@@ -162,7 +179,7 @@
       builder.addError(msgs.missingBuildMethod(), subject);
     }
 
-    // Note: there's more validation in BindingGraphValidator:
+    // Note: there's more validation in ComponentDescriptorValidator:
     // - to make sure the setter methods mirror the deps
     // - to make sure each type or key is set by only one method
 
diff --git a/java/dagger/internal/codegen/ChildFactoryMethodEdgeImpl.java b/java/dagger/internal/codegen/ChildFactoryMethodEdgeImpl.java
new file mode 100644
index 000000000..8a81017f5
--- /dev/null
+++ b/java/dagger/internal/codegen/ChildFactoryMethodEdgeImpl.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static dagger.internal.codegen.DaggerElements.elementToString;
+
+import dagger.model.BindingGraph.ChildFactoryMethodEdge;
+import javax.lang.model.element.ExecutableElement;
+
+/** An implementation of {@link ChildFactoryMethodEdge}. */
+final class ChildFactoryMethodEdgeImpl implements ChildFactoryMethodEdge {
+
+  private final ExecutableElement factoryMethod;
+
+  ChildFactoryMethodEdgeImpl(ExecutableElement factoryMethod) {
+    this.factoryMethod = factoryMethod;
+  }
+
+  @Override
+  public ExecutableElement factoryMethod() {
+    return factoryMethod;
+  }
+
+  @Override
+  public String toString() {
+    return elementToString(factoryMethod);
+  }
+}
diff --git a/java/dagger/internal/codegen/CompilerOptions.java b/java/dagger/internal/codegen/CompilerOptions.java
index 7d97e2a26..ee59bf0cd 100644
--- a/java/dagger/internal/codegen/CompilerOptions.java
+++ b/java/dagger/internal/codegen/CompilerOptions.java
@@ -16,18 +16,32 @@
 
 package dagger.internal.codegen;
 
+import static com.google.common.base.CaseFormat.LOWER_CAMEL;
+import static com.google.common.base.CaseFormat.UPPER_UNDERSCORE;
 import static com.google.common.base.Preconditions.checkState;
+import static com.google.common.collect.Iterables.concat;
+import static com.google.common.collect.Sets.immutableEnumSet;
+import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
+import static dagger.internal.codegen.FeatureStatus.DISABLED;
+import static dagger.internal.codegen.FeatureStatus.ENABLED;
+import static dagger.internal.codegen.ValidationType.ERROR;
+import static dagger.internal.codegen.ValidationType.WARNING;
+import static java.util.EnumSet.allOf;
 
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Ascii;
 import com.google.common.collect.ImmutableSet;
+import com.google.errorprone.annotations.CanIgnoreReturnValue;
+import com.google.errorprone.annotations.CheckReturnValue;
 import dagger.producers.Produces;
-import java.util.EnumSet;
+import java.util.Arrays;
 import java.util.Map;
 import java.util.Set;
+import java.util.function.BiConsumer;
+import java.util.stream.Stream;
 import javax.annotation.processing.ProcessingEnvironment;
+import javax.annotation.processing.Processor;
 import javax.tools.Diagnostic;
-import javax.tools.Diagnostic.Kind;
 
 /** A collection of options that dictate how the compiler will run. */
 @AutoValue
@@ -35,20 +49,14 @@
   abstract boolean usesProducers();
 
   /**
-   * Returns true if the experimental Android mode is enabled.
+   * Returns true if the fast initialization flag, {@code fastInit}, is enabled.
    *
-   * <p><b>Warning: Do Not use! This flag is for internal, experimental use only!</b>
-   *
-   * <p>Issues related to this flag will not be supported. This flag could break your build, cause
-   * memory leaks in your app, or cause other unknown issues at runtime.
-   *
-   * <p>If enabled, the generated code will attempt to more aggressively inline creation logic for
-   * bindings inside of the component rather than in a separate factory class. Enabling this flag
-   * should reduced the class loading and the number of eagerly initialized fields, at the cost of
-   * potential memory leaks and higher per-provision instantiation time. Due to very slow
-   * classloading on Android, these trade-offs are potentially advantageous.
+   * <p>If enabled, the generated code will attempt to optimize for fast component initialization.
+   * This is done by reducing the number of factory classes loaded during initialization and the
+   * number of eagerly initialized fields at the cost of potential memory leaks and higher
+   * per-provision instantiation time.
    */
-  abstract boolean experimentalAndroidMode();
+  abstract boolean fastInit();
 
   /**
    * Returns true if the experimental Android mode 2 is enabled.
@@ -63,18 +71,27 @@
    */
   abstract boolean experimentalAndroidMode2();
 
+  abstract boolean formatGeneratedSource();
+
   abstract boolean writeProducerNameInToken();
 
   abstract Diagnostic.Kind nullableValidationKind();
 
   boolean doCheckForNulls() {
-    return nullableValidationKind().equals(Kind.ERROR);
+    return nullableValidationKind().equals(Diagnostic.Kind.ERROR);
   }
 
   abstract Diagnostic.Kind privateMemberValidationKind();
 
   abstract Diagnostic.Kind staticMemberValidationKind();
 
+  /**
+   * If {@code true}, Dagger will generate factories and components even if some members-injected
+   * types have {@code private} or {@code static} {@code @Inject}-annotated members.
+   *
+   * <p>This should only ever be enabled by the TCK tests. Disabling this validation could lead to
+   * generating code that does not compile.
+   */
   abstract boolean ignorePrivateAndStaticInjectionForComponent();
 
   abstract ValidationType scopeCycleValidationType();
@@ -83,54 +100,47 @@ boolean doCheckForNulls() {
 
   abstract boolean headerCompilation();
 
-  abstract boolean aheadOfTimeComponents();
+  abstract boolean aheadOfTimeSubcomponents();
+
+  /** See b/79859714 */
+  abstract boolean floatingBindsMethods();
+
+  abstract boolean useGradleIncrementalProcessing();
 
   static Builder builder() {
-    return new AutoValue_CompilerOptions.Builder().headerCompilation(false);
+    return new AutoValue_CompilerOptions.Builder()
+        .headerCompilation(false)
+        .useGradleIncrementalProcessing(false);
   }
 
-  static CompilerOptions create(ProcessingEnvironment processingEnv, DaggerElements elements) {
+  static CompilerOptions create(ProcessingEnvironment processingEnv) {
+    Builder builder = new AutoValue_CompilerOptions.Builder();
+    for (Option option : concat(allOf(Feature.class), allOf(Validation.class))) {
+      option.set(builder, processingEnv);
+    }
+    return builder.build().validate();
+  }
+
+  CompilerOptions validate() {
     checkState(
-        !(experimentalAndroidModeFeatureStatus(processingEnv).equals(FeatureStatus.ENABLED)
-            && experimentalAndroidMode2FeatureStatus(processingEnv).equals(FeatureStatus.ENABLED)),
-        "experimentalAndroidMode and experimentalAndroidMode2 cannot be used together.");
-
-    return builder()
-        .usesProducers(elements.getTypeElement(Produces.class) != null)
-        .headerCompilation(processingEnv.getOptions().containsKey(HEADER_COMPILATION))
-        .experimentalAndroidMode(
-            experimentalAndroidModeFeatureStatus(processingEnv).equals(FeatureStatus.ENABLED))
-        .experimentalAndroidMode2(
-            experimentalAndroidMode2FeatureStatus(processingEnv).equals(FeatureStatus.ENABLED))
-        .writeProducerNameInToken(
-            writeProducerNameInTokenFeatureStatus(processingEnv).equals(FeatureStatus.ENABLED))
-        .nullableValidationKind(nullableValidationType(processingEnv).diagnosticKind().get())
-        .privateMemberValidationKind(
-            privateMemberValidationType(processingEnv).diagnosticKind().get())
-        .staticMemberValidationKind(
-            staticMemberValidationType(processingEnv).diagnosticKind().get())
-        .ignorePrivateAndStaticInjectionForComponent(
-            ignorePrivateAndStaticInjectionForComponentFeatureStatus(processingEnv)
-                .equals(FeatureStatus.DISABLED))
-        .scopeCycleValidationType(scopeValidationType(processingEnv))
-        .warnIfInjectionFactoryNotGeneratedUpstream(
-            warnIfInjectionFactoryNotGeneratedUpstreamFeatureStatus(processingEnv)
-                .equals(FeatureStatus.ENABLED))
-        .aheadOfTimeComponents(
-            aheadOfTimeComponentsFeatureStatus(processingEnv).equals(FeatureStatus.ENABLED))
-        .build();
+        !(fastInit() && experimentalAndroidMode2()),
+        "fastInit/experimentalAndroidMode and experimentalAndroidMode2 cannot be used together.");
+    return this;
   }
 
   @AutoValue.Builder
+  @CanIgnoreReturnValue
   interface Builder {
     Builder usesProducers(boolean usesProduces);
 
     Builder headerCompilation(boolean headerCompilation);
 
-    Builder experimentalAndroidMode(boolean experimentalAndroidMode);
+    Builder fastInit(boolean fastInit);
 
     Builder experimentalAndroidMode2(boolean experimentalAndroidMode2);
 
+    Builder formatGeneratedSource(boolean formatGeneratedSource);
+
     Builder writeProducerNameInToken(boolean writeProducerNameInToken);
 
     Builder nullableValidationKind(Diagnostic.Kind kind);
@@ -147,164 +157,219 @@ Builder ignorePrivateAndStaticInjectionForComponent(
     Builder warnIfInjectionFactoryNotGeneratedUpstream(
         boolean warnIfInjectionFactoryNotGeneratedUpstream);
 
-    Builder aheadOfTimeComponents(boolean aheadOfTimeComponents);
+    Builder aheadOfTimeSubcomponents(boolean aheadOfTimeSubcomponents);
 
+    Builder floatingBindsMethods(boolean enabled);
+
+    Builder useGradleIncrementalProcessing(boolean enabled);
+
+    @CheckReturnValue
     CompilerOptions build();
   }
 
-  private static final String HEADER_COMPILATION = "experimental_turbine_hjar";
+  /** An option that can be set into {@link CompilerOptions}. */
+  private interface Option {
 
-  static final String EXPERIMENTAL_ANDROID_MODE = "dagger.experimentalAndroidMode";
+    /** Sets the appropriate property on a {@link CompilerOptions,Builder}. */
+    void set(Builder builder, ProcessingEnvironment processingEnvironment);
 
-  static final String EXPERIMENTAL_ANDROID_MODE2 = "dagger.experimentalAndroidMode2";
+    /**
+     * {@code true} if {@link #toString()} represents a {@linkplain Processor#getSupportedOptions()
+     * supported command line option}.
+     */
+    default boolean useCommandLineOption() {
+      return true;
+    }
+  }
 
-  static final String WRITE_PRODUCER_NAME_IN_TOKEN_KEY = "dagger.writeProducerNameInToken";
+  /** A feature that can be enabled or disabled. */
+  private enum Feature implements Option {
+    HEADER_COMPILATION(Builder::headerCompilation) {
+      @Override
+      boolean isEnabled(ProcessingEnvironment processingEnvironment) {
+        return processingEnvironment.getOptions().containsKey(toString());
+      }
 
-  static final String DISABLE_INTER_COMPONENT_SCOPE_VALIDATION_KEY =
-      "dagger.disableInterComponentScopeValidation";
+      @Override
+      public boolean useCommandLineOption() {
+        return false;
+      }
 
-  static final String NULLABLE_VALIDATION_KEY = "dagger.nullableValidation";
+      @Override
+      public String toString() {
+        return "experimental_turbine_hjar";
+      }
+    },
 
-  static final String PRIVATE_MEMBER_VALIDATION_TYPE_KEY = "dagger.privateMemberValidation";
+    FAST_INIT(Builder::fastInit) {
+      @Override
+      boolean isEnabled(ProcessingEnvironment processingEnvironment) {
+        return super.isEnabled(processingEnvironment)
+            || EXPERIMENTAL_ANDROID_MODE.isEnabled(processingEnvironment);
+      }
+    },
 
-  static final String STATIC_MEMBER_VALIDATION_TYPE_KEY = "dagger.staticMemberValidation";
+    // TODO(user): Remove once all usages are migrated to FAST_INIT.
+    EXPERIMENTAL_ANDROID_MODE((builder, enabled) -> {}),
 
-  static final String WARN_IF_INJECTION_FACTORY_NOT_GENERATED_UPSTREAM_KEY =
-      "dagger.warnIfInjectionFactoryNotGeneratedUpstream";
+    EXPERIMENTAL_ANDROID_MODE2(Builder::experimentalAndroidMode2),
 
-  /**
-   * If true, Dagger will generate factories and components even if some members-injected types have
-   * private or static {@code @Inject}-annotated members.
-   *
-   * <p>This defaults to false, and should only ever be enabled by the TCK tests. Disabling this
-   * validation could lead to generating code that does not compile.
-   */
-  static final String IGNORE_PRIVATE_AND_STATIC_INJECTION_FOR_COMPONENT =
-      "dagger.ignorePrivateAndStaticInjectionForComponent";
+    FORMAT_GENERATED_SOURCE(Builder::formatGeneratedSource, ENABLED),
 
-  static final String AHEAD_OF_TIME_COMPONENTS_KEY = "dagger.experimentalAheadOfTimeComponents";
+    WRITE_PRODUCER_NAME_IN_TOKEN(Builder::writeProducerNameInToken),
 
-  static final ImmutableSet<String> SUPPORTED_OPTIONS =
-      ImmutableSet.of(
-          EXPERIMENTAL_ANDROID_MODE,
-          HEADER_COMPILATION,
-          WRITE_PRODUCER_NAME_IN_TOKEN_KEY,
-          DISABLE_INTER_COMPONENT_SCOPE_VALIDATION_KEY,
-          NULLABLE_VALIDATION_KEY,
-          PRIVATE_MEMBER_VALIDATION_TYPE_KEY,
-          STATIC_MEMBER_VALIDATION_TYPE_KEY,
-          WARN_IF_INJECTION_FACTORY_NOT_GENERATED_UPSTREAM_KEY,
-          IGNORE_PRIVATE_AND_STATIC_INJECTION_FOR_COMPONENT,
-          AHEAD_OF_TIME_COMPONENTS_KEY);
-
-  private static FeatureStatus experimentalAndroidModeFeatureStatus(
-      ProcessingEnvironment processingEnv) {
-    return valueOf(
-        processingEnv,
-        EXPERIMENTAL_ANDROID_MODE,
-        FeatureStatus.DISABLED,
-        EnumSet.allOf(FeatureStatus.class));
-  }
+    WARN_IF_INJECTION_FACTORY_NOT_GENERATED_UPSTREAM(
+        Builder::warnIfInjectionFactoryNotGeneratedUpstream),
 
-  private static FeatureStatus experimentalAndroidMode2FeatureStatus(
-      ProcessingEnvironment processingEnv) {
-    return valueOf(
-        processingEnv,
-        EXPERIMENTAL_ANDROID_MODE2,
-        FeatureStatus.DISABLED,
-        EnumSet.allOf(FeatureStatus.class));
-  }
+    IGNORE_PRIVATE_AND_STATIC_INJECTION_FOR_COMPONENT(
+        Builder::ignorePrivateAndStaticInjectionForComponent),
 
-  private static FeatureStatus writeProducerNameInTokenFeatureStatus(
-      ProcessingEnvironment processingEnv) {
-    return valueOf(
-        processingEnv,
-        WRITE_PRODUCER_NAME_IN_TOKEN_KEY,
-        FeatureStatus.DISABLED,
-        EnumSet.allOf(FeatureStatus.class));
-  }
+    EXPERIMENTAL_AHEAD_OF_TIME_SUBCOMPONENTS(Builder::aheadOfTimeSubcomponents),
 
-  private static ValidationType scopeValidationType(ProcessingEnvironment processingEnv) {
-    return valueOf(
-        processingEnv,
-        DISABLE_INTER_COMPONENT_SCOPE_VALIDATION_KEY,
-        ValidationType.ERROR,
-        EnumSet.allOf(ValidationType.class));
-  }
+    FLOATING_BINDS_METHODS(Builder::floatingBindsMethods),
 
-  private static ValidationType nullableValidationType(ProcessingEnvironment processingEnv) {
-    return valueOf(
-        processingEnv,
-        NULLABLE_VALIDATION_KEY,
-        ValidationType.ERROR,
-        EnumSet.of(ValidationType.ERROR, ValidationType.WARNING));
-  }
+    USE_GRADLE_INCREMENTAL_PROCESSING(Builder::useGradleIncrementalProcessing) {
+      @Override
+      boolean isEnabled(ProcessingEnvironment processingEnvironment) {
+        return processingEnvironment.getOptions().containsKey(toString());
+      }
 
-  private static ValidationType privateMemberValidationType(ProcessingEnvironment processingEnv) {
-    return valueOf(
-        processingEnv,
-        PRIVATE_MEMBER_VALIDATION_TYPE_KEY,
-        ValidationType.ERROR,
-        EnumSet.of(ValidationType.ERROR, ValidationType.WARNING));
-  }
+      @Override
+      public String toString() {
+        return "dagger.gradle.incremental";
+      }
+    },
+
+    USES_PRODUCERS(Builder::usesProducers) {
+      @Override
+      boolean isEnabled(ProcessingEnvironment processingEnvironment) {
+        return processingEnvironment
+                .getElementUtils()
+                .getTypeElement(Produces.class.getCanonicalName())
+            != null;
+      }
 
-  private static ValidationType staticMemberValidationType(ProcessingEnvironment processingEnv) {
-    return valueOf(
-        processingEnv,
-        STATIC_MEMBER_VALIDATION_TYPE_KEY,
-        ValidationType.ERROR,
-        EnumSet.of(ValidationType.ERROR, ValidationType.WARNING));
-  }
+      @Override
+      public boolean useCommandLineOption() {
+        return false;
+      }
+    },
+    ;
 
-  private static FeatureStatus ignorePrivateAndStaticInjectionForComponentFeatureStatus(
-      ProcessingEnvironment processingEnv) {
-    return valueOf(
-        processingEnv,
-        IGNORE_PRIVATE_AND_STATIC_INJECTION_FOR_COMPONENT,
-        FeatureStatus.DISABLED,
-        EnumSet.allOf(FeatureStatus.class));
+    final FeatureStatus defaultValue;
+    final BiConsumer<Builder, Boolean> setter;
+
+    Feature(BiConsumer<Builder, Boolean> setter) {
+      this(setter, DISABLED);
+    }
+
+    Feature(BiConsumer<Builder, Boolean> setter, FeatureStatus defaultValue) {
+      this.setter = setter;
+      this.defaultValue = defaultValue;
+    }
+
+    @Override
+    public void set(Builder builder, ProcessingEnvironment processingEnvironment) {
+      setter.accept(builder, isEnabled(processingEnvironment));
+    }
+
+    boolean isEnabled(ProcessingEnvironment processingEnvironment) {
+      return CompilerOptions.valueOf(
+              processingEnvironment, toString(), defaultValue, allOf(FeatureStatus.class))
+          .equals(ENABLED);
+    }
+
+    @Override
+    public String toString() {
+      return optionName(name());
+    }
   }
 
-  private static FeatureStatus warnIfInjectionFactoryNotGeneratedUpstreamFeatureStatus(
-      ProcessingEnvironment processingEnv) {
-    return valueOf(
-        processingEnv,
-        WARN_IF_INJECTION_FACTORY_NOT_GENERATED_UPSTREAM_KEY,
-        FeatureStatus.DISABLED,
-        EnumSet.allOf(FeatureStatus.class));
+  /** The diagnostic kind or validation type for a kind of validation. */
+  private enum Validation implements Option {
+    DISABLE_INTER_COMPONENT_SCOPE_VALIDATION(Builder::scopeCycleValidationType),
+
+    NULLABLE_VALIDATION(kindSetter(Builder::nullableValidationKind), ERROR, WARNING) {
+    },
+
+    PRIVATE_MEMBER_VALIDATION(kindSetter(Builder::privateMemberValidationKind), ERROR, WARNING),
+
+    STATIC_MEMBER_VALIDATION(kindSetter(Builder::staticMemberValidationKind), ERROR, WARNING),
+    ;
+
+    static BiConsumer<Builder, ValidationType> kindSetter(
+        BiConsumer<Builder, Diagnostic.Kind> setter) {
+      return (builder, validationType) ->
+          setter.accept(builder, validationType.diagnosticKind().get());
+    }
+
+    final ImmutableSet<ValidationType> validTypes;
+    final BiConsumer<Builder, ValidationType> setter;
+
+    Validation(BiConsumer<Builder, ValidationType> setter) {
+      this.setter = setter;
+      this.validTypes = immutableEnumSet(allOf(ValidationType.class));
+    }
+
+    Validation(
+        BiConsumer<Builder, ValidationType> setter,
+        ValidationType validType,
+        ValidationType... moreValidTypes) {
+      this.setter = setter;
+      this.validTypes = immutableEnumSet(validType, moreValidTypes);
+    }
+
+    @Override
+    public void set(Builder builder, ProcessingEnvironment processingEnvironment) {
+      setter.accept(builder, validationType(processingEnvironment));
+    }
+
+    ValidationType validationType(ProcessingEnvironment processingEnvironment) {
+      return CompilerOptions.valueOf(processingEnvironment, toString(), ERROR, validTypes);
+    }
+
+    @Override
+    public String toString() {
+      return optionName(name());
+    }
   }
 
-  private static FeatureStatus aheadOfTimeComponentsFeatureStatus(
-      ProcessingEnvironment processingEnv) {
-    return valueOf(
-        processingEnv,
-        AHEAD_OF_TIME_COMPONENTS_KEY,
-        FeatureStatus.DISABLED,
-        EnumSet.allOf(FeatureStatus.class));
+  static final ImmutableSet<String> SUPPORTED_OPTIONS =
+      Stream.<Option>concat(Arrays.stream(Feature.values()), Arrays.stream(Validation.values()))
+          .filter(Option::useCommandLineOption)
+          .map(Object::toString)
+          .collect(toImmutableSet());
+
+  private static String optionName(String enumName) {
+    return "dagger." + UPPER_UNDERSCORE.to(LOWER_CAMEL, enumName);
   }
 
   private static <T extends Enum<T>> T valueOf(
       ProcessingEnvironment processingEnv, String key, T defaultValue, Set<T> validValues) {
     Map<String, String> options = processingEnv.getOptions();
     if (options.containsKey(key)) {
-      try {
-        T type =
-            Enum.valueOf(defaultValue.getDeclaringClass(), Ascii.toUpperCase(options.get(key)));
-        if (!validValues.contains(type)) {
-          throw new IllegalArgumentException(); // let handler below print out good msg.
-        }
-        return type;
-      } catch (IllegalArgumentException e) {
+      String optionValue = options.get(key);
+      if (optionValue == null) {
         processingEnv
             .getMessager()
-            .printMessage(
-                Diagnostic.Kind.ERROR,
-                "Processor option -A"
-                    + key
-                    + " may only have the values "
-                    + validValues
-                    + " (case insensitive), found: "
-                    + options.get(key));
+            .printMessage(Diagnostic.Kind.ERROR, "Processor option -A" + key + " needs a value");
+      } else {
+        try {
+          T type = Enum.valueOf(defaultValue.getDeclaringClass(), Ascii.toUpperCase(optionValue));
+          if (!validValues.contains(type)) {
+            throw new IllegalArgumentException(); // let handler below print out good msg.
+          }
+          return type;
+        } catch (IllegalArgumentException e) {
+          processingEnv
+              .getMessager()
+              .printMessage(
+                  Diagnostic.Kind.ERROR,
+                  String.format(
+                      "Processor option -A%s may only have the values %s "
+                          + "(case insensitive), found: %s",
+                      key, validValues, options.get(key)));
+        }
       }
     }
     return defaultValue;
diff --git a/java/dagger/internal/codegen/ComponentBindingExpressions.java b/java/dagger/internal/codegen/ComponentBindingExpressions.java
index 8b0ffc20e..350a3da47 100644
--- a/java/dagger/internal/codegen/ComponentBindingExpressions.java
+++ b/java/dagger/internal/codegen/ComponentBindingExpressions.java
@@ -18,8 +18,10 @@
 
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.base.Verify.verify;
 import static dagger.internal.codegen.Accessibility.isRawTypeAccessible;
 import static dagger.internal.codegen.Accessibility.isTypeAccessibleFrom;
+import static dagger.internal.codegen.BindingRequest.bindingRequest;
 import static dagger.internal.codegen.BindingType.MEMBERS_INJECTION;
 import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
 import static dagger.internal.codegen.DelegateBindingExpression.isBindsScopeStrongerThanDependencyScope;
@@ -32,17 +34,16 @@
 import static dagger.model.BindingKind.MULTIBOUND_SET;
 
 import com.google.auto.common.MoreTypes;
-import com.google.common.collect.HashBasedTable;
 import com.google.common.collect.ImmutableList;
-import com.google.common.collect.Table;
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
 import com.squareup.javapoet.MethodSpec;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
 import dagger.internal.codegen.FrameworkFieldInitializer.FrameworkInstanceCreationExpression;
 import dagger.model.DependencyRequest;
-import dagger.model.Key;
 import dagger.model.RequestKind;
+import java.util.HashMap;
+import java.util.Map;
 import java.util.Optional;
 import javax.inject.Provider;
 import javax.lang.model.type.TypeMirror;
@@ -57,7 +58,6 @@
   private final Optional<ComponentBindingExpressions> parent;
   private final BindingGraph graph;
   private final GeneratedComponentModel generatedComponentModel;
-  private final SubcomponentNames subcomponentNames;
   private final ComponentRequirementFields componentRequirementFields;
   private final ReferenceReleasingManagerFields referenceReleasingManagerFields;
   private final OptionalFactories optionalFactories;
@@ -67,12 +67,12 @@
   private final MembersInjectionMethods membersInjectionMethods;
   private final InnerSwitchingProviders innerSwitchingProviders;
   private final StaticSwitchingProviders staticSwitchingProviders;
-  private final Table<Key, RequestKind, BindingExpression> expressions = HashBasedTable.create();
+  private final ModifiableBindingExpressions modifiableBindingExpressions;
+  private final Map<BindingRequest, BindingExpression> expressions = new HashMap<>();
 
   ComponentBindingExpressions(
       BindingGraph graph,
       GeneratedComponentModel generatedComponentModel,
-      SubcomponentNames subcomponentNames,
       ComponentRequirementFields componentRequirementFields,
       OptionalFactories optionalFactories,
       DaggerTypes types,
@@ -82,9 +82,8 @@
         Optional.empty(),
         graph,
         generatedComponentModel,
-        subcomponentNames,
         componentRequirementFields,
-        new ReferenceReleasingManagerFields(graph, generatedComponentModel),
+        new ReferenceReleasingManagerFields(graph, generatedComponentModel, compilerOptions),
         new StaticSwitchingProviders(generatedComponentModel, types),
         optionalFactories,
         types,
@@ -96,7 +95,6 @@ private ComponentBindingExpressions(
       Optional<ComponentBindingExpressions> parent,
       BindingGraph graph,
       GeneratedComponentModel generatedComponentModel,
-      SubcomponentNames subcomponentNames,
       ComponentRequirementFields componentRequirementFields,
       ReferenceReleasingManagerFields referenceReleasingManagerFields,
       StaticSwitchingProviders staticSwitchingProviders,
@@ -107,7 +105,6 @@ private ComponentBindingExpressions(
     this.parent = parent;
     this.graph = graph;
     this.generatedComponentModel = generatedComponentModel;
-    this.subcomponentNames = checkNotNull(subcomponentNames);
     this.componentRequirementFields = checkNotNull(componentRequirementFields);
     this.referenceReleasingManagerFields = checkNotNull(referenceReleasingManagerFields);
     this.optionalFactories = checkNotNull(optionalFactories);
@@ -119,6 +116,13 @@ private ComponentBindingExpressions(
     this.innerSwitchingProviders =
         new InnerSwitchingProviders(generatedComponentModel, this, types);
     this.staticSwitchingProviders = staticSwitchingProviders;
+    this.modifiableBindingExpressions =
+        new ModifiableBindingExpressions(
+            parent.map(cbe -> cbe.modifiableBindingExpressions),
+            this,
+            graph,
+            generatedComponentModel,
+            compilerOptions);
   }
 
   /**
@@ -132,7 +136,6 @@ ComponentBindingExpressions forChildComponent(
         Optional.of(this),
         childGraph,
         childComponentModel,
-        subcomponentNames,
         childComponentRequirementFields,
         referenceReleasingManagerFields,
         staticSwitchingProviders,
@@ -142,46 +145,38 @@ ComponentBindingExpressions forChildComponent(
         compilerOptions);
   }
 
-  /**
-   * Returns an expression that evaluates to the value of a dependency request for a binding owned
-   * by this component or an ancestor.
-   *
-   * @param requestingClass the class that will contain the expression
-   * @throws IllegalStateException if there is no binding expression that satisfies the dependency
-   *     request
-   */
-  Expression getDependencyExpression(Key key, RequestKind requestKind, ClassName requestingClass) {
-    return getBindingExpression(key, requestKind).getDependencyExpression(requestingClass);
+  /* Returns the {@link ModifiableBindingExpressions} for this component. */
+  ModifiableBindingExpressions modifiableBindingExpressions() {
+    return modifiableBindingExpressions;
   }
 
   /**
-   * Returns an expression that evaluates to the value of a dependency request for a binding owned
-   * by this component or an ancestor.
+   * Returns an expression that evaluates to the value of a binding request for a binding owned by
+   * this component or an ancestor.
    *
    * @param requestingClass the class that will contain the expression
-   * @throws IllegalStateException if there is no binding expression that satisfies the dependency
-   *     request
+   * @throws IllegalStateException if there is no binding expression that satisfies the request
    */
-  Expression getDependencyExpression(DependencyRequest request, ClassName requestingClass) {
-    return getDependencyExpression(request.key(), request.kind(), requestingClass);
+  Expression getDependencyExpression(BindingRequest request, ClassName requestingClass) {
+    return getBindingExpression(request).getDependencyExpression(requestingClass);
   }
 
   /**
-   * Returns an expression that evaluates to the value of a framework dependency for a binding owned
-   * in this component or an ancestor.
+   * Equivalent to {@link #getDependencyExpression(BindingRequest, ClassName)} that is used only
+   * when the request is for implementation of a component method.
    *
-   * @param requestingClass the class that will contain the expression
-   * @throws IllegalStateException if there is no binding expression that satisfies the dependency
-   *     request
+   * @throws IllegalStateException if there is no binding expression that satisfies the request
    */
-  Expression getDependencyExpression(
-      FrameworkDependency frameworkDependency, ClassName requestingClass) {
-    return getDependencyExpression(
-        frameworkDependency.key(), frameworkDependency.dependencyRequestKind(), requestingClass);
+  Expression getDependencyExpressionForComponentMethod(
+      BindingRequest request,
+      ComponentMethodDescriptor componentMethod,
+      GeneratedComponentModel componentModel) {
+    return getBindingExpression(request)
+        .getDependencyExpressionForComponentMethod(componentMethod, componentModel);
   }
 
   /**
-   * Returns the {@link CodeBlock} for the method argmuments used with the factory {@code create()}
+   * Returns the {@link CodeBlock} for the method arguments used with the factory {@code create()}
    * method for the given {@link ContributionBinding binding}.
    */
   CodeBlock getCreateMethodArgumentsCodeBlock(ContributionBinding binding) {
@@ -198,10 +193,11 @@ CodeBlock getCreateMethodArgumentsCodeBlock(ContributionBinding binding) {
               generatedComponentModel.name()));
     }
 
-    binding
-        .frameworkDependencies()
-        .stream()
-        .map(dependency -> getDependencyExpression(dependency, generatedComponentModel.name()))
+    binding.frameworkDependencies().stream()
+        .map(BindingRequest::bindingRequest)
+        .map(
+            request ->
+                getDependencyExpression(request, generatedComponentModel.name()))
         .map(Expression::codeBlock)
         .forEach(arguments::add);
 
@@ -218,12 +214,12 @@ CodeBlock getCreateMethodArgumentsCodeBlock(ContributionBinding binding) {
    *
    * @param requestingClass the class that will contain the expression
    */
-  // TODO(b/64024402) Merge with getDependencyExpression(DependencyRequest, ClassName) if possible.
   Expression getDependencyArgumentExpression(
       DependencyRequest dependencyRequest, ClassName requestingClass) {
 
     TypeMirror dependencyType = dependencyRequest.key().type();
-    Expression dependencyExpression = getDependencyExpression(dependencyRequest, requestingClass);
+    Expression dependencyExpression =
+        getDependencyExpression(bindingRequest(dependencyRequest), requestingClass);
 
     if (dependencyRequest.kind().equals(RequestKind.INSTANCE)
         && !isTypeAccessibleFrom(dependencyType, requestingClass.packageName())
@@ -237,42 +233,51 @@ Expression getDependencyArgumentExpression(
   /** Returns the implementation of a component method. */
   MethodSpec getComponentMethod(ComponentMethodDescriptor componentMethod) {
     checkArgument(componentMethod.dependencyRequest().isPresent());
-    DependencyRequest dependencyRequest = componentMethod.dependencyRequest().get();
+    BindingRequest request = bindingRequest(componentMethod.dependencyRequest().get());
     return MethodSpec.overriding(
             componentMethod.methodElement(),
             MoreTypes.asDeclared(graph.componentType().asType()),
             types)
         .addCode(
-            getBindingExpression(dependencyRequest.key(), dependencyRequest.kind())
-                .getComponentMethodImplementation(componentMethod, generatedComponentModel.name()))
+            getBindingExpression(request)
+                .getComponentMethodImplementation(componentMethod, generatedComponentModel))
         .build();
   }
 
-  private BindingExpression getBindingExpression(Key key, RequestKind requestKind) {
-    ResolvedBindings resolvedBindings = graph.resolvedBindings(requestKind, key);
-    if (resolvedBindings != null && !resolvedBindings.ownedBindings().isEmpty()) {
-      if (!expressions.contains(key, requestKind)) {
-        expressions.put(key, requestKind, createBindingExpression(resolvedBindings, requestKind));
+  /** Returns the {@link BindingExpression} for the given {@link BindingRequest}. */
+  BindingExpression getBindingExpression(BindingRequest request) {
+    if (expressions.containsKey(request)) {
+      return expressions.get(request);
+    }
+    Optional<BindingExpression> expression =
+        modifiableBindingExpressions.maybeCreateModifiableBindingExpression(request);
+    if (!expression.isPresent()) {
+      ResolvedBindings resolvedBindings = graph.resolvedBindings(request);
+      if (resolvedBindings != null && !resolvedBindings.ownedBindings().isEmpty()) {
+        expression = Optional.of(createBindingExpression(resolvedBindings, request));
       }
-      return expressions.get(key, requestKind);
     }
-    checkArgument(parent.isPresent(), "no expression found for %s-%s", key, requestKind);
-    return parent.get().getBindingExpression(key, requestKind);
+    if (expression.isPresent()) {
+      expressions.put(request, expression.get());
+      return expression.get();
+    }
+    checkArgument(parent.isPresent(), "no expression found for %s", request);
+    return parent.get().getBindingExpression(request);
   }
 
   /** Creates a binding expression. */
-  private BindingExpression createBindingExpression(
-      ResolvedBindings resolvedBindings, RequestKind requestKind) {
+  BindingExpression createBindingExpression(
+      ResolvedBindings resolvedBindings, BindingRequest request) {
     switch (resolvedBindings.bindingType()) {
       case MEMBERS_INJECTION:
-        checkArgument(requestKind.equals(RequestKind.MEMBERS_INJECTION));
+        checkArgument(request.isRequestKind(RequestKind.MEMBERS_INJECTION));
         return new MembersInjectionBindingExpression(resolvedBindings, membersInjectionMethods);
 
       case PROVISION:
-        return provisionBindingExpression(resolvedBindings, requestKind);
+        return provisionBindingExpression(resolvedBindings, request);
 
       case PRODUCTION:
-        return frameworkInstanceBindingExpression(resolvedBindings, requestKind);
+        return productionBindingExpression(resolvedBindings, request);
 
       default:
         throw new AssertionError(resolvedBindings);
@@ -284,7 +289,7 @@ private BindingExpression createBindingExpression(
    * or a {@link dagger.producers.Producer} for production bindings.
    */
   private FrameworkInstanceBindingExpression frameworkInstanceBindingExpression(
-      ResolvedBindings resolvedBindings, RequestKind requestKind) {
+      ResolvedBindings resolvedBindings) {
     // TODO(user): Consider merging the static factory creation logic into CreationExpressions?
     Optional<MemberSelect> staticMethod =
         useStaticFactoryCreation(resolvedBindings.contributionBinding())
@@ -294,17 +299,22 @@ private FrameworkInstanceBindingExpression frameworkInstanceBindingExpression(
         resolvedBindings.scope().isPresent()
             ? scope(resolvedBindings, frameworkInstanceCreationExpression(resolvedBindings))
             : frameworkInstanceCreationExpression(resolvedBindings);
-    return new FrameworkInstanceBindingExpression(
-        resolvedBindings,
-        requestKind,
-        this,
-        resolvedBindings.bindingType().frameworkType(),
+    FrameworkInstanceSupplier frameworkInstanceSupplier =
         staticMethod.isPresent()
             ? staticMethod::get
             : new FrameworkFieldInitializer(
-                generatedComponentModel, resolvedBindings, frameworkInstanceCreationExpression),
-        types,
-        elements);
+                generatedComponentModel, resolvedBindings, frameworkInstanceCreationExpression);
+
+    switch (resolvedBindings.bindingType()) {
+      case PROVISION:
+        return new ProviderInstanceBindingExpression(
+            resolvedBindings, frameworkInstanceSupplier, types, elements);
+      case PRODUCTION:
+        return new ProducerNodeInstanceBindingExpression(
+            resolvedBindings, frameworkInstanceSupplier, types, elements, generatedComponentModel);
+      default:
+        throw new AssertionError("invalid binding type: " + resolvedBindings.bindingType());
+    }
   }
 
   private FrameworkInstanceCreationExpression scope(
@@ -354,7 +364,7 @@ private FrameworkInstanceCreationExpression frameworkInstanceCreationExpression(
 
       case SUBCOMPONENT_BUILDER:
         return new SubcomponentBuilderProviderCreationExpression(
-            binding.key().type(), subcomponentNames.get(binding.key()));
+            binding.key().type(), generatedComponentModel.getSubcomponentName(binding.key()));
 
       case INJECTION:
       case PROVISION:
@@ -373,7 +383,8 @@ private FrameworkInstanceCreationExpression frameworkInstanceCreationExpression(
         return new SetFactoryCreationExpression(binding, generatedComponentModel, this, graph);
 
       case MULTIBOUND_MAP:
-        return new MapFactoryCreationExpression(binding, generatedComponentModel, this, graph);
+        return new MapFactoryCreationExpression(
+            binding, generatedComponentModel, this, graph, elements);
 
       case RELEASABLE_REFERENCE_MANAGER:
         return new ReleasableReferenceManagerProviderCreationExpression(
@@ -410,7 +421,15 @@ private InstanceFactoryCreationExpression instanceFactoryCreationExpression(
 
   /** Returns a binding expression for a provision binding. */
   private BindingExpression provisionBindingExpression(
-      ResolvedBindings resolvedBindings, RequestKind requestKind) {
+      ResolvedBindings resolvedBindings, BindingRequest request) {
+    if (!request.requestKind().isPresent()) {
+      verify(
+          request.frameworkType().get().equals(FrameworkType.PRODUCER_NODE),
+          "expected a PRODUCER_NODE: %s",
+          request);
+      return producerFromProviderBindingExpression(resolvedBindings);
+    }
+    RequestKind requestKind = request.requestKind().get();
     switch (requestKind) {
       case INSTANCE:
         return instanceBindingExpression(resolvedBindings);
@@ -421,10 +440,11 @@ private BindingExpression provisionBindingExpression(
       case LAZY:
       case PRODUCED:
       case PROVIDER_OF_LAZY:
-        return new DerivedFromProviderBindingExpression(resolvedBindings, requestKind, this, types);
+        return new DerivedFromFrameworkInstanceBindingExpression(
+            resolvedBindings, FrameworkType.PROVIDER, requestKind, this, types);
 
       case PRODUCER:
-        return producerFromProviderBindingExpression(resolvedBindings, requestKind);
+        return producerFromProviderBindingExpression(resolvedBindings);
 
       case FUTURE:
         return new ImmediateFutureBindingExpression(resolvedBindings, this, types);
@@ -436,15 +456,27 @@ private BindingExpression provisionBindingExpression(
     throw new AssertionError();
   }
 
+  /** Returns a binding expression for a production binding. */
+  private BindingExpression productionBindingExpression(
+      ResolvedBindings resolvedBindings, BindingRequest request) {
+    if (request.frameworkType().isPresent()) {
+      return frameworkInstanceBindingExpression(resolvedBindings);
+    } else {
+      // If no FrameworkType is present, a RequestKind is guaranteed to be present.
+      return new DerivedFromFrameworkInstanceBindingExpression(
+          resolvedBindings, FrameworkType.PRODUCER_NODE, request.requestKind().get(), this, types);
+    }
+  }
+
   /**
    * Returns a binding expression for {@link RequestKind#PROVIDER} requests.
    *
    * <p>{@code @Binds} bindings that don't {@linkplain #needsCaching(ResolvedBindings) need to be
    * cached} can use a {@link DelegateBindingExpression}.
    *
-   * <p>In Android mode, use an {@link InnerSwitchingProviders inner switching provider} unless that
-   * provider's case statement will simply call {@code get()} on another {@link Provider} (in which
-   * case, just use that Provider directly).
+   * <p>In fastInit mode, use an {@link InnerSwitchingProviders inner switching provider} unless
+   * that provider's case statement will simply call {@code get()} on another {@link Provider} (in
+   * which case, just use that Provider directly).
    *
    * <p>Otherwise, return a {@link FrameworkInstanceBindingExpression}.
    */
@@ -453,16 +485,16 @@ private BindingExpression providerBindingExpression(ResolvedBindings resolvedBin
         && !needsCaching(resolvedBindings)) {
       return new DelegateBindingExpression(
           resolvedBindings, RequestKind.PROVIDER, this, types, elements);
-    } else if (compilerOptions.experimentalAndroidMode()
+    } else if (compilerOptions.fastInit()
         && frameworkInstanceCreationExpression(resolvedBindings).useInnerSwitchingProvider()
         && !(instanceBindingExpression(resolvedBindings)
-        instanceof DerivedFromProviderBindingExpression)) {
+            instanceof DerivedFromFrameworkInstanceBindingExpression)) {
       return wrapInMethod(
           resolvedBindings,
-          RequestKind.PROVIDER,
+          bindingRequest(resolvedBindings.key(), RequestKind.PROVIDER),
           innerSwitchingProviders.newBindingExpression(resolvedBindings.contributionBinding()));
     }
-    return frameworkInstanceBindingExpression(resolvedBindings, RequestKind.PROVIDER);
+    return frameworkInstanceBindingExpression(resolvedBindings);
   }
 
   /**
@@ -470,20 +502,18 @@ private BindingExpression providerBindingExpression(ResolvedBindings resolvedBin
    * provision binding.
    */
   private FrameworkInstanceBindingExpression producerFromProviderBindingExpression(
-      ResolvedBindings resolvedBindings, RequestKind requestKind) {
-    checkArgument(resolvedBindings.bindingType().frameworkType().equals(FrameworkType.PROVIDER));
-    return new FrameworkInstanceBindingExpression(
+      ResolvedBindings resolvedBindings) {
+    checkArgument(resolvedBindings.bindingType().equals(BindingType.PROVISION));
+    return new ProducerNodeInstanceBindingExpression(
         resolvedBindings,
-        requestKind,
-        this,
-        FrameworkType.PRODUCER,
         new FrameworkFieldInitializer(
             generatedComponentModel,
             resolvedBindings,
             new ProducerFromProviderCreationExpression(
                 resolvedBindings.contributionBinding(), generatedComponentModel, this)),
         types,
-        elements);
+        elements,
+        generatedComponentModel);
   }
 
   /**
@@ -496,7 +526,7 @@ private FrameworkInstanceBindingExpression producerFromProviderBindingExpression
    * <p>In default mode, we can use direct expressions for bindings that don't need to be cached in
    * a reference-releasing scope.
    *
-   * <p>In Android mode, we can use direct expressions unless the binding needs to be cached.
+   * <p>In fastInit mode, we can use direct expressions unless the binding needs to be cached.
    */
   private BindingExpression instanceBindingExpression(ResolvedBindings resolvedBindings) {
     Optional<BindingExpression> maybeDirectInstanceExpression =
@@ -506,11 +536,14 @@ private BindingExpression instanceBindingExpression(ResolvedBindings resolvedBin
       BindingExpression directInstanceExpression = maybeDirectInstanceExpression.get();
       return directInstanceExpression.requiresMethodEncapsulation()
               || needsCaching(resolvedBindings)
-          ? wrapInMethod(resolvedBindings, RequestKind.INSTANCE, directInstanceExpression)
+          ? wrapInMethod(
+              resolvedBindings,
+              bindingRequest(resolvedBindings.key(), RequestKind.INSTANCE),
+              directInstanceExpression)
           : directInstanceExpression;
     }
-    return new DerivedFromProviderBindingExpression(
-        resolvedBindings, RequestKind.INSTANCE, this, types);
+    return new DerivedFromFrameworkInstanceBindingExpression(
+        resolvedBindings, FrameworkType.PROVIDER, RequestKind.INSTANCE, this, types);
   }
 
   /**
@@ -545,15 +578,18 @@ private BindingExpression instanceBindingExpression(ResolvedBindings resolvedBin
       case SUBCOMPONENT_BUILDER:
         return Optional.of(
             new SubcomponentBuilderBindingExpression(
-                resolvedBindings, subcomponentNames.get(resolvedBindings.key())));
+                resolvedBindings,
+                generatedComponentModel.getSubcomponentName(resolvedBindings.key())));
 
       case MULTIBOUND_SET:
         return Optional.of(
-            new SetBindingExpression(resolvedBindings, graph, this, types, elements));
+            new SetBindingExpression(
+                resolvedBindings, generatedComponentModel, graph, this, types, elements));
 
       case MULTIBOUND_MAP:
         return Optional.of(
-            new MapBindingExpression(resolvedBindings, graph, this, types, elements));
+            new MapBindingExpression(
+                resolvedBindings, generatedComponentModel, graph, this, types, elements));
 
       case OPTIONAL:
         return Optional.of(new OptionalBindingExpression(resolvedBindings, this, types));
@@ -594,14 +630,13 @@ private BindingExpression instanceBindingExpression(ResolvedBindings resolvedBin
   /**
    * Returns {@code true} if the binding should use the static factory creation strategy.
    *
-   * In default mode, we always use the static factory creation strategy. In Android mode, we
-   * prefer to use the SwitchingProvider than the static factories to reduce class loading; however,
-   * we allow static factories that can reused across multiple bindings, e.g. {@code MapFactory} or
-   * {@code SetFactory}.
+   * <p>In default mode, we always use the static factory creation strategy. In fastInit mode, we
+   * prefer to use a SwitchingProvider instead of static factories in order to reduce class loading;
+   * however, we allow static factories that can reused across multiple bindings, e.g. {@code
+   * MapFactory} or {@code SetFactory}.
    */
   private boolean useStaticFactoryCreation(ContributionBinding binding) {
-    return !(compilerOptions.experimentalAndroidMode2()
-            || compilerOptions.experimentalAndroidMode())
+    return !(compilerOptions.experimentalAndroidMode2() || compilerOptions.fastInit())
         || binding.kind().equals(MULTIBOUND_MAP)
         || binding.kind().equals(MULTIBOUND_SET);
   }
@@ -611,29 +646,48 @@ private boolean useStaticFactoryCreation(ContributionBinding binding) {
    * binding. If the binding doesn't {@linkplain #needsCaching(ResolvedBindings) need to be cached},
    * we can.
    *
-   * <p>In Android mode, we can use a direct expression even if the binding {@linkplain
+   * <p>In fastInit mode, we can use a direct expression even if the binding {@linkplain
    * #needsCaching(ResolvedBindings) needs to be cached} as long as it's not in a
    * reference-releasing scope.
    */
   private boolean canUseDirectInstanceExpression(ResolvedBindings resolvedBindings) {
     return !needsCaching(resolvedBindings)
-        || (compilerOptions.experimentalAndroidMode()
-            && !requiresReleasableReferences(resolvedBindings));
+        || (compilerOptions.fastInit() && !requiresReleasableReferences(resolvedBindings));
   }
 
   /**
    * Returns a binding expression that uses a given one as the body of a method that users call. If
-   * a component provision method matches it, it will be the method implemented. If not, a new
-   * private method will be written.
+   * a component provision method matches it, it will be the method implemented. If it does not
+   * match a component provision method and the binding is modifiable, then a new public modifiable
+   * binding method will be written. If the binding doesn't match a component method and is not
+   * modifiable, then a new private method will be written.
    */
-  private BindingExpression wrapInMethod(
+  BindingExpression wrapInMethod(
       ResolvedBindings resolvedBindings,
-      RequestKind requestKind,
+      BindingRequest request,
       BindingExpression bindingExpression) {
+    // If we've already wrapped the expression, then use the delegate.
+    if (bindingExpression instanceof MethodBindingExpression) {
+      return bindingExpression;
+    }
+
     BindingMethodImplementation methodImplementation =
-        methodImplementation(resolvedBindings, requestKind, bindingExpression);
+        methodImplementation(resolvedBindings, request, bindingExpression);
+    Optional<ComponentMethodDescriptor> matchingComponentMethod =
+        graph.componentDescriptor().findMatchingComponentMethod(request);
+
+    Optional<BindingExpression> modifiableBindingExpression =
+        modifiableBindingExpressions.maybeWrapInModifiableMethodBindingExpression(
+            resolvedBindings,
+            request,
+            bindingExpression,
+            methodImplementation,
+            matchingComponentMethod);
+    if (modifiableBindingExpression.isPresent()) {
+      return modifiableBindingExpression.get();
+    }
 
-    return findMatchingComponentMethod(resolvedBindings.key(), requestKind)
+    return matchingComponentMethod
         .<BindingExpression>map(
             componentMethod ->
                 new ComponentMethodBindingExpression(
@@ -641,49 +695,28 @@ private BindingExpression wrapInMethod(
         .orElseGet(
             () ->
                 new PrivateMethodBindingExpression(
-                    resolvedBindings, requestKind, methodImplementation, generatedComponentModel));
-  }
-
-  /** Returns the first component method associated with this request kind, if one exists. */
-  private Optional<ComponentMethodDescriptor> findMatchingComponentMethod(
-      Key key, RequestKind requestKind) {
-    return graph
-        .componentDescriptor()
-        .componentMethods()
-        .stream()
-        .filter(method -> doesComponentMethodMatch(method, key, requestKind))
-        .findFirst();
-  }
-
-  /** Returns true if the component method matches the dependency request binding key and kind. */
-  private boolean doesComponentMethodMatch(
-      ComponentMethodDescriptor componentMethod, Key key, RequestKind requestKind) {
-    return componentMethod
-        .dependencyRequest()
-        .filter(request -> request.key().equals(key))
-        .filter(request -> request.kind().equals(requestKind))
-        .isPresent();
+                    resolvedBindings, request, methodImplementation, generatedComponentModel));
   }
 
   private BindingMethodImplementation methodImplementation(
       ResolvedBindings resolvedBindings,
-      RequestKind requestKind,
+      BindingRequest request,
       BindingExpression bindingExpression) {
-    if (compilerOptions.experimentalAndroidMode()) {
-      if (requestKind.equals(RequestKind.PROVIDER)) {
+    if (compilerOptions.fastInit()) {
+      if (request.isRequestKind(RequestKind.PROVIDER)) {
         return new SingleCheckedMethodImplementation(
-            resolvedBindings, requestKind, bindingExpression, types, generatedComponentModel);
-      } else if (requestKind.equals(RequestKind.INSTANCE) && needsCaching(resolvedBindings)) {
+            resolvedBindings, request, bindingExpression, types, generatedComponentModel);
+      } else if (request.isRequestKind(RequestKind.INSTANCE) && needsCaching(resolvedBindings)) {
         return resolvedBindings.scope().get().isReusable()
             ? new SingleCheckedMethodImplementation(
-                resolvedBindings, requestKind, bindingExpression, types, generatedComponentModel)
+                resolvedBindings, request, bindingExpression, types, generatedComponentModel)
             : new DoubleCheckedMethodImplementation(
-                resolvedBindings, requestKind, bindingExpression, types, generatedComponentModel);
+                resolvedBindings, request, bindingExpression, types, generatedComponentModel);
       }
     }
 
     return new BindingMethodImplementation(
-        resolvedBindings, requestKind, bindingExpression, generatedComponentModel.name(), types);
+        resolvedBindings, request, bindingExpression, generatedComponentModel.name(), types);
   }
 
   /**
@@ -702,7 +735,7 @@ private boolean needsCaching(ResolvedBindings resolvedBindings) {
     return true;
   }
 
-  // TODO(user): Enable releasable references in experimentalAndroidMode
+  // TODO(user): Enable releasable references in fastInit
   private boolean requiresReleasableReferences(ResolvedBindings resolvedBindings) {
     return resolvedBindings.scope().isPresent()
         && referenceReleasingManagerFields.requiresReleasableReferences(
diff --git a/java/dagger/internal/codegen/ComponentDescriptor.java b/java/dagger/internal/codegen/ComponentDescriptor.java
index 1ce30aefb..2f6240451 100644
--- a/java/dagger/internal/codegen/ComponentDescriptor.java
+++ b/java/dagger/internal/codegen/ComponentDescriptor.java
@@ -31,6 +31,7 @@
 import static dagger.internal.codegen.InjectionAnnotations.getQualifier;
 import static dagger.internal.codegen.Scopes.productionScope;
 import static dagger.internal.codegen.Scopes.scopesOf;
+import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.type.TypeKind.DECLARED;
 import static javax.lang.model.type.TypeKind.VOID;
 import static javax.lang.model.util.ElementFilter.methodsIn;
@@ -63,6 +64,7 @@
 import java.util.List;
 import java.util.Optional;
 import java.util.Set;
+import java.util.stream.Stream;
 import javax.inject.Inject;
 import javax.inject.Provider;
 import javax.lang.model.element.AnnotationMirror;
@@ -206,6 +208,17 @@ boolean isProducer() {
    */
   abstract ImmutableSet<ComponentRequirement> dependencies();
 
+  /** The non-abstract {@link #transitiveModules()} and the {@link #dependencies()}. */
+  ImmutableSet<ComponentRequirement> availableDependencies() {
+    return Stream.concat(
+            transitiveModuleTypes()
+                .stream()
+                .filter(dep -> !dep.getModifiers().contains(ABSTRACT))
+                .map(module -> ComponentRequirement.forModule(module.asType())),
+            dependencies().stream())
+        .collect(toImmutableSet());
+  }
+
   /**
    * The set of {@link ModuleDescriptor modules} declared directly in {@link Component#modules}.
    * Use {@link #transitiveModules} to get the full set of modules available upon traversing
@@ -302,6 +315,23 @@ boolean isProducer() {
 
   abstract ImmutableSet<ComponentMethodDescriptor> componentMethods();
 
+  /** Returns the first component method associated with this binding request, if one exists. */
+  Optional<ComponentMethodDescriptor> findMatchingComponentMethod(BindingRequest request) {
+    return componentMethods().stream()
+        .filter(method -> doesComponentMethodMatch(method, request))
+        .findFirst();
+  }
+
+  /** Returns true if the component method matches the binding request. */
+  private static boolean doesComponentMethodMatch(
+      ComponentMethodDescriptor componentMethod, BindingRequest request) {
+    return componentMethod
+        .dependencyRequest()
+        .map(BindingRequest::bindingRequest)
+        .filter(request::equals)
+        .isPresent();
+  }
+
   /** The entry point methods on the component type. */
   ImmutableSet<ComponentMethodDescriptor> entryPointMethods() {
     return componentMethods()
@@ -429,30 +459,38 @@ Kind componentKind() {
     private final Types types;
     private final DependencyRequestFactory dependencyRequestFactory;
     private final ModuleDescriptor.Factory moduleDescriptorFactory;
+    private final CompilerOptions compilerOptions;
 
     @Inject
     Factory(
         DaggerElements elements,
         Types types,
         DependencyRequestFactory dependencyRequestFactory,
-        ModuleDescriptor.Factory moduleDescriptorFactory) {
+        ModuleDescriptor.Factory moduleDescriptorFactory,
+        CompilerOptions compilerOptions) {
       this.elements = elements;
       this.types = types;
       this.dependencyRequestFactory = dependencyRequestFactory;
       this.moduleDescriptorFactory = moduleDescriptorFactory;
+      this.compilerOptions = compilerOptions;
     }
 
     /**
      * Returns a component descriptor for a type annotated with either {@link Component @Component}
-     * or {@link ProductionComponent @ProductionComponent}.
+     * or {@link ProductionComponent @ProductionComponent}. This is also compatible with {@link
+     * Subcomponent @Subcomponent} or {@link ProductionSubcomponent @ProductionSubcomponent} when
+     * generating ahead-of-time subcomponents.
      */
-    ComponentDescriptor forComponent(TypeElement componentDefinitionType) {
-      Optional<Kind> kind = Kind.forAnnotatedElement(componentDefinitionType);
+    ComponentDescriptor forComponent(TypeElement componentType) {
+      Optional<Kind> kind = Kind.forAnnotatedElement(componentType);
       checkArgument(
-          kind.isPresent() && kind.get().isTopLevel(),
-          "%s must be annotated with @Component or @ProductionComponent",
-          componentDefinitionType);
-      return create(componentDefinitionType, kind.get(), Optional.empty());
+          kind.isPresent(), "%s must have a component or subcomponent annotation", componentType);
+      if (!compilerOptions.aheadOfTimeSubcomponents()) {
+        checkArgument(kind.get().isTopLevel(),
+            "%s must be annotated with @Component or @ProductionComponent.",
+            componentType);
+      }
+      return create(componentType, kind.get(), Optional.empty());
     }
 
     private ComponentDescriptor create(
diff --git a/java/dagger/internal/codegen/BindingGraphValidator.java b/java/dagger/internal/codegen/ComponentDescriptorValidator.java
similarity index 52%
rename from java/dagger/internal/codegen/BindingGraphValidator.java
rename to java/dagger/internal/codegen/ComponentDescriptorValidator.java
index 2727da473..8cc8b7c64 100644
--- a/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/java/dagger/internal/codegen/ComponentDescriptorValidator.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2015 The Dagger Authors.
+ * Copyright (C) 2018 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,47 +16,33 @@
 
 package dagger.internal.codegen;
 
-import static com.google.auto.common.MoreTypes.asDeclared;
-import static com.google.auto.common.MoreTypes.asExecutable;
-import static com.google.auto.common.MoreTypes.asTypeElements;
+import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static dagger.internal.codegen.ComponentRequirement.Kind.BOUND_INSTANCE;
-import static dagger.internal.codegen.ComponentRequirement.Kind.MODULE;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentAnnotation;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
 import static dagger.internal.codegen.DaggerElements.getAnnotationMirror;
 import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
 import static dagger.internal.codegen.DiagnosticFormatting.stripCommonTypePrefixes;
 import static dagger.internal.codegen.Formatter.INDENT;
-import static dagger.internal.codegen.RequestKinds.extractKeyType;
-import static dagger.internal.codegen.RequestKinds.getRequestKind;
 import static dagger.internal.codegen.Scopes.getReadableSource;
 import static dagger.internal.codegen.Scopes.scopesOf;
 import static dagger.internal.codegen.Scopes.singletonScope;
-import static dagger.internal.codegen.Util.componentCanMakeNewInstances;
 import static dagger.internal.codegen.Util.reentrantComputeIfAbsent;
 import static java.util.stream.Collectors.groupingBy;
 import static java.util.stream.Collectors.joining;
 import static java.util.stream.Collectors.mapping;
 import static java.util.stream.Collectors.toList;
-import static java.util.stream.Collectors.toSet;
 
 import com.google.auto.common.MoreTypes;
 import com.google.common.base.Equivalence;
-import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Sets;
-import dagger.BindsOptionalOf;
 import dagger.Component;
-import dagger.Lazy;
 import dagger.internal.codegen.ComponentDescriptor.BuilderRequirementMethod;
 import dagger.internal.codegen.ComponentDescriptor.BuilderSpec;
-import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
 import dagger.internal.codegen.ComponentRequirement.NullPolicy;
 import dagger.internal.codegen.ErrorMessages.ComponentBuilderMessages;
-import dagger.model.DependencyRequest;
-import dagger.model.Key;
-import dagger.model.RequestKind;
 import dagger.model.Scope;
 import java.util.ArrayDeque;
 import java.util.Deque;
@@ -65,141 +51,111 @@
 import java.util.Map;
 import java.util.Optional;
 import java.util.Set;
-import java.util.concurrent.atomic.AtomicBoolean;
 import javax.inject.Inject;
-import javax.inject.Provider;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.DeclaredType;
-import javax.lang.model.type.ExecutableType;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
 
-/** Reports errors in the shape of the binding graph. */
-final class BindingGraphValidator {
+/**
+ * Reports errors in the component hierarchy.
+ *
+ * <ul>
+ *   <li>Validates scope hierarchy of component dependencies and subcompoennts.
+ *   <li>Reports errors if there are component dependency cycles.
+ *   <li>Reports errors if any abstract modules have non-abstract instance binding methods.
+ *   <li>Validates component builder types.
+ * </ul>
+ */
+// TODO(dpb): Combine with ComponentHierarchyValidator.
+final class ComponentDescriptorValidator {
 
   private final Elements elements;
   private final DaggerTypes types;
   private final CompilerOptions compilerOptions;
   private final MethodSignatureFormatter methodSignatureFormatter;
-  private final DependencyRequestFormatter dependencyRequestFormatter;
-  private final KeyFactory keyFactory;
+  private final ComponentHierarchyValidator componentHierarchyValidator;
 
   @Inject
-  BindingGraphValidator(
+  ComponentDescriptorValidator(
       Elements elements,
       DaggerTypes types,
       CompilerOptions compilerOptions,
       MethodSignatureFormatter methodSignatureFormatter,
-      DependencyRequestFormatter dependencyRequestFormatter,
-      KeyFactory keyFactory) {
+      ComponentHierarchyValidator componentHierarchyValidator) {
     this.elements = elements;
     this.types = types;
     this.compilerOptions = compilerOptions;
     this.methodSignatureFormatter = methodSignatureFormatter;
-    this.dependencyRequestFormatter = dependencyRequestFormatter;
-    this.keyFactory = keyFactory;
+    this.componentHierarchyValidator = componentHierarchyValidator;
   }
 
-  private final class ComponentValidation extends ComponentTreeTraverser {
-    final BindingGraph rootGraph;
+  ValidationReport<TypeElement> validate(ComponentDescriptor component) {
+    ComponentValidation validation = new ComponentValidation(component);
+    validation.visitComponent(component);
+    validation.report(component).addSubreport(componentHierarchyValidator.validate(component));
+    return validation.buildReport();
+  }
+
+  private final class ComponentValidation {
+    final ComponentDescriptor rootComponent;
     final Map<ComponentDescriptor, ValidationReport.Builder<TypeElement>> reports =
         new LinkedHashMap<>();
 
-    ComponentValidation(BindingGraph rootGraph) {
-      super(rootGraph);
-      this.rootGraph = rootGraph;
-    }
-
-    @Override
-    protected BindingGraphTraverser bindingGraphTraverser(
-        ComponentTreePath componentPath, ComponentMethodDescriptor entryPointMethod) {
-      return new BindingGraphValidation(componentPath, entryPointMethod);
+    ComponentValidation(ComponentDescriptor rootComponent) {
+      this.rootComponent = checkNotNull(rootComponent);
     }
 
     /** Returns a report that contains all validation messages found during traversal. */
     ValidationReport<TypeElement> buildReport() {
       ValidationReport.Builder<TypeElement> report =
-          ValidationReport.about(rootGraph.componentType());
+          ValidationReport.about(rootComponent.componentDefinitionType());
       reports.values().forEach(subreport -> report.addSubreport(subreport.build()));
       return report.build();
     }
 
     /** Returns the report builder for a (sub)component. */
-    private ValidationReport.Builder<TypeElement> report(BindingGraph graph) {
+    private ValidationReport.Builder<TypeElement> report(ComponentDescriptor component) {
       return reentrantComputeIfAbsent(
           reports,
-          graph.componentDescriptor(),
+          component,
           descriptor -> ValidationReport.about(descriptor.componentDefinitionType()));
     }
 
-    @Override
-    protected void visitComponent(BindingGraph graph) {
-      validateDependencyScopes(graph);
-      validateComponentDependencyHierarchy(graph);
-      validateModules(graph);
-      validateBuilders(graph);
-      super.visitComponent(graph);
-    }
-
-    @Override
-    protected void visitSubcomponentFactoryMethod(
-        BindingGraph graph, BindingGraph parent, ExecutableElement factoryMethod) {
-      Set<TypeElement> missingModules =
-          graph
-              .componentRequirements()
-              .stream()
-              .filter(componentRequirement -> componentRequirement.kind().equals(MODULE))
-              .map(ComponentRequirement::typeElement)
-              .filter(
-                  moduleType ->
-                      !subgraphFactoryMethodParameters(parent, factoryMethod).contains(moduleType))
-              .filter(moduleType -> !componentCanMakeNewInstances(moduleType))
-              .collect(toSet());
-      if (!missingModules.isEmpty()) {
-        report(parent)
-            .addError(
-                String.format(
-                    "%s requires modules which have no visible default constructors. "
-                        + "Add the following modules as parameters to this method: %s",
-                    graph.componentType().getQualifiedName(),
-                    missingModules.stream().map(Object::toString).collect(joining(", "))),
-                factoryMethod);
-      }
-    }
-
-    private ImmutableSet<TypeElement> subgraphFactoryMethodParameters(
-        BindingGraph parent, ExecutableElement childFactoryMethod) {
-      DeclaredType componentType = asDeclared(parent.componentType().asType());
-      ExecutableType factoryMethodType =
-          asExecutable(types.asMemberOf(componentType, childFactoryMethod));
-      return asTypeElements(factoryMethodType.getParameterTypes());
+    void visitComponent(ComponentDescriptor component) {
+      validateDependencyScopes(component);
+      validateComponentDependencyHierarchy(component);
+      validateModules(component);
+      validateBuilders(component);
+      component.subcomponents().forEach(this::visitComponent);
     }
 
     /** Validates that component dependencies do not form a cycle. */
-    private void validateComponentDependencyHierarchy(BindingGraph graph) {
-      validateComponentDependencyHierarchy(graph, graph.componentType(), new ArrayDeque<>());
+    private void validateComponentDependencyHierarchy(ComponentDescriptor component) {
+      validateComponentDependencyHierarchy(
+          component, component.componentDefinitionType(), new ArrayDeque<>());
     }
 
     /** Recursive method to validate that component dependencies do not form a cycle. */
     private void validateComponentDependencyHierarchy(
-        BindingGraph graph, TypeElement dependency, Deque<TypeElement> dependencyStack) {
+        ComponentDescriptor component, TypeElement dependency, Deque<TypeElement> dependencyStack) {
       if (dependencyStack.contains(dependency)) {
         // Current component has already appeared in the component chain.
         StringBuilder message = new StringBuilder();
-        message.append(graph.componentType().getQualifiedName());
+        message.append(component.componentDefinitionType().getQualifiedName());
         message.append(" contains a cycle in its component dependencies:\n");
         dependencyStack.push(dependency);
         appendIndentedComponentsList(message, dependencyStack);
         dependencyStack.pop();
-        report(graph)
+        report(component)
             .addItem(
                 message.toString(),
                 compilerOptions.scopeCycleValidationType().diagnosticKind().get(),
-                graph.componentType(),
-                getComponentAnnotation(graph.componentType()).get());
+                component.componentDefinitionType(),
+                getComponentAnnotation(component.componentDefinitionType()).get());
       } else {
         Optional<AnnotationMirror> componentAnnotation = getComponentAnnotation(dependency);
         if (componentAnnotation.isPresent()) {
@@ -208,7 +164,7 @@ private void validateComponentDependencyHierarchy(
           ImmutableSet<TypeElement> dependencies =
               MoreTypes.asTypeElements(getComponentDependencies(componentAnnotation.get()));
           for (TypeElement nextDependency : dependencies) {
-            validateComponentDependencyHierarchy(graph, nextDependency, dependencyStack);
+            validateComponentDependencyHierarchy(component, nextDependency, dependencyStack);
           }
 
           dependencyStack.pop();
@@ -220,12 +176,11 @@ private void validateComponentDependencyHierarchy(
      * Validates that among the dependencies are at most one scoped dependency, that there are no
      * cycles within the scoping chain, and that singleton components have no scoped dependencies.
      */
-    private void validateDependencyScopes(BindingGraph graph) {
-      ComponentDescriptor descriptor = graph.componentDescriptor();
-      ImmutableSet<Scope> scopes = descriptor.scopes();
+    private void validateDependencyScopes(ComponentDescriptor component) {
+      ImmutableSet<Scope> scopes = component.scopes();
       ImmutableSet<TypeElement> scopedDependencies =
           scopedTypesIn(
-              descriptor
+              component
                   .dependencies()
                   .stream()
                   .map(ComponentRequirement::typeElement)
@@ -238,15 +193,16 @@ private void validateDependencyScopes(BindingGraph graph) {
           // Singleton is a special-case representing the longest lifetime, and therefore
           // @Singleton components may not depend on scoped components
           if (!scopedDependencies.isEmpty()) {
-            StringBuilder message = new StringBuilder(
-                "This @Singleton component cannot depend on scoped components:\n");
+            StringBuilder message =
+                new StringBuilder(
+                    "This @Singleton component cannot depend on scoped components:\n");
             appendIndentedComponentsList(message, scopedDependencies);
-            report(graph)
+            report(component)
                 .addItem(
                     message.toString(),
                     compilerOptions.scopeCycleValidationType().diagnosticKind().get(),
-                    descriptor.componentDefinitionType(),
-                    descriptor.componentAnnotation());
+                    component.componentDefinitionType(),
+                    component.componentAnnotation());
           }
         } else if (scopedDependencies.size() > 1) {
           // Scoped components may depend on at most one scoped component.
@@ -255,20 +211,20 @@ private void validateDependencyScopes(BindingGraph graph) {
             message.append(getReadableSource(scope)).append(' ');
           }
           message
-              .append(descriptor.componentDefinitionType().getQualifiedName())
+              .append(component.componentDefinitionType().getQualifiedName())
               .append(" depends on more than one scoped component:\n");
           appendIndentedComponentsList(message, scopedDependencies);
-          report(graph)
+          report(component)
               .addError(
                   message.toString(),
-                  descriptor.componentDefinitionType(),
-                  descriptor.componentAnnotation());
+                  component.componentDefinitionType(),
+                  component.componentAnnotation());
         } else {
           // Dagger 1.x scope compatibility requires this be suppress-able.
           if (!compilerOptions.scopeCycleValidationType().equals(ValidationType.NONE)) {
             validateDependencyScopeHierarchy(
-                graph,
-                descriptor.componentDefinitionType(),
+                component,
+                component.componentDefinitionType(),
                 new ArrayDeque<ImmutableSet<Scope>>(),
                 new ArrayDeque<TypeElement>());
           }
@@ -277,24 +233,24 @@ private void validateDependencyScopes(BindingGraph graph) {
         // Scopeless components may not depend on scoped components.
         if (!scopedDependencies.isEmpty()) {
           StringBuilder message =
-              new StringBuilder(descriptor.componentDefinitionType().getQualifiedName())
+              new StringBuilder(component.componentDefinitionType().getQualifiedName())
                   .append(" (unscoped) cannot depend on scoped components:\n");
           appendIndentedComponentsList(message, scopedDependencies);
-          report(graph)
+          report(component)
               .addError(
                   message.toString(),
-                  descriptor.componentDefinitionType(),
-                  descriptor.componentAnnotation());
+                  component.componentDefinitionType(),
+                  component.componentAnnotation());
         }
       }
     }
 
-    private void validateModules(BindingGraph graph) {
-      for (ModuleDescriptor module : graph.componentDescriptor().transitiveModules()) {
+    private void validateModules(ComponentDescriptor component) {
+      for (ModuleDescriptor module : component.transitiveModules()) {
         if (module.moduleElement().getModifiers().contains(Modifier.ABSTRACT)) {
           for (ContributionBinding binding : module.bindings()) {
             if (binding.requiresModuleInstance()) {
-              report(graph).addError(abstractModuleHasInstanceBindingMethodsError(module));
+              report(component).addError(abstractModuleHasInstanceBindingMethodsError(module));
               break;
             }
           }
@@ -320,14 +276,14 @@ private String abstractModuleHasInstanceBindingMethodsError(ModuleDescriptor mod
           module.moduleElement(), methodAnnotations);
     }
 
-    private void validateBuilders(BindingGraph graph) {
-      ComponentDescriptor componentDesc = graph.componentDescriptor();
+    private void validateBuilders(ComponentDescriptor component) {
+      ComponentDescriptor componentDesc = component;
       if (!componentDesc.builderSpec().isPresent()) {
         // If no builder, nothing to validate.
         return;
       }
 
-      Set<ComponentRequirement> availableDependencies = graph.availableDependencies();
+      Set<ComponentRequirement> availableDependencies = component.availableDependencies();
       Set<ComponentRequirement> requiredDependencies =
           Sets.filter(
               availableDependencies,
@@ -344,8 +300,7 @@ private void validateBuilders(BindingGraph graph) {
               .map(BuilderRequirementMethod::requirement)
               .collect(toImmutableSet());
 
-      ComponentBuilderMessages msgs =
-          ErrorMessages.builderMsgsFor(graph.componentDescriptor().kind());
+      ComponentBuilderMessages msgs = ErrorMessages.builderMsgsFor(component.kind());
       Set<ComponentRequirement> extraSetters =
           Sets.difference(declaredRequirements, availableDependencies);
       if (!extraSetters.isEmpty()) {
@@ -362,14 +317,14 @@ private void validateBuilders(BindingGraph graph) {
                 .stream()
                 .map(method -> methodSignatureFormatter.format(method, container))
                 .collect(joining(", ", "[", "]"));
-        report(graph)
+        report(component)
             .addError(String.format(msgs.extraSetters(), formatted), spec.builderDefinitionType());
       }
 
       Set<ComponentRequirement> missingSetters =
           Sets.difference(requiredDependencies, declaredRequirements);
       if (!missingSetters.isEmpty()) {
-        report(graph)
+        report(component)
             .addError(
                 String.format(
                     msgs.missingSetters(),
@@ -390,7 +345,7 @@ private void validateBuilders(BindingGraph graph) {
           declaredRequirementsByType.entrySet()) {
         if (entry.getValue().size() > 1) {
           TypeMirror type = entry.getKey().get();
-          report(graph)
+          report(component)
               .addError(
                   String.format(msgs.manyMethodsForType(), type, entry.getValue()),
                   spec.builderDefinitionType());
@@ -405,10 +360,10 @@ private void validateBuilders(BindingGraph graph) {
      * <p>As a side-effect, this means scoped components cannot have a dependency cycle between
      * themselves, since a component's presence within its own dependency path implies a cyclical
      * relationship between scopes. However, cycles in component dependencies are explicitly checked
-     * in {@link #validateComponentDependencyHierarchy(BindingGraph)}.
+     * in {@link #validateComponentDependencyHierarchy(ComponentDescriptor)}.
      */
     private void validateDependencyScopeHierarchy(
-        BindingGraph graph,
+        ComponentDescriptor component,
         TypeElement dependency,
         Deque<ImmutableSet<Scope>> scopeStack,
         Deque<TypeElement> scopedDependencyStack) {
@@ -417,16 +372,16 @@ private void validateDependencyScopeHierarchy(
         scopedDependencyStack.push(dependency);
         // Current scope has already appeared in the component chain.
         StringBuilder message = new StringBuilder();
-        message.append(graph.componentType().getQualifiedName());
+        message.append(component.componentDefinitionType().getQualifiedName());
         message.append(" depends on scoped components in a non-hierarchical scope ordering:\n");
         appendIndentedComponentsList(message, scopedDependencyStack);
         if (compilerOptions.scopeCycleValidationType().diagnosticKind().isPresent()) {
-          report(graph)
+          report(component)
               .addItem(
                   message.toString(),
                   compilerOptions.scopeCycleValidationType().diagnosticKind().get(),
-                  graph.componentType(),
-                  getComponentAnnotation(graph.componentType()).get());
+                  component.componentDefinitionType(),
+                  getComponentAnnotation(component.componentDefinitionType()).get());
         }
         scopedDependencyStack.pop();
       } else {
@@ -442,7 +397,7 @@ private void validateDependencyScopeHierarchy(
                     scopeStack.push(scopes);
                     scopedDependencyStack.push(dependency);
                     validateDependencyScopeHierarchy(
-                        graph,
+                        component,
                         getOnlyElement(scopedDependencies),
                         scopeStack,
                         scopedDependencyStack);
@@ -462,168 +417,25 @@ private void validateDependencyScopeHierarchy(
       return false;
     }
 
-    final class BindingGraphValidation extends BindingGraphTraverser {
-
-      BindingGraphValidation(
-          ComponentTreePath componentPath, ComponentMethodDescriptor entryPointMethod) {
-        super(componentPath, entryPointMethod);
-      }
-
-      /** Reports an error for the current component at the entry point. */
-      private void reportErrorAtEntryPoint(String format, Object... args) {
-        reportErrorAtEntryPoint(currentGraph(), format, args);
-      }
-
-      /** Reports an error for the given component at the entry point. */
-      private void reportErrorAtEntryPoint(BindingGraph graph, String format, Object... args) {
-        String message = args.length == 0 ? format : String.format(format, args);
-        report(graph).addError(message, entryPointElement());
-      }
-
-      private String formatDependencyTrace() {
-        return dependencyRequestFormatter.format(dependencyTrace());
-      }
-
-      @Override
-      protected void visitDependencyRequest(DependencyRequest dependencyRequest) {
-        if (atDependencyCycle()) {
-          reportDependencyCycle();
-        } else {
-          super.visitDependencyRequest(dependencyRequest);
-        }
-      }
-
-      @Override
-      protected void visitContributionBinding(
-          ContributionBinding binding, ComponentDescriptor owningComponent) {
-        if (compilerOptions.usesProducers()) {
-          // TODO(dpb,beder): Validate this during @Inject/@Provides/@Produces validation.
-          // Only the Dagger-specific binding may depend on the production executor.
-          Key productionImplementationExecutorKey =
-              keyFactory.forProductionImplementationExecutor();
-          if (!binding.key().equals(productionImplementationExecutorKey)) {
-            Key productionExecutorKey = keyFactory.forProductionExecutor();
-            for (DependencyRequest request : binding.explicitDependencies()) {
-              if (request.key().equals(productionExecutorKey)
-                  || request.key().equals(productionImplementationExecutorKey)) {
-                reportDependsOnProductionExecutor();
-              }
-            }
-          }
-        }
-        super.visitContributionBinding(binding, owningComponent);
-      }
-
-      @SuppressWarnings("resource") // Appendable is a StringBuilder.
-      private void reportDependsOnProductionExecutor() {
-        reportErrorAtEntryPoint(
-            "%s may not depend on the production executor", formatCurrentDependencyRequestKey());
-      }
-
-      // TODO(cgruber): Provide a hint for the start and end of the cycle.
-      private void reportDependencyCycle() {
-        if (!providersBreakingCycle().isEmpty()) {
-          return;
-        }
-        ImmutableList.Builder<ContributionBinding> cycleBindings = ImmutableList.builder();
-        cycleDependencyTrace()
-            .forEach(
-                (dependencyRequest, resolvedBindings) ->
-                    cycleBindings.addAll(resolvedBindings.contributionBindings()));
-        reportErrorAtEntryPoint(
-            owningGraph(cycleBindings.build()),
-            "Found a dependency cycle:\n%s",
-            formatDependencyTrace());
-      }
-
-      /**
-       * Returns any steps in a dependency cycle that "break" the cycle. These are any nonsynthetic
-       * {@link Provider}, {@link Lazy}, or {@code Map<K, Provider<V>>} requests after the first
-       * request in the cycle.
-       *
-       * <p>The synthetic request for a {@code Map<K, Provider<V>>} as a dependency of a multibound
-       * {@code Map<K, V>} does not break cycles because the map's {@link Provider}s' {@link
-       * Provider#get() get()} methods are called during provision.
-       *
-       * <p>A request for an instance of {@code Optional} breaks the cycle if it is resolved to a
-       * {@link BindsOptionalOf} binding and a request for the {@code Optional}'s type parameter
-       * would.
-       */
-      private ImmutableSet<DependencyRequest> providersBreakingCycle() {
-        ImmutableSet.Builder<DependencyRequest> providers = ImmutableSet.builder();
-        AtomicBoolean first = new AtomicBoolean(true);
-        cycleDependencyTrace()
-            .forEach(
-                (dependencyRequest, resolvedBindings) -> {
-                  // Skip the first request in the cycle and any synthetic requests.
-                  if (first.getAndSet(false) || !dependencyRequest.requestElement().isPresent()) {
-                    return;
-                  }
-
-                  if (breaksCycle(dependencyRequest.key().type(), dependencyRequest.kind())) {
-                    providers.add(dependencyRequest);
-                  } else if (!resolvedBindings.optionalBindingDeclarations().isEmpty()) {
-                    /* Request resolved to a @BindsOptionalOf binding, so test the type inside the
-                     * Optional. Optional<Provider or Lazy or Provider of Lazy or Map of Provider>
-                     * breaks the cycle. */
-                    TypeMirror optionalValueType =
-                        OptionalType.from(dependencyRequest.key()).valueType();
-                    RequestKind requestKind = getRequestKind(optionalValueType);
-                    if (breaksCycle(extractKeyType(requestKind, optionalValueType), requestKind)) {
-                      providers.add(dependencyRequest);
-                    }
-                  }
-                });
-        return providers.build();
-      }
-
-      private boolean breaksCycle(TypeMirror requestedType, RequestKind requestKind) {
-        switch (requestKind) {
-          case PROVIDER:
-          case LAZY:
-          case PROVIDER_OF_LAZY:
-            return true;
-
-          case INSTANCE:
-            return MapType.isMap(requestedType)
-                && MapType.from(requestedType).valuesAreTypeOf(Provider.class);
-
-          default:
-            return false;
+    /** Appends and formats a list of indented component types (with their scope annotations). */
+    private void appendIndentedComponentsList(StringBuilder message, Iterable<TypeElement> types) {
+      for (TypeElement scopedComponent : types) {
+        message.append(INDENT);
+        for (Scope scope : scopesOf(scopedComponent)) {
+          message.append(getReadableSource(scope)).append(' ');
         }
-      }
-
-      private String formatCurrentDependencyRequestKey() {
-        return dependencyRequest().key().toString();
+        message
+            .append(stripCommonTypePrefixes(scopedComponent.getQualifiedName().toString()))
+            .append('\n');
       }
     }
-  }
-
-  ValidationReport<TypeElement> validate(BindingGraph graph) {
-    ComponentValidation validation = new ComponentValidation(graph);
-    validation.traverseComponents();
-    return validation.buildReport();
-  }
 
-  /**
-   * Append and format a list of indented component types (with their scope annotations)
-   */
-  private void appendIndentedComponentsList(StringBuilder message, Iterable<TypeElement> types) {
-    for (TypeElement scopedComponent : types) {
-      message.append(INDENT);
-      for (Scope scope : scopesOf(scopedComponent)) {
-        message.append(getReadableSource(scope)).append(' ');
-      }
-      message.append(stripCommonTypePrefixes(scopedComponent.getQualifiedName().toString()))
-          .append('\n');
+    /**
+     * Returns a set of type elements containing only those found in the input set that have a
+     * scoping annotation.
+     */
+    private ImmutableSet<TypeElement> scopedTypesIn(Set<TypeElement> types) {
+      return types.stream().filter(type -> !scopesOf(type).isEmpty()).collect(toImmutableSet());
     }
   }
-
-  /**
-   * Returns a set of type elements containing only those found in the input set that have
-   * a scoping annotation.
-   */
-  private ImmutableSet<TypeElement> scopedTypesIn(Set<TypeElement> types) {
-    return types.stream().filter(type -> !scopesOf(type).isEmpty()).collect(toImmutableSet());
-  }
 }
diff --git a/java/dagger/internal/codegen/ComponentGenerator.java b/java/dagger/internal/codegen/ComponentGenerator.java
index 1b8086dfe..d15341cf3 100644
--- a/java/dagger/internal/codegen/ComponentGenerator.java
+++ b/java/dagger/internal/codegen/ComponentGenerator.java
@@ -36,6 +36,7 @@
   private final DaggerElements elements;
   private final KeyFactory keyFactory;
   private final CompilerOptions compilerOptions;
+  private final BindingGraphFactory bindingGraphFactory;
 
   @Inject
   ComponentGenerator(
@@ -44,12 +45,14 @@
       SourceVersion sourceVersion,
       DaggerTypes types,
       KeyFactory keyFactory,
-      CompilerOptions compilerOptions) {
+      CompilerOptions compilerOptions,
+      BindingGraphFactory bindingGraphFactory) {
     super(filer, elements, sourceVersion);
     this.types = types;
     this.elements = elements;
     this.keyFactory = keyFactory;
     this.compilerOptions = compilerOptions;
+    this.bindingGraphFactory = bindingGraphFactory;
   }
 
   @Override
@@ -63,14 +66,21 @@ static ClassName componentName(TypeElement componentDefinitionType) {
   }
 
   @Override
-  Optional<? extends Element> getElementForErrorReporting(BindingGraph input) {
-    return Optional.of(input.componentType());
+  Element originatingElement(BindingGraph input) {
+    return input.componentType();
   }
 
   @Override
   Optional<TypeSpec.Builder> write(ClassName componentName, BindingGraph input) {
     return Optional.of(
-        ComponentWriter.writeComponent(
-            types, elements, keyFactory, compilerOptions, componentName, input));
+        ComponentModelBuilder.buildComponentModel(
+                types,
+                elements,
+                keyFactory,
+                compilerOptions,
+                componentName,
+                input,
+                bindingGraphFactory)
+            .generate());
   }
 }
diff --git a/java/dagger/internal/codegen/ComponentHjarProcessingStep.java b/java/dagger/internal/codegen/ComponentHjarProcessingStep.java
index fbbd0718a..cedc3896c 100644
--- a/java/dagger/internal/codegen/ComponentHjarProcessingStep.java
+++ b/java/dagger/internal/codegen/ComponentHjarProcessingStep.java
@@ -72,7 +72,7 @@
  * compilation succeeded.
  *
  * <p>The components emitted by this processing step include all of the API elements exposed by the
- * normal {@link ComponentWriter}. Method bodies are omitted as Turbine ignores them entirely.
+ * normal step. Method bodies are omitted as Turbine ignores them entirely.
  */
 final class ComponentHjarProcessingStep implements ProcessingStep {
   private final Elements elements;
@@ -147,8 +147,8 @@ ClassName nameGeneratedType(ComponentDescriptor input) {
     }
 
     @Override
-    Optional<? extends Element> getElementForErrorReporting(ComponentDescriptor input) {
-      return Optional.of(input.componentDefinitionType());
+    Element originatingElement(ComponentDescriptor input) {
+      return input.componentDefinitionType();
     }
 
     @Override
@@ -188,7 +188,7 @@ ClassName nameGeneratedType(ComponentDescriptor input) {
       }
 
       DeclaredType componentType = MoreTypes.asDeclared(componentElement.asType());
-      // TODO(ronshapiro): unify with AbstractComponentWriter
+      // TODO(ronshapiro): unify with ComponentModelBuilder
       Set<MethodSignature> methodSignatures =
           Sets.newHashSetWithExpectedSize(componentDescriptor.componentMethods().size());
       componentDescriptor
diff --git a/java/dagger/internal/codegen/ComponentMethodBindingExpression.java b/java/dagger/internal/codegen/ComponentMethodBindingExpression.java
index 2a53a223c..760c73523 100644
--- a/java/dagger/internal/codegen/ComponentMethodBindingExpression.java
+++ b/java/dagger/internal/codegen/ComponentMethodBindingExpression.java
@@ -45,7 +45,7 @@
 
   @Override
   protected CodeBlock getComponentMethodImplementation(
-      ComponentMethodDescriptor componentMethod, ClassName componentName) {
+      ComponentMethodDescriptor componentMethod, GeneratedComponentModel component) {
     // There could be several methods on the component for the same request key and kind.
     // Only one should use the BindingMethodImplementation; the others can delegate that one. So
     // use methodImplementation.body() only if componentMethod equals the method for this instance.
@@ -55,10 +55,9 @@ protected CodeBlock getComponentMethodImplementation(
     // for the parent and the child. Only the parent's should use the BindingMethodImplementation;
     // the child's can delegate to the parent. So use methodImplementation.body() only if
     // componentName equals the component for this instance.
-    return componentMethod.equals(this.componentMethod)
-            && componentName.equals(generatedComponentModel.name())
+    return componentMethod.equals(this.componentMethod) && component.equals(generatedComponentModel)
         ? methodImplementation.body()
-        : super.getComponentMethodImplementation(componentMethod, componentName);
+        : super.getComponentMethodImplementation(componentMethod, component);
   }
 
   @Override
diff --git a/java/dagger/internal/codegen/ComponentModelBuilder.java b/java/dagger/internal/codegen/ComponentModelBuilder.java
new file mode 100644
index 000000000..01d70a971
--- /dev/null
+++ b/java/dagger/internal/codegen/ComponentModelBuilder.java
@@ -0,0 +1,664 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.auto.common.MoreElements.getLocalAndInheritedMethods;
+import static com.google.auto.common.MoreTypes.asDeclared;
+import static com.google.common.base.Preconditions.checkState;
+import static com.squareup.javapoet.MethodSpec.constructorBuilder;
+import static com.squareup.javapoet.MethodSpec.methodBuilder;
+import static dagger.internal.codegen.AnnotationSpecs.Suppression.UNCHECKED;
+import static dagger.internal.codegen.CodeBlocks.toParametersCodeBlock;
+import static dagger.internal.codegen.DaggerStreams.toImmutableList;
+import static dagger.internal.codegen.GeneratedComponentModel.MethodSpecKind.BUILDER_METHOD;
+import static dagger.internal.codegen.GeneratedComponentModel.MethodSpecKind.CANCELLATION_LISTENER_METHOD;
+import static dagger.internal.codegen.GeneratedComponentModel.MethodSpecKind.COMPONENT_METHOD;
+import static dagger.internal.codegen.GeneratedComponentModel.MethodSpecKind.CONSTRUCTOR;
+import static dagger.internal.codegen.GeneratedComponentModel.MethodSpecKind.INITIALIZE_METHOD;
+import static dagger.internal.codegen.GeneratedComponentModel.TypeSpecKind.COMPONENT_BUILDER;
+import static dagger.internal.codegen.GeneratedComponentModel.TypeSpecKind.SUBCOMPONENT;
+import static dagger.internal.codegen.ProducerNodeInstanceBindingExpression.MAY_INTERRUPT_IF_RUNNING;
+import static javax.lang.model.element.Modifier.FINAL;
+import static javax.lang.model.element.Modifier.PRIVATE;
+import static javax.lang.model.element.Modifier.PROTECTED;
+import static javax.lang.model.element.Modifier.PUBLIC;
+import static javax.lang.model.element.Modifier.STATIC;
+
+import com.google.auto.common.MoreTypes;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableListMultimap;
+import com.google.common.collect.Iterables;
+import com.google.common.collect.Lists;
+import com.google.common.collect.Multimaps;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.MethodSpec;
+import com.squareup.javapoet.ParameterSpec;
+import com.squareup.javapoet.TypeSpec;
+import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
+import dagger.internal.codegen.ModifiableBindingMethods.ModifiableBindingMethod;
+import dagger.producers.internal.CancellationListener;
+import java.util.List;
+import java.util.Optional;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.type.DeclaredType;
+
+/** Builds the model for an implementation of a component or subcomponent. */
+abstract class ComponentModelBuilder {
+  static GeneratedComponentModel buildComponentModel(
+      DaggerTypes types,
+      DaggerElements elements,
+      KeyFactory keyFactory,
+      CompilerOptions compilerOptions,
+      ClassName name,
+      BindingGraph graph,
+      BindingGraphFactory bindingGraphFactory) {
+    GeneratedComponentModel generatedComponentModel =
+        GeneratedComponentModel.create(name, graph, keyFactory);
+    OptionalFactories optionalFactories = new OptionalFactories(generatedComponentModel);
+    Optional<GeneratedComponentBuilderModel> generatedComponentBuilderModel =
+        GeneratedComponentBuilderModel.create(generatedComponentModel, graph, elements, types);
+    ComponentRequirementFields componentRequirementFields =
+        new ComponentRequirementFields(
+            graph, generatedComponentModel, generatedComponentBuilderModel);
+    ComponentBindingExpressions bindingExpressions =
+        new ComponentBindingExpressions(
+            graph,
+            generatedComponentModel,
+            componentRequirementFields,
+            optionalFactories,
+            types,
+            elements,
+            compilerOptions);
+    if (generatedComponentModel.isAbstract()) {
+      checkState(
+          compilerOptions.aheadOfTimeSubcomponents(),
+          "Calling 'buildComponentModel()' on %s when not generating ahead-of-time subcomponents.",
+          graph.componentDescriptor().componentDefinitionType());
+      return new AbstractSubcomponentModelBuilder(
+              Optional.empty(), /* parent */
+              types,
+              elements,
+              keyFactory,
+              graph,
+              generatedComponentModel,
+              optionalFactories,
+              bindingExpressions,
+              componentRequirementFields,
+              generatedComponentBuilderModel,
+              bindingGraphFactory,
+              compilerOptions)
+          .build();
+    } else {
+      return new RootComponentModelBuilder(
+              types,
+              elements,
+              keyFactory,
+              graph,
+              generatedComponentModel,
+              optionalFactories,
+              bindingExpressions,
+              componentRequirementFields,
+              generatedComponentBuilderModel,
+              bindingGraphFactory,
+              compilerOptions)
+          .build();
+    }
+  }
+
+  private final DaggerElements elements;
+  private final DaggerTypes types;
+  private final KeyFactory keyFactory;
+  private final BindingGraph graph;
+  private final ComponentBindingExpressions bindingExpressions;
+  private final ComponentRequirementFields componentRequirementFields;
+  private final GeneratedComponentModel generatedComponentModel;
+  private final OptionalFactories optionalFactories;
+  private final Optional<GeneratedComponentBuilderModel> generatedComponentBuilderModel;
+  private final BindingGraphFactory bindingGraphFactory;
+  private final CompilerOptions compilerOptions;
+  private boolean done;
+
+  private ComponentModelBuilder(
+      DaggerTypes types,
+      DaggerElements elements,
+      KeyFactory keyFactory,
+      BindingGraph graph,
+      GeneratedComponentModel generatedComponentModel,
+      OptionalFactories optionalFactories,
+      ComponentBindingExpressions bindingExpressions,
+      ComponentRequirementFields componentRequirementFields,
+      Optional<GeneratedComponentBuilderModel> generatedComponentBuilderModel,
+      BindingGraphFactory bindingGraphFactory,
+      CompilerOptions compilerOptions) {
+    this.types = types;
+    this.elements = elements;
+    this.keyFactory = keyFactory;
+    this.graph = graph;
+    this.generatedComponentModel = generatedComponentModel;
+    this.optionalFactories = optionalFactories;
+    this.bindingExpressions = bindingExpressions;
+    this.componentRequirementFields = componentRequirementFields;
+    this.generatedComponentBuilderModel = generatedComponentBuilderModel;
+    this.bindingGraphFactory = bindingGraphFactory;
+    this.compilerOptions = compilerOptions;
+  }
+
+  /**
+   * Returns a {@link GeneratedComponentModel} for this component. This is only intended to be
+   * called once (and will throw on successive invocations). If the component must be regenerated,
+   * use a new instance.
+   */
+  protected final GeneratedComponentModel build() {
+    checkState(
+        !done,
+        "ComponentModelBuilder has already built the GeneratedComponentModel for [%s].",
+        generatedComponentModel.name());
+    setSupertype();
+    generatedComponentBuilderModel
+        .map(GeneratedComponentBuilderModel::typeSpec)
+        .ifPresent(this::addBuilderClass);
+
+    getLocalAndInheritedMethods(
+            graph.componentDescriptor().componentDefinitionType(), types, elements)
+        .forEach(method -> generatedComponentModel.claimMethodName(method.getSimpleName()));
+
+    addFactoryMethods();
+    addInterfaceMethods();
+    addSubcomponents();
+    addConstructor();
+
+    if (graph.componentDescriptor().kind().isProducer()) {
+      addCancellationListenerImplementation();
+    }
+
+    done = true;
+    return generatedComponentModel;
+  }
+
+  /** Set the supertype for this generated class. */
+  private void setSupertype() {
+    if (generatedComponentModel.supermodel().isPresent()) {
+      generatedComponentModel.addSuperclass(generatedComponentModel.supermodel().get().name());
+    } else {
+      generatedComponentModel.addSupertype(graph.componentType());
+    }
+  }
+
+  /**
+   * Adds {@code builder} as a nested builder class. Root components and subcomponents will nest
+   * this in different classes.
+   */
+  protected abstract void addBuilderClass(TypeSpec builder);
+
+  /** Adds component factory methods. */
+  protected abstract void addFactoryMethods();
+
+  protected void addInterfaceMethods() {
+    /* Each component method may have been declared by several supertypes. We want to implement only
+     * one method for each distinct signature.*/
+    ImmutableListMultimap<MethodSignature, ComponentMethodDescriptor> componentMethodsBySignature =
+        Multimaps.index(graph.componentDescriptor().entryPointMethods(), this::getMethodSignature);
+    for (List<ComponentMethodDescriptor> methodsWithSameSignature :
+        Multimaps.asMap(componentMethodsBySignature).values()) {
+      ComponentMethodDescriptor anyOneMethod = methodsWithSameSignature.stream().findAny().get();
+      MethodSpec methodSpec = bindingExpressions.getComponentMethod(anyOneMethod);
+
+      // If the binding for the component method is modifiable, register it as such.
+      ModifiableBindingType modifiableBindingType =
+          bindingExpressions
+              .modifiableBindingExpressions()
+              .registerComponentMethodIfModifiable(anyOneMethod, methodSpec);
+
+      // If the method should be implemented in this component, implement it.
+      if (modifiableBindingType.hasBaseClassImplementation()) {
+        generatedComponentModel.addMethod(COMPONENT_METHOD, methodSpec);
+      }
+    }
+  }
+
+  private static final int STATEMENTS_PER_METHOD = 100;
+
+  private static final String CANCELLATION_LISTENER_METHOD_NAME = "onProducerFutureCancelled";
+
+  private void addCancellationListenerImplementation() {
+    generatedComponentModel.addSupertype(elements.getTypeElement(CancellationListener.class));
+    generatedComponentModel.claimMethodName(CANCELLATION_LISTENER_METHOD_NAME);
+
+    // Reversing should order cancellations starting from entry points and going down to leaves
+    // rather than the other way around. This shouldn't really matter but seems *slightly*
+    // preferable because:
+    // When a future that another future depends on is cancelled, that cancellation will propagate
+    // up the future graph toward the entry point. Cancelling in reverse order should ensure that
+    // everything that depends on a particular node has already been cancelled when that node is
+    // cancelled, so there's no need to propagate. Otherwise, when we cancel a leaf node, it might
+    // propagate through most of the graph, making most of the cancel calls that follow in the
+    // onProducerFutureCancelled method do nothing.
+    ImmutableList<CodeBlock> cancellationStatements =
+        generatedComponentModel.getCancellations().reverse();
+    MethodSpec.Builder methodBuilder =
+        methodBuilder(CANCELLATION_LISTENER_METHOD_NAME)
+            .addModifiers(PUBLIC)
+            .addAnnotation(Override.class)
+            .addParameter(boolean.class, MAY_INTERRUPT_IF_RUNNING);
+    if (generatedComponentModel.supermodel().isPresent()) {
+      methodBuilder.addStatement(
+          "super.$L($L)", CANCELLATION_LISTENER_METHOD_NAME, MAY_INTERRUPT_IF_RUNNING);
+    }
+
+    if (cancellationStatements.size() < STATEMENTS_PER_METHOD) {
+      methodBuilder.addCode(CodeBlocks.concat(cancellationStatements)).build();
+    } else {
+      List<List<CodeBlock>> partitions =
+          Lists.partition(cancellationStatements, STATEMENTS_PER_METHOD);
+      for (List<CodeBlock> partition : partitions) {
+        String methodName = generatedComponentModel.getUniqueMethodName("cancelProducers");
+        MethodSpec method =
+            MethodSpec.methodBuilder(methodName)
+                .addModifiers(PRIVATE)
+                .addParameter(boolean.class, MAY_INTERRUPT_IF_RUNNING)
+                .addCode(CodeBlocks.concat(partition))
+                .build();
+        methodBuilder.addStatement("$N($L)", method, MAY_INTERRUPT_IF_RUNNING);
+        generatedComponentModel.addMethod(CANCELLATION_LISTENER_METHOD, method);
+      }
+    }
+
+    generatedComponentModel.addMethod(CANCELLATION_LISTENER_METHOD, methodBuilder.build());
+  }
+
+  private MethodSignature getMethodSignature(ComponentMethodDescriptor method) {
+    return MethodSignature.forComponentMethod(
+        method, MoreTypes.asDeclared(graph.componentType().asType()), types);
+  }
+
+  private void addSubcomponents() {
+    for (BindingGraph subgraph : graph.subgraphs()) {
+      // TODO(b/72748365): Can an abstract inner subcomponent implementation be elided if it's
+      // totally empty?
+      generatedComponentModel.addSubcomponent(
+          subgraph.componentDescriptor(),
+          generatedComponentModel.isAbstract()
+              ? buildAbstractInnerSubcomponentModel(subgraph)
+              : buildSubcomponentModel(subgraph));
+    }
+  }
+
+  private GeneratedComponentModel buildAbstractInnerSubcomponentModel(BindingGraph childGraph) {
+    GeneratedComponentModel supermodel =
+        getSubcomponentSupermodel(childGraph.componentDescriptor());
+    GeneratedComponentModel childModel =
+        GeneratedComponentModel.forAbstractSubcomponent(
+            childGraph.componentDescriptor(), supermodel, generatedComponentModel);
+    Optional<GeneratedComponentBuilderModel> childBuilderModel =
+        GeneratedComponentBuilderModel.create(childModel, childGraph, elements, types);
+    ComponentRequirementFields childComponentRequirementFields =
+        componentRequirementFields.forChildComponent(childGraph, childModel, childBuilderModel);
+    ComponentBindingExpressions childBindingExpressions =
+        bindingExpressions.forChildComponent(
+            childGraph, childModel, childComponentRequirementFields);
+    return new AbstractSubcomponentModelBuilder(
+            Optional.of(this),
+            types,
+            elements,
+            keyFactory,
+            childGraph,
+            childModel,
+            optionalFactories,
+            childBindingExpressions,
+            childComponentRequirementFields,
+            childBuilderModel,
+            bindingGraphFactory,
+            compilerOptions)
+        .build();
+  }
+
+  private GeneratedComponentModel getSubcomponentSupermodel(ComponentDescriptor subcomponent) {
+    // If the current model is for a subcomponent that has a defined supermodel, that supermodel
+    // should contain a reference to a model for `subcomponent`
+    if (generatedComponentModel.supermodel().isPresent()) {
+      Optional<GeneratedComponentModel> supermodel =
+          generatedComponentModel.supermodel().get().subcomponentModel(subcomponent);
+      checkState(
+          supermodel.isPresent(),
+          "Attempting to generate an implementation of a subcomponent [%s] whose parent is a "
+              + "subcomponent [%s], but whose supermodel is not present on the parent's "
+              + "supermodel.",
+          subcomponent.componentDefinitionType(),
+          graph.componentType());
+      return supermodel.get();
+    }
+
+    // Otherwise, the enclosing component is top-level, so we must generate the supermodel for the
+    // subcomponent. We do so by building the model for the abstract base class for the
+    // subcomponent. This is done by truncating the binding graph at the subcomponent.
+    BindingGraph truncatedBindingGraph = bindingGraphFactory.create(subcomponent);
+    return buildComponentModel(
+        // TODO(ronshapiro): extract a factory class here so that we don't need to pass around
+        // types, elements, keyFactory, etc...
+        types,
+        elements,
+        keyFactory,
+        compilerOptions,
+        ComponentGenerator.componentName(truncatedBindingGraph.componentType()),
+        truncatedBindingGraph,
+        bindingGraphFactory);
+  }
+
+  private GeneratedComponentModel buildSubcomponentModel(BindingGraph childGraph) {
+    GeneratedComponentModel childModel =
+        GeneratedComponentModel.forSubcomponent(
+            childGraph.componentDescriptor(), generatedComponentModel);
+    Optional<GeneratedComponentBuilderModel> childBuilderModel =
+        GeneratedComponentBuilderModel.create(childModel, childGraph, elements, types);
+    ComponentRequirementFields childComponentRequirementFields =
+        componentRequirementFields.forChildComponent(childGraph, childModel, childBuilderModel);
+    ComponentBindingExpressions childBindingExpressions =
+        bindingExpressions.forChildComponent(
+            childGraph, childModel, childComponentRequirementFields);
+    return new SubComponentModelBuilder(
+            this,
+            childGraph,
+            childModel,
+            childBindingExpressions,
+            childComponentRequirementFields,
+            childBuilderModel)
+        .build();
+  }
+
+  private void addConstructor() {
+    List<List<CodeBlock>> partitions =
+        Lists.partition(generatedComponentModel.getInitializations(), STATEMENTS_PER_METHOD);
+
+    ImmutableList<ParameterSpec> constructorParameters = constructorParameters();
+    MethodSpec.Builder constructor =
+        constructorBuilder()
+            .addModifiers(generatedComponentModel.isAbstract() ? PROTECTED : PRIVATE)
+            .addParameters(constructorParameters);
+
+    if (generatedComponentModel.supermodel().isPresent()) {
+      constructor.addStatement(
+          CodeBlock.of(
+              "super($L)",
+              constructorParameters
+                  .stream()
+                  .map(param -> CodeBlock.of("$N", param))
+                  .collect(toParametersCodeBlock())));
+    }
+
+    ImmutableList<ParameterSpec> initializeParameters = initializeParameters();
+    CodeBlock initializeParametersCodeBlock =
+        constructorParameters
+            .stream()
+            .map(param -> CodeBlock.of("$N", param))
+            .collect(toParametersCodeBlock());
+
+    for (List<CodeBlock> partition : partitions) {
+      String methodName = generatedComponentModel.getUniqueMethodName("initialize");
+      MethodSpec.Builder initializeMethod =
+          methodBuilder(methodName)
+              .addModifiers(PRIVATE)
+              /* TODO(gak): Strictly speaking, we only need the suppression here if we are also
+               * initializing a raw field in this method, but the structure of this code makes it
+               * awkward to pass that bit through.  This will be cleaned up when we no longer
+               * separate fields and initialization as we do now. */
+              .addAnnotation(AnnotationSpecs.suppressWarnings(UNCHECKED))
+              .addCode(CodeBlocks.concat(partition));
+      initializeMethod.addParameters(initializeParameters);
+      constructor.addStatement("$L($L)", methodName, initializeParametersCodeBlock);
+      generatedComponentModel.addMethod(INITIALIZE_METHOD, initializeMethod.build());
+    }
+    generatedComponentModel.addMethod(CONSTRUCTOR, constructor.build());
+  }
+
+  /** Returns the list of {@link ParameterSpec}s for the initialize methods. */
+  private ImmutableList<ParameterSpec> initializeParameters() {
+    return constructorParameters()
+        .stream()
+        .map(param -> param.toBuilder().addModifiers(FINAL).build())
+        .collect(toImmutableList());
+  }
+
+  /** Returns the list of {@link ParameterSpec}s for the constructor. */
+  private ImmutableList<ParameterSpec> constructorParameters() {
+    if (generatedComponentBuilderModel.isPresent()) {
+      return ImmutableList.of(
+          ParameterSpec.builder(generatedComponentBuilderModel.get().name(), "builder").build());
+    } else if (graph.factoryMethod().isPresent()) {
+      return getFactoryMethodParameterSpecs(graph);
+    } else if (generatedComponentModel.isAbstract() && !generatedComponentModel.isNested()) {
+      return ImmutableList.of();
+    } else {
+      throw new AssertionError(
+          "Expected either a component builder or factory method but found neither.");
+    }
+  }
+
+  /** Builds the model for the root component. */
+  private static final class RootComponentModelBuilder extends ComponentModelBuilder {
+    RootComponentModelBuilder(
+        DaggerTypes types,
+        DaggerElements elements,
+        KeyFactory keyFactory,
+        BindingGraph graph,
+        GeneratedComponentModel generatedComponentModel,
+        OptionalFactories optionalFactories,
+        ComponentBindingExpressions bindingExpressions,
+        ComponentRequirementFields componentRequirementFields,
+        Optional<GeneratedComponentBuilderModel> generatedComponentBuilderModel,
+        BindingGraphFactory bindingGraphFactory,
+        CompilerOptions compilerOptions) {
+      super(
+          types,
+          elements,
+          keyFactory,
+          graph,
+          generatedComponentModel,
+          optionalFactories,
+          bindingExpressions,
+          componentRequirementFields,
+          generatedComponentBuilderModel,
+          bindingGraphFactory,
+          compilerOptions);
+    }
+
+    @Override
+    protected void addBuilderClass(TypeSpec builder) {
+      super.generatedComponentModel.addType(COMPONENT_BUILDER, builder);
+    }
+
+    @Override
+    protected void addFactoryMethods() {
+      // Only top-level components have the factory builder() method.
+      // Mirror the user's builder API type if they had one.
+      MethodSpec builderFactoryMethod =
+          methodBuilder("builder")
+              .addModifiers(PUBLIC, STATIC)
+              .returns(
+                  builderSpec().isPresent()
+                      ? ClassName.get(builderSpec().get().builderDefinitionType())
+                      : super.generatedComponentBuilderModel.get().name())
+              .addStatement("return new $T()", super.generatedComponentBuilderModel.get().name())
+              .build();
+      super.generatedComponentModel.addMethod(BUILDER_METHOD, builderFactoryMethod);
+      if (canInstantiateAllRequirements()) {
+        CharSequence buildMethodName =
+            builderSpec().isPresent() ? builderSpec().get().buildMethod().getSimpleName() : "build";
+        super.generatedComponentModel.addMethod(
+            BUILDER_METHOD,
+            methodBuilder("create")
+                .returns(ClassName.get(super.graph.componentType()))
+                .addModifiers(PUBLIC, STATIC)
+                .addStatement("return new Builder().$L()", buildMethodName)
+                .build());
+      }
+    }
+
+    private Optional<ComponentDescriptor.BuilderSpec> builderSpec() {
+      return super.graph.componentDescriptor().builderSpec();
+    }
+
+    /** {@code true} if all of the graph's required dependencies can be automatically constructed */
+    private boolean canInstantiateAllRequirements() {
+      return !Iterables.any(
+          super.graph.componentRequirements(),
+          dependency -> dependency.requiresAPassedInstance(super.elements, super.types));
+    }
+  }
+
+  /**
+   * Builds the model for a nested subcomponent. This is used when ahead-of-time components are not
+   * enabled (current default mode).
+   */
+  private static final class SubComponentModelBuilder extends ComponentModelBuilder {
+    private final ComponentModelBuilder parent;
+
+    SubComponentModelBuilder(
+        ComponentModelBuilder parent,
+        BindingGraph graph,
+        GeneratedComponentModel generatedComponentModel,
+        ComponentBindingExpressions bindingExpressions,
+        ComponentRequirementFields componentRequirementFields,
+        Optional<GeneratedComponentBuilderModel> generatedComponentBuilderModel) {
+      super(
+          parent.types,
+          parent.elements,
+          parent.keyFactory,
+          graph,
+          generatedComponentModel,
+          parent.optionalFactories,
+          bindingExpressions,
+          componentRequirementFields,
+          generatedComponentBuilderModel,
+          parent.bindingGraphFactory,
+          parent.compilerOptions);
+      this.parent = parent;
+    }
+
+    @Override
+    protected void addBuilderClass(TypeSpec builder) {
+      parent.generatedComponentModel.addType(SUBCOMPONENT, builder);
+    }
+
+    @Override
+    protected void addFactoryMethods() {
+      // The parent's factory method to create this subcomponent if the
+      // subcomponent was not added via {@link dagger.Module#subcomponents()}.
+      super.graph.factoryMethod().ifPresent(this::createSubcomponentFactoryMethod);
+    }
+
+    private void createSubcomponentFactoryMethod(ExecutableElement factoryMethod) {
+      parent.generatedComponentModel.addMethod(
+          COMPONENT_METHOD,
+          MethodSpec.overriding(factoryMethod, parentType(), super.types)
+              .addStatement(
+                  "return new $T($L)",
+                  super.generatedComponentModel.name(),
+                  getFactoryMethodParameterSpecs(super.graph)
+                      .stream()
+                      .map(param -> CodeBlock.of("$N", param))
+                      .collect(toParametersCodeBlock()))
+              .build());
+    }
+
+    private DeclaredType parentType() {
+      return asDeclared(parent.graph.componentType().asType());
+    }
+  }
+
+  /** Builds the model for abstract implementations of a subcomponent. */
+  private static final class AbstractSubcomponentModelBuilder extends ComponentModelBuilder {
+    private final Optional<ComponentModelBuilder> parent;
+    private final GeneratedComponentModel generatedComponentModel;
+    private final ComponentBindingExpressions bindingExpressions;
+
+    AbstractSubcomponentModelBuilder(
+        Optional<ComponentModelBuilder> parent,
+        DaggerTypes types,
+        DaggerElements elements,
+        KeyFactory keyFactory,
+        BindingGraph graph,
+        GeneratedComponentModel generatedComponentModel,
+        OptionalFactories optionalFactories,
+        ComponentBindingExpressions bindingExpressions,
+        ComponentRequirementFields componentRequirementFields,
+        Optional<GeneratedComponentBuilderModel> generatedComponentBuilderModel,
+        BindingGraphFactory bindingGraphFactory,
+        CompilerOptions compilerOptions) {
+      super(
+          types,
+          elements,
+          keyFactory,
+          graph,
+          generatedComponentModel,
+          optionalFactories,
+          bindingExpressions,
+          componentRequirementFields,
+          generatedComponentBuilderModel,
+          bindingGraphFactory,
+          compilerOptions);
+      this.parent = parent;
+      this.generatedComponentModel = generatedComponentModel;
+      this.bindingExpressions = bindingExpressions;
+    }
+
+    @Override
+    protected void addBuilderClass(TypeSpec builder) {
+      if (parent.isPresent()) {
+        // If an inner implementation of a subcomponent the builder is a peer class.
+        parent.get().generatedComponentModel.addType(SUBCOMPONENT, builder);
+      } else {
+        generatedComponentModel.addType(SUBCOMPONENT, builder);
+      }
+    }
+
+    @Override
+    protected void addFactoryMethods() {
+      // Only construct instances of subcomponents that have concrete implementations.
+    }
+
+    @Override
+    protected void addInterfaceMethods() {
+      if (generatedComponentModel.supermodel().isPresent()) {
+        // Since we're overriding a subcomponent implementation we add to its implementation given
+        // an expanded binding graph.
+
+        // Override modifiable binding methods.
+        for (ModifiableBindingMethod modifiableBindingMethod :
+            generatedComponentModel.getModifiableBindingMethods()) {
+          bindingExpressions
+              .modifiableBindingExpressions()
+              .getModifiableBindingMethod(modifiableBindingMethod)
+              .ifPresent(
+                  method -> generatedComponentModel.addImplementedModifiableBindingMethod(method));
+        }
+      } else {
+        super.addInterfaceMethods();
+      }
+    }
+  }
+
+  /** Returns the list of {@link ParameterSpec}s for the corresponding graph's factory method. */
+  private static ImmutableList<ParameterSpec> getFactoryMethodParameterSpecs(BindingGraph graph) {
+    return graph
+        .factoryMethodParameters()
+        .values()
+        .stream()
+        .map(ParameterSpec::get)
+        .collect(toImmutableList());
+  }
+}
diff --git a/java/dagger/internal/codegen/ComponentNodeImpl.java b/java/dagger/internal/codegen/ComponentNodeImpl.java
new file mode 100644
index 000000000..7b624aa17
--- /dev/null
+++ b/java/dagger/internal/codegen/ComponentNodeImpl.java
@@ -0,0 +1,50 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import com.google.auto.value.AutoValue;
+import com.google.common.collect.ImmutableSet;
+import dagger.model.BindingGraph.ComponentNode;
+import dagger.model.ComponentPath;
+import dagger.model.DependencyRequest;
+import dagger.model.Scope;
+
+/** An implementation of {@link ComponentNode} that also exposes the {@link ComponentDescriptor}. */
+@AutoValue
+abstract class ComponentNodeImpl implements ComponentNode {
+  static ComponentNode create(
+      ComponentPath componentPath, ComponentDescriptor componentDescriptor) {
+    return new AutoValue_ComponentNodeImpl(componentPath, componentDescriptor);
+  }
+
+  @Override
+  public ImmutableSet<DependencyRequest> entryPoints() {
+    return componentDescriptor().entryPoints();
+  }
+
+  @Override
+  public ImmutableSet<Scope> scopes() {
+    return componentDescriptor().scopes();
+  }
+
+  abstract ComponentDescriptor componentDescriptor();
+
+  @Override
+  public final String toString() {
+    return componentPath().toString();
+  }
+}
diff --git a/java/dagger/internal/codegen/ComponentProcessingStep.java b/java/dagger/internal/codegen/ComponentProcessingStep.java
index 17d06dc7c..62881c3d3 100644
--- a/java/dagger/internal/codegen/ComponentProcessingStep.java
+++ b/java/dagger/internal/codegen/ComponentProcessingStep.java
@@ -17,7 +17,6 @@
 package dagger.internal.codegen;
 
 import static javax.lang.model.util.ElementFilter.typesIn;
-import static javax.tools.Diagnostic.Kind.ERROR;
 
 import com.google.auto.common.BasicAnnotationProcessor.ProcessingStep;
 import com.google.auto.common.MoreElements;
@@ -47,39 +46,39 @@
   private final Messager messager;
   private final ComponentValidator componentValidator;
   private final BuilderValidator builderValidator;
-  private final ComponentHierarchyValidator componentHierarchyValidator;
-  private final BindingGraphValidator bindingGraphValidator;
+  private final ComponentDescriptorValidator componentDescriptorValidator;
   private final ComponentDescriptor.Factory componentDescriptorFactory;
   private final BindingGraphFactory bindingGraphFactory;
   private final ComponentGenerator componentGenerator;
   private final BindingGraphConverter bindingGraphConverter;
   private final BindingGraphPlugins validationPlugins;
   private final BindingGraphPlugins spiPlugins;
+  private final CompilerOptions compilerOptions;
 
   @Inject
   ComponentProcessingStep(
       Messager messager,
       ComponentValidator componentValidator,
       BuilderValidator builderValidator,
-      ComponentHierarchyValidator componentHierarchyValidator,
-      BindingGraphValidator bindingGraphValidator,
+      ComponentDescriptorValidator componentDescriptorValidator,
       ComponentDescriptor.Factory componentDescriptorFactory,
       BindingGraphFactory bindingGraphFactory,
       ComponentGenerator componentGenerator,
       BindingGraphConverter bindingGraphConverter,
       @Validation BindingGraphPlugins validationPlugins,
-      BindingGraphPlugins spiPlugins) {
+      BindingGraphPlugins spiPlugins,
+      CompilerOptions compilerOptions) {
     this.messager = messager;
     this.componentValidator = componentValidator;
     this.builderValidator = builderValidator;
-    this.componentHierarchyValidator = componentHierarchyValidator;
-    this.bindingGraphValidator = bindingGraphValidator;
+    this.componentDescriptorValidator = componentDescriptorValidator;
     this.componentDescriptorFactory = componentDescriptorFactory;
     this.bindingGraphFactory = bindingGraphFactory;
     this.componentGenerator = componentGenerator;
     this.bindingGraphConverter = bindingGraphConverter;
     this.validationPlugins = validationPlugins;
     this.spiPlugins = spiPlugins;
+    this.compilerOptions = compilerOptions;
   }
 
   @Override
@@ -136,10 +135,10 @@
         }
         ComponentDescriptor componentDescriptor =
             componentDescriptorFactory.forComponent(componentTypeElement);
-        ValidationReport<TypeElement> hierarchyReport =
-            componentHierarchyValidator.validate(componentDescriptor);
-        hierarchyReport.printMessagesTo(messager);
-        if (!hierarchyReport.isClean()) {
+        ValidationReport<TypeElement> componentDescriptorReport =
+            componentDescriptorValidator.validate(componentDescriptor);
+        componentDescriptorReport.printMessagesTo(messager);
+        if (!componentDescriptorReport.isClean()) {
           continue;
         }
         BindingGraph bindingGraph = bindingGraphFactory.create(componentDescriptor);
@@ -150,18 +149,32 @@
         rejectedElements.add(componentTypeElement);
       }
     }
+
+    if (compilerOptions.aheadOfTimeSubcomponents()) {
+      for (TypeElement subcomponentTypeElement : typesIn(subcomponentElements)) {
+        if (!subcomponentIsClean(
+            subcomponentTypeElement, reportsBySubcomponent, builderReportsBySubcomponent)) {
+          continue;
+        }
+        try {
+          ComponentDescriptor componentDescriptor =
+              componentDescriptorFactory.forComponent(subcomponentTypeElement);
+          BindingGraph bindingGraph = bindingGraphFactory.create(componentDescriptor);
+          // TODO(b/72748365): Do subgraph validation.
+          generateComponent(bindingGraph);
+        } catch (TypeNotPresentException e) {
+          rejectedElements.add(subcomponentTypeElement);
+        }
+      }
+    }
+
     return rejectedElements.build();
   }
 
   private boolean isValid(BindingGraph bindingGraph) {
-    ValidationReport<TypeElement> graphReport = bindingGraphValidator.validate(bindingGraph);
-    graphReport.printMessagesTo(messager);
-
     dagger.model.BindingGraph modelGraph = bindingGraphConverter.convert(bindingGraph);
-    if (validationPlugins.visitGraph(modelGraph).contains(ERROR) || !graphReport.isClean()) {
-      return false;
-    }
-    return !spiPlugins.visitGraph(modelGraph).contains(ERROR);
+    return !validationPlugins.pluginsReportErrors(modelGraph)
+        && !spiPlugins.pluginsReportErrors(modelGraph);
   }
 
   private void generateComponent(BindingGraph bindingGraph) {
@@ -221,15 +234,27 @@ private boolean isClean(
       return false;
     }
     for (Element element : report.referencedSubcomponents()) {
-      ValidationReport<?> subcomponentBuilderReport = builderReportsBySubcomponent.get(element);
-      if (subcomponentBuilderReport != null && !subcomponentBuilderReport.isClean()) {
-        return false;
-      }
-      ValidationReport<?> subcomponentReport = reportsBySubcomponent.get(element);
-      if (subcomponentReport != null && !subcomponentReport.isClean()) {
+      if (!subcomponentIsClean(element, reportsBySubcomponent, builderReportsBySubcomponent)) {
         return false;
       }
     }
     return true;
   }
+
+  /** Returns true if the reports associated with the subcomponent are clean. */
+  private boolean subcomponentIsClean(
+      Element subcomponentElement,
+      Map<Element, ValidationReport<TypeElement>> reportsBySubcomponent,
+      Map<Element, ValidationReport<TypeElement>> builderReportsBySubcomponent) {
+    ValidationReport<?> subcomponentBuilderReport =
+        builderReportsBySubcomponent.get(subcomponentElement);
+    if (subcomponentBuilderReport != null && !subcomponentBuilderReport.isClean()) {
+      return false;
+    }
+    ValidationReport<?> subcomponentReport = reportsBySubcomponent.get(subcomponentElement);
+    if (subcomponentReport != null && !subcomponentReport.isClean()) {
+      return false;
+    }
+    return true;
+  }
 }
diff --git a/java/dagger/internal/codegen/ComponentProcessor.java b/java/dagger/internal/codegen/ComponentProcessor.java
index a77509fc5..65e7d0a85 100644
--- a/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/java/dagger/internal/codegen/ComponentProcessor.java
@@ -54,6 +54,7 @@
   @Inject MembersInjectorGenerator membersInjectorGenerator;
   @Inject ImmutableList<ProcessingStep> processingSteps;
   @Inject BindingGraphPlugins spiPlugins;
+  @Inject CompilerOptions compilerOptions;
   @Inject @Validation BindingGraphPlugins validationPlugins;
 
   public ComponentProcessor() {
@@ -93,6 +94,9 @@ public SourceVersion getSupportedSourceVersion() {
     options.addAll(CompilerOptions.SUPPORTED_OPTIONS);
     options.addAll(spiPlugins.allSupportedOptions());
     options.addAll(validationPlugins.allSupportedOptions());
+    if (compilerOptions.useGradleIncrementalProcessing()) {
+      options.add("org.gradle.annotation.processing.isolating");
+    }
     return options.build();
   }
 
@@ -116,6 +120,7 @@ public SourceVersion getSupportedSourceVersion() {
         BindingGraphPluginsModule.class,
         BindingGraphValidationModule.class,
         BindingMethodValidatorsModule.class,
+        IncorrectlyInstalledBindsMethodsValidator.Module.class,
         ProcessingStepsModule.class,
       })
   interface ProcessorComponent {
@@ -166,6 +171,8 @@ Builder testingPlugins(
           bindsInstanceProcessingStep,
           moduleProcessingStep,
           compilerOptions.headerCompilation()
+                  // TODO(b/72748365): Support hjars for ahead-of-time subcomponents.
+                  && !compilerOptions.aheadOfTimeSubcomponents()
               ? componentHjarProcessingStep
               : componentProcessingStep,
           bindingMethodProcessingStep);
diff --git a/java/dagger/internal/codegen/ComponentRequirementFields.java b/java/dagger/internal/codegen/ComponentRequirementFields.java
index f38fbdaec..cef581b07 100644
--- a/java/dagger/internal/codegen/ComponentRequirementFields.java
+++ b/java/dagger/internal/codegen/ComponentRequirementFields.java
@@ -47,33 +47,33 @@
       new HashMap<>();
   private final BindingGraph graph;
   private final GeneratedComponentModel generatedComponentModel;
-  private final Optional<ComponentBuilder> componentBuilder;
+  private final Optional<GeneratedComponentBuilderModel> generatedComponentBuilderModel;
 
   private ComponentRequirementFields(
       Optional<ComponentRequirementFields> parent,
       BindingGraph graph,
       GeneratedComponentModel generatedComponentModel,
-      Optional<ComponentBuilder> componentBuilder) {
+      Optional<GeneratedComponentBuilderModel> generatedComponentBuilderModel) {
     this.parent = parent;
     this.graph = graph;
     this.generatedComponentModel = generatedComponentModel;
-    this.componentBuilder = componentBuilder;
+    this.generatedComponentBuilderModel = generatedComponentBuilderModel;
   }
 
   ComponentRequirementFields(
       BindingGraph graph,
       GeneratedComponentModel generatedComponentModel,
-      Optional<ComponentBuilder> componentBuilder) {
-    this(Optional.empty(), graph, generatedComponentModel, componentBuilder);
+      Optional<GeneratedComponentBuilderModel> generatedComponentBuilderModel) {
+    this(Optional.empty(), graph, generatedComponentModel, generatedComponentBuilderModel);
   }
 
   /** Returns a new object representing the fields available from a child component of this one. */
   ComponentRequirementFields forChildComponent(
       BindingGraph graph,
       GeneratedComponentModel generatedComponentModel,
-      Optional<ComponentBuilder> componentBuilder) {
+      Optional<GeneratedComponentBuilderModel> generatedComponentBuilderModel) {
     return new ComponentRequirementFields(
-        Optional.of(this), graph, generatedComponentModel, componentBuilder);
+        Optional.of(this), graph, generatedComponentModel, generatedComponentBuilderModel);
   }
 
   /**
@@ -110,10 +110,12 @@ ComponentRequirementField getField(ComponentRequirement componentRequirement) {
 
   /** Returns a {@link ComponentRequirementField} for a {@link ComponentRequirement}. */
   private ComponentRequirementField create(ComponentRequirement requirement) {
-    if (componentBuilder.isPresent()) {
-      FieldSpec builderField = componentBuilder.get().builderFields().get(requirement);
+    if (generatedComponentBuilderModel.isPresent()) {
+      FieldSpec builderField =
+          generatedComponentBuilderModel.get().builderFields().get(requirement);
       return new BuilderField(requirement, generatedComponentModel, builderField);
-    } else if (graph.factoryMethodParameters().containsKey(requirement)) {
+    } else if (graph.factoryMethod().isPresent()
+        && graph.factoryMethodParameters().containsKey(requirement)) {
       ParameterSpec factoryParameter =
           ParameterSpec.get(graph.factoryMethodParameters().get(requirement));
       return new ComponentParameterField(requirement, generatedComponentModel, factoryParameter);
diff --git a/java/dagger/internal/codegen/ComponentTreeTraverser.java b/java/dagger/internal/codegen/ComponentTreeTraverser.java
index 778c651e9..7f99bf1d6 100644
--- a/java/dagger/internal/codegen/ComponentTreeTraverser.java
+++ b/java/dagger/internal/codegen/ComponentTreeTraverser.java
@@ -25,6 +25,7 @@
 import static com.google.common.collect.Iterables.indexOf;
 import static com.google.common.collect.Iterables.skip;
 import static com.google.common.collect.Multimaps.asMap;
+import static dagger.internal.codegen.BindingRequest.bindingRequest;
 import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
 import static java.util.Spliterator.ORDERED;
 import static java.util.Spliterator.SIZED;
@@ -74,9 +75,10 @@
   private final Deque<BindingGraph> bindingGraphPath = new ArrayDeque<>();
 
   /** Constructs a traverser for a root (component, not subcomponent) binding graph. */
-  public ComponentTreeTraverser(BindingGraph rootGraph) {
+  public ComponentTreeTraverser(BindingGraph rootGraph, CompilerOptions compilerOptions) {
     checkArgument(
-        rootGraph.componentDescriptor().kind().isTopLevel(),
+        rootGraph.componentDescriptor().kind().isTopLevel()
+            || compilerOptions.aheadOfTimeSubcomponents(),
         "only top-level graphs can be traversed, not %s",
         rootGraph.componentDescriptor().componentDefinitionType().getQualifiedName());
     bindingGraphPath.add(rootGraph);
@@ -392,7 +394,7 @@ protected void visitBinding(Binding binding, ComponentDescriptor owningComponent
     private void nextDependencyRequest(
         DependencyRequest dependencyRequest, BindingGraph bindingGraph) {
       ResolvedBindings resolvedBindings =
-          bindingGraph.resolvedBindings(dependencyRequest.kind(), dependencyRequest.key());
+          bindingGraph.resolvedBindings(bindingRequest(dependencyRequest));
       dependencyRequestPath.addLast(dependencyRequest);
       resolvedBindingsPath.addLast(resolvedBindings);
       // Don't add the key of a members injection request, as it doesn't participate in cycles
@@ -659,7 +661,7 @@ ComponentPath toComponentPath() {
     }
 
     @Override
-    public String toString() {
+    public final String toString() {
       return graphsInPath()
           .stream()
           .map(BindingGraph::componentType)
diff --git a/java/dagger/internal/codegen/ComponentValidator.java b/java/dagger/internal/codegen/ComponentValidator.java
index 89c8195d9..51adcbe53 100644
--- a/java/dagger/internal/codegen/ComponentValidator.java
+++ b/java/dagger/internal/codegen/ComponentValidator.java
@@ -16,8 +16,12 @@
 
 package dagger.internal.codegen;
 
+import static com.google.auto.common.MoreElements.asType;
 import static com.google.auto.common.MoreElements.getLocalAndInheritedMethods;
+import static com.google.auto.common.MoreTypes.asDeclared;
 import static com.google.auto.common.MoreTypes.asExecutable;
+import static com.google.common.base.Verify.verify;
+import static com.google.common.collect.Multimaps.asMap;
 import static dagger.internal.codegen.ConfigurationAnnotations.enclosedBuilders;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentModules;
@@ -25,15 +29,19 @@
 import static dagger.internal.codegen.ConfigurationAnnotations.getTransitiveModules;
 import static dagger.internal.codegen.DaggerElements.getAnnotationMirror;
 import static dagger.internal.codegen.DaggerElements.getAnyAnnotation;
+import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
+import static java.util.Comparator.comparing;
 import static javax.lang.model.element.ElementKind.CLASS;
 import static javax.lang.model.element.ElementKind.INTERFACE;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.type.TypeKind.VOID;
+import static javax.lang.model.util.ElementFilter.methodsIn;
 
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
 import com.google.common.collect.FluentIterable;
+import com.google.common.collect.HashMultimap;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
@@ -44,8 +52,11 @@
 import dagger.Component;
 import dagger.Reusable;
 import dagger.internal.codegen.ComponentDescriptor.Kind;
+import dagger.model.DependencyRequest;
+import dagger.model.Key;
 import dagger.producers.ProductionComponent;
 import java.lang.annotation.Annotation;
+import java.util.Collection;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Optional;
@@ -71,17 +82,29 @@
   private final Types types;
   private final ModuleValidator moduleValidator;
   private final BuilderValidator builderValidator;
+  private final DependencyRequestValidator dependencyRequestValidator;
+  private final MembersInjectionValidator membersInjectionValidator;
+  private final MethodSignatureFormatter methodSignatureFormatter;
+  private final DependencyRequestFactory dependencyRequestFactory;
 
   @Inject
   ComponentValidator(
       DaggerElements elements,
       Types types,
       ModuleValidator moduleValidator,
-      BuilderValidator builderValidator) {
+      BuilderValidator builderValidator,
+      DependencyRequestValidator dependencyRequestValidator,
+      MembersInjectionValidator membersInjectionValidator,
+      MethodSignatureFormatter methodSignatureFormatter,
+      DependencyRequestFactory dependencyRequestFactory) {
     this.elements = elements;
     this.types = types;
     this.moduleValidator = moduleValidator;
     this.builderValidator = builderValidator;
+    this.dependencyRequestValidator = dependencyRequestValidator;
+    this.membersInjectionValidator = membersInjectionValidator;
+    this.methodSignatureFormatter = methodSignatureFormatter;
+    this.dependencyRequestFactory = dependencyRequestFactory;
   }
 
   @AutoValue
@@ -99,14 +122,14 @@ public ComponentValidationReport validate(
       final TypeElement subject,
       Set<? extends Element> validatedSubcomponents,
       Set<? extends Element> validatedSubcomponentBuilders) {
-    ValidationReport.Builder<TypeElement> builder = ValidationReport.about(subject);
+    ValidationReport.Builder<TypeElement> report = ValidationReport.about(subject);
 
     ComponentDescriptor.Kind componentKind =
         ComponentDescriptor.Kind.forAnnotatedElement(subject).get();
 
     if (!subject.getKind().equals(INTERFACE)
         && !(subject.getKind().equals(CLASS) && subject.getModifiers().contains(ABSTRACT))) {
-      builder.addError(
+      report.addError(
           String.format(
               "@%s may only be applied to an interface or abstract class",
               componentKind.annotationType().getSimpleName()),
@@ -116,14 +139,14 @@ public ComponentValidationReport validate(
     ImmutableList<DeclaredType> builders =
         enclosedBuilders(subject, componentKind.builderAnnotationType());
     if (builders.size() > 1) {
-      builder.addError(
+      report.addError(
           String.format(ErrorMessages.builderMsgsFor(componentKind).moreThanOne(), builders),
           subject);
     }
 
     Optional<AnnotationMirror> reusableAnnotation = getAnnotationMirror(subject, Reusable.class);
     if (reusableAnnotation.isPresent()) {
-      builder.addError(
+      report.addError(
           "@Reusable cannot be applied to components or subcomponents",
           subject,
           reusableAnnotation.get());
@@ -132,8 +155,7 @@ public ComponentValidationReport validate(
     DeclaredType subjectType = MoreTypes.asDeclared(subject.asType());
 
     SetMultimap<Element, ExecutableElement> referencedSubcomponents = LinkedHashMultimap.create();
-    getLocalAndInheritedMethods(subject, types, elements)
-        .stream()
+    getLocalAndInheritedMethods(subject, types, elements).stream()
         .filter(method -> method.getModifiers().contains(ABSTRACT))
         .forEachOrdered(
             method -> {
@@ -143,7 +165,7 @@ public ComponentValidationReport validate(
               TypeMirror returnType = resolvedMethod.getReturnType();
 
               if (!resolvedMethod.getTypeVariables().isEmpty()) {
-                builder.addError("Component methods cannot have type variables", method);
+                report.addError("Component methods cannot have type variables", method);
               }
 
               // abstract methods are ones we have to implement, so they each need to be validated
@@ -163,7 +185,7 @@ public ComponentValidationReport validate(
               if (subcomponentAnnotation.isPresent()) {
                 referencedSubcomponents.put(MoreTypes.asElement(returnType), method);
                 validateSubcomponentMethod(
-                    builder,
+                    report,
                     ComponentDescriptor.Kind.forAnnotatedElement(
                             MoreTypes.asTypeElement(returnType))
                         .get(),
@@ -176,27 +198,31 @@ public ComponentValidationReport validate(
                 referencedSubcomponents.put(
                     MoreTypes.asElement(returnType).getEnclosingElement(), method);
                 validateSubcomponentBuilderMethod(
-                    builder, method, parameters, returnType, validatedSubcomponentBuilders);
+                    report, method, parameters, returnType, validatedSubcomponentBuilders);
               } else {
                 // if it's not a subcomponent...
                 switch (parameters.size()) {
                   case 0:
                     // no parameters means that it is a provision method
-                    // basically, there are no restrictions here.  \o/
+                    dependencyRequestValidator.validateDependencyRequest(
+                        report, method, returnType);
                     break;
                   case 1:
                     // one parameter means that it's a members injection method
-                    TypeMirror onlyParameter = Iterables.getOnlyElement(parameterTypes);
+                    TypeMirror parameterType = Iterables.getOnlyElement(parameterTypes);
+                    report.addSubreport(
+                        membersInjectionValidator.validateMembersInjectionMethod(
+                            method, parameterType));
                     if (!(returnType.getKind().equals(VOID)
-                        || types.isSameType(returnType, onlyParameter))) {
-                      builder.addError(
+                        || types.isSameType(returnType, parameterType))) {
+                      report.addError(
                           "Members injection methods may only return the injected type or void.",
                           method);
                     }
                     break;
                   default:
                     // this isn't any method that we know how to implement...
-                    builder.addError(
+                    report.addError(
                         "This method isn't a valid provision method, members injection method or "
                             + "subcomponent factory method. Dagger cannot implement this method",
                         method);
@@ -205,10 +231,12 @@ public ComponentValidationReport validate(
               }
             });
 
+    checkConflictingEntryPoints(report);
+
     Maps.filterValues(referencedSubcomponents.asMap(), methods -> methods.size() > 1)
         .forEach(
             (subcomponent, methods) ->
-                builder.addError(
+                report.addError(
                     String.format(
                         ErrorMessages.SubcomponentBuilderMessages.INSTANCE
                             .moreThanOneRefToSubcomponent(),
@@ -219,9 +247,9 @@ public ComponentValidationReport validate(
     AnnotationMirror componentMirror =
         getAnnotationMirror(subject, componentKind.annotationType()).get();
     if (componentKind.isTopLevel()) {
-      validateComponentDependencies(builder, getComponentDependencies(componentMirror));
+      validateComponentDependencies(report, getComponentDependencies(componentMirror));
     }
-    builder.addSubreport(
+    report.addSubreport(
         moduleValidator.validateReferencedModules(
             subject, componentMirror, componentKind.moduleKinds(), new HashSet<>()));
 
@@ -235,20 +263,99 @@ public ComponentValidationReport validate(
     for (Element subcomponent :
         Sets.difference(referencedSubcomponents.keySet(), validatedSubcomponents)) {
       ComponentValidationReport subreport =
-          validate(
-              MoreElements.asType(subcomponent),
-              validatedSubcomponents,
-              validatedSubcomponentBuilders);
-      builder.addItems(subreport.report().items());
+          validate(asType(subcomponent), validatedSubcomponents, validatedSubcomponentBuilders);
+      report.addItems(subreport.report().items());
       allSubcomponents.addAll(subreport.referencedSubcomponents());
     }
 
     return new AutoValue_ComponentValidator_ComponentValidationReport(
-        allSubcomponents.build(), builder.build());
+        allSubcomponents.build(), report.build());
+  }
+
+  private void checkConflictingEntryPoints(ValidationReport.Builder<TypeElement> report) {
+    DeclaredType componentType = asDeclared(report.getSubject().asType());
+
+    // Collect entry point methods that are not overridden by others. If the "same" method is
+    // inherited from more than one supertype, each will be in the multimap.
+    SetMultimap<String, ExecutableElement> entryPointMethods = HashMultimap.create();
+
+    methodsIn(elements.getAllMembers(report.getSubject()))
+        .stream()
+        .filter(
+            method -> isEntryPoint(method, asExecutable(types.asMemberOf(componentType, method))))
+        .forEach(
+            method ->
+                addMethodUnlessOverridden(
+                    method, entryPointMethods.get(method.getSimpleName().toString())));
+
+    for (Set<ExecutableElement> methods : asMap(entryPointMethods).values()) {
+      if (distinctKeys(methods, report.getSubject()).size() > 1) {
+        reportConflictingEntryPoints(methods, report);
+      }
+    }
+  }
+
+  private boolean isEntryPoint(ExecutableElement method, ExecutableType methodType) {
+    return method.getModifiers().contains(ABSTRACT)
+        && method.getParameters().isEmpty()
+        && !methodType.getReturnType().getKind().equals(VOID)
+        && methodType.getTypeVariables().isEmpty();
+  }
+
+  private ImmutableSet<Key> distinctKeys(Set<ExecutableElement> methods, TypeElement component) {
+    return methods
+        .stream()
+        .map(method -> dependencyRequest(method, component))
+        .map(DependencyRequest::key)
+        .collect(toImmutableSet());
+  }
+
+  private DependencyRequest dependencyRequest(ExecutableElement method, TypeElement component) {
+    ExecutableType methodType =
+        asExecutable(types.asMemberOf(asDeclared(component.asType()), method));
+    return ComponentDescriptor.Kind.forAnnotatedElement(component).get().isProducer()
+        ? dependencyRequestFactory.forComponentProductionMethod(method, methodType)
+        : dependencyRequestFactory.forComponentProvisionMethod(method, methodType);
+  }
+
+  private void addMethodUnlessOverridden(ExecutableElement method, Set<ExecutableElement> methods) {
+    if (methods.stream().noneMatch(existingMethod -> overridesAsDeclared(existingMethod, method))) {
+      methods.removeIf(existingMethod -> overridesAsDeclared(method, existingMethod));
+      methods.add(method);
+    }
+  }
+
+  /**
+   * Returns {@code true} if {@code overrider} overrides {@code overridden} considered from within
+   * the type that declares {@code overrider}.
+   */
+  // TODO(dpb): Does this break for ECJ?
+  private boolean overridesAsDeclared(ExecutableElement overridder, ExecutableElement overridden) {
+    return elements.overrides(overridder, overridden, asType(overridder.getEnclosingElement()));
+  }
+
+  private void reportConflictingEntryPoints(
+      Collection<ExecutableElement> methods, ValidationReport.Builder<TypeElement> report) {
+    verify(
+        methods.stream().map(ExecutableElement::getEnclosingElement).distinct().count()
+            == methods.size(),
+        "expected each method to be declared on a different type: %s",
+        methods);
+    StringBuilder message = new StringBuilder("conflicting entry point declarations:");
+    methodSignatureFormatter
+        .typedFormatter(asDeclared(report.getSubject().asType()))
+        .formatIndentedList(
+            message,
+            ImmutableList.sortedCopyOf(
+                comparing(
+                    method -> asType(method.getEnclosingElement()).getQualifiedName().toString()),
+                methods),
+            1);
+    report.addError(message.toString());
   }
 
   private void validateSubcomponentMethod(
-      final ValidationReport.Builder<TypeElement> builder,
+      final ValidationReport.Builder<TypeElement> report,
       final ComponentDescriptor.Kind subcomponentKind,
       ExecutableElement method,
       List<? extends VariableElement> parameters,
@@ -292,7 +399,7 @@ private void validateSubcomponentMethod(
               null);
       if (moduleType.isPresent()) {
         if (variableTypes.contains(moduleType.get())) {
-          builder.addError(
+          report.addError(
               String.format(
                   "A module may only occur once an an argument in a Subcomponent factory "
                       + "method, but %s was already passed.",
@@ -300,7 +407,7 @@ private void validateSubcomponentMethod(
               parameter);
         }
         if (!transitiveModules.contains(moduleType.get())) {
-          builder.addError(
+          report.addError(
               String.format(
                   "%s is present as an argument to the %s factory method, but is not one of the"
                       + " modules used to implement the subcomponent.",
@@ -310,7 +417,7 @@ private void validateSubcomponentMethod(
         }
         variableTypes.add(moduleType.get());
       } else {
-        builder.addError(
+        report.addError(
             String.format(
                 "Subcomponent factory methods may only accept modules, but %s is not.",
                 parameterType),
@@ -320,14 +427,14 @@ private void validateSubcomponentMethod(
   }
 
   private void validateSubcomponentBuilderMethod(
-      ValidationReport.Builder<TypeElement> builder,
+      ValidationReport.Builder<TypeElement> report,
       ExecutableElement method,
       List<? extends VariableElement> parameters,
       TypeMirror returnType,
       Set<? extends Element> validatedSubcomponentBuilders) {
 
     if (!parameters.isEmpty()) {
-      builder.addError(
+      report.addError(
           ErrorMessages.SubcomponentBuilderMessages.INSTANCE.builderMethodRequiresNoArgs(), method);
     }
 
@@ -337,7 +444,7 @@ private void validateSubcomponentBuilderMethod(
       // TODO(sameb): The builder validator right now assumes the element is being compiled
       // in this pass, which isn't true here.  We should change error messages to spit out
       // this method as the subject and add the original subject to the message output.
-      builder.addItems(builderValidator.validate(builderElement).items());
+      report.addItems(builderValidator.validate(builderElement).items());
     }
   }
 
diff --git a/java/dagger/internal/codegen/ComponentWriter.java b/java/dagger/internal/codegen/ComponentWriter.java
deleted file mode 100644
index dbeea6565..000000000
--- a/java/dagger/internal/codegen/ComponentWriter.java
+++ /dev/null
@@ -1,403 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal.codegen;
-
-import static com.google.auto.common.MoreElements.getLocalAndInheritedMethods;
-import static com.google.auto.common.MoreTypes.asDeclared;
-import static com.google.common.base.Preconditions.checkState;
-import static com.squareup.javapoet.MethodSpec.constructorBuilder;
-import static com.squareup.javapoet.MethodSpec.methodBuilder;
-import static dagger.internal.codegen.AnnotationSpecs.Suppression.UNCHECKED;
-import static dagger.internal.codegen.CodeBlocks.toParametersCodeBlock;
-import static dagger.internal.codegen.DaggerStreams.toImmutableList;
-import static dagger.internal.codegen.GeneratedComponentModel.MethodSpecKind.BUILDER_METHOD;
-import static dagger.internal.codegen.GeneratedComponentModel.MethodSpecKind.COMPONENT_METHOD;
-import static dagger.internal.codegen.GeneratedComponentModel.MethodSpecKind.CONSTRUCTOR;
-import static dagger.internal.codegen.GeneratedComponentModel.MethodSpecKind.INITIALIZE_METHOD;
-import static dagger.internal.codegen.GeneratedComponentModel.TypeSpecKind.COMPONENT_BUILDER;
-import static dagger.internal.codegen.GeneratedComponentModel.TypeSpecKind.SUBCOMPONENT;
-import static javax.lang.model.element.Modifier.FINAL;
-import static javax.lang.model.element.Modifier.PRIVATE;
-import static javax.lang.model.element.Modifier.PUBLIC;
-import static javax.lang.model.element.Modifier.STATIC;
-
-import com.google.auto.common.MoreTypes;
-import com.google.common.collect.ImmutableList;
-import com.google.common.collect.ImmutableListMultimap;
-import com.google.common.collect.Iterables;
-import com.google.common.collect.Lists;
-import com.google.common.collect.Multimaps;
-import com.squareup.javapoet.ClassName;
-import com.squareup.javapoet.CodeBlock;
-import com.squareup.javapoet.MethodSpec;
-import com.squareup.javapoet.ParameterSpec;
-import com.squareup.javapoet.TypeSpec;
-import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
-import java.util.List;
-import java.util.Optional;
-import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.type.DeclaredType;
-import javax.lang.model.util.Elements;
-
-/** Creates the implementation class for a component or subcomponent. */
-abstract class ComponentWriter {
-  static TypeSpec.Builder writeComponent(
-      DaggerTypes types,
-      DaggerElements elements,
-      KeyFactory keyFactory,
-      CompilerOptions compilerOptions,
-      ClassName name,
-      BindingGraph graph) {
-    GeneratedComponentModel generatedComponentModel = GeneratedComponentModel.forComponent(name);
-    SubcomponentNames subcomponentNames = new SubcomponentNames(graph, keyFactory);
-    OptionalFactories optionalFactories = new OptionalFactories(generatedComponentModel);
-    Optional<ComponentBuilder> builder =
-        ComponentBuilder.create(name, graph, subcomponentNames, elements, types);
-    ComponentRequirementFields componentRequirementFields =
-        new ComponentRequirementFields(graph, generatedComponentModel, builder);
-    ComponentBindingExpressions bindingExpressions =
-        new ComponentBindingExpressions(
-            graph,
-            generatedComponentModel,
-            subcomponentNames,
-            componentRequirementFields,
-            optionalFactories,
-            types,
-            elements,
-            compilerOptions);
-    return new RootComponentWriter(
-            types,
-            elements,
-            graph,
-            generatedComponentModel,
-            subcomponentNames,
-            optionalFactories,
-            bindingExpressions,
-            componentRequirementFields,
-            builder)
-        .write();
-  }
-
-  private static TypeSpec writeSubcomponent(ComponentWriter parent, BindingGraph childGraph) {
-    ClassName parentName = parent.generatedComponentModel.name();
-    ClassName childName =
-        parentName.nestedClass(
-            parent.subcomponentNames.get(childGraph.componentDescriptor()) + "Impl");
-    GeneratedComponentModel childGeneratedComponentModel =
-        GeneratedComponentModel.forSubcomponent(childName);
-    Optional<ComponentBuilder> childBuilder =
-        ComponentBuilder.create(
-            childName, childGraph, parent.subcomponentNames, parent.elements, parent.types);
-    ComponentRequirementFields childComponentRequirementFields =
-        parent.componentRequirementFields.forChildComponent(
-            childGraph, childGeneratedComponentModel, childBuilder);
-    ComponentBindingExpressions childBindingExpressions =
-        parent.bindingExpressions.forChildComponent(
-            childGraph, childGeneratedComponentModel, childComponentRequirementFields);
-    return new SubcomponentWriter(
-            parent,
-            childGraph,
-            childGeneratedComponentModel,
-            childBindingExpressions,
-            childComponentRequirementFields,
-            childBuilder)
-        .write()
-        .build();
-  }
-
-  private final Elements elements;
-  private final DaggerTypes types;
-  private final BindingGraph graph;
-  private final SubcomponentNames subcomponentNames;
-  private final ComponentBindingExpressions bindingExpressions;
-  private final ComponentRequirementFields componentRequirementFields;
-  private final GeneratedComponentModel generatedComponentModel;
-  private final OptionalFactories optionalFactories;
-  private final Optional<ComponentBuilder> builder;
-  private boolean done;
-
-  private ComponentWriter(
-      DaggerTypes types,
-      Elements elements,
-      BindingGraph graph,
-      GeneratedComponentModel generatedComponentModel,
-      SubcomponentNames subcomponentNames,
-      OptionalFactories optionalFactories,
-      ComponentBindingExpressions bindingExpressions,
-      ComponentRequirementFields componentRequirementFields,
-      Optional<ComponentBuilder> builder) {
-    this.types = types;
-    this.elements = elements;
-    this.graph = graph;
-    this.subcomponentNames = subcomponentNames;
-    this.generatedComponentModel = generatedComponentModel;
-    this.optionalFactories = optionalFactories;
-    this.bindingExpressions = bindingExpressions;
-    this.componentRequirementFields = componentRequirementFields;
-    this.builder = builder;
-  }
-
-  /**
-   * Constructs a {@link TypeSpec.Builder} that models the {@link BindingGraph} for this component.
-   * This is only intended to be called once (and will throw on successive invocations). If the
-   * component must be regenerated, use a new instance.
-   */
-  protected final TypeSpec.Builder write() {
-    checkState(!done, "ComponentWriter has already been generated.");
-    generatedComponentModel.addSupertype(graph.componentType());
-    builder.map(ComponentBuilder::typeSpec).ifPresent(this::addBuilderClass);
-
-    getLocalAndInheritedMethods(
-            graph.componentDescriptor().componentDefinitionType(), types, elements)
-        .forEach(method -> generatedComponentModel.claimMethodName(method.getSimpleName()));
-
-    addFactoryMethods();
-    addInterfaceMethods();
-    addSubcomponents();
-    addConstructor();
-
-    done = true;
-    return generatedComponentModel.generate();
-  }
-
-  /**
-   * Adds {@code builder} as a nested builder class. Root components and subcomponents will nest
-   * this in different classes.
-   */
-  protected abstract void addBuilderClass(TypeSpec builder);
-
-  /** Adds component factory methods. */
-  protected abstract void addFactoryMethods();
-
-  private void addInterfaceMethods() {
-    /* Each component method may have been declared by several supertypes. We want to implement only
-     * one method for each distinct signature.*/
-    ImmutableListMultimap<MethodSignature, ComponentMethodDescriptor> componentMethodsBySignature =
-        Multimaps.index(graph.componentDescriptor().entryPointMethods(), this::getMethodSignature);
-    for (List<ComponentMethodDescriptor> methodsWithSameSignature :
-        Multimaps.asMap(componentMethodsBySignature).values()) {
-      ComponentMethodDescriptor anyOneMethod = methodsWithSameSignature.stream().findAny().get();
-      generatedComponentModel.addMethod(
-          COMPONENT_METHOD, bindingExpressions.getComponentMethod(anyOneMethod));
-    }
-  }
-
-  private MethodSignature getMethodSignature(ComponentMethodDescriptor method) {
-    return MethodSignature.forComponentMethod(
-        method, MoreTypes.asDeclared(graph.componentType().asType()), types);
-  }
-
-  private void addSubcomponents() {
-    for (BindingGraph subgraph : graph.subgraphs()) {
-      generatedComponentModel.addType(SUBCOMPONENT, writeSubcomponent(this, subgraph));
-    }
-  }
-
-  private static final int INITIALIZATIONS_PER_INITIALIZE_METHOD = 100;
-
-  private void addConstructor() {
-    List<List<CodeBlock>> partitions =
-        Lists.partition(
-            generatedComponentModel.getInitializations(), INITIALIZATIONS_PER_INITIALIZE_METHOD);
-
-    ImmutableList<ParameterSpec> constructorParameters = constructorParameters();
-    MethodSpec.Builder constructor =
-        constructorBuilder().addModifiers(PRIVATE).addParameters(constructorParameters);
-
-    ImmutableList<ParameterSpec> initializeParameters = initializeParameters();
-    CodeBlock initializeParametersCodeBlock =
-        constructorParameters
-            .stream()
-            .map(param -> CodeBlock.of("$N", param))
-            .collect(toParametersCodeBlock());
-
-    UniqueNameSet methodNames = new UniqueNameSet();
-    for (List<CodeBlock> partition : partitions) {
-      String methodName = methodNames.getUniqueName("initialize");
-      MethodSpec.Builder initializeMethod =
-          methodBuilder(methodName)
-              .addModifiers(PRIVATE)
-              /* TODO(gak): Strictly speaking, we only need the suppression here if we are also
-               * initializing a raw field in this method, but the structure of this code makes it
-               * awkward to pass that bit through.  This will be cleaned up when we no longer
-               * separate fields and initilization as we do now. */
-              .addAnnotation(AnnotationSpecs.suppressWarnings(UNCHECKED))
-              .addCode(CodeBlocks.concat(partition));
-      initializeMethod.addParameters(initializeParameters);
-      constructor.addStatement("$L($L)", methodName, initializeParametersCodeBlock);
-      generatedComponentModel.addMethod(INITIALIZE_METHOD, initializeMethod.build());
-    }
-    generatedComponentModel.addMethod(CONSTRUCTOR, constructor.build());
-  }
-
-  /** Returns the list of {@link ParameterSpec}s for the initialze methods. */
-  private ImmutableList<ParameterSpec> initializeParameters() {
-    return constructorParameters()
-        .stream()
-        .map(param -> param.toBuilder().addModifiers(FINAL).build())
-        .collect(toImmutableList());
-  }
-
-  /** Returns the list of {@link ParameterSpec}s for the constructor. */
-  private ImmutableList<ParameterSpec> constructorParameters() {
-    if (builder.isPresent()) {
-      return ImmutableList.of(ParameterSpec.builder(builder.get().name(), "builder").build());
-    } else if (graph.factoryMethod().isPresent()) {
-      return getFactoryMethodParameterSpecs(graph);
-    } else {
-      throw new AssertionError(
-          "Expected either a component builder or factory method but found neither.");
-    }
-  }
-
-  /**
-   * Creates the implementation class for the root component.
-   */
-  private static final class RootComponentWriter extends ComponentWriter {
-    RootComponentWriter(
-        DaggerTypes types,
-        Elements elements,
-        BindingGraph graph,
-        GeneratedComponentModel generatedComponentModel,
-        SubcomponentNames subcomponentNames,
-        OptionalFactories optionalFactories,
-        ComponentBindingExpressions bindingExpressions,
-        ComponentRequirementFields componentRequirementFields,
-        Optional<ComponentBuilder> builder) {
-      super(
-          types,
-          elements,
-          graph,
-          generatedComponentModel,
-          subcomponentNames,
-          optionalFactories,
-          bindingExpressions,
-          componentRequirementFields,
-          builder);
-    }
-
-    @Override
-    protected void addBuilderClass(TypeSpec builder) {
-      super.generatedComponentModel.addType(COMPONENT_BUILDER, builder);
-    }
-
-    @Override
-    protected void addFactoryMethods() {
-      // Only top-level components have the factory builder() method.
-      // Mirror the user's builder API type if they had one.
-      MethodSpec builderFactoryMethod =
-          methodBuilder("builder")
-              .addModifiers(PUBLIC, STATIC)
-              .returns(
-                  builderSpec().isPresent()
-                      ? ClassName.get(builderSpec().get().builderDefinitionType())
-                      : super.builder.get().name())
-              .addStatement("return new $T()", super.builder.get().name())
-              .build();
-      super.generatedComponentModel.addMethod(BUILDER_METHOD, builderFactoryMethod);
-      if (canInstantiateAllRequirements()) {
-        CharSequence buildMethodName =
-            builderSpec().isPresent() ? builderSpec().get().buildMethod().getSimpleName() : "build";
-        super.generatedComponentModel.addMethod(
-            BUILDER_METHOD,
-            methodBuilder("create")
-                .returns(ClassName.get(super.graph.componentType()))
-                .addModifiers(PUBLIC, STATIC)
-                .addStatement("return new Builder().$L()", buildMethodName)
-                .build());
-      }
-    }
-
-    private Optional<ComponentDescriptor.BuilderSpec> builderSpec() {
-      return super.graph.componentDescriptor().builderSpec();
-    }
-
-    /** {@code true} if all of the graph's required dependencies can be automatically constructed */
-    private boolean canInstantiateAllRequirements() {
-      return !Iterables.any(
-          super.graph.componentRequirements(),
-          dependency -> dependency.requiresAPassedInstance(super.elements, super.types));
-    }
-  }
-
-  /**
-   * Creates the nested implementation class for a subcomponent.
-   */
-  private static final class SubcomponentWriter extends ComponentWriter {
-    private final ComponentWriter parent;
-
-    SubcomponentWriter(
-        ComponentWriter parent,
-        BindingGraph graph,
-        GeneratedComponentModel generatedComponentModel,
-        ComponentBindingExpressions bindingExpressions,
-        ComponentRequirementFields componentRequirementFields,
-        Optional<ComponentBuilder> builder) {
-      super(
-          parent.types,
-          parent.elements,
-          graph,
-          generatedComponentModel,
-          parent.subcomponentNames,
-          parent.optionalFactories,
-          bindingExpressions,
-          componentRequirementFields,
-          builder);
-      this.parent = parent;
-    }
-
-    @Override
-    protected void addBuilderClass(TypeSpec builder) {
-      parent.generatedComponentModel.addType(SUBCOMPONENT, builder);
-    }
-
-    @Override
-    protected void addFactoryMethods() {
-      // The parent's factory method to create this subcomponent if the
-      // subcomponent was not added via {@link dagger.Module#subcomponents()}.
-      super.graph.factoryMethod().ifPresent(this::createSubcomponentFactoryMethod);
-    }
-
-    private void createSubcomponentFactoryMethod(ExecutableElement factoryMethod) {
-      parent.generatedComponentModel.addMethod(
-          COMPONENT_METHOD,
-          MethodSpec.overriding(factoryMethod, parentType(), super.types)
-              .addStatement(
-                  "return new $T($L)",
-                  super.generatedComponentModel.name(),
-                  getFactoryMethodParameterSpecs(super.graph)
-                      .stream()
-                      .map(param -> CodeBlock.of("$N", param))
-                      .collect(toParametersCodeBlock()))
-              .build());
-    }
-
-    private DeclaredType parentType() {
-      return asDeclared(parent.graph.componentType().asType());
-    }
-  }
-
-  /** Returns the list of {@link ParameterSpec}s for the corresponding graph's factory method. */
-  private static ImmutableList<ParameterSpec> getFactoryMethodParameterSpecs(BindingGraph graph) {
-    return graph
-        .factoryMethodParameters()
-        .values()
-        .stream()
-        .map(ParameterSpec::get)
-        .collect(toImmutableList());
-  }
-}
diff --git a/java/dagger/internal/codegen/ContributionBinding.java b/java/dagger/internal/codegen/ContributionBinding.java
index 9b7685103..9d206eff5 100644
--- a/java/dagger/internal/codegen/ContributionBinding.java
+++ b/java/dagger/internal/codegen/ContributionBinding.java
@@ -143,7 +143,7 @@ FactoryCreationStrategy factoryCreationStrategy() {
   final TypeMirror contributedType() {
     switch (contributionType()) {
       case MAP:
-        return MapType.from(key()).unwrappedValueType(bindingType().frameworkClass());
+        return MapType.from(key()).unwrappedFrameworkValueType();
       case SET:
         return SetType.from(key()).elementType();
       case SET_VALUES:
@@ -164,6 +164,17 @@ final boolean isSyntheticMultibinding() {
     }
   }
 
+  /** Whether the bound type has a generated implementation. */
+  final boolean requiresGeneratedInstance() {
+    switch (kind()) {
+      case COMPONENT:
+      case SUBCOMPONENT_BUILDER:
+        return true;
+      default:
+        return false;
+    }
+  }
+
   /**
    * Returns {@link BindingKind#MULTIBOUND_SET} or {@link
    * BindingKind#MULTIBOUND_MAP} if the key is a set or map.
diff --git a/java/dagger/internal/codegen/DaggerElements.java b/java/dagger/internal/codegen/DaggerElements.java
index 314c26db7..e9e505213 100644
--- a/java/dagger/internal/codegen/DaggerElements.java
+++ b/java/dagger/internal/codegen/DaggerElements.java
@@ -23,6 +23,7 @@
 import static com.google.common.collect.Lists.asList;
 import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
 import static dagger.internal.codegen.Formatter.formatArgumentInList;
+import static java.util.Comparator.comparing;
 import static java.util.stream.Collectors.joining;
 import static java.util.stream.Collectors.toSet;
 import static javax.lang.model.element.Modifier.ABSTRACT;
@@ -32,10 +33,13 @@
 import com.google.common.annotations.VisibleForTesting;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Iterables;
+import com.google.common.graph.Traverser;
 import dagger.Reusable;
 import java.io.Writer;
 import java.lang.annotation.Annotation;
 import java.util.Collection;
+import java.util.Comparator;
 import java.util.List;
 import java.util.Map;
 import java.util.Optional;
@@ -74,6 +78,17 @@
     this(processingEnv.getElementUtils(), processingEnv.getTypeUtils());
   }
 
+  /**
+   * Returns {@code true} if {@code encloser} is equal to {@code enclosed} or recursively encloses
+   * it.
+   */
+  static boolean elementEncloses(TypeElement encloser, Element enclosed) {
+    return Iterables.contains(GET_ENCLOSED_ELEMENTS.breadthFirst(encloser), enclosed);
+  }
+
+  private static final Traverser<Element> GET_ENCLOSED_ELEMENTS =
+      Traverser.forTree(Element::getEnclosedElements);
+
   ImmutableSet<ExecutableElement> getUnimplementedMethods(TypeElement type) {
     return FluentIterable.from(getLocalAndInheritedMethods(type, types, elements))
         .filter(hasModifiers(ABSTRACT))
@@ -171,6 +186,13 @@ public TypeElement visitType(TypeElement type, Void p) {
         }
       };
 
+  /**
+   * Compares elements according to their declaration order among siblings. Only valid to compare
+   * elements enclosed by the same parent.
+   */
+  static final Comparator<Element> DECLARATION_ORDER =
+      comparing(element -> element.getEnclosingElement().getEnclosedElements().indexOf(element));
+
   /**
    * Returns {@code true} iff the given element has an {@link AnnotationMirror} whose
    * {@linkplain AnnotationMirror#getAnnotationType() annotation type} has the same canonical name
diff --git a/java/dagger/internal/codegen/DaggerGraphs.java b/java/dagger/internal/codegen/DaggerGraphs.java
index 066668fc8..e9f384247 100644
--- a/java/dagger/internal/codegen/DaggerGraphs.java
+++ b/java/dagger/internal/codegen/DaggerGraphs.java
@@ -16,9 +16,14 @@
 
 package dagger.internal.codegen;
 
+import static com.google.common.collect.Sets.difference;
+import static com.google.common.graph.Graphs.reachableNodes;
+
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
+import com.google.common.graph.Graph;
 import com.google.common.graph.SuccessorsFunction;
+import dagger.model.BindingGraph.Node;
 import java.util.ArrayDeque;
 import java.util.HashMap;
 import java.util.Map;
@@ -49,12 +54,11 @@
     }
 
     Map<N, N> visitedNodeToPathPredecessor = new HashMap<>(); // encodes shortest path tree
-    Queue<N> currentNodes = new ArrayDeque<N>();
-    Queue<N> nextNodes = new ArrayDeque<N>();
     for (N node : successors) {
       visitedNodeToPathPredecessor.put(node, nodeU);
     }
-    currentNodes.addAll(successors);
+    Queue<N> currentNodes = new ArrayDeque<N>(successors);
+    Queue<N> nextNodes = new ArrayDeque<N>();
 
     // Perform a breadth-first traversal starting with the successors of nodeU.
     while (!currentNodes.isEmpty()) {
@@ -86,5 +90,10 @@
     return ImmutableList.of();
   }
 
+  /** Returns the nodes in a graph that are not reachable from a node. */
+  static ImmutableSet<Node> unreachableNodes(Graph<Node> graph, Node node) {
+    return ImmutableSet.copyOf(difference(graph.nodes(), reachableNodes(graph, node)));
+  }
+
   private DaggerGraphs() {}
 }
diff --git a/java/dagger/internal/codegen/DaggerKythePlugin.java b/java/dagger/internal/codegen/DaggerKythePlugin.java
index 98d210cc6..df1b16afb 100644
--- a/java/dagger/internal/codegen/DaggerKythePlugin.java
+++ b/java/dagger/internal/codegen/DaggerKythePlugin.java
@@ -19,6 +19,8 @@
 // the regular kythe/java tree.
 package dagger.internal.codegen;
 
+import static dagger.internal.codegen.BindingRequest.bindingRequest;
+
 import com.google.auto.service.AutoService;
 import com.google.common.collect.Iterables;
 import com.google.devtools.kythe.analyzers.base.EntrySet;
@@ -98,7 +100,8 @@ private void addEdgesForDependencyRequest(
     if (!dependency.requestElement().isPresent()) {
       return;
     }
-    ResolvedBindings resolvedBindings = graph.resolvedBindings(dependency.kind(), targetKey);
+    BindingRequest request = bindingRequest(targetKey, dependency.kind());
+    ResolvedBindings resolvedBindings = graph.resolvedBindings(request);
     for (Binding binding : resolvedBindings.bindings()) {
       if (binding.bindingElement().isPresent()) {
         addDependencyEdge(dependency, binding);
@@ -155,6 +158,7 @@ public void run(
       DaggerDaggerKythePlugin_PluginComponent.builder()
           .types(JavacTypes.instance(javaContext))
           .elements(JavacElements.instance(javaContext))
+          .compilerOptions(KytheBindingGraphFactory.createCompilerOptions())
           .build()
           .inject(this);
     }
@@ -168,8 +172,15 @@ public void run(
 
     @Component.Builder
     interface Builder {
-      @BindsInstance Builder types(Types types);
-      @BindsInstance Builder elements(Elements elements);
+      @BindsInstance
+      Builder types(Types types);
+
+      @BindsInstance
+      Builder elements(Elements elements);
+
+      @BindsInstance
+      Builder compilerOptions(CompilerOptions compilerOptions);
+
       PluginComponent build();
     }
   }
diff --git a/java/dagger/internal/codegen/DaggerStreams.java b/java/dagger/internal/codegen/DaggerStreams.java
index 83a4e30d1..ff4c44698 100644
--- a/java/dagger/internal/codegen/DaggerStreams.java
+++ b/java/dagger/internal/codegen/DaggerStreams.java
@@ -25,6 +25,7 @@
 import com.google.common.collect.ImmutableSetMultimap;
 import com.google.common.collect.Maps;
 import java.util.Map;
+import java.util.Optional;
 import java.util.function.Function;
 import java.util.stream.Collector;
 import java.util.stream.Collectors;
@@ -98,5 +99,19 @@
     return f -> to.isInstance(f) ? Stream.of(to.cast(f)) : Stream.empty();
   }
 
+  /**
+   * A function that you can use to extract the present values from a stream of {@link Optional}s.
+   *
+   * <pre>{@code
+   * Set<Foo> foos =
+   *     optionalFoos()
+   *         .flatMap(DaggerStreams.presentValues())
+   *         .collect(toSet());
+   * }</pre>
+   */
+  public static <T> Function<Optional<T>, Stream<T>> presentValues() {
+    return optional -> optional.map(Stream::of).orElse(Stream.empty());
+  }
+
   private DaggerStreams() {}
 }
diff --git a/java/dagger/internal/codegen/DaggerTypes.java b/java/dagger/internal/codegen/DaggerTypes.java
index 40f3b4188..a0f352ff2 100644
--- a/java/dagger/internal/codegen/DaggerTypes.java
+++ b/java/dagger/internal/codegen/DaggerTypes.java
@@ -23,6 +23,7 @@
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.common.collect.ImmutableSet;
+import com.google.common.graph.Traverser;
 import com.google.common.util.concurrent.FluentFuture;
 import com.google.common.util.concurrent.ListenableFuture;
 import com.squareup.javapoet.ClassName;
@@ -65,6 +66,14 @@
     return Optional.ofNullable(MoreTypes.nonObjectSuperclass(types, elements, type).orNull());
   }
 
+  /**
+   * Returns the {@linkplain #directSupertypes(TypeMirror) supertype}s of a type in breadth-first
+   * order.
+   */
+  Iterable<TypeMirror> supertypes(TypeMirror type) {
+    return Traverser.<TypeMirror>forGraph(this::directSupertypes).breadthFirst(type);
+  }
+
   /**
    * Returns {@code type}'s single type argument.
    *
diff --git a/java/dagger/internal/codegen/DelegateBindingExpression.java b/java/dagger/internal/codegen/DelegateBindingExpression.java
index 702b3342f..aaafe6f87 100644
--- a/java/dagger/internal/codegen/DelegateBindingExpression.java
+++ b/java/dagger/internal/codegen/DelegateBindingExpression.java
@@ -20,6 +20,7 @@
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static dagger.internal.codegen.Accessibility.isTypeAccessibleFrom;
+import static dagger.internal.codegen.BindingRequest.bindingRequest;
 import static dagger.internal.codegen.RequestKinds.requestType;
 import static dagger.model.BindingKind.DELEGATE;
 
@@ -71,7 +72,8 @@ static boolean isBindsScopeStrongerThanDependencyScope(
   Expression getDependencyExpression(ClassName requestingClass) {
     Expression delegateExpression =
         componentBindingExpressions.getDependencyExpression(
-            getOnlyElement(binding.dependencies()).key(), requestKind, requestingClass);
+            bindingRequest(getOnlyElement(binding.dependencies()).key(), requestKind),
+            requestingClass);
 
     TypeMirror contributedType = binding.contributedType();
     switch (requestKind) {
diff --git a/java/dagger/internal/codegen/DelegatingFrameworkInstanceCreationExpression.java b/java/dagger/internal/codegen/DelegatingFrameworkInstanceCreationExpression.java
index 09fd1f962..e5f71ee72 100644
--- a/java/dagger/internal/codegen/DelegatingFrameworkInstanceCreationExpression.java
+++ b/java/dagger/internal/codegen/DelegatingFrameworkInstanceCreationExpression.java
@@ -18,6 +18,7 @@
 
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.collect.Iterables.getOnlyElement;
+import static dagger.internal.codegen.BindingRequest.bindingRequest;
 
 import com.squareup.javapoet.CodeBlock;
 import dagger.internal.codegen.FrameworkFieldInitializer.FrameworkInstanceCreationExpression;
@@ -44,8 +45,9 @@ public CodeBlock creationExpression() {
     FrameworkDependency frameworkDependency = getOnlyElement(binding.frameworkDependencies());
     return CodeBlocks.cast(
         componentBindingExpressions
-            .getDependencyExpression(frameworkDependency, generatedComponentModel.name())
+            .getDependencyExpression(
+                bindingRequest(frameworkDependency), generatedComponentModel.name())
             .codeBlock(),
-        binding.bindingType().frameworkClass());
+        frameworkDependency.frameworkClass());
   }
 }
diff --git a/java/dagger/internal/codegen/DependencyCycleValidator.java b/java/dagger/internal/codegen/DependencyCycleValidator.java
new file mode 100644
index 000000000..b5e3b562d
--- /dev/null
+++ b/java/dagger/internal/codegen/DependencyCycleValidator.java
@@ -0,0 +1,307 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.collect.Iterables.getLast;
+import static com.google.common.collect.Iterables.limit;
+import static com.google.common.collect.Iterables.skip;
+import static com.google.common.collect.Sets.newHashSetWithExpectedSize;
+import static dagger.internal.codegen.DaggerGraphs.shortestPath;
+import static dagger.internal.codegen.DaggerStreams.instancesOf;
+import static dagger.internal.codegen.DaggerStreams.toImmutableList;
+import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
+import static dagger.internal.codegen.RequestKinds.extractKeyType;
+import static dagger.internal.codegen.RequestKinds.getRequestKind;
+import static javax.tools.Diagnostic.Kind.ERROR;
+
+import com.google.auto.value.AutoValue;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Iterables;
+import com.google.common.graph.EndpointPair;
+import com.google.common.graph.ImmutableNetwork;
+import com.google.common.graph.MutableNetwork;
+import com.google.common.graph.NetworkBuilder;
+import dagger.model.BindingGraph;
+import dagger.model.BindingGraph.BindingNode;
+import dagger.model.BindingGraph.ComponentNode;
+import dagger.model.BindingGraph.DependencyEdge;
+import dagger.model.BindingGraph.Node;
+import dagger.model.BindingKind;
+import dagger.model.DependencyRequest;
+import dagger.model.RequestKind;
+import dagger.spi.BindingGraphPlugin;
+import dagger.spi.DiagnosticReporter;
+import java.util.List;
+import java.util.Optional;
+import java.util.Set;
+import java.util.stream.Stream;
+import javax.inject.Inject;
+import javax.inject.Provider;
+import javax.lang.model.type.TypeMirror;
+
+/** Reports errors for dependency cycles. */
+final class DependencyCycleValidator implements BindingGraphPlugin {
+
+  private final DependencyRequestFormatter dependencyRequestFormatter;
+
+  @Inject
+  DependencyCycleValidator(DependencyRequestFormatter dependencyRequestFormatter) {
+    this.dependencyRequestFormatter = dependencyRequestFormatter;
+  }
+
+  @Override
+  public String pluginName() {
+    return "Dagger/DependencyCycle";
+  }
+
+  @Override
+  public void visitGraph(BindingGraph bindingGraph, DiagnosticReporter diagnosticReporter) {
+    ImmutableNetwork<Node, DependencyEdge> dependencyGraph =
+        nonCycleBreakingDependencyGraph(bindingGraph);
+    // Check each endpoint pair only once, no matter how many parallel edges connect them.
+    Set<EndpointPair<Node>> dependencyEndpointPairs = dependencyGraph.asGraph().edges();
+    Set<EndpointPair<Node>> visited = newHashSetWithExpectedSize(dependencyEndpointPairs.size());
+    for (EndpointPair<Node> endpointPair : dependencyEndpointPairs) {
+      cycleContainingEndpointPair(endpointPair, dependencyGraph, visited)
+          .ifPresent(cycle -> reportCycle(cycle, bindingGraph, diagnosticReporter));
+    }
+  }
+
+  private Optional<Cycle<Node>> cycleContainingEndpointPair(
+      EndpointPair<Node> endpoints,
+      ImmutableNetwork<Node, DependencyEdge> dependencyGraph,
+      Set<EndpointPair<Node>> visited) {
+    if (!visited.add(endpoints)) {
+      // don't recheck endpoints we already know are part of a cycle
+      return Optional.empty();
+    }
+
+    // If there's a path from the target back to the source, there's a cycle.
+    ImmutableList<Node> cycleNodes =
+        shortestPath(dependencyGraph, endpoints.target(), endpoints.source());
+    if (cycleNodes.isEmpty()) {
+      return Optional.empty();
+    }
+
+    Cycle<Node> cycle = Cycle.fromPath(cycleNodes);
+    visited.addAll(cycle.endpointPairs()); // no need to check any edge in this cycle again
+    return Optional.of(cycle);
+  }
+
+  /**
+   * Reports a dependency cycle at the dependency into the cycle that is closest to an entry point.
+   *
+   * <p>Looks for the shortest path from the component that contains the cycle (all bindings in a
+   * cycle must be in the same component; see below) to some binding in the cycle. Then looks for
+   * the last dependency in that path that is not in the cycle; that is the dependency that will be
+   * reported, so that the dependency trace will end just before the cycle.
+   *
+   * <p>Proof (by counterexample) that all bindings in a cycle must be in the same component: Assume
+   * one binding in the cycle is in a parent component. Bindings cannot depend on bindings in child
+   * components, so that binding cannot depend on the next binding in the cycle.
+   */
+  private void reportCycle(
+      Cycle<Node> cycle, BindingGraph bindingGraph, DiagnosticReporter diagnosticReporter) {
+    ImmutableList<Node> path = shortestPathToCycleFromAnEntryPoint(cycle, bindingGraph);
+    Node cycleStartNode = path.get(path.size() - 1);
+    Node previousNode = path.get(path.size() - 2);
+    DependencyEdge dependencyToReport =
+        chooseDependencyEdgeConnecting(previousNode, cycleStartNode, bindingGraph);
+    diagnosticReporter.reportDependency(
+        ERROR, dependencyToReport, errorMessage(cycle.shift(cycleStartNode), bindingGraph));
+  }
+
+  private ImmutableList<Node> shortestPathToCycleFromAnEntryPoint(
+      Cycle<Node> cycle, BindingGraph bindingGraph) {
+    Node someCycleNode = cycle.nodes().asList().get(0);
+    ComponentNode componentContainingCycle =
+        bindingGraph.componentNode(someCycleNode.componentPath()).get();
+    ImmutableList<Node> pathToCycle =
+        shortestPath(bindingGraph.network(), componentContainingCycle, someCycleNode);
+    return subpathToCycle(pathToCycle, cycle);
+  }
+
+  /**
+   * Returns the subpath from the head of {@code path} to the first node in {@code path} that's in
+   * the cycle.
+   */
+  private ImmutableList<Node> subpathToCycle(ImmutableList<Node> path, Cycle<Node> cycle) {
+    ImmutableList.Builder<Node> subpath = ImmutableList.builder();
+    for (Node node : path) {
+      subpath.add(node);
+      if (cycle.nodes().contains(node)) {
+        return subpath.build();
+      }
+    }
+    throw new IllegalArgumentException(
+        "path " + path + " doesn't contain any nodes in cycle " + cycle);
+  }
+
+  private String errorMessage(Cycle<Node> cycle, BindingGraph graph) {
+    StringBuilder message = new StringBuilder("Found a dependency cycle:");
+    ImmutableList<DependencyRequest> cycleRequests =
+        cycle.endpointPairs().stream()
+            // TODO(dpb): Would be nice to take the dependency graph here.
+            .map(endpointPair -> nonCycleBreakingEdge(endpointPair, graph))
+            .map(DependencyEdge::dependencyRequest)
+            .collect(toImmutableList())
+            .reverse();
+    dependencyRequestFormatter.formatIndentedList(message, cycleRequests, 0);
+    return message.toString();
+  }
+
+  /**
+   * Returns one of the edges between two nodes that doesn't {@linkplain
+   * #breaksCycle(DependencyEdge, BindingGraph) break} a cycle.
+   */
+  private DependencyEdge nonCycleBreakingEdge(EndpointPair<Node> endpointPair, BindingGraph graph) {
+    return graph.network().edgesConnecting(endpointPair.source(), endpointPair.target()).stream()
+        .flatMap(instancesOf(DependencyEdge.class))
+        .filter(edge -> !breaksCycle(edge, graph))
+        .findFirst()
+        .get();
+  }
+
+  private boolean breaksCycle(DependencyEdge edge, BindingGraph graph) {
+    if (edge.dependencyRequest().key().multibindingContributionIdentifier().isPresent()) {
+      return false;
+    }
+    if (breaksCycle(edge.dependencyRequest().key().type(), edge.dependencyRequest().kind())) {
+      return true;
+    }
+    Node target = graph.network().incidentNodes(edge).target();
+    if (target instanceof BindingNode
+        && ((BindingNode) target).binding().kind().equals(BindingKind.OPTIONAL)) {
+      /* For @BindsOptionalOf bindings, unwrap the type inside the Optional. If the unwrapped type
+       * breaks the cycle, so does the optional binding. */
+      TypeMirror optionalValueType = OptionalType.from(edge.dependencyRequest().key()).valueType();
+      RequestKind requestKind = getRequestKind(optionalValueType);
+      return breaksCycle(extractKeyType(requestKind, optionalValueType), requestKind);
+    }
+    return false;
+  }
+
+  private boolean breaksCycle(TypeMirror requestedType, RequestKind requestKind) {
+    switch (requestKind) {
+      case PROVIDER:
+      case LAZY:
+      case PROVIDER_OF_LAZY:
+        return true;
+
+      case INSTANCE:
+        if (MapType.isMap(requestedType)) {
+          MapType mapType = MapType.from(requestedType);
+          return !mapType.isRawType() && mapType.valuesAreTypeOf(Provider.class);
+        }
+        // fall through
+
+      default:
+        return false;
+    }
+  }
+
+  private DependencyEdge chooseDependencyEdgeConnecting(
+      Node source, Node target, BindingGraph bindingGraph) {
+    return bindingGraph.network().edgesConnecting(source, target).stream()
+        .flatMap(instancesOf(DependencyEdge.class))
+        .findFirst()
+        .get();
+  }
+
+  /** Returns the subgraph containing only {@link DependencyEdge}s that would not break a cycle. */
+  private ImmutableNetwork<Node, DependencyEdge> nonCycleBreakingDependencyGraph(
+      BindingGraph bindingGraph) {
+    MutableNetwork<Node, DependencyEdge> dependencyNetwork =
+        NetworkBuilder.from(bindingGraph.network())
+            .expectedNodeCount(bindingGraph.network().nodes().size())
+            .expectedEdgeCount(bindingGraph.dependencyEdges().size())
+            .build();
+    bindingGraph.dependencyEdges().stream()
+        .filter(edge -> !breaksCycle(edge, bindingGraph))
+        .forEach(
+            edge -> {
+              EndpointPair<Node> endpoints = bindingGraph.network().incidentNodes(edge);
+              dependencyNetwork.addEdge(endpoints.source(), endpoints.target(), edge);
+            });
+    return ImmutableNetwork.copyOf(dependencyNetwork);
+  }
+
+  /**
+   * An ordered set of endpoint pairs representing the edges in the cycle. The target of each pair
+   * is the source of the next pair. The target of the last pair is the source of the first pair.
+   */
+  @AutoValue
+  abstract static class Cycle<N> {
+    /**
+     * The ordered set of endpoint pairs representing the edges in the cycle. The target of each
+     * pair is the source of the next pair. The target of the last pair is the source of the first
+     * pair.
+     */
+    abstract ImmutableSet<EndpointPair<N>> endpointPairs();
+
+    /** Returns the nodes that participate in the cycle. */
+    ImmutableSet<N> nodes() {
+      return endpointPairs().stream()
+          .flatMap(pair -> Stream.of(pair.source(), pair.target()))
+          .collect(toImmutableSet());
+    }
+
+    /** Returns the number of edges in the cycle. */
+    int size() {
+      return endpointPairs().size();
+    }
+
+    /**
+     * Shifts this cycle so that it starts with a specific node.
+     *
+     * @return a cycle equivalent to this one but whose first pair starts with {@code startNode}
+     */
+    Cycle<N> shift(N startNode) {
+      int startIndex = Iterables.indexOf(endpointPairs(), pair -> pair.source().equals(startNode));
+      checkArgument(
+          startIndex >= 0, "startNode (%s) is not part of this cycle: %s", startNode, this);
+      if (startIndex == 0) {
+        return this;
+      }
+      ImmutableSet.Builder<EndpointPair<N>> shifted = ImmutableSet.builder();
+      shifted.addAll(skip(endpointPairs(), startIndex));
+      shifted.addAll(limit(endpointPairs(), size() - startIndex));
+      return new AutoValue_DependencyCycleValidator_Cycle<>(shifted.build());
+    }
+
+    @Override
+    public final String toString() {
+      return endpointPairs().toString();
+    }
+
+    /**
+     * Creates a {@link Cycle} from a nonempty list of nodes, assuming there is an edge between each
+     * pair of nodes as well as an edge from the last node to the first.
+     */
+    static <N> Cycle<N> fromPath(List<N> nodes) {
+      checkArgument(!nodes.isEmpty());
+      ImmutableSet.Builder<EndpointPair<N>> cycle = ImmutableSet.builder();
+      cycle.add(EndpointPair.ordered(getLast(nodes), nodes.get(0)));
+      for (int i = 0; i < nodes.size() - 1; i++) {
+        cycle.add(EndpointPair.ordered(nodes.get(i), nodes.get(i + 1)));
+      }
+      return new AutoValue_DependencyCycleValidator_Cycle<>(cycle.build());
+    }
+  }
+}
diff --git a/java/dagger/internal/codegen/DependencyEdgeImpl.java b/java/dagger/internal/codegen/DependencyEdgeImpl.java
new file mode 100644
index 000000000..b777251af
--- /dev/null
+++ b/java/dagger/internal/codegen/DependencyEdgeImpl.java
@@ -0,0 +1,55 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import dagger.model.BindingGraph.DependencyEdge;
+import dagger.model.DependencyRequest;
+
+/** An implementation of {@link DependencyEdge}. */
+final class DependencyEdgeImpl implements DependencyEdge {
+
+  private final DependencyRequest dependencyRequest;
+  private final boolean entryPoint;
+
+  DependencyEdgeImpl(DependencyRequest dependencyRequest, boolean entryPoint) {
+    this.dependencyRequest = dependencyRequest;
+    this.entryPoint = entryPoint;
+  }
+
+  @Override
+  public DependencyRequest dependencyRequest() {
+    return dependencyRequest;
+  }
+
+  @Override
+  public boolean isEntryPoint() {
+    return entryPoint;
+  }
+
+  @Override
+  public String toString() {
+    String string =
+        dependencyRequest
+            .requestElement()
+            .map(DaggerElements::elementToString)
+            .orElseGet(
+                () ->
+                    "synthetic request for "
+                        + dependencyRequest.kind().format(dependencyRequest.key()));
+    return entryPoint ? string + " (entry point)" : string;
+  }
+}
diff --git a/java/dagger/internal/codegen/DependencyMethodProducerCreationExpression.java b/java/dagger/internal/codegen/DependencyMethodProducerCreationExpression.java
index 6efe4c750..f762e3c95 100644
--- a/java/dagger/internal/codegen/DependencyMethodProducerCreationExpression.java
+++ b/java/dagger/internal/codegen/DependencyMethodProducerCreationExpression.java
@@ -19,8 +19,8 @@
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.squareup.javapoet.MethodSpec.methodBuilder;
 import static com.squareup.javapoet.TypeSpec.anonymousClassBuilder;
+import static dagger.internal.codegen.TypeNames.dependencyMethodProducerOf;
 import static dagger.internal.codegen.TypeNames.listenableFutureOf;
-import static dagger.internal.codegen.TypeNames.producerOf;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.PUBLIC;
@@ -74,10 +74,10 @@ public CodeBlock creationExpression() {
     return CodeBlock.of(
         "$L",
         anonymousClassBuilder("")
-            .superclass(producerOf(keyType))
+            .superclass(dependencyMethodProducerOf(keyType))
             .addField(dependencyField)
             .addMethod(
-                methodBuilder("get")
+                methodBuilder("callDependencyMethod")
                     .addAnnotation(Override.class)
                     .addModifiers(PUBLIC)
                     .returns(listenableFutureOf(keyType))
diff --git a/java/dagger/internal/codegen/DependencyRequestFactory.java b/java/dagger/internal/codegen/DependencyRequestFactory.java
index 95ac61824..a66edd073 100644
--- a/java/dagger/internal/codegen/DependencyRequestFactory.java
+++ b/java/dagger/internal/codegen/DependencyRequestFactory.java
@@ -111,7 +111,7 @@ private RequestKind multibindingContributionRequestKind(
       case MAP:
         MapType mapType = MapType.from(multibindingKey);
         for (RequestKind kind : WRAPPING_MAP_VALUE_FRAMEWORK_TYPES) {
-          if (mapType.valuesAreTypeOf(frameworkClass(kind).get())) {
+          if (mapType.valuesAreTypeOf(frameworkClass(kind))) {
             return kind;
           }
         }
diff --git a/java/dagger/internal/codegen/DependencyRequestFormatter.java b/java/dagger/internal/codegen/DependencyRequestFormatter.java
index 9fb3b885e..4ccf8aa18 100644
--- a/java/dagger/internal/codegen/DependencyRequestFormatter.java
+++ b/java/dagger/internal/codegen/DependencyRequestFormatter.java
@@ -22,6 +22,7 @@
 
 import com.google.common.base.Joiner;
 import com.google.common.collect.ImmutableSet;
+import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import dagger.Provides;
 import dagger.internal.codegen.ComponentTreeTraverser.DependencyTrace;
 import dagger.model.DependencyRequest;
@@ -98,6 +99,19 @@ public String format(DependencyRequest request) {
         .orElse("");
   }
 
+  /**
+   * Appends a newline and the formatted dependency request unless {@link
+   * #format(DependencyRequest)} returns the empty string.
+   */
+  @CanIgnoreReturnValue
+  StringBuilder appendFormatLine(StringBuilder builder, DependencyRequest dependencyRequest) {
+    String formatted = format(dependencyRequest);
+    if (!formatted.isEmpty()) {
+      builder.append('\n').append(formatted);
+    }
+    return builder;
+  }
+
   private final ElementVisitor<String, DependencyRequest> formatVisitor =
       new ElementKindVisitor8<String, DependencyRequest>() {
 
diff --git a/java/dagger/internal/codegen/DependencyRequestValidator.java b/java/dagger/internal/codegen/DependencyRequestValidator.java
new file mode 100644
index 000000000..1a9981852
--- /dev/null
+++ b/java/dagger/internal/codegen/DependencyRequestValidator.java
@@ -0,0 +1,97 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static dagger.internal.codegen.InjectionAnnotations.getQualifiers;
+import static dagger.internal.codegen.RequestKinds.extractKeyType;
+import static dagger.internal.codegen.RequestKinds.getRequestKind;
+import static javax.lang.model.type.TypeKind.WILDCARD;
+
+import com.google.auto.common.MoreTypes;
+import com.google.common.collect.ImmutableSet;
+import dagger.MembersInjector;
+import javax.inject.Inject;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeMirror;
+
+/** Validation for dependency requests. */
+final class DependencyRequestValidator {
+  private final MembersInjectionValidator membersInjectionValidator;
+
+  @Inject
+  DependencyRequestValidator(MembersInjectionValidator membersInjectionValidator) {
+    this.membersInjectionValidator = membersInjectionValidator;
+  }
+
+  /**
+   * Adds an error if the given dependency request has more than one qualifier annotation or is a
+   * non-instance request with a wildcard type.
+   */
+  void validateDependencyRequest(
+      ValidationReport.Builder<?> report, Element requestElement, TypeMirror requestType) {
+    ImmutableSet<? extends AnnotationMirror> qualifiers = getQualifiers(requestElement);
+    if (qualifiers.size() > 1) {
+      for (AnnotationMirror qualifier : qualifiers) {
+        report.addError(
+            "A single dependency request may not use more than one @Qualifier",
+            requestElement,
+            qualifier);
+      }
+    }
+
+    TypeMirror keyType = extractKeyType(getRequestKind(requestType), requestType);
+    if (keyType.getKind().equals(WILDCARD)) {
+      // TODO(ronshapiro): Explore creating this message using RequestKinds.
+      report.addError(
+          "Dagger does not support injecting Provider<T>, Lazy<T>, Producer<T>, "
+              + "or Produced<T> when T is a wildcard type such as "
+              + keyType,
+          requestElement);
+    }
+    if (MoreTypes.isType(keyType) && MoreTypes.isTypeOf(MembersInjector.class, keyType)) {
+      DeclaredType membersInjectorType = MoreTypes.asDeclared(keyType);
+      if (membersInjectorType.getTypeArguments().isEmpty()) {
+        report.addError("Cannot inject a raw MembersInjector", requestElement);
+      } else {
+        report.addSubreport(
+            membersInjectionValidator.validateMembersInjectionRequest(
+                requestElement, membersInjectorType.getTypeArguments().get(0)));
+      }
+    }
+  }
+
+  /**
+   * Adds an error if the given dependency request is for a {@link dagger.producers.Producer} or
+   * {@link dagger.producers.Produced}.
+   *
+   * <p>Only call this when processing a provision binding.
+   */
+  // TODO(dpb): Should we disallow Producer entry points in non-production components?
+  void checkNotProducer(ValidationReport.Builder<?> report, VariableElement requestElement) {
+    TypeMirror requestType = requestElement.asType();
+    if (FrameworkTypes.isProducerType(requestType)) {
+      report.addError(
+          String.format(
+              "%s may only be injected in @Produces methods",
+              MoreTypes.asTypeElement(requestType).getSimpleName()),
+          requestElement);
+    }
+  }
+}
diff --git a/java/dagger/internal/codegen/DependsOnProductionExecutorValidator.java b/java/dagger/internal/codegen/DependsOnProductionExecutorValidator.java
new file mode 100644
index 000000000..965be6dd8
--- /dev/null
+++ b/java/dagger/internal/codegen/DependsOnProductionExecutorValidator.java
@@ -0,0 +1,70 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static dagger.internal.codegen.DaggerStreams.instancesOf;
+import static javax.tools.Diagnostic.Kind.ERROR;
+
+import dagger.model.BindingGraph;
+import dagger.model.BindingGraph.BindingNode;
+import dagger.model.Key;
+import dagger.spi.BindingGraphPlugin;
+import dagger.spi.DiagnosticReporter;
+import javax.inject.Inject;
+
+/**
+ * Reports an error on all bindings that depend explicitly on the {@code @Production Executor} key.
+ */
+// TODO(dpb,beder): Validate this during @Inject/@Provides/@Produces validation.
+final class DependsOnProductionExecutorValidator implements BindingGraphPlugin {
+  private final CompilerOptions compilerOptions;
+  private final KeyFactory keyFactory;
+
+  @Inject
+  DependsOnProductionExecutorValidator(CompilerOptions compilerOptions, KeyFactory keyFactory) {
+    this.compilerOptions = compilerOptions;
+    this.keyFactory = keyFactory;
+  }
+
+  @Override
+  public String pluginName() {
+    return "Dagger/DependsOnProductionExecutor";
+  }
+
+  @Override
+  public void visitGraph(BindingGraph bindingGraph, DiagnosticReporter diagnosticReporter) {
+    if (!compilerOptions.usesProducers()) {
+      return;
+    }
+
+    Key productionImplementationExecutorKey = keyFactory.forProductionImplementationExecutor();
+    Key productionExecutorKey = keyFactory.forProductionExecutor();
+
+    bindingGraph.bindingNodes(productionExecutorKey).stream()
+        .flatMap(
+            productionExecutorBinding ->
+                bindingGraph.network().predecessors(productionExecutorBinding).stream())
+        .flatMap(instancesOf(BindingNode.class))
+        .filter(binding -> !binding.key().equals(productionImplementationExecutorKey))
+        .forEach(binding -> reportError(diagnosticReporter, binding));
+  }
+
+  private void reportError(DiagnosticReporter diagnosticReporter, BindingNode bindingNode) {
+    diagnosticReporter.reportBinding(
+        ERROR, bindingNode, "%s may not depend on the production executor", bindingNode.key());
+  }
+}
diff --git a/java/dagger/internal/codegen/DerivedFromProviderBindingExpression.java b/java/dagger/internal/codegen/DerivedFromFrameworkInstanceBindingExpression.java
similarity index 55%
rename from java/dagger/internal/codegen/DerivedFromProviderBindingExpression.java
rename to java/dagger/internal/codegen/DerivedFromFrameworkInstanceBindingExpression.java
index 2dfa992f5..2e0ab538b 100644
--- a/java/dagger/internal/codegen/DerivedFromProviderBindingExpression.java
+++ b/java/dagger/internal/codegen/DerivedFromFrameworkInstanceBindingExpression.java
@@ -17,36 +17,48 @@
 package dagger.internal.codegen;
 
 import static com.google.common.base.Preconditions.checkNotNull;
+import static dagger.internal.codegen.BindingRequest.bindingRequest;
 
 import com.squareup.javapoet.ClassName;
-import dagger.model.Key;
+import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
 import dagger.model.RequestKind;
 
-/** A binding expression that depends on the expression for the {@link RequestKind#PROVIDER}. */
-final class DerivedFromProviderBindingExpression extends BindingExpression {
+/** A binding expression that depends on a framework instance. */
+final class DerivedFromFrameworkInstanceBindingExpression extends BindingExpression {
 
-  private final Key key;
+  private final BindingRequest frameworkRequest;
   private final RequestKind requestKind;
+  private final FrameworkType frameworkType;
   private final ComponentBindingExpressions componentBindingExpressions;
   private final DaggerTypes types;
 
-  DerivedFromProviderBindingExpression(
+  DerivedFromFrameworkInstanceBindingExpression(
       ResolvedBindings resolvedBindings,
+      FrameworkType frameworkType,
       RequestKind requestKind,
       ComponentBindingExpressions componentBindingExpressions,
       DaggerTypes types) {
-    this.key = resolvedBindings.key();
+    this.frameworkRequest = bindingRequest(resolvedBindings.key(), frameworkType);
     this.requestKind = checkNotNull(requestKind);
+    this.frameworkType = checkNotNull(frameworkType);
     this.componentBindingExpressions = checkNotNull(componentBindingExpressions);
     this.types = checkNotNull(types);
   }
 
   @Override
   Expression getDependencyExpression(ClassName requestingClass) {
-    return FrameworkType.PROVIDER.to(
+    return frameworkType.to(
         requestKind,
-        componentBindingExpressions.getDependencyExpression(
-            key, RequestKind.PROVIDER, requestingClass),
+        componentBindingExpressions.getDependencyExpression(frameworkRequest, requestingClass),
         types);
   }
+
+  @Override
+  Expression getDependencyExpressionForComponentMethod(
+      ComponentMethodDescriptor componentMethod, GeneratedComponentModel component) {
+    Expression expression =
+        componentBindingExpressions.getDependencyExpressionForComponentMethod(
+            frameworkRequest, componentMethod, component);
+    return frameworkType.to(requestKind, expression, types);
+  }
 }
diff --git a/java/dagger/internal/codegen/DiagnosticReporterFactory.java b/java/dagger/internal/codegen/DiagnosticReporterFactory.java
index ddb98e8fc..83e09870c 100644
--- a/java/dagger/internal/codegen/DiagnosticReporterFactory.java
+++ b/java/dagger/internal/codegen/DiagnosticReporterFactory.java
@@ -16,27 +16,50 @@
 
 package dagger.internal.codegen;
 
-import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.auto.common.MoreTypes.asTypeElement;
+import static com.google.common.base.Predicates.equalTo;
+import static com.google.common.base.Verify.verify;
+import static com.google.common.collect.Iterables.getLast;
+import static com.google.common.collect.Iterables.indexOf;
+import static com.google.common.collect.Iterables.transform;
 import static com.google.common.collect.Lists.asList;
+import static com.google.common.collect.Sets.filter;
+import static dagger.internal.codegen.DaggerElements.DECLARATION_ORDER;
+import static dagger.internal.codegen.DaggerElements.closestEnclosingTypeElement;
+import static dagger.internal.codegen.DaggerElements.elementEncloses;
 import static dagger.internal.codegen.DaggerElements.elementToString;
 import static dagger.internal.codegen.DaggerGraphs.shortestPath;
+import static dagger.internal.codegen.DaggerStreams.instancesOf;
+import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
+import static java.util.Collections.min;
+import static java.util.Comparator.comparing;
+import static java.util.Comparator.comparingInt;
 
+import com.google.auto.common.MoreElements;
+import com.google.common.cache.CacheBuilder;
+import com.google.common.cache.CacheLoader;
+import com.google.common.cache.LoadingCache;
+import com.google.common.collect.HashBasedTable;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
-import com.google.common.collect.Sets;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
+import com.google.common.collect.Table;
 import com.google.errorprone.annotations.FormatMethod;
 import dagger.model.BindingGraph;
 import dagger.model.BindingGraph.BindingNode;
+import dagger.model.BindingGraph.ChildFactoryMethodEdge;
 import dagger.model.BindingGraph.ComponentNode;
 import dagger.model.BindingGraph.DependencyEdge;
 import dagger.model.BindingGraph.Edge;
+import dagger.model.BindingGraph.MaybeBindingNode;
 import dagger.model.BindingGraph.Node;
-import dagger.model.DependencyRequest;
+import dagger.model.ComponentPath;
 import dagger.spi.BindingGraphPlugin;
 import dagger.spi.DiagnosticReporter;
+import java.util.Comparator;
+import java.util.Formatter;
 import java.util.Set;
+import java.util.function.Function;
 import javax.annotation.processing.Messager;
 import javax.inject.Inject;
 import javax.lang.model.element.Element;
@@ -47,12 +70,14 @@
 // TODO(ronshapiro): If multiple plugins print errors on the same node/edge, should we condense the
 // messages and only print the dependency trace once?
 final class DiagnosticReporterFactory {
+  private final DaggerTypes types;
   private final Messager messager;
   private final DependencyRequestFormatter dependencyRequestFormatter;
 
   @Inject
   DiagnosticReporterFactory(
-      Messager messager, DependencyRequestFormatter dependencyRequestFormatter) {
+      DaggerTypes types, Messager messager, DependencyRequestFormatter dependencyRequestFormatter) {
+    this.types = types;
     this.messager = messager;
     this.dependencyRequestFormatter = dependencyRequestFormatter;
 
@@ -63,11 +88,40 @@ DiagnosticReporterImpl reporter(BindingGraph graph, BindingGraphPlugin plugin) {
     return new DiagnosticReporterImpl(graph, plugin.pluginName());
   }
 
+  private static <K, V> Function<K, V> memoize(Function<K, V> uncached) {
+    // If Android Guava is on the processor path, then c.g.c.b.Function (which LoadingCache
+    // implements) does not extend j.u.f.Function.
+
+    // First, explicitly convert uncached to c.g.c.b.Function because CacheLoader.from() expects
+    // one.
+    com.google.common.base.Function<K, V> uncachedAsBaseFunction = uncached::apply;
+
+    LoadingCache<K, V> cache =
+        CacheBuilder.newBuilder().build(CacheLoader.from(uncachedAsBaseFunction));
+
+    // Second, explicitly convert LoadingCache to j.u.f.Function.
+    @SuppressWarnings("deprecation") // uncachedAsBaseFunction throws only unchecked exceptions
+    Function<K, V> memoized = cache::apply;
+
+    return memoized;
+  }
+
   /**
    * A {@link DiagnosticReporter} that keeps track of which {@linkplain Diagnostic.Kind kinds} of
    * diagnostics were reported.
    */
   final class DiagnosticReporterImpl implements DiagnosticReporter {
+
+    /** A cached function from type to all of its supertypes in breadth-first order. */
+    private final Function<TypeElement, Iterable<TypeElement>> supertypes =
+        memoize(
+            component ->
+                transform(types.supertypes(component.asType()), type -> asTypeElement(type)));
+
+    /** The shortest path (value) from an entry point (column) to a binding (row). */
+    private final Table<MaybeBindingNode, DependencyEdge, ImmutableList<Node>> shortestPaths =
+        HashBasedTable.create();
+
     private final BindingGraph graph;
     private final String plugin;
     private final TypeElement rootComponent;
@@ -88,11 +142,9 @@ DiagnosticReporterImpl reporter(BindingGraph graph, BindingGraphPlugin plugin) {
     @Override
     public void reportComponent(
         Diagnostic.Kind diagnosticKind, ComponentNode componentNode, String messageFormat) {
-      StringBuilder messageBuilder = new StringBuilder(messageFormat);
-      if (!componentNode.componentPath().currentComponent().equals(rootComponent)) {
-        appendComponentPath(messageBuilder, componentNode);
-      }
-      printMessage(diagnosticKind, messageBuilder, rootComponent);
+      StringBuilder message = new StringBuilder(messageFormat);
+      appendComponentPathUnlessAtRoot(message, componentNode);
+      printMessage(diagnosticKind, message, rootComponent);
     }
 
     @Override
@@ -107,18 +159,17 @@ public void reportComponent(
           diagnosticKind, componentNode, formatMessage(messageFormat, firstArg, moreArgs));
     }
 
+    // TODO(ronshapiro): should this also include the binding element?
     @Override
     public void reportBinding(
-        Diagnostic.Kind diagnosticKind, BindingNode bindingNode, String message) {
-      // TODO(ronshapiro): should this also include the binding element?
-      reportAtEntryPointsWithDependencyTrace(
-          diagnosticKind, new StringBuilder(message), bindingNode);
+        Diagnostic.Kind diagnosticKind, MaybeBindingNode bindingNode, String message) {
+      printMessage(diagnosticKind, message + new DiagnosticInfo(bindingNode), rootComponent);
     }
 
     @Override
     public void reportBinding(
         Diagnostic.Kind diagnosticKind,
-        BindingNode bindingNode,
+        MaybeBindingNode bindingNode,
         String messageFormat,
         Object firstArg,
         Object... moreArgs) {
@@ -128,17 +179,7 @@ public void reportBinding(
     @Override
     public void reportDependency(
         Diagnostic.Kind diagnosticKind, DependencyEdge dependencyEdge, String message) {
-      StringBuilder messageBuilder =
-          new StringBuilder(message)
-              .append('\n')
-              .append(dependencyRequestFormatter.format(dependencyEdge.dependencyRequest()));
-
-      if (dependencyEdge.isEntryPoint()) {
-        printAtEntryPoint(diagnosticKind, messageBuilder, dependencyEdge);
-      } else {
-        BindingNode sourceNode = (BindingNode) graph.incidentNodes(dependencyEdge).source();
-        reportAtEntryPointsWithDependencyTrace(diagnosticKind, messageBuilder, sourceNode);
-      }
+      printMessage(diagnosticKind, message + new DiagnosticInfo(dependencyEdge), rootComponent);
     }
 
     @Override
@@ -152,91 +193,275 @@ public void reportDependency(
           diagnosticKind, dependencyEdge, formatMessage(messageFormat, firstArg, moreArgs));
     }
 
+    @Override
+    public void reportSubcomponentFactoryMethod(
+        Diagnostic.Kind diagnosticKind,
+        ChildFactoryMethodEdge childFactoryMethodEdge,
+        String message) {
+      printMessage(diagnosticKind, message, childFactoryMethodEdge.factoryMethod());
+    }
+
+    @Override
+    public void reportSubcomponentFactoryMethod(
+        Diagnostic.Kind diagnosticKind,
+        ChildFactoryMethodEdge childFactoryMethodEdge,
+        String messageFormat,
+        Object firstArg,
+        Object... moreArgs) {
+      reportSubcomponentFactoryMethod(
+          diagnosticKind, childFactoryMethodEdge, formatMessage(messageFormat, firstArg, moreArgs));
+    }
+
     private String formatMessage(String messageFormat, Object firstArg, Object[] moreArgs) {
       return String.format(messageFormat, asList(firstArg, moreArgs).toArray());
     }
 
-    /**
-     * For each entry point that depends on {@code targetNode}, appends the {@link
-     * #dependencyTrace(DependencyEdge, BindingNode)} to the binding onto {@code message} and prints
-     * to the messager.
-     */
-    private void reportAtEntryPointsWithDependencyTrace(
-        Diagnostic.Kind diagnosticKind, CharSequence message, BindingNode bindingNode) {
-      for (DependencyEdge entryPoint : graph.entryPointEdgesDependingOnBindingNode(bindingNode)) {
-        printAtEntryPoint(
-            diagnosticKind,
-            new StringBuilder(message).append(dependencyTrace(entryPoint, bindingNode)),
-            entryPoint);
-      }
+    private Node source(Edge edge) {
+      return graph.network().incidentNodes(edge).source();
     }
 
-    // TODO(ronshapiro): Adding a DependencyPath type to dagger.model could be useful, i.e.
-    // bindingGraph.shortestPathFromEntryPoint(DependencyEdge, BindingNode)
-    private CharSequence dependencyTrace(DependencyEdge entryPoint, BindingNode bindingNode) {
-      checkArgument(entryPoint.isEntryPoint());
-      Node entryPointBinding = graph.incidentNodes(entryPoint).target();
-      ImmutableList<Node> shortestPath =
-          shortestPath(
-              node -> Sets.filter(graph.successors(node), BindingNode.class::isInstance),
-              entryPointBinding,
-              bindingNode);
-
-      StringBuilder trace = new StringBuilder(shortestPath.size() * 100 /* a guess heuristic */);
-      for (int i = shortestPath.size() - 1; i > 0; i--) {
-        Set<Edge> dependenciesBetween =
-            graph.edgesConnecting(shortestPath.get(i - 1), shortestPath.get(i));
-        DependencyRequest dependencyRequest =
-            // If a binding requests a key more than once, any of them should be fine to get to
-            // the shortest path
-            ((DependencyEdge) Iterables.get(dependenciesBetween, 0)).dependencyRequest();
-        trace.append('\n').append(dependencyRequestFormatter.format(dependencyRequest));
-      }
-      trace.append('\n').append(dependencyRequestFormatter.format(entryPoint.dependencyRequest()));
-      return trace;
-    }
-
-    /**
-     * Prints {@code message} at {@code entryPoint}'s element if it is defined in the {@code
-     * rootComponent}, otherwise at the root component.
-     */
-    private void printAtEntryPoint(
-        Diagnostic.Kind diagnosticKind, CharSequence message, DependencyEdge entryPoint) {
-      checkArgument(entryPoint.isEntryPoint());
-      Element entryPointElement = entryPoint.dependencyRequest().requestElement().get();
-
-      StringBuilder messageBuilder = new StringBuilder(message);
-      Node component = graph.incidentNodes(entryPoint).source();
-      if (!component.equals(graph.rootComponentNode())) {
-        appendComponentPath(messageBuilder, component);
-      }
-
-      // TODO(ronshapiro): should we create a HashSet out of getEnclosedElements() so we don't
+    void printMessage(
+        Diagnostic.Kind diagnosticKind, CharSequence message, Element elementToReport) {
+      reportedDiagnosticKinds.add(diagnosticKind);
+      StringBuilder fullMessage = new StringBuilder();
+      appendBracketPrefix(fullMessage, plugin);
+      // TODO(ronshapiro): should we create a HashSet out of elementEncloses() so we don't
       // need to do an O(n) contains() each time?
-      if (rootComponent.getEnclosedElements().contains(entryPointElement)) {
-        printMessage(diagnosticKind, messageBuilder, entryPointElement);
-      } else {
-        printMessage(
-            diagnosticKind,
-            insertBracketPrefix(messageBuilder, elementToString(entryPointElement)),
-            rootComponent);
+      if (!elementEncloses(rootComponent, elementToReport)) {
+        appendBracketPrefix(fullMessage, elementToString(elementToReport));
+        elementToReport = rootComponent;
       }
+      messager.printMessage(diagnosticKind, fullMessage.append(message), elementToReport);
     }
 
-    private void printMessage(
-        Diagnostic.Kind diagnosticKind, StringBuilder message, Element elementToReport) {
-      reportedDiagnosticKinds.add(diagnosticKind);
-      messager.printMessage(diagnosticKind, insertBracketPrefix(message, plugin), elementToReport);
+    private void appendComponentPathUnlessAtRoot(StringBuilder message, Node node) {
+      if (!node.componentPath().equals(graph.rootComponentNode().componentPath())) {
+        new Formatter(message).format(" [%s]", node.componentPath());
+      }
     }
 
-    @CanIgnoreReturnValue
-    private StringBuilder appendComponentPath(StringBuilder message, Node node) {
-      return message.append("\ncomponent path: ").append(node.componentPath());
+    private void appendBracketPrefix(StringBuilder message, String prefix) {
+      new Formatter(message).format("[%s] ", prefix);
     }
 
-    @CanIgnoreReturnValue
-    private StringBuilder insertBracketPrefix(StringBuilder messageBuilder, String prefix) {
-      return messageBuilder.insert(0, String.format("[%s] ", prefix));
+    /** The diagnostic information associated with an error. */
+    private final class DiagnosticInfo {
+      final ImmutableList<DependencyEdge> dependencyTrace;
+      final ImmutableSet<DependencyEdge> requests;
+      final ImmutableSet<DependencyEdge> entryPoints;
+
+      DiagnosticInfo(MaybeBindingNode bindingNode) {
+        entryPoints = graph.entryPointEdgesDependingOnBindingNode(bindingNode);
+        requests = requests(bindingNode);
+        dependencyTrace = dependencyTrace(bindingNode, entryPoints);
+      }
+
+      DiagnosticInfo(DependencyEdge dependencyEdge) {
+        requests = ImmutableSet.of(dependencyEdge);
+        ImmutableList.Builder<DependencyEdge> dependencyTraceBuilder = ImmutableList.builder();
+        dependencyTraceBuilder.add(dependencyEdge);
+
+        if (dependencyEdge.isEntryPoint()) {
+          entryPoints = ImmutableSet.of(dependencyEdge);
+        } else {
+          // It's not an entry point, so it's part of a binding
+          BindingNode bindingNode = (BindingNode) source(dependencyEdge);
+          entryPoints = graph.entryPointEdgesDependingOnBindingNode(bindingNode);
+          dependencyTraceBuilder.addAll(dependencyTrace(bindingNode, entryPoints));
+        }
+        dependencyTrace = dependencyTraceBuilder.build();
+      }
+
+      @Override
+      public String toString() {
+        StringBuilder message =
+            new StringBuilder(dependencyTrace.size() * 100 /* a guess heuristic */);
+
+        // Print the dependency trace.
+        dependencyTrace.forEach(
+            edge -> dependencyRequestFormatter.appendFormatLine(message, edge.dependencyRequest()));
+        appendComponentPathUnlessAtRoot(message, source(getLast(dependencyTrace)));
+
+        // List any other dependency requests.
+        ImmutableSet<Element> otherRequests =
+            requests.stream()
+                .filter(request -> !request.isEntryPoint()) // skip entry points, listed below
+                // skip the request from the dependency trace above
+                .filter(request -> !request.equals(dependencyTrace.get(0)))
+                .map(request -> request.dependencyRequest().requestElement().get())
+                .collect(toImmutableSet());
+        if (!otherRequests.isEmpty()) {
+          message.append("\nIt is also requested at:");
+          for (Element otherRequest : otherRequests) {
+            message.append("\n    ").append(elementToString(otherRequest));
+          }
+        }
+
+        // List the remaining entry points, showing which component they're in.
+        if (entryPoints.size() > 1) {
+          message.append("\nThe following other entry points also depend on it:");
+          entryPoints.stream()
+              .filter(entryPoint -> !entryPoint.equals(getLast(dependencyTrace)))
+              .sorted(
+                  // start with entry points in components closest to the root
+                  rootComponentFirst()
+                      // then list entry points declared in the component before those declared in a
+                      // supertype
+                      .thenComparing(nearestComponentSupertypeFirst())
+                      // finally list entry points in declaration order in their declaring type
+                      .thenComparing(requestElementDeclarationOrder()))
+              .forEachOrdered(
+                  entryPoint -> {
+                    message.append("\n    ");
+                    Element requestElement = entryPoint.dependencyRequest().requestElement().get();
+                    message.append(elementToString(requestElement));
+
+                    // For entry points declared in subcomponents or supertypes of the root
+                    // component, append the component path to make clear to the user which
+                    // component it's in.
+                    ComponentPath componentPath = source(entryPoint).componentPath();
+                    if (!componentPath.atRoot()
+                        || !requestElement.getEnclosingElement().equals(rootComponent)) {
+                      message.append(String.format(" [%s]", componentPath));
+                    }
+                  });
+        }
+        return message.toString();
+      }
+
+      /**
+       * Returns the dependency trace from one of the {@code entryPoints} to {@code bindingNode} to
+       * {@code message} as a list <i>ending with</i> the entry point.
+       */
+      // TODO(ronshapiro): Adding a DependencyPath type to dagger.model could be useful, i.e.
+      // bindingGraph.shortestPathFromEntryPoint(DependencyEdge, MaybeBindingNode)
+      ImmutableList<DependencyEdge> dependencyTrace(
+          MaybeBindingNode bindingNode, ImmutableSet<DependencyEdge> entryPoints) {
+        // Show the full dependency trace for one entry point.
+        DependencyEdge entryPointForTrace =
+            min(
+                entryPoints,
+                // prefer entry points in components closest to the root
+                rootComponentFirst()
+                    // then prefer entry points with a short dependency path to the error
+                    .thenComparing(shortestDependencyPathFirst(bindingNode))
+                    // then prefer entry points declared in the component to those declared in a
+                    // supertype
+                    .thenComparing(nearestComponentSupertypeFirst())
+                    // finally prefer entry points declared first in their enclosing type
+                    .thenComparing(requestElementDeclarationOrder()));
+
+        ImmutableList<Node> shortestBindingPath =
+            shortestPathFromEntryPoint(entryPointForTrace, bindingNode);
+        verify(
+            !shortestBindingPath.isEmpty(),
+            "no dependency path from %s to %s in %s",
+            entryPointForTrace,
+            bindingNode,
+            graph);
+
+        ImmutableList.Builder<DependencyEdge> dependencyTrace = ImmutableList.builder();
+        dependencyTrace.add(entryPointForTrace);
+        for (int i = 0; i < shortestBindingPath.size() - 1; i++) {
+          Set<Edge> dependenciesBetween =
+              graph
+                  .network()
+                  .edgesConnecting(shortestBindingPath.get(i), shortestBindingPath.get(i + 1));
+          // If a binding requests a key more than once, any of them should be fine to get to the
+          // shortest path
+          dependencyTrace.add((DependencyEdge) Iterables.get(dependenciesBetween, 0));
+        }
+        return dependencyTrace.build().reverse();
+      }
+
+      /** Returns all the nonsynthetic dependency requests for a binding node. */
+      ImmutableSet<DependencyEdge> requests(MaybeBindingNode bindingNode) {
+        return graph.network().inEdges(bindingNode).stream()
+            .flatMap(instancesOf(DependencyEdge.class))
+            .filter(edge -> edge.dependencyRequest().requestElement().isPresent())
+            .sorted(requestEnclosingTypeName().thenComparing(requestElementDeclarationOrder()))
+            .collect(toImmutableSet());
+      }
+
+      /**
+       * Returns a comparator that sorts entry points in components whose paths from the root are
+       * shorter first.
+       */
+      Comparator<DependencyEdge> rootComponentFirst() {
+        return comparingInt(entryPoint -> source(entryPoint).componentPath().components().size());
+      }
+
+      /**
+       * Returns a comparator that puts entry points whose shortest dependency path to {@code
+       * bindingNode} is shortest first.
+       */
+      Comparator<DependencyEdge> shortestDependencyPathFirst(MaybeBindingNode bindingNode) {
+        return comparing(entryPoint -> shortestPathFromEntryPoint(entryPoint, bindingNode).size());
+      }
+
+      ImmutableList<Node> shortestPathFromEntryPoint(
+          DependencyEdge entryPoint, MaybeBindingNode bindingNode) {
+        return shortestPaths
+            .row(bindingNode)
+            .computeIfAbsent(
+                entryPoint,
+                ep ->
+                    shortestPath(
+                        node ->
+                            filter(
+                                graph.network().successors(node),
+                                MaybeBindingNode.class::isInstance),
+                        graph.network().incidentNodes(ep).target(),
+                        bindingNode));
+      }
+
+      /**
+       * Returns a comparator that sorts entry points in by the distance of the type that declares
+       * them from the type of the component that contains them.
+       *
+       * <p>For instance, an entry point declared directly in the component type would sort before
+       * one declared in a direct supertype, which would sort before one declared in a supertype of
+       * a supertype.
+       */
+      Comparator<DependencyEdge> nearestComponentSupertypeFirst() {
+        return comparingInt(
+            entryPoint ->
+                indexOf(
+                    supertypes.apply(componentContainingEntryPoint(entryPoint)),
+                    equalTo(typeDeclaringEntryPoint(entryPoint))));
+      }
+
+      TypeElement componentContainingEntryPoint(DependencyEdge entryPoint) {
+        return source(entryPoint).componentPath().currentComponent();
+      }
+
+      TypeElement typeDeclaringEntryPoint(DependencyEdge entryPoint) {
+        return MoreElements.asType(
+            entryPoint.dependencyRequest().requestElement().get().getEnclosingElement());
+      }
+
+      /**
+       * Returns a comparator that sorts dependency edges lexicographically by the qualified name of
+       * the type that contains them. Only appropriate for edges with request elements.
+       */
+      Comparator<DependencyEdge> requestEnclosingTypeName() {
+        return comparing(
+            edge ->
+                closestEnclosingTypeElement(edge.dependencyRequest().requestElement().get())
+                    .getQualifiedName()
+                    .toString());
+      }
+
+      /**
+       * Returns a comparator that sorts edges in the order in which their request elements were
+       * declared in their declaring type.
+       *
+       * <p>Only useful to compare edges whose request elements were declared in the same type.
+       */
+      Comparator<DependencyEdge> requestElementDeclarationOrder() {
+        return comparing(
+            edge -> edge.dependencyRequest().requestElement().get(), DECLARATION_ORDER);
+      }
     }
   }
 }
diff --git a/java/dagger/internal/codegen/DoubleCheckedMethodImplementation.java b/java/dagger/internal/codegen/DoubleCheckedMethodImplementation.java
index 31b51e46c..7c059d9c1 100644
--- a/java/dagger/internal/codegen/DoubleCheckedMethodImplementation.java
+++ b/java/dagger/internal/codegen/DoubleCheckedMethodImplementation.java
@@ -27,7 +27,6 @@
 import com.squareup.javapoet.TypeName;
 import dagger.internal.DoubleCheck;
 import dagger.internal.MemoizedSentinel;
-import dagger.model.RequestKind;
 
 /**
  * Defines a method body and return type for double checked locking of the given {@link
@@ -41,11 +40,11 @@
 
   DoubleCheckedMethodImplementation(
       ResolvedBindings resolvedBindings,
-      RequestKind requestKind,
+      BindingRequest request,
       BindingExpression bindingExpression,
       DaggerTypes types,
       GeneratedComponentModel generatedComponentModel) {
-    super(resolvedBindings, requestKind, bindingExpression, generatedComponentModel.name(), types);
+    super(resolvedBindings, request, bindingExpression, generatedComponentModel.name(), types);
     this.generatedComponentModel = generatedComponentModel;
     this.binding = resolvedBindings.contributionBinding();
   }
diff --git a/java/dagger/internal/codegen/DuplicateBindingsValidation.java b/java/dagger/internal/codegen/DuplicateBindingsValidator.java
similarity index 89%
rename from java/dagger/internal/codegen/DuplicateBindingsValidation.java
rename to java/dagger/internal/codegen/DuplicateBindingsValidator.java
index 7c8686145..927dbf4b2 100644
--- a/java/dagger/internal/codegen/DuplicateBindingsValidation.java
+++ b/java/dagger/internal/codegen/DuplicateBindingsValidator.java
@@ -21,7 +21,7 @@
 import static dagger.internal.codegen.DaggerStreams.instancesOf;
 import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
 import static dagger.internal.codegen.DaggerStreams.toImmutableSetMultimap;
-import static dagger.internal.codegen.DuplicateBindingsValidation.SourceAndRequest.indexEdgesBySourceAndRequest;
+import static dagger.internal.codegen.DuplicateBindingsValidator.SourceAndRequest.indexEdgesBySourceAndRequest;
 import static dagger.internal.codegen.Formatter.INDENT;
 import static dagger.internal.codegen.Optionals.emptiesLast;
 import static java.util.Comparator.comparing;
@@ -48,7 +48,7 @@
 import javax.lang.model.element.TypeElement;
 
 /** Reports errors for conflicting bindings with the same key. */
-final class DuplicateBindingsValidation implements BindingGraphPlugin {
+final class DuplicateBindingsValidator implements BindingGraphPlugin {
 
   // 1. contributing module or enclosing type
   // 2. binding element's simple name
@@ -69,7 +69,7 @@
   private final BindingDeclarationFormatter bindingDeclarationFormatter;
 
   @Inject
-  DuplicateBindingsValidation(BindingDeclarationFormatter bindingDeclarationFormatter) {
+  DuplicateBindingsValidator(BindingDeclarationFormatter bindingDeclarationFormatter) {
     this.bindingDeclarationFormatter = bindingDeclarationFormatter;
   }
 
@@ -96,9 +96,8 @@ private void reportDuplicateBindings(
       BindingGraph bindingGraph,
       DiagnosticReporter diagnosticReporter) {
     ImmutableSet<BindingNode> duplicateBindings =
-        duplicateDependencies
-            .stream()
-            .map(edge -> bindingGraph.incidentNodes(edge).target())
+        duplicateDependencies.stream()
+            .map(edge -> bindingGraph.network().incidentNodes(edge).target())
             .flatMap(instancesOf(BindingNode.class))
             .collect(toImmutableSet());
     diagnosticReporter.reportDependency(
@@ -124,8 +123,7 @@ private String incompatibleBindingsMessage(
       ImmutableSet<BindingNode> duplicateBindings,
       BindingGraph graph) {
     ImmutableSet<BindingNode> multibindings =
-        duplicateBindings
-            .stream()
+        duplicateBindings.stream()
             .filter(node -> node.binding().kind().isMultibinding())
             .collect(toImmutableSet());
     verify(
@@ -144,7 +142,7 @@ private String incompatibleBindingsMessage(
 
     Set<BindingNode> uniqueBindings =
         Sets.filter(duplicateBindings, binding -> !binding.equals(multibinding));
-    message.append(INDENT).append("Unique bindings and declarations:");
+    message.append('\n').append(INDENT).append("Unique bindings and declarations:");
     formatDeclarations(
         message,
         2,
@@ -160,13 +158,11 @@ private void formatDeclarations(
       Iterable<? extends BindingDeclaration> bindingDeclarations) {
     bindingDeclarationFormatter.formatIndentedList(
         builder, ImmutableList.copyOf(bindingDeclarations), indentLevel);
-    builder.append('\n');
   }
 
   private ImmutableSet<BindingDeclaration> declarations(
       BindingGraph graph, Set<BindingNode> bindings) {
-    return bindings
-        .stream()
+    return bindings.stream()
         .flatMap(node -> declarations(graph, node).stream())
         .distinct()
         .sorted(BINDING_DECLARATION_COMPARATOR)
@@ -181,9 +177,7 @@ private void formatDeclarations(
       if (bindingDeclarationFormatter.canFormat(declaration)) {
         declarations.add(declaration);
       } else {
-        graph
-            .successors(node)
-            .stream()
+        graph.network().successors(node).stream()
             .flatMap(instancesOf(BindingNode.class))
             .flatMap(dependency -> declarations(graph, dependency).stream())
             .forEach(declarations::add);
@@ -212,18 +206,18 @@ private String multibindingTypeString(BindingNode multibinding) {
 
     static ImmutableSetMultimap<SourceAndRequest, DependencyEdge> indexEdgesBySourceAndRequest(
         BindingGraph bindingGraph) {
-      return bindingGraph
-          .dependencyEdges()
-          .stream()
+      return bindingGraph.dependencyEdges().stream()
           .collect(
               toImmutableSetMultimap(
                   edge ->
-                      create(bindingGraph.incidentNodes(edge).source(), edge.dependencyRequest()),
+                      create(
+                          bindingGraph.network().incidentNodes(edge).source(),
+                          edge.dependencyRequest()),
                   edge -> edge));
     }
 
     static SourceAndRequest create(Node source, DependencyRequest request) {
-      return new AutoValue_DuplicateBindingsValidation_SourceAndRequest(source, request);
+      return new AutoValue_DuplicateBindingsValidator_SourceAndRequest(source, request);
     }
   }
 }
diff --git a/java/dagger/internal/codegen/ErrorMessages.java b/java/dagger/internal/codegen/ErrorMessages.java
index fcc31a5e9..f7b143eb5 100644
--- a/java/dagger/internal/codegen/ErrorMessages.java
+++ b/java/dagger/internal/codegen/ErrorMessages.java
@@ -16,7 +16,6 @@
 
 package dagger.internal.codegen;
 
-import com.google.auto.common.MoreTypes;
 import com.google.common.base.Joiner;
 import java.util.Set;
 import javax.lang.model.element.ExecutableElement;
@@ -28,12 +27,6 @@
  */
 final class ErrorMessages {
 
-  static String provisionMayNotDependOnProducerType(TypeMirror type) {
-    return String.format(
-        "%s may only be injected in @Produces methods",
-        MoreTypes.asTypeElement(type).getSimpleName());
-  }
-
   static ComponentBuilderMessages builderMsgsFor(ComponentDescriptor.Kind kind) {
     switch(kind) {
       case COMPONENT:
@@ -125,7 +118,7 @@ final String buildMustReturnComponentType() {
     }
 
     final String inheritedBuildMustReturnComponentType() {
-      return process(buildMustReturnComponentType() + ". Inherited method: %s");
+      return buildMustReturnComponentType() + ". Inherited method: %s";
     }
 
     final String methodsMustTakeOneArg() {
@@ -156,6 +149,16 @@ final String inheritedMethodsMayNotHaveTypeParameters() {
           "@Component.Builder methods must not have type parameters. Inherited method: %s");
     }
 
+    final String nonBindsInstanceMethodsMayNotTakePrimitives() {
+      return process(
+          "@Component.Builder methods that are not annotated with @BindsInstance "
+              + "must take either a module or a component dependency, not a primitive");
+    }
+
+    final String inheritedNonBindsInstanceMethodsMayNotTakePrimitives() {
+      return nonBindsInstanceMethodsMayNotTakePrimitives() + process(". Inherited method: %s");
+    }
+
     final String buildMethodReturnsSupertypeWithMissingMethods(
         TypeElement component,
         TypeElement componentBuilder,
diff --git a/java/dagger/internal/codegen/FactoryGenerator.java b/java/dagger/internal/codegen/FactoryGenerator.java
index 3e34d3a6d..afa1d9e04 100644
--- a/java/dagger/internal/codegen/FactoryGenerator.java
+++ b/java/dagger/internal/codegen/FactoryGenerator.java
@@ -91,8 +91,9 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
   }
 
   @Override
-  Optional<? extends Element> getElementForErrorReporting(ProvisionBinding binding) {
-    return binding.bindingElement();
+  Element originatingElement(ProvisionBinding binding) {
+    // we only create factories for bindings that have a binding element
+    return binding.bindingElement().get();
   }
 
   @Override
diff --git a/java/dagger/internal/codegen/Formatter.java b/java/dagger/internal/codegen/Formatter.java
index 674f2cb40..53d4f9ade 100644
--- a/java/dagger/internal/codegen/Formatter.java
+++ b/java/dagger/internal/codegen/Formatter.java
@@ -56,9 +56,13 @@ public final String apply(T object) {
   public void formatIndentedList(
       StringBuilder builder, Iterable<? extends T> items, int indentLevel) {
     for (T item : Iterables.limit(items, LIST_LIMIT)) {
+      String formatted = format(item);
+      if (formatted.isEmpty()) {
+        continue;
+      }
       builder.append('\n');
       appendIndent(builder, indentLevel);
-      builder.append(format(item));
+      builder.append(formatted);
     }
     int numberOfOtherItems = Iterables.size(items) - LIST_LIMIT;
     if (numberOfOtherItems > 0) {
diff --git a/java/dagger/internal/codegen/FrameworkDependency.java b/java/dagger/internal/codegen/FrameworkDependency.java
index 6b69e0eb9..feea7a0a6 100644
--- a/java/dagger/internal/codegen/FrameworkDependency.java
+++ b/java/dagger/internal/codegen/FrameworkDependency.java
@@ -18,8 +18,6 @@
 
 import com.google.auto.value.AutoValue;
 import dagger.model.Key;
-import dagger.model.RequestKind;
-import javax.inject.Provider;
 
 /**
  * The framework class and binding key for a resolved dependency of a binding. If a binding has
@@ -34,7 +32,7 @@
  *
  * But they both can be satisfied with the same instance of {@code Provider<Bar>}. So one instance
  * of {@code FrameworkDependency} will be used for both. Its {@link #key()} will be for {@code Bar},
- * and its {@link #frameworkClass()} will be {@link Provider}.
+ * and its {@link #frameworkType()} will be {@link FrameworkType#PROVIDER}.
  *
  * <pre><code>
  *   {@literal @Provides} static Foo provideFoo(Bar bar, {@literal Provider<Bar>} barProvider) {
@@ -48,30 +46,16 @@
   /** The fully-resolved key shared by all the dependency requests. */
   abstract Key key();
 
-  /** The binding type of the framework dependency. */
-  abstract BindingType bindingType();
+  /** The type of the framework dependency. */
+  abstract FrameworkType frameworkType();
 
-  /** The dependency request kind that is equivalent to requesting the framework dependency. */
-  RequestKind dependencyRequestKind() {
-    switch (bindingType()) {
-      case PROVISION:
-        return RequestKind.PROVIDER;
-
-      case PRODUCTION:
-        return RequestKind.PRODUCER;
-
-      default:
-        throw new AssertionError(bindingType());
-    }
-  }
-
-  /** The framework class to use for these requests. */
+  /** The framework class to use for this dependency. */
   final Class<?> frameworkClass() {
-    return bindingType().frameworkClass();
+    return frameworkType().frameworkClass();
   }
 
   /** Returns a new instance with the given key and type. */
-  static FrameworkDependency create(Key key, BindingType bindingType) {
-    return new AutoValue_FrameworkDependency(key, bindingType);
+  static FrameworkDependency create(Key key, FrameworkType frameworkType) {
+    return new AutoValue_FrameworkDependency(key, frameworkType);
   }
 }
diff --git a/java/dagger/internal/codegen/FrameworkField.java b/java/dagger/internal/codegen/FrameworkField.java
index fdb9f6e59..c04dcf11f 100644
--- a/java/dagger/internal/codegen/FrameworkField.java
+++ b/java/dagger/internal/codegen/FrameworkField.java
@@ -69,24 +69,17 @@ static FrameworkField create(
   static FrameworkField forResolvedBindings(
       ResolvedBindings resolvedBindings, Optional<ClassName> frameworkClass) {
     return create(
-        frameworkClass.orElse(ClassName.get(resolvedBindings.frameworkClass())),
+        frameworkClass.orElse(
+            ClassName.get(
+                FrameworkType.forBindingType(resolvedBindings.bindingType()).frameworkClass())),
         TypeName.get(fieldValueType(resolvedBindings)),
         frameworkFieldName(resolvedBindings));
   }
 
   private static TypeMirror fieldValueType(ResolvedBindings resolvedBindings) {
-    if (resolvedBindings.isMultibindingContribution()) {
-      switch (resolvedBindings.contributionType()) {
-        case MAP:
-          return MapType.from(resolvedBindings.key())
-              .unwrappedValueType(resolvedBindings.frameworkClass());
-        case SET:
-          return SetType.from(resolvedBindings.key()).elementType();
-        default:
-          // do nothing
-      }
-    }
-    return resolvedBindings.key().type();
+    return resolvedBindings.isMultibindingContribution()
+        ? resolvedBindings.contributionBinding().contributedType()
+        : resolvedBindings.key().type();
   }
 
   private static String frameworkFieldName(ResolvedBindings resolvedBindings) {
diff --git a/java/dagger/internal/codegen/FrameworkInstanceBindingExpression.java b/java/dagger/internal/codegen/FrameworkInstanceBindingExpression.java
index b5016819c..54284a738 100644
--- a/java/dagger/internal/codegen/FrameworkInstanceBindingExpression.java
+++ b/java/dagger/internal/codegen/FrameworkInstanceBindingExpression.java
@@ -22,80 +22,48 @@
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
 import com.squareup.javapoet.FieldSpec;
-import dagger.model.RequestKind;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeMirror;
-import javax.lang.model.util.Elements;
 
-/** A binding expression that uses an instance of a {@link FrameworkType}. */
-final class FrameworkInstanceBindingExpression extends BindingExpression {
+/** A binding expression that uses a {@link FrameworkType} field. */
+abstract class FrameworkInstanceBindingExpression extends BindingExpression {
   private final ResolvedBindings resolvedBindings;
-  private final RequestKind requestKind;
-  private final ComponentBindingExpressions componentBindingExpressions;
   private final FrameworkInstanceSupplier frameworkInstanceSupplier;
-  private final FrameworkType frameworkType;
   private final DaggerTypes types;
-  private final Elements elements;
+  private final DaggerElements elements;
 
   FrameworkInstanceBindingExpression(
       ResolvedBindings resolvedBindings,
-      RequestKind requestKind,
-      ComponentBindingExpressions componentBindingExpressions,
-      FrameworkType frameworkType,
       FrameworkInstanceSupplier frameworkInstanceSupplier,
       DaggerTypes types,
-      Elements elements) {
+      DaggerElements elements) {
     this.resolvedBindings = checkNotNull(resolvedBindings);
-    this.requestKind = checkNotNull(requestKind);
-    this.componentBindingExpressions = checkNotNull(componentBindingExpressions);
-    this.frameworkType = checkNotNull(frameworkType);
     this.frameworkInstanceSupplier = checkNotNull(frameworkInstanceSupplier);
     this.types = checkNotNull(types);
     this.elements = checkNotNull(elements);
   }
 
   /**
-   * The expression for the framework instance for this binding. If the instance comes from a
-   * component field, it will be {@link GeneratedComponentModel#addInitialization(CodeBlock)
-   * initialized} and {@link GeneratedComponentModel#addField(GeneratedComponentModel.FieldSpecKind,
-   * FieldSpec) added} to the component the first time this method is invoked.
+   * The expression for the framework instance for this binding. The field will be {@link
+   * GeneratedComponentModel#addInitialization(CodeBlock) initialized} and {@link
+   * GeneratedComponentModel#addField(GeneratedComponentModel.FieldSpecKind, FieldSpec) added} to
+   * the component the first time this method is invoked.
    */
   @Override
   Expression getDependencyExpression(ClassName requestingClass) {
-    if (requestKind.equals(frameworkRequestKind())) {
-      MemberSelect memberSelect = frameworkInstanceSupplier.memberSelect();
-      TypeMirror contributedType = resolvedBindings.contributionBinding().contributedType();
-      TypeMirror expressionType =
-          frameworkInstanceSupplier.specificType().isPresent()
-                  || isTypeAccessibleFrom(contributedType, requestingClass.packageName())
-                  || isInlinedFactoryCreation(memberSelect)
-              ? types.wrapType(contributedType, resolvedBindings.frameworkClass())
-              : rawFrameworkType();
-      return Expression.create(expressionType, memberSelect.getExpressionFor(requestingClass));
-    }
-
-    // The following expressions form a composite with the expression for the framework type. For
-    // example, the expression for RequestKind.LAZY is a composite of the expression for a
-    // RequestKind.PROVIDER (the framework type):
-    //    lazyExpression = DoubleCheck.lazy(providerExpression);
-    return frameworkType.to(
-        requestKind,
-        componentBindingExpressions.getDependencyExpression(
-            resolvedBindings.key(), frameworkRequestKind(), requestingClass),
-        types);
+    MemberSelect memberSelect = frameworkInstanceSupplier.memberSelect();
+    TypeMirror contributedType = resolvedBindings.contributionBinding().contributedType();
+    TypeMirror expressionType =
+        frameworkInstanceSupplier.specificType().isPresent()
+                || isTypeAccessibleFrom(contributedType, requestingClass.packageName())
+                || isInlinedFactoryCreation(memberSelect)
+            ? types.wrapType(contributedType, frameworkType().frameworkClass())
+            : rawFrameworkType();
+    return Expression.create(expressionType, memberSelect.getExpressionFor(requestingClass));
   }
 
-  /** Returns the request kind that matches the framework type. */
-  private RequestKind frameworkRequestKind() {
-    switch (frameworkType) {
-      case PROVIDER:
-        return RequestKind.PROVIDER;
-      case PRODUCER:
-        return RequestKind.PRODUCER;
-      default:
-        throw new AssertionError(frameworkType);
-    }
-  }
+  /** Returns the framework type for the binding. */
+  protected abstract FrameworkType frameworkType();
 
   /**
    * Returns {@code true} if a factory is created inline each time it is requested. For example, in
@@ -113,7 +81,6 @@ private static boolean isInlinedFactoryCreation(MemberSelect memberSelect) {
   }
 
   private DeclaredType rawFrameworkType() {
-    return types.getDeclaredType(
-        elements.getTypeElement(resolvedBindings.frameworkClass().getCanonicalName()));
+    return types.getDeclaredType(elements.getTypeElement(frameworkType().frameworkClass()));
   }
 }
diff --git a/java/dagger/internal/codegen/FrameworkType.java b/java/dagger/internal/codegen/FrameworkType.java
index f596a0f32..0e279fce7 100644
--- a/java/dagger/internal/codegen/FrameworkType.java
+++ b/java/dagger/internal/codegen/FrameworkType.java
@@ -18,14 +18,15 @@
 
 import static com.google.common.base.CaseFormat.UPPER_CAMEL;
 import static com.google.common.base.CaseFormat.UPPER_UNDERSCORE;
-import static dagger.internal.codegen.RequestKinds.frameworkClass;
 import static dagger.model.RequestKind.INSTANCE;
 
 import com.google.common.util.concurrent.Futures;
 import com.google.common.util.concurrent.ListenableFuture;
+import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.ParameterizedTypeName;
+import com.squareup.javapoet.TypeName;
 import dagger.Lazy;
-import dagger.MembersInjector;
 import dagger.internal.DoubleCheck;
 import dagger.internal.ProviderOfLazy;
 import dagger.model.DependencyRequest;
@@ -33,6 +34,7 @@
 import dagger.producers.Produced;
 import dagger.producers.Producer;
 import dagger.producers.internal.Producers;
+import java.util.Optional;
 import javax.inject.Provider;
 import javax.lang.model.type.TypeMirror;
 
@@ -40,6 +42,16 @@
 enum FrameworkType {
   /** A {@link Provider}. */
   PROVIDER {
+    @Override
+    Class<?> frameworkClass() {
+      return Provider.class;
+    }
+
+    @Override
+    Optional<RequestKind> requestKind() {
+      return Optional.of(RequestKind.PROVIDER);
+    }
+
     @Override
     CodeBlock to(RequestKind requestKind, CodeBlock from) {
       switch (requestKind) {
@@ -90,13 +102,26 @@ Expression to(RequestKind requestKind, Expression from, DaggerTypes types) {
 
         default:
           return Expression.create(
-              types.rewrapType(from.type(), frameworkClass(requestKind).get()), codeBlock);
+              types.rewrapType(from.type(), RequestKinds.frameworkClass(requestKind)), codeBlock);
       }
     }
   },
 
   /** A {@link Producer}. */
-  PRODUCER {
+  PRODUCER_NODE {
+    @Override
+    Class<?> frameworkClass() {
+      // TODO(cgdecker): Replace this with new class for representing internal producer nodes.
+      // Currently the new class is CancellableProducer, but it may be changed to ProducerNode and
+      // made to not implement Producer.
+      return Producer.class;
+    }
+
+    @Override
+    Optional<RequestKind> requestKind() {
+      return Optional.empty();
+    }
+
     @Override
     CodeBlock to(RequestKind requestKind, CodeBlock from) {
       switch (requestKind) {
@@ -121,7 +146,7 @@ Expression to(RequestKind requestKind, Expression from, DaggerTypes types) {
               to(requestKind, from.codeBlock()));
 
         case PRODUCER:
-          return from;
+          return Expression.create(from.type(), to(requestKind, from.codeBlock()));
 
         default:
           throw new IllegalArgumentException(
@@ -129,21 +154,40 @@ Expression to(RequestKind requestKind, Expression from, DaggerTypes types) {
       }
     }
   },
+  ;
 
-  // TODO(ronshapiro): Remove this once MembersInjectionBinding no longer extends Binding
-  /** A {@link MembersInjector}. */
-  MEMBERS_INJECTOR {
-    @Override
-    CodeBlock to(RequestKind requestKind, CodeBlock from) {
-      throw new UnsupportedOperationException(requestKind.toString());
+  /** Returns the framework type appropriate for fields for a given binding type. */
+  static FrameworkType forBindingType(BindingType bindingType) {
+    switch (bindingType) {
+      case PROVISION:
+        return PROVIDER;
+      case PRODUCTION:
+        return PRODUCER_NODE;
+      case MEMBERS_INJECTION:
     }
+    throw new AssertionError(bindingType);
+  }
 
-    @Override
-    Expression to(RequestKind requestKind, Expression from, DaggerTypes types) {
-      throw new UnsupportedOperationException(requestKind.toString());
+  /** Returns the framework type that exactly matches the given request kind, if one exists. */
+  static Optional<FrameworkType> forRequestKind(RequestKind requestKind) {
+    switch (requestKind) {
+      case PROVIDER:
+        return Optional.of(FrameworkType.PROVIDER);
+      default:
+        return Optional.empty();
     }
-  },
-  ;
+  }
+
+  /** The class of fields of this type. */
+  abstract Class<?> frameworkClass();
+
+  /** Returns the {@link #frameworkClass()} parameterized with a type. */
+  ParameterizedTypeName frameworkClassOf(TypeName valueType) {
+    return ParameterizedTypeName.get(ClassName.get(frameworkClass()), valueType);
+  }
+
+  /** The request kind that an instance of this framework type can satisfy directly, if any. */
+  abstract Optional<RequestKind> requestKind();
 
   /**
    * Returns a {@link CodeBlock} that evaluates to a requested object given an expression that
diff --git a/java/dagger/internal/codegen/BindingTypeMapper.java b/java/dagger/internal/codegen/FrameworkTypeMapper.java
similarity index 52%
rename from java/dagger/internal/codegen/BindingTypeMapper.java
rename to java/dagger/internal/codegen/FrameworkTypeMapper.java
index f407cbed3..774669253 100644
--- a/java/dagger/internal/codegen/BindingTypeMapper.java
+++ b/java/dagger/internal/codegen/FrameworkTypeMapper.java
@@ -17,30 +17,30 @@
 package dagger.internal.codegen;
 
 import static com.google.common.collect.Iterables.getOnlyElement;
-import static dagger.internal.codegen.BindingType.CONTRIBUTION_TYPES;
 import static dagger.internal.codegen.BindingType.PRODUCTION;
-import static dagger.internal.codegen.BindingType.PROVISION;
+import static java.util.stream.Collectors.toSet;
 
-import com.google.common.collect.FluentIterable;
-import com.google.common.collect.ImmutableSet;
 import dagger.model.DependencyRequest;
+import dagger.model.Key;
 import dagger.model.RequestKind;
 import dagger.producers.Producer;
+import java.util.Set;
 import javax.inject.Provider;
 
 /**
- * A mapper for associating a {@link RequestKind} to a {@link BindingType}, dependent on the type of
- * code to be generated (e.g., for {@link Provider} or {@link Producer}).
+ * A mapper for associating a {@link RequestKind} to a {@link FrameworkType}, dependent on the type
+ * of code to be generated (e.g., for {@link Provider} or {@link Producer}).
  */
-enum BindingTypeMapper {
+enum FrameworkTypeMapper {
   FOR_PROVIDER() {
-    @Override public BindingType getBindingType(RequestKind requestKind) {
+    @Override
+    public FrameworkType getFrameworkType(RequestKind requestKind) {
       switch (requestKind) {
         case INSTANCE:
         case PROVIDER:
         case PROVIDER_OF_LAZY:
         case LAZY:
-          return PROVISION;
+          return FrameworkType.PROVIDER;
         case PRODUCED:
         case PRODUCER:
           throw new IllegalArgumentException(requestKind.toString());
@@ -50,42 +50,36 @@
     }
   },
   FOR_PRODUCER() {
-    @Override public BindingType getBindingType(RequestKind requestKind) {
+    @Override
+    public FrameworkType getFrameworkType(RequestKind requestKind) {
       switch (requestKind) {
         case INSTANCE:
         case PRODUCED:
         case PRODUCER:
-          return PRODUCTION;
+          return FrameworkType.PRODUCER_NODE;
         case PROVIDER:
         case PROVIDER_OF_LAZY:
         case LAZY:
-          return PROVISION;
+          return FrameworkType.PROVIDER;
         default:
           throw new AssertionError(requestKind);
       }
     }
   };
 
-  static BindingTypeMapper forBindingType(BindingType bindingType) {
+  static FrameworkTypeMapper forBindingType(BindingType bindingType) {
     return bindingType.equals(PRODUCTION) ? FOR_PRODUCER : FOR_PROVIDER;
   }
 
-  abstract BindingType getBindingType(RequestKind requestKind);
+  abstract FrameworkType getFrameworkType(RequestKind requestKind);
 
   /**
-   * Returns the {@link BindingType} to use for a collection of requests of the same {@link
-   * dagger.model.Key}. This allows factories to only take a single argument for multiple requests
-   * of the same key.
+   * Returns the {@link FrameworkType} to use for a collection of requests of the same {@link Key}.
+   * This allows factories to only take a single argument for multiple requests of the same key.
    */
-  BindingType getBindingType(Iterable<DependencyRequest> requests) {
-    ImmutableSet<BindingType> classes =
-        FluentIterable.from(requests).transform(request -> getBindingType(request.kind())).toSet();
-    if (classes.size() == 1) {
-      return getOnlyElement(classes);
-    } else if (classes.equals(CONTRIBUTION_TYPES)) {
-      return PROVISION;
-    } else {
-      throw new IllegalArgumentException("Bad set of framework classes: " + classes);
-    }
+  FrameworkType getFrameworkType(Set<DependencyRequest> requests) {
+    Set<FrameworkType> frameworkTypes =
+        requests.stream().map(request -> getFrameworkType(request.kind())).collect(toSet());
+    return frameworkTypes.size() == 1 ? getOnlyElement(frameworkTypes) : FrameworkType.PROVIDER;
   }
 }
diff --git a/java/dagger/internal/codegen/ComponentBuilder.java b/java/dagger/internal/codegen/GeneratedComponentBuilderModel.java
similarity index 83%
rename from java/dagger/internal/codegen/ComponentBuilder.java
rename to java/dagger/internal/codegen/GeneratedComponentBuilderModel.java
index 519fd3742..5aadda60b 100644
--- a/java/dagger/internal/codegen/ComponentBuilder.java
+++ b/java/dagger/internal/codegen/GeneratedComponentBuilderModel.java
@@ -49,12 +49,12 @@
 import javax.lang.model.util.Types;
 
 /** Models the generated code for a component builder. */
-final class ComponentBuilder {
+final class GeneratedComponentBuilderModel {
   private final TypeSpec typeSpec;
   private final ClassName name;
   private final ImmutableMap<ComponentRequirement, FieldSpec> builderFields;
 
-  private ComponentBuilder(
+  private GeneratedComponentBuilderModel(
       TypeSpec typeSpec,
       ClassName name,
       ImmutableMap<ComponentRequirement, FieldSpec> builderFields) {
@@ -75,15 +75,13 @@ ClassName name() {
     return builderFields;
   }
 
-  static Optional<ComponentBuilder> create(
-      ClassName componentName,
+  static Optional<GeneratedComponentBuilderModel> create(
+      GeneratedComponentModel generatedComponentModel,
       BindingGraph graph,
-      SubcomponentNames subcomponentNames,
       Elements elements,
       Types types) {
     return hasBuilder(graph.componentDescriptor())
-        ? Optional.of(
-            new Creator(componentName, graph, subcomponentNames, elements, types).create())
+        ? Optional.of(new Creator(generatedComponentModel, graph, elements, types).create())
         : Optional.empty();
   }
 
@@ -97,51 +95,64 @@ private static boolean hasBuilder(ComponentDescriptor component) {
             + "no-op. For more, see https://google.github.io/dagger/unused-modules.\n";
     private final BindingGraph graph;
     private final TypeSpec.Builder builder;
-    private final ClassName componentName;
-    private final ClassName builderName;
+    private final GeneratedComponentModel generatedComponentModel;
     private final Elements elements;
     private final Types types;
-    private ImmutableMap<ComponentRequirement, FieldSpec> builderFields;
 
     Creator(
-        ClassName componentName,
+        GeneratedComponentModel generatedComponentModel,
         BindingGraph graph,
-        SubcomponentNames subcomponentNames,
         Elements elements,
         Types types) {
-      this.componentName = componentName;
-      if (graph.componentDescriptor().kind().isTopLevel()) {
-        builderName = componentName.nestedClass("Builder");
-        builder = classBuilder(builderName).addModifiers(STATIC);
-      } else {
-        builderName =
-            componentName.peerClass(subcomponentNames.get(graph.componentDescriptor()) + "Builder");
-        builder = classBuilder(builderName);
-      }
+      this.generatedComponentModel = generatedComponentModel;
+      this.builder = classBuilder(generatedComponentModel.getBuilderName());
       this.graph = graph;
       this.elements = elements;
       this.types = types;
     }
 
-    ComponentBuilder create() {
+    GeneratedComponentBuilderModel create() {
+      if (!generatedComponentModel.isNested()) {
+        builder.addModifiers(STATIC);
+      }
       if (builderSpec().isPresent()) {
-        builder.addModifiers(PRIVATE);
-        addSupertype(builder, builderSpec().get().builderDefinitionType());
+        if (generatedComponentModel.isAbstract()) {
+          builder.addModifiers(PUBLIC);
+        } else {
+          builder.addModifiers(PRIVATE);
+        }
+        setSupertype();
       } else {
         builder.addModifiers(PUBLIC).addMethod(constructorBuilder().addModifiers(PRIVATE).build());
       }
 
-      builderFields = builderFields(graph);
+      ImmutableMap<ComponentRequirement, FieldSpec> builderFields = builderFields(graph);
+
+      if (generatedComponentModel.isAbstract()) {
+        builder.addModifiers(ABSTRACT);
+      } else {
+        builder.addModifiers(FINAL);
+        builder.addMethod(buildMethod(builderFields)); // Can only instantiate concrete classes.
+      }
 
       builder
-          .addModifiers(FINAL)
           .addFields(builderFields.values())
-          .addMethod(buildMethod())
           // TODO(ronshapiro): this should be switched with buildMethod(), but that currently breaks
           // compile-testing tests that rely on the order of the methods
-          .addMethods(builderMethods());
+          .addMethods(builderMethods(builderFields));
+
+      return new GeneratedComponentBuilderModel(
+          builder.build(), generatedComponentModel.getBuilderName(), builderFields);
+    }
 
-      return new ComponentBuilder(builder.build(), builderName, builderFields);
+    /** Set the superclass being extended or interface being implemented for this builder. */
+    private void setSupertype() {
+      if (generatedComponentModel.supermodel().isPresent()) {
+        // If there's a superclass, extend the Builder defined there.
+        builder.superclass(generatedComponentModel.supermodel().get().getBuilderName());
+      } else {
+        addSupertype(builder, builderSpec().get().builderDefinitionType());
+      }
     }
 
     /**
@@ -160,7 +171,7 @@ ComponentBuilder create() {
       return builderFields.build();
     }
 
-    private MethodSpec buildMethod() {
+    private MethodSpec buildMethod(ImmutableMap<ComponentRequirement, FieldSpec> builderFields) {
       MethodSpec.Builder buildMethod;
       if (builderSpec().isPresent()) {
         ExecutableElement specBuildMethod = builderSpec().get().buildMethod();
@@ -195,7 +206,7 @@ private MethodSpec buildMethod() {
                 throw new AssertionError(requirement);
             }
           });
-      buildMethod.addStatement("return new $T(this)", componentName);
+      buildMethod.addStatement("return new $T(this)", generatedComponentModel.name());
       return buildMethod.build();
     }
 
@@ -203,7 +214,8 @@ private MethodSpec buildMethod() {
      * Computes the methods that set each of parameters on the builder. If the {@link BuilderSpec}
      * is present, it will tailor the methods to match the spec.
      */
-    private ImmutableSet<MethodSpec> builderMethods() {
+    private ImmutableSet<MethodSpec> builderMethods(
+        ImmutableMap<ComponentRequirement, FieldSpec> builderFields) {
       ImmutableSet<ComponentRequirement> componentRequirements = graph.componentRequirements();
       ImmutableSet.Builder<MethodSpec> methods = ImmutableSet.builder();
       if (builderSpec().isPresent()) {
@@ -251,11 +263,12 @@ private MethodSpec buildMethod() {
           methods.add(builderMethod.build());
         }
       } else {
-        for (ComponentRequirement componentRequirement : graph.availableDependencies()) {
+        for (ComponentRequirement componentRequirement :
+            graph.componentDescriptor().availableDependencies()) {
           String componentRequirementName = simpleVariableName(componentRequirement.typeElement());
           MethodSpec.Builder builderMethod =
               methodBuilder(componentRequirementName)
-                  .returns(builderName)
+                  .returns(generatedComponentModel.getBuilderName())
                   .addModifiers(PUBLIC)
                   .addParameter(
                       TypeName.get(componentRequirement.type()), componentRequirementName);
@@ -288,7 +301,7 @@ private MethodSpec buildMethod() {
       // Otherwise we use the generated builder name and take advantage of covariant returns
       // (so that we don't have to worry about setter methods that return type variables).
       if (!returnType.getKind().equals(VOID)) {
-        builderMethod.returns(builderName);
+        builderMethod.returns(generatedComponentModel.getBuilderName());
       }
       return builderMethod;
     }
diff --git a/java/dagger/internal/codegen/GeneratedComponentModel.java b/java/dagger/internal/codegen/GeneratedComponentModel.java
index 8f8dde15c..3ee1ecb84 100644
--- a/java/dagger/internal/codegen/GeneratedComponentModel.java
+++ b/java/dagger/internal/codegen/GeneratedComponentModel.java
@@ -16,26 +16,47 @@
 
 package dagger.internal.codegen;
 
+import static com.google.common.base.CaseFormat.LOWER_CAMEL;
+import static com.google.common.base.CaseFormat.UPPER_CAMEL;
+import static com.google.common.base.CaseFormat.UPPER_UNDERSCORE;
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.base.Preconditions.checkState;
 import static com.squareup.javapoet.TypeSpec.classBuilder;
 import static dagger.internal.codegen.Accessibility.isTypeAccessibleFrom;
+import static dagger.internal.codegen.SourceFiles.simpleVariableName;
+import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.PUBLIC;
 
+import com.google.auto.common.MoreTypes;
 import com.google.common.base.Supplier;
+import com.google.common.collect.HashMultimap;
 import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ListMultimap;
 import com.google.common.collect.MultimapBuilder;
+import com.google.common.collect.SetMultimap;
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
 import com.squareup.javapoet.FieldSpec;
 import com.squareup.javapoet.MethodSpec;
 import com.squareup.javapoet.TypeSpec;
 import dagger.internal.ReferenceReleasingProviderManager;
+import dagger.internal.codegen.ModifiableBindingMethods.ModifiableBindingMethod;
+import dagger.model.DependencyRequest;
+import dagger.model.Key;
+import dagger.model.RequestKind;
+import dagger.producers.internal.CancellationListener;
 import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.HashMap;
 import java.util.List;
+import java.util.Map;
+import java.util.Optional;
 import javax.lang.model.element.Modifier;
-import javax.lang.model.element.Name;
+import javax.lang.model.element.NestingKind;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.TypeMirror;
 
@@ -43,8 +64,8 @@
 final class GeneratedComponentModel {
   /** A type of field that this component model can generate. */
   // TODO(user, dpb): Move component requirements and reference managers to top? The order should
-  // be component requirements, referencemanagers, framework fields, private method fields, ... etc
-  static enum FieldSpecKind {
+  // be component requirements, reference managers, framework fields, private method fields, ... etc
+  enum FieldSpecKind {
 
     /**
      * A field for the lock and cached value for {@linkplain PrivateMethodBindingExpression
@@ -68,14 +89,14 @@
   /** A type of method that this component model can generate. */
   // TODO(user, dpb): Change the oder to constructor, initialize, component, then private
   // (including MIM and AOM—why treat those separately?).
-  static enum MethodSpecKind {
+  enum MethodSpecKind {
     /** The component constructor. */
     CONSTRUCTOR,
 
     /** A builder method for the component. (Only used by the root component.) */
     BUILDER_METHOD,
 
-    /** A private method that wraps depenency expressions. */
+    /** A private method that wraps dependency expressions. */
     PRIVATE_METHOD,
 
     /** An initialization method that initializes component requirements and framework types. */
@@ -88,11 +109,25 @@
     MEMBERS_INJECTION_METHOD,
 
     /** A static method that always returns an absent {@code Optional} value for the binding. */
-    ABSENT_OPTIONAL_METHOD
+    ABSENT_OPTIONAL_METHOD,
+
+    /**
+     * A method that encapsulates a modifiable binding. A binding is modifiable if it can change
+     * across implementations of a subcomponent. This is only relevant for ahead-of-time
+     * subcomponents.
+     */
+    MODIFIABLE_BINDING_METHOD,
+
+    /**
+     * The {@link CancellationListener#onProducerFutureCancelled(boolean)} method for a production
+     * component.
+     */
+    CANCELLATION_LISTENER_METHOD,
+    ;
   }
 
   /** A type of nested class that this component model can generate. */
-  static enum TypeSpecKind {
+  enum TypeSpecKind {
     /** A factory class for a present optional binding. */
     PRESENT_FACTORY,
 
@@ -106,11 +141,18 @@
     SUBCOMPONENT
   }
 
+  private final ComponentDescriptor componentDescriptor;
   private final ClassName name;
+  private final NestingKind nestingKind;
+  private final boolean isAbstract;
+  private final Optional<GeneratedComponentModel> supermodel;
+  private final Map<TypeElement, GeneratedComponentModel> subcomponentModels = new HashMap<>();
   private final TypeSpec.Builder component;
+  private final SubcomponentNames subcomponentNames;
   private final UniqueNameSet componentFieldNames = new UniqueNameSet();
   private final UniqueNameSet componentMethodNames = new UniqueNameSet();
   private final List<CodeBlock> initializations = new ArrayList<>();
+  private final List<CodeBlock> cancellations = new ArrayList<>();
   private final ListMultimap<FieldSpecKind, FieldSpec> fieldSpecsMap =
       MultimapBuilder.enumKeys(FieldSpecKind.class).arrayListValues().build();
   private final ListMultimap<MethodSpecKind, MethodSpec> methodSpecsMap =
@@ -118,18 +160,93 @@
   private final ListMultimap<TypeSpecKind, TypeSpec> typeSpecsMap =
       MultimapBuilder.enumKeys(TypeSpecKind.class).arrayListValues().build();
   private final List<Supplier<TypeSpec>> switchingProviderSupplier = new ArrayList<>();
-
-  private GeneratedComponentModel(ClassName name, Modifier... modifiers) {
+  private final ModifiableBindingMethods modifiableBindingMethods = new ModifiableBindingMethods();
+  private final SetMultimap<Key, DependencyRequest> contributionsByMultibinding =
+      HashMultimap.create();
+
+  private GeneratedComponentModel(
+      ComponentDescriptor componentDescriptor,
+      ClassName name,
+      NestingKind nestingKind,
+      Optional<GeneratedComponentModel> supermodel,
+      SubcomponentNames subcomponentNames,
+      Modifier... modifiers) {
+    checkName(name, nestingKind);
+    this.componentDescriptor = componentDescriptor;
     this.name = name;
+    this.nestingKind = nestingKind;
+    this.isAbstract = Arrays.asList(modifiers).contains(ABSTRACT);
+    this.supermodel = supermodel;
     this.component = classBuilder(name).addModifiers(modifiers);
+    this.subcomponentNames = subcomponentNames;
   }
 
-  static GeneratedComponentModel forComponent(ClassName name) {
-    return new GeneratedComponentModel(name, PUBLIC, FINAL);
+  private static void checkName(ClassName name, NestingKind nestingKind) {
+    switch (nestingKind) {
+      case TOP_LEVEL:
+        checkArgument(
+            name.enclosingClassName() == null, "must be a top-level class name: %s", name);
+        break;
+
+      case MEMBER:
+        checkNotNull(name.enclosingClassName(), "must not be a top-level class name: %s", name);
+        break;
+
+      default:
+        throw new IllegalArgumentException(
+            "nestingKind must be TOP_LEVEL or MEMBER: " + nestingKind);
+    }
   }
 
-  static GeneratedComponentModel forSubcomponent(ClassName name) {
-    return new GeneratedComponentModel(name, PRIVATE, FINAL);
+  /** Creates a model for a root component or top-level abstract subcomponent. */
+  static GeneratedComponentModel create(ClassName name, BindingGraph graph, KeyFactory keyFactory) {
+    return new GeneratedComponentModel(
+        graph.componentDescriptor(),
+        name,
+        NestingKind.TOP_LEVEL,
+        Optional.empty(), // supermodel
+        new SubcomponentNames(graph, keyFactory),
+        PUBLIC,
+        graph.componentDescriptor().kind().isTopLevel() ? FINAL : ABSTRACT);
+  }
+
+  /**
+   * Create a model for a subcomponent. This is for concrete subcomponents implementations when not
+   * generating ahead-of-time subcomponents.
+   */
+  static GeneratedComponentModel forSubcomponent(
+      ComponentDescriptor componentDescriptor, GeneratedComponentModel parentModel) {
+    return new GeneratedComponentModel(
+        componentDescriptor,
+        parentModel.getSubcomponentName(componentDescriptor),
+        NestingKind.MEMBER,
+        Optional.empty(), // supermodel
+        parentModel.subcomponentNames,
+        PRIVATE,
+        FINAL);
+  }
+
+  /**
+   * Create a model for an inner abstract implementation of a subcomponent. This is applicable when
+   * generating ahead-of-time subcomponents.
+   */
+  static GeneratedComponentModel forAbstractSubcomponent(
+      ComponentDescriptor componentDescriptor,
+      GeneratedComponentModel supermodel,
+      GeneratedComponentModel parentModel) {
+    return new GeneratedComponentModel(
+        componentDescriptor,
+        parentModel.getSubcomponentName(componentDescriptor),
+        NestingKind.MEMBER,
+        Optional.of(supermodel),
+        parentModel.subcomponentNames,
+        PUBLIC,
+        ABSTRACT);
+  }
+
+  /** Returns the descriptor for the component being generated. */
+  ComponentDescriptor componentDescriptor() {
+    return componentDescriptor;
   }
 
   /** Returns the name of the component. */
@@ -137,6 +254,51 @@ ClassName name() {
     return name;
   }
 
+  /** Returns whether or not the implementation is nested within another class. */
+  boolean isNested() {
+    return nestingKind.isNested();
+  }
+
+  /** Returns whether or not the implementation is abstract. */
+  boolean isAbstract() {
+    return isAbstract;
+  }
+
+  /** Returns the model of this model's superclass. */
+  Optional<GeneratedComponentModel> supermodel() {
+    return supermodel;
+  }
+
+  /**
+   * Returns the name of the builder class for this component. It will be a sibling of this
+   * generated class unless this is a top-level component, in which case it will be nested.
+   */
+  ClassName getBuilderName() {
+    return isNested()
+        ? name.peerClass(subcomponentNames.get(componentDescriptor) + "Builder")
+        : name.nestedClass("Builder");
+  }
+
+  /** Returns the name of the nested implementation class for a child component. */
+  private ClassName getSubcomponentName(ComponentDescriptor childDescriptor) {
+    checkArgument(
+        componentDescriptor.subcomponents().contains(childDescriptor),
+        "%s is not a child of %s",
+        childDescriptor.componentDefinitionType(),
+        componentDescriptor.componentDefinitionType());
+    return name.nestedClass(subcomponentNames.get(childDescriptor) + "Impl");
+  }
+
+  /** Returns the simple subcomponent name for the given subcomponent builder {@link Key}. */
+  String getSubcomponentName(Key key) {
+    return subcomponentNames.get(key);
+  }
+
+  /** Returns the model of the child subcomponent. */
+  Optional<GeneratedComponentModel> subcomponentModel(ComponentDescriptor subcomponent) {
+    return Optional.ofNullable(subcomponentModels.get(subcomponent.componentDefinitionType()));
+  }
+
   /** Returns {@code true} if {@code type} is accessible from the generated component. */
   boolean isTypeAccessible(TypeMirror type) {
     return isTypeAccessibleFrom(type, name.packageName());
@@ -147,6 +309,15 @@ void addSupertype(TypeElement supertype) {
     TypeSpecs.addSupertype(component, supertype);
   }
 
+  /** Adds the given super class to the subcomponent. */
+  void addSuperclass(ClassName className) {
+    checkState(
+        supermodel.isPresent(),
+        "Setting the supertype for model [%s] as a class when model has no supermodel.",
+        name);
+    component.superclass(className);
+  }
+
   // TODO(dpb): Consider taking FieldSpec, and returning identical FieldSpec with unique name?
   /** Adds the given field to the component. */
   void addField(FieldSpecKind fieldKind, FieldSpec fieldSpec) {
@@ -169,6 +340,39 @@ void addMethods(MethodSpecKind methodKind, Iterable<MethodSpec> methodSpecs) {
     methodSpecsMap.putAll(methodKind, methodSpecs);
   }
 
+  /**
+   * Adds the given method to the component. In this case, the method represents an encapsulation of
+   * a modifiable binding between implementations of a subcomponent. This is only relevant for
+   * ahead-of-time subcomponents.
+   */
+  void addModifiableBindingMethod(
+      ModifiableBindingType type,
+      BindingRequest request,
+      MethodSpec methodSpec,
+      boolean finalized) {
+    modifiableBindingMethods.addMethod(type, request, methodSpec, finalized);
+    methodSpecsMap.put(MethodSpecKind.MODIFIABLE_BINDING_METHOD, methodSpec);
+  }
+
+  /**
+   * Registers a known method as encapsulating a modifiable binding without adding the method to the
+   * current component. This is relevant when a method of a different type, such as a component
+   * method, encapsulates a modifiable binding.
+   */
+  void registerModifiableBindingMethod(
+      ModifiableBindingType type,
+      BindingRequest request,
+      MethodSpec methodSpec,
+      boolean finalized) {
+    modifiableBindingMethods.addMethod(type, request, methodSpec, finalized);
+  }
+
+  /** Adds the implementation for the given {@link ModifiableBindingMethod} to the component. */
+  void addImplementedModifiableBindingMethod(ModifiableBindingMethod method) {
+    modifiableBindingMethods.methodImplemented(method);
+    methodSpecsMap.put(MethodSpecKind.MODIFIABLE_BINDING_METHOD, method.methodSpec());
+  }
+
   /** Adds the given type to the component. */
   void addType(TypeSpecKind typeKind, TypeSpec typeSpec) {
     typeSpecsMap.put(typeKind, typeSpec);
@@ -179,6 +383,13 @@ void addTypes(TypeSpecKind typeKind, Iterable<TypeSpec> typeSpecs) {
     typeSpecsMap.putAll(typeKind, typeSpecs);
   }
 
+  /** Adds the type generated from the given subcomponent model. */
+  void addSubcomponent(
+      ComponentDescriptor subcomponent, GeneratedComponentModel subcomponentModel) {
+    subcomponentModels.put(subcomponent.componentDefinitionType(), subcomponentModel);
+    addType(TypeSpecKind.SUBCOMPONENT, subcomponentModel.generate().build());
+  }
+
   /** Adds a {@link Supplier} for the SwitchingProvider for the component. */
   void addSwitchingProvider(Supplier<TypeSpec> typeSpecSupplier) {
     switchingProviderSupplier.add(typeSpecSupplier);
@@ -189,6 +400,11 @@ void addInitialization(CodeBlock codeBlock) {
     initializations.add(codeBlock);
   }
 
+  /** Adds the given code block to the cancellation listener method of the component. */
+  void addCancellation(CodeBlock codeBlock) {
+    cancellations.add(codeBlock);
+  }
+
   /** Returns a new, unique field name for the component based on the given name. */
   String getUniqueFieldName(String name) {
     return componentFieldNames.getUniqueName(name);
@@ -199,8 +415,34 @@ String getUniqueMethodName(String name) {
     return componentMethodNames.getUniqueName(name);
   }
 
+  /** Returns a new, unique method name for a getter method for the given request. */
+  String getUniqueMethodName(BindingRequest request) {
+    return uniqueMethodName(
+        request, simpleVariableName(MoreTypes.asTypeElement(request.key().type())));
+  }
+
+  /**
+   * Returns a new, unique method name for a getter method exposing the given binding for the given
+   * request.
+   */
+  String getUniqueMethodName(BindingRequest request, ContributionBinding binding) {
+    // TODO(user): Use a better name for @MapKey binding instances.
+    // TODO(user): Include the binding method as part of the method name.
+    return uniqueMethodName(request, BindingVariableNamer.name(binding));
+  }
+
+  private String uniqueMethodName(BindingRequest request, String bindingName) {
+    String baseMethodName =
+        "get"
+            + LOWER_CAMEL.to(UPPER_CAMEL, bindingName)
+            + (request.isRequestKind(RequestKind.INSTANCE)
+                ? ""
+                : UPPER_UNDERSCORE.to(UPPER_CAMEL, request.kindName()));
+    return getUniqueMethodName(baseMethodName);
+  }
+
   /** Claims a new method name for the component. Does nothing if method name already exists. */
-  void claimMethodName(Name name) {
+  void claimMethodName(CharSequence name) {
     componentMethodNames.claim(name);
   }
 
@@ -209,6 +451,41 @@ void claimMethodName(Name name) {
     return ImmutableList.copyOf(initializations);
   }
 
+  /** Returns the list of {@link CodeBlock}s that need to go in the cancellation listener method. */
+  ImmutableList<CodeBlock> getCancellations() {
+    return ImmutableList.copyOf(cancellations);
+  }
+
+  /**
+   * Returns the {@link ModifiableBindingMethod}s for this subcomponent implementation and its
+   * superclasses.
+   */
+  ImmutableList<ModifiableBindingMethod> getModifiableBindingMethods() {
+    ImmutableList.Builder<ModifiableBindingMethod> modifiableBindingMethodsBuilder =
+        ImmutableList.builder();
+    if (supermodel.isPresent()) {
+      ImmutableList<ModifiableBindingMethod> superclassModifiableBindingMethods =
+          supermodel.get().getModifiableBindingMethods();
+      superclassModifiableBindingMethods.stream()
+          .filter(method -> !modifiableBindingMethods.finalized(method))
+          .forEach(modifiableBindingMethodsBuilder::add);
+    }
+    modifiableBindingMethodsBuilder.addAll(modifiableBindingMethods.getNonFinalizedMethods());
+    return modifiableBindingMethodsBuilder.build();
+  }
+
+  /**
+   * Returns the {@link ModifiableBindingMethod} for this subcomponent for the given binding, if it
+   * exists.
+   */
+  Optional<ModifiableBindingMethod> getModifiableBindingMethod(BindingRequest request) {
+    Optional<ModifiableBindingMethod> method = modifiableBindingMethods.getMethod(request);
+    if (!method.isPresent() && supermodel.isPresent()) {
+      return supermodel.get().getModifiableBindingMethod(request);
+    }
+    return method;
+  }
+
   /** Generates the component and returns the resulting {@link TypeSpec.Builder}. */
   TypeSpec.Builder generate() {
     fieldSpecsMap.asMap().values().forEach(component::addFields);
@@ -217,4 +494,43 @@ void claimMethodName(Name name) {
     switchingProviderSupplier.stream().map(Supplier::get).forEach(component::addType);
     return component;
   }
+
+  /**
+   * Registers a {@ProvisionBinding} representing a multibinding as having been implemented in this
+   * component. Multibindings are modifiable across subcomponent implementations and this allows us
+   * to know whether a contribution has been made by a superclass implementation. This is only
+   * relevant for ahead-of-time subcomponents.
+   */
+  void registerImplementedMultibinding(ContributionBinding multibinding) {
+    checkArgument(multibinding.isSyntheticMultibinding());
+    // We register a multibinding as implemented each time we request the multibinding expression,
+    // so only modify the set of contributions once.
+    if (!contributionsByMultibinding.containsKey(multibinding.key())) {
+      contributionsByMultibinding.putAll(multibinding.key(), multibinding.dependencies());
+    }
+  }
+
+  /**
+   * Returns the set of multibinding contributions associated with all superclass implementations of
+   * a multibinding.
+   */
+  ImmutableSet<DependencyRequest> superclassContributionsMade(Key key) {
+    ImmutableSet.Builder<DependencyRequest> contributionsBuilder = ImmutableSet.builder();
+    if (supermodel.isPresent()) {
+      contributionsBuilder.addAll(supermodel.get().getAllMultibindingContributions(key));
+    }
+    return contributionsBuilder.build();
+  }
+
+  /**
+   * Returns the set of multibinding contributions associated with all implementations of a
+   * multibinding.
+   */
+  private ImmutableSet<DependencyRequest> getAllMultibindingContributions(Key key) {
+    ImmutableSet.Builder<DependencyRequest> contributionsBuilder = ImmutableSet.builder();
+    if (contributionsByMultibinding.containsKey(key)) {
+      contributionsBuilder.addAll(contributionsByMultibinding.get(key));
+    }
+    return contributionsBuilder.addAll(superclassContributionsMade(key)).build();
+  }
 }
diff --git a/java/dagger/internal/codegen/GeneratedInstanceBindingExpression.java b/java/dagger/internal/codegen/GeneratedInstanceBindingExpression.java
new file mode 100644
index 000000000..a5a99f8a2
--- /dev/null
+++ b/java/dagger/internal/codegen/GeneratedInstanceBindingExpression.java
@@ -0,0 +1,56 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
+import dagger.internal.codegen.ModifiableBindingMethods.ModifiableBindingMethod;
+import java.util.Optional;
+
+/**
+ * An {@link ModifiableAbstractMethodBindingExpression} for a binding that requires an instance of a
+ * generated type. This expression is used in abstract implementations of a subcomponent when there
+ * are no concrete definitions of generated types available. The (unimplemented) method is added to
+ * the {@code GeneratedComponentModel} when this dependency expression is requested. The method is
+ * overridden when generating the concrete implementation of an ancestor component.
+ */
+final class GeneratedInstanceBindingExpression extends ModifiableAbstractMethodBindingExpression {
+  private final GeneratedComponentModel generatedComponentModel;
+  private final ContributionBinding binding;
+  private final BindingRequest request;
+
+  GeneratedInstanceBindingExpression(
+      GeneratedComponentModel generatedComponentModel,
+      ResolvedBindings resolvedBindings,
+      BindingRequest request,
+      Optional<ModifiableBindingMethod> matchingModifiableBindingMethod,
+      Optional<ComponentMethodDescriptor> matchingComponentMethod) {
+    super(
+        generatedComponentModel,
+        ModifiableBindingType.GENERATED_INSTANCE,
+        request,
+        matchingModifiableBindingMethod,
+        matchingComponentMethod);
+    this.generatedComponentModel = generatedComponentModel;
+    this.binding = resolvedBindings.contributionBinding();
+    this.request = request;
+  }
+
+  @Override
+  String chooseMethodName() {
+    return generatedComponentModel.getUniqueMethodName(request, binding);
+  }
+}
diff --git a/java/dagger/internal/codegen/ImmediateFutureBindingExpression.java b/java/dagger/internal/codegen/ImmediateFutureBindingExpression.java
index 661063425..d4e082021 100644
--- a/java/dagger/internal/codegen/ImmediateFutureBindingExpression.java
+++ b/java/dagger/internal/codegen/ImmediateFutureBindingExpression.java
@@ -17,6 +17,7 @@
 package dagger.internal.codegen;
 
 import static com.google.common.base.Preconditions.checkNotNull;
+import static dagger.internal.codegen.BindingRequest.bindingRequest;
 
 import com.google.common.util.concurrent.Futures;
 import com.google.common.util.concurrent.ListenableFuture;
@@ -50,7 +51,7 @@ Expression getDependencyExpression(ClassName requestingClass) {
   private CodeBlock instanceExpression(ClassName requestingClass) {
     Expression expression =
         componentBindingExpressions.getDependencyExpression(
-            key, RequestKind.INSTANCE, requestingClass);
+            bindingRequest(key, RequestKind.INSTANCE), requestingClass);
     // Java 7 type inference is not as strong as in Java 8, and therefore some generated code must
     // cast.
     //
diff --git a/java/dagger/internal/codegen/InaccessibleMapKeyProxyGenerator.java b/java/dagger/internal/codegen/InaccessibleMapKeyProxyGenerator.java
index 0a042332c..878c4ec42 100644
--- a/java/dagger/internal/codegen/InaccessibleMapKeyProxyGenerator.java
+++ b/java/dagger/internal/codegen/InaccessibleMapKeyProxyGenerator.java
@@ -36,12 +36,14 @@
  */
 final class InaccessibleMapKeyProxyGenerator extends SourceFileGenerator<ContributionBinding> {
   private final DaggerTypes types;
+  private final DaggerElements elements;
 
   @Inject
   InaccessibleMapKeyProxyGenerator(
       Filer filer, DaggerTypes types, DaggerElements elements, SourceVersion sourceVersion) {
     super(filer, elements, sourceVersion);
     this.types = types;
+    this.elements = elements;
   }
 
   @Override
@@ -50,13 +52,14 @@ ClassName nameGeneratedType(ContributionBinding binding) {
   }
 
   @Override
-  Optional<? extends Element> getElementForErrorReporting(ContributionBinding binding) {
-    return binding.bindingElement();
+  Element originatingElement(ContributionBinding binding) {
+    // a map key is only ever present on bindings that have a binding element
+    return binding.bindingElement().get();
   }
 
   @Override
   Optional<TypeSpec.Builder> write(ClassName generatedName, ContributionBinding binding) {
-    return MapKeys.mapKeyFactoryMethod(binding, types)
+    return MapKeys.mapKeyFactoryMethod(binding, types, elements)
         .map(
             method ->
                 classBuilder(generatedName)
diff --git a/java/dagger/internal/codegen/IncompatiblyScopedBindingsValidation.java b/java/dagger/internal/codegen/IncompatiblyScopedBindingsValidator.java
similarity index 96%
rename from java/dagger/internal/codegen/IncompatiblyScopedBindingsValidation.java
rename to java/dagger/internal/codegen/IncompatiblyScopedBindingsValidator.java
index 0a1c708ff..17b8c7eb2 100644
--- a/java/dagger/internal/codegen/IncompatiblyScopedBindingsValidation.java
+++ b/java/dagger/internal/codegen/IncompatiblyScopedBindingsValidator.java
@@ -38,12 +38,12 @@
  * Reports an error for any component that uses bindings with scopes that are not assigned to the
  * component.
  */
-final class IncompatiblyScopedBindingsValidation implements BindingGraphPlugin {
+final class IncompatiblyScopedBindingsValidator implements BindingGraphPlugin {
 
   private final MethodSignatureFormatter methodSignatureFormatter;
 
   @Inject
-  IncompatiblyScopedBindingsValidation(MethodSignatureFormatter methodSignatureFormatter) {
+  IncompatiblyScopedBindingsValidator(MethodSignatureFormatter methodSignatureFormatter) {
     this.methodSignatureFormatter = methodSignatureFormatter;
   }
 
diff --git a/java/dagger/internal/codegen/IncorrectlyInstalledBindsMethodsValidator.java b/java/dagger/internal/codegen/IncorrectlyInstalledBindsMethodsValidator.java
new file mode 100644
index 000000000..67d72d0ab
--- /dev/null
+++ b/java/dagger/internal/codegen/IncorrectlyInstalledBindsMethodsValidator.java
@@ -0,0 +1,145 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.base.Preconditions.checkState;
+import static java.util.stream.Collectors.toCollection;
+import static javax.tools.Diagnostic.Kind.WARNING;
+
+import com.google.common.collect.Iterables;
+import com.google.common.collect.MultimapBuilder;
+import com.google.common.collect.SetMultimap;
+import com.google.common.graph.EndpointPair;
+import com.google.common.graph.Graphs;
+import com.google.common.graph.ImmutableGraph;
+import com.google.common.graph.ImmutableNetwork;
+import com.google.common.graph.MutableNetwork;
+import com.google.common.graph.NetworkBuilder;
+import dagger.Binds;
+import dagger.model.BindingGraph;
+import dagger.model.BindingGraph.BindingNode;
+import dagger.model.BindingGraph.DependencyEdge;
+import dagger.model.BindingGraph.Edge;
+import dagger.model.BindingGraph.Node;
+import dagger.model.ComponentPath;
+import dagger.multibindings.IntoSet;
+import dagger.spi.BindingGraphPlugin;
+import dagger.spi.DiagnosticReporter;
+import java.util.LinkedHashSet;
+import java.util.Map.Entry;
+import java.util.Set;
+import javax.inject.Inject;
+import javax.inject.Singleton;
+
+/**
+ * Prints warnings to help users debug <a
+ * href="https://github.com/google/dagger/wiki/Dagger-2.17-@Binds-bugs">the floating {@code @Binds}
+ * bug</a>.
+ */
+@Singleton
+final class IncorrectlyInstalledBindsMethodsValidator implements BindingGraphPlugin {
+  private final SetMultimap<ComponentPath, ContributionBinding> incorrectlyInstalledBindingsCache =
+      MultimapBuilder.hashKeys().linkedHashSetValues().build();
+  private final CompilerOptions compilerOptions;
+
+  @Inject
+  IncorrectlyInstalledBindsMethodsValidator(CompilerOptions compilerOptions) {
+    this.compilerOptions = compilerOptions;
+  }
+
+  @Override
+  public void visitGraph(BindingGraph graph, DiagnosticReporter diagnosticReporter) {
+    checkState(
+        compilerOptions.floatingBindsMethods() || incorrectlyInstalledBindingsCache.isEmpty());
+    for (Entry<ComponentPath, ContributionBinding> entry :
+        incorrectlyInstalledBindingsCache.entries()) {
+      ComponentPath idealComponentPath = entry.getKey();
+      ContributionBinding incorrectlyInstalledBinding = entry.getValue();
+      graph
+          .bindingNodes(incorrectlyInstalledBinding.key())
+          .stream()
+          .filter(bindingNode -> bindingNode.binding().equals(incorrectlyInstalledBinding))
+          .forEach(
+              bindingNode -> report(bindingNode, idealComponentPath, graph, diagnosticReporter));
+    }
+  }
+
+  private void report(
+      BindingNode incompatiblyInstalledBinding,
+      ComponentPath idealComponentPath,
+      BindingGraph graph,
+      DiagnosticReporter diagnosticReporter) {
+    // TODO(dpb): consider creating this once per visitGraph()
+    ImmutableGraph<Node> dependencyGraph = dependencyGraph(graph).asGraph();
+    Set<Node> culpableDependencies =
+        Graphs.reachableNodes(dependencyGraph, incompatiblyInstalledBinding)
+            .stream()
+            .filter(node -> isChild(idealComponentPath, node.componentPath()))
+            .filter(node -> !node.equals(incompatiblyInstalledBinding))
+            .collect(toCollection(LinkedHashSet::new));
+    if (culpableDependencies.isEmpty()) {
+      return;
+    }
+    StringBuilder warning =
+        new StringBuilder()
+            .append("Floating @Binds method detected:\n  ")
+            .append(incompatiblyInstalledBinding)
+            .append("\n  It is installed in:       ")
+            .append(idealComponentPath)
+            .append("\n  But is being resolved in: ")
+            .append(incompatiblyInstalledBinding.componentPath())
+            .append("\n  This is because it depends transitively on:");
+
+    while (!culpableDependencies.isEmpty()) {
+      BindingNode culpableDependency = (BindingNode) Iterables.get(culpableDependencies, 0);
+      warning
+          .append("\n      ")
+          .append(culpableDependency)
+          .append(", resolved in: ")
+          .append(culpableDependency.componentPath());
+      culpableDependencies.removeAll(Graphs.reachableNodes(dependencyGraph, culpableDependency));
+    }
+
+    diagnosticReporter.reportComponent(WARNING, graph.rootComponentNode(), warning.toString());
+  }
+
+  private boolean isChild(ComponentPath possibleParent, ComponentPath possibleChild) {
+    return !possibleParent.equals(possibleChild)
+        && possibleChild.components().containsAll(possibleParent.components());
+  }
+
+  private ImmutableNetwork<Node, Edge> dependencyGraph(BindingGraph graph) {
+    MutableNetwork<Node, Edge> dependencyGraph = NetworkBuilder.from(graph.network()).build();
+    for (DependencyEdge dependencyEdge : graph.dependencyEdges()) {
+      EndpointPair<Node> endpoint = graph.network().incidentNodes(dependencyEdge);
+      dependencyGraph.addEdge(endpoint.source(), endpoint.target(), dependencyEdge);
+    }
+    return ImmutableNetwork.copyOf(dependencyGraph);
+  }
+
+  void recordBinding(ComponentPath componentPath, ContributionBinding binding) {
+    incorrectlyInstalledBindingsCache.put(componentPath, binding);
+  }
+
+  @dagger.Module
+  interface Module {
+    @Binds
+    @IntoSet
+    @Validation
+    BindingGraphPlugin validator(IncorrectlyInstalledBindsMethodsValidator validator);
+  }
+}
diff --git a/java/dagger/internal/codegen/InjectBindingRegistryImpl.java b/java/dagger/internal/codegen/InjectBindingRegistryImpl.java
index add4c7669..b0247e4ef 100644
--- a/java/dagger/internal/codegen/InjectBindingRegistryImpl.java
+++ b/java/dagger/internal/codegen/InjectBindingRegistryImpl.java
@@ -33,6 +33,7 @@
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import com.squareup.javapoet.ClassName;
 import dagger.Component;
+import dagger.MembersInjector;
 import dagger.Provides;
 import dagger.model.Key;
 import java.util.ArrayDeque;
@@ -42,6 +43,7 @@
 import java.util.Set;
 import javax.annotation.processing.Messager;
 import javax.inject.Inject;
+import javax.inject.Provider;
 import javax.inject.Singleton;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
@@ -68,13 +70,13 @@
   private final CompilerOptions compilerOptions;
 
   final class BindingsCollection<B extends Binding> {
-    private final BindingType bindingType;
+    private final Class<?> factoryClass;
     private final Map<Key, B> bindingsByKey = Maps.newLinkedHashMap();
     private final Deque<B> bindingsRequiringGeneration = new ArrayDeque<>();
     private final Set<Key> materializedBindingKeys = Sets.newLinkedHashSet();
-    
-    BindingsCollection(BindingType bindingType) {
-      this.bindingType = bindingType;
+
+    BindingsCollection(Class<?> factoryClass) {
+      this.factoryClass = factoryClass;
     }
 
     void generateBindings(SourceFileGenerator<B> generator) throws SourceFileGenerationException {
@@ -117,7 +119,7 @@ void tryToGenerateBinding(B binding, boolean warnIfNotAlreadyGenerated) {
               String.format(
                   "Generating a %s for %s. "
                       + "Prefer to run the dagger processor over that class instead.",
-                  bindingType.frameworkClass().getSimpleName(),
+                  factoryClass.getSimpleName(),
                   types.erasure(binding.key().type()))); // erasure to strip <T> from msgs.
         }
       }
@@ -147,9 +149,9 @@ private void tryToCacheBinding(B binding) {
   }
 
   private final BindingsCollection<ProvisionBinding> provisionBindings =
-      new BindingsCollection<>(BindingType.PROVISION);
+      new BindingsCollection<>(Provider.class);
   private final BindingsCollection<MembersInjectionBinding> membersInjectionBindings =
-      new BindingsCollection<>(BindingType.MEMBERS_INJECTION);
+      new BindingsCollection<>(MembersInjector.class);
 
   @Inject
   InjectBindingRegistryImpl(
diff --git a/java/dagger/internal/codegen/InjectBindingValidation.java b/java/dagger/internal/codegen/InjectBindingValidator.java
similarity index 89%
rename from java/dagger/internal/codegen/InjectBindingValidation.java
rename to java/dagger/internal/codegen/InjectBindingValidator.java
index 373a37f73..a275bcbe4 100644
--- a/java/dagger/internal/codegen/InjectBindingValidation.java
+++ b/java/dagger/internal/codegen/InjectBindingValidator.java
@@ -28,12 +28,12 @@
 import javax.lang.model.element.TypeElement;
 
 /** Validates bindings from {@code @Inject}-annotated constructors. */
-final class InjectBindingValidation implements BindingGraphPlugin {
+final class InjectBindingValidator implements BindingGraphPlugin {
 
   private final InjectValidator injectValidator;
 
   @Inject
-  InjectBindingValidation(InjectValidator injectValidator) {
+  InjectBindingValidator(InjectValidator injectValidator) {
     this.injectValidator = injectValidator.whenGeneratingCode();
   }
 
@@ -44,16 +44,14 @@ public String pluginName() {
 
   @Override
   public void visitGraph(BindingGraph bindingGraph, DiagnosticReporter diagnosticReporter) {
-    bindingGraph
-        .bindingNodes()
-        .stream()
+    bindingGraph.bindingNodes().stream()
         .filter(node -> node.binding().kind().equals(INJECTION)) // TODO(dpb): Move to BindingGraph
         .forEach(node -> validateInjectionBinding(node, diagnosticReporter));
   }
 
   private void validateInjectionBinding(BindingNode node, DiagnosticReporter diagnosticReporter) {
     ValidationReport<TypeElement> typeReport =
-        injectValidator.validateType(MoreTypes.asTypeElement(node.binding().key().type()));
+        injectValidator.validateType(MoreTypes.asTypeElement(node.key().type()));
     for (Item item : typeReport.allItems()) {
       diagnosticReporter.reportBinding(item.kind(), node, item.message());
     }
diff --git a/java/dagger/internal/codegen/InjectValidator.java b/java/dagger/internal/codegen/InjectValidator.java
index 4d6c89b03..2c83f3730 100644
--- a/java/dagger/internal/codegen/InjectValidator.java
+++ b/java/dagger/internal/codegen/InjectValidator.java
@@ -17,7 +17,6 @@
 package dagger.internal.codegen;
 
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
-import static dagger.internal.codegen.ErrorMessages.provisionMayNotDependOnProducerType;
 import static dagger.internal.codegen.InjectionAnnotations.getQualifiers;
 import static dagger.internal.codegen.InjectionAnnotations.injectedConstructors;
 import static dagger.internal.codegen.Scopes.scopesOf;
@@ -46,6 +45,7 @@
 import javax.lang.model.util.ElementFilter;
 import javax.lang.model.util.Types;
 import javax.tools.Diagnostic;
+import javax.tools.Diagnostic.Kind;
 
 /**
  * A {@linkplain ValidationReport validator} for {@link Inject}-annotated elements and the types
@@ -55,32 +55,45 @@
   private final Types types;
   private final DaggerElements elements;
   private final CompilerOptions compilerOptions;
+  private final DependencyRequestValidator dependencyRequestValidator;
   private final Optional<Diagnostic.Kind> privateAndStaticInjectionDiagnosticKind;
 
   @Inject
-  InjectValidator(Types types, DaggerElements elements, CompilerOptions compilerOptions) {
-    this(types, elements, compilerOptions, Optional.empty());
+  InjectValidator(
+      Types types,
+      DaggerElements elements,
+      DependencyRequestValidator dependencyRequestValidator,
+      CompilerOptions compilerOptions) {
+    this(types, elements, compilerOptions, dependencyRequestValidator, Optional.empty());
   }
 
   private InjectValidator(
       Types types,
       DaggerElements elements,
       CompilerOptions compilerOptions,
-      Optional<Diagnostic.Kind> privateAndStaticInjectionDiagnosticKind) {
+      DependencyRequestValidator dependencyRequestValidator,
+      Optional<Kind> privateAndStaticInjectionDiagnosticKind) {
     this.types = types;
     this.elements = elements;
     this.compilerOptions = compilerOptions;
+    this.dependencyRequestValidator = dependencyRequestValidator;
     this.privateAndStaticInjectionDiagnosticKind = privateAndStaticInjectionDiagnosticKind;
   }
 
   /**
    * Returns a new validator that performs the same validation as this one, but is strict about
-   * rejecting optionally-specified JSR 330 behavior that Dagger doesn't support.
+   * rejecting optionally-specified JSR 330 behavior that Dagger doesn't support (unless {@code
+   * -Adagger.ignorePrivateAndStaticInjectionForComponent=enabled} was set in the javac options).
    */
   InjectValidator whenGeneratingCode() {
     return compilerOptions.ignorePrivateAndStaticInjectionForComponent()
-        ? new InjectValidator(types, elements, compilerOptions, Optional.of(Diagnostic.Kind.ERROR))
-        : this;
+        ? this
+        : new InjectValidator(
+            types,
+            elements,
+            compilerOptions,
+            dependencyRequestValidator,
+            Optional.of(Diagnostic.Kind.ERROR));
   }
 
   ValidationReport<TypeElement> validateConstructor(ExecutableElement constructorElement) {
@@ -106,17 +119,13 @@ InjectValidator whenGeneratingCode() {
     }
 
     for (VariableElement parameter : constructorElement.getParameters()) {
-      checkMultipleQualifiers(constructorElement, parameter, builder);
-      if (FrameworkTypes.isProducerType(parameter.asType())) {
-        builder.addError(provisionMayNotDependOnProducerType(parameter.asType()), parameter);
-      }
+      validateDependencyRequest(builder, parameter);
     }
 
     if (throwsCheckedExceptions(constructorElement)) {
       builder.addItem(
           "Dagger does not support checked exceptions on @Inject constructors",
-          privateAndStaticInjectionDiagnosticKind.orElse(
-              compilerOptions.privateMemberValidationKind()),
+          privateMemberDiagnosticKind(),
           constructorElement);
     }
 
@@ -169,24 +178,18 @@ InjectValidator whenGeneratingCode() {
     if (modifiers.contains(PRIVATE)) {
       builder.addItem(
           "Dagger does not support injection into private fields",
-          privateAndStaticInjectionDiagnosticKind.orElse(
-              compilerOptions.privateMemberValidationKind()),
+          privateMemberDiagnosticKind(),
           fieldElement);
     }
 
     if (modifiers.contains(STATIC)) {
       builder.addItem(
           "Dagger does not support injection into static fields",
-          privateAndStaticInjectionDiagnosticKind.orElse(
-              compilerOptions.staticMemberValidationKind()),
+          staticMemberDiagnosticKind(),
           fieldElement);
     }
 
-    checkMultipleQualifiers(fieldElement, fieldElement, builder);
-
-    if (FrameworkTypes.isProducerType(fieldElement.asType())) {
-      builder.addError(provisionMayNotDependOnProducerType(fieldElement.asType()), fieldElement);
-    }
+    validateDependencyRequest(builder, fieldElement);
 
     return builder.build();
   }
@@ -201,16 +204,14 @@ InjectValidator whenGeneratingCode() {
     if (modifiers.contains(PRIVATE)) {
       builder.addItem(
           "Dagger does not support injection into private methods",
-          privateAndStaticInjectionDiagnosticKind.orElse(
-              compilerOptions.privateMemberValidationKind()),
+          privateMemberDiagnosticKind(),
           methodElement);
     }
 
     if (modifiers.contains(STATIC)) {
       builder.addItem(
           "Dagger does not support injection into static methods",
-          privateAndStaticInjectionDiagnosticKind.orElse(
-              compilerOptions.staticMemberValidationKind()),
+          staticMemberDiagnosticKind(),
           methodElement);
     }
 
@@ -219,15 +220,18 @@ InjectValidator whenGeneratingCode() {
     }
 
     for (VariableElement parameter : methodElement.getParameters()) {
-      checkMultipleQualifiers(methodElement, parameter, builder);
-      if (FrameworkTypes.isProducerType(parameter.asType())) {
-        builder.addError(provisionMayNotDependOnProducerType(parameter.asType()), parameter);
-      }
+      validateDependencyRequest(builder, parameter);
     }
 
     return builder.build();
   }
 
+  private void validateDependencyRequest(
+      ValidationReport.Builder<?> builder, VariableElement parameter) {
+    dependencyRequestValidator.validateDependencyRequest(builder, parameter, parameter.asType());
+    dependencyRequestValidator.checkNotProducer(builder, parameter);
+  }
+
   ValidationReport<TypeElement> validateMembersInjectionType(TypeElement typeElement) {
     // TODO(beder): This element might not be currently compiled, so this error message could be
     // left in limbo. Find an appropriate way to display the error message in that case.
@@ -304,30 +308,23 @@ private boolean throwsCheckedExceptions(ExecutableElement methodElement) {
     return false;
   }
 
-  // TODO(dpb,ronshapiro): Use this on AnyBindingMethodValidator, or a DependencyRequestValidator.
-  // Currently, @Provides and @Produces methods with multiple qualifiers on a dependency will crash
-  // the compiler.
-  private void checkMultipleQualifiers(
-      Element errorElement, Element qualifiedElement, ValidationReport.Builder<?> builder) {
-    ImmutableSet<? extends AnnotationMirror> qualifiers = getQualifiers(qualifiedElement);
-    if (qualifiers.size() > 1) {
-      for (AnnotationMirror qualifier : qualifiers) {
-        builder.addError(
-            "A single injection site may not use more than one @Qualifier",
-            errorElement,
-            qualifier);
-      }
-    }
-  }
-
   private void checkInjectIntoPrivateClass(Element element, Builder<TypeElement> builder) {
     if (!Accessibility.isElementAccessibleFromOwnPackage(
         DaggerElements.closestEnclosingTypeElement(element))) {
       builder.addItem(
           "Dagger does not support injection into private classes",
-          privateAndStaticInjectionDiagnosticKind.orElse(
-              compilerOptions.privateMemberValidationKind()),
+          privateMemberDiagnosticKind(),
           element);
     }
   }
+
+  private Diagnostic.Kind privateMemberDiagnosticKind() {
+    return privateAndStaticInjectionDiagnosticKind.orElse(
+        compilerOptions.privateMemberValidationKind());
+  }
+
+  private Diagnostic.Kind staticMemberDiagnosticKind() {
+    return privateAndStaticInjectionDiagnosticKind.orElse(
+        compilerOptions.staticMemberValidationKind());
+  }
 }
diff --git a/java/dagger/internal/codegen/InjectionOrProvisionProviderCreationExpression.java b/java/dagger/internal/codegen/InjectionOrProvisionProviderCreationExpression.java
index f80c0831e..a2ba0e0c4 100644
--- a/java/dagger/internal/codegen/InjectionOrProvisionProviderCreationExpression.java
+++ b/java/dagger/internal/codegen/InjectionOrProvisionProviderCreationExpression.java
@@ -24,11 +24,11 @@
 import com.squareup.javapoet.TypeName;
 import dagger.internal.codegen.FrameworkFieldInitializer.FrameworkInstanceCreationExpression;
 import java.util.Optional;
+import javax.inject.Provider;
 
 /**
- * A {@link javax.inject.Provider} creation expression for an {@link
- * javax.inject.Inject @Inject}-constructed class or a {@link dagger.Provides @Provides}-annotated
- * module method.
+ * A {@link Provider} creation expression for an {@link javax.inject.Inject @Inject}-constructed
+ * class or a {@link dagger.Provides @Provides}-annotated module method.
  */
 // TODO(dpb): Resolve with ProducerCreationExpression.
 final class InjectionOrProvisionProviderCreationExpression
@@ -56,7 +56,7 @@ public CodeBlock creationExpression() {
     if (binding.kind().equals(INJECTION)
         && binding.unresolved().isPresent()
         && binding.scope().isPresent()) {
-      return CodeBlocks.cast(createFactory, binding.bindingType().frameworkClass());
+      return CodeBlocks.cast(createFactory, Provider.class);
     } else {
       return createFactory;
     }
diff --git a/java/dagger/internal/codegen/InnerSwitchingProviders.java b/java/dagger/internal/codegen/InnerSwitchingProviders.java
index c3c590e3f..388d315f0 100644
--- a/java/dagger/internal/codegen/InnerSwitchingProviders.java
+++ b/java/dagger/internal/codegen/InnerSwitchingProviders.java
@@ -17,6 +17,7 @@
 package dagger.internal.codegen;
 
 import static com.squareup.javapoet.MethodSpec.constructorBuilder;
+import static dagger.internal.codegen.BindingRequest.bindingRequest;
 import static dagger.model.RequestKind.INSTANCE;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
@@ -97,7 +98,7 @@ public Expression getProviderExpression(ClassName switchType, int switchId) {
     @Override
     public Expression getReturnExpression() {
       return componentBindingExpressions.getDependencyExpression(
-          binding.key(), INSTANCE, requestingClass);
+          bindingRequest(binding.key(), INSTANCE), requestingClass);
     }
   }
 }
diff --git a/java/dagger/internal/codegen/KeyFactory.java b/java/dagger/internal/codegen/KeyFactory.java
index 5f8650be5..645c2193e 100644
--- a/java/dagger/internal/codegen/KeyFactory.java
+++ b/java/dagger/internal/codegen/KeyFactory.java
@@ -64,15 +64,14 @@
 import javax.lang.model.type.ExecutableType;
 import javax.lang.model.type.PrimitiveType;
 import javax.lang.model.type.TypeMirror;
-import javax.lang.model.util.Elements;
 
 /** A factory for {@link Key}s. */
 final class KeyFactory {
   private final DaggerTypes types;
-  private final Elements elements;
+  private final DaggerElements elements;
 
   @Inject
-  KeyFactory(DaggerTypes types, Elements elements) {
+  KeyFactory(DaggerTypes types, DaggerElements elements) {
     this.types = checkNotNull(types);
     this.elements = checkNotNull(elements);
   }
@@ -192,20 +191,17 @@ private Key forBindingMethod(
   /**
    * Returns the key for a {@link Multibinds @Multibinds} method.
    *
-   * <p>The key's type is either {@code Set<T>} or {@code Map<K, F<V>>}, where {@code F} is either
-   * {@link Provider} or {@link Producer}, depending on {@code bindingType}.
+   * <p>The key's type is either {@code Set<T>} or {@code Map<K, Provider<V>>}. The latter works
+   * even for maps used by {@code Producer}s.
    */
-  Key forMultibindsMethod(
-      BindingType bindingType, ExecutableType executableType, ExecutableElement method) {
+  Key forMultibindsMethod(ExecutableType executableType, ExecutableElement method) {
     checkArgument(method.getKind().equals(METHOD), "%s must be a method", method);
-    TypeElement factoryType =
-        elements.getTypeElement(bindingType.frameworkClass().getCanonicalName());
     TypeMirror returnType = executableType.getReturnType();
     TypeMirror keyType =
         MapType.isMap(returnType)
             ? mapOfFrameworkType(
                 MapType.from(returnType).keyType(),
-                factoryType,
+                elements.getTypeElement(Provider.class),
                 MapType.from(returnType).valueType())
             : returnType;
     return forMethod(method, keyType);
diff --git a/java/dagger/internal/codegen/KytheBindingGraphFactory.java b/java/dagger/internal/codegen/KytheBindingGraphFactory.java
index 894e86fdd..8332e2499 100644
--- a/java/dagger/internal/codegen/KytheBindingGraphFactory.java
+++ b/java/dagger/internal/codegen/KytheBindingGraphFactory.java
@@ -41,11 +41,13 @@
   private final BindingGraphFactory bindingGraphFactory;
 
   @Inject
-  KytheBindingGraphFactory(Types types, Elements elements) {
+  KytheBindingGraphFactory(Types types, Elements elements, CompilerOptions compilerOptions) {
     DaggerElements daggerElements = new DaggerElements(elements, types);
     DaggerTypes daggerTypes = new DaggerTypes(types, daggerElements);
-    this.componentDescriptorFactory = createComponentDescriptorFactory(daggerElements, daggerTypes);
-    this.bindingGraphFactory = createBindingGraphFactory(daggerTypes, daggerElements);
+    this.componentDescriptorFactory =
+        createComponentDescriptorFactory(daggerElements, daggerTypes, compilerOptions);
+    this.bindingGraphFactory =
+        createBindingGraphFactory(daggerTypes, daggerElements, compilerOptions);
   }
 
   /**
@@ -60,8 +62,27 @@
     return Optional.empty();
   }
 
+  /** Creates the {@link CompilerOptions} for use during {@link BindingGraph} construction. */
+  static CompilerOptions createCompilerOptions() {
+    return CompilerOptions.builder()
+        .usesProducers(true)
+        .writeProducerNameInToken(true)
+        .nullableValidationKind(Diagnostic.Kind.NOTE)
+        .privateMemberValidationKind(Diagnostic.Kind.NOTE)
+        .staticMemberValidationKind(Diagnostic.Kind.NOTE)
+        .ignorePrivateAndStaticInjectionForComponent(false)
+        .scopeCycleValidationType(ValidationType.NONE)
+        .warnIfInjectionFactoryNotGeneratedUpstream(false)
+        .fastInit(false)
+        .experimentalAndroidMode2(false)
+        .aheadOfTimeSubcomponents(false)
+        .floatingBindsMethods(false)
+        .build()
+        .validate();
+  }
+
   private static ComponentDescriptor.Factory createComponentDescriptorFactory(
-      DaggerElements elements, DaggerTypes types) {
+      DaggerElements elements, DaggerTypes types, CompilerOptions compilerOptions) {
     KeyFactory keyFactory = new KeyFactory(types, elements);
     DependencyRequestFactory dependencyRequestFactory =
         new DependencyRequestFactory(keyFactory, types);
@@ -85,46 +106,37 @@
             subcomponentDeclarationFactory,
             optionalBindingDeclarationFactory);
     return new ComponentDescriptor.Factory(
-        elements, types, dependencyRequestFactory, moduleDescriptorFactory);
+        elements, types, dependencyRequestFactory, moduleDescriptorFactory, compilerOptions);
   }
 
   private static BindingGraphFactory createBindingGraphFactory(
-      DaggerTypes types, DaggerElements elements) {
+      DaggerTypes types, DaggerElements elements, CompilerOptions compilerOptions) {
     KeyFactory keyFactory = new KeyFactory(types, elements);
-    DependencyRequestFactory dependencyRequestFactory =
-        new DependencyRequestFactory(keyFactory, types);
-    Messager messager = new NullMessager();
-    CompilerOptions compilerOptions =
-        CompilerOptions.builder()
-            .usesProducers(true)
-            .writeProducerNameInToken(true)
-            .nullableValidationKind(Diagnostic.Kind.NOTE)
-            .privateMemberValidationKind(Diagnostic.Kind.NOTE)
-            .staticMemberValidationKind(Diagnostic.Kind.NOTE)
-            .ignorePrivateAndStaticInjectionForComponent(false)
-            .scopeCycleValidationType(ValidationType.NONE)
-            .warnIfInjectionFactoryNotGeneratedUpstream(false)
-            .experimentalAndroidMode(false)
-            .experimentalAndroidMode2(false)
-            .aheadOfTimeComponents(false)
-            .build();
 
     BindingFactory bindingFactory =
-        new BindingFactory(types, elements, keyFactory, dependencyRequestFactory);
-
-    InjectValidator injectMethodValidator = new InjectValidator(types, elements, compilerOptions);
+        new BindingFactory(
+            types, elements, keyFactory, new DependencyRequestFactory(keyFactory, types));
 
     InjectBindingRegistry injectBindingRegistry =
         new InjectBindingRegistryImpl(
             elements,
             types,
-            messager,
-            injectMethodValidator,
+            new NullMessager(),
+            new InjectValidator(
+                types,
+                elements,
+                new DependencyRequestValidator(new MembersInjectionValidator()),
+                compilerOptions),
             keyFactory,
             bindingFactory,
             compilerOptions);
-
-    return new BindingGraphFactory(elements, injectBindingRegistry, keyFactory, bindingFactory);
+    return new BindingGraphFactory(
+        elements,
+        injectBindingRegistry,
+        keyFactory,
+        bindingFactory,
+        new IncorrectlyInstalledBindsMethodsValidator(compilerOptions),
+        compilerOptions);
   }
 
   private static class NullMessager implements Messager {
diff --git a/java/dagger/internal/codegen/META-INF/gradle/incremental.annotation.processors b/java/dagger/internal/codegen/META-INF/gradle/incremental.annotation.processors
new file mode 100644
index 000000000..db550fe97
--- /dev/null
+++ b/java/dagger/internal/codegen/META-INF/gradle/incremental.annotation.processors
@@ -0,0 +1 @@
+dagger.internal.codegen.ComponentProcessor,dynamic
diff --git a/java/dagger/internal/codegen/MapBindingExpression.java b/java/dagger/internal/codegen/MapBindingExpression.java
index 8a1f70360..b5fe89095 100644
--- a/java/dagger/internal/codegen/MapBindingExpression.java
+++ b/java/dagger/internal/codegen/MapBindingExpression.java
@@ -19,6 +19,7 @@
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static dagger.internal.codegen.Accessibility.isTypeAccessibleFrom;
+import static dagger.internal.codegen.BindingRequest.bindingRequest;
 import static dagger.internal.codegen.CodeBlocks.toParametersCodeBlock;
 import static dagger.internal.codegen.MapKeys.getMapKeyExpression;
 import static dagger.model.BindingKind.MULTIBOUND_MAP;
@@ -32,11 +33,12 @@
 import dagger.model.BindingKind;
 import dagger.model.DependencyRequest;
 import java.util.Collections;
+import java.util.Optional;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeMirror;
 
 /** A {@link BindingExpression} for multibound maps. */
-final class MapBindingExpression extends SimpleInvocationBindingExpression {
+final class MapBindingExpression extends MultibindingExpression {
   /** Maximum number of key-value pairs that can be passed to ImmutableMap.of(K, V, K, V, ...). */
   private static final int MAX_IMMUTABLE_MAP_OF_KEY_VALUE_PAIRS = 5;
 
@@ -48,11 +50,12 @@
 
   MapBindingExpression(
       ResolvedBindings resolvedBindings,
+      GeneratedComponentModel generatedComponentModel,
       BindingGraph graph,
       ComponentBindingExpressions componentBindingExpressions,
       DaggerTypes types,
       DaggerElements elements) {
-    super(resolvedBindings);
+    super(resolvedBindings, generatedComponentModel);
     this.binding = (ProvisionBinding) resolvedBindings.contributionBinding();
     BindingKind bindingKind = this.binding.kind();
     checkArgument(bindingKind.equals(MULTIBOUND_MAP), bindingKind);
@@ -66,11 +69,14 @@
   }
 
   @Override
-  Expression getDependencyExpression(ClassName requestingClass) {
+  protected Expression buildDependencyExpression(ClassName requestingClass) {
+    Optional<CodeBlock> superMethodCall = superMethodCall();
     // TODO(ronshapiro): We should also make an ImmutableMap version of MapFactory
     boolean isImmutableMapAvailable = isImmutableMapAvailable();
     // TODO(ronshapiro, gak): Use Maps.immutableEnumMap() if it's available?
-    if (isImmutableMapAvailable && dependencies.size() <= MAX_IMMUTABLE_MAP_OF_KEY_VALUE_PAIRS) {
+    if (isImmutableMapAvailable
+        && dependencies.size() <= MAX_IMMUTABLE_MAP_OF_KEY_VALUE_PAIRS
+        && !superMethodCall.isPresent()) {
       return Expression.create(
           immutableMapType(),
           CodeBlock.builder()
@@ -106,9 +112,12 @@ Expression getDependencyExpression(ClassName requestingClass) {
         } else {
           instantiation.add("newMapBuilder($L)", dependencies.size());
         }
-        for (DependencyRequest dependency : dependencies.keySet()) {
+        for (DependencyRequest dependency : getNewContributions(dependencies.keySet())) {
           instantiation.add(".put($L)", keyAndValueExpression(dependency, requestingClass));
         }
+        if (superMethodCall.isPresent()) {
+          instantiation.add(CodeBlock.of(".putAll($L)", superMethodCall.get()));
+        }
         return Expression.create(
             isImmutableMapAvailable ? immutableMapType() : binding.key().type(),
             instantiation.add(".build()").build());
@@ -124,9 +133,9 @@ private DeclaredType immutableMapType() {
   private CodeBlock keyAndValueExpression(DependencyRequest dependency, ClassName requestingClass) {
     return CodeBlock.of(
         "$L, $L",
-        getMapKeyExpression(dependencies.get(dependency), requestingClass),
+        getMapKeyExpression(dependencies.get(dependency), requestingClass, elements),
         componentBindingExpressions
-            .getDependencyExpression(dependency, requestingClass)
+            .getDependencyExpression(bindingRequest(dependency), requestingClass)
             .codeBlock());
   }
 
diff --git a/java/dagger/internal/codegen/MapFactoryCreationExpression.java b/java/dagger/internal/codegen/MapFactoryCreationExpression.java
index b5804908b..a931d185d 100644
--- a/java/dagger/internal/codegen/MapFactoryCreationExpression.java
+++ b/java/dagger/internal/codegen/MapFactoryCreationExpression.java
@@ -17,6 +17,7 @@
 package dagger.internal.codegen;
 
 import static com.google.common.base.Preconditions.checkNotNull;
+import static dagger.internal.codegen.BindingRequest.bindingRequest;
 import static dagger.internal.codegen.MapKeys.getMapKeyExpression;
 import static dagger.internal.codegen.SourceFiles.mapFactoryClassName;
 
@@ -37,16 +38,19 @@
   private final ComponentBindingExpressions componentBindingExpressions;
   private final BindingGraph graph;
   private final ContributionBinding binding;
+  private final DaggerElements elements;
 
   MapFactoryCreationExpression(
       ContributionBinding binding,
       GeneratedComponentModel generatedComponentModel,
       ComponentBindingExpressions componentBindingExpressions,
-      BindingGraph graph) {
+      BindingGraph graph,
+      DaggerElements elements) {
     this.binding = checkNotNull(binding);
     this.generatedComponentModel = checkNotNull(generatedComponentModel);
     this.componentBindingExpressions = checkNotNull(componentBindingExpressions);
     this.graph = checkNotNull(graph);
+    this.elements = checkNotNull(elements);
   }
 
   @Override
@@ -80,11 +84,12 @@ public CodeBlock creationExpression() {
           graph.contributionBindings().get(frameworkDependency.key()).contributionBinding();
       CodeBlock value =
           componentBindingExpressions
-              .getDependencyExpression(frameworkDependency, generatedComponentModel.name())
+              .getDependencyExpression(
+                  bindingRequest(frameworkDependency), generatedComponentModel.name())
               .codeBlock();
       builder.add(
           ".put($L, $L)",
-          getMapKeyExpression(contributionBinding, generatedComponentModel.name()),
+          getMapKeyExpression(contributionBinding, generatedComponentModel.name(), elements),
           useRawType ? CodeBlocks.cast(value, frameworkDependency.frameworkClass()) : value);
     }
     builder.add(".build()");
diff --git a/java/dagger/internal/codegen/MapKeys.java b/java/dagger/internal/codegen/MapKeys.java
index 59dea8660..af0e98ea1 100644
--- a/java/dagger/internal/codegen/MapKeys.java
+++ b/java/dagger/internal/codegen/MapKeys.java
@@ -42,6 +42,7 @@
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ElementKind;
 import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.ArrayType;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.PrimitiveType;
@@ -145,11 +146,12 @@ public DeclaredType visitDeclared(DeclaredType t, Void p) {
    * @throws IllegalStateException if {@code binding} is not a {@link dagger.multibindings.IntoMap
    *     map} contribution.
    */
-  static CodeBlock getMapKeyExpression(ContributionBinding binding, ClassName requestingClass) {
+  static CodeBlock getMapKeyExpression(
+      ContributionBinding binding, ClassName requestingClass, DaggerElements elements) {
     AnnotationMirror mapKeyAnnotation = binding.mapKeyAnnotation().get();
     return MapKeyAccessibility.isMapKeyAccessibleFrom(
             mapKeyAnnotation, requestingClass.packageName())
-        ? directMapKeyExpression(mapKeyAnnotation)
+        ? directMapKeyExpression(mapKeyAnnotation, elements)
         : CodeBlock.of("$T.create()", mapKeyProxyClassName(binding));
   }
 
@@ -157,17 +159,30 @@ static CodeBlock getMapKeyExpression(ContributionBinding binding, ClassName requ
    * Returns a code block for the map key annotation {@code mapKey}.
    *
    * <p>This method assumes the map key will be accessible in the context that the returned {@link
-   * CodeBlock} is used. Use {@link #getMapKeyExpression(ContributionBinding, ClassName)} when that
-   * assumption is not guaranteed.
+   * CodeBlock} is used. Use {@link #getMapKeyExpression(ContributionBinding, ClassName,
+   * DaggerElements)} when that assumption is not guaranteed.
    *
    * @throws IllegalArgumentException if the element is annotated with more than one {@code MapKey}
    *     annotation
    * @throws IllegalStateException if {@code bindingElement} is not annotated with a {@code MapKey}
    *     annotation
    */
-  private static CodeBlock directMapKeyExpression(AnnotationMirror mapKey) {
+  private static CodeBlock directMapKeyExpression(
+      AnnotationMirror mapKey, DaggerElements elements) {
     Optional<? extends AnnotationValue> unwrappedValue = unwrapValue(mapKey);
     AnnotationExpression annotationExpression = new AnnotationExpression(mapKey);
+
+    if (MoreTypes.asTypeElement(mapKey.getAnnotationType())
+        .getQualifiedName()
+        .contentEquals("dagger.android.AndroidInjectionKey")) {
+      TypeElement unwrappedType =
+          elements.checkTypePresent((String) unwrappedValue.get().getValue());
+      return CodeBlock.of(
+          "$T.of($S)",
+          ClassName.get("dagger.android.internal", "AndroidInjectionKeys"),
+          ClassName.get(unwrappedType).reflectionName());
+    }
+
     if (unwrappedValue.isPresent()) {
       TypeMirror unwrappedValueType =
           getOnlyElement(getAnnotationValuesWithDefaults(mapKey).keySet()).getReturnType();
@@ -178,8 +193,8 @@ private static CodeBlock directMapKeyExpression(AnnotationMirror mapKey) {
   }
 
   /**
-   * Returns the {@link ClassName} in which {@link #mapKeyFactoryMethod(ContributionBinding, Types)}
-   * is generated.
+   * Returns the {@link ClassName} in which {@link #mapKeyFactoryMethod(ContributionBinding, Types,
+   * DaggerElements)} is generated.
    */
   static ClassName mapKeyProxyClassName(ContributionBinding binding) {
     return elementBasedClassName(
@@ -191,7 +206,8 @@ static ClassName mapKeyProxyClassName(ContributionBinding binding) {
    * #mapKeyProxyClassName(ContributionBinding)} when the {@code @MapKey} annotation is not publicly
    * accessible.
    */
-  static Optional<MethodSpec> mapKeyFactoryMethod(ContributionBinding binding, Types types) {
+  static Optional<MethodSpec> mapKeyFactoryMethod(
+      ContributionBinding binding, Types types, DaggerElements elements) {
     return binding
         .mapKeyAnnotation()
         .filter(mapKey -> !isMapKeyPubliclyAccessible(mapKey))
@@ -200,7 +216,7 @@ static ClassName mapKeyProxyClassName(ContributionBinding binding) {
                 methodBuilder("create")
                     .addModifiers(PUBLIC, STATIC)
                     .returns(TypeName.get(mapKeyType(mapKey, types)))
-                    .addStatement("return $L", directMapKeyExpression(mapKey))
+                    .addStatement("return $L", directMapKeyExpression(mapKey, elements))
                     .build());
   }
 
diff --git a/java/dagger/internal/codegen/MapMultibindingValidation.java b/java/dagger/internal/codegen/MapMultibindingValidator.java
similarity index 93%
rename from java/dagger/internal/codegen/MapMultibindingValidation.java
rename to java/dagger/internal/codegen/MapMultibindingValidator.java
index 0c6893336..f604a8b80 100644
--- a/java/dagger/internal/codegen/MapMultibindingValidation.java
+++ b/java/dagger/internal/codegen/MapMultibindingValidator.java
@@ -41,12 +41,12 @@
  * Reports an error for any map binding with either more than one contribution with the same map key
  * or contributions with inconsistent map key annotation types.
  */
-final class MapMultibindingValidation implements BindingGraphPlugin {
+final class MapMultibindingValidator implements BindingGraphPlugin {
 
   private final BindingDeclarationFormatter bindingDeclarationFormatter;
 
   @Inject
-  MapMultibindingValidation(BindingDeclarationFormatter bindingDeclarationFormatter) {
+  MapMultibindingValidator(BindingDeclarationFormatter bindingDeclarationFormatter) {
     this.bindingDeclarationFormatter = bindingDeclarationFormatter;
   }
 
@@ -70,9 +70,7 @@ public void visitGraph(BindingGraph bindingGraph, DiagnosticReporter diagnosticR
   private ImmutableSet<ContributionBinding> mapBindingContributions(
       BindingNode bindingNode, BindingGraph bindingGraph) {
     checkArgument(bindingNode.binding().kind().equals(MULTIBOUND_MAP));
-    return bindingGraph
-        .successors(bindingNode)
-        .stream()
+    return bindingGraph.network().successors(bindingNode).stream()
         .flatMap(instancesOf(BindingNode.class))
         .map(node -> (ContributionBinding) node.binding())
         .collect(toImmutableSet());
@@ -91,8 +89,7 @@ private void checkForDuplicateMapKeys(
         diagnosticReporter.reportBinding(
             ERROR,
             multiboundMapBindingNode,
-            duplicateMapKeyErrorMessage(
-                contributionsForOneMapKey, multiboundMapBindingNode.binding().key()));
+            duplicateMapKeyErrorMessage(contributionsForOneMapKey, multiboundMapBindingNode.key()));
       }
     }
   }
@@ -109,7 +106,7 @@ private void checkForInconsistentMapKeyAnnotationTypes(
           ERROR,
           multiboundMapBindingNode,
           inconsistentMapKeyAnnotationTypesErrorMessage(
-              contributionsByMapKeyAnnotationType, multiboundMapBindingNode.binding().key()));
+              contributionsByMapKeyAnnotationType, multiboundMapBindingNode.key()));
     }
   }
 
diff --git a/java/dagger/internal/codegen/MapType.java b/java/dagger/internal/codegen/MapType.java
index c7e51e047..73ecdbfa3 100644
--- a/java/dagger/internal/codegen/MapType.java
+++ b/java/dagger/internal/codegen/MapType.java
@@ -88,7 +88,20 @@ boolean valuesAreTypeOf(Class<?> clazz) {
   boolean valuesAreFrameworkType() {
     return FrameworkTypes.isFrameworkType(valueType());
   }
-  
+
+  /**
+   * {@code V} if {@link #valueType()} is a framework type like {@code Provider<V>} or {@code
+   * Producer<V>}.
+   *
+   * @throws IllegalStateException if {@link #isRawType()} is true or {@link #valueType()} is not a
+   *     framework type
+   */
+  TypeMirror unwrappedFrameworkValueType() {
+    checkState(
+        valuesAreFrameworkType(), "called unwrappedFrameworkValueType() on %s", declaredMapType());
+    return uncheckedUnwrappedValueType();
+  }
+
   /**
    * {@code V} if {@link #valueType()} is a {@code WrappingClass<V>}.
    *
@@ -103,6 +116,10 @@ TypeMirror unwrappedValueType(Class<?> wrappingClass) {
         "%s must have exactly one type parameter",
         wrappingClass);
     checkState(valuesAreTypeOf(wrappingClass), "expected values to be %s: %s", wrappingClass, this);
+    return uncheckedUnwrappedValueType();
+  }
+
+  private TypeMirror uncheckedUnwrappedValueType() {
     return MoreTypes.asDeclared(valueType()).getTypeArguments().get(0);
   }
 
diff --git a/java/dagger/internal/codegen/MembersInjectionBinding.java b/java/dagger/internal/codegen/MembersInjectionBinding.java
index 81dd05b5f..2b6c94040 100644
--- a/java/dagger/internal/codegen/MembersInjectionBinding.java
+++ b/java/dagger/internal/codegen/MembersInjectionBinding.java
@@ -98,10 +98,6 @@ public final boolean isProduction() {
 
     abstract ImmutableSet<DependencyRequest> dependencies();
 
-    int indexAmongSiblingMembers() {
-      return element().getEnclosingElement().getEnclosedElements().indexOf(element());
-    }
-
     /**
      * Returns the index of {@link #element()} in its parents {@code @Inject} members that have the
      * same simple name. This method filters out private elements so that the results will be
diff --git a/java/dagger/internal/codegen/MembersInjectionBindingExpression.java b/java/dagger/internal/codegen/MembersInjectionBindingExpression.java
index 32992e73b..a22b1dd5a 100644
--- a/java/dagger/internal/codegen/MembersInjectionBindingExpression.java
+++ b/java/dagger/internal/codegen/MembersInjectionBindingExpression.java
@@ -49,7 +49,7 @@ Expression getDependencyExpression(ClassName requestingClass) {
   // better suited as a method on MembersInjectionMethods
   @Override
   protected CodeBlock getComponentMethodImplementation(
-      ComponentMethodDescriptor componentMethod, ClassName componentName) {
+      ComponentMethodDescriptor componentMethod, GeneratedComponentModel component) {
     ExecutableElement methodElement = componentMethod.methodElement();
     ParameterSpec parameter = ParameterSpec.get(getOnlyElement(methodElement.getParameters()));
 
diff --git a/java/dagger/internal/codegen/MembersInjectionBindingValidation.java b/java/dagger/internal/codegen/MembersInjectionBindingValidation.java
deleted file mode 100644
index e68ecdfc7..000000000
--- a/java/dagger/internal/codegen/MembersInjectionBindingValidation.java
+++ /dev/null
@@ -1,163 +0,0 @@
-/*
- * Copyright (C) 2018 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal.codegen;
-
-import static javax.tools.Diagnostic.Kind.ERROR;
-
-import com.google.auto.common.MoreElements;
-import dagger.model.BindingGraph;
-import dagger.model.BindingGraph.BindingNode;
-import dagger.spi.BindingGraphPlugin;
-import dagger.spi.DiagnosticReporter;
-import java.util.Optional;
-import javax.inject.Inject;
-import javax.lang.model.type.ArrayType;
-import javax.lang.model.type.DeclaredType;
-import javax.lang.model.type.PrimitiveType;
-import javax.lang.model.type.TypeMirror;
-import javax.lang.model.type.TypeVisitor;
-import javax.lang.model.util.SimpleTypeVisitor8;
-
-/**
- * Validates bindings that satisfy members-injecting entry point methods or requests for a {@link
- * dagger.MembersInjector}.
- */
-final class MembersInjectionBindingValidation implements BindingGraphPlugin {
-
-  private final DaggerTypes types;
-
-  @Inject
-  MembersInjectionBindingValidation(DaggerTypes types) {
-    this.types = types;
-  }
-
-  @Override
-  public String pluginName() {
-    return "Dagger/MembersInjection";
-  }
-
-  @Override
-  public void visitGraph(BindingGraph bindingGraph, DiagnosticReporter diagnosticReporter) {
-    for (BindingNode bindingNode : bindingGraph.bindingNodes()) {
-      membersInjectedType(bindingNode)
-          .ifPresent(type -> validateMembersInjectionType(type, bindingNode, diagnosticReporter));
-    }
-  }
-
-  /**
-   * Returns the type whose members will be injected if the binding is a {@link
-   * dagger.model.BindingKind#MEMBERS_INJECTION} or {@link
-   * dagger.model.BindingKind#MEMBERS_INJECTOR} binding.
-   */
-  private Optional<TypeMirror> membersInjectedType(BindingNode bindingNode) {
-    switch (bindingNode.binding().kind()) {
-      case MEMBERS_INJECTION:
-        return Optional.of(bindingNode.binding().key().type());
-
-      case MEMBERS_INJECTOR:
-        return Optional.of(types.unwrapType(bindingNode.binding().key().type()));
-
-      default:
-        return Optional.empty();
-    }
-  }
-
-  /** Reports errors if a members injection binding is invalid. */
-  private void validateMembersInjectionType(
-      TypeMirror membersInjectedType,
-      BindingNode bindingNode,
-      DiagnosticReporter diagnosticReporter) {
-    membersInjectedType.accept(
-        new SimpleTypeVisitor8<Void, Void>() {
-          @Override
-          protected Void defaultAction(TypeMirror e, Void v) {
-            // Only declared types can be members-injected.
-            diagnosticReporter.reportBinding(
-                ERROR, bindingNode, "Cannot inject members into %s", e);
-            return null;
-          }
-
-          @Override
-          public Void visitDeclared(DeclaredType type, Void v) {
-            if (type.getTypeArguments().isEmpty()) {
-              // If the type is the erasure of a generic type, that means the user referred to
-              // Foo<T> as just 'Foo', which we don't allow.  (This is a judgement call; we
-              // *could* allow it and instantiate the type bounds, but we don't.)
-              if (!MoreElements.asType(type.asElement()).getTypeParameters().isEmpty()) {
-                diagnosticReporter.reportBinding(
-                    ERROR, bindingNode, "Cannot inject members into raw type %s", type);
-              }
-            } else {
-              // If the type has arguments, validate that each type argument is declared.
-              // Otherwise the type argument may be a wildcard (or other type), and we can't
-              // resolve that to actual types.  For array type arguments, validate the type of
-              // the array.
-              for (TypeMirror arg : type.getTypeArguments()) {
-                if (!arg.accept(DECLARED_OR_ARRAY, null)) {
-                  diagnosticReporter.reportBinding(
-                      ERROR,
-                      bindingNode,
-                      "Cannot inject members into types with unbounded type arguments: %s",
-                      type);
-                }
-              }
-            }
-            return null;
-          }
-        },
-        null);
-  }
-
-  // TODO(dpb): Can this be inverted so it explicitly rejects wildcards or type variables?
-  // This logic is hard to describe.
-  private static final TypeVisitor<Boolean, Void> DECLARED_OR_ARRAY =
-      new SimpleTypeVisitor8<Boolean, Void>(false) {
-        @Override
-        public Boolean visitArray(ArrayType arrayType, Void p) {
-          return arrayType
-              .getComponentType()
-              .accept(
-                  new SimpleTypeVisitor8<Boolean, Void>(false) {
-                    @Override
-                    public Boolean visitDeclared(DeclaredType declaredType, Void p) {
-                      for (TypeMirror arg : declaredType.getTypeArguments()) {
-                        if (!arg.accept(this, null)) {
-                          return false;
-                        }
-                      }
-                      return true;
-                    }
-
-                    @Override
-                    public Boolean visitArray(ArrayType arrayType, Void p) {
-                      return arrayType.getComponentType().accept(this, null);
-                    }
-
-                    @Override
-                    public Boolean visitPrimitive(PrimitiveType primitiveType, Void p) {
-                      return true;
-                    }
-                  },
-                  null);
-        }
-
-        @Override
-        public Boolean visitDeclared(DeclaredType t, Void p) {
-          return true;
-        }
-      };
-}
diff --git a/java/dagger/internal/codegen/MembersInjectionValidator.java b/java/dagger/internal/codegen/MembersInjectionValidator.java
new file mode 100644
index 000000000..036315ea9
--- /dev/null
+++ b/java/dagger/internal/codegen/MembersInjectionValidator.java
@@ -0,0 +1,149 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.base.Preconditions.checkArgument;
+import static dagger.internal.codegen.InjectionAnnotations.getQualifiers;
+
+import com.google.auto.common.MoreElements;
+import javax.inject.Inject;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.type.ArrayType;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.PrimitiveType;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.type.TypeVisitor;
+import javax.lang.model.util.SimpleTypeVisitor8;
+
+/**
+ * Validates members injection requests (members injection methods on components and requests for
+ * {@code MembersInjector<Foo>}).
+ */
+final class MembersInjectionValidator {
+
+  @Inject
+  MembersInjectionValidator() {}
+
+  /** Reports errors if a request for a {@code MembersInjector<Foo>}) is invalid. */
+  ValidationReport<Element> validateMembersInjectionRequest(
+      Element requestElement, TypeMirror membersInjectedType) {
+    ValidationReport.Builder<Element> report = ValidationReport.about(requestElement);
+    checkQualifiers(report, requestElement);
+    membersInjectedType.accept(VALIDATE_MEMBERS_INJECTED_TYPE, report);
+    return report.build();
+  }
+
+  /**
+   * Reports errors if a members injection method on a component is invalid.
+   *
+   * @throws IllegalArgumentException if the method doesn't have exactly one parameter
+   */
+  ValidationReport<ExecutableElement> validateMembersInjectionMethod(
+      ExecutableElement method, TypeMirror membersInjectedType) {
+    checkArgument(
+        method.getParameters().size() == 1, "expected a method with one parameter: %s", method);
+
+    ValidationReport.Builder<ExecutableElement> report = ValidationReport.about(method);
+    checkQualifiers(report, method);
+    checkQualifiers(report, method.getParameters().get(0));
+    membersInjectedType.accept(VALIDATE_MEMBERS_INJECTED_TYPE, report);
+    return report.build();
+  }
+
+  private void checkQualifiers(ValidationReport.Builder<?> report, Element element) {
+    for (AnnotationMirror qualifier : getQualifiers(element)) {
+      report.addError("Cannot inject members into qualified types", element, qualifier);
+      break; // just report on the first qualifier, in case there is more than one
+    }
+  }
+
+  private static final TypeVisitor<Void, ValidationReport.Builder<?>>
+      VALIDATE_MEMBERS_INJECTED_TYPE =
+          new SimpleTypeVisitor8<Void, ValidationReport.Builder<?>>() {
+            // Only declared types can be members-injected.
+            @Override
+            protected Void defaultAction(TypeMirror type, ValidationReport.Builder<?> report) {
+              report.addError("Cannot inject members into " + type);
+              return null;
+            }
+
+            @Override
+            public Void visitDeclared(DeclaredType type, ValidationReport.Builder<?> report) {
+              if (type.getTypeArguments().isEmpty()) {
+                // If the type is the erasure of a generic type, that means the user referred to
+                // Foo<T> as just 'Foo', which we don't allow.  (This is a judgement call; we
+                // *could* allow it and instantiate the type bounds, but we don't.)
+                if (!MoreElements.asType(type.asElement()).getTypeParameters().isEmpty()) {
+                  report.addError("Cannot inject members into raw type " + type);
+                }
+              } else {
+                // If the type has arguments, validate that each type argument is declared.
+                // Otherwise the type argument may be a wildcard (or other type), and we can't
+                // resolve that to actual types.  For array type arguments, validate the type of the
+                // array.
+                for (TypeMirror arg : type.getTypeArguments()) {
+                  if (!arg.accept(DECLARED_OR_ARRAY, null)) {
+                    report.addError(
+                        "Cannot inject members into types with unbounded type arguments: " + type);
+                  }
+                }
+              }
+              return null;
+            }
+          };
+
+  // TODO(dpb): Can this be inverted so it explicitly rejects wildcards or type variables?
+  // This logic is hard to describe.
+  private static final TypeVisitor<Boolean, Void> DECLARED_OR_ARRAY =
+      new SimpleTypeVisitor8<Boolean, Void>(false) {
+        @Override
+        public Boolean visitArray(ArrayType arrayType, Void p) {
+          return arrayType
+              .getComponentType()
+              .accept(
+                  new SimpleTypeVisitor8<Boolean, Void>(false) {
+                    @Override
+                    public Boolean visitDeclared(DeclaredType declaredType, Void p) {
+                      for (TypeMirror arg : declaredType.getTypeArguments()) {
+                        if (!arg.accept(this, null)) {
+                          return false;
+                        }
+                      }
+                      return true;
+                    }
+
+                    @Override
+                    public Boolean visitArray(ArrayType arrayType, Void p) {
+                      return arrayType.getComponentType().accept(this, null);
+                    }
+
+                    @Override
+                    public Boolean visitPrimitive(PrimitiveType primitiveType, Void p) {
+                      return true;
+                    }
+                  },
+                  null);
+        }
+
+        @Override
+        public Boolean visitDeclared(DeclaredType t, Void p) {
+          return true;
+        }
+      };
+}
diff --git a/java/dagger/internal/codegen/MembersInjectorGenerator.java b/java/dagger/internal/codegen/MembersInjectorGenerator.java
index 13e3e1635..9e9e9753e 100644
--- a/java/dagger/internal/codegen/MembersInjectorGenerator.java
+++ b/java/dagger/internal/codegen/MembersInjectorGenerator.java
@@ -79,8 +79,8 @@ ClassName nameGeneratedType(MembersInjectionBinding binding) {
   }
 
   @Override
-  Optional<? extends Element> getElementForErrorReporting(MembersInjectionBinding binding) {
-    return Optional.of(binding.membersInjectedType());
+  Element originatingElement(MembersInjectionBinding binding) {
+    return binding.membersInjectedType();
   }
 
   @Override
diff --git a/java/dagger/internal/codegen/MethodSignatureFormatter.java b/java/dagger/internal/codegen/MethodSignatureFormatter.java
index 6ffee05d0..67535572c 100644
--- a/java/dagger/internal/codegen/MethodSignatureFormatter.java
+++ b/java/dagger/internal/codegen/MethodSignatureFormatter.java
@@ -46,6 +46,22 @@
     this.types = types;
   }
 
+  /**
+   * A formatter that uses the type where the method is declared for the annotations and name of the
+   * method, but the method's resolved type as a member of {@code declaredType} for the key.
+   */
+  Formatter<ExecutableElement> typedFormatter(DeclaredType declaredType) {
+    return new Formatter<ExecutableElement>() {
+      @Override
+      public String format(ExecutableElement method) {
+        return MethodSignatureFormatter.this.format(
+            method,
+            MoreTypes.asExecutable(types.asMemberOf(declaredType, method)),
+            MoreElements.asType(method.getEnclosingElement()));
+      }
+    };
+  }
+
   @Override public String format(ExecutableElement method) {
     return format(method, Optional.empty());
   }
@@ -55,14 +71,18 @@
    * present.
    */
   public String format(ExecutableElement method, Optional<DeclaredType> container) {
-    StringBuilder builder = new StringBuilder();
     TypeElement type = MoreElements.asType(method.getEnclosingElement());
     ExecutableType executableType = MoreTypes.asExecutable(method.asType());
     if (container.isPresent()) {
       executableType = MoreTypes.asExecutable(types.asMemberOf(container.get(), method));
       type = MoreElements.asType(container.get().asElement());
     }
+    return format(method, executableType, type);
+  }
 
+  private String format(
+      ExecutableElement method, ExecutableType methodType, TypeElement declaringType) {
+    StringBuilder builder = new StringBuilder();
     // TODO(cgruber): AnnotationMirror formatter.
     List<? extends AnnotationMirror> annotations = method.getAnnotationMirrors();
     if (!annotations.isEmpty()) {
@@ -75,15 +95,15 @@ public String format(ExecutableElement method, Optional<DeclaredType> container)
       }
       builder.append(' ');
     }
-    builder.append(nameOfType(executableType.getReturnType()));
+    builder.append(nameOfType(methodType.getReturnType()));
     builder.append(' ');
-    builder.append(type.getQualifiedName());
+    builder.append(declaringType.getQualifiedName());
     builder.append('.');
     builder.append(method.getSimpleName());
     builder.append('(');
-    checkState(method.getParameters().size() == executableType.getParameterTypes().size());
+    checkState(method.getParameters().size() == methodType.getParameterTypes().size());
     Iterator<? extends VariableElement> parameters = method.getParameters().iterator();
-    Iterator<? extends TypeMirror> parameterTypes = executableType.getParameterTypes().iterator();
+    Iterator<? extends TypeMirror> parameterTypes = methodType.getParameterTypes().iterator();
     for (int i = 0; parameters.hasNext(); i++) {
       if (i > 0) {
         builder.append(", ");
diff --git a/java/dagger/internal/codegen/MissingBindingExpression.java b/java/dagger/internal/codegen/MissingBindingExpression.java
new file mode 100644
index 000000000..2c1b7df46
--- /dev/null
+++ b/java/dagger/internal/codegen/MissingBindingExpression.java
@@ -0,0 +1,52 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
+import dagger.internal.codegen.ModifiableBindingMethods.ModifiableBindingMethod;
+import java.util.Optional;
+
+/**
+ * A {@link ModifiableAbstractMethodBindingExpression} for a binding that is missing when generating
+ * the abstract base class implementation of a subcomponent. The (unimplemented) method is added to
+ * the {@link GeneratedComponentModel} when the dependency expression is requested. The method is
+ * overridden when generating the implementation of an ancestor component.
+ */
+final class MissingBindingExpression extends ModifiableAbstractMethodBindingExpression {
+  private final GeneratedComponentModel generatedComponentModel;
+  private final BindingRequest request;
+
+  MissingBindingExpression(
+      GeneratedComponentModel generatedComponentModel,
+      BindingRequest request,
+      Optional<ModifiableBindingMethod> matchingModifiableBindingMethod,
+      Optional<ComponentMethodDescriptor> matchingComponentMethod) {
+    super(
+        generatedComponentModel,
+        ModifiableBindingType.MISSING,
+        request,
+        matchingModifiableBindingMethod,
+        matchingComponentMethod);
+    this.generatedComponentModel = generatedComponentModel;
+    this.request = request;
+  }
+
+  @Override
+  String chooseMethodName() {
+    return generatedComponentModel.getUniqueMethodName(request);
+  }
+}
diff --git a/java/dagger/internal/codegen/MissingBindingValidation.java b/java/dagger/internal/codegen/MissingBindingValidator.java
similarity index 76%
rename from java/dagger/internal/codegen/MissingBindingValidation.java
rename to java/dagger/internal/codegen/MissingBindingValidator.java
index 5ce5f9bab..0e1e7a7e6 100644
--- a/java/dagger/internal/codegen/MissingBindingValidation.java
+++ b/java/dagger/internal/codegen/MissingBindingValidator.java
@@ -20,6 +20,7 @@
 import static com.google.auto.common.MoreTypes.asTypeElement;
 import static com.google.auto.common.MoreTypes.isType;
 import static com.google.auto.common.MoreTypes.isTypeOf;
+import static com.google.common.base.Verify.verify;
 import static dagger.internal.codegen.DaggerElements.isAnnotationPresent;
 import static dagger.internal.codegen.DaggerStreams.instancesOf;
 import static dagger.internal.codegen.Keys.isValidImplicitProvisionKey;
@@ -36,6 +37,7 @@
 import dagger.model.BindingGraph.BindingNode;
 import dagger.model.BindingGraph.ComponentNode;
 import dagger.model.BindingGraph.DependencyEdge;
+import dagger.model.BindingGraph.MissingBindingNode;
 import dagger.model.BindingGraph.Node;
 import dagger.model.Key;
 import dagger.model.Scope;
@@ -55,14 +57,14 @@
 import javax.lang.model.type.TypeMirror;
 
 /** Reports errors for missing bindings. */
-final class MissingBindingValidation implements BindingGraphPlugin {
+final class MissingBindingValidator implements BindingGraphPlugin {
 
   private final DaggerTypes types;
   private final DaggerElements elements;
   private final InjectBindingRegistry injectBindingRegistry;
 
   @Inject
-  MissingBindingValidation(
+  MissingBindingValidator(
       DaggerTypes types, DaggerElements elements, InjectBindingRegistry injectBindingRegistry) {
     this.types = types;
     this.injectBindingRegistry = injectBindingRegistry;
@@ -76,53 +78,43 @@ public String pluginName() {
 
   @Override
   public void visitGraph(BindingGraph graph, DiagnosticReporter diagnosticReporter) {
-    // TODO(ronshapiro): Maybe report each missing binding once instead of each dependency.
     graph
         .missingBindingNodes()
-        .stream()
-        .flatMap(node -> graph.inEdges(node).stream())
-        .flatMap(instancesOf(DependencyEdge.class))
-        .forEach(edge -> reportMissingBinding(edge, graph, diagnosticReporter));
+        .forEach(node -> reportMissingBinding(node, graph, diagnosticReporter));
   }
 
   private void reportMissingBinding(
-      DependencyEdge edge, BindingGraph graph, DiagnosticReporter diagnosticReporter) {
-    diagnosticReporter.reportDependency(
+      MissingBindingNode missingBindingNode,
+      BindingGraph graph,
+      DiagnosticReporter diagnosticReporter) {
+    diagnosticReporter.reportBinding(
         ERROR,
-        edge,
-        missingReleasableReferenceManagerBindingErrorMessage(edge, graph)
-            .orElseGet(() -> missingBindingErrorMessage(edge, graph)));
+        missingBindingNode,
+        missingReleasableReferenceManagerBindingErrorMessage(missingBindingNode, graph)
+            .orElseGet(() -> missingBindingErrorMessage(missingBindingNode, graph)));
   }
 
-  private String missingBindingErrorMessage(DependencyEdge edge, BindingGraph graph) {
-    Key key = edge.dependencyRequest().key();
+  private String missingBindingErrorMessage(
+      MissingBindingNode missingBindingNode, BindingGraph graph) {
+    Key key = missingBindingNode.key();
     StringBuilder errorMessage = new StringBuilder();
-    // TODO(dpb): Check for wildcard injection somewhere else first?
-    if (key.type().getKind().equals(TypeKind.WILDCARD)) {
-      // TODO(ronshapiro): Explore creating this message using RequestKinds.
-      errorMessage
-          .append("Dagger does not support injecting Provider<T>, Lazy<T>, Producer<T>, ")
-          .append("or Produced<T> when T is a wildcard type such as ")
-          .append(key);
-    } else {
-      // TODO(ronshapiro): replace "provided" with "satisfied"?
-      errorMessage.append(key).append(" cannot be provided without ");
-      if (isValidImplicitProvisionKey(key, types)) {
-        errorMessage.append("an @Inject constructor or ");
-      }
-      errorMessage.append("an @Provides-"); // TODO(dpb): s/an/a
-      if (dependencyCanBeProduction(edge, graph)) {
-        errorMessage.append(" or @Produces-");
-      }
-      errorMessage.append("annotated method.");
+    // Wildcards should have already been checked by DependencyRequestValidator.
+    verify(!key.type().getKind().equals(TypeKind.WILDCARD), "unexpected wildcard request: %s", key);
+    // TODO(ronshapiro): replace "provided" with "satisfied"?
+    errorMessage.append(key).append(" cannot be provided without ");
+    if (isValidImplicitProvisionKey(key, types)) {
+      errorMessage.append("an @Inject constructor or ");
+    }
+    errorMessage.append("an @Provides-"); // TODO(dpb): s/an/a
+    if (allIncomingDependenciesCanUseProduction(missingBindingNode, graph)) {
+      errorMessage.append(" or @Produces-");
     }
+    errorMessage.append("annotated method.");
     if (isValidMembersInjectionKey(key) && typeHasInjectionSites(key)) {
       errorMessage.append(
           " This type supports members injection but cannot be implicitly provided.");
     }
-    graph
-        .bindingNodes(key)
-        .stream()
+    graph.bindingNodes(key).stream()
         .map(bindingNode -> bindingNode.componentPath().currentComponent())
         .distinct()
         .forEach(
@@ -133,8 +125,15 @@ private String missingBindingErrorMessage(DependencyEdge edge, BindingGraph grap
     return errorMessage.toString();
   }
 
+  private boolean allIncomingDependenciesCanUseProduction(
+      MissingBindingNode missingBindingNode, BindingGraph graph) {
+    return graph.network().inEdges(missingBindingNode).stream()
+        .flatMap(instancesOf(DependencyEdge.class))
+        .allMatch(edge -> dependencyCanBeProduction(edge, graph));
+  }
+
   private boolean dependencyCanBeProduction(DependencyEdge edge, BindingGraph graph) {
-    Node source = graph.incidentNodes(edge).source();
+    Node source = graph.network().incidentNodes(edge).source();
     if (source instanceof ComponentNode) {
       return entryPointCanUseProduction(edge.dependencyRequest().kind());
     }
@@ -152,10 +151,10 @@ private boolean typeHasInjectionSites(Key key) {
   }
 
   /**
-   * If {@code edge} is missing a binding because it's an invalid {@code @ForReleasableReferences}
-   * request, returns a more specific error message.
+   * If {@code missingBindingNode}'s key is for an invalid {@code @ForReleasableReferences}, returns
+   * a more specific error message.
    *
-   * <p>An invalid request is one whose type is either {@link ReleasableReferenceManager} or {@link
+   * <p>An invalid key is one whose type is either {@link ReleasableReferenceManager} or {@link
    * TypedReleasableReferenceManager}, and whose scope:
    *
    * <ul>
@@ -165,8 +164,8 @@ private boolean typeHasInjectionSites(Key key) {
    * </ul>
    */
   private Optional<String> missingReleasableReferenceManagerBindingErrorMessage(
-      DependencyEdge edge, BindingGraph graph) {
-    Key key = edge.dependencyRequest().key();
+      MissingBindingNode missingBindingNode, BindingGraph graph) {
+    Key key = missingBindingNode.key();
     if (!key.qualifier().isPresent()
         || !isTypeOf(ForReleasableReferences.class, key.qualifier().get().getAnnotationType())
         || !isType(key.type())) {
@@ -194,7 +193,7 @@ private boolean typeHasInjectionSites(Key key) {
               "There is no binding for %s because no component in %s's component hierarchy is "
                   + "annotated with %s. The available reference-releasing scopes are %s.",
               key,
-              graph.rootComponentNode().toString(),
+              graph.rootComponentNode().componentPath().currentComponent().getQualifiedName(),
               getReadableSource(scope),
               releasableReferencesScopes(graph).map(Scopes::getReadableSource).collect(toList())));
     }
@@ -219,9 +218,7 @@ private static String notAnnotated(Key key, TypeElement type, TypeElement annota
   }
 
   private Stream<Scope> releasableReferencesScopes(BindingGraph graph) {
-    return graph
-        .componentNodes()
-        .stream()
+    return graph.componentNodes().stream()
         .flatMap(node -> node.scopes().stream())
         .filter(Scope::canReleaseReferences);
   }
diff --git a/java/dagger/internal/codegen/ModifiableAbstractMethodBindingExpression.java b/java/dagger/internal/codegen/ModifiableAbstractMethodBindingExpression.java
new file mode 100644
index 000000000..0da08797d
--- /dev/null
+++ b/java/dagger/internal/codegen/ModifiableAbstractMethodBindingExpression.java
@@ -0,0 +1,100 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static javax.lang.model.element.Modifier.ABSTRACT;
+import static javax.lang.model.element.Modifier.PUBLIC;
+
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.MethodSpec;
+import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
+import dagger.internal.codegen.ModifiableBindingMethods.ModifiableBindingMethod;
+import java.util.Optional;
+
+/**
+ * A {@link BindingExpression} that invokes a method that encapsulates a binding that cannot be
+ * satisfied when generating the abstract base class implementation of a subcomponent. The
+ * (unimplemented) method is added to the {@link GeneratedComponentModel} when the dependency
+ * expression is requested. The method is overridden when generating the implementation of an
+ * ancestor component.
+ */
+// TODO(b/72748365): There may be unimplemented abstract binding methods even after considering a
+// complete binding graph: If there are @Provides-over-@Inject bindings then there could be branches
+// of dependencies (of the @Inject binding) that have induced abstract modifiable binding methods
+// that are missing in the full binding graph (given the @Provides binding). Such abstract
+// modifiable methods should be overridden and an exception thrown.
+abstract class ModifiableAbstractMethodBindingExpression extends BindingExpression {
+  private final GeneratedComponentModel generatedComponentModel;
+  private final ModifiableBindingType modifiableBindingType;
+  private final BindingRequest request;
+  private Optional<String> methodName;
+
+  ModifiableAbstractMethodBindingExpression(
+      GeneratedComponentModel generatedComponentModel,
+      ModifiableBindingType modifiableBindingType,
+      BindingRequest request,
+      Optional<ModifiableBindingMethod> matchingModifiableBindingMethod,
+      Optional<ComponentMethodDescriptor> matchingComponentMethod) {
+    this.generatedComponentModel = generatedComponentModel;
+    this.modifiableBindingType = modifiableBindingType;
+    this.request = request;
+    this.methodName =
+        initializeMethodName(matchingComponentMethod, matchingModifiableBindingMethod);
+  }
+
+  /**
+   * If this binding corresponds to an existing component method, or a known modifiable binding
+   * method, use them to initialize the method name, which is a signal to call the existing method
+   * rather than emit an abstract method.
+   */
+  private static Optional<String> initializeMethodName(
+      Optional<ComponentMethodDescriptor> matchingComponentMethod,
+      Optional<ModifiableBindingMethod> matchingModifiableBindingMethod) {
+    if (matchingComponentMethod.isPresent()) {
+      return Optional.of(matchingComponentMethod.get().methodElement().getSimpleName().toString());
+    }
+    if (matchingModifiableBindingMethod.isPresent()) {
+      return Optional.of(matchingModifiableBindingMethod.get().methodSpec().name);
+    }
+    return Optional.empty();
+  }
+
+  @Override
+  final Expression getDependencyExpression(ClassName requestingClass) {
+    addUnimplementedMethod();
+    return Expression.create(request.key().type(), CodeBlock.of("$L()", methodName.get()));
+  }
+
+  private void addUnimplementedMethod() {
+    if (!methodName.isPresent()) {
+      // Only add the method once in case of repeated references to the missing binding.
+      methodName = Optional.of(chooseMethodName());
+      generatedComponentModel.addModifiableBindingMethod(
+          modifiableBindingType,
+          request,
+          MethodSpec.methodBuilder(methodName.get())
+              .addModifiers(PUBLIC, ABSTRACT)
+              .returns(request.typeName())
+              .build(),
+          false /* finalized */);
+    }
+  }
+
+  /** Returns a unique 'getter' method name for the current component. */
+  abstract String chooseMethodName();
+}
diff --git a/java/dagger/internal/codegen/ModifiableBindingExpressions.java b/java/dagger/internal/codegen/ModifiableBindingExpressions.java
new file mode 100644
index 000000000..7f3fa7123
--- /dev/null
+++ b/java/dagger/internal/codegen/ModifiableBindingExpressions.java
@@ -0,0 +1,362 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static dagger.internal.codegen.BindingRequest.bindingRequest;
+import static javax.lang.model.element.Modifier.PUBLIC;
+
+import com.squareup.javapoet.MethodSpec;
+import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
+import dagger.internal.codegen.ModifiableBindingMethods.ModifiableBindingMethod;
+import dagger.model.BindingKind;
+import java.util.Optional;
+
+/**
+ * A central repository of code expressions used to access modifiable bindings available to a
+ * component. A binding is modifiable if it can be modified across implementations of a
+ * subcomponent. This is only relevant for ahead-of-time subcomponents.
+ */
+final class ModifiableBindingExpressions {
+  private final Optional<ModifiableBindingExpressions> parent;
+  private final ComponentBindingExpressions bindingExpressions;
+  private final BindingGraph graph;
+  private final GeneratedComponentModel generatedComponentModel;
+  private final CompilerOptions compilerOptions;
+
+  ModifiableBindingExpressions(
+      Optional<ModifiableBindingExpressions> parent,
+      ComponentBindingExpressions bindingExpressions,
+      BindingGraph graph,
+      GeneratedComponentModel generatedComponentModel,
+      CompilerOptions compilerOptions) {
+    this.parent = parent;
+    this.bindingExpressions = bindingExpressions;
+    this.graph = graph;
+    this.generatedComponentModel = generatedComponentModel;
+    this.compilerOptions = compilerOptions;
+  }
+
+  /**
+   * Records the binding exposed by the given component method as modifiable, if it is, and returns
+   * the {@link ModifiableBindingType} associated with the binding.
+   */
+  ModifiableBindingType registerComponentMethodIfModifiable(
+      ComponentMethodDescriptor componentMethod, MethodSpec method) {
+    BindingRequest request = bindingRequest(componentMethod.dependencyRequest().get());
+    ModifiableBindingType modifiableBindingType = getModifiableBindingType(request);
+    if (modifiableBindingType.isModifiable()) {
+      generatedComponentModel.registerModifiableBindingMethod(
+          modifiableBindingType,
+          request,
+          method,
+          newModifiableBindingWillBeFinalized(modifiableBindingType, request));
+    }
+    return modifiableBindingType;
+  }
+
+  /**
+   * Returns the implementation of a modifiable binding method originally defined in a supertype
+   * implementation of this subcomponent. Returns {@link Optional#empty()} when the binding cannot
+   * or should not be modified by the current binding graph.
+   */
+  Optional<ModifiableBindingMethod> getModifiableBindingMethod(
+      ModifiableBindingMethod modifiableBindingMethod) {
+    if (shouldModifyKnownBinding(modifiableBindingMethod)) {
+      MethodSpec baseMethod = modifiableBindingMethod.methodSpec();
+      return Optional.of(
+          ModifiableBindingMethod.implement(
+              modifiableBindingMethod,
+              MethodSpec.methodBuilder(baseMethod.name)
+                  .addModifiers(PUBLIC)
+                  // TODO(b/72748365): Mark method as final if binding should not be further
+                  // modified.
+                  .returns(baseMethod.returnType)
+                  .addAnnotation(Override.class)
+                  .addCode(
+                      bindingExpressions
+                          .getBindingExpression(modifiableBindingMethod.request())
+                          .getModifiableBindingMethodImplementation(
+                              modifiableBindingMethod, generatedComponentModel))
+                  .build(),
+              knownModifiableBindingWillBeFinalized(modifiableBindingMethod)));
+    }
+    return Optional.empty();
+  }
+
+  /**
+   * Returns true if a modifiable binding method that was registered in a superclass implementation
+   * of this subcomponent should be marked as "finalized" if it is being overridden by this
+   * subcomponent implementation. "Finalized" means we should not attempt to modify the binding in
+   * any subcomponent subclass.
+   */
+  private boolean knownModifiableBindingWillBeFinalized(
+      ModifiableBindingMethod modifiableBindingMethod) {
+    ModifiableBindingType newModifiableBindingType =
+        getModifiableBindingType(modifiableBindingMethod.request());
+    if (!newModifiableBindingType.isModifiable()) {
+      // If a modifiable binding has become non-modifiable it is final by definition.
+      return true;
+    }
+    return modifiableBindingWillBeFinalized(
+        newModifiableBindingType,
+        shouldModifyBinding(newModifiableBindingType, modifiableBindingMethod.request()));
+  }
+
+  /**
+   * Returns true if a newly discovered modifiable binding method, once it is defined in this
+   * subcomponent implementation, should be marked as "finalized", meaning we should not attempt to
+   * modify the binding in any subcomponent subclass.
+   */
+  private boolean newModifiableBindingWillBeFinalized(
+      ModifiableBindingType modifiableBindingType, BindingRequest request) {
+    return modifiableBindingWillBeFinalized(
+        modifiableBindingType, shouldModifyBinding(modifiableBindingType, request));
+  }
+
+  /**
+   * Returns true if we shouldn't attempt to further modify a modifiable binding once we complete
+   * the implementation for the current subcomponent.
+   */
+  private boolean modifiableBindingWillBeFinalized(
+      ModifiableBindingType modifiableBindingType, boolean modifyingBinding) {
+    switch (modifiableBindingType) {
+      case MISSING:
+      case GENERATED_INSTANCE:
+      case OPTIONAL:
+      case INJECTION:
+        // Once we modify any of the above a single time, then they are finalized.
+        return modifyingBinding;
+      case MULTIBINDING:
+        return false;
+      default:
+        throw new IllegalStateException(
+            String.format(
+                "Building binding expression for unsupported ModifiableBindingType [%s].",
+                modifiableBindingType));
+    }
+  }
+
+  /**
+   * Creates a binding expression for a binding if it may be modified across implementations of a
+   * subcomponent.
+   */
+  Optional<BindingExpression> maybeCreateModifiableBindingExpression(BindingRequest request) {
+    ModifiableBindingType type = getModifiableBindingType(request);
+    if (!type.isModifiable()) {
+      return Optional.empty();
+    }
+    return Optional.of(createModifiableBindingExpression(type, request));
+  }
+
+  /** Creates a binding expression for a modifiable binding. */
+  private BindingExpression createModifiableBindingExpression(
+      ModifiableBindingType type, BindingRequest request) {
+    ResolvedBindings resolvedBindings = graph.resolvedBindings(request);
+    Optional<ModifiableBindingMethod> matchingModifiableBindingMethod =
+        generatedComponentModel.getModifiableBindingMethod(request);
+    Optional<ComponentMethodDescriptor> matchingComponentMethod =
+        graph.componentDescriptor().findMatchingComponentMethod(request);
+    switch (type) {
+      case GENERATED_INSTANCE:
+        return new GeneratedInstanceBindingExpression(
+            generatedComponentModel,
+            resolvedBindings,
+            request,
+            matchingModifiableBindingMethod,
+            matchingComponentMethod);
+      case MISSING:
+        return new MissingBindingExpression(
+            generatedComponentModel,
+            request,
+            matchingModifiableBindingMethod,
+            matchingComponentMethod);
+      case OPTIONAL:
+      case MULTIBINDING:
+      case INJECTION:
+        return bindingExpressions.wrapInMethod(
+            resolvedBindings,
+            request,
+            bindingExpressions.createBindingExpression(resolvedBindings, request));
+      default:
+        throw new IllegalStateException(
+            String.format(
+                "Building binding expression for unsupported ModifiableBindingType [%s].", type));
+    }
+  }
+
+  /**
+   * The reason why a binding may need to be modified across implementations of a subcomponent, if
+   * at all.
+   */
+  private ModifiableBindingType getModifiableBindingType(BindingRequest request) {
+    if (!compilerOptions.aheadOfTimeSubcomponents()) {
+      return ModifiableBindingType.NONE;
+    }
+
+    // When generating a final (concrete) implementation of a (sub)component the binding is no
+    // longer considered modifiable. It cannot be further modified by a subclass implementation.
+    if (!generatedComponentModel.isAbstract()) {
+      return ModifiableBindingType.NONE;
+    }
+
+    if (resolvedInThisComponent(request)) {
+      ResolvedBindings resolvedBindings = graph.resolvedBindings(request);
+      if (resolvedBindings.contributionBindings().isEmpty()) {
+        // TODO(ronshapiro): Confirm whether a resolved binding must have a single contribution
+        // binding.
+        return ModifiableBindingType.NONE;
+      }
+
+      ContributionBinding binding = resolvedBindings.contributionBinding();
+      if (binding.requiresGeneratedInstance()) {
+        return ModifiableBindingType.GENERATED_INSTANCE;
+      }
+
+      if (binding.kind().equals(BindingKind.OPTIONAL)) {
+        return ModifiableBindingType.OPTIONAL;
+      }
+
+      if (resolvedBindings.bindingType().equals(BindingType.PROVISION)
+          && binding.isSyntheticMultibinding()) {
+        return ModifiableBindingType.MULTIBINDING;
+      }
+
+      if (binding.kind().equals(BindingKind.INJECTION)) {
+        return ModifiableBindingType.INJECTION;
+      }
+    } else if (!resolvableBinding(request)) {
+      return ModifiableBindingType.MISSING;
+    }
+
+    return ModifiableBindingType.NONE;
+  }
+
+  /**
+   * Returns true if the current binding graph can, and should, modify a binding by overriding a
+   * modifiable binding method.
+   */
+  private boolean shouldModifyKnownBinding(ModifiableBindingMethod modifiableBindingMethod) {
+    ModifiableBindingType newModifiableBindingType =
+        getModifiableBindingType(modifiableBindingMethod.request());
+    if (!newModifiableBindingType.equals(modifiableBindingMethod.type())) {
+      // It is possible that a binding can change types, in which case we should always modify the
+      // binding.
+      return true;
+    }
+    return shouldModifyBinding(modifiableBindingMethod.type(), modifiableBindingMethod.request());
+  }
+
+  /**
+   * Returns true if the current binding graph can, and should, modify a binding by overriding a
+   * modifiable binding method.
+   */
+  private boolean shouldModifyBinding(
+      ModifiableBindingType modifiableBindingType, BindingRequest request) {
+    ResolvedBindings resolvedBindings = graph.resolvedBindings(request);
+    switch (modifiableBindingType) {
+      case GENERATED_INSTANCE:
+        return !generatedComponentModel.isAbstract();
+      case MISSING:
+        // TODO(b/72748365): investigate beder@'s comment about having intermediate component
+        // ancestors satisfy missing bindings of their children with their own missing binding
+        // methods so that we can minimize the cases where we need to reach into doubly-nested
+        // descendant component implementations
+        return resolvableBinding(request);
+      case OPTIONAL:
+        // Only override optional binding methods if we have a non-empty binding.
+        return !resolvedBindings.contributionBinding().dependencies().isEmpty();
+      case MULTIBINDING:
+        // Only modify a multibinding if there are new contributions.
+        return !generatedComponentModel
+            .superclassContributionsMade(request.key())
+            .containsAll(resolvedBindings.contributionBinding().dependencies());
+      case INJECTION:
+        return !resolvedBindings.contributionBinding().kind().equals(BindingKind.INJECTION);
+      default:
+        throw new IllegalStateException(
+            String.format(
+                "Overriding modifiable binding method with unsupported ModifiableBindingType [%s].",
+                modifiableBindingType));
+    }
+  }
+
+  /**
+   * Returns true if the binding can be resolved by the graph for this component or any parent
+   * component.
+   */
+  private boolean resolvableBinding(BindingRequest request) {
+    for (ModifiableBindingExpressions expressions = this;
+        expressions != null;
+        expressions = expressions.parent.orElse(null)) {
+      if (expressions.resolvedInThisComponent(request)) {
+        return true;
+      }
+    }
+    return false;
+  }
+
+  /** Returns true if the binding can be resolved by the graph for this component. */
+  private boolean resolvedInThisComponent(BindingRequest request) {
+    ResolvedBindings resolvedBindings = graph.resolvedBindings(request);
+    return resolvedBindings != null && !resolvedBindings.ownedBindings().isEmpty();
+  }
+
+  /**
+   * Returns a binding expression that invokes a method whose implementation is the given binding
+   * expression. It will only return such an expression if the binding represents a modifiable
+   * binding that should be wrapped in a method. We wrap expressions in this way so we can modify
+   * the binding when generating a subcomponent subclass by overriding the method.
+   */
+  Optional<BindingExpression> maybeWrapInModifiableMethodBindingExpression(
+      ResolvedBindings resolvedBindings,
+      BindingRequest request,
+      BindingExpression bindingExpression,
+      BindingMethodImplementation methodImplementation,
+      Optional<ComponentMethodDescriptor> matchingComponentMethod) {
+    ModifiableBindingType modifiableBindingType = getModifiableBindingType(request);
+    if (shouldUseAModifiableConcreteMethodBindingExpression(
+        modifiableBindingType, matchingComponentMethod)) {
+      return Optional.of(
+          new ModifiableConcreteMethodBindingExpression(
+              resolvedBindings,
+              request,
+              modifiableBindingType,
+              methodImplementation,
+              generatedComponentModel,
+              generatedComponentModel.getModifiableBindingMethod(request),
+              newModifiableBindingWillBeFinalized(modifiableBindingType, request)));
+    }
+    return Optional.empty();
+  }
+
+  /**
+   * Returns true if we should wrap a binding expression using a {@link
+   * ModifiableConcreteMethodBindingExpression}. If we're generating the abstract base class of a
+   * subcomponent and the binding matches a component method, even if it is modifiable, then it
+   * should be "wrapped" by a {@link ComponentMethodBindingExpression}. If it isn't a base class
+   * then modifiable methods should be handled by a {@link
+   * ModifiableConcreteMethodBindingExpression}. When generating an inner subcomponent it doesn't
+   * matter whether the binding matches a component method: All modifiable bindings should be
+   * handled by a {@link ModifiableConcreteMethodBindingExpression}.
+   */
+  private boolean shouldUseAModifiableConcreteMethodBindingExpression(
+      ModifiableBindingType type, Optional<ComponentMethodDescriptor> matchingComponentMethod) {
+    return type.isModifiable()
+        && (generatedComponentModel.supermodel().isPresent()
+            || !matchingComponentMethod.isPresent());
+  }
+}
diff --git a/java/dagger/internal/codegen/ModifiableBindingMethods.java b/java/dagger/internal/codegen/ModifiableBindingMethods.java
new file mode 100644
index 000000000..d83a5fc9b
--- /dev/null
+++ b/java/dagger/internal/codegen/ModifiableBindingMethods.java
@@ -0,0 +1,117 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkState;
+import static dagger.internal.codegen.DaggerStreams.toImmutableList;
+
+import com.google.auto.value.AutoValue;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.Maps;
+import com.google.common.collect.Sets;
+import com.squareup.javapoet.MethodSpec;
+import java.util.Map;
+import java.util.Optional;
+import java.util.Set;
+
+/**
+ * A registry for those methods which each wrap a binding whose definition may be modified across
+ * each class in the class hierarchy implementing a subcomponent. Subcomponent implementations are
+ * spread across a class hierarchy when generating ahead-of-time subcomponents. There is one
+ * subcomponent implementation class for each of the subcomponent's ancestor components. An instance
+ * of {@link ModifiableBindingMethod} is associated with a single class in this hierarchy. For a
+ * given subcomponent implementation class we can use the {@link ModifiableBindingMethod}s of its
+ * superclasses to know what binding methods to attempt to modify.
+ */
+final class ModifiableBindingMethods {
+  private final Map<BindingRequest, ModifiableBindingMethod> methods = Maps.newLinkedHashMap();
+  private final Set<BindingRequest> finalizedMethods = Sets.newHashSet();
+
+  /** Register a method encapsulating a modifiable binding. */
+  void addMethod(
+      ModifiableBindingType type, BindingRequest request, MethodSpec method, boolean finalized) {
+    checkArgument(type.isModifiable());
+    if (finalized) {
+      finalizedMethods.add(request);
+    }
+    methods.put(request, ModifiableBindingMethod.create(type, request, method, finalized));
+  }
+
+  /** Returns all {@link ModifiableBindingMethod}s that have not been marked as finalized. */
+  ImmutableList<ModifiableBindingMethod> getNonFinalizedMethods() {
+    return methods.values().stream().filter(m -> !m.finalized()).collect(toImmutableList());
+  }
+
+  /** Returns the {@link ModifiableBindingMethod} for the given binding if present. */
+  Optional<ModifiableBindingMethod> getMethod(BindingRequest request) {
+    return Optional.ofNullable(methods.get(request));
+  }
+
+  /**
+   * Mark the {@link ModifiableBindingMethod} as having been implemented, thus modifying the
+   * binding.
+   */
+  void methodImplemented(ModifiableBindingMethod method) {
+    if (method.finalized()) {
+      checkState(
+          finalizedMethods.add(method.request()),
+          "Implementing and finalizing a modifiable binding method that has been marked as "
+              + "finalized in the current subcomponent implementation. The binding is for a %s "
+              + "of type %s.",
+          method.request(),
+          method.type());
+    }
+  }
+
+  /** Whether a given binding has been marked as finalized. */
+  boolean finalized(ModifiableBindingMethod method) {
+    return finalizedMethods.contains(method.request());
+  }
+
+  @AutoValue
+  abstract static class ModifiableBindingMethod {
+    private static ModifiableBindingMethod create(
+        ModifiableBindingType type,
+        BindingRequest request,
+        MethodSpec methodSpec,
+        boolean finalized) {
+      return new AutoValue_ModifiableBindingMethods_ModifiableBindingMethod(
+          type, request, methodSpec, finalized);
+    }
+
+    /** Create a {@ModifiableBindingMethod} representing an implementation of an existing method. */
+    static ModifiableBindingMethod implement(
+        ModifiableBindingMethod unimplementedMethod, MethodSpec methodSpec, boolean finalized) {
+      return new AutoValue_ModifiableBindingMethods_ModifiableBindingMethod(
+          unimplementedMethod.type(), unimplementedMethod.request(), methodSpec, finalized);
+    }
+
+    abstract ModifiableBindingType type();
+
+    abstract BindingRequest request();
+
+    abstract MethodSpec methodSpec();
+
+    abstract boolean finalized();
+
+    /** Whether a {@link ModifiableBindingMethod} is for the same binding request. */
+    boolean fulfillsSameRequestAs(ModifiableBindingMethod other) {
+      return request().equals(other.request());
+    }
+  }
+}
diff --git a/java/dagger/internal/codegen/ModifiableBindingType.java b/java/dagger/internal/codegen/ModifiableBindingType.java
new file mode 100644
index 000000000..2bec3dc39
--- /dev/null
+++ b/java/dagger/internal/codegen/ModifiableBindingType.java
@@ -0,0 +1,89 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import com.google.common.collect.ImmutableSet;
+
+/**
+ * A label for a binding indicating whether, and how, it may be redefined across implementations of
+ * a subcomponent.
+ *
+ * <p>A subcomponent has multiple implementations only when generating ahead-of-time subcomponents.
+ * Specifically, each subcomponent type in a component hierarchy is implemented as an abstract
+ * class, and descendent components are implemented as abstract inner classes. A consequence of this
+ * is that a given subcomponent has an implementation for each ancestor component. Each
+ * implementation represents a different sub-binding-graph of the full subcomponent. A binding is
+ * modifiable if it's definition may change depending on the characteristics of its ancestor
+ * components.
+ */
+enum ModifiableBindingType {
+  /** A binding that is not modifiable */
+  NONE,
+
+  /**
+   * A binding that is missing when generating the abstract base class implementation of a
+   * subcomponent.
+   */
+  MISSING,
+
+  /**
+   * A binding that requires an instance of a generated type. These binding are modifiable in the
+   * sense that they are encapsulated in a method when they are first required, possibly in an
+   * abstract implementation of a subcomponent, where, in general, no concrete instances of
+   * generated types are available, and the method is satisfied in a final concrete implementation.
+   */
+  GENERATED_INSTANCE,
+
+  /**
+   * Multibindings may have contributions come from any ancestor component. Therefore, each
+   * implementation of a subcomponent may have newly available contributions, and so the binding
+   * method is reimplemented with each subcomponent implementation.
+   */
+  MULTIBINDING,
+
+  /**
+   * A Optional binding that may be empty when looking at a partial binding graph, but bound to a
+   * value when considering the complete binding graph, thus modifiable across subcomponent
+   * implementations.
+   */
+  OPTIONAL,
+
+  /**
+   * If a binding is defined according to an {@code @Inject} annotated constructor on the object it
+   * is valid for that binding to be redefined a single time by an {@code @Provides} annotated
+   * module method. It is possible that the {@code @Provides} binding isn't available in a partial
+   * binding graph, but becomes available when considering a more complete binding graph, therefore
+   * such bindings are modifiable across subcomponent implementations.
+   */
+  INJECTION,
+  ;
+
+  private static final ImmutableSet<ModifiableBindingType> TYPES_WITH_BASE_CLASS_IMPLEMENTATIONS =
+      ImmutableSet.of(NONE, MULTIBINDING, OPTIONAL, INJECTION);
+
+  boolean isModifiable() {
+    return !equals(NONE);
+  }
+
+  /**
+   * Returns true if the method encapsulating the modifiable binding should have a concrete
+   * implementation in the abstract base class for a subcomponent.
+   */
+  boolean hasBaseClassImplementation() {
+    return TYPES_WITH_BASE_CLASS_IMPLEMENTATIONS.contains(this);
+  }
+}
diff --git a/java/dagger/internal/codegen/ModifiableConcreteMethodBindingExpression.java b/java/dagger/internal/codegen/ModifiableConcreteMethodBindingExpression.java
new file mode 100644
index 000000000..fb2c1fdc2
--- /dev/null
+++ b/java/dagger/internal/codegen/ModifiableConcreteMethodBindingExpression.java
@@ -0,0 +1,101 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.base.Preconditions.checkState;
+import static com.squareup.javapoet.MethodSpec.methodBuilder;
+import static javax.lang.model.element.Modifier.PRIVATE;
+import static javax.lang.model.element.Modifier.PUBLIC;
+
+import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.TypeName;
+import dagger.internal.codegen.ModifiableBindingMethods.ModifiableBindingMethod;
+import java.util.Optional;
+
+/**
+ * A binding expression that wraps a modifiable binding expression in a public, no-arg method.
+ *
+ * <p>Dependents of this binding expression will just call the modifiable binding method.
+ */
+final class ModifiableConcreteMethodBindingExpression extends MethodBindingExpression {
+  private final ContributionBinding binding;
+  private final BindingRequest request;
+  private final ModifiableBindingType modifiableBindingType;
+  private final BindingMethodImplementation methodImplementation;
+  private final GeneratedComponentModel generatedComponentModel;
+  private final boolean bindingFinalized;
+  private final Optional<ModifiableBindingMethod> matchingModifiableBindingMethod;
+  private Optional<String> methodName;
+
+  ModifiableConcreteMethodBindingExpression(
+      ResolvedBindings resolvedBindings,
+      BindingRequest request,
+      ModifiableBindingType modifiableBindingType,
+      BindingMethodImplementation methodImplementation,
+      GeneratedComponentModel generatedComponentModel,
+      Optional<ModifiableBindingMethod> matchingModifiableBindingMethod,
+      boolean bindingFinalized) {
+    super(methodImplementation, generatedComponentModel);
+    this.binding = resolvedBindings.contributionBinding();
+    this.request = checkNotNull(request);
+    this.modifiableBindingType = checkNotNull(modifiableBindingType);
+    this.methodImplementation = checkNotNull(methodImplementation);
+    this.generatedComponentModel = checkNotNull(generatedComponentModel);
+    this.bindingFinalized = bindingFinalized;
+    this.matchingModifiableBindingMethod = matchingModifiableBindingMethod;
+    this.methodName =
+        matchingModifiableBindingMethod.map(modifiableMethod -> modifiableMethod.methodSpec().name);
+  }
+
+  @Override
+  CodeBlock getModifiableBindingMethodImplementation(
+      ModifiableBindingMethod modifiableBindingMethod, GeneratedComponentModel component) {
+    // Only emit the method implementation if the binding was known when the expression was created
+    // (and not registered when calling 'getDependencyExpression'), and we're generating a
+    // modifiable binding method for the original component (and not an ancestor component).
+    if (matchingModifiableBindingMethod.isPresent() && generatedComponentModel.equals(component)) {
+      checkState(
+          matchingModifiableBindingMethod.get().fulfillsSameRequestAs(modifiableBindingMethod));
+      return methodImplementation.body();
+    }
+    return super.getModifiableBindingMethodImplementation(modifiableBindingMethod, component);
+  }
+
+  @Override
+  protected void addMethod() {
+    // Add the modifiable binding method to the component model if we haven't already.
+    if (!methodName.isPresent()) {
+      methodName = Optional.of(generatedComponentModel.getUniqueMethodName(request, binding));
+      generatedComponentModel.addModifiableBindingMethod(
+          modifiableBindingType,
+          request,
+          methodBuilder(methodName.get())
+              .addModifiers(bindingFinalized ? PRIVATE : PUBLIC)
+              .returns(TypeName.get(methodImplementation.returnType()))
+              .addCode(methodImplementation.body())
+              .build(),
+          bindingFinalized);
+    }
+  }
+
+  @Override
+  protected String methodName() {
+    checkState(methodName.isPresent(), "addMethod() must be called before methodName().");
+    return methodName.get();
+  }
+}
diff --git a/java/dagger/internal/codegen/MonitoringModuleGenerator.java b/java/dagger/internal/codegen/MonitoringModuleGenerator.java
index d80dccdc4..74502620a 100644
--- a/java/dagger/internal/codegen/MonitoringModuleGenerator.java
+++ b/java/dagger/internal/codegen/MonitoringModuleGenerator.java
@@ -57,8 +57,8 @@ ClassName nameGeneratedType(TypeElement componentElement) {
   }
 
   @Override
-  Optional<? extends Element> getElementForErrorReporting(TypeElement componentElement) {
-    return Optional.of(componentElement);
+  Element originatingElement(TypeElement componentElement) {
+    return componentElement;
   }
 
   @Override
diff --git a/java/dagger/internal/codegen/MultibindingDeclaration.java b/java/dagger/internal/codegen/MultibindingDeclaration.java
index 4fa25f537..a642b1d73 100644
--- a/java/dagger/internal/codegen/MultibindingDeclaration.java
+++ b/java/dagger/internal/codegen/MultibindingDeclaration.java
@@ -21,17 +21,13 @@
 
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
-import dagger.Module;
 import dagger.internal.codegen.ContributionType.HasContributionType;
 import dagger.model.Key;
 import dagger.multibindings.Multibinds;
-import dagger.producers.Producer;
-import dagger.producers.ProducerModule;
 import java.util.Map;
 import java.util.Optional;
 import java.util.Set;
 import javax.inject.Inject;
-import javax.inject.Provider;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
@@ -48,9 +44,8 @@
 abstract class MultibindingDeclaration extends BindingDeclaration implements HasContributionType {
 
   /**
-   * The map or set key whose availability is declared. For maps, this will be {@code Map<K, F<V>>},
-   * where {@code F} is either {@link Provider} or {@link Producer}. For sets, this will be
-   * {@code Set<T>}.
+   * The map or set key whose availability is declared. For maps, this will be {@code Map<K,
+   * Provider<V>>}. For sets, this will be {@code Set<T>}.
    */
   @Override
   public abstract Key key();
@@ -62,13 +57,6 @@
   @Override
   public abstract ContributionType contributionType();
 
-  /**
-   * {@link BindingType#PROVISION} if {@link Multibinds @Multibinds}-annotated method
-   * is enclosed in a {@link Module @Module}, or {@link BindingType#PROVISION} if it is nested in a
-   * {@link ProducerModule @ProducerModule}.
-   */
-  abstract BindingType bindingType();
-
   /**
    * A factory for {@link MultibindingDeclaration}s.
    */
@@ -87,26 +75,13 @@ MultibindingDeclaration forMultibindsMethod(
         ExecutableElement moduleMethod, TypeElement moduleElement) {
       checkArgument(isAnnotationPresent(moduleMethod, Multibinds.class));
       return forDeclaredMethod(
-          bindingType(moduleElement),
           moduleMethod,
           MoreTypes.asExecutable(
               types.asMemberOf(MoreTypes.asDeclared(moduleElement.asType()), moduleMethod)),
           moduleElement);
     }
 
-    private BindingType bindingType(Element moduleElement) {
-      if (isAnnotationPresent(moduleElement, Module.class)) {
-        return BindingType.PROVISION;
-      } else if (isAnnotationPresent(moduleElement, ProducerModule.class)) {
-        return BindingType.PRODUCTION;
-      } else {
-        throw new IllegalArgumentException(
-            "Expected " + moduleElement + " to be a @Module or @ProducerModule");
-      }
-    }
-
     private MultibindingDeclaration forDeclaredMethod(
-        BindingType bindingType,
         ExecutableElement method,
         ExecutableType methodType,
         TypeElement contributingType) {
@@ -118,9 +93,8 @@ private MultibindingDeclaration forDeclaredMethod(
       return new AutoValue_MultibindingDeclaration(
           Optional.<Element>of(method),
           Optional.of(contributingType),
-          keyFactory.forMultibindsMethod(bindingType, methodType, method),
-          contributionType(returnType),
-          bindingType);
+          keyFactory.forMultibindsMethod(methodType, method),
+          contributionType(returnType));
     }
 
     private ContributionType contributionType(TypeMirror returnType) {
diff --git a/java/dagger/internal/codegen/MultibindingExpression.java b/java/dagger/internal/codegen/MultibindingExpression.java
new file mode 100644
index 000000000..337802ec1
--- /dev/null
+++ b/java/dagger/internal/codegen/MultibindingExpression.java
@@ -0,0 +1,94 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.base.Preconditions.checkState;
+import static dagger.internal.codegen.BindingRequest.bindingRequest;
+
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Sets;
+import com.google.common.collect.Sets.SetView;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+import dagger.internal.codegen.ModifiableBindingMethods.ModifiableBindingMethod;
+import dagger.model.DependencyRequest;
+import dagger.model.RequestKind;
+import java.util.Optional;
+
+/** An abstract base class for multibinding {@link BindingExpression}s. */
+abstract class MultibindingExpression extends SimpleInvocationBindingExpression {
+  private final ProvisionBinding binding;
+  private final GeneratedComponentModel generatedComponentModel;
+
+  MultibindingExpression(
+      ResolvedBindings resolvedBindings, GeneratedComponentModel generatedComponentModel) {
+    super(resolvedBindings);
+    this.generatedComponentModel = generatedComponentModel;
+    this.binding = (ProvisionBinding) resolvedBindings.contributionBinding();
+  }
+
+  @Override
+  Expression getDependencyExpression(ClassName requestingClass) {
+    Expression expression = buildDependencyExpression(requestingClass);
+    generatedComponentModel.registerImplementedMultibinding(binding);
+    return expression;
+  }
+
+  /**
+   * Returns an expression that evaluates to the value of a multibinding request for the given
+   * requesting class.
+   */
+  protected abstract Expression buildDependencyExpression(ClassName requestingClass);
+
+  /**
+   * Returns the subset of {@code dependencies} that represent multibinding
+   * contributions that were not included in a superclass implementation of this multibinding
+   * method. This is relevant only for ahead-of-time subcomponents. When not generating
+   * ahead-of-time subcomponents there is only one implementation of a multibinding expression and
+   * all {@link DependencyRequest}s from the argment are returned.
+   */
+  protected SetView<DependencyRequest> getNewContributions(
+      ImmutableSet<DependencyRequest> dependencies) {
+    return Sets.difference(
+        dependencies, generatedComponentModel.superclassContributionsMade(binding.key()));
+  }
+
+  /**
+   * Returns the {@link CodeBlock} representing a call to a superclass implementation of the
+   * modifiable binding method that encapsulates this binding, if it exists. This is only possible
+   * when generating ahead-of-time subcomponents.
+   */
+  protected Optional<CodeBlock> superMethodCall() {
+    if (generatedComponentModel.supermodel().isPresent()) {
+      Optional<ModifiableBindingMethod> method =
+          generatedComponentModel.getModifiableBindingMethod(
+              bindingRequest(binding.key(), RequestKind.INSTANCE));
+      checkState(
+          method.isPresent(),
+          "Generating a multibinding super method call when no method has been registered for the "
+              + "binding. Binding is for a %s in %s",
+          binding.key(),
+          generatedComponentModel.name());
+      ImmutableSet<DependencyRequest> superclassContributions =
+          generatedComponentModel.superclassContributionsMade(binding.key());
+      if (!superclassContributions.isEmpty()) {
+        return Optional.of(CodeBlock.of("super.$L()", method.get().methodSpec().name));
+      }
+    }
+    return Optional.empty();
+  }
+}
diff --git a/java/dagger/internal/codegen/MultibindsMethodValidator.java b/java/dagger/internal/codegen/MultibindsMethodValidator.java
index bfac2839a..8e8765d08 100644
--- a/java/dagger/internal/codegen/MultibindsMethodValidator.java
+++ b/java/dagger/internal/codegen/MultibindsMethodValidator.java
@@ -36,12 +36,14 @@
 
   /** Creates a validator for {@link Multibinds @Multibinds} methods. */
   @Inject
-  MultibindsMethodValidator(DaggerElements elements, Types types) {
+  MultibindsMethodValidator(
+      DaggerElements elements, Types types, DependencyRequestValidator dependencyRequestValidator) {
     super(
         elements,
         types,
         Multibinds.class,
         ImmutableSet.of(Module.class, ProducerModule.class),
+        dependencyRequestValidator,
         MUST_BE_ABSTRACT,
         NO_EXCEPTIONS,
         NO_MULTIBINDINGS);
@@ -54,7 +56,8 @@ protected void checkMethod(ValidationReport.Builder<ExecutableElement> builder)
     checkParameters(builder);
   }
 
-  private void checkParameters(ValidationReport.Builder<ExecutableElement> builder) {
+  @Override
+  protected void checkParameters(ValidationReport.Builder<ExecutableElement> builder) {
     if (!builder.getSubject().getParameters().isEmpty()) {
       builder.addError(bindingMethods("cannot have parameters"));
     }
diff --git a/java/dagger/internal/codegen/NonNullableRequestForNullableBindingValidation.java b/java/dagger/internal/codegen/NullableBindingValidator.java
similarity index 83%
rename from java/dagger/internal/codegen/NonNullableRequestForNullableBindingValidation.java
rename to java/dagger/internal/codegen/NullableBindingValidator.java
index 6734824fd..553192eb9 100644
--- a/java/dagger/internal/codegen/NonNullableRequestForNullableBindingValidation.java
+++ b/java/dagger/internal/codegen/NullableBindingValidator.java
@@ -18,9 +18,11 @@
 
 import static dagger.internal.codegen.DaggerStreams.instancesOf;
 import static dagger.internal.codegen.DaggerStreams.toImmutableList;
+import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
 
 import com.google.common.annotations.VisibleForTesting;
 import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
 import dagger.model.BindingGraph;
 import dagger.model.BindingGraph.BindingNode;
 import dagger.model.BindingGraph.DependencyEdge;
@@ -32,12 +34,12 @@
  * Reports errors or warnings (depending on the {@code -Adagger.nullableValidation} value) for each
  * non-nullable dependency request that is satisfied by a nullable binding.
  */
-final class NonNullableRequestForNullableBindingValidation implements BindingGraphPlugin {
+final class NullableBindingValidator implements BindingGraphPlugin {
 
   private final CompilerOptions compilerOptions;
 
   @Inject
-  NonNullableRequestForNullableBindingValidation(CompilerOptions compilerOptions) {
+  NullableBindingValidator(CompilerOptions compilerOptions) {
     this.compilerOptions = compilerOptions;
   }
 
@@ -49,7 +51,7 @@ public void visitGraph(BindingGraph bindingGraph, DiagnosticReporter diagnosticR
             compilerOptions.nullableValidationKind(),
             dependencyEdge,
             nullableToNonNullable(
-                bindingNode.binding().key().toString(),
+                bindingNode.key().toString(),
                 bindingNode.toString())); // will include the @Nullable
       }
     }
@@ -61,21 +63,17 @@ public String pluginName() {
   }
 
   private ImmutableList<BindingNode> nullableBindings(BindingGraph bindingGraph) {
-    return bindingGraph
-        .bindingNodes()
-        .stream()
+    return bindingGraph.bindingNodes().stream()
         .filter(bindingNode -> bindingNode.binding().isNullable())
         .collect(toImmutableList());
   }
 
-  private ImmutableList<DependencyEdge> nonNullableDependencies(
+  private ImmutableSet<DependencyEdge> nonNullableDependencies(
       BindingGraph bindingGraph, BindingNode bindingNode) {
-    return bindingGraph
-        .inEdges(bindingNode)
-        .stream()
+    return bindingGraph.network().inEdges(bindingNode).stream()
         .flatMap(instancesOf(DependencyEdge.class))
         .filter(edge -> !edge.dependencyRequest().isNullable())
-        .collect(toImmutableList());
+        .collect(toImmutableSet());
   }
 
   @VisibleForTesting
diff --git a/java/dagger/internal/codegen/OptionalBindingExpression.java b/java/dagger/internal/codegen/OptionalBindingExpression.java
index 68941dd0f..682978522 100644
--- a/java/dagger/internal/codegen/OptionalBindingExpression.java
+++ b/java/dagger/internal/codegen/OptionalBindingExpression.java
@@ -18,6 +18,7 @@
 
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static dagger.internal.codegen.Accessibility.isTypeAccessibleFrom;
+import static dagger.internal.codegen.BindingRequest.bindingRequest;
 
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
@@ -63,7 +64,7 @@ Expression getDependencyExpression(ClassName requestingClass) {
 
     CodeBlock dependencyExpression =
         componentBindingExpressions
-            .getDependencyExpression(dependency, requestingClass)
+            .getDependencyExpression(bindingRequest(dependency), requestingClass)
             .codeBlock();
 
     // If the dependency type is inaccessible, then we have to use Optional.<Object>of(...), or else
diff --git a/java/dagger/internal/codegen/OptionalFactories.java b/java/dagger/internal/codegen/OptionalFactories.java
index 3297823d0..71523b9eb 100644
--- a/java/dagger/internal/codegen/OptionalFactories.java
+++ b/java/dagger/internal/codegen/OptionalFactories.java
@@ -31,6 +31,7 @@
 import static dagger.internal.codegen.GeneratedComponentModel.TypeSpecKind.PRESENT_FACTORY;
 import static dagger.internal.codegen.RequestKinds.requestTypeName;
 import static dagger.internal.codegen.TypeNames.PROVIDER;
+import static dagger.internal.codegen.TypeNames.abstractProducerOf;
 import static dagger.internal.codegen.TypeNames.listenableFutureOf;
 import static dagger.internal.codegen.TypeNames.providerOf;
 import static javax.lang.model.element.Modifier.FINAL;
@@ -60,6 +61,7 @@
 import dagger.producers.internal.Producers;
 import java.util.Comparator;
 import java.util.Map;
+import java.util.Optional;
 import java.util.TreeMap;
 import java.util.concurrent.Executor;
 import javax.inject.Provider;
@@ -83,7 +85,7 @@
   private final Map<PresentFactorySpec, TypeSpec> presentFactoryClasses =
       new TreeMap<>(
           Comparator.comparing(PresentFactorySpec::valueKind)
-              .thenComparing(PresentFactorySpec::bindingType)
+              .thenComparing(PresentFactorySpec::frameworkType)
               .thenComparing(PresentFactorySpec::optionalKind));
 
   /**
@@ -173,7 +175,7 @@ private FieldSpec absentOptionalProviderField(OptionalKind optionalKind) {
   @AutoValue
   abstract static class PresentFactorySpec {
     /** Whether the factory is a {@link Provider} or a {@link Producer}. */
-    abstract BindingType bindingType();
+    abstract FrameworkType frameworkType();
 
     /** What kind of {@code Optional} is returned. */
     abstract OptionalKind optionalKind();
@@ -198,12 +200,50 @@ ParameterizedTypeName optionalType() {
 
     /** The type of the factory. */
     ParameterizedTypeName factoryType() {
-      return bindingType().frameworkClassOf(optionalType());
+      return frameworkType().frameworkClassOf(optionalType());
     }
 
     /** The type of the delegate provider or producer. */
     ParameterizedTypeName delegateType() {
-      return bindingType().frameworkClassOf(typeVariable());
+      return frameworkType().frameworkClassOf(typeVariable());
+    }
+
+    /** Returns the superclass the generated factory should have, if any. */
+    Optional<ParameterizedTypeName> superclass() {
+      switch (frameworkType()) {
+        case PRODUCER_NODE:
+          // TODO(cgdecker): This probably isn't a big issue for now, but it's possible this
+          // shouldn't be an AbstractProducer:
+          // - As AbstractProducer, it'll only call the delegate's get() method once and then cache
+          //   that result (essentially) rather than calling the delegate's get() method each time
+          //   its get() method is called (which was what it did before the cancellation change).
+          // - It's not 100% clear to me whether the view-creation methods should return a view of
+          //   the same view created by the delegate or if they should just return their own views.
+          return Optional.of(abstractProducerOf(optionalType()));
+        default:
+          return Optional.empty();
+      }
+    }
+
+    /** Returns the superinterface the generated factory should have, if any. */
+    Optional<ParameterizedTypeName> superinterface() {
+      switch (frameworkType()) {
+        case PROVIDER:
+          return Optional.of(factoryType());
+        default:
+          return Optional.empty();
+      }
+    }
+
+    /** Returns the name of the factory method to generate. */
+    String factoryMethodName() {
+      switch (frameworkType()) {
+        case PROVIDER:
+          return "get";
+        case PRODUCER_NODE:
+          return "compute";
+      }
+      throw new AssertionError(frameworkType());
     }
 
     /** The name of the factory class. */
@@ -211,13 +251,13 @@ String factoryClassName() {
       return new StringBuilder("Present")
           .append(UPPER_UNDERSCORE.to(UPPER_CAMEL, optionalKind().name()))
           .append(UPPER_UNDERSCORE.to(UPPER_CAMEL, valueKind().toString()))
-          .append(bindingType().frameworkClass().getSimpleName())
+          .append(frameworkType().frameworkClass().getSimpleName())
           .toString();
     }
 
     private static PresentFactorySpec of(ContributionBinding binding) {
       return new AutoValue_OptionalFactories_PresentFactorySpec(
-          binding.bindingType(),
+          FrameworkType.forBindingType(binding.bindingType()),
           OptionalType.from(binding.key()).kind(),
           getOnlyElement(binding.dependencies()).kind());
     }
@@ -263,12 +303,19 @@ private TypeSpec presentOptionalFactoryClass(PresentFactorySpec spec) {
     FieldSpec delegateField =
         FieldSpec.builder(spec.delegateType(), "delegate", PRIVATE, FINAL).build();
     ParameterSpec delegateParameter = ParameterSpec.builder(delegateField.type, "delegate").build();
-    return classBuilder(spec.factoryClassName())
-        .addTypeVariable(spec.typeVariable())
-        .addModifiers(PRIVATE, STATIC, FINAL)
-        .addSuperinterface(spec.factoryType())
-        .addJavadoc(
-            "A {@code $T} that uses a delegate {@code $T}.", spec.factoryType(), delegateField.type)
+    TypeSpec.Builder factoryClassBuilder =
+        classBuilder(spec.factoryClassName())
+            .addTypeVariable(spec.typeVariable())
+            .addModifiers(PRIVATE, STATIC, FINAL)
+            .addJavadoc(
+                "A {@code $T} that uses a delegate {@code $T}.",
+                spec.factoryType(),
+                delegateField.type);
+
+    spec.superclass().ifPresent(factoryClassBuilder::superclass);
+    spec.superinterface().ifPresent(factoryClassBuilder::addSuperinterface);
+
+    return factoryClassBuilder
         .addField(delegateField)
         .addMethod(
             constructorBuilder()
@@ -299,10 +346,10 @@ private TypeSpec presentOptionalFactoryClass(PresentFactorySpec spec) {
   private MethodSpec presentOptionalFactoryGetMethod(
       PresentFactorySpec spec, FieldSpec delegateField) {
     MethodSpec.Builder getMethodBuilder =
-        methodBuilder("get").addAnnotation(Override.class).addModifiers(PUBLIC);
+        methodBuilder(spec.factoryMethodName()).addAnnotation(Override.class).addModifiers(PUBLIC);
 
-    switch (spec.bindingType()) {
-      case PROVISION:
+    switch (spec.frameworkType()) {
+      case PROVIDER:
         return getMethodBuilder
             .returns(spec.optionalType())
             .addCode(
@@ -313,7 +360,7 @@ private MethodSpec presentOptionalFactoryGetMethod(
                             spec.valueKind(), CodeBlock.of("$N", delegateField))))
             .build();
 
-      case PRODUCTION:
+      case PRODUCER_NODE:
         getMethodBuilder.returns(listenableFutureOf(spec.optionalType()));
 
         switch (spec.valueKind()) {
@@ -325,7 +372,7 @@ private MethodSpec presentOptionalFactoryGetMethod(
                     Futures.class,
                     spec.optionalKind()
                         .presentExpression(
-                            FrameworkType.PRODUCER.to(
+                            FrameworkType.PRODUCER_NODE.to(
                                 spec.valueKind(), CodeBlock.of("$N", delegateField))))
                 .build();
 
@@ -356,7 +403,7 @@ private MethodSpec presentOptionalFactoryGetMethod(
         }
 
       default:
-        throw new AssertionError(spec.bindingType());
+        throw new AssertionError(spec.frameworkType());
     }
   }
 
diff --git a/java/dagger/internal/codegen/OptionalFactoryInstanceCreationExpression.java b/java/dagger/internal/codegen/OptionalFactoryInstanceCreationExpression.java
index cffcbc83e..074167da4 100644
--- a/java/dagger/internal/codegen/OptionalFactoryInstanceCreationExpression.java
+++ b/java/dagger/internal/codegen/OptionalFactoryInstanceCreationExpression.java
@@ -17,6 +17,7 @@
 package dagger.internal.codegen;
 
 import static com.google.common.collect.Iterables.getOnlyElement;
+import static dagger.internal.codegen.BindingRequest.bindingRequest;
 
 import com.squareup.javapoet.CodeBlock;
 import dagger.internal.codegen.FrameworkFieldInitializer.FrameworkInstanceCreationExpression;
@@ -51,7 +52,8 @@ public CodeBlock creationExpression() {
             binding,
             componentBindingExpressions
                 .getDependencyExpression(
-                    getOnlyElement(binding.frameworkDependencies()), generatedComponentModel.name())
+                    bindingRequest(getOnlyElement(binding.frameworkDependencies())),
+                    generatedComponentModel.name())
                 .codeBlock());
   }
 
diff --git a/java/dagger/internal/codegen/PrivateMethodBindingExpression.java b/java/dagger/internal/codegen/PrivateMethodBindingExpression.java
index e19f9b853..88893fd8a 100644
--- a/java/dagger/internal/codegen/PrivateMethodBindingExpression.java
+++ b/java/dagger/internal/codegen/PrivateMethodBindingExpression.java
@@ -16,9 +16,6 @@
 
 package dagger.internal.codegen;
 
-import static com.google.common.base.CaseFormat.LOWER_CAMEL;
-import static com.google.common.base.CaseFormat.UPPER_CAMEL;
-import static com.google.common.base.CaseFormat.UPPER_UNDERSCORE;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
 import static com.squareup.javapoet.MethodSpec.methodBuilder;
@@ -26,7 +23,6 @@
 import static javax.lang.model.element.Modifier.PRIVATE;
 
 import com.squareup.javapoet.TypeName;
-import dagger.model.RequestKind;
 
 /**
  * A binding expression that wraps the dependency expressions in a private, no-arg method.
@@ -35,19 +31,19 @@
  */
 final class PrivateMethodBindingExpression extends MethodBindingExpression {
   private final ContributionBinding binding;
-  private final RequestKind requestKind;
+  private final BindingRequest request;
   private final BindingMethodImplementation methodImplementation;
   private final GeneratedComponentModel generatedComponentModel;
   private String methodName;
 
   PrivateMethodBindingExpression(
       ResolvedBindings resolvedBindings,
-      RequestKind requestKind,
+      BindingRequest request,
       BindingMethodImplementation methodImplementation,
       GeneratedComponentModel generatedComponentModel) {
     super(methodImplementation, generatedComponentModel);
     this.binding = resolvedBindings.contributionBinding();
-    this.requestKind = checkNotNull(requestKind);
+    this.request = checkNotNull(request);
     this.methodImplementation = checkNotNull(methodImplementation);
     this.generatedComponentModel = checkNotNull(generatedComponentModel);
   }
@@ -56,7 +52,7 @@
   protected void addMethod() {
     if (methodName == null) {
       // Have to set methodName field before implementing the method in order to handle recursion.
-      methodName = chooseMethodName();
+      methodName = generatedComponentModel.getUniqueMethodName(request, binding);
       // TODO(user): Fix the order that these generated methods are written to the component.
       generatedComponentModel.addMethod(
           PRIVATE_METHOD,
@@ -73,23 +69,4 @@ protected String methodName() {
     checkState(methodName != null, "addMethod() must be called before methodName()");
     return methodName;
   }
-
-  private String chooseMethodName() {
-    // TODO(user): Use a better name for @MapKey binding instances.
-    // TODO(user): Include the binding method as part of the method name.
-    return generatedComponentModel.getUniqueMethodName(
-        "get" + bindingName() + dependencyKindName());
-  }
-
-  /** Returns the canonical method name suffix for the binding. */
-  private String bindingName() {
-    return LOWER_CAMEL.to(UPPER_CAMEL, BindingVariableNamer.name(binding));
-  }
-
-  /** Returns a canonical method name suffix for the request kind. */
-  private String dependencyKindName() {
-    return requestKind.equals(RequestKind.INSTANCE)
-        ? ""
-        : UPPER_UNDERSCORE.to(UPPER_CAMEL, requestKind.name());
-  }
 }
diff --git a/java/dagger/internal/codegen/ProcessingEnvironmentModule.java b/java/dagger/internal/codegen/ProcessingEnvironmentModule.java
index 786955570..9bb0873d0 100644
--- a/java/dagger/internal/codegen/ProcessingEnvironmentModule.java
+++ b/java/dagger/internal/codegen/ProcessingEnvironmentModule.java
@@ -54,9 +54,8 @@ Messager messager() {
   }
 
   @Provides
-  @Reusable // to avoid noting about disabling the formatter more than once
-  Filer filer(CompilerOptions compilerOptions, Messager messager) {
-    if (compilerOptions.headerCompilation()) {
+  Filer filer(CompilerOptions compilerOptions) {
+    if (compilerOptions.headerCompilation() || !compilerOptions.formatGeneratedSource()) {
       return processingEnvironment.getFiler();
     } else {
       return new FormattingFiler(processingEnvironment.getFiler());
@@ -80,8 +79,8 @@ DaggerElements daggerElements() {
 
   @Provides
   @Reusable // to avoid parsing options more than once
-  CompilerOptions compilerOptions(DaggerElements elements) {
-    return CompilerOptions.create(processingEnvironment, elements);
+  CompilerOptions compilerOptions() {
+    return CompilerOptions.create(processingEnvironment);
   }
 
   @Module
diff --git a/java/dagger/internal/codegen/ProducerFactoryGenerator.java b/java/dagger/internal/codegen/ProducerFactoryGenerator.java
index 16e5cd923..efc0c515e 100644
--- a/java/dagger/internal/codegen/ProducerFactoryGenerator.java
+++ b/java/dagger/internal/codegen/ProducerFactoryGenerator.java
@@ -29,14 +29,10 @@
 import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
 import static dagger.internal.codegen.SourceFiles.generateBindingFieldsForDependencies;
 import static dagger.internal.codegen.SourceFiles.generatedClassNameForBinding;
-import static dagger.internal.codegen.TypeNames.ASYNC_FUNCTION;
-import static dagger.internal.codegen.TypeNames.EXECUTOR;
 import static dagger.internal.codegen.TypeNames.FUTURES;
 import static dagger.internal.codegen.TypeNames.PRODUCERS;
 import static dagger.internal.codegen.TypeNames.PRODUCER_TOKEN;
-import static dagger.internal.codegen.TypeNames.RUNNABLE;
 import static dagger.internal.codegen.TypeNames.VOID_CLASS;
-import static dagger.internal.codegen.TypeNames.abstractProducerOf;
 import static dagger.internal.codegen.TypeNames.listOf;
 import static dagger.internal.codegen.TypeNames.listenableFutureOf;
 import static dagger.internal.codegen.TypeNames.producedOf;
@@ -46,7 +42,6 @@
 import static javax.lang.model.element.Modifier.PROTECTED;
 import static javax.lang.model.element.Modifier.PUBLIC;
 
-import com.google.common.base.Joiner;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
@@ -63,6 +58,8 @@
 import dagger.model.Key;
 import dagger.model.RequestKind;
 import dagger.producers.Producer;
+import dagger.producers.internal.AbstractProducesMethodProducer;
+import dagger.producers.internal.Producers;
 import java.util.Map;
 import java.util.Optional;
 import javax.annotation.processing.Filer;
@@ -97,8 +94,9 @@ ClassName nameGeneratedType(ProductionBinding binding) {
   }
 
   @Override
-  Optional<? extends Element> getElementForErrorReporting(ProductionBinding binding) {
-    return binding.bindingElement();
+  Element originatingElement(ProductionBinding binding) {
+    // we only create factories for bindings that have a binding element
+    return binding.bindingElement().get();
   }
 
   @Override
@@ -119,7 +117,6 @@ ClassName nameGeneratedType(ProductionBinding binding) {
                     .addMember("value", "$S", "FutureReturnValueIgnored")
                     .build())
             .addModifiers(PUBLIC, FINAL)
-            .superclass(abstractProducerOf(providedTypeName))
             .addTypeVariables(bindingTypeElementTypeVariableNames(binding));
 
     UniqueNameSet uniqueFieldNames = new UniqueNameSet();
@@ -137,44 +134,46 @@ ClassName nameGeneratedType(ProductionBinding binding) {
                     TypeName.get(binding.bindingTypeElement().get().asType())))
             : Optional.empty();
 
-    String monitorParameterName = null;
-    for (Map.Entry<Key, FrameworkField> entry :
-        generateBindingFieldsForDependencies(binding).entrySet()) {
-      Key key = entry.getKey();
-      FrameworkField bindingField = entry.getValue();
-      String fieldName = uniqueFieldNames.getUniqueName(bindingField.name());
-      if (key.equals(keyFactory.forProductionComponentMonitor())) {
-        monitorParameterName = fieldName;
-        constructorBuilder.addParameter(bindingField.type(), monitorParameterName);
-        continue;
-      }
-
-      FieldSpec field =
-          addFieldAndConstructorParameter(
-              factoryBuilder,
-              constructorBuilder,
-              fieldName,
-              bindingField.type());
-      fieldsBuilder.put(key, field);
-    }
+    String[] executorParameterName = new String[1];
+    String[] monitorParameterName = new String[1];
+    Map<Key, FrameworkField> bindingFieldsForDependencies =
+        generateBindingFieldsForDependencies(binding);
+    bindingFieldsForDependencies.forEach(
+        (key, bindingField) -> {
+          String fieldName = uniqueFieldNames.getUniqueName(bindingField.name());
+          if (key.equals(keyFactory.forProductionImplementationExecutor())) {
+            executorParameterName[0] = fieldName;
+            constructorBuilder.addParameter(bindingField.type(), executorParameterName[0]);
+          } else if (key.equals(keyFactory.forProductionComponentMonitor())) {
+            monitorParameterName[0] = fieldName;
+            constructorBuilder.addParameter(bindingField.type(), monitorParameterName[0]);
+          } else {
+            FieldSpec field =
+                addFieldAndConstructorParameter(
+                    factoryBuilder, constructorBuilder, fieldName, bindingField.type());
+            fieldsBuilder.put(key, field);
+          }
+        });
     ImmutableMap<Key, FieldSpec> fields = fieldsBuilder.build();
 
     constructorBuilder.addStatement(
-        "super($N, $L)",
-        verifyNotNull(monitorParameterName),
-        producerTokenConstruction(generatedTypeName, binding));
+        "super($N, $L, $N)",
+        verifyNotNull(monitorParameterName[0]),
+        producerTokenConstruction(generatedTypeName, binding),
+        verifyNotNull(executorParameterName[0]));
 
     if (binding.requiresModuleInstance()) {
-      assignField(constructorBuilder, moduleField.get());
-    }
-    
-    for (FieldSpec field : fields.values()) {
-      assignField(constructorBuilder, field);
+      assignField(constructorBuilder, moduleField.get(), null);
     }
 
-    MethodSpec.Builder computeMethodBuilder =
-        methodBuilder("compute")
-            .returns(futureTypeName)
+    fields.forEach(
+        (key, field) -> {
+          ParameterizedTypeName type = bindingFieldsForDependencies.get(key).type();
+          assignField(constructorBuilder, field, type);
+        });
+
+    MethodSpec.Builder collectDependenciesBuilder =
+        methodBuilder("collectDependencies")
             .addAnnotation(Override.class)
             .addModifiers(PROTECTED);
 
@@ -182,7 +181,7 @@ ClassName nameGeneratedType(ProductionBinding binding) {
     for (DependencyRequest dependency : asyncDependencies) {
       TypeName futureType = listenableFutureOf(asyncDependencyType(dependency));
       CodeBlock futureAccess = CodeBlock.of("$N.get()", fields.get(dependency.key()));
-      computeMethodBuilder.addStatement(
+      collectDependenciesBuilder.addStatement(
           "$T $L = $L",
           futureType,
           dependencyFutureName(dependency),
@@ -192,22 +191,13 @@ ClassName nameGeneratedType(ProductionBinding binding) {
     }
     FutureTransform futureTransform = FutureTransform.create(fields, binding, asyncDependencies);
 
-    computeMethodBuilder.addStatement(
-        "return $T.transformAsync($L, this, this)",
-        FUTURES,
-        futureTransform.futureCodeBlock());
-
-    factoryBuilder
-        .addSuperinterface(
-            ParameterizedTypeName.get(
-                ASYNC_FUNCTION, futureTransform.applyArgType(), providedTypeName))
-        .addSuperinterface(EXECUTOR);
+    collectDependenciesBuilder
+        .returns(listenableFutureOf(futureTransform.applyArgType()))
+        .addStatement("return $L", futureTransform.futureCodeBlock());
 
-    MethodSpec.Builder applyMethodBuilder =
-        methodBuilder("apply")
+    MethodSpec.Builder callProducesMethod =
+        methodBuilder("callProducesMethod")
             .returns(futureTypeName)
-            .addJavadoc("@deprecated this may only be called from the internal {@link #compute()}")
-            .addAnnotation(Deprecated.class)
             .addAnnotation(Override.class)
             .addModifiers(PUBLIC)
             .addParameter(futureTransform.applyArgType(), futureTransform.applyArgName())
@@ -216,23 +206,18 @@ ClassName nameGeneratedType(ProductionBinding binding) {
                 getInvocationCodeBlock(
                     binding, providedTypeName, futureTransform.parameterCodeBlocks()));
     if (futureTransform.hasUncheckedCast()) {
-      applyMethodBuilder.addAnnotation(AnnotationSpecs.suppressWarnings(UNCHECKED));
+      callProducesMethod.addAnnotation(AnnotationSpecs.suppressWarnings(UNCHECKED));
     }
 
-    MethodSpec.Builder executeMethodBuilder =
-        methodBuilder("execute")
-            .addModifiers(PUBLIC)
-            .addJavadoc("@deprecated this may only be called from the internal {@link #compute()}")
-            .addAnnotation(Deprecated.class)
-            .addAnnotation(Override.class)
-            .addParameter(RUNNABLE, "runnable")
-            .addStatement("monitor.ready()")
-            .addStatement("executorProvider.get().execute(runnable)");
-
-    factoryBuilder.addMethod(constructorBuilder.build());
-    factoryBuilder.addMethod(computeMethodBuilder.build());
-    factoryBuilder.addMethod(applyMethodBuilder.build());
-    factoryBuilder.addMethod(executeMethodBuilder.build());
+    factoryBuilder
+        .superclass(
+            ParameterizedTypeName.get(
+                ClassName.get(AbstractProducesMethodProducer.class),
+                futureTransform.applyArgType(),
+                providedTypeName))
+        .addMethod(constructorBuilder.build())
+        .addMethod(collectDependenciesBuilder.build())
+        .addMethod(callProducesMethod.build());
 
     gwtIncompatibleAnnotation(binding).ifPresent(factoryBuilder::addAnnotation);
 
@@ -252,8 +237,14 @@ private static FieldSpec addFieldAndConstructorParameter(
     return field;
   }
 
-  private static void assignField(MethodSpec.Builder constructorBuilder, FieldSpec field) {
-    constructorBuilder.addStatement("this.$1N = $1N", field);
+  private static void assignField(
+      MethodSpec.Builder constructorBuilder, FieldSpec field, ParameterizedTypeName type) {
+    if (type != null && type.rawType.equals(TypeNames.PRODUCER)) {
+      constructorBuilder.addStatement(
+          "this.$1N = $2T.nonCancellationPropagatingViewOf($1N)", field, Producers.class);
+    } else {
+      constructorBuilder.addStatement("this.$1N = $1N", field);
+    }
   }
 
   /** Returns a list of dependencies that are generated asynchronously. */
@@ -519,12 +510,6 @@ private CodeBlock getInvocationCodeBlock(
             binding.bindingElement().get().getSimpleName(),
             makeParametersCodeBlock(parameterCodeBlocks));
 
-    // NOTE(beder): We don't worry about catching exceptions from the monitor methods themselves
-    // because we'll wrap all monitoring in non-throwing monitors before we pass them to the
-    // factories.
-    ImmutableList.Builder<CodeBlock> codeBlocks = ImmutableList.builder();
-    codeBlocks.add(CodeBlock.of("monitor.methodStarting();"));
-
     final CodeBlock returnCodeBlock;
     switch (binding.productionKind().get()) {
       case IMMEDIATE:
@@ -540,16 +525,7 @@ private CodeBlock getInvocationCodeBlock(
       default:
         throw new AssertionError();
     }
-    return CodeBlock.of(
-        Joiner.on('\n')
-            .join(
-                "monitor.methodStarting();",
-                "try {",
-                "  return $L;",
-                "} finally {",
-                "  monitor.methodFinished();",
-                "}"),
-        returnCodeBlock);
+    return CodeBlock.of("return $L;", returnCodeBlock);
   }
 
   /**
diff --git a/java/dagger/internal/codegen/ProducerFromProviderCreationExpression.java b/java/dagger/internal/codegen/ProducerFromProviderCreationExpression.java
index f34e26cfd..d4f6d8587 100644
--- a/java/dagger/internal/codegen/ProducerFromProviderCreationExpression.java
+++ b/java/dagger/internal/codegen/ProducerFromProviderCreationExpression.java
@@ -17,7 +17,7 @@
 package dagger.internal.codegen;
 
 import static com.google.common.base.Preconditions.checkNotNull;
-import static dagger.internal.codegen.BindingType.PROVISION;
+import static dagger.internal.codegen.BindingRequest.bindingRequest;
 
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
@@ -47,7 +47,7 @@ public CodeBlock creationExpression() {
         RequestKind.PRODUCER,
         componentBindingExpressions
             .getDependencyExpression(
-                FrameworkDependency.create(binding.key(), PROVISION),
+                bindingRequest(binding.key(), FrameworkType.PROVIDER),
                 generatedComponentModel.name())
             .codeBlock());
   }
diff --git a/java/dagger/internal/codegen/ProducerNodeInstanceBindingExpression.java b/java/dagger/internal/codegen/ProducerNodeInstanceBindingExpression.java
new file mode 100644
index 000000000..dd8689e8e
--- /dev/null
+++ b/java/dagger/internal/codegen/ProducerNodeInstanceBindingExpression.java
@@ -0,0 +1,111 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.base.Preconditions.checkNotNull;
+import static dagger.internal.codegen.GeneratedComponentModel.FieldSpecKind.FRAMEWORK_FIELD;
+import static javax.lang.model.element.Modifier.PRIVATE;
+
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.FieldSpec;
+import com.squareup.javapoet.TypeName;
+import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
+import dagger.producers.Producer;
+import dagger.producers.internal.Producers;
+import javax.lang.model.type.TypeMirror;
+
+/** Binding expression for producer node instances. */
+final class ProducerNodeInstanceBindingExpression extends FrameworkInstanceBindingExpression {
+
+  static final String MAY_INTERRUPT_IF_RUNNING = "mayInterruptIfRunning";
+
+  /** Model for the component defining this binding. */
+  private final GeneratedComponentModel generatedComponentModel;
+
+  private final TypeMirror type;
+  private boolean addedCancellationStatement = false;
+
+  ProducerNodeInstanceBindingExpression(
+      ResolvedBindings resolvedBindings,
+      FrameworkInstanceSupplier frameworkInstanceSupplier,
+      DaggerTypes types,
+      DaggerElements elements,
+      GeneratedComponentModel generatedComponentModel) {
+    super(resolvedBindings, frameworkInstanceSupplier, types, elements);
+    this.generatedComponentModel = checkNotNull(generatedComponentModel);
+    this.type = types.wrapType(resolvedBindings.key().type(), Producer.class);
+  }
+
+  @Override
+  protected FrameworkType frameworkType() {
+    return FrameworkType.PRODUCER_NODE;
+  }
+
+  @Override
+  Expression getDependencyExpression(ClassName requestingClass) {
+    Expression result = super.getDependencyExpression(requestingClass);
+    if (!addedCancellationStatement) {
+      CodeBlock cancel =
+          CodeBlock.of(
+              "$T.cancel($L, $L);", Producers.class, result.codeBlock(), MAY_INTERRUPT_IF_RUNNING);
+      generatedComponentModel.addCancellation(cancel);
+      addedCancellationStatement = true;
+    }
+    return result;
+  }
+
+  @Override
+  Expression getDependencyExpressionForComponentMethod(
+      ComponentMethodDescriptor componentMethod, GeneratedComponentModel component) {
+    if (component.componentDescriptor().kind().isProducer()) {
+      return Expression.create(type, "$N", createField(componentMethod, component));
+    } else {
+      // If the component isn't a production component, it won't implement CancellationListener and
+      // as such we can't create an entry point. But this binding must also just be a Producer from
+      // Provider anyway in that case, so there shouldn't be an issue.
+      // TODO(b/116855531): Is it really intended that a non-production component can have Producer
+      // entry points?
+      return super.getDependencyExpressionForComponentMethod(componentMethod, component);
+    }
+  }
+
+  private FieldSpec createField(
+      ComponentMethodDescriptor componentMethod, GeneratedComponentModel component) {
+    // TODO(cgdecker): Use a FrameworkFieldInitializer for this?
+    // Though I don't think we need the once-only behavior of that, since I think
+    // getComponentMethodImplementation will only be called once anyway
+    String methodName = componentMethod.methodElement().getSimpleName().toString();
+    FieldSpec field =
+        FieldSpec.builder(
+                TypeName.get(type),
+                component.getUniqueFieldName(methodName + "EntryPoint"),
+                PRIVATE)
+            .build();
+    component.addField(FRAMEWORK_FIELD, field);
+
+    CodeBlock fieldInitialization =
+        CodeBlock.of(
+            "this.$N = $T.entryPointViewOf($L, this);",
+            field,
+            Producers.class,
+            getDependencyExpression(component.name()).codeBlock());
+    component.addInitialization(fieldInitialization);
+
+    return field;
+  }
+}
diff --git a/java/dagger/internal/codegen/ProducesMethodValidator.java b/java/dagger/internal/codegen/ProducesMethodValidator.java
index 2245dff30..5a043da4c 100644
--- a/java/dagger/internal/codegen/ProducesMethodValidator.java
+++ b/java/dagger/internal/codegen/ProducesMethodValidator.java
@@ -41,10 +41,12 @@
 final class ProducesMethodValidator extends BindingMethodValidator {
 
   @Inject
-  ProducesMethodValidator(DaggerElements elements, Types types) {
+  ProducesMethodValidator(
+      DaggerElements elements, Types types, DependencyRequestValidator dependencyRequestValidator) {
     super(
         elements,
         types,
+        dependencyRequestValidator,
         Produces.class,
         ProducerModule.class,
         MUST_BE_CONCRETE,
@@ -56,7 +58,6 @@
   protected void checkMethod(ValidationReport.Builder<ExecutableElement> builder) {
     super.checkMethod(builder);
     checkNullable(builder);
-    checkScope(builder);
   }
 
   /** Adds a warning if a {@link Produces @Produces} method is declared nullable. */
@@ -68,7 +69,8 @@ private void checkNullable(ValidationReport.Builder<ExecutableElement> builder)
   }
 
   /** Adds an error if a {@link Produces @Produces} method has a scope annotation. */
-  private void checkScope(ValidationReport.Builder<ExecutableElement> builder) {
+  @Override
+  protected void checkScopes(ValidationReport.Builder<ExecutableElement> builder) {
     if (!scopesOf(builder.getSubject()).isEmpty()) {
       builder.addError("@Produces methods may not have scope annotations");
     }
diff --git a/java/dagger/internal/codegen/ProductionExecutorModuleGenerator.java b/java/dagger/internal/codegen/ProductionExecutorModuleGenerator.java
index 118edd5a9..a28981a72 100644
--- a/java/dagger/internal/codegen/ProductionExecutorModuleGenerator.java
+++ b/java/dagger/internal/codegen/ProductionExecutorModuleGenerator.java
@@ -53,8 +53,8 @@ ClassName nameGeneratedType(TypeElement componentElement) {
   }
 
   @Override
-  Optional<? extends Element> getElementForErrorReporting(TypeElement componentElement) {
-    return Optional.of(componentElement);
+  Element originatingElement(TypeElement componentElement) {
+    return componentElement;
   }
 
   @Override
diff --git a/java/dagger/internal/codegen/ProviderInstanceBindingExpression.java b/java/dagger/internal/codegen/ProviderInstanceBindingExpression.java
new file mode 100644
index 000000000..aa8c8156e
--- /dev/null
+++ b/java/dagger/internal/codegen/ProviderInstanceBindingExpression.java
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+/** Binding expression for provider instances. */
+final class ProviderInstanceBindingExpression extends FrameworkInstanceBindingExpression {
+
+  ProviderInstanceBindingExpression(
+      ResolvedBindings resolvedBindings,
+      FrameworkInstanceSupplier frameworkInstanceSupplier,
+      DaggerTypes types,
+      DaggerElements elements) {
+    super(
+        resolvedBindings,
+        frameworkInstanceSupplier,
+        types,
+        elements);
+  }
+
+  @Override
+  protected FrameworkType frameworkType() {
+    return FrameworkType.PROVIDER;
+  }
+}
diff --git a/java/dagger/internal/codegen/ProvidesMethodValidator.java b/java/dagger/internal/codegen/ProvidesMethodValidator.java
index 8f7cf1a17..c4d409f14 100644
--- a/java/dagger/internal/codegen/ProvidesMethodValidator.java
+++ b/java/dagger/internal/codegen/ProvidesMethodValidator.java
@@ -19,7 +19,6 @@
 import static dagger.internal.codegen.BindingMethodValidator.Abstractness.MUST_BE_CONCRETE;
 import static dagger.internal.codegen.BindingMethodValidator.AllowsMultibindings.ALLOWS_MULTIBINDINGS;
 import static dagger.internal.codegen.BindingMethodValidator.ExceptionSuperclass.RUNTIME_EXCEPTION;
-import static dagger.internal.codegen.ErrorMessages.provisionMayNotDependOnProducerType;
 
 import com.google.common.collect.ImmutableSet;
 import dagger.Module;
@@ -35,30 +34,33 @@
  */
 final class ProvidesMethodValidator extends BindingMethodValidator {
 
+  private final DependencyRequestValidator dependencyRequestValidator;
+
   @Inject
-  ProvidesMethodValidator(DaggerElements elements, Types types) {
+  ProvidesMethodValidator(
+      DaggerElements elements, Types types, DependencyRequestValidator dependencyRequestValidator) {
     super(
         elements,
         types,
         Provides.class,
         ImmutableSet.of(Module.class, ProducerModule.class),
+        dependencyRequestValidator,
         MUST_BE_CONCRETE,
         RUNTIME_EXCEPTION,
         ALLOWS_MULTIBINDINGS);
+    this.dependencyRequestValidator = dependencyRequestValidator;
   }
 
   @Override
   protected void checkMethod(ValidationReport.Builder<ExecutableElement> builder) {
     super.checkMethod(builder);
-    checkDependsOnProducers(builder);
   }
 
   /** Adds an error if a {@link Provides @Provides} method depends on a producer type. */
-  private void checkDependsOnProducers(ValidationReport.Builder<ExecutableElement> builder) {
-    for (VariableElement parameter : builder.getSubject().getParameters()) {
-      if (FrameworkTypes.isProducerType(parameter.asType())) {
-        builder.addError(provisionMayNotDependOnProducerType(parameter.asType()), parameter);
-      }
-    }
+  @Override
+  protected void checkParameter(
+      ValidationReport.Builder<ExecutableElement> builder, VariableElement parameter) {
+    super.checkParameter(builder, parameter);
+    dependencyRequestValidator.checkNotProducer(builder, parameter);
   }
 }
diff --git a/java/dagger/internal/codegen/ProvisionDependencyOnProducerBindingValidation.java b/java/dagger/internal/codegen/ProvisionDependencyOnProducerBindingValidator.java
similarity index 90%
rename from java/dagger/internal/codegen/ProvisionDependencyOnProducerBindingValidation.java
rename to java/dagger/internal/codegen/ProvisionDependencyOnProducerBindingValidator.java
index f7584210b..272bf8889 100644
--- a/java/dagger/internal/codegen/ProvisionDependencyOnProducerBindingValidation.java
+++ b/java/dagger/internal/codegen/ProvisionDependencyOnProducerBindingValidator.java
@@ -36,10 +36,10 @@
  * binding.
  */
 // TODO(b/29509141): Clarify the error.
-final class ProvisionDependencyOnProducerBindingValidation implements BindingGraphPlugin {
+final class ProvisionDependencyOnProducerBindingValidator implements BindingGraphPlugin {
 
   @Inject
-  ProvisionDependencyOnProducerBindingValidation() {}
+  ProvisionDependencyOnProducerBindingValidator() {}
 
   @Override
   public String pluginName() {
@@ -61,9 +61,7 @@ public void visitGraph(BindingGraph bindingGraph, DiagnosticReporter diagnosticR
 
   private Stream<DependencyEdge> provisionDependenciesOnProductionBindings(
       BindingGraph bindingGraph) {
-    return bindingGraph
-        .bindingNodes()
-        .stream()
+    return bindingGraph.bindingNodes().stream()
         .filter(bindingNode -> bindingNode.binding().isProduction())
         .flatMap(binding -> incomingDependencies(binding, bindingGraph))
         .filter(edge -> !dependencyCanUseProduction(edge, bindingGraph));
@@ -73,7 +71,8 @@ public void visitGraph(BindingGraph bindingGraph, DiagnosticReporter diagnosticR
   // TODO(dpb): Move to BindingGraph.
   private Stream<DependencyEdge> incomingDependencies(
       BindingNode binding, BindingGraph bindingGraph) {
-    return bindingGraph.inEdges(binding).stream().flatMap(instancesOf(DependencyEdge.class));
+    return bindingGraph.network().inEdges(binding).stream()
+        .flatMap(instancesOf(DependencyEdge.class));
   }
 
   private boolean dependencyCanUseProduction(DependencyEdge edge, BindingGraph bindingGraph) {
@@ -92,7 +91,7 @@ private boolean dependencyCanUseProduction(DependencyEdge edge, BindingGraph bin
   private BindingNode bindingRequestingDependency(
       DependencyEdge dependency, BindingGraph bindingGraph) {
     checkArgument(!dependency.isEntryPoint());
-    Node source = bindingGraph.incidentNodes(dependency).source();
+    Node source = bindingGraph.network().incidentNodes(dependency).source();
     verify(
         source instanceof BindingNode,
         "expected source of %s to be a binding node, but was: %s",
@@ -111,6 +110,6 @@ private String dependencyErrorMessage(
       DependencyEdge dependencyOnProduction, BindingGraph bindingGraph) {
     return String.format(
         "%s is a provision, which cannot depend on a production.",
-        bindingRequestingDependency(dependencyOnProduction, bindingGraph).binding().key());
+        bindingRequestingDependency(dependencyOnProduction, bindingGraph).key());
   }
 }
diff --git a/java/dagger/internal/codegen/ReferenceReleasingManagerFields.java b/java/dagger/internal/codegen/ReferenceReleasingManagerFields.java
index fe6962184..0a42fb2ac 100644
--- a/java/dagger/internal/codegen/ReferenceReleasingManagerFields.java
+++ b/java/dagger/internal/codegen/ReferenceReleasingManagerFields.java
@@ -56,10 +56,14 @@
   private final GeneratedComponentModel generatedComponentModel;
 
   ReferenceReleasingManagerFields(
-      BindingGraph graph, GeneratedComponentModel generatedComponentModel) {
+      BindingGraph graph,
+      GeneratedComponentModel generatedComponentModel,
+      CompilerOptions compilerOptions) {
     this.graph = checkNotNull(graph);
     this.generatedComponentModel = checkNotNull(generatedComponentModel);
-    checkArgument(graph.componentDescriptor().kind().isTopLevel());
+    if (!compilerOptions.aheadOfTimeSubcomponents()) {
+      checkArgument(graph.componentDescriptor().kind().isTopLevel());
+    }
   }
 
   /**
diff --git a/java/dagger/internal/codegen/RequestKinds.java b/java/dagger/internal/codegen/RequestKinds.java
index b13c57b8e..1a1516e51 100644
--- a/java/dagger/internal/codegen/RequestKinds.java
+++ b/java/dagger/internal/codegen/RequestKinds.java
@@ -42,7 +42,6 @@
 import dagger.model.RequestKind;
 import dagger.producers.Produced;
 import dagger.producers.Producer;
-import java.util.Optional;
 import javax.inject.Provider;
 import javax.lang.model.type.TypeMirror;
 
@@ -61,7 +60,7 @@ static TypeMirror requestType(RequestKind requestKind, TypeMirror type, DaggerTy
         return types.wrapType(type, ListenableFuture.class);
 
       default:
-        return types.wrapType(type, frameworkClass(requestKind).get());
+        return types.wrapType(type, frameworkClass(requestKind));
     }
   }
 
@@ -94,10 +93,17 @@ static TypeName requestTypeName(RequestKind requestKind, TypeName keyType) {
     }
   }
 
+  private static final ImmutableMap<RequestKind, Class<?>> FRAMEWORK_CLASSES =
+      ImmutableMap.of(
+          PROVIDER, Provider.class,
+          LAZY, Lazy.class,
+          PRODUCER, Producer.class,
+          PRODUCED, Produced.class);
+
   /** Returns the {@link RequestKind} that matches the wrapping types (if any) of {@code type}. */
   static RequestKind getRequestKind(TypeMirror type) {
     checkTypePresent(type);
-    for (RequestKind kind : RequestKind.values()) {
+    for (RequestKind kind : FRAMEWORK_CLASSES.keySet()) {
       if (matchesKind(kind, type)) {
         if (kind.equals(PROVIDER) && matchesKind(LAZY, extractKeyType(kind, type))) {
           return PROVIDER_OF_LAZY;
@@ -113,10 +119,8 @@ static RequestKind getRequestKind(TypeMirror type) {
    * #frameworkClass(RequestKind) framework class}.
    */
   private static boolean matchesKind(RequestKind kind, TypeMirror type) {
-    Optional<Class<?>> frameworkClass = frameworkClass(kind);
-    return frameworkClass.isPresent()
-        && isType(type)
-        && isTypeOf(frameworkClass.get(), type)
+    return isType(type)
+        && isTypeOf(frameworkClass(kind), type)
         && !asDeclared(type).getTypeArguments().isEmpty();
   }
 
@@ -137,18 +141,11 @@ static TypeMirror extractKeyType(RequestKind requestKind, TypeMirror type) {
       case PROVIDER_OF_LAZY:
         return extractKeyType(LAZY, extractKeyType(PROVIDER, type));
       default:
-        checkArgument(isType(type) && isTypeOf(frameworkClass(requestKind).get(), type));
+        checkArgument(isType(type) && isTypeOf(frameworkClass(requestKind), type));
         return getOnlyElement(MoreTypes.asDeclared(type).getTypeArguments());
     }
   }
 
-  private static final ImmutableMap<RequestKind, Class<?>> FRAMEWORK_CLASSES =
-      ImmutableMap.of(
-          PROVIDER, Provider.class,
-          LAZY, Lazy.class,
-          PRODUCER, Producer.class,
-          PRODUCED, Produced.class);
-
   /**
    * A dagger- or {@code javax.inject}-defined class for {@code requestKind} that that can wrap
    * another type but share the same {@link dagger.model.Key}.
@@ -161,8 +158,10 @@ static TypeMirror extractKeyType(RequestKind requestKind, TypeMirror type) {
    * classes, and {@link RequestKind#FUTURE} is wrapped with a {@link ListenableFuture}, but for
    * historical/implementation reasons has not had an associated framework class.
    */
-  static Optional<Class<?>> frameworkClass(RequestKind requestKind) {
-    return Optional.ofNullable(FRAMEWORK_CLASSES.get(requestKind));
+  static Class<?> frameworkClass(RequestKind requestKind) {
+    Class<?> result = FRAMEWORK_CLASSES.get(requestKind);
+    checkArgument(result != null, "no framework class for %s", requestKind);
+    return result;
   }
 
   /**
diff --git a/java/dagger/internal/codegen/ResolvedBindings.java b/java/dagger/internal/codegen/ResolvedBindings.java
index 4aadf633a..e4421d5d8 100644
--- a/java/dagger/internal/codegen/ResolvedBindings.java
+++ b/java/dagger/internal/codegen/ResolvedBindings.java
@@ -22,6 +22,7 @@
 import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
 
 import com.google.auto.value.AutoValue;
+import com.google.auto.value.extension.memoized.Memoized;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
@@ -77,6 +78,15 @@
    */
   abstract ImmutableSet<OptionalBindingDeclaration> optionalBindingDeclarations();
 
+  // Computing the hash code is an expensive operation.
+  @Memoized
+  @Override
+  public abstract int hashCode();
+
+  // Suppresses ErrorProne warning that hashCode was overridden w/o equals
+  @Override
+  public abstract boolean equals(Object other);
+
   /**
    * All bindings for {@link #key()}, indexed by the component in which the binding was resolved.
    */
@@ -263,13 +273,6 @@ public ContributionType contributionType() {
     return contributionBinding().contributionType();
   }
 
-  /**
-   * The framework class associated with these bindings.
-   */
-  Class<?> frameworkClass() {
-    return bindingType().frameworkClass();
-  }
-
   /**
    * The scope associated with the single binding.
    *
diff --git a/java/dagger/internal/codegen/SetBindingExpression.java b/java/dagger/internal/codegen/SetBindingExpression.java
index 2409541c0..ffb2d7b58 100644
--- a/java/dagger/internal/codegen/SetBindingExpression.java
+++ b/java/dagger/internal/codegen/SetBindingExpression.java
@@ -18,6 +18,7 @@
 
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static dagger.internal.codegen.Accessibility.isTypeAccessibleFrom;
+import static dagger.internal.codegen.BindingRequest.bindingRequest;
 import static dagger.internal.codegen.CodeBlocks.toParametersCodeBlock;
 import static javax.lang.model.util.ElementFilter.methodsIn;
 
@@ -27,11 +28,12 @@
 import dagger.internal.SetBuilder;
 import dagger.model.DependencyRequest;
 import java.util.Collections;
+import java.util.Optional;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeMirror;
 
 /** A binding expression for multibound sets. */
-final class SetBindingExpression extends SimpleInvocationBindingExpression {
+final class SetBindingExpression extends MultibindingExpression {
   private final ProvisionBinding binding;
   private final BindingGraph graph;
   private final ComponentBindingExpressions componentBindingExpressions;
@@ -40,11 +42,12 @@
 
   SetBindingExpression(
       ResolvedBindings resolvedBindings,
+      GeneratedComponentModel generatedComponentModel,
       BindingGraph graph,
       ComponentBindingExpressions componentBindingExpressions,
       DaggerTypes types,
       DaggerElements elements) {
-    super(resolvedBindings);
+    super(resolvedBindings, generatedComponentModel);
     this.binding = (ProvisionBinding) resolvedBindings.contributionBinding();
     this.graph = graph;
     this.componentBindingExpressions = componentBindingExpressions;
@@ -53,11 +56,14 @@
   }
 
   @Override
-  Expression getDependencyExpression(ClassName requestingClass) {
+  protected Expression buildDependencyExpression(ClassName requestingClass) {
+    Optional<CodeBlock> superMethodCall = superMethodCall();
     // TODO(ronshapiro): We should also make an ImmutableSet version of SetFactory
     boolean isImmutableSetAvailable = isImmutableSetAvailable();
     // TODO(ronshapiro, gak): Use Sets.immutableEnumSet() if it's available?
-    if (isImmutableSetAvailable && binding.dependencies().stream().allMatch(this::isSingleValue)) {
+    if (isImmutableSetAvailable
+        && binding.dependencies().stream().allMatch(this::isSingleValue)
+        && !superMethodCall.isPresent()) {
       return Expression.create(
           immutableSetType(),
           CodeBlock.builder()
@@ -105,11 +111,14 @@ Expression getDependencyExpression(ClassName requestingClass) {
         } else {
           instantiation.add("newSetBuilder($L)", binding.dependencies().size());
         }
-        for (DependencyRequest dependency : binding.dependencies()) {
+        for (DependencyRequest dependency : getNewContributions(binding.dependencies())) {
           String builderMethod = isSingleValue(dependency) ? "add" : "addAll";
           instantiation.add(
               ".$L($L)", builderMethod, getContributionExpression(dependency, requestingClass));
         }
+        if (superMethodCall.isPresent()) {
+          instantiation.add(CodeBlock.of(".addAll($L)", superMethodCall.get()));
+        }
         instantiation.add(".build()");
         return Expression.create(
             isImmutableSetAvailable ? immutableSetType() : binding.key().type(),
@@ -125,7 +134,7 @@ private DeclaredType immutableSetType() {
   private CodeBlock getContributionExpression(
       DependencyRequest dependency, ClassName requestingClass) {
     return componentBindingExpressions
-        .getDependencyExpression(dependency, requestingClass)
+        .getDependencyExpression(bindingRequest(dependency), requestingClass)
         .codeBlock();
   }
 
diff --git a/java/dagger/internal/codegen/SetFactoryCreationExpression.java b/java/dagger/internal/codegen/SetFactoryCreationExpression.java
index 94975680f..302a41097 100644
--- a/java/dagger/internal/codegen/SetFactoryCreationExpression.java
+++ b/java/dagger/internal/codegen/SetFactoryCreationExpression.java
@@ -17,6 +17,7 @@
 package dagger.internal.codegen;
 
 import static com.google.common.base.Preconditions.checkNotNull;
+import static dagger.internal.codegen.BindingRequest.bindingRequest;
 import static dagger.internal.codegen.SourceFiles.setFactoryClassName;
 
 import com.squareup.javapoet.CodeBlock;
@@ -78,7 +79,8 @@ public CodeBlock creationExpression() {
 
       CodeBlock argument =
           componentBindingExpressions
-              .getDependencyExpression(frameworkDependency, generatedComponentModel.name())
+              .getDependencyExpression(
+                  bindingRequest(frameworkDependency), generatedComponentModel.name())
               .codeBlock();
       builderMethodCalls.add(
           ".$L($L)",
diff --git a/java/dagger/internal/codegen/SingleCheckedMethodImplementation.java b/java/dagger/internal/codegen/SingleCheckedMethodImplementation.java
index dc32cd199..944436225 100644
--- a/java/dagger/internal/codegen/SingleCheckedMethodImplementation.java
+++ b/java/dagger/internal/codegen/SingleCheckedMethodImplementation.java
@@ -17,7 +17,6 @@
 package dagger.internal.codegen;
 
 import static dagger.internal.codegen.GeneratedComponentModel.FieldSpecKind.PRIVATE_METHOD_SCOPED_FIELD;
-import static dagger.model.RequestKind.INSTANCE;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.VOLATILE;
 
@@ -39,20 +38,20 @@
   private final GeneratedComponentModel generatedComponentModel;
   private final ResolvedBindings resolvedBindings;
   private final ContributionBinding binding;
-  private final RequestKind requestKind;
+  private final BindingRequest request;
   private final Supplier<FieldSpec> field = Suppliers.memoize(this::createField);
 
   SingleCheckedMethodImplementation(
       ResolvedBindings resolvedBindings,
-      RequestKind requestKind,
+      BindingRequest request,
       BindingExpression bindingExpression,
       DaggerTypes types,
       GeneratedComponentModel generatedComponentModel) {
-    super(resolvedBindings, requestKind, bindingExpression, generatedComponentModel.name(), types);
+    super(resolvedBindings, request, bindingExpression, generatedComponentModel.name(), types);
     this.generatedComponentModel = generatedComponentModel;
     this.resolvedBindings = resolvedBindings;
     this.binding = resolvedBindings.contributionBinding();
-    this.requestKind = requestKind;
+    this.request = request;
   }
 
   @Override
@@ -79,7 +78,7 @@ CodeBlock body() {
   private FieldSpec createField() {
     String name =
         generatedComponentModel.getUniqueFieldName(
-            requestKind.equals(INSTANCE)
+            request.isRequestKind(RequestKind.INSTANCE)
                 ? BindingVariableNamer.name(binding)
                 : FrameworkField.forResolvedBindings(resolvedBindings, Optional.empty()).name());
 
@@ -104,6 +103,6 @@ private TypeName fieldType() {
   }
 
   private boolean isNullable() {
-    return requestKind.equals(INSTANCE) && binding.isNullable();
+    return request.isRequestKind(RequestKind.INSTANCE) && binding.isNullable();
   }
 }
diff --git a/java/dagger/internal/codegen/SourceFileGenerationException.java b/java/dagger/internal/codegen/SourceFileGenerationException.java
index 445a8404f..07c1c68d6 100644
--- a/java/dagger/internal/codegen/SourceFileGenerationException.java
+++ b/java/dagger/internal/codegen/SourceFileGenerationException.java
@@ -28,17 +28,14 @@
  * An exception thrown to indicate that a source file could not be generated.
  *
  * <p>This exception <b>should not</b> be used to report detectable, logical errors as it may mask
- * other errors that might have been caught upon further processing.  Use a {@link ValidationReport}
+ * other errors that might have been caught upon further processing. Use a {@link ValidationReport}
  * for that.
  */
 final class SourceFileGenerationException extends Exception {
-  // TODO(ronshapiro): remove these unused values
-  private final Optional<? extends Element> associatedElement;
+  private final Element associatedElement;
 
   SourceFileGenerationException(
-      Optional<ClassName> generatedClassName,
-      Throwable cause,
-      Optional<? extends Element> associatedElement) {
+      Optional<ClassName> generatedClassName, Throwable cause, Element associatedElement) {
     super(createMessage(generatedClassName, cause.getMessage()), cause);
     this.associatedElement = checkNotNull(associatedElement);
   }
@@ -52,10 +49,6 @@ private static String createMessage(Optional<ClassName> generatedClassName, Stri
   }
 
   void printMessageTo(Messager messager) {
-    if (associatedElement.isPresent()) {
-      messager.printMessage(ERROR, getMessage(), associatedElement.get());
-    } else {
-      messager.printMessage(ERROR, getMessage());
-    }
+    messager.printMessage(ERROR, getMessage(), associatedElement);
   }
 }
diff --git a/java/dagger/internal/codegen/SourceFileGenerator.java b/java/dagger/internal/codegen/SourceFileGenerator.java
index 5b2506478..8c663c9c4 100644
--- a/java/dagger/internal/codegen/SourceFileGenerator.java
+++ b/java/dagger/internal/codegen/SourceFileGenerator.java
@@ -71,18 +71,19 @@ void generate(T input) throws SourceFileGenerationException {
       return;
     }
     try {
-      buildJavaFile(generatedTypeName, type.get()).writeTo(filer);
+      buildJavaFile(generatedTypeName, input, type.get()).writeTo(filer);
     } catch (Exception e) {
       // if the code above threw a SFGE, use that
       Throwables.propagateIfPossible(e, SourceFileGenerationException.class);
       // otherwise, throw a new one
       throw new SourceFileGenerationException(
-          Optional.empty(), e, getElementForErrorReporting(input));
+          Optional.empty(), e, originatingElement(input));
     }
   }
 
   private JavaFile buildJavaFile(
-      ClassName generatedTypeName, TypeSpec.Builder typeSpecBuilder) {
+      ClassName generatedTypeName, T input, TypeSpec.Builder typeSpecBuilder) {
+    typeSpecBuilder.addOriginatingElement(originatingElement(input));
     Optional<AnnotationSpec> generatedAnnotation =
         generatedAnnotation(elements, sourceVersion)
             .map(
@@ -106,11 +107,8 @@ private JavaFile buildJavaFile(
    */
   abstract ClassName nameGeneratedType(T input);
 
-  /**
-   * Returns an optional element to be used for reporting errors. This returns a single element
-   * rather than a collection to reduce output noise.
-   */
-  abstract Optional<? extends Element> getElementForErrorReporting(T input);
+  /** Returns the originating element of the generating type. */
+  abstract Element originatingElement(T input);
 
   /**
    * Returns a {@link TypeSpec.Builder type} to be generated for {@code T}, or {@link
diff --git a/java/dagger/internal/codegen/StaticSwitchingProviders.java b/java/dagger/internal/codegen/StaticSwitchingProviders.java
index f0918dec4..6a8492011 100644
--- a/java/dagger/internal/codegen/StaticSwitchingProviders.java
+++ b/java/dagger/internal/codegen/StaticSwitchingProviders.java
@@ -19,6 +19,7 @@
 import static com.squareup.javapoet.ClassName.OBJECT;
 import static com.squareup.javapoet.MethodSpec.constructorBuilder;
 import static com.squareup.javapoet.TypeName.INT;
+import static dagger.internal.codegen.BindingRequest.bindingRequest;
 import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
 import static dagger.internal.codegen.CodeBlocks.toParametersCodeBlock;
 import static dagger.internal.codegen.SourceFiles.generatedClassNameForBinding;
@@ -141,7 +142,9 @@ private CodeBlock getMethodArguments() {
 
       for (FrameworkDependency dependency : binding.frameworkDependencies()) {
         TypeMirror type =
-            componentBindingExpressions.getDependencyExpression(dependency, owningComponent).type();
+            componentBindingExpressions
+                .getDependencyExpression(bindingRequest(dependency), owningComponent)
+                .type();
         arguments.add(argument(type, i++));
       }
       return makeParametersCodeBlock(arguments.build());
diff --git a/java/dagger/internal/codegen/SubcomponentBuilderBindingEdgeImpl.java b/java/dagger/internal/codegen/SubcomponentBuilderBindingEdgeImpl.java
new file mode 100644
index 000000000..3035def7c
--- /dev/null
+++ b/java/dagger/internal/codegen/SubcomponentBuilderBindingEdgeImpl.java
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.collect.Iterables.getOnlyElement;
+import static java.util.stream.Collectors.joining;
+
+import com.google.common.collect.ImmutableSet;
+import dagger.model.BindingGraph.SubcomponentBuilderBindingEdge;
+import javax.lang.model.element.TypeElement;
+
+/** An implementation of {@link SubcomponentBuilderBindingEdge}. */
+final class SubcomponentBuilderBindingEdgeImpl implements SubcomponentBuilderBindingEdge {
+
+  private final ImmutableSet<TypeElement> declaringModules;
+
+  SubcomponentBuilderBindingEdgeImpl(Iterable<TypeElement> declaringModules) {
+    this.declaringModules = ImmutableSet.copyOf(declaringModules);
+  }
+
+  @Override
+  public ImmutableSet<TypeElement> declaringModules() {
+    return declaringModules;
+  }
+
+  @Override
+  public String toString() {
+    return "subcomponent declared by "
+        + (declaringModules.size() == 1
+            ? getOnlyElement(declaringModules).getQualifiedName()
+            : declaringModules.stream()
+                .map(TypeElement::getQualifiedName)
+                .collect(joining(", ", "{", "}")));
+  }
+}
diff --git a/java/dagger/internal/codegen/SubcomponentFactoryMethodValidator.java b/java/dagger/internal/codegen/SubcomponentFactoryMethodValidator.java
new file mode 100644
index 000000000..5e9b1e8a8
--- /dev/null
+++ b/java/dagger/internal/codegen/SubcomponentFactoryMethodValidator.java
@@ -0,0 +1,150 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.auto.common.MoreTypes.asDeclared;
+import static com.google.auto.common.MoreTypes.asExecutable;
+import static com.google.auto.common.MoreTypes.asTypeElements;
+import static com.google.common.collect.Sets.union;
+import static dagger.internal.codegen.DaggerStreams.instancesOf;
+import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
+import static dagger.internal.codegen.Util.componentCanMakeNewInstances;
+import static javax.tools.Diagnostic.Kind.ERROR;
+
+import com.google.common.base.Joiner;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Sets;
+import com.google.common.collect.Sets.SetView;
+import dagger.model.BindingGraph;
+import dagger.model.BindingGraph.ChildFactoryMethodEdge;
+import dagger.model.BindingGraph.ComponentNode;
+import dagger.spi.BindingGraphPlugin;
+import dagger.spi.DiagnosticReporter;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Set;
+import java.util.function.Function;
+import javax.inject.Inject;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.ExecutableType;
+
+/** Reports an error if a subcomponent factory method is missing required modules. */
+final class SubcomponentFactoryMethodValidator implements BindingGraphPlugin {
+
+  private final DaggerTypes types;
+  private final Map<ComponentNode, Set<TypeElement>> inheritedModulesCache = new HashMap<>();
+
+  @Inject
+  SubcomponentFactoryMethodValidator(DaggerTypes types) {
+    this.types = types;
+  }
+
+  @Override
+  public String pluginName() {
+    return "Dagger/SubcomponentFactoryMethodMissingModule";
+  }
+
+  @Override
+  public void visitGraph(BindingGraph bindingGraph, DiagnosticReporter diagnosticReporter) {
+    bindingGraph.network().edges().stream()
+        .flatMap(instancesOf(ChildFactoryMethodEdge.class))
+        .forEach(
+            edge -> {
+              ImmutableSet<TypeElement> missingModules = findMissingModules(edge, bindingGraph);
+              if (!missingModules.isEmpty()) {
+                reportMissingModuleParameters(
+                    edge, missingModules, bindingGraph, diagnosticReporter);
+              }
+            });
+  }
+
+  private ImmutableSet<TypeElement> findMissingModules(
+      ChildFactoryMethodEdge edge, BindingGraph graph) {
+    ImmutableSet<TypeElement> factoryMethodParameters =
+        subgraphFactoryMethodParameters(edge, graph);
+    ComponentNode child = (ComponentNode) graph.network().incidentNodes(edge).target();
+    SetView<TypeElement> modulesOwnedByChild = ownedModules(child, graph);
+    return graph.bindingNodes().stream()
+        // bindings owned by child
+        .filter(node -> node.componentPath().equals(child.componentPath()))
+        // that require a module instance
+        .filter(
+            node ->
+                node.binding() instanceof ContributionBinding
+                    && ((ContributionBinding) node.binding()).requiresModuleInstance())
+        .map(node -> node.binding().contributingModule().get())
+        .distinct()
+        // module owned by child
+        .filter(module -> modulesOwnedByChild.contains(module))
+        // module not in the method parameters
+        .filter(module -> !factoryMethodParameters.contains(module))
+        // module doesn't have an accessible no-arg constructor
+        .filter(moduleType -> !componentCanMakeNewInstances(moduleType))
+        .collect(toImmutableSet());
+  }
+
+  private ImmutableSet<TypeElement> subgraphFactoryMethodParameters(
+      ChildFactoryMethodEdge edge, BindingGraph bindingGraph) {
+    ComponentNode parent = (ComponentNode) bindingGraph.network().incidentNodes(edge).source();
+    DeclaredType parentType = asDeclared(parent.componentPath().currentComponent().asType());
+    ExecutableType factoryMethodType =
+        asExecutable(types.asMemberOf(parentType, edge.factoryMethod()));
+    return asTypeElements(factoryMethodType.getParameterTypes());
+  }
+
+  private SetView<TypeElement> ownedModules(ComponentNode component, BindingGraph graph) {
+    return Sets.difference(
+        ((ComponentNodeImpl) component).componentDescriptor().transitiveModuleTypes(),
+        inheritedModules(component, graph));
+  }
+
+  private Set<TypeElement> inheritedModules(ComponentNode component, BindingGraph graph) {
+    return Util.reentrantComputeIfAbsent(
+        inheritedModulesCache, component, uncachedInheritedModules(graph));
+  }
+
+  private Function<ComponentNode, Set<TypeElement>> uncachedInheritedModules(BindingGraph graph) {
+    return componentNode ->
+        componentNode.componentPath().atRoot()
+            ? ImmutableSet.of()
+            : graph
+                .componentNode(componentNode.componentPath().parent())
+                .map(parent -> union(ownedModules(parent, graph), inheritedModules(parent, graph)))
+                .get();
+  }
+
+  private void reportMissingModuleParameters(
+      ChildFactoryMethodEdge edge,
+      ImmutableSet<TypeElement> missingModules,
+      BindingGraph graph,
+      DiagnosticReporter diagnosticReporter) {
+    diagnosticReporter.reportSubcomponentFactoryMethod(
+        ERROR,
+        edge,
+        "%s requires modules which have no visible default constructors. "
+            + "Add the following modules as parameters to this method: %s",
+        graph
+            .network()
+            .incidentNodes(edge)
+            .target()
+            .componentPath()
+            .currentComponent()
+            .getQualifiedName(),
+        Joiner.on(", ").join(missingModules));
+  }
+}
diff --git a/java/dagger/internal/codegen/TypeNames.java b/java/dagger/internal/codegen/TypeNames.java
index d6b01c768..ed2ee286b 100644
--- a/java/dagger/internal/codegen/TypeNames.java
+++ b/java/dagger/internal/codegen/TypeNames.java
@@ -39,6 +39,7 @@
 import dagger.producers.Produced;
 import dagger.producers.Producer;
 import dagger.producers.internal.AbstractProducer;
+import dagger.producers.internal.DependencyMethodProducer;
 import dagger.producers.internal.MapOfProducedProducer;
 import dagger.producers.internal.MapOfProducerProducer;
 import dagger.producers.internal.MapProducer;
@@ -60,6 +61,7 @@
 
   static final ClassName ABSTRACT_PRODUCER = ClassName.get(AbstractProducer.class);
   static final ClassName ASYNC_FUNCTION = ClassName.get(AsyncFunction.class);
+  static final ClassName DEPENDENCY_METHOD_PRODUCER = ClassName.get(DependencyMethodProducer.class);
   static final ClassName DOUBLE_CHECK = ClassName.get(DoubleCheck.class);
   static final ClassName EXECUTOR = ClassName.get(Executor.class);
   static final ClassName FACTORY = ClassName.get(Factory.class);
@@ -139,6 +141,10 @@ static ParameterizedTypeName producerOf(TypeName typeName) {
     return ParameterizedTypeName.get(PRODUCER, typeName);
   }
 
+  static ParameterizedTypeName dependencyMethodProducerOf(TypeName typeName) {
+    return ParameterizedTypeName.get(DEPENDENCY_METHOD_PRODUCER, typeName);
+  }
+
   static ParameterizedTypeName providerOf(TypeName typeName) {
     return ParameterizedTypeName.get(PROVIDER, typeName);
   }
diff --git a/third_party/kythe_plugin_deploy.jar b/java/dagger/internal/codegen/kythe_plugin_deploy.jar
similarity index 100%
rename from third_party/kythe_plugin_deploy.jar
rename to java/dagger/internal/codegen/kythe_plugin_deploy.jar
diff --git a/java/dagger/model/BUILD b/java/dagger/model/BUILD
index f18d229a1..a2c91a0e7 100644
--- a/java/dagger/model/BUILD
+++ b/java/dagger/model/BUILD
@@ -41,11 +41,11 @@ java_library(
         "//java/dagger:core",
         "//java/dagger/internal/codegen:shared-with-spi",
         "//java/dagger/producers",
-        "//third_party:auto_common",
-        "//third_party:auto_value",
-        "//third_party:error_prone_annotations",
-        "//third_party:guava",
-        "//third_party:jsr330_inject",
+        "@google_bazel_common//third_party/java/auto:common",
+        "@google_bazel_common//third_party/java/auto:value",
+        "@google_bazel_common//third_party/java/error_prone:annotations",
+        "@google_bazel_common//third_party/java/guava",
+        "@google_bazel_common//third_party/java/jsr330_inject",
     ],
 )
 
@@ -55,6 +55,6 @@ java_library(
     tags = ["maven:merged"],
     deps = [
         ":model",
-        "//third_party:guava",
+        "@google_bazel_common//third_party/java/guava",
     ],
 )
diff --git a/java/dagger/model/BindingGraph.java b/java/dagger/model/BindingGraph.java
index 9ed3158c2..3c8d31bb0 100644
--- a/java/dagger/model/BindingGraph.java
+++ b/java/dagger/model/BindingGraph.java
@@ -16,7 +16,7 @@
 
 package dagger.model;
 
-import static com.google.common.base.MoreObjects.toStringHelper;
+import static com.google.common.base.Verify.verify;
 import static com.google.common.collect.Sets.intersection;
 import static com.google.common.graph.Graphs.inducedSubgraph;
 import static com.google.common.graph.Graphs.reachableNodes;
@@ -30,10 +30,10 @@
 import com.google.common.collect.ImmutableSetMultimap;
 import com.google.common.graph.EndpointPair;
 import com.google.common.graph.ImmutableNetwork;
+import com.google.common.graph.MutableNetwork;
 import com.google.common.graph.Network;
+import com.google.common.graph.NetworkBuilder;
 import dagger.Module;
-import dagger.model.BindingGraph.Edge;
-import dagger.model.BindingGraph.Node;
 import java.util.Optional;
 import java.util.stream.Stream;
 import javax.lang.model.element.ExecutableElement;
@@ -69,9 +69,26 @@
  *
  * <p><b>Note that this API is experimental and will change.</b>
  */
-public final class BindingGraph extends ForwardingNetwork<Node, Edge> {
+public final class BindingGraph {
+  private final ImmutableNetwork<Node, Edge> network;
+
   BindingGraph(Network<Node, Edge> network) {
-    super(ImmutableNetwork.copyOf(network));
+    this.network = ImmutableNetwork.copyOf(network);
+  }
+
+  /** Returns the graph in its {@link Network} representation. */
+  public ImmutableNetwork<Node, Edge> network() {
+    return network;
+  }
+
+  @Override
+  public int hashCode() {
+    return network.hashCode();
+  }
+
+  @Override
+  public String toString() {
+    return network.toString();
   }
 
   /** Returns the binding nodes. */
@@ -82,7 +99,7 @@
   /** Returns the binding nodes for a key. */
   public ImmutableSet<BindingNode> bindingNodes(Key key) {
     return nodeStream(BindingNode.class)
-        .filter(node -> node.binding().key().equals(key))
+        .filter(node -> node.key().equals(key))
         .collect(toImmutableSet());
   }
 
@@ -152,7 +169,7 @@ public ComponentNode rootComponentNode() {
   }
 
   private Stream<DependencyEdge> dependencyEdgeStream(Node node) {
-    return outEdges(node).stream().flatMap(instancesOf(DependencyEdge.class));
+    return network.outEdges(node).stream().flatMap(instancesOf(DependencyEdge.class));
   }
 
   /**
@@ -163,20 +180,43 @@ public ComponentNode rootComponentNode() {
     return entryPointEdgeStream().collect(toImmutableSet());
   }
 
-  /** Returns the binding nodes for bindings that directly satisfy entry points. */
-  public ImmutableSet<BindingNode> entryPointBindingNodes() {
+  /** Returns the binding nodes or missing binding nodes that directly satisfy entry points. */
+  public ImmutableSet<MaybeBindingNode> entryPointBindingNodes() {
     return entryPointEdgeStream()
-        .map(edge -> (BindingNode) incidentNodes(edge).target())
+        .map(edge -> (MaybeBindingNode) network.incidentNodes(edge).target())
         .collect(toImmutableSet());
   }
 
-  /** Returns the edges for entry points that transitively depend on a binding. */
+  /**
+   * Returns the edges for entry points that transitively depend on a binding or missing binding for
+   * a key. Never returns an empty set.
+   */
   public ImmutableSet<DependencyEdge> entryPointEdgesDependingOnBindingNode(
-      BindingNode bindingNode) {
-    Network<Node, Edge> subgraphDependingOnBindingNode =
-        inducedSubgraph(this, reachableNodes(transpose(this).asGraph(), bindingNode));
-    return ImmutableSet.copyOf(
-        intersection(entryPointEdges(), subgraphDependingOnBindingNode.edges()));
+      MaybeBindingNode bindingNode) {
+    ImmutableNetwork<Node, DependencyEdge> dependencyGraph = dependencyGraph();
+    Network<Node, DependencyEdge> subgraphDependingOnBindingNode =
+        inducedSubgraph(
+            dependencyGraph, reachableNodes(transpose(dependencyGraph).asGraph(), bindingNode));
+    ImmutableSet<DependencyEdge> entryPointEdges =
+        intersection(entryPointEdges(), subgraphDependingOnBindingNode.edges()).immutableCopy();
+    verify(!entryPointEdges.isEmpty(), "No entry points depend on binding %s", bindingNode);
+    return entryPointEdges;
+  }
+
+  // TODO(dpb): Make public. Cache.
+  private ImmutableNetwork<Node, DependencyEdge> dependencyGraph() {
+    MutableNetwork<Node, DependencyEdge> dependencyGraph =
+        NetworkBuilder.from(network)
+            .expectedNodeCount(network.nodes().size())
+            .expectedEdgeCount((int) dependencyEdgeStream().count())
+            .build();
+    dependencyEdgeStream()
+        .forEach(
+            edge -> {
+              EndpointPair<Node> endpoints = network.incidentNodes(edge);
+              dependencyGraph.addEdge(endpoints.source(), endpoints.target(), edge);
+            });
+    return ImmutableNetwork.copyOf(dependencyGraph);
   }
 
   private <N extends Node> ImmutableSet<N> nodes(Class<N> clazz) {
@@ -184,11 +224,11 @@ public ComponentNode rootComponentNode() {
   }
 
   private <N extends Node> Stream<N> nodeStream(Class<N> clazz) {
-    return nodes().stream().flatMap(instancesOf(clazz));
+    return network.nodes().stream().flatMap(instancesOf(clazz));
   }
 
   private Stream<DependencyEdge> dependencyEdgeStream() {
-    return edges().stream().flatMap(instancesOf(DependencyEdge.class));
+    return network.edges().stream().flatMap(instancesOf(DependencyEdge.class));
   }
 
   private Stream<DependencyEdge> entryPointEdgeStream() {
@@ -214,56 +254,21 @@ public ComponentNode rootComponentNode() {
    * <p>For dependencies on missing bindings, the target node is a {@link MissingBindingNode}.
    * Otherwise the target node is a {@link BindingNode}.
    */
-  public static final class DependencyEdge implements Edge {
-
-    private final DependencyRequest dependencyRequest;
-    private final boolean entryPoint;
-
-    DependencyEdge(DependencyRequest dependencyRequest, boolean entryPoint) {
-      this.dependencyRequest = dependencyRequest;
-      this.entryPoint = entryPoint;
-    }
-
+  public interface DependencyEdge extends Edge {
     /** The dependency request. */
-    public DependencyRequest dependencyRequest() {
-      return dependencyRequest;
-    }
+    DependencyRequest dependencyRequest();
 
     /** Returns {@code true} if this edge represents an entry point. */
-    public boolean isEntryPoint() {
-      return entryPoint;
-    }
-
-    @Override
-    public String toString() {
-      return toStringHelper(this)
-          .add("dependencyRequest", dependencyRequest)
-          .add("entryPoint", entryPoint)
-          .toString();
-    }
+    boolean isEntryPoint();
   }
 
   /**
    * An edge that represents a subcomponent factory method linking a parent component to a child
    * subcomponent.
    */
-  public static final class ChildFactoryMethodEdge implements Edge {
-
-    private final ExecutableElement factoryMethod;
-
-    ChildFactoryMethodEdge(ExecutableElement factoryMethod) {
-      this.factoryMethod = factoryMethod;
-    }
-
+  public interface ChildFactoryMethodEdge extends Edge {
     /** The subcomponent factory method element. */
-    public ExecutableElement factoryMethod() {
-      return factoryMethod;
-    }
-
-    @Override
-    public String toString() {
-      return toStringHelper(this).add("factoryMethod", factoryMethod).toString();
-    }
+    ExecutableElement factoryMethod();
   }
 
   /**
@@ -273,27 +278,13 @@ public String toString() {
    * the {@linkplain com.google.common.graph.EndpointPair#target() target node} is a {@link
    * ComponentNode} for the child subcomponent.
    */
-  public static final class SubcomponentBuilderBindingEdge implements Edge {
-
-    private final ImmutableSet<TypeElement> declaringModules;
-
-    SubcomponentBuilderBindingEdge(Iterable<TypeElement> declaringModules) {
-      this.declaringModules = ImmutableSet.copyOf(declaringModules);
-    }
-
+  public interface SubcomponentBuilderBindingEdge extends Edge {
     /**
      * The modules that {@linkplain Module#subcomponents() declare the subcomponent} that generated
      * this edge. Empty if the parent component has a subcomponent builder method and there are no
      * declaring modules.
      */
-    public ImmutableSet<TypeElement> declaringModules() {
-      return declaringModules;
-    }
-
-    @Override
-    public String toString() {
-      return toStringHelper(this).add("declaringModules", declaringModules).toString();
-    }
+    ImmutableSet<TypeElement> declaringModules();
   }
 
   /** A node in the binding graph. Either a {@link BindingNode} or a {@link ComponentNode}. */
@@ -302,11 +293,28 @@ public String toString() {
     ComponentPath componentPath();
   }
 
+  /**
+   * A node in the binding graph that is either a {@link BindingNode} or a {@link
+   * MissingBindingNode}.
+   */
+  public interface MaybeBindingNode extends Node {
+
+    /** The component that owns the binding, or in which the binding is missing. */
+    @Override
+    ComponentPath componentPath();
+
+    /** The key of the binding, or for which there is no binding. */
+    Key key();
+
+    /** The binding, or empty if missing. */
+    Optional<Binding> maybeBinding();
+  }
+
   /**
    * A <b>binding node</b> in the binding graph. If a binding is owned by more than one component,
    * there is one binding node for that binding for every owning component.
    */
-  public interface BindingNode extends Node {
+  public interface BindingNode extends MaybeBindingNode {
 
     /** The component that owns the {@link #binding()}. */
     @Override
@@ -314,11 +322,21 @@ public String toString() {
 
     /** The binding. */
     Binding binding();
+
+    @Override
+    default Key key() {
+      return binding().key();
+    }
+
+    @Override
+    default Optional<Binding> maybeBinding() {
+      return Optional.of(binding());
+    }
   }
 
   /** A node in the binding graph that represents a missing binding for a key in a component. */
   @AutoValue
-  public abstract static class MissingBindingNode implements Node {
+  public abstract static class MissingBindingNode implements MaybeBindingNode {
     static MissingBindingNode create(ComponentPath component, Key key) {
       return new AutoValue_BindingGraph_MissingBindingNode(component, key);
     }
@@ -331,7 +349,12 @@ static MissingBindingNode create(ComponentPath component, Key key) {
     public abstract Key key();
 
     @Override
-    public String toString() {
+    public final Optional<Binding> maybeBinding() {
+      return Optional.empty();
+    }
+
+    @Override
+    public final String toString() {
       return String.format("missing binding for %s in %s", key(), componentPath());
     }
   }
@@ -340,28 +363,16 @@ public String toString() {
    * A <b>component node</b> in the graph. Every entry point {@linkplain DependencyEdge dependency
    * edge}'s source node is a component node for the component containing the entry point.
    */
-  @AutoValue
-  public abstract static class ComponentNode implements Node {
-    static ComponentNode create(
-        ComponentPath componentPath,
-        ImmutableSet<DependencyRequest> entryPoints,
-        ImmutableSet<Scope> scopes) {
-      return new AutoValue_BindingGraph_ComponentNode(componentPath, entryPoints, scopes);
-    }
+  public interface ComponentNode extends Node {
 
     /** The component represented by this node. */
     @Override
-    public abstract ComponentPath componentPath();
+    ComponentPath componentPath();
 
     /** The entry points on this component. */
-    public abstract ImmutableSet<DependencyRequest> entryPoints();
+    ImmutableSet<DependencyRequest> entryPoints();
 
     /** The scopes declared on this component. */
-    public abstract ImmutableSet<Scope> scopes();
-
-    @Override
-    public final String toString() {
-      return componentPath().toString();
-    }
+    ImmutableSet<Scope> scopes();
   }
 }
diff --git a/java/dagger/model/BindingGraphProxies.java b/java/dagger/model/BindingGraphProxies.java
index a5e24ff3e..1e3ec5637 100644
--- a/java/dagger/model/BindingGraphProxies.java
+++ b/java/dagger/model/BindingGraphProxies.java
@@ -16,17 +16,10 @@
 
 package dagger.model;
 
-import com.google.common.collect.ImmutableSet;
 import com.google.common.graph.Network;
-import dagger.model.BindingGraph.ChildFactoryMethodEdge;
-import dagger.model.BindingGraph.ComponentNode;
-import dagger.model.BindingGraph.DependencyEdge;
 import dagger.model.BindingGraph.Edge;
 import dagger.model.BindingGraph.MissingBindingNode;
 import dagger.model.BindingGraph.Node;
-import dagger.model.BindingGraph.SubcomponentBuilderBindingEdge;
-import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.TypeElement;
 
 /**
  * Exposes package-private constructors to the {@code dagger.internal.codegen} package. <em>This
@@ -44,30 +37,5 @@ public static MissingBindingNode missingBindingNode(ComponentPath component, Key
     return MissingBindingNode.create(component, key);
   }
 
-  /** Creates a new {@link ComponentNode}. */
-  public static ComponentNode componentNode(
-      ComponentPath component,
-      ImmutableSet<DependencyRequest> entryPoints,
-      ImmutableSet<Scope> scopes) {
-    return ComponentNode.create(component, entryPoints, scopes);
-  }
-
-  /** Creates a new {@link DependencyEdge}. */
-  public static DependencyEdge dependencyEdge(
-      DependencyRequest dependencyRequest, boolean entryPoint) {
-    return new DependencyEdge(dependencyRequest, entryPoint);
-  }
-
-  /** Creates a new {@link ChildFactoryMethodEdge}. */
-  public static ChildFactoryMethodEdge childFactoryMethodEdge(ExecutableElement factoryMethod) {
-    return new ChildFactoryMethodEdge(factoryMethod);
-  }
-
-  /** Creates a new {@link SubcomponentBuilderBindingEdge}. */
-  public static SubcomponentBuilderBindingEdge subcomponentBuilderBindingEdge(
-      Iterable<TypeElement> declaringModules) {
-    return new SubcomponentBuilderBindingEdge(declaringModules);
-  }
-
   private BindingGraphProxies() {}
 }
diff --git a/java/dagger/model/ComponentPath.java b/java/dagger/model/ComponentPath.java
index 5ef7b41f9..722595049 100644
--- a/java/dagger/model/ComponentPath.java
+++ b/java/dagger/model/ComponentPath.java
@@ -61,6 +61,16 @@ public final TypeElement parentComponent() {
     return components().reverse().get(1);
   }
 
+  /**
+   * Returns this path's parent path.
+   *
+   * @throws IllegalStateException if the current graph is the {@linkplain #atRoot() root component}
+   */
+  public final ComponentPath parent() {
+    checkState(!atRoot());
+    return create(components().subList(0, components().size() - 1));
+  }
+
   /**
    * Returns {@code true} if the {@linkplain #currentComponent()} current component} is the
    * {@linkplain #rootComponent()} root component}.
diff --git a/java/dagger/model/ForwardingNetwork.java b/java/dagger/model/ForwardingNetwork.java
deleted file mode 100644
index aa4b538f9..000000000
--- a/java/dagger/model/ForwardingNetwork.java
+++ /dev/null
@@ -1,174 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.model;
-
-import static dagger.internal.Preconditions.checkNotNull;
-
-import com.google.common.collect.ForwardingObject;
-import com.google.common.graph.ElementOrder;
-import com.google.common.graph.EndpointPair;
-import com.google.common.graph.Graph;
-import com.google.common.graph.Network;
-import java.util.Optional;
-import java.util.Set;
-
-/** A {@link Network} that delegates all methods to another instance. */
-// TODO(dpb): Move to com.google.common.graph.
-public class ForwardingNetwork<N, E> extends ForwardingObject implements Network<N, E> {
-
-  private final Network<N, E> delegate;
-
-  protected ForwardingNetwork(Network<N, E> delegate) {
-    this.delegate = checkNotNull(delegate);
-  }
-
-  @Override
-  protected final Network<N, E> delegate() {
-    return delegate;
-  }
-
-  @Override
-  public Set<N> nodes() {
-    return delegate().nodes();
-  }
-
-  @Override
-  public Set<E> edges() {
-    return delegate().edges();
-  }
-
-  @Override
-  public Graph<N> asGraph() {
-    return delegate().asGraph();
-  }
-
-  @Override
-  public boolean isDirected() {
-    return delegate().isDirected();
-  }
-
-  @Override
-  public boolean allowsParallelEdges() {
-    return delegate().allowsParallelEdges();
-  }
-
-  @Override
-  public boolean allowsSelfLoops() {
-    return delegate().allowsSelfLoops();
-  }
-
-  @Override
-  public ElementOrder<N> nodeOrder() {
-    return delegate().nodeOrder();
-  }
-
-  @Override
-  public ElementOrder<E> edgeOrder() {
-    return delegate().edgeOrder();
-  }
-
-  @Override
-  public Set<N> adjacentNodes(N node) {
-    return delegate().adjacentNodes(node);
-  }
-
-  @Override
-  public Set<N> predecessors(N node) {
-    return delegate().predecessors(node);
-  }
-
-  @Override
-  public Set<N> successors(N node) {
-    return delegate().successors(node);
-  }
-
-  @Override
-  public Set<E> incidentEdges(N node) {
-    return delegate().incidentEdges(node);
-  }
-
-  @Override
-  public Set<E> inEdges(N node) {
-    return delegate().inEdges(node);
-  }
-
-  @Override
-  public Set<E> outEdges(N node) {
-    return delegate().outEdges(node);
-  }
-
-  @Override
-  public int degree(N node) {
-    return delegate().degree(node);
-  }
-
-  @Override
-  public int inDegree(N node) {
-    return delegate().inDegree(node);
-  }
-
-  @Override
-  public int outDegree(N node) {
-    return delegate().outDegree(node);
-  }
-
-  @Override
-  public EndpointPair<N> incidentNodes(E edge) {
-    return delegate().incidentNodes(edge);
-  }
-
-  @Override
-  public Set<E> adjacentEdges(E edge) {
-    return delegate().adjacentEdges(edge);
-  }
-
-  @Override
-  public Set<E> edgesConnecting(N nodeU, N nodeV) {
-    return delegate().edgesConnecting(nodeU, nodeV);
-  }
-
-  @SuppressWarnings("MissingOverride") // Until Guava 23.0
-  public Optional<E> edgeConnecting(N nodeU, N nodeV) {
-    return Optional.ofNullable(edgeConnectingOrNull(nodeU, nodeV));
-  }
-
-  @SuppressWarnings("MissingOverride") // Until Guava 23.0
-  // @Nullable // TODO(ronshapiro): replace with the checker framework?
-  public E edgeConnectingOrNull(N nodeU, N nodeV) {
-    return delegate().edgeConnectingOrNull(nodeU, nodeV);
-  }
-
-  @Override
-  public boolean hasEdgeConnecting(N nodeU, N nodeV) {
-    return delegate().hasEdgeConnecting(nodeU, nodeV);
-  }
-
-  @Override
-  public boolean equals(Object obj) {
-    return delegate().equals(obj);
-  }
-
-  @Override
-  public int hashCode() {
-    return delegate().hashCode();
-  }
-
-  @Override
-  public String toString() {
-    return delegate().toString();
-  }
-}
diff --git a/java/dagger/model/Key.java b/java/dagger/model/Key.java
index daeb35a94..e543d2ab0 100644
--- a/java/dagger/model/Key.java
+++ b/java/dagger/model/Key.java
@@ -88,6 +88,32 @@ public final TypeMirror type() {
   @Override
   public abstract int hashCode();
 
+  // We are modifying what would be the AutoValue-generated equals() method to stick in a check for
+  // hashCode() equality before other properties. Profiling indicated that Key equality is called in
+  // numerous places and it cannot be @Memoized, but hashCode() can be. Because so many other value
+  // types use Key, their equality is dependant on Key's. Inserting the check removed Key.equals()
+  // from the profile.
+  // The main equality bottleneck in calculating the equality is in MoreTypes.equivalence()'s
+  // equality checker. It's possible that we can avoid this by tuning that method. Perhaps we can
+  // also avoid the issue entirely by interning all Keys
+  // TODO(ronshapiro): consider creating an AutoValue extension that can generate this code on its
+  // own
+  @Override
+  public boolean equals(Object o) {
+    if (o == this) {
+      return true;
+    }
+    if (o instanceof Key) {
+      Key that = (Key) o;
+      return (this.hashCode() == that.hashCode())
+          && (this.wrappedQualifier().equals(that.wrappedQualifier()))
+          && (this.wrappedType().equals(that.wrappedType()))
+          && (this.multibindingContributionIdentifier()
+              .equals(that.multibindingContributionIdentifier()));
+    }
+    return false;
+  }
+
   @Override
   public final String toString() {
     return Joiner.on(' ')
diff --git a/java/dagger/model/RequestKind.java b/java/dagger/model/RequestKind.java
index 2f3c75734..74a434633 100644
--- a/java/dagger/model/RequestKind.java
+++ b/java/dagger/model/RequestKind.java
@@ -16,6 +16,9 @@
 
 package dagger.model;
 
+import static com.google.common.base.CaseFormat.UPPER_CAMEL;
+import static com.google.common.base.CaseFormat.UPPER_UNDERSCORE;
+
 import dagger.Lazy;
 import dagger.producers.Produced;
 import dagger.producers.Producer;
@@ -42,8 +45,8 @@
   PROVIDER_OF_LAZY,
 
   /**
-   * A request for a members injection. E.g. {@code void inject(FooType);}. Can only be requested by
-   * component interfaces.
+   * A request for a members injection. E.g. {@code void injectMembers(FooType);}. Can only be
+   * requested by component interfaces.
    */
   MEMBERS_INJECTION,
 
@@ -59,4 +62,24 @@
    */
   FUTURE,
   ;
+
+  /** Returns a string that represents requests of this kind for a key. */
+  public String format(Key key) {
+    switch (this) {
+      case INSTANCE:
+        return key.toString();
+
+      case PROVIDER_OF_LAZY:
+        return String.format("Provider<Lazy<%s>>", key);
+
+      case MEMBERS_INJECTION:
+        return String.format("injectMembers(%s)", key);
+
+      case FUTURE:
+        return String.format("ListenableFuture<%s>", key);
+
+      default:
+        return String.format("%s<%s>", UPPER_UNDERSCORE.to(UPPER_CAMEL, name()), key);
+    }
+  }
 }
diff --git a/java/dagger/model/testing/BUILD b/java/dagger/model/testing/BUILD
index 969c84c43..4e8b62d53 100644
--- a/java/dagger/model/testing/BUILD
+++ b/java/dagger/model/testing/BUILD
@@ -31,9 +31,9 @@ java_library(
     deps = [
         "//java/dagger/internal/codegen:shared-with-spi",
         "//java/dagger/model",
-        "//third_party:auto_value",
-        "//third_party:checker_framework_annotations",
-        "//third_party:guava",
-        "//third_party:truth",
+        "@google_bazel_common//third_party/java/auto:value",
+        "@google_bazel_common//third_party/java/checker_framework:annotations",
+        "@google_bazel_common//third_party/java/guava",
+        "@google_bazel_common//third_party/java/truth",
     ],
 )
diff --git a/java/dagger/model/testing/BindingGraphSubject.java b/java/dagger/model/testing/BindingGraphSubject.java
index 66d3c3627..cd4e65ce1 100644
--- a/java/dagger/model/testing/BindingGraphSubject.java
+++ b/java/dagger/model/testing/BindingGraphSubject.java
@@ -96,10 +96,8 @@ private BindingNodeSubject bindingWithKeyString(String keyString) {
   }
 
   private ImmutableSet<BindingNode> getBindingNodes(String keyString) {
-    return actual()
-        .bindingNodes()
-        .stream()
-        .filter(node -> node.binding().key().toString().equals(keyString))
+    return actual().bindingNodes().stream()
+        .filter(node -> node.key().toString().equals(keyString))
         .collect(toImmutableSet());
   }
 
@@ -139,12 +137,10 @@ public void dependsOnBindingWithKey(String qualifier, String type) {
     }
 
     private void dependsOnBindingWithKeyString(String keyString) {
-      if (actualBindingGraph()
-          .successors(actual())
-          .stream()
+      if (actualBindingGraph().network().successors(actual()).stream()
           .filter(node -> node instanceof BindingNode)
           .map(node -> (BindingNode) node)
-          .noneMatch(node -> node.binding().key().toString().equals(keyString))) {
+          .noneMatch(node -> node.key().toString().equals(keyString))) {
         fail("has successor with key", keyString);
       }
     }
diff --git a/java/dagger/producers/BUILD b/java/dagger/producers/BUILD
index 435d29699..3af069b1b 100644
--- a/java/dagger/producers/BUILD
+++ b/java/dagger/producers/BUILD
@@ -23,6 +23,7 @@ load(
     "DOCLINT_REFERENCES",
     "SOURCE_7_TARGET_7",
 )
+load("//tools:maven.bzl", "pom_file", "POM_VERSION")
 
 # Work around b/70476182 which prevents Kythe from connecting :producers to the .java files it
 # contains.
@@ -37,21 +38,29 @@ java_library(
     name = "producers",
     srcs = SRCS,
     javacopts = SOURCE_7_TARGET_7 + DOCLINT_HTML_AND_SYNTAX + DOCLINT_REFERENCES,
+    tags = ["maven_coordinates=com.google.dagger:dagger-producers:" + POM_VERSION],
     exports = [
         # TODO(dpb): Don't export any of Guava.
-        "//third_party:guava",
-        "//third_party:jsr330_inject",
+        "@google_bazel_common//third_party/java/guava",
+        "@google_bazel_common//third_party/java/jsr330_inject",
     ],
     deps = [
         "//java/dagger:core",
-        "//third_party:checker_framework_annotations",
-        "//third_party:error_prone_annotations",
-        "//third_party:guava",
-        "//third_party:jsr330_inject",
+        "@google_bazel_common//third_party/java/checker_framework:annotations",
+        "@google_bazel_common//third_party/java/error_prone:annotations",
+        "@google_bazel_common//third_party/java/guava",
+        "@google_bazel_common//third_party/java/jsr330_inject",
     ],
 )
 
-load("//tools:javadoc.bzl", "javadoc_library")
+pom_file(
+    name = "pom",
+    artifact_id = "dagger-producers",
+    artifact_name = "Dagger Producers",
+    targets = [":producers"],
+)
+
+load("@google_bazel_common//tools/javadoc:javadoc.bzl", "javadoc_library")
 
 javadoc_library(
     name = "producers-javadoc",
diff --git a/java/dagger/producers/internal/AbstractProducer.java b/java/dagger/producers/internal/AbstractProducer.java
index 39abe991e..3dcd906da 100644
--- a/java/dagger/producers/internal/AbstractProducer.java
+++ b/java/dagger/producers/internal/AbstractProducer.java
@@ -16,60 +16,152 @@
 
 package dagger.producers.internal;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.util.concurrent.MoreExecutors.directExecutor;
 
+import com.google.common.util.concurrent.AbstractFuture;
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.producers.Producer;
-import dagger.producers.monitoring.ProducerMonitor;
-import dagger.producers.monitoring.ProducerToken;
-import dagger.producers.monitoring.ProductionComponentMonitor;
-import dagger.producers.monitoring.internal.Monitors;
-import javax.inject.Provider;
-import org.checkerframework.checker.nullness.compatqual.NullableDecl;
-
-/**
- * An abstract {@link Producer} implementation that memoizes the result of its compute method.
- */
-public abstract class AbstractProducer<T> implements Producer<T> {
-  private final Provider<ProductionComponentMonitor> monitorProvider;
-  @NullableDecl private final ProducerToken token;
-  private volatile ListenableFuture<T> instance = null;
-  protected volatile ProducerMonitor monitor = null;
-
-  protected AbstractProducer() {
-    this(Monitors.noOpProductionComponentMonitorProvider(), null);
+import java.util.concurrent.atomic.AtomicBoolean;
+
+/** An abstract {@link Producer} implementation that memoizes the result of its compute method. */
+public abstract class AbstractProducer<T> implements CancellableProducer<T> {
+  private final AtomicBoolean requested = new AtomicBoolean();
+  private final NonExternallyCancellableFuture<T> future = new NonExternallyCancellableFuture<T>();
+
+  protected AbstractProducer() {}
+
+  /** Computes this producer's future, which is then cached in {@link #get}. */
+  protected abstract ListenableFuture<T> compute();
+
+  @Override
+  public final ListenableFuture<T> get() {
+    if (requested.compareAndSet(false, true)) {
+      future.setFuture(compute());
+    }
+    return future;
+  }
+
+  @Override
+  public final void cancel(boolean mayInterruptIfRunning) {
+    requested.set(true); // Avoid potentially starting the task later only to cancel it immediately.
+    future.doCancel(mayInterruptIfRunning);
   }
 
-  protected AbstractProducer(
-      Provider<ProductionComponentMonitor> monitorProvider, @NullableDecl ProducerToken token) {
-    this.monitorProvider = checkNotNull(monitorProvider);
-    this.token = token;
+  @Override
+  public Producer<T> newDependencyView() {
+    return new NonCancellationPropagatingView();
+  }
+
+  @Override
+  public Producer<T> newEntryPointView(CancellationListener cancellationListener) {
+    NonCancellationPropagatingView result = new NonCancellationPropagatingView();
+    result.addCancellationListener(cancellationListener);
+    return result;
   }
 
   /**
-   * Computes this producer's future, which is then cached in {@link #get}. The {@link #monitor}
-   * will be non-null from the point of this call forward.
+   * A view of this producer that returns a future that can be cancelled without cancelling the
+   * producer itself.
    */
-  protected abstract ListenableFuture<T> compute();
+  private final class NonCancellationPropagatingView implements Producer<T> {
+    /**
+     * An independently cancellable view of this node. Needs to be cancellable by normal future
+     * cancellation so that the view at an entry point can listen for its cancellation.
+     */
+    private final ListenableFuture<T> viewFuture = nonCancellationPropagating(future);
 
-  @Override
-  public final ListenableFuture<T> get() {
-    // double-check idiom from EJ2: Item 71
-    ListenableFuture<T> result = instance;
-    if (result == null) {
-      synchronized (this) {
-        result = instance;
-        if (result == null) {
-          monitor = monitorProvider.get().producerMonitorFor(token);
-          monitor.requested();
-          instance = result = compute();
-          if (result == null) {
-            throw new NullPointerException("compute returned null");
-          }
-          monitor.addCallbackTo(result);
-        }
+    @SuppressWarnings("FutureReturnValueIgnored")
+    @Override
+    public ListenableFuture<T> get() {
+      AbstractProducer.this.get(); // force compute()
+      return viewFuture;
+    }
+
+    void addCancellationListener(final CancellationListener cancellationListener) {
+      viewFuture.addListener(
+          new Runnable() {
+            @Override
+            public void run() {
+              if (viewFuture.isCancelled()) {
+                boolean mayInterruptIfRunning =
+                    viewFuture instanceof NonCancellationPropagatingFuture
+                        && ((NonCancellationPropagatingFuture) viewFuture).interrupted();
+                cancellationListener.onProducerFutureCancelled(mayInterruptIfRunning);
+              }
+            }
+          },
+          directExecutor());
+    }
+  }
+
+  /** A settable future that can't be cancelled via normal future cancellation. */
+  private static final class NonExternallyCancellableFuture<T> extends AbstractFuture<T> {
+
+    @Override
+    public boolean setFuture(ListenableFuture<? extends T> future) {
+      return super.setFuture(future);
+    }
+
+    @Override
+    public boolean cancel(boolean mayInterruptIfRunning) {
+      return false;
+    }
+
+    /** Actually cancels this future. */
+    void doCancel(boolean mayInterruptIfRunning) {
+      super.cancel(mayInterruptIfRunning);
+    }
+  }
+
+  private static <T> ListenableFuture<T> nonCancellationPropagating(ListenableFuture<T> future) {
+    if (future.isDone()) {
+      return future;
+    }
+    NonCancellationPropagatingFuture<T> output = new NonCancellationPropagatingFuture<T>(future);
+    future.addListener(output, directExecutor());
+    return output;
+  }
+
+  /**
+   * Equivalent to {@code Futures.nonCancellationPropagating}, but allowing us to check whether or
+   * not {@code mayInterruptIfRunning} was set when cancelling it.
+   */
+  private static final class NonCancellationPropagatingFuture<T> extends AbstractFuture<T>
+      implements Runnable {
+    // TODO(cgdecker): This is copied directly from Producers.nonCancellationPropagating, but try
+    // to find out why this doesn't need to be volatile.
+    private ListenableFuture<T> delegate;
+
+    NonCancellationPropagatingFuture(final ListenableFuture<T> delegate) {
+      this.delegate = delegate;
+    }
+
+    @Override
+    public void run() {
+      // This prevents cancellation from propagating because we don't call setFuture(delegate) until
+      // delegate is already done, so calling cancel() on this future won't affect it.
+      ListenableFuture<T> localDelegate = delegate;
+      if (localDelegate != null) {
+        setFuture(localDelegate);
       }
     }
-    return result;
+
+    @Override
+    protected String pendingToString() {
+      ListenableFuture<T> localDelegate = delegate;
+      if (localDelegate != null) {
+        return "delegate=[" + localDelegate + "]";
+      }
+      return null;
+    }
+
+    @Override
+    protected void afterDone() {
+      delegate = null;
+    }
+
+    public boolean interrupted() {
+      return super.wasInterrupted();
+    }
   }
 }
diff --git a/java/dagger/producers/internal/AbstractProducesMethodProducer.java b/java/dagger/producers/internal/AbstractProducesMethodProducer.java
new file mode 100644
index 000000000..0cf36ca53
--- /dev/null
+++ b/java/dagger/producers/internal/AbstractProducesMethodProducer.java
@@ -0,0 +1,100 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.producers.internal;
+
+import static dagger.internal.Preconditions.checkNotNull;
+
+import com.google.common.util.concurrent.AsyncFunction;
+import com.google.common.util.concurrent.Futures;
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.producers.monitoring.ProducerMonitor;
+import dagger.producers.monitoring.ProducerToken;
+import dagger.producers.monitoring.ProductionComponentMonitor;
+import java.util.concurrent.Executor;
+import javax.inject.Provider;
+import org.checkerframework.checker.nullness.compatqual.NullableDecl;
+
+/**
+ * An {@link AbstractProducer} for all {@link dagger.producers.Produces} methods.
+ *
+ * @param <D> the type of asynchronous dependencies. These will be collected in {@link
+ *     #collectDependencies()} and then made available to the {@code @Produces method in} {@link
+ *     #callProducesMethod(Object)}. If there is only one asynchronous dependency, {@code D} can be
+ *     the key for that dependency. If there are multiple, they should be wrapped in a list and
+ *     unwrapped in {@link #callProducesMethod(Object)}.
+ * @param <T> the produced type
+ */
+public abstract class AbstractProducesMethodProducer<D, T> extends AbstractProducer<T>
+    implements AsyncFunction<D, T>, Executor {
+  private final Provider<ProductionComponentMonitor> monitorProvider;
+  @NullableDecl private final ProducerToken token;
+  private final Provider<Executor> executorProvider;
+  private volatile ProducerMonitor monitor = null;
+
+  protected AbstractProducesMethodProducer(
+      Provider<ProductionComponentMonitor> monitorProvider,
+      @NullableDecl ProducerToken token,
+      Provider<Executor> executorProvider) {
+    this.monitorProvider = checkNotNull(monitorProvider);
+    this.token = token;
+    this.executorProvider = checkNotNull(executorProvider);
+  }
+
+  @Override
+  protected final ListenableFuture<T> compute() {
+    monitor = monitorProvider.get().producerMonitorFor(token);
+    monitor.requested();
+    ListenableFuture<T> result = Futures.transformAsync(collectDependencies(), this, this);
+    monitor.addCallbackTo(result);
+    return result;
+  }
+
+  /**
+   * Collects the asynchronous dependencies to be passed to {@link
+   * Futures#transformAsync(ListenableFuture, AsyncFunction, Executor)}.
+   */
+  protected abstract ListenableFuture<D> collectDependencies();
+
+  /** @deprecated this may only be called from the internal {@link #compute()} */
+  @Deprecated
+  @Override
+  public final ListenableFuture<T> apply(D asyncDependencies) throws Exception {
+    // NOTE(beder): We don't worry about catching exceptions from the monitor methods themselves
+    // because we'll wrap all monitoring in non-throwing monitors before we pass them to the
+    // factories.
+    monitor.methodStarting();
+    try {
+      return callProducesMethod(asyncDependencies);
+    } finally {
+      monitor.methodFinished();
+    }
+  }
+
+  /**
+   * Calls the {@link dagger.producers.Produces} method. This will always be called on the {@link
+   * Executor} provided to this producer.
+   */
+  protected abstract ListenableFuture<T> callProducesMethod(D asyncDependencies) throws Exception;
+
+  /** @deprecated this may only be called from the internal {@link #compute()} */
+  @Deprecated
+  @Override
+  public final void execute(Runnable runnable) {
+    monitor.ready();
+    executorProvider.get().execute(runnable);
+  }
+}
diff --git a/java/dagger/producers/internal/CancellableProducer.java b/java/dagger/producers/internal/CancellableProducer.java
new file mode 100644
index 000000000..6a1475e5a
--- /dev/null
+++ b/java/dagger/producers/internal/CancellableProducer.java
@@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.producers.internal;
+
+import dagger.producers.Producer;
+
+/** A {@link Producer} that can be cancelled directly even if it hasn't been started. */
+public interface CancellableProducer<T> extends Producer<T> {
+
+  /**
+   * Cancels this producer. If {@link #get()} has already been called, the future it returns will be
+   * cancelled if possible. If not, calling {@link #get()} will return a cancelled future and will
+   * not actually start the underlying operation.
+   *
+   * @param mayInterruptIfRunning the value that should be passed to {@code Future.cancel(boolean)}
+   *     for the futures for any running tasks when cancelling them
+   */
+  void cancel(boolean mayInterruptIfRunning);
+
+  /** Returns a new view of this producer for use as a dependency of another node. */
+  Producer<T> newDependencyView();
+
+  /**
+   * Returns a new view of this producer for use as an entry point.
+   *
+   * <p>When the view's future is cancelled, the given {@code cancellableListener} will be called.
+   */
+  Producer<T> newEntryPointView(CancellationListener cancellationListener);
+}
diff --git a/tools/testdata/Bar.java b/java/dagger/producers/internal/CancellationListener.java
similarity index 54%
rename from tools/testdata/Bar.java
rename to java/dagger/producers/internal/CancellationListener.java
index e040e39fd..182ddc6b3 100644
--- a/tools/testdata/Bar.java
+++ b/java/dagger/producers/internal/CancellationListener.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2017 The Dagger Authors.
+ * Copyright (C) 2018 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,9 +14,12 @@
  * limitations under the License.
  */
 
-package bar;
+package dagger.producers.internal;
 
-import com.google.auto.service.AutoService;
-
-@AutoService(Object.class)
-class Bar {}
+/** A listener for producer future cancellation. */
+public interface CancellationListener {
+  /** Called when the future for a producer this listener has been added to is cancelled. */
+  // Note that this name is intentionally a bit verbose to make it unlikely that it will conflict
+  // with any user-defined methods on a component.
+  void onProducerFutureCancelled(boolean mayInterruptIfRunning);
+}
diff --git a/java/dagger/producers/internal/DependencyMethodProducer.java b/java/dagger/producers/internal/DependencyMethodProducer.java
new file mode 100644
index 000000000..be118f2d2
--- /dev/null
+++ b/java/dagger/producers/internal/DependencyMethodProducer.java
@@ -0,0 +1,119 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.producers.internal;
+
+import static com.google.common.util.concurrent.MoreExecutors.directExecutor;
+
+import com.google.common.collect.MapMaker;
+import com.google.common.util.concurrent.Futures;
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.producers.Producer;
+import java.util.Collections;
+import java.util.Set;
+
+/**
+ * Abstract class for implementing producers derived from methods on component dependencies.
+ *
+ * <p>Unlike most other {@link CancellableProducer} implementations, cancelling the future returned
+ * by a {@linkplain #newDependencyView dependency view} injected into an {@code @Produces} method
+ * will actually cancel the underlying future. This is because the future comes from outside the
+ * component's producer graph (including possibly from another object that isn't a component at
+ * all), so if we don't cancel it when the user asks to cancel it, there might just be no way to
+ * cancel it at all.
+ */
+public abstract class DependencyMethodProducer<T> implements CancellableProducer<T> {
+
+  /** Weak set of all incomplete futures this producer has returned. */
+  private final Set<ListenableFuture<T>> futures =
+      Collections.newSetFromMap(new MapMaker().weakKeys().<ListenableFuture<T>, Boolean>makeMap());
+
+  private boolean cancelled = false;
+
+  /** Calls a method on a component dependency to get a future. */
+  protected abstract ListenableFuture<T> callDependencyMethod();
+
+  @Override
+  public final ListenableFuture<T> get() {
+    synchronized (futures) {
+      if (cancelled) {
+        return Futures.immediateCancelledFuture();
+      }
+
+      final ListenableFuture<T> future = callDependencyMethod();
+      if (!future.isDone() && futures.add(future)) {
+        future.addListener(
+            new Runnable() {
+              @Override
+              public void run() {
+                synchronized (futures) {
+                  futures.remove(future);
+                }
+              }
+            },
+            directExecutor());
+      }
+      return future;
+    }
+  }
+
+  @Override
+  public final void cancel(boolean mayInterruptIfRunning) {
+    synchronized (futures) {
+      cancelled = true;
+      for (ListenableFuture<T> future : futures) {
+        // futures is a concurrent set so that the concurrent removal that will happen here is not
+        // a problem
+        future.cancel(mayInterruptIfRunning);
+      }
+    }
+  }
+
+  @Override
+  public final Producer<T> newDependencyView() {
+    return this;
+  }
+
+  @Override
+  public final Producer<T> newEntryPointView(final CancellationListener cancellationListener) {
+    return new Producer<T>() {
+      private final Set<ListenableFuture<T>> entryPointFutures =
+          Collections.newSetFromMap(
+              new MapMaker().weakKeys().<ListenableFuture<T>, Boolean>makeMap());
+
+      @Override
+      public ListenableFuture<T> get() {
+        final ListenableFuture<T> future = DependencyMethodProducer.this.get();
+        if (!future.isDone() && entryPointFutures.add(future)) {
+          future.addListener(
+              new Runnable() {
+                @Override
+                public void run() {
+                  entryPointFutures.remove(future);
+                  if (future.isCancelled()) {
+                    // TODO(cgdecker): Make this also propagate the actual value that was passed for
+                    // mayInterruptIfRunning
+                    cancellationListener.onProducerFutureCancelled(true);
+                  }
+                }
+              },
+              directExecutor());
+        }
+        return future;
+      }
+    };
+  }
+}
diff --git a/java/dagger/producers/internal/MapOfProducerProducer.java b/java/dagger/producers/internal/MapOfProducerProducer.java
index ef1659224..78b2c017c 100644
--- a/java/dagger/producers/internal/MapOfProducerProducer.java
+++ b/java/dagger/producers/internal/MapOfProducerProducer.java
@@ -17,9 +17,13 @@
 package dagger.producers.internal;
 
 import static com.google.common.base.Preconditions.checkNotNull;
+import static dagger.producers.internal.Producers.entryPointViewOf;
+import static dagger.producers.internal.Producers.nonCancellationPropagatingViewOf;
 import static dagger.producers.internal.Producers.producerFromProvider;
 
+import com.google.common.base.Function;
 import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.Maps;
 import com.google.common.util.concurrent.Futures;
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.producers.Producer;
@@ -72,4 +76,45 @@ private MapOfProducerProducer(ImmutableMap<K, Producer<V>> contributingMap) {
       return new MapOfProducerProducer<>(mapBuilder.build());
     }
   }
+
+  @Override
+  public Producer<Map<K, Producer<V>>> newDependencyView() {
+    return newTransformedValuesView(MapOfProducerProducer.<V>toDependencyView());
+  }
+
+  @Override
+  public Producer<Map<K, Producer<V>>> newEntryPointView(
+      CancellationListener cancellationListener) {
+    return newTransformedValuesView(
+        MapOfProducerProducer.<V>toEntryPointView(cancellationListener));
+  }
+
+  private Producer<Map<K, Producer<V>>> newTransformedValuesView(
+      Function<Producer<V>, Producer<V>> valueTransformationFunction) {
+    return Producers.<Map<K, Producer<V>>>immediateProducer(
+        ImmutableMap.copyOf(Maps.transformValues(contributingMap, valueTransformationFunction)));
+  }
+
+  @SuppressWarnings("unchecked")
+  private static <T> Function<Producer<T>, Producer<T>> toDependencyView() {
+    return (Function) TO_DEPENDENCY_VIEW;
+  }
+
+  private static <T> Function<Producer<T>, Producer<T>> toEntryPointView(
+      final CancellationListener cancellationListener) {
+    return new Function<Producer<T>, Producer<T>>() {
+      @Override
+      public Producer<T> apply(Producer<T> input) {
+        return entryPointViewOf(input, cancellationListener);
+      }
+    };
+  }
+
+  private static final Function<Producer<?>, Producer<?>> TO_DEPENDENCY_VIEW =
+      new Function<Producer<?>, Producer<?>>() {
+        @Override
+        public Producer<?> apply(Producer<?> input) {
+          return nonCancellationPropagatingViewOf(input);
+        }
+      };
 }
diff --git a/java/dagger/producers/internal/Producers.java b/java/dagger/producers/internal/Producers.java
index 4de3354ee..b50a95ef2 100644
--- a/java/dagger/producers/internal/Producers.java
+++ b/java/dagger/producers/internal/Producers.java
@@ -126,7 +126,7 @@
    */
   public static <T> Producer<T> producerFromProvider(final Provider<T> provider) {
     checkNotNull(provider);
-    return new Producer<T>() {
+    return new CompletedProducer<T>() {
       @Override
       public ListenableFuture<T> get() {
         return Futures.immediateFuture(provider.get());
@@ -136,24 +136,76 @@
 
   /** Returns a producer that succeeds with the given value. */
   public static <T> Producer<T> immediateProducer(final T value) {
-    return new Producer<T>() {
+    final ListenableFuture<T> future = Futures.immediateFuture(value);
+    return new CompletedProducer<T>() {
       @Override
       public ListenableFuture<T> get() {
-        return Futures.immediateFuture(value);
+        return future;
       }
     };
   }
 
   /** Returns a producer that fails with the given exception. */
   public static <T> Producer<T> immediateFailedProducer(final Throwable throwable) {
-    return new Producer<T>() {
+    final ListenableFuture<T> future = Futures.immediateFailedFuture(throwable);
+    return new CompletedProducer<T>() {
       @Override
       public ListenableFuture<T> get() {
-        return Futures.immediateFailedFuture(throwable);
+        return future;
       }
     };
   }
 
+  /**
+   * Returns a new view of the given {@code producer} if and only if it is a {@link
+   * CancellableProducer}. Cancelling the returned producer's future will not cancel the underlying
+   * task for the given producer.
+   *
+   * @throws IllegalArgumentException if {@code producer} is not a {@code CancellableProducer}
+   */
+  public static <T> Producer<T> nonCancellationPropagatingViewOf(Producer<T> producer) {
+    // This is a hack until we change the types of Producer fields to be CancellableProducer or
+    // some other type.
+    if (producer instanceof CancellableProducer) {
+      return ((CancellableProducer<T>) producer).newDependencyView();
+    }
+    throw new IllegalArgumentException(
+        "nonCancellationPropagatingViewOf called with non-CancellableProducer: " + producer);
+  }
+
+  /**
+   * Returns a new view of the given {@code producer} for use as an entry point in a production
+   * component, if and only if it is a {@link CancellableProducer}. When the returned producer's
+   * future is cancelled, the given {@code cancellable} will also be cancelled.
+   *
+   * @throws IllegalArgumentException if {@code producer} is not a {@code CancellableProducer}
+   */
+  public static <T> Producer<T> entryPointViewOf(
+      Producer<T> producer, CancellationListener cancellationListener) {
+    // This is a hack until we change the types of Producer fields to be CancellableProducer or
+    // some other type.
+    if (producer instanceof CancellableProducer) {
+      return ((CancellableProducer<T>) producer).newEntryPointView(cancellationListener);
+    }
+    throw new IllegalArgumentException(
+        "entryPointViewOf called with non-CancellableProducer: " + producer);
+  }
+
+  /**
+   * Calls {@code cancel} on the given {@code producer} if it is a {@link CancellableProducer}.
+   *
+   * @throws IllegalArgumentException if {@code producer} is not a {@code CancellableProducer}
+   */
+  public static void cancel(Producer<?> producer, boolean mayInterruptIfRunning) {
+    // This is a hack until we change the types of Producer fields to be CancellableProducer or
+    // some other type.
+    if (producer instanceof CancellableProducer) {
+      ((CancellableProducer<?>) producer).cancel(mayInterruptIfRunning);
+    } else {
+      throw new IllegalArgumentException("cancel called with non-CancellableProducer: " + producer);
+    }
+  }
+
   private static final Producer<Map<Object, Object>> EMPTY_MAP_PRODUCER =
       Producers.<Map<Object, Object>>immediateProducer(ImmutableMap.of());
 
@@ -162,5 +214,24 @@
     return (Producer<Map<K, V>>) (Producer) EMPTY_MAP_PRODUCER;
   }
 
+  /**
+   * A {@link CancellableProducer} which can't be cancelled because it represents an
+   * already-completed task.
+   */
+  private abstract static class CompletedProducer<T> implements CancellableProducer<T> {
+    @Override
+    public void cancel(boolean mayInterruptIfRunning) {}
+
+    @Override
+    public Producer<T> newDependencyView() {
+      return this;
+    }
+
+    @Override
+    public Producer<T> newEntryPointView(CancellationListener cancellationListener) {
+      return this;
+    }
+  }
+
   private Producers() {}
 }
diff --git a/java/dagger/producers/internal/SetOfProducedProducer.java b/java/dagger/producers/internal/SetOfProducedProducer.java
index 60ccc7cc4..40833e5c2 100644
--- a/java/dagger/producers/internal/SetOfProducedProducer.java
+++ b/java/dagger/producers/internal/SetOfProducedProducer.java
@@ -101,15 +101,14 @@ private SetOfProducedProducer(
   }
 
   /**
-   * Returns a future {@link Set} of {@link Produced} values whose iteration order is that of the
-   * elements given by each of the producers, which are invoked in the order given at creation.
+   * Returns a future {@link Set} of {@link Produced} elements given by each of the producers.
    *
    * <p>If any of the delegate collections, or any elements therein, are null, then that
    * corresponding {@code Produced} element will fail with a NullPointerException.
    *
    * <p>Canceling this future will attempt to cancel all of the component futures; but if any of the
-   * delegate futures fail or are canceled, this future succeeds, with the appropriate failed
-   * {@link Produced}.
+   * delegate futures fail or are canceled, this future succeeds, with the appropriate failed {@link
+   * Produced}.
    *
    * @throws NullPointerException if any of the delegate producers return null
    */
diff --git a/java/dagger/producers/internal/SetProducer.java b/java/dagger/producers/internal/SetProducer.java
index 12e196771..687b9ee3c 100644
--- a/java/dagger/producers/internal/SetProducer.java
+++ b/java/dagger/producers/internal/SetProducer.java
@@ -39,12 +39,7 @@
  */
 public final class SetProducer<T> extends AbstractProducer<Set<T>> {
   private static final Producer<Set<Object>> EMPTY_PRODUCER =
-      new Producer<Set<Object>>() {
-        @Override
-        public ListenableFuture<Set<Object>> get() {
-          return Futures.<Set<Object>>immediateFuture(ImmutableSet.<Object>of());
-        }
-      };
+      Producers.<Set<Object>>immediateProducer(ImmutableSet.<Object>of());
 
   @SuppressWarnings({"unchecked", "rawtypes"}) // safe covariant cast
   public static <T> Producer<Set<T>> empty() {
@@ -109,8 +104,7 @@ private SetProducer(
   }
 
   /**
-   * Returns a future {@link Set} whose iteration order is that of the elements given by each of the
-   * producers, which are invoked in the order given at creation.
+   * Returns a future {@link Set} that contains the elements given by each of the producers.
    *
    * <p>If any of the delegate collections, or any elements therein, are null, then this future will
    * fail with a NullPointerException.
diff --git a/java/dagger/spi/BUILD b/java/dagger/spi/BUILD
index 34cc7d31f..fb4fcc148 100644
--- a/java/dagger/spi/BUILD
+++ b/java/dagger/spi/BUILD
@@ -28,16 +28,29 @@ filegroup(
     srcs = glob(["*.java"]),
 )
 
+load("//tools:maven.bzl", "pom_file", "POM_VERSION")
+
 java_library(
     name = "spi",
     srcs = [":spi-srcs"],
     javacopts = DOCLINT_HTML_AND_SYNTAX + DOCLINT_REFERENCES,
+    tags = ["maven_coordinates=com.google.dagger:dagger-spi:" + POM_VERSION],
     deps = [
         "//java/dagger:core",
         "//java/dagger/model",
-        "//third_party:auto_value",
-        "//third_party:error_prone_annotations",
-        "//third_party:guava",
-        "//third_party:jsr330_inject",
+        "@google_bazel_common//third_party/java/auto:value",
+        "@google_bazel_common//third_party/java/error_prone:annotations",
+        "@google_bazel_common//third_party/java/guava",
+        "@google_bazel_common//third_party/java/jsr330_inject",
+    ],
+)
+
+pom_file(
+    name = "pom",
+    artifact_id = "dagger-spi",
+    artifact_name = "Dagger SPI",
+    targets = [
+        "//java/dagger/model",
+        ":spi",
     ],
 )
diff --git a/java/dagger/spi/DiagnosticReporter.java b/java/dagger/spi/DiagnosticReporter.java
index 05e1d3fba..8c15149d6 100644
--- a/java/dagger/spi/DiagnosticReporter.java
+++ b/java/dagger/spi/DiagnosticReporter.java
@@ -18,14 +18,17 @@
 
 import com.google.errorprone.annotations.FormatMethod;
 import dagger.model.BindingGraph;
-import dagger.model.BindingGraph.BindingNode;
+import dagger.model.BindingGraph.ChildFactoryMethodEdge;
 import dagger.model.BindingGraph.ComponentNode;
 import dagger.model.BindingGraph.DependencyEdge;
+import dagger.model.BindingGraph.MaybeBindingNode;
 import javax.tools.Diagnostic;
 
 /**
  * An object that {@link BindingGraphPlugin}s can use to report diagnostics while visiting a {@link
  * BindingGraph}.
+ *
+ * <p>Note: This API is still experimental and will change.
  */
 public interface DiagnosticReporter {
   /**
@@ -47,19 +50,19 @@ void reportComponent(
       Object... moreArgs);
 
   /**
-   * Reports a diagnostic for a binding. Includes information about how the binding is reachable
-   * from entry points.
+   * Reports a diagnostic for a binding or missing binding. Includes information about how the
+   * binding is reachable from entry points.
    */
-  void reportBinding(Diagnostic.Kind diagnosticKind, BindingNode bindingNode, String message);
+  void reportBinding(Diagnostic.Kind diagnosticKind, MaybeBindingNode bindingNode, String message);
 
   /**
-   * Reports a diagnostic for a binding. Includes information about how the binding is reachable
-   * from entry points.
+   * Reports a diagnostic for a binding or missing binding. Includes information about how the
+   * binding is reachable from entry points.
    */
   @FormatMethod
   void reportBinding(
       Diagnostic.Kind diagnosticKind,
-      BindingNode bindingNode,
+      MaybeBindingNode bindingNode,
       String messageFormat,
       Object firstArg,
       Object... moreArgs);
@@ -82,4 +85,19 @@ void reportDependency(
       String messageFormat,
       Object firstArg,
       Object... moreArgs);
+
+  /** Reports a diagnostic for a subcomponent factory method. */
+  void reportSubcomponentFactoryMethod(
+      Diagnostic.Kind diagnosticKind,
+      ChildFactoryMethodEdge childFactoryMethodEdge,
+      String message);
+
+  /** Reports a diagnostic for a subcomponent factory method. */
+  @FormatMethod
+  void reportSubcomponentFactoryMethod(
+      Diagnostic.Kind diagnosticKind,
+      ChildFactoryMethodEdge childFactoryMethodEdge,
+      String messageFormat,
+      Object firstArg,
+      Object... moreArgs);
 }
diff --git a/javatests/dagger/BUILD b/javatests/dagger/BUILD
index ae7aeb021..83257e800 100644
--- a/javatests/dagger/BUILD
+++ b/javatests/dagger/BUILD
@@ -26,9 +26,9 @@ GenJavaTests(
     javacopts = DOCLINT_HTML_AND_SYNTAX + DOCLINT_REFERENCES,
     deps = [
         "//java/dagger:core",
-        "//third_party:guava",
-        "//third_party:jsr330_inject",
-        "//third_party:junit",
-        "//third_party:truth",
+        "@google_bazel_common//third_party/java/guava",
+        "@google_bazel_common//third_party/java/jsr330_inject",
+        "@google_bazel_common//third_party/java/junit",
+        "@google_bazel_common//third_party/java/truth",
     ],
 )
diff --git a/javatests/dagger/android/AndroidInjectionTest.java b/javatests/dagger/android/AndroidInjectionTest.java
index ec5be117b..a24ff5b6c 100644
--- a/javatests/dagger/android/AndroidInjectionTest.java
+++ b/javatests/dagger/android/AndroidInjectionTest.java
@@ -22,10 +22,10 @@
 import android.app.Activity;
 import android.app.Application;
 import android.app.Fragment;
-import org.robolectric.RobolectricTestRunner;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
+import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 import org.robolectric.util.FragmentTestUtil;
 
diff --git a/javatests/dagger/android/BUILD b/javatests/dagger/android/BUILD
index cf47d8be9..8fa3dc303 100644
--- a/javatests/dagger/android/BUILD
+++ b/javatests/dagger/android/BUILD
@@ -24,11 +24,12 @@ GenRobolectricTests(
     name = "android_tests",
     srcs = glob(["*.java"]),
     javacopts = DOCLINT_HTML_AND_SYNTAX,
+    manifest_values = {"minSdkVersion": "17"},
     deps = [
         "//:dagger_with_compiler",
         "//java/dagger/android",
-        "//third_party:guava",
-        "//third_party:junit",
-        "//third_party:truth",
+        "@google_bazel_common//third_party/java/guava",
+        "@google_bazel_common//third_party/java/junit",
+        "@google_bazel_common//third_party/java/truth",
     ],
 )
diff --git a/javatests/dagger/android/DispatchingAndroidInjectorTest.java b/javatests/dagger/android/DispatchingAndroidInjectorTest.java
index 2d1e6132c..544565a37 100644
--- a/javatests/dagger/android/DispatchingAndroidInjectorTest.java
+++ b/javatests/dagger/android/DispatchingAndroidInjectorTest.java
@@ -20,50 +20,70 @@
 import static org.junit.Assert.fail;
 
 import android.app.Activity;
-import org.robolectric.RobolectricTestRunner;
+import com.google.common.collect.ImmutableMap;
 import dagger.android.DispatchingAndroidInjector.InvalidInjectorBindingException;
-import java.util.HashMap;
-import java.util.Map;
-import javax.inject.Provider;
-import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
+import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
 @Config(manifest = Config.NONE)
 @RunWith(RobolectricTestRunner.class)
 public final class DispatchingAndroidInjectorTest {
-  private DispatchingAndroidInjector<Activity> dispatchingAndroidInjector;
-
-  @Before
-  public void setup() {
-    Map<Class<? extends Activity>, Provider<AndroidInjector.Factory<? extends Activity>>>
-        injectorFactories = new HashMap<>();
-    injectorFactories.put(FooActivity.class, FooInjector.Factory::new);
-    injectorFactories.put(ReturnsNullActivity.class, () -> null);
-    injectorFactories.put(WrongActivity.class, FooInjector.Factory::new);
-    dispatchingAndroidInjector = new DispatchingAndroidInjector<>(injectorFactories);
+  @Test
+  public void withClassKeys() {
+    DispatchingAndroidInjector<Activity> dispatchingAndroidInjector =
+        new DispatchingAndroidInjector<>(
+            ImmutableMap.of(FooActivity.class, FooInjector.Factory::new), ImmutableMap.of());
+
+    FooActivity activity = Robolectric.setupActivity(FooActivity.class);
+    assertThat(dispatchingAndroidInjector.maybeInject(activity)).isTrue();
+  }
+
+  @Test
+  public void withStringKeys() {
+    DispatchingAndroidInjector<Activity> dispatchingAndroidInjector =
+        new DispatchingAndroidInjector<>(
+            ImmutableMap.of(),
+            ImmutableMap.of(FooActivity.class.getName(), FooInjector.Factory::new));
+
+    FooActivity activity = Robolectric.setupActivity(FooActivity.class);
+    assertThat(dispatchingAndroidInjector.maybeInject(activity)).isTrue();
   }
 
   @Test
-  public void maybeInject_returnsTrue_ifMatchingInjectorExists() {
+  public void withMixedKeys() {
+    DispatchingAndroidInjector<Activity> dispatchingAndroidInjector =
+        new DispatchingAndroidInjector<>(
+            ImmutableMap.of(FooActivity.class, FooInjector.Factory::new),
+            ImmutableMap.of(BarActivity.class.getName(), BarInjector.Factory::new));
+
     FooActivity fooActivity = Robolectric.setupActivity(FooActivity.class);
     assertThat(dispatchingAndroidInjector.maybeInject(fooActivity)).isTrue();
+    BarActivity barActivity = Robolectric.setupActivity(BarActivity.class);
+    assertThat(dispatchingAndroidInjector.maybeInject(barActivity)).isTrue();
   }
 
   @Test
   public void maybeInject_returnsFalse_ifNoMatchingInjectorExists() {
-    BarActivity barActivity = Robolectric.setupActivity(BarActivity.class);
-    assertThat(dispatchingAndroidInjector.maybeInject(barActivity)).isFalse();
+    DispatchingAndroidInjector<Activity> dispatchingAndroidInjector =
+        new DispatchingAndroidInjector<>(ImmutableMap.of(), ImmutableMap.of());
+    
+    BarActivity activity = Robolectric.setupActivity(BarActivity.class);
+    assertThat(dispatchingAndroidInjector.maybeInject(activity)).isFalse();
   }
 
   @Test
   public void throwsIfFactoryCreateReturnsNull() {
-    ReturnsNullActivity returnsNullActivity = Robolectric.setupActivity(ReturnsNullActivity.class);
+    DispatchingAndroidInjector<Activity> dispatchingAndroidInjector =
+        new DispatchingAndroidInjector<>(
+            ImmutableMap.of(FooActivity.class, () -> null),
+            ImmutableMap.of());
+    FooActivity activity = Robolectric.setupActivity(FooActivity.class);
 
     try {
-      dispatchingAndroidInjector.maybeInject(returnsNullActivity);
+      dispatchingAndroidInjector.maybeInject(activity);
       fail("Expected NullPointerException");
     } catch (NullPointerException expected) {
     }
@@ -71,10 +91,13 @@ public void throwsIfFactoryCreateReturnsNull() {
 
   @Test
   public void throwsIfClassMismatched() {
-    WrongActivity wrongActivity = Robolectric.setupActivity(WrongActivity.class);
+    DispatchingAndroidInjector<Activity> dispatchingAndroidInjector =
+        new DispatchingAndroidInjector<>(
+            ImmutableMap.of(FooActivity.class, BarInjector.Factory::new), ImmutableMap.of());
+    FooActivity activity = Robolectric.setupActivity(FooActivity.class);
 
     try {
-      dispatchingAndroidInjector.maybeInject(wrongActivity);
+      dispatchingAndroidInjector.maybeInject(activity);
       fail("Expected InvalidInjectorBindingException");
     } catch (InvalidInjectorBindingException expected) {
     }
@@ -84,10 +107,6 @@ public void throwsIfClassMismatched() {
 
   static class BarActivity extends Activity {}
 
-  static class ReturnsNullActivity extends Activity {}
-
-  static class WrongActivity extends Activity {}
-
   static class FooInjector implements AndroidInjector<FooActivity> {
     @Override
     public void inject(FooActivity instance) {}
@@ -99,4 +118,16 @@ public void inject(FooActivity instance) {}
       }
     }
   }
+
+  static class BarInjector implements AndroidInjector<BarActivity> {
+    @Override
+    public void inject(BarActivity instance) {}
+
+    static class Factory implements AndroidInjector.Factory<BarActivity> {
+      @Override
+      public AndroidInjector<BarActivity> create(BarActivity activity) {
+        return new BarInjector();
+      }
+    }
+  }
 }
diff --git a/javatests/dagger/android/functional/AndroidMemorySensitiveReferenceManagerTest.java b/javatests/dagger/android/functional/AndroidMemorySensitiveReferenceManagerTest.java
index 076de40fc..df0c890bf 100644
--- a/javatests/dagger/android/functional/AndroidMemorySensitiveReferenceManagerTest.java
+++ b/javatests/dagger/android/functional/AndroidMemorySensitiveReferenceManagerTest.java
@@ -25,11 +25,11 @@
 import com.google.common.collect.ImmutableList;
 import com.google.common.testing.GcFinalization;
 import com.google.common.testing.GcFinalization.FinalizationPredicate;
-import org.robolectric.RobolectricTestRunner;
 import java.lang.ref.WeakReference;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
 
 /** Functional tests of {@link dagger.android.AndroidMemorySensitiveReferenceManager}. */
 @RunWith(RobolectricTestRunner.class)
diff --git a/javatests/dagger/android/functional/BUILD b/javatests/dagger/android/functional/BUILD
index cfe46e194..fe80b6d47 100644
--- a/javatests/dagger/android/functional/BUILD
+++ b/javatests/dagger/android/functional/BUILD
@@ -45,9 +45,9 @@ GenRobolectricTests(
     javacopts = DOCLINT_HTML_AND_SYNTAX,
     deps = [
         ":code_under_test",
-        "//third_party:guava",
-        "//third_party:guava_testlib",
-        "//third_party:junit",
-        "//third_party:truth",
+        "@google_bazel_common//third_party/java/guava",
+        "@google_bazel_common//third_party/java/guava:testlib",
+        "@google_bazel_common//third_party/java/junit",
+        "@google_bazel_common//third_party/java/truth",
     ],
 )
diff --git a/javatests/dagger/android/processor/AndroidMapKeyValidatorTest.java b/javatests/dagger/android/processor/AndroidMapKeyValidatorTest.java
new file mode 100644
index 000000000..d08bf0b78
--- /dev/null
+++ b/javatests/dagger/android/processor/AndroidMapKeyValidatorTest.java
@@ -0,0 +1,451 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.processor;
+
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static com.google.testing.compile.Compiler.javac;
+
+import com.google.common.base.Joiner;
+import com.google.testing.compile.Compilation;
+import com.google.testing.compile.JavaFileObjects;
+import dagger.internal.codegen.ComponentProcessor;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public class AndroidMapKeyValidatorTest {
+  private static final JavaFileObject FOO_ACTIVITY =
+      JavaFileObjects.forSourceLines(
+          "test.FooActivity",
+          "package test;",
+          "",
+          "import android.app.Activity;",
+          "import dagger.android.AndroidInjector;",
+          "",
+          "public class FooActivity extends Activity {",
+          "  interface Factory extends AndroidInjector.Factory<FooActivity> {}",
+          "  abstract static class Builder extends AndroidInjector.Builder<FooActivity> {}",
+          "}");
+  private static final JavaFileObject BAR_ACTIVITY =
+      JavaFileObjects.forSourceLines(
+          "test.BarActivity",
+          "package test;",
+          "",
+          "import android.app.Activity;",
+          "",
+          "public class BarActivity extends Activity {}");
+  private static final JavaFileObject BAZ_FRAGMENT =
+      JavaFileObjects.forSourceLines(
+          "test.BazFragment",
+          "package test;",
+          "",
+          "import android.app.Fragment;",
+          "",
+          "public class BazFragment extends Fragment {}");
+
+  private static JavaFileObject moduleWithMethod(String... lines) {
+    return JavaFileObjects.forSourceLines(
+        "test.AndroidModule",
+        "package test;",
+        "",
+        "import android.app.Activity;",
+        "import android.app.Fragment;",
+        "import dagger.Module;",
+        "import dagger.*;",
+        "import dagger.android.*;",
+        "import dagger.multibindings.IntoMap;",
+        "import javax.inject.*;",
+        "",
+        "@Module",
+        "abstract class AndroidModule {",
+        "  " + Joiner.on("\n  ").join(lines),
+        "}");
+  }
+
+  // TODO(dpb): Change these tests to use onLineContaining() instead of onLine().
+  private static final int LINES_BEFORE_METHOD = 12;
+
+  @Test
+  public void rawFactoryType() {
+    JavaFileObject module =
+        moduleWithMethod(
+            "@Binds",
+            "@IntoMap",
+            "@ActivityKey(FooActivity.class)",
+            "abstract AndroidInjector.Factory bindRawFactory(FooActivity.Factory factory);");
+    Compilation compilation = compile(module, FOO_ACTIVITY);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            "@dagger.android.ActivityKey methods should bind "
+                + "dagger.android.AndroidInjector.Factory<? extends android.app.Activity>, not "
+                + "dagger.android.AndroidInjector.Factory");
+  }
+
+  @Test
+  public void rawBuilderType() {
+    JavaFileObject module =
+        moduleWithMethod(
+            "@Binds",
+            "@IntoMap",
+            "@ActivityKey(FooActivity.class)",
+            "abstract AndroidInjector.Builder bindRawBuilder(FooActivity.Builder builder);");
+    Compilation compilation = compile(module, FOO_ACTIVITY);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            "@dagger.android.ActivityKey methods should bind "
+                + "dagger.android.AndroidInjector.Factory<? extends android.app.Activity>, not "
+                + "dagger.android.AndroidInjector.Builder");
+  }
+
+  @Test
+  public void bindsToBuilderNotFactory() {
+    JavaFileObject module =
+        moduleWithMethod(
+            "@Binds",
+            "@IntoMap",
+            "@ActivityKey(FooActivity.class)",
+            "abstract AndroidInjector.Builder<? extends Activity> bindBuilder(",
+            "    FooActivity.Builder builder);");
+    Compilation compilation = compile(module, FOO_ACTIVITY);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            "@dagger.android.ActivityKey methods should bind "
+                + "dagger.android.AndroidInjector.Factory<? extends android.app.Activity>, not "
+                + "dagger.android.AndroidInjector.Builder<? extends android.app.Activity>");
+  }
+
+  @Test
+  public void providesToBuilderNotFactory() {
+    JavaFileObject module =
+        moduleWithMethod(
+            "@Provides",
+            "@IntoMap",
+            "@ActivityKey(FooActivity.class)",
+            "static AndroidInjector.Builder<? extends Activity> bindBuilder(",
+            "    FooActivity.Builder builder) {",
+            "  return builder;",
+            "}");
+    Compilation compilation = compile(module, FOO_ACTIVITY);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            "@dagger.android.ActivityKey methods should bind "
+                + "dagger.android.AndroidInjector.Factory<? extends android.app.Activity>, not "
+                + "dagger.android.AndroidInjector.Builder<? extends android.app.Activity>");
+  }
+
+  @Test
+  public void mapKeyDoesntMatchCoreType() {
+    JavaFileObject module =
+        moduleWithMethod(
+            "@Binds",
+            "@IntoMap",
+            "@FragmentKey(BazFragment.class)",
+            "abstract AndroidInjector.Factory<? extends Activity> bindWrongFrameworkType(",
+            "    FooActivity.Builder builder);");
+    Compilation compilation = compile(module, FOO_ACTIVITY, BAZ_FRAGMENT);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            "@dagger.android.FragmentKey methods should bind "
+                + "dagger.android.AndroidInjector.Factory<? extends android.app.Fragment>, not "
+                + "dagger.android.AndroidInjector.Factory<? extends android.app.Activity>");
+    assertThat(compilation)
+        .hadErrorContaining(
+            "test.FooActivity.Builder does not implement AndroidInjector<test.BazFragment>")
+        .inFile(module)
+        .onLine(LINES_BEFORE_METHOD + 3);
+  }
+
+  @Test
+  public void mapKeyDoesntMatchCoreType_AndroidInjectionKey() {
+    JavaFileObject module =
+        moduleWithMethod(
+            "@Binds",
+            "@IntoMap",
+            "@AndroidInjectionKey(\"test.BazFragment\")",
+            "abstract AndroidInjector.Factory<? extends Activity> bindWrongFrameworkType(",
+            "    FooActivity.Builder builder);");
+    Compilation compilation = compile(module, FOO_ACTIVITY, BAZ_FRAGMENT);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            "bindWrongFrameworkType(test.FooActivity.Builder) should bind "
+                + "dagger.android.AndroidInjector.Factory<? extends android.app.Fragment>, not "
+                + "dagger.android.AndroidInjector.Factory<? extends android.app.Activity>");
+    assertThat(compilation)
+        .hadErrorContaining(
+            "test.FooActivity.Builder does not implement AndroidInjector<test.BazFragment>")
+        .inFile(module)
+        .onLine(LINES_BEFORE_METHOD + 3);
+  }
+
+  @Test
+  public void mapKeyDoesntMatchCoreType_supportFragments() {
+    JavaFileObject supportFragment =
+        JavaFileObjects.forSourceLines(
+            "test.SupportFragment",
+            "package test;",
+            "",
+            "import android.support.v4.app.Fragment;",
+            "import dagger.android.AndroidInjector;",
+            "",
+            "public class SupportFragment extends Fragment {",
+            "  interface Factory extends AndroidInjector.Factory<SupportFragment> {}",
+            "}");
+
+    JavaFileObject module =
+        moduleWithMethod(
+            "@Binds",
+            "@IntoMap",
+            "@dagger.android.FragmentKey(BazFragment.class)",
+            "abstract AndroidInjector.Factory<? extends android.support.v4.app.Fragment> ",
+            "    bindWrongFrameworkType(SupportFragment.Factory factory);");
+    Compilation compilation = compile(module, BAZ_FRAGMENT, supportFragment);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            "@dagger.android.FragmentKey methods should bind "
+                + "dagger.android.AndroidInjector.Factory<? extends android.app.Fragment>, not "
+                + "dagger.android.AndroidInjector.Factory<? extends "
+                + "android.support.v4.app.Fragment>");
+    assertThat(compilation)
+        .hadErrorContaining(
+            "test.SupportFragment.Factory does not implement AndroidInjector<test.BazFragment>")
+        .inFile(module)
+        .onLine(LINES_BEFORE_METHOD + 3);
+  }
+
+  @Test
+  public void bindsToConcreteTypeInsteadOfWildcard() {
+    JavaFileObject module =
+        moduleWithMethod(
+            "@Binds",
+            "@IntoMap",
+            "@ActivityKey(FooActivity.class)",
+            "abstract AndroidInjector.Builder<FooActivity> bindBuilder(",
+            "    FooActivity.Builder builder);");
+    Compilation compilation = compile(module, FOO_ACTIVITY);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            "@dagger.android.ActivityKey methods should bind "
+                + "dagger.android.AndroidInjector.Factory<? extends android.app.Activity>, not "
+                + "dagger.android.AndroidInjector.Builder<test.FooActivity>");
+  }
+
+  @Test
+  public void bindsToBaseTypeInsteadOfWildcard() {
+    JavaFileObject module =
+        moduleWithMethod(
+            "@Binds",
+            "@IntoMap",
+            "@ActivityKey(FooActivity.class)",
+            "abstract AndroidInjector.Builder<Activity> bindBuilder(",
+            "    FooActivity.Builder builder);");
+    Compilation compilation = compile(module, FOO_ACTIVITY);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("@Binds methods' parameter type must be assignable to the return type");
+  }
+
+  @Test
+  public void bindsCorrectType() {
+    JavaFileObject module =
+        moduleWithMethod(
+            "@Binds",
+            "@IntoMap",
+            "@ActivityKey(FooActivity.class)",
+            "abstract AndroidInjector.Factory<? extends Activity> bindCorrectType(",
+            "    FooActivity.Builder builder);");
+    Compilation compilation = compile(module, FOO_ACTIVITY);
+    assertThat(compilation).succeededWithoutWarnings();
+  }
+
+  @Test
+  public void bindsCorrectType_AndroidInjectionKey() {
+    JavaFileObject module =
+        moduleWithMethod(
+            "@Binds",
+            "@IntoMap",
+            "@AndroidInjectionKey(\"test.FooActivity\")",
+            "abstract AndroidInjector.Factory<? extends Activity> bindCorrectType(",
+            "    FooActivity.Builder builder);");
+    Compilation compilation = compile(module, FOO_ACTIVITY);
+    assertThat(compilation).succeededWithoutWarnings();
+  }
+
+  @Test
+  public void bindsWithScope() {
+    JavaFileObject module =
+        moduleWithMethod(
+            "@Binds",
+            "@IntoMap",
+            "@ActivityKey(FooActivity.class)",
+            "@Singleton",
+            "abstract AndroidInjector.Factory<? extends Activity> bindWithScope(",
+            "    FooActivity.Builder builder);");
+    Compilation compilation = compile(module, FOO_ACTIVITY);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining("should not be scoped");
+  }
+
+  @Test
+  public void bindsWithScope_suppressWarnings() {
+    JavaFileObject module =
+        moduleWithMethod(
+            "@SuppressWarnings(\"dagger.android.ScopedInjectorFactory\")",
+            "@Binds",
+            "@IntoMap",
+            "@ActivityKey(FooActivity.class)",
+            "@Singleton",
+            "abstract AndroidInjector.Factory<? extends Activity> bindWithScope(",
+            "    FooActivity.Builder builder);");
+    Compilation compilation = compile(module, FOO_ACTIVITY);
+    assertThat(compilation).succeededWithoutWarnings();
+  }
+
+  @Test
+  public void mismatchedMapKey_bindsFactory() {
+    JavaFileObject module =
+        moduleWithMethod(
+            "@Binds",
+            "@IntoMap",
+            "@ActivityKey(BarActivity.class)",
+            "abstract AndroidInjector.Factory<?> mismatchedFactory(",
+            "    FooActivity.Factory factory);");
+    Compilation compilation = compile(module, FOO_ACTIVITY, BAR_ACTIVITY);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            "test.FooActivity.Factory does not implement AndroidInjector<test.BarActivity>")
+        .inFile(module)
+        .onLine(LINES_BEFORE_METHOD + 3);
+  }
+
+  @Test
+  public void mismatchedMapKey_bindsBuilder() {
+    JavaFileObject module =
+        moduleWithMethod(
+            "@Binds",
+            "@IntoMap",
+            "@ActivityKey(BarActivity.class)",
+            "abstract AndroidInjector.Factory<? extends Activity> mismatchedBuilder(",
+            "    FooActivity.Builder builder);");
+    Compilation compilation = compile(module, FOO_ACTIVITY, BAR_ACTIVITY);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            "test.FooActivity.Builder does not implement AndroidInjector<test.BarActivity>")
+        .inFile(module)
+        .onLine(LINES_BEFORE_METHOD + 3);
+  }
+
+  @Test
+  public void mismatchedMapKey_bindsBuilder_androidInjectionKey() {
+    JavaFileObject module =
+        moduleWithMethod(
+            "@Binds",
+            "@IntoMap",
+            "@AndroidInjectionKey(\"test.BarActivity\")",
+            "abstract AndroidInjector.Factory<? extends Activity> mismatchedBuilder(",
+            "    FooActivity.Builder builder);");
+    Compilation compilation = compile(module, FOO_ACTIVITY, BAR_ACTIVITY);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            "test.FooActivity.Builder does not implement AndroidInjector<test.BarActivity>")
+        .inFile(module)
+        .onLine(LINES_BEFORE_METHOD + 3);
+  }
+
+  @Test
+  public void mismatchedMapKey_providesBuilder() {
+    JavaFileObject module =
+        moduleWithMethod(
+            "@Provides",
+            "@IntoMap",
+            "@ActivityKey(BarActivity.class)",
+            "static AndroidInjector.Factory<? extends Activity> mismatchedBuilder(",
+            "    FooActivity.Builder builder) {",
+            "  return builder;",
+            "}");
+    Compilation compilation = compile(module, FOO_ACTIVITY, BAR_ACTIVITY);
+    assertThat(compilation).succeededWithoutWarnings();
+  }
+
+  @Test
+  public void bindsQualifier_ignoresChecks() {
+    JavaFileObject module =
+        moduleWithMethod(
+            "@Binds",
+            "@IntoMap",
+            "@ActivityKey(FooActivity.class)",
+            "@Named(\"unused\")",
+            // normally this should fail, since it is binding to a Builder not a Factory
+            "abstract AndroidInjector.Builder<?> bindsBuilderWithQualifier(",
+            "    FooActivity.Builder builder);");
+    Compilation compilation = compile(module, FOO_ACTIVITY);
+    assertThat(compilation).succeededWithoutWarnings();
+  }
+
+  @Test
+  public void bindToPrimitive() {
+    JavaFileObject module =
+        moduleWithMethod(
+            "@Binds",
+            "@IntoMap",
+            "@ActivityKey(FooActivity.class)",
+            "abstract int bindInt(@Named(\"unused\") int otherInt);");
+    Compilation compilation = compile(module, FOO_ACTIVITY);
+    assertThat(compilation).succeededWithoutWarnings();
+  }
+
+  @Test
+  public void bindToNonFrameworkClass() {
+    JavaFileObject module =
+        moduleWithMethod(
+            "@Binds",
+            "@IntoMap",
+            "@ActivityKey(FooActivity.class)",
+            "abstract Number bindInt(Integer integer);");
+    Compilation compilation = compile(module, FOO_ACTIVITY);
+    assertThat(compilation).succeededWithoutWarnings();
+  }
+
+  @Test
+  public void invalidBindsMethod() {
+    JavaFileObject module =
+        moduleWithMethod(
+            "@Binds",
+            "@IntoMap",
+            "@ActivityKey(FooActivity.class)",
+            "abstract AndroidInjector.Factory<?> bindCorrectType(",
+            "    FooActivity.Builder builder, FooActivity.Builder builder2);");
+    Compilation compilation = compile(module, FOO_ACTIVITY);
+    assertThat(compilation).failed();
+  }
+
+  private Compilation compile(JavaFileObject... files) {
+    return javac().withProcessors(new ComponentProcessor(), new AndroidProcessor()).compile(files);
+  }
+}
diff --git a/javatests/dagger/android/processor/AndroidProcessorTest.java b/javatests/dagger/android/processor/AndroidProcessorTest.java
new file mode 100644
index 000000000..1a45bdd05
--- /dev/null
+++ b/javatests/dagger/android/processor/AndroidProcessorTest.java
@@ -0,0 +1,81 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.processor;
+
+import static com.google.common.truth.Truth8.assertThat;
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static com.google.testing.compile.Compiler.javac;
+import static javax.tools.StandardLocation.CLASS_OUTPUT;
+
+import com.google.testing.compile.Compilation;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public final class AndroidProcessorTest {
+  @Test
+  public void generatedProguardFile() {
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.android.AndroidInjectionKey;",
+            "import dagger.Module;",
+            "import dagger.multibindings.IntoMap;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "class TestModule {",
+            "  @Provides",
+            "  @IntoMap",
+            "  @AndroidInjectionKey(\"test.TestActivity\")",
+            "  static int i() { ",
+            "    return 1;",
+            "  }",
+            "}");
+    Compilation enabled =
+        javac()
+            .withProcessors(new AndroidProcessor())
+            .withOptions("-Adagger.android.experimentalUseStringKeys=true")
+            .compile(module);
+    assertThat(enabled).succeeded();
+    assertThat(enabled)
+        .generatedFile(CLASS_OUTPUT, "META-INF/proguard/dagger.android.AndroidInjectionKeys");
+
+    Compilation disabled =
+        javac()
+            .withProcessors(new AndroidProcessor())
+            .withOptions("-Adagger.android.experimentalUseStringKeys=false")
+            .compile(module);
+    assertThat(disabled).succeeded();
+    assertThat(
+            disabled.generatedFile(
+                CLASS_OUTPUT, "META-INF/proguard/dagger.android.AndroidInjectionKeys"))
+        .isEmpty();
+
+    Compilation noFlag = javac().withProcessors(new AndroidProcessor()).compile(module);
+    assertThat(noFlag).succeeded();
+    assertThat(
+            noFlag.generatedFile(
+                CLASS_OUTPUT, "META-INF/proguard/dagger.android.AndroidInjectionKeys"))
+        .isEmpty();
+  }
+}
diff --git a/javatests/dagger/android/processor/BUILD b/javatests/dagger/android/processor/BUILD
new file mode 100644
index 000000000..8a9c16e67
--- /dev/null
+++ b/javatests/dagger/android/processor/BUILD
@@ -0,0 +1,42 @@
+# Copyright (C) 2017 The Dagger Authors.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+# Description:
+#   Tests for Dagger's Android integrations
+
+package(default_visibility = ["//:src"])
+
+load("//:build_defs.bzl", "DOCLINT_HTML_AND_SYNTAX")
+load("//:test_defs.bzl", "GenJavaTests")
+
+GenJavaTests(
+    name = "android_processor_tests",
+    srcs = glob(["*.java"]),
+    functional = False,
+    javacopts = DOCLINT_HTML_AND_SYNTAX,
+    deps = [
+        "@google_bazel_common//third_party/java/guava",
+        "@androidsdk//com.android.support:support-fragment-25.0.0",
+        # TODO(ronshapiro): create a common location to define the current Android version
+        "@androidsdk//:platforms/android-26/android.jar",
+        "@google_bazel_common//third_party/java/compile_testing",
+        "//:dagger_with_compiler",
+        "@google_bazel_common//third_party/java/junit",
+        "@google_bazel_common//third_party/java/truth",
+        "@google_bazel_common//third_party/java/truth:truth8",
+        "//java/dagger/android",
+        "//java/dagger/android/processor",
+        "//java/dagger/internal/codegen:processor",
+    ],
+)
diff --git a/javatests/dagger/android/processor/ContributesAndroidInjectorTest.java b/javatests/dagger/android/processor/ContributesAndroidInjectorTest.java
new file mode 100644
index 000000000..7ac0d53ac
--- /dev/null
+++ b/javatests/dagger/android/processor/ContributesAndroidInjectorTest.java
@@ -0,0 +1,238 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.processor;
+
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static com.google.testing.compile.Compiler.javac;
+
+import com.google.testing.compile.Compilation;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public final class ContributesAndroidInjectorTest {
+  private static final JavaFileObject TEST_ACTIVITY =
+      JavaFileObjects.forSourceLines(
+          "test.TestActivity",
+          "package test;",
+          "",
+          "import android.app.Activity;",
+          "",
+          "class TestActivity extends Activity {}");
+
+  @Test
+  public void notAbstract() {
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.android.ContributesAndroidInjector;",
+            "",
+            "@Module",
+            "abstract class TestModule {",
+            "  @ContributesAndroidInjector",
+            "  static TestActivity test() {",
+            "    return null;",
+            "  }",
+            "}");
+
+    Compilation compilation = compile(module, TEST_ACTIVITY);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("must be abstract")
+        .inFile(module)
+        .onLineContaining("test()");
+  }
+
+  @Test
+  public void hasParameters() {
+    JavaFileObject otherActivity =
+        JavaFileObjects.forSourceLines(
+            "test.OtherActivity",
+            "package test;",
+            "",
+            "import android.app.Activity;",
+            "",
+            "class OtherActivity extends Activity {}");
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.android.ContributesAndroidInjector;",
+            "",
+            "@Module",
+            "abstract class TestModule {",
+            "  @ContributesAndroidInjector",
+            "  abstract TestActivity oneParam(TestActivity one);",
+            "",
+            "  @ContributesAndroidInjector",
+            "  abstract OtherActivity manyParams(OtherActivity two, Object o);",
+            "}");
+
+    Compilation compilation = compile(module, TEST_ACTIVITY, otherActivity);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("cannot have parameters")
+        .inFile(module)
+        .onLineContaining("oneParam(");
+    assertThat(compilation)
+        .hadErrorContaining("cannot have parameters")
+        .inFile(module)
+        .onLineContaining("manyParams(");
+  }
+
+  @Test
+  public void notInAModule() {
+    JavaFileObject randomFile =
+        JavaFileObjects.forSourceLines(
+            "test.RandomFile",
+            "package test;",
+            "",
+            "import dagger.android.ContributesAndroidInjector;",
+            "",
+            "abstract class RandomFile {",
+            "  @ContributesAndroidInjector",
+            "  abstract TestActivity test() {}",
+            "}");
+
+    Compilation compilation = compile(randomFile, TEST_ACTIVITY);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("must be in a @Module")
+        .inFile(randomFile)
+        .onLineContaining("test()");
+  }
+
+  @Test
+  public void parameterizedReturnType() {
+    JavaFileObject parameterizedActivity =
+        JavaFileObjects.forSourceLines(
+            "test.ParameterizedActivity",
+            "package test;",
+            "",
+            "import android.app.Activity;",
+            "",
+            "class ParameterizedActivity<T> extends Activity {}");
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.android.ContributesAndroidInjector;",
+            "",
+            "@Module",
+            "abstract class TestModule {",
+            "  @ContributesAndroidInjector",
+            "  abstract <T> ParameterizedActivity<T> test();",
+            "}");
+
+    Compilation compilation = compile(module, TEST_ACTIVITY, parameterizedActivity);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("cannot return parameterized types")
+        .inFile(module)
+        .onLineContaining("test()");
+  }
+
+  @Test
+  public void notAFrameworkType() {
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.android.ContributesAndroidInjector;",
+            "",
+            "@Module",
+            "abstract class TestModule {",
+            "  @ContributesAndroidInjector",
+            "  abstract android.content.Intent intent();",
+            "}");
+
+    Compilation compilation = compile(module);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("is not a framework type")
+        .inFile(module)
+        .onLineContaining("intent()");
+  }
+
+  @Test
+  public void moduleIsntModule() {
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.android.ContributesAndroidInjector;",
+            "",
+            "@Module",
+            "abstract class TestModule {",
+            "  @ContributesAndroidInjector(modules = android.content.Intent.class)",
+            "  abstract TestActivity test();",
+            "}");
+
+    Compilation compilation = compile(module, TEST_ACTIVITY);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("Intent is not a @Module")
+        .inFile(module)
+        .onLineContaining("modules = android.content.Intent.class");
+  }
+
+  @Test
+  public void hasQualifier() {
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.android.ContributesAndroidInjector;",
+            "import javax.inject.Qualifier;",
+            "",
+            "@Module",
+            "abstract class TestModule {",
+            "  @Qualifier @interface AndroidQualifier {}",
+            "",
+            "  @AndroidQualifier",
+            "  @ContributesAndroidInjector",
+            "  abstract TestActivity test();",
+            "}");
+
+    Compilation compilation = compile(module, TEST_ACTIVITY);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("@ContributesAndroidInjector methods cannot have qualifiers")
+        .inFile(module)
+        .onLineContaining("@AndroidQualifier");
+  }
+
+  private static Compilation compile(JavaFileObject... javaFileObjects) {
+    return javac().withProcessors(new AndroidProcessor()).compile(javaFileObjects);
+  }
+}
diff --git a/javatests/dagger/android/processor/DuplicateAndroidInjectorsCheckerTest.java b/javatests/dagger/android/processor/DuplicateAndroidInjectorsCheckerTest.java
new file mode 100644
index 000000000..8cd1979ee
--- /dev/null
+++ b/javatests/dagger/android/processor/DuplicateAndroidInjectorsCheckerTest.java
@@ -0,0 +1,106 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.processor;
+
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static com.google.testing.compile.Compiler.javac;
+
+import com.google.testing.compile.Compilation;
+import com.google.testing.compile.JavaFileObjects;
+import dagger.internal.codegen.ComponentProcessor;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public final class DuplicateAndroidInjectorsCheckerTest {
+  @Test
+  public void conflictingMapKeys() {
+    JavaFileObject activity =
+        JavaFileObjects.forSourceLines(
+            "test.TestActivity",
+            "package test;",
+            "",
+            "import android.app.Activity;",
+            "",
+            "public class TestActivity extends Activity {}");
+    JavaFileObject injectorFactory =
+        JavaFileObjects.forSourceLines(
+            "test.TestInjectorFactory",
+            "package test;",
+            "",
+            "import dagger.android.AndroidInjector;",
+            "import javax.inject.Inject;",
+            "",
+            "class TestInjectorFactory implements AndroidInjector.Factory<TestActivity> {",
+            "  @Inject TestInjectorFactory() {}",
+            "",
+            "  @Override",
+            "  public AndroidInjector<TestActivity> create(TestActivity instance) { return null; }",
+            "}");
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import android.app.Activity;",
+            "import dagger.Binds;",
+            "import dagger.Module;",
+            "import dagger.android.*;",
+            "import dagger.multibindings.*;",
+            "",
+            "@Module",
+            "interface TestModule {",
+            "  @Binds",
+            "  @IntoMap",
+            "  @ActivityKey(TestActivity.class)",
+            "  AndroidInjector.Factory<? extends Activity> classKey(TestInjectorFactory factory);",
+            "",
+            "  @Binds",
+            "  @IntoMap",
+            "  @AndroidInjectionKey(\"test.TestActivity\")",
+            "  AndroidInjector.Factory<? extends Activity> stringKey(TestInjectorFactory factory);",
+            "}");
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import android.app.Activity;",
+            "import dagger.Component;",
+            "import dagger.android.DispatchingAndroidInjector;",
+            "",
+            "@Component(modules = TestModule.class)",
+            "interface TestComponent {",
+            "  DispatchingAndroidInjector<Activity> dispatchingInjector();",
+            "}");
+
+    Compilation compilation =
+        javac()
+            .withProcessors(ComponentProcessor.forTesting(new DuplicateAndroidInjectorsChecker()))
+            .compile(activity, injectorFactory, module, component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("Multiple injector factories bound for the same type")
+        .inFile(component)
+        .onLineContaining("interface TestComponent");
+    assertThat(compilation).hadErrorContaining("classKey(test.TestInjectorFactory)");
+    assertThat(compilation).hadErrorContaining("stringKey(test.TestInjectorFactory)");
+    assertThat(compilation).hadErrorCount(1);
+  }
+}
diff --git a/javatests/dagger/android/support/AndroidSupportInjectionTest.java b/javatests/dagger/android/support/AndroidSupportInjectionTest.java
index 243bc38de..51e9992b7 100644
--- a/javatests/dagger/android/support/AndroidSupportInjectionTest.java
+++ b/javatests/dagger/android/support/AndroidSupportInjectionTest.java
@@ -21,10 +21,10 @@
 
 import android.app.Application;
 import android.support.v4.app.Fragment;
-import org.robolectric.RobolectricTestRunner;
 import dagger.android.AndroidInjector;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 import org.robolectric.shadows.support.v4.SupportFragmentTestUtil;
 
diff --git a/javatests/dagger/android/support/BUILD b/javatests/dagger/android/support/BUILD
index 1d1ed68e3..9b87d849b 100644
--- a/javatests/dagger/android/support/BUILD
+++ b/javatests/dagger/android/support/BUILD
@@ -28,10 +28,10 @@ GenRobolectricTests(
         "//:dagger_with_compiler",
         "//java/dagger/android",
         "//java/dagger/android/support",
-        "//third_party:guava",
-        "//third_party:junit",
-        "//third_party:truth",
         "@androidsdk//com.android.support:appcompat-v7-25.0.0",
         "@androidsdk//com.android.support:support-fragment-25.0.0",
+        "@google_bazel_common//third_party/java/guava",
+        "@google_bazel_common//third_party/java/junit",
+        "@google_bazel_common//third_party/java/truth",
     ],
 )
diff --git a/javatests/dagger/android/support/functional/AllControllersAreDirectChildrenOfApplication.java b/javatests/dagger/android/support/functional/AllControllersAreDirectChildrenOfApplication.java
index 271bafc94..1382af1ed 100644
--- a/javatests/dagger/android/support/functional/AllControllersAreDirectChildrenOfApplication.java
+++ b/javatests/dagger/android/support/functional/AllControllersAreDirectChildrenOfApplication.java
@@ -36,6 +36,7 @@
 import dagger.android.support.FragmentKey;
 import dagger.android.support.functional.AllControllersAreDirectChildrenOfApplication.ApplicationComponent.BroadcastReceiverSubcomponent.BroadcastReceiverModule;
 import dagger.android.support.functional.AllControllersAreDirectChildrenOfApplication.ApplicationComponent.ContentProviderSubcomponent.ContentProviderModule;
+import dagger.android.support.functional.AllControllersAreDirectChildrenOfApplication.ApplicationComponent.InnerActivitySubcomponent.InnerActivityModule;
 import dagger.android.support.functional.AllControllersAreDirectChildrenOfApplication.ApplicationComponent.IntentServiceSubcomponent.IntentServiceModule;
 import dagger.android.support.functional.AllControllersAreDirectChildrenOfApplication.ApplicationComponent.ServiceSubcomponent.ServiceModule;
 import dagger.multibindings.IntoMap;
@@ -56,6 +57,7 @@
     @Module(
       subcomponents = {
         ActivitySubcomponent.class,
+        InnerActivitySubcomponent.class,
         ParentFragmentSubcomponent.class,
         ChildFragmentSubcomponent.class,
         DialogFragmentSubcomponent.class,
@@ -78,6 +80,12 @@
       abstract AndroidInjector.Factory<? extends Activity> bindFactoryForTestActivity(
           ActivitySubcomponent.Builder builder);
 
+      @Binds
+      @IntoMap
+      @ActivityKey(OuterClass.TestInnerClassActivity.class)
+      abstract AndroidInjector.Factory<? extends Activity> bindFactoryForInnerActivity(
+          InnerActivitySubcomponent.Builder builder);
+
       @Binds
       @IntoMap
       @FragmentKey(TestParentFragment.class)
@@ -136,6 +144,21 @@
       abstract class Builder extends AndroidInjector.Builder<TestActivity> {}
     }
 
+    @Subcomponent(modules = InnerActivityModule.class)
+    interface InnerActivitySubcomponent extends AndroidInjector<OuterClass.TestInnerClassActivity> {
+      @Subcomponent.Builder
+      abstract class Builder extends AndroidInjector.Builder<OuterClass.TestInnerClassActivity> {}
+
+      @Module
+      abstract class InnerActivityModule {
+        @Provides
+        @IntoSet
+        static Class<?> addToComponentHierarchy() {
+          return InnerActivitySubcomponent.class;
+        }
+      }
+    }
+
     @Subcomponent(modules = ParentFragmentSubcomponent.ParentFragmentModule.class)
     interface ParentFragmentSubcomponent extends AndroidInjector<TestParentFragment> {
       @Module
diff --git a/javatests/dagger/android/support/functional/AndroidManifest.xml b/javatests/dagger/android/support/functional/AndroidManifest.xml
index 1ace8cb8f..c89d30667 100644
--- a/javatests/dagger/android/support/functional/AndroidManifest.xml
+++ b/javatests/dagger/android/support/functional/AndroidManifest.xml
@@ -16,7 +16,8 @@
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
   package="dagger.android.support.functional">
 
-  <application android:theme="@style/Theme.AppCompat">
+  <application android:theme="@style/Theme.AppCompat"
+      android:name=".UsesGeneratedModulesApplication">
     <activity android:name="dagger.android.support.functional.ParentOfFragmentActivity"/>
     <activity android:name="dagger.android.support.functional.SiblingOfFragmentActivity"/>
     <activity android:name="dagger.android.support.functional.InjectedWithoutSubcomponentActivity"/>
diff --git a/javatests/dagger/android/support/functional/BUILD b/javatests/dagger/android/support/functional/BUILD
index ee7c47587..8f899178f 100644
--- a/javatests/dagger/android/support/functional/BUILD
+++ b/javatests/dagger/android/support/functional/BUILD
@@ -23,15 +23,16 @@ android_library(
         ["*.java"],
         exclude = ["*Test.java"],
     ),
+    exports_manifest = 1,
     manifest = "AndroidManifest.xml",
     resource_files = glob(["res/**"]),
     deps = [
         "//:android",
         "//:android-support",
         "//:dagger_with_compiler",
-        "//third_party:guava",
         "@androidsdk//com.android.support:appcompat-v7-25.0.0",
         "@androidsdk//com.android.support:support-fragment-25.0.0",
+        "@google_bazel_common//third_party/java/guava",
     ],
 )
 
@@ -45,8 +46,8 @@ GenRobolectricTests(
         "//:android",
         "//:android-support",
         "//:dagger_with_compiler",
-        "//third_party:junit",
-        "//third_party:truth",
         "@androidsdk//com.android.support:support-fragment-25.0.0",
+        "@google_bazel_common//third_party/java/junit",
+        "@google_bazel_common//third_party/java/truth",
     ],
 )
diff --git a/javatests/dagger/android/support/functional/ComponentStructureFollowsControllerStructureApplication.java b/javatests/dagger/android/support/functional/ComponentStructureFollowsControllerStructureApplication.java
index 9490f48e5..379c795f0 100644
--- a/javatests/dagger/android/support/functional/ComponentStructureFollowsControllerStructureApplication.java
+++ b/javatests/dagger/android/support/functional/ComponentStructureFollowsControllerStructureApplication.java
@@ -36,6 +36,7 @@
 import dagger.android.support.FragmentKey;
 import dagger.android.support.functional.ComponentStructureFollowsControllerStructureApplication.ApplicationComponent.BroadcastReceiverSubcomponent.BroadcastReceiverModule;
 import dagger.android.support.functional.ComponentStructureFollowsControllerStructureApplication.ApplicationComponent.ContentProviderSubcomponent.ContentProviderModule;
+import dagger.android.support.functional.ComponentStructureFollowsControllerStructureApplication.ApplicationComponent.InnerActivitySubcomponent.InnerActivityModule;
 import dagger.android.support.functional.ComponentStructureFollowsControllerStructureApplication.ApplicationComponent.IntentServiceSubcomponent.IntentServiceModule;
 import dagger.android.support.functional.ComponentStructureFollowsControllerStructureApplication.ApplicationComponent.ServiceSubcomponent.ServiceModule;
 import dagger.multibindings.IntoMap;
@@ -58,6 +59,7 @@
     @Module(
       subcomponents = {
         ActivitySubcomponent.class,
+        InnerActivitySubcomponent.class,
         ServiceSubcomponent.class,
         IntentServiceSubcomponent.class,
         BroadcastReceiverSubcomponent.class,
@@ -77,6 +79,12 @@
       abstract AndroidInjector.Factory<? extends Activity> bindFactoryForTestActivity(
           ActivitySubcomponent.Builder builder);
 
+      @Binds
+      @IntoMap
+      @ActivityKey(OuterClass.TestInnerClassActivity.class)
+      abstract AndroidInjector.Factory<? extends Activity> bindFactoryForInnerActivity(
+          InnerActivitySubcomponent.Builder builder);
+
       @Binds
       @IntoMap
       @ServiceKey(TestService.class)
@@ -180,6 +188,21 @@
       }
     }
 
+    @Subcomponent(modules = InnerActivityModule.class)
+    interface InnerActivitySubcomponent extends AndroidInjector<OuterClass.TestInnerClassActivity> {
+      @Subcomponent.Builder
+      abstract class Builder extends AndroidInjector.Builder<OuterClass.TestInnerClassActivity> {}
+
+      @Module
+      abstract class InnerActivityModule {
+        @Provides
+        @IntoSet
+        static Class<?> addToComponentHierarchy() {
+          return InnerActivitySubcomponent.class;
+        }
+      }
+    }
+
     @Subcomponent(modules = ServiceModule.class)
     interface ServiceSubcomponent extends AndroidInjector<TestService> {
       @Subcomponent.Builder
diff --git a/javatests/dagger/android/support/functional/InjectorsTest.java b/javatests/dagger/android/support/functional/InjectorsTest.java
index 7303e2b1c..e66d70261 100644
--- a/javatests/dagger/android/support/functional/InjectorsTest.java
+++ b/javatests/dagger/android/support/functional/InjectorsTest.java
@@ -20,21 +20,17 @@
 
 import android.content.Intent;
 import android.content.res.Configuration;
-import org.robolectric.RobolectricTestRunner;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
+import org.robolectric.RobolectricTestRunner;
 import org.robolectric.RuntimeEnvironment;
 import org.robolectric.android.controller.ActivityController;
 import org.robolectric.annotation.Config;
 
 @RunWith(RobolectricTestRunner.class)
 public class InjectorsTest {
-  private static final String MANIFEST =
-      "//javatests/dagger/android/support/functional"
-          + ":functional/AndroidManifest.xml";
-
   private ActivityController<TestActivity> activityController;
   private TestActivity activity;
   private TestParentFragment parentFragment;
@@ -69,10 +65,7 @@ public void setUp() {
   }
 
   @Test
-  @Config(
-    manifest = MANIFEST,
-    application = ComponentStructureFollowsControllerStructureApplication.class
-  )
+  @Config(application = ComponentStructureFollowsControllerStructureApplication.class)
   public void componentStructureFollowsControllerStructure() {
     assertThat(activity.componentHierarchy)
         .containsExactly(
@@ -127,10 +120,18 @@ public void componentStructureFollowsControllerStructure() {
                 .ContentProviderSubcomponent.class);
 
     changeConfiguration();
+
+    OuterClass.TestInnerClassActivity innerClassActivity =
+        Robolectric.setupActivity(OuterClass.TestInnerClassActivity.class);
+    assertThat(innerClassActivity.componentHierarchy)
+        .containsExactly(
+            ComponentStructureFollowsControllerStructureApplication.ApplicationComponent.class,
+            ComponentStructureFollowsControllerStructureApplication.ApplicationComponent
+                .InnerActivitySubcomponent.class);
   }
 
   @Test
-  @Config(manifest = MANIFEST, application = AllControllersAreDirectChildrenOfApplication.class)
+  @Config(application = AllControllersAreDirectChildrenOfApplication.class)
   public void allControllersAreDirectChildrenOfApplication() {
     assertThat(activity.componentHierarchy)
         .containsExactly(
@@ -177,10 +178,18 @@ public void allControllersAreDirectChildrenOfApplication() {
                 .ContentProviderSubcomponent.class);
 
     changeConfiguration();
+
+    OuterClass.TestInnerClassActivity innerClassActivity =
+        Robolectric.setupActivity(OuterClass.TestInnerClassActivity.class);
+    assertThat(innerClassActivity.componentHierarchy)
+        .containsExactly(
+            AllControllersAreDirectChildrenOfApplication.ApplicationComponent.class,
+            AllControllersAreDirectChildrenOfApplication.ApplicationComponent
+                .InnerActivitySubcomponent.class);
   }
 
   @Test
-  @Config(manifest = MANIFEST, application = UsesGeneratedModulesApplication.class)
+  @Config(application = UsesGeneratedModulesApplication.class)
   public void usesGeneratedModules() {
     assertThat(activity.componentHierarchy)
         .containsExactly(
@@ -224,6 +233,13 @@ public void usesGeneratedModules() {
         Robolectric.setupActivity(TestActivityWithScope.class);
     assertThat(activityWithScope.scopedStringProvider.get())
         .isSameAs(activityWithScope.scopedStringProvider.get());
+
+    OuterClass.TestInnerClassActivity innerClassActivity =
+        Robolectric.setupActivity(OuterClass.TestInnerClassActivity.class);
+    assertThat(innerClassActivity.componentHierarchy)
+        .containsExactly(
+            UsesGeneratedModulesApplication.ApplicationComponent.class,
+            UsesGeneratedModulesApplication.DummyInnerActivitySubcomponent.class);
   }
 
   // https://github.com/google/dagger/issues/598
diff --git a/tools/testdata/Foo.java b/javatests/dagger/android/support/functional/OuterClass.java
similarity index 61%
rename from tools/testdata/Foo.java
rename to javatests/dagger/android/support/functional/OuterClass.java
index f2305c83a..e5d6ed595 100644
--- a/tools/testdata/Foo.java
+++ b/javatests/dagger/android/support/functional/OuterClass.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2017 The Dagger Authors.
+ * Copyright (C) 2018 The Dagger Authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,9 +14,15 @@
  * limitations under the License.
  */
 
-package foo;
+package dagger.android.support.functional;
 
-import com.google.auto.service.AutoService;
+import dagger.android.support.DaggerAppCompatActivity;
+import java.util.Set;
+import javax.inject.Inject;
 
-@AutoService(Object.class)
-class Foo {}
+final class OuterClass {
+  public static class TestInnerClassActivity extends DaggerAppCompatActivity {
+    @Inject
+    Set<Class<?>> componentHierarchy;
+  }
+}
diff --git a/javatests/dagger/android/support/functional/UsesGeneratedModulesApplication.java b/javatests/dagger/android/support/functional/UsesGeneratedModulesApplication.java
index 661426244..cf340e319 100644
--- a/javatests/dagger/android/support/functional/UsesGeneratedModulesApplication.java
+++ b/javatests/dagger/android/support/functional/UsesGeneratedModulesApplication.java
@@ -55,6 +55,9 @@
     @ContributesAndroidInjector(modules = DummyActivitySubcomponent.AddToHierarchy.class)
     abstract TestActivity contributeTestActivityInjector();
 
+    @ContributesAndroidInjector(modules = DummyInnerActivitySubcomponent.AddToHierarchy.class)
+    abstract OuterClass.TestInnerClassActivity contributeInnerActivityInjector();
+
     @ContributesAndroidInjector(modules = DummyParentFragmentSubcomponent.AddToHierarchy.class)
     abstract TestParentFragment contributeTestParentFragmentInjector();
 
@@ -101,6 +104,17 @@ static String provideScopedString() {
     }
   }
 
+  interface DummyInnerActivitySubcomponent {
+    @Module
+    abstract class AddToHierarchy {
+      @Provides
+      @IntoSet
+      static Class<?> addDummyValueToComponentHierarchy() {
+        return DummyInnerActivitySubcomponent.class;
+      }
+    }
+  }
+
   interface DummyParentFragmentSubcomponent {
     @Module
     abstract class AddToHierarchy {
diff --git a/javatests/dagger/functional/BUILD b/javatests/dagger/functional/BUILD
index eac8ac1d6..bf6e066cb 100644
--- a/javatests/dagger/functional/BUILD
+++ b/javatests/dagger/functional/BUILD
@@ -37,15 +37,15 @@ GenJavaTests(
     # NOTE: This should not depend on Guava or jsr305 to ensure that Dagger can be
     # used without Guava and jsr305 deps.
     test_only_deps = [
-        "//third_party:guava_testlib",
-        "//third_party:guava",
-        "//third_party:truth",
-        "//third_party:junit",
+        "@google_bazel_common//third_party/java/guava:testlib",
+        "@google_bazel_common//third_party/java/guava",
+        "@google_bazel_common//third_party/java/truth",
+        "@google_bazel_common//third_party/java/junit",
     ],
     deps = [
         "//:dagger_with_compiler",
-        "//third_party:auto_factory",
-        "//third_party:auto_value",
-        "//third_party:jsr330_inject",
+        "@google_bazel_common//third_party/java/auto:factory",
+        "@google_bazel_common//third_party/java/auto:value",
+        "@google_bazel_common//third_party/java/jsr330_inject",
     ],
 )
diff --git a/javatests/dagger/functional/BasicTest.java b/javatests/dagger/functional/BasicTest.java
index 26f277e43..39dee307d 100644
--- a/javatests/dagger/functional/BasicTest.java
+++ b/javatests/dagger/functional/BasicTest.java
@@ -56,8 +56,8 @@
     assertThat(basicComponent.getInt()).isEqualTo(BOUND_INT);
     assertThat(basicComponent.getLong()).isEqualTo(BOUND_LONG);
     assertThat(basicComponent.getBoolean()).isEqualTo(BOUND_BOOLEAN);
-    assertThat(basicComponent.getFloat()).isWithin(0).of(BOUND_FLOAT);
-    assertThat(basicComponent.getDouble()).isWithin(0).of(BOUND_DOUBLE);
+    assertThat(basicComponent.getFloat()).isEqualTo(BOUND_FLOAT);
+    assertThat(basicComponent.getDouble()).isEqualTo(BOUND_DOUBLE);
   }
 
   @Theory public void boxedPrimitives(BasicComponent basicComponent) {
@@ -67,8 +67,8 @@
     assertThat(basicComponent.getBoxedInt()).isEqualTo(new Integer(BOUND_INT));
     assertThat(basicComponent.getBoxedLong()).isEqualTo(new Long(BOUND_LONG));
     assertThat(basicComponent.getBoxedBoolean()).isEqualTo(new Boolean(BOUND_BOOLEAN));
-    assertThat(basicComponent.getBoxedFloat()).isWithin(0).of(BOUND_FLOAT);
-    assertThat(basicComponent.getBoxedDouble()).isWithin(0).of(BOUND_DOUBLE);
+    assertThat(basicComponent.getBoxedFloat()).isEqualTo(BOUND_FLOAT);
+    assertThat(basicComponent.getBoxedDouble()).isEqualTo(BOUND_DOUBLE);
   }
 
   @Theory public void boxedPrimitiveProviders(BasicComponent basicComponent) {
@@ -78,8 +78,8 @@
     assertThat(basicComponent.getIntProvider().get()).isEqualTo(new Integer(BOUND_INT));
     assertThat(basicComponent.getLongProvider().get()).isEqualTo(new Long(BOUND_LONG));
     assertThat(basicComponent.getBooleanProvider().get()).isEqualTo(new Boolean(BOUND_BOOLEAN));
-    assertThat(basicComponent.getFloatProvider().get()).isWithin(0).of(BOUND_FLOAT);
-    assertThat(basicComponent.getDoubleProvider().get()).isWithin(0).of(BOUND_DOUBLE);
+    assertThat(basicComponent.getFloatProvider().get()).isEqualTo(BOUND_FLOAT);
+    assertThat(basicComponent.getDoubleProvider().get()).isEqualTo(BOUND_DOUBLE);
   }
 
   @Theory public void primitiveArrays(BasicComponent basicComponent) {
diff --git a/javatests/dagger/functional/ComponentWithReusableBindings.java b/javatests/dagger/functional/ComponentWithReusableBindings.java
index acd9e93ff..afad0d75f 100644
--- a/javatests/dagger/functional/ComponentWithReusableBindings.java
+++ b/javatests/dagger/functional/ComponentWithReusableBindings.java
@@ -43,7 +43,7 @@
   // b/77150738
   int primitive();
 
-  // b/77150738: This is used as a regression test for Android mode with SwitchingProvider. In
+  // b/77150738: This is used as a regression test for fastInit mode's switching providers. In
   // particular, it occurs when a @Provides method returns the boxed type but the component method
   // returns the unboxed type, and the instance is requested from a SwitchingProvider.
   boolean unboxedPrimitive();
diff --git a/javatests/dagger/functional/builder/BuilderTest.java b/javatests/dagger/functional/builder/BuilderTest.java
index d5c066fd6..75b15c4b0 100644
--- a/javatests/dagger/functional/builder/BuilderTest.java
+++ b/javatests/dagger/functional/builder/BuilderTest.java
@@ -45,8 +45,8 @@
     TestComponentWithBuilderInterface component = builder.build();
     assertThat(component.s()).isEqualTo("sam");
     assertThat(component.i()).isEqualTo(1);
-    assertThat(component.d()).isWithin(0).of(4.2d);
-    assertThat(component.f()).isWithin(0).of(5.5f);
+    assertThat(component.d()).isEqualTo(4.2d);
+    assertThat(component.f()).isEqualTo(5.5f);
     assertThat(component.l()).isEqualTo(6L);
   }
 
@@ -69,8 +69,8 @@
     TestComponentWithBuilderAbstractClass component = builder.build();
     assertThat(component.s()).isEqualTo("sam");
     assertThat(component.i()).isEqualTo(1);
-    assertThat(component.d()).isWithin(0).of(4.2d);
-    assertThat(component.f()).isWithin(0).of(5.5f);
+    assertThat(component.d()).isEqualTo(4.2d);
+    assertThat(component.f()).isEqualTo(5.5f);
     assertThat(component.l()).isEqualTo(6L);
   }
 
@@ -93,8 +93,8 @@
     TestComponentWithGenericBuilderInterface component = builder.build();
     assertThat(component.s()).isEqualTo("sam");
     assertThat(component.i()).isEqualTo(1);
-    assertThat(component.d()).isWithin(0).of(4.2d);
-    assertThat(component.f()).isWithin(0).of(5.5f);
+    assertThat(component.d()).isEqualTo(4.2d);
+    assertThat(component.f()).isEqualTo(5.5f);
     assertThat(component.l()).isEqualTo(6L);
   }
 
@@ -117,8 +117,8 @@
     TestComponentWithGenericBuilderAbstractClass component = builder.build();
     assertThat(component.s()).isEqualTo("sam");
     assertThat(component.i()).isEqualTo(1);
-    assertThat(component.d()).isWithin(0).of(4.2d);
-    assertThat(component.f()).isWithin(0).of(5.5f);
+    assertThat(component.d()).isEqualTo(4.2d);
+    assertThat(component.f()).isEqualTo(5.5f);
     assertThat(component.l()).isEqualTo(6L);
   }
   
@@ -137,8 +137,8 @@
     TestChildComponentWithBuilderInterface child1 = builder1.build();
     assertThat(child1.s()).isEqualTo("sam");
     assertThat(child1.i()).isEqualTo(1);
-    assertThat(child1.d()).isWithin(0).of(4.2d);
-    assertThat(child1.f()).isWithin(0).of(5.5f);
+    assertThat(child1.d()).isEqualTo(4.2d);
+    assertThat(child1.f()).isEqualTo(5.5f);
     assertThat(child1.l()).isEqualTo(6L);
     assertThat(child1.b()).isEqualTo((byte)7);
   }
@@ -159,8 +159,8 @@
     TestChildComponentWithBuilderAbstractClass child2 = builder2.build();
     assertThat(child2.s()).isEqualTo("tara");
     assertThat(child2.i()).isEqualTo(10);
-    assertThat(child2.d()).isWithin(0).of(4.2d);
-    assertThat(child2.f()).isWithin(0).of(5.5f);
+    assertThat(child2.d()).isEqualTo(4.2d);
+    assertThat(child2.f()).isEqualTo(5.5f);
     assertThat(child2.l()).isEqualTo(6L);
     assertThat(child2.b()).isEqualTo((byte)70);
   }
diff --git a/javatests/dagger/functional/cycle/DoubleCheckCycleTest.java b/javatests/dagger/functional/cycle/DoubleCheckCycleTest.java
index 4eaf2d924..05162c2b2 100644
--- a/javatests/dagger/functional/cycle/DoubleCheckCycleTest.java
+++ b/javatests/dagger/functional/cycle/DoubleCheckCycleTest.java
@@ -17,11 +17,26 @@
 package dagger.functional.cycle;
 
 import static com.google.common.truth.Truth.assertThat;
+import static java.lang.Thread.State.BLOCKED;
+import static java.lang.Thread.State.WAITING;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
 import static org.junit.Assert.fail;
 
-import dagger.functional.cycle.DoubleCheckCycles.FailingReentrantModule;
-import dagger.functional.cycle.DoubleCheckCycles.NonReentrantModule;
-import dagger.functional.cycle.DoubleCheckCycles.ReentrantModule;
+import com.google.common.util.concurrent.SettableFuture;
+import com.google.common.util.concurrent.Uninterruptibles;
+import dagger.Component;
+import dagger.Module;
+import dagger.Provides;
+import java.lang.annotation.Retention;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.atomic.AtomicInteger;
+import javax.inject.Provider;
+import javax.inject.Qualifier;
+import javax.inject.Singleton;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
@@ -30,47 +45,195 @@
 public class DoubleCheckCycleTest {
   // TODO(b/77916397): Migrate remaining tests in DoubleCheckTest to functional tests in this class.
 
+  /** A qualifier for a reentrant scoped binding. */
+  @Retention(RUNTIME)
+  @Qualifier
+  @interface Reentrant {}
+
+  /** A module to be overridden in each test. */
+  @Module
+  static class OverrideModule {
+    @Provides
+    @Singleton
+    Object provideObject() {
+      throw new IllegalStateException("This method should be overridden in tests");
+    }
+
+    @Provides
+    @Singleton
+    @Reentrant
+    Object provideReentrantObject(@Reentrant Provider<Object> provider) {
+      throw new IllegalStateException("This method should be overridden in tests");
+    }
+  }
+
+  @Singleton
+  @Component(modules = OverrideModule.class)
+  interface TestComponent {
+    Object getObject();
+    @Reentrant Object getReentrantObject();
+  }
+
   @Test
   public void testNonReentrant() {
-    NonReentrantModule module = new NonReentrantModule();
-    DoubleCheckCycles.TestComponent component =
-        DaggerDoubleCheckCycles_TestComponent.builder().nonReentrantModule(module).build();
-
-    assertThat(module.callCount).isEqualTo(0);
-    Object first = component.getNonReentrant();
-    assertThat(module.callCount).isEqualTo(1);
-    Object second = component.getNonReentrant();
-    assertThat(module.callCount).isEqualTo(1);
+    AtomicInteger callCount = new AtomicInteger(0);
+
+    // Provides a non-reentrant binding. The provides method should only be called once.
+    DoubleCheckCycleTest.TestComponent component =
+        DaggerDoubleCheckCycleTest_TestComponent.builder()
+            .overrideModule(
+                new OverrideModule() {
+                  @Override Object provideObject() {
+                    callCount.getAndIncrement();
+                    return new Object();
+                  }
+                })
+            .build();
+
+    assertThat(callCount.get()).isEqualTo(0);
+    Object first = component.getObject();
+    assertThat(callCount.get()).isEqualTo(1);
+    Object second = component.getObject();
+    assertThat(callCount.get()).isEqualTo(1);
     assertThat(first).isSameAs(second);
   }
 
   @Test
   public void testReentrant() {
-    ReentrantModule module = new ReentrantModule();
-    DoubleCheckCycles.TestComponent component =
-        DaggerDoubleCheckCycles_TestComponent.builder().reentrantModule(module).build();
-
-    assertThat(module.callCount).isEqualTo(0);
-    Object first = component.getReentrant();
-    assertThat(module.callCount).isEqualTo(2);
-    Object second = component.getReentrant();
-    assertThat(module.callCount).isEqualTo(2);
+    AtomicInteger callCount = new AtomicInteger(0);
+
+    // Provides a reentrant binding. Even though it's scoped, the provides method is called twice.
+    // In this case, we allow it since the same instance is returned on the second call.
+    DoubleCheckCycleTest.TestComponent component =
+        DaggerDoubleCheckCycleTest_TestComponent.builder()
+            .overrideModule(
+                new OverrideModule() {
+                  @Override Object provideReentrantObject(Provider<Object> provider) {
+                    if (callCount.incrementAndGet() == 1) {
+                      return provider.get();
+                    }
+                    return new Object();
+                  }
+                })
+            .build();
+
+    assertThat(callCount.get()).isEqualTo(0);
+    Object first = component.getReentrantObject();
+    assertThat(callCount.get()).isEqualTo(2);
+    Object second = component.getReentrantObject();
+    assertThat(callCount.get()).isEqualTo(2);
     assertThat(first).isSameAs(second);
   }
 
   @Test
   public void testFailingReentrant() {
-    FailingReentrantModule module = new FailingReentrantModule();
-    DoubleCheckCycles.TestComponent component =
-        DaggerDoubleCheckCycles_TestComponent.builder().failingReentrantModule(module).build();
+    AtomicInteger callCount = new AtomicInteger(0);
+
+    // Provides a failing reentrant binding. Even though it's scoped, the provides method is called
+    // twice. In this case we throw an exception since a different instance is provided on the
+    // second call.
+    DoubleCheckCycleTest.TestComponent component =
+        DaggerDoubleCheckCycleTest_TestComponent.builder()
+            .overrideModule(
+                new OverrideModule() {
+                  @Override Object provideReentrantObject(Provider<Object> provider) {
+                    if (callCount.incrementAndGet() == 1) {
+                      provider.get();
+                      return new Object();
+                    }
+                    return new Object();
+                  }
+                })
+            .build();
 
-    assertThat(module.callCount).isEqualTo(0);
+    assertThat(callCount.get()).isEqualTo(0);
     try {
-      component.getFailingReentrant();
+      component.getReentrantObject();
       fail("Expected IllegalStateException");
     } catch (IllegalStateException e) {
       assertThat(e).hasMessageThat().contains("Scoped provider was invoked recursively");
     }
-    assertThat(module.callCount).isEqualTo(2);
+    assertThat(callCount.get()).isEqualTo(2);
+  }
+
+  @Test(timeout = 5000)
+  public void testGetFromMultipleThreads() throws Exception {
+    AtomicInteger callCount = new AtomicInteger(0);
+    AtomicInteger requestCount = new AtomicInteger(0);
+    SettableFuture<Object> future = SettableFuture.create();
+
+    // Provides a non-reentrant binding. In this case, we return a SettableFuture so that we can
+    // control when the provides method returns.
+    DoubleCheckCycleTest.TestComponent component =
+        DaggerDoubleCheckCycleTest_TestComponent.builder()
+            .overrideModule(
+                new OverrideModule() {
+                  @Override
+                  Object provideObject() {
+                    callCount.incrementAndGet();
+                    try {
+                      return Uninterruptibles.getUninterruptibly(future);
+                    } catch (ExecutionException e) {
+                      throw new RuntimeException(e);
+                    }
+                  }
+                })
+            .build();
+
+    int numThreads = 10;
+    CountDownLatch remainingTasks = new CountDownLatch(numThreads);
+    List<Thread> tasks = new ArrayList<>(numThreads);
+    List<Object> values = Collections.synchronizedList(new ArrayList<>(numThreads));
+
+    // Set up multiple threads that call component.getObject().
+    for (int i = 0; i < numThreads; i++) {
+      tasks.add(
+          new Thread(
+              () -> {
+                requestCount.incrementAndGet();
+                values.add(component.getObject());
+                remainingTasks.countDown();
+              }));
+    }
+
+    // Check initial conditions
+    assertThat(remainingTasks.getCount()).isEqualTo(10);
+    assertThat(requestCount.get()).isEqualTo(0);
+    assertThat(callCount.get()).isEqualTo(0);
+    assertThat(values).isEmpty();
+
+    // Start all threads
+    tasks.forEach(Thread::start);
+
+    // Wait for all threads to wait/block.
+    long waiting = 0;
+    while (waiting != numThreads) {
+      waiting =
+          tasks.stream()
+              .map(Thread::getState)
+              .filter(state -> state == WAITING || state == BLOCKED)
+              .count();
+    }
+
+    // Check the intermediate state conditions.
+    // * All 10 threads should have requested the binding, but none should have finished.
+    // * Only 1 thread should have reached the provides method.
+    // * None of the threads should have set a value (since they are waiting for future to be set).
+    assertThat(remainingTasks.getCount()).isEqualTo(10);
+    assertThat(requestCount.get()).isEqualTo(10);
+    assertThat(callCount.get()).isEqualTo(1);
+    assertThat(values).isEmpty();
+
+    // Set the future and wait on all remaining threads to finish.
+    Object futureValue = new Object();
+    future.set(futureValue);
+    remainingTasks.await();
+
+    // Check the final state conditions.
+    // All values should be set now, and they should all be equal to the same instance.
+    assertThat(remainingTasks.getCount()).isEqualTo(0);
+    assertThat(requestCount.get()).isEqualTo(10);
+    assertThat(callCount.get()).isEqualTo(1);
+    assertThat(values).isEqualTo(Collections.nCopies(numThreads, futureValue));
   }
 }
diff --git a/javatests/dagger/functional/cycle/DoubleCheckCycles.java b/javatests/dagger/functional/cycle/DoubleCheckCycles.java
deleted file mode 100644
index bffb9f77c..000000000
--- a/javatests/dagger/functional/cycle/DoubleCheckCycles.java
+++ /dev/null
@@ -1,117 +0,0 @@
-/*
- * Copyright (C) 2017 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.functional.cycle;
-
-import static java.lang.annotation.RetentionPolicy.RUNTIME;
-
-import dagger.Component;
-import dagger.Module;
-import dagger.Provides;
-import java.lang.annotation.Retention;
-import javax.inject.Provider;
-import javax.inject.Qualifier;
-import javax.inject.Singleton;
-
-/**
- * A functional test for scoped providers that recursively call {@link Provider#get()} during
- * construction (b/28829473).
- */
-interface DoubleCheckCycles {
-
-  /** A qualifier for a non-reentrant scoped binding. */
-  @Qualifier
-  @Retention(RUNTIME)
-  @interface NonReentrant {}
-
-  /** Provides a non-reentrant scoped binding. The provides method should only be called once. */
-  @Module
-  final class NonReentrantModule {
-    int callCount;
-
-    @Provides
-    @Singleton
-    @NonReentrant
-    Object provideNonReentrant() {
-      callCount++;
-      return new Object();
-    }
-  }
-
-  /** A qualifier for a reentrant scoped binding. */
-  @Qualifier
-  @Retention(RUNTIME)
-  @interface Reentrant {}
-
-  /**
-   * Provides a reentrant scoped binding. The provides method is actually called twice even though
-   * it's scoped, but we allow this since the same instance is returned both times.
-   */
-  @Module
-  final class ReentrantModule {
-    int callCount;
-
-    @Provides
-    @Singleton
-    @Reentrant
-    Object provideReentrant(@Reentrant Provider<Object> provider) {
-      callCount++;
-      if (callCount == 1) {
-        return provider.get();
-      }
-      return new Object();
-    }
-  }
-
-  /** A qualifier for a failing reentrant scoped binding. */
-  @Qualifier
-  @Retention(RUNTIME)
-  @interface FailingReentrant {}
-
-  /**
-   * Provides a failing reentrant scoped binding. Similar to the other reentrant module, the
-   * provides method is called twice. However, in this case we throw since a different instance is
-   * provided for each call.
-   */
-  @Module
-  final class FailingReentrantModule {
-    int callCount;
-
-    @Provides
-    @Singleton
-    @FailingReentrant
-    Object provideFailingReentrantA(@FailingReentrant Provider<Object> provider) {
-      callCount++;
-      if (callCount == 1) {
-        provider.get();
-        return new Object();
-      }
-      return new Object();
-    }
-  }
-
-  @Singleton
-  @Component(modules = {
-    NonReentrantModule.class,
-    ReentrantModule.class,
-    FailingReentrantModule.class,
-  })
-  interface TestComponent {
-    @NonReentrant Object getNonReentrant();
-    @Reentrant Object getReentrant();
-    @FailingReentrant Object getFailingReentrant();
-  }
-}
diff --git a/javatests/dagger/functional/cycle/LongCycleTest.java b/javatests/dagger/functional/cycle/LongCycleTest.java
index 37e5e90fc..02250541a 100644
--- a/javatests/dagger/functional/cycle/LongCycleTest.java
+++ b/javatests/dagger/functional/cycle/LongCycleTest.java
@@ -43,10 +43,10 @@ public void longCycle() {
    */
   @Test
   public void longCycleHasMoreThanOneInitializeMethod() throws NoSuchMethodException {
-    assume().that(System.getProperty("dagger.mode")).isNotEqualTo("ExperimentalAndroidMode");
+    assume().that(System.getProperty("dagger.mode")).isNotEqualTo("FastInit");
     assume()
         .that(System.getProperty("dagger.mode"))
-        .isNotEqualTo("ExperimentalAndroidModeAndAheadOfTimeComponents");
+        .isNotEqualTo("FastInitAndAheadOfTimeSubcomponents");
     DaggerLongCycle_LongCycleComponent.class
         .getDeclaredMethod("initialize2", DaggerLongCycle_LongCycleComponent.Builder.class);
   }
diff --git a/javatests/dagger/functional/guava/BUILD b/javatests/dagger/functional/guava/BUILD
index dd2c8921f..66492eb74 100644
--- a/javatests/dagger/functional/guava/BUILD
+++ b/javatests/dagger/functional/guava/BUILD
@@ -26,11 +26,11 @@ GenJavaTests(
     javacopts = DOCLINT_HTML_AND_SYNTAX,
     deps = [
         "//:dagger_with_compiler",
-        "//third_party:auto_value",
-        "//third_party:guava",
-        "//third_party:jsr305_annotations",
-        "//third_party:jsr330_inject",
-        "//third_party:junit",
-        "//third_party:truth",
+        "@google_bazel_common//third_party/java/auto:value",
+        "@google_bazel_common//third_party/java/guava",
+        "@google_bazel_common//third_party/java/jsr305_annotations",
+        "@google_bazel_common//third_party/java/jsr330_inject",
+        "@google_bazel_common//third_party/java/junit",
+        "@google_bazel_common//third_party/java/truth",
     ],
 )
diff --git a/javatests/dagger/functional/jdk8/BUILD b/javatests/dagger/functional/jdk8/BUILD
index 10108bec2..6b76ba3a7 100644
--- a/javatests/dagger/functional/jdk8/BUILD
+++ b/javatests/dagger/functional/jdk8/BUILD
@@ -25,13 +25,13 @@ GenJavaTests(
     srcs = glob(["**/*.java"]),
     javacopts = DOCLINT_HTML_AND_SYNTAX,
     test_only_deps = [
-        "//third_party:guava",
-        "//third_party:junit",
-        "//third_party:truth8",
+        "@google_bazel_common//third_party/java/guava",
+        "@google_bazel_common//third_party/java/junit",
+        "@google_bazel_common//third_party/java/truth:truth8",
     ],
     deps = [
         "//:dagger_with_compiler",
-        "//third_party:auto_value",
-        "//third_party:jsr305_annotations",
+        "@google_bazel_common//third_party/java/auto:value",
+        "@google_bazel_common//third_party/java/jsr305_annotations",
     ],
 )
diff --git a/javatests/dagger/functional/producers/BUILD b/javatests/dagger/functional/producers/BUILD
index cf7abf30f..2b3db633f 100644
--- a/javatests/dagger/functional/producers/BUILD
+++ b/javatests/dagger/functional/producers/BUILD
@@ -31,13 +31,13 @@ GenJavaTests(
     javacopts = SOURCE_7_TARGET_7 + DOCLINT_HTML_AND_SYNTAX + DOCLINT_REFERENCES,
     deps = [
         "//:producers_with_compiler",
-        "//third_party:auto_value",
-        "//third_party:guava",
-        "//third_party:jsr305_annotations",
-        "//third_party:jsr330_inject",
-        "//third_party:junit",
-        "//third_party:mockito",
-        "//third_party:truth",
+        "@google_bazel_common//third_party/java/auto:value",
+        "@google_bazel_common//third_party/java/guava",
+        "@google_bazel_common//third_party/java/jsr305_annotations",
+        "@google_bazel_common//third_party/java/jsr330_inject",
+        "@google_bazel_common//third_party/java/junit",
+        "@google_bazel_common//third_party/java/mockito",
+        "@google_bazel_common//third_party/java/truth",
     ],
 )
 
diff --git a/javatests/dagger/functional/producers/ProducerFactoryTest.java b/javatests/dagger/functional/producers/ProducerFactoryTest.java
index 1134ffed4..ba39b9784 100644
--- a/javatests/dagger/functional/producers/ProducerFactoryTest.java
+++ b/javatests/dagger/functional/producers/ProducerFactoryTest.java
@@ -26,6 +26,8 @@
 import com.google.common.util.concurrent.MoreExecutors;
 import com.google.common.util.concurrent.SettableFuture;
 import dagger.producers.Producer;
+import dagger.producers.internal.AbstractProducer;
+import dagger.producers.internal.CancellableProducer;
 import dagger.producers.monitoring.ProducerMonitor;
 import dagger.producers.monitoring.ProducerToken;
 import dagger.producers.monitoring.ProductionComponentMonitor;
@@ -87,7 +89,7 @@ public void noArgMethod() throws Exception {
   @Test
   public void singleArgMethod() throws Exception {
     SettableFuture<Integer> intFuture = SettableFuture.create();
-    Producer<Integer> intProducer = producerOfFuture(intFuture);
+    CancellableProducer<Integer> intProducer = producerOfFuture(intFuture);
     Producer<String> producer =
         new SimpleProducerModule_StrWithArgFactory(
             executorProvider, componentMonitorProvider, intProducer);
@@ -103,7 +105,8 @@ public void successMonitor() throws Exception {
     SettableFuture<String> strFuture = SettableFuture.create();
     @SuppressWarnings("FutureReturnValueIgnored")
     SettableFuture<SettableFuture<String>> strFutureFuture = SettableFuture.create();
-    Producer<SettableFuture<String>> strFutureProducer = producerOfFuture(strFutureFuture);
+    CancellableProducer<SettableFuture<String>> strFutureProducer =
+        producerOfFuture(strFutureFuture);
     Producer<String> producer =
         new SimpleProducerModule_SettableFutureStrFactory(
             executorProvider, componentMonitorProvider, strFutureProducer);
@@ -131,7 +134,8 @@ public void failureMonitor() throws Exception {
     SettableFuture<String> strFuture = SettableFuture.create();
     @SuppressWarnings("FutureReturnValueIgnored")
     SettableFuture<SettableFuture<String>> strFutureFuture = SettableFuture.create();
-    Producer<SettableFuture<String>> strFutureProducer = producerOfFuture(strFutureFuture);
+    CancellableProducer<SettableFuture<String>> strFutureProducer =
+        producerOfFuture(strFutureFuture);
     Producer<String> producer =
         new SimpleProducerModule_SettableFutureStrFactory(
             executorProvider, componentMonitorProvider, strFutureProducer);
@@ -188,10 +192,10 @@ public void nullComponentMonitorProvider() throws Exception {
     new SimpleProducerModule_StrFactory(executorProvider, null);
   }
 
-  private static <T> Producer<T> producerOfFuture(final ListenableFuture<T> future) {
-    return new Producer<T>() {
+  private static <T> CancellableProducer<T> producerOfFuture(final ListenableFuture<T> future) {
+    return new AbstractProducer<T>() {
       @Override
-      public ListenableFuture<T> get() {
+      public ListenableFuture<T> compute() {
         return future;
       }
     };
diff --git a/javatests/dagger/functional/producers/badexecutor/BadExecutorTest.java b/javatests/dagger/functional/producers/badexecutor/BadExecutorTest.java
index 90bbca156..e0484df54 100644
--- a/javatests/dagger/functional/producers/badexecutor/BadExecutorTest.java
+++ b/javatests/dagger/functional/producers/badexecutor/BadExecutorTest.java
@@ -86,6 +86,6 @@ public void rejectSingleArgFromComponentDepMethod() throws Exception {
 
   @Test
   public void doNotRejectComponentDepMethod() throws Exception {
-    assertThat(component.doubleDep().get()).isWithin(0).of(42.0);
+    assertThat(component.doubleDep().get()).isEqualTo(42.0);
   }
 }
diff --git a/javatests/dagger/functional/producers/builder/ProductionComponentBuilderTest.java b/javatests/dagger/functional/producers/builder/ProductionComponentBuilderTest.java
index 7b33053b8..14f153eac 100644
--- a/javatests/dagger/functional/producers/builder/ProductionComponentBuilderTest.java
+++ b/javatests/dagger/functional/producers/builder/ProductionComponentBuilderTest.java
@@ -36,7 +36,7 @@ public void successfulBuild() throws Exception {
             .strModule(new StringModule())
             .build();
     assertThat(component.s().get()).isEqualTo("arg: 42");
-    assertThat(component.d().get()).isWithin(0).of(15.3);
+    assertThat(component.d().get()).isEqualTo(15.3);
   }
 
   @Test
@@ -46,7 +46,7 @@ public void successfulBuild_withMissingZeroArgModule() throws Exception {
             .depComponent(depComponent(15.3))
             .build();
     assertThat(component.s().get()).isEqualTo("arg: 42");
-    assertThat(component.d().get()).isWithin(0).of(15.3);
+    assertThat(component.d().get()).isEqualTo(15.3);
   }
 
   @Test(expected = IllegalStateException.class)
diff --git a/javatests/dagger/functional/producers/cancellation/CancellationComponent.java b/javatests/dagger/functional/producers/cancellation/CancellationComponent.java
new file mode 100644
index 000000000..f06829e0f
--- /dev/null
+++ b/javatests/dagger/functional/producers/cancellation/CancellationComponent.java
@@ -0,0 +1,69 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.producers.cancellation;
+
+import static com.google.common.base.Preconditions.checkNotNull;
+
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.BindsInstance;
+import dagger.functional.producers.cancellation.CancellationComponent.Dependency;
+import dagger.producers.Producer;
+import dagger.producers.Production;
+import dagger.producers.ProductionComponent;
+import java.util.concurrent.Executor;
+import javax.inject.Named;
+
+@ProductionComponent(modules = CancellationModule.class, dependencies = Dependency.class)
+interface CancellationComponent {
+
+  @Named("ep1")
+  ListenableFuture<String> entryPoint1();
+
+  @Named("ep2")
+  Producer<String> entryPoint2();
+
+  @Named("ep3")
+  ListenableFuture<String> entryPoint3();
+
+  CancellationSubcomponent.Builder subcomponentBuilder();
+
+  @ProductionComponent.Builder
+  interface Builder {
+    Builder module(CancellationModule module);
+
+    Builder dependency(Dependency dependency);
+
+    @BindsInstance
+    Builder executor(@Production Executor executor);
+
+    CancellationComponent build();
+  }
+
+  final class Dependency {
+
+    final ProducerTester tester;
+
+    Dependency(ProducerTester tester) {
+      this.tester = checkNotNull(tester);
+    }
+
+    @SuppressWarnings("unused") // Dagger uses it
+    ListenableFuture<String> getDependencyFuture() {
+      return tester.start("dependencyFuture");
+    }
+  }
+}
diff --git a/javatests/dagger/functional/producers/cancellation/CancellationModule.java b/javatests/dagger/functional/producers/cancellation/CancellationModule.java
new file mode 100644
index 000000000..ff7ee791f
--- /dev/null
+++ b/javatests/dagger/functional/producers/cancellation/CancellationModule.java
@@ -0,0 +1,115 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.producers.cancellation;
+
+import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.truth.Truth.assertThat;
+
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.Provides;
+import dagger.producers.Producer;
+import dagger.producers.ProducerModule;
+import dagger.producers.Produces;
+import javax.inject.Named;
+
+@SuppressWarnings("unused") // not actually using dependencies
+@ProducerModule(subcomponents = CancellationSubcomponent.class)
+final class CancellationModule {
+
+  private final ProducerTester tester;
+
+  CancellationModule(ProducerTester tester) {
+    this.tester = checkNotNull(tester);
+  }
+
+  @Produces
+  @Named("leaf1")
+  ListenableFuture<String> produceLeaf1() {
+    return tester.start("leaf1");
+  }
+
+  @Produces
+  @Named("leaf2")
+  ListenableFuture<String> produceLeaf2() {
+    return tester.start("leaf2");
+  }
+
+  @Produces
+  @Named("leaf3")
+  ListenableFuture<String> produceLeaf3() {
+    return tester.start("leaf3");
+  }
+
+  @Produces
+  @Named("foo")
+  ListenableFuture<String> produceFoo(@Named("leaf1") String leaf1, @Named("leaf2") String leaf2) {
+    return tester.start("foo");
+  }
+
+  @Produces
+  @Named("bar")
+  ListenableFuture<String> produceBar(@Named("leaf2") String leaf2, @Named("leaf3") String leaf3) {
+    return tester.start("bar");
+  }
+
+  @Produces
+  @Named("baz")
+  ListenableFuture<String> produceBaz(
+      @Named("foo") Producer<String> foo, @Named("bar") String bar) {
+    ListenableFuture<String> fooFuture = foo.get();
+    if (!fooFuture.isDone()) {
+      assertThat(fooFuture.cancel(true)).isTrue();
+      assertThat(fooFuture.isCancelled()).isTrue();
+    }
+    return tester.start("baz");
+  }
+
+  @Provides
+  @Named("providesDep")
+  static String provideProvidesDep() {
+    return "providesDep";
+  }
+
+  @Produces
+  @Named("qux")
+  ListenableFuture<String> produceQux(
+      @Named("baz") String baz, @Named("providesDep") String providesDep) {
+    return tester.start("qux");
+  }
+
+  @Produces
+  @Named("ep1")
+  ListenableFuture<String> produceEntryPoint1(@Named("qux") String qux) {
+    return tester.start("entryPoint1");
+  }
+
+  @Produces
+  @Named("ep2")
+  ListenableFuture<String> produceEntryPoint2(@Named("bar") String bar, String dependency) {
+    return tester.start("entryPoint2");
+  }
+
+  @Produces
+  @Named("ep3")
+  static ListenableFuture<String> produceEntryPoint3(Producer<String> dependencyProducer) {
+    ListenableFuture<String> dependencyFuture = dependencyProducer.get();
+    assertThat(dependencyFuture.isDone()).isFalse();
+    assertThat(dependencyFuture.cancel(true)).isTrue();
+    assertThat(dependencyFuture.isCancelled()).isTrue();
+    return dependencyFuture;
+  }
+}
diff --git a/javatests/dagger/functional/producers/cancellation/CancellationSubcomponent.java b/javatests/dagger/functional/producers/cancellation/CancellationSubcomponent.java
new file mode 100644
index 000000000..63b1a9d68
--- /dev/null
+++ b/javatests/dagger/functional/producers/cancellation/CancellationSubcomponent.java
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.producers.cancellation;
+
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.producers.ProductionSubcomponent;
+import javax.inject.Named;
+
+@ProductionSubcomponent(modules = CancellationSubcomponentModule.class)
+interface CancellationSubcomponent {
+
+  @Named("subEntryPoint")
+  ListenableFuture<String> subcomponentEntryPoint();
+
+  @ProductionSubcomponent.Builder
+  interface Builder {
+    Builder module(CancellationSubcomponentModule module);
+
+    CancellationSubcomponent build();
+  }
+}
diff --git a/javatests/dagger/functional/producers/cancellation/CancellationSubcomponentModule.java b/javatests/dagger/functional/producers/cancellation/CancellationSubcomponentModule.java
new file mode 100644
index 000000000..9cedad462
--- /dev/null
+++ b/javatests/dagger/functional/producers/cancellation/CancellationSubcomponentModule.java
@@ -0,0 +1,66 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.producers.cancellation;
+
+import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.truth.Truth.assertThat;
+
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.producers.Producer;
+import dagger.producers.ProducerModule;
+import dagger.producers.Produces;
+import javax.inject.Named;
+
+@SuppressWarnings("unused") // not actually using dependencies
+@ProducerModule
+final class CancellationSubcomponentModule {
+
+  private final ProducerTester tester;
+
+  CancellationSubcomponentModule(ProducerTester tester) {
+    this.tester = checkNotNull(tester);
+  }
+
+  @Produces
+  @Named("subLeaf")
+  ListenableFuture<String> produceSubLeaf() {
+    return tester.start("subLeaf");
+  }
+
+  @Produces
+  @Named("subTask1")
+  ListenableFuture<String> produceSubTask1(
+      @Named("subLeaf") String subLeaf, @Named("qux") String qux) {
+    return tester.start("subTask1");
+  }
+
+  @Produces
+  @Named("subTask2")
+  ListenableFuture<String> produceSubTask2(@Named("foo") String foo, Producer<String> dependency) {
+    ListenableFuture<String> dependencyFuture = dependency.get();
+    assertThat(dependencyFuture.cancel(true)).isTrue();
+    assertThat(dependencyFuture.isCancelled()).isTrue();
+    return tester.start("subTask2");
+  }
+
+  @Produces
+  @Named("subEntryPoint")
+  ListenableFuture<String> produceSubEntryPoint(
+      @Named("subTask1") String subTask1, @Named("subTask2") String subTask2) {
+    return tester.start("subEntryPoint");
+  }
+}
diff --git a/javatests/dagger/functional/producers/cancellation/ProducerCancellationTest.java b/javatests/dagger/functional/producers/cancellation/ProducerCancellationTest.java
new file mode 100644
index 000000000..23b31d2f5
--- /dev/null
+++ b/javatests/dagger/functional/producers/cancellation/ProducerCancellationTest.java
@@ -0,0 +1,117 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.producers.cancellation;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import com.google.common.util.concurrent.ListenableFuture;
+import com.google.common.util.concurrent.MoreExecutors;
+import dagger.functional.producers.cancellation.CancellationComponent.Dependency;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/** Tests cancellation of tasks in production components. */
+@RunWith(JUnit4.class)
+public class ProducerCancellationTest {
+
+  private final ProducerTester tester = new ProducerTester();
+  private final CancellationComponent component =
+      DaggerCancellationComponent.builder()
+          .module(new CancellationModule(tester))
+          .dependency(new Dependency(tester))
+          .executor(MoreExecutors.directExecutor())
+          .build();
+
+  @Test
+  public void initialState() {
+    tester.assertNoStartedNodes();
+  }
+
+  @Test
+  public void cancellingOneEntryPoint_cancelsAllRunningNodes() {
+    ListenableFuture<String> entryPoint1 = component.entryPoint1();
+    tester.assertStarted("leaf2", "leaf3").only();
+
+    assertThat(entryPoint1.cancel(true)).isTrue();
+    assertThat(entryPoint1.isCancelled()).isTrue();
+
+    tester.assertCancelled("leaf2", "leaf3").only();
+
+    // The other entry points were also cancelled in the process, from the user's perspective.
+    assertThat(component.entryPoint2().get().isCancelled()).isTrue();
+    assertThat(component.entryPoint3().isCancelled()).isTrue();
+
+    // The underlying tasks weren't actually started, even though we just requested them above,
+    // because the node was cancelled already along with the component.
+    tester.assertNotStarted("entryPoint2", "entryPoint3");
+  }
+
+  @SuppressWarnings({"CheckReturnValue", "FutureReturnValueIgnored"})
+  @Test
+  public void cancellingNonEntryPointProducer_doesNotCancelUnderlyingTask() {
+    ListenableFuture<String> entryPoint1 = component.entryPoint1();
+    tester.assertStarted("leaf2", "leaf3").only();
+
+    tester.complete("leaf2", "leaf3");
+
+    tester.assertStarted("bar");
+
+    // foo's dependencies are complete, but it is not yet started because baz depends on
+    // Producer<foo>, so it won't be started until baz calls get() on it.
+    // baz not started yet because it needs bar to complete first.
+    tester.assertNotStarted("foo", "baz");
+
+    // Complete bar, triggering baz to run. It calls get() on the foo Producer, so that also starts
+    // once its dependency leaf1 is complete.
+    tester.complete("bar", "leaf1");
+    tester.assertStarted("baz", "foo");
+
+    // baz then cancelled the foo Producer's future, but that didn't cancel the underlying task.
+    tester.assertNotCancelled("foo");
+
+    // If we cancel the entry point, that does cancel the task.
+    entryPoint1.cancel(true);
+    tester.assertCancelled("foo");
+  }
+
+  @SuppressWarnings({"CheckReturnValue", "FutureReturnValueIgnored"})
+  @Test
+  public void cancellingProducerFromComponentDependency_cancelsUnderlyingTask() {
+    // Start leaf2/leaf3 tasks.
+    component.entryPoint1();
+    tester.assertStarted("leaf2", "leaf3").only();
+    tester.assertNotCancelled("leaf2", "leaf3");
+
+    // Nothing's requested dependencyFuture yet.
+    tester.assertNotStarted("dependencyFuture");
+
+    // entryPoint3 injects Producer of dependency future, then cancels that future. Then also
+    // returns that future as the entry point.
+    ListenableFuture<String> entryPoint = component.entryPoint3();
+
+    tester.assertStarted("dependencyFuture");
+    tester.assertCancelled("dependencyFuture");
+
+    // Even though the entry point future returned from the component is not the dependency future
+    // itself, the cancellation should have propagated out to it and cancelled it.
+    assertThat(entryPoint.isCancelled()).isTrue();
+
+    // And that cancellation should have cancelled the other tasks running in the component.
+    tester.assertCancelled("leaf2", "leaf3");
+  }
+}
diff --git a/javatests/dagger/functional/producers/cancellation/ProducerSubcomponentCancellationTest.java b/javatests/dagger/functional/producers/cancellation/ProducerSubcomponentCancellationTest.java
new file mode 100644
index 000000000..246bf9ffd
--- /dev/null
+++ b/javatests/dagger/functional/producers/cancellation/ProducerSubcomponentCancellationTest.java
@@ -0,0 +1,122 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.producers.cancellation;
+
+import static com.google.common.truth.Truth.assertThat;
+import static java.util.concurrent.TimeUnit.MILLISECONDS;
+
+import com.google.common.util.concurrent.ListenableFuture;
+import com.google.common.util.concurrent.MoreExecutors;
+import dagger.functional.producers.cancellation.CancellationComponent.Dependency;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/** Tests cancellation of tasks in production subcomponents. */
+@RunWith(JUnit4.class)
+public class ProducerSubcomponentCancellationTest {
+
+  private final ProducerTester tester = new ProducerTester();
+  private final CancellationComponent component =
+      DaggerCancellationComponent.builder()
+          .module(new CancellationModule(tester))
+          .dependency(new Dependency(tester))
+          .executor(MoreExecutors.directExecutor())
+          .build();
+  private final CancellationSubcomponent subcomponent =
+      component.subcomponentBuilder().module(new CancellationSubcomponentModule(tester)).build();
+
+  @Test
+  public void initialState() {
+    tester.assertNoStartedNodes();
+  }
+
+  @Test
+  public void cancellingSubcomponent_doesNotCancelParent() throws Exception {
+    ListenableFuture<String> subcomponentEntryPoint = subcomponent.subcomponentEntryPoint();
+
+    // Subcomponent entry point depends on all leaves from the parent component and on the single
+    // leaf in the subcomponent itself, so they should all have started.
+    tester.assertStarted("leaf1", "leaf2", "leaf3", "subLeaf").only();
+
+    assertThat(subcomponentEntryPoint.cancel(true)).isTrue();
+    assertThat(subcomponentEntryPoint.isCancelled()).isTrue();
+
+    // None of the tasks running in the parent were cancelled.
+    tester.assertNotCancelled("leaf1", "leaf2", "leaf3");
+    tester.assertCancelled("subLeaf").only();
+
+    // Finish all the parent tasks to ensure that it can still complete normally.
+    tester.complete(
+        "dependencyFuture",
+        "leaf1",
+        "leaf2",
+        "leaf3",
+        "foo",
+        "bar",
+        "baz",
+        "qux",
+        "entryPoint1",
+        "entryPoint2");
+
+    assertThat(component.entryPoint1().get(1, MILLISECONDS)).isEqualTo("completed");
+    assertThat(component.entryPoint2().get().get(1, MILLISECONDS)).isEqualTo("completed");
+  }
+
+  @Test
+  public void cancellingSubcomponent_preventsUnstartedNodesFromStarting() {
+    ListenableFuture<String> subcomponentEntryPoint = subcomponent.subcomponentEntryPoint();
+
+    tester.complete("subLeaf");
+    tester.assertNotStarted("subTask1", "subTask2");
+
+    subcomponentEntryPoint.cancel(true);
+
+    // Complete the remaining dependencies of subTask1 and subTask2.
+    tester.complete("leaf1", "leaf2", "leaf3", "foo", "bar", "baz", "qux");
+
+    // Since the subcomponent was cancelled, they are not started.
+    tester.assertNotStarted("subTask1", "subTask2");
+  }
+
+  @Test
+  public void cancellingProducerFromComponentDependency_inSubcomponent_cancelsUnderlyingTask()
+      throws Exception {
+    // Request subcomponent's entry point.
+    ListenableFuture<String> subcomponentEntryPoint = subcomponent.subcomponentEntryPoint();
+
+    // Finish all parent tasks so that the subcomponent's tasks can start.
+    tester.complete("leaf1", "leaf2", "leaf3", "foo", "bar", "baz", "qux", "subLeaf");
+
+    tester.assertStarted("subTask1", "subTask2");
+    tester.assertNotCancelled("subTask1", "subTask2");
+
+    // When subTask2 runs, it cancels the dependency future.
+    // TODO(cgdecker): Is this what we want to happen?
+    // On the one hand, there's a policy of "futures from component dependencies come from outside
+    // our control and should be cancelled unconditionally". On the other hand, the dependency is
+    // coming from the parent component, and the policy is also not to cancel things belonging to
+    // the parent unless it allows that.
+    tester.assertCancelled("dependencyFuture");
+
+    // The future it returns didn't depend directly on that future, though, so the subcomponent
+    // should be able to complete normally.
+    tester.complete("subTask1", "subTask2", "subEntryPoint");
+
+    assertThat(subcomponentEntryPoint.get(1, MILLISECONDS)).isEqualTo("completed");
+  }
+}
diff --git a/javatests/dagger/functional/producers/cancellation/ProducerTester.java b/javatests/dagger/functional/producers/cancellation/ProducerTester.java
new file mode 100644
index 000000000..61ddaef35
--- /dev/null
+++ b/javatests/dagger/functional/producers/cancellation/ProducerTester.java
@@ -0,0 +1,212 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.producers.cancellation;
+
+import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.truth.Truth.assertThat;
+
+import com.google.common.collect.ImmutableSet;
+import com.google.common.util.concurrent.AbstractFuture;
+import com.google.common.util.concurrent.ListenableFuture;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.function.Predicate;
+
+/**
+ * Helper for testing producers.
+ *
+ * <p>Maintains a set of nodes (futures mapped to names) representing the results of different
+ * producer nodes and allows those nodes to be "started" (when returned from a producer method),
+ * completed, and cancelled, as well as to be queried for their state. Additionally, provides
+ * assertions about the state of nodes.
+ */
+final class ProducerTester {
+
+  private final Map<String, TestFuture> futures = new HashMap<>();
+
+  /** Starts the given node. */
+  ListenableFuture<String> start(String node) {
+    return getOrCreate(node).start();
+  }
+
+  private TestFuture getOrCreate(String node) {
+    TestFuture result = futures.get(node);
+    if (result == null) {
+      result = new TestFuture(node);
+      futures.put(node, result);
+    }
+    return result;
+  }
+
+  /** Returns whether or not the given node has been started. */
+  boolean isStarted(String node) {
+    return futures.containsKey(node) && futures.get(node).isStarted();
+  }
+
+  /** Completes of the given nodes. */
+  void complete(String... nodes) {
+    for (String node : nodes) {
+      getOrCreate(node).complete();
+    }
+  }
+
+  /** Returns whether or not the given node has been cancelled. */
+  boolean isCancelled(String node) {
+    TestFuture future = futures.get(node);
+    return future != null && future.isCancelled();
+  }
+
+  /** Asserts that the given nodes have been started. */
+  Only assertStarted(String... nodes) {
+    return assertAboutNodes(STARTED, nodes);
+  }
+
+  /** Asserts that the given nodes have been cancelled. */
+  Only assertCancelled(String... nodes) {
+    return assertAboutNodes(CANCELLED, nodes);
+  }
+
+  /** Asserts that the given nodes have not been started. */
+  Only assertNotStarted(String... nodes) {
+    return assertAboutNodes(not(STARTED), nodes);
+  }
+
+  /** Asserts that the given nodes have not been cancelled. */
+  Only assertNotCancelled(String... nodes) {
+    return assertAboutNodes(not(CANCELLED), nodes);
+  }
+
+  /** Asserts that no nodes in this tester have been started. */
+  void assertNoStartedNodes() {
+    for (TestFuture future : futures.values()) {
+      assertThat(future.isStarted()).named("%s is started", future).isFalse();
+    }
+  }
+
+  private Only assertAboutNodes(Predicate<? super TestFuture> assertion, String... nodes) {
+    ImmutableSet.Builder<TestFuture> builder = ImmutableSet.builder();
+    for (String node : nodes) {
+      TestFuture future = getOrCreate(node);
+      assertThat(assertion.test(future)).named("%s is %s", future, assertion).isTrue();
+      builder.add(future);
+    }
+    return new Only(builder.build(), assertion);
+  }
+
+  /**
+   * Fluent class for making a previous assertion more strict by specifying that whatever was
+   * asserted should be true only for the specified nodes and not for any others.
+   */
+  final class Only {
+
+    private final ImmutableSet<TestFuture> expected;
+    private final Predicate<? super TestFuture> assertion;
+
+    Only(ImmutableSet<TestFuture> expected, Predicate<? super TestFuture> assertion) {
+      this.expected = checkNotNull(expected);
+      this.assertion = checkNotNull(assertion);
+    }
+
+    /**
+     * Asserts that the previous assertion was not true for any node other than those that were
+     * specified.
+     */
+    void only() {
+      for (TestFuture future : futures.values()) {
+        if (!expected.contains(future)) {
+          assertThat(assertion.test(future)).named("%s is %s", future, assertion).isFalse();
+        }
+      }
+    }
+  }
+
+  /**
+   * A simple future for testing that can be marked as having been started and which can be
+   * completed with a result.
+   */
+  private static final class TestFuture extends AbstractFuture<String> {
+
+    private final String name;
+    private volatile boolean started;
+
+    private TestFuture(String name) {
+      this.name = checkNotNull(name);
+    }
+
+    /** Marks this future as having been started and returns it. */
+    TestFuture start() {
+      this.started = true;
+      return this;
+    }
+
+    /** Returns whether or not this future's task was started. */
+    boolean isStarted() {
+      return started;
+    }
+
+    /** Completes this future's task by setting a value for it. */
+    public void complete() {
+      super.set("completed");
+    }
+
+    @Override
+    public String toString() {
+      return name;
+    }
+  }
+
+  private static final Predicate<TestFuture> STARTED =
+      new Predicate<TestFuture>() {
+        @Override
+        public boolean test(TestFuture future) {
+          return future.isStarted();
+        }
+
+        @Override
+        public String toString() {
+          return "started";
+        }
+      };
+
+  private static final Predicate<TestFuture> CANCELLED =
+      new Predicate<TestFuture>() {
+        @Override
+        public boolean test(TestFuture future) {
+          return future.isCancelled();
+        }
+
+        @Override
+        public String toString() {
+          return "cancelled";
+        }
+      };
+
+  /** Version of Predicates.not with a toString() that's nicer for our assertion error messages. */
+  private static <T> Predicate<T> not(final Predicate<T> predicate) {
+    return new Predicate<T>() {
+      @Override
+      public boolean test(T input) {
+        return !predicate.test(input);
+      }
+
+      @Override
+      public String toString() {
+        return "not " + predicate;
+      }
+    };
+  }
+}
diff --git a/javatests/dagger/functional/spi/BUILD b/javatests/dagger/functional/spi/BUILD
index 2ee433495..b88a841f1 100644
--- a/javatests/dagger/functional/spi/BUILD
+++ b/javatests/dagger/functional/spi/BUILD
@@ -25,9 +25,9 @@ java_plugin(
     deps = [
         "//java/dagger/model",
         "//java/dagger/spi",
-        "//third_party:auto_service",
-        "//third_party:guava",
-        "//third_party:javapoet",
+        "@google_bazel_common//third_party/java/auto:service",
+        "@google_bazel_common//third_party/java/guava",
+        "@google_bazel_common//third_party/java/javapoet",
     ],
 )
 
@@ -43,12 +43,12 @@ GenJavaTests(
         exclude = ["TestPlugin.java"],
     ),
     test_only_deps = [
-        "//third_party:truth",
-        "//third_party:junit",
+        "@google_bazel_common//third_party/java/truth",
+        "@google_bazel_common//third_party/java/junit",
     ],
     deps = [
         ":test_lib",
         "//:dagger_with_compiler",
-        "//third_party:guava",
+        "@google_bazel_common//third_party/java/guava",
     ],
 )
diff --git a/javatests/dagger/functional/subcomponent/SubcomponentTest.java b/javatests/dagger/functional/subcomponent/SubcomponentTest.java
index 73562b8d4..8e72138fc 100644
--- a/javatests/dagger/functional/subcomponent/SubcomponentTest.java
+++ b/javatests/dagger/functional/subcomponent/SubcomponentTest.java
@@ -86,10 +86,10 @@ public void multibindingContributions() {
 
   @Test
   public void unscopedProviders() {
-    assume().that(System.getProperty("dagger.mode")).isNotEqualTo("ExperimentalAndroidMode");
+    assume().that(System.getProperty("dagger.mode")).isNotEqualTo("FastInit");
     assume()
         .that(System.getProperty("dagger.mode"))
-        .isNotEqualTo("ExperimentalAndroidModeAndAheadOfTimeComponents");
+        .isNotEqualTo("FastInitAndAheadOfTimeSubcomponents");
     assertThat(parentGetters.getUnscopedTypeProvider())
         .isSameAs(childComponent.getUnscopedTypeProvider());
     assertThat(parentGetters.getUnscopedTypeProvider())
diff --git a/javatests/dagger/functional/tck/BUILD b/javatests/dagger/functional/tck/BUILD
index f971e3a37..7526bf097 100644
--- a/javatests/dagger/functional/tck/BUILD
+++ b/javatests/dagger/functional/tck/BUILD
@@ -35,8 +35,8 @@ GenJavaTests(
     ],
     deps = [
         "//:dagger_with_compiler",
-        "//third_party:jsr330_inject",
-        "//third_party:jsr330_inject_tck",
-        "//third_party:junit",
+        "@google_bazel_common//third_party/java/jsr330_inject",
+        "@google_bazel_common//third_party/java/jsr330_inject:tck",
+        "@google_bazel_common//third_party/java/junit",
     ],
 )
diff --git a/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java b/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java
new file mode 100644
index 000000000..0fee19f39
--- /dev/null
+++ b/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java
@@ -0,0 +1,2688 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static dagger.internal.codegen.CompilerMode.AHEAD_OF_TIME_SUBCOMPONENTS_MODE;
+import static dagger.internal.codegen.Compilers.CLASS_PATH_WITHOUT_GUAVA_OPTION;
+import static dagger.internal.codegen.Compilers.daggerCompiler;
+import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
+import static dagger.internal.codegen.GeneratedLines.IMPORT_GENERATED_ANNOTATION;
+
+import com.google.common.collect.ImmutableList;
+import com.google.testing.compile.Compilation;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public final class AheadOfTimeSubcomponentsTest {
+  @Test
+  public void missingBindings_fromComponentMethod() {
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
+    createAncillaryClasses(filesToCompile, "MissingInLeaf");
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Leaf",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent",
+            "interface Leaf {",
+            "  MissingInLeaf missingFromComponentMethod();",
+            "}"));
+    JavaFileObject generatedLeaf =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerLeaf",
+            "package test;",
+            "",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerLeaf implements Leaf {",
+            "  protected DaggerLeaf() {}",
+            "}");
+    Compilation compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerLeaf")
+        .hasSourceEquivalentTo(generatedLeaf);
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.AncestorModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "class AncestorModule {",
+            "  @Provides",
+            "  static MissingInLeaf satisfiedInAncestor() { return new MissingInLeaf(); }",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.Ancestor",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = AncestorModule.class)",
+            "interface Ancestor {",
+            "  Leaf leaf();",
+            "}"));
+    JavaFileObject generatedAncestor =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerLeaf",
+            "package test;",
+            "",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerAncestor implements Ancestor {",
+            "  protected DaggerAncestor() {}",
+            "",
+            "  public abstract class LeafImpl extends DaggerLeaf {",
+            "    protected LeafImpl() { super(); }",
+            "",
+            "    @Override",
+            "    public MissingInLeaf missingFromComponentMethod() {",
+            "      return AncestorModule_SatisfiedInAncestorFactory.proxySatisfiedInAncestor();",
+            "    }",
+            "  }",
+            "}");
+    compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerAncestor")
+        .hasSourceEquivalentTo(generatedAncestor);
+  }
+
+  @Test
+  public void missingBindings_dependsOnBindingWithMatchingComponentMethod() {
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
+    createAncillaryClasses(filesToCompile, "MissingInLeaf");
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Leaf",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent",
+            "interface Leaf {",
+            "  MissingInLeaf missingComponentMethod();",
+            "  DependsOnComponentMethod dependsOnComponentMethod();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.DependsOnComponentMethod",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class DependsOnComponentMethod {",
+            "  @Inject DependsOnComponentMethod(MissingInLeaf missingInLeaf) {}",
+            "}"));
+    JavaFileObject generatedLeaf =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerLeaf",
+            "package test;",
+            "",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerLeaf implements Leaf {",
+            "  protected DaggerLeaf() {}",
+            "",
+            "  @Override",
+            "  public DependsOnComponentMethod dependsOnComponentMethod() {",
+            "    return new DependsOnComponentMethod(missingComponentMethod());",
+            "  }",
+            "}");
+    Compilation compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerLeaf")
+        .hasSourceEquivalentTo(generatedLeaf);
+  }
+
+  @Test
+  public void missingBindings_dependsOnMissingBinding() {
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
+    createAncillaryClasses(filesToCompile, "MissingInLeaf");
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Leaf",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent",
+            "interface Leaf {",
+            "  DependsOnMissingBinding dependsOnMissingBinding();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.DependsOnMissingBinding",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class DependsOnMissingBinding {",
+            "  @Inject DependsOnMissingBinding(MissingInLeaf missing) {}",
+            "}"));
+    JavaFileObject generatedLeaf =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerLeaf",
+            "package test;",
+            "",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerLeaf implements Leaf {",
+            "  protected DaggerLeaf() {}",
+            "",
+            "  @Override",
+            "  public DependsOnMissingBinding dependsOnMissingBinding() {",
+            "    return new DependsOnMissingBinding(getMissingInLeaf());",
+            "  }",
+            "",
+            "  public abstract MissingInLeaf getMissingInLeaf();",
+            "}");
+    Compilation compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerLeaf")
+        .hasSourceEquivalentTo(generatedLeaf);
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.AncestorModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "class AncestorModule {",
+            "  @Provides",
+            "  static MissingInLeaf satisfiedInAncestor() { return new MissingInLeaf(); }",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.Ancestor",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = AncestorModule.class)",
+            "interface Ancestor {",
+            "  Leaf leaf();",
+            "}"));
+    JavaFileObject generatedAncestor =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerLeaf",
+            "package test;",
+            "",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerAncestor implements Ancestor {",
+            "  protected DaggerAncestor() {}",
+            "",
+            "  public abstract class LeafImpl extends DaggerLeaf {",
+            "    protected LeafImpl() { super(); }",
+            "",
+            "    @Override",
+            "    public MissingInLeaf getMissingInLeaf() {",
+            "      return AncestorModule_SatisfiedInAncestorFactory.proxySatisfiedInAncestor();",
+            "    }",
+            "  }",
+            "}");
+    compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerAncestor")
+        .hasSourceEquivalentTo(generatedAncestor);
+  }
+
+  @Test
+  public void missingBindings_satisfiedInGreatAncestor() {
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
+    createAncillaryClasses(filesToCompile, "MissingInLeaf");
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Leaf",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent",
+            "interface Leaf {",
+            "  DependsOnMissingBinding dependsOnMissingBinding();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.DependsOnMissingBinding",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class DependsOnMissingBinding {",
+            "  @Inject DependsOnMissingBinding(MissingInLeaf missing) {}",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.Ancestor",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent",
+            "interface Ancestor {",
+            "  Leaf leaf();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.GreatAncestor",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = SatisfiesMissingBindingModule.class)",
+            "interface GreatAncestor {",
+            "  Ancestor ancestor();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.SatisfiesMissingBindingModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "class SatisfiesMissingBindingModule {",
+            "  @Provides",
+            "  static MissingInLeaf satisfy() { return new MissingInLeaf(); }",
+            "}"));
+    // DaggerLeaf+DaggerAncestor generated types are ignored - they're not the focus of this test
+    // and are tested elsewhere
+    JavaFileObject generatedGreatAncestor =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerLeaf",
+            "package test;",
+            "",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerGreatAncestor implements GreatAncestor {",
+            "  protected DaggerGreatAncestor() {}",
+            "",
+            "  public abstract class AncestorImpl extends DaggerAncestor {",
+            "    protected AncestorImpl() { super(); }",
+            "",
+            "    public abstract class LeafImpl extends DaggerAncestor.LeafImpl {",
+            "      protected LeafImpl() { super(); }",
+            "",
+            "      @Override",
+            "      public MissingInLeaf getMissingInLeaf() {",
+            "        return SatisfiesMissingBindingModule_SatisfyFactory.proxySatisfy();",
+            "      }",
+            "    }",
+            "  }",
+            "}");
+    Compilation compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerGreatAncestor")
+        .hasSourceEquivalentTo(generatedGreatAncestor);
+  }
+
+  @Test
+  public void moduleInstanceDependency() {
+    JavaFileObject subcomponent =
+        JavaFileObjects.forSourceLines(
+            "test.Sub",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = TestModule.class)",
+            "interface Sub {",
+            "  String string();",
+            "}");
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "class TestModule {",
+            "  @Provides String provideString() { return \"florp\"; }",
+            "}");
+    JavaFileObject generatedSubcomponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerSub",
+            "package test;",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerSub implements Sub {",
+            "  private TestModule testModule;",
+            "",
+            "  protected DaggerSub() {",
+            "    initialize();",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize() {",
+            "    this.testModule = new TestModule();",
+            "  }",
+            "",
+            "  @Override",
+            "  public String string() {",
+            "    return TestModule_ProvideStringFactory.proxyProvideString(testModule);",
+            "  }",
+            "}");
+    Compilation compilation = compile(subcomponent, module);
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerSub")
+        .hasSourceEquivalentTo(generatedSubcomponent);
+  }
+
+  @Test
+  public void generatedInstanceBinding() {
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Leaf",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent",
+            "interface Leaf {",
+            // "  Leaf leaf();", // TODO(b/72748365): enable this (and fix the bug that's causing
+            // this to stack overflow
+            "",
+            "  @Subcomponent.Builder",
+            "  interface Builder {",
+            "    Leaf build();",
+            "  }",
+            "}"));
+    JavaFileObject generatedLeaf =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerLeaf",
+            "package test;",
+            "",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerLeaf implements Leaf {",
+            "  protected DaggerLeaf(Builder builder) {}",
+            "",
+            "  public abstract static class Builder implements Leaf.Builder {}",
+            "}");
+    Compilation compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerLeaf")
+        .hasSourceEquivalentTo(generatedLeaf);
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Ancestor",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent",
+            "interface Ancestor {",
+            "  Leaf.Builder leaf();",
+            "}"));
+    JavaFileObject generatedAncestor =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerAncestor",
+            "package test;",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerAncestor implements Ancestor {",
+            "  protected DaggerAncestor() {}",
+            "",
+            "  public abstract class LeafBuilder extends DaggerLeaf.Builder {}",
+            "",
+            "  public abstract class LeafImpl extends DaggerLeaf {",
+            "    protected LeafImpl(LeafBuilder builder) {",
+            "      super(builder);",
+            "    }",
+            "  }",
+            "}");
+    compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerAncestor")
+        .hasSourceEquivalentTo(generatedAncestor);
+  }
+
+  @Test
+  public void optionalBindings_boundAndSatisfiedInSameSubcomponent() {
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
+    createAncillaryClasses(filesToCompile, "SatisfiedInSub");
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Sub",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "import java.util.Optional;",
+            "",
+            "@Subcomponent(modules = {SubModule.class, BindsSatisfiedInSubModule.class})",
+            "interface Sub {",
+            "  Optional<SatisfiedInSub> satisfiedInSub();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.SubModule",
+            "package test;",
+            "",
+            "import dagger.BindsOptionalOf;",
+            "import dagger.Module;",
+            "",
+            "@Module",
+            "abstract class SubModule {",
+            "  @BindsOptionalOf abstract SatisfiedInSub optionalSatisfiedInSub();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.BindsSatisfiedInSubModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "abstract class BindsSatisfiedInSubModule {",
+            "  @Provides static SatisfiedInSub provideSatisfiedInSub() {",
+            "      return new SatisfiedInSub();",
+            "  }",
+            "}"));
+    JavaFileObject generatedSubcomponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerSub",
+            "package test;",
+            "",
+            "import java.util.Optional;",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerSub implements Sub {",
+            "  protected DaggerSub() {}",
+            "",
+            "  @Override",
+            "  public Optional<SatisfiedInSub> satisfiedInSub() {",
+            "    return Optional.of(",
+            "        BindsSatisfiedInSubModule_ProvideSatisfiedInSubFactory",
+            "            .proxyProvideSatisfiedInSub());",
+            "  }",
+            "}");
+    Compilation compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerSub")
+        .hasSourceEquivalentTo(generatedSubcomponent);
+  }
+
+  @Test
+  public void optionalBindings_satisfiedInAncestor() {
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
+    createAncillaryClasses(filesToCompile, "SatisfiedInAncestor");
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Leaf",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "import java.util.Optional;",
+            "",
+            "@Subcomponent(modules = LeafModule.class)",
+            "interface Leaf {",
+            "  Optional<SatisfiedInAncestor> satisfiedInAncestor();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.LeafModule",
+            "package test;",
+            "",
+            "import dagger.BindsOptionalOf;",
+            "import dagger.Module;",
+            "",
+            "@Module",
+            "abstract class LeafModule {",
+            "  @BindsOptionalOf abstract SatisfiedInAncestor optionalSatisfiedInAncestor();",
+            "}"));
+    JavaFileObject generatedLeaf =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerLeaf",
+            "package test;",
+            "",
+            "import java.util.Optional;",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerLeaf implements Leaf {",
+            "  protected DaggerLeaf() {}",
+            "",
+            "  @Override",
+            "  public Optional<SatisfiedInAncestor> satisfiedInAncestor() {",
+            "    return Optional.<SatisfiedInAncestor>empty();",
+            "  }",
+            "}");
+    Compilation compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerLeaf")
+        .hasSourceEquivalentTo(generatedLeaf);
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Ancestor",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = AncestorModule.class)",
+            "interface Ancestor {",
+            "  Leaf leaf();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.AncestorModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "abstract class AncestorModule {",
+            "  @Provides",
+            "  static SatisfiedInAncestor satisfiedInAncestor(){",
+            "    return new SatisfiedInAncestor();",
+            "  }",
+            "}"));
+    JavaFileObject generatedAncestor =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerAncestor",
+            "package test;",
+            "",
+            "import java.util.Optional;",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerAncestor implements Ancestor {",
+            "  protected DaggerAncestor() {}",
+            "",
+            "  public abstract class LeafImpl extends DaggerLeaf {",
+            "    protected LeafImpl() { super(); }",
+            "",
+            "    @Override",
+            "    public Optional<SatisfiedInAncestor> satisfiedInAncestor() {",
+            "      return Optional.of(AncestorModule_SatisfiedInAncestorFactory",
+            "          .proxySatisfiedInAncestor());",
+            "    }",
+            "",
+            "  }",
+            "}");
+    compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerAncestor")
+        .hasSourceEquivalentTo(generatedAncestor);
+  }
+
+  @Test
+  public void optionalBindings_satisfiedInGrandAncestor() {
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
+    createAncillaryClasses(filesToCompile, "SatisfiedInGrandAncestor");
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Leaf",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "import java.util.Optional;",
+            "",
+            "@Subcomponent(modules = LeafModule.class)",
+            "interface Leaf {",
+            "  Optional<SatisfiedInGrandAncestor> satisfiedInGrandAncestor();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.LeafModule",
+            "package test;",
+            "",
+            "import dagger.BindsOptionalOf;",
+            "import dagger.Module;",
+            "",
+            "@Module",
+            "abstract class LeafModule {",
+            "  @BindsOptionalOf",
+            "  abstract SatisfiedInGrandAncestor optionalSatisfiedInGrandAncestor();",
+            "}"));
+    JavaFileObject generatedLeaf =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerLeaf",
+            "package test;",
+            "",
+            "import java.util.Optional;",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerLeaf implements Leaf {",
+            "  protected DaggerLeaf() {}",
+            "",
+            "  @Override",
+            "  public Optional<SatisfiedInGrandAncestor> satisfiedInGrandAncestor() {",
+            "    return Optional.<SatisfiedInGrandAncestor>empty();",
+            "  }",
+            "}");
+    Compilation compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerLeaf")
+        .hasSourceEquivalentTo(generatedLeaf);
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Ancestor",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent",
+            "interface Ancestor {",
+            "  Leaf leaf();",
+            "}"));
+    JavaFileObject generatedAncestor =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerAncestor",
+            "package test;",
+            "",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerAncestor implements Ancestor {",
+            "  protected DaggerAncestor() {}",
+            "",
+            "  public abstract class LeafImpl extends DaggerLeaf {",
+            "    protected LeafImpl() { super(); }",
+            "  }",
+            "}");
+    compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerAncestor")
+        .hasSourceEquivalentTo(generatedAncestor);
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.GreatAncestor",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = GreatAncestorModule.class)",
+            "interface GreatAncestor {",
+            "  Ancestor ancestor();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.GreatAncestorModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "abstract class GreatAncestorModule {",
+            "  @Provides",
+            "  static SatisfiedInGrandAncestor satisfiedInGrandAncestor(){",
+            "    return new SatisfiedInGrandAncestor();",
+            "  }",
+            "}"));
+    JavaFileObject generatedGreatAncestor =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerGreatAncestor",
+            "package test;",
+            "",
+            "import java.util.Optional;",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerGreatAncestor implements GreatAncestor {",
+            "  protected DaggerGreatAncestor() {}",
+            "",
+            "  public abstract class AncestorImpl extends DaggerAncestor {",
+            "    protected AncestorImpl() { super(); }",
+            "",
+            "    public abstract class LeafImpl extends DaggerAncestor.LeafImpl {",
+            "      protected LeafImpl() { super(); }",
+            "",
+            "      @Override",
+            "      public Optional<SatisfiedInGrandAncestor> satisfiedInGrandAncestor() {",
+            "        return Optional.of(",
+            "            GreatAncestorModule_SatisfiedInGrandAncestorFactory",
+            "                .proxySatisfiedInGrandAncestor());",
+            "      }",
+            "    }",
+            "  }",
+            "}");
+    compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerGreatAncestor")
+        .hasSourceEquivalentTo(generatedGreatAncestor);
+  }
+
+  @Test
+  public void optionalBindings_nonComponentMethodDependencySatisfiedInAncestor() {
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
+    createAncillaryClasses(
+        filesToCompile, "SatisfiedInAncestor", "RequiresOptionalSatisfiedInAncestor");
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Leaf",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "import java.util.Optional;",
+            "",
+            "@Subcomponent(modules = LeafModule.class)",
+            "interface Leaf {",
+            "  RequiresOptionalSatisfiedInAncestor requiresOptionalSatisfiedInAncestor();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.LeafModule",
+            "package test;",
+            "",
+            "import dagger.BindsOptionalOf;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import java.util.Optional;",
+            "",
+            "@Module",
+            "abstract class LeafModule {",
+            "  @Provides static RequiresOptionalSatisfiedInAncestor",
+            "      provideRequiresOptionalSatisfiedInAncestor(",
+            "          Optional<SatisfiedInAncestor> satisfiedInAncestor) {",
+            "    return new RequiresOptionalSatisfiedInAncestor();",
+            "  }",
+            "",
+            "  @BindsOptionalOf abstract SatisfiedInAncestor optionalSatisfiedInAncestor();",
+            "}"));
+    JavaFileObject generatedLeaf =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerLeaf",
+            "package test;",
+            "",
+            "import java.util.Optional;",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerLeaf implements Leaf {",
+            "  protected DaggerLeaf() {}",
+            "",
+            "  @Override",
+            "  public RequiresOptionalSatisfiedInAncestor requiresOptionalSatisfiedInAncestor() {",
+            "    return LeafModule_ProvideRequiresOptionalSatisfiedInAncestorFactory",
+            "        .proxyProvideRequiresOptionalSatisfiedInAncestor(",
+            "            getOptionalOfSatisfiedInAncestor());",
+            "  }",
+            "",
+            "  public Optional<SatisfiedInAncestor> getOptionalOfSatisfiedInAncestor() {",
+            "    return Optional.<SatisfiedInAncestor>empty();",
+            "  }",
+            "}");
+    Compilation compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerLeaf")
+        .hasSourceEquivalentTo(generatedLeaf);
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Ancestor",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = AncestorModule.class)",
+            "interface Ancestor {",
+            "  Leaf leaf();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.AncestorModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "abstract class AncestorModule {",
+            "  @Provides",
+            "  static SatisfiedInAncestor satisfiedInAncestor(){",
+            "    return new SatisfiedInAncestor();",
+            "  }",
+            "}"));
+    JavaFileObject generatedAncestor =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerAncestor",
+            "package test;",
+            "",
+            "import java.util.Optional;",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerAncestor implements Ancestor {",
+            "  protected DaggerAncestor() {}",
+            "",
+            "  public abstract class LeafImpl extends DaggerLeaf {",
+            "    protected LeafImpl() { super(); }",
+            "",
+            "    @Override",
+            "    public Optional<SatisfiedInAncestor> getOptionalOfSatisfiedInAncestor() {",
+            "      return Optional.of(",
+            "          AncestorModule_SatisfiedInAncestorFactory.proxySatisfiedInAncestor());",
+            "    }",
+            "  }",
+            "}");
+    compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerAncestor")
+        .hasSourceEquivalentTo(generatedAncestor);
+  }
+
+  @Test
+  public void optionalBindings_boundInAncestorAndSatisfiedInGrandAncestor() {
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
+    createAncillaryClasses(filesToCompile, "SatisfiedInGrandAncestor");
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Leaf",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "import java.util.Optional;",
+            "",
+            "@Subcomponent",
+            "interface Leaf {",
+            "  Optional<SatisfiedInGrandAncestor> boundInAncestorSatisfiedInGrandAncestor();",
+            "}"));
+    JavaFileObject generatedLeaf =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerLeaf",
+            "package test;",
+            "",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerLeaf implements Leaf {",
+            "  protected DaggerLeaf() {}",
+            "}");
+    Compilation compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerLeaf")
+        .hasSourceEquivalentTo(generatedLeaf);
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Ancestor",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = AncestorModule.class)",
+            "interface Ancestor {",
+            "  Leaf leaf();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.AncestorModule",
+            "package test;",
+            "",
+            "import dagger.BindsOptionalOf;",
+            "import dagger.Module;",
+            "",
+            "@Module",
+            "abstract class AncestorModule {",
+            "  @BindsOptionalOf",
+            "  abstract SatisfiedInGrandAncestor optionalSatisfiedInGrandAncestor();",
+            "}"));
+    JavaFileObject generatedAncestor =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerAncestor",
+            "package test;",
+            "",
+            "import java.util.Optional;",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerAncestor implements Ancestor {",
+            "  protected DaggerAncestor() {}",
+            "",
+            "  public abstract class LeafImpl extends DaggerLeaf {",
+            "    protected LeafImpl() { super(); }",
+            "",
+            "    @Override",
+            "    public Optional<SatisfiedInGrandAncestor>",
+            "        boundInAncestorSatisfiedInGrandAncestor() {",
+            "      return Optional.<SatisfiedInGrandAncestor>empty();",
+            "    }",
+            "  }",
+            "}");
+    compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerAncestor")
+        .hasSourceEquivalentTo(generatedAncestor);
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.GrandAncestor",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = GrandAncestorModule.class)",
+            "interface GrandAncestor {",
+            "  Ancestor ancestor();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.GrandAncestorModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "class GrandAncestorModule {",
+            "  @Provides static SatisfiedInGrandAncestor provideSatisfiedInGrandAncestor() {",
+            "    return new SatisfiedInGrandAncestor();",
+            "  }",
+            "}"));
+    JavaFileObject generatedGrandAncestor =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerGrandAncestor",
+            "package test;",
+            "",
+            "import java.util.Optional;",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerGrandAncestor implements GrandAncestor {",
+            "  protected DaggerGrandAncestor() {}",
+            "",
+            "  public abstract class AncestorImpl extends DaggerAncestor {",
+            "    protected AncestorImpl() { super(); }",
+            "",
+            "    public abstract class LeafImpl extends DaggerAncestor.LeafImpl {",
+            "      protected LeafImpl() { super(); }",
+            "",
+            "      @Override",
+            "      public Optional<SatisfiedInGrandAncestor>",
+            "          boundInAncestorSatisfiedInGrandAncestor() {",
+            "        return Optional.of(",
+            "            GrandAncestorModule_ProvideSatisfiedInGrandAncestorFactory",
+            "                .proxyProvideSatisfiedInGrandAncestor());",
+            "      }",
+            "    }",
+            "  }",
+            "}");
+    compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerGrandAncestor")
+        .hasSourceEquivalentTo(generatedGrandAncestor);
+  }
+
+  @Test
+  public void setMultibindings_contributionsInLeaf() {
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
+    createAncillaryClasses(filesToCompile, "InLeaf");
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Leaf",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "import java.util.Set;",
+            "",
+            "@Subcomponent(modules = LeafModule.class)",
+            "interface Leaf {",
+            "  Set<InLeaf> contributionsInLeaf();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.LeafModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntoSet;",
+            "",
+            "@Module",
+            "class LeafModule {",
+            "  @Provides",
+            "  @IntoSet",
+            "  static InLeaf provideInLeaf() {",
+            "    return new InLeaf();",
+            "  }",
+            "}"));
+    JavaFileObject generatedLeaf =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerLeaf",
+            "package test;",
+            "",
+            "import com.google.common.collect.ImmutableSet;",
+            "import java.util.Set;",
+            "",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerLeaf implements Leaf {",
+            "  protected DaggerLeaf() {}",
+            "",
+            "  @Override",
+            "  public Set<InLeaf> contributionsInLeaf() {",
+            "    return ImmutableSet.<InLeaf>of(",
+            "        LeafModule_ProvideInLeafFactory.proxyProvideInLeaf());",
+            "  }",
+            "}");
+    Compilation compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerLeaf")
+        .hasSourceEquivalentTo(generatedLeaf);
+  }
+
+  @Test
+  public void setMultibindings_contributionsInAncestorOnly() {
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
+    createAncillaryClasses(filesToCompile, "InAncestor");
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Leaf",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "import java.util.Set;",
+            "",
+            "@Subcomponent",
+            "interface Leaf {",
+            "  Set<InAncestor> contributionsInAncestor();",
+            "}"));
+    JavaFileObject generatedLeaf =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerLeaf",
+            "package test;",
+            "",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerLeaf implements Leaf {",
+            "  protected DaggerLeaf() {}",
+            "}");
+    Compilation compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerLeaf")
+        .hasSourceEquivalentTo(generatedLeaf);
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Ancestor",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "import java.util.Set;",
+            "",
+            "@Subcomponent(modules = AncestorModule.class)",
+            "interface Ancestor {",
+            "  Leaf leaf();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.AncestorModule",
+            "package test;",
+            "",
+            "import com.google.common.collect.ImmutableSet;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.ElementsIntoSet;",
+            "import java.util.Set;",
+            "",
+            "@Module",
+            "class AncestorModule {",
+            "  @Provides",
+            "  @ElementsIntoSet",
+            "  static Set<InAncestor> provideInAncestors() {",
+            "    return ImmutableSet.of(new InAncestor(), new InAncestor());",
+            "  }",
+            "}"));
+    JavaFileObject generatedAncestor =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerAncestor",
+            "package test;",
+            "",
+            "import com.google.common.collect.ImmutableSet;",
+            "import java.util.Set;",
+            "",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerAncestor implements Ancestor {",
+            "  protected DaggerAncestor() {}",
+            "",
+            "  public abstract class LeafImpl extends DaggerLeaf {",
+            "    protected LeafImpl() { super(); }",
+            "",
+            "    @Override",
+            "    public Set<InAncestor> contributionsInAncestor() {",
+            "      return ImmutableSet.<InAncestor>copyOf(",
+            "          AncestorModule_ProvideInAncestorsFactory.proxyProvideInAncestors());",
+            "    }",
+            "  }",
+            "}");
+    compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerAncestor")
+        .hasSourceEquivalentTo(generatedAncestor);
+  }
+
+  @Test
+  public void setMultibindings_contributionsInLeafAndAncestor() {
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
+    createAncillaryClasses(filesToCompile, "InEachSubcomponent");
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Leaf",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "import java.util.Set;",
+            "",
+            "@Subcomponent(modules = LeafModule.class)",
+            "interface Leaf {",
+            "  Set<InEachSubcomponent> contributionsInEachSubcomponent();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.LeafModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntoSet;",
+            "",
+            "@Module",
+            "class LeafModule {",
+            "  @Provides",
+            "  @IntoSet",
+            "  static InEachSubcomponent provideInLeaf() {",
+            "    return new InEachSubcomponent();",
+            "  }",
+            "",
+            "  @Provides",
+            "  @IntoSet",
+            "  static InEachSubcomponent provideAnotherInLeaf() {",
+            "    return new InEachSubcomponent();",
+            "  }",
+            "}"));
+    JavaFileObject generatedLeaf =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerLeaf",
+            "package test;",
+            "",
+            "import com.google.common.collect.ImmutableSet;",
+            "import java.util.Set;",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerLeaf implements Leaf {",
+            "  protected DaggerLeaf() {}",
+            "",
+            "  @Override",
+            "  public Set<InEachSubcomponent> contributionsInEachSubcomponent() {",
+            "    return ImmutableSet.<InEachSubcomponent>of(",
+            "        LeafModule_ProvideInLeafFactory.proxyProvideInLeaf(),",
+            "        LeafModule_ProvideAnotherInLeafFactory.proxyProvideAnotherInLeaf());",
+            "  }",
+            "}");
+    Compilation compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerLeaf")
+        .hasSourceEquivalentTo(generatedLeaf);
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Ancestor",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "import java.util.Set;",
+            "",
+            "@Subcomponent(modules = AncestorModule.class)",
+            "interface Ancestor {",
+            "  Leaf leaf();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.AncestorModule",
+            "package test;",
+            "",
+            "import com.google.common.collect.ImmutableSet;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.ElementsIntoSet;",
+            "import java.util.Set;",
+            "",
+            "@Module",
+            "class AncestorModule {",
+            "  @Provides",
+            "  @ElementsIntoSet",
+            "  static Set<InEachSubcomponent> provideInAncestor() {",
+            "    return ImmutableSet.of(new InEachSubcomponent(), new InEachSubcomponent());",
+            "  }",
+            "}"));
+    JavaFileObject generatedAncestor =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerAncestor",
+            "package test;",
+            "",
+            "import com.google.common.collect.ImmutableSet;",
+            "import java.util.Set;",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerAncestor implements Ancestor {",
+            "  protected DaggerAncestor() {}",
+            "",
+            "  public abstract class LeafImpl extends DaggerLeaf {",
+            "    protected LeafImpl() { super(); }",
+            "",
+            "    @Override",
+            "    public Set<InEachSubcomponent> contributionsInEachSubcomponent() {",
+            "      return ImmutableSet.<InEachSubcomponent>builderWithExpectedSize(3)",
+            "          .addAll(AncestorModule_ProvideInAncestorFactory.proxyProvideInAncestor())",
+            "          .addAll(super.contributionsInEachSubcomponent())",
+            "          .build();",
+            "    }",
+            "  }",
+            "}");
+    compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerAncestor")
+        .hasSourceEquivalentTo(generatedAncestor);
+  }
+
+  @Test
+  public void setMultibindings_contributionsInLeafAndGrandAncestor() {
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
+    createAncillaryClasses(filesToCompile, "InLeafAndGrandAncestor");
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Leaf",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "import java.util.Set;",
+            "",
+            "@Subcomponent(modules = LeafModule.class)",
+            "interface Leaf {",
+            "  Set<InLeafAndGrandAncestor> contributionsInLeafAndGrandAncestor();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.LeafModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntoSet;",
+            "",
+            "@Module",
+            "class LeafModule {",
+            "  @Provides",
+            "  @IntoSet",
+            "  static InLeafAndGrandAncestor provideInLeaf() {",
+            "    return new InLeafAndGrandAncestor();",
+            "  }",
+            "",
+            "  @Provides",
+            "  @IntoSet",
+            "  static InLeafAndGrandAncestor provideAnotherInLeaf() {",
+            "    return new InLeafAndGrandAncestor();",
+            "  }",
+            "}"));
+    JavaFileObject generatedLeaf =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerLeaf",
+            "package test;",
+            "",
+            "import com.google.common.collect.ImmutableSet;",
+            "import java.util.Set;",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerLeaf implements Leaf {",
+            "  protected DaggerLeaf() {}",
+            "",
+            "  @Override",
+            "  public Set<InLeafAndGrandAncestor> contributionsInLeafAndGrandAncestor() {",
+            "    return ImmutableSet.<InLeafAndGrandAncestor>of(",
+            "        LeafModule_ProvideInLeafFactory.proxyProvideInLeaf(),",
+            "        LeafModule_ProvideAnotherInLeafFactory.proxyProvideAnotherInLeaf());",
+            "  }",
+            "}");
+    Compilation compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerLeaf")
+        .hasSourceEquivalentTo(generatedLeaf);
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Ancestor",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "import java.util.Set;",
+            "",
+            "@Subcomponent",
+            "interface Ancestor {",
+            "  Leaf leaf();",
+            "}"));
+    JavaFileObject generatedAncestor =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerAncestor",
+            "package test;",
+            "",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerAncestor implements Ancestor {",
+            "  protected DaggerAncestor() {}",
+            "",
+            "  public abstract class LeafImpl extends DaggerLeaf {",
+            "    protected LeafImpl() { super(); }",
+            "  }",
+            "}");
+    compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerAncestor")
+        .hasSourceEquivalentTo(generatedAncestor);
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.GrandAncestor",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "import java.util.Set;",
+            "",
+            "@Subcomponent(modules = GrandAncestorModule.class)",
+            "interface GrandAncestor {",
+            "  Leaf leaf();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.GrandAncestorModule",
+            "package test;",
+            "",
+            "import com.google.common.collect.ImmutableSet;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.ElementsIntoSet;",
+            "import java.util.Set;",
+            "",
+            "@Module",
+            "class GrandAncestorModule {",
+            "  @Provides",
+            "  @ElementsIntoSet",
+            "  static Set<InLeafAndGrandAncestor> provideInGrandAncestor() {",
+            "    return ImmutableSet.of(new InLeafAndGrandAncestor(),",
+            "        new InLeafAndGrandAncestor());",
+            "  }",
+            "}"));
+    JavaFileObject generatedGrandAncestor =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerGrandAncestor",
+            "package test;",
+            "",
+            "import com.google.common.collect.ImmutableSet;",
+            "import java.util.Set;",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerGrandAncestor implements GrandAncestor {",
+            "  protected DaggerGrandAncestor() {}",
+            "",
+            "  public abstract class LeafImpl extends DaggerLeaf {",
+            "    protected LeafImpl() {",
+            "      super();",
+            "    }",
+            "",
+            "    @Override",
+            "    public Set<InLeafAndGrandAncestor> contributionsInLeafAndGrandAncestor() {",
+            "      return ImmutableSet.<InLeafAndGrandAncestor>builderWithExpectedSize(3)",
+            "          .addAll(GrandAncestorModule_ProvideInGrandAncestorFactory",
+            "              .proxyProvideInGrandAncestor())",
+            "          .addAll(super.contributionsInLeafAndGrandAncestor())",
+            "          .build();",
+            "    }",
+            "  }",
+            "}");
+    compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerGrandAncestor")
+        .hasSourceEquivalentTo(generatedGrandAncestor);
+  }
+
+  @Test
+  public void setMultibindings_nonComponentMethodDependency() {
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
+    createAncillaryClasses(filesToCompile, "InAllSubcomponents", "RequresInAllSubcomponentsSet");
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Leaf",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "import java.util.Set;",
+            "",
+            "@Subcomponent(modules = LeafModule.class)",
+            "interface Leaf {",
+            "  RequresInAllSubcomponentsSet requiresNonComponentMethod();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.LeafModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntoSet;",
+            "import java.util.Set;",
+            "",
+            "@Module",
+            "class LeafModule {",
+            "  @Provides",
+            "  @IntoSet",
+            "  static InAllSubcomponents provideInAllSubcomponents() {",
+            "    return new InAllSubcomponents();",
+            "  }",
+            "",
+            "  @Provides",
+            "  static RequresInAllSubcomponentsSet providesRequresInAllSubcomponentsSet(",
+            "      Set<InAllSubcomponents> inAllSubcomponents) {",
+            "    return new RequresInAllSubcomponentsSet();",
+            "  }",
+            "}"));
+    JavaFileObject generatedLeaf =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerLeaf",
+            "package test;",
+            "",
+            "import com.google.common.collect.ImmutableSet;",
+            "import java.util.Set;",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerLeaf implements Leaf {",
+            "  protected DaggerLeaf() {}",
+            "",
+            "  @Override",
+            "  public RequresInAllSubcomponentsSet requiresNonComponentMethod() {",
+            "    return LeafModule_ProvidesRequresInAllSubcomponentsSetFactory",
+            "        .proxyProvidesRequresInAllSubcomponentsSet(getSetOfInAllSubcomponents());",
+            "  }",
+            "",
+            "  public Set<InAllSubcomponents> getSetOfInAllSubcomponents() {",
+            "    return ImmutableSet.<InAllSubcomponents>of(",
+            "        LeafModule_ProvideInAllSubcomponentsFactory",
+            "            .proxyProvideInAllSubcomponents());",
+            "  }",
+            "}");
+    Compilation compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerLeaf")
+        .hasSourceEquivalentTo(generatedLeaf);
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Ancestor",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = AncestorModule.class)",
+            "interface Ancestor {",
+            "  Leaf leaf();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.AncestorModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntoSet;",
+            "",
+            "@Module",
+            "class AncestorModule {",
+            "  @Provides",
+            "  @IntoSet",
+            "  static InAllSubcomponents provideInAllSubcomponents() {",
+            "      return new InAllSubcomponents();",
+            "  }",
+            "}"));
+    JavaFileObject generatedAncestor =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerAncestor",
+            "package test;",
+            "",
+            "import com.google.common.collect.ImmutableSet;",
+            "import java.util.Set;",
+            "",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerAncestor implements Ancestor {",
+            "  protected DaggerAncestor() {}",
+            "",
+            "  public abstract class LeafImpl extends DaggerLeaf {",
+            "    protected LeafImpl() { super(); }",
+            "",
+            "    @Override",
+            "    public Set<InAllSubcomponents> getSetOfInAllSubcomponents() {",
+            "      return ImmutableSet.<InAllSubcomponents>builderWithExpectedSize(2)",
+            "          .add(AncestorModule_ProvideInAllSubcomponentsFactory",
+            "              .proxyProvideInAllSubcomponents())",
+            "          .addAll(super.getSetOfInAllSubcomponents())",
+            "          .build();",
+            "    }",
+            "  }",
+            "}");
+    compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerAncestor")
+        .hasSourceEquivalentTo(generatedAncestor);
+  }
+
+  @Test
+  public void setMultibindings_newSubclass() {
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
+    createAncillaryClasses(filesToCompile, "InAncestor", "RequiresInAncestorSet");
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Leaf",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent",
+            "interface Leaf {",
+            "  RequiresInAncestorSet missingWithSetDependency();",
+            "}"));
+    JavaFileObject generatedLeaf =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerLeaf",
+            "package test;",
+            "",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerLeaf implements Leaf {",
+            "  protected DaggerLeaf() {}",
+            "}");
+    Compilation compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerLeaf")
+        .hasSourceEquivalentTo(generatedLeaf);
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Ancestor",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = AncestorModule.class)",
+            "interface Ancestor {",
+            "  Leaf leaf();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.AncestorModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntoSet;",
+            "import java.util.Set;",
+            "",
+            "@Module",
+            "class AncestorModule {",
+            "",
+            "  @Provides",
+            "  static RequiresInAncestorSet provideRequiresInAncestorSet(",
+            "      Set<InAncestor> inAncestors) {",
+            "    return new RequiresInAncestorSet();",
+            "  }",
+            "",
+            "  @Provides",
+            "  @IntoSet",
+            "  static InAncestor provideInAncestor() {",
+            "    return new InAncestor();",
+            "  }",
+            "}"));
+    JavaFileObject generatedAncestor =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerAncestor",
+            "package test;",
+            "",
+            "import com.google.common.collect.ImmutableSet;",
+            "import java.util.Set;",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerAncestor implements Ancestor {",
+            "  protected DaggerAncestor() {}",
+            "",
+            "  private RequiresInAncestorSet getRequiresInAncestorSet() {",
+            "    return AncestorModule_ProvideRequiresInAncestorSetFactory",
+            "        .proxyProvideRequiresInAncestorSet(getSetOfInAncestor());",
+            "  }",
+            "",
+            "  public Set<InAncestor> getSetOfInAncestor() {",
+            "    return ImmutableSet.<InAncestor>of(",
+            "        AncestorModule_ProvideInAncestorFactory.proxyProvideInAncestor());",
+            "  }",
+            "",
+            "  public abstract class LeafImpl extends DaggerLeaf {",
+            "    protected LeafImpl() { super(); }",
+            "",
+            "    @Override",
+            "    public RequiresInAncestorSet missingWithSetDependency() {",
+            "      return DaggerAncestor.this.getRequiresInAncestorSet();",
+            "    }",
+            "  }",
+            "}");
+    compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerAncestor")
+        .hasSourceEquivalentTo(generatedAncestor);
+  }
+
+  @Test
+  public void mapMultibindings_contributionsInLeaf() {
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
+    createAncillaryClasses(filesToCompile, "InLeaf");
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Leaf",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "import java.util.Map;",
+            "",
+            "@Subcomponent(modules = LeafModule.class)",
+            "interface Leaf {",
+            "  Map<String, InLeaf> contributionsInLeaf();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.LeafModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntoMap;",
+            "import dagger.multibindings.StringKey;",
+            "import java.util.Map;",
+            "",
+            "@Module",
+            "class LeafModule {",
+            "  @Provides",
+            "  @IntoMap",
+            "  @StringKey(\"leafmodule\")",
+            "  static InLeaf provideInLeaf() {",
+            "    return new InLeaf();",
+            "  }",
+            "}"));
+    JavaFileObject generatedLeaf =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerLeaf",
+            "package test;",
+            "",
+            "import com.google.common.collect.ImmutableMap;",
+            "import java.util.Map;",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerLeaf implements Leaf {",
+            "  protected DaggerLeaf() {}",
+            "",
+            "  @Override",
+            "  public Map<String, InLeaf> contributionsInLeaf() {",
+            "    return ImmutableMap.<String, InLeaf>of(",
+            "        \"leafmodule\",",
+            "        LeafModule_ProvideInLeafFactory.proxyProvideInLeaf());",
+            "  }",
+            "}");
+    Compilation compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerLeaf")
+        .hasSourceEquivalentTo(generatedLeaf);
+  }
+
+  @Test
+  public void mapMultibindings_contributionsInAncestorOnly() {
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
+    createAncillaryClasses(filesToCompile, "InAncestor");
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Leaf",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "import java.util.Map;",
+            "",
+            "@Subcomponent",
+            "interface Leaf {",
+            "  Map<String, InAncestor> contributionsInAncestor();",
+            "}"));
+    JavaFileObject generatedLeaf =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerLeaf",
+            "package test;",
+            "",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerLeaf implements Leaf {",
+            "  protected DaggerLeaf() {}",
+            "}");
+    Compilation compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerLeaf")
+        .hasSourceEquivalentTo(generatedLeaf);
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Ancestor",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = AncestorModule.class)",
+            "interface Ancestor {",
+            "  Leaf leaf();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.AncestorModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntoMap;",
+            "import dagger.multibindings.StringKey;",
+            "import java.util.Map;",
+            "",
+            "@Module",
+            "class AncestorModule {",
+            "  @Provides",
+            "  @IntoMap",
+            "  @StringKey(\"ancestormodule\")",
+            "  static InAncestor provideInAncestor() {",
+            "    return new InAncestor();",
+            "  }",
+            "}"));
+    JavaFileObject generatedAncestor =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerAncestor",
+            "package test;",
+            "",
+            "import com.google.common.collect.ImmutableMap;",
+            "import java.util.Map;",
+            "",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerAncestor implements Ancestor {",
+            "  protected DaggerAncestor() {}",
+            "",
+            "  public abstract class LeafImpl extends DaggerLeaf {",
+            "    protected LeafImpl() { super(); }",
+            "",
+            "    @Override",
+            "    public Map<String, InAncestor> contributionsInAncestor() {",
+            "      return ImmutableMap.<String, InAncestor>of(\"ancestormodule\",",
+            "          AncestorModule_ProvideInAncestorFactory.proxyProvideInAncestor());",
+            "    }",
+            "  }",
+            "}");
+    compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerAncestor")
+        .hasSourceEquivalentTo(generatedAncestor);
+  }
+
+  @Test
+  public void mapMultibindings_contributionsInLeafAndAncestor() {
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
+    createAncillaryClasses(filesToCompile, "InEachSubcomponent");
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Leaf",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "import java.util.Map;",
+            "",
+            "@Subcomponent(modules = LeafModule.class)",
+            "interface Leaf {",
+            "  Map<String, InEachSubcomponent> contributionsInEachSubcomponent();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.LeafModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntoMap;",
+            "import dagger.multibindings.StringKey;",
+            "import java.util.Map;",
+            "",
+            "@Module",
+            "class LeafModule {",
+            "  @Provides",
+            "  @IntoMap",
+            "  @StringKey(\"leafmodule\")",
+            "  static InEachSubcomponent provideInLeaf() {",
+            "    return new InEachSubcomponent();",
+            "  }",
+            "}"));
+    JavaFileObject generatedLeaf =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerLeaf",
+            "package test;",
+            "",
+            "import com.google.common.collect.ImmutableMap;",
+            "import java.util.Map;",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerLeaf implements Leaf {",
+            "  protected DaggerLeaf() {}",
+            "",
+            "  @Override",
+            "  public Map<String, InEachSubcomponent> contributionsInEachSubcomponent() {",
+            "    return ImmutableMap.<String, InEachSubcomponent>of(",
+            "        \"leafmodule\", LeafModule_ProvideInLeafFactory.proxyProvideInLeaf());",
+            "  }",
+            "}");
+    Compilation compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerLeaf")
+        .hasSourceEquivalentTo(generatedLeaf);
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Ancestor",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = AncestorModule.class)",
+            "interface Ancestor {",
+            "  Leaf leaf();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.AncestorModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntoMap;",
+            "import dagger.multibindings.StringKey;",
+            "import java.util.Map;",
+            "",
+            "@Module",
+            "class AncestorModule {",
+            "  @Provides",
+            "  @IntoMap",
+            "  @StringKey(\"ancestormodule\")",
+            "  static InEachSubcomponent provideInAncestor() {",
+            "    return new InEachSubcomponent();",
+            "  }",
+            "}"));
+    JavaFileObject generatedAncestor =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerAncestor",
+            "package test;",
+            "",
+            "import com.google.common.collect.ImmutableMap;",
+            "import java.util.Map;",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerAncestor implements Ancestor {",
+            "  protected DaggerAncestor() {}",
+            "",
+            "  public abstract class LeafImpl extends DaggerLeaf {",
+            "    protected LeafImpl() { super(); }",
+            "",
+            "    @Override",
+            "    public Map<String, InEachSubcomponent> contributionsInEachSubcomponent() {",
+            "      return ImmutableMap.<String, InEachSubcomponent>builderWithExpectedSize(2)",
+            "          .put(\"ancestormodule\",",
+            "              AncestorModule_ProvideInAncestorFactory.proxyProvideInAncestor())",
+            "          .putAll(super.contributionsInEachSubcomponent())",
+            "          .build();",
+            "    }",
+            "  }",
+            "}");
+    compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerAncestor")
+        .hasSourceEquivalentTo(generatedAncestor);
+  }
+
+  @Test
+  public void mapMultibindings_contributionsInLeafAndGrandAncestor() {
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
+    createAncillaryClasses(filesToCompile, "InLeafAndGrandAncestor");
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Leaf",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "import java.util.Map;",
+            "",
+            "@Subcomponent(modules = LeafModule.class)",
+            "interface Leaf {",
+            "  Map<String, InLeafAndGrandAncestor> contributionsInLeafAndGrandAncestor();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.LeafModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntoMap;",
+            "import dagger.multibindings.StringKey;",
+            "import java.util.Map;",
+            "",
+            "@Module",
+            "class LeafModule {",
+            "  @Provides",
+            "  @IntoMap",
+            "  @StringKey(\"leafmodule\")",
+            "  static InLeafAndGrandAncestor provideInLeaf() {",
+            "    return new InLeafAndGrandAncestor();",
+            "  }",
+            "}"));
+    JavaFileObject generatedLeaf =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerLeaf",
+            "package test;",
+            "",
+            "import com.google.common.collect.ImmutableMap;",
+            "import java.util.Map;",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerLeaf implements Leaf {",
+            "  protected DaggerLeaf() {}",
+            "",
+            "  @Override",
+            "  public Map<String, InLeafAndGrandAncestor> contributionsInLeafAndGrandAncestor() {",
+            "    return ImmutableMap.<String, InLeafAndGrandAncestor>of(",
+            "        \"leafmodule\", LeafModule_ProvideInLeafFactory.proxyProvideInLeaf());",
+            "  }",
+            "}");
+    Compilation compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerLeaf")
+        .hasSourceEquivalentTo(generatedLeaf);
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Ancestor",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent",
+            "interface Ancestor {",
+            "  Leaf leaf();",
+            "}"));
+    JavaFileObject generatedAncestor =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerAncestor",
+            "package test;",
+            "",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerAncestor implements Ancestor {",
+            "  protected DaggerAncestor() {}",
+            "",
+            "  public abstract class LeafImpl extends DaggerLeaf {",
+            "    protected LeafImpl() { super(); }",
+            "  }",
+            "}");
+    compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerAncestor")
+        .hasSourceEquivalentTo(generatedAncestor);
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.GrandAncestor",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = GrandAncestorModule.class)",
+            "interface GrandAncestor {",
+            "  Ancestor ancestor();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.GrandAncestorModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntoMap;",
+            "import dagger.multibindings.StringKey;",
+            "import java.util.Map;",
+            "",
+            "@Module",
+            "class GrandAncestorModule {",
+            "  @Provides",
+            "  @IntoMap",
+            "  @StringKey(\"grandancestormodule\")",
+            "  static InLeafAndGrandAncestor provideInGrandAncestor() {",
+            "    return new InLeafAndGrandAncestor();",
+            "  }",
+            "}"));
+    JavaFileObject generatedGrandAncestor =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerGrandAncestor",
+            "package test;",
+            "",
+            "import com.google.common.collect.ImmutableMap;",
+            "import java.util.Map;",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerGrandAncestor implements GrandAncestor {",
+            "  protected DaggerGrandAncestor() {}",
+            "",
+            "  public abstract class AncestorImpl extends DaggerAncestor {",
+            "    protected AncestorImpl() { super(); }",
+            "",
+            "    public abstract class LeafImpl extends DaggerAncestor.LeafImpl {",
+            "      protected LeafImpl() { super(); }",
+            "",
+            "      @Override",
+            "      public Map<String, InLeafAndGrandAncestor>",
+            "          contributionsInLeafAndGrandAncestor() {",
+            "        return",
+            "            ImmutableMap.<String, InLeafAndGrandAncestor>builderWithExpectedSize(2)",
+            "                .put(\"grandancestormodule\",",
+            "                    GrandAncestorModule_ProvideInGrandAncestorFactory",
+            "                        .proxyProvideInGrandAncestor())",
+            "                .putAll(super.contributionsInLeafAndGrandAncestor())",
+            "                .build();",
+            "      }",
+            "    }",
+            "  }",
+            "}");
+    compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerGrandAncestor")
+        .hasSourceEquivalentTo(generatedGrandAncestor);
+  }
+
+  @Test
+  public void mapMultibindings_contributionsInLeafAndAncestorWithoutGuava() {
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
+    createAncillaryClasses(filesToCompile, "InEachSubcomponent");
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Leaf",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "import java.util.Map;",
+            "",
+            "@Subcomponent(modules = LeafModule.class)",
+            "interface Leaf {",
+            "  Map<String, InEachSubcomponent> contributionsInEachSubcomponent();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.LeafModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntoMap;",
+            "import dagger.multibindings.StringKey;",
+            "import java.util.Map;",
+            "",
+            "@Module",
+            "class LeafModule {",
+            "  @Provides",
+            "  @IntoMap",
+            "  @StringKey(\"leafmodule\")",
+            "  static InEachSubcomponent provideInLeaf() {",
+            "    return new InEachSubcomponent();",
+            "  }",
+            "}"));
+    JavaFileObject generatedLeaf =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerLeaf",
+            "package test;",
+            "",
+            "import java.util.Collections;",
+            "import java.util.Map",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerLeaf implements Leaf {",
+            "  protected DaggerLeaf() {}",
+            "",
+            "  @Override",
+            "  public Map<String, InEachSubcomponent> contributionsInEachSubcomponent() {",
+            "    return Collections.<String, InEachSubcomponent>singletonMap(",
+            "        \"leafmodule\", LeafModule_ProvideInLeafFactory.proxyProvideInLeaf());",
+            "  }",
+            "}");
+    Compilation compilation = compileWithoutGuava(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerLeaf")
+        .hasSourceEquivalentTo(generatedLeaf);
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Ancestor",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = AncestorModule.class)",
+            "interface Ancestor {",
+            "  Leaf leaf();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.AncestorModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntoMap;",
+            "import dagger.multibindings.StringKey;",
+            "import java.util.Map;",
+            "",
+            "@Module",
+            "class AncestorModule {",
+            "  @Provides",
+            "  @IntoMap",
+            "  @StringKey(\"ancestormodule\")",
+            "  static InEachSubcomponent provideInAncestor() {",
+            "    return new InEachSubcomponent();",
+            "  }",
+            "}"));
+    JavaFileObject generatedAncestor =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerAncestor",
+            "package test;",
+            "",
+            "import dagger.internal.MapBuilder;",
+            "import java.util.Map;",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerAncestor implements Ancestor {",
+            "  protected DaggerAncestor() {}",
+            "",
+            "  public abstract class LeafImpl extends DaggerLeaf {",
+            "    protected LeafImpl() {",
+            "      super();",
+            "    }",
+            "",
+            "    @Override",
+            "    public Map<String, InEachSubcomponent> contributionsInEachSubcomponent() {",
+            "      return MapBuilder.<String, InEachSubcomponent>newMapBuilder(2)",
+            "          .put(\"ancestormodule\",",
+            "              AncestorModule_ProvideInAncestorFactory.proxyProvideInAncestor())",
+            "          .putAll(super.contributionsInEachSubcomponent())",
+            "          .build();",
+            "    }",
+            "  }",
+            "}");
+    compilation = compileWithoutGuava(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerAncestor")
+        .hasSourceEquivalentTo(generatedAncestor);
+  }
+
+  @Test
+  public void provisionOverInjection_providedInAncestor() {
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.ProvidedInAncestor",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class ProvidedInAncestor {",
+            "  @Inject",
+            "  ProvidedInAncestor(String string) {}",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.Leaf",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent",
+            "interface Leaf {",
+            "  ProvidedInAncestor injectedInLeaf();",
+            "}"));
+    JavaFileObject generatedLeaf =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerLeaf",
+            "package test;",
+            "",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerLeaf implements Leaf {",
+            "  protected DaggerLeaf() {}",
+            "",
+            "  @Override",
+            "  public ProvidedInAncestor injectedInLeaf() {",
+            "    return new ProvidedInAncestor(getString());",
+            "  }",
+            "",
+            "  public abstract String getString();",
+            "}");
+    Compilation compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerLeaf")
+        .hasSourceEquivalentTo(generatedLeaf);
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Ancestor",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = AncestorModule.class)",
+            "interface Ancestor {",
+            "  Leaf leaf();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.AncestorModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "class AncestorModule {",
+            "  @Provides",
+            "  static ProvidedInAncestor provideProvidedInAncestor() {",
+            "    return new ProvidedInAncestor(\"static\");",
+            "  }",
+            "}"));
+    JavaFileObject generatedAncestor =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerAncestor",
+            "package test;",
+            "",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerAncestor implements Ancestor {",
+            "  protected DaggerAncestor() {}",
+            "",
+            "  public abstract class LeafImpl extends DaggerLeaf {",
+            "    protected LeafImpl() { super(); }",
+            "",
+            "    @Override",
+            "    public ProvidedInAncestor injectedInLeaf() {",
+            "      return AncestorModule_ProvideProvidedInAncestorFactory",
+            "          .proxyProvideProvidedInAncestor();",
+            "    }",
+            "  }",
+            "}");
+    compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerAncestor")
+        .hasSourceEquivalentTo(generatedAncestor);
+  }
+
+  @Test
+  public void provisionOverInjection_providedInGrandAncestor() {
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.ProvidedInGrandAncestor",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class ProvidedInGrandAncestor {",
+            "  @Inject",
+            "  ProvidedInGrandAncestor(String string) {}",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.Leaf",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent",
+            "interface Leaf {",
+            "  ProvidedInGrandAncestor injectedInLeaf();",
+            "}"));
+    JavaFileObject generatedLeaf =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerLeaf",
+            "package test;",
+            "",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerLeaf implements Leaf {",
+            "  protected DaggerLeaf() {}",
+            "",
+            "  @Override",
+            "  public ProvidedInGrandAncestor injectedInLeaf() {",
+            "    return new ProvidedInGrandAncestor(getString());",
+            "  }",
+            "",
+            "  public abstract String getString();",
+            "}");
+    Compilation compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerLeaf")
+        .hasSourceEquivalentTo(generatedLeaf);
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Ancestor",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent",
+            "interface Ancestor {",
+            "  Leaf leaf();",
+            "}"));
+    JavaFileObject generatedAncestor =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerAncestor",
+            "package test;",
+            "",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerAncestor implements Ancestor {",
+            "  protected DaggerAncestor() {}",
+            "",
+            "  public abstract class LeafImpl extends DaggerLeaf {",
+            "    protected LeafImpl() { super(); }",
+            "  }",
+            "}");
+    compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerAncestor")
+        .hasSourceEquivalentTo(generatedAncestor);
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.GrandAncestor",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = GrandAncestorModule.class)",
+            "interface GrandAncestor {",
+            "  Ancestor ancestor();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.GrandAncestorModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "class GrandAncestorModule {",
+            "  @Provides",
+            "  static ProvidedInGrandAncestor provideProvidedInGrandAncestor() {",
+            "    return new ProvidedInGrandAncestor(\"static\");",
+            "  }",
+            "}"));
+    JavaFileObject generatedGrandAncestor =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerGrandAncestor",
+            "package test;",
+            "",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerGrandAncestor implements GrandAncestor {",
+            "  protected DaggerGrandAncestor() {}",
+            "",
+            "  public abstract class AncestorImpl extends DaggerAncestor {",
+            "    protected AncestorImpl() { super(); }",
+            "",
+            "    public abstract class LeafImpl extends DaggerAncestor.LeafImpl {",
+            "      protected LeafImpl() { super(); }",
+            "",
+            "      @Override",
+            "      public ProvidedInGrandAncestor injectedInLeaf() {",
+            "        return GrandAncestorModule_ProvideProvidedInGrandAncestorFactory",
+            "            .proxyProvideProvidedInGrandAncestor();",
+            "      }",
+            "    }",
+            "  }",
+            "}");
+    compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerGrandAncestor")
+        .hasSourceEquivalentTo(generatedGrandAncestor);
+  }
+
+  @Test
+  public void provisionOverInjection_indirectDependency() {
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.ProvidedInAncestor",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class ProvidedInAncestor {",
+            "  @Inject",
+            "  ProvidedInAncestor(String string) {}",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.InjectedInLeaf",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class InjectedInLeaf {",
+            "  @Inject",
+            "  InjectedInLeaf(ProvidedInAncestor providedInAncestor) {}",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.Leaf",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent",
+            "interface Leaf {",
+            "  InjectedInLeaf injectedInLeaf();",
+            "}"));
+    JavaFileObject generatedLeaf =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerLeaf",
+            "package test;",
+            "",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerLeaf implements Leaf {",
+            "  protected DaggerLeaf() {}",
+            "",
+            "  @Override",
+            "  public InjectedInLeaf injectedInLeaf() {",
+            "    return new InjectedInLeaf(getProvidedInAncestor());",
+            "  }",
+            "",
+            "  public abstract String getString();",
+            "",
+            "  public ProvidedInAncestor getProvidedInAncestor() {",
+            "    return new ProvidedInAncestor(getString());",
+            "  }",
+            "}");
+    Compilation compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerLeaf")
+        .hasSourceEquivalentTo(generatedLeaf);
+
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.Ancestor",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = AncestorModule.class)",
+            "interface Ancestor {",
+            "  Leaf leaf();",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.AncestorModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "class AncestorModule {",
+            "  @Provides",
+            "  static ProvidedInAncestor provideProvidedInAncestor() {",
+            "    return new ProvidedInAncestor(\"static\");",
+            "  }",
+            "}"));
+    JavaFileObject generatedAncestor =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerAncestor",
+            "package test;",
+            "",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerAncestor implements Ancestor {",
+            "  protected DaggerAncestor() {}",
+            "",
+            "  public abstract class LeafImpl extends DaggerLeaf {",
+            "    protected LeafImpl() {",
+            "      super();",
+            "    }",
+            "",
+            "    @Override",
+            "    public ProvidedInAncestor getProvidedInAncestor() {",
+            "      return AncestorModule_ProvideProvidedInAncestorFactory",
+            "          .proxyProvideProvidedInAncestor();",
+            "    }",
+            "}");
+    compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerAncestor")
+        .hasSourceEquivalentTo(generatedAncestor);
+  }
+
+  private void createAncillaryClasses(
+      ImmutableList.Builder<JavaFileObject> filesBuilder, String... ancillaryClasses) {
+    for (String className : ancillaryClasses) {
+      filesBuilder.add(
+          JavaFileObjects.forSourceLines(
+              String.format("test.%s", className),
+              "package test;",
+              "",
+              String.format("class %s { }", className)));
+    }
+  }
+
+  private static Compilation compile(Iterable<JavaFileObject> files) {
+    return daggerCompiler()
+        .withOptions(AHEAD_OF_TIME_SUBCOMPONENTS_MODE.javacopts())
+        .compile(files);
+  }
+
+  private static Compilation compile(JavaFileObject... files) {
+    return daggerCompiler()
+        .withOptions(AHEAD_OF_TIME_SUBCOMPONENTS_MODE.javacopts())
+        .compile(files);
+  }
+
+  private static Compilation compileWithoutGuava(Iterable<JavaFileObject> files) {
+    return daggerCompiler()
+        .withOptions(
+            AHEAD_OF_TIME_SUBCOMPONENTS_MODE.javacopts().append(CLASS_PATH_WITHOUT_GUAVA_OPTION))
+        .compile(files);
+  }
+}
diff --git a/javatests/dagger/internal/codegen/BUILD b/javatests/dagger/internal/codegen/BUILD
index 19b68e8e5..dd7598e96 100644
--- a/javatests/dagger/internal/codegen/BUILD
+++ b/javatests/dagger/internal/codegen/BUILD
@@ -29,7 +29,7 @@ GenJavaTests(
         "//java/dagger:core",
         "//java/dagger/internal/codegen:base",
         "//java/dagger/internal/codegen:binding",
-        "//java/dagger/internal/codegen:internal_validation",
+        "//java/dagger/internal/codegen:binding_graph_validation",
         "//java/dagger/internal/codegen:processor",
         "//java/dagger/internal/codegen:validation",
         "//java/dagger/internal/codegen:writing",
@@ -37,15 +37,16 @@ GenJavaTests(
         "//java/dagger/model/testing",
         "//java/dagger/producers",
         "//java/dagger/spi",
-        "//third_party:auto_common",
-        "//third_party:auto_value",
-        "//third_party:compile_testing",
-        "//third_party:guava",
-        "//third_party:javapoet",
-        "//third_party:jsr250_annotations",
-        "//third_party:jsr330_inject",
-        "//third_party:junit",
-        "//third_party:mockito",
-        "//third_party:truth",
+        "@com_google_auto_value_auto_value//jar",  # For AutoAnnotationProcessor
+        "@google_bazel_common//third_party/java/auto:common",
+        "@google_bazel_common//third_party/java/auto:value",
+        "@google_bazel_common//third_party/java/compile_testing",
+        "@google_bazel_common//third_party/java/guava",
+        "@google_bazel_common//third_party/java/javapoet",
+        "@google_bazel_common//third_party/java/jsr250_annotations",
+        "@google_bazel_common//third_party/java/jsr330_inject",
+        "@google_bazel_common//third_party/java/junit",
+        "@google_bazel_common//third_party/java/mockito",
+        "@google_bazel_common//third_party/java/truth",
     ],
 )
diff --git a/javatests/dagger/internal/codegen/BindingGraphCapturer.java b/javatests/dagger/internal/codegen/BindingGraphCapturer.java
index b06b504b0..503fd47f4 100644
--- a/javatests/dagger/internal/codegen/BindingGraphCapturer.java
+++ b/javatests/dagger/internal/codegen/BindingGraphCapturer.java
@@ -32,7 +32,14 @@
 
   @Override
   public void visitGraph(BindingGraph bindingGraph, DiagnosticReporter diagnosticReporter) {
-    bindingGraphs.put(bindingGraph.rootComponentNode().toString(), bindingGraph);
+    bindingGraphs.put(
+        bindingGraph
+            .rootComponentNode()
+            .componentPath()
+            .currentComponent()
+            .getQualifiedName()
+            .toString(),
+        bindingGraph);
   }
 
   /** Returns a map of binding graphs, indexed by the canonical name of the root component type. */
diff --git a/javatests/dagger/internal/codegen/BindsMethodValidatorTest.java b/javatests/dagger/internal/codegen/BindsMethodValidationTest.java
similarity index 90%
rename from javatests/dagger/internal/codegen/BindsMethodValidatorTest.java
rename to javatests/dagger/internal/codegen/BindsMethodValidationTest.java
index 07c07859e..c3de6c0cf 100644
--- a/javatests/dagger/internal/codegen/BindsMethodValidatorTest.java
+++ b/javatests/dagger/internal/codegen/BindsMethodValidationTest.java
@@ -37,7 +37,7 @@
 import org.junit.runners.Parameterized.Parameters;
 
 @RunWith(Parameterized.class)
-public class BindsMethodValidatorTest {
+public class BindsMethodValidationTest {
   @Parameters
   public static Collection<Object[]> data() {
     return ImmutableList.copyOf(new Object[][] {{Module.class}, {ProducerModule.class}});
@@ -45,7 +45,7 @@
 
   private final String moduleDeclaration;
 
-  public BindsMethodValidatorTest(Class<? extends Annotation> moduleAnnotation) {
+  public BindsMethodValidationTest(Class<? extends Annotation> moduleAnnotation) {
     moduleDeclaration = "@" + moduleAnnotation.getCanonicalName() + " abstract class %s { %s }";
   }
 
@@ -59,7 +59,7 @@ public void nonAbstract() {
   public void notAssignable() {
     assertThatMethod("@Binds abstract String notAssignable(Object impl);").hasError("assignable");
   }
-  
+
   @Test
   public void moreThanOneParameter() {
     assertThatMethod("@Binds abstract Object tooManyParameters(String s1, String s2);")
@@ -92,13 +92,21 @@ public void returnsVoid() {
   }
 
   @Test
-  public void tooManyQualifiers() {
+  public void tooManyQualifiersOnMethod() {
     assertThatMethod(
             "@Binds @Qualifier1 @Qualifier2 abstract String tooManyQualifiers(String impl);")
         .importing(Qualifier1.class, Qualifier2.class)
         .hasError("more than one @Qualifier");
   }
 
+  @Test
+  public void tooManyQualifiersOnParameter() {
+    assertThatMethod(
+            "@Binds abstract String tooManyQualifiers(@Qualifier1 @Qualifier2 String impl);")
+        .importing(Qualifier1.class, Qualifier2.class)
+        .hasError("more than one @Qualifier");
+  }
+
   @Test
   public void noParameters() {
     assertThatMethod("@Binds abstract Object noParameters();").hasError("one parameter");
@@ -126,7 +134,7 @@ public void elementsIntoSet_withRawSets() {
   @Test
   public void intoMap_noMapKey() {
     assertThatMethod("@Binds @IntoMap abstract Object bindNoMapKey(String string);")
-         .hasError("methods of type map must declare a map key");
+        .hasError("methods of type map must declare a map key");
   }
 
   @Test
diff --git a/javatests/dagger/internal/codegen/BindsMissingDelegateValidationTest.java b/javatests/dagger/internal/codegen/BindsMissingDelegateValidationTest.java
new file mode 100644
index 000000000..28b75beaf
--- /dev/null
+++ b/javatests/dagger/internal/codegen/BindsMissingDelegateValidationTest.java
@@ -0,0 +1,216 @@
+/*
+ * Copyright (C) 2014 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static dagger.internal.codegen.Compilers.daggerCompiler;
+import static dagger.internal.codegen.TestUtils.message;
+
+import com.google.testing.compile.Compilation;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/**
+ * Tests that errors are reported correctly when a {@code @Binds} method's delegate (the type of its
+ * parameter) is missing.
+ */
+@RunWith(JUnit4.class)
+public class BindsMissingDelegateValidationTest {
+  @Test
+  public void bindsMissingDelegate() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.C",
+            "package test;",
+            "",
+            "import dagger.Binds;",
+            "import dagger.Component;",
+            "import dagger.Module;",
+            "",
+            "@Component(modules = C.TestModule.class)",
+            "interface C {",
+            "  Object object();",
+            "",
+            "  static class NotBound {}",
+            "",
+            "  @Module",
+            "  abstract static class TestModule {",
+            "    @Binds abstract Object bindObject(NotBound notBound);",
+            "  }",
+            "}");
+
+    Compilation compilation = daggerCompiler().compile(component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("test.C.NotBound cannot be provided")
+        .inFile(component)
+        .onLineContaining("interface C");
+  }
+
+  @Test
+  public void bindsMissingDelegate_duplicateBinding() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.C",
+            "package test;",
+            "",
+            "import dagger.Binds;",
+            "import dagger.Component;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Component(modules = C.TestModule.class)",
+            "interface C {",
+            "  Object object();",
+            "",
+            "  static class NotBound {}",
+            "",
+            "  @Module",
+            "  abstract static class TestModule {",
+            "    @Binds abstract Object bindObject(NotBound notBound);",
+            "    @Provides static Object provideObject() { return new Object(); }",
+            "  }",
+            "}");
+
+    Compilation compilation = daggerCompiler().compile(component);
+    assertThat(compilation).failed();
+    // Some javacs report only the first error for each source line.
+    // Assert that one of the expected errors is reported.
+    assertThat(compilation)
+        .hadErrorContainingMatch(
+            "\\Qtest.C.NotBound cannot be provided\\E|"
+                + message(
+                    "\\Qjava.lang.Object is bound multiple times:",
+                    "    @Binds Object test.C.TestModule.bindObject(test.C.NotBound)",
+                    "    @Provides Object test.C.TestModule.provideObject()\\E"))
+        .inFile(component)
+        .onLineContaining("interface C");
+  }
+
+  @Test
+  public void bindsMissingDelegate_setBinding() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.C",
+            "package test;",
+            "",
+            "import dagger.Binds;",
+            "import dagger.Component;",
+            "import dagger.Module;",
+            "import dagger.multibindings.IntoSet;",
+            "import java.util.Set;",
+            "",
+            "@Component(modules = C.TestModule.class)",
+            "interface C {",
+            "  Set<Object> objects();",
+            "",
+            "  static class NotBound {}",
+            "",
+            "  @Module",
+            "  abstract static class TestModule {",
+            "    @Binds @IntoSet abstract Object bindObject(NotBound notBound);",
+            "  }",
+            "}");
+
+    Compilation compilation = daggerCompiler().compile(component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("test.C.NotBound cannot be provided")
+        .inFile(component)
+        .onLineContaining("interface C");
+  }
+
+  @Test
+  public void bindsMissingDelegate_mapBinding() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.C",
+            "package test;",
+            "",
+            "import dagger.Binds;",
+            "import dagger.Component;",
+            "import dagger.Module;",
+            "import dagger.multibindings.IntoMap;",
+            "import dagger.multibindings.StringKey;",
+            "import java.util.Map;",
+            "",
+            "@Component(modules = C.TestModule.class)",
+            "interface C {",
+            "  Map<String, Object> objects();",
+            "",
+            "  static class NotBound {}",
+            "",
+            "  @Module",
+            "  abstract static class TestModule {",
+            "    @Binds @IntoMap @StringKey(\"key\")",
+            "    abstract Object bindObject(NotBound notBound);",
+            "  }",
+            "}");
+
+    Compilation compilation = daggerCompiler().compile(component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("test.C.NotBound cannot be provided")
+        .inFile(component)
+        .onLineContaining("interface C");
+  }
+
+  @Test
+  public void bindsMissingDelegate_mapBinding_sameKey() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.C",
+            "package test;",
+            "",
+            "import dagger.Binds;",
+            "import dagger.Component;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntoMap;",
+            "import dagger.multibindings.StringKey;",
+            "import java.util.Map;",
+            "",
+            "@Component(modules = C.TestModule.class)",
+            "interface C {",
+            "  Map<String, Object> objects();",
+            "",
+            "  static class NotBound {}",
+            "",
+            "  @Module",
+            "  abstract static class TestModule {",
+            "    @Binds @IntoMap @StringKey(\"key\")",
+            "    abstract Object bindObject(NotBound notBound);",
+            "",
+            "    @Provides @IntoMap @StringKey(\"key\")",
+            "    static Object provideObject() { return new Object(); }",
+            "  }",
+            "}");
+
+    Compilation compilation = daggerCompiler().compile(component);
+    assertThat(compilation).failed();
+    // Some javacs report only the first error for each source line.
+    assertThat(compilation)
+        .hadErrorContainingMatch(
+            "\\Qtest.C.NotBound cannot be provided\\E|"
+                + "\\Qsame map key is bound more than once\\E")
+        .inFile(component)
+        .onLineContaining("interface C");
+  }
+}
diff --git a/javatests/dagger/internal/codegen/BindsOptionalOfMethodValidatorTest.java b/javatests/dagger/internal/codegen/BindsOptionalOfMethodValidationTest.java
similarity index 91%
rename from javatests/dagger/internal/codegen/BindsOptionalOfMethodValidatorTest.java
rename to javatests/dagger/internal/codegen/BindsOptionalOfMethodValidationTest.java
index 9f48dd308..c268fa0ac 100644
--- a/javatests/dagger/internal/codegen/BindsOptionalOfMethodValidatorTest.java
+++ b/javatests/dagger/internal/codegen/BindsOptionalOfMethodValidationTest.java
@@ -26,6 +26,7 @@
 import java.util.Collection;
 import javax.inject.Inject;
 import javax.inject.Qualifier;
+import javax.inject.Singleton;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
@@ -33,7 +34,7 @@
 
 /** Tests {@link BindsOptionalOfMethodValidator}. */
 @RunWith(Parameterized.class)
-public class BindsOptionalOfMethodValidatorTest {
+public class BindsOptionalOfMethodValidationTest {
   @Parameters(name = "{0}")
   public static Collection<Object[]> data() {
     return ImmutableList.copyOf(new Object[][] {{Module.class}, {ProducerModule.class}});
@@ -41,7 +42,7 @@
 
   private final String moduleDeclaration;
 
-  public BindsOptionalOfMethodValidatorTest(Class<? extends Annotation> moduleAnnotation) {
+  public BindsOptionalOfMethodValidationTest(Class<? extends Annotation> moduleAnnotation) {
     moduleDeclaration = "@" + moduleAnnotation.getCanonicalName() + " abstract class %s { %s }";
   }
 
@@ -124,6 +125,13 @@ public void implicitlyProvidedType() {
         .hasError("return unqualified types that have an @Inject-annotated constructor");
   }
 
+  @Test
+  public void hasScope() {
+    assertThatMethod("@BindsOptionalOf @Singleton abstract String scoped();")
+        .importing(Singleton.class)
+        .hasError("cannot be scoped");
+  }
+
   private DaggerModuleMethodSubject assertThatMethod(String method) {
     return assertThatModuleMethod(method).withDeclaration(moduleDeclaration);
   }
diff --git a/javatests/dagger/internal/codegen/CanReleaseReferencesValidatorTest.java b/javatests/dagger/internal/codegen/CanReleaseReferencesValidationTest.java
similarity index 96%
rename from javatests/dagger/internal/codegen/CanReleaseReferencesValidatorTest.java
rename to javatests/dagger/internal/codegen/CanReleaseReferencesValidationTest.java
index 00e9bb2cb..fda3a04c0 100644
--- a/javatests/dagger/internal/codegen/CanReleaseReferencesValidatorTest.java
+++ b/javatests/dagger/internal/codegen/CanReleaseReferencesValidationTest.java
@@ -28,7 +28,7 @@
 
 /** Tests for {@link CanReleaseReferencesValidator}. */
 @RunWith(JUnit4.class)
-public final class CanReleaseReferencesValidatorTest {
+public final class CanReleaseReferencesValidationTest {
   @Test
   public void annotatesSourceRetainedAnnotation() {
     JavaFileObject annotation =
diff --git a/javatests/dagger/internal/codegen/CompilerMode.java b/javatests/dagger/internal/codegen/CompilerMode.java
index 33aaff116..4dcc21548 100644
--- a/javatests/dagger/internal/codegen/CompilerMode.java
+++ b/javatests/dagger/internal/codegen/CompilerMode.java
@@ -22,14 +22,13 @@
 /** The configuration options for compiler modes. */
 enum CompilerMode {
   DEFAULT_MODE,
-  EXPERIMENTAL_ANDROID_MODE("-Adagger.experimentalAndroidMode=enabled");
+  FAST_INIT_MODE("-Adagger.fastInit=enabled"),
+  AHEAD_OF_TIME_SUBCOMPONENTS_MODE("-Adagger.experimentalAheadOfTimeSubcomponents=enabled");
 
   /** Returns the compiler modes as a list of parameters for parameterized tests */
   static final ImmutableList<Object[]> TEST_PARAMETERS =
       ImmutableList.copyOf(
-          new Object[][] {
-            {CompilerMode.DEFAULT_MODE}, {CompilerMode.EXPERIMENTAL_ANDROID_MODE},
-          });
+          new Object[][] {{CompilerMode.DEFAULT_MODE}, {CompilerMode.FAST_INIT_MODE}});
 
   private final ImmutableList<String> javacopts;
 
diff --git a/javatests/dagger/internal/codegen/ComponentBuilderTest.java b/javatests/dagger/internal/codegen/ComponentBuilderTest.java
index e5bc11202..d04c359a7 100644
--- a/javatests/dagger/internal/codegen/ComponentBuilderTest.java
+++ b/javatests/dagger/internal/codegen/ComponentBuilderTest.java
@@ -616,6 +616,36 @@ public void testBuilderBuildReturnsWrongTypeFails() {
         .onLineContaining("String build();");
   }
 
+  @Test
+  public void builderMethodTakesPrimitive() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface TestComponent {",
+            "  Object object();",
+            "",
+            "  @Component.Builder",
+            "  interface Builder {",
+            "    Builder primitive(long l);",
+            "    TestComponent build();",
+            "  }",
+            "}");
+    Compilation compilation =
+        daggerCompiler().withOptions(compilerMode.javacopts()).compile(component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            "@Component.Builder methods that are not annotated with @BindsInstance must take "
+                + "either a module or a component dependency, not a primitive")
+        .inFile(component)
+        .onLineContaining("primitive(long l);");
+  }
+
   @Test
   public void testInheritedBuilderBuildReturnsWrongTypeFails() {
     JavaFileObject componentFile =
diff --git a/javatests/dagger/internal/codegen/ComponentHierarchyValidatorTest.java b/javatests/dagger/internal/codegen/ComponentHierarchyValidationTest.java
similarity index 98%
rename from javatests/dagger/internal/codegen/ComponentHierarchyValidatorTest.java
rename to javatests/dagger/internal/codegen/ComponentHierarchyValidationTest.java
index 6fbdbd3bd..757d5d7cc 100644
--- a/javatests/dagger/internal/codegen/ComponentHierarchyValidatorTest.java
+++ b/javatests/dagger/internal/codegen/ComponentHierarchyValidationTest.java
@@ -28,7 +28,7 @@
 
 /** Tests for {ComponentHierarchyValidator}. */
 @RunWith(JUnit4.class)
-public class ComponentHierarchyValidatorTest {
+public class ComponentHierarchyValidationTest {
   @Test
   public void singletonSubcomponent() {
     JavaFileObject component =
@@ -67,7 +67,7 @@ public void singletonSubcomponent() {
             .compile(component, subcomponent);
     assertThat(withoutScopeValidation).succeeded();
   }
-  
+
   @Test
   public void productionComponents_productionScopeImplicitOnBoth() {
     JavaFileObject component =
diff --git a/javatests/dagger/internal/codegen/ComponentProcessorTest.java b/javatests/dagger/internal/codegen/ComponentProcessorTest.java
index 45b14c379..43603c3e8 100644
--- a/javatests/dagger/internal/codegen/ComponentProcessorTest.java
+++ b/javatests/dagger/internal/codegen/ComponentProcessorTest.java
@@ -19,7 +19,7 @@
 import static com.google.testing.compile.CompilationSubject.assertThat;
 import static com.google.testing.compile.Compiler.javac;
 import static dagger.internal.codegen.CompilerMode.DEFAULT_MODE;
-import static dagger.internal.codegen.CompilerMode.EXPERIMENTAL_ANDROID_MODE;
+import static dagger.internal.codegen.CompilerMode.FAST_INIT_MODE;
 import static dagger.internal.codegen.Compilers.daggerCompiler;
 import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
 import static dagger.internal.codegen.GeneratedLines.IMPORT_GENERATED_ANNOTATION;
@@ -193,7 +193,7 @@ public ComponentProcessorTest(CompilerMode compilerMode) {
                 GENERATED_ANNOTATION,
                 "public final class DaggerSimpleComponent implements SimpleComponent {")
             .addLinesIn(
-                EXPERIMENTAL_ANDROID_MODE,
+                FAST_INIT_MODE,
                 "  private volatile Provider<SomeInjectableType> someInjectableTypeProvider;")
             .addLines(
                 "  private DaggerSimpleComponent(Builder builder) {}",
@@ -217,7 +217,7 @@ public ComponentProcessorTest(CompilerMode compilerMode) {
                 DEFAULT_MODE, //
                 "    return DoubleCheck.lazy(SomeInjectableType_Factory.create());")
             .addLinesIn(
-                EXPERIMENTAL_ANDROID_MODE,
+                FAST_INIT_MODE,
                 "    return DoubleCheck.lazy(someInjectableTypeProvider());")
             .addLines(
                 "  }",
@@ -228,7 +228,7 @@ public ComponentProcessorTest(CompilerMode compilerMode) {
                 DEFAULT_MODE, //
                 "    return SomeInjectableType_Factory.create();")
             .addLinesIn(
-                EXPERIMENTAL_ANDROID_MODE, //
+                FAST_INIT_MODE, //
                 "    Object local = someInjectableTypeProvider;",
                 "    if (local == null) {",
                 "      local = new SwitchingProvider<>(0);",
@@ -246,7 +246,7 @@ public ComponentProcessorTest(CompilerMode compilerMode) {
                 "    }",
                 "  }")
             .addLinesIn(
-                EXPERIMENTAL_ANDROID_MODE,
+                FAST_INIT_MODE,
                 "  private final class SwitchingProvider<T> implements Provider<T> {",
                 "    private final int id;",
                 "",
@@ -310,7 +310,7 @@ public ComponentProcessorTest(CompilerMode compilerMode) {
                 GENERATED_ANNOTATION,
                 "public final class DaggerSimpleComponent implements SimpleComponent {")
             .addLinesIn(
-                EXPERIMENTAL_ANDROID_MODE,
+                FAST_INIT_MODE,
                 "  private volatile Object someInjectableType = new MemoizedSentinel();",
                 "  private volatile Provider<SomeInjectableType> someInjectableTypeProvider;")
             .addLinesIn(
@@ -327,7 +327,7 @@ public ComponentProcessorTest(CompilerMode compilerMode) {
                 "  @Override", //
                 "  public SomeInjectableType someInjectableType() {")
             .addLinesIn(
-                EXPERIMENTAL_ANDROID_MODE,
+                FAST_INIT_MODE,
                 "    Object local = someInjectableType;",
                 "    if (local instanceof MemoizedSentinel) {",
                 "      synchronized (local) {",
@@ -352,7 +352,7 @@ public ComponentProcessorTest(CompilerMode compilerMode) {
                 DEFAULT_MODE, //
                 "    return DoubleCheck.lazy(someInjectableTypeProvider);")
             .addLinesIn(
-                EXPERIMENTAL_ANDROID_MODE,
+                FAST_INIT_MODE,
                 "    return DoubleCheck.lazy(someInjectableTypeProvider());")
             .addLines(
                 "  }",
@@ -360,7 +360,7 @@ public ComponentProcessorTest(CompilerMode compilerMode) {
                 "  @Override",
                 "  public Provider<SomeInjectableType> someInjectableTypeProvider() {")
             .addLinesIn(
-                EXPERIMENTAL_ANDROID_MODE, //
+                FAST_INIT_MODE, //
                 "    Object local = someInjectableTypeProvider;",
                 "    if (local == null) {",
                 "      local = new SwitchingProvider<>(0);",
@@ -373,7 +373,7 @@ public ComponentProcessorTest(CompilerMode compilerMode) {
             .addLines( //
                 "  }")
             .addLinesIn(
-                EXPERIMENTAL_ANDROID_MODE,
+                FAST_INIT_MODE,
                 "  private final class SwitchingProvider<T> implements Provider<T> {",
                 "    private final int id;",
                 "",
@@ -1209,7 +1209,7 @@ public void testDefaultPackage() {
                 DEFAULT_MODE,
                 "  private test_AComponent_a aProvider;")
             .addLinesIn(
-                EXPERIMENTAL_ANDROID_MODE,
+                FAST_INIT_MODE,
                 "  private volatile Provider<A> aProvider;",
                 "  private AComponent aComponent;",
                 "",
@@ -1228,7 +1228,7 @@ public void testDefaultPackage() {
                 DEFAULT_MODE,
                 "    this.aProvider = new test_AComponent_a(builder.aComponent);")
             .addLinesIn(
-                EXPERIMENTAL_ANDROID_MODE,
+                FAST_INIT_MODE,
                 "    this.aComponent = builder.aComponent;")
             .addLines(
                 "  }",
@@ -1239,7 +1239,7 @@ public void testDefaultPackage() {
                 DEFAULT_MODE,
                 "    return new B(aProvider);")
             .addLinesIn(
-                EXPERIMENTAL_ANDROID_MODE,
+                FAST_INIT_MODE,
                 "    return new B(getAProvider());")
             .addLines(
                 "  }",
@@ -1277,7 +1277,7 @@ public void testDefaultPackage() {
                 "  }",
                 "}")
             .addLinesIn(
-                EXPERIMENTAL_ANDROID_MODE,
+                FAST_INIT_MODE,
                 "  private final class SwitchingProvider<T> implements Provider<T> {",
                 "    @SuppressWarnings(\"unchecked\")",
                 "    @Override",
@@ -2184,7 +2184,7 @@ public void bindsToDuplicateBinding_bindsKeyIsNotDuplicated() {
     assertThat(compilation)
         .hadErrorContaining("java.lang.String is bound multiple times")
         .inFile(component)
-        .onLineContaining("Object notDuplicated();");
+        .onLineContaining("interface TestComponent");
   }
 
   @Test
diff --git a/javatests/dagger/internal/codegen/ComponentRequirementFieldTest.java b/javatests/dagger/internal/codegen/ComponentRequirementFieldTest.java
index 962e5e11d..8148f4ccd 100644
--- a/javatests/dagger/internal/codegen/ComponentRequirementFieldTest.java
+++ b/javatests/dagger/internal/codegen/ComponentRequirementFieldTest.java
@@ -363,7 +363,7 @@ public void componentRequirementNeededInFactoryCreationOfSubcomponent() {
             "}");
     JavaFileObject generatedComponent;
     switch (compilerMode) {
-      case EXPERIMENTAL_ANDROID_MODE:
+      case FAST_INIT_MODE:
         generatedComponent =
             JavaFileObjects.forSourceLines(
                 "test.DaggerTestComponent",
diff --git a/javatests/dagger/internal/codegen/ComponentValidationTest.java b/javatests/dagger/internal/codegen/ComponentValidationTest.java
index 5a84052b9..2208b4a18 100644
--- a/javatests/dagger/internal/codegen/ComponentValidationTest.java
+++ b/javatests/dagger/internal/codegen/ComponentValidationTest.java
@@ -18,6 +18,7 @@
 
 import static com.google.testing.compile.CompilationSubject.assertThat;
 import static dagger.internal.codegen.Compilers.daggerCompiler;
+import static dagger.internal.codegen.TestUtils.message;
 
 import com.google.testing.compile.Compilation;
 import com.google.testing.compile.JavaFileObjects;
@@ -201,4 +202,158 @@ public void moduleInDependencies() {
         .hadErrorContaining("test.TestModule is a module, which cannot be a component dependency");
   }
 
+  @Test
+  public void componentDependencyMustNotCycle_Direct() {
+    JavaFileObject shortLifetime =
+        JavaFileObjects.forSourceLines(
+            "test.ComponentShort",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(dependencies = ComponentShort.class)",
+            "interface ComponentShort {",
+            "}");
+
+    Compilation compilation = daggerCompiler().compile(shortLifetime);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "test.ComponentShort contains a cycle in its component dependencies:",
+                "    test.ComponentShort"));
+  }
+
+  @Test
+  public void componentDependencyMustNotCycle_Indirect() {
+    JavaFileObject longLifetime =
+        JavaFileObjects.forSourceLines(
+            "test.ComponentLong",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(dependencies = ComponentMedium.class)",
+            "interface ComponentLong {",
+            "}");
+    JavaFileObject mediumLifetime =
+        JavaFileObjects.forSourceLines(
+            "test.ComponentMedium",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(dependencies = ComponentLong.class)",
+            "interface ComponentMedium {",
+            "}");
+    JavaFileObject shortLifetime =
+        JavaFileObjects.forSourceLines(
+            "test.ComponentShort",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(dependencies = ComponentMedium.class)",
+            "interface ComponentShort {",
+            "}");
+
+    Compilation compilation = daggerCompiler().compile(longLifetime, mediumLifetime, shortLifetime);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "test.ComponentLong contains a cycle in its component dependencies:",
+                "    test.ComponentLong",
+                "    test.ComponentMedium",
+                "    test.ComponentLong"))
+        .inFile(longLifetime);
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "test.ComponentMedium contains a cycle in its component dependencies:",
+                "    test.ComponentMedium",
+                "    test.ComponentLong",
+                "    test.ComponentMedium"))
+        .inFile(mediumLifetime);
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "test.ComponentShort contains a cycle in its component dependencies:",
+                "    test.ComponentMedium",
+                "    test.ComponentLong",
+                "    test.ComponentMedium",
+                "    test.ComponentShort"))
+        .inFile(shortLifetime);
+  }
+
+  @Test
+  public void abstractModuleWithInstanceMethod() {
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "abstract class TestModule {",
+            "  @Provides int i() { return 1; }",
+            "}");
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = TestModule.class)",
+            "interface TestComponent {",
+            "  int i();",
+            "}");
+    Compilation compilation = daggerCompiler().compile(module, component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("TestModule is abstract and has instance @Provides methods")
+        .inFile(component)
+        .onLineContaining("interface TestComponent");
+  }
+
+  @Test
+  public void abstractModuleWithInstanceMethod_subclassedIsAllowed() {
+    JavaFileObject abstractModule =
+        JavaFileObjects.forSourceLines(
+            "test.AbstractModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "abstract class AbstractModule {",
+            "  @Provides int i() { return 1; }",
+            "}");
+    JavaFileObject subclassedModule =
+        JavaFileObjects.forSourceLines(
+            "test.SubclassedModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "",
+            "@Module",
+            "class SubclassedModule extends AbstractModule {}");
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = SubclassedModule.class)",
+            "interface TestComponent {",
+            "  int i();",
+            "}");
+    Compilation compilation = daggerCompiler().compile(abstractModule, subclassedModule, component);
+    assertThat(compilation).succeeded();
+  }
 }
diff --git a/javatests/dagger/internal/codegen/ConflictingEntryPointsTest.java b/javatests/dagger/internal/codegen/ConflictingEntryPointsTest.java
new file mode 100644
index 000000000..7ffd922a3
--- /dev/null
+++ b/javatests/dagger/internal/codegen/ConflictingEntryPointsTest.java
@@ -0,0 +1,262 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static dagger.internal.codegen.Compilers.daggerCompiler;
+import static dagger.internal.codegen.TestUtils.message;
+
+import com.google.testing.compile.Compilation;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public final class ConflictingEntryPointsTest {
+
+  @Test
+  public void covariantType() {
+    JavaFileObject base1 =
+        JavaFileObjects.forSourceLines(
+            "test.Base1", //
+            "package test;",
+            "",
+            "interface Base1 {",
+            "  Long foo();",
+            "}");
+    JavaFileObject base2 =
+        JavaFileObjects.forSourceLines(
+            "test.Base2", //
+            "package test;",
+            "",
+            "interface Base2 {",
+            "  Number foo();",
+            "}");
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.BindsInstance;",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface TestComponent extends Base1, Base2 {",
+            "",
+            "  @Component.Builder",
+            "  interface Builder {",
+            "    @BindsInstance Builder foo(Long foo);",
+            "    @BindsInstance Builder foo(Number foo);",
+            "    TestComponent build();",
+            "  }",
+            "}");
+    Compilation compilation = daggerCompiler().compile(base1, base2, component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "conflicting entry point declarations:",
+                "    Long test.Base1.foo()",
+                "    Number test.Base2.foo()"))
+        .inFile(component)
+        .onLineContaining("interface TestComponent ");
+  }
+
+  @Test
+  public void covariantTypeFromGenericSupertypes() {
+    JavaFileObject base1 =
+        JavaFileObjects.forSourceLines(
+            "test.Base1", //
+            "package test;",
+            "",
+            "interface Base1<T> {",
+            "  T foo();",
+            "}");
+    JavaFileObject base2 =
+        JavaFileObjects.forSourceLines(
+            "test.Base2", //
+            "package test;",
+            "",
+            "interface Base2<T> {",
+            "  T foo();",
+            "}");
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.BindsInstance;",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface TestComponent extends Base1<Long>, Base2<Number> {",
+            "",
+            "  @Component.Builder",
+            "  interface Builder {",
+            "    @BindsInstance Builder foo(Long foo);",
+            "    @BindsInstance Builder foo(Number foo);",
+            "    TestComponent build();",
+            "  }",
+            "}");
+    Compilation compilation = daggerCompiler().compile(base1, base2, component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "conflicting entry point declarations:",
+                "    Long test.Base1.foo()",
+                "    Number test.Base2.foo()"))
+        .inFile(component)
+        .onLineContaining("interface TestComponent ");
+  }
+
+  @Test
+  public void differentQualifier() {
+    JavaFileObject base1 =
+        JavaFileObjects.forSourceLines(
+            "test.Base1", //
+            "package test;",
+            "",
+            "interface Base1 {",
+            "  Object foo();",
+            "}");
+    JavaFileObject base2 =
+        JavaFileObjects.forSourceLines(
+            "test.Base2", //
+            "package test;",
+            "",
+            "import javax.inject.Named;",
+            "",
+            "interface Base2 {",
+            "  @Named(\"foo\") Object foo();",
+            "}");
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.BindsInstance;",
+            "import dagger.Component;",
+            "import javax.inject.Named;",
+            "",
+            "@Component",
+            "interface TestComponent extends Base1, Base2 {",
+            "",
+            "  @Component.Builder",
+            "  interface Builder {",
+            "    @BindsInstance Builder foo(Object foo);",
+            "    @BindsInstance Builder namedFoo(@Named(\"foo\") Object foo);",
+            "    TestComponent build();",
+            "  }",
+            "}");
+    Compilation compilation = daggerCompiler().compile(base1, base2, component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "conflicting entry point declarations:",
+                "    Object test.Base1.foo()",
+                "    @Named(\"foo\") Object test.Base2.foo()"))
+        .inFile(component)
+        .onLineContaining("interface TestComponent ");
+  }
+
+  @Test
+  public void sameKey() {
+    JavaFileObject base1 =
+        JavaFileObjects.forSourceLines(
+            "test.Base1", //
+            "package test;",
+            "",
+            "interface Base1 {",
+            "  Object foo();",
+            "}");
+    JavaFileObject base2 =
+        JavaFileObjects.forSourceLines(
+            "test.Base2", //
+            "package test;",
+            "",
+            "interface Base2 {",
+            "  Object foo();",
+            "}");
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.BindsInstance;",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface TestComponent extends Base1, Base2 {",
+            "",
+            "  @Component.Builder",
+            "  interface Builder {",
+            "    @BindsInstance Builder foo(Object foo);",
+            "    TestComponent build();",
+            "  }",
+            "}");
+    Compilation compilation = daggerCompiler().compile(base1, base2, component);
+    assertThat(compilation).succeeded();
+  }
+
+  @Test
+  public void sameQualifiedKey() {
+    JavaFileObject base1 =
+        JavaFileObjects.forSourceLines(
+            "test.Base1", //
+            "package test;",
+            "",
+            "import javax.inject.Named;",
+            "",
+            "interface Base1 {",
+            "  @Named(\"foo\") Object foo();",
+            "}");
+    JavaFileObject base2 =
+        JavaFileObjects.forSourceLines(
+            "test.Base2", //
+            "package test;",
+            "",
+            "import javax.inject.Named;",
+            "",
+            "interface Base2 {",
+            "  @Named(\"foo\") Object foo();",
+            "}");
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.BindsInstance;",
+            "import dagger.Component;",
+            "import javax.inject.Named;",
+            "",
+            "@Component",
+            "interface TestComponent extends Base1, Base2 {",
+            "",
+            "  @Component.Builder",
+            "  interface Builder {",
+            "    @BindsInstance Builder foo(@Named(\"foo\") Object foo);",
+            "    TestComponent build();",
+            "  }",
+            "}");
+    Compilation compilation = daggerCompiler().compile(base1, base2, component);
+    assertThat(compilation).succeeded();
+  }
+}
diff --git a/javatests/dagger/internal/codegen/DelegateBindingExpressionTest.java b/javatests/dagger/internal/codegen/DelegateBindingExpressionTest.java
index 8ed23d776..15260e76c 100644
--- a/javatests/dagger/internal/codegen/DelegateBindingExpressionTest.java
+++ b/javatests/dagger/internal/codegen/DelegateBindingExpressionTest.java
@@ -18,7 +18,7 @@
 
 import static com.google.testing.compile.CompilationSubject.assertThat;
 import static dagger.internal.codegen.CompilerMode.DEFAULT_MODE;
-import static dagger.internal.codegen.CompilerMode.EXPERIMENTAL_ANDROID_MODE;
+import static dagger.internal.codegen.CompilerMode.FAST_INIT_MODE;
 import static dagger.internal.codegen.Compilers.daggerCompiler;
 import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
 
@@ -177,7 +177,7 @@ public void toDoubleCheck() {
                     GENERATED_ANNOTATION,
                     "public final class DaggerTestComponent implements TestComponent {")
                 .addLinesIn(
-                    EXPERIMENTAL_ANDROID_MODE,
+                    FAST_INIT_MODE,
                     "  private volatile Object regularScoped = new MemoizedSentinel();",
                     "  private volatile ReusableScoped reusableScoped;",
                     "",
@@ -275,7 +275,7 @@ public void toSingleCheck() {
                     GENERATED_ANNOTATION,
                     "public final class DaggerTestComponent implements TestComponent {")
                 .addLinesIn(
-                    EXPERIMENTAL_ANDROID_MODE,
+                    FAST_INIT_MODE,
                     "  private volatile Object regularScoped = new MemoizedSentinel();",
                     "  private volatile ReusableScoped reusableScoped;",
                     "",
@@ -370,7 +370,7 @@ public void toReleasableCheck() {
                     GENERATED_ANNOTATION,
                     "public final class DaggerTestComponent implements TestComponent {")
                 .addLinesIn(
-                    EXPERIMENTAL_ANDROID_MODE,
+                    FAST_INIT_MODE,
                     "  private volatile Object regularScoped = new MemoizedSentinel();",
                     "  private volatile ReusableScoped reusableScoped;",
                     "  private volatile Provider<Unscoped> unscopedProvider;",
@@ -426,7 +426,7 @@ public void toReleasableCheck() {
                     "        ReferenceReleasingProvider.create(",
                     "            (Provider) Unscoped_Factory.create(), customScopeReferences);")
                 .addLinesIn(
-                    EXPERIMENTAL_ANDROID_MODE,
+                    FAST_INIT_MODE,
                     "    this.unscopedProvider2 =",
                     "        ReferenceReleasingProvider.create(",
                     "            (Provider) getUnscopedProvider(), customScopeReferences);")
@@ -440,7 +440,7 @@ public void toReleasableCheck() {
                     "        };",
                     "  }")
                 .addLinesIn(
-                    EXPERIMENTAL_ANDROID_MODE,
+                    FAST_INIT_MODE,
                     "  private final class SwitchingProvider<T> implements Provider<T> {",
                     "    @SuppressWarnings(\"unchecked\")",
                     "    @Override",
@@ -491,7 +491,7 @@ public void toUnscoped() {
                     GENERATED_ANNOTATION,
                     "public final class DaggerTestComponent implements TestComponent {")
                 .addLinesIn(
-                    EXPERIMENTAL_ANDROID_MODE,
+                    FAST_INIT_MODE,
                     "  private volatile Object regularScoped = new MemoizedSentinel();",
                     "  private volatile ReusableScoped reusableScoped;",
                     "",
@@ -619,7 +619,7 @@ public void castNeeded_rawTypes_Provider_get() {
                     "    return (Supertype) subtypeProvider.get();",
                     "  }")
                 .addLinesIn(
-                    EXPERIMENTAL_ANDROID_MODE,
+                    FAST_INIT_MODE,
                     "  private volatile Object subtype = new MemoizedSentinel();",
                     "",
                     "  private Object getSubtype() {",
@@ -725,7 +725,7 @@ public void noCast_rawTypes_Provider_get_toInaccessibleType() {
                     "  }",
                     "}")
                 .addLinesIn(
-                    EXPERIMENTAL_ANDROID_MODE,
+                    FAST_INIT_MODE,
                     "  private volatile Object subtype = new MemoizedSentinel();",
                     "",
                     "  private Object getSubtype() {",
@@ -817,7 +817,7 @@ public void castedToRawType() {
                     "  }",
                     "}")
                 .addLinesIn(
-                    EXPERIMENTAL_ANDROID_MODE,
+                    FAST_INIT_MODE,
                     "  private volatile Provider<String> provideStringProvider;",
                     "",
                     "  private Provider<String> getStringProvider() {",
@@ -918,7 +918,7 @@ public void doubleBinds() {
                     "  }",
                     "}")
                 .addLinesIn(
-                    EXPERIMENTAL_ANDROID_MODE,
+                    FAST_INIT_MODE,
                     "  private volatile Provider<String> provideStringProvider;",
                     "",
                     "  private Provider<String> getStringProvider() {",
@@ -1021,7 +1021,7 @@ public void inlineFactoryOfInacessibleType() {
                     "  }",
                     "}")
                 .addLinesIn(
-                    EXPERIMENTAL_ANDROID_MODE,
+                    FAST_INIT_MODE,
                     "  private volatile Provider subtypeProvider;",
                     "",
                     "  private Provider getSubtypeProvider() {",
@@ -1124,7 +1124,7 @@ public void providerWhenBindsScopeGreaterThanDependencyScope() {
                     "  }",
                     "}")
                 .addLinesIn(
-                    EXPERIMENTAL_ANDROID_MODE,
+                    FAST_INIT_MODE,
                     "  private volatile Provider<Object> bindStringProvider;",
                     "  private volatile Object object = new MemoizedSentinel();",
                     "  private volatile String string;",
diff --git a/javatests/dagger/internal/codegen/DependencyCycleValidationTest.java b/javatests/dagger/internal/codegen/DependencyCycleValidationTest.java
new file mode 100644
index 000000000..9fcaeacf7
--- /dev/null
+++ b/javatests/dagger/internal/codegen/DependencyCycleValidationTest.java
@@ -0,0 +1,651 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static dagger.internal.codegen.Compilers.daggerCompiler;
+import static dagger.internal.codegen.TestUtils.message;
+
+import com.google.testing.compile.Compilation;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public class DependencyCycleValidationTest {
+  @Test public void cyclicDependency() {
+    JavaFileObject component = JavaFileObjects.forSourceLines("test.Outer",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import javax.inject.Inject;",
+        "",
+        "final class Outer {",
+        "  static class A {",
+        "    @Inject A(C cParam) {}",
+        "  }",
+        "",
+        "  static class B {",
+        "    @Inject B(A aParam) {}",
+        "  }",
+        "",
+        "  static class C {",
+        "    @Inject C(B bParam) {}",
+        "  }",
+        "",
+        "  @Component()",
+        "  interface CComponent {",
+        "    C getC();",
+        "  }",
+        "}");
+
+    Compilation compilation = daggerCompiler().compile(component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "Found a dependency cycle:",
+                "    test.Outer.C is injected at",
+                "        test.Outer.A.<init>(cParam)",
+                "    test.Outer.A is injected at",
+                "        test.Outer.B.<init>(aParam)",
+                "    test.Outer.B is injected at",
+                "        test.Outer.C.<init>(bParam)",
+                "    test.Outer.C is provided at",
+                "        test.Outer.CComponent.getC()"))
+        .inFile(component)
+        .onLineContaining("interface CComponent");
+  }
+
+  @Test public void cyclicDependencyNotIncludingEntryPoint() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.Outer",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import javax.inject.Inject;",
+            "",
+            "final class Outer {",
+            "  static class A {",
+            "    @Inject A(C cParam) {}",
+            "  }",
+            "",
+            "  static class B {",
+            "    @Inject B(A aParam) {}",
+            "  }",
+            "",
+            "  static class C {",
+            "    @Inject C(B bParam) {}",
+            "  }",
+            "",
+            "  static class D {",
+            "    @Inject D(C cParam) {}",
+            "  }",
+            "",
+            "  @Component()",
+            "  interface DComponent {",
+            "    D getD();",
+            "  }",
+            "}");
+
+    Compilation compilation = daggerCompiler().compile(component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "Found a dependency cycle:",
+                "    test.Outer.C is injected at",
+                "        test.Outer.A.<init>(cParam)",
+                "    test.Outer.A is injected at",
+                "        test.Outer.B.<init>(aParam)",
+                "    test.Outer.B is injected at",
+                "        test.Outer.C.<init>(bParam)",
+                "    test.Outer.C is injected at",
+                "        test.Outer.D.<init>(cParam)",
+                "    test.Outer.D is provided at",
+                "        test.Outer.DComponent.getD()"))
+        .inFile(component)
+        .onLineContaining("interface DComponent");
+  }
+
+  @Test
+  public void cyclicDependencyNotBrokenByMapBinding() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.Outer",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntoMap;",
+            "import dagger.multibindings.StringKey;",
+            "import java.util.Map;",
+            "import javax.inject.Inject;",
+            "",
+            "final class Outer {",
+            "  static class A {",
+            "    @Inject A(Map<String, C> cMap) {}",
+            "  }",
+            "",
+            "  static class B {",
+            "    @Inject B(A aParam) {}",
+            "  }",
+            "",
+            "  static class C {",
+            "    @Inject C(B bParam) {}",
+            "  }",
+            "",
+            "  @Component(modules = CModule.class)",
+            "  interface CComponent {",
+            "    C getC();",
+            "  }",
+            "",
+            "  @Module",
+            "  static class CModule {",
+            "    @Provides @IntoMap",
+            "    @StringKey(\"C\")",
+            "    static C c(C c) {",
+            "      return c;",
+            "    }",
+            "  }",
+            "}");
+
+    Compilation compilation = daggerCompiler().compile(component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "Found a dependency cycle:",
+                "    test.Outer.C is injected at",
+                "        test.Outer.CModule.c(c)",
+                "    java.util.Map<java.lang.String,test.Outer.C> is injected at",
+                "        test.Outer.A.<init>(cMap)",
+                "    test.Outer.A is injected at",
+                "        test.Outer.B.<init>(aParam)",
+                "    test.Outer.B is injected at",
+                "        test.Outer.C.<init>(bParam)",
+                "    test.Outer.C is provided at",
+                "        test.Outer.CComponent.getC()"))
+        .inFile(component)
+        .onLineContaining("interface CComponent");
+  }
+
+  @Test
+  public void cyclicDependencyWithSetBinding() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.Outer",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntoSet;",
+            "import java.util.Set;",
+            "import javax.inject.Inject;",
+            "",
+            "final class Outer {",
+            "  static class A {",
+            "    @Inject A(Set<C> cSet) {}",
+            "  }",
+            "",
+            "  static class B {",
+            "    @Inject B(A aParam) {}",
+            "  }",
+            "",
+            "  static class C {",
+            "    @Inject C(B bParam) {}",
+            "  }",
+            "",
+            "  @Component(modules = CModule.class)",
+            "  interface CComponent {",
+            "    C getC();",
+            "  }",
+            "",
+            "  @Module",
+            "  static class CModule {",
+            "    @Provides @IntoSet",
+            "    static C c(C c) {",
+            "      return c;",
+            "    }",
+            "  }",
+            "}");
+
+    Compilation compilation = daggerCompiler().compile(component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "Found a dependency cycle:",
+                "    test.Outer.C is injected at",
+                "        test.Outer.CModule.c(c)",
+                "    java.util.Set<test.Outer.C> is injected at",
+                "        test.Outer.A.<init>(cSet)",
+                "    test.Outer.A is injected at",
+                "        test.Outer.B.<init>(aParam)",
+                "    test.Outer.B is injected at",
+                "        test.Outer.C.<init>(bParam)",
+                "    test.Outer.C is provided at",
+                "        test.Outer.CComponent.getC()"))
+        .inFile(component)
+        .onLineContaining("interface CComponent");
+  }
+
+  @Test
+  public void falsePositiveCyclicDependencyIndirectionDetected() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.Outer",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import javax.inject.Inject;",
+            "import javax.inject.Provider;",
+            "",
+            "final class Outer {",
+            "  static class A {",
+            "    @Inject A(C cParam) {}",
+            "  }",
+            "",
+            "  static class B {",
+            "    @Inject B(A aParam) {}",
+            "  }",
+            "",
+            "  static class C {",
+            "    @Inject C(B bParam) {}",
+            "  }",
+            "",
+            "  static class D {",
+            "    @Inject D(Provider<C> cParam) {}",
+            "  }",
+            "",
+            "  @Component()",
+            "  interface DComponent {",
+            "    D getD();",
+            "  }",
+            "}");
+
+    Compilation compilation = daggerCompiler().compile(component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "Found a dependency cycle:",
+                "    test.Outer.C is injected at",
+                "        test.Outer.A.<init>(cParam)",
+                "    test.Outer.A is injected at",
+                "        test.Outer.B.<init>(aParam)",
+                "    test.Outer.B is injected at",
+                "        test.Outer.C.<init>(bParam)",
+                "    javax.inject.Provider<test.Outer.C> is injected at",
+                "        test.Outer.D.<init>(cParam)",
+                "    test.Outer.D is provided at",
+                "        test.Outer.DComponent.getD()"))
+        .inFile(component)
+        .onLineContaining("interface DComponent");
+  }
+
+  @Test
+  public void cyclicDependencyInSubcomponents() {
+    JavaFileObject parent =
+        JavaFileObjects.forSourceLines(
+            "test.Parent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface Parent {",
+            "  Child.Builder child();",
+            "}");
+    JavaFileObject child =
+        JavaFileObjects.forSourceLines(
+            "test.Child",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = CycleModule.class)",
+            "interface Child {",
+            "  Grandchild.Builder grandchild();",
+            "",
+            "  @Subcomponent.Builder",
+            "  interface Builder {",
+            "    Child build();",
+            "  }",
+            "}");
+    JavaFileObject grandchild =
+        JavaFileObjects.forSourceLines(
+            "test.Grandchild",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent",
+            "interface Grandchild {",
+            "  String entry();",
+            "",
+            "  @Subcomponent.Builder",
+            "  interface Builder {",
+            "    Grandchild build();",
+            "  }",
+            "}");
+    JavaFileObject cycleModule =
+        JavaFileObjects.forSourceLines(
+            "test.CycleModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "abstract class CycleModule {",
+            "  @Provides static Object object(String string) {",
+            "    return string;",
+            "  }",
+            "",
+            "  @Provides static String string(Object object) {",
+            "    return object.toString();",
+            "  }",
+            "}");
+
+    Compilation compilation = daggerCompiler().compile(parent, child, grandchild, cycleModule);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "Found a dependency cycle:",
+                "    java.lang.String is injected at",
+                "        test.CycleModule.object(string)",
+                "    java.lang.Object is injected at",
+                "        test.CycleModule.string(object)",
+                "    java.lang.String is provided at",
+                "        test.Grandchild.entry()"))
+        .inFile(parent)
+        .onLineContaining("interface Parent");
+  }
+
+  @Test
+  public void cyclicDependencyInSubcomponentsWithChildren() {
+    JavaFileObject parent =
+        JavaFileObjects.forSourceLines(
+            "test.Parent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface Parent {",
+            "  Child.Builder child();",
+            "}");
+    JavaFileObject child =
+        JavaFileObjects.forSourceLines(
+            "test.Child",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = CycleModule.class)",
+            "interface Child {",
+            "  String entry();",
+            "",
+            "  Grandchild grandchild();",
+            "",
+            "  @Subcomponent.Builder",
+            "  interface Builder {",
+            "    Child build();",
+            "  }",
+            "}");
+    // Grandchild has no entry point that depends on the cycle. http://b/111317986
+    JavaFileObject grandchild =
+        JavaFileObjects.forSourceLines(
+            "test.Grandchild",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent",
+            "interface Grandchild {",
+            "",
+            "  @Subcomponent.Builder",
+            "  interface Builder {",
+            "    Grandchild build();",
+            "  }",
+            "}");
+    JavaFileObject cycleModule =
+        JavaFileObjects.forSourceLines(
+            "test.CycleModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "abstract class CycleModule {",
+            "  @Provides static Object object(String string) {",
+            "    return string;",
+            "  }",
+            "",
+            "  @Provides static String string(Object object) {",
+            "    return object.toString();",
+            "  }",
+            "}");
+
+    Compilation compilation = daggerCompiler().compile(parent, child, grandchild, cycleModule);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "Found a dependency cycle:",
+                "    java.lang.String is injected at",
+                "        test.CycleModule.object(string)",
+                "    java.lang.Object is injected at",
+                "        test.CycleModule.string(object)",
+                "    java.lang.String is provided at",
+                "        test.Child.entry() [test.Parent → test.Child]"))
+        .inFile(parent)
+        .onLineContaining("interface Parent");
+  }
+
+  @Test
+  public void circularBindsMethods() {
+    JavaFileObject qualifier =
+        JavaFileObjects.forSourceLines(
+            "test.SomeQualifier",
+            "package test;",
+            "",
+            "import javax.inject.Qualifier;",
+            "",
+            "@Qualifier @interface SomeQualifier {}");
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Binds;",
+            "import dagger.Module;",
+            "",
+            "@Module",
+            "abstract class TestModule {",
+            "  @Binds abstract Object bindUnqualified(@SomeQualifier Object qualified);",
+            "  @Binds @SomeQualifier abstract Object bindQualified(Object unqualified);",
+            "}");
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = TestModule.class)",
+            "interface TestComponent {",
+            "  Object unqualified();",
+            "}");
+
+    Compilation compilation = daggerCompiler().compile(qualifier, module, component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "Found a dependency cycle:",
+                "    java.lang.Object is injected at",
+                "        test.TestModule.bindQualified(unqualified)",
+                "    @test.SomeQualifier java.lang.Object is injected at",
+                "        test.TestModule.bindUnqualified(qualified)",
+                "    java.lang.Object is provided at",
+                "        test.TestComponent.unqualified()"))
+        .inFile(component)
+        .onLineContaining("interface TestComponent");
+  }
+
+  @Test
+  public void selfReferentialBinds() {
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Binds;",
+            "import dagger.Module;",
+            "",
+            "@Module",
+            "abstract class TestModule {",
+            "  @Binds abstract Object bindToSelf(Object sameKey);",
+            "}");
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = TestModule.class)",
+            "interface TestComponent {",
+            "  Object selfReferential();",
+            "}");
+
+    Compilation compilation = daggerCompiler().compile(module, component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "Found a dependency cycle:",
+                "    java.lang.Object is injected at",
+                "        test.TestModule.bindToSelf(sameKey)",
+                "    java.lang.Object is provided at",
+                "        test.TestComponent.selfReferential()"))
+        .inFile(component)
+        .onLineContaining("interface TestComponent");
+  }
+
+  @Test
+  public void cycleFromMembersInjectionMethod_WithSameKeyAsMembersInjectionMethod() {
+    JavaFileObject a =
+        JavaFileObjects.forSourceLines(
+            "test.A",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class A {",
+            "  @Inject A() {}",
+            "  @Inject B b;",
+            "}");
+    JavaFileObject b =
+        JavaFileObjects.forSourceLines(
+            "test.B",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class B {",
+            "  @Inject B() {}",
+            "  @Inject A a;",
+            "}");
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.CycleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface CycleComponent {",
+            "  void inject(A a);",
+            "}");
+
+    Compilation compilation = daggerCompiler().compile(a, b, component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "Found a dependency cycle:",
+                "    test.B is injected at",
+                "        test.A.b",
+                "    test.A is injected at",
+                "        test.B.a",
+                "    test.B is injected at",
+                "        test.A.b",
+                "    test.A is injected at",
+                "        test.CycleComponent.inject(test.A)"))
+        .inFile(component)
+        .onLineContaining("interface CycleComponent");
+  }
+
+  @Test
+  public void longCycleMaskedByShortBrokenCycles() {
+    JavaFileObject cycles =
+        JavaFileObjects.forSourceLines(
+            "test.Cycles",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "import javax.inject.Provider;",
+            "import dagger.Component;",
+            "",
+            "final class Cycles {",
+            "  static class A {",
+            "    @Inject A(Provider<A> aProvider, B b) {}",
+            "  }",
+            "",
+            "  static class B {",
+            "    @Inject B(Provider<B> bProvider, A a) {}",
+            "  }",
+            "",
+            "  @Component",
+            "  interface C {",
+            "    A a();",
+            "  }",
+            "}");
+    Compilation compilation = daggerCompiler().compile(cycles);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("Found a dependency cycle:")
+        .inFile(cycles)
+        .onLineContaining("interface C");
+  }
+}
diff --git a/javatests/dagger/internal/codegen/DuplicateBindingsValidationTest.java b/javatests/dagger/internal/codegen/DuplicateBindingsValidationTest.java
new file mode 100644
index 000000000..232445785
--- /dev/null
+++ b/javatests/dagger/internal/codegen/DuplicateBindingsValidationTest.java
@@ -0,0 +1,757 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static com.google.testing.compile.Compiler.javac;
+import static dagger.internal.codegen.Compilers.daggerCompiler;
+import static dagger.internal.codegen.TestUtils.message;
+
+import com.google.testing.compile.Compilation;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public class DuplicateBindingsValidationTest {
+  @Test public void duplicateExplicitBindings_ProvidesAndComponentProvision() {
+    JavaFileObject component = JavaFileObjects.forSourceLines("test.Outer",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "final class Outer {",
+        "  interface A {}",
+        "",
+        "  interface B {}",
+        "",
+        "  @Module",
+        "  static class AModule {",
+        "    @Provides String provideString() { return \"\"; }",
+        "    @Provides A provideA(String s) { return new A() {}; }",
+        "  }",
+        "",
+        "  @Component(modules = AModule.class)",
+        "  interface Parent {",
+        "    A getA();",
+        "  }",
+        "",
+        "  @Module",
+        "  static class BModule {",
+        "    @Provides B provideB(A a) { return new B() {}; }",
+        "  }",
+        "",
+        "  @Component(dependencies = Parent.class, modules = { BModule.class, AModule.class})",
+        "  interface Child {",
+        "    B getB();",
+        "  }",
+        "}");
+
+    Compilation compilation = daggerCompiler().compile(component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "test.Outer.A is bound multiple times:",
+                "    @Provides test.Outer.A test.Outer.AModule.provideA(String)",
+                "    test.Outer.A test.Outer.Parent.getA()"))
+        .inFile(component)
+        .onLineContaining("interface Child");
+  }
+
+  @Test public void duplicateExplicitBindings_TwoProvidesMethods() {
+    JavaFileObject component = JavaFileObjects.forSourceLines("test.Outer",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import javax.inject.Inject;",
+        "",
+        "final class Outer {",
+        "  interface A {}",
+        "",
+        "  @Module",
+        "  static class Module1 {",
+        "    @Provides A provideA1() { return new A() {}; }",
+        "  }",
+        "",
+        "  @Module",
+        "  static class Module2 {",
+        "    @Provides String provideString() { return \"\"; }",
+        "    @Provides A provideA2(String s) { return new A() {}; }",
+        "  }",
+        "",
+        "  @Component(modules = { Module1.class, Module2.class})",
+        "  interface TestComponent {",
+        "    A getA();",
+        "  }",
+        "}");
+
+    Compilation compilation = daggerCompiler().compile(component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "test.Outer.A is bound multiple times:",
+                "    @Provides test.Outer.A test.Outer.Module1.provideA1()",
+                "    @Provides test.Outer.A test.Outer.Module2.provideA2(String)"))
+        .inFile(component)
+        .onLineContaining("interface TestComponent");
+  }
+
+  @Test
+  public void duplicateExplicitBindings_ProvidesVsBinds() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.Outer",
+            "package test;",
+            "",
+            "import dagger.Binds;",
+            "import dagger.Component;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import javax.inject.Inject;",
+            "",
+            "final class Outer {",
+            "  interface A {}",
+            "",
+            "  static final class B implements A {",
+            "    @Inject B() {}",
+            "  }",
+            "",
+            "  @Module",
+            "  static class Module1 {",
+            "    @Provides A provideA1() { return new A() {}; }",
+            "  }",
+            "",
+            "  @Module",
+            "  static abstract class Module2 {",
+            "    @Binds abstract A bindA2(B b);",
+            "  }",
+            "",
+            "  @Component(modules = { Module1.class, Module2.class})",
+            "  interface TestComponent {",
+            "    A getA();",
+            "  }",
+            "}");
+
+    Compilation compilation = daggerCompiler().compile(component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "test.Outer.A is bound multiple times:",
+                "    @Provides test.Outer.A test.Outer.Module1.provideA1()",
+                "    @Binds test.Outer.A test.Outer.Module2.bindA2(test.Outer.B)"))
+        .inFile(component)
+        .onLineContaining("interface TestComponent");
+  }
+
+  @Test
+  public void duplicateExplicitBindings_multibindingsAndExplicitSets() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.Outer",
+            "package test;",
+            "",
+            "import dagger.Binds;",
+            "import dagger.Component;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntoSet;",
+            "import java.util.HashSet;",
+            "import java.util.Set;",
+            "import javax.inject.Qualifier;",
+            "",
+            "final class Outer {",
+            "  @Qualifier @interface SomeQualifier {}",
+            "",
+            "  @Module",
+            "  abstract static class TestModule1 {",
+            "    @Provides @IntoSet static String stringSetElement() { return \"\"; }",
+            "",
+            "    @Binds",
+            "    @IntoSet abstract String bindStringSetElement(@SomeQualifier String value);",
+            "",
+            "    @Provides @SomeQualifier",
+            "    static String provideSomeQualifiedString() { return \"\"; }",
+            "  }",
+            "",
+            "  @Module",
+            "  static class TestModule2 {",
+            "    @Provides Set<String> stringSet() { return new HashSet<String>(); }",
+            "  }",
+            "",
+            "  @Component(modules = { TestModule1.class, TestModule2.class })",
+            "  interface TestComponent {",
+            "    Set<String> getStringSet();",
+            "  }",
+            "}");
+
+    Compilation compilation = daggerCompiler().compile(component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "java.util.Set<java.lang.String> has incompatible bindings or declarations:",
+                "    Set bindings and declarations:",
+                "        @Binds @dagger.multibindings.IntoSet String "
+                    + "test.Outer.TestModule1.bindStringSetElement(@test.Outer.SomeQualifier "
+                    + "String)",
+                "        @Provides @dagger.multibindings.IntoSet String "
+                    + "test.Outer.TestModule1.stringSetElement()",
+                "    Unique bindings and declarations:",
+                "        @Provides Set<String> test.Outer.TestModule2.stringSet()"))
+        .inFile(component)
+        .onLineContaining("interface TestComponent");
+  }
+
+  @Test
+  public void duplicateExplicitBindings_multibindingsAndExplicitMaps() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.Outer",
+            "package test;",
+            "",
+            "import dagger.Binds;",
+            "import dagger.Component;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntoMap;",
+            "import dagger.multibindings.StringKey;",
+            "import java.util.HashMap;",
+            "import java.util.Map;",
+            "import javax.inject.Qualifier;",
+            "",
+            "final class Outer {",
+            "  @Qualifier @interface SomeQualifier {}",
+            "",
+            "  @Module",
+            "  abstract static class TestModule1 {",
+            "    @Provides @IntoMap",
+            "    @StringKey(\"foo\")",
+            "    static String stringMapEntry() { return \"\"; }",
+            "",
+            "    @Binds @IntoMap @StringKey(\"bar\")",
+            "    abstract String bindStringMapEntry(@SomeQualifier String value);",
+            "",
+            "    @Provides @SomeQualifier",
+            "    static String provideSomeQualifiedString() { return \"\"; }",
+            "  }",
+            "",
+            "  @Module",
+            "  static class TestModule2 {",
+            "    @Provides Map<String, String> stringMap() {",
+            "      return new HashMap<String, String>();",
+            "    }",
+            "  }",
+            "",
+            "  @Component(modules = { TestModule1.class, TestModule2.class })",
+            "  interface TestComponent {",
+            "    Map<String, String> getStringMap();",
+            "  }",
+            "}");
+
+    Compilation compilation = daggerCompiler().compile(component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "java.util.Map<java.lang.String,java.lang.String> has incompatible bindings "
+                    + "or declarations:",
+                "    Map bindings and declarations:",
+                "        @Binds @dagger.multibindings.IntoMap "
+                    + "@dagger.multibindings.StringKey(\"bar\") String"
+                    + " test.Outer.TestModule1.bindStringMapEntry(@test.Outer.SomeQualifier "
+                    + "String)",
+                "        @Provides @dagger.multibindings.IntoMap "
+                    + "@dagger.multibindings.StringKey(\"foo\") String"
+                    + " test.Outer.TestModule1.stringMapEntry()",
+                "    Unique bindings and declarations:",
+                "        @Provides Map<String,String> test.Outer.TestModule2.stringMap()"))
+        .inFile(component)
+        .onLineContaining("interface TestComponent");
+  }
+
+  @Test
+  public void duplicateExplicitBindings_UniqueBindingAndMultibindingDeclaration_Set() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.Outer",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.Multibinds;",
+            "import java.util.HashSet;",
+            "import java.util.Set;",
+            "",
+            "final class Outer {",
+            "  @Module",
+            "  abstract static class TestModule1 {",
+            "    @Multibinds abstract Set<String> stringSet();",
+            "  }",
+            "",
+            "  @Module",
+            "  static class TestModule2 {",
+            "    @Provides Set<String> stringSet() { return new HashSet<String>(); }",
+            "  }",
+            "",
+            "  @Component(modules = { TestModule1.class, TestModule2.class })",
+            "  interface TestComponent {",
+            "    Set<String> getStringSet();",
+            "  }",
+            "}");
+
+    Compilation compilation = daggerCompiler().compile(component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "java.util.Set<java.lang.String> has incompatible bindings or declarations:",
+                "    Set bindings and declarations:",
+                "        @dagger.multibindings.Multibinds Set<String> "
+                    + "test.Outer.TestModule1.stringSet()",
+                "    Unique bindings and declarations:",
+                "        @Provides Set<String> test.Outer.TestModule2.stringSet()"))
+        .inFile(component)
+        .onLineContaining("interface TestComponent");
+  }
+
+  @Test
+  public void duplicateExplicitBindings_UniqueBindingAndMultibindingDeclaration_Map() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.Outer",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.Multibinds;",
+            "import java.util.HashMap;",
+            "import java.util.Map;",
+            "",
+            "final class Outer {",
+            "  @Module",
+            "  abstract static class TestModule1 {",
+            "    @Multibinds abstract Map<String, String> stringMap();",
+            "  }",
+            "",
+            "  @Module",
+            "  static class TestModule2 {",
+            "    @Provides Map<String, String> stringMap() {",
+            "      return new HashMap<String, String>();",
+            "    }",
+            "  }",
+            "",
+            "  @Component(modules = { TestModule1.class, TestModule2.class })",
+            "  interface TestComponent {",
+            "    Map<String, String> getStringMap();",
+            "  }",
+            "}");
+
+    Compilation compilation = daggerCompiler().compile(component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "java.util.Map<java.lang.String,java.lang.String> has incompatible bindings "
+                    + "or declarations:",
+                "    Map bindings and declarations:",
+                "        @dagger.multibindings.Multibinds Map<String,String> "
+                    + "test.Outer.TestModule1.stringMap()",
+                "    Unique bindings and declarations:",
+                "        @Provides Map<String,String> test.Outer.TestModule2.stringMap()"))
+        .inFile(component)
+        .onLineContaining("interface TestComponent");
+  }
+
+  @Test public void duplicateBindings_TruncateAfterLimit() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.Outer",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import javax.inject.Inject;",
+            "",
+            "final class Outer {",
+            "  interface A {}",
+            "",
+            "  @Module",
+            "  static class Module01 {",
+            "    @Provides A provideA() { return new A() {}; }",
+            "  }",
+            "",
+            "  @Module",
+            "  static class Module02 {",
+            "    @Provides A provideA() { return new A() {}; }",
+            "  }",
+            "",
+            "  @Module",
+            "  static class Module03 {",
+            "    @Provides A provideA() { return new A() {}; }",
+            "  }",
+            "",
+            "  @Module",
+            "  static class Module04 {",
+            "    @Provides A provideA() { return new A() {}; }",
+            "  }",
+            "",
+            "  @Module",
+            "  static class Module05 {",
+            "    @Provides A provideA() { return new A() {}; }",
+            "  }",
+            "",
+            "  @Module",
+            "  static class Module06 {",
+            "    @Provides A provideA() { return new A() {}; }",
+            "  }",
+            "",
+            "  @Module",
+            "  static class Module07 {",
+            "    @Provides A provideA() { return new A() {}; }",
+            "  }",
+            "",
+            "  @Module",
+            "  static class Module08 {",
+            "    @Provides A provideA() { return new A() {}; }",
+            "  }",
+            "",
+            "  @Module",
+            "  static class Module09 {",
+            "    @Provides A provideA() { return new A() {}; }",
+            "  }",
+            "",
+            "  @Module",
+            "  static class Module10 {",
+            "    @Provides A provideA() { return new A() {}; }",
+            "  }",
+            "",
+            "  @Module",
+            "  static class Module11 {",
+            "    @Provides A provideA() { return new A() {}; }",
+            "  }",
+            "",
+            "  @Module",
+            "  static class Module12 {",
+            "    @Provides A provideA() { return new A() {}; }",
+            "  }",
+            "",
+            "  @Component(modules = {",
+            "    Module01.class,",
+            "    Module02.class,",
+            "    Module03.class,",
+            "    Module04.class,",
+            "    Module05.class,",
+            "    Module06.class,",
+            "    Module07.class,",
+            "    Module08.class,",
+            "    Module09.class,",
+            "    Module10.class,",
+            "    Module11.class,",
+            "    Module12.class",
+            "  })",
+            "  interface TestComponent {",
+            "    A getA();",
+            "  }",
+            "}");
+
+    Compilation compilation = daggerCompiler().compile(component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "test.Outer.A is bound multiple times:",
+                "    @Provides test.Outer.A test.Outer.Module01.provideA()",
+                "    @Provides test.Outer.A test.Outer.Module02.provideA()",
+                "    @Provides test.Outer.A test.Outer.Module03.provideA()",
+                "    @Provides test.Outer.A test.Outer.Module04.provideA()",
+                "    @Provides test.Outer.A test.Outer.Module05.provideA()",
+                "    @Provides test.Outer.A test.Outer.Module06.provideA()",
+                "    @Provides test.Outer.A test.Outer.Module07.provideA()",
+                "    @Provides test.Outer.A test.Outer.Module08.provideA()",
+                "    @Provides test.Outer.A test.Outer.Module09.provideA()",
+                "    @Provides test.Outer.A test.Outer.Module10.provideA()",
+                "    and 2 others"))
+        .inFile(component)
+        .onLineContaining("interface TestComponent");
+  }
+
+  @Test
+  public void childBindingConflictsWithParent() {
+    JavaFileObject aComponent =
+        JavaFileObjects.forSourceLines(
+            "test.A",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Component(modules = A.AModule.class)",
+            "interface A {",
+            "  Object conflict();",
+            "",
+            "  B b();",
+            "",
+            "  @Module",
+            "  static class AModule {",
+            "    @Provides static Object abConflict() {",
+            "      return \"a\";",
+            "    }",
+            "  }",
+            "}");
+    JavaFileObject bComponent =
+        JavaFileObjects.forSourceLines(
+            "test.B",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = B.BModule.class)",
+            "interface B {",
+            "  Object conflict();",
+            "",
+            "  @Module",
+            "  static class BModule {",
+            "    @Provides static Object abConflict() {",
+            "      return \"b\";",
+            "    }",
+            "  }",
+            "}");
+
+    Compilation compilation = daggerCompiler().compile(aComponent, bComponent);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "java.lang.Object is bound multiple times:",
+                "    @Provides Object test.A.AModule.abConflict()",
+                "    @Provides Object test.B.BModule.abConflict()"))
+        .inFile(aComponent)
+        .onLineContaining("interface A {");
+  }
+
+  @Test
+  public void grandchildBindingConflictsWithGrandparent() {
+    JavaFileObject aComponent =
+        JavaFileObjects.forSourceLines(
+            "test.A",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Component(modules = A.AModule.class)",
+            "interface A {",
+            "  Object conflict();",
+            "",
+            "  B b();",
+            "",
+            "  @Module",
+            "  static class AModule {",
+            "    @Provides static Object acConflict() {",
+            "      return \"a\";",
+            "    }",
+            "  }",
+            "}");
+    JavaFileObject bComponent =
+        JavaFileObjects.forSourceLines(
+            "test.B",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent",
+            "interface B {",
+            "  C c();",
+            "}");
+    JavaFileObject cComponent =
+        JavaFileObjects.forSourceLines(
+            "test.C",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = C.CModule.class)",
+            "interface C {",
+            "  Object conflict();",
+            "",
+            "  @Module",
+            "  static class CModule {",
+            "    @Provides static Object acConflict() {",
+            "      return \"c\";",
+            "    }",
+            "  }",
+            "}");
+
+    Compilation compilation = daggerCompiler().compile(aComponent, bComponent, cComponent);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "java.lang.Object is bound multiple times:",
+                "    @Provides Object test.A.AModule.acConflict()",
+                "    @Provides Object test.C.CModule.acConflict()"))
+        .inFile(aComponent)
+        .onLineContaining("interface A {");
+  }
+
+  @Test
+  public void grandchildBindingConflictsWithChild() {
+    JavaFileObject aComponent =
+        JavaFileObjects.forSourceLines(
+            "test.A",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface A {",
+            "  B b();",
+            "}");
+    JavaFileObject bComponent =
+        JavaFileObjects.forSourceLines(
+            "test.B",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = B.BModule.class)",
+            "interface B {",
+            "  Object conflict();",
+            "",
+            "  C c();",
+            "",
+            "  @Module",
+            "  static class BModule {",
+            "    @Provides static Object bcConflict() {",
+            "      return \"b\";",
+            "    }",
+            "  }",
+            "}");
+    JavaFileObject cComponent =
+        JavaFileObjects.forSourceLines(
+            "test.C",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = C.CModule.class)",
+            "interface C {",
+            "  Object conflict();",
+            "",
+            "  @Module",
+            "  static class CModule {",
+            "    @Provides static Object bcConflict() {",
+            "      return \"c\";",
+            "    }",
+            "  }",
+            "}");
+
+    Compilation compilation = daggerCompiler().compile(aComponent, bComponent, cComponent);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "java.lang.Object is bound multiple times:",
+                "    @Provides Object test.B.BModule.bcConflict()",
+                "    @Provides Object test.C.CModule.bcConflict()"))
+        .inFile(aComponent)
+        .onLineContaining("interface A {");
+  }
+
+  @Test
+  public void grandchildBindingConflictsWithParentWithNullableViolationAsWarning() {
+    JavaFileObject parentConflictsWithChild =
+        JavaFileObjects.forSourceLines(
+            "test.ParentConflictsWithChild",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import javax.annotation.Nullable;",
+            "",
+            "@Component(modules = ParentConflictsWithChild.ParentModule.class)",
+            "interface ParentConflictsWithChild {",
+            "  Child child();",
+            "",
+            "  @Module",
+            "  static class ParentModule {",
+            "    @Provides @Nullable static Object nullableParentChildConflict() {",
+            "      return \"parent\";",
+            "    }",
+            "  }",
+            "}");
+    JavaFileObject child =
+        JavaFileObjects.forSourceLines(
+            "test.Child",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = Child.ChildModule.class)",
+            "interface Child {",
+            "  Object parentChildConflictThatViolatesNullability();",
+            "",
+            "  @Module",
+            "  static class ChildModule {",
+            "    @Provides static Object nonNullableParentChildConflict() {",
+            "      return \"child\";",
+            "    }",
+            "  }",
+            "}");
+
+    Compilation compilation =
+        javac()
+            .withOptions("-Adagger.nullableValidation=WARNING")
+            .withProcessors(new ComponentProcessor())
+            .compile(parentConflictsWithChild, child);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "java.lang.Object is bound multiple times:",
+                "    @Provides Object test.Child.ChildModule.nonNullableParentChildConflict()",
+                "    @Provides @javax.annotation.Nullable Object"
+                    + " test.ParentConflictsWithChild.ParentModule.nullableParentChildConflict()"))
+        .inFile(parentConflictsWithChild)
+        .onLine(9);
+  }
+}
diff --git a/javatests/dagger/internal/codegen/ElidedFactoriesTest.java b/javatests/dagger/internal/codegen/ElidedFactoriesTest.java
index 9de7df603..cae7c0506 100644
--- a/javatests/dagger/internal/codegen/ElidedFactoriesTest.java
+++ b/javatests/dagger/internal/codegen/ElidedFactoriesTest.java
@@ -174,7 +174,7 @@ public void simpleComponent_injectsProviderOf_dependsOnScoped() {
             "}");
     JavaFileObject generatedComponent;
     switch (compilerMode) {
-      case EXPERIMENTAL_ANDROID_MODE:
+      case FAST_INIT_MODE:
         generatedComponent =
             JavaFileObjects.forSourceLines(
                 "test.DaggerSimpleComponent",
@@ -368,7 +368,7 @@ public void scopedBinding_onlyUsedInSubcomponent() {
 
     JavaFileObject generatedComponent;
     switch (compilerMode) {
-      case EXPERIMENTAL_ANDROID_MODE:
+      case FAST_INIT_MODE:
         generatedComponent =
             JavaFileObjects.forSourceLines(
                 "test.DaggerSimpleComponent",
diff --git a/javatests/dagger/internal/codegen/ForReleasableReferencesValidatorTest.java b/javatests/dagger/internal/codegen/ForReleasableReferencesValidationTest.java
similarity index 98%
rename from javatests/dagger/internal/codegen/ForReleasableReferencesValidatorTest.java
rename to javatests/dagger/internal/codegen/ForReleasableReferencesValidationTest.java
index 8a529e91c..e15c6dbc1 100644
--- a/javatests/dagger/internal/codegen/ForReleasableReferencesValidatorTest.java
+++ b/javatests/dagger/internal/codegen/ForReleasableReferencesValidationTest.java
@@ -28,7 +28,7 @@
 
 /** Tests validation of {@code @ForReleasableRefernces}. */
 @RunWith(JUnit4.class)
-public class ForReleasableReferencesValidatorTest {
+public class ForReleasableReferencesValidationTest {
   @Test
   public void notAScope() {
     JavaFileObject notAScope =
diff --git a/javatests/dagger/internal/codegen/BindingTypeMapperTest.java b/javatests/dagger/internal/codegen/FrameworkTypeMapperTest.java
similarity index 53%
rename from javatests/dagger/internal/codegen/BindingTypeMapperTest.java
rename to javatests/dagger/internal/codegen/FrameworkTypeMapperTest.java
index 7dc162cc7..3e6e3ad69 100644
--- a/javatests/dagger/internal/codegen/BindingTypeMapperTest.java
+++ b/javatests/dagger/internal/codegen/FrameworkTypeMapperTest.java
@@ -17,8 +17,6 @@
 package dagger.internal.codegen;
 
 import static com.google.common.truth.Truth.assertThat;
-import static dagger.internal.codegen.BindingType.PRODUCTION;
-import static dagger.internal.codegen.BindingType.PROVISION;
 import static dagger.model.RequestKind.INSTANCE;
 import static dagger.model.RequestKind.LAZY;
 import static dagger.model.RequestKind.PRODUCED;
@@ -29,32 +27,22 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-/**
- * Test case for {@link BindingTypeMapper}.
- */
+/** Test case for {@link FrameworkTypeMapper}. */
 @RunWith(JUnit4.class)
-public class BindingTypeMapperTest {
+public class FrameworkTypeMapperTest {
   @Test public void forProvider() {
-    BindingTypeMapper mapper = BindingTypeMapper.FOR_PROVIDER;
-    assertThat(mapper.getBindingType(INSTANCE))
-        .isEqualTo(PROVISION);
-    assertThat(mapper.getBindingType(LAZY))
-        .isEqualTo(PROVISION);
-    assertThat(mapper.getBindingType(PROVIDER))
-        .isEqualTo(PROVISION);
+    FrameworkTypeMapper mapper = FrameworkTypeMapper.FOR_PROVIDER;
+    assertThat(mapper.getFrameworkType(INSTANCE)).isEqualTo(FrameworkType.PROVIDER);
+    assertThat(mapper.getFrameworkType(LAZY)).isEqualTo(FrameworkType.PROVIDER);
+    assertThat(mapper.getFrameworkType(PROVIDER)).isEqualTo(FrameworkType.PROVIDER);
   }
 
   @Test public void forProducer() {
-    BindingTypeMapper mapper = BindingTypeMapper.FOR_PRODUCER;
-    assertThat(mapper.getBindingType(INSTANCE))
-        .isEqualTo(PRODUCTION);
-    assertThat(mapper.getBindingType(LAZY))
-        .isEqualTo(PROVISION);
-    assertThat(mapper.getBindingType(PROVIDER))
-        .isEqualTo(PROVISION);
-    assertThat(mapper.getBindingType(PRODUCER))
-        .isEqualTo(PRODUCTION);
-    assertThat(mapper.getBindingType(PRODUCED))
-        .isEqualTo(PRODUCTION);
+    FrameworkTypeMapper mapper = FrameworkTypeMapper.FOR_PRODUCER;
+    assertThat(mapper.getFrameworkType(INSTANCE)).isEqualTo(FrameworkType.PRODUCER_NODE);
+    assertThat(mapper.getFrameworkType(LAZY)).isEqualTo(FrameworkType.PROVIDER);
+    assertThat(mapper.getFrameworkType(PROVIDER)).isEqualTo(FrameworkType.PROVIDER);
+    assertThat(mapper.getFrameworkType(PRODUCER)).isEqualTo(FrameworkType.PRODUCER_NODE);
+    assertThat(mapper.getFrameworkType(PRODUCED)).isEqualTo(FrameworkType.PRODUCER_NODE);
   }
 }
diff --git a/javatests/dagger/internal/codegen/GraphValidationScopingTest.java b/javatests/dagger/internal/codegen/GraphValidationScopingTest.java
deleted file mode 100644
index c11d04fbc..000000000
--- a/javatests/dagger/internal/codegen/GraphValidationScopingTest.java
+++ /dev/null
@@ -1,402 +0,0 @@
-/*
- * Copyright (C) 2014 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal.codegen;
-
-import static com.google.testing.compile.CompilationSubject.assertThat;
-import static dagger.internal.codegen.Compilers.daggerCompiler;
-
-import com.google.testing.compile.Compilation;
-import com.google.testing.compile.JavaFileObjects;
-import javax.tools.JavaFileObject;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-@RunWith(JUnit4.class)
-public class GraphValidationScopingTest {
-  @Test public void componentWithoutScopeIncludesScopedBindings_Fail() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.MyComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import javax.inject.Singleton;",
-        "",
-        "@Component(modules = ScopedModule.class)",
-        "interface MyComponent {",
-        "  ScopedType string();",
-        "}");
-    JavaFileObject typeFile = JavaFileObjects.forSourceLines("test.ScopedType",
-        "package test;",
-        "",
-        "import javax.inject.Inject;",
-        "import javax.inject.Singleton;",
-        "",
-        "@Singleton",
-        "class ScopedType {",
-        "  @Inject ScopedType(String s, long l, float f) {}",
-        "}");
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.ScopedModule",
-        "package test;",
-        "",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "import javax.inject.Singleton;",
-        "",
-        "@Module",
-        "class ScopedModule {",
-        "  @Provides @Singleton String string() { return \"a string\"; }",
-        "  @Provides long integer() { return 0L; }",
-        "  @Provides float floatingPoint() { return 0.0f; }",
-        "}");
-    String errorMessage =
-        "test.MyComponent (unscoped) may not reference scoped bindings:\n"
-            + "      @Singleton class test.ScopedType\n"
-            + "      @Provides @Singleton String test.ScopedModule.string()";
-    Compilation compilation = daggerCompiler().compile(componentFile, typeFile, moduleFile);
-    assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(errorMessage);
-  }
-
-  @Test public void componentWithScopeIncludesIncompatiblyScopedBindings_Fail() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.MyComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import javax.inject.Singleton;",
-        "",
-        "@Singleton",
-        "@Component(modules = ScopedModule.class)",
-        "interface MyComponent {",
-        "  ScopedType string();",
-        "}");
-    JavaFileObject scopeFile = JavaFileObjects.forSourceLines("test.PerTest",
-        "package test;",
-        "",
-        "import javax.inject.Scope;",
-        "",
-        "@Scope",
-        "@interface PerTest {}");
-    JavaFileObject scopeWithAttribute =
-        JavaFileObjects.forSourceLines(
-            "test.Per",
-            "package test;",
-            "",
-            "import javax.inject.Scope;",
-            "",
-            "@Scope",
-            "@interface Per {",
-            "  Class<?> value();",
-            "}");
-    JavaFileObject typeFile = JavaFileObjects.forSourceLines("test.ScopedType",
-        "package test;",
-        "",
-        "import javax.inject.Inject;",
-        "",
-        "@PerTest", // incompatible scope
-        "class ScopedType {",
-        "  @Inject ScopedType(String s, long l, float f, boolean b) {}",
-        "}");
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.ScopedModule",
-        "package test;",
-        "",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "import javax.inject.Singleton;",
-        "",
-        "@Module",
-        "class ScopedModule {",
-        "  @Provides @PerTest String string() { return \"a string\"; }", // incompatible scope
-        "  @Provides long integer() { return 0L; }", // unscoped - valid
-        "  @Provides @Singleton float floatingPoint() { return 0.0f; }", // same scope - valid
-        "  @Provides @Per(MyComponent.class) boolean bool() { return false; }", // incompatible
-        "}");
-    String errorMessage =
-        "test.MyComponent scoped with @Singleton "
-            + "may not reference bindings with different scopes:\n"
-            + "      @test.PerTest class test.ScopedType\n"
-            + "      @Provides @test.PerTest String test.ScopedModule.string()\n"
-            + "      @Provides @test.Per(test.MyComponent.class) boolean test.ScopedModule.bool()";
-    Compilation compilation =
-        daggerCompiler()
-            .compile(componentFile, scopeFile, scopeWithAttribute, typeFile, moduleFile);
-    assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(errorMessage);
-  }
-
-  @Test public void componentWithScopeMayDependOnOnlyOneScopedComponent() {
-    // If a scoped component will have dependencies, they must only include, at most, a single
-    // scoped component
-    JavaFileObject type = JavaFileObjects.forSourceLines("test.SimpleType",
-        "package test;",
-        "",
-        "import javax.inject.Inject;",
-        "",
-        "class SimpleType {",
-        "  @Inject SimpleType() {}",
-        "  static class A { @Inject A() {} }",
-        "  static class B { @Inject B() {} }",
-        "}");
-    JavaFileObject simpleScope = JavaFileObjects.forSourceLines("test.SimpleScope",
-        "package test;",
-        "",
-        "import javax.inject.Scope;",
-        "",
-        "@Scope @interface SimpleScope {}");
-    JavaFileObject singletonScopedA = JavaFileObjects.forSourceLines("test.SingletonComponentA",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import javax.inject.Singleton;",
-        "",
-        "@Singleton",
-        "@Component",
-        "interface SingletonComponentA {",
-        "  SimpleType.A type();",
-        "}");
-    JavaFileObject singletonScopedB = JavaFileObjects.forSourceLines("test.SingletonComponentB",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import javax.inject.Singleton;",
-        "",
-        "@Singleton",
-        "@Component",
-        "interface SingletonComponentB {",
-        "  SimpleType.B type();",
-        "}");
-    JavaFileObject scopeless = JavaFileObjects.forSourceLines("test.ScopelessComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "",
-        "@Component",
-        "interface ScopelessComponent {",
-        "  SimpleType type();",
-        "}");
-    JavaFileObject simpleScoped = JavaFileObjects.forSourceLines("test.SimpleScopedComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "",
-        "@SimpleScope",
-        "@Component(dependencies = {SingletonComponentA.class, SingletonComponentB.class})",
-        "interface SimpleScopedComponent {",
-        "  SimpleType.A type();",
-        "}");
-    String errorMessage =
-        "@test.SimpleScope test.SimpleScopedComponent depends on more than one scoped component:\n"
-        + "      @Singleton test.SingletonComponentA\n"
-        + "      @Singleton test.SingletonComponentB";
-    Compilation compilation =
-        daggerCompiler()
-            .compile(
-                type, simpleScope, simpleScoped, singletonScopedA, singletonScopedB, scopeless);
-    assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(errorMessage);
-  }
-
-  @Test public void componentWithoutScopeCannotDependOnScopedComponent() {
-    JavaFileObject type = JavaFileObjects.forSourceLines("test.SimpleType",
-        "package test;",
-        "",
-        "import javax.inject.Inject;",
-        "",
-        "class SimpleType {",
-        "  @Inject SimpleType() {}",
-        "}");
-    JavaFileObject scopedComponent = JavaFileObjects.forSourceLines("test.ScopedComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import javax.inject.Singleton;",
-        "",
-        "@Singleton",
-        "@Component",
-        "interface ScopedComponent {",
-        "  SimpleType type();",
-        "}");
-    JavaFileObject unscopedComponent = JavaFileObjects.forSourceLines("test.UnscopedComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import javax.inject.Singleton;",
-        "",
-        "@Component(dependencies = ScopedComponent.class)",
-        "interface UnscopedComponent {",
-        "  SimpleType type();",
-        "}");
-    String errorMessage =
-        "test.UnscopedComponent (unscoped) cannot depend on scoped components:\n"
-        + "      @Singleton test.ScopedComponent";
-    Compilation compilation = daggerCompiler().compile(type, scopedComponent, unscopedComponent);
-    assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(errorMessage);
-  }
-
-  @Test public void componentWithSingletonScopeMayNotDependOnOtherScope() {
-    // Singleton must be the widest lifetime of present scopes.
-    JavaFileObject type = JavaFileObjects.forSourceLines("test.SimpleType",
-        "package test;",
-        "",
-        "import javax.inject.Inject;",
-        "",
-        "class SimpleType {",
-        "  @Inject SimpleType() {}",
-        "}");
-    JavaFileObject simpleScope = JavaFileObjects.forSourceLines("test.SimpleScope",
-        "package test;",
-        "",
-        "import javax.inject.Scope;",
-        "",
-        "@Scope @interface SimpleScope {}");
-    JavaFileObject simpleScoped = JavaFileObjects.forSourceLines("test.SimpleScopedComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "",
-        "@SimpleScope",
-        "@Component",
-        "interface SimpleScopedComponent {",
-        "  SimpleType type();",
-        "}");
-    JavaFileObject singletonScoped = JavaFileObjects.forSourceLines("test.SingletonComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import javax.inject.Singleton;",
-        "",
-        "@Singleton",
-        "@Component(dependencies = SimpleScopedComponent.class)",
-        "interface SingletonComponent {",
-        "  SimpleType type();",
-        "}");
-    String errorMessage =
-        "This @Singleton component cannot depend on scoped components:\n"
-        + "      @test.SimpleScope test.SimpleScopedComponent";
-    Compilation compilation =
-        daggerCompiler().compile(type, simpleScope, simpleScoped, singletonScoped);
-    assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(errorMessage);
-  }
-
-  @Test public void componentScopeAncestryMustNotCycle() {
-    // The dependency relationship of components is necessarily from shorter lifetimes to
-    // longer lifetimes.  The scoping annotations must reflect this, and so one cannot declare
-    // scopes on components such that they cycle.
-    JavaFileObject type = JavaFileObjects.forSourceLines("test.SimpleType",
-        "package test;",
-        "",
-        "import javax.inject.Inject;",
-        "",
-        "class SimpleType {",
-        "  @Inject SimpleType() {}",
-        "}");
-    JavaFileObject scopeA = JavaFileObjects.forSourceLines("test.ScopeA",
-        "package test;",
-        "",
-        "import javax.inject.Scope;",
-        "",
-        "@Scope @interface ScopeA {}");
-    JavaFileObject scopeB = JavaFileObjects.forSourceLines("test.ScopeB",
-        "package test;",
-        "",
-        "import javax.inject.Scope;",
-        "",
-        "@Scope @interface ScopeB {}");
-    JavaFileObject longLifetime = JavaFileObjects.forSourceLines("test.ComponentLong",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "",
-        "@ScopeA",
-        "@Component",
-        "interface ComponentLong {",
-        "  SimpleType type();",
-        "}");
-    JavaFileObject mediumLifetime = JavaFileObjects.forSourceLines("test.ComponentMedium",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "",
-        "@ScopeB",
-        "@Component(dependencies = ComponentLong.class)",
-        "interface ComponentMedium {",
-        "  SimpleType type();",
-        "}");
-    JavaFileObject shortLifetime = JavaFileObjects.forSourceLines("test.ComponentShort",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "",
-        "@ScopeA",
-        "@Component(dependencies = ComponentMedium.class)",
-        "interface ComponentShort {",
-        "  SimpleType type();",
-        "}");
-    String errorMessage =
-        "test.ComponentShort depends on scoped components in a non-hierarchical scope ordering:\n"
-        + "      @test.ScopeA test.ComponentLong\n"
-        + "      @test.ScopeB test.ComponentMedium\n"
-        + "      @test.ScopeA test.ComponentShort";
-    Compilation compilation =
-        daggerCompiler().compile(type, scopeA, scopeB, longLifetime, mediumLifetime, shortLifetime);
-    assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(errorMessage);
-  }
-
-  @Test
-  public void reusableNotAllowedOnComponent() {
-    JavaFileObject someComponent =
-        JavaFileObjects.forSourceLines(
-            "test.SomeComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "import dagger.Reusable;",
-            "",
-            "@Reusable",
-            "@Component",
-            "interface SomeComponent {}");
-    Compilation compilation = daggerCompiler().compile(someComponent);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining("@Reusable cannot be applied to components or subcomponents")
-        .inFile(someComponent)
-        .onLine(6);
-  }
-
-  @Test
-  public void reusableNotAllowedOnSubcomponent() {
-    JavaFileObject someSubcomponent =
-        JavaFileObjects.forSourceLines(
-            "test.SomeComponent",
-            "package test;",
-            "",
-            "import dagger.Reusable;",
-            "import dagger.Subcomponent;",
-            "",
-            "@Reusable",
-            "@Subcomponent",
-            "interface SomeSubcomponent {}");
-    Compilation compilation = daggerCompiler().compile(someSubcomponent);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining("@Reusable cannot be applied to components or subcomponents")
-        .inFile(someSubcomponent)
-        .onLine(6);
-  }
-}
diff --git a/javatests/dagger/internal/codegen/GraphValidationTest.java b/javatests/dagger/internal/codegen/GraphValidationTest.java
deleted file mode 100644
index a36fd23d4..000000000
--- a/javatests/dagger/internal/codegen/GraphValidationTest.java
+++ /dev/null
@@ -1,2772 +0,0 @@
-/*
- * Copyright (C) 2014 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal.codegen;
-
-import static com.google.testing.compile.CompilationSubject.assertThat;
-import static com.google.testing.compile.Compiler.javac;
-import static dagger.internal.codegen.Compilers.daggerCompiler;
-import static dagger.internal.codegen.NonNullableRequestForNullableBindingValidation.nullableToNonNullable;
-
-import com.google.common.base.Joiner;
-import com.google.testing.compile.Compilation;
-import com.google.testing.compile.JavaFileObjects;
-import javax.tools.JavaFileObject;
-import org.junit.Ignore;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-@RunWith(JUnit4.class)
-public class GraphValidationTest {
-  private static final JavaFileObject NULLABLE =
-      JavaFileObjects.forSourceLines(
-          "test.Nullable", // force one-string-per-line format
-          "package test;",
-          "",
-          "public @interface Nullable {}");
-
-  @Test public void componentOnConcreteClass() {
-    JavaFileObject component = JavaFileObjects.forSourceLines("test.MyComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "",
-        "@Component",
-        "interface MyComponent {",
-        "  Foo getFoo();",
-        "}");
-    JavaFileObject injectable = JavaFileObjects.forSourceLines("test.Foo",
-        "package test;",
-        "",
-        "import javax.inject.Inject;",
-        "",
-        "class Foo {",
-        "  @Inject Foo(Bar bar) {}",
-        "}");
-    JavaFileObject nonInjectable = JavaFileObjects.forSourceLines("test.Bar",
-        "package test;",
-        "",
-        "import javax.inject.Inject;",
-        "",
-        "interface Bar {}");
-    Compilation compilation = daggerCompiler().compile(component, injectable, nonInjectable);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining("test.Bar cannot be provided without an @Provides-annotated method.")
-        .inFile(component)
-        .onLine(7);
-  }
-
-  @Test public void componentProvisionWithNoDependencyChain() {
-    JavaFileObject component =
-        JavaFileObjects.forSourceLines(
-            "test.TestClass",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "import javax.inject.Qualifier;",
-            "",
-            "final class TestClass {",
-            "  @Qualifier @interface Q {}",
-            "  interface A {}",
-            "",
-            "  @Component()",
-            "  interface AComponent {",
-            "    A getA();",
-            "    @Q A qualifiedA();",
-            "  }",
-            "}");
-    Compilation compilation = daggerCompiler().compile(component);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining(
-            "test.TestClass.A cannot be provided without an @Provides-annotated method.")
-        .inFile(component)
-        .onLine(12);
-    assertThat(compilation)
-        .hadErrorContaining(
-            "@test.TestClass.Q test.TestClass.A "
-                + "cannot be provided without an @Provides-annotated method.")
-        .inFile(component)
-        .onLine(13);
-  }
-
-  @Test public void constructorInjectionWithoutAnnotation() {
-    JavaFileObject component = JavaFileObjects.forSourceLines("test.TestClass",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "import javax.inject.Inject;",
-        "",
-        "final class TestClass {",
-        "  static class A {",
-        "    A() {}",
-        "  }",
-        "",
-        "  @Component()",
-        "  interface AComponent {",
-        "    A getA();",
-        "  }",
-        "}");
-    String expectedError =
-        "test.TestClass.A cannot be provided without an @Inject constructor or an "
-            + "@Provides-annotated method.";
-    Compilation compilation = daggerCompiler().compile(component);
-    assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(expectedError).inFile(component).onLine(15);
-  }
-
-  @Test public void membersInjectWithoutProvision() {
-    JavaFileObject component = JavaFileObjects.forSourceLines("test.TestClass",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "import javax.inject.Inject;",
-        "",
-        "final class TestClass {",
-        "  static class A {",
-        "    @Inject A() {}",
-        "  }",
-        "",
-        "  static class B {",
-        "    @Inject A a;",
-        "  }",
-        "",
-        "  @Component()",
-        "  interface AComponent {",
-        "    B getB();",
-        "  }",
-        "}");
-    String expectedError =
-        "test.TestClass.B cannot be provided without an @Inject constructor or an "
-            + "@Provides-annotated method. This type supports members injection but cannot be "
-            + "implicitly provided.";
-    Compilation compilation = daggerCompiler().compile(component);
-    assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(expectedError).inFile(component).onLine(19);
-  }
-
-  @Test
-  public void membersInjectDependsOnUnboundedType() {
-    JavaFileObject injectsUnboundedType =
-        JavaFileObjects.forSourceLines(
-            "test.InjectsUnboundedType",
-            "package test;",
-            "",
-            "import dagger.MembersInjector;",
-            "import java.util.ArrayList;",
-            "import javax.inject.Inject;",
-            "",
-            "class InjectsUnboundedType {",
-            "  @Inject MembersInjector<ArrayList<?>> listInjector;",
-            "}");
-    JavaFileObject component =
-        JavaFileObjects.forSourceLines(
-            "test.TestComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "",
-            "@Component",
-            "interface TestComponent {",
-            "  void injectsUnboundedType(InjectsUnboundedType injects);",
-            "}");
-    Compilation compilation = daggerCompiler().compile(injectsUnboundedType, component);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining(
-            Joiner.on('\n')
-                .join(
-                    "Cannot inject members into types with unbounded type arguments: "
-                        + "java.util.ArrayList<?>",
-                    "      dagger.MembersInjector<java.util.ArrayList<?>> is injected at",
-                    "          test.InjectsUnboundedType.listInjector",
-                    "      test.InjectsUnboundedType is injected at",
-                    "          test.TestComponent.injectsUnboundedType(test.InjectsUnboundedType)"))
-        .inFile(component)
-        .onLine(7);
-  }
-
-  @Ignore // TODO(b/77220343)
-  @Test
-  public void membersInjectPrimitive() {
-    JavaFileObject component =
-        JavaFileObjects.forSourceLines(
-            "test.TestComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "",
-            "@Component",
-            "interface TestComponent {",
-            "  void inject(int primitive);",
-            "}");
-    Compilation compilation = daggerCompiler().compile(component);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining("Cannot inject members into int")
-        .inFile(component)
-        .onLineContaining("void inject(int primitive);");
-  }
-
-  @Ignore // TODO(b/77220343)
-  @Test
-  public void membersInjectArray() {
-    JavaFileObject component =
-        JavaFileObjects.forSourceLines(
-            "test.TestComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "",
-            "@Component",
-            "interface TestComponent {",
-            "  void inject(Object[] array);",
-            "}");
-    Compilation compilation = daggerCompiler().compile(component);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining("Cannot inject members into java.lang.Object[]")
-        .inFile(component)
-        .onLineContaining("void inject(Object[] array);");
-  }
-
-  @Ignore // TODO(b/77220343)
-  @Test
-  public void membersInjectorOfArray() {
-    JavaFileObject component =
-        JavaFileObjects.forSourceLines(
-            "test.TestComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "import dagger.MembersInjector;",
-            "",
-            "@Component",
-            "interface TestComponent {",
-            "  MembersInjector<Object[]> objectArrayInjector();",
-            "}");
-    Compilation compilation = daggerCompiler().compile(component);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining("Cannot inject members into java.lang.Object[]")
-        .inFile(component)
-        .onLineContaining("objectArrayInjector();");
-  }
-
-  @Test
-  public void membersInjectRawType() {
-    JavaFileObject component =
-        JavaFileObjects.forSourceLines(
-            "test.TestComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "import java.util.Set;",
-            "",
-            "@Component",
-            "interface TestComponent {",
-            "  void inject(Set rawSet);",
-            "}");
-    Compilation compilation = daggerCompiler().compile(component);
-    assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining("Cannot inject members into raw type java.util.Set");
-  }
-
-  @Test
-  public void staticFieldInjection() {
-    JavaFileObject injected =
-        JavaFileObjects.forSourceLines(
-            "test.Injected",
-            "package test;",
-            "",
-            "import javax.inject.Inject;",
-            "",
-            "final class Injected {",
-            "  @Inject static Object object;",
-            "}");
-    JavaFileObject component =
-        JavaFileObjects.forSourceLines(
-            "test.TestComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "",
-            "@Component",
-            "interface TestComponent {",
-            "  void inject(Injected injected);",
-            "}");
-    Compilation compilation = daggerCompiler().compile(injected, component);
-    assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining("static fields").inFile(injected).onLine(6);
-  }
-
-  @Test public void cyclicDependency() {
-    JavaFileObject component = JavaFileObjects.forSourceLines("test.Outer",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "import javax.inject.Inject;",
-        "",
-        "final class Outer {",
-        "  static class A {",
-        "    @Inject A(C cParam) {}",
-        "  }",
-        "",
-        "  static class B {",
-        "    @Inject B(A aParam) {}",
-        "  }",
-        "",
-        "  static class C {",
-        "    @Inject C(B bParam) {}",
-        "  }",
-        "",
-        "  @Component()",
-        "  interface CComponent {",
-        "    C getC();",
-        "  }",
-        "}");
-
-    String expectedError =
-        Joiner.on('\n')
-            .join(
-                "Found a dependency cycle:",
-                "      test.Outer.C is injected at",
-                "          test.Outer.A.<init>(cParam)",
-                "      test.Outer.A is injected at",
-                "          test.Outer.B.<init>(aParam)",
-                "      test.Outer.B is injected at",
-                "          test.Outer.C.<init>(bParam)",
-                "      test.Outer.C is provided at",
-                "          test.Outer.CComponent.getC()");
-
-    Compilation compilation = daggerCompiler().compile(component);
-    assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(expectedError).inFile(component).onLine(23);
-  }
-
-  @Test public void cyclicDependencyNotIncludingEntryPoint() {
-    JavaFileObject component =
-        JavaFileObjects.forSourceLines(
-            "test.Outer",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import javax.inject.Inject;",
-            "",
-            "final class Outer {",
-            "  static class A {",
-            "    @Inject A(C cParam) {}",
-            "  }",
-            "",
-            "  static class B {",
-            "    @Inject B(A aParam) {}",
-            "  }",
-            "",
-            "  static class C {",
-            "    @Inject C(B bParam) {}",
-            "  }",
-            "",
-            "  static class D {",
-            "    @Inject D(C cParam) {}",
-            "  }",
-            "",
-            "  @Component()",
-            "  interface DComponent {",
-            "    D getD();",
-            "  }",
-            "}");
-
-    String expectedError =
-        Joiner.on('\n')
-            .join(
-                "Found a dependency cycle:",
-                "      test.Outer.C is injected at",
-                "          test.Outer.A.<init>(cParam)",
-                "      test.Outer.A is injected at",
-                "          test.Outer.B.<init>(aParam)",
-                "      test.Outer.B is injected at",
-                "          test.Outer.C.<init>(bParam)",
-                "      test.Outer.C is injected at",
-                "          test.Outer.D.<init>(cParam)",
-                "      test.Outer.D is provided at",
-                "          test.Outer.DComponent.getD()");
-
-    Compilation compilation = daggerCompiler().compile(component);
-    assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(expectedError).inFile(component).onLine(27);
-  }
-
-  @Test
-  public void cyclicDependencyNotBrokenByMapBinding() {
-    JavaFileObject component =
-        JavaFileObjects.forSourceLines(
-            "test.Outer",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "import dagger.MapKey;",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.multibindings.IntoMap;",
-            "import java.util.Map;",
-            "import javax.inject.Inject;",
-            "",
-            "final class Outer {",
-            "  static class A {",
-            "    @Inject A(Map<String, C> cMap) {}",
-            "  }",
-            "",
-            "  static class B {",
-            "    @Inject B(A aParam) {}",
-            "  }",
-            "",
-            "  static class C {",
-            "    @Inject C(B bParam) {}",
-            "  }",
-            "",
-            "  @Component(modules = CModule.class)",
-            "  interface CComponent {",
-            "    C getC();",
-            "  }",
-            "",
-            "  @Module",
-            "  static class CModule {",
-            "    @Provides @IntoMap",
-            "    @StringKey(\"C\")",
-            "    static C c(C c) {",
-            "      return c;",
-            "    }",
-            "  }",
-            "",
-            "  @MapKey",
-            "  @interface StringKey {",
-            "    String value();",
-            "  }",
-            "}");
-
-    String expectedError =
-        Joiner.on('\n')
-            .join(
-                "Found a dependency cycle:",
-                "      test.Outer.C is injected at",
-                "          test.Outer.CModule.c(c)",
-                "      java.util.Map<java.lang.String,test.Outer.C> is injected at",
-                "          test.Outer.A.<init>(cMap)",
-                "      test.Outer.A is injected at",
-                "          test.Outer.B.<init>(aParam)",
-                "      test.Outer.B is injected at",
-                "          test.Outer.C.<init>(bParam)",
-                "      test.Outer.C is provided at",
-                "          test.Outer.CComponent.getC()");
-
-    Compilation compilation = daggerCompiler().compile(component);
-    assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(expectedError).inFile(component).onLine(26);
-  }
-
-  @Test
-  public void cyclicDependencyWithSetBinding() {
-    JavaFileObject component =
-        JavaFileObjects.forSourceLines(
-            "test.Outer",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.multibindings.IntoSet;",
-            "import java.util.Set;",
-            "import javax.inject.Inject;",
-            "",
-            "final class Outer {",
-            "  static class A {",
-            "    @Inject A(Set<C> cSet) {}",
-            "  }",
-            "",
-            "  static class B {",
-            "    @Inject B(A aParam) {}",
-            "  }",
-            "",
-            "  static class C {",
-            "    @Inject C(B bParam) {}",
-            "  }",
-            "",
-            "  @Component(modules = CModule.class)",
-            "  interface CComponent {",
-            "    C getC();",
-            "  }",
-            "",
-            "  @Module",
-            "  static class CModule {",
-            "    @Provides @IntoSet",
-            "    static C c(C c) {",
-            "      return c;",
-            "    }",
-            "  }",
-            "}");
-
-    String expectedError =
-        Joiner.on('\n')
-            .join(
-                "Found a dependency cycle:",
-                "      test.Outer.C is injected at",
-                "          test.Outer.CModule.c(c)",
-                "      java.util.Set<test.Outer.C> is injected at",
-                "          test.Outer.A.<init>(cSet)",
-                "      test.Outer.A is injected at",
-                "          test.Outer.B.<init>(aParam)",
-                "      test.Outer.B is injected at",
-                "          test.Outer.C.<init>(bParam)",
-                "      test.Outer.C is provided at",
-                "          test.Outer.CComponent.getC()");
-
-    Compilation compilation = daggerCompiler().compile(component);
-    assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(expectedError).inFile(component).onLine(25);
-  }
-
-  @Test
-  public void falsePositiveCyclicDependencyIndirectionDetected() {
-    JavaFileObject component =
-        JavaFileObjects.forSourceLines(
-            "test.Outer",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import javax.inject.Inject;",
-            "import javax.inject.Provider;",
-            "",
-            "final class Outer {",
-            "  static class A {",
-            "    @Inject A(C cParam) {}",
-            "  }",
-            "",
-            "  static class B {",
-            "    @Inject B(A aParam) {}",
-            "  }",
-            "",
-            "  static class C {",
-            "    @Inject C(B bParam) {}",
-            "  }",
-            "",
-            "  static class D {",
-            "    @Inject D(Provider<C> cParam) {}",
-            "  }",
-            "",
-            "  @Component()",
-            "  interface DComponent {",
-            "    D getD();",
-            "  }",
-            "}");
-
-    String expectedError =
-        Joiner.on('\n')
-            .join(
-                "Found a dependency cycle:",
-                "      test.Outer.C is injected at",
-                "          test.Outer.A.<init>(cParam)",
-                "      test.Outer.A is injected at",
-                "          test.Outer.B.<init>(aParam)",
-                "      test.Outer.B is injected at",
-                "          test.Outer.C.<init>(bParam)",
-                "      javax.inject.Provider<test.Outer.C> is injected at",
-                "          test.Outer.D.<init>(cParam)",
-                "      test.Outer.D is provided at",
-                "          test.Outer.DComponent.getD()");
-
-    Compilation compilation = daggerCompiler().compile(component);
-    assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(expectedError).inFile(component).onLine(28);
-  }
-
-  @Test
-  public void cyclicDependencyInSubcomponents() {
-    JavaFileObject parent =
-        JavaFileObjects.forSourceLines(
-            "test.Parent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "",
-            "@Component",
-            "interface Parent {",
-            "  Child child();",
-            "}");
-    JavaFileObject child =
-        JavaFileObjects.forSourceLines(
-            "test.Child",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent(modules = ChildModule.class)",
-            "interface Child {",
-            "  Grandchild grandchild();",
-            "}");
-    JavaFileObject grandchild =
-        JavaFileObjects.forSourceLines(
-            "test.Grandchild",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent(modules = GrandchildModule.class)",
-            "interface Grandchild {",
-            "  String entry();",
-            "}");
-    JavaFileObject childModule =
-        JavaFileObjects.forSourceLines(
-            "test.ChildModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "",
-            "@Module",
-            "abstract class ChildModule {",
-            "  @Provides static Object object(String string) {",
-            "    return string;",
-            "  }",
-            "}");
-    JavaFileObject grandchildModule =
-        JavaFileObjects.forSourceLines(
-            "test.GrandchildModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "",
-            "@Module",
-            "abstract class GrandchildModule {",
-            "  @Provides static String string(Object object) {",
-            "    return object.toString();",
-            "  }",
-            "}");
-
-    String expectedError =
-        Joiner.on('\n')
-            .join(
-                "[test.Grandchild.entry()] Found a dependency cycle:",
-                "      java.lang.String is injected at",
-                "          test.ChildModule.object(string)",
-                "      java.lang.Object is injected at",
-                "          test.GrandchildModule.string(object)",
-                "      java.lang.String is provided at",
-                "          test.Grandchild.entry()");
-
-    Compilation compilation =
-        daggerCompiler().compile(parent, child, grandchild, childModule, grandchildModule);
-    assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(expectedError).inFile(child).onLine(6);
-  }
-
-  @Test
-  public void circularBindsMethods() {
-    JavaFileObject qualifier =
-        JavaFileObjects.forSourceLines(
-            "test.SomeQualifier",
-            "package test;",
-            "",
-            "import javax.inject.Qualifier;",
-            "",
-            "@Qualifier @interface SomeQualifier {}");
-    JavaFileObject module =
-        JavaFileObjects.forSourceLines(
-            "test.TestModule",
-            "package test;",
-            "",
-            "import dagger.Binds;",
-            "import dagger.Module;",
-            "",
-            "@Module",
-            "abstract class TestModule {",
-            "  @Binds abstract Object bindUnqualified(@SomeQualifier Object qualified);",
-            "  @Binds @SomeQualifier abstract Object bindQualified(Object unqualified);",
-            "}");
-    JavaFileObject component =
-        JavaFileObjects.forSourceLines(
-            "test.TestComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "",
-            "@Component(modules = TestModule.class)",
-            "interface TestComponent {",
-            "  Object unqualified();",
-            "  @SomeQualifier Object qualified();",
-            "}");
-
-    Compilation compilation = daggerCompiler().compile(qualifier, module, component);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining(
-            "Found a dependency cycle:\n"
-                + "      java.lang.Object is injected at\n"
-                + "          test.TestModule.bindQualified(unqualified)\n"
-                + "      @test.SomeQualifier java.lang.Object is injected at\n"
-                + "          test.TestModule.bindUnqualified(qualified)\n"
-                + "      java.lang.Object is provided at\n"
-                + "          test.TestComponent.unqualified()")
-        .inFile(component)
-        .onLine(7);
-    assertThat(compilation)
-        .hadErrorContaining(
-            // TODO(gak): cl/126230644 produces a better error message in this case. Here it isn't
-            // unclear what is going wrong.
-            "Found a dependency cycle:\n"
-                + "      @test.SomeQualifier java.lang.Object is injected at\n"
-                + "          test.TestModule.bindUnqualified(qualified)\n"
-                + "      java.lang.Object is injected at\n"
-                + "          test.TestModule.bindQualified(unqualified)\n"
-                + "      @test.SomeQualifier java.lang.Object is provided at\n"
-                + "          test.TestComponent.qualified()")
-        .inFile(component)
-        .onLine(8);
-  }
-
-  @Test
-  public void selfReferentialBinds() {
-    JavaFileObject module =
-        JavaFileObjects.forSourceLines(
-            "test.TestModule",
-            "package test;",
-            "",
-            "import dagger.Binds;",
-            "import dagger.Module;",
-            "",
-            "@Module",
-            "abstract class TestModule {",
-            "  @Binds abstract Object bindToSelf(Object sameKey);",
-            "}");
-    JavaFileObject component =
-        JavaFileObjects.forSourceLines(
-            "test.TestComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "",
-            "@Component(modules = TestModule.class)",
-            "interface TestComponent {",
-            "  Object selfReferential();",
-            "}");
-
-    Compilation compilation = daggerCompiler().compile(module, component);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining(
-            "Found a dependency cycle:\n"
-                + "      java.lang.Object is injected at\n"
-                + "          test.TestModule.bindToSelf(sameKey)\n"
-                + "      java.lang.Object is provided at\n"
-                + "          test.TestComponent.selfReferential()")
-        .inFile(component)
-        .onLine(7);
-  }
-
-  @Test
-  public void cycleFromMembersInjectionMethod_WithSameKeyAsMembersInjectionMethod() {
-    JavaFileObject a =
-        JavaFileObjects.forSourceLines(
-            "test.A",
-            "package test;",
-            "",
-            "import javax.inject.Inject;",
-            "",
-            "class A {",
-            "  @Inject A() {}",
-            "  @Inject B b;",
-            "}");
-    JavaFileObject b =
-        JavaFileObjects.forSourceLines(
-            "test.B",
-            "package test;",
-            "",
-            "import javax.inject.Inject;",
-            "",
-            "class B {",
-            "  @Inject B() {}",
-            "  @Inject A a;",
-            "}");
-    JavaFileObject component =
-        JavaFileObjects.forSourceLines(
-            "test.CycleComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "",
-            "@Component",
-            "interface CycleComponent {",
-            "  void inject(A a);",
-            "}");
-
-    Compilation compilation = daggerCompiler().compile(a, b, component);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining(
-            Joiner.on('\n')
-                .join(
-                    "Found a dependency cycle:",
-                    "      test.B is injected at",
-                    "          test.A.b",
-                    "      test.A is injected at",
-                    "          test.B.a",
-                    "      test.B is injected at",
-                    "          test.A.b",
-                    "      test.A is injected at",
-                    "          test.CycleComponent.inject(test.A)"))
-        .inFile(component)
-        .onLineContaining("void inject(A a);");
-  }
-
-  @Test
-  public void missingBindingWithSameKeyAsMembersInjectionMethod() {
-    JavaFileObject self =
-        JavaFileObjects.forSourceLines(
-            "test.Self",
-            "package test;",
-            "",
-            "import javax.inject.Inject;",
-            "import javax.inject.Provider;",
-            "",
-            "class Self {",
-            "  @Inject Provider<Self> selfProvider;",
-            "}");
-    JavaFileObject component =
-        JavaFileObjects.forSourceLines(
-            "test.SelfComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "",
-            "@Component",
-            "interface SelfComponent {",
-            "  void inject(Self target);",
-            "}");
-
-    Compilation compilation = daggerCompiler().compile(self, component);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining("test.Self cannot be provided without an @Inject constructor")
-        .inFile(component)
-        .onLineContaining("void inject(Self target);");
-  }
-
-  @Test public void duplicateExplicitBindings_ProvidesAndComponentProvision() {
-    JavaFileObject component = JavaFileObjects.forSourceLines("test.Outer",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "",
-        "final class Outer {",
-        "  interface A {}",
-        "",
-        "  interface B {}",
-        "",
-        "  @Module",
-        "  static class AModule {",
-        "    @Provides String provideString() { return \"\"; }",
-        "    @Provides A provideA(String s) { return new A() {}; }",
-        "  }",
-        "",
-        "  @Component(modules = AModule.class)",
-        "  interface Parent {",
-        "    A getA();",
-        "  }",
-        "",
-        "  @Module",
-        "  static class BModule {",
-        "    @Provides B provideB(A a) { return new B() {}; }",
-        "  }",
-        "",
-        "  @Component(dependencies = Parent.class, modules = { BModule.class, AModule.class})",
-        "  interface Child {",
-        "    B getB();",
-        "  }",
-        "}");
-
-    String expectedError =
-        error(
-            "test.Outer.A is bound multiple times:",
-            "@Provides test.Outer.A test.Outer.AModule.provideA(String)",
-            "test.Outer.A test.Outer.Parent.getA()");
-
-    Compilation compilation = daggerCompiler().compile(component);
-    assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(expectedError).inFile(component).onLine(30);
-  }
-
-  @Test public void duplicateExplicitBindings_TwoProvidesMethods() {
-    JavaFileObject component = JavaFileObjects.forSourceLines("test.Outer",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "import javax.inject.Inject;",
-        "",
-        "final class Outer {",
-        "  interface A {}",
-        "",
-        "  @Module",
-        "  static class Module1 {",
-        "    @Provides A provideA1() { return new A() {}; }",
-        "  }",
-        "",
-        "  @Module",
-        "  static class Module2 {",
-        "    @Provides String provideString() { return \"\"; }",
-        "    @Provides A provideA2(String s) { return new A() {}; }",
-        "  }",
-        "",
-        "  @Component(modules = { Module1.class, Module2.class})",
-        "  interface TestComponent {",
-        "    A getA();",
-        "  }",
-        "}");
-
-    String expectedError = "test.Outer.A is bound multiple times:\n"
-        + "      @Provides test.Outer.A test.Outer.Module1.provideA1()\n"
-        + "      @Provides test.Outer.A test.Outer.Module2.provideA2(String)";
-
-    Compilation compilation = daggerCompiler().compile(component);
-    assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(expectedError).inFile(component).onLine(24);
-  }
-
-  @Test
-  public void duplicateExplicitBindings_ProvidesVsBinds() {
-    JavaFileObject component =
-        JavaFileObjects.forSourceLines(
-            "test.Outer",
-            "package test;",
-            "",
-            "import dagger.Binds;",
-            "import dagger.Component;",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import javax.inject.Inject;",
-            "",
-            "final class Outer {",
-            "  interface A {}",
-            "",
-            "  static final class B implements A {",
-            "    @Inject B() {}",
-            "  }",
-            "",
-            "  @Module",
-            "  static class Module1 {",
-            "    @Provides A provideA1() { return new A() {}; }",
-            "  }",
-            "",
-            "  @Module",
-            "  static abstract class Module2 {",
-            "    @Binds abstract A bindA2(B b);",
-            "  }",
-            "",
-            "  @Component(modules = { Module1.class, Module2.class})",
-            "  interface TestComponent {",
-            "    A getA();",
-            "  }",
-            "}");
-
-    Compilation compilation = daggerCompiler().compile(component);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining(
-            Joiner.on("\n      ")
-                .join(
-                    "test.Outer.A is bound multiple times:",
-                    "@Provides test.Outer.A test.Outer.Module1.provideA1()",
-                    "@Binds test.Outer.A test.Outer.Module2.bindA2(test.Outer.B)"))
-        .inFile(component)
-        .onLine(28);
-  }
-
-  @Test public void duplicateExplicitBindings_MultipleProvisionTypes() {
-    JavaFileObject component = JavaFileObjects.forSourceLines("test.Outer",
-        "package test;",
-        "",
-        "import dagger.Binds;",
-        "import dagger.Component;",
-        "import dagger.MapKey;",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "import dagger.MapKey;",
-        "import dagger.multibindings.IntoMap;",
-        "import dagger.multibindings.IntoSet;",
-        "import java.util.HashMap;",
-        "import java.util.HashSet;",
-        "import java.util.Map;",
-        "import java.util.Set;",
-        "import javax.inject.Qualifier;",
-        "",
-        "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
-        "final class Outer {",
-        "  @MapKey(unwrapValue = true)",
-        "  @interface StringKey {",
-        "    String value();",
-        "  }",
-        "",
-        "  @Qualifier @interface SomeQualifier {}",
-        "",
-        "  @Module",
-        "  abstract static class TestModule1 {",
-        "    @Provides @IntoMap",
-        "    @StringKey(\"foo\")",
-        "    static String stringMapEntry() { return \"\"; }",
-        "",
-        "    @Binds @IntoMap @StringKey(\"bar\")",
-        "    abstract String bindStringMapEntry(@SomeQualifier String value);",
-        "",
-        "    @Provides @IntoSet static String stringSetElement() { return \"\"; }",
-        "    @Binds @IntoSet abstract String bindStringSetElement(@SomeQualifier String value);",
-        "",
-        "    @Provides @SomeQualifier static String provideSomeQualifiedString() { return \"\"; }",
-        "  }",
-        "",
-        "  @Module",
-        "  static class TestModule2 {",
-        "    @Provides Set<String> stringSet() { return new HashSet<String>(); }",
-        "",
-        "    @Provides Map<String, String> stringMap() {",
-        "      return new HashMap<String, String>();",
-        "    }",
-        "  }",
-        "",
-        "  @Component(modules = { TestModule1.class, TestModule2.class })",
-        "  interface TestComponent {",
-        "    Set<String> getStringSet();",
-        "    Map<String, String> getStringMap();",
-        "  }",
-        "}");
-
-    String expectedSetError =
-        error(
-            "java.util.Set<java.lang.String> has incompatible bindings or declarations:",
-            "Set bindings and declarations:",
-            "    @Binds @dagger.multibindings.IntoSet String "
-                + "test.Outer.TestModule1.bindStringSetElement(@test.Outer.SomeQualifier String)",
-            "    @Provides @dagger.multibindings.IntoSet String "
-                + "test.Outer.TestModule1.stringSetElement()",
-            "Unique bindings and declarations:",
-            "    @Provides Set<String> test.Outer.TestModule2.stringSet()");
-
-    String expectedMapError =
-        error(
-            "java.util.Map<java.lang.String,java.lang.String> has incompatible bindings "
-                + "or declarations:",
-            "Map bindings and declarations:",
-            "    @Binds @dagger.multibindings.IntoMap "
-                + "@test.Outer.StringKey(\"bar\") String"
-                + " test.Outer.TestModule1.bindStringMapEntry(@test.Outer.SomeQualifier String)",
-            "    @Provides @dagger.multibindings.IntoMap "
-                + "@test.Outer.StringKey(\"foo\") String"
-                + " test.Outer.TestModule1.stringMapEntry()",
-            "Unique bindings and declarations:",
-            "    @Provides Map<String,String> test.Outer.TestModule2.stringMap()");
-
-    Compilation compilation = daggerCompiler().compile(component);
-    assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(expectedSetError).inFile(component).onLine(52);
-    assertThat(compilation).hadErrorContaining(expectedMapError).inFile(component).onLine(53);
-  }
-
-  @Test
-  public void duplicateExplicitBindings_UniqueBindingAndMultibindingDeclaration() {
-    JavaFileObject component =
-        JavaFileObjects.forSourceLines(
-            "test.Outer",
-            "package test;",
-            "",
-            "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
-            "",
-            "import dagger.Component;",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.multibindings.Multibinds;",
-            "import java.util.HashMap;",
-            "import java.util.HashSet;",
-            "import java.util.Map;",
-            "import java.util.Set;",
-            "",
-            "final class Outer {",
-            "  @Module",
-            "  abstract static class TestModule1 {",
-            "    @Multibinds abstract Map<String, String> stringMap();",
-            "    @Multibinds abstract Set<String> stringSet();",
-            "  }",
-            "",
-            "  @Module",
-            "  static class TestModule2 {",
-            "    @Provides Set<String> stringSet() { return new HashSet<String>(); }",
-            "",
-            "    @Provides Map<String, String> stringMap() {",
-            "      return new HashMap<String, String>();",
-            "    }",
-            "  }",
-            "",
-            "  @Component(modules = { TestModule1.class, TestModule2.class })",
-            "  interface TestComponent {",
-            "    Set<String> getStringSet();",
-            "    Map<String, String> getStringMap();",
-            "  }",
-            "}");
-
-    String expectedSetError =
-        "java.util.Set<java.lang.String> has incompatible bindings or declarations:\n"
-            + "      Set bindings and declarations:\n"
-            + "          @dagger.multibindings.Multibinds Set<String> "
-            + "test.Outer.TestModule1.stringSet()\n"
-            + "      Unique bindings and declarations:\n"
-            + "          @Provides Set<String> test.Outer.TestModule2.stringSet()";
-
-    String expectedMapError =
-        "java.util.Map<java.lang.String,java.lang.String> has incompatible bindings "
-            + "or declarations:\n"
-            + "      Map bindings and declarations:\n"
-            + "          @dagger.multibindings.Multibinds Map<String,String> "
-            + "test.Outer.TestModule1.stringMap()\n"
-            + "      Unique bindings and declarations:\n"
-            + "          @Provides Map<String,String> test.Outer.TestModule2.stringMap()";
-
-    Compilation compilation = daggerCompiler().compile(component);
-    assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(expectedSetError).inFile(component).onLine(32);
-    assertThat(compilation).hadErrorContaining(expectedMapError).inFile(component).onLine(33);
-  }
-
-  @Test public void duplicateBindings_TruncateAfterLimit() {
-    JavaFileObject component =
-        JavaFileObjects.forSourceLines(
-            "test.Outer",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import javax.inject.Inject;",
-            "",
-            "final class Outer {",
-            "  interface A {}",
-            "",
-            "  @Module",
-            "  static class Module01 {",
-            "    @Provides A provideA() { return new A() {}; }",
-            "  }",
-            "",
-            "  @Module",
-            "  static class Module02 {",
-            "    @Provides A provideA() { return new A() {}; }",
-            "  }",
-            "",
-            "  @Module",
-            "  static class Module03 {",
-            "    @Provides A provideA() { return new A() {}; }",
-            "  }",
-            "",
-            "  @Module",
-            "  static class Module04 {",
-            "    @Provides A provideA() { return new A() {}; }",
-            "  }",
-            "",
-            "  @Module",
-            "  static class Module05 {",
-            "    @Provides A provideA() { return new A() {}; }",
-            "  }",
-            "",
-            "  @Module",
-            "  static class Module06 {",
-            "    @Provides A provideA() { return new A() {}; }",
-            "  }",
-            "",
-            "  @Module",
-            "  static class Module07 {",
-            "    @Provides A provideA() { return new A() {}; }",
-            "  }",
-            "",
-            "  @Module",
-            "  static class Module08 {",
-            "    @Provides A provideA() { return new A() {}; }",
-            "  }",
-            "",
-            "  @Module",
-            "  static class Module09 {",
-            "    @Provides A provideA() { return new A() {}; }",
-            "  }",
-            "",
-            "  @Module",
-            "  static class Module10 {",
-            "    @Provides A provideA() { return new A() {}; }",
-            "  }",
-            "",
-            "  @Module",
-            "  static class Module11 {",
-            "    @Provides A provideA() { return new A() {}; }",
-            "  }",
-            "",
-            "  @Module",
-            "  static class Module12 {",
-            "    @Provides A provideA() { return new A() {}; }",
-            "  }",
-            "",
-            "  @Component(modules = {",
-            "    Module01.class,",
-            "    Module02.class,",
-            "    Module03.class,",
-            "    Module04.class,",
-            "    Module05.class,",
-            "    Module06.class,",
-            "    Module07.class,",
-            "    Module08.class,",
-            "    Module09.class,",
-            "    Module10.class,",
-            "    Module11.class,",
-            "    Module12.class",
-            "  })",
-            "  interface TestComponent {",
-            "    A getA();",
-            "  }",
-            "}");
-
-    Compilation compilation = daggerCompiler().compile(component);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining(
-            error(
-                "test.Outer.A is bound multiple times:",
-                "@Provides test.Outer.A test.Outer.Module01.provideA()",
-                "@Provides test.Outer.A test.Outer.Module02.provideA()",
-                "@Provides test.Outer.A test.Outer.Module03.provideA()",
-                "@Provides test.Outer.A test.Outer.Module04.provideA()",
-                "@Provides test.Outer.A test.Outer.Module05.provideA()",
-                "@Provides test.Outer.A test.Outer.Module06.provideA()",
-                "@Provides test.Outer.A test.Outer.Module07.provideA()",
-                "@Provides test.Outer.A test.Outer.Module08.provideA()",
-                "@Provides test.Outer.A test.Outer.Module09.provideA()",
-                "@Provides test.Outer.A test.Outer.Module10.provideA()",
-                "and 2 others"))
-        .inFile(component)
-        .onLineContaining("getA();");
-  }
-
-  @Test public void longChainOfDependencies() {
-    JavaFileObject component =
-        JavaFileObjects.forSourceLines(
-            "test.TestClass",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "import dagger.Lazy;",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import javax.inject.Inject;",
-            "import javax.inject.Named;",
-            "import javax.inject.Provider;",
-            "",
-            "final class TestClass {",
-            "  interface A {}",
-            "",
-            "  static class B {",
-            "    @Inject B(A a) {}",
-            "  }",
-            "",
-            "  static class C {",
-            "    @Inject B b;",
-            "    @Inject C(X x) {}",
-            "  }",
-            "",
-            "  interface D { }",
-            "",
-            "  static class DImpl implements D {",
-            "    @Inject DImpl(C c, B b) {}",
-            "  }",
-            "",
-            "  static class X {",
-            "    @Inject X() {}",
-            "  }",
-            "",
-            "  @Module",
-            "  static class DModule {",
-            "    @Provides @Named(\"slim shady\") D d(X x1, DImpl impl, X x2) { return impl; }",
-            "  }",
-            "",
-            "  @Component(modules = { DModule.class })",
-            "  interface AComponent {",
-            "    @Named(\"slim shady\") D getFoo();",
-            "    C injectC(C c);",
-            "    Provider<C> cProvider();",
-            "    Lazy<C> lazyC();",
-            "    Provider<Lazy<C>> lazyCProvider();",
-            "  }",
-            "}");
-    String errorText = "test.TestClass.A cannot be provided without an @Provides-annotated method.";
-    String firstError =
-        error(
-            errorText,
-            "test.TestClass.A is injected at",
-            "    test.TestClass.B.<init>(a)",
-            "test.TestClass.B is injected at",
-            "    test.TestClass.DImpl.<init>(…, b)",
-            "test.TestClass.DImpl is injected at",
-            "    test.TestClass.DModule.d(…, impl, …)",
-            "@javax.inject.Named(\"slim shady\") test.TestClass.D is provided at",
-            "    test.TestClass.AComponent.getFoo()");
-    String otherErrorFormat =
-        error(
-            errorText,
-            "test.TestClass.A is injected at",
-            "    test.TestClass.B.<init>(a)",
-            "test.TestClass.B is injected at",
-            "    test.TestClass.C.b",
-            "test.TestClass.C is %s at",
-            "    test.TestClass.AComponent.%s");
-    Compilation compilation = daggerCompiler().compile(component);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining(firstError)
-        .inFile(component)
-        .onLineContaining("getFoo();");
-    assertThat(compilation)
-        .hadErrorContaining(
-            String.format(otherErrorFormat, "injected", "injectC(test.TestClass.C)"))
-        .inFile(component)
-        .onLineContaining("injectC(C c);");
-    assertThat(compilation)
-        .hadErrorContaining(String.format(otherErrorFormat, "provided", "cProvider()"))
-        .inFile(component)
-        .onLineContaining("cProvider();");
-    assertThat(compilation)
-        .hadErrorContaining(String.format(otherErrorFormat, "provided", "lazyC()"))
-        .inFile(component)
-        .onLineContaining("lazyC();");
-    assertThat(compilation)
-        .hadErrorContaining(String.format(otherErrorFormat, "provided", "lazyCProvider()"))
-        .inFile(component)
-        .onLineContaining("lazyCProvider();");
-  }
-
-  @Test
-  public void bindsMethodAppearsInTrace() {
-    JavaFileObject component =
-        JavaFileObjects.forSourceLines(
-            "TestComponent",
-            "import dagger.Component;",
-            "",
-            "@Component(modules = TestModule.class)",
-            "interface TestComponent {",
-            "  TestInterface testInterface();",
-            "}");
-    JavaFileObject interfaceFile =
-        JavaFileObjects.forSourceLines("TestInterface", "interface TestInterface {}");
-    JavaFileObject implementationFile =
-        JavaFileObjects.forSourceLines(
-            "TestImplementation",
-            "import javax.inject.Inject;",
-            "",
-            "final class TestImplementation implements TestInterface {",
-            "  @Inject TestImplementation(String missingBinding) {}",
-            "}");
-    JavaFileObject module =
-        JavaFileObjects.forSourceLines(
-            "TestModule",
-            "import dagger.Binds;",
-            "import dagger.Module;",
-            "",
-            "@Module",
-            "interface TestModule {",
-            "  @Binds abstract TestInterface bindTestInterface(TestImplementation implementation);",
-            "}");
-    Compilation compilation =
-        daggerCompiler().compile(component, module, interfaceFile, implementationFile);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining(
-            Joiner.on("\n      ")
-                .join(
-                    "java.lang.String cannot be provided without an @Inject constructor or an "
-                        + "@Provides-annotated method.",
-                    "java.lang.String is injected at",
-                    "    TestImplementation.<init>(missingBinding)",
-                    "TestImplementation is injected at",
-                    "    TestModule.bindTestInterface(implementation)",
-                    "TestInterface is provided at",
-                    "    TestComponent.testInterface()"))
-        .inFile(component)
-        .onLine(5);
-  }
-
-  @Test
-  public void bindsMissingRightHandSide() {
-    JavaFileObject duplicates =
-        JavaFileObjects.forSourceLines(
-            "test.Duplicates",
-            "package test;",
-            "",
-            "import dagger.Binds;",
-            "import dagger.Component;",
-            "import dagger.Module;",
-            "import dagger.multibindings.IntKey;",
-            "import dagger.multibindings.IntoSet;",
-            "import dagger.multibindings.IntoMap;",
-            "import dagger.multibindings.LongKey;",
-            "import dagger.Provides;",
-            "import javax.inject.Inject;",
-            "",
-            "interface Duplicates {",
-            "",
-            "  interface BoundTwice {}",
-            "",
-            "  class BoundImpl implements BoundTwice {",
-            "    @Inject BoundImpl() {}",
-            "  }",
-            "",
-            "  class NotBound implements BoundTwice {}",
-            "",
-            "  @Module",
-            "  abstract class DuplicatesModule {",
-            "    @Binds abstract BoundTwice bindWithResolvedKey(BoundImpl impl);",
-            "    @Binds abstract BoundTwice bindWithUnresolvedKey(NotBound notBound);",
-            "",
-            "    @Binds abstract Object bindObject(NotBound notBound);",
-            "",
-            "    @Binds @IntoSet abstract BoundTwice bindWithUnresolvedKey_set(NotBound notBound);",
-            "",
-            "    @Binds @IntoMap @IntKey(1)",
-            "    abstract BoundTwice bindWithUnresolvedKey_intMap(NotBound notBound);",
-            "",
-            "    @Provides @IntoMap @LongKey(2L)",
-            "    static BoundTwice provideWithUnresolvedKey_longMap(BoundImpl impl) {",
-            "      return impl;",
-            "    }",
-            "    @Binds @IntoMap @LongKey(2L)",
-            "    abstract BoundTwice bindWithUnresolvedKey_longMap(NotBound notBound);",
-            "  }",
-            "}");
-    JavaFileObject component =
-        JavaFileObjects.forSourceLines(
-            "test.C",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "import java.util.Set;",
-            "import java.util.Map;",
-            "import test.Duplicates.BoundTwice;",
-            "",
-            "@Component(modules = Duplicates.DuplicatesModule.class)",
-            "interface C {",
-            "  BoundTwice boundTwice();",
-            "  Object object();",
-            "  Set<BoundTwice> set();",
-            "  Map<Integer, BoundTwice> intMap();",
-            "  Map<Long, BoundTwice> longMap();",
-            "}");
-
-    Compilation compilation = daggerCompiler().compile(duplicates, component);
-    assertThat(compilation).failed();
-    // Some javacs report only the first error for each source line.
-    // Assert that one of the expected errors is reported.
-    assertThat(compilation)
-        .hadErrorContainingMatch(
-            "\\Qtest.Duplicates.NotBound cannot be provided\\E|"
-                + error(
-                    "\\Qtest.Duplicates.BoundTwice is bound multiple times:",
-                    "@Binds test.Duplicates.BoundTwice "
-                        + "test.Duplicates.DuplicatesModule"
-                        + ".bindWithResolvedKey(test.Duplicates.BoundImpl)",
-                    "@Binds test.Duplicates.BoundTwice "
-                        + "test.Duplicates.DuplicatesModule"
-                        + ".bindWithUnresolvedKey(test.Duplicates.NotBound)"))
-        .inFile(component)
-        .onLineContaining("boundTwice();");
-    assertThat(compilation)
-        .hadErrorContaining("test.Duplicates.NotBound cannot be provided")
-        .inFile(component)
-        .onLineContaining("object();");
-    assertThat(compilation)
-        .hadErrorContaining("test.Duplicates.NotBound cannot be provided")
-        .inFile(component)
-        .onLineContaining("set();");
-    assertThat(compilation)
-        .hadErrorContaining("test.Duplicates.NotBound cannot be provided")
-        .inFile(component)
-        .onLineContaining("intMap();");
-    // Some javacs report only the first error for each source line.
-    // Assert that one of the expected errors is reported.
-    assertThat(compilation)
-        .hadErrorContainingMatch(
-            "test\\.Duplicates\\.NotBound cannot be provided|same map key is bound more than once")
-        .inFile(component)
-        .onLineContaining("longMap();");
-  }
-
-  @Test public void resolvedParametersInDependencyTrace() {
-    JavaFileObject generic = JavaFileObjects.forSourceLines("test.Generic",
-        "package test;",
-        "",
-        "import javax.inject.Inject;",
-        "import javax.inject.Provider;",
-        "",
-        "final class Generic<T> {",
-        "  @Inject Generic(T t) {}",
-        "}");
-    JavaFileObject testClass = JavaFileObjects.forSourceLines("test.TestClass",
-        "package test;",
-        "",
-        "import javax.inject.Inject;",
-        "import java.util.List;",
-        "",
-        "final class TestClass {",
-        "  @Inject TestClass(List list) {}",
-        "}");
-    JavaFileObject usesTest = JavaFileObjects.forSourceLines("test.UsesTest",
-        "package test;",
-        "",
-        "import javax.inject.Inject;",
-        "",
-        "final class UsesTest {",
-        "  @Inject UsesTest(Generic<TestClass> genericTestClass) {}",
-        "}");
-    JavaFileObject component = JavaFileObjects.forSourceLines("test.TestComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "",
-        "@Component",
-        "interface TestComponent {",
-        "  UsesTest usesTest();",
-        "}");
-    String expectedMsg =
-        Joiner.on("\n")
-            .join(
-                "java.util.List cannot be provided without an @Provides-annotated method.",
-                "      java.util.List is injected at",
-                "          test.TestClass.<init>(list)",
-                "      test.TestClass is injected at",
-                "          test.Generic.<init>(t)",
-                "      test.Generic<test.TestClass> is injected at",
-                "          test.UsesTest.<init>(genericTestClass)",
-                "      test.UsesTest is provided at",
-                "          test.TestComponent.usesTest()");
-    Compilation compilation = daggerCompiler().compile(generic, testClass, usesTest, component);
-    assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(expectedMsg);
-  }
-
-  @Test public void resolvedVariablesInDependencyTrace() {
-    JavaFileObject generic = JavaFileObjects.forSourceLines("test.Generic",
-        "package test;",
-        "",
-        "import javax.inject.Inject;",
-        "import javax.inject.Provider;",
-        "",
-        "final class Generic<T> {",
-        "  @Inject T t;",
-        "  @Inject Generic() {}",
-        "}");
-    JavaFileObject testClass = JavaFileObjects.forSourceLines("test.TestClass",
-        "package test;",
-        "",
-        "import javax.inject.Inject;",
-        "import java.util.List;",
-        "",
-        "final class TestClass {",
-        "  @Inject TestClass(List list) {}",
-        "}");
-    JavaFileObject usesTest = JavaFileObjects.forSourceLines("test.UsesTest",
-        "package test;",
-        "",
-        "import javax.inject.Inject;",
-        "",
-        "final class UsesTest {",
-        "  @Inject UsesTest(Generic<TestClass> genericTestClass) {}",
-        "}");
-    JavaFileObject component = JavaFileObjects.forSourceLines("test.TestComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "",
-        "@Component",
-        "interface TestComponent {",
-        "  UsesTest usesTest();",
-        "}");
-    String expectedMsg =
-        Joiner.on("\n")
-            .join(
-                "java.util.List cannot be provided without an @Provides-annotated method.",
-                "      java.util.List is injected at",
-                "          test.TestClass.<init>(list)",
-                "      test.TestClass is injected at",
-                "          test.Generic.t",
-                "      test.Generic<test.TestClass> is injected at",
-                "          test.UsesTest.<init>(genericTestClass)",
-                "      test.UsesTest is provided at",
-                "          test.TestComponent.usesTest()");
-    Compilation compilation = daggerCompiler().compile(generic, testClass, usesTest, component);
-    assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(expectedMsg);
-  }
-
-  @Test public void nullCheckForConstructorParameters() {
-    JavaFileObject a = JavaFileObjects.forSourceLines("test.A",
-        "package test;",
-        "",
-        "import javax.inject.Inject;",
-        "",
-        "final class A {",
-        "  @Inject A(String string) {}",
-        "}");
-    JavaFileObject module = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import dagger.Provides;",
-        "import javax.inject.Inject;",
-        "",
-        "@dagger.Module",
-        "final class TestModule {",
-        "  @Nullable @Provides String provideString() { return null; }",
-        "}");
-    JavaFileObject component = JavaFileObjects.forSourceLines("test.TestComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "",
-        "@Component(modules = TestModule.class)",
-        "interface TestComponent {",
-        "  A a();",
-        "}");
-    Compilation compilation = daggerCompiler().compile(NULLABLE, a, module, component);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining(
-            nullableToNonNullable(
-                "java.lang.String",
-                "@test.Nullable @Provides String test.TestModule.provideString()"));
-
-    // but if we disable the validation, then it compiles fine.
-    Compilation compilation2 =
-        javac()
-            .withOptions("-Adagger.nullableValidation=WARNING")
-            .withProcessors(new ComponentProcessor())
-            .compile(NULLABLE, a, module, component);
-    assertThat(compilation2).succeeded();
-  }
-
-  @Test public void nullCheckForMembersInjectParam() {
-    JavaFileObject a = JavaFileObjects.forSourceLines("test.A",
-        "package test;",
-        "",
-        "import javax.inject.Inject;",
-        "",
-        "final class A {",
-        "  @Inject A() {}",
-        "  @Inject void register(String string) {}",
-        "}");
-    JavaFileObject module = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import dagger.Provides;",
-        "import javax.inject.Inject;",
-        "",
-        "@dagger.Module",
-        "final class TestModule {",
-        "  @Nullable @Provides String provideString() { return null; }",
-        "}");
-    JavaFileObject component = JavaFileObjects.forSourceLines("test.TestComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "",
-        "@Component(modules = TestModule.class)",
-        "interface TestComponent {",
-        "  A a();",
-        "}");
-    Compilation compilation = daggerCompiler().compile(NULLABLE, a, module, component);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining(
-            nullableToNonNullable(
-                "java.lang.String",
-                "@test.Nullable @Provides String test.TestModule.provideString()"));
-
-    // but if we disable the validation, then it compiles fine.
-    Compilation compilation2 =
-        javac()
-            .withOptions("-Adagger.nullableValidation=WARNING")
-            .withProcessors(new ComponentProcessor())
-            .compile(NULLABLE, a, module, component);
-    assertThat(compilation2).succeeded();
-  }
-
-  @Test public void nullCheckForVariable() {
-    JavaFileObject a = JavaFileObjects.forSourceLines("test.A",
-        "package test;",
-        "",
-        "import javax.inject.Inject;",
-        "",
-        "final class A {",
-        "  @Inject String string;",
-        "  @Inject A() {}",
-        "}");
-    JavaFileObject module = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import dagger.Provides;",
-        "import javax.inject.Inject;",
-        "",
-        "@dagger.Module",
-        "final class TestModule {",
-        "  @Nullable @Provides String provideString() { return null; }",
-        "}");
-    JavaFileObject component = JavaFileObjects.forSourceLines("test.TestComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "",
-        "@Component(modules = TestModule.class)",
-        "interface TestComponent {",
-        "  A a();",
-        "}");
-    Compilation compilation = daggerCompiler().compile(NULLABLE, a, module, component);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining(
-            nullableToNonNullable(
-                "java.lang.String",
-                "@test.Nullable @Provides String test.TestModule.provideString()"));
-
-    // but if we disable the validation, then it compiles fine.
-    Compilation compilation2 =
-        javac()
-            .withOptions("-Adagger.nullableValidation=WARNING")
-            .withProcessors(new ComponentProcessor())
-            .compile(NULLABLE, a, module, component);
-    assertThat(compilation2).succeeded();
-  }
-
-  @Test public void nullCheckForComponentReturn() {
-    JavaFileObject module = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import dagger.Provides;",
-        "import javax.inject.Inject;",
-        "",
-        "@dagger.Module",
-        "final class TestModule {",
-        "  @Nullable @Provides String provideString() { return null; }",
-        "}");
-    JavaFileObject component = JavaFileObjects.forSourceLines("test.TestComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "",
-        "@Component(modules = TestModule.class)",
-        "interface TestComponent {",
-        "  String string();",
-        "}");
-    Compilation compilation = daggerCompiler().compile(NULLABLE, module, component);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining(
-            nullableToNonNullable(
-                "java.lang.String",
-                "@test.Nullable @Provides String test.TestModule.provideString()"));
-
-    // but if we disable the validation, then it compiles fine.
-    Compilation compilation2 =
-        javac()
-            .withOptions("-Adagger.nullableValidation=WARNING")
-            .withProcessors(new ComponentProcessor())
-            .compile(NULLABLE, module, component);
-    assertThat(compilation2).succeeded();
-  }
-
-  @Test
-  public void nullCheckForOptionalInstance() {
-    JavaFileObject a =
-        JavaFileObjects.forSourceLines(
-            "test.A",
-            "package test;",
-            "",
-            "import com.google.common.base.Optional;",
-            "import javax.inject.Inject;",
-            "",
-            "final class A {",
-            "  @Inject A(Optional<String> optional) {}",
-            "}");
-    JavaFileObject module =
-        JavaFileObjects.forSourceLines(
-            "test.TestModule",
-            "package test;",
-            "",
-            "import dagger.BindsOptionalOf;",
-            "import dagger.Provides;",
-            "import javax.inject.Inject;",
-            "",
-            "@dagger.Module",
-            "abstract class TestModule {",
-            "  @Nullable @Provides static String provideString() { return null; }",
-            "  @BindsOptionalOf abstract String optionalString();",
-            "}");
-    JavaFileObject component =
-        JavaFileObjects.forSourceLines(
-            "test.TestComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "",
-            "@Component(modules = TestModule.class)",
-            "interface TestComponent {",
-            "  A a();",
-            "}");
-    Compilation compilation = daggerCompiler().compile(NULLABLE, a, module, component);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining(
-            nullableToNonNullable(
-                "java.lang.String",
-                "@test.Nullable @Provides String test.TestModule.provideString()"));
-  }
-
-  @Test
-  public void nullCheckForOptionalProvider() {
-    JavaFileObject a =
-        JavaFileObjects.forSourceLines(
-            "test.A",
-            "package test;",
-            "",
-            "import com.google.common.base.Optional;",
-            "import javax.inject.Inject;",
-            "import javax.inject.Provider;",
-            "",
-            "final class A {",
-            "  @Inject A(Optional<Provider<String>> optional) {}",
-            "}");
-    JavaFileObject module =
-        JavaFileObjects.forSourceLines(
-            "test.TestModule",
-            "package test;",
-            "",
-            "import dagger.BindsOptionalOf;",
-            "import dagger.Provides;",
-            "import javax.inject.Inject;",
-            "",
-            "@dagger.Module",
-            "abstract class TestModule {",
-            "  @Nullable @Provides static String provideString() { return null; }",
-            "  @BindsOptionalOf abstract String optionalString();",
-            "}");
-    JavaFileObject component =
-        JavaFileObjects.forSourceLines(
-            "test.TestComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "",
-            "@Component(modules = TestModule.class)",
-            "interface TestComponent {",
-            "  A a();",
-            "}");
-    Compilation compilation = daggerCompiler().compile(NULLABLE, a, module, component);
-    assertThat(compilation).succeeded();
-  }
-
-  @Test
-  public void nullCheckForOptionalLazy() {
-    JavaFileObject a =
-        JavaFileObjects.forSourceLines(
-            "test.A",
-            "package test;",
-            "",
-            "import com.google.common.base.Optional;",
-            "import dagger.Lazy;",
-            "import javax.inject.Inject;",
-            "",
-            "final class A {",
-            "  @Inject A(Optional<Lazy<String>> optional) {}",
-            "}");
-    JavaFileObject module =
-        JavaFileObjects.forSourceLines(
-            "test.TestModule",
-            "package test;",
-            "",
-            "import dagger.BindsOptionalOf;",
-            "import dagger.Provides;",
-            "import javax.inject.Inject;",
-            "",
-            "@dagger.Module",
-            "abstract class TestModule {",
-            "  @Nullable @Provides static String provideString() { return null; }",
-            "  @BindsOptionalOf abstract String optionalString();",
-            "}");
-    JavaFileObject component =
-        JavaFileObjects.forSourceLines(
-            "test.TestComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "",
-            "@Component(modules = TestModule.class)",
-            "interface TestComponent {",
-            "  A a();",
-            "}");
-    Compilation compilation = daggerCompiler().compile(NULLABLE, a, module, component);
-    assertThat(compilation).succeeded();
-  }
-
-  @Test
-  public void nullCheckForOptionalProviderOfLazy() {
-    JavaFileObject a =
-        JavaFileObjects.forSourceLines(
-            "test.A",
-            "package test;",
-            "",
-            "import com.google.common.base.Optional;",
-            "import dagger.Lazy;",
-            "import javax.inject.Inject;",
-            "import javax.inject.Provider;",
-            "",
-            "final class A {",
-            "  @Inject A(Optional<Provider<Lazy<String>>> optional) {}",
-            "}");
-    JavaFileObject module =
-        JavaFileObjects.forSourceLines(
-            "test.TestModule",
-            "package test;",
-            "",
-            "import dagger.BindsOptionalOf;",
-            "import dagger.Provides;",
-            "import javax.inject.Inject;",
-            "",
-            "@dagger.Module",
-            "abstract class TestModule {",
-            "  @Nullable @Provides static String provideString() { return null; }",
-            "  @BindsOptionalOf abstract String optionalString();",
-            "}");
-    JavaFileObject component =
-        JavaFileObjects.forSourceLines(
-            "test.TestComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "",
-            "@Component(modules = TestModule.class)",
-            "interface TestComponent {",
-            "  A a();",
-            "}");
-    Compilation compilation = daggerCompiler().compile(NULLABLE, a, module, component);
-    assertThat(compilation).succeeded();
-  }
-
-  @Test public void componentDependencyMustNotCycle_Direct() {
-    JavaFileObject shortLifetime = JavaFileObjects.forSourceLines("test.ComponentShort",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "",
-        "@Component(dependencies = ComponentShort.class)",
-        "interface ComponentShort {",
-        "}");
-    String errorMessage =
-        "test.ComponentShort contains a cycle in its component dependencies:\n"
-            + "      test.ComponentShort";
-    Compilation compilation = daggerCompiler().compile(shortLifetime);
-    assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(errorMessage);
-  }
-
-  @Test public void componentDependencyMustNotCycle_Indirect() {
-    JavaFileObject longLifetime = JavaFileObjects.forSourceLines("test.ComponentLong",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "",
-        "@Component(dependencies = ComponentMedium.class)",
-        "interface ComponentLong {",
-        "}");
-    JavaFileObject mediumLifetime = JavaFileObjects.forSourceLines("test.ComponentMedium",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "",
-        "@Component(dependencies = ComponentLong.class)",
-        "interface ComponentMedium {",
-        "}");
-    JavaFileObject shortLifetime = JavaFileObjects.forSourceLines("test.ComponentShort",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "",
-        "@Component(dependencies = ComponentMedium.class)",
-        "interface ComponentShort {",
-        "}");
-    String longErrorMessage =
-        "test.ComponentLong contains a cycle in its component dependencies:\n"
-            + "      test.ComponentLong\n"
-            + "      test.ComponentMedium\n"
-            + "      test.ComponentLong";
-    String mediumErrorMessage =
-        "test.ComponentMedium contains a cycle in its component dependencies:\n"
-            + "      test.ComponentMedium\n"
-            + "      test.ComponentLong\n"
-            + "      test.ComponentMedium";
-    String shortErrorMessage =
-        "test.ComponentShort contains a cycle in its component dependencies:\n"
-            + "      test.ComponentMedium\n"
-            + "      test.ComponentLong\n"
-            + "      test.ComponentMedium\n"
-            + "      test.ComponentShort";
-    Compilation compilation = daggerCompiler().compile(longLifetime, mediumLifetime, shortLifetime);
-    assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(longErrorMessage).inFile(longLifetime);
-    assertThat(compilation).hadErrorContaining(mediumErrorMessage).inFile(mediumLifetime);
-    assertThat(compilation).hadErrorContaining(shortErrorMessage).inFile(shortLifetime);
-  }
-
-  @Test
-  public void childBindingConflictsWithParent() {
-    JavaFileObject aComponent =
-        JavaFileObjects.forSourceLines(
-            "test.A",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "",
-            "@Component(modules = A.AModule.class)",
-            "interface A {",
-            "  Object conflict();",
-            "",
-            "  B b();",
-            "",
-            "  @Module",
-            "  static class AModule {",
-            "    @Provides static Object abConflict() {",
-            "      return \"a\";",
-            "    }",
-            "  }",
-            "}");
-    JavaFileObject bComponent =
-        JavaFileObjects.forSourceLines(
-            "test.B",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent(modules = B.BModule.class)",
-            "interface B {",
-            "  Object conflict();",
-            "",
-            "  @Module",
-            "  static class BModule {",
-            "    @Provides static Object abConflict() {",
-            "      return \"b\";",
-            "    }",
-            "  }",
-            "}");
-    Compilation compilation = daggerCompiler().compile(aComponent, bComponent);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining(
-            error(
-                "[test.B.conflict()] java.lang.Object is bound multiple times:",
-                "@Provides Object test.A.AModule.abConflict()",
-                "@Provides Object test.B.BModule.abConflict()"))
-        .inFile(aComponent)
-        .onLineContaining("interface A {");
-  }
-
-  @Test
-  public void grandchildBindingConflictsWithGrandparent() {
-    JavaFileObject aComponent =
-        JavaFileObjects.forSourceLines(
-            "test.A",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "",
-            "@Component(modules = A.AModule.class)",
-            "interface A {",
-            "  Object conflict();",
-            "",
-            "  B b();",
-            "",
-            "  @Module",
-            "  static class AModule {",
-            "    @Provides static Object acConflict() {",
-            "      return \"a\";",
-            "    }",
-            "  }",
-            "}");
-    JavaFileObject bComponent =
-        JavaFileObjects.forSourceLines(
-            "test.B",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent",
-            "interface B {",
-            "  C c();",
-            "}");
-    JavaFileObject cComponent =
-        JavaFileObjects.forSourceLines(
-            "test.C",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent(modules = C.CModule.class)",
-            "interface C {",
-            "  Object conflict();",
-            "",
-            "  @Module",
-            "  static class CModule {",
-            "    @Provides static Object acConflict() {",
-            "      return \"c\";",
-            "    }",
-            "  }",
-            "}");
-    Compilation compilation = daggerCompiler().compile(aComponent, bComponent, cComponent);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining(
-            error(
-                "[test.C.conflict()] java.lang.Object is bound multiple times:",
-                "@Provides Object test.A.AModule.acConflict()",
-                "@Provides Object test.C.CModule.acConflict()"))
-        .inFile(aComponent)
-        .onLineContaining("interface A {");
-  }
-
-  @Test
-  public void grandchildBindingConflictsWithChild() {
-    JavaFileObject aComponent =
-        JavaFileObjects.forSourceLines(
-            "test.A",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "",
-            "@Component",
-            "interface A {",
-            "  B b();",
-            "}");
-    JavaFileObject bComponent =
-        JavaFileObjects.forSourceLines(
-            "test.B",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent(modules = B.BModule.class)",
-            "interface B {",
-            "  Object conflict();",
-            "",
-            "  C c();",
-            "",
-            "  @Module",
-            "  static class BModule {",
-            "    @Provides static Object bcConflict() {",
-            "      return \"b\";",
-            "    }",
-            "  }",
-            "}");
-    JavaFileObject cComponent =
-        JavaFileObjects.forSourceLines(
-            "test.C",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent(modules = C.CModule.class)",
-            "interface C {",
-            "  Object conflict();",
-            "",
-            "  @Module",
-            "  static class CModule {",
-            "    @Provides static Object bcConflict() {",
-            "      return \"c\";",
-            "    }",
-            "  }",
-            "}");
-    Compilation compilation = daggerCompiler().compile(aComponent, bComponent, cComponent);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining(
-            error(
-                "[test.C.conflict()] java.lang.Object is bound multiple times:",
-                "@Provides Object test.B.BModule.bcConflict()",
-                "@Provides Object test.C.CModule.bcConflict()"))
-        .inFile(aComponent)
-        .onLineContaining("interface A {");
-  }
-
-  @Test
-  public void grandchildBindingConflictsWithParentWithNullableViolationAsWarning() {
-    JavaFileObject parentConflictsWithChild =
-        JavaFileObjects.forSourceLines(
-            "test.ParentConflictsWithChild",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import javax.annotation.Nullable;",
-            "",
-            "@Component(modules = ParentConflictsWithChild.ParentModule.class)",
-            "interface ParentConflictsWithChild {",
-            "  Child child();",
-            "",
-            "  @Module",
-            "  static class ParentModule {",
-            "    @Provides @Nullable static Object nullableParentChildConflict() {",
-            "      return \"parent\";",
-            "    }",
-            "  }",
-            "}");
-    JavaFileObject child =
-        JavaFileObjects.forSourceLines(
-            "test.Child",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent(modules = Child.ChildModule.class)",
-            "interface Child {",
-            "  Object parentChildConflictThatViolatesNullability();",
-            "",
-            "  @Module",
-            "  static class ChildModule {",
-            "    @Provides static Object nonNullableParentChildConflict() {",
-            "      return \"child\";",
-            "    }",
-            "  }",
-            "}");
-    Compilation compilation =
-        javac()
-            .withOptions("-Adagger.nullableValidation=WARNING")
-            .withProcessors(new ComponentProcessor())
-            .compile(parentConflictsWithChild, child);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining(
-            error(
-                "[test.Child.parentChildConflictThatViolatesNullability()] "
-                    + "java.lang.Object is bound multiple times:",
-                "@Provides Object test.Child.ChildModule.nonNullableParentChildConflict()",
-                "@Provides @javax.annotation.Nullable Object"
-                    + " test.ParentConflictsWithChild.ParentModule.nullableParentChildConflict()"))
-        .inFile(parentConflictsWithChild)
-        .onLine(9);
-  }
-
-  @Test
-  public void bindingUsedOnlyInSubcomponentDependsOnBindingOnlyInSubcomponent() {
-    JavaFileObject parent =
-        JavaFileObjects.forSourceLines(
-            "Parent",
-            "import dagger.Component;",
-            "",
-            "@Component(modules = ParentModule.class)",
-            "interface Parent {",
-            "  Child child();",
-            "}");
-    JavaFileObject parentModule =
-        JavaFileObjects.forSourceLines(
-            "ParentModule",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "",
-            "@Module",
-            "class ParentModule {",
-            "  @Provides static Object needsString(String string) {",
-            "    return \"needs string: \" + string;",
-            "  }",
-            "}");
-    JavaFileObject child =
-        JavaFileObjects.forSourceLines(
-            "Child",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent(modules = ChildModule.class)",
-            "interface Child {",
-            "  String string();",
-            "  Object needsString();",
-            "}");
-    JavaFileObject childModule =
-        JavaFileObjects.forSourceLines(
-            "ChildModule",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "",
-            "@Module",
-            "class ChildModule {",
-            "  @Provides static String string() {",
-            "    return \"child string\";",
-            "  }",
-            "}");
-    Compilation compilation = daggerCompiler().compile(parent, parentModule, child, childModule);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining("[Child.needsString()] java.lang.String cannot be provided")
-        .inFile(parent)
-        .onLine(4);
-  }
-
-  @Test
-  public void multibindingContributionBetweenAncestorComponentAndEntrypointComponent() {
-    JavaFileObject parent =
-        JavaFileObjects.forSourceLines(
-            "Parent",
-            "import dagger.Component;",
-            "",
-            "@Component(modules = ParentModule.class)",
-            "interface Parent {",
-            "  Child child();",
-            "}");
-    JavaFileObject child =
-        JavaFileObjects.forSourceLines(
-            "Child",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent(modules = ChildModule.class)",
-            "interface Child {",
-            "  Grandchild grandchild();",
-            "}");
-    JavaFileObject grandchild =
-        JavaFileObjects.forSourceLines(
-            "Grandchild",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent",
-            "interface Grandchild {",
-            "  Object object();",
-            "}");
-
-    JavaFileObject parentModule =
-        JavaFileObjects.forSourceLines(
-            "ParentModule",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.multibindings.IntoSet;",
-            "import java.util.Set;",
-            "",
-            "@Module",
-            "class ParentModule {",
-            "  @Provides static Object dependsOnSet(Set<String> strings) {",
-            "    return \"needs strings: \" + strings;",
-            "  }",
-            "",
-            "  @Provides @IntoSet static String contributesToSet() {",
-            "    return \"parent string\";",
-            "  }",
-            "",
-            "  @Provides int missingDependency(double dub) {",
-            "    return 4;",
-            "  }",
-            "}");
-    JavaFileObject childModule =
-        JavaFileObjects.forSourceLines(
-            "ChildModule",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.multibindings.IntoSet;",
-            "",
-            "@Module",
-            "class ChildModule {",
-            "  @Provides @IntoSet static String contributesToSet(int i) {",
-            "    return \"\" + i;",
-            "  }",
-            "}");
-    Compilation compilation =
-        daggerCompiler().compile(parent, parentModule, child, childModule, grandchild);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining("[Grandchild.object()] java.lang.Double cannot be provided")
-        .inFile(parent)
-        .onLine(4);
-  }
-
-  @Test
-  public void missingReleasableReferenceManager() {
-    JavaFileObject testScope =
-        JavaFileObjects.forSourceLines(
-            "test.TestScope",
-            "package test;",
-            "",
-            "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
-            "",
-            "import dagger.releasablereferences.CanReleaseReferences;",
-            "import java.lang.annotation.Retention;",
-            "import javax.inject.Scope;",
-            "",
-            "@CanReleaseReferences",
-            "@BadMetadata",
-            "@Scope",
-            "@Retention(RUNTIME)",
-            "@interface TestScope {}");
-    JavaFileObject otherScope =
-        JavaFileObjects.forSourceLines(
-            "test.OtherScope",
-            "package test;",
-            "",
-            "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
-            "",
-            "import dagger.releasablereferences.CanReleaseReferences;",
-            "import java.lang.annotation.Retention;",
-            "import javax.inject.Scope;",
-            "",
-            "@CanReleaseReferences",
-            "@Scope",
-            "@Retention(RUNTIME)",
-            "@interface OtherScope {}");
-    JavaFileObject yetAnotherScope =
-        JavaFileObjects.forSourceLines(
-            "test.YetAnotherScope",
-            "package test;",
-            "",
-            "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
-            "",
-            "import dagger.releasablereferences.CanReleaseReferences;",
-            "import java.lang.annotation.Retention;",
-            "import javax.inject.Scope;",
-            "",
-            "@CanReleaseReferences",
-            "@Scope",
-            "@Retention(RUNTIME)",
-            "@interface YetAnotherScope {}");
-    JavaFileObject testMetadata =
-        JavaFileObjects.forSourceLines(
-            "test.TestMetadata",
-            "package test;",
-            "",
-            "import dagger.releasablereferences.CanReleaseReferences;",
-            "",
-            "@CanReleaseReferences",
-            "@interface TestMetadata {}");
-    JavaFileObject badMetadata =
-        JavaFileObjects.forSourceLines(
-            "test.BadMetadata", // force one-string-per-line format
-            "package test;",
-            "",
-            "@interface BadMetadata {}");
-    JavaFileObject component =
-        JavaFileObjects.forSourceLines(
-            "test.TestComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "import dagger.releasablereferences.ForReleasableReferences;",
-            "import dagger.releasablereferences.ReleasableReferenceManager;",
-            "import dagger.releasablereferences.TypedReleasableReferenceManager;",
-            "",
-            "@TestScope",
-            "@YetAnotherScope",
-            "@Component",
-            "interface TestComponent {",
-            "  @ForReleasableReferences(OtherScope.class)",
-            "  ReleasableReferenceManager otherManager();",
-            "",
-            "  @ForReleasableReferences(TestScope.class)",
-            "  TypedReleasableReferenceManager<TestMetadata> typedManager();",
-            "",
-            "  @ForReleasableReferences(TestScope.class)",
-            "  TypedReleasableReferenceManager<BadMetadata> badManager();",
-            "}");
-    Compilation compilation =
-        daggerCompiler()
-            .compile(testScope, otherScope, yetAnotherScope, testMetadata, badMetadata, component);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining(
-            "There is no binding for "
-                + "@dagger.releasablereferences.ForReleasableReferences(test.OtherScope.class) "
-                + "dagger.releasablereferences.ReleasableReferenceManager "
-                + "because no component in test.TestComponent's component hierarchy is annotated "
-                + "with @test.OtherScope. "
-                + "The available reference-releasing scopes are "
-                + "[@test.TestScope, @test.YetAnotherScope].")
-        .inFile(component)
-        .onLine(13);
-    assertThat(compilation)
-        .hadErrorContaining(
-            "There is no binding for "
-                + "@dagger.releasablereferences.ForReleasableReferences(test.TestScope.class) "
-                + "dagger.releasablereferences.TypedReleasableReferenceManager<test.TestMetadata> "
-                + "because test.TestScope is not annotated with @test.TestMetadata")
-        .inFile(component)
-        .onLine(16);
-    assertThat(compilation)
-        .hadErrorContaining(
-            "There is no binding for "
-                + "@dagger.releasablereferences.ForReleasableReferences(test.TestScope.class) "
-                + "dagger.releasablereferences.TypedReleasableReferenceManager<test.BadMetadata> "
-                + "because test.BadMetadata is not annotated with "
-                + "@dagger.releasablereferences.CanReleaseReferences")
-        .inFile(component)
-        .onLine(19);
-  }
-
-  @Test
-  public void releasableReferenceManagerConflict() {
-    JavaFileObject testScope =
-        JavaFileObjects.forSourceLines(
-            "test.TestScope",
-            "package test;",
-            "",
-            "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
-            "",
-            "import dagger.releasablereferences.CanReleaseReferences;",
-            "import java.lang.annotation.Retention;",
-            "import javax.inject.Scope;",
-            "",
-            "@TestMetadata",
-            "@CanReleaseReferences",
-            "@Scope",
-            "@Retention(RUNTIME)",
-            "@interface TestScope {}");
-    JavaFileObject testMetadata =
-        JavaFileObjects.forSourceLines(
-            "test.TestMetadata",
-            "package test;",
-            "",
-            "import dagger.releasablereferences.CanReleaseReferences;",
-            "",
-            "@CanReleaseReferences",
-            "@interface TestMetadata {}");
-
-    JavaFileObject testModule =
-        JavaFileObjects.forSourceLines(
-            "test.TestModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.releasablereferences.ForReleasableReferences;",
-            "import dagger.releasablereferences.ReleasableReferenceManager;",
-            "import dagger.releasablereferences.TypedReleasableReferenceManager;",
-            "import java.util.Set;",
-            "",
-            "@Module",
-            "abstract class TestModule {",
-            "  @Provides @ForReleasableReferences(TestScope.class)",
-            "  static ReleasableReferenceManager rrm() {",
-            "    return null;",
-            "  }",
-            "",
-            "  @Provides @ForReleasableReferences(TestScope.class)",
-            "  static TypedReleasableReferenceManager<TestMetadata> typedRrm() {",
-            "    return null;",
-            "  }",
-            "",
-            "  @Provides",
-            "  static Set<ReleasableReferenceManager> rrmSet() {",
-            "    return null;",
-            "  }",
-            "",
-            "  @Provides",
-            "  static Set<TypedReleasableReferenceManager<TestMetadata>> typedRrmSet() {",
-            "    return null;",
-            "  }",
-            "}");
-
-    JavaFileObject component =
-        JavaFileObjects.forSourceLines(
-            "test.TestComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "import dagger.releasablereferences.ForReleasableReferences;",
-            "import dagger.releasablereferences.ReleasableReferenceManager;",
-            "import dagger.releasablereferences.TypedReleasableReferenceManager;",
-            "import java.util.Set;",
-            "",
-            "@TestScope",
-            "@Component(modules = TestModule.class)",
-            "interface TestComponent {",
-            "  @ForReleasableReferences(TestScope.class)",
-            "  ReleasableReferenceManager testManager();",
-            "",
-            "  @ForReleasableReferences(TestScope.class)",
-            "  TypedReleasableReferenceManager<TestMetadata> typedManager();",
-            "",
-            "  Set<ReleasableReferenceManager> managers();",
-            "  Set<TypedReleasableReferenceManager<TestMetadata>> typedManagers();",
-            "}");
-    Compilation compilation =
-        daggerCompiler().compile(testScope, testMetadata, testModule, component);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining(
-            String.format(
-                error(
-                    "@%1$s.ForReleasableReferences(test.TestScope.class) "
-                        + "%1$s.ReleasableReferenceManager is bound multiple times:",
-                    "@Provides @%1$s.ForReleasableReferences(test.TestScope.class) "
-                        + "%1$s.ReleasableReferenceManager test.TestModule.rrm()",
-                    "binding for "
-                        + "@%1$s.ForReleasableReferences(value = test.TestScope.class) "
-                        + "%1$s.ReleasableReferenceManager from the scope declaration"),
-                "dagger.releasablereferences"))
-        .inFile(component)
-        .onLine(13);
-    assertThat(compilation)
-        .hadErrorContaining(
-            String.format(
-                error(
-                    "@%1$s.ForReleasableReferences(test.TestScope.class) "
-                        + "%1$s.TypedReleasableReferenceManager<test.TestMetadata> "
-                        + "is bound multiple times:",
-                    "@Provides @%1$s.ForReleasableReferences(test.TestScope.class) "
-                        + "%1$s.TypedReleasableReferenceManager<test.TestMetadata> "
-                        + "test.TestModule.typedRrm()",
-                    "binding for "
-                        + "@%1$s.ForReleasableReferences(value = test.TestScope.class) "
-                        + "%1$s.TypedReleasableReferenceManager<test.TestMetadata> "
-                        + "from the scope declaration"),
-                "dagger.releasablereferences"))
-        .inFile(component)
-        .onLine(16);
-    assertThat(compilation)
-        .hadErrorContaining(
-            error(
-                "java.util.Set<dagger.releasablereferences.ReleasableReferenceManager> "
-                    + "is bound multiple times:",
-                "@Provides "
-                    + "Set<dagger.releasablereferences.ReleasableReferenceManager> "
-                    + "test.TestModule.rrmSet()",
-                "Dagger-generated binding for "
-                    + "Set<dagger.releasablereferences.ReleasableReferenceManager>"))
-        .inFile(component)
-        .onLine(18);
-    assertThat(compilation)
-        .hadErrorContaining(
-            String.format(
-                error(
-                    "java.util.Set<%1$s.TypedReleasableReferenceManager<test.TestMetadata>> "
-                        + "is bound multiple times:",
-                    "@Provides "
-                        + "Set<%1$s.TypedReleasableReferenceManager<test.TestMetadata>> "
-                        + "test.TestModule.typedRrmSet()",
-                    "Dagger-generated binding for "
-                        + "Set<%1$s.TypedReleasableReferenceManager<test.TestMetadata>>"),
-                "dagger.releasablereferences"))
-        .inFile(component)
-        .onLine(19);
-  }
-
-  @Test
-  public void abstractModuleWithInstanceMethod() {
-    JavaFileObject module =
-        JavaFileObjects.forSourceLines(
-            "test.TestModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "",
-            "@Module",
-            "abstract class TestModule {",
-            "  @Provides int i() { return 1; }",
-            "}");
-    JavaFileObject component =
-        JavaFileObjects.forSourceLines(
-            "test.TestComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "",
-            "@Component(modules = TestModule.class)",
-            "interface TestComponent {",
-            "  int i();",
-            "}");
-    Compilation compilation = daggerCompiler().compile(module, component);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining("TestModule is abstract and has instance @Provides methods")
-        .inFile(component)
-        .onLineContaining("interface TestComponent");
-  }
-
-  @Test
-  public void abstractModuleWithInstanceMethod_subclassedIsAllowed() {
-    JavaFileObject abstractModule =
-        JavaFileObjects.forSourceLines(
-            "test.AbstractModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "",
-            "@Module",
-            "abstract class AbstractModule {",
-            "  @Provides int i() { return 1; }",
-            "}");
-    JavaFileObject subclassedModule =
-        JavaFileObjects.forSourceLines(
-            "test.SubclassedModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "",
-            "@Module",
-            "class SubclassedModule extends AbstractModule {}");
-    JavaFileObject component =
-        JavaFileObjects.forSourceLines(
-            "test.TestComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "",
-            "@Component(modules = SubclassedModule.class)",
-            "interface TestComponent {",
-            "  int i();",
-            "}");
-    Compilation compilation = daggerCompiler().compile(abstractModule, subclassedModule, component);
-    assertThat(compilation).succeeded();
-  }
-
-  private String error(String... lines) {
-    return Joiner.on("\n      ").join(lines);
-  }
-}
diff --git a/javatests/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java b/javatests/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java
index 21de94a06..a852752e2 100644
--- a/javatests/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java
+++ b/javatests/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java
@@ -564,7 +564,7 @@
     assertThat(compilation).failed();
     // for whatever reason, javac only reports the error once on the constructor
     assertThat(compilation)
-        .hadErrorContaining("A single injection site may not use more than one @Qualifier")
+        .hadErrorContaining("A single dependency request may not use more than one @Qualifier")
         .inFile(file)
         .onLine(6);
   }
@@ -824,12 +824,12 @@
     Compilation compilation = daggerCompiler().compile(file, QUALIFIER_A, QUALIFIER_B);
     assertThat(compilation).failed();
     assertThat(compilation)
-        .hadErrorContaining("A single injection site may not use more than one @Qualifier")
+        .hadErrorContaining("A single dependency request may not use more than one @Qualifier")
         .inFile(file)
         .onLine(6)
         .atColumn(11);
     assertThat(compilation)
-        .hadErrorContaining("A single injection site may not use more than one @Qualifier")
+        .hadErrorContaining("A single dependency request may not use more than one @Qualifier")
         .inFile(file)
         .onLine(6)
         .atColumn(23);
@@ -943,7 +943,7 @@
     Compilation compilation = daggerCompiler().compile(file, QUALIFIER_A, QUALIFIER_B);
     assertThat(compilation).failed();
     assertThat(compilation)
-        .hadErrorContaining("A single injection site may not use more than one @Qualifier")
+        .hadErrorContaining("A single dependency request may not use more than one @Qualifier")
         .inFile(file)
         .onLine(6);
   }
diff --git a/javatests/dagger/internal/codegen/MapBindingComponentProcessorTest.java b/javatests/dagger/internal/codegen/MapBindingComponentProcessorTest.java
index 0f8d95789..05b4dc671 100644
--- a/javatests/dagger/internal/codegen/MapBindingComponentProcessorTest.java
+++ b/javatests/dagger/internal/codegen/MapBindingComponentProcessorTest.java
@@ -122,7 +122,7 @@ public void mapBindingsWithEnumKey() {
         "}");
     JavaFileObject generatedComponent;
     switch (compilerMode) {
-      case EXPERIMENTAL_ANDROID_MODE:
+      case FAST_INIT_MODE:
         generatedComponent =
             JavaFileObjects.forSourceLines(
                 "test.DaggerTestComponent",
@@ -527,7 +527,7 @@ public void mapBindingsWithStringKey() {
         "}");
     JavaFileObject generatedComponent;
     switch (compilerMode) {
-      case EXPERIMENTAL_ANDROID_MODE:
+      case FAST_INIT_MODE:
         generatedComponent =
             JavaFileObjects.forSourceLines(
                 "test.DaggerTestComponent",
@@ -725,7 +725,7 @@ public void mapBindingsWithWrappedKey() {
         "}");
     JavaFileObject generatedComponent;
     switch (compilerMode) {
-      case EXPERIMENTAL_ANDROID_MODE:
+      case FAST_INIT_MODE:
         generatedComponent =
             JavaFileObjects.forSourceLines(
                 "test.DaggerTestComponent",
@@ -937,7 +937,7 @@ public void mapBindingsWithNonProviderValue() {
         "}");
     JavaFileObject generatedComponent;
     switch (compilerMode) {
-      case EXPERIMENTAL_ANDROID_MODE:
+      case FAST_INIT_MODE:
         generatedComponent =
             JavaFileObjects.forSourceLines(
                 "test.DaggerTestComponent",
diff --git a/javatests/dagger/internal/codegen/MapBindingExpressionTest.java b/javatests/dagger/internal/codegen/MapBindingExpressionTest.java
index 547ad4ea8..7d6f62ccc 100644
--- a/javatests/dagger/internal/codegen/MapBindingExpressionTest.java
+++ b/javatests/dagger/internal/codegen/MapBindingExpressionTest.java
@@ -18,7 +18,7 @@
 
 import static com.google.testing.compile.CompilationSubject.assertThat;
 import static dagger.internal.codegen.CompilerMode.DEFAULT_MODE;
-import static dagger.internal.codegen.CompilerMode.EXPERIMENTAL_ANDROID_MODE;
+import static dagger.internal.codegen.CompilerMode.FAST_INIT_MODE;
 import static dagger.internal.codegen.Compilers.CLASS_PATH_WITHOUT_GUAVA_OPTION;
 import static dagger.internal.codegen.Compilers.daggerCompiler;
 import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
@@ -95,7 +95,7 @@ public void mapBindings() {
                 GENERATED_ANNOTATION,
                 "public final class DaggerTestComponent implements TestComponent {")
             .addLinesIn(
-                EXPERIMENTAL_ANDROID_MODE,
+                FAST_INIT_MODE,
                 "  private volatile Provider<Integer> provideIntProvider;",
                 "  private volatile Provider<Long> provideLong0Provider;",
                 "  private volatile Provider<Long> provideLong1Provider;",
@@ -159,7 +159,7 @@ public void mapBindings() {
                 DEFAULT_MODE, //
                 "        0, MapModule_ProvideIntFactory.create());")
             .addLinesIn(
-                EXPERIMENTAL_ANDROID_MODE,
+                FAST_INIT_MODE,
                 "        0, getMapOfIntegerAndProviderOfIntegerProvider());")
             .addLines(
                 "  }",
@@ -182,14 +182,14 @@ public void mapBindings() {
                 "        .put(1L, MapModule_ProvideLong1Factory.create())",
                 "        .put(2L, MapModule_ProvideLong2Factory.create())")
             .addLinesIn(
-                EXPERIMENTAL_ANDROID_MODE,
+                FAST_INIT_MODE,
                 "        .put(0L, getMapOfLongAndProviderOfLongProvider())",
                 "        .put(1L, getMapOfLongAndProviderOfLongProvider2())",
                 "        .put(2L, getMapOfLongAndProviderOfLongProvider3())")
             .addLines( //
                 "        .build();", "  }")
             .addLinesIn(
-                EXPERIMENTAL_ANDROID_MODE,
+                FAST_INIT_MODE,
                 "  private final class SwitchingProvider<T> implements Provider<T> {",
                 "    private final int id;",
                 "",
diff --git a/javatests/dagger/internal/codegen/MapBindingExpressionWithGuavaTest.java b/javatests/dagger/internal/codegen/MapBindingExpressionWithGuavaTest.java
index 672c074e4..343f2613d 100644
--- a/javatests/dagger/internal/codegen/MapBindingExpressionWithGuavaTest.java
+++ b/javatests/dagger/internal/codegen/MapBindingExpressionWithGuavaTest.java
@@ -18,7 +18,7 @@
 
 import static com.google.testing.compile.CompilationSubject.assertThat;
 import static dagger.internal.codegen.CompilerMode.DEFAULT_MODE;
-import static dagger.internal.codegen.CompilerMode.EXPERIMENTAL_ANDROID_MODE;
+import static dagger.internal.codegen.CompilerMode.FAST_INIT_MODE;
 import static dagger.internal.codegen.Compilers.daggerCompiler;
 import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
 
@@ -130,7 +130,7 @@ public void mapBindings() {
                 GENERATED_ANNOTATION,
                 "public final class DaggerTestComponent implements TestComponent {")
             .addLinesIn(
-                EXPERIMENTAL_ANDROID_MODE,
+                FAST_INIT_MODE,
                 "  private volatile Provider<Integer> provideIntProvider;",
                 "  private volatile Provider<Long> provideLong0Provider;",
                 "  private volatile Provider<Long> provideLong1Provider;",
@@ -194,7 +194,7 @@ public void mapBindings() {
                 DEFAULT_MODE, //
                 "        0, MapModule_ProvideIntFactory.create());")
             .addLinesIn(
-                EXPERIMENTAL_ANDROID_MODE,
+                FAST_INIT_MODE,
                 "        0, getMapOfIntegerAndProviderOfIntegerProvider());")
             .addLines(
                 "  }",
@@ -216,7 +216,7 @@ public void mapBindings() {
                 "      1L, MapModule_ProvideLong1Factory.create(),",
                 "      2L, MapModule_ProvideLong2Factory.create());")
             .addLinesIn(
-                EXPERIMENTAL_ANDROID_MODE,
+                FAST_INIT_MODE,
                 "      0L, getMapOfLongAndProviderOfLongProvider(),",
                 "      1L, getMapOfLongAndProviderOfLongProvider2(),",
                 "      2L, getMapOfLongAndProviderOfLongProvider3());")
@@ -230,7 +230,7 @@ public void mapBindings() {
                 "",
                 "  private final class SubImpl implements Sub {")
             .addLinesIn(
-                EXPERIMENTAL_ANDROID_MODE,
+                FAST_INIT_MODE,
                 "    private volatile Provider<Long> provideLong3Provider;",
                 "    private volatile Provider<Long> provideLong4Provider;",
                 "    private volatile Provider<Long> provideLong5Provider;",
@@ -287,7 +287,7 @@ public void mapBindings() {
                 "          .put(4L, SubcomponentMapModule_ProvideLong4Factory.create())",
                 "          .put(5L, SubcomponentMapModule_ProvideLong5Factory.create())")
             .addLinesIn(
-                EXPERIMENTAL_ANDROID_MODE,
+                FAST_INIT_MODE,
                 "          .put(0L, DaggerTestComponent.this",
                 "              .getMapOfLongAndProviderOfLongProvider())",
                 "          .put(1L, DaggerTestComponent.this",
@@ -300,7 +300,7 @@ public void mapBindings() {
             .addLines( //
                 "          .build();", "    }")
             .addLinesIn(
-                EXPERIMENTAL_ANDROID_MODE,
+                FAST_INIT_MODE,
                 "    private final class SwitchingProvider<T> implements Provider<T> {",
                 "      private final int id;",
                 "",
@@ -522,13 +522,19 @@ public void productionComponents() {
             "test.DaggerTestComponent",
             "package test;",
             "",
+            "import dagger.producers.internal.CancellationListener;",
+            "",
             GENERATED_ANNOTATION,
-            "public final class DaggerTestComponent implements TestComponent {",
+            "public final class DaggerTestComponent implements TestComponent, "
+                + "CancellationListener {",
             "  @Override",
             "  public ListenableFuture<Map<String, String>> stringMap() {",
             "    return Futures.immediateFuture(",
             "        (Map<String, String>) ImmutableMap.<String, String>of());",
             "  }",
+            "",
+            "  @Override",
+            "  public void onProducerFutureCancelled(boolean mayInterruptIfRunning) {}",
             "}");
     Compilation compilation =
         daggerCompiler()
diff --git a/javatests/dagger/internal/codegen/MembersInjectionTest.java b/javatests/dagger/internal/codegen/MembersInjectionTest.java
index 2a7fd2194..bb6029fab 100644
--- a/javatests/dagger/internal/codegen/MembersInjectionTest.java
+++ b/javatests/dagger/internal/codegen/MembersInjectionTest.java
@@ -21,7 +21,7 @@
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
 import static dagger.internal.codegen.CompilerMode.DEFAULT_MODE;
-import static dagger.internal.codegen.CompilerMode.EXPERIMENTAL_ANDROID_MODE;
+import static dagger.internal.codegen.CompilerMode.FAST_INIT_MODE;
 import static dagger.internal.codegen.Compilers.daggerCompiler;
 import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
 import static dagger.internal.codegen.GeneratedLines.IMPORT_GENERATED_ANNOTATION;
@@ -1017,7 +1017,8 @@ public void fieldInjectionForShadowedMember() {
     assertThat(compilation).succeeded();
   }
 
-  @Test public void rawFrameworkTypes() {
+  @Test
+  public void rawFrameworkTypeField() {
     JavaFileObject file =
         JavaFileObjects.forSourceLines(
             "test.RawFrameworkTypes",
@@ -1031,25 +1032,45 @@ public void fieldInjectionForShadowedMember() {
             "  @Inject Provider fieldWithRawProvider;",
             "}",
             "",
+            "@Component",
+            "interface C {",
+            "  void inject(RawProviderField rawProviderField);",
+            "}");
+
+    Compilation compilation = daggerCompiler().withOptions(compilerMode.javacopts()).compile(file);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("javax.inject.Provider cannot be provided")
+        .inFile(file)
+        .onLineContaining("interface C");
+  }
+
+  @Test
+  public void rawFrameworkTypeParameter() {
+    JavaFileObject file =
+        JavaFileObjects.forSourceLines(
+            "test.RawFrameworkTypes",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Inject;",
+            "import javax.inject.Provider;",
+            "",
             "class RawProviderParameter {",
             "  @Inject void methodInjection(Provider rawProviderParameter) {}",
             "}",
             "",
             "@Component",
             "interface C {",
-            "  void inject(RawProviderField rawProviderField);",
             "  void inject(RawProviderParameter rawProviderParameter);",
             "}");
+
     Compilation compilation = daggerCompiler().withOptions(compilerMode.javacopts()).compile(file);
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining("javax.inject.Provider cannot be provided")
         .inFile(file)
-        .onLine(17);
-    assertThat(compilation)
-        .hadErrorContaining("javax.inject.Provider cannot be provided")
-        .inFile(file)
-        .onLine(18);
+        .onLineContaining("interface C");
   }
 
   @Test
@@ -1362,7 +1383,7 @@ public void accessibleRawType_ofInaccessibleType() {
                 GENERATED_ANNOTATION,
                 "public final class DaggerTestComponent implements TestComponent {")
             .addLinesIn(
-                EXPERIMENTAL_ANDROID_MODE,
+                FAST_INIT_MODE,
                 "  private volatile Object listOfInaccessible = new MemoizedSentinel();",
                 "",
                 "  private List getListOfInaccessible() {",
@@ -1402,7 +1423,7 @@ public void accessibleRawType_ofInaccessibleType() {
                 "        UsesInaccessibles instance) {",
                 "    UsesInaccessibles_MembersInjector.injectInaccessibles(")
             .addLinesIn(
-                EXPERIMENTAL_ANDROID_MODE,
+                FAST_INIT_MODE,
                 "        instance, (List) getListOfInaccessible());")
             .addLinesIn(
                 DEFAULT_MODE,
diff --git a/javatests/dagger/internal/codegen/MembersInjectionValidationTest.java b/javatests/dagger/internal/codegen/MembersInjectionValidationTest.java
new file mode 100644
index 000000000..68d5daaa7
--- /dev/null
+++ b/javatests/dagger/internal/codegen/MembersInjectionValidationTest.java
@@ -0,0 +1,239 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static dagger.internal.codegen.Compilers.daggerCompiler;
+
+import com.google.testing.compile.Compilation;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/**
+ * Tests that errors are reported for invalid members injection methods and {@link
+ * dagger.MembersInjector} dependency requests.
+ */
+@RunWith(JUnit4.class)
+public class MembersInjectionValidationTest {
+  @Test
+  public void membersInjectDependsOnUnboundedType() {
+    JavaFileObject injectsUnboundedType =
+        JavaFileObjects.forSourceLines(
+            "test.InjectsUnboundedType",
+            "package test;",
+            "",
+            "import dagger.MembersInjector;",
+            "import java.util.ArrayList;",
+            "import javax.inject.Inject;",
+            "",
+            "class InjectsUnboundedType {",
+            "  @Inject MembersInjector<ArrayList<?>> listInjector;",
+            "}");
+
+    Compilation compilation = daggerCompiler().compile(injectsUnboundedType);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            "Cannot inject members into types with unbounded type arguments: "
+                + "java.util.ArrayList<?>")
+        .inFile(injectsUnboundedType)
+        .onLineContaining("@Inject MembersInjector<ArrayList<?>> listInjector;");
+  }
+
+  @Test
+  public void membersInjectPrimitive() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface TestComponent {",
+            "  void inject(int primitive);",
+            "}");
+    Compilation compilation = daggerCompiler().compile(component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("Cannot inject members into int")
+        .inFile(component)
+        .onLineContaining("void inject(int primitive);");
+  }
+
+  @Test
+  public void membersInjectArray() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface TestComponent {",
+            "  void inject(Object[] array);",
+            "}");
+    Compilation compilation = daggerCompiler().compile(component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("Cannot inject members into java.lang.Object[]")
+        .inFile(component)
+        .onLineContaining("void inject(Object[] array);");
+  }
+
+  @Test
+  public void membersInjectorOfArray() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import dagger.MembersInjector;",
+            "",
+            "@Component",
+            "interface TestComponent {",
+            "  MembersInjector<Object[]> objectArrayInjector();",
+            "}");
+    Compilation compilation = daggerCompiler().compile(component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("Cannot inject members into java.lang.Object[]")
+        .inFile(component)
+        .onLineContaining("objectArrayInjector();");
+  }
+
+  @Test
+  public void membersInjectRawType() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import java.util.Set;",
+            "",
+            "@Component",
+            "interface TestComponent {",
+            "  void inject(Set rawSet);",
+            "}");
+    Compilation compilation = daggerCompiler().compile(component);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining("Cannot inject members into raw type java.util.Set");
+  }
+
+  @Test
+  public void qualifiedMembersInjector() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import dagger.MembersInjector;",
+            "import javax.inject.Named;",
+            "",
+            "@Component",
+            "interface TestComponent {",
+            "  @Named(\"foo\") MembersInjector<Object> objectInjector();",
+            "}");
+    Compilation compilation = daggerCompiler().compile(component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("Cannot inject members into qualified types")
+        .inFile(component)
+        .onLineContaining("objectInjector();");
+  }
+
+  @Test
+  public void qualifiedMembersInjectionMethod() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import dagger.MembersInjector;",
+            "import javax.inject.Named;",
+            "",
+            "@Component",
+            "interface TestComponent {",
+            "  @Named(\"foo\") void injectObject(Object object);",
+            "}");
+    Compilation compilation = daggerCompiler().compile(component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("Cannot inject members into qualified types")
+        .inFile(component)
+        .onLineContaining("injectObject(Object object);");
+  }
+
+  @Test
+  public void qualifiedMembersInjectionMethodParameter() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import dagger.MembersInjector;",
+            "import javax.inject.Named;",
+            "",
+            "@Component",
+            "interface TestComponent {",
+            "  void injectObject(@Named(\"foo\") Object object);",
+            "}");
+    Compilation compilation = daggerCompiler().compile(component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("Cannot inject members into qualified types")
+        .inFile(component)
+        .onLineContaining("injectObject(@Named(\"foo\") Object object);");
+  }
+
+  @Test
+  public void staticFieldInjection() {
+    JavaFileObject injected =
+        JavaFileObjects.forSourceLines(
+            "test.Injected",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "final class Injected {",
+            "  @Inject static Object object;",
+            "}");
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface TestComponent {",
+            "  void inject(Injected injected);",
+            "}");
+    Compilation compilation = daggerCompiler().compile(injected, component);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining("static fields").inFile(injected).onLine(6);
+  }
+}
diff --git a/javatests/dagger/internal/codegen/MissingBindingValidationTest.java b/javatests/dagger/internal/codegen/MissingBindingValidationTest.java
new file mode 100644
index 000000000..66e81a8c7
--- /dev/null
+++ b/javatests/dagger/internal/codegen/MissingBindingValidationTest.java
@@ -0,0 +1,666 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static dagger.internal.codegen.Compilers.daggerCompiler;
+import static dagger.internal.codegen.TestUtils.message;
+
+import com.google.testing.compile.Compilation;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public class MissingBindingValidationTest {
+  @Test
+  public void dependOnInterface() {
+    JavaFileObject component = JavaFileObjects.forSourceLines("test.MyComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component",
+        "interface MyComponent {",
+        "  Foo getFoo();",
+        "}");
+    JavaFileObject injectable = JavaFileObjects.forSourceLines("test.Foo",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "class Foo {",
+        "  @Inject Foo(Bar bar) {}",
+        "}");
+    JavaFileObject nonInjectable = JavaFileObjects.forSourceLines("test.Bar",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "interface Bar {}");
+    Compilation compilation = daggerCompiler().compile(component, injectable, nonInjectable);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("test.Bar cannot be provided without an @Provides-annotated method.")
+        .inFile(component)
+        .onLineContaining("interface MyComponent");
+  }
+
+  @Test
+  public void entryPointDependsOnInterface() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestClass",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "final class TestClass {",
+            "  interface A {}",
+            "",
+            "  @Component()",
+            "  interface AComponent {",
+            "    A getA();",
+            "  }",
+            "}");
+    Compilation compilation = daggerCompiler().compile(component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            "[Dagger/MissingBinding] test.TestClass.A cannot be provided "
+                + "without an @Provides-annotated method.")
+        .inFile(component)
+        .onLineContaining("interface AComponent");
+  }
+
+  @Test
+  public void entryPointDependsOnQualifiedInterface() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestClass",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Qualifier;",
+            "",
+            "final class TestClass {",
+            "  @Qualifier @interface Q {}",
+            "  interface A {}",
+            "",
+            "  @Component()",
+            "  interface AComponent {",
+            "    @Q A qualifiedA();",
+            "  }",
+            "}");
+    Compilation compilation = daggerCompiler().compile(component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            "[Dagger/MissingBinding] @test.TestClass.Q test.TestClass.A cannot be provided "
+                + "without an @Provides-annotated method.")
+        .inFile(component)
+        .onLineContaining("interface AComponent");
+  }
+
+  @Test public void constructorInjectionWithoutAnnotation() {
+    JavaFileObject component = JavaFileObjects.forSourceLines("test.TestClass",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import javax.inject.Inject;",
+        "",
+        "final class TestClass {",
+        "  static class A {",
+        "    A() {}",
+        "  }",
+        "",
+        "  @Component()",
+        "  interface AComponent {",
+        "    A getA();",
+        "  }",
+        "}");
+
+    Compilation compilation = daggerCompiler().compile(component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            "test.TestClass.A cannot be provided without an @Inject constructor or an "
+                + "@Provides-annotated method.")
+        .inFile(component)
+        .onLineContaining("interface AComponent");
+  }
+
+  @Test public void membersInjectWithoutProvision() {
+    JavaFileObject component = JavaFileObjects.forSourceLines("test.TestClass",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import javax.inject.Inject;",
+        "",
+        "final class TestClass {",
+        "  static class A {",
+        "    @Inject A() {}",
+        "  }",
+        "",
+        "  static class B {",
+        "    @Inject A a;",
+        "  }",
+        "",
+        "  @Component()",
+        "  interface AComponent {",
+        "    B getB();",
+        "  }",
+        "}");
+
+    Compilation compilation = daggerCompiler().compile(component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            "test.TestClass.B cannot be provided without an @Inject constructor or an "
+                + "@Provides-annotated method. This type supports members injection but cannot be "
+                + "implicitly provided.")
+        .inFile(component)
+        .onLineContaining("interface AComponent");
+  }
+
+  @Test
+  public void missingBindingWithSameKeyAsMembersInjectionMethod() {
+    JavaFileObject self =
+        JavaFileObjects.forSourceLines(
+            "test.Self",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "import javax.inject.Provider;",
+            "",
+            "class Self {",
+            "  @Inject Provider<Self> selfProvider;",
+            "}");
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.SelfComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface SelfComponent {",
+            "  void inject(Self target);",
+            "}");
+
+    Compilation compilation = daggerCompiler().compile(self, component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("test.Self cannot be provided without an @Inject constructor")
+        .inFile(component)
+        .onLineContaining("interface SelfComponent");
+  }
+
+  @Test
+  public void genericInjectClassWithWildcardDependencies() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface TestComponent {",
+            "  Foo<? extends Number> foo();",
+            "}");
+    JavaFileObject foo =
+        JavaFileObjects.forSourceLines(
+            "test.Foo",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "final class Foo<T> {",
+            "  @Inject Foo(T t) {}",
+            "}");
+    Compilation compilation = daggerCompiler().compile(component, foo);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            "test.Foo<? extends java.lang.Number> cannot be provided "
+                + "without an @Provides-annotated method");
+  }
+
+  @Test public void longChainOfDependencies() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestClass",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import dagger.Lazy;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import javax.inject.Inject;",
+            "import javax.inject.Named;",
+            "import javax.inject.Provider;",
+            "",
+            "final class TestClass {",
+            "  interface A {}",
+            "",
+            "  static class B {",
+            "    @Inject B(A a) {}",
+            "  }",
+            "",
+            "  static class C {",
+            "    @Inject B b;",
+            "    @Inject C(X x) {}",
+            "  }",
+            "",
+            "  interface D { }",
+            "",
+            "  static class DImpl implements D {",
+            "    @Inject DImpl(C c, B b) {}",
+            "  }",
+            "",
+            "  static class X {",
+            "    @Inject X() {}",
+            "  }",
+            "",
+            "  @Module",
+            "  static class DModule {",
+            "    @Provides @Named(\"slim shady\") D d(X x1, DImpl impl, X x2) { return impl; }",
+            "  }",
+            "",
+            "  @Component(modules = { DModule.class })",
+            "  interface AComponent {",
+            "    @Named(\"slim shady\") D getFoo();",
+            "    C injectC(C c);",
+            "    Provider<C> cProvider();",
+            "    Lazy<C> lazyC();",
+            "    Provider<Lazy<C>> lazyCProvider();",
+            "  }",
+            "}");
+
+    Compilation compilation = daggerCompiler().compile(component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "test.TestClass.A cannot be provided without an @Provides-annotated method.",
+                "    test.TestClass.A is injected at",
+                "        test.TestClass.B.<init>(a)",
+                "    test.TestClass.B is injected at",
+                "        test.TestClass.C.b",
+                "    test.TestClass.C is injected at",
+                "        test.TestClass.AComponent.injectC(test.TestClass.C)",
+                "The following other entry points also depend on it:",
+                "    test.TestClass.AComponent.getFoo()",
+                "    test.TestClass.AComponent.cProvider()",
+                "    test.TestClass.AComponent.lazyC()",
+                "    test.TestClass.AComponent.lazyCProvider()"))
+        .inFile(component)
+        .onLineContaining("interface AComponent");
+  }
+
+  @Test
+  public void bindsMethodAppearsInTrace() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "TestComponent",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = TestModule.class)",
+            "interface TestComponent {",
+            "  TestInterface testInterface();",
+            "}");
+    JavaFileObject interfaceFile =
+        JavaFileObjects.forSourceLines("TestInterface", "interface TestInterface {}");
+    JavaFileObject implementationFile =
+        JavaFileObjects.forSourceLines(
+            "TestImplementation",
+            "import javax.inject.Inject;",
+            "",
+            "final class TestImplementation implements TestInterface {",
+            "  @Inject TestImplementation(String missingBinding) {}",
+            "}");
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "TestModule",
+            "import dagger.Binds;",
+            "import dagger.Module;",
+            "",
+            "@Module",
+            "interface TestModule {",
+            "  @Binds abstract TestInterface bindTestInterface(TestImplementation implementation);",
+            "}");
+
+    Compilation compilation =
+        daggerCompiler().compile(component, module, interfaceFile, implementationFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "java.lang.String cannot be provided without an @Inject constructor or an "
+                    + "@Provides-annotated method.",
+                "    java.lang.String is injected at",
+                "        TestImplementation.<init>(missingBinding)",
+                "    TestImplementation is injected at",
+                "        TestModule.bindTestInterface(implementation)",
+                "    TestInterface is provided at",
+                "        TestComponent.testInterface()"))
+        .inFile(component)
+        .onLineContaining("interface TestComponent");
+  }
+
+  @Test public void resolvedParametersInDependencyTrace() {
+    JavaFileObject generic = JavaFileObjects.forSourceLines("test.Generic",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "import javax.inject.Provider;",
+        "",
+        "final class Generic<T> {",
+        "  @Inject Generic(T t) {}",
+        "}");
+    JavaFileObject testClass = JavaFileObjects.forSourceLines("test.TestClass",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "import java.util.List;",
+        "",
+        "final class TestClass {",
+        "  @Inject TestClass(List list) {}",
+        "}");
+    JavaFileObject usesTest = JavaFileObjects.forSourceLines("test.UsesTest",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class UsesTest {",
+        "  @Inject UsesTest(Generic<TestClass> genericTestClass) {}",
+        "}");
+    JavaFileObject component = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component",
+        "interface TestComponent {",
+        "  UsesTest usesTest();",
+        "}");
+
+    Compilation compilation = daggerCompiler().compile(generic, testClass, usesTest, component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "java.util.List cannot be provided without an @Provides-annotated method.",
+                "    java.util.List is injected at",
+                "        test.TestClass.<init>(list)",
+                "    test.TestClass is injected at",
+                "        test.Generic.<init>(t)",
+                "    test.Generic<test.TestClass> is injected at",
+                "        test.UsesTest.<init>(genericTestClass)",
+                "    test.UsesTest is provided at",
+                "        test.TestComponent.usesTest()"));
+  }
+
+  @Test public void resolvedVariablesInDependencyTrace() {
+    JavaFileObject generic = JavaFileObjects.forSourceLines("test.Generic",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "import javax.inject.Provider;",
+        "",
+        "final class Generic<T> {",
+        "  @Inject T t;",
+        "  @Inject Generic() {}",
+        "}");
+    JavaFileObject testClass = JavaFileObjects.forSourceLines("test.TestClass",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "import java.util.List;",
+        "",
+        "final class TestClass {",
+        "  @Inject TestClass(List list) {}",
+        "}");
+    JavaFileObject usesTest = JavaFileObjects.forSourceLines("test.UsesTest",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class UsesTest {",
+        "  @Inject UsesTest(Generic<TestClass> genericTestClass) {}",
+        "}");
+    JavaFileObject component = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component",
+        "interface TestComponent {",
+        "  UsesTest usesTest();",
+        "}");
+
+    Compilation compilation = daggerCompiler().compile(generic, testClass, usesTest, component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "java.util.List cannot be provided without an @Provides-annotated method.",
+                "    java.util.List is injected at",
+                "        test.TestClass.<init>(list)",
+                "    test.TestClass is injected at",
+                "        test.Generic.t",
+                "    test.Generic<test.TestClass> is injected at",
+                "        test.UsesTest.<init>(genericTestClass)",
+                "    test.UsesTest is provided at",
+                "        test.TestComponent.usesTest()"));
+  }
+
+  @Test
+  public void bindingUsedOnlyInSubcomponentDependsOnBindingOnlyInSubcomponent() {
+    JavaFileObject parent =
+        JavaFileObjects.forSourceLines(
+            "Parent",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = ParentModule.class)",
+            "interface Parent {",
+            "  Child child();",
+            "}");
+    JavaFileObject parentModule =
+        JavaFileObjects.forSourceLines(
+            "ParentModule",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "class ParentModule {",
+            "  @Provides static Object needsString(String string) {",
+            "    return \"needs string: \" + string;",
+            "  }",
+            "}");
+    JavaFileObject child =
+        JavaFileObjects.forSourceLines(
+            "Child",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = ChildModule.class)",
+            "interface Child {",
+            "  String string();",
+            "  Object needsString();",
+            "}");
+    JavaFileObject childModule =
+        JavaFileObjects.forSourceLines(
+            "ChildModule",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "class ChildModule {",
+            "  @Provides static String string() {",
+            "    return \"child string\";",
+            "  }",
+            "}");
+
+    Compilation compilation = daggerCompiler().compile(parent, parentModule, child, childModule);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContainingMatch(
+            "(?s)\\Qjava.lang.String cannot be provided\\E.*\\QChild.needsString()\\E")
+        .inFile(parent)
+        .onLineContaining("interface Parent");
+  }
+
+  @Test
+  public void multibindingContributionBetweenAncestorComponentAndEntrypointComponent() {
+    JavaFileObject parent =
+        JavaFileObjects.forSourceLines(
+            "Parent",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = ParentModule.class)",
+            "interface Parent {",
+            "  Child child();",
+            "}");
+    JavaFileObject child =
+        JavaFileObjects.forSourceLines(
+            "Child",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = ChildModule.class)",
+            "interface Child {",
+            "  Grandchild grandchild();",
+            "}");
+    JavaFileObject grandchild =
+        JavaFileObjects.forSourceLines(
+            "Grandchild",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent",
+            "interface Grandchild {",
+            "  Object object();",
+            "}");
+
+    JavaFileObject parentModule =
+        JavaFileObjects.forSourceLines(
+            "ParentModule",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntoSet;",
+            "import java.util.Set;",
+            "",
+            "@Module",
+            "class ParentModule {",
+            "  @Provides static Object dependsOnSet(Set<String> strings) {",
+            "    return \"needs strings: \" + strings;",
+            "  }",
+            "",
+            "  @Provides @IntoSet static String contributesToSet() {",
+            "    return \"parent string\";",
+            "  }",
+            "",
+            "  @Provides int missingDependency(double dub) {",
+            "    return 4;",
+            "  }",
+            "}");
+    JavaFileObject childModule =
+        JavaFileObjects.forSourceLines(
+            "ChildModule",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntoSet;",
+            "",
+            "@Module",
+            "class ChildModule {",
+            "  @Provides @IntoSet static String contributesToSet(int i) {",
+            "    return \"\" + i;",
+            "  }",
+            "}");
+    Compilation compilation =
+        daggerCompiler().compile(parent, parentModule, child, childModule, grandchild);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContainingMatch(
+            "(?s)\\Qjava.lang.Double cannot be provided\\E.*"
+                + "\\QGrandchild.object() [Parent → Child → Grandchild]\\E$")
+        .inFile(parent)
+        .onLineContaining("interface Parent");
+  }
+
+  @Test
+  public void manyDependencies() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = TestModule.class)",
+            "interface TestComponent {",
+            "  Object object();",
+            "  String string();",
+            "}");
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Binds;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "abstract class TestModule {",
+            "  @Binds abstract Object object(NotBound notBound);",
+            "",
+            "  @Provides static String string(NotBound notBound, Object object) {",
+            "    return notBound.toString();",
+            "  }",
+            "}");
+    JavaFileObject notBound =
+        JavaFileObjects.forSourceLines(
+            "test.NotBound", //
+            "package test;",
+            "",
+            "interface NotBound {}");
+    Compilation compilation = daggerCompiler().compile(component, module, notBound);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "[Dagger/MissingBinding] "
+                    + "test.NotBound cannot be provided without an @Provides-annotated method.",
+                "    test.NotBound is injected at",
+                "        test.TestModule.object(notBound)",
+                "    java.lang.Object is provided at",
+                "        test.TestComponent.object()",
+                "It is also requested at:",
+                "    test.TestModule.string(notBound, …)",
+                "The following other entry points also depend on it:",
+                "    test.TestComponent.string()"))
+        .inFile(component)
+        .onLineContaining("interface TestComponent");
+    assertThat(compilation).hadErrorCount(1);
+  }
+}
diff --git a/javatests/dagger/internal/codegen/ModuleFactoryGeneratorTest.java b/javatests/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
index 3c1931b9e..ca9cc9550 100644
--- a/javatests/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
+++ b/javatests/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
@@ -213,13 +213,12 @@ public void providesMethodReturnsProduced() {
         "",
         "@Module(includes = Void.class)",
         "class TestModule {}");
+
     Compilation compilation = daggerCompiler().compile(module);
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining(
-            String.format(
-                "%s is listed as a module, but is not annotated with %s",
-                "java.lang.Void", "@Module"));
+            "java.lang.Void is listed as a module, but is not annotated with @Module");
   }
 
   @Test public void singleProvidesMethodNoArgs() {
@@ -380,21 +379,6 @@ public void providesMethodReturnsProduced() {
         .and().generatesSources(factoryFile);
   }
 
-  private static final JavaFileObject QUALIFIER_A =
-      JavaFileObjects.forSourceLines("test.QualifierA",
-          "package test;",
-          "",
-          "import javax.inject.Qualifier;",
-          "",
-          "@Qualifier @interface QualifierA {}");
-  private static final JavaFileObject QUALIFIER_B =
-      JavaFileObjects.forSourceLines("test.QualifierB",
-          "package test;",
-          "",
-          "import javax.inject.Qualifier;",
-          "",
-          "@Qualifier @interface QualifierB {}");
-
   @Test public void multipleProvidesMethods() {
     JavaFileObject classXFile = JavaFileObjects.forSourceLines("test.X",
         "package test;",
@@ -1298,14 +1282,31 @@ public void genericSubclassedModule() {
             provideNonGenericTypeWithDepsFactory);
   }
 
-  @Test public void providesMethodMultipleQualifiers() {
+  private static final JavaFileObject QUALIFIER_A =
+      JavaFileObjects.forSourceLines(
+          "test.QualifierA",
+          "package test;",
+          "",
+          "import javax.inject.Qualifier;",
+          "",
+          "@Qualifier @interface QualifierA {}");
+
+  private static final JavaFileObject QUALIFIER_B =
+      JavaFileObjects.forSourceLines(
+          "test.QualifierB",
+          "package test;",
+          "",
+          "import javax.inject.Qualifier;",
+          "",
+          "@Qualifier @interface QualifierB {}");
+
+  @Test
+  public void providesMethodMultipleQualifiersOnMethod() {
     JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
         "package test;",
         "",
         "import dagger.Module;",
         "import dagger.Provides;",
-        "import javax.annotation.Nullable;",
-        "import javax.inject.Singleton;",
         "",
         "@Module",
         "final class TestModule {",
@@ -1315,7 +1316,102 @@ public void genericSubclassedModule() {
         "}");
     Compilation compilation = daggerCompiler().compile(moduleFile, QUALIFIER_A, QUALIFIER_B);
     assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining("Cannot use more than one @Qualifier");
+    assertThat(compilation).hadErrorContaining("may not use more than one @Qualifier");
+  }
+
+  @Test
+  public void providesMethodMultipleQualifiersOnParameter() {
+    JavaFileObject moduleFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "final class TestModule {",
+            "  @Provides static String provideString(@QualifierA @QualifierB Object object) {",
+            "    return \"foo\";",
+            "  }",
+            "}");
+    Compilation compilation = daggerCompiler().compile(moduleFile, QUALIFIER_A, QUALIFIER_B);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining("may not use more than one @Qualifier");
+  }
+
+  @Test
+  public void providesMethodWildcardDependency() {
+    JavaFileObject moduleFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import javax.inject.Provider;",
+            "",
+            "@Module",
+            "final class TestModule {",
+            "  @Provides static String provideString(Provider<? extends Number> numberProvider) {",
+            "    return \"foo\";",
+            "  }",
+            "}");
+    Compilation compilation = daggerCompiler().compile(moduleFile, QUALIFIER_A, QUALIFIER_B);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            "Dagger does not support injecting Provider<T>, Lazy<T>, Producer<T>, or Produced<T> "
+                + "when T is a wildcard type such as ? extends java.lang.Number");
+  }
+
+  private static final JavaFileObject SCOPE_A =
+      JavaFileObjects.forSourceLines(
+          "test.ScopeA",
+          "package test;",
+          "",
+          "import javax.inject.Scope;",
+          "",
+          "@Scope @interface ScopeA {}");
+
+  private static final JavaFileObject SCOPE_B =
+      JavaFileObjects.forSourceLines(
+          "test.ScopeB",
+          "package test;",
+          "",
+          "import javax.inject.Scope;",
+          "",
+          "@Scope @interface ScopeB {}");
+
+  @Test
+  public void providesMethodMultipleScopes() {
+    JavaFileObject moduleFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "final class TestModule {",
+            "  @Provides",
+            "  @ScopeA",
+            "  @ScopeB",
+            "  String provideString() {",
+            "    return \"foo\";",
+            "  }",
+            "}");
+    Compilation compilation = daggerCompiler().compile(moduleFile, SCOPE_A, SCOPE_B);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("Cannot use more than one @Scope")
+        .inFile(moduleFile)
+        .onLineContaining("@ScopeA");
+    assertThat(compilation)
+        .hadErrorContaining("Cannot use more than one @Scope")
+        .inFile(moduleFile)
+        .onLineContaining("@ScopeB");
   }
 
   @Test public void providerDependsOnProduced() {
diff --git a/javatests/dagger/internal/codegen/ModuleValidatorTest.java b/javatests/dagger/internal/codegen/ModuleValidationTest.java
similarity index 99%
rename from javatests/dagger/internal/codegen/ModuleValidatorTest.java
rename to javatests/dagger/internal/codegen/ModuleValidationTest.java
index 1c605bb5c..9823c097d 100644
--- a/javatests/dagger/internal/codegen/ModuleValidatorTest.java
+++ b/javatests/dagger/internal/codegen/ModuleValidationTest.java
@@ -33,7 +33,7 @@
 import org.junit.runners.Parameterized;
 
 @RunWith(Parameterized.class)
-public final class ModuleValidatorTest {
+public final class ModuleValidationTest {
 
   @Parameterized.Parameters(name = "{0}")
   public static Collection<Object[]> parameters() {
@@ -66,7 +66,7 @@ String simpleName() {
 
   private final ModuleType moduleType;
 
-  public ModuleValidatorTest(ModuleType moduleType) {
+  public ModuleValidationTest(ModuleType moduleType) {
     this.moduleType = moduleType;
   }
 
diff --git a/javatests/dagger/internal/codegen/MultibindingTest.java b/javatests/dagger/internal/codegen/MultibindingTest.java
index 23ce61438..fb156cd57 100644
--- a/javatests/dagger/internal/codegen/MultibindingTest.java
+++ b/javatests/dagger/internal/codegen/MultibindingTest.java
@@ -134,7 +134,7 @@ public void concreteBindingForMultibindingAlias() {
             "java.util.Map<java.lang.String,java.lang.String> "
                 + "cannot be provided without an @Provides-annotated method")
         .inFile(component)
-        .onLineContaining("mapOfStringToString()");
+        .onLineContaining("interface TestComponent");
   }
 
   @Test
@@ -186,8 +186,7 @@ public void produceConcreteSet_andRequestSetOfProduced() {
             "java.util.Set<dagger.producers.Produced<java.lang.String>> "
                 + "cannot be provided without an @Provides- or @Produces-annotated method")
         .inFile(component)
-        .onLineContaining("setOfProduced()");
-
+        .onLineContaining("interface TestComponent");
   }
 
   @Test
diff --git a/javatests/dagger/internal/codegen/MultibindsValidatorTest.java b/javatests/dagger/internal/codegen/MultibindsValidationTest.java
similarity index 95%
rename from javatests/dagger/internal/codegen/MultibindsValidatorTest.java
rename to javatests/dagger/internal/codegen/MultibindsValidationTest.java
index 6f642f603..e5603a4d6 100644
--- a/javatests/dagger/internal/codegen/MultibindsValidatorTest.java
+++ b/javatests/dagger/internal/codegen/MultibindsValidationTest.java
@@ -31,7 +31,7 @@
 import org.junit.runners.Parameterized.Parameters;
 
 @RunWith(Parameterized.class)
-public class MultibindsValidatorTest {
+public class MultibindsValidationTest {
 
   @Parameters(name = "{0}")
   public static Collection<Object[]> parameters() {
@@ -40,7 +40,7 @@
 
   private final String moduleDeclaration;
 
-  public MultibindsValidatorTest(Class<? extends Annotation> moduleAnnotation) {
+  public MultibindsValidationTest(Class<? extends Annotation> moduleAnnotation) {
     moduleDeclaration = "@" + moduleAnnotation.getCanonicalName() + " abstract class %s { %s }";
   }
 
@@ -141,7 +141,7 @@ public void overqualifiedSet() {
                 + "abstract Set<Object> tooManyQualifiersSet();")
         .withDeclaration(moduleDeclaration)
         .importing(SomeQualifier.class, OtherQualifier.class)
-        .hasError("Cannot use more than one @Qualifier");
+        .hasError("may not use more than one @Qualifier");
   }
 
   @Test
@@ -151,7 +151,7 @@ public void overqualifiedMap() {
                 + "abstract Map<String, Object> tooManyQualifiersMap();")
         .withDeclaration(moduleDeclaration)
         .importing(SomeQualifier.class, OtherQualifier.class)
-        .hasError("Cannot use more than one @Qualifier");
+        .hasError("may not use more than one @Qualifier");
   }
 
   @Test
diff --git a/javatests/dagger/internal/codegen/NullableBindingValidationTest.java b/javatests/dagger/internal/codegen/NullableBindingValidationTest.java
new file mode 100644
index 000000000..710f77721
--- /dev/null
+++ b/javatests/dagger/internal/codegen/NullableBindingValidationTest.java
@@ -0,0 +1,390 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static com.google.testing.compile.Compiler.javac;
+import static dagger.internal.codegen.Compilers.daggerCompiler;
+import static dagger.internal.codegen.NullableBindingValidator.nullableToNonNullable;
+
+import com.google.testing.compile.Compilation;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public class NullableBindingValidationTest {
+  private static final JavaFileObject NULLABLE =
+      JavaFileObjects.forSourceLines(
+          "test.Nullable", // force one-string-per-line format
+          "package test;",
+          "",
+          "public @interface Nullable {}");
+
+  @Test public void nullCheckForConstructorParameters() {
+    JavaFileObject a = JavaFileObjects.forSourceLines("test.A",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class A {",
+        "  @Inject A(String string) {}",
+        "}");
+    JavaFileObject module = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.Provides;",
+        "import javax.inject.Inject;",
+        "",
+        "@dagger.Module",
+        "final class TestModule {",
+        "  @Nullable @Provides String provideString() { return null; }",
+        "}");
+    JavaFileObject component = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component(modules = TestModule.class)",
+        "interface TestComponent {",
+        "  A a();",
+        "}");
+    Compilation compilation = daggerCompiler().compile(NULLABLE, a, module, component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            nullableToNonNullable(
+                "java.lang.String",
+                "@test.Nullable @Provides String test.TestModule.provideString()"));
+
+    // but if we disable the validation, then it compiles fine.
+    Compilation compilation2 =
+        javac()
+            .withOptions("-Adagger.nullableValidation=WARNING")
+            .withProcessors(new ComponentProcessor())
+            .compile(NULLABLE, a, module, component);
+    assertThat(compilation2).succeeded();
+  }
+
+  @Test public void nullCheckForMembersInjectParam() {
+    JavaFileObject a = JavaFileObjects.forSourceLines("test.A",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class A {",
+        "  @Inject A() {}",
+        "  @Inject void register(String string) {}",
+        "}");
+    JavaFileObject module = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.Provides;",
+        "import javax.inject.Inject;",
+        "",
+        "@dagger.Module",
+        "final class TestModule {",
+        "  @Nullable @Provides String provideString() { return null; }",
+        "}");
+    JavaFileObject component = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component(modules = TestModule.class)",
+        "interface TestComponent {",
+        "  A a();",
+        "}");
+    Compilation compilation = daggerCompiler().compile(NULLABLE, a, module, component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            nullableToNonNullable(
+                "java.lang.String",
+                "@test.Nullable @Provides String test.TestModule.provideString()"));
+
+    // but if we disable the validation, then it compiles fine.
+    Compilation compilation2 =
+        javac()
+            .withOptions("-Adagger.nullableValidation=WARNING")
+            .withProcessors(new ComponentProcessor())
+            .compile(NULLABLE, a, module, component);
+    assertThat(compilation2).succeeded();
+  }
+
+  @Test public void nullCheckForVariable() {
+    JavaFileObject a = JavaFileObjects.forSourceLines("test.A",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class A {",
+        "  @Inject String string;",
+        "  @Inject A() {}",
+        "}");
+    JavaFileObject module = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.Provides;",
+        "import javax.inject.Inject;",
+        "",
+        "@dagger.Module",
+        "final class TestModule {",
+        "  @Nullable @Provides String provideString() { return null; }",
+        "}");
+    JavaFileObject component = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component(modules = TestModule.class)",
+        "interface TestComponent {",
+        "  A a();",
+        "}");
+    Compilation compilation = daggerCompiler().compile(NULLABLE, a, module, component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            nullableToNonNullable(
+                "java.lang.String",
+                "@test.Nullable @Provides String test.TestModule.provideString()"));
+
+    // but if we disable the validation, then it compiles fine.
+    Compilation compilation2 =
+        javac()
+            .withOptions("-Adagger.nullableValidation=WARNING")
+            .withProcessors(new ComponentProcessor())
+            .compile(NULLABLE, a, module, component);
+    assertThat(compilation2).succeeded();
+  }
+
+  @Test public void nullCheckForComponentReturn() {
+    JavaFileObject module = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.Provides;",
+        "import javax.inject.Inject;",
+        "",
+        "@dagger.Module",
+        "final class TestModule {",
+        "  @Nullable @Provides String provideString() { return null; }",
+        "}");
+    JavaFileObject component = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component(modules = TestModule.class)",
+        "interface TestComponent {",
+        "  String string();",
+        "}");
+    Compilation compilation = daggerCompiler().compile(NULLABLE, module, component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            nullableToNonNullable(
+                "java.lang.String",
+                "@test.Nullable @Provides String test.TestModule.provideString()"));
+
+    // but if we disable the validation, then it compiles fine.
+    Compilation compilation2 =
+        javac()
+            .withOptions("-Adagger.nullableValidation=WARNING")
+            .withProcessors(new ComponentProcessor())
+            .compile(NULLABLE, module, component);
+    assertThat(compilation2).succeeded();
+  }
+
+  @Test
+  public void nullCheckForOptionalInstance() {
+    JavaFileObject a =
+        JavaFileObjects.forSourceLines(
+            "test.A",
+            "package test;",
+            "",
+            "import com.google.common.base.Optional;",
+            "import javax.inject.Inject;",
+            "",
+            "final class A {",
+            "  @Inject A(Optional<String> optional) {}",
+            "}");
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.BindsOptionalOf;",
+            "import dagger.Provides;",
+            "import javax.inject.Inject;",
+            "",
+            "@dagger.Module",
+            "abstract class TestModule {",
+            "  @Nullable @Provides static String provideString() { return null; }",
+            "  @BindsOptionalOf abstract String optionalString();",
+            "}");
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = TestModule.class)",
+            "interface TestComponent {",
+            "  A a();",
+            "}");
+    Compilation compilation = daggerCompiler().compile(NULLABLE, a, module, component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            nullableToNonNullable(
+                "java.lang.String",
+                "@test.Nullable @Provides String test.TestModule.provideString()"));
+  }
+
+  @Test
+  public void nullCheckForOptionalProvider() {
+    JavaFileObject a =
+        JavaFileObjects.forSourceLines(
+            "test.A",
+            "package test;",
+            "",
+            "import com.google.common.base.Optional;",
+            "import javax.inject.Inject;",
+            "import javax.inject.Provider;",
+            "",
+            "final class A {",
+            "  @Inject A(Optional<Provider<String>> optional) {}",
+            "}");
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.BindsOptionalOf;",
+            "import dagger.Provides;",
+            "import javax.inject.Inject;",
+            "",
+            "@dagger.Module",
+            "abstract class TestModule {",
+            "  @Nullable @Provides static String provideString() { return null; }",
+            "  @BindsOptionalOf abstract String optionalString();",
+            "}");
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = TestModule.class)",
+            "interface TestComponent {",
+            "  A a();",
+            "}");
+    Compilation compilation = daggerCompiler().compile(NULLABLE, a, module, component);
+    assertThat(compilation).succeeded();
+  }
+
+  @Test
+  public void nullCheckForOptionalLazy() {
+    JavaFileObject a =
+        JavaFileObjects.forSourceLines(
+            "test.A",
+            "package test;",
+            "",
+            "import com.google.common.base.Optional;",
+            "import dagger.Lazy;",
+            "import javax.inject.Inject;",
+            "",
+            "final class A {",
+            "  @Inject A(Optional<Lazy<String>> optional) {}",
+            "}");
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.BindsOptionalOf;",
+            "import dagger.Provides;",
+            "import javax.inject.Inject;",
+            "",
+            "@dagger.Module",
+            "abstract class TestModule {",
+            "  @Nullable @Provides static String provideString() { return null; }",
+            "  @BindsOptionalOf abstract String optionalString();",
+            "}");
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = TestModule.class)",
+            "interface TestComponent {",
+            "  A a();",
+            "}");
+    Compilation compilation = daggerCompiler().compile(NULLABLE, a, module, component);
+    assertThat(compilation).succeeded();
+  }
+
+  @Test
+  public void nullCheckForOptionalProviderOfLazy() {
+    JavaFileObject a =
+        JavaFileObjects.forSourceLines(
+            "test.A",
+            "package test;",
+            "",
+            "import com.google.common.base.Optional;",
+            "import dagger.Lazy;",
+            "import javax.inject.Inject;",
+            "import javax.inject.Provider;",
+            "",
+            "final class A {",
+            "  @Inject A(Optional<Provider<Lazy<String>>> optional) {}",
+            "}");
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.BindsOptionalOf;",
+            "import dagger.Provides;",
+            "import javax.inject.Inject;",
+            "",
+            "@dagger.Module",
+            "abstract class TestModule {",
+            "  @Nullable @Provides static String provideString() { return null; }",
+            "  @BindsOptionalOf abstract String optionalString();",
+            "}");
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = TestModule.class)",
+            "interface TestComponent {",
+            "  A a();",
+            "}");
+    Compilation compilation = daggerCompiler().compile(NULLABLE, a, module, component);
+    assertThat(compilation).succeeded();
+  }
+}
diff --git a/javatests/dagger/internal/codegen/OptionalBindingRequestFulfillmentTest.java b/javatests/dagger/internal/codegen/OptionalBindingRequestFulfillmentTest.java
index 4da7f6b5e..338b62eb1 100644
--- a/javatests/dagger/internal/codegen/OptionalBindingRequestFulfillmentTest.java
+++ b/javatests/dagger/internal/codegen/OptionalBindingRequestFulfillmentTest.java
@@ -18,7 +18,7 @@
 
 import static com.google.testing.compile.CompilationSubject.assertThat;
 import static dagger.internal.codegen.CompilerMode.DEFAULT_MODE;
-import static dagger.internal.codegen.CompilerMode.EXPERIMENTAL_ANDROID_MODE;
+import static dagger.internal.codegen.CompilerMode.FAST_INIT_MODE;
 import static dagger.internal.codegen.Compilers.daggerCompiler;
 import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
 
@@ -113,7 +113,7 @@ public void inlinedOptionalBindings() {
                 GENERATED_ANNOTATION,
                 "public final class DaggerTestComponent implements TestComponent {")
             .addLinesIn(
-                EXPERIMENTAL_ANDROID_MODE,
+                FAST_INIT_MODE,
                 "  private volatile Provider<Maybe> provideMaybeProvider;",
                 "",
                 "  private Provider<Maybe> getMaybeProvider() {",
@@ -138,7 +138,7 @@ public void inlinedOptionalBindings() {
                 DEFAULT_MODE,
                 "        Maybe_MaybeModule_ProvideMaybeFactory.create()));")
             .addLinesIn(
-                EXPERIMENTAL_ANDROID_MODE,
+                FAST_INIT_MODE,
                 "        getMaybeProvider()));")
             .addLines(
                 "  }",
@@ -154,7 +154,7 @@ public void inlinedOptionalBindings() {
                 "    return Optional.<Provider<Lazy<DefinitelyNot>>>absent();",
                 "  }")
             .addLinesIn(
-                EXPERIMENTAL_ANDROID_MODE,
+                FAST_INIT_MODE,
                 "  private final class SwitchingProvider<T> implements Provider<T> {",
                 "    private final int id;",
                 "",
@@ -246,9 +246,11 @@ public void requestForFuture() {
             "package test;",
             "",
             "import com.google.common.base.Optional;",
+            "import dagger.producers.internal.CancellationListener;",
             "",
             GENERATED_ANNOTATION,
-            "public final class DaggerTestComponent implements TestComponent {",
+            "public final class DaggerTestComponent implements TestComponent, "
+                + "CancellationListener {",
             "  @Override",
             "  public ListenableFuture<Optional<Maybe>> maybe() {",
             "    return Futures.immediateFuture(",
@@ -260,6 +262,9 @@ public void requestForFuture() {
             "    return Futures.immediateFuture(Optional.<DefinitelyNot>absent());",
 
             "  }",
+            "",
+            "  @Override",
+            "  public void onProducerFutureCancelled(boolean mayInterruptIfRunning) {}",
             "}");
 
     Compilation compilation =
diff --git a/javatests/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java b/javatests/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
index eec32f72d..cd9a97779 100644
--- a/javatests/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
+++ b/javatests/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
@@ -358,10 +358,9 @@ public void publicModuleNonPublicIncludes() {
             "TestModule_ProduceStringFactory",
             "package test;",
             "",
-            "import com.google.common.util.concurrent.AsyncFunction;",
             "import com.google.common.util.concurrent.Futures;",
             "import com.google.common.util.concurrent.ListenableFuture;",
-            "import dagger.producers.internal.AbstractProducer;",
+            "import dagger.producers.internal.AbstractProducesMethodProducer;",
             "import dagger.producers.monitoring.ProducerToken;",
             "import dagger.producers.monitoring.ProductionComponentMonitor;",
             "import java.util.concurrent.Executor;",
@@ -371,10 +370,8 @@ public void publicModuleNonPublicIncludes() {
             "@SuppressWarnings(\"FutureReturnValueIgnored\")",
             GENERATED_ANNOTATION,
             "public final class TestModule_ProduceStringFactory",
-            "    extends AbstractProducer<String>",
-            "    implements AsyncFunction<Void, String>, Executor {",
+            "    extends AbstractProducesMethodProducer<Void, String> {",
             "  private final TestModule module;",
-            "  private final Provider<Executor> executorProvider;",
             "",
             "  public TestModule_ProduceStringFactory(",
             "      TestModule module,",
@@ -382,30 +379,17 @@ public void publicModuleNonPublicIncludes() {
             "      Provider<ProductionComponentMonitor> productionComponentMonitorProvider) {",
             "    super(",
             "        productionComponentMonitorProvider,",
-            "        ProducerToken.create(TestModule_ProduceStringFactory.class));",
+            "        ProducerToken.create(TestModule_ProduceStringFactory.class),",
+            "        executorProvider);",
             "    this.module = module;",
-            "    this.executorProvider = executorProvider;",
             "  }",
             "",
-            "  @Override protected ListenableFuture<String> compute() {",
-            "    return Futures.transformAsync(",
-            "        Futures.<Void>immediateFuture(null), this, this);",
+            "  @Override protected ListenableFuture<Void> collectDependencies() {",
+            "    return Futures.<Void>immediateFuture(null);",
             "  }",
             "",
-            "  @Deprecated",
-            "  @Override public ListenableFuture<String> apply(Void ignoredVoidArg) {",
-            "    monitor.methodStarting();",
-            "    try {",
-            "      return module.produceString();",
-            "    } finally {",
-            "      monitor.methodFinished();",
-            "    }",
-            "  }",
-            "",
-            "  @Deprecated",
-            "  @Override public void execute(Runnable runnable) {",
-            "    monitor.ready();",
-            "    executorProvider.get().execute(runnable);",
+            "  @Override public ListenableFuture<String> callProducesMethod(Void ignoredVoidArg) {",
+            "    return module.produceString();",
             "  }",
             "}");
     assertAbout(javaSource())
@@ -439,10 +423,9 @@ public void singleProducesMethodNoArgsFutureWithProducerName() {
             "TestModule_ProduceStringFactory",
             "package test;",
             "",
-            "import com.google.common.util.concurrent.AsyncFunction;",
             "import com.google.common.util.concurrent.Futures;",
             "import com.google.common.util.concurrent.ListenableFuture;",
-            "import dagger.producers.internal.AbstractProducer;",
+            "import dagger.producers.internal.AbstractProducesMethodProducer;",
             "import dagger.producers.monitoring.ProducerToken;",
             "import dagger.producers.monitoring.ProductionComponentMonitor;",
             "import java.util.concurrent.Executor;",
@@ -452,10 +435,8 @@ public void singleProducesMethodNoArgsFutureWithProducerName() {
             "@SuppressWarnings(\"FutureReturnValueIgnored\")",
             GENERATED_ANNOTATION,
             "public final class TestModule_ProduceStringFactory",
-            "    extends AbstractProducer<String>",
-            "    implements AsyncFunction<Void, String>, Executor {",
+            "    extends AbstractProducesMethodProducer<Void, String> {",
             "  private final TestModule module;",
-            "  private final Provider<Executor> executorProvider;",
             "",
             "  public TestModule_ProduceStringFactory(",
             "      TestModule module,",
@@ -463,30 +444,17 @@ public void singleProducesMethodNoArgsFutureWithProducerName() {
             "      Provider<ProductionComponentMonitor> productionComponentMonitorProvider) {",
             "    super(",
             "        productionComponentMonitorProvider,",
-            "        ProducerToken.create(\"test.TestModule#produceString\"));",
+            "        ProducerToken.create(\"test.TestModule#produceString\"),",
+            "        executorProvider);",
             "    this.module = module;",
-            "    this.executorProvider = executorProvider;",
-            "  }",
-            "",
-            "  @Override protected ListenableFuture<String> compute() {",
-            "    return Futures.transformAsync(",
-            "      Futures.<Void>immediateFuture(null), this, this);",
             "  }",
             "",
-            "  @Deprecated",
-            "  @Override public ListenableFuture<String> apply(Void ignoredVoidArg) {",
-            "    monitor.methodStarting();",
-            "    try {",
-            "      return module.produceString();",
-            "    } finally {",
-            "      monitor.methodFinished();",
-            "    }",
+            "  @Override protected ListenableFuture<Void> collectDependencies() {",
+            "    return Futures.<Void>immediateFuture(null);",
             "  }",
             "",
-            "  @Deprecated",
-            "  @Override public void execute(Runnable runnable) {",
-            "    monitor.ready();",
-            "    executorProvider.get().execute(runnable);",
+            "  @Override public ListenableFuture<String> callProducesMethod(Void ignoredVoidArg) {",
+            "    return module.produceString();",
             "  }",
             "}");
     assertAbout(javaSource())
@@ -498,11 +466,32 @@ public void singleProducesMethodNoArgsFutureWithProducerName() {
         .generatesSources(factoryFile);
   }
 
-  @Test public void producesMethodMultipleQualifiers() {
+  @Test
+  public void producesMethodMultipleQualifiersOnMethod() {
+    assertThatProductionModuleMethod(
+            "@Produces @QualifierA @QualifierB static String produceString() { return null; }")
+        .importing(ListenableFuture.class, QualifierA.class, QualifierB.class)
+        .hasError("may not use more than one @Qualifier");
+  }
+
+  @Test
+  public void producesMethodMultipleQualifiersOnParameter() {
+    assertThatProductionModuleMethod(
+            "@Produces static String produceString(@QualifierA @QualifierB Object input) "
+                + "{ return null; }")
+        .importing(ListenableFuture.class, QualifierA.class, QualifierB.class)
+        .hasError("may not use more than one @Qualifier");
+  }
+
+  @Test
+  public void producesMethodWildcardDependency() {
     assertThatProductionModuleMethod(
-            "@Produces @QualifierA @QualifierB abstract String produceString() { return null; }")
+            "@Produces static String produceString(Provider<? extends Number> numberProvider) "
+                + "{ return null; }")
         .importing(ListenableFuture.class, QualifierA.class, QualifierB.class)
-        .hasError("Cannot use more than one @Qualifier");
+        .hasError(
+            "Dagger does not support injecting Provider<T>, Lazy<T>, Producer<T>, or Produced<T> "
+                + "when T is a wildcard type such as ? extends java.lang.Number");
   }
 
   @Qualifier
diff --git a/javatests/dagger/internal/codegen/ProductionComponentProcessorTest.java b/javatests/dagger/internal/codegen/ProductionComponentProcessorTest.java
index b7fa898ca..13d821039 100644
--- a/javatests/dagger/internal/codegen/ProductionComponentProcessorTest.java
+++ b/javatests/dagger/internal/codegen/ProductionComponentProcessorTest.java
@@ -215,7 +215,7 @@ public void simpleComponent() {
             "}");
     JavaFileObject generatedComponent;
     switch (compilerMode) {
-      case EXPERIMENTAL_ANDROID_MODE:
+      case FAST_INIT_MODE:
         generatedComponent =
             JavaFileObjects.forSourceLines(
                 "test.DaggerTestClass_SimpleComponent",
@@ -228,6 +228,7 @@ public void simpleComponent() {
                 "import dagger.internal.Preconditions;",
                 "import dagger.internal.SetFactory;",
                 "import dagger.producers.Producer;",
+                "import dagger.producers.internal.CancellationListener;",
                 "import dagger.producers.internal.Producers;",
                 "import dagger.producers.monitoring.ProductionComponentMonitor;",
                 "import java.util.concurrent.Executor;",
@@ -236,7 +237,7 @@ public void simpleComponent() {
                 "",
                 GENERATED_ANNOTATION,
                 "public final class DaggerTestClass_SimpleComponent",
-                "    implements TestClass.SimpleComponent {",
+                "    implements TestClass.SimpleComponent, CancellationListener {",
                 "  private volatile Provider<Executor> executorProvider;",
                 "  private volatile Object productionImplementationExecutor =",
                 "      new MemoizedSentinel();",
@@ -244,6 +245,7 @@ public void simpleComponent() {
                 "  private volatile Object productionComponentMonitor = new MemoizedSentinel();",
                 "  private volatile Provider<TestClass.B> bProvider;",
                 "  private TestClass.BModule bModule;",
+                "  private Producer<TestClass.A> aEntryPoint;",
                 "  private Provider<TestClass.SimpleComponent> simpleComponentProvider;",
                 "  private Producer<TestClass.B> bProducer;",
                 "  private TestClass_AModule_AFactory aProducer;",
@@ -343,27 +345,33 @@ public void simpleComponent() {
                 "            getProductionImplementationExecutorProvider(),",
                 "            getProductionComponentMonitorProvider(),",
                 "            bProducer);",
+                "    this.aEntryPoint = Producers.entryPointViewOf(aProducer, this);",
                 "  }",
                 "",
                 "  @Override",
                 "  public ListenableFuture<TestClass.A> a() {",
-                "    return aProducer.get();",
+                "    return aEntryPoint.get();",
                 "  }",
                 "",
-                "  public static final class Builder {",
-                "    private TestClass.BModule bModule;",
+                "  @Override",
+                "  public void onProducerFutureCancelled(boolean mayInterruptIfRunning) {",
+                "    Producers.cancel(aProducer, mayInterruptIfRunning);",
+                "    Producers.cancel(bProducer, mayInterruptIfRunning);",
+                "  }",
                 "",
+                "  public static final class Builder {",
                 "    private TestClass.AModule aModule;",
+                "    private TestClass.BModule bModule;",
                 "",
                 "    private Builder() {}",
                 "",
                 "    public TestClass.SimpleComponent build() {",
-                "      if (bModule == null) {",
-                "        this.bModule = new TestClass.BModule();",
-                "      }",
                 "      if (aModule == null) {",
                 "        this.aModule = new TestClass.AModule();",
                 "      }",
+                "      if (bModule == null) {",
+                "        this.bModule = new TestClass.BModule();",
+                "      }",
                 "      return new DaggerTestClass_SimpleComponent(this);",
                 "    }",
                 "",
@@ -418,6 +426,7 @@ public void simpleComponent() {
                 "import dagger.internal.Preconditions;",
                 "import dagger.internal.SetFactory;",
                 "import dagger.producers.Producer;",
+                "import dagger.producers.internal.CancellationListener;",
                 "import dagger.producers.internal.Producers;",
                 "import dagger.producers.monitoring.ProductionComponentMonitor;",
                 "import java.util.concurrent.Executor;",
@@ -426,7 +435,8 @@ public void simpleComponent() {
                 "",
                 GENERATED_ANNOTATION,
                 "public final class DaggerTestClass_SimpleComponent",
-                "    implements TestClass.SimpleComponent {",
+                "    implements TestClass.SimpleComponent, CancellationListener {",
+                "  private Producer<TestClass.A> aEntryPoint;",
                 "  private TestClass_BModule_ExecutorFactory executorProvider;",
                 "  private Provider<Executor> executorProvider2;",
                 "  private Provider<TestClass.SimpleComponent> simpleComponentProvider;",
@@ -471,26 +481,33 @@ public void simpleComponent() {
                 "        executorProvider2,",
                 "        monitorProvider,",
                 "        bProducer);",
+                "    this.aEntryPoint = Producers.entryPointViewOf(aProducer, this);",
                 "  }",
                 "",
                 "  @Override",
                 "  public ListenableFuture<TestClass.A> a() {",
-                "    return aProducer.get();",
+                "    return aEntryPoint.get();",
+                "  }",
+                "",
+                "  @Override",
+                "  public void onProducerFutureCancelled(boolean mayInterruptIfRunning) {",
+                "    Producers.cancel(aProducer, mayInterruptIfRunning);",
+                "    Producers.cancel(bProducer, mayInterruptIfRunning);",
                 "  }",
                 "",
                 "  public static final class Builder {",
-                "    private TestClass.BModule bModule;",
                 "    private TestClass.AModule aModule;",
+                "    private TestClass.BModule bModule;",
                 "",
                 "    private Builder() {}",
                 "",
                 "    public TestClass.SimpleComponent build() {",
-                "      if (bModule == null) {",
-                "        this.bModule = new TestClass.BModule();",
-                "      }",
                 "      if (aModule == null) {",
                 "        this.aModule = new TestClass.AModule();",
                 "      }",
+                "      if (bModule == null) {",
+                "        this.bModule = new TestClass.BModule();",
+                "      }",
                 "      return new DaggerTestClass_SimpleComponent(this);",
                 "    }",
                 "",
diff --git a/javatests/dagger/internal/codegen/ProductionGraphValidationTest.java b/javatests/dagger/internal/codegen/ProductionGraphValidationTest.java
index 32f984b81..1029c1cd5 100644
--- a/javatests/dagger/internal/codegen/ProductionGraphValidationTest.java
+++ b/javatests/dagger/internal/codegen/ProductionGraphValidationTest.java
@@ -26,9 +26,7 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-/**
- * Unit tests for {@link BindingGraphValidator} that exercise producer-specific logic.
- */
+/** Producer-specific validation tests. */
 @RunWith(JUnit4.class)
 public class ProductionGraphValidationTest {
   private static final JavaFileObject EXECUTOR_MODULE =
@@ -82,7 +80,7 @@
             "test.Bar cannot be provided without an @Inject constructor or an @Provides- or "
                 + "@Produces-annotated method.")
         .inFile(component)
-        .onLine(8);
+        .onLineContaining("interface MyComponent");
   }
 
   @Test public void componentProductionWithNoDependencyChain() {
@@ -100,11 +98,15 @@
         "    ListenableFuture<A> getA();",
         "  }",
         "}");
-    String expectedError =
-        "test.TestClass.A cannot be provided without an @Provides- or @Produces-annotated method.";
+
     Compilation compilation = daggerCompiler().compile(EXECUTOR_MODULE, component);
     assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(expectedError).inFile(component).onLine(11);
+    assertThat(compilation)
+        .hadErrorContaining(
+            "test.TestClass.A cannot be provided without an @Provides- or @Produces-annotated "
+                + "method.")
+        .inFile(component)
+        .onLineContaining("interface AComponent");
   }
 
   @Test public void provisionDependsOnProduction() {
@@ -141,11 +143,13 @@
         "    ListenableFuture<A> getA();",
         "  }",
         "}");
-    String expectedError =
-        "test.TestClass.A is a provision, which cannot depend on a production.";
+
     Compilation compilation = daggerCompiler().compile(EXECUTOR_MODULE, component);
     assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(expectedError).inFile(component).onLine(30);
+    assertThat(compilation)
+        .hadErrorContaining("test.TestClass.A is a provision, which cannot depend on a production.")
+        .inFile(component)
+        .onLineContaining("interface AComponent");
   }
 
   @Test public void provisionEntryPointDependsOnProduction() {
@@ -174,11 +178,14 @@
             "    A getA();",
             "  }",
             "}");
-    String expectedError =
-        "test.TestClass.A is a provision entry-point, which cannot depend on a production.";
+
     Compilation compilation = daggerCompiler().compile(EXECUTOR_MODULE, component);
     assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(expectedError).inFile(component).onLine(20);
+    assertThat(compilation)
+        .hadErrorContaining(
+            "test.TestClass.A is a provision entry-point, which cannot depend on a production.")
+        .inFile(component)
+        .onLineContaining("interface AComponent");
   }
 
   @Test
@@ -236,7 +243,7 @@ public void providingMultibindingWithProductions() {
     assertThat(compilation)
         .hadErrorContaining("test.TestClass.A is a provision, which cannot depend on a production")
         .inFile(component)
-        .onLine(43);
+        .onLineContaining("interface AComponent");
   }
 
   @Test
@@ -280,11 +287,14 @@ public void monitoringDependsOnUnboundType() {
             "    ListenableFuture<String> getString();",
             "  }",
             "}");
-    String expectedError =
-        "test.TestClass.A cannot be provided without an @Provides-annotated method.";
+
     Compilation compilation = daggerCompiler().compile(EXECUTOR_MODULE, component);
     assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(expectedError).inFile(component).onLine(34);
+    assertThat(compilation)
+        .hadErrorContaining(
+            "test.TestClass.A cannot be provided without an @Provides-annotated method.")
+        .inFile(component)
+        .onLineContaining("interface StringComponent");
   }
 
   @Test
@@ -331,13 +341,16 @@ public void monitoringDependsOnProduction() {
             "    ListenableFuture<String> getString();",
             "  }",
             "}");
-    String expectedError =
-        "java.util.Set<dagger.producers.monitoring.ProductionComponentMonitor.Factory>"
-            + " test.TestClass.MonitoringModule#monitorFactory is a provision,"
-            + " which cannot depend on a production.";
+
     Compilation compilation = daggerCompiler().compile(EXECUTOR_MODULE, component);
     assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(expectedError).inFile(component).onLine(37);
+    assertThat(compilation)
+        .hadErrorContaining(
+            "java.util.Set<dagger.producers.monitoring.ProductionComponentMonitor.Factory>"
+                + " test.TestClass.MonitoringModule#monitorFactory is a provision,"
+                + " which cannot depend on a production.")
+        .inFile(component)
+        .onLineContaining("interface StringComponent");
   }
 
   @Test
@@ -378,7 +391,10 @@ public void cycleNotBrokenByMap() {
             "}");
     Compilation compilation = daggerCompiler().compile(EXECUTOR_MODULE, component, module);
     assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining("cycle").inFile(component).onLine(8);
+    assertThat(compilation)
+        .hadErrorContaining("cycle")
+        .inFile(component)
+        .onLineContaining("interface TestComponent");
   }
 
   @Test
@@ -420,7 +436,10 @@ public void cycleNotBrokenByProducerMap() {
             "}");
     Compilation compilation = daggerCompiler().compile(EXECUTOR_MODULE, component, module);
     assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining("cycle").inFile(component).onLine(8);
+    assertThat(compilation)
+        .hadErrorContaining("cycle")
+        .inFile(component)
+        .onLineContaining("interface TestComponent");
   }
   
   @Test
diff --git a/javatests/dagger/internal/codegen/ReleasableReferenceManagerValidationTest.java b/javatests/dagger/internal/codegen/ReleasableReferenceManagerValidationTest.java
new file mode 100644
index 000000000..ad039cad3
--- /dev/null
+++ b/javatests/dagger/internal/codegen/ReleasableReferenceManagerValidationTest.java
@@ -0,0 +1,490 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static dagger.internal.codegen.Compilers.daggerCompiler;
+import static dagger.internal.codegen.TestUtils.message;
+
+import com.google.testing.compile.Compilation;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public class ReleasableReferenceManagerValidationTest {
+  @Test
+  public void missingReleasableReferenceManager() {
+    JavaFileObject testScope =
+        JavaFileObjects.forSourceLines(
+            "test.TestScope",
+            "package test;",
+            "",
+            "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
+            "",
+            "import dagger.releasablereferences.CanReleaseReferences;",
+            "import java.lang.annotation.Retention;",
+            "import javax.inject.Scope;",
+            "",
+            "@CanReleaseReferences",
+            "@BadMetadata",
+            "@Scope",
+            "@Retention(RUNTIME)",
+            "@interface TestScope {}");
+    JavaFileObject otherScope =
+        JavaFileObjects.forSourceLines(
+            "test.OtherScope",
+            "package test;",
+            "",
+            "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
+            "",
+            "import dagger.releasablereferences.CanReleaseReferences;",
+            "import java.lang.annotation.Retention;",
+            "import javax.inject.Scope;",
+            "",
+            "@CanReleaseReferences",
+            "@Scope",
+            "@Retention(RUNTIME)",
+            "@interface OtherScope {}");
+    JavaFileObject yetAnotherScope =
+        JavaFileObjects.forSourceLines(
+            "test.YetAnotherScope",
+            "package test;",
+            "",
+            "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
+            "",
+            "import dagger.releasablereferences.CanReleaseReferences;",
+            "import java.lang.annotation.Retention;",
+            "import javax.inject.Scope;",
+            "",
+            "@CanReleaseReferences",
+            "@Scope",
+            "@Retention(RUNTIME)",
+            "@interface YetAnotherScope {}");
+    JavaFileObject testMetadata =
+        JavaFileObjects.forSourceLines(
+            "test.TestMetadata",
+            "package test;",
+            "",
+            "import dagger.releasablereferences.CanReleaseReferences;",
+            "",
+            "@CanReleaseReferences",
+            "@interface TestMetadata {}");
+    JavaFileObject badMetadata =
+        JavaFileObjects.forSourceLines(
+            "test.BadMetadata", // force one-string-per-line format
+            "package test;",
+            "",
+            "@interface BadMetadata {}");
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponents",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import dagger.releasablereferences.ForReleasableReferences;",
+            "import dagger.releasablereferences.ReleasableReferenceManager;",
+            "import dagger.releasablereferences.TypedReleasableReferenceManager;",
+            "",
+            "interface TestComponents {",
+            "  @TestScope",
+            "  @YetAnotherScope",
+            "  @Component",
+            "  interface WrongScopeComponent {",
+            "    @ForReleasableReferences(OtherScope.class)",
+            "    ReleasableReferenceManager otherManager();",
+            "  }",
+            "",
+            "  @TestScope",
+            "  @YetAnotherScope",
+            "  @Component",
+            "  interface WrongMetadataComponent {",
+            "    @ForReleasableReferences(TestScope.class)",
+            "    TypedReleasableReferenceManager<TestMetadata> wrongMetadata();",
+            "  }",
+            "",
+            "  @TestScope",
+            "  @YetAnotherScope",
+            "  @Component",
+            "  interface BadMetadataComponent {",
+            "    @ForReleasableReferences(TestScope.class)",
+            "    TypedReleasableReferenceManager<BadMetadata> badManager();",
+            "  }",
+            "}");
+    Compilation compilation =
+        daggerCompiler()
+            .compile(testScope, otherScope, yetAnotherScope, testMetadata, badMetadata, component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            "There is no binding for "
+                + "@dagger.releasablereferences.ForReleasableReferences(test.OtherScope.class) "
+                + "dagger.releasablereferences.ReleasableReferenceManager "
+                + "because no component in test.TestComponents.WrongScopeComponent's "
+                + "component hierarchy is annotated with @test.OtherScope. "
+                + "The available reference-releasing scopes are "
+                + "[@test.TestScope, @test.YetAnotherScope].")
+        .inFile(component)
+        .onLineContaining("interface WrongScopeComponent");
+    assertThat(compilation)
+        .hadErrorContaining(
+            "There is no binding for "
+                + "@dagger.releasablereferences.ForReleasableReferences(test.TestScope.class) "
+                + "dagger.releasablereferences.TypedReleasableReferenceManager<test.TestMetadata> "
+                + "because test.TestScope is not annotated with @test.TestMetadata")
+        .inFile(component)
+        .onLineContaining("interface WrongMetadataComponent");
+    assertThat(compilation)
+        .hadErrorContaining(
+            "There is no binding for "
+                + "@dagger.releasablereferences.ForReleasableReferences(test.TestScope.class) "
+                + "dagger.releasablereferences.TypedReleasableReferenceManager<test.BadMetadata> "
+                + "because test.BadMetadata is not annotated with "
+                + "@dagger.releasablereferences.CanReleaseReferences")
+        .inFile(component)
+        .onLineContaining("interface BadMetadataComponent");
+  }
+
+  @Test
+  public void releasableReferenceManagerConflict_ReleasableReferenceManager() {
+    JavaFileObject testScope =
+        JavaFileObjects.forSourceLines(
+            "test.TestScope",
+            "package test;",
+            "",
+            "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
+            "",
+            "import dagger.releasablereferences.CanReleaseReferences;",
+            "import java.lang.annotation.Retention;",
+            "import javax.inject.Scope;",
+            "",
+            "@TestMetadata",
+            "@CanReleaseReferences",
+            "@Scope",
+            "@Retention(RUNTIME)",
+            "@interface TestScope {}");
+    JavaFileObject testMetadata =
+        JavaFileObjects.forSourceLines(
+            "test.TestMetadata",
+            "package test;",
+            "",
+            "import dagger.releasablereferences.CanReleaseReferences;",
+            "",
+            "@CanReleaseReferences",
+            "@interface TestMetadata {}");
+
+    JavaFileObject testModule =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.releasablereferences.ForReleasableReferences;",
+            "import dagger.releasablereferences.ReleasableReferenceManager;",
+            "",
+            "@Module",
+            "abstract class TestModule {",
+            "  @Provides @ForReleasableReferences(TestScope.class)",
+            "  static ReleasableReferenceManager rrm() {",
+            "    return null;",
+            "  }",
+            "}");
+
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import dagger.releasablereferences.ForReleasableReferences;",
+            "import dagger.releasablereferences.ReleasableReferenceManager;",
+            "",
+            "@TestScope",
+            "@Component(modules = TestModule.class)",
+            "interface TestComponent {",
+            "  @ForReleasableReferences(TestScope.class)",
+            "  ReleasableReferenceManager testManager();",
+            "}");
+
+    Compilation compilation =
+        daggerCompiler().compile(testScope, testMetadata, testModule, component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            String.format(
+                message(
+                    "@%1$s.ForReleasableReferences(test.TestScope.class) "
+                        + "%1$s.ReleasableReferenceManager is bound multiple times:",
+                    "    @Provides @%1$s.ForReleasableReferences(test.TestScope.class) "
+                        + "%1$s.ReleasableReferenceManager test.TestModule.rrm()",
+                    "    binding for "
+                        + "@%1$s.ForReleasableReferences(value = test.TestScope.class) "
+                        + "%1$s.ReleasableReferenceManager from the scope declaration"),
+                "dagger.releasablereferences"))
+        .inFile(component)
+        .onLineContaining("interface TestComponent");
+  }
+
+  @Test
+  public void releasableReferenceManagerConflict_TypedReleasableReferenceManager() {
+    JavaFileObject testScope =
+        JavaFileObjects.forSourceLines(
+            "test.TestScope",
+            "package test;",
+            "",
+            "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
+            "",
+            "import dagger.releasablereferences.CanReleaseReferences;",
+            "import java.lang.annotation.Retention;",
+            "import javax.inject.Scope;",
+            "",
+            "@TestMetadata",
+            "@CanReleaseReferences",
+            "@Scope",
+            "@Retention(RUNTIME)",
+            "@interface TestScope {}");
+    JavaFileObject testMetadata =
+        JavaFileObjects.forSourceLines(
+            "test.TestMetadata",
+            "package test;",
+            "",
+            "import dagger.releasablereferences.CanReleaseReferences;",
+            "",
+            "@CanReleaseReferences",
+            "@interface TestMetadata {}");
+
+    JavaFileObject testModule =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.releasablereferences.ForReleasableReferences;",
+            "import dagger.releasablereferences.TypedReleasableReferenceManager;",
+            "",
+            "@Module",
+            "abstract class TestModule {",
+            "  @Provides @ForReleasableReferences(TestScope.class)",
+            "  static TypedReleasableReferenceManager<TestMetadata> typedRrm() {",
+            "    return null;",
+            "  }",
+            "}");
+
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import dagger.releasablereferences.ForReleasableReferences;",
+            "import dagger.releasablereferences.TypedReleasableReferenceManager;",
+            "",
+            "@TestScope",
+            "@Component(modules = TestModule.class)",
+            "interface TestComponent {",
+            "  @ForReleasableReferences(TestScope.class)",
+            "  TypedReleasableReferenceManager<TestMetadata> typedManager();",
+            "}");
+
+    Compilation compilation =
+        daggerCompiler().compile(testScope, testMetadata, testModule, component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            String.format(
+                message(
+                    "@%1$s.ForReleasableReferences(test.TestScope.class) "
+                        + "%1$s.TypedReleasableReferenceManager<test.TestMetadata> "
+                        + "is bound multiple times:",
+                    "    @Provides @%1$s.ForReleasableReferences(test.TestScope.class) "
+                        + "%1$s.TypedReleasableReferenceManager<test.TestMetadata> "
+                        + "test.TestModule.typedRrm()",
+                    "    binding for "
+                        + "@%1$s.ForReleasableReferences(value = test.TestScope.class) "
+                        + "%1$s.TypedReleasableReferenceManager<test.TestMetadata> "
+                        + "from the scope declaration"),
+                "dagger.releasablereferences"))
+        .inFile(component)
+        .onLineContaining("interface TestComponent");
+  }
+
+  @Test
+  public void releasableReferenceManagerConflict_SetOfReleasableReferenceManager() {
+    JavaFileObject testScope =
+        JavaFileObjects.forSourceLines(
+            "test.TestScope",
+            "package test;",
+            "",
+            "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
+            "",
+            "import dagger.releasablereferences.CanReleaseReferences;",
+            "import java.lang.annotation.Retention;",
+            "import javax.inject.Scope;",
+            "",
+            "@TestMetadata",
+            "@CanReleaseReferences",
+            "@Scope",
+            "@Retention(RUNTIME)",
+            "@interface TestScope {}");
+    JavaFileObject testMetadata =
+        JavaFileObjects.forSourceLines(
+            "test.TestMetadata",
+            "package test;",
+            "",
+            "import dagger.releasablereferences.CanReleaseReferences;",
+            "",
+            "@CanReleaseReferences",
+            "@interface TestMetadata {}");
+
+    JavaFileObject testModule =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.releasablereferences.ForReleasableReferences;",
+            "import dagger.releasablereferences.ReleasableReferenceManager;",
+            "import java.util.Set;",
+            "",
+            "@Module",
+            "abstract class TestModule {",
+            "  @Provides",
+            "  static Set<ReleasableReferenceManager> rrmSet() {",
+            "    return null;",
+            "  }",
+            "}");
+
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import dagger.releasablereferences.ForReleasableReferences;",
+            "import dagger.releasablereferences.ReleasableReferenceManager;",
+            "import java.util.Set;",
+            "",
+            "@TestScope",
+            "@Component(modules = TestModule.class)",
+            "interface TestComponent {",
+            "  Set<ReleasableReferenceManager> managers();",
+            "}");
+
+    Compilation compilation =
+        daggerCompiler().compile(testScope, testMetadata, testModule, component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "java.util.Set<dagger.releasablereferences.ReleasableReferenceManager> "
+                    + "is bound multiple times:",
+                "    @Provides "
+                    + "Set<dagger.releasablereferences.ReleasableReferenceManager> "
+                    + "test.TestModule.rrmSet()",
+                "    Dagger-generated binding for "
+                    + "Set<dagger.releasablereferences.ReleasableReferenceManager>"))
+        .inFile(component)
+        .onLineContaining("interface TestComponent");
+  }
+
+  @Test
+  public void releasableReferenceManagerConflict_SetOfTypedReleasableReferenceManagers() {
+    JavaFileObject testScope =
+        JavaFileObjects.forSourceLines(
+            "test.TestScope",
+            "package test;",
+            "",
+            "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
+            "",
+            "import dagger.releasablereferences.CanReleaseReferences;",
+            "import java.lang.annotation.Retention;",
+            "import javax.inject.Scope;",
+            "",
+            "@TestMetadata",
+            "@CanReleaseReferences",
+            "@Scope",
+            "@Retention(RUNTIME)",
+            "@interface TestScope {}");
+    JavaFileObject testMetadata =
+        JavaFileObjects.forSourceLines(
+            "test.TestMetadata",
+            "package test;",
+            "",
+            "import dagger.releasablereferences.CanReleaseReferences;",
+            "",
+            "@CanReleaseReferences",
+            "@interface TestMetadata {}");
+
+    JavaFileObject testModule =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.releasablereferences.ForReleasableReferences;",
+            "import dagger.releasablereferences.TypedReleasableReferenceManager;",
+            "import java.util.Set;",
+            "",
+            "@Module",
+            "abstract class TestModule {",
+            "  @Provides",
+            "  static Set<TypedReleasableReferenceManager<TestMetadata>> typedRrmSet() {",
+            "    return null;",
+            "  }",
+            "}");
+
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import dagger.releasablereferences.ForReleasableReferences;",
+            "import dagger.releasablereferences.TypedReleasableReferenceManager;",
+            "import java.util.Set;",
+            "",
+            "@TestScope",
+            "@Component(modules = TestModule.class)",
+            "interface TestComponent {",
+            "  Set<TypedReleasableReferenceManager<TestMetadata>> typedManagers();",
+            "}");
+
+    Compilation compilation =
+        daggerCompiler().compile(testScope, testMetadata, testModule, component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            String.format(
+                message(
+                    "java.util.Set<%1$s.TypedReleasableReferenceManager<test.TestMetadata>> "
+                        + "is bound multiple times:",
+                    "    @Provides "
+                        + "Set<%1$s.TypedReleasableReferenceManager<test.TestMetadata>> "
+                        + "test.TestModule.typedRrmSet()",
+                    "    Dagger-generated binding for "
+                        + "Set<%1$s.TypedReleasableReferenceManager<test.TestMetadata>>"),
+                "dagger.releasablereferences"))
+        .inFile(component)
+        .onLineContaining("interface TestComponent");
+  }
+}
diff --git a/javatests/dagger/internal/codegen/ScopingValidationTest.java b/javatests/dagger/internal/codegen/ScopingValidationTest.java
new file mode 100644
index 000000000..cbe358013
--- /dev/null
+++ b/javatests/dagger/internal/codegen/ScopingValidationTest.java
@@ -0,0 +1,557 @@
+/*
+ * Copyright (C) 2014 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static dagger.internal.codegen.Compilers.daggerCompiler;
+import static dagger.internal.codegen.TestUtils.message;
+
+import com.google.testing.compile.Compilation;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public class ScopingValidationTest {
+  @Test
+  public void componentWithoutScopeIncludesScopedBindings_Fail() {
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.MyComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Singleton;",
+            "",
+            "@Component(modules = ScopedModule.class)",
+            "interface MyComponent {",
+            "  ScopedType string();",
+            "}");
+    JavaFileObject typeFile =
+        JavaFileObjects.forSourceLines(
+            "test.ScopedType",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "import javax.inject.Singleton;",
+            "",
+            "@Singleton",
+            "class ScopedType {",
+            "  @Inject ScopedType(String s, long l, float f) {}",
+            "}");
+    JavaFileObject moduleFile =
+        JavaFileObjects.forSourceLines(
+            "test.ScopedModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import javax.inject.Singleton;",
+            "",
+            "@Module",
+            "class ScopedModule {",
+            "  @Provides @Singleton String string() { return \"a string\"; }",
+            "  @Provides long integer() { return 0L; }",
+            "  @Provides float floatingPoint() { return 0.0f; }",
+            "}");
+
+    Compilation compilation = daggerCompiler().compile(componentFile, typeFile, moduleFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "test.MyComponent (unscoped) may not reference scoped bindings:",
+                "    @Singleton class test.ScopedType",
+                "    @Provides @Singleton String test.ScopedModule.string()"));
+  }
+
+  @Test // b/79859714
+  public void bindsWithChildScope_inParentModule_notAllowed() {
+    JavaFileObject childScope =
+        JavaFileObjects.forSourceLines(
+            "test.ChildScope",
+            "package test;",
+            "",
+            "import javax.inject.Scope;",
+            "",
+            "@Scope",
+            "@interface ChildScope {}");
+
+    JavaFileObject foo =
+        JavaFileObjects.forSourceLines(
+            "test.Foo",
+            "package test;",
+            "", //
+            "interface Foo {}");
+
+    JavaFileObject fooImpl =
+        JavaFileObjects.forSourceLines(
+            "test.ChildModule",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class FooImpl implements Foo {",
+            "  @Inject FooImpl() {}",
+            "}");
+
+    JavaFileObject parentModule =
+        JavaFileObjects.forSourceLines(
+            "test.ParentModule",
+            "package test;",
+            "",
+            "import dagger.Binds;",
+            "import dagger.Module;",
+            "",
+            "@Module",
+            "interface ParentModule {",
+            "  @Binds @ChildScope Foo bind(FooImpl fooImpl);",
+            "}");
+
+    JavaFileObject parent =
+        JavaFileObjects.forSourceLines(
+            "test.ParentComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Singleton;",
+            "",
+            "@Singleton",
+            "@Component(modules = ParentModule.class)",
+            "interface Parent {",
+            "  Child child();",
+            "}");
+
+    JavaFileObject child =
+        JavaFileObjects.forSourceLines(
+            "test.Child",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@ChildScope",
+            "@Subcomponent",
+            "interface Child {",
+            "  Foo foo();",
+            "}");
+
+    Compilation compilation =
+        daggerCompiler().compile(childScope, foo, fooImpl, parentModule, parent, child);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "test.Parent scoped with @Singleton may not reference bindings with different "
+                    + "scopes:",
+                "    @Binds @test.ChildScope test.Foo test.ParentModule.bind(test.FooImpl)"));
+  }
+
+  @Test
+  public void componentWithScopeIncludesIncompatiblyScopedBindings_Fail() {
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.MyComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Singleton;",
+            "",
+            "@Singleton",
+            "@Component(modules = ScopedModule.class)",
+            "interface MyComponent {",
+            "  ScopedType string();",
+            "}");
+    JavaFileObject scopeFile =
+        JavaFileObjects.forSourceLines(
+            "test.PerTest",
+            "package test;",
+            "",
+            "import javax.inject.Scope;",
+            "",
+            "@Scope",
+            "@interface PerTest {}");
+    JavaFileObject scopeWithAttribute =
+        JavaFileObjects.forSourceLines(
+            "test.Per",
+            "package test;",
+            "",
+            "import javax.inject.Scope;",
+            "",
+            "@Scope",
+            "@interface Per {",
+            "  Class<?> value();",
+            "}");
+    JavaFileObject typeFile =
+        JavaFileObjects.forSourceLines(
+            "test.ScopedType",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "@PerTest", // incompatible scope
+            "class ScopedType {",
+            "  @Inject ScopedType(String s, long l, float f, boolean b) {}",
+            "}");
+    JavaFileObject moduleFile =
+        JavaFileObjects.forSourceLines(
+            "test.ScopedModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import javax.inject.Singleton;",
+            "",
+            "@Module",
+            "class ScopedModule {",
+            "  @Provides @PerTest String string() { return \"a string\"; }", // incompatible scope
+            "  @Provides long integer() { return 0L; }", // unscoped - valid
+            "  @Provides @Singleton float floatingPoint() { return 0.0f; }", // same scope - valid
+            "  @Provides @Per(MyComponent.class) boolean bool() { return false; }", // incompatible
+            "}");
+
+    Compilation compilation =
+        daggerCompiler()
+            .compile(componentFile, scopeFile, scopeWithAttribute, typeFile, moduleFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "test.MyComponent scoped with @Singleton "
+                    + "may not reference bindings with different scopes:",
+                "    @test.PerTest class test.ScopedType",
+                "    @Provides @test.PerTest String test.ScopedModule.string()",
+                "    @Provides @test.Per(test.MyComponent.class) boolean "
+                    + "test.ScopedModule.bool()"));
+  }
+
+  @Test
+  public void componentWithScopeMayDependOnOnlyOneScopedComponent() {
+    // If a scoped component will have dependencies, they must only include, at most, a single
+    // scoped component
+    JavaFileObject type =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleType",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class SimpleType {",
+            "  @Inject SimpleType() {}",
+            "  static class A { @Inject A() {} }",
+            "  static class B { @Inject B() {} }",
+            "}");
+    JavaFileObject simpleScope =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleScope",
+            "package test;",
+            "",
+            "import javax.inject.Scope;",
+            "",
+            "@Scope @interface SimpleScope {}");
+    JavaFileObject singletonScopedA =
+        JavaFileObjects.forSourceLines(
+            "test.SingletonComponentA",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Singleton;",
+            "",
+            "@Singleton",
+            "@Component",
+            "interface SingletonComponentA {",
+            "  SimpleType.A type();",
+            "}");
+    JavaFileObject singletonScopedB =
+        JavaFileObjects.forSourceLines(
+            "test.SingletonComponentB",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Singleton;",
+            "",
+            "@Singleton",
+            "@Component",
+            "interface SingletonComponentB {",
+            "  SimpleType.B type();",
+            "}");
+    JavaFileObject scopeless =
+        JavaFileObjects.forSourceLines(
+            "test.ScopelessComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface ScopelessComponent {",
+            "  SimpleType type();",
+            "}");
+    JavaFileObject simpleScoped =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleScopedComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@SimpleScope",
+            "@Component(dependencies = {SingletonComponentA.class, SingletonComponentB.class})",
+            "interface SimpleScopedComponent {",
+            "  SimpleType.A type();",
+            "}");
+
+    Compilation compilation =
+        daggerCompiler()
+            .compile(
+                type, simpleScope, simpleScoped, singletonScopedA, singletonScopedB, scopeless);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "@test.SimpleScope test.SimpleScopedComponent depends on more than one scoped "
+                    + "component:",
+                "    @Singleton test.SingletonComponentA",
+                "    @Singleton test.SingletonComponentB"));
+  }
+
+  @Test
+  public void componentWithoutScopeCannotDependOnScopedComponent() {
+    JavaFileObject type =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleType",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class SimpleType {",
+            "  @Inject SimpleType() {}",
+            "}");
+    JavaFileObject scopedComponent =
+        JavaFileObjects.forSourceLines(
+            "test.ScopedComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Singleton;",
+            "",
+            "@Singleton",
+            "@Component",
+            "interface ScopedComponent {",
+            "  SimpleType type();",
+            "}");
+    JavaFileObject unscopedComponent =
+        JavaFileObjects.forSourceLines(
+            "test.UnscopedComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Singleton;",
+            "",
+            "@Component(dependencies = ScopedComponent.class)",
+            "interface UnscopedComponent {",
+            "  SimpleType type();",
+            "}");
+
+    Compilation compilation = daggerCompiler().compile(type, scopedComponent, unscopedComponent);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "test.UnscopedComponent (unscoped) cannot depend on scoped components:",
+                "    @Singleton test.ScopedComponent"));
+  }
+
+  @Test
+  public void componentWithSingletonScopeMayNotDependOnOtherScope() {
+    // Singleton must be the widest lifetime of present scopes.
+    JavaFileObject type =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleType",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class SimpleType {",
+            "  @Inject SimpleType() {}",
+            "}");
+    JavaFileObject simpleScope =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleScope",
+            "package test;",
+            "",
+            "import javax.inject.Scope;",
+            "",
+            "@Scope @interface SimpleScope {}");
+    JavaFileObject simpleScoped =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleScopedComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@SimpleScope",
+            "@Component",
+            "interface SimpleScopedComponent {",
+            "  SimpleType type();",
+            "}");
+    JavaFileObject singletonScoped =
+        JavaFileObjects.forSourceLines(
+            "test.SingletonComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Singleton;",
+            "",
+            "@Singleton",
+            "@Component(dependencies = SimpleScopedComponent.class)",
+            "interface SingletonComponent {",
+            "  SimpleType type();",
+            "}");
+
+    Compilation compilation =
+        daggerCompiler().compile(type, simpleScope, simpleScoped, singletonScoped);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "This @Singleton component cannot depend on scoped components:",
+                "    @test.SimpleScope test.SimpleScopedComponent"));
+  }
+
+  @Test
+  public void componentScopeAncestryMustNotCycle() {
+    // The dependency relationship of components is necessarily from shorter lifetimes to
+    // longer lifetimes.  The scoping annotations must reflect this, and so one cannot declare
+    // scopes on components such that they cycle.
+    JavaFileObject type =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleType",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class SimpleType {",
+            "  @Inject SimpleType() {}",
+            "}");
+    JavaFileObject scopeA =
+        JavaFileObjects.forSourceLines(
+            "test.ScopeA",
+            "package test;",
+            "",
+            "import javax.inject.Scope;",
+            "",
+            "@Scope @interface ScopeA {}");
+    JavaFileObject scopeB =
+        JavaFileObjects.forSourceLines(
+            "test.ScopeB",
+            "package test;",
+            "",
+            "import javax.inject.Scope;",
+            "",
+            "@Scope @interface ScopeB {}");
+    JavaFileObject longLifetime =
+        JavaFileObjects.forSourceLines(
+            "test.ComponentLong",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@ScopeA",
+            "@Component",
+            "interface ComponentLong {",
+            "  SimpleType type();",
+            "}");
+    JavaFileObject mediumLifetime =
+        JavaFileObjects.forSourceLines(
+            "test.ComponentMedium",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@ScopeB",
+            "@Component(dependencies = ComponentLong.class)",
+            "interface ComponentMedium {",
+            "  SimpleType type();",
+            "}");
+    JavaFileObject shortLifetime =
+        JavaFileObjects.forSourceLines(
+            "test.ComponentShort",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@ScopeA",
+            "@Component(dependencies = ComponentMedium.class)",
+            "interface ComponentShort {",
+            "  SimpleType type();",
+            "}");
+
+    Compilation compilation =
+        daggerCompiler().compile(type, scopeA, scopeB, longLifetime, mediumLifetime, shortLifetime);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "test.ComponentShort depends on scoped components in a non-hierarchical scope "
+                    + "ordering:",
+                "    @test.ScopeA test.ComponentLong",
+                "    @test.ScopeB test.ComponentMedium",
+                "    @test.ScopeA test.ComponentShort"));
+  }
+
+  @Test
+  public void reusableNotAllowedOnComponent() {
+    JavaFileObject someComponent =
+        JavaFileObjects.forSourceLines(
+            "test.SomeComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import dagger.Reusable;",
+            "",
+            "@Reusable",
+            "@Component",
+            "interface SomeComponent {}");
+    Compilation compilation = daggerCompiler().compile(someComponent);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("@Reusable cannot be applied to components or subcomponents")
+        .inFile(someComponent)
+        .onLine(6);
+  }
+
+  @Test
+  public void reusableNotAllowedOnSubcomponent() {
+    JavaFileObject someSubcomponent =
+        JavaFileObjects.forSourceLines(
+            "test.SomeComponent",
+            "package test;",
+            "",
+            "import dagger.Reusable;",
+            "import dagger.Subcomponent;",
+            "",
+            "@Reusable",
+            "@Subcomponent",
+            "interface SomeSubcomponent {}");
+    Compilation compilation = daggerCompiler().compile(someSubcomponent);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("@Reusable cannot be applied to components or subcomponents")
+        .inFile(someSubcomponent)
+        .onLine(6);
+  }
+}
diff --git a/javatests/dagger/internal/codegen/SetBindingRequestFulfillmentWithGuavaTest.java b/javatests/dagger/internal/codegen/SetBindingRequestFulfillmentWithGuavaTest.java
index 0274d96d2..8caae3e2a 100644
--- a/javatests/dagger/internal/codegen/SetBindingRequestFulfillmentWithGuavaTest.java
+++ b/javatests/dagger/internal/codegen/SetBindingRequestFulfillmentWithGuavaTest.java
@@ -330,11 +330,13 @@ public void productionComponents() {
             "import com.google.common.util.concurrent.Futures;",
             "import com.google.common.util.concurrent.ListenableFuture;",
             "import dagger.internal.Preconditions;",
+            "import dagger.producers.internal.CancellationListener;",
             "import java.util.Set;",
             IMPORT_GENERATED_ANNOTATION,
             "",
             GENERATED_ANNOTATION,
-            "public final class DaggerTestComponent implements TestComponent {",
+            "public final class DaggerTestComponent implements TestComponent, "
+                + "CancellationListener {",
             "  private DaggerTestComponent(Builder builder) {}",
             "",
             "  public static Builder builder() {",
@@ -355,6 +357,9 @@ public void productionComponents() {
             "    return Futures.immediateFuture(getSetOfString());",
             "  }",
             "",
+            "  @Override",
+            "  public void onProducerFutureCancelled(boolean mayInterruptIfRunning) {}",
+            "",
             "  public static final class Builder {",
             "    private Builder() {}",
             "",
diff --git a/javatests/dagger/internal/codegen/SubcomponentBuilderValidationTest.java b/javatests/dagger/internal/codegen/SubcomponentBuilderValidationTest.java
index a829ec3d5..3cfed6971 100644
--- a/javatests/dagger/internal/codegen/SubcomponentBuilderValidationTest.java
+++ b/javatests/dagger/internal/codegen/SubcomponentBuilderValidationTest.java
@@ -18,8 +18,8 @@
 
 import static com.google.testing.compile.CompilationSubject.assertThat;
 import static dagger.internal.codegen.Compilers.daggerCompiler;
+import static dagger.internal.codegen.TestUtils.message;
 
-import com.google.common.base.Joiner;
 import com.google.testing.compile.Compilation;
 import com.google.testing.compile.JavaFileObjects;
 import javax.tools.JavaFileObject;
@@ -719,15 +719,17 @@ public void testMultipleSettersPerBoundInstanceTypeFails() {
             "    @BindsInstance void set2(String s);",
             "  }",
             "}");
+
     Compilation compilation = daggerCompiler().compile(componentFile, childComponentFile);
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining(
-            Joiner.on("\n      ")
-                .join(
-                    "[test.ChildComponent.s()] java.lang.String is bound multiple times:",
-                    "@BindsInstance void test.ChildComponent.Builder.set1(String)",
-                    "@BindsInstance void test.ChildComponent.Builder.set2(String)"))
+            message(
+                "java.lang.String is bound multiple times:",
+                "    @BindsInstance void test.ChildComponent.Builder.set1(String)",
+                "    @BindsInstance void test.ChildComponent.Builder.set2(String)",
+                "    java.lang.String is provided at",
+                "        test.ChildComponent.s() [test.ParentComponent → test.ChildComponent]"))
         .inFile(componentFile)
         .onLineContaining("interface ParentComponent {");
   }
diff --git a/javatests/dagger/internal/codegen/SubcomponentValidationTest.java b/javatests/dagger/internal/codegen/SubcomponentValidationTest.java
index 5e02bd637..212e62aae 100644
--- a/javatests/dagger/internal/codegen/SubcomponentValidationTest.java
+++ b/javatests/dagger/internal/codegen/SubcomponentValidationTest.java
@@ -18,7 +18,7 @@
 
 import static com.google.testing.compile.CompilationSubject.assertThat;
 import static dagger.internal.codegen.CompilerMode.DEFAULT_MODE;
-import static dagger.internal.codegen.CompilerMode.EXPERIMENTAL_ANDROID_MODE;
+import static dagger.internal.codegen.CompilerMode.FAST_INIT_MODE;
 import static dagger.internal.codegen.Compilers.daggerCompiler;
 import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
 import static dagger.internal.codegen.GeneratedLines.IMPORT_GENERATED_ANNOTATION;
@@ -93,7 +93,77 @@ public SubcomponentValidationTest(CompilerMode compilerMode) {
                 + "Add the following modules as parameters to this method: "
                 + "test.ModuleWithParameters")
         .inFile(componentFile)
-        .onLine(7);
+        .onLineContaining("ChildComponent newChildComponent();");
+  }
+
+  @Test
+  public void factoryMethod_grandchild() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface TestComponent {",
+            "  ChildComponent newChildComponent();",
+            "}");
+    JavaFileObject childComponent =
+        JavaFileObjects.forSourceLines(
+            "test.ChildComponent",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent",
+            "interface ChildComponent {",
+            "  GrandchildComponent newGrandchildComponent();",
+            "}");
+    JavaFileObject grandchildComponent =
+        JavaFileObjects.forSourceLines(
+            "test.GrandchildComponent",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = GrandchildModule.class)",
+            "interface GrandchildComponent {",
+            "  Object object();",
+            "}");
+    JavaFileObject grandchildModule =
+        JavaFileObjects.forSourceLines(
+            "test.GrandchildModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "final class GrandchildModule {",
+            "  private final Object object;",
+            "",
+            "  GrandchildModule(Object object) {",
+            "    this.object = object;",
+            "  }",
+            "",
+            "  @Provides Object object() {",
+            "    return object;",
+            "  }",
+            "}");
+    Compilation compilation =
+        daggerCompiler()
+            .withOptions(compilerMode.javacopts())
+            .compile(component, childComponent, grandchildComponent, grandchildModule);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            "[test.ChildComponent.newGrandchildComponent()] "
+                + "test.GrandchildComponent requires modules which have no visible default "
+                + "constructors. Add the following modules as parameters to this method: "
+                + "test.GrandchildModule")
+        .inFile(component)
+        .onLineContaining("interface TestComponent");
   }
 
   @Test public void factoryMethod_nonModuleParameter() {
@@ -239,11 +309,10 @@ public SubcomponentValidationTest(CompilerMode compilerMode) {
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining(
-            "[test.ChildComponent.getString()] "
-                + "java.lang.Integer cannot be provided without an @Inject constructor or an "
+            "java.lang.Integer cannot be provided without an @Inject constructor or an "
                 + "@Provides-annotated method")
         .inFile(componentFile)
-        .onLine(6);
+        .onLineContaining("interface TestComponent");
   }
 
   @Test public void subcomponentOnConcreteType() {
@@ -408,7 +477,7 @@ public void delegateFactoryNotCreatedForSubcomponentWhenProviderExistsInParent()
                 "  @Override", //
                 "  public Dep1 getDep1() {")
             .addLinesIn(
-                EXPERIMENTAL_ANDROID_MODE,
+                FAST_INIT_MODE,
                 "   Object local = dep1;",
                 "    if (local instanceof MemoizedSentinel) {",
                 "      synchronized (local) {",
@@ -429,7 +498,7 @@ public void delegateFactoryNotCreatedForSubcomponentWhenProviderExistsInParent()
                 "  @Override",
                 "  public Dep2 getDep2() {")
             .addLinesIn(
-                EXPERIMENTAL_ANDROID_MODE,
+                FAST_INIT_MODE,
                 "   Object local = dep2;",
                 "    if (local instanceof MemoizedSentinel) {",
                 "      synchronized (local) {",
@@ -453,7 +522,7 @@ public void delegateFactoryNotCreatedForSubcomponentWhenProviderExistsInParent()
                 "  }",
                 "")
             .addLinesIn(
-                EXPERIMENTAL_ANDROID_MODE,
+                FAST_INIT_MODE,
                 "  @CanIgnoreReturnValue",
                 "  private Dep1 injectDep1(Dep1 instance) {",
                 "    Dep1_MembersInjector.injectDep1Method(instance);",
@@ -480,7 +549,7 @@ public void delegateFactoryNotCreatedForSubcomponentWhenProviderExistsInParent()
                 "      return new NeedsDep1(DaggerParentComponent.this.dep1Provider.get());",
                 "    }")
             .addLinesIn(
-                EXPERIMENTAL_ANDROID_MODE,
+                FAST_INIT_MODE,
                 "    private NeedsDep1 getNeedsDep1() {",
                 "      return new NeedsDep1(DaggerParentComponent.this.getDep1());",
                 "    }")
@@ -494,7 +563,7 @@ public void delegateFactoryNotCreatedForSubcomponentWhenProviderExistsInParent()
                 "              DaggerParentComponent.this.dep1Provider.get(),",
                 "              DaggerParentComponent.this.dep2Provider.get()));")
             .addLinesIn(
-                EXPERIMENTAL_ANDROID_MODE,
+                FAST_INIT_MODE,
                 "              DaggerParentComponent.this.getDep1(),",
                 "              DaggerParentComponent.this.getDep2()));")
             .addLines(
diff --git a/javatests/dagger/internal/codegen/SwitchingProviderTest.java b/javatests/dagger/internal/codegen/SwitchingProviderTest.java
index bb2a3316c..721d322a1 100644
--- a/javatests/dagger/internal/codegen/SwitchingProviderTest.java
+++ b/javatests/dagger/internal/codegen/SwitchingProviderTest.java
@@ -596,6 +596,6 @@ public void optionals() {
   private Compiler compilerWithAndroidMode() {
     return javac()
         .withProcessors(new ComponentProcessor())
-        .withOptions(CompilerMode.EXPERIMENTAL_ANDROID_MODE.javacopts());
+        .withOptions(CompilerMode.FAST_INIT_MODE.javacopts());
   }
 }
diff --git a/javatests/dagger/internal/codegen/TestUtils.java b/javatests/dagger/internal/codegen/TestUtils.java
new file mode 100644
index 000000000..c02a5f934
--- /dev/null
+++ b/javatests/dagger/internal/codegen/TestUtils.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import com.google.common.base.Joiner;
+
+/** Utility methods useful for codegen tests. */
+final class TestUtils {
+
+  private static final Joiner MESSAGE_JOINER = Joiner.on("\n  ");
+
+  /**
+   * Returns the lines joined by newline plus two spaces. Useful for passing to {@link
+   * com.google.testing.compile.CompilationSubject#hadErrorContaining(String)}, etc.
+   */
+  static String message(String... lines) {
+    return MESSAGE_JOINER.join(lines);
+  }
+}
diff --git a/javatests/dagger/producers/BUILD b/javatests/dagger/producers/BUILD
index 1d353ee13..58a8987c0 100644
--- a/javatests/dagger/producers/BUILD
+++ b/javatests/dagger/producers/BUILD
@@ -31,10 +31,10 @@ GenJavaTests(
     javacopts = SOURCE_7_TARGET_7 + DOCLINT_REFERENCES + DOCLINT_HTML_AND_SYNTAX,
     deps = [
         "//java/dagger/producers",
-        "//third_party:guava",
-        "//third_party:guava_testlib",
-        "//third_party:junit",
-        "//third_party:mockito",
-        "//third_party:truth",
+        "@google_bazel_common//third_party/java/guava",
+        "@google_bazel_common//third_party/java/guava:testlib",
+        "@google_bazel_common//third_party/java/junit",
+        "@google_bazel_common//third_party/java/mockito",
+        "@google_bazel_common//third_party/java/truth",
     ],
 )
diff --git a/javatests/dagger/producers/internal/AbstractProducerTest.java b/javatests/dagger/producers/internal/AbstractProducerTest.java
index 0e2fca495..da2412513 100644
--- a/javatests/dagger/producers/internal/AbstractProducerTest.java
+++ b/javatests/dagger/producers/internal/AbstractProducerTest.java
@@ -18,55 +18,23 @@
 
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.fail;
-import static org.mockito.Matchers.any;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.verifyNoMoreInteractions;
-import static org.mockito.Mockito.when;
 
 import com.google.common.util.concurrent.Futures;
 import com.google.common.util.concurrent.ListenableFuture;
-import com.google.common.util.concurrent.SettableFuture;
 import dagger.producers.Producer;
-import dagger.producers.monitoring.ProducerMonitor;
-import dagger.producers.monitoring.ProducerToken;
-import dagger.producers.monitoring.ProductionComponentMonitor;
-import java.util.concurrent.ExecutionException;
-import javax.inject.Provider;
-import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
-import org.mockito.Mock;
-import org.mockito.Mockito;
-import org.mockito.MockitoAnnotations;
 
 /**
  * Tests {@link AbstractProducer}.
  */
 @RunWith(JUnit4.class)
 public class AbstractProducerTest {
-  @Mock private ProductionComponentMonitor componentMonitor;
-  private ProducerMonitor monitor;
-  private Provider<ProductionComponentMonitor> componentMonitorProvider;
-
-  @Before
-  public void initMocks() {
-    MockitoAnnotations.initMocks(this);
-    monitor = Mockito.mock(ProducerMonitor.class, Mockito.CALLS_REAL_METHODS);
-    when(componentMonitor.producerMonitorFor(any(ProducerToken.class))).thenReturn(monitor);
-    componentMonitorProvider =
-        new Provider<ProductionComponentMonitor>() {
-          @Override
-          public ProductionComponentMonitor get() {
-            return componentMonitor;
-          }
-        };
-  }
-
   @Test
   @SuppressWarnings("CheckReturnValue")
   public void get_nullPointerException() {
-    Producer<Object> producer = new DelegateProducer<>(componentMonitorProvider, null);
+    Producer<Object> producer = new DelegateProducer<>(null);
     try {
       producer.get();
       fail();
@@ -76,7 +44,7 @@ public void get_nullPointerException() {
 
   @Test public void get() throws Exception {
     Producer<Integer> producer =
-        new AbstractProducer<Integer>(componentMonitorProvider, null) {
+        new AbstractProducer<Integer>() {
           int i = 0;
 
           @Override
@@ -89,64 +57,15 @@ public void get_nullPointerException() {
     assertThat(producer.get().get()).isEqualTo(0);
   }
 
-  @Test
-  public void monitor_success() throws Exception {
-    SettableFuture<Integer> delegateFuture = SettableFuture.create();
-    Producer<Integer> producer = new DelegateProducer<>(componentMonitorProvider, delegateFuture);
-
-    ListenableFuture<Integer> future = producer.get();
-    assertThat(future.isDone()).isFalse();
-    verify(monitor).requested();
-    verify(monitor).addCallbackTo(anyListenableFuture());
-    delegateFuture.set(-42);
-    assertThat(future.get()).isEqualTo(-42);
-    verify(monitor).succeeded(-42);
-    verifyNoMoreInteractions(monitor);
-  }
-
-  @Test
-  public void monitor_failure() throws Exception {
-    SettableFuture<Integer> delegateFuture = SettableFuture.create();
-    Producer<Integer> producer = new DelegateProducer<>(componentMonitorProvider, delegateFuture);
-
-    ListenableFuture<Integer> future = producer.get();
-    assertThat(future.isDone()).isFalse();
-    verify(monitor).requested();
-    verify(monitor).addCallbackTo(anyListenableFuture());
-    Throwable t = new RuntimeException("monkey");
-    delegateFuture.setException(t);
-    try {
-      future.get();
-      fail();
-    } catch (ExecutionException e) {
-      assertThat(e.getCause()).isSameAs(t);
-    }
-    verify(monitor).failed(t);
-    verifyNoMoreInteractions(monitor);
-  }
-
-  private ListenableFuture<?> anyListenableFuture() {
-    return any(ListenableFuture.class);
-  }
-
-  @Test(expected = NullPointerException.class)
-  public void monitor_null() throws Exception {
-    new DelegateProducer<>(null, Futures.immediateFuture(42));
-  }
-
   static final class DelegateProducer<T> extends AbstractProducer<T> {
     private final ListenableFuture<T> delegate;
 
-    DelegateProducer(
-        Provider<ProductionComponentMonitor> componentMonitorProvider,
-        ListenableFuture<T> delegate) {
-      super(componentMonitorProvider, null);
+    DelegateProducer(ListenableFuture<T> delegate) {
       this.delegate = delegate;
     }
 
     @Override
     public ListenableFuture<T> compute() {
-      assertThat(monitor).isNotNull();
       return delegate;
     }
   }
diff --git a/javatests/dagger/producers/internal/AbstractProducesMethodProducerTest.java b/javatests/dagger/producers/internal/AbstractProducesMethodProducerTest.java
new file mode 100644
index 000000000..82258956d
--- /dev/null
+++ b/javatests/dagger/producers/internal/AbstractProducesMethodProducerTest.java
@@ -0,0 +1,147 @@
+/*
+ * Copyright (C) 2014 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.producers.internal;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.verifyNoMoreInteractions;
+import static org.mockito.Mockito.when;
+
+import com.google.common.util.concurrent.Futures;
+import com.google.common.util.concurrent.ListenableFuture;
+import com.google.common.util.concurrent.MoreExecutors;
+import com.google.common.util.concurrent.SettableFuture;
+import dagger.producers.Producer;
+import dagger.producers.monitoring.ProducerMonitor;
+import dagger.producers.monitoring.ProducerToken;
+import dagger.producers.monitoring.ProductionComponentMonitor;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.Executor;
+import javax.inject.Provider;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import org.mockito.Mock;
+import org.mockito.Mockito;
+import org.mockito.MockitoAnnotations;
+
+/**
+ * Tests {@link AbstractProducer}.
+ */
+@RunWith(JUnit4.class)
+public class AbstractProducesMethodProducerTest {
+  @Mock private ProductionComponentMonitor componentMonitor;
+  private ProducerMonitor monitor;
+  private Provider<ProductionComponentMonitor> componentMonitorProvider;
+
+  @Before
+  public void initMocks() {
+    MockitoAnnotations.initMocks(this);
+    monitor = Mockito.mock(ProducerMonitor.class, Mockito.CALLS_REAL_METHODS);
+    when(componentMonitor.producerMonitorFor(any(ProducerToken.class))).thenReturn(monitor);
+    componentMonitorProvider =
+        new Provider<ProductionComponentMonitor>() {
+          @Override
+          public ProductionComponentMonitor get() {
+            return componentMonitor;
+          }
+        };
+  }
+
+  @Test
+  public void monitor_success() throws Exception {
+    SettableFuture<Integer> delegateFuture = SettableFuture.create();
+    Producer<Integer> producer = new DelegateProducer<>(componentMonitorProvider, delegateFuture);
+
+    ListenableFuture<Integer> future = producer.get();
+    assertThat(future.isDone()).isFalse();
+    verify(monitor).ready();
+    verify(monitor).requested();
+    verify(monitor).addCallbackTo(anyListenableFuture());
+    verify(monitor).methodStarting();
+    verify(monitor).methodFinished();
+    delegateFuture.set(-42);
+    assertThat(future.get()).isEqualTo(-42);
+    verify(monitor).succeeded(-42);
+    verifyNoMoreInteractions(monitor);
+  }
+
+  @Test
+  public void monitor_failure() throws Exception {
+    SettableFuture<Integer> delegateFuture = SettableFuture.create();
+    Producer<Integer> producer = new DelegateProducer<>(componentMonitorProvider, delegateFuture);
+
+    ListenableFuture<Integer> future = producer.get();
+    assertThat(future.isDone()).isFalse();
+    verify(monitor).ready();
+    verify(monitor).requested();
+    verify(monitor).addCallbackTo(anyListenableFuture());
+    verify(monitor).methodStarting();
+    verify(monitor).methodFinished();
+    Throwable t = new RuntimeException("monkey");
+    delegateFuture.setException(t);
+    try {
+      future.get();
+      fail();
+    } catch (ExecutionException e) {
+      assertThat(e.getCause()).isSameAs(t);
+    }
+    verify(monitor).failed(t);
+    verifyNoMoreInteractions(monitor);
+  }
+
+  private ListenableFuture<?> anyListenableFuture() {
+    return any(ListenableFuture.class);
+  }
+
+  @Test(expected = NullPointerException.class)
+  public void monitor_null() throws Exception {
+    new DelegateProducer<>(null, Futures.immediateFuture(42));
+  }
+
+  static final class DelegateProducer<T> extends AbstractProducesMethodProducer<Void, T> {
+    private final ListenableFuture<T> delegate;
+
+    DelegateProducer(
+        Provider<ProductionComponentMonitor> componentMonitorProvider,
+        ListenableFuture<T> delegate) {
+      super(
+          componentMonitorProvider,
+          null, // token
+          new Provider<Executor>() {
+            @Override
+            public Executor get() {
+              return MoreExecutors.directExecutor();
+            }
+          });
+      this.delegate = delegate;
+    }
+
+    @Override
+    protected ListenableFuture<Void> collectDependencies() {
+      return Futures.immediateFuture(null);
+    }
+
+    @Override
+    protected ListenableFuture<T> callProducesMethod(Void asyncDependencies) {
+      return delegate;
+    }
+  }
+}
diff --git a/javatests/dagger/spi/BUILD b/javatests/dagger/spi/BUILD
index 5be82d7a5..a94461b07 100644
--- a/javatests/dagger/spi/BUILD
+++ b/javatests/dagger/spi/BUILD
@@ -34,11 +34,11 @@ GenJavaTests(
         "//java/dagger/internal/codegen:processor",
         "//java/dagger/model",
         "//java/dagger/spi",
-        "//third_party:auto_service",
-        "//third_party:compile_testing",
-        "//third_party:guava",
-        "//third_party:jsr330_inject",
-        "//third_party:junit",
-        "//third_party:truth",
+        "@google_bazel_common//third_party/java/auto:service",
+        "@google_bazel_common//third_party/java/compile_testing",
+        "@google_bazel_common//third_party/java/guava",
+        "@google_bazel_common//third_party/java/jsr330_inject",
+        "@google_bazel_common//third_party/java/junit",
+        "@google_bazel_common//third_party/java/truth",
     ],
 )
diff --git a/javatests/dagger/spi/FailingPlugin.java b/javatests/dagger/spi/FailingPlugin.java
index e8bd6a446..a8ccf5b2d 100644
--- a/javatests/dagger/spi/FailingPlugin.java
+++ b/javatests/dagger/spi/FailingPlugin.java
@@ -43,16 +43,13 @@ public void initOptions(Map<String, String> options) {
   public void visitGraph(BindingGraph bindingGraph, DiagnosticReporter diagnosticReporter) {
     if (options.containsKey("error_on_binding")) {
       String key = options.get("error_on_binding");
-      bindingGraph
-          .bindingNodes()
-          .stream()
-          .filter(node -> node.binding().key().toString().equals(key))
-          .forEach(node -> diagnosticReporter.reportBinding(ERROR, node, "Bad %s!", "Binding"));
+      bindingGraph.bindingNodes().stream()
+          .filter(node -> node.key().toString().equals(key))
+          .forEach(node -> diagnosticReporter.reportBinding(ERROR, node, "Bad Binding!"));
     }
 
     if (options.containsKey("error_on_component")) {
-      diagnosticReporter.reportComponent(
-          ERROR, bindingGraph.rootComponentNode(), "Bad %s!", "Component");
+      diagnosticReporter.reportComponent(ERROR, bindingGraph.rootComponentNode(), "Bad Component!");
     }
 
     if (options.containsKey("error_on_subcomponents")) {
@@ -65,9 +62,7 @@ public void visitGraph(BindingGraph bindingGraph, DiagnosticReporter diagnosticR
 
     if (options.containsKey("error_on_dependency")) {
       String dependency = options.get("error_on_dependency");
-      bindingGraph
-          .dependencyEdges()
-          .stream()
+      bindingGraph.dependencyEdges().stream()
           .filter(
               edge ->
                   edge.dependencyRequest()
@@ -75,8 +70,7 @@ public void visitGraph(BindingGraph bindingGraph, DiagnosticReporter diagnosticR
                       .get()
                       .getSimpleName()
                       .contentEquals(dependency))
-          .forEach(
-              edge -> diagnosticReporter.reportDependency(ERROR, edge, "Bad %s!", "Dependency"));
+          .forEach(edge -> diagnosticReporter.reportDependency(ERROR, edge, "Bad Dependency!"));
     }
   }
 
diff --git a/javatests/dagger/spi/SpiPluginTest.java b/javatests/dagger/spi/SpiPluginTest.java
index d9d479b38..fd4d9d9fe 100644
--- a/javatests/dagger/spi/SpiPluginTest.java
+++ b/javatests/dagger/spi/SpiPluginTest.java
@@ -63,12 +63,12 @@ public void dependencyTraceAtBinding() {
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining(
-            lines(
+            message(
                 "[FailingPlugin] Bad Binding!",
-                "      test.Foo is provided at",
-                "          test.TestComponent.foo()"))
+                "    test.Foo is provided at",
+                "        test.TestComponent.foo()"))
         .inFile(component)
-        .onLineContaining("Foo foo();");
+        .onLineContaining("interface TestComponent");
   }
 
   @Test
@@ -151,64 +151,49 @@ public void dependencyTraceAtDependencyRequest() {
 
     assertThat(compilationFactory.compilationWithErrorOnDependency("entryPoint"))
         .hadErrorContaining(
-            lines(
+            message(
                 "[FailingPlugin] Bad Dependency!",
-                "      test.EntryPoint is provided at",
-                "          test.TestComponent.entryPoint()"))
+                "    test.EntryPoint is provided at",
+                "        test.TestComponent.entryPoint()"))
         .inFile(component)
-        .onLineContaining("EntryPoint entryPoint();");
+        .onLineContaining("interface TestComponent");
     assertThat(compilationFactory.compilationWithErrorOnDependency("dup1"))
         .hadErrorContaining(
-            lines(
+            message(
                 "[FailingPlugin] Bad Dependency!",
-                "      test.Duplicated is injected at",
-                "          test.EntryPoint.<init>(…, dup1, …)",
-                "      test.EntryPoint is provided at",
-                "          test.TestComponent.entryPoint()"))
+                "    test.Duplicated is injected at",
+                "        test.EntryPoint.<init>(…, dup1, …)",
+                "    test.EntryPoint is provided at",
+                "        test.TestComponent.entryPoint()"))
         .inFile(component)
-        .onLineContaining("EntryPoint entryPoint();");
+        .onLineContaining("interface TestComponent");
     assertThat(compilationFactory.compilationWithErrorOnDependency("dup2"))
         .hadErrorContaining(
-            lines(
+            message(
                 "[FailingPlugin] Bad Dependency!",
-                "      test.Duplicated is injected at",
-                "          test.EntryPoint.<init>(…, dup2)",
-                "      test.EntryPoint is provided at",
-                "          test.TestComponent.entryPoint()"))
+                "    test.Duplicated is injected at",
+                "        test.EntryPoint.<init>(…, dup2)",
+                "    test.EntryPoint is provided at",
+                "        test.TestComponent.entryPoint()"))
         .inFile(component)
-        .onLineContaining("EntryPoint entryPoint();");
-    // Note that this compilation results in one error being reported twice since there are
-    // two entry points that depend on test.Foo
+        .onLineContaining("interface TestComponent");
+
     Compilation inFooDepCompilation =
         compilationFactory.compilationWithErrorOnDependency("inFooDep");
     assertThat(inFooDepCompilation)
         .hadErrorContaining(
-            lines(
+            message(
                 "[FailingPlugin] Bad Dependency!",
-                "      test.Duplicated is injected at",
-                "          test.Foo.<init>(inFooDep)",
-                "      test.Foo is injected at",
-                "          test.EntryPoint.<init>(foo, …)",
-                "      test.EntryPoint is provided at",
-                "          test.TestComponent.entryPoint()"))
+                "    test.Duplicated is injected at",
+                "        test.Foo.<init>(inFooDep)",
+                "    test.Foo is injected at",
+                "        test.EntryPoint.<init>(foo, …)",
+                "    test.EntryPoint is provided at",
+                "        test.TestComponent.entryPoint()",
+                "The following other entry points also depend on it:",
+                "    test.TestComponent.chain()"))
         .inFile(component)
-        .onLineContaining("EntryPoint entryPoint();");
-    assertThat(inFooDepCompilation)
-        .hadErrorContaining(
-            lines(
-                "[FailingPlugin] Bad Dependency!",
-                "      test.Duplicated is injected at",
-                "          test.Foo.<init>(inFooDep)",
-                "      test.Foo is injected at",
-                "          test.Chain3.<init>(foo)",
-                "      test.Chain3 is injected at",
-                "          test.Chain2.<init>(chain)",
-                "      test.Chain2 is injected at",
-                "          test.Chain1.<init>(chain)",
-                "      test.Chain1 is provided at",
-                "          test.TestComponent.chain()"))
-        .inFile(component)
-        .onLineContaining("Chain1 chain();");
+        .onLineContaining("interface TestComponent");
   }
 
   @Test
@@ -260,25 +245,26 @@ public void dependencyTraceAtDependencyRequest_subcomponents() {
         new CompilationFactory(component, subcomponent, foo, entryPoint);
     assertThat(compilationFactory.compilationWithErrorOnDependency("childEntryPoint"))
         .hadErrorContaining(
-            lines(
-                "[FailingPlugin] [test.TestSubcomponent.childEntryPoint()] Bad Dependency!",
-                "      test.EntryPoint is provided at",
-                "          test.TestSubcomponent.childEntryPoint()",
-                "  component path: test.TestComponent → test.TestSubcomponent"))
+            message(
+                "[FailingPlugin] Bad Dependency!",
+                "    test.EntryPoint is provided at",
+                "        test.TestSubcomponent.childEntryPoint()"
+                    + " [test.TestComponent → test.TestSubcomponent]"))
         .inFile(component)
         .onLineContaining("interface TestComponent");
     assertThat(compilationFactory.compilationWithErrorOnDependency("foo"))
         .hadErrorContaining(
-            lines(
-                "[FailingPlugin] [test.TestSubcomponent.childEntryPoint()] Bad Dependency!",
-                "      test.Foo is injected at",
-                "          test.EntryPoint.<init>(foo)",
-                "      test.EntryPoint is provided at",
-                "          test.TestSubcomponent.childEntryPoint()",
-                // TODO(ronshapiro): Maybe make the component path resemble a stack trace:
-                //     test.TestSubcomponent is a child of
-                //         test.TestComponent
-                "  component path: test.TestComponent → test.TestSubcomponent"))
+            // TODO(ronshapiro): Maybe make the component path resemble a stack trace:
+            //     test.TestSubcomponent is a child of
+            //         test.TestComponent
+            // TODO(dpb): Or invert the order: Child → Parent
+            message(
+                "[FailingPlugin] Bad Dependency!",
+                "    test.Foo is injected at",
+                "        test.EntryPoint.<init>(foo)",
+                "    test.EntryPoint is provided at",
+                "        test.TestSubcomponent.childEntryPoint() "
+                    + "[test.TestComponent → test.TestSubcomponent]"))
         .inFile(component)
         .onLineContaining("interface TestComponent");
   }
@@ -338,9 +324,7 @@ public void errorOnSubcomponent() {
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining(
-            lines(
-                "[FailingPlugin] Bad Subcomponent!",
-                "  component path: test.TestComponent → test.TestSubcomponent"))
+            "[FailingPlugin] Bad Subcomponent! [test.TestComponent → test.TestSubcomponent]")
         .inFile(component)
         .onLineContaining("interface TestComponent");
   }
@@ -446,27 +430,19 @@ public void shortestPathToBindingExistsThroughSubcomponentBuilder() {
                 subcomponentModule);
     assertThat(compilation)
         .hadErrorContaining(
-            lines(
+            message(
                 "[FailingPlugin] Bad Binding!",
-                "      test.ExposedOnSubcomponent is injected at",
-                "          test.Chain3.<init>(exposedOnSubcomponent)",
-                "      test.Chain3 is injected at",
-                "          test.Chain2.<init>(chain)",
-                "      test.Chain2 is injected at",
-                "          test.Chain1.<init>(chain)",
-                "      test.Chain1 is provided at",
-                "          test.TestComponent.chain()"))
-        .inFile(component)
-        .onLineContaining("Chain1 chain();");
-    assertThat(compilation)
-        .hadErrorContaining(
-            lines(
-                // TODO(ronshapiro): should this error be reported if it's already been reported at
-                // an ancestor component?
-                "[FailingPlugin] [test.TestSubcomponent.exposedOnSubcomponent()] Bad Binding!",
-                "      test.ExposedOnSubcomponent is provided at",
-                "          test.TestSubcomponent.exposedOnSubcomponent()",
-                "  component path: test.TestComponent → test.TestSubcomponent"))
+                "    test.ExposedOnSubcomponent is injected at",
+                "        test.Chain3.<init>(exposedOnSubcomponent)",
+                "    test.Chain3 is injected at",
+                "        test.Chain2.<init>(chain)",
+                "    test.Chain2 is injected at",
+                "        test.Chain1.<init>(chain)",
+                "    test.Chain1 is provided at",
+                "        test.TestComponent.chain()",
+                "The following other entry points also depend on it:",
+                "    test.TestSubcomponent.exposedOnSubcomponent() "
+                    + "[test.TestComponent → test.TestSubcomponent]"))
         .inFile(component)
         .onLineContaining("interface TestComponent");
   }
@@ -490,7 +466,7 @@ private Compilation compilationWithErrorOnDependency(String dependencySimpleName
     }
   }
 
-  private static String lines(String... lines) {
-    return Joiner.on('\n').join(lines);
+  private static String message(String... lines) {
+    return Joiner.on("\n  ").join(lines);
   }
 }
diff --git a/maven_sha1_test.py b/maven_sha1_test.py
deleted file mode 100644
index c999dfafa..000000000
--- a/maven_sha1_test.py
+++ /dev/null
@@ -1,42 +0,0 @@
-# Copyright (C) 2017 The Dagger Authors.
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-# http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-import ast
-import unittest
-
-class WorkspaceVisitor(ast.NodeVisitor):
-  def __init__(self):
-    self.missing_sha1 = []
-
-  def visit_Call(self, rule):
-    if rule.func.id == 'maven_jar':
-      name = None
-      for parameter in rule.keywords:
-        if parameter.arg == 'sha1':
-          return
-        if parameter.arg == 'name':
-          name = parameter.value.s
-      self.missing_sha1.append(name)
-
-class MavenSha1Test(unittest.TestCase):
-  def test_each_maven_jar_rule_has_sha1(self):
-    with open('WORKSPACE', 'r') as workspace:
-      visitor = WorkspaceVisitor()
-      visitor.visit(ast.parse(workspace.read()))
-      if len(visitor.missing_sha1) > 0:
-        missing = ', '.join(visitor.missing_sha1)
-        self.fail('%s did not specify a sha1' % missing)
-
-if __name__ == '__main__':
-  unittest.main()
diff --git a/merge_all_rules.txt b/merge_all_rules.txt
deleted file mode 100644
index 345c532e8..000000000
--- a/merge_all_rules.txt
+++ /dev/null
@@ -1 +0,0 @@
-# an empty rules file causes jarjar to merge all of the jar contents without any renaming
diff --git a/shade_rules.txt b/shade_rules.txt
deleted file mode 100644
index 968e53209..000000000
--- a/shade_rules.txt
+++ /dev/null
@@ -1 +0,0 @@
-rule com.google.auto.common.** dagger.shaded.auto.common.@1
diff --git a/test_defs.bzl b/test_defs.bzl
index ddffe1667..db13354e4 100644
--- a/test_defs.bzl
+++ b/test_defs.bzl
@@ -12,91 +12,171 @@
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
+
 # Defines a set of build variants and the list of extra javacopts to build with.
 # The key will be appended to the generated test names to ensure uniqueness.
 BUILD_VARIANTS = {
-    "ExperimentalAndroidMode": ["-Adagger.experimentalAndroidMode=enabled"],
+    "FastInit": ["-Adagger.fastInit=enabled"],
     "ExperimentalAndroidMode2": ["-Adagger.experimentalAndroidMode2=enabled"],
-    "ExperimentalAheadOfTimeComponents": ["-Adagger.experimentalAheadOfTimeComponents=enabled"],
-    "ExperimentalAndroidModeAndAheadOfTimeComponents": ["-Adagger.experimentalAndroidMode=enabled",
-                                                        "-Adagger.experimentalAheadOfTimeComponents=enabled"],
+    "ExperimentalAheadOfTimeSubcomponents": ["-Adagger.experimentalAheadOfTimeSubcomponents=enabled"],
+    "FastInitAndAheadOfTimeSubcomponents": [
+        "-Adagger.fastInit=enabled",
+        "-Adagger.experimentalAheadOfTimeSubcomponents=enabled",
+    ],
 }
 
+# TODO(ronshapiro): convert this to use bazel_common
 # TODO(user): split into two functions for functional vs non-functional tests?
-def GenJavaTests(name, srcs, deps, test_only_deps=None, plugins=None, javacopts=None,
-                 lib_javacopts=None, test_javacopts=None, functional=True):
-  _GenTests(native.java_library, native.java_test, name, srcs, deps, test_only_deps,
-            plugins, javacopts, lib_javacopts, test_javacopts, functional)
-
-def GenRobolectricTests(name, srcs, deps, test_only_deps=None, plugins=None, javacopts=None,
-                        lib_javacopts=None, test_javacopts=None):
-  # TODO(ronshapiro): enable these when Bazel supports robolectric tests
-  pass
+def GenJavaTests(
+        name,
+        srcs,
+        deps,
+        test_only_deps = None,
+        plugins = None,
+        javacopts = None,
+        lib_javacopts = None,
+        test_javacopts = None,
+        functional = True):
+    _GenTests(
+        native.java_library,
+        native.java_test,
+        name,
+        srcs,
+        deps,
+        test_only_deps,
+        plugins,
+        javacopts,
+        lib_javacopts,
+        test_javacopts,
+        functional,
+    )
 
-def _GenTests(library_rule_type, test_rule_type, name, srcs, deps, test_only_deps=None,
-              plugins=None, javacopts=None, lib_javacopts=None, test_javacopts=None,
-              functional=True):
-  _gen_tests(library_rule_type, test_rule_type, name, srcs, deps, test_only_deps,
-             plugins, javacopts, lib_javacopts, test_javacopts)
+def GenRobolectricTests(
+        name,
+        srcs,
+        deps,
+        test_only_deps = None,
+        plugins = None,
+        javacopts = None,
+        lib_javacopts = None,
+        test_javacopts = None,
+        manifest_values = None):
+    # TODO(ronshapiro): enable these with these instructions:
+    # https://docs.bazel.build/versions/master/be/android.html#android_local_test_examples
+    # We probably want to import all of Robolectric's dependencies into bazel-common because there
+    # are some differences (i.e. we both provide Guava).
+    pass
 
-  if functional:
-    for (variant_name, extra_javacopts) in BUILD_VARIANTS.items():
-      variant_javacopts = (javacopts or []) + extra_javacopts
-      _gen_tests(library_rule_type, test_rule_type, name, srcs, deps, test_only_deps,
-                 plugins, variant_javacopts, lib_javacopts, test_javacopts, variant_name)
+def _GenTests(
+        library_rule_type,
+        test_rule_type,
+        name,
+        srcs,
+        deps,
+        test_only_deps = None,
+        plugins = None,
+        javacopts = None,
+        lib_javacopts = None,
+        test_javacopts = None,
+        functional = True,
+        test_kwargs = {}):
+    _gen_tests(
+        library_rule_type,
+        test_rule_type,
+        name,
+        srcs,
+        deps,
+        test_only_deps,
+        plugins,
+        javacopts,
+        lib_javacopts,
+        test_javacopts,
+        test_kwargs = test_kwargs,
+    )
 
-def _gen_tests(library_rule_type, test_rule_type, name, srcs, deps, test_only_deps,
-               plugins, javacopts, lib_javacopts, test_javacopts, variant_name=None):
-  if variant_name:
-    suffix = "_" + variant_name
-    tags = [variant_name]
-    # Add jvm_flags so that the mode can be accessed from within tests.
-    jvm_flags = ["-Ddagger.mode=" + variant_name]
-  else:
-    suffix = ""
-    tags = []
-    jvm_flags = []
+    if functional:
+        for (variant_name, extra_javacopts) in BUILD_VARIANTS.items():
+            variant_javacopts = (javacopts or []) + extra_javacopts
+            _gen_tests(
+                library_rule_type,
+                test_rule_type,
+                name,
+                srcs,
+                deps,
+                test_only_deps,
+                plugins,
+                variant_javacopts,
+                lib_javacopts,
+                test_javacopts,
+                variant_name,
+                test_kwargs = test_kwargs,
+            )
 
-  test_files = []
-  supporting_files = []
+def _gen_tests(
+        library_rule_type,
+        test_rule_type,
+        name,
+        srcs,
+        deps,
+        test_only_deps,
+        plugins,
+        javacopts,
+        lib_javacopts,
+        test_javacopts,
+        variant_name = None,
+        test_kwargs = {}):
+    if variant_name:
+        suffix = "_" + variant_name
+        tags = [variant_name]
 
-  for src in srcs:
-    if src.endswith("Test.java"):
-      test_files.append(src)
+        # Add jvm_flags so that the mode can be accessed from within tests.
+        jvm_flags = ["-Ddagger.mode=" + variant_name]
     else:
-      supporting_files.append(src)
+        suffix = ""
+        tags = []
+        jvm_flags = []
 
-  if not test_only_deps:
-    test_only_deps = []
+    test_files = []
+    supporting_files = []
 
-  test_deps = test_only_deps + deps
-  if supporting_files:
-    supporting_files_name = name + suffix + "_lib"
-    test_deps.append(":" + supporting_files_name)
-    library_rule_type(
-        name = supporting_files_name,
-        deps = deps,
-        srcs = supporting_files,
-        plugins = plugins,
-        javacopts = (javacopts or []) + (lib_javacopts or []),
-        tags = tags,
-        testonly = 1,
-    )
+    for src in srcs:
+        if src.endswith("Test.java"):
+            test_files.append(src)
+        else:
+            supporting_files.append(src)
 
-  for test_file in test_files:
-    test_name = test_file.replace(".java", "")
-    prefix_path = "src/test/java/"
-    package_name = native.package_name()
-    if package_name.find("javatests/") != -1:
-      prefix_path = "javatests/"
-    test_class = (package_name + "/" + test_name).rpartition(prefix_path)[2].replace("/",".")
-    test_rule_type(
-        name = test_name + suffix,
-        deps = test_deps,
-        srcs = [test_file],
-        plugins = plugins,
-        javacopts = (javacopts or []) + (test_javacopts or []),
-        jvm_flags = jvm_flags,
-        tags = tags,
-        test_class = test_class,
-    )
+    if not test_only_deps:
+        test_only_deps = []
+
+    test_deps = test_only_deps + deps
+    if supporting_files:
+        supporting_files_name = name + suffix + "_lib"
+        test_deps.append(":" + supporting_files_name)
+        library_rule_type(
+            name = supporting_files_name,
+            testonly = 1,
+            srcs = supporting_files,
+            javacopts = (javacopts or []) + (lib_javacopts or []),
+            plugins = plugins,
+            tags = tags,
+            deps = deps,
+        )
+
+    for test_file in test_files:
+        test_name = test_file.replace(".java", "")
+        prefix_path = "src/test/java/"
+        package_name = native.package_name()
+        if package_name.find("javatests/") != -1:
+            prefix_path = "javatests/"
+        test_class = (package_name + "/" + test_name).rpartition(prefix_path)[2].replace("/", ".")
+        test_rule_type(
+            name = test_name + suffix,
+            srcs = [test_file],
+            javacopts = (javacopts or []) + (test_javacopts or []),
+            jvm_flags = jvm_flags,
+            plugins = plugins,
+            tags = tags,
+            test_class = test_class,
+            deps = test_deps,
+            **test_kwargs
+        )
diff --git a/third_party/BUILD b/third_party/BUILD
deleted file mode 100644
index 6178f5fd1..000000000
--- a/third_party/BUILD
+++ /dev/null
@@ -1,250 +0,0 @@
-# Copyright (C) 2017 The Dagger Authors.
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-# http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-package(default_visibility = ["//visibility:public"])
-
-java_library(
-    name = "jsr250_annotations",
-    exports = ["@javax_annotation_jsr250_api//jar"],
-)
-
-java_library(
-    name = "jsr305_annotations",
-    exports = ["@com_google_code_findbugs_jsr305//jar"],
-)
-
-java_library(
-    name = "jsr330_inject",
-    exports = ["@javax_inject_javax_inject//jar"],
-)
-
-java_library(
-    name = "jsr330_inject_tck",
-    exports = ["@javax_inject_javax_inject_tck//jar"],
-)
-
-java_library(
-    name = "error_prone_annotations",
-    tags = ["maven:compile_only"],
-    exports = ["@com_google_errorprone_error_prone_annotations//jar"],
-)
-
-java_library(
-    name = "junit",
-    testonly = 1,
-    exports = [
-        "@junit_junit//jar",
-        "@org_hamcrest_hamcrest_core//jar",
-    ],
-)
-
-java_library(
-    name = "truth",
-    testonly = 1,
-    exports = ["@com_google_truth_truth//jar"],
-)
-
-java_library(
-    name = "truth8",
-    testonly = 1,
-    exports = [
-        ":truth",
-        "@com_google_truth_extensions_truth_java8_extension//jar",
-    ],
-)
-
-java_library(
-    name = "guava",
-    exports = ["@com_google_guava_guava//jar"],
-)
-
-java_library(
-    name = "guava_testlib",
-    testonly = 1,
-    exports = ["@com_google_guava_guava_testlib//jar"],
-)
-
-java_library(
-    name = "auto_common",
-    tags = ["maven:shaded"],
-    exports = ["@com_google_auto_auto_common//jar"],
-)
-
-java_plugin(
-    name = "auto_value_processor",
-    processor_class = "com.google.auto.value.processor.AutoValueProcessor",
-    visibility = ["//visibility:private"],
-    deps = [
-        ":auto_common",
-        ":auto_service",
-        "//third_party:guava",
-        "@com_google_auto_value_auto_value//jar",
-    ],
-)
-
-java_plugin(
-    name = "auto_annotation_processor",
-    processor_class = "com.google.auto.value.processor.AutoAnnotationProcessor",
-    visibility = ["//visibility:private"],
-    deps = [
-        ":auto_common",
-        ":auto_service",
-        "//third_party:guava",
-        "@com_google_auto_value_auto_value//jar",
-    ],
-)
-
-java_library(
-    name = "auto_value",
-    exported_plugins = [
-        ":auto_value_processor",
-        ":auto_annotation_processor",
-    ],
-    tags = ["maven:compile_only"],
-    exports = [
-        ":jsr250_annotations",
-        "@com_google_auto_value_auto_value//jar",
-    ],
-)
-
-java_plugin(
-    name = "auto_factory_processor",
-    generates_api = 1,
-    processor_class = "com.google.auto.factory.processor.AutoFactoryProcessor",
-    visibility = ["//visibility:private"],
-    deps = [
-        ":auto_common",
-        ":auto_service",
-        ":javapoet",
-        "//third_party:guava",
-        "@com_google_auto_factory_auto_factory//jar",
-    ],
-)
-
-java_library(
-    name = "auto_factory",
-    exported_plugins = [":auto_factory_processor"],
-    exports = ["@com_google_auto_factory_auto_factory//jar"],
-)
-
-java_plugin(
-    name = "auto_service_processor",
-    processor_class = "com.google.auto.service.processor.AutoServiceProcessor",
-    visibility = ["//visibility:private"],
-    deps = [
-        ":auto_common",
-        "//third_party:guava",
-        "@com_google_auto_service_auto_service//jar",
-    ],
-)
-
-java_library(
-    name = "auto_service",
-    exported_plugins = [":auto_service_processor"],
-    tags = ["maven:compile_only"],
-    exports = ["@com_google_auto_service_auto_service//jar"],
-)
-
-java_library(
-    name = "google_java_format",
-    exports = [
-        "@com_google_googlejavaformat_google_java_format//jar",
-    ],
-    runtime_deps = [
-        ":guava",
-        "@com_google_errorprone_javac//jar",
-    ],
-)
-
-java_library(
-    name = "javapoet",
-    exports = ["@com_squareup_javapoet//jar"],
-)
-
-java_library(
-    name = "mockito",
-    testonly = 1,
-    exports = ["@org_mockito_mockito_core//jar"],
-    runtime_deps = [
-        "@org_hamcrest_hamcrest_core//jar",
-        "@org_objenesis_objenesis//jar",
-    ],
-)
-
-java_library(
-    name = "grpc",
-    exports = ["@io_grpc_grpc_all//jar"],
-)
-
-java_library(
-    name = "grpc_core",
-    exports = ["@io_grpc_grpc_core//jar"],
-)
-
-java_library(
-    name = "grpc_netty",
-    exports = ["@io_grpc_grpc_netty//jar"],
-)
-
-java_library(
-    name = "grpc_context",
-    exports = ["@io_grpc_grpc_context//jar"],
-)
-
-java_library(
-    name = "grpc_protobuf",
-    exports = ["@io_grpc_grpc_protobuf//jar"],
-)
-
-java_library(
-    name = "grpc_stub",
-    exports = ["@io_grpc_grpc_stub//jar"],
-)
-
-java_library(
-    name = "protobuf",
-    exports = ["@com_google_protobuf_protobuf_java//jar"],
-)
-
-java_library(
-    name = "compile_testing",
-    testonly = 1,
-    exports = [
-        "@com_google_testing_compile_compile_testing//jar",
-    ],
-    runtime_deps = [
-        ":auto_value",
-        ":jsr305_annotations",
-        "//third_party:error_prone_annotations",
-        "//third_party:guava",
-        "//third_party:junit",
-        "//third_party:truth",
-        "@local_jdk//:lib/tools.jar",
-    ],
-)
-
-java_library(
-    name = "checker_framework_annotations",
-    exports = ["@org_checkerframework_checker_compat_qual//jar"],
-)
-
-# A _deploy.jar consisting of the java_librarys in https://github.com/google/kythe needed to build a
-# Kythe plugin
-# TODO(ronshapiro): replace this with a http_archive of the next release in
-# https://github.com/google/kythe/releases
-java_import(
-    name = "kythe_plugin",
-    jars = ["kythe_plugin_deploy.jar"],
-    neverlink = 1,
-)
diff --git a/tools/BUILD b/tools/BUILD
index 6f1a53feb..dff2cde9c 100644
--- a/tools/BUILD
+++ b/tools/BUILD
@@ -17,49 +17,4 @@
 
 package(default_visibility = ["//:src"])
 
-sh_binary(
-    name = "jarjar_library_impl",
-    srcs = ["jarjar_library_impl.sh"],
-)
-
-sh_test(
-    name = "jarjar_library_impl_test",
-    srcs = ["jarjar_library_impl_test.sh"],
-    args = ["$(JAVABASE)"],
-    data = [
-        ":jarjar_deploy.jar",
-        ":jarjar_library_impl",
-        "//tools/testdata:bar",
-        "//tools/testdata:bar_with_dupe_file",
-        "//tools/testdata:foo",
-        "//tools/testdata:foo_with_dupe_file",
-        "@local_jdk//:bin/jar",
-        "@local_jdk//:bin/java",
-        "@local_jdk//:jre",
-    ],
-    toolchains = ["@bazel_tools//tools/jdk:current_java_runtime"],
-)
-
-java_binary(
-    name = "jarjar",
-    main_class = "org.pantsbuild.jarjar.Main",
-    runtime_deps = [
-        "@javax_annotation_jsr250_api//jar",
-        "@javax_enterprise_cdi_api//jar",
-        "@javax_inject_javax_inject//jar",
-        "@org_apache_ant_ant//jar",
-        "@org_apache_ant_ant_launcher//jar",
-        "@org_apache_maven_maven_artifact//jar",
-        "@org_apache_maven_maven_model//jar",
-        "@org_apache_maven_maven_plugin_api//jar",
-        "@org_codehaus_plexus_plexus_classworlds//jar",
-        "@org_codehaus_plexus_plexus_component_annotations//jar",
-        "@org_codehaus_plexus_plexus_utils//jar",
-        "@org_eclipse_sisu_org_eclipse_sisu_inject//jar",
-        "@org_eclipse_sisu_org_eclipse_sisu_plexus//jar",
-        "@org_ow2_asm_asm//jar",
-        "@org_ow2_asm_asm_commons//jar",
-        "@org_ow2_asm_asm_tree//jar",
-        "@org_pantsbuild_jarjar//jar",
-    ],
-)
+exports_files(["pom-template.xml"])
diff --git a/tools/bazel.rc b/tools/bazel.rc
index de078cce9..c930d8e25 100644
--- a/tools/bazel.rc
+++ b/tools/bazel.rc
@@ -1,2 +1,6 @@
 # Include debug info in the compiled jars
-build --javacopt=-g
\ No newline at end of file
+build --javacopt=-g
+
+# Disable The Guava Beta Checker.
+# TODO(ronshapiro): explore how much work it would be to reenable this
+build  --javacopt="-Xep:BetaApi:OFF"
diff --git a/tools/jarjar.bzl b/tools/jarjar.bzl
deleted file mode 100644
index baf9b5858..000000000
--- a/tools/jarjar.bzl
+++ /dev/null
@@ -1,141 +0,0 @@
-# Copyright (C) 2017 The Dagger Authors.
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-# http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-def jarjar_deps():
-  """
-  Deps that are necessary to build jarjar_binary() but aren't used in the regular build process for
-  Dagger, so they are organized separately from the workspace file.
-  """
-  native.maven_jar(
-      name = "org_codehaus_plexus_plexus_utils",
-      artifact = "org.codehaus.plexus:plexus-utils:3.0.20",
-      sha1 = "e121ed37af8ee3928952f6d8a303de24e019aab0",
-  )
-
-  native.maven_jar(
-      name = "org_eclipse_sisu_org_eclipse_sisu_plexus",
-      artifact = "org.eclipse.sisu:org.eclipse.sisu.plexus:0.3.0",
-      sha1 = "3f53953a998d03b9b0f7d5098f63119e434af0ef",
-  )
-
-  native.maven_jar(
-      name = "org_apache_ant_ant_launcher",
-      artifact = "org.apache.ant:ant-launcher:1.9.6",
-      sha1 = "d75dd4c39ba06401f20e7afffb861d268baec6bc",
-  )
-
-  native.maven_jar(
-      name = "org_apache_maven_maven_plugin_api",
-      artifact = "org.apache.maven:maven-plugin-api:3.3.3",
-      sha1 = "3b78a7e40707be313c4d5449ba514c9747e1c731",
-  )
-
-  native.maven_jar(
-      name = "org_eclipse_sisu_org_eclipse_sisu_inject",
-      artifact = "org.eclipse.sisu:org.eclipse.sisu.inject:0.3.0",
-      sha1 = "6c25adce9ca9af097728ed57834e8807e3b6e2b5",
-  )
-
-  native.maven_jar(
-      name = "org_ow2_asm_asm",
-      artifact = "org.ow2.asm:asm:5.0.4",
-      sha1 = "0da08b8cce7bbf903602a25a3a163ae252435795",
-  )
-
-  native.maven_jar(
-      name = "org_ow2_asm_asm_tree",
-      artifact = "org.ow2.asm:asm-tree:5.0.4",
-      sha1 = "396ce0c07ba2b481f25a70195c7c94922f0d1b0b",
-  )
-
-  native.maven_jar(
-      name = "javax_enterprise_cdi_api",
-      artifact = "javax.enterprise:cdi-api:1.0",
-      sha1 = "44c453f60909dfc223552ace63e05c694215156b",
-  )
-
-  native.maven_jar(
-      name = "org_ow2_asm_asm_commons",
-      artifact = "org.ow2.asm:asm-commons:5.0.4",
-      sha1 = "5a556786086c23cd689a0328f8519db93821c04c",
-  )
-
-  native.maven_jar(
-      name = "org_apache_maven_maven_model",
-      artifact = "org.apache.maven:maven-model:3.3.3",
-      sha1 = "73ba535c2e3a1381aeab131598010b3a723d4b47",
-  )
-
-  native.maven_jar(
-      name = "org_apache_maven_maven_artifact",
-      artifact = "org.apache.maven:maven-artifact:3.3.3",
-      sha1 = "d9f439dfef726e54eebb390ff38dd27356901528",
-  )
-
-  native.maven_jar(
-      name = "org_pantsbuild_jarjar",
-      artifact = "org.pantsbuild:jarjar:1.6.3",
-      sha1 = "cf54d4b142f5409c394095181c8d308a81869622",
-  )
-
-  native.maven_jar(
-      name = "org_codehaus_plexus_plexus_classworlds",
-      artifact = "org.codehaus.plexus:plexus-classworlds:2.5.2",
-      sha1 = "4abb111bfdace5b8167db4c0ef74644f3f88f142",
-  )
-
-  native.maven_jar(
-      name = "org_apache_ant_ant",
-      artifact = "org.apache.ant:ant:1.9.6",
-      sha1 = "80e2063b01bab3c79c2d84e4ed5e73868394c85a",
-  )
-
-  native.maven_jar(
-      name = "org_codehaus_plexus_plexus_component_annotations",
-      artifact = "org.codehaus.plexus:plexus-component-annotations:1.5.5",
-      sha1 = "c72f2660d0cbed24246ddb55d7fdc4f7374d2078",
-  )
-
-def jarjar_library(name, deps, rules_file):
-  """
-  Combines `deps` into one jar file named <name>.jar and jarjar with the rules specified in
-  `rules_file`.
-
-  See: https://github.com/pantsbuild/jarjar
-  """
-  native.genrule(
-      name = name,
-      srcs = deps + [
-          rules_file,
-          "//tools:jarjar_deploy.jar",
-      ],
-      tools = [
-          "//tools:jarjar_library_impl",
-          "@local_jdk//:bin/jar",
-          "@local_jdk//:bin/java",
-          "@local_jdk//:jre",
-      ],
-      outs = [name + ".jar"],
-      cmd = """
-      export JAVA_HOME=$(JAVABASE)
-      $(location //tools:jarjar_library_impl) $@ "{deps}" {rules} \
-        $(location //tools:jarjar_deploy.jar) \
-        $$(readlink $(location @local_jdk//:bin/jar)) \
-        $$(readlink $(location @local_jdk//:bin/java)) \
-        $(@D)
-      """.format(
-          deps=" ".join(["$(location %s)" % dep for dep in deps]),
-          rules="$(location %s)" % rules_file),
-      toolchains = ["@bazel_tools//tools/jdk:current_java_runtime"],
-  )
diff --git a/tools/jarjar_library_impl.sh b/tools/jarjar_library_impl.sh
deleted file mode 100755
index e576d08f6..000000000
--- a/tools/jarjar_library_impl.sh
+++ /dev/null
@@ -1,56 +0,0 @@
-#!/usr/bin/env bash
-
-# Copyright (C) 2017 The Dagger Authors.
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-# http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-if [[ ! $JAVA_HOME =~ ^/ ]]; then
-  JAVA_HOME=$(readlink -f $JAVA_HOME)
-fi
-
-OUT=$1
-DEPS=$2
-RULES_FILE=$3
-JARJAR=$4
-JAR_BINARY=$5
-JAVA_BINARY=$6
-TMPDIR=$7/combined
-
-mkdir -p $TMPDIR
-for dep in $DEPS; do
-  unzip -qq -B $dep -d $TMPDIR
-done
-pushd $TMPDIR &>/dev/null
-
-# Concatenate similar files in META-INF/services
-for file in META-INF/services/*; do
-  original=$(echo $file | sed s/"~[0-9]*$"//)
-  if [[ "$file" != "$original" ]]; then
-    cat $file >> $original
-    rm $file
-  fi
-done
-
-rm META-INF/MANIFEST.MF*
-rm -rf META-INF/maven/
-duplicate_files=$(find * -type f -regex ".*~[0-9]*$")
-if [[ -n "$duplicate_files" ]]; then
-  echo "Error: duplicate files in merged jar: $duplicate_files"
-  exit 1
-fi
-$JAR_BINARY cf combined.jar *
-
-popd &>/dev/null
-
-$JAVA_BINARY -jar $JARJAR process $RULES_FILE $TMPDIR/combined.jar $OUT
-rm -rf $TMPDIR
diff --git a/tools/jarjar_library_impl_test.sh b/tools/jarjar_library_impl_test.sh
deleted file mode 100755
index edc65d44c..000000000
--- a/tools/jarjar_library_impl_test.sh
+++ /dev/null
@@ -1,60 +0,0 @@
-#!/usr/bin/env bash
-
-# Copyright (C) 2017 The Dagger Authors.
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-# http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-
-export JAVA_HOME=$(readlink -f $1)
-
-set -eu
-
-JAR_BINARY="$(readlink external/local_jdk/bin/jar)"
-JAVA_BINARY="$(readlink external/local_jdk/bin/java)"
-
-report_bad_output() {
-  $JAR_BINARY tf output.jar
-  echo $1
-  exit 1
-}
-
-ROOT=$TEST_SRCDIR/$TEST_WORKSPACE
-
-cd $TEST_TMPDIR
-
-echo "rule foo.** baz.@1" > rules_file
-
-$ROOT/tools/jarjar_library_impl.sh \
-  "output.jar" \
-  "$ROOT/tools/testdata/libfoo.jar $ROOT/tools/testdata/libbar.jar" \
-  "rules_file" \
-  "$ROOT/tools/jarjar_deploy.jar" \
-  "$JAR_BINARY" \
-  "$JAVA_BINARY" \
-  "."
-if $JAR_BINARY  tf output.jar | grep -F -q foo/Foo.class; then
-  report_bad_output "Expected foo/Foo.class to be renamed to baz/Foo.class"
-elif ! $JAR_BINARY tf output.jar | grep -F -q baz/Foo.class; then
-  report_bad_output "Expected baz/Foo.class to be in the output jar"
-fi
-
-if $ROOT/tools/jarjar_library_impl.sh \
-  "output.jar" \
-  "$ROOT/tools/testdata/libfoo_with_dupe_file.jar $ROOT/tools/testdata/libbar_with_dupe_file.jar" \
-  "rules_file" \
-  "$ROOT/tools/jarjar_deploy.jar" \
-  "$JAR_BINARY" \
-  "$JAVA_BINARY" \
-  "."; then
-  report_bad_output 'Expected duplicate file "dupe"'
-fi
diff --git a/tools/javadoc.bzl b/tools/javadoc.bzl
deleted file mode 100644
index e9bc2b4e3..000000000
--- a/tools/javadoc.bzl
+++ /dev/null
@@ -1,120 +0,0 @@
-# Copyright (C) 2017 The Dagger Authors.
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-# http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-_EXTERNAL_JAVADOC_LINKS = [
-    "https://docs.oracle.com/javase/8/docs/api/",
-    "https://developer.android.com/reference/",
-    "https://google.github.io/guava/releases/23.3-jre/api/docs/",
-    "https://docs.oracle.com/javaee/7/api/",
-]
-
-def _check_non_empty(value, name):
-  if not value:
-    fail("%s must be non-empty" % name)
-
-def _android_jar(android_api_level):
-  if android_api_level == -1:
-    return None
-  return Label("@androidsdk//:platforms/android-%s/android.jar" % android_api_level)
-
-def _javadoc_library(ctx):
-  _check_non_empty(ctx.attr.root_packages, "root_packages")
-
-  inputs = []
-  for src_attr in ctx.attr.srcs:
-    inputs.extend(src_attr.files.to_list())
-
-  classpath = depset()
-  for dep in ctx.attr.deps:
-    for transitive_dep in dep.java.transitive_deps:
-      classpath += [transitive_dep]
-  if ctx.attr._android_jar:
-    classpath += ctx.attr._android_jar.files
-
-  inputs += classpath.to_list()
-
-  include_packages = " ".join(ctx.attr.root_packages)
-  javadoc_command = [
-      ctx.file._javadoc_binary.path,
-      '-sourcepath $(find * -type d -name "*java" -print0 | tr "\\0" :)',
-      include_packages,
-      "-use",
-      "-subpackages", include_packages,
-      "-encoding UTF8",
-      "-classpath", ":".join([jar.path for jar in classpath.to_list()]),
-      "-notimestamp",
-      '-bottom "Copyright &copy; 2012&ndash;2017 The Dagger Authors. All rights reserved."',
-      "-d tmp",
-      "-Xdoclint:-missing",
-      "-quiet",
-  ]
-
-  if ctx.attr.doctitle:
-    javadoc_command.append('-doctitle "%s"' % ctx.attr.doctitle)
-
-  if ctx.attr.exclude_packages:
-    javadoc_command.append("-exclude %s" % ":".join(ctx.attr.exclude_packages))
-
-  for link in _EXTERNAL_JAVADOC_LINKS:
-    javadoc_command.append("-linkoffline {0} {0}".format(link))
-
-  jar_command = "%s cf %s -C tmp ." % (ctx.file._jar_binary.path, ctx.outputs.jar.path)
-
-  ctx.action(
-      inputs = inputs + ctx.files._jdk,
-      command = "%s && %s" % (" ".join(javadoc_command), jar_command),
-      outputs = [ctx.outputs.jar])
-
-javadoc_library = rule(
-    attrs = {
-        "srcs": attr.label_list(allow_files = True),
-        "deps": attr.label_list(),
-        "doctitle": attr.string(default = ""),
-        "root_packages": attr.string_list(),
-        "exclude_packages": attr.string_list(),
-        "android_api_level": attr.int(default = -1),
-        "_android_jar": attr.label(
-            default = _android_jar,
-            allow_single_file = True,
-        ),
-        "_javadoc_binary": attr.label(
-            default = Label("@local_jdk//:bin/javadoc"),
-            allow_single_file = True,
-        ),
-        "_jar_binary": attr.label(
-            default = Label("@local_jdk//:bin/jar"),
-            allow_single_file = True,
-        ),
-        "_jdk": attr.label(
-            default = Label("@local_jdk//:jdk-default"),
-            allow_files = True,
-        ),
-    },
-    outputs = {"jar": "%{name}.jar"},
-    implementation = _javadoc_library,
-)
-"""
-Generates a Javadoc jar path/to/target/<name>.jar.
-
-Arguments:
-  srcs: source files to process
-  deps: targets that contain references to other types referenced in Javadoc. This can be the
-      java_library/android_library target(s) for the same sources
-  root_packages: Java packages to include in generated Javadoc. Any subpackages not listed in
-      exclude_packages will be included as well
-  exclude_packages: Java packages to exclude from generated Javadoc
-  android_api_level: If Android APIs are used, the API level to compile against to generate
-      Javadoc
-  doctitle: title for Javadoc's index.html. See javadoc -doctitle
-"""
diff --git a/tools/maven.bzl b/tools/maven.bzl
new file mode 100644
index 000000000..4a930489c
--- /dev/null
+++ b/tools/maven.bzl
@@ -0,0 +1,38 @@
+# Copyright (C) 2018 The Dagger Authors.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+"""Macros to simplify generating maven files.
+"""
+
+load("@google_bazel_common//tools/maven:pom_file.bzl", default_pom_file = "pom_file")
+
+def pom_file(name, targets, artifact_name, artifact_id, packaging = None, **kwargs):
+    default_pom_file(
+        name = name,
+        targets = targets,
+        preferred_group_ids = [
+            "com.google.dagger",
+            "com.google",
+        ],
+        template_file = "//tools:pom-template.xml",
+        substitutions = {
+            "{artifact_name}": artifact_name,
+            "{artifact_id}": artifact_id,
+            "{packaging}": packaging or "jar",
+        },
+        excluded_artifacts = ["com.google.auto:auto-common"],
+        **kwargs
+    )
+
+POM_VERSION = "${project.version}"
diff --git a/tools/pom-template.xml b/tools/pom-template.xml
new file mode 100644
index 000000000..39ed62d1d
--- /dev/null
+++ b/tools/pom-template.xml
@@ -0,0 +1,61 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+ Copyright (C) 2018 The Dagger Authors.
+
+  Licensed under the Apache License, Version 2.0 (the "License");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>org.sonatype.oss</groupId>
+    <artifactId>oss-parent</artifactId>
+    <version>7</version>
+  </parent>
+
+  <groupId>com.google.dagger</groupId>
+  <artifactId>{artifact_id}</artifactId>
+  <name>{artifact_name}</name>
+  <version>{pom_version}</version>
+  <description>A fast dependency injector for Android and Java.</description>
+  <url>https://github.com/google/dagger</url>
+  <packaging>{packaging}</packaging>
+
+  <scm>
+    <url>http://github.com/google/dagger/</url>
+    <connection>scm:git:git://github.com/google/dagger.git</connection>
+    <developerConnection>scm:git:ssh://git@github.com/google/dagger.git</developerConnection>
+    <tag>HEAD</tag>
+  </scm>
+
+  <issueManagement>
+    <system>GitHub Issues</system>
+    <url>http://github.com/google/dagger/issues</url>
+  </issueManagement>
+
+  <licenses>
+    <license>
+      <name>Apache 2.0</name>
+      <url>http://www.apache.org/licenses/LICENSE-2.0.txt</url>
+    </license>
+  </licenses>
+
+  <organization>
+    <name>Google, Inc.</name>
+    <url>http://www.google.com</url>
+  </organization>
+
+  <dependencies>
+{generated_bzl_deps}
+  </dependencies>
+</project>
diff --git a/tools/simple_jar.bzl b/tools/simple_jar.bzl
new file mode 100644
index 000000000..71b3f7b1e
--- /dev/null
+++ b/tools/simple_jar.bzl
@@ -0,0 +1,31 @@
+# Copyright (C) 2018 The Dagger Authors.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+"""Macro for creating a jar from a set of flat files"""
+
+def simple_jar(name, srcs):
+    """Creates a jar out of a set of flat files"""
+
+    # TODO(dpb): consider creating a Fileset() under the hood to support srcs from different
+    # directories
+    native.genrule(
+        name = name,
+        srcs = srcs,
+        outs = ["%s.jar" % name],
+        cmd = """
+        OUT="$$(pwd)/$@"
+        cd {package_name}
+        zip "$$OUT" -r * &> /dev/null
+        """.format(package_name = native.package_name()),
+    )
diff --git a/tools/testdata/BUILD b/tools/testdata/BUILD
deleted file mode 100644
index b994ff545..000000000
--- a/tools/testdata/BUILD
+++ /dev/null
@@ -1,44 +0,0 @@
-# Copyright (C) 2017 The Dagger Authors.
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-# http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-# Description:
-#   Tools for Dagger
-
-package(default_visibility = ["//:src"])
-
-java_library(
-    name = "foo",
-    srcs = ["Foo.java"],
-    deps = ["//third_party:auto_service"],
-)
-
-java_library(
-    name = "foo_with_dupe_file",
-    srcs = ["Foo.java"],
-    resources = ["dupe"],
-    deps = ["//third_party:auto_service"],
-)
-
-java_library(
-    name = "bar",
-    srcs = ["Bar.java"],
-    deps = ["//third_party:auto_service"],
-)
-
-java_library(
-    name = "bar_with_dupe_file",
-    srcs = ["Bar.java"],
-    resources = ["dupe"],
-    deps = ["//third_party:auto_service"],
-)
diff --git a/tools/testdata/dupe b/tools/testdata/dupe
deleted file mode 100644
index b68619fc0..000000000
--- a/tools/testdata/dupe
+++ /dev/null
@@ -1 +0,0 @@
-duped data file
diff --git a/util/deploy-to-maven-central.sh b/util/deploy-to-maven-central.sh
index 63471807f..87dff6aff 100755
--- a/util/deploy-to-maven-central.sh
+++ b/util/deploy-to-maven-central.sh
@@ -37,10 +37,6 @@ cd gh-pages
 unzip ../bazel-bin/user-docs.jar -d api/$version_name
 rm -rf api/$version_name/META-INF/
 git add api/$version_name
-sed -i -r \
-  s/"2\.[[:digit:]]+(-rc[[:digit:]]+)?"/"${version_name}"/g \
-  _layouts/default.html
-git add _layouts/default.html
 git commit -m "$version_name docs"
 git push origin gh-pages
 cd ..
@@ -50,5 +46,14 @@ for generated_pom_file in dagger*pom.xml; do
   rm "${generated_pom_file}.asc"
 done
 
+git checkout --detach
+# Set the version string that is used as a tag in all of our libraries. If another repo depends on
+# a versioned tag of Dagger, their java_library.tags should match the versioned release.
+sed -i s/'${project.version}'/"${version_name}"/g tools/maven.bzl
+git commit -m "${version_name} release" tools/maven.bzl
+
 git tag -a -m "Dagger ${version_name}" dagger-"${version_name}"
 git push origin tag dagger-"${version_name}"
+
+# Switch back to the original HEAD
+git checkout -
diff --git a/util/execute-deploy.sh b/util/execute-deploy.sh
index 82f2c1871..6908e97d1 100755
--- a/util/execute-deploy.sh
+++ b/util/execute-deploy.sh
@@ -1,4 +1,4 @@
-#!/bin/sh
+#!/bin/bash
 
 set -eu
 
@@ -7,46 +7,32 @@ readonly VERSION_NAME="$2"
 shift 2
 readonly EXTRA_MAVEN_ARGS=("$@")
 
-python $(dirname $0)/maven/generate_poms.py $VERSION_NAME \
-  //java/dagger:core \
-  //gwt:gwt \
-  //java/dagger/internal/codegen:processor \
-  //java/dagger/producers:producers \
-  //java/dagger/model:model \
-  //java/dagger/android:android \
-  //java/dagger/android:libandroid.jar \
-  //java/dagger/android/support:libsupport.jar \
-  //java/dagger/android/support:support \
-  //java/dagger/android/processor:processor \
-  //java/dagger/grpc/server:server \
-  //java/dagger/grpc/server:annotations \
-  //java/dagger/grpc/server/processor:processor
-
-library_output_file() {
-  library=$1
-  library_output=bazel-bin/$library
-  if [[ ! -e $library_output ]]; then
-     library_output=bazel-genfiles/$library
+bazel_output_file() {
+  local library=$1
+  local output_file=bazel-bin/$library
+  if [[ ! -e $output_file ]]; then
+     output_file=bazel-genfiles/$library
   fi
-  if [[ ! -e $library_output ]]; then
+  if [[ ! -e $output_file ]]; then
     echo "Could not find bazel output file for $library"
     exit 1
   fi
-  echo -n $library_output
+  echo -n $output_file
 }
 
 deploy_library() {
-  library=$1
-  srcjar=$2
-  javadoc=$3
-  pomfile=$4
-  bazel build $library $srcjar $javadoc
+  local library=$1
+  local srcjar=$2
+  local javadoc=$3
+  local pomfile=$4
+  bazel build --define=pom_version="$VERSION_NAME" \
+    $library $srcjar $javadoc $pomfile
 
   mvn $MVN_GOAL \
-    -Dfile=$(library_output_file $library) \
-    -Djavadoc=$(library_output_file $javadoc) \
-    -DpomFile=$pomfile \
-    -Dsources=$(library_output_file $srcjar) \
+    -Dfile=$(bazel_output_file $library) \
+    -Djavadoc=$(bazel_output_file $javadoc) \
+    -DpomFile=$(bazel_output_file $pomfile) \
+    -Dsources=$(bazel_output_file $srcjar) \
     "${EXTRA_MAVEN_ARGS[@]:+${EXTRA_MAVEN_ARGS[@]}}"
 }
 
@@ -54,78 +40,78 @@ deploy_library \
   java/dagger/libcore.jar \
   java/dagger/libcore-src.jar \
   java/dagger/core-javadoc.jar \
-  dagger.pom.xml
+  java/dagger/pom.xml
 
 deploy_library \
   gwt/libgwt.jar \
   gwt/libgwt.jar \
   gwt/libgwt.jar \
-  dagger-gwt.pom.xml
+  gwt/pom.xml
 
 deploy_library \
   shaded_compiler.jar \
   shaded_compiler_src.jar \
   java/dagger/internal/codegen/codegen-javadoc.jar \
-  dagger-compiler.pom.xml
+  java/dagger/internal/codegen/pom.xml
 
 deploy_library \
   java/dagger/producers/libproducers.jar \
   java/dagger/producers/libproducers-src.jar \
   java/dagger/producers/producers-javadoc.jar \
-  dagger-producers.pom.xml
+  java/dagger/producers/pom.xml
 
 deploy_library \
   shaded_spi.jar \
   shaded_spi_src.jar \
   spi-javadoc.jar \
-  dagger-spi.pom.xml
+  java/dagger/spi/pom.xml
 
 deploy_library \
   java/dagger/android/android.aar \
   java/dagger/android/libandroid-src.jar \
   java/dagger/android/android-javadoc.jar \
-  dagger-android.pom.xml
+  java/dagger/android/pom.xml
 
 # b/37741866 and https://github.com/google/dagger/issues/715
 deploy_library \
   java/dagger/android/libandroid.jar \
   java/dagger/android/libandroid-src.jar \
   java/dagger/android/android-javadoc.jar \
-  dagger-android-jarimpl.pom.xml
+  java/dagger/android/jarimpl-pom.xml
 
 deploy_library \
   java/dagger/android/support/support.aar \
   java/dagger/android/support/libsupport-src.jar \
   java/dagger/android/support/support-javadoc.jar \
-  dagger-android-support.pom.xml
+  java/dagger/android/support/pom.xml
 
 # b/37741866 and https://github.com/google/dagger/issues/715
 deploy_library \
   java/dagger/android/support/libsupport.jar \
   java/dagger/android/support/libsupport-src.jar \
   java/dagger/android/support/support-javadoc.jar \
-  dagger-android-support-jarimpl.pom.xml
+  java/dagger/android/support/jarimpl-pom.xml
 
 deploy_library \
   shaded_android_processor.jar \
   java/dagger/android/processor/libprocessor-src.jar \
   java/dagger/android/processor/processor-javadoc.jar \
-  dagger-android-processor.pom.xml
+  java/dagger/android/processor/pom.xml
 
 deploy_library \
   java/dagger/grpc/server/libserver.jar \
   java/dagger/grpc/server/libserver-src.jar \
   java/dagger/grpc/server/javadoc.jar \
-  dagger-grpc-server.pom.xml
+  java/dagger/grpc/server/server-pom.xml
 
 deploy_library \
   java/dagger/grpc/server/libannotations.jar \
   java/dagger/grpc/server/libannotations-src.jar \
   java/dagger/grpc/server/javadoc.jar \
-  dagger-grpc-server-annotations.pom.xml
+  java/dagger/grpc/server/annotations-pom.xml
 
 deploy_library \
   shaded_grpc_server_processor.jar \
   java/dagger/grpc/server/processor/libprocessor-src.jar \
   java/dagger/grpc/server/processor/javadoc.jar \
-  dagger-grpc-server-processor.pom.xml
+  java/dagger/grpc/server/processor/pom.xml
diff --git a/util/maven/__init__.py b/util/maven/__init__.py
deleted file mode 100644
index e69de29bb..000000000
diff --git a/util/maven/generate_poms.py b/util/maven/generate_poms.py
deleted file mode 100644
index ce902537e..000000000
--- a/util/maven/generate_poms.py
+++ /dev/null
@@ -1,175 +0,0 @@
-# Copyright (C) 2017 The Dagger Authors.
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-# http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-import os
-import re
-from subprocess import check_output
-import sys
-from workspace_parser import maven_artifacts
-from xml_formatting import generate_pom
-
-
-def _shell(command):
-  output = check_output(command,
-                        shell=True,
-                        stderr=open(os.devnull)).strip()
-  return output.splitlines()
-
-def deps_of(label):
-  return _shell(
-      """bazel query 'let deps = labels(deps, {0}) in $deps
-      except attr(tags, "maven:(compile_only|merged|shaded)", $deps)
-      '""".format(label))
-
-def exports_for(label):
-  return _shell('bazel query "labels(exports, %s)"' % label)
-
-def pom_deps(label):
-  accumulated_deps = set()
-  for dep in deps_of(label):
-    if dep.startswith("@local_jdk//:"): continue
-    if dep.startswith(('//:', '//third_party:')):
-      for export in exports_for(dep):
-        accumulated_deps.add(export)
-        accumulated_deps.update(pom_deps(export))
-    else:
-      accumulated_deps.add(dep)
-
-  return accumulated_deps
-
-
-GROUP = 'com.google.dagger'
-
-METADATA = {
-    '//java/dagger:core': {
-        'name': 'Dagger',
-        'artifact': 'dagger',
-    },
-    '//gwt:gwt': {
-        'name': 'Dagger GWT',
-        'artifact': 'dagger-gwt',
-        'manual_dependencies': [
-            'com.google.dagger:dagger:${project.version}',
-            'com.google.dagger:dagger:${project.version}:jar:sources',
-            'javax.inject:javax.inject:1:jar:sources',
-        ],
-    },
-    '//java/dagger/internal/codegen:processor': {
-        'name': 'Dagger Compiler',
-        'artifact': 'dagger-compiler',
-    },
-    '//java/dagger/producers:producers': {
-        'name': 'Dagger Producers',
-        'artifact': 'dagger-producers',
-    },
-    '//java/dagger/model:model': {
-        'name': 'Dagger SPI',
-        'artifact': 'dagger-spi',
-    },
-    '//java/dagger/spi:spi': {
-        'name': 'Dagger SPI',
-        'artifact': 'dagger-spi',
-    },
-    '//java/dagger/android:android': {
-        'name': 'Dagger Android',
-        'artifact': 'dagger-android',
-        'packaging': 'aar',
-    },
-    '//java/dagger/android/support:support': {
-        'name': 'Dagger Android Support',
-        'artifact': 'dagger-android-support',
-        'packaging': 'aar',
-    },
-    '//java/dagger/android/processor:processor': {
-        'name': 'Dagger Android Processor',
-        'artifact': 'dagger-android-processor',
-    },
-    '//java/dagger/grpc/server:server': {
-        'name': 'Dagger gRPC Server',
-        'artifact': 'dagger-grpc-server',
-    },
-    '//java/dagger/grpc/server:annotations': {
-        'name': 'Dagger gRPC Server annotations',
-        'artifact': 'dagger-grpc-server-annotations',
-    },
-    '//java/dagger/grpc/server/processor:processor': {
-        'name': 'Dagger gRPC Server processor',
-        'artifact': 'dagger-grpc-server-processor',
-    },
-    # b/37741866 and https://github.com/google/dagger/issues/715
-    '//java/dagger/android:libandroid.jar': {
-        'name': 'Dagger Android (Jar Impl)',
-        'artifact': 'dagger-android-jarimpl',
-    },
-    '//java/dagger/android/support:libsupport.jar': {
-        'name': 'Dagger Android Support (Jar Impl)',
-        'artifact': 'dagger-android-support-jarimpl',
-    },
-}
-
-def dependencies_comparator(first, second):
-  if first == second:
-    return 0
-
-  first = first.split(':')
-  second = second.split(':')
-
-  if first[0] == GROUP and second[0] != GROUP:
-    return -1
-  if second[0] == GROUP and first[0] != GROUP:
-    return 1
-
-  # Compare each item in the list: first sort by group, then artifact
-  if first < second:
-    return -1
-  else:
-    return 1
-
-class UnknownDependencyException(Exception): pass
-
-
-def main():
-  if len(sys.argv) < 3:
-    print 'Usage: %s <version> <target_for_pom>...' % sys.argv[0]
-    sys.exit(1)
-
-  version = sys.argv[1]
-  artifacts = maven_artifacts()
-
-  android_sdk_pattern = re.compile(
-      r'@androidsdk//([a-z.-]*):([a-z0-9-]*)-([0-9.]*)')
-
-  for label, metadata in METADATA.iteritems():
-    artifacts[label] = (
-        'com.google.dagger:%s:%s' % (metadata['artifact'], version)
-    )
-
-  def artifact_for_dep(label):
-    if label in artifacts:
-      return artifacts[label]
-    match = android_sdk_pattern.match(label)
-    if match:
-      return ':'.join(match.groups())
-    raise UnknownDependencyException('No artifact found for %s' % label)
-
-  for arg in sys.argv[2:]:
-    metadata = METADATA[arg]
-    with open('%s.pom.xml' % metadata['artifact'], 'w') as pom_file:
-      deps = map(artifact_for_dep, pom_deps(arg))
-      deps = list(set(deps)) # remove duplicates
-      deps.sort(cmp=dependencies_comparator)
-      pom_file.write(generate_pom(artifacts[arg], metadata, deps, version))
-
-if __name__ == '__main__':
-  main()
diff --git a/util/maven/workspace_parser.py b/util/maven/workspace_parser.py
deleted file mode 100644
index 47e24483a..000000000
--- a/util/maven/workspace_parser.py
+++ /dev/null
@@ -1,37 +0,0 @@
-# Copyright (C) 2017 The Dagger Authors.
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-# http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-import ast
-
-class WorkspaceVisitor(ast.NodeVisitor):
-  def __init__(self):
-    self.artifacts = {}
-
-  def visit_Call(self, rule):
-    if rule.func.id is not 'maven_jar': return
-    name = None
-    artifact = None
-    for keyword in rule.keywords:
-      if keyword.arg == 'name':
-        name = keyword.value.s
-      if keyword.arg == 'artifact':
-        artifact = keyword.value.s
-    self.artifacts['@%s//jar:jar' % name] = artifact
-
-def maven_artifacts():
-  visitor = WorkspaceVisitor()
-  with open('WORKSPACE', 'r') as workspace:
-    visitor.visit(ast.parse(workspace.read()))
-
-  return visitor.artifacts
diff --git a/util/maven/xml_formatting.py b/util/maven/xml_formatting.py
deleted file mode 100644
index 4e8cbb717..000000000
--- a/util/maven/xml_formatting.py
+++ /dev/null
@@ -1,118 +0,0 @@
-# Copyright (C) 2017 The Dagger Authors.
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-# http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-import textwrap
-
-DEP_BLOCK = """
-<dependency>
-  <groupId>%s</groupId>
-  <artifactId>%s</artifactId>
-  <version>%s</version>
-</dependency>
-""".strip()
-
-CLASSIFIER_DEP_BLOCK = """
-<dependency>
-  <groupId>%s</groupId>
-  <artifactId>%s</artifactId>
-  <version>%s</version>
-  <type>%s</type>
-  <classifier>%s</classifier>
-</dependency>
-""".strip()
-
-
-def maven_dependency_xml(artifact_string):
-  if artifact_string.count(':') is 2:
-    format_string = DEP_BLOCK
-  else:
-    format_string = CLASSIFIER_DEP_BLOCK
-  formatted = format_string % tuple(artifact_string.split(':'))
-  return '\n'.join(['    %s' %x for x in formatted.split('\n')])
-
-POM_OUTLINE = """<?xml version="1.0" encoding="UTF-8"?>
-<!--
- Copyright (C) 2012 The Dagger Authors.
-
-  Licensed under the Apache License, Version 2.0 (the "License");
-  you may not use this file except in compliance with the License.
-  You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-  Unless required by applicable law or agreed to in writing, software
-  distributed under the License is distributed on an "AS IS" BASIS,
-  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-  See the License for the specific language governing permissions and
-  limitations under the License.
--->
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-
-  <parent>
-    <groupId>org.sonatype.oss</groupId>
-    <artifactId>oss-parent</artifactId>
-    <version>7</version>
-  </parent>
-
-  <groupId>{group}</groupId>
-  <artifactId>{artifact}</artifactId>
-  <name>{name}</name>
-  <version>{version}</version>
-  <description>A fast dependency injector for Android and Java.</description>
-  <url>https://github.com/google/dagger</url>
-  <packaging>{packaging}</packaging>
-
-  <scm>
-    <url>http://github.com/google/dagger/</url>
-    <connection>scm:git:git://github.com/google/dagger.git</connection>
-    <developerConnection>scm:git:ssh://git@github.com/google/dagger.git</developerConnection>
-    <tag>HEAD</tag>
-  </scm>
-
-  <issueManagement>
-    <system>GitHub Issues</system>
-    <url>http://github.com/google/dagger/issues</url>
-  </issueManagement>
-
-  <licenses>
-    <license>
-      <name>Apache 2.0</name>
-      <url>http://www.apache.org/licenses/LICENSE-2.0.txt</url>
-    </license>
-  </licenses>
-
-  <organization>
-    <name>Google, Inc.</name>
-    <url>http://www.google.com</url>
-  </organization>
-
-  <dependencies>
-{deps}
-  </dependencies>
-</project>
-"""
-
-def generate_pom(artifact_string, metadata, deps, version):
-  group, artifact, version = artifact_string.split(':')
-
-  deps = deps + metadata.get('manual_dependencies', [])
-
-  return POM_OUTLINE.format(
-      group=group,
-      artifact=artifact,
-      name=metadata['name'],
-      version=version,
-      packaging=metadata.get('packaging', 'jar'),
-      deps='\n'.join(map(maven_dependency_xml, deps)))
