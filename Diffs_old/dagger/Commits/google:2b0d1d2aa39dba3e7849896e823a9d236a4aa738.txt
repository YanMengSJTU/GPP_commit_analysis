diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/ClassWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/ClassWriter.java
index 841ee1ed7..eb3d1d352 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/ClassWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/ClassWriter.java
@@ -15,9 +15,13 @@
  */
 package dagger.internal.codegen.writer;
 
+import static javax.lang.model.element.Modifier.PRIVATE;
+import static javax.lang.model.element.Modifier.PROTECTED;
+import static javax.lang.model.element.Modifier.PUBLIC;
+
 import com.google.common.base.Function;
-import com.google.common.base.Joiner;
 import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Lists;
 import com.google.common.collect.Sets;
@@ -27,18 +31,14 @@
 import java.util.Set;
 import javax.lang.model.element.Modifier;
 
-import static javax.lang.model.element.Modifier.PRIVATE;
-import static javax.lang.model.element.Modifier.PROTECTED;
-import static javax.lang.model.element.Modifier.PUBLIC;
-
 public final class ClassWriter extends TypeWriter {
   private final List<ConstructorWriter> constructorWriters;
-  private final List<TypeVariableName> typeVariables;
+  private final List<TypeVariableName> typeParameters;
 
   ClassWriter(ClassName className) {
     super(className);
     this.constructorWriters = Lists.newArrayList();
-    this.typeVariables = Lists.newArrayList();
+    this.typeParameters = Lists.newArrayList();
   }
 
   public ConstructorWriter addConstructor() {
@@ -46,6 +46,18 @@ public ConstructorWriter addConstructor() {
     constructorWriters.add(constructorWriter);
     return constructorWriter;
   }
+  
+  public void addTypeParameter(TypeVariableName typeVariableName) {
+    this.typeParameters.add(typeVariableName);
+  }
+  
+  public void addTypeParameters(Iterable<TypeVariableName> typeVariableNames) {
+    Iterables.addAll(typeParameters, typeVariableNames);
+  }
+  
+  public List<TypeVariableName> typeParameters() {
+    return ImmutableList.copyOf(typeParameters);
+  }
 
   @Override
   public Appendable write(Appendable appendable, Context context) throws IOException {
@@ -58,24 +70,12 @@ public Appendable write(Appendable appendable, Context context) throws IOExcepti
         .toSet());
     writeAnnotations(appendable, context);
     writeModifiers(appendable).append("class ").append(name.simpleName());
-    if (!typeVariables.isEmpty()) {
-      appendable.append('<');
-      Joiner.on(", ").appendTo(appendable, typeVariables);
-      appendable.append('>');
-    }
+    Writables.join(", ", typeParameters, "<", ">", appendable, context);
     if (supertype.isPresent()) {
       appendable.append(" extends ");
       supertype.get().write(appendable, context);
     }
-    Iterator<TypeName> implementedTypesIterator = implementedTypes.iterator();
-    if (implementedTypesIterator.hasNext()) {
-      appendable.append(" implements ");
-      implementedTypesIterator.next().write(appendable, context);
-      while (implementedTypesIterator.hasNext()) {
-        appendable.append(", ");
-        implementedTypesIterator.next().write(appendable, context);
-      }
-    }
+    Writables.join(", ", implementedTypes, " implements ", "", appendable, context);
     appendable.append(" {");
     if (!fieldWriters.isEmpty()) {
       appendable.append('\n');
@@ -115,7 +115,7 @@ private boolean isDefaultConstructor(ConstructorWriter constructorWriter) {
     @SuppressWarnings("unchecked")
     Iterable<? extends HasClassReferences> concat =
         Iterables.concat(nestedTypeWriters, fieldWriters.values(), constructorWriters,
-            methodWriters, implementedTypes, supertype.asSet(), annotations);
+            methodWriters, implementedTypes, supertype.asSet(), annotations, typeParameters);
     return FluentIterable.from(concat)
         .transformAndConcat(new Function<HasClassReferences, Set<ClassName>>() {
           @Override
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/ConstructorWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/ConstructorWriter.java
index 8e1c6987a..f1fa015bc 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/ConstructorWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/ConstructorWriter.java
@@ -15,6 +15,8 @@
  */
 package dagger.internal.codegen.writer;
 
+import com.google.common.collect.ImmutableMap;
+
 import com.google.common.base.Function;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
@@ -25,7 +27,6 @@
 import java.util.Map;
 import java.util.Set;
 import javax.lang.model.element.TypeElement;
-
 import static com.google.common.base.Preconditions.checkArgument;
 
 public final class ConstructorWriter extends Modifiable implements Writable, HasClassReferences {
@@ -56,6 +57,14 @@ public VariableWriter addParameter(TypeName type, String name) {
     parameterWriters.put(name, parameterWriter);
     return parameterWriter;
   }
+  
+  public Map<String, TypeName> parameters() {
+    ImmutableMap.Builder<String, TypeName> params = ImmutableMap.builder();
+    for (Map.Entry<String, VariableWriter> entry : parameterWriters.entrySet()) {
+      params.put(entry.getKey(), entry.getValue().type());
+    }
+    return params.build();
+  }
 
   public BlockWriter body() {
     return blockWriter;
@@ -84,14 +93,7 @@ private VariableWriter addParameter(ClassName type, String name) {
   @Override
   public Appendable write(Appendable appendable, Context context) throws IOException {
     writeModifiers(appendable).append(name).append('(');
-    Iterator<VariableWriter> parameterWritersIterator = parameterWriters.values().iterator();
-    if (parameterWritersIterator.hasNext()) {
-      parameterWritersIterator.next().write(appendable, context);
-    }
-    while (parameterWritersIterator.hasNext()) {
-      appendable.append(", ");
-      parameterWritersIterator.next().write(appendable, context);
-    }
+    Writables.join(", ", parameterWriters.values(), appendable, context);
     appendable.append(") {");
     blockWriter.write(new IndentingAppendable(appendable), context);
     return appendable.append("}\n");
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/MethodWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/MethodWriter.java
index 5ef8eabfc..86c24b363 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/MethodWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/MethodWriter.java
@@ -20,9 +20,11 @@
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Iterables;
+import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
 import java.io.IOException;
 import java.util.Iterator;
+import java.util.List;
 import java.util.Map;
 import java.util.Set;
 import javax.lang.model.element.TypeElement;
@@ -33,18 +35,28 @@
   private final TypeName returnType;
   private final String name;
   private final Map<String, VariableWriter> parameterWriters;
+  private final List<TypeVariableName> typeParameters;
   private Optional<BlockWriter> body;
 
   MethodWriter(TypeName returnType, String name) {
     this.returnType = returnType;
     this.name = name;
     this.parameterWriters = Maps.newLinkedHashMap();
+    this.typeParameters = Lists.newArrayList();
     this.body = Optional.absent();
   }
 
   public String name() {
     return name;
   }
+  
+  public void addTypeParameter(TypeVariableName typeVariableName) {
+    this.typeParameters.add(typeVariableName);
+  }
+  
+  public void addTypeParameters(Iterable<TypeVariableName> typeVariableNames) {
+    Iterables.addAll(typeParameters, typeVariableNames);
+  }
 
   public VariableWriter addParameter(Class<?> type, String name) {
     return addParameter(ClassName.fromClass(type), name);
@@ -79,16 +91,10 @@ public BlockWriter body() {
   public Appendable write(Appendable appendable, Context context) throws IOException {
     writeAnnotations(appendable, context);
     writeModifiers(appendable);
+    Writables.join(", ", typeParameters, "<", "> ", appendable, context);
     returnType.write(appendable, context);
     appendable.append(' ').append(name).append('(');
-    Iterator<VariableWriter> parameterWritersIterator = parameterWriters.values().iterator();
-    if (parameterWritersIterator.hasNext()) {
-      parameterWritersIterator.next().write(appendable, context);
-    }
-    while (parameterWritersIterator.hasNext()) {
-      appendable.append(", ");
-      parameterWritersIterator.next().write(appendable, context);
-    }
+    Writables.join(", ", parameterWriters.values(), appendable, context);
     appendable.append(")");
     if (body.isPresent()) {
       appendable.append(" {");
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/ParameterizedTypeName.java b/compiler/src/main/java/dagger/internal/codegen/writer/ParameterizedTypeName.java
index 7e816165d..63cf3dd95 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/ParameterizedTypeName.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/ParameterizedTypeName.java
@@ -27,12 +27,20 @@
 
 public final class ParameterizedTypeName implements TypeName {
   private final ClassName type;
-  private final ImmutableList<? extends TypeName> parameters;
+  private final ImmutableList<TypeName> parameters;
 
   ParameterizedTypeName(ClassName type, Iterable<? extends TypeName> parameters) {
     this.type = type;
     this.parameters = ImmutableList.copyOf(parameters);
   }
+  
+  public ClassName type() {
+    return type;
+  }
+  
+  public ImmutableList<TypeName> parameters() {
+    return parameters;
+  }
 
   @Override
   public Set<ClassName> referencedClasses() {
@@ -85,6 +93,11 @@ public static ParameterizedTypeName create(ClassName className,
     return new ParameterizedTypeName(className, ImmutableList.copyOf(parameters));
   }
 
+  public static ParameterizedTypeName create(ClassName className,
+      Iterable<? extends TypeName> parameters) {
+    return new ParameterizedTypeName(className, ImmutableList.copyOf(parameters));
+  }
+
   public static ParameterizedTypeName create(Class<?> parameterizedClass,
       TypeName... parameters) {
     checkArgument(parameterizedClass.getTypeParameters().length == parameters.length);
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/TypeNames.java b/compiler/src/main/java/dagger/internal/codegen/writer/TypeNames.java
index b97b06fe2..4bc234739 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/TypeNames.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/TypeNames.java
@@ -24,6 +24,7 @@
 import javax.lang.model.type.NullType;
 import javax.lang.model.type.PrimitiveType;
 import javax.lang.model.type.TypeMirror;
+import javax.lang.model.type.TypeVariable;
 import javax.lang.model.type.WildcardType;
 import javax.lang.model.util.SimpleTypeVisitor6;
 
@@ -53,6 +54,11 @@ public static TypeName forTypeMirror(TypeMirror mirror) {
       protected TypeName defaultAction(TypeMirror e, Void p) {
         throw new IllegalArgumentException(e.toString());
       }
+      
+      @Override
+      public TypeName visitTypeVariable(TypeVariable t, Void p) {
+        return TypeVariableName.fromTypeVariable(t);
+      }
 
       @Override
       public ArrayTypeName visitArray(ArrayType t, Void p) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/TypeVariableName.java b/compiler/src/main/java/dagger/internal/codegen/writer/TypeVariableName.java
index 4d46167d5..e7b13cefb 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/TypeVariableName.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/TypeVariableName.java
@@ -15,34 +15,39 @@
  */
 package dagger.internal.codegen.writer;
 
-import com.google.common.base.Optional;
+import com.google.common.base.Objects;
+
+import com.google.auto.common.MoreTypes;
+import com.google.common.base.Predicate;
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Iterables;
 import java.io.IOException;
+import java.util.Iterator;
 import java.util.Set;
+import javax.lang.model.element.TypeParameterElement;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.type.TypeVariable;
 
 public final class TypeVariableName implements TypeName {
-  private final String name;
-  private final Optional<TypeName> extendsBound;
-  private final Optional<TypeName> superBound;
-  TypeVariableName(String name, Optional<TypeName> extendsBound,
-      Optional<TypeName> superBound) {
+  private final CharSequence name;
+  private final Iterable<? extends TypeName> extendsBounds;
+
+  TypeVariableName(CharSequence name, Iterable<? extends TypeName> extendsBounds) {
     this.name = name;
-    this.extendsBound = extendsBound;
-    this.superBound = superBound;
+    this.extendsBounds = extendsBounds;
   }
 
-  public String name() {
+  public CharSequence name() {
     return name;
   }
 
   @Override
   public Set<ClassName> referencedClasses() {
     ImmutableSet.Builder<ClassName> builder = new ImmutableSet.Builder<ClassName>();
-    if (extendsBound.isPresent()) {
-      builder.addAll(extendsBound.get().referencedClasses());
-    }
-    if (superBound.isPresent()) {
-      builder.addAll(superBound.get().referencedClasses());
+    for (TypeName bound : extendsBounds) {
+      builder.addAll(bound.referencedClasses());
     }
     return builder.build();
   }
@@ -50,13 +55,14 @@ public String name() {
   @Override
   public Appendable write(Appendable appendable, Context context) throws IOException {
     appendable.append(name);
-    if (extendsBound.isPresent()) {
-      appendable.append(' ');
-      extendsBound.get().write(appendable, context);
-    }
-    if (superBound.isPresent()) {
-      appendable.append(' ');
-      superBound.get().write(appendable, context);
+    if (!Iterables.isEmpty(extendsBounds)) {
+      appendable.append(" extends ");
+      Iterator<? extends TypeName> iter = extendsBounds.iterator();
+      iter.next().write(appendable, context);
+      while (iter.hasNext()) {
+        appendable.append(" & ");
+        iter.next().write(appendable, context);  
+      }
     }
     return appendable;
   }
@@ -66,8 +72,45 @@ public String toString() {
     return Writables.writeToString(this);
   }
 
-  static TypeVariableName named(String name) {
-    return new TypeVariableName(
-        name, Optional.<TypeName>absent(), Optional.<TypeName>absent());
+  @Override
+  public boolean equals(Object obj) {
+    if (obj instanceof TypeVariableName) {
+      TypeVariableName that = (TypeVariableName) obj;
+      return this.name.toString().equals(that.name.toString())
+          && this.extendsBounds.equals(that.extendsBounds);
+    } else {
+      return false;
+    }
+  }
+
+  @Override
+  public int hashCode() {
+    return Objects.hashCode(name, extendsBounds);
+  }
+
+  static TypeVariableName named(CharSequence name) {
+    return new TypeVariableName(name, ImmutableList.<TypeName>of());
+  }
+  
+  public static TypeVariableName fromTypeVariable(TypeVariable variable) {
+    // Note: We don't have any use right now for the bounds because these are references
+    // to the type & not the specification of the type itself.  We never generate
+    // code with type variables that include upper or lower bounds.
+    return named(variable.asElement().getSimpleName());
+  }
+
+  // TODO(sameb): Consider making this a whole different thing: TypeParameterName since it
+  // has different semantics than a TypeVariable (parameters only have upper bounds).
+  public static TypeVariableName fromTypeParameterElement(TypeParameterElement element) {
+    // We filter out bounds of type Object because those would just clutter the generated code.
+    Iterable<? extends TypeName> bounds =
+        FluentIterable.from(element.getBounds())
+            .filter(new Predicate<TypeMirror>() {
+              @Override public boolean apply(TypeMirror input) {
+                return !MoreTypes.isType(input) || !MoreTypes.isTypeOf(Object.class, input);
+              }
+            })
+            .transform(TypeNames.FOR_TYPE_MIRROR);
+    return new TypeVariableName(element.getSimpleName(), bounds);
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/Writables.java b/compiler/src/main/java/dagger/internal/codegen/writer/Writables.java
index 86999cc83..0186cbfcf 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/Writables.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/Writables.java
@@ -17,9 +17,36 @@
 
 import dagger.internal.codegen.writer.Writable.Context;
 import java.io.IOException;
+import java.util.Iterator;
 import java.util.Set;
 
 final class Writables {
+
+  /**
+   * Joins the writables by the given delimiter, writing out the
+   * prefix & suffix if there's at least one element.
+   */
+  static void join(String delimiter, Iterable<? extends Writable> writables,
+      String prefix, String suffix,
+      Appendable appendable, Context context) throws IOException {
+    Iterator<? extends Writable> iter = writables.iterator();
+    if (iter.hasNext()) {
+      appendable.append(prefix);
+      iter.next().write(appendable, context);
+      while (iter.hasNext()) {
+        appendable.append(delimiter);
+        iter.next().write(appendable, context);
+      }
+      appendable.append(suffix);
+    }
+  }
+
+  /** Joins the writables by the given delimiter. */
+  static void join(String delimiter, Iterable<? extends Writable> writables,
+      Appendable appendable, Context context) throws IOException {
+    join(delimiter, writables, "", "", appendable, context);
+  }
+
   static Writable toStringWritable(final Object object) {
     return new Writable() {
       @Override
diff --git a/compiler/src/test/java/dagger/internal/codegen/writer/TypeNamesTest.java b/compiler/src/test/java/dagger/internal/codegen/writer/TypeNamesTest.java
index 39f40bff2..a38e61e51 100644
--- a/compiler/src/test/java/dagger/internal/codegen/writer/TypeNamesTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/writer/TypeNamesTest.java
@@ -15,6 +15,8 @@
  */
 package dagger.internal.codegen.writer;
 
+import static com.google.common.truth.Truth.assertThat;
+
 import com.google.testing.compile.CompilationRule;
 import java.nio.charset.Charset;
 import java.util.Set;
@@ -27,8 +29,6 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import static com.google.common.truth.Truth.assert_;
-
 @RunWith(JUnit4.class)
 public class TypeNamesTest {
   @Rule public final CompilationRule compilation = new CompilationRule();
@@ -43,11 +43,11 @@ private TypeMirror getType(Class<?> clazz) {
 
   @Test
   public void forTypeMirror_basicTypes() {
-    assert_().that(TypeNames.forTypeMirror(getType(Object.class)))
+    assertThat(TypeNames.forTypeMirror(getType(Object.class)))
         .isEqualTo(ClassName.fromClass(Object.class));
-    assert_().that(TypeNames.forTypeMirror(getType(Charset.class)))
+    assertThat(TypeNames.forTypeMirror(getType(Charset.class)))
         .isEqualTo(ClassName.fromClass(Charset.class));
-    assert_().that(TypeNames.forTypeMirror(getType(TypeNamesTest.class)))
+    assertThat(TypeNames.forTypeMirror(getType(TypeNamesTest.class)))
         .isEqualTo(ClassName.fromClass(TypeNamesTest.class));
   }
 
@@ -55,45 +55,52 @@ public void forTypeMirror_basicTypes() {
   public void forTypeMirror_parameterizedType() {
     DeclaredType setType =
         compilation.getTypes().getDeclaredType(getElement(Set.class), getType(Object.class));
-    assert_().that(TypeNames.forTypeMirror(setType))
+    assertThat(TypeNames.forTypeMirror(setType))
         .isEqualTo(ParameterizedTypeName.create(Set.class, ClassName.fromClass(Object.class)));
   }
 
+  @Test
+  public void forTypeMirror_typeVariables() {
+    TypeMirror setType = getType(Set.class);
+    assertThat(TypeNames.forTypeMirror(setType))
+        .isEqualTo(ParameterizedTypeName.create(Set.class, TypeVariableName.named("E")));
+  }
+
   @Test
   public void forTypeMirror_primitive() {
-    assert_().that(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.BOOLEAN)))
+    assertThat(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.BOOLEAN)))
         .isEqualTo(PrimitiveName.BOOLEAN);
-    assert_().that(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.BYTE)))
+    assertThat(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.BYTE)))
         .isEqualTo(PrimitiveName.BYTE);
-    assert_().that(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.SHORT)))
+    assertThat(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.SHORT)))
         .isEqualTo(PrimitiveName.SHORT);
-    assert_().that(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.INT)))
+    assertThat(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.INT)))
         .isEqualTo(PrimitiveName.INT);
-    assert_().that(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.LONG)))
+    assertThat(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.LONG)))
         .isEqualTo(PrimitiveName.LONG);
-    assert_().that(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.CHAR)))
+    assertThat(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.CHAR)))
         .isEqualTo(PrimitiveName.CHAR);
-    assert_().that(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.FLOAT)))
+    assertThat(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.FLOAT)))
         .isEqualTo(PrimitiveName.FLOAT);
-    assert_().that(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.DOUBLE)))
+    assertThat(TypeNames.forTypeMirror(compilation.getTypes().getPrimitiveType(TypeKind.DOUBLE)))
         .isEqualTo(PrimitiveName.DOUBLE);
   }
 
   @Test
   public void forTypeMirror_arrays() {
-    assert_().that(TypeNames.forTypeMirror(compilation.getTypes().getArrayType(getType(Object.class))))
+    assertThat(TypeNames.forTypeMirror(compilation.getTypes().getArrayType(getType(Object.class))))
         .isEqualTo(new ArrayTypeName(ClassName.fromClass(Object.class)));
   }
 
   @Test
   public void forTypeMirror_void() {
-    assert_().that(TypeNames.forTypeMirror(compilation.getTypes().getNoType(TypeKind.VOID)))
+    assertThat(TypeNames.forTypeMirror(compilation.getTypes().getNoType(TypeKind.VOID)))
         .isEqualTo(VoidName.VOID);
   }
 
   @Test
   public void forTypeMirror_null() {
-    assert_().that(TypeNames.forTypeMirror(compilation.getTypes().getNullType()))
+    assertThat(TypeNames.forTypeMirror(compilation.getTypes().getNullType()))
         .isEqualTo(NullName.NULL);
   }
 }
