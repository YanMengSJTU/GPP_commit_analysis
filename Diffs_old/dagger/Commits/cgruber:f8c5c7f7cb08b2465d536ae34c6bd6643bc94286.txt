diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
index c8dbd98e7..ccbf91b27 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -52,6 +52,7 @@
 import dagger.internal.codegen.writer.TypeName;
 import dagger.internal.codegen.writer.TypeNames;
 import dagger.internal.codegen.writer.VoidName;
+import dagger.producers.Produced;
 import dagger.producers.Producer;
 import dagger.producers.internal.Producers;
 import dagger.producers.internal.SetOfProducedProducer;
@@ -101,9 +102,6 @@
 import static dagger.internal.codegen.SourceFiles.indexDependenciesByUnresolvedKey;
 import static dagger.internal.codegen.SourceFiles.membersInjectorNameForType;
 import static dagger.internal.codegen.Util.componentCanMakeNewInstances;
-import static dagger.internal.codegen.Util.getKeyTypeOfMap;
-import static dagger.internal.codegen.Util.getProvidedValueTypeOfMap;
-import static dagger.internal.codegen.Util.isMapWithNonProvidedValues;
 import static dagger.internal.codegen.writer.Snippet.makeParametersSnippet;
 import static dagger.internal.codegen.writer.Snippet.memberSelectSnippet;
 import static dagger.internal.codegen.writer.Snippet.nullCheck;
@@ -754,11 +752,12 @@ private Snippet initializeSetMultibindings(ResolvedBindings resolvedBindings) {
       }
       parameterSnippets.add(snippet);
     }
+    SetType setType = SetType.from(resolvedBindings.bindingKey().key().type());
     Class<?> factoryClass =
         Iterables.all(
                 resolvedBindings.contributionBindings(), Binding.isOfType(Binding.Type.PROVISION))
             ? SetFactory.class
-            : Util.isSetOfProduced(resolvedBindings.bindingKey().key().type())
+            : setType.elementsAreTypeOf(Produced.class)
                 ? SetOfProducedProducer.class
                 : SetProducer.class;
     Snippet initializeSetSnippet =
@@ -783,7 +782,7 @@ private Snippet initializeMapMultibindings(ResolvedBindings resolvedBindings) {
     for (ContributionBinding binding : resolvedBindings.contributionBindings()) {
       Optional<MemberSelect> multibindingContributionSnippet =
           getMultibindingContributionSnippet(binding);
-      if (!isMapWithNonProvidedValues(binding.key().type())
+      if (MapType.from(binding.key().type()).valuesAreTypeOf(Provider.class)
           && multibindingContributionSnippet.isPresent()
           && multibindingContributionSnippet.get().owningClass().equals(name)) {
         initializationSnippets.add(
@@ -1101,9 +1100,9 @@ private TypeMirror typeMirrorAsMemberOf(TypeElement bindingTypeElement, Element
   private Snippet initializeMapBinding(Set<ContributionBinding> bindings) {
     // Get type information from the first binding.
     ContributionBinding firstBinding = bindings.iterator().next();
-    DeclaredType mapType = asDeclared(firstBinding.key().type());
+    MapType mapType = MapType.from(asDeclared(firstBinding.key().type()));
 
-    if (isMapWithNonProvidedValues(mapType)) {
+    if (!mapType.valuesAreTypeOf(Provider.class)) {
       return Snippet.format(
           "%s.create(%s)",
           ClassName.fromClass(MapFactory.class),
@@ -1112,11 +1111,13 @@ private Snippet initializeMapBinding(Set<ContributionBinding> bindings) {
 
     ImmutableList.Builder<dagger.internal.codegen.writer.Snippet> snippets =
         ImmutableList.builder();
-    snippets.add(Snippet.format("%s.<%s, %s>builder(%d)",
-        ClassName.fromClass(MapProviderFactory.class),
-        TypeNames.forTypeMirror(getKeyTypeOfMap(mapType)),
-        TypeNames.forTypeMirror(getProvidedValueTypeOfMap(mapType)), // V of Map<K, Provider<V>>
-        bindings.size()));
+    snippets.add(
+        Snippet.format(
+            "%s.<%s, %s>builder(%d)",
+            ClassName.fromClass(MapProviderFactory.class),
+            TypeNames.forTypeMirror(mapType.keyType()),
+            TypeNames.forTypeMirror(mapType.unwrappedValueType(Provider.class)),
+            bindings.size()));
 
     for (ContributionBinding binding : bindings) {
       snippets.add(
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
index 8594fbad4..e21bc4e52 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -95,11 +95,6 @@
 import static dagger.internal.codegen.ErrorMessages.nullableToNonNullable;
 import static dagger.internal.codegen.ErrorMessages.stripCommonTypePrefixes;
 import static dagger.internal.codegen.Util.componentCanMakeNewInstances;
-import static dagger.internal.codegen.Util.getKeyTypeOfMap;
-import static dagger.internal.codegen.Util.getProvidedValueTypeOfMap;
-import static dagger.internal.codegen.Util.getValueTypeOfMap;
-import static dagger.internal.codegen.Util.isMapWithNonProvidedValues;
-import static dagger.internal.codegen.Util.isMapWithProvidedValues;
 import static javax.tools.Diagnostic.Kind.ERROR;
 import static javax.tools.Diagnostic.Kind.WARNING;
 
@@ -113,6 +108,7 @@
   private final MethodSignatureFormatter methodSignatureFormatter;
   private final DependencyRequestFormatter dependencyRequestFormatter;
   private final KeyFormatter keyFormatter;
+  private final Key.Factory keyFactory;
 
   BindingGraphValidator(
       Types types,
@@ -122,7 +118,8 @@
       ContributionBindingFormatter contributionBindingFormatter,
       MethodSignatureFormatter methodSignatureFormatter,
       DependencyRequestFormatter dependencyRequestFormatter,
-      KeyFormatter keyFormatter) {
+      KeyFormatter keyFormatter,
+      Key.Factory keyFactory) {
     this.types = types;
     this.injectBindingRegistry = injectBindingRegistry;
     this.scopeCycleValidationType = scopeCycleValidationType;
@@ -131,6 +128,7 @@
     this.methodSignatureFormatter = methodSignatureFormatter;
     this.dependencyRequestFormatter = dependencyRequestFormatter;
     this.keyFormatter = keyFormatter;
+    this.keyFactory = keyFactory;
   }
 
   private class Validation {
@@ -963,11 +961,11 @@ private boolean cycleHasProviderOrLazy(ImmutableList<DependencyRequest> cycle) {
             return true;
 
           case INSTANCE:
-            if (isMapWithProvidedValues(dependencyRequest.key().type())) {
+            TypeMirror type = dependencyRequest.key().type();
+            if (MapType.isMap(type) && MapType.from(type).valuesAreTypeOf(Provider.class)) {
               return true;
-            } else {
-              break;
             }
+            break;
 
           default:
             break;
@@ -984,20 +982,10 @@ private boolean cycleHasProviderOrLazy(ImmutableList<DependencyRequest> cycle) {
      */
     private boolean isImplicitProviderMapForValueMap(
         DependencyRequest maybeProviderMapRequest, DependencyRequest maybeValueMapRequest) {
-      TypeMirror maybeProviderMapRequestType = maybeProviderMapRequest.key().type();
-      TypeMirror maybeValueMapRequestType = maybeValueMapRequest.key().type();
-      return maybeProviderMapRequest
-              .key()
-              .wrappedQualifier()
-              .equals(maybeValueMapRequest.key().wrappedQualifier())
-          && isMapWithProvidedValues(maybeProviderMapRequestType)
-          && isMapWithNonProvidedValues(maybeValueMapRequestType)
-          && types.isSameType(
-              getKeyTypeOfMap(asDeclared(maybeProviderMapRequestType)),
-              getKeyTypeOfMap(asDeclared(maybeValueMapRequestType)))
-          && types.isSameType(
-              getProvidedValueTypeOfMap(asDeclared(maybeProviderMapRequestType)),
-              getValueTypeOfMap(asDeclared(maybeValueMapRequestType)));
+      Optional<Key> implicitProviderMapKey =
+          keyFactory.implicitMapProviderKeyFrom(maybeValueMapRequest.key());
+      return implicitProviderMapKey.isPresent()
+          && implicitProviderMapKey.get().equals(maybeProviderMapRequest.key());
     }
   }
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
index 5232815f7..46571b889 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -173,7 +173,8 @@ public SourceVersion getSupportedSourceVersion() {
             contributionBindingFormatter,
             methodSignatureFormatter,
             dependencyRequestFormatter,
-            keyFormatter);
+            keyFormatter,
+            keyFactory);
 
     return ImmutableList.<ProcessingStep>of(
         new MapKeyProcessingStep(messager, types, mapKeyValidator, mapKeyGenerator),
diff --git a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
index a0a48c81e..2aa355e87 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
@@ -44,6 +44,7 @@
 import javax.annotation.Generated;
 import javax.annotation.processing.Filer;
 import javax.inject.Inject;
+import javax.inject.Provider;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.TypeParameterElement;
@@ -101,9 +102,10 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
     // We don't want to write out resolved bindings -- we want to write out the generic version.
     checkState(!binding.hasNonDefaultTypeParameters());
 
-    TypeMirror keyType = binding.provisionType().equals(Type.MAP)
-        ? Util.getProvidedValueTypeOfMap(MoreTypes.asDeclared(binding.key().type()))
-        : binding.key().type();
+    TypeMirror keyType =
+        binding.provisionType().equals(Type.MAP)
+            ? MapType.from(binding.key().type()).unwrappedValueType(Provider.class)
+            : binding.key().type();
     TypeName providedTypeName = TypeNames.forTypeMirror(keyType);
     JavaWriter writer = JavaWriter.inPackage(generatedTypeName.packageName());
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/Key.java b/compiler/src/main/java/dagger/internal/codegen/Key.java
index cd094febb..0f3da6b6d 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Key.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Key.java
@@ -20,6 +20,7 @@
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Equivalence;
+import com.google.common.base.Equivalence.Wrapper;
 import com.google.common.base.MoreObjects;
 import com.google.common.base.Optional;
 import com.google.common.collect.Iterables;
@@ -52,8 +53,6 @@
 import static dagger.internal.codegen.InjectionAnnotations.getQualifier;
 import static dagger.internal.codegen.MapKeys.getMapKey;
 import static dagger.internal.codegen.MapKeys.getUnwrappedMapKeyType;
-import static dagger.internal.codegen.Util.unwrapOptionalEquivalence;
-import static dagger.internal.codegen.Util.wrapOptionalInEquivalence;
 import static javax.lang.model.element.ElementKind.METHOD;
 
 /**
@@ -155,6 +154,27 @@ public String toString() {
         .toString();
   }
 
+  /**
+   * Wraps an {@link Optional} of a type in an {@code Optional} of a {@link Wrapper} for that type.
+   */
+  private static <T> Optional<Equivalence.Wrapper<T>> wrapOptionalInEquivalence(
+      Equivalence<T> equivalence, Optional<T> optional) {
+    return optional.isPresent()
+        ? Optional.of(equivalence.wrap(optional.get()))
+        : Optional.<Equivalence.Wrapper<T>>absent();
+  }
+
+  /**
+   * Unwraps an {@link Optional} of a {@link Wrapper} into an {@code Optional} of the underlying
+   * type.
+   */
+  private static <T> Optional<T> unwrapOptionalEquivalence(
+      Optional<Equivalence.Wrapper<T>> wrappedOptional) {
+    return wrappedOptional.isPresent()
+        ? Optional.of(wrappedOptional.get().get())
+        : Optional.<T>absent();
+  }
+
   static final class Factory {
     private final Types types;
     private final Elements elements;
@@ -342,22 +362,20 @@ Key forQualifiedType(Optional<AnnotationMirror> qualifier, TypeMirror type) {
      * {@code Map<K, V>}.
      */
     private Optional<Key> maybeWrapMapValue(Key possibleMapKey, Class<?> wrappingClass) {
-      if (MoreTypes.isTypeOf(Map.class, possibleMapKey.type())) {
-        DeclaredType declaredMapType = MoreTypes.asDeclared(possibleMapKey.type());
-        TypeMirror mapValueType = Util.getValueTypeOfMap(declaredMapType);
-        if (!MoreTypes.isTypeOf(wrappingClass, mapValueType)) {
-          TypeMirror keyType = Util.getKeyTypeOfMap(declaredMapType);
+      if (MapType.isMap(possibleMapKey.type())) {
+        MapType mapType = MapType.from(possibleMapKey.type());
+        if (!mapType.valuesAreTypeOf(wrappingClass)) {
           TypeElement wrappingElement = getClassElement(wrappingClass);
           if (wrappingElement == null) {
             // This target might not be compiled with Producers, so wrappingClass might not have an
             // associated element.
             return Optional.absent();
           }
-          DeclaredType wrappedType = types.getDeclaredType(wrappingElement, mapValueType);
-          TypeMirror mapType = types.getDeclaredType(getMapElement(), keyType, wrappedType);
-          return Optional.<Key>of(new AutoValue_Key(
-              possibleMapKey.wrappedQualifier(),
-              MoreTypes.equivalence().wrap(mapType)));
+          DeclaredType wrappedValueType =
+              types.getDeclaredType(wrappingElement, mapType.valueType());
+          TypeMirror wrappedMapType =
+              types.getDeclaredType(getMapElement(), mapType.keyType(), wrappedValueType);
+          return Optional.of(possibleMapKey.withType(types, wrappedMapType));
         }
       }
       return Optional.absent();
diff --git a/compiler/src/main/java/dagger/internal/codegen/MapType.java b/compiler/src/main/java/dagger/internal/codegen/MapType.java
new file mode 100644
index 000000000..cab30de04
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/MapType.java
@@ -0,0 +1,99 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.common.MoreTypes;
+import com.google.auto.value.AutoValue;
+import com.google.common.base.Equivalence;
+import java.util.Map;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeMirror;
+
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkState;
+
+/**
+ * Information about a {@link Map} {@link TypeMirror}.
+ */
+@AutoValue
+abstract class MapType {
+  /**
+   * The map type itself, wrapped using {@link MoreTypes#equivalence()}. Use
+   * {@link #declaredMapType()} instead.
+   */
+  protected abstract Equivalence.Wrapper<DeclaredType> wrappedDeclaredMapType();
+
+  /**
+   * The map type itself.
+   */
+  DeclaredType declaredMapType() {
+    return wrappedDeclaredMapType().get();
+  }
+
+  /**
+   * The map key type.
+   */
+  TypeMirror keyType() {
+    return declaredMapType().getTypeArguments().get(0);
+  }
+
+  /**
+   * The map value type.
+   */
+  TypeMirror valueType() {
+    return declaredMapType().getTypeArguments().get(1);
+  }
+
+  /**
+   * {@code true} if {@link #valueType()} is a {@code clazz}.
+   */
+  boolean valuesAreTypeOf(Class<?> clazz) {
+    return MoreTypes.isType(valueType()) && MoreTypes.isTypeOf(clazz, valueType());
+  }
+
+  /**
+   * {@code V} if {@link #valueType()} is a {@code WrappingClass<V>}.
+   *
+   * @throws IllegalStateException if {@link #valueType()} is not a {@code WrappingClass<V>}
+   * @throws IllegalArgumentException if {@code wrappingClass} does not have exactly one type
+   *     parameter
+   */
+  TypeMirror unwrappedValueType(Class<?> wrappingClass) {
+    checkArgument(
+        wrappingClass.getTypeParameters().length == 1,
+        "%s must have exactly one type parameter",
+        wrappingClass);
+    checkState(valuesAreTypeOf(wrappingClass));
+    return MoreTypes.asDeclared(valueType()).getTypeArguments().get(0);
+  }
+
+  /**
+   * {@code true} if {@code type} is a {@link Map} type.
+   */
+  static boolean isMap(TypeMirror type) {
+    return MoreTypes.isType(type) && MoreTypes.isTypeOf(Map.class, type);
+  }
+
+  /**
+   * Returns a {@link MapType} for {@code type}.
+   *
+   * @throws IllegalArgumentException if {@code type} is not a {@link Map} type
+   */
+  static MapType from(TypeMirror type) {
+    checkArgument(isMap(type), "%s is not a Map", type);
+    return new AutoValue_MapType(MoreTypes.equivalence().wrap(MoreTypes.asDeclared(type)));
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
index dcf7e4874..3c47d55ca 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
@@ -15,7 +15,6 @@
  */
 package dagger.internal.codegen;
 
-import com.google.auto.common.MoreTypes;
 import com.google.common.base.Function;
 import com.google.common.base.Joiner;
 import com.google.common.base.Optional;
@@ -93,9 +92,10 @@ ClassName nameGeneratedType(ProductionBinding binding) {
 
   @Override
   ImmutableSet<JavaWriter> write(ClassName generatedTypeName, ProductionBinding binding) {
-    TypeMirror keyType = binding.productionType().equals(Type.MAP)
-        ? Util.getProvidedValueTypeOfMap(MoreTypes.asDeclared(binding.key().type()))
-        : binding.key().type();
+    TypeMirror keyType =
+        binding.productionType().equals(Type.MAP)
+            ? MapType.from(binding.key().type()).unwrappedValueType(Producer.class)
+            : binding.key().type();
     TypeName providedTypeName = TypeNames.forTypeMirror(keyType);
     TypeName futureTypeName = ParameterizedTypeName.create(
         ClassName.fromClass(ListenableFuture.class), providedTypeName);
diff --git a/compiler/src/main/java/dagger/internal/codegen/SetType.java b/compiler/src/main/java/dagger/internal/codegen/SetType.java
new file mode 100644
index 000000000..4103c71d0
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/SetType.java
@@ -0,0 +1,92 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.common.MoreTypes;
+import com.google.auto.value.AutoValue;
+import com.google.common.base.Equivalence;
+import java.util.Set;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeMirror;
+
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkState;
+
+/**
+ * Information about a {@link Set} {@link TypeMirror}.
+ */
+@AutoValue
+abstract class SetType {
+  /**
+   * The set type itself, wrapped using {@link MoreTypes#equivalence()}. Use
+   * {@link #declaredSetType()} instead.
+   */
+  protected abstract Equivalence.Wrapper<DeclaredType> wrappedDeclaredSetType();
+  
+  /**
+   * The set type itself.
+   */
+  DeclaredType declaredSetType() {
+    return wrappedDeclaredSetType().get();
+  }
+
+  /**
+   * The element type.
+   */
+  TypeMirror elementType() {
+    return declaredSetType().getTypeArguments().get(0);
+  }
+
+  /**
+   * {@code true} if {@link #elementType()} is a {@code clazz}.
+   */
+  boolean elementsAreTypeOf(Class<?> clazz) {
+    return MoreTypes.isType(elementType()) && MoreTypes.isTypeOf(clazz, elementType());
+  }
+
+  /**
+   * {@code T} if {@link #elementType()} is a {@code WrappingClass<T>}.
+   *
+   * @throws IllegalStateException if {@link #elementType()} is not a {@code WrappingClass<T>}
+   * @throws IllegalArgumentException if {@code wrappingClass} does not have exactly one type
+   *     parameter
+   */
+  TypeMirror unwrappedElementType(Class<?> wrappingClass) {
+    checkArgument(
+        wrappingClass.getTypeParameters().length == 1,
+        "%s must have exactly one type parameter",
+        wrappingClass);
+    checkState(elementsAreTypeOf(wrappingClass));
+    return MoreTypes.asDeclared(elementType()).getTypeArguments().get(0);
+  }
+
+  /**
+   * {@code true} if {@code type} is a {@link Set} type.
+   */
+  static boolean isSetType(TypeMirror type) {
+    return MoreTypes.isType(type) && MoreTypes.isTypeOf(Set.class, type);
+  }
+
+  /**
+   * Returns a {@link SetType} for {@code type}.
+   *
+   * @throws IllegalArgumentException if {@code type} is not a {@link Set} type
+   */
+  static SetType from(TypeMirror type) {
+    checkArgument(isSetType(type), "%s must be a Set", type);
+    return new AutoValue_SetType(MoreTypes.equivalence().wrap(MoreTypes.asDeclared(type)));
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/Util.java b/compiler/src/main/java/dagger/internal/codegen/Util.java
index 8c1aba399..1b941ceab 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Util.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Util.java
@@ -16,26 +16,15 @@
  */
 package dagger.internal.codegen;
 
-import com.google.auto.common.MoreTypes;
-import com.google.common.base.Equivalence;
-import com.google.common.base.Equivalence.Wrapper;
-import com.google.common.base.Optional;
+import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableSet;
-import dagger.producers.Produced;
-import java.util.Map;
-import java.util.Set;
-import javax.inject.Provider;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.Modifier;
 import javax.lang.model.element.TypeElement;
-import javax.lang.model.type.DeclaredType;
-import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
 
 import static com.google.auto.common.MoreElements.getLocalAndInheritedMethods;
-import static com.google.auto.common.MoreTypes.asDeclared;
-import static com.google.common.base.Preconditions.checkState;
+import static com.google.auto.common.MoreElements.hasModifiers;
 import static javax.lang.model.element.ElementKind.CONSTRUCTOR;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.element.Modifier.PRIVATE;
@@ -45,92 +34,6 @@
  * Utilities for handling types in annotation processors
  */
 final class Util {
-  /**
-   * Returns the {@code V} type for a {@link Map} type like {@code Map<K, Provider<V>>} if the map
-   * includes such a construction
-   */
-  public static TypeMirror getProvidedValueTypeOfMap(DeclaredType mapType) {
-    checkState(MoreTypes.isTypeOf(Map.class, mapType), "%s is not a Map.", mapType);
-    return asDeclared(mapType.getTypeArguments().get(1)).getTypeArguments().get(0);
-  }
-
-  // TODO(cgruber): Consider an object that holds and exposes the various parts of a Map type.
-  /**
-   * returns the value type for a {@link Map} type like Map<K, V>}.
-   */
-  public static TypeMirror getValueTypeOfMap(DeclaredType mapType) {
-    checkState(MoreTypes.isTypeOf(Map.class, mapType), "%s is not a Map.", mapType);
-    return mapType.getTypeArguments().get(1);
-  }
-
-  /**
-   * Returns the key type for a {@link Map} type like Map<K, Provider<V>>}
-   */
-  public static TypeMirror getKeyTypeOfMap(DeclaredType mapType) {
-    checkState(MoreTypes.isTypeOf(Map.class, mapType), "%s is not a Map.", mapType);
-    return mapType.getTypeArguments().get(0);
-  }
-
-  /**
-   * Returns true if {@code type} is a {@link Map} whose value type is not a {@link Provider}.
-   */
-  public static boolean isMapWithNonProvidedValues(TypeMirror type) {
-    return MoreTypes.isType(type)
-        && MoreTypes.isTypeOf(Map.class, type)
-        && !MoreTypes.isTypeOf(Provider.class, asDeclared(type).getTypeArguments().get(1));
-  }
-
-  /**
-   * Returns true if {@code type} is a {@link Map} whose value type is a {@link Provider}.
-   */
-  public static boolean isMapWithProvidedValues(TypeMirror type) {
-    return MoreTypes.isType(type)
-        && MoreTypes.isTypeOf(Map.class, type)
-        && MoreTypes.isTypeOf(Provider.class, asDeclared(type).getTypeArguments().get(1));
-  }
-
-  /** Returns true if {@code type} is a {@code Set<Produced<T>>}. */
-  static boolean isSetOfProduced(TypeMirror type) {
-    return MoreTypes.isType(type)
-        && MoreTypes.isTypeOf(Set.class, type)
-        && MoreTypes.isTypeOf(Produced.class, MoreTypes.asDeclared(type).getTypeArguments().get(0));
-  }
-
-  /**
-   * Wraps an {@link Optional} of a type in an {@code Optional} of a {@link Wrapper} for that type.
-   */
-  static <T> Optional<Equivalence.Wrapper<T>> wrapOptionalInEquivalence(
-      Equivalence<T> equivalence, Optional<T> optional) {
-    return optional.isPresent()
-        ? Optional.of(equivalence.wrap(optional.get()))
-        : Optional.<Equivalence.Wrapper<T>>absent();
-  }
-
-  /**
-   * Unwraps an {@link Optional} of a {@link Wrapper} into an {@code Optional} of the underlying
-   * type.
-   */
-  static <T> Optional<T> unwrapOptionalEquivalence(
-      Optional<Equivalence.Wrapper<T>> wrappedOptional) {
-    return wrappedOptional.isPresent()
-        ? Optional.of(wrappedOptional.get().get())
-        : Optional.<T>absent();
-  }
-
-  private static boolean requiresEnclosingInstance(TypeElement typeElement) {
-    switch (typeElement.getNestingKind()) {
-      case TOP_LEVEL:
-        return false;
-      case MEMBER:
-        return !typeElement.getModifiers().contains(STATIC);
-      case ANONYMOUS:
-      case LOCAL:
-        return true;
-      default:
-        throw new AssertionError("TypeElement cannot have nesting kind: "
-            + typeElement.getNestingKind());
-    }
-  }
 
   /**
    * Returns true if and only if a component can instantiate new instances (typically of a module)
@@ -169,16 +72,26 @@ static boolean componentCanMakeNewInstances(TypeElement typeElement) {
     return false;
   }
 
+  private static boolean requiresEnclosingInstance(TypeElement typeElement) {
+    switch (typeElement.getNestingKind()) {
+      case TOP_LEVEL:
+        return false;
+      case MEMBER:
+        return !typeElement.getModifiers().contains(STATIC);
+      case ANONYMOUS:
+      case LOCAL:
+        return true;
+      default:
+        throw new AssertionError(
+            "TypeElement cannot have nesting kind: " + typeElement.getNestingKind());
+    }
+  }
+
   static ImmutableSet<ExecutableElement> getUnimplementedMethods(
       Elements elements, TypeElement type) {
-    ImmutableSet.Builder<ExecutableElement> unimplementedMethods = ImmutableSet.builder();
-    Set<ExecutableElement> methods = getLocalAndInheritedMethods(type, elements);
-    for (ExecutableElement method : methods) {
-      if (method.getModifiers().contains(Modifier.ABSTRACT)) {
-        unimplementedMethods.add(method);
-      }
-    }
-    return unimplementedMethods.build();
+    return FluentIterable.from(getLocalAndInheritedMethods(type, elements))
+        .filter(hasModifiers(ABSTRACT))
+        .toSet();
   }
 
   private Util() {}
