diff --git a/compiler/src/main/java/dagger/internal/codegen/Binding.java b/compiler/src/main/java/dagger/internal/codegen/Binding.java
index 435d8f3ca..1a88f1c2c 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Binding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Binding.java
@@ -34,6 +34,9 @@
 // TODO(gak): make a decision about whether or not to bring MembersInjectionBinding under this
 // supertype or whether to just get rid of this.
 abstract class Binding {
+  /** The {@link Key} that is provided by this binding. */
+  protected abstract Key key();
+
   /** Returns the {@link Element} instance that is responsible for declaring the binding. */
   abstract Element bindingElement();
 
@@ -68,4 +71,5 @@ public TypeElement visitType(TypeElement e, Void p) {
    * may reference non-public types.
    */
   abstract Optional<String> bindingPackage();
+
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
index 7053e2742..303668368 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
@@ -150,7 +150,7 @@ ComponentDescriptor create(TypeElement componentDefinitionType)
 
       ImmutableSetMultimap.Builder<Key, ProvisionBinding> explicitBindingIndexBuilder =
           new ImmutableSetMultimap.Builder<Key, ProvisionBinding>()
-              .put(componentBinding.providedKey(), componentBinding);
+              .put(componentBinding.key(), componentBinding);
       ImmutableMap.Builder<ExecutableElement, TypeElement> dependencyMethodIndex =
           ImmutableMap.builder();
 
@@ -158,7 +158,7 @@ ComponentDescriptor create(TypeElement componentDefinitionType)
         ProvisionBinding componentDependencyBinding =
             provisionBindingFactory.forComponent(componentDependency);
         explicitBindingIndexBuilder.put(
-            componentDependencyBinding.providedKey(), componentDependencyBinding);
+            componentDependencyBinding.key(), componentDependencyBinding);
         List<ExecutableElement> dependencyMethods =
             ElementFilter.methodsIn(elements.getAllMembers(componentDependency));
         for (ExecutableElement dependencyMethod : dependencyMethods) {
@@ -166,7 +166,7 @@ ComponentDescriptor create(TypeElement componentDefinitionType)
             ProvisionBinding componentMethodBinding =
                 provisionBindingFactory.forComponentMethod(dependencyMethod);
             explicitBindingIndexBuilder
-                .put(componentMethodBinding.providedKey(), componentMethodBinding);
+                .put(componentMethodBinding.key(), componentMethodBinding);
             dependencyMethodIndex.put(dependencyMethod, componentDependency);
           }
         }
@@ -181,7 +181,7 @@ ComponentDescriptor create(TypeElement componentDefinitionType)
             ProvisionBinding providesMethodBinding =
                 provisionBindingFactory.forProvidesMethod(moduleMethod);
             explicitBindingIndexBuilder
-                .put(providesMethodBinding.providedKey(), providesMethodBinding);
+                .put(providesMethodBinding.key(), providesMethodBinding);
           }
         }
       }
@@ -292,7 +292,7 @@ private void resolveRequest(DependencyRequest request,
             } else {
               // no explicit binding, look it up
               Optional<ProvisionBinding> provisionBinding =
-                  injectBindingRegistry.getOrFindOrCreateProvisionBinding(requestKey);
+                  injectBindingRegistry.getOrFindProvisionBinding(requestKey);
               checkState(provisionBinding.isPresent(),
                   "Can not find a provision binding for %s. this should not have passed validation",
                   requestKey);
@@ -308,7 +308,7 @@ private void resolveRequest(DependencyRequest request,
             }
           } else {
             // we found explicit bindings. resolve the deps and them mark them resolved
-            for (ProvisionBinding explicitBinding : explicitBindingsForKey) {
+            for (Binding explicitBinding : explicitBindingsForKey) {
               for (DependencyRequest dependency : explicitBinding.dependencies()) {
                 resolveRequest(dependency, explicitBindings, resolvedBindings,
                     resolvedProvisionsBindingBuilder, resolvedMembersInjectionBindingsBuilder);
@@ -321,7 +321,7 @@ private void resolveRequest(DependencyRequest request,
         case MEMBERS_INJECTOR:
          // no explicit deps for members injection, so just look it up
           MembersInjectionBinding membersInjectionBinding =
-              injectBindingRegistry.getOrFindOrCreateMembersInjectionBinding(requestKey);
+              injectBindingRegistry.getOrFindMembersInjectionBinding(requestKey);
           //resolve its deps and then mark it resolved
           for (DependencyRequest dependency : Iterables.concat(
               membersInjectionBinding.dependencies(),
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
index 72e3d4177..a0768671f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
@@ -395,7 +395,7 @@ private Snippet initializeFactoryForBinding(ProvisionBinding binding,
     if (binding.bindingKind().equals(COMPONENT)) {
       return Snippet.format("%s.<%s>create(this)",
           ClassName.fromClass(InstanceFactory.class),
-          TypeNames.forTypeMirror(binding.providedKey().type()));
+          TypeNames.forTypeMirror(binding.key().type()));
     } else if (binding.bindingKind().equals(COMPONENT_PROVISION)) {
       return Snippet.format(Joiner.on('\n').join(
           "new %s<%2$s>() {",
@@ -404,7 +404,7 @@ private Snippet initializeFactoryForBinding(ProvisionBinding binding,
           "  }",
           "}"),
           ClassName.fromClass(Factory.class),
-          TypeNames.forTypeMirror(binding.providedKey().type()),
+          TypeNames.forTypeMirror(binding.key().type()),
           contributionFields.get(dependencyMethodIndex.get(binding.bindingElement())).name(),
           binding.bindingElement().getSimpleName().toString());
     } else {
@@ -479,7 +479,7 @@ private Snippet initializeMapBinding(
           ClassName.fromClass(MapFactory.class),
           memberSelectSnippets.get(Iterables.getOnlyElement(firstBinding.dependencies()).key()));
     } else {
-      DeclaredType mapType = Util.asDeclaredType(firstBinding.providedKey().type());
+      DeclaredType mapType = Util.asDeclaredType(firstBinding.key().type());
       TypeMirror mapKeyType = Util.getKeyTypeOfMap(mapType);
       TypeMirror mapValueType = Util.getProvidedValueTypeOfMap(mapType); // V of Map<K, Provider<V>>
       StringBuilder snippetFormatBuilder = new StringBuilder("%s.<%s, %s>builder(%d)");
@@ -508,7 +508,7 @@ private Snippet initializeMapBinding(
   }
 
   // add one map entry for map Provider in Constructor
-  private void writeEntry(List<Object> argsBuilder, ProvisionBinding binding,
+  private void writeEntry(List<Object> argsBuilder, Binding binding,
       Snippet factory) {
     AnnotationMirror mapKeyAnnotationMirror =
         Iterables.getOnlyElement(getMapKeys(binding.bindingElement()));
@@ -598,8 +598,8 @@ public Snippet visitArray(List<? extends AnnotationValue> values, Void v) {
     return value.accept(mapKeyVisitor, null);
   }
 
-  private boolean isNonProviderMap(ProvisionBinding binding) {
-    TypeMirror bindingType = binding.providedKey().type();
+  private boolean isNonProviderMap(Binding binding) {
+    TypeMirror bindingType = binding.key().type();
     return Util.isTypeOf(Map.class, bindingType) // Implicitly guarantees a declared type.
         && !Util.isTypeOf(Provider.class, asDeclaredType(bindingType).getTypeArguments().get(1));
   }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
index 8da069f9f..644d79173 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -44,6 +44,7 @@
  */
 public final class ComponentProcessor extends AbstractProcessor {
   private ImmutableList<ProcessingStep> processingSteps;
+  private InjectBindingRegistry injectBindingRegistry;
 
   @Override
   public Set<String> getSupportedAnnotationTypes() {
@@ -90,11 +91,11 @@ public synchronized void init(ProcessingEnvironment processingEnv) {
         new ProvisionBinding.Factory(elements, types, keyFactory, dependencyRequestFactory);
 
     MembersInjectionBinding.Factory membersInjectionBindingFactory =
-        new MembersInjectionBinding.Factory(elements, types, dependencyRequestFactory);
+        new MembersInjectionBinding.Factory(elements, types, keyFactory, dependencyRequestFactory);
 
-    InjectBindingRegistry injectBindingRegistry = new InjectBindingRegistry(
+    this.injectBindingRegistry = new InjectBindingRegistry(
         elements, types, messager, provisionBindingFactory, factoryGenerator,
-        membersInjectionBindingFactory, membersInjectorGenerator, keyFactory);
+        membersInjectionBindingFactory, membersInjectorGenerator);
 
     ComponentDescriptor.Factory componentDescriptorFactory =
         new ComponentDescriptor.Factory(elements, types, injectBindingRegistry,
@@ -115,9 +116,7 @@ public synchronized void init(ProcessingEnvironment processingEnv) {
             injectFieldValidator,
             injectMethodValidator,
             provisionBindingFactory,
-            factoryGenerator,
             membersInjectionBindingFactory,
-            membersInjectorGenerator,
             injectBindingRegistry),
         new ModuleProcessingStep(
             messager,
@@ -138,6 +137,11 @@ public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment
     for (ProcessingStep processingStep : processingSteps) {
       processingStep.process(annotations, roundEnv);
     }
+    try {
+      injectBindingRegistry.generateSourcesForRequiredBindings();
+    } catch (SourceFileGenerationException e) {
+      e.printMessageTo(processingEnv.getMessager());
+    }
     return false;
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
index e1164d339..a59a01fec 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
@@ -86,8 +86,8 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
   @Override
   ImmutableSet<JavaWriter> write(ClassName generatedTypeName, ProvisionBinding binding) {
     TypeMirror keyType = binding.provisionType().equals(Type.MAP)
-        ? Util.getProvidedValueTypeOfMap(Util.asDeclaredType(binding.providedKey().type()))
-        : binding.providedKey().type();
+        ? Util.getProvidedValueTypeOfMap(Util.asDeclaredType(binding.key().type()))
+        : binding.key().type();
     TypeName providedTypeName = TypeNames.forTypeMirror(keyType);
     JavaWriter writer = JavaWriter.inPackage(generatedTypeName.packageName());
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/GraphValidator.java b/compiler/src/main/java/dagger/internal/codegen/GraphValidator.java
index 83f0b27f1..7d9954371 100644
--- a/compiler/src/main/java/dagger/internal/codegen/GraphValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/GraphValidator.java
@@ -168,7 +168,7 @@ void validateGraph(TypeElement component,
     // Multimaps.index() doesn't do ImmutableSetMultimaps.
     ImmutableSetMultimap.Builder<Key, ProvisionBinding> builder = ImmutableSetMultimap.builder();
     for (ProvisionBinding binding : bindings) {
-      builder.put(binding.providedKey(), binding);
+      builder.put(binding.key(), binding);
     }
     return builder.build();
   }
@@ -236,7 +236,7 @@ private void resolveRequest(DependencyRequest request,
             if (key.isPresent()) {
               DependencyRequest implicitRequest =
                   dependencyRequestFactory.forImplicitMapBinding(request, key.get());
-              ProvisionBinding implicitBinding =
+              Binding implicitBinding =
                   provisionBindingFactory.forImplicitMapBinding(request, implicitRequest);
               resolveRequest(Iterables.getOnlyElement(implicitBinding.dependencies()),
                   rootRequest, reportBuilder, explicitBindings, resolvedBindings, cycleStack,
@@ -275,7 +275,7 @@ private void resolveRequest(DependencyRequest request,
                 reportDuplicateBindings(rootRequest, requestKey, bindingsByType, reportBuilder);
               }
             }
-            for (ProvisionBinding explicitBinding : explicitBindingsForKey) {
+            for (Binding explicitBinding : explicitBindingsForKey) {
               for (DependencyRequest dependency : explicitBinding.dependencies()) {
                 resolveRequest(dependency, rootRequest, reportBuilder, explicitBindings,
                     resolvedBindings, cycleStack, dependencyPath);
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java b/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
index 42bda5e26..b05cfc62d 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
@@ -22,8 +22,12 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Maps;
+import com.google.common.collect.Queues;
 import com.google.common.collect.Sets;
+import dagger.Component;
+import dagger.Provides;
 import dagger.internal.codegen.writer.ClassName;
+import java.util.Deque;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
@@ -40,10 +44,14 @@
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
+import static com.google.common.base.Verify.verify;
+import static dagger.internal.codegen.Key.Kind.PROVIDER;
 
 /**
  * Maintains the collection of provision bindings from {@link Inject} constructors and members
  * injection bindings from {@link Inject} fields and methods known to the annotation processor.
+ * Note that this registry <b>does not</b> handle any explicit bindings (those from {@link Provides}
+ * methods, {@link Component} dependencies, etc.).
  *
  * @author Gregory Kick
  */
@@ -55,10 +63,10 @@
   private final FactoryGenerator factoryGenerator;
   private final MembersInjectionBinding.Factory membersInjectionBindingFactory;
   private final MembersInjectorGenerator membersInjectorGenerator;
-  private final Key.Factory keyFactory;
-  private final Map<Key, ProvisionBinding> provisionBindingsByKey;
-  private final Map<Key, MembersInjectionBinding> membersInjectionBindingsByKey;
-  private final Set<ClassName> generatedTypeNames;
+
+  private final Map<Key, Binding> bindingsByKey = Maps.newLinkedHashMap();
+  private final Deque<Binding> bindingsRequiringGeneration = Queues.newArrayDeque();
+  private final Set<Binding> materializedBindings = Sets.newLinkedHashSet();
 
   InjectBindingRegistry(Elements elements,
       Types types,
@@ -66,8 +74,7 @@
       ProvisionBinding.Factory provisionBindingFactory,
       FactoryGenerator factoryGenerator,
       MembersInjectionBinding.Factory membersInjectionBindingFactory,
-      MembersInjectorGenerator membersInjectorGenerator,
-      Key.Factory keyFactory) {
+      MembersInjectorGenerator membersInjectorGenerator) {
     this.elements = elements;
     this.types = types;
     this.messager = messager;
@@ -75,43 +82,76 @@
     this.factoryGenerator = factoryGenerator;
     this.membersInjectionBindingFactory = membersInjectionBindingFactory;
     this.membersInjectorGenerator = membersInjectorGenerator;
-    this.provisionBindingsByKey = Maps.newLinkedHashMap();
-    this.membersInjectionBindingsByKey = Maps.newLinkedHashMap();
-    this.generatedTypeNames = Sets.newLinkedHashSet();
-    this.keyFactory = keyFactory;
-  }
-
-  // TODO(gak): rework how we handle knowing what we've generated and not.
-  void registerGeneratedFile(ClassName generatedTypeName) {
-    checkState(generatedTypeNames.add(generatedTypeName),
-        "couldn't register %s as it was already registered.", generatedTypeName);
   }
 
-  void registerProvisionBinding(ProvisionBinding binding) {
-    ProvisionBinding previousValue = provisionBindingsByKey.put(binding.providedKey(), binding);
-    checkState(previousValue == null, "couldn't register %s. %s was already registered", binding,
-        previousValue);
+  /**
+   * This method ensures that sources for all registered {@link Binding bindings} (either
+   * {@linkplain #registerBinding explicitly} or implicitly via
+   * {@link #getOrFindMembersInjectionBinding} or {@link #getOrFindProvisionBinding}) are generated.
+   */
+  void generateSourcesForRequiredBindings() throws SourceFileGenerationException {
+    for (Binding binding = bindingsRequiringGeneration.poll();
+        binding != null;
+        binding = bindingsRequiringGeneration.poll()) {
+      switch (binding.key().kind()) {
+        case PROVIDER:
+          factoryGenerator.generate((ProvisionBinding) binding);
+          break;
+        case MEMBERS_INJECTOR:
+          membersInjectorGenerator.generate((MembersInjectionBinding) binding);
+          break;
+        default:
+          throw new AssertionError();
+      }
+      materializedBindings.add(binding);
+    }
   }
 
-  void registerMembersInjectionBinding(MembersInjectionBinding binding) {
-    MembersInjectionBinding previousValue = membersInjectionBindingsByKey.put(
-        keyFactory.forMembersInjectedType(binding.bindingElement().asType()), binding);
-    checkState(previousValue == null, "couldn't register %s. %s was already registered", binding,
-        previousValue);
+  <B extends Binding> B registerBinding(B binding) {
+    return registerBinding(binding, true);
   }
 
-  Optional<ProvisionBinding> getOrFindOrCreateProvisionBinding(Key key)
-      throws SourceFileGenerationException {
-    Optional<ProvisionBinding> binding = getOrFindProvisionBinding(key);
-    if (binding.isPresent()) {
-      ClassName factoryName = SourceFiles.factoryNameForProvisionBinding(binding.get());
-      if (!generatedTypeNames.contains(factoryName)
-          && elements.getTypeElement(factoryName.canonicalName()) == null) {
-        // does not exist.  generate
-        factoryGenerator.generate(binding.get());
-        generatedTypeNames.add(factoryName);
-        messager.printMessage(Kind.NOTE, String.format("Generating a Factory for %s. "
-            + "Prefer to run the dagger processor over that class instead.", key.type()));
+  private <B extends Binding> B registerBinding(B binding, boolean explicit) {
+    Key key = binding.key();
+    Binding previousValue = bindingsByKey.put(key, binding);
+    checkState(previousValue == null || binding.equals(previousValue),
+        "couldn't register %s. %s was already registered for %s",
+        binding, previousValue, key);
+    if (!materializedBindings.contains(binding) && !bindingsRequiringGeneration.contains(binding)) {
+      switch (key.kind()) {
+        case PROVIDER:
+          ProvisionBinding provisionBinding =  (ProvisionBinding) binding;
+          ClassName factoryName = SourceFiles.factoryNameForProvisionBinding(provisionBinding);
+          if (elements.getTypeElement(factoryName.canonicalName()) == null) {
+            bindingsRequiringGeneration.offer(provisionBinding);
+            if (!explicit) {
+              messager.printMessage(Kind.NOTE, String.format("Generating a Factory for %s. "
+                  + "Prefer to run the dagger processor over that class instead.", key.type()));
+            }
+          }
+          break;
+        case MEMBERS_INJECTOR:
+          MembersInjectionBinding membersInjectionBinding = (MembersInjectionBinding) binding;
+          if (membersInjectionBinding.injectionSites().isEmpty()) {
+            // empty members injection bindings are special and don't need source files.
+            // so, we just pretend
+            materializedBindings.add(binding);
+          } else  {
+            ClassName membersInjectorName =
+                SourceFiles.membersInjectorNameForMembersInjectionBinding(membersInjectionBinding);
+            if (elements.getTypeElement(membersInjectorName.canonicalName()) == null) {
+              bindingsRequiringGeneration.offer(membersInjectionBinding);
+              if (!explicit) {
+                messager.printMessage(Kind.NOTE, String.format(
+                    "Generating a MembersInjector for %s. "
+                          + "Prefer to run the dagger processor over that class instead.",
+                    key.type()));
+              }
+            }
+          }
+          break;
+        default:
+          throw new AssertionError();
       }
     }
     return binding;
@@ -119,12 +159,14 @@ void registerMembersInjectionBinding(MembersInjectionBinding binding) {
 
   Optional<ProvisionBinding> getOrFindProvisionBinding(Key key) {
     checkNotNull(key);
+    checkArgument(key.kind().equals(PROVIDER));
     if (key.qualifier().isPresent()) {
       return Optional.absent();
     }
-    Optional<ProvisionBinding> binding = Optional.fromNullable(provisionBindingsByKey.get(key));
-    if (binding.isPresent()) {
-      return binding;
+    Binding binding = bindingsByKey.get(key);
+    if (binding != null) {
+      verify(binding instanceof ProvisionBinding);
+      return Optional.of((ProvisionBinding) binding);
     }
     // ok, let's see if we can find an @Inject constructor
     TypeElement element = MoreElements.asType(types.asElement(key.type()));
@@ -143,41 +185,23 @@ void registerMembersInjectionBinding(MembersInjectionBinding binding) {
       case 1:
         ProvisionBinding constructorBinding = provisionBindingFactory.forInjectConstructor(
             Iterables.getOnlyElement(injectConstructors));
-        registerProvisionBinding(constructorBinding);
-        return Optional.of(constructorBinding);
+        return Optional.of(registerBinding(constructorBinding, false));
       default:
         throw new IllegalStateException("Found multiple @Inject constructors: "
             + injectConstructors);
     }
   }
 
-  MembersInjectionBinding getOrFindOrCreateMembersInjectionBinding(Key key)
-      throws SourceFileGenerationException {
-    MembersInjectionBinding binding = getOrFindMembersInjectionBinding(key);
-    if (!binding.injectionSites().isEmpty()) {
-      ClassName membersInjectorName =
-          SourceFiles.membersInjectorNameForMembersInjectionBinding(binding);
-      if (!generatedTypeNames.contains(membersInjectorName)
-          && elements.getTypeElement(membersInjectorName.canonicalName()) == null) {
-        // does not exist.  generate
-        membersInjectorGenerator.generate(binding);
-        messager.printMessage(Kind.NOTE, String.format("Generating a MembersInjector for %s. "
-            + "Prefer to run the dagger processor over that class instead.", key.type()));
-        registerMembersInjectionBinding(binding);
-        generatedTypeNames.add(membersInjectorName);
-      }
-    }
-    return binding;
-  }
-
   MembersInjectionBinding getOrFindMembersInjectionBinding(Key key) {
     checkNotNull(key);
+    // TODO(gak): is checking the kind enough?
     checkArgument(key.isValidMembersInjectionKey());
-    MembersInjectionBinding binding = membersInjectionBindingsByKey.get(key);
+    Binding binding = bindingsByKey.get(key);
     if (binding == null) {
       TypeElement element = MoreElements.asType(types.asElement(key.type()));
-      binding = membersInjectionBindingFactory.forInjectedType(element);
+      binding = registerBinding(membersInjectionBindingFactory.forInjectedType(element), false);
     }
-    return binding;
+    verify(binding instanceof MembersInjectionBinding);
+    return (MembersInjectionBinding) binding;
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/InjectProcessingStep.java
index 06e15bf16..587df5bc7 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectProcessingStep.java
@@ -41,9 +41,7 @@
   private final InjectFieldValidator fieldValidator;
   private final InjectMethodValidator methodValidator;
   private final ProvisionBinding.Factory provisionBindingFactory;
-  private final FactoryGenerator factoryGenerator;
   private final MembersInjectionBinding.Factory membersInjectionBindingFactory;
-  private final MembersInjectorGenerator membersInjectorGenerator;
   private final InjectBindingRegistry injectBindingRegistry;
 
   InjectProcessingStep(Messager messager,
@@ -51,18 +49,14 @@
       InjectFieldValidator fieldValidator,
       InjectMethodValidator methodValidator,
       ProvisionBinding.Factory provisionBindingFactory,
-      FactoryGenerator factoryGenerator,
       MembersInjectionBinding.Factory membersInjectionBindingFactory,
-      MembersInjectorGenerator membersInjectorWriter,
       InjectBindingRegistry factoryRegistrar) {
     this.messager = messager;
     this.constructorValidator = constructorValidator;
     this.fieldValidator = fieldValidator;
     this.methodValidator = methodValidator;
     this.provisionBindingFactory = provisionBindingFactory;
-    this.factoryGenerator = factoryGenerator;
     this.membersInjectionBindingFactory = membersInjectionBindingFactory;
-    this.membersInjectorGenerator = membersInjectorWriter;
     this.injectBindingRegistry = factoryRegistrar;
   }
 
@@ -124,26 +118,12 @@ public Void visitExecutableAsMethod(ExecutableElement methodElement, Void p) {
     }
 
     for (TypeElement injectedType : membersInjectedTypes.build()) {
-      try {
-        MembersInjectionBinding binding =
-            membersInjectionBindingFactory.forInjectedType(injectedType);
-        membersInjectorGenerator.generate(binding);
-        injectBindingRegistry.registerMembersInjectionBinding(binding);
-        injectBindingRegistry.registerGeneratedFile(
-            membersInjectorGenerator.nameGeneratedType(binding));
-      } catch (SourceFileGenerationException e) {
-        e.printMessageTo(messager);
-      }
+      injectBindingRegistry.registerBinding(
+          membersInjectionBindingFactory.forInjectedType(injectedType));
     }
 
     for (ProvisionBinding binding : provisions.build()) {
-      try {
-        factoryGenerator.generate(binding);
-        injectBindingRegistry.registerProvisionBinding(binding);
-        injectBindingRegistry.registerGeneratedFile(factoryGenerator.nameGeneratedType(binding));
-      } catch (SourceFileGenerationException e) {
-        e.printMessageTo(messager);
-      }
+      injectBindingRegistry.registerBinding(binding);
     }
 
     return false;
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
index 98b21c7cd..afa771b36 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
@@ -95,11 +95,14 @@ private int targetIndexInEnclosing(InjectionSite injectionSite)  {
   static final class Factory {
     private final Elements elements;
     private final Types types;
+    private final Key.Factory keyFactory;
     private final DependencyRequest.Factory dependencyRequestFactory;
 
-    Factory(Elements elements, Types types, DependencyRequest.Factory dependencyRequestFactory) {
+    Factory(Elements elements, Types types, Key.Factory keyFactory,
+        DependencyRequest.Factory dependencyRequestFactory) {
       this.elements = checkNotNull(elements);
       this.types = checkNotNull(types);
+      this.keyFactory = checkNotNull(keyFactory);
       this.dependencyRequestFactory = checkNotNull(dependencyRequestFactory);
     }
 
@@ -162,6 +165,7 @@ MembersInjectionBinding forInjectedType(TypeElement typeElement) {
           });
 
       return new AutoValue_MembersInjectionBinding(
+          keyFactory.forMembersInjectedType(typeElement.asType()),
           dependencies,
           new ImmutableSet.Builder<DependencyRequest>()
               .addAll(dependencies)
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
index 9cd1b85cc..6eaa59687 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
@@ -89,10 +89,7 @@
   /** Returns provision type that was used to bind the key. */
   abstract Provides.Type provisionType();
 
-  /** The {@link Key} that is provided by this binding. */
-  abstract Key providedKey();
-
-  /** The scope in which the binding declares the {@link #providedKey()}. */
+  /** The scope in which the binding declares the {@link #key()}. */
   abstract Optional<AnnotationMirror> scope();
 
   /** If this provision requires members injeciton, this will be the corresonding request. */
@@ -239,12 +236,12 @@ ProvisionBinding forInjectConstructor(ExecutableElement constructorElement) {
       Optional<DependencyRequest> membersInjectionRequest = membersInjectionRequest(
           MoreElements.asType(constructorElement.getEnclosingElement()));
       return new AutoValue_ProvisionBinding(
+          key,
           constructorElement,
           dependencies,
           findBindingPackage(key),
           Kind.INJECTION,
           Provides.Type.UNIQUE,
-          key,
           getScopeAnnotation(constructorElement.getEnclosingElement()),
           membersInjectionRequest);
     }
@@ -275,12 +272,12 @@ ProvisionBinding forProvidesMethod(ExecutableElement providesMethod) {
       ImmutableSet<DependencyRequest> dependencies =
           dependencyRequestFactory.forRequiredVariables(providesMethod.getParameters());
       return new AutoValue_ProvisionBinding(
+          key,
           providesMethod,
           dependencies,
           findBindingPackage(key),
           Kind.PROVISION,
           providesAnnotation.type(),
-          key,
           getScopeAnnotation(providesMethod),
           Optional.<DependencyRequest>absent());
     }
@@ -291,12 +288,12 @@ ProvisionBinding forImplicitMapBinding(DependencyRequest explicitRequest,
       checkNotNull(implicitRequest);
       ImmutableSet<DependencyRequest> dependencies = ImmutableSet.of(implicitRequest);
       return new AutoValue_ProvisionBinding(
+          explicitRequest.key(),
           implicitRequest.requestElement(),
           dependencies,
           findBindingPackage(explicitRequest.key()),
           Kind.PROVISION,
           Provides.Type.MAP,
-          explicitRequest.key(),
           getScopeAnnotation(implicitRequest.requestElement()),
           Optional.<DependencyRequest>absent());
     }
@@ -306,12 +303,12 @@ ProvisionBinding forComponent(TypeElement componentDefinitionType) {
       Component componentAnnotation = componentDefinitionType.getAnnotation(Component.class);
       checkArgument(componentAnnotation != null);
       return new AutoValue_ProvisionBinding(
+          keyFactory.forComponent(componentDefinitionType.asType()),
           componentDefinitionType,
           ImmutableSet.<DependencyRequest>of(),
           Optional.<String>absent(),
           Kind.COMPONENT,
           Provides.Type.UNIQUE,
-          keyFactory.forComponent(componentDefinitionType.asType()),
           Optional.<AnnotationMirror>absent(),
           Optional.<DependencyRequest>absent());
     }
@@ -321,12 +318,12 @@ ProvisionBinding forComponentMethod(ExecutableElement componentMethod) {
       checkArgument(componentMethod.getKind().equals(METHOD));
       checkArgument(componentMethod.getParameters().isEmpty());
       return new AutoValue_ProvisionBinding(
+          keyFactory.forComponentMethod(componentMethod),
           componentMethod,
           ImmutableSet.<DependencyRequest>of(),
           Optional.<String>absent(),
           Kind.COMPONENT_PROVISION,
           Provides.Type.UNIQUE,
-          keyFactory.forComponentMethod(componentMethod),
           getScopeAnnotation(componentMethod),
           Optional.<DependencyRequest>absent());
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
index 8506b867b..21d4a3e06 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
@@ -197,7 +197,7 @@
               new KeyVariableNamer().apply(entry.getKey()) + "Provider");
           break;
         case UNIQUE:
-          ProvisionBinding binding = Iterables.getOnlyElement(bindingsForKey);
+          Binding binding = Iterables.getOnlyElement(bindingsForKey);
           providerNames.put(entry.getKey(),
               binding.bindingElement().accept(new ElementKindVisitor6<String, Void>() {
                 @Override
