diff --git a/java/dagger/internal/codegen/DeferredModifiableBindingExpression.java b/java/dagger/internal/codegen/DeferredModifiableBindingExpression.java
index a92015f67..ac529f620 100644
--- a/java/dagger/internal/codegen/DeferredModifiableBindingExpression.java
+++ b/java/dagger/internal/codegen/DeferredModifiableBindingExpression.java
@@ -15,11 +15,13 @@
  */
 
 package dagger.internal.codegen;
+
 import static com.google.common.base.Preconditions.checkNotNull;
 
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
 import dagger.internal.codegen.ModifiableBindingMethods.ModifiableBindingMethod;
 import java.util.Optional;
+import javax.lang.model.type.TypeMirror;
 
 /**
  * A {@link ModifiableAbstractMethodBindingExpression} for a binding that exists but is not ready to
@@ -64,4 +66,9 @@
   String chooseMethodName() {
     return componentImplementation.getUniqueMethodName(request, binding);
   }
+
+  @Override
+  protected TypeMirror contributedType() {
+    return binding.contributedType();
+  }
 }
diff --git a/java/dagger/internal/codegen/MissingBindingExpression.java b/java/dagger/internal/codegen/MissingBindingExpression.java
index 1b414ffdd..c7fa17c13 100644
--- a/java/dagger/internal/codegen/MissingBindingExpression.java
+++ b/java/dagger/internal/codegen/MissingBindingExpression.java
@@ -19,6 +19,7 @@
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
 import dagger.internal.codegen.ModifiableBindingMethods.ModifiableBindingMethod;
 import java.util.Optional;
+import javax.lang.model.type.TypeMirror;
 
 /**
  * A {@link ModifiableAbstractMethodBindingExpression} for a binding that is missing when generating
@@ -51,4 +52,9 @@
   String chooseMethodName() {
     return componentImplementation.getUniqueMethodName(request);
   }
+
+  @Override
+  protected TypeMirror contributedType() {
+    return request.key().type();
+  }
 }
diff --git a/java/dagger/internal/codegen/ModifiableAbstractMethodBindingExpression.java b/java/dagger/internal/codegen/ModifiableAbstractMethodBindingExpression.java
index 2dd875d3b..102094413 100644
--- a/java/dagger/internal/codegen/ModifiableAbstractMethodBindingExpression.java
+++ b/java/dagger/internal/codegen/ModifiableAbstractMethodBindingExpression.java
@@ -39,7 +39,8 @@
   private final ComponentImplementation componentImplementation;
   private final ModifiableBindingType modifiableBindingType;
   private final BindingRequest request;
-  private final TypeMirror returnType;
+  private final Optional<ComponentMethodDescriptor> matchingComponentMethod;
+  private final DaggerTypes types;
   private Optional<String> methodName;
 
   ModifiableAbstractMethodBindingExpression(
@@ -52,7 +53,8 @@
     this.componentImplementation = componentImplementation;
     this.modifiableBindingType = modifiableBindingType;
     this.request = request;
-    this.returnType = returnType(request, matchingComponentMethod, types);
+    this.matchingComponentMethod = matchingComponentMethod;
+    this.types = types;
     this.methodName =
         initializeMethodName(matchingComponentMethod, matchingModifiableBindingMethod);
   }
@@ -78,7 +80,7 @@
   final Expression getDependencyExpression(ClassName requestingClass) {
     addUnimplementedMethod();
     return Expression.create(
-        returnType,
+        returnType(),
         componentImplementation.name().equals(requestingClass)
             ? CodeBlock.of("$N()", methodName.get())
             : CodeBlock.of("$T.this.$N()", componentImplementation.name(), methodName.get()));
@@ -88,6 +90,7 @@ private void addUnimplementedMethod() {
     if (!methodName.isPresent()) {
       // Only add the method once in case of repeated references to the missing binding.
       methodName = Optional.of(chooseMethodName());
+      TypeMirror returnType = returnType();
       componentImplementation.addModifiableBindingMethod(
           modifiableBindingType,
           request,
@@ -112,18 +115,21 @@ private void addUnimplementedMethod() {
    *       from which the request type is not accessible.
    * </ul>
    */
-  private static TypeMirror returnType(
-      BindingRequest bindingRequest,
-      Optional<ComponentMethodDescriptor> matchingComponentMethod,
-      DaggerTypes types) {
+  private TypeMirror returnType() {
     if (matchingComponentMethod.isPresent()) {
       return matchingComponentMethod.get().resolvedReturnType(types);
     }
 
-    TypeMirror requestedType = bindingRequest.requestedType(bindingRequest.key().type(), types);
+    TypeMirror requestedType = request.requestedType(contributedType(), types);
     return types.publiclyAccessibleType(requestedType);
   }
 
+  /**
+   * The {@link ContributionBinding#contributedType() type contributed} by the binding of this
+   * expression. For missing bindings, this will be the key type.
+   */
+  protected abstract TypeMirror contributedType();
+
   /** Returns a unique 'getter' method name for the current component. */
   abstract String chooseMethodName();
 }
diff --git a/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java b/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java
index 59d1f510c..c9e1ab982 100644
--- a/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java
+++ b/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java
@@ -6670,6 +6670,69 @@ public void modifiedProducerFromProvider() {
         .hasSourceEquivalentTo(generatedRoot);
   }
 
+  @Test
+  public void bindsMissingDep_Multibindings() {
+    ImmutableList.Builder<JavaFileObject> filesToCompile = ImmutableList.builder();
+    filesToCompile.add(
+        JavaFileObjects.forSourceLines(
+            "test.LeafModule",
+            "package test;",
+            "",
+            "import dagger.Binds;",
+            "import dagger.Module;",
+            "import dagger.multibindings.IntoSet;",
+            "",
+            "@Module",
+            "interface LeafModule {",
+            "  @Binds",
+            "  @IntoSet",
+            "  CharSequence bindsMultibindingWithMissingDep(String string);",
+            "}"),
+        JavaFileObjects.forSourceLines(
+            "test.Leaf",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "import java.util.Set;",
+            "",
+            "@Subcomponent(modules = LeafModule.class)",
+            "interface Leaf {",
+            "  Set<CharSequence> set();",
+            "}"));
+
+    JavaFileObject generatedLeaf =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerLeaf",
+            "package test;",
+            "",
+            "import com.google.common.collect.ImmutableSet;",
+            "import java.util.Set;",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerLeaf implements Leaf {",
+            "  protected DaggerLeaf() {}",
+            "",
+            "  @Override",
+            "  public Set<CharSequence> set() {",
+            "    return ImmutableSet.<CharSequence>of(getCharSequence());",
+            "  }",
+            "",
+            // The expected output here is subtle: the Key of
+            // LeafModule.bindsMultibindingWithMissingDep() is Set<CharSequence>, but the binding
+            // method should only be returning an individual CharSequence. Otherwise the
+            // ImmutableSet factory method above will fail.
+            // TODO(b/117833324): It would be great to get this method name to match the binding
+            // element name
+            "  protected abstract CharSequence getCharSequence();",
+            "}");
+    Compilation compilation = compile(filesToCompile.build());
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerLeaf")
+        .hasSourceEquivalentTo(generatedLeaf);
+  }
+
   private void createAncillaryClasses(
       ImmutableList.Builder<JavaFileObject> filesBuilder, String... ancillaryClasses) {
     for (String className : ancillaryClasses) {
