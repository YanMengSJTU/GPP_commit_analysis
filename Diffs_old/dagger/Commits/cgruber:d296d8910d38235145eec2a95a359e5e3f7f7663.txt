diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/RequiresSingleton.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/BoundAsSingleton.java
similarity index 69%
rename from compiler/src/it/functional-tests/src/main/java/test/subcomponent/RequiresSingleton.java
rename to compiler/src/it/functional-tests/src/main/java/test/subcomponent/BoundAsSingleton.java
index d7813f1cd..8ae147415 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/RequiresSingleton.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/BoundAsSingleton.java
@@ -15,16 +15,13 @@
  */
 package test.subcomponent;
 
-import javax.inject.Inject;
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import javax.inject.Qualifier;
 
-final class RequiresSingleton {
-  private final SingletonType singletonType;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
-  @Inject RequiresSingleton(SingletonType singletonType) {
-    this.singletonType = singletonType;
-  }
-
-  SingletonType singletonType() {
-    return singletonType;
-  }
-}
+@Documented
+@Retention(RUNTIME)
+@Qualifier
+@interface BoundAsSingleton {}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildComponent.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildComponent.java
index 96e4bcb1f..67d66cae9 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildComponent.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildComponent.java
@@ -23,7 +23,7 @@
 interface ChildComponent {
   Provider<UnscopedType> getUnscopedTypeProvider();
 
-  RequiresSingleton requiresSingleton();
+  RequiresSingletons requiresSingleton();
 
   Set<Object> objectSet();
 
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/GrandchildComponent.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/GrandchildComponent.java
index 388d66960..9ed4c714a 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/GrandchildComponent.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/GrandchildComponent.java
@@ -23,7 +23,7 @@
 interface GrandchildComponent {
   Provider<UnscopedType> getUnscopedTypeProvider();
 
-  RequiresSingleton requiresSingleton();
+  RequiresSingletons requiresSingleton();
 
   Set<Object> objectSet();
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentComponent.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentComponent.java
index ec9a79941..ed4e6f0e8 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentComponent.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentComponent.java
@@ -25,8 +25,6 @@
 interface ParentComponent {
   Provider<UnscopedType> getUnscopedTypeProvider();
 
-  SingletonType getSingletonType();
-
   Set<Object> objectSet();
 
   ChildComponent newChildComponent();
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentModule.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentModule.java
index 3ac07b086..dbe1a534a 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentModule.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentModule.java
@@ -38,4 +38,9 @@
       }
     };
   }
+
+  @Provides @Singleton @BoundAsSingleton UnscopedType provideUnscopedTypeBoundAsSingleton(
+      UnscopedType unscopedType) {
+    return unscopedType;
+  }
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/RequiresSingletons.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/RequiresSingletons.java
new file mode 100644
index 000000000..2d4053824
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/RequiresSingletons.java
@@ -0,0 +1,37 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.subcomponent;
+
+import javax.inject.Inject;
+
+final class RequiresSingletons {
+  private final SingletonType singletonType;
+  private final UnscopedType unscopedTypeBoundAsSingleton;
+
+  @Inject RequiresSingletons(SingletonType singletonType,
+      @BoundAsSingleton UnscopedType unscopedTypeBoundAsSingleton) {
+    this.singletonType = singletonType;
+    this.unscopedTypeBoundAsSingleton = unscopedTypeBoundAsSingleton;
+  }
+
+  SingletonType singletonType() {
+    return singletonType;
+  }
+
+  UnscopedType unscopedTypeBoundAsSingleton() {
+    return unscopedTypeBoundAsSingleton;
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/test/java/test/subcomponent/SubcomponentScopeTest.java b/compiler/src/it/functional-tests/src/test/java/test/subcomponent/SubcomponentScopeTest.java
index 3f75547ce..4e897ff72 100644
--- a/compiler/src/it/functional-tests/src/test/java/test/subcomponent/SubcomponentScopeTest.java
+++ b/compiler/src/it/functional-tests/src/test/java/test/subcomponent/SubcomponentScopeTest.java
@@ -26,15 +26,26 @@
 @RunWith(JUnit4.class)
 public class SubcomponentScopeTest {
   @Test
-  public void singletonPropagatesUpward() {
+  public void scopePropagatesUpward_class() {
     ParentComponent parentComponent = Dagger_ParentComponent.create();
-    SingletonType singletonType = parentComponent.getSingletonType();
     assertThat(parentComponent.newChildComponent().requiresSingleton().singletonType())
-        .isSameAs(singletonType);
+        .isSameAs(parentComponent.newChildComponent().requiresSingleton().singletonType());
+    assertThat(parentComponent.newChildComponent().requiresSingleton().singletonType())
+        .isSameAs(parentComponent.newChildComponent()
+            .newGrandchildComponent().requiresSingleton().singletonType());
+  }
+
+  @Test
+  public void scopePropagatesUpward_provides() {
+    ParentComponent parentComponent = Dagger_ParentComponent.create();
+    assertThat(parentComponent.newChildComponent()
+        .requiresSingleton().unscopedTypeBoundAsSingleton())
+            .isSameAs(parentComponent.newChildComponent()
+                .requiresSingleton().unscopedTypeBoundAsSingleton());
     assertThat(parentComponent.newChildComponent()
-        .newGrandchildComponent()
-        .requiresSingleton().singletonType())
-            .isSameAs(singletonType);
+        .requiresSingleton().unscopedTypeBoundAsSingleton())
+            .isSameAs(parentComponent.newChildComponent().newGrandchildComponent()
+                .requiresSingleton().unscopedTypeBoundAsSingleton());
   }
 
   @Test
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
index 94f72ec1e..dde9f2823 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
@@ -26,6 +26,7 @@
 import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
 import com.google.common.collect.Queues;
+import com.google.common.collect.Sets;
 import dagger.Component;
 import dagger.Provides;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodType;
@@ -35,6 +36,7 @@
 import java.util.List;
 import java.util.Map;
 import java.util.Map.Entry;
+import java.util.Set;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
@@ -71,11 +73,35 @@
   @AutoValue
   abstract static class ResolvedBindings {
     abstract BindingKey bindingKey();
-    abstract ImmutableSet<? extends Binding> bindings();
+    abstract ImmutableSet<? extends Binding> ownedBindings();
+    abstract ImmutableSet<? extends Binding> inheritedBindings();
+
+    ImmutableSet<? extends Binding> bindings() {
+      return new ImmutableSet.Builder<Binding>()
+          .addAll(inheritedBindings())
+          .addAll(ownedBindings())
+          .build();
+    }
+
+    static ResolvedBindings create(
+        BindingKey bindingKey,
+        Set<? extends Binding> ownedBindings,
+        Set<? extends Binding> inheritedBindings) {
+      return new AutoValue_BindingGraph_ResolvedBindings(
+          bindingKey, ImmutableSet.copyOf(ownedBindings), ImmutableSet.copyOf(inheritedBindings));
+    }
 
     static ResolvedBindings create(
-        BindingKey bindingKey, ImmutableSet<? extends Binding> bindings) {
-      return new AutoValue_BindingGraph_ResolvedBindings(bindingKey, bindings);
+        BindingKey bindingKey,
+        Binding... ownedBindings) {
+      return new AutoValue_BindingGraph_ResolvedBindings(
+          bindingKey, ImmutableSet.copyOf(ownedBindings), ImmutableSet.<Binding>of());
+    }
+
+    @SuppressWarnings("unchecked")  // checked by validator
+    ImmutableSet<? extends ContributionBinding> ownedContributionBindings() {
+      checkState(bindingKey().kind().equals(BindingKey.Kind.CONTRIBUTION));
+      return (ImmutableSet<? extends ContributionBinding>) ownedBindings();
     }
 
     @SuppressWarnings("unchecked")  // checked by validator
@@ -270,8 +296,7 @@ private BindingGraph create(Optional<RequestResolver> parentResolver,
        *  event that the binding is owned by a parent component it will trigger resolution in that
        *  component's resolver but will return an {@link Optional#absent} value.
        */
-      Optional<? extends ImmutableSet<? extends Binding>> lookUpBindings(
-          DependencyRequest request) {
+      ResolvedBindings lookUpBindings(DependencyRequest request) {
         BindingKey bindingKey = BindingKey.forDependencyRequest(request);
         switch (bindingKey.kind()) {
           case CONTRIBUTION:
@@ -299,27 +324,39 @@ private BindingGraph create(Optional<RequestResolver> parentResolver,
                 || !explicitProductionBindingsForKey.isEmpty()) {
               // we have some explicit binding for this key, so we collect all explicit implicit map
               // bindings that might conflict with this and let the validator sort it out
-              return Optional.of(ImmutableSet.<ContributionBinding>builder()
-                  .addAll(explicitProvisionBindingsForKey)
-                  .addAll(explicitMapProvisionBindings)
-                  .addAll(explicitProductionBindingsForKey)
-                  .addAll(explicitMapProductionBindings)
-                  .build());
+              ImmutableSet.Builder<ContributionBinding> ownedBindings = ImmutableSet.builder();
+              ImmutableSet.Builder<ContributionBinding> inheritedBindings = ImmutableSet.builder();
+              for (ProvisionBinding provisionBinding :
+                  Sets.union(explicitProvisionBindingsForKey, explicitMapProvisionBindings)) {
+                Optional<RequestResolver> owningResolver = getOwningResolver(provisionBinding);
+                if (owningResolver.isPresent() && !owningResolver.get().equals(this)) {
+                  owningResolver.get().resolve(request);
+                  inheritedBindings.add(provisionBinding);
+                } else {
+                  ownedBindings.add(provisionBinding);
+                }
+              }
+              return ResolvedBindings.create(bindingKey,
+                  ownedBindings
+                      .addAll(explicitProductionBindingsForKey)
+                      .addAll(explicitMapProductionBindings)
+                      .build(),
+                  inheritedBindings.build());
             } else {
               if (!explicitMapProductionBindings.isEmpty()) {
                 // if we have any explicit Map<K, Producer<V>> bindings, then this Map<K, V> binding
                 // must be considered an implicit ProductionBinding
                 DependencyRequest implicitRequest =
                     dependencyRequestFactory.forImplicitMapBinding(request, mapProducerKey.get());
-                return Optional.of(ImmutableSet.of(productionBindingFactory.forImplicitMapBinding(
-                    request, implicitRequest)));
+                return ResolvedBindings.create(bindingKey,
+                    productionBindingFactory.forImplicitMapBinding(request, implicitRequest));
               } else if (!explicitMapProvisionBindings.isEmpty()) {
                 // if there are Map<K, Provider<V>> bindings, then it'll be an implicit
                 // ProvisionBinding
                 DependencyRequest implicitRequest =
                     dependencyRequestFactory.forImplicitMapBinding(request, mapProviderKey.get());
-                return Optional.of(ImmutableSet.of(provisionBindingFactory.forImplicitMapBinding(
-                    request, implicitRequest)));
+                return ResolvedBindings.create(bindingKey,
+                    provisionBindingFactory.forImplicitMapBinding(request, implicitRequest));
               } else {
                 // no explicit binding, look it up.
                 Optional<ProvisionBinding> provisionBinding =
@@ -329,15 +366,19 @@ private BindingGraph create(Optional<RequestResolver> parentResolver,
                       getOwningResolver(provisionBinding.get());
                   if (owningResolver.isPresent() && !owningResolver.get().equals(this)) {
                     owningResolver.get().resolve(request);
-                    return Optional.absent();
+                    return ResolvedBindings.create(
+                        bindingKey, ImmutableSet.<Binding>of(),
+                        provisionBinding.asSet());
                   }
                 }
-                return Optional.of(ImmutableSet.copyOf(provisionBinding.asSet()));
+                return ResolvedBindings.create(
+                    bindingKey, provisionBinding.asSet(), ImmutableSet.<Binding>of());
               }
             }
           case MEMBERS_INJECTION:
             // no explicit deps for members injection, so just look it up
-            return Optional.of(ImmutableSet.of(rollUpMembersInjectionBindings(bindingKey.key())));
+            return ResolvedBindings.create(
+                bindingKey, rollUpMembersInjectionBindings(bindingKey.key()));
           default:
             throw new AssertionError();
         }
@@ -430,15 +471,13 @@ void resolve(DependencyRequest request) {
 
         cycleStack.push(bindingKey);
         try {
-          Optional<? extends ImmutableSet<? extends Binding>> bindings = lookUpBindings(request);
-          if (bindings.isPresent()) {
-            for (Binding binding : bindings.get()) {
-              for (DependencyRequest dependency : binding.implicitDependencies()) {
-                resolve(dependency);
-              }
+          ResolvedBindings bindings = lookUpBindings(request);
+          for (Binding binding : bindings.ownedBindings()) {
+            for (DependencyRequest dependency : binding.implicitDependencies()) {
+              resolve(dependency);
             }
-            resolvedBindings.put(bindingKey, ResolvedBindings.create(bindingKey, bindings.get()));
           }
+          resolvedBindings.put(bindingKey, bindings);
         } finally {
           cycleStack.pop();
         }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
index 187b71e7d..f8ffb17dd 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
@@ -474,129 +474,155 @@ private void writeFields(BindingGraph input,
       Map<ContributionBinding, Snippet> parentMultibindingContributionSnippetsBuilder,
       Map<ContributionBinding, Snippet> multibindingContributionSnippetsBuilder,
       ImmutableSet.Builder<BindingKey> enumBindingKeysBuilder,
-      Map<String, ProxyClassAndField> packageProxies) throws AssertionError {
+      Map<String, ProxyClassAndField> packageProxies) {
     for (ResolvedBindings resolvedBindings : input.resolvedBindings().values()) {
-      BindingKey bindingKey = resolvedBindings.bindingKey();
-
-      if (resolvedBindings.bindings().size() == 1) {
-        if (bindingKey.kind().equals(BindingKey.Kind.CONTRIBUTION)) {
-          ContributionBinding contributionBinding =
-              Iterables.getOnlyElement(resolvedBindings.contributionBindings());
-          if (contributionBinding instanceof ProvisionBinding) {
-            ProvisionBinding provisionBinding = (ProvisionBinding) contributionBinding;
-            if (provisionBinding.factoryCreationStrategy().equals(ENUM_INSTANCE)
-                && !provisionBinding.scope().isPresent()) {
-              enumBindingKeysBuilder.add(bindingKey);
-              // skip keys whose factories are enum instances and aren't scoped
-              memberSelectSnippetsBuilder.put(bindingKey,
-                  MemberSelect.staticSelect(
-                      factoryNameForProvisionBinding(provisionBinding),
-                      Snippet.format("create()")));
-              continue;
-            }
-          }
-        } else if (bindingKey.kind().equals(BindingKey.Kind.MEMBERS_INJECTION)) {
-          MembersInjectionBinding membersInjectionBinding =
-              Iterables.getOnlyElement(resolvedBindings.membersInjectionBindings());
-          if (membersInjectionBinding.injectionStrategy().equals(NO_OP)) {
-            // TODO(gak): refactor to use enumBindingKeys throughout the generator
+      writeField(
+          componentWriter,
+          proxyWriters,
+          memberSelectSnippetsBuilder,
+          parentMultibindingContributionSnippetsBuilder,
+          multibindingContributionSnippetsBuilder,
+          enumBindingKeysBuilder,
+          packageProxies,
+          resolvedBindings);
+    }
+  }
+
+  private void writeField(
+      ClassWriter componentWriter,
+      Set<JavaWriter> proxyWriters,
+      Map<BindingKey, MemberSelect> memberSelectSnippetsBuilder,
+      Map<ContributionBinding, Snippet> parentMultibindingContributionSnippetsBuilder,
+      Map<ContributionBinding, Snippet> multibindingContributionSnippetsBuilder,
+      ImmutableSet.Builder<BindingKey> enumBindingKeysBuilder,
+      Map<String, ProxyClassAndField> packageProxies, ResolvedBindings resolvedBindings) {
+    BindingKey bindingKey = resolvedBindings.bindingKey();
+
+    if (bindingKey.kind().equals(BindingKey.Kind.CONTRIBUTION)
+        && resolvedBindings.ownedContributionBindings().isEmpty()
+        && !ContributionBinding.bindingTypeFor(resolvedBindings.contributionBindings())
+            .isMultibinding()) {
+      return;
+    }
+
+    if (resolvedBindings.bindings().size() == 1) {
+      if (bindingKey.kind().equals(BindingKey.Kind.CONTRIBUTION)) {
+        ContributionBinding contributionBinding =
+            Iterables.getOnlyElement(resolvedBindings.contributionBindings());
+        if (contributionBinding instanceof ProvisionBinding) {
+          ProvisionBinding provisionBinding = (ProvisionBinding) contributionBinding;
+          if (provisionBinding.factoryCreationStrategy().equals(ENUM_INSTANCE)
+              && !provisionBinding.scope().isPresent()) {
             enumBindingKeysBuilder.add(bindingKey);
-            // TODO(gak): suppress the warnings in a reasonable place
+            // skip keys whose factories are enum instances and aren't scoped
             memberSelectSnippetsBuilder.put(bindingKey,
-                MemberSelect.staticMethodInvocationWithCast(
-                    ClassName.fromClass(MembersInjectors.class),
-                    Snippet.format("noOp()"),
-                    ClassName.fromClass(MembersInjector.class)));
-            continue;
+                MemberSelect.staticSelect(
+                    factoryNameForProvisionBinding(provisionBinding),
+                    Snippet.format("create()")));
+            return;
           }
         }
+      } else if (bindingKey.kind().equals(BindingKey.Kind.MEMBERS_INJECTION)) {
+        MembersInjectionBinding membersInjectionBinding =
+            Iterables.getOnlyElement(resolvedBindings.membersInjectionBindings());
+        if (membersInjectionBinding.injectionStrategy().equals(NO_OP)) {
+          // TODO(gak): refactor to use enumBindingKeys throughout the generator
+          enumBindingKeysBuilder.add(bindingKey);
+          // TODO(gak): suppress the warnings in a reasonable place
+          memberSelectSnippetsBuilder.put(bindingKey,
+              MemberSelect.staticMethodInvocationWithCast(
+                  ClassName.fromClass(MembersInjectors.class),
+                  Snippet.format("noOp()"),
+                  ClassName.fromClass(MembersInjector.class)));
+          return;
+        }
       }
+    }
 
-      String bindingPackage = bindingPackageFor(resolvedBindings.bindings())
-          .or(componentWriter.name().packageName());
+    String bindingPackage = bindingPackageFor(resolvedBindings.bindings())
+        .or(componentWriter.name().packageName());
 
-      final Optional<String> proxySelector;
-      final TypeWriter classWithFields;
-      final Set<Modifier> fieldModifiers;
+    final Optional<String> proxySelector;
+    final TypeWriter classWithFields;
+    final Set<Modifier> fieldModifiers;
 
-      if (bindingPackage.equals(componentWriter.name().packageName())) {
-        // no proxy
-        proxySelector = Optional.absent();
-        // component gets the fields
-        classWithFields = componentWriter;
-        // private fields
-        fieldModifiers = EnumSet.of(PRIVATE);
-      } else {
-        // get or create the proxy
-        ProxyClassAndField proxyClassAndField = packageProxies.get(bindingPackage);
-        if (proxyClassAndField == null) {
-          JavaWriter proxyJavaWriter = JavaWriter.inPackage(bindingPackage);
-          proxyWriters.add(proxyJavaWriter);
-          ClassWriter proxyWriter =
-              proxyJavaWriter.addClass(componentWriter.name().simpleName() + "__PackageProxy");
-          proxyWriter.annotate(Generated.class)
-              .setValue(ComponentProcessor.class.getCanonicalName());
-          proxyWriter.addModifiers(PUBLIC, FINAL);
-          // create the field for the proxy in the component
-          FieldWriter proxyFieldWriter =
-              componentWriter.addField(proxyWriter.name(),
-                  bindingPackage.replace('.', '_') + "_Proxy");
-          proxyFieldWriter.addModifiers(PRIVATE, FINAL);
-          proxyFieldWriter.setInitializer("new %s()", proxyWriter.name());
-          proxyClassAndField = ProxyClassAndField.create(proxyWriter, proxyFieldWriter);
-          packageProxies.put(bindingPackage, proxyClassAndField);
-        }
-        // add the field for the member select
-        proxySelector = Optional.of(proxyClassAndField.proxyFieldWriter().name());
-        // proxy gets the fields
-        classWithFields = proxyClassAndField.proxyWriter();
-        // public fields in the proxy
-        fieldModifiers = EnumSet.of(PUBLIC);
+    if (bindingPackage.equals(componentWriter.name().packageName())) {
+      // no proxy
+      proxySelector = Optional.absent();
+      // component gets the fields
+      classWithFields = componentWriter;
+      // private fields
+      fieldModifiers = EnumSet.of(PRIVATE);
+    } else {
+      // get or create the proxy
+      ProxyClassAndField proxyClassAndField = packageProxies.get(bindingPackage);
+      if (proxyClassAndField == null) {
+        JavaWriter proxyJavaWriter = JavaWriter.inPackage(bindingPackage);
+        proxyWriters.add(proxyJavaWriter);
+        ClassWriter proxyWriter =
+            proxyJavaWriter.addClass(componentWriter.name().simpleName() + "__PackageProxy");
+        proxyWriter.annotate(Generated.class)
+            .setValue(ComponentProcessor.class.getCanonicalName());
+        proxyWriter.addModifiers(PUBLIC, FINAL);
+        // create the field for the proxy in the component
+        FieldWriter proxyFieldWriter =
+            componentWriter.addField(proxyWriter.name(),
+                bindingPackage.replace('.', '_') + "_Proxy");
+        proxyFieldWriter.addModifiers(PRIVATE, FINAL);
+        proxyFieldWriter.setInitializer("new %s()", proxyWriter.name());
+        proxyClassAndField = ProxyClassAndField.create(proxyWriter, proxyFieldWriter);
+        packageProxies.put(bindingPackage, proxyClassAndField);
       }
+      // add the field for the member select
+      proxySelector = Optional.of(proxyClassAndField.proxyFieldWriter().name());
+      // proxy gets the fields
+      classWithFields = proxyClassAndField.proxyWriter();
+      // public fields in the proxy
+      fieldModifiers = EnumSet.of(PUBLIC);
+    }
 
-      if (bindingKey.kind().equals(BindingKey.Kind.CONTRIBUTION)) {
-        ImmutableSet<? extends ContributionBinding> contributionBindings =
-            resolvedBindings.contributionBindings();
-        if (ContributionBinding.bindingTypeFor(contributionBindings).isMultibinding()) {
-          // note that here we rely on the order of the resolved bindings being from parent to child
-          // otherwise, the numbering wouldn't work
-          int contributionNumber = 0;
-          for (ContributionBinding contributionBinding : contributionBindings) {
-            if (!contributionBinding.isSyntheticBinding()) {
-              contributionNumber++;
-              if (!parentMultibindingContributionSnippetsBuilder.containsKey(contributionBinding)) {
-                FrameworkField contributionBindingField =
-                    frameworkFieldForSyntheticContributionBinding(
-                          bindingKey, contributionNumber, contributionBinding);
-                FieldWriter contributionField = classWithFields.addField(
-                    contributionBindingField.frameworkType(), contributionBindingField.name());
-                contributionField.addModifiers(fieldModifiers);
-
-                ImmutableList<String> contributionSelectTokens = new ImmutableList.Builder<String>()
-                    .addAll(proxySelector.asSet())
-                    .add(contributionField.name())
-                    .build();
-                multibindingContributionSnippetsBuilder.put(contributionBinding,
-                    Snippet.memberSelectSnippet(contributionSelectTokens));
-              }
+    if (bindingKey.kind().equals(BindingKey.Kind.CONTRIBUTION)) {
+      ImmutableSet<? extends ContributionBinding> contributionBindings =
+          resolvedBindings.contributionBindings();
+      if (ContributionBinding.bindingTypeFor(contributionBindings).isMultibinding()) {
+        // note that here we rely on the order of the resolved bindings being from parent to child
+        // otherwise, the numbering wouldn't work
+        int contributionNumber = 0;
+        for (ContributionBinding contributionBinding : contributionBindings) {
+          if (!contributionBinding.isSyntheticBinding()) {
+            contributionNumber++;
+            if (!parentMultibindingContributionSnippetsBuilder.containsKey(contributionBinding)) {
+              FrameworkField contributionBindingField =
+                  frameworkFieldForSyntheticContributionBinding(
+                        bindingKey, contributionNumber, contributionBinding);
+              FieldWriter contributionField = classWithFields.addField(
+                  contributionBindingField.frameworkType(), contributionBindingField.name());
+              contributionField.addModifiers(fieldModifiers);
+
+              ImmutableList<String> contributionSelectTokens = new ImmutableList.Builder<String>()
+                  .addAll(proxySelector.asSet())
+                  .add(contributionField.name())
+                  .build();
+              multibindingContributionSnippetsBuilder.put(contributionBinding,
+                  Snippet.memberSelectSnippet(contributionSelectTokens));
             }
           }
         }
       }
-
-      FrameworkField bindingField = frameworkFieldForResolvedBindings(resolvedBindings);
-      FieldWriter frameworkField =
-          classWithFields.addField(bindingField.frameworkType(), bindingField.name());
-      frameworkField.addModifiers(fieldModifiers);
-
-      ImmutableList<String> memberSelectTokens = new ImmutableList.Builder<String>()
-          .addAll(proxySelector.asSet())
-          .add(frameworkField.name())
-          .build();
-      memberSelectSnippetsBuilder.put(bindingKey, MemberSelect.instanceSelect(
-          componentWriter.name(),
-          Snippet.memberSelectSnippet(memberSelectTokens)));
     }
+
+    FrameworkField bindingField = frameworkFieldForResolvedBindings(resolvedBindings);
+    FieldWriter frameworkField =
+        classWithFields.addField(bindingField.frameworkType(), bindingField.name());
+    frameworkField.addModifiers(fieldModifiers);
+
+    ImmutableList<String> memberSelectTokens = new ImmutableList.Builder<String>()
+        .addAll(proxySelector.asSet())
+        .add(frameworkField.name())
+        .build();
+    memberSelectSnippetsBuilder.put(bindingKey, MemberSelect.instanceSelect(
+        componentWriter.name(),
+        Snippet.memberSelectSnippet(memberSelectTokens)));
   }
 
   private void writeInterfaceMethods(BindingGraph input, ClassWriter componentWriter,
@@ -686,10 +712,11 @@ private void initializeFrameworkTypes(BindingGraph input,
       for (BindingKey bindingKey : partitions.get(i)) {
         Snippet memberSelectSnippet =
             memberSelectSnippets.get(bindingKey).getSnippetFor(componentWriter.name());
+        ResolvedBindings resolvedBindings = input.resolvedBindings().get(bindingKey);
         switch (bindingKey.kind()) {
           case CONTRIBUTION:
             ImmutableSet<? extends ContributionBinding> bindings =
-                input.resolvedBindings().get(bindingKey).contributionBindings();
+                resolvedBindings.contributionBindings();
 
             switch (ContributionBinding.bindingTypeFor(bindings)) {
               case SET:
@@ -751,29 +778,31 @@ private void initializeFrameworkTypes(BindingGraph input,
                 }
                 break;
               case UNIQUE:
-                ContributionBinding binding = Iterables.getOnlyElement(bindings);
-                if (binding instanceof ProvisionBinding) {
-                  ProvisionBinding provisionBinding = (ProvisionBinding) binding;
-                  if (!provisionBinding.factoryCreationStrategy().equals(ENUM_INSTANCE)
-                      || provisionBinding.scope().isPresent()) {
+                if (!resolvedBindings.ownedContributionBindings().isEmpty()) {
+                  ContributionBinding binding = Iterables.getOnlyElement(bindings);
+                  if (binding instanceof ProvisionBinding) {
+                    ProvisionBinding provisionBinding = (ProvisionBinding) binding;
+                    if (!provisionBinding.factoryCreationStrategy().equals(ENUM_INSTANCE)
+                        || provisionBinding.scope().isPresent()) {
+                      initializeMethod.body().addSnippet("this.%s = %s;",
+                          memberSelectSnippet,
+                          initializeFactoryForProvisionBinding(provisionBinding,
+                              componentWriter.name(),
+                              input.componentDescriptor().dependencyMethodIndex(),
+                              componentContributionFields, memberSelectSnippets));
+                    }
+                  } else if (binding instanceof ProductionBinding) {
+                    ProductionBinding productionBinding = (ProductionBinding) binding;
                     initializeMethod.body().addSnippet("this.%s = %s;",
                         memberSelectSnippet,
-                        initializeFactoryForProvisionBinding(provisionBinding,
+                        initializeFactoryForProductionBinding(productionBinding,
+                            input,
                             componentWriter.name(),
                             input.componentDescriptor().dependencyMethodIndex(),
                             componentContributionFields, memberSelectSnippets));
+                  } else {
+                    throw new AssertionError();
                   }
-                } else if (binding instanceof ProductionBinding) {
-                  ProductionBinding productionBinding = (ProductionBinding) binding;
-                  initializeMethod.body().addSnippet("this.%s = %s;",
-                      memberSelectSnippet,
-                      initializeFactoryForProductionBinding(productionBinding,
-                          input,
-                          componentWriter.name(),
-                          input.componentDescriptor().dependencyMethodIndex(),
-                          componentContributionFields, memberSelectSnippets));
-                } else {
-                  throw new AssertionError();
                 }
                 break;
               default:
@@ -782,7 +811,7 @@ private void initializeFrameworkTypes(BindingGraph input,
             break;
           case MEMBERS_INJECTION:
             MembersInjectionBinding binding = Iterables.getOnlyElement(
-                input.resolvedBindings().get(bindingKey).membersInjectionBindings());
+                resolvedBindings.membersInjectionBindings());
             if (!binding.injectionStrategy().equals(MembersInjectionBinding.Strategy.NO_OP)) {
               initializeMethod.body().addSnippet("this.%s = %s;",
                   memberSelectSnippet,
