diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
index 1ae4a0724..bf5c18465 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
@@ -20,27 +20,32 @@
 import com.google.common.base.Functions;
 import com.google.common.base.Joiner;
 import com.google.common.base.Optional;
-import com.google.common.collect.Collections2;
 import com.google.common.collect.ImmutableBiMap;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ImmutableSetMultimap;
-import com.google.common.collect.ImmutableSortedSet;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
-import com.google.common.collect.Sets;
-import com.squareup.javawriter.JavaWriter;
 import dagger.Component;
 import dagger.MembersInjector;
 import dagger.internal.InstanceFactory;
 import dagger.internal.ScopedProvider;
 import dagger.internal.SetFactory;
-import java.io.IOException;
-import java.util.EnumSet;
+import dagger.internal.codegen.writer.ClassName;
+import dagger.internal.codegen.writer.ClassWriter;
+import dagger.internal.codegen.writer.ConstructorWriter;
+import dagger.internal.codegen.writer.FieldWriter;
+import dagger.internal.codegen.writer.JavaWriter;
+import dagger.internal.codegen.writer.MethodWriter;
+import dagger.internal.codegen.writer.ParameterizedTypeName;
+import dagger.internal.codegen.writer.Snippet;
+import dagger.internal.codegen.writer.StringLiteral;
+import dagger.internal.codegen.writer.TypeName;
+import dagger.internal.codegen.writer.TypeReferences;
+import dagger.internal.codegen.writer.VoidName;
 import java.util.List;
-import java.util.Map;
 import java.util.Map.Entry;
 import java.util.Set;
 import javax.annotation.Generated;
@@ -48,31 +53,19 @@
 import javax.inject.Provider;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.Modifier;
 import javax.lang.model.element.Name;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
-import javax.lang.model.type.TypeKind;
-import javax.lang.model.type.TypeMirror;
-import javax.lang.model.util.Elements;
-import javax.lang.model.util.Types;
 
 import static com.google.common.base.CaseFormat.LOWER_CAMEL;
-import static com.google.common.base.Preconditions.checkNotNull;
-import static com.squareup.javawriter.JavaWriter.stringLiteral;
-import static dagger.Provides.Type.SET;
-import static dagger.Provides.Type.SET_VALUES;
 import static dagger.internal.codegen.DependencyRequest.Kind.MEMBERS_INJECTOR;
 import static dagger.internal.codegen.ProvisionBinding.Kind.COMPONENT;
 import static dagger.internal.codegen.ProvisionBinding.Kind.PROVISION;
-import static dagger.internal.codegen.SourceFiles.collectImportsFromDependencies;
 import static dagger.internal.codegen.SourceFiles.factoryNameForProvisionBinding;
-import static dagger.internal.codegen.SourceFiles.flattenVariableMap;
+import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
 import static dagger.internal.codegen.SourceFiles.generateMembersInjectorNamesForBindings;
 import static dagger.internal.codegen.SourceFiles.generateProviderNamesForBindings;
 import static dagger.internal.codegen.SourceFiles.membersInjectorNameForMembersInjectionBinding;
-import static dagger.internal.codegen.SourceFiles.providerUsageStatement;
-import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.PUBLIC;
@@ -85,14 +78,10 @@
  * @since 2.0
  */
 final class ComponentGenerator extends SourceFileGenerator<ComponentDescriptor> {
-  private final Elements elements;
-  private final Types types;
   private final Key.Factory keyFactory;
 
-  ComponentGenerator(Filer filer, Elements elements, Types types, Key.Factory keyFactory) {
+  ComponentGenerator(Filer filer, Key.Factory keyFactory) {
     super(filer);
-    this.elements = checkNotNull(elements);
-    this.types = checkNotNull(types);
     this.keyFactory = keyFactory;
   }
 
@@ -115,15 +104,13 @@ ClassName nameGeneratedType(ComponentDescriptor input) {
   }
 
   @Override
-  void write(ClassName componentName, JavaWriter writer, ComponentDescriptor input)
-      throws IOException {
-    writer.emitPackage(componentName.packageName());
+  JavaWriter write(ClassName componentName, ComponentDescriptor input)  {
+    JavaWriter writer = JavaWriter.inPackage(componentName.packageName());
 
-    writeImports(writer, componentName, input);
-
-    writer.emitAnnotation(Generated.class, stringLiteral(ComponentProcessor.class.getName()));
-    writer.beginType(componentName.simpleName(), "class", EnumSet.of(PUBLIC, FINAL), null,
-        input.componentDefinitionType().getQualifiedName().toString());
+    ClassWriter componentWriter = writer.addClass(componentName.simpleName());
+    componentWriter.annotate(Generated.class).setValue(ComponentProcessor.class.getCanonicalName());
+    componentWriter.addModifiers(PUBLIC, FINAL);
+    componentWriter.addImplementedType(input.componentDefinitionType());
 
     ImmutableSetMultimap<Key, ProvisionBinding> resolvedProvisionBindings =
         input.resolvedProvisionBindings();
@@ -144,138 +131,67 @@ void write(ClassName componentName, JavaWriter writer, ComponentDescriptor input
               }
             })));
 
-    writeModuleFields(writer, moduleNames);
-    writeProviderFields(writer, providerNames);
-    writeMembersInjectorFields(writer, membersInjectorNames);
-
-    writeConstructor(writer, input.initializationOrdering(), resolvedProvisionBindings,
-        resolvedMembersInjectionBindings, providerNames, moduleNames, membersInjectorNames);
-
-    writeInterfaceMethods(writer, input.interfaceRequests(), providerNames, membersInjectorNames);
-
-    writer.endType();
-  }
-
-  private void writeImports(JavaWriter writer, ClassName factoryClassName,
-      ComponentDescriptor input) throws IOException {
-
-    ImmutableSortedSet.Builder<ClassName> importsBuilder =
-        ImmutableSortedSet.<ClassName>naturalOrder()
-            .addAll(collectImportsFromDependencies(factoryClassName, input.interfaceRequests()))
-            .add(ClassName.fromClass(Generated.class))
-            .add(ClassName.fromClass(Provider.class));
-
-    ClassName componentClassName = ClassName.fromTypeElement(input.componentDefinitionType());
-    if (!componentClassName.enclosingSimpleNames().isEmpty()) {
-      importsBuilder.add(componentClassName);
-    }
-
-    for (ProvisionBinding binding : input.resolvedProvisionBindings().values()) {
-      if (binding.scope().isPresent()) {
-        importsBuilder.add(ClassName.fromClass(ScopedProvider.class));
-      }
-      if (binding.bindingKind().equals(COMPONENT)) {
-        importsBuilder.add(ClassName.fromClass(InstanceFactory.class));
-      }
-      if (binding.provisionType().equals(SET) || binding.provisionType().equals(SET_VALUES)) {
-        importsBuilder.add(ClassName.fromClass(SetFactory.class));
-      }
-      if (binding.requiresMemberInjection()) {
-        importsBuilder.add(ClassName.fromClass(MembersInjector.class));
-      }
-      for (TypeElement referencedType : MoreTypes.referencedTypes(binding.providedKey().type())) {
-        ClassName className = ClassName.fromTypeElement(referencedType);
-        if (!className.packageName().equals("java.lang")
-            && !className.packageName().equals(factoryClassName.packageName()))
-          importsBuilder.add(className);
-      }
-    }
-
-    writer.emitImports(Collections2.transform(importsBuilder.build(), Functions.toStringFunction()))
-        .emitEmptyLine();
-  }
+    ConstructorWriter constructorWriter = componentWriter.addConstructor();
+    constructorWriter.addModifiers(PUBLIC);
+    for (Entry<TypeElement, String> entry : moduleNames.entrySet()) {
+      componentWriter.addField(entry.getKey(), entry.getValue())
+          .addModifiers(PRIVATE, FINAL);
+      constructorWriter.addParameter(entry.getKey(), entry.getValue());
+      constructorWriter.body()
+          .addSnippet("if (%s == null) {", entry.getValue())
+          .addSnippet("  throw new NullPointerException(%s);",
+              StringLiteral.forValue(entry.getValue()))
+          .addSnippet("}")
+          .addSnippet("this.%1$s = %1$s;", entry.getValue());
 
-  private void writeModuleFields(JavaWriter writer,
-      ImmutableBiMap<TypeElement, String> moduleDependencies) throws IOException {
-    for (Entry<TypeElement, String> entry : moduleDependencies.entrySet()) {
-      writer.emitField(entry.getKey().getQualifiedName().toString(), entry.getValue(),
-          EnumSet.of(PRIVATE, FINAL));
     }
-  }
 
-  private void writeProviderFields(JavaWriter writer, ImmutableBiMap<Key, String> providerNames)
-      throws IOException {
     for (Entry<Key, String> providerEntry : providerNames.entrySet()) {
       Key key = providerEntry.getKey();
       // TODO(gak): provide more elaborate information about which requests relate
-      writer.emitJavadoc(key.toString())
-          .emitField(providerTypeString(key), providerEntry.getValue(),
-              EnumSet.of(PRIVATE, FINAL));
+      TypeName providerTypeReferece = ParameterizedTypeName.create(
+          ClassName.fromClass(Provider.class),
+          TypeReferences.forTypeMirror(key.type()));
+      FieldWriter providerField =
+          componentWriter.addField(providerTypeReferece, providerEntry.getValue());
+      providerField.addModifiers(PRIVATE, FINAL);
     }
-    writer.emitEmptyLine();
-  }
-
-  private void writeMembersInjectorFields(JavaWriter writer,
-      ImmutableBiMap<Key, String> membersInjectorNames) throws IOException {
     for (Entry<Key, String> providerEntry : membersInjectorNames.entrySet()) {
       Key key = providerEntry.getKey();
       // TODO(gak): provide more elaborate information about which requests relate
-      writer.emitJavadoc(key.toString())
-          .emitField(membersInjectorTypeString(key), providerEntry.getValue(),
-              EnumSet.of(PRIVATE, FINAL));
+      TypeName membersInjectorTypeReferece = ParameterizedTypeName.create(
+          ClassName.fromClass(MembersInjector.class),
+          TypeReferences.forTypeMirror(key.type()));
+      FieldWriter membersInjectorField =
+          componentWriter.addField(membersInjectorTypeReferece, providerEntry.getValue());
+      membersInjectorField.addModifiers(PRIVATE, FINAL);
     }
-    writer.emitEmptyLine();
-  }
 
-  private void writeConstructor(final JavaWriter writer,
-      ImmutableList<FrameworkKey> initializationOrdering,
-      ImmutableSetMultimap<Key, ProvisionBinding> resolvedProvisionBindings,
-      ImmutableMap<Key, MembersInjectionBinding> resolvedMembersInjectionBindings,
-      ImmutableBiMap<Key, String> providerNames,
-      ImmutableBiMap<TypeElement, String> moduleNames,
-      ImmutableBiMap<Key, String> membersInjectorNames)
-          throws IOException {
-    Map<String, String> variableMap =
-        Maps.transformValues(moduleNames.inverse(), new Function<TypeElement, String>() {
-      @Override
-      public String apply(TypeElement input) {
-        return writer.compressType(input.getQualifiedName().toString());
-      }
-    });
-
-    writer.beginConstructor(EnumSet.of(PUBLIC), flattenVariableMap(variableMap),
-        ImmutableList.<String>of());
-    for (String variableName : variableMap.keySet()) {
-      writer.beginControlFlow("if (%s == null)", variableName)
-          .emitStatement("throw new NullPointerException(\"%s\")", variableName)
-          .endControlFlow();
-      writer.emitStatement("this.%1$s = %1$s", variableName);
-    }
-
-    for (FrameworkKey frameworkKey : initializationOrdering) {
+    for (FrameworkKey frameworkKey : input.initializationOrdering()) {
       Key key = frameworkKey.key();
       if (frameworkKey.frameworkClass().equals(Provider.class)) {
         Set<ProvisionBinding> bindings = resolvedProvisionBindings.get(key);
         if (ProvisionBinding.isSetBindingCollection(bindings)) {
-          ImmutableList.Builder<String> setFactoryParameters = ImmutableList.builder();
+          ImmutableList.Builder<Snippet> setFactoryParameters = ImmutableList.builder();
           for (ProvisionBinding binding : bindings) {
             setFactoryParameters.add(initializeFactoryForBinding(
-                writer, binding, moduleNames, providerNames,membersInjectorNames));
+                binding, moduleNames, providerNames,membersInjectorNames));
           }
-          writer.emitStatement("this.%s = SetFactory.create(%n%s)",
+          constructorWriter.body().addSnippet("this.%s = %s.create(%n%s);",
               providerNames.get(key),
-              Joiner.on(",\n").join(setFactoryParameters.build()));
+              ClassName.fromClass(SetFactory.class),
+              Snippet.makeParametersSnippet(setFactoryParameters.build()));
         } else {
           ProvisionBinding binding = Iterables.getOnlyElement(bindings);
-          writer.emitStatement("this.%s = %s",
+          constructorWriter.body().addSnippet("this.%s = %s;",
               providerNames.get(key),
               initializeFactoryForBinding(
-                  writer, binding, moduleNames, providerNames, membersInjectorNames));
+                  binding, moduleNames, providerNames, membersInjectorNames));
         }
       } else if (frameworkKey.frameworkClass().equals(MembersInjector.class)) {
-        writer.emitStatement("this.%s = %s",
+        constructorWriter.body().addSnippet("this.%s = %s;",
             membersInjectorNames.get(key),
-            initializeMembersInjectorForBinding(writer, resolvedMembersInjectionBindings.get(key),
+            initializeMembersInjectorForBinding(resolvedMembersInjectionBindings.get(key),
                 providerNames, membersInjectorNames));
       } else {
         throw new IllegalStateException(
@@ -283,16 +199,46 @@ public String apply(TypeElement input) {
       }
     }
 
-    writer.endConstructor().emitEmptyLine();
+    for (DependencyRequest interfaceRequest : input.interfaceRequests()) {
+      ExecutableElement requestElement = (ExecutableElement) interfaceRequest.requestElement();
+      MethodWriter interfaceMethod = requestElement.getReturnType().getKind().equals(VOID)
+          ? componentWriter.addMethod(VoidName.VOID, requestElement.getSimpleName().toString())
+          : componentWriter.addMethod(requestElement.getReturnType(),
+              requestElement.getSimpleName().toString());
+      interfaceMethod.annotate(Override.class);
+      interfaceMethod.addModifiers(PUBLIC);
+      if (interfaceRequest.kind().equals(MEMBERS_INJECTOR)) {
+        String membersInjectorName = membersInjectorNames.get(interfaceRequest.key());
+        VariableElement parameter = Iterables.getOnlyElement(requestElement.getParameters());
+        Name parameterName = parameter.getSimpleName();
+        interfaceMethod.addParameter(
+            TypeReferences.forTypeMirror(parameter.asType()), parameterName.toString());
+        interfaceMethod.body()
+            .addSnippet("%s.injectMembers(%s);", membersInjectorName, parameterName);
+        if (!requestElement.getReturnType().getKind().equals(VOID)) {
+          interfaceMethod.body().addSnippet("return %s;", parameterName);
+        }
+      } else {
+        // provision requests
+        String providerName = providerNames.get(interfaceRequest.key());
+
+        // look up the provider in the Key->name map and invoke.  Done.
+        interfaceMethod.body().addSnippet("return %s;",
+            frameworkTypeUsageStatement(providerName, interfaceRequest.kind()));
+      }
+    }
+
+    return writer;
   }
 
-  private String initializeFactoryForBinding(JavaWriter writer, ProvisionBinding binding,
+  private Snippet initializeFactoryForBinding(ProvisionBinding binding,
       ImmutableBiMap<TypeElement, String> moduleNames,
       ImmutableBiMap<Key, String> providerNames,
       ImmutableBiMap<Key, String> membersInjectorNames) {
     if (binding.bindingKind().equals(COMPONENT)) {
-      return String.format("InstanceFactory.<%s>create(this)",
-          writer.compressType(Util.typeToString(binding.providedKey().type())));
+      return Snippet.format("%s.<%s>create(this)",
+          ClassName.fromClass(InstanceFactory.class),
+          TypeReferences.forTypeMirror(binding.providedKey().type()));
     } else {
       List<String> parameters = Lists.newArrayListWithCapacity(binding.dependencies().size() + 1);
       if (binding.bindingKind().equals(PROVISION)) {
@@ -309,21 +255,25 @@ private String initializeFactoryForBinding(JavaWriter writer, ProvisionBinding b
       }
       parameters.addAll(
           getDependencyParameters(binding.dependencies(), providerNames, membersInjectorNames));
-      return String.format(
-          binding.scope().isPresent() ? "ScopedProvider.create(new %s(%s))" : "new %s(%s)",
-          writer.compressType(factoryNameForProvisionBinding(binding).toString()),
-          Joiner.on(", ").join(parameters));
+      return binding.scope().isPresent()
+          ? Snippet.format("%s.create(new %s(%s))",
+              ClassName.fromClass(ScopedProvider.class),
+              factoryNameForProvisionBinding(binding).toString(),
+              Joiner.on(", ").join(parameters))
+          : Snippet.format("new %s(%s)",
+              factoryNameForProvisionBinding(binding).toString(),
+              Joiner.on(", ").join(parameters));
     }
   }
 
-  private static String initializeMembersInjectorForBinding(JavaWriter writer,
+  private static Snippet initializeMembersInjectorForBinding(
       MembersInjectionBinding binding,
       ImmutableBiMap<Key, String> providerNames,
       ImmutableBiMap<Key, String> membersInjectorNames) {
     List<String> parameters = getDependencyParameters(binding.dependencySet(),
         providerNames, membersInjectorNames);
-    return String.format("new %s(%s)",
-        writer.compressType(membersInjectorNameForMembersInjectionBinding(binding).toString()),
+    return Snippet.format("new %s(%s)",
+       membersInjectorNameForMembersInjectionBinding(binding).toString(),
         Joiner.on(", ").join(parameters));
   }
 
@@ -338,76 +288,4 @@ private static String initializeMembersInjectorForBinding(JavaWriter writer,
     }
     return parameters.build();
   }
-
-  private void writeInterfaceMethods(JavaWriter writer,
-      ImmutableList<DependencyRequest> interfaceRequests,
-      ImmutableBiMap<Key, String> providerNames,
-      ImmutableBiMap<Key, String> membersInjectorNames) throws IOException {
-    for (DependencyRequest interfaceRequest : interfaceRequests) {
-      ExecutableElement requestElement = (ExecutableElement) interfaceRequest.requestElement();
-      beginMethodOverride(writer, requestElement);
-      if (interfaceRequest.kind().equals(MEMBERS_INJECTOR)) {
-        String membersInjectorName = membersInjectorNames.get(interfaceRequest.key());
-        Name parameterName =
-            Iterables.getOnlyElement(requestElement.getParameters()).getSimpleName();
-        writer.emitStatement("%s.injectMembers(%s)", membersInjectorName, parameterName);
-        if (!requestElement.getReturnType().getKind().equals(VOID)) {
-          writer.emitStatement("return %s", parameterName);
-        }
-      } else {
-        // provision requests
-        String providerName = providerNames.get(interfaceRequest.key());
-
-        // look up the provider in the Key->name map and invoke.  Done.
-        writer.emitStatement("return "
-            + providerUsageStatement(providerName, interfaceRequest.kind()));
-      }
-      writer.endMethod();
-    }
-  }
-
-  private JavaWriter beginMethodOverride(JavaWriter writer, ExecutableElement methodElement)
-      throws IOException {
-    String returnTypeString = writer.compressType(returnTypeString(methodElement.getReturnType()));
-    String methodName = methodElement.getSimpleName().toString();
-    Set<Modifier> modifiers = Sets.difference(methodElement.getModifiers(), EnumSet.of(ABSTRACT));
-    ImmutableList.Builder<String> parametersBuilder = ImmutableList.builder();
-    for (VariableElement parameterElement : methodElement.getParameters()) {
-      parametersBuilder.add(writer.compressType(Util.typeToString(parameterElement.asType())),
-          parameterElement.getSimpleName().toString());
-    }
-    ImmutableList.Builder<String> thrownTypesBuilder = ImmutableList.builder();
-    for (TypeMirror thrownTypeMirror : methodElement.getThrownTypes()) {
-      thrownTypesBuilder.add(writer.compressType(Util.typeToString(thrownTypeMirror)));
-    }
-    return writer.emitAnnotation(Override.class)
-        .beginMethod(
-            returnTypeString,
-            methodName,
-            modifiers,
-            parametersBuilder.build(),
-            thrownTypesBuilder.build());
-  }
-
-  private String returnTypeString(TypeMirror returnType) {
-    TypeKind returnTypeKind = returnType.getKind();
-    if (returnTypeKind.equals(VOID)) {
-      return "void";
-    } else if (returnTypeKind.isPrimitive()) {
-      // TypeMirrors don't have names but PrimitiveType#toString() reflects the simple type name.
-      return returnType.toString();
-    }
-    // Util.typeToString() does boxing, so cannot be used for primitive types.
-    return Util.typeToString(returnType);
-  }
-
-  private String providerTypeString(Key key) {
-    return Util.typeToString(types.getDeclaredType(
-        elements.getTypeElement(Provider.class.getCanonicalName()), key.type()));
-  }
-
-  private String membersInjectorTypeString(Key key) {
-    return Util.typeToString(types.getDeclaredType(
-        elements.getTypeElement(MembersInjector.class.getCanonicalName()), key.type()));
-  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
index 82a9f343a..0b74b2a5f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -87,11 +87,11 @@ public synchronized void init(ProcessingEnvironment processingEnv) {
         new ComponentDescriptor.Factory(elements, types, injectBindingRegistry,
             provisionBindingFactory, dependencyRequestFactory);
 
-    FactoryGenerator factoryGenerator = new FactoryGenerator(filer, elements, types);
+    FactoryGenerator factoryGenerator = new FactoryGenerator(filer);
     MembersInjectorGenerator membersInjectorGenerator =
         new MembersInjectorGenerator(filer, elements, types);
     ComponentGenerator componentGenerator =
-        new ComponentGenerator(filer, elements, types, keyFactory);
+        new ComponentGenerator(filer, keyFactory);
 
     this.processingSteps = ImmutableList.<ProcessingStep>of(
         new InjectProcessingStep(
diff --git a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
index a847b782c..29f763fd3 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
@@ -15,46 +15,35 @@
  */
 package dagger.internal.codegen;
 
-import com.google.common.base.Function;
-import com.google.common.base.Functions;
-import com.google.common.base.Joiner;
 import com.google.common.base.Optional;
-import com.google.common.collect.Collections2;
-import com.google.common.collect.FluentIterable;
-import com.google.common.collect.ImmutableBiMap;
-import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.ImmutableSortedSet;
-import com.google.common.collect.Maps;
-import com.squareup.javawriter.JavaWriter;
+import com.google.common.collect.Lists;
 import dagger.Factory;
 import dagger.MembersInjector;
-import dagger.Provides;
-import java.io.IOException;
+import dagger.internal.codegen.writer.ClassName;
+import dagger.internal.codegen.writer.ClassWriter;
+import dagger.internal.codegen.writer.ConstructorWriter;
+import dagger.internal.codegen.writer.FieldWriter;
+import dagger.internal.codegen.writer.JavaWriter;
+import dagger.internal.codegen.writer.MethodWriter;
+import dagger.internal.codegen.writer.ParameterizedTypeName;
+import dagger.internal.codegen.writer.Snippet;
+import dagger.internal.codegen.writer.TypeName;
+import dagger.internal.codegen.writer.TypeReferences;
 import java.util.Collections;
-import java.util.EnumSet;
-import java.util.Map;
+import java.util.List;
 import java.util.Map.Entry;
 import javax.annotation.Generated;
 import javax.annotation.processing.Filer;
 import javax.inject.Inject;
 import javax.inject.Provider;
 import javax.lang.model.element.Element;
-import javax.lang.model.element.TypeElement;
-import javax.lang.model.type.TypeMirror;
-import javax.lang.model.util.Elements;
-import javax.lang.model.util.Types;
-
-import static com.google.common.base.Preconditions.checkNotNull;
-import static com.squareup.javawriter.JavaWriter.stringLiteral;
-import static com.squareup.javawriter.JavaWriter.type;
+
 import static dagger.internal.codegen.ProvisionBinding.Kind.PROVISION;
-import static dagger.internal.codegen.SourceFiles.collectImportsFromDependencies;
 import static dagger.internal.codegen.SourceFiles.factoryNameForProvisionBinding;
-import static dagger.internal.codegen.SourceFiles.flattenVariableMap;
-import static dagger.internal.codegen.SourceFiles.generateProviderNamesForDependencies;
-import static dagger.internal.codegen.SourceFiles.providerUsageStatement;
+import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
+import static dagger.internal.codegen.writer.Snippet.makeParametersSnippet;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.PUBLIC;
@@ -67,13 +56,8 @@
  * @since 2.0
  */
 final class FactoryGenerator extends SourceFileGenerator<ProvisionBinding> {
-  private final Elements elements;
-  private final Types types;
-
-  FactoryGenerator(Filer filer, Elements elements, Types types) {
+  FactoryGenerator(Filer filer) {
     super(filer);
-    this.elements = checkNotNull(elements);
-    this.types = checkNotNull(types);
   }
 
   @Override
@@ -91,165 +75,102 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
     return Optional.of(binding.bindingElement());
   }
 
-  @Override
-  void write(ClassName factoryClassName, JavaWriter writer, ProvisionBinding binding)
-      throws IOException {
-    TypeMirror providedType = binding.providedKey().type();
-    String providedTypeString = Util.typeToString(providedType);
 
-    writer.emitPackage(factoryClassName.packageName());
+  @Override
+  JavaWriter write(ClassName generatedTypeName, ProvisionBinding binding) {
+    TypeName providedTypeName = TypeReferences.forTypeMirror(binding.providedKey().type());
+    JavaWriter writer = JavaWriter.inPackage(generatedTypeName.packageName());
 
-    writeImports(writer, factoryClassName, binding, providedType);
+    ClassWriter factoryWriter = writer.addClass(generatedTypeName.simpleName());
+    factoryWriter.annotate(Generated.class).setValue(ComponentProcessor.class.getName());
+    factoryWriter.addModifiers(PUBLIC, FINAL);
+    factoryWriter.addImplementedType(ParameterizedTypeName.create(
+        ClassName.fromClass(Factory.class),
+        providedTypeName));
 
-    writer.emitAnnotation(Generated.class, stringLiteral(ComponentProcessor.class.getName()))
-        .beginType(factoryClassName.simpleName(), "class", EnumSet.of(PUBLIC, FINAL), null,
-            type(Factory.class, Util.typeToString(binding.providedKey().type())));
 
-    final ImmutableBiMap<Key, String> providerNames =
-        generateProviderNamesForDependencies(binding.dependencies());
+    MethodWriter getMethodWriter = factoryWriter.addMethod(binding.providedKey().type(), "get");
+    getMethodWriter.annotate(Override.class);
+    getMethodWriter.addModifiers(PUBLIC);
 
-    ImmutableMap.Builder<String, String> variableMapBuilder =
-        new ImmutableMap.Builder<String, String>();
+    ConstructorWriter constructorWriter = factoryWriter.addConstructor();
+    constructorWriter.addModifiers(PUBLIC);
     if (binding.bindingKind().equals(PROVISION)) {
-      variableMapBuilder.put("module", binding.bindingTypeElement().getQualifiedName().toString());
+      factoryWriter.addField(binding.bindingTypeElement(), "module").addModifiers(PRIVATE, FINAL);
+      constructorWriter.addParameter(binding.bindingTypeElement(), "module");
+      constructorWriter.body()
+          .addSnippet("assert module != null;")
+          .addSnippet("this.module = module;");
     }
-    if (binding.requiresMemberInjection()) {
-      variableMapBuilder.put("membersInjector", type(MembersInjector.class, providedTypeString));
-    }
-    ImmutableMap<String, String> variableMap = variableMapBuilder
-        .putAll(providersAsVariableMap(providerNames))
-        .build();
 
     if (binding.requiresMemberInjection()) {
-      writeMembersInjectorField(writer, providedTypeString);
-    }
-    if (binding.bindingKind().equals(PROVISION)) {
-      writeModuleField(writer, binding.bindingTypeElement());
+      ParameterizedTypeName membersInjectorType = ParameterizedTypeName.create(
+          MembersInjector.class, providedTypeName);
+      factoryWriter.addField(membersInjectorType, "membersInjector").addModifiers(PRIVATE, FINAL);
+      constructorWriter.addParameter(membersInjectorType, "membersInjector");
+      constructorWriter.body()
+          .addSnippet("assert membersInjector != null;")
+          .addSnippet("this.membersInjector = membersInjector;");
     }
-    writeProviderFields(writer, providerNames);
-
-    writeConstructor(writer, variableMap);
 
-    writeGetMethod(writer, binding, providedTypeString, providerNames);
-
-    // TODO(gak): write a sensible toString
-
-    writer.endType();
-  }
-
-  private void writeImports(JavaWriter writer, ClassName factoryClassName, ProvisionBinding binding,
-      TypeMirror providedType) throws IOException {
-    ImmutableSortedSet.Builder<ClassName> importsBuilder =
-        ImmutableSortedSet.<ClassName>naturalOrder()
-            .addAll(collectImportsFromDependencies(factoryClassName, binding.dependencies()))
-            .add(ClassName.fromClass(Factory.class))
-            .add(ClassName.fromClass(Generated.class));
-    ClassName bindingClassName = ClassName.fromTypeElement(binding.bindingTypeElement());
-    if(!bindingClassName.enclosingSimpleNames().isEmpty()) {
-      importsBuilder.add(bindingClassName);
-    }
-    if (binding.provisionType().equals(Provides.Type.SET)) {
-      importsBuilder.add(ClassName.fromClass(Collections.class));
-    }
-    if (binding.requiresMemberInjection()) {
-      importsBuilder.add(ClassName.fromClass(MembersInjector.class));
-    }
-    for (TypeElement referencedProvidedType : MoreTypes.referencedTypes(providedType)) {
-      ClassName className = ClassName.fromTypeElement(referencedProvidedType);
-      if (!className.packageName().equals("java.lang")
-          && !className.packageName().equals(factoryClassName.packageName()))
-      importsBuilder.add(className);
+    ImmutableMap<FrameworkKey, String> names =
+        SourceFiles.generateFrameworkReferenceNamesForDependencies(binding.dependencies());
+
+    for (Entry<FrameworkKey, String> nameEntry : names.entrySet()) {
+      final FieldWriter field;
+      if (nameEntry.getKey().frameworkClass().equals(Provider.class)) {
+        ParameterizedTypeName providerType = ParameterizedTypeName.create(
+            ClassName.fromClass(Provider.class),
+            TypeReferences.forTypeMirror(nameEntry.getKey().key().type()));
+        field = factoryWriter.addField(providerType, nameEntry.getValue());
+      } else if (nameEntry.getKey().frameworkClass().equals(MembersInjector.class)) {
+        ParameterizedTypeName membersInjectorType = ParameterizedTypeName.create(
+            ClassName.fromClass(MembersInjector.class),
+            TypeReferences.forTypeMirror(nameEntry.getKey().key().type()));
+        field = factoryWriter.addField(membersInjectorType, nameEntry.getValue());
+      } else {
+        throw new IllegalStateException();
+      }
+      field.addModifiers(PRIVATE, FINAL);
+      constructorWriter.addParameter(field.type(), field.name());
+      constructorWriter.body()
+          .addSnippet("assert %s != null;", field.name())
+          .addSnippet("this.%1$s = %1$s;", field.name());
     }
 
-    writer.emitImports(Collections2.transform(importsBuilder.build(), Functions.toStringFunction()))
-        .emitEmptyLine();
-  }
-
-  private void writeMembersInjectorField(JavaWriter writer, String providedTypeString)
-      throws IOException {
-    writer.emitField(type(MembersInjector.class, providedTypeString),
-        "membersInjector", EnumSet.of(PRIVATE, FINAL));
-  }
-
-  private void writeModuleField(JavaWriter writer, TypeElement moduleType) throws IOException {
-    writer.emitField(moduleType.getQualifiedName().toString(), "module",
-        EnumSet.of(PRIVATE, FINAL));
-  }
-
-  private void writeProviderFields(JavaWriter writer, ImmutableBiMap<Key, String> providerNames)
-      throws IOException {
-    for (Entry<Key, String> providerEntry : providerNames.entrySet()) {
-      Key key = providerEntry.getKey();
-      // TODO(gak): provide more elaborate information about which requests relate
-      writer.emitJavadoc(key.toString())
-          .emitField(providerTypeString(key), providerEntry.getValue(),
-              EnumSet.of(PRIVATE, FINAL));
+    List<Snippet> parameters = Lists.newArrayList();
+    for (DependencyRequest dependency : binding.dependencies()) {
+      parameters.add(frameworkTypeUsageStatement(
+          names.get(FrameworkKey.forDependencyRequest(dependency)), dependency.kind()));
     }
-    writer.emitEmptyLine();
-  }
+    Snippet parametersSnippet = makeParametersSnippet(parameters);
 
-  private void writeConstructor(JavaWriter writer, Map<String, String> variableMap)
-      throws IOException {
-    if (!variableMap.isEmpty()) {
-      writer.beginConstructor(EnumSet.of(PUBLIC),
-          flattenVariableMap(variableMap),
-          ImmutableList.<String>of());
-      for (String variableName : variableMap.keySet()) {
-        writer.emitStatement("assert %s != null", variableName);
-        writer.emitStatement("this.%1$s = %1$s", variableName);
-      }
-      writer.endConstructor().emitEmptyLine();
-    }
-  }
-
-  private void writeGetMethod(JavaWriter writer, ProvisionBinding binding,
-      String providedTypeString, final ImmutableBiMap<Key, String> providerNames)
-          throws IOException {
-    writer.emitAnnotation(Override.class)
-        .beginMethod(providedTypeString, "get", EnumSet.of(PUBLIC));
-    String parameterString =
-        Joiner.on(", ").join(FluentIterable.from(binding.dependencies())
-            .transform(new Function<DependencyRequest, String>() {
-              @Override public String apply(DependencyRequest input) {
-                return providerUsageStatement(providerNames.get(input.key()), input.kind());
-              }
-            }));
     if (binding.bindingKind().equals(PROVISION)) {
       switch (binding.provisionType()) {
         case UNIQUE:
         case SET_VALUES:
-          writer.emitStatement("return module.%s(%s)",
-              binding.bindingElement().getSimpleName(), parameterString);
+          getMethodWriter.body().addSnippet("return module.%s(%s);",
+              binding.bindingElement().getSimpleName(), parametersSnippet);
           break;
         case SET:
-          writer.emitStatement("return Collections.singleton(module.%s(%s))",
-              binding.bindingElement().getSimpleName(), parameterString);
+          getMethodWriter.body().addSnippet("return %s.singleton(module.%s(%s));",
+              ClassName.fromClass(Collections.class),
+              binding.bindingElement().getSimpleName(), parametersSnippet);
           break;
         default:
           throw new AssertionError();
       }
     } else if (binding.requiresMemberInjection()) {
-      writer.emitStatement("%1$s instance = new %1$s(%2$s)",
-          writer.compressType(providedTypeString), parameterString);
-      writer.emitStatement("membersInjector.injectMembers(instance)");
-      writer.emitStatement("return instance");
+      getMethodWriter.body().addSnippet("%1$s instance = new %1$s(%2$s);",
+          providedTypeName, parametersSnippet);
+      getMethodWriter.body().addSnippet("membersInjector.injectMembers(instance);");
+      getMethodWriter.body().addSnippet("return instance;");
     } else {
-      writer.emitStatement("return new %s(%s)",
-          writer.compressType(providedTypeString), parameterString);
+      getMethodWriter.body()
+          .addSnippet("return new %s(%s);", providedTypeName, parametersSnippet);
     }
-    writer.endMethod().emitEmptyLine();
-  }
 
-  private Map<String, String> providersAsVariableMap(ImmutableBiMap<Key, String> providerNames) {
-    return Maps.transformValues(providerNames.inverse(), new Function<Key, String>() {
-      @Override public String apply(Key key) {
-        return providerTypeString(key);
-      }
-    });
-  }
-
-  private String providerTypeString(Key key) {
-    return Util.typeToString(types.getDeclaredType(
-        elements.getTypeElement(Provider.class.getCanonicalName()), key.type()));
+    // TODO(gak): write a sensible toString
+    return writer;
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
index c72f15f30..ab000fc98 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
@@ -15,49 +15,38 @@
  */
 package dagger.internal.codegen;
 
+import dagger.internal.codegen.writer.VoidName;
+
 import com.google.auto.common.MoreElements;
 import com.google.common.base.Function;
-import com.google.common.base.Functions;
 import com.google.common.base.Joiner;
 import com.google.common.base.Optional;
 import com.google.common.collect.FluentIterable;
-import com.google.common.collect.ImmutableBiMap;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
-import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.ImmutableSortedSet;
 import com.google.common.collect.Iterables;
-import com.google.common.collect.Maps;
-import com.google.common.collect.Ordering;
-import com.squareup.javawriter.JavaWriter;
 import dagger.MembersInjector;
 import dagger.internal.codegen.MembersInjectionBinding.InjectionSite;
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.EnumSet;
-import java.util.List;
-import java.util.Map;
+import dagger.internal.codegen.writer.ClassName;
+import dagger.internal.codegen.writer.ClassWriter;
+import dagger.internal.codegen.writer.ConstructorWriter;
+import dagger.internal.codegen.writer.FieldWriter;
+import dagger.internal.codegen.writer.JavaWriter;
+import dagger.internal.codegen.writer.MethodWriter;
+import dagger.internal.codegen.writer.ParameterizedTypeName;
+import dagger.internal.codegen.writer.Snippet;
+import dagger.internal.codegen.writer.TypeReferences;
 import java.util.Map.Entry;
 import javax.annotation.Generated;
 import javax.annotation.processing.Filer;
 import javax.inject.Provider;
 import javax.lang.model.element.Element;
-import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.Modifier;
-import javax.lang.model.element.Name;
 import javax.lang.model.element.TypeElement;
-import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
-
 import static com.google.common.base.Preconditions.checkNotNull;
-import static com.squareup.javawriter.JavaWriter.stringLiteral;
-import static com.squareup.javawriter.JavaWriter.type;
-import static dagger.internal.codegen.SourceFiles.collectImportsFromDependencies;
-import static dagger.internal.codegen.SourceFiles.flattenVariableMap;
-import static dagger.internal.codegen.SourceFiles.generateProviderNamesForDependencies;
-import static dagger.internal.codegen.SourceFiles.providerUsageStatement;
+import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.PUBLIC;
@@ -101,97 +90,99 @@ ClassName nameGeneratedType(MembersInjectionBinding binding) {
   }
 
   @Override
-  void write(ClassName injectorClassName, JavaWriter writer, MembersInjectionBinding binding)
-      throws IOException {
+  JavaWriter write(ClassName injectorClassName, MembersInjectionBinding binding) {
     ClassName injectedClassName = ClassName.fromTypeElement(binding.injectedType());
 
-    writer.emitPackage(injectedClassName.packageName());
-
-    ImmutableSet<DependencyRequest> dependencies = binding.dependencySet();
-    Optional<TypeElement> supertype = supertype(binding.injectedType());
-
-    List<ClassName> importsBuilder = new ArrayList<ClassName>();
-    importsBuilder.addAll(collectImportsFromDependencies(injectorClassName, dependencies));
-    importsBuilder.add(ClassName.fromClass(MembersInjector.class));
-    importsBuilder.add(ClassName.fromClass(Generated.class));
-    if(!injectedClassName.enclosingSimpleNames().isEmpty()) {
-      importsBuilder.add(injectedClassName);
-    }
-    if (supertype.isPresent()) {
-      ClassName supertypeClassName = ClassName.fromTypeElement(supertype.get());
-      if (!supertypeClassName.packageName().equals(injectorClassName.packageName())) {
-        importsBuilder.add(supertypeClassName);
-      }
-    }
-    ImmutableSortedSet<String> imports = FluentIterable.from(importsBuilder)
-        .transform(Functions.toStringFunction())
-        .toSortedSet(Ordering.natural());
-    writer.emitImports(imports).emitEmptyLine();
-
-    writer.emitJavadoc("A {@link MembersInjector} implementation for {@link %s}.",
-        injectedClassName.simpleName());
+    JavaWriter writer = JavaWriter.inPackage(injectedClassName.packageName());
 
-    String membersInjectorType = type(MembersInjector.class, injectedClassName.simpleName());
-    // @Generated("dagger.internal.codegen.InjectProcessor")
-    // public final class Blah$$MembersInjector implements MembersInjector<Blah>
-    writer.emitAnnotation(Generated.class, stringLiteral(ComponentProcessor.class.getName()))
-        .beginType(injectorClassName.simpleName(), "class", EnumSet.of(FINAL), null,
-            membersInjectorType);
+    ClassWriter injectorWriter = writer.addClass(injectorClassName.simpleName());
+    injectorWriter.annotate(Generated.class)
+        .setValue(ComponentProcessor.class.getCanonicalName());
+    injectorWriter.addModifiers(PUBLIC, FINAL);
+    injectorWriter.addImplementedType(
+        ParameterizedTypeName.create(MembersInjector.class, injectedClassName));
 
-    final ImmutableBiMap<Key, String> providerNames =
-        generateProviderNamesForDependencies(dependencies);
+    ConstructorWriter constructorWriter = injectorWriter.addConstructor();
+    constructorWriter.addModifiers(PUBLIC);
+    MethodWriter injectMembersWriter = injectorWriter.addMethod(VoidName.VOID, "injectMembers");
+    injectMembersWriter.addModifiers(PUBLIC);
+    injectMembersWriter.annotate(Override.class);
+    injectMembersWriter.addParameter(injectedClassName, "instance");
+    injectMembersWriter.body().addSnippet(Joiner.on('\n').join(
+        "if (instance == null) {",
+        "  throw new NullPointerException(\"Cannot inject members into a null reference\");",
+        "}"));
 
-    writeSupertypeInjectorField(writer, supertype);
-
-    // Add the fields
-    writeProviderFields(writer, providerNames);
-
-    // Add the constructor
-    writeConstructor(writer, supertype, providerNames);
-
-    // @Override public void injectMembers(Blah instance)
-    writer.emitAnnotation(Override.class)
-        .beginMethod("void", "injectMembers", EnumSet.of(PUBLIC),
-            injectedClassName.simpleName(), "instance");
-    // TODO(gak): figure out what (if anything) to do about being passed a subtype of the class
-    // specified as the type parameter for the MembersInjector.
-    writer.beginControlFlow("if (instance == null)")
-        .emitStatement(
-            "throw new NullPointerException(\"Cannot inject members into a null reference\")")
-        .endControlFlow();
 
+    Optional<TypeElement> supertype = supertype(binding.injectedType());
     if (supertype.isPresent()) {
-      writer.emitStatement("supertypeInjector.injectMembers(instance)");
+      ParameterizedTypeName supertypeMemebersInjectorType = ParameterizedTypeName.create(
+          MembersInjector.class, ClassName.fromTypeElement(supertype.get()));
+      injectorWriter
+          .addField(supertypeMemebersInjectorType, "supertypeInjector")
+          .addModifiers(PRIVATE, FINAL);
+      constructorWriter.addParameter(supertypeMemebersInjectorType, "supertypeInjector");
+      constructorWriter.body()
+          .addSnippet("assert supertypeInjector != null;")
+          .addSnippet("this.supertypeInjector = supertypeInjector;");
+      injectMembersWriter.body().addSnippet("supertypeInjector.injectMembers(instance);");
     }
 
+    ImmutableMap<FrameworkKey, String> names =
+        SourceFiles.generateFrameworkReferenceNamesForDependencies(binding.dependencySet());
+
+    ImmutableMap.Builder<FrameworkKey, FieldWriter> dependencyFieldsBuilder =
+        ImmutableMap.builder();
+
+    for (Entry<FrameworkKey, String> nameEntry : names.entrySet()) {
+      final FieldWriter field;
+      if (nameEntry.getKey().frameworkClass().equals(Provider.class)) {
+        ParameterizedTypeName providerType = ParameterizedTypeName.create(
+            ClassName.fromClass(Provider.class),
+            TypeReferences.forTypeMirror(nameEntry.getKey().key().type()));
+        field = injectorWriter.addField(providerType, nameEntry.getValue());
+      } else if (nameEntry.getKey().frameworkClass().equals(MembersInjector.class)) {
+        ParameterizedTypeName membersInjectorType = ParameterizedTypeName.create(
+            ClassName.fromClass(MembersInjector.class),
+            TypeReferences.forTypeMirror(nameEntry.getKey().key().type()));
+        field = injectorWriter.addField(membersInjectorType, nameEntry.getValue());
+      } else {
+        throw new IllegalStateException();
+      }
+      field.addModifiers(PRIVATE, FINAL);
+      constructorWriter.addParameter(field.type(), field.name());
+      constructorWriter.body().addSnippet("assert %s != null;", field.name());
+      constructorWriter.body().addSnippet("this.%1$s = %1$s;", field.name());
+      dependencyFieldsBuilder.put(nameEntry.getKey(), field);
+    }
+    ImmutableMap<FrameworkKey, FieldWriter> depedencyFields = dependencyFieldsBuilder.build();
     for (InjectionSite injectionSite : binding.injectionSites()) {
       switch (injectionSite.kind()) {
         case FIELD:
-          Name fieldName = ((VariableElement) injectionSite.element()).getSimpleName();
-          DependencyRequest singleDependency =
+          DependencyRequest fieldDependency =
               Iterables.getOnlyElement(injectionSite.dependencies());
-          String providerName = providerNames.get(singleDependency.key());
-          writer.emitStatement("instance.%s = %s",
-              fieldName, providerUsageStatement(providerName, singleDependency.kind()));
+          FieldWriter singleField = depedencyFields.get(FrameworkKey.forDependencyRequest(
+              fieldDependency));
+          injectMembersWriter.body().addSnippet("instance.%s = %s;",
+              injectionSite.element().getSimpleName(),
+              frameworkTypeUsageStatement(singleField.name(), fieldDependency.kind()));
           break;
         case METHOD:
-          Name methodName = ((ExecutableElement) injectionSite.element()).getSimpleName();
-          String parameterString =
-              Joiner.on(", ").join(FluentIterable.from(injectionSite.dependencies())
-                  .transform(new Function<DependencyRequest, String>() {
-                    @Override public String apply(DependencyRequest input) {
-                      return providerUsageStatement(providerNames.get(input.key()), input.kind());
-                    }
-                  }));
-          writer.emitStatement("instance.%s(%s)", methodName, parameterString);
+          ImmutableList.Builder<Snippet> parameters = ImmutableList.builder();
+          for (DependencyRequest methodDependnecy : injectionSite.dependencies()) {
+            FieldWriter field =
+            depedencyFields.get(FrameworkKey.forDependencyRequest(methodDependnecy));
+            parameters.add(frameworkTypeUsageStatement(field.name(), methodDependnecy.kind()));
+          }
+          injectMembersWriter.body().addSnippet("instance.%s(%s);",
+              injectionSite.element().getSimpleName(),
+              Snippet.makeParametersSnippet(parameters.build()));
           break;
         default:
           throw new AssertionError();
       }
     }
-    writer.endMethod();
-
-    writer.endType();
+    return writer;
   }
 
   private Optional<TypeElement> supertype(TypeElement type) {
@@ -202,59 +193,4 @@ void write(ClassName injectorClassName, JavaWriter writer, MembersInjectionBindi
         ? Optional.of(MoreElements.asType(types.asElement(superclass)))
         : Optional.<TypeElement>absent();
   }
-
-  private void writeSupertypeInjectorField(JavaWriter writer, Optional<TypeElement> supertype)
-      throws IOException {
-    if (supertype.isPresent()) {
-      writer.emitField(type(MembersInjector.class, supertype.get().getQualifiedName().toString()),
-          "supertypeInjector", EnumSet.of(PRIVATE, FINAL));
-    }
-  }
-
-  private void writeProviderFields(JavaWriter writer, ImmutableBiMap<Key, String> providerNames)
-      throws IOException {
-    for (Entry<Key, String> providerEntry : providerNames.entrySet()) {
-      Key key = providerEntry.getKey();
-      // TODO(gak): provide more elaborate information about which requests relate
-      writer.emitJavadoc(key.toString())
-          .emitField(providerTypeString(key), providerEntry.getValue(),
-              EnumSet.of(PRIVATE, FINAL));
-    }
-    writer.emitEmptyLine();
-  }
-
-  private void writeConstructor(JavaWriter writer, Optional<TypeElement> supertype,
-      ImmutableBiMap<Key, String> providerNames) throws IOException {
-    ImmutableMap.Builder<String, String> variableMapBuilder = ImmutableMap.builder();
-    if (supertype.isPresent()) {
-      variableMapBuilder.put("supertypeInjector",
-          type(MembersInjector.class, supertype.get().getQualifiedName().toString()));
-    }
-    variableMapBuilder.putAll(providersAsVariableMap(providerNames));
-    writer.beginConstructor(EnumSet.noneOf(Modifier.class),
-        flattenVariableMap(variableMapBuilder.build()),
-        ImmutableList.<String>of());
-    if (supertype.isPresent()) {
-      writer.emitStatement("assert %s != null", "supertypeInjector");
-      writer.emitStatement("this.%1$s = %1$s", "supertypeInjector");
-    }
-    for (String providerName : providerNames.values()) {
-      writer.emitStatement("assert %s != null", providerName);
-      writer.emitStatement("this.%1$s = %1$s", providerName);
-    }
-    writer.endConstructor().emitEmptyLine();
-  }
-
-  private Map<String, String> providersAsVariableMap(ImmutableBiMap<Key, String> providerNames) {
-    return Maps.transformValues(providerNames.inverse(), new Function<Key, String>() {
-      @Override public String apply(Key key) {
-        return providerTypeString(key);
-      }
-    });
-  }
-
-  private String providerTypeString(Key key) {
-    return Util.typeToString(types.getDeclaredType(
-        elements.getTypeElement(Provider.class.getCanonicalName()), key.type()));
-  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerationException.java b/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerationException.java
index ad78595f5..725c24e37 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerationException.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerationException.java
@@ -16,6 +16,7 @@
 package dagger.internal.codegen;
 
 import com.google.common.base.Optional;
+import dagger.internal.codegen.writer.ClassName;
 import javax.annotation.processing.Messager;
 import javax.lang.model.element.Element;
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerator.java b/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerator.java
index 10ac64013..9cfd003ec 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceFileGenerator.java
@@ -18,12 +18,11 @@
 import com.google.common.base.Optional;
 import com.google.common.base.Throwables;
 import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.Iterables;
-import com.squareup.javawriter.JavaWriter;
+import dagger.internal.codegen.writer.ClassName;
+import dagger.internal.codegen.writer.JavaWriter;
 import java.io.IOException;
 import javax.annotation.processing.Filer;
 import javax.lang.model.element.Element;
-import javax.tools.JavaFileObject;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
@@ -46,40 +45,16 @@
   final ClassName generate(T input) throws SourceFileGenerationException {
     ClassName generatedTypeName = nameGeneratedType(input);
     ImmutableSet<Element> originatingElements = ImmutableSet.copyOf(getOriginatingElements(input));
-    JavaFileObject file = null;
     try {
-      // first, try to create the file
-      file = filer.createSourceFile(generatedTypeName.fullyQualifiedName(),
-          Iterables.toArray(originatingElements, Element.class));
-      // try to create the writer
-      JavaWriter writer = new JavaWriter(file.openWriter());
-      boolean thrownWriting = false;
+      JavaWriter javaWriter = write(generatedTypeName, input);
       try {
-        write(generatedTypeName, writer, input);
-        return generatedTypeName;
-      } catch (Exception e) {
-        thrownWriting = true;
+        javaWriter.file(filer, originatingElements);
+      } catch (IOException e) {
         throw new SourceFileGenerationException(generatedTypeName, e,
             getElementForErrorReporting(input));
-      } finally {
-        // good or bad, we have to close the stream
-        try {
-          writer.close();
-        } catch (IOException e) {
-          // only throw this exception if nothing was thrown during writing as that one is much
-          // more likely to be interesting
-          if (!thrownWriting) {
-            throw new SourceFileGenerationException(generatedTypeName, e,
-                getElementForErrorReporting(input));
-          }
-        }
       }
+      return generatedTypeName;
     } catch (Exception e) {
-      // deletes the file if any exception occurred creating the file, opening the writer or writing
-      // the contents
-      if (file != null) {
-        file.delete();
-      }
       // if the code above threw a SFGE, use that
       Throwables.propagateIfPossible(e, SourceFileGenerationException.class);
       // otherwise, throw a new one
@@ -106,8 +81,6 @@ final ClassName generate(T input) throws SourceFileGenerationException {
   abstract Optional<? extends Element> getElementForErrorReporting(T input);
 
   /**
-   * Implementations should emit source using the given {@link JavaWriter} instance. It is not
-   * necessary to close the writer.
    */
-  abstract void write(ClassName generatedTypeName, JavaWriter writer, T input) throws IOException;
+  abstract JavaWriter write(ClassName generatedTypeName, T input);
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
index e42aaf972..5152f027d 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
@@ -23,6 +23,7 @@
 import com.google.common.collect.HashBiMap;
 import com.google.common.collect.ImmutableBiMap;
 import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ImmutableSetMultimap;
 import com.google.common.collect.ImmutableSortedMap;
@@ -31,10 +32,11 @@
 import com.google.common.collect.Maps;
 import com.google.common.collect.Ordering;
 import com.google.common.collect.SetMultimap;
-import com.squareup.javawriter.JavaWriter;
 import dagger.Lazy;
 import dagger.MembersInjector;
 import dagger.internal.DoubleCheckLazy;
+import dagger.internal.codegen.writer.ClassName;
+import dagger.internal.codegen.writer.Snippet;
 import java.util.Collection;
 import java.util.Iterator;
 import java.util.Map;
@@ -138,29 +140,31 @@
    * @return Returns the mapping from {@link Key} to provider name sorted by the name of the
    * provider.
    */
-  static ImmutableBiMap<Key, String> generateProviderNamesForDependencies(
+  static ImmutableMap<FrameworkKey, String> generateFrameworkReferenceNamesForDependencies(
       Iterable<? extends DependencyRequest> dependencies) {
-    ImmutableSetMultimap.Builder<Key, DependencyRequest> dependenciesByKeyBuilder =
-        new ImmutableSetMultimap.Builder<Key, DependencyRequest>()
+    ImmutableSetMultimap.Builder<FrameworkKey, DependencyRequest> dependenciesByKeyBuilder =
+        new ImmutableSetMultimap.Builder<FrameworkKey, DependencyRequest>()
             .orderValuesBy(DEPENDENCY_ORDERING);
     for (DependencyRequest dependency : dependencies) {
-      dependenciesByKeyBuilder.put(dependency.key(), dependency);
+      dependenciesByKeyBuilder.put(
+          FrameworkKey.forDependencyRequest(dependency), dependency);
     }
-    ImmutableSetMultimap<Key, DependencyRequest> dependenciesByKey =
+    ImmutableSetMultimap<FrameworkKey, DependencyRequest> dependenciesByKey =
         dependenciesByKeyBuilder.build();
-    Map<Key, Collection<DependencyRequest>> dependenciesByKeyMap = dependenciesByKey.asMap();
-    BiMap<Key, String> providerNames = HashBiMap.create(dependenciesByKeyMap.size());
-    for (Entry<Key, Collection<DependencyRequest>> entry : dependenciesByKeyMap.entrySet()) {
+    Map<FrameworkKey, Collection<DependencyRequest>> dependenciesByKeyMap =
+        dependenciesByKey.asMap();
+    ImmutableMap.Builder<FrameworkKey, String> providerNames = ImmutableMap.builder();
+    for (Entry<FrameworkKey, Collection<DependencyRequest>> entry :
+      dependenciesByKeyMap.entrySet()) {
       // collect together all of the names that we would want to call the provider
       ImmutableSet<String> dependencyNames = FluentIterable.from(entry.getValue())
           .transform(new DependencyVariableNamer())
           .toSet();
 
-      final String baseProviderName;
       if (dependencyNames.size() == 1) {
         // if there's only one name, great!  use it!
         String name = Iterables.getOnlyElement(dependencyNames);
-        baseProviderName = name.endsWith("Provider") ? name : name + "Provider";
+        providerNames.put(entry.getKey(), name.endsWith("Provider") ? name : name + "Provider");
       } else {
         // in the event that a provider is being used for a bunch of deps with different names,
         // add all the names together with "And"s in the middle.  E.g.: stringAndS
@@ -171,20 +175,10 @@
           compositeNameBuilder.append("And")
               .append(CaseFormat.LOWER_CAMEL.to(UPPER_CAMEL, namesIterator.next()));
         }
-        baseProviderName = compositeNameBuilder.append("Provider").toString();
+        providerNames.put(entry.getKey(), compositeNameBuilder.append("Provider").toString());
       }
-
-      // in the unlikely event that we have more that one provider with the exact same name,
-      // just add numbers at the end until there is no collision
-      String candidateName = baseProviderName;
-      for (int candidateNum = 2; providerNames.containsValue(candidateName); candidateNum++) {
-        candidateName = baseProviderName + candidateNum;
-      }
-
-      providerNames.put(entry.getKey(), candidateName);
     }
-    // return the map so that it is sorted by name
-    return ImmutableBiMap.copyOf(ImmutableSortedMap.copyOf(providerNames.inverse())).inverse();
+    return providerNames.build();
   }
 
   // TODO(gak): this needs to suck less
@@ -234,16 +228,17 @@ public String visitType(TypeElement e, Void p) {
         }));
   }
 
-  static String providerUsageStatement(String providerName,
+  static Snippet frameworkTypeUsageStatement(String frameworkTypeName,
       DependencyRequest.Kind dependencyKind) {
     switch (dependencyKind) {
       case LAZY:
-        return String.format("%s.create(%s)",
-            DoubleCheckLazy.class.getSimpleName(), providerName);
+        return Snippet.format("%s.create(%s)",
+            ClassName.fromClass(DoubleCheckLazy.class), frameworkTypeName);
       case INSTANCE:
-        return String.format("%s.get()", providerName);
+        return Snippet.format("%s.get()", frameworkTypeName);
       case PROVIDER:
-        return String.format("%s", providerName);
+      case MEMBERS_INJECTOR:
+        return Snippet.format("%s", frameworkTypeName);
       default:
         throw new AssertionError();
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/AnnotationWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/AnnotationWriter.java
new file mode 100644
index 000000000..82ee2034b
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/AnnotationWriter.java
@@ -0,0 +1,57 @@
+package dagger.internal.codegen.writer;
+
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Iterables;
+import com.google.common.collect.Maps;
+import dagger.internal.codegen.writer.JavaWriter.CompilationUnitContext;
+import java.io.IOException;
+import java.util.Map.Entry;
+import java.util.Set;
+import java.util.SortedMap;
+
+import static dagger.internal.codegen.writer.Writables.toStringWritable;
+
+public class AnnotationWriter implements Writable, HasClassReferences {
+  private final ClassName annotationName;
+  private final SortedMap<String, Writable> memberMap = Maps.newTreeMap();
+
+  AnnotationWriter(ClassName annotationName) {
+    this.annotationName = annotationName;
+  }
+
+  public void setValue(String value) {
+    setMember("value", value);
+  }
+
+  public void setMember(String name, int value) {
+    memberMap.put(name, toStringWritable(value));
+  }
+
+  public void setMember(String name, String value) {
+    memberMap.put(name, toStringWritable(StringLiteral.forValue(value)));
+  }
+
+  @Override
+  public Appendable write(Appendable appendable, CompilationUnitContext context)
+      throws IOException {
+    appendable.append('@');
+    annotationName.write(appendable, context);
+    if (!memberMap.isEmpty()) {
+      appendable.append('(');
+      if (memberMap.size() == 1) {
+        Entry<String, Writable> onlyEntry = Iterables.getOnlyElement(memberMap.entrySet());
+        if (!onlyEntry.getKey().equals("value")) {
+          appendable.append(onlyEntry.getKey()).append(" = ");
+        }
+        onlyEntry.getValue().write(appendable, context);
+      }
+      appendable.append(')');
+    }
+    return appendable;
+  }
+
+  @Override
+  public Set<ClassName> referencedClasses() {
+    return ImmutableSet.of(annotationName);
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/BlockWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/BlockWriter.java
new file mode 100644
index 000000000..50bfe2dfc
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/BlockWriter.java
@@ -0,0 +1,53 @@
+package dagger.internal.codegen.writer;
+
+import com.google.common.base.Function;
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.Lists;
+import dagger.internal.codegen.writer.JavaWriter.CompilationUnitContext;
+import java.io.IOException;
+import java.util.List;
+import java.util.Set;
+
+public final class BlockWriter implements Writable, HasClassReferences {
+  private final List<Snippet> snippets;
+
+  BlockWriter() {
+    this.snippets = Lists.newArrayList();
+  }
+
+  public BlockWriter addSnippet(String snippet, Object... args) {
+    snippets.add(Snippet.format(snippet, args));
+    return this;
+  }
+
+  public BlockWriter addSnippet(Snippet snippet) {
+    snippets.add(snippet);
+    return this;
+  }
+
+  boolean isEmpty() {
+    return snippets.isEmpty();
+  }
+
+  @Override
+  public Appendable write(Appendable appendable, CompilationUnitContext context)
+      throws IOException {
+    for (Snippet snippet : snippets) {
+      appendable.append('\n');
+      snippet.write(appendable, context);
+    }
+    return appendable.append('\n');
+  }
+
+  @Override
+  public Set<ClassName> referencedClasses() {
+    return FluentIterable.from(snippets)
+        .transformAndConcat(new Function<HasClassReferences, Set<ClassName>>() {
+          @Override
+          public Set<ClassName> apply(HasClassReferences input) {
+            return input.referencedClasses();
+          }
+        })
+        .toSet();
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ClassName.java b/compiler/src/main/java/dagger/internal/codegen/writer/ClassName.java
similarity index 60%
rename from compiler/src/main/java/dagger/internal/codegen/ClassName.java
rename to compiler/src/main/java/dagger/internal/codegen/writer/ClassName.java
index 89ce24e96..8e89fe184 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ClassName.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/ClassName.java
@@ -13,29 +13,32 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package dagger.internal.codegen;
+package dagger.internal.codegen.writer;
 
-import com.google.auto.value.AutoValue;
 import com.google.common.base.Ascii;
-import com.google.common.base.CaseFormat;
-import com.google.common.base.CharMatcher;
 import com.google.common.base.Joiner;
+import com.google.common.base.Objects;
+import com.google.common.base.Optional;
 import com.google.common.base.Splitter;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Sets;
+import dagger.internal.codegen.writer.JavaWriter.CompilationUnitContext;
+import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.Iterator;
 import java.util.List;
+import java.util.Set;
+import javax.lang.model.SourceVersion;
 import javax.lang.model.element.Element;
+import javax.lang.model.element.ElementKind;
 import javax.lang.model.element.NestingKind;
 import javax.lang.model.element.PackageElement;
 import javax.lang.model.element.TypeElement;
 
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
-import static dagger.internal.codegen.Util.isValidJavaIdentifier;
 import static javax.lang.model.element.NestingKind.MEMBER;
 import static javax.lang.model.element.NestingKind.TOP_LEVEL;
 
@@ -45,11 +48,41 @@
  *
  * @since 2.0
  */
-@AutoValue
-abstract class ClassName implements Comparable<ClassName> {
+public final class ClassName implements Comparable<ClassName>, TypeName {
   private String fullyQualifiedName = null;
+  private final String packageName;
+  /* From top to bottom.  E.g.: this field will contian ["A", "B"] for pgk.A.B.C */
+  private final ImmutableList<String> enclosingSimpleNames;
+  private final String simpleName;
+
+  private ClassName(String packageName, ImmutableList<String> enclosingSimpleNames,
+      String simpleName) {
+    this.packageName = packageName;
+    this.enclosingSimpleNames = enclosingSimpleNames;
+    this.simpleName = simpleName;
+  }
+
+  public String packageName() {
+    return packageName;
+  }
+
+  public ImmutableList<String> enclosingSimpleNames() {
+    return enclosingSimpleNames;
+  }
+
+  public Optional<ClassName> enclosingClassName() {
+    return enclosingSimpleNames.isEmpty()
+        ? Optional.<ClassName>absent()
+        : Optional.of(new ClassName(packageName,
+            enclosingSimpleNames.subList(0, enclosingSimpleNames.size() - 1),
+            enclosingSimpleNames.get(enclosingSimpleNames.size() - 1)));
+  }
+
+  public String simpleName() {
+    return simpleName;
+  }
 
-  String fullyQualifiedName() {
+  public String canonicalName() {
     if (fullyQualifiedName == null) {
       StringBuilder builder = new StringBuilder(packageName());
       if (builder.length() > 0) {
@@ -63,7 +96,7 @@ String fullyQualifiedName() {
     return fullyQualifiedName;
   }
 
-  String classFileName() {
+  public String classFileName() {
     StringBuilder builder = new StringBuilder();
     Joiner.on('$').appendTo(builder, enclosingSimpleNames());
     if (!enclosingSimpleNames().isEmpty()) {
@@ -72,30 +105,19 @@ String classFileName() {
     return builder.append(simpleName()).toString();
   }
 
-  abstract String packageName();
-  /* From top to bottom.  E.g.: this field will contian ["A", "B"] for pgk.A.B.C */
-  abstract ImmutableList<String> enclosingSimpleNames();
-  abstract String simpleName();
-
-
-  String suggestedVariableName() {
-    return CharMatcher.is('$').removeFrom(
-        CaseFormat.UPPER_CAMEL.to(CaseFormat.LOWER_CAMEL, simpleName()));
-  }
-
-  ClassName topLevelClassName() {
+  public ClassName topLevelClassName() {
     Iterator<String> enclosingIterator = enclosingSimpleNames().iterator();
     return enclosingIterator.hasNext()
-        ? new AutoValue_ClassName(packageName(), ImmutableList.<String>of(),
+        ? new ClassName(packageName(), ImmutableList.<String>of(),
             enclosingIterator.next())
         : this;
   }
 
-  ClassName memberClassNamed(String memberClassName) {
+  public ClassName nestedClassNamed(String memberClassName) {
     checkNotNull(memberClassName);
-    checkArgument(isValidJavaIdentifier(memberClassName));
+    checkArgument(SourceVersion.isIdentifier(memberClassName));
     checkArgument(Ascii.isUpperCase(memberClassName.charAt(0)));
-    return new AutoValue_ClassName(packageName(),
+    return new ClassName(packageName(),
         new ImmutableList.Builder<String>()
             .addAll(enclosingSimpleNames())
             .add(simpleName())
@@ -103,17 +125,17 @@ ClassName memberClassNamed(String memberClassName) {
         memberClassName);
   }
 
-  ClassName peerNamed(String peerClassName) {
+  public ClassName peerNamed(String peerClassName) {
     checkNotNull(peerClassName);
-    checkArgument(isValidJavaIdentifier(peerClassName));
+    checkArgument(SourceVersion.isIdentifier(peerClassName));
     checkArgument(Ascii.isUpperCase(peerClassName.charAt(0)));
-    return new AutoValue_ClassName(packageName(), enclosingSimpleNames(), peerClassName);
+    return new ClassName(packageName(), enclosingSimpleNames(), peerClassName);
   }
 
   private static final ImmutableSet<NestingKind> ACCEPTABLE_NESTING_KINDS =
       Sets.immutableEnumSet(TOP_LEVEL, MEMBER);
 
-  static ClassName fromTypeElement(TypeElement element) {
+  public static ClassName fromTypeElement(TypeElement element) {
     checkNotNull(element);
     checkArgument(ACCEPTABLE_NESTING_KINDS.contains(element.getNestingKind()));
     String simpleName = element.getSimpleName().toString();
@@ -124,13 +146,13 @@ static ClassName fromTypeElement(TypeElement element) {
       enclosingNames.add(current.getSimpleName().toString());
       current = current.getEnclosingElement();
     }
-    PackageElement packageElement = Util.getPackage(current);
+    PackageElement packageElement = getPackage(current);
     Collections.reverse(enclosingNames);
-    return new AutoValue_ClassName(packageElement.getQualifiedName().toString(),
+    return new ClassName(packageElement.getQualifiedName().toString(),
         ImmutableList.copyOf(enclosingNames), simpleName);
   }
 
-  static ClassName fromClass(Class<?> clazz) {
+  public static ClassName fromClass(Class<?> clazz) {
     checkNotNull(clazz);
     List<String> enclosingNames = new ArrayList<String>();
     Class<?> current = clazz.getEnclosingClass();
@@ -142,6 +164,13 @@ static ClassName fromClass(Class<?> clazz) {
     return create(clazz.getPackage().getName(), enclosingNames, clazz.getSimpleName());
   }
 
+  private static PackageElement getPackage(Element type) {
+    while (type.getKind() != ElementKind.PACKAGE) {
+      type = type.getEnclosingElement();
+    }
+    return (PackageElement) type;
+  }
+
   /**
    * Returns a new {@link ClassName} instance for the given fully-qualified class name string. This
    * method assumes that the input is ASCII and follows typical Java style (lower-case package
@@ -150,13 +179,13 @@ static ClassName fromClass(Class<?> clazz) {
    * {@link #fromClass(Class)} should be preferred as they can correctly create {@link ClassName}
    * instances without such restrictions.
    */
-  static ClassName bestGuessFromString(String classNameString) {
+  public static ClassName bestGuessFromString(String classNameString) {
     checkNotNull(classNameString);
     List<String> parts = Splitter.on('.').splitToList(classNameString);
     int firstClassPartIndex = -1;
     for (int i = 0; i < parts.size(); i++) {
       String part = parts.get(i);
-      checkArgument(isValidJavaIdentifier(part));
+      checkArgument(SourceVersion.isIdentifier(part));
       char firstChar = part.charAt(0);
       if (Ascii.isLowerCase(firstChar)) {
         // looks like a package part
@@ -173,7 +202,7 @@ static ClassName bestGuessFromString(String classNameString) {
       }
     }
     int lastIndex = parts.size() - 1;
-    return new AutoValue_ClassName(
+    return new ClassName(
         Joiner.on('.').join(parts.subList(0, firstClassPartIndex)),
         firstClassPartIndex == lastIndex
             ? ImmutableList.<String>of()
@@ -181,23 +210,54 @@ static ClassName bestGuessFromString(String classNameString) {
         parts.get(lastIndex));
   }
 
-  static ClassName create(String packageName,
-      List<String> enclosingSimpleNames, String simpleName) {
-    return new AutoValue_ClassName(packageName, ImmutableList.copyOf(enclosingSimpleNames),
+  public static ClassName create(
+      String packageName, List<String> enclosingSimpleNames, String simpleName) {
+    return new ClassName(packageName, ImmutableList.copyOf(enclosingSimpleNames),
         simpleName);
   }
 
-  static ClassName create(String packageName, String simpleName) {
-    return new AutoValue_ClassName(packageName, ImmutableList.<String>of(), simpleName);
+  public static ClassName create(String packageName, String simpleName) {
+    return new ClassName(packageName, ImmutableList.<String>of(), simpleName);
   }
 
   @Override
   public String toString() {
-    return fullyQualifiedName();
+    return canonicalName();
+  }
+
+  @Override
+  public Appendable write(Appendable appendable, CompilationUnitContext context)
+      throws IOException {
+    appendable.append(context.sourceReferenceForClassName(this));
+    return appendable;
+  }
+
+  @Override
+  public boolean equals(Object obj) {
+    if (obj == this) {
+      return true;
+    } else if (obj instanceof ClassName) {
+      ClassName that = (ClassName) obj;
+      return this.packageName.equals(that.packageName)
+          && this.enclosingSimpleNames.equals(that.enclosingSimpleNames)
+          && this.simpleName.equals(that.simpleName);
+    } else {
+      return false;
+    }
+  }
+
+  @Override
+  public int hashCode() {
+    return Objects.hashCode(packageName, enclosingSimpleNames, simpleName);
   }
 
   @Override
   public int compareTo(ClassName o) {
-    return fullyQualifiedName().compareTo(o.fullyQualifiedName());
+    return canonicalName().compareTo(o.canonicalName());
+  }
+
+  @Override
+  public Set<ClassName> referencedClasses() {
+    return ImmutableSet.of(this);
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/ClassWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/ClassWriter.java
new file mode 100644
index 000000000..ffe8c8f18
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/ClassWriter.java
@@ -0,0 +1,170 @@
+package dagger.internal.codegen.writer;
+
+import com.google.common.base.Function;
+import com.google.common.base.Joiner;
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.Iterables;
+import com.google.common.collect.Lists;
+import com.google.common.collect.Sets;
+import dagger.internal.codegen.writer.JavaWriter.CompilationUnitContext;
+import java.io.IOException;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Set;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.TypeMirror;
+
+import static javax.lang.model.element.Modifier.PRIVATE;
+import static javax.lang.model.element.Modifier.PROTECTED;
+import static javax.lang.model.element.Modifier.PUBLIC;
+
+public final class ClassWriter extends TypeWriter {
+  private final List<TypeWriter> nestedTypeWriters;
+  private final List<FieldWriter> fieldWriters;
+  private final List<ConstructorWriter> constructorWriters;
+  private final List<MethodWriter> methodWriters;
+  private final List<TypeVariableName> typeVariables;
+
+  ClassWriter(ClassName className) {
+    super(className);
+    this.nestedTypeWriters = Lists.newArrayList();
+    this.fieldWriters = Lists.newArrayList();
+    this.constructorWriters = Lists.newArrayList();
+    this.methodWriters = Lists.newArrayList();
+    this.typeVariables = Lists.newArrayList();
+  }
+
+  public void addImplementedType(TypeName typeReference) {
+    implementedTypes.add(typeReference);
+  }
+
+  public void addImplementedType(TypeElement typeElement) {
+    implementedTypes.add(ClassName.fromTypeElement(typeElement));
+  }
+
+  public FieldWriter addField(Class<?> type, String name) {
+    FieldWriter fieldWriter = new FieldWriter(ClassName.fromClass(type), name);
+    fieldWriters.add(fieldWriter);
+    return fieldWriter;
+  }
+
+  public FieldWriter addField(TypeElement type, String name) {
+    FieldWriter fieldWriter = new FieldWriter(ClassName.fromTypeElement(type), name);
+    fieldWriters.add(fieldWriter);
+    return fieldWriter;
+  }
+
+  public FieldWriter addField(TypeName type, String name) {
+    FieldWriter fieldWriter = new FieldWriter(type, name);
+    fieldWriters.add(fieldWriter);
+    return fieldWriter;
+  }
+
+  public ConstructorWriter addConstructor() {
+    ConstructorWriter constructorWriter = new ConstructorWriter(name.simpleName());
+    constructorWriters.add(constructorWriter);
+    return constructorWriter;
+  }
+
+  public ClassWriter addNestedClass(String name) {
+    ClassWriter innerClassWriter = new ClassWriter(this.name.nestedClassNamed(name));
+    nestedTypeWriters.add(innerClassWriter);
+    return innerClassWriter;
+  }
+
+  public MethodWriter addMethod(TypeWriter returnType, String name) {
+    MethodWriter methodWriter = new MethodWriter(returnType.name, name);
+    methodWriters.add(methodWriter);
+    return methodWriter;
+  }
+
+  public MethodWriter addMethod(TypeMirror returnType, String name) {
+    MethodWriter methodWriter =
+        new MethodWriter(TypeReferences.forTypeMirror(returnType), name);
+    methodWriters.add(methodWriter);
+    return methodWriter;
+  }
+
+  public MethodWriter addMethod(TypeName returnType, String name) {
+    MethodWriter methodWriter = new MethodWriter(returnType, name);
+    methodWriters.add(methodWriter);
+    return methodWriter;
+  }
+
+  public MethodWriter addMethod(Class<?> returnType, String name) {
+    MethodWriter methodWriter =
+        new MethodWriter(ClassName.fromClass(returnType), name);
+    methodWriters.add(methodWriter);
+    return methodWriter;
+  }
+
+  @Override
+  public Appendable write(Appendable appendable, CompilationUnitContext context)
+      throws IOException {
+    writeAnnotations(appendable, context);
+    writeModifiers(appendable).append("class ").append(name.simpleName());
+    if (!typeVariables.isEmpty()) {
+      appendable.append('<');
+      Joiner.on(", ").appendTo(appendable, typeVariables);
+      appendable.append('>');
+    }
+    if (supertype.isPresent()) {
+      appendable.append(" extends ");
+      supertype.get().write(appendable, context);
+    }
+    Iterator<TypeName> implementedTypesIterator = implementedTypes.iterator();
+    if (implementedTypesIterator.hasNext()) {
+      appendable.append(" implements ");
+      implementedTypesIterator.next().write(appendable, context);
+      while (implementedTypesIterator.hasNext()) {
+        appendable.append(", ");
+        implementedTypesIterator.next().write(appendable, context);
+      }
+    }
+    appendable.append(" {\n");
+    for (VariableWriter fieldWriter : fieldWriters) {
+      fieldWriter.write(new IndentingAppendable(appendable), context).append("\n");
+    }
+    appendable.append('\n');
+    for (ConstructorWriter constructorWriter : constructorWriters) {
+      if (!isDefaultConstructor(constructorWriter)) {
+        constructorWriter.write(new IndentingAppendable(appendable), context);
+      }
+    }
+    appendable.append('\n');
+    for (MethodWriter methodWriter : methodWriters) {
+      methodWriter.write(new IndentingAppendable(appendable), context);
+    }
+    appendable.append('\n');
+    for (TypeWriter nestedTypeWriter : nestedTypeWriters) {
+      nestedTypeWriter.write(new IndentingAppendable(appendable), context);
+    }
+    appendable.append("}\n");
+    return appendable;
+  }
+
+  private static final Set<Modifier> VISIBILIY_MODIFIERS =
+      Sets.immutableEnumSet(PUBLIC, PROTECTED, PRIVATE);
+
+  private boolean isDefaultConstructor(ConstructorWriter constructorWriter) {
+    return Sets.intersection(VISIBILIY_MODIFIERS, modifiers)
+        .equals(Sets.intersection(VISIBILIY_MODIFIERS, constructorWriter.modifiers))
+        && constructorWriter.body().isEmpty();
+  }
+
+  @Override
+  public Set<ClassName> referencedClasses() {
+    Iterable<? extends HasClassReferences> concat =
+        Iterables.concat(nestedTypeWriters, fieldWriters, constructorWriters, methodWriters,
+            implementedTypes, supertype.asSet(), annotations);
+    return FluentIterable.from(concat)
+        .transformAndConcat(new Function<HasClassReferences, Set<ClassName>>() {
+          @Override
+          public Set<ClassName> apply(HasClassReferences input) {
+            return input.referencedClasses();
+          }
+        })
+        .toSet();
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/ConstructorWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/ConstructorWriter.java
new file mode 100644
index 000000000..cbdb6108b
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/ConstructorWriter.java
@@ -0,0 +1,86 @@
+package dagger.internal.codegen.writer;
+
+import com.google.common.base.Function;
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.Iterables;
+import com.google.common.collect.Maps;
+import dagger.internal.codegen.writer.JavaWriter.CompilationUnitContext;
+import java.io.IOException;
+import java.util.Iterator;
+import java.util.Map;
+import java.util.Set;
+import javax.lang.model.element.TypeElement;
+
+import static com.google.common.base.Preconditions.checkArgument;
+
+public class ConstructorWriter extends Modifiable implements Writable, HasClassReferences {
+  private final String name;
+  private final Map<String, VariableWriter> parameterWriters;
+  private final BlockWriter blockWriter;
+
+  ConstructorWriter(String name) {
+    this.name = name;
+    this.parameterWriters = Maps.newLinkedHashMap();
+    this.blockWriter = new BlockWriter();
+  }
+
+  public VariableWriter addParameter(Class<?> type, String name) {
+    return addParameter(ClassName.fromClass(type), name);
+  }
+
+  public VariableWriter addParameter(TypeElement type, String name) {
+    return addParameter(ClassName.fromTypeElement(type), name);
+  }
+
+  public VariableWriter addParameter(TypeWriter type, String name) {
+    return addParameter(type.name, name);
+  }
+
+  public VariableWriter addParameter(TypeName type, String name) {
+    VariableWriter parameterWriter = new VariableWriter(type, name);
+    parameterWriters.put(name, parameterWriter);
+    return parameterWriter;
+  }
+
+  public BlockWriter body() {
+    return blockWriter;
+  }
+
+  private VariableWriter addParameter(ClassName type, String name) {
+    checkArgument(!parameterWriters.containsKey(name));
+    VariableWriter parameterWriter = new VariableWriter(type, name);
+    parameterWriters.put(name, parameterWriter);
+    return parameterWriter;
+  }
+
+  @Override
+  public Set<ClassName> referencedClasses() {
+    return FluentIterable.from(
+        Iterables.concat(parameterWriters.values(), ImmutableList.of(blockWriter)))
+            .transformAndConcat(new Function<HasClassReferences, Set<ClassName>>() {
+              @Override
+              public Set<ClassName> apply(HasClassReferences input) {
+                return input.referencedClasses();
+              }
+            })
+            .toSet();
+  }
+
+  @Override
+  public Appendable write(Appendable appendable, CompilationUnitContext context)
+      throws IOException {
+    writeModifiers(appendable).append(name).append('(');
+    Iterator<VariableWriter> parameterWritersIterator = parameterWriters.values().iterator();
+    if (parameterWritersIterator.hasNext()) {
+      parameterWritersIterator.next().write(appendable, context);
+    }
+    while (parameterWritersIterator.hasNext()) {
+      appendable.append(", ");
+      parameterWritersIterator.next().write(appendable, context);
+    }
+    appendable.append(") {");
+    blockWriter.write(new IndentingAppendable(appendable), context);
+    return appendable.append("}\n");
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/FieldWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/FieldWriter.java
new file mode 100644
index 000000000..0d2565774
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/FieldWriter.java
@@ -0,0 +1,49 @@
+package dagger.internal.codegen.writer;
+
+import com.google.common.base.Function;
+import com.google.common.base.Optional;
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.Iterables;
+import dagger.internal.codegen.writer.JavaWriter.CompilationUnitContext;
+import java.io.IOException;
+import java.util.Set;
+
+public class FieldWriter extends VariableWriter {
+  private Optional<Snippet> initializer;
+
+  FieldWriter(TypeName type, String name) {
+    super(type, name);
+    this.initializer = Optional.absent();
+  }
+
+  public void setInitializer(Snippet initializer) {
+    this.initializer = Optional.of(initializer);
+  }
+
+  @Override
+  public Appendable write(Appendable appendable, CompilationUnitContext context)
+      throws IOException {
+    super.write(appendable, context);
+    if (initializer.isPresent()) {
+      appendable.append(" = ");
+      initializer.get().write(appendable, context);
+    }
+    appendable.append(';');
+    return appendable;
+  }
+
+  @Override
+  public Set<ClassName> referencedClasses() {
+    Iterable<? extends HasClassReferences> concat =
+        Iterables.concat(ImmutableList.of(type()), initializer.asSet(), annotations);
+    return FluentIterable.from(concat)
+        .transformAndConcat(new Function<HasClassReferences, Set<ClassName>>() {
+          @Override
+          public Set<ClassName> apply(HasClassReferences input) {
+            return input.referencedClasses();
+          }
+        })
+        .toSet();
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/HasClassReferences.java b/compiler/src/main/java/dagger/internal/codegen/writer/HasClassReferences.java
new file mode 100644
index 000000000..137f8e86e
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/HasClassReferences.java
@@ -0,0 +1,7 @@
+package dagger.internal.codegen.writer;
+
+import java.util.Set;
+
+public interface HasClassReferences {
+  Set<ClassName> referencedClasses();
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/IndentingAppendable.java b/compiler/src/main/java/dagger/internal/codegen/writer/IndentingAppendable.java
new file mode 100644
index 000000000..bb1273e71
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/IndentingAppendable.java
@@ -0,0 +1,77 @@
+package dagger.internal.codegen.writer;
+
+import com.google.common.collect.AbstractIterator;
+import java.io.IOException;
+import java.util.Iterator;
+
+final class IndentingAppendable implements Appendable {
+  private final String indentation;
+  private final Appendable delegate;
+  private boolean requiresIndent = true;
+
+  IndentingAppendable(Appendable delegate) {
+    this("  ", delegate);
+  }
+
+  IndentingAppendable(String indentation, Appendable delegate) {
+    this.indentation = indentation;
+    this.delegate = delegate;
+  }
+
+  @Override
+  public Appendable append(CharSequence csq) throws IOException {
+    return append(csq, 0, csq.length());
+  }
+
+  @Override
+  public Appendable append(CharSequence csq, int start, int end) throws IOException {
+    Iterator<CharSequence> lines = lines(csq, start, end);
+    while (lines.hasNext()) {
+      CharSequence line = lines.next();
+      maybeIndent();
+      delegate.append(line);
+      if (line.charAt(line.length() - 1) == '\n') {
+        requiresIndent = true;
+      }
+    }
+    return this;
+  }
+
+  @Override
+  public Appendable append(char c) throws IOException {
+    maybeIndent();
+    delegate.append(c);
+    if (c == '\n') {
+      requiresIndent = true;
+    }
+    return this;
+  }
+
+  void maybeIndent() throws IOException {
+    if (requiresIndent) {
+      delegate.append(indentation);
+    }
+    requiresIndent = false;
+  }
+
+  private static Iterator<CharSequence> lines(
+      final CharSequence csq, final int start, final int end) {
+    return new AbstractIterator<CharSequence>() {
+      int index = start;
+
+      @Override protected CharSequence computeNext() {
+        int nextStart = index;
+        while (index < end && csq.charAt(index) != '\n') {
+          index++;
+        }
+        if (index < end && csq.charAt(index) == '\n') {
+          index++;
+        }
+        int nextEnd = index;
+        return nextStart >= end
+            ? endOfData()
+            : csq.subSequence(nextStart, nextEnd);
+      }
+    };
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/InterfaceWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/InterfaceWriter.java
new file mode 100644
index 000000000..ce610f63d
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/InterfaceWriter.java
@@ -0,0 +1,59 @@
+package dagger.internal.codegen.writer;
+
+import com.google.common.base.Function;
+import com.google.common.base.Joiner;
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.Lists;
+import dagger.internal.codegen.writer.JavaWriter.CompilationUnitContext;
+import java.io.IOException;
+import java.util.List;
+import java.util.Set;
+
+public class InterfaceWriter extends TypeWriter {
+  private final List<TypeVariableName> typeVariables;
+  private final List<MethodWriter> methodWriters;
+  private final List<TypeWriter> nestedTypeWriters;
+
+  InterfaceWriter(ClassName name) {
+    super(name);
+    this.typeVariables = Lists.newArrayList();
+    this.methodWriters = Lists.newArrayList();
+    this.nestedTypeWriters = Lists.newArrayList();
+  }
+
+  public void addTypeVariable(TypeVariableName typeVariable) {
+    this.typeVariables.add(typeVariable);
+  }
+
+  @Override
+  public Appendable write(Appendable appendable, CompilationUnitContext context) throws IOException {
+    writeModifiers(appendable).append("class ").append(name.simpleName());
+    if (!typeVariables.isEmpty()) {
+      appendable.append('<');
+      Joiner.on(", ").appendTo(appendable, typeVariables);
+      appendable.append('>');
+    }
+    appendable.append(" {\n");
+    for (MethodWriter methodWriter : methodWriters) {
+      methodWriter.write(new IndentingAppendable(appendable), context);
+    }
+    appendable.append('\n');
+    for (TypeWriter nestedTypeWriter : nestedTypeWriters) {
+      nestedTypeWriter.write(new IndentingAppendable(appendable), context);
+    }
+    appendable.append("}\n");
+    return appendable;
+  }
+
+  @Override
+  public Set<ClassName> referencedClasses() {
+    return FluentIterable.from(nestedTypeWriters)
+        .transformAndConcat(new Function<HasClassReferences, Set<ClassName>>() {
+          @Override
+          public Set<ClassName> apply(HasClassReferences input) {
+            return input.referencedClasses();
+          }
+        })
+        .toSet();
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/JavaWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/JavaWriter.java
new file mode 100644
index 000000000..ff5570cb5
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/JavaWriter.java
@@ -0,0 +1,222 @@
+package dagger.internal.codegen.writer;
+
+import com.google.common.base.Function;
+import com.google.common.base.Optional;
+import com.google.common.collect.BiMap;
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.HashBiMap;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.ImmutableSortedSet;
+import com.google.common.collect.Iterables;
+import com.google.common.collect.Lists;
+import com.google.common.collect.Ordering;
+import com.google.common.io.Closer;
+import java.io.IOException;
+import java.util.List;
+import java.util.Set;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+import javax.annotation.processing.Filer;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.PackageElement;
+import javax.tools.JavaFileObject;
+
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkNotNull;
+import static javax.lang.model.element.Modifier.PRIVATE;
+import static javax.lang.model.element.Modifier.PROTECTED;
+import static javax.lang.model.element.Modifier.STATIC;
+
+/**
+ * Writes a single compilation unit.
+ */
+public final class JavaWriter {
+  public static JavaWriter inPackage(String packageName) {
+    return new JavaWriter(packageName);
+  }
+
+  public static JavaWriter inPackage(Package enclosingPackage) {
+    return new JavaWriter(enclosingPackage.getName());
+  }
+
+  public static JavaWriter inPackage(PackageElement packageElement) {
+    return new JavaWriter(packageElement.getQualifiedName().toString());
+  }
+
+  private final String packageName;
+  // TODO(gak): disallow multiple types in a file
+  private final List<TypeWriter> typeWriters;
+  private final List<ClassName> explicitImports;
+
+  private JavaWriter(String packageName) {
+    this.packageName = packageName;
+    this.typeWriters = Lists.newArrayList();
+    this.explicitImports = Lists.newArrayList();
+  }
+
+  public JavaWriter addImport(Class<?> importedClass) {
+    explicitImports.add(ClassName.fromClass(importedClass));
+    return this;
+  }
+
+  public ClassWriter addClass(String simpleName) {
+    Set<Modifier> modifiers = ImmutableSet.<Modifier>of();
+    checkNotNull(modifiers);
+    checkNotNull(simpleName);
+    checkArgument(!modifiers.contains(PROTECTED));
+    checkArgument(!modifiers.contains(PRIVATE));
+    checkArgument(!modifiers.contains(STATIC));
+    checkNotNull(Optional.<Class<?>>absent());
+    checkNotNull(ImmutableSet.<Class<?>>of());
+    ClassWriter classWriter = new ClassWriter(ClassName.create(packageName, simpleName));
+    typeWriters.add(classWriter);
+    return classWriter;
+  }
+
+  public InterfaceWriter addInterface(String simpleName) {
+    InterfaceWriter writer = new InterfaceWriter(ClassName.create(packageName, simpleName));
+    typeWriters.add(writer);
+    return writer;
+  }
+
+  static ImmutableSet<ClassName> collectReferencedClasses(
+      Iterable<? extends HasClassReferences> iterable) {
+    return FluentIterable.from(iterable)
+        .transformAndConcat(new Function<HasClassReferences, Set<ClassName>>() {
+          @Override
+          public Set<ClassName> apply(HasClassReferences input) {
+            return input.referencedClasses();
+          }
+        })
+        .toSet();
+  }
+
+  public Appendable write(Appendable appendable) throws IOException {
+    appendable.append("package ").append(packageName).append(';').append("\n\n");
+
+    // write imports
+    ImmutableSet<ClassName> classNames = FluentIterable.from(typeWriters)
+        .transformAndConcat(new Function<HasClassReferences, Set<ClassName>>() {
+          @Override
+          public Set<ClassName> apply(HasClassReferences input) {
+            return input.referencedClasses();
+          }
+        })
+        .toSet();
+    BiMap<String, ClassName> importedClassIndex = HashBiMap.create();
+    // TODO(gak): check for collisions with types declared in this compilation unit too
+    ImmutableSortedSet<ClassName> importCandidates = ImmutableSortedSet.<ClassName>naturalOrder()
+        .addAll(explicitImports)
+        .addAll(classNames)
+        .build();
+    for (ClassName className : importCandidates) {
+      if (!(className.packageName().equals(packageName)
+              && !className.enclosingClassName().isPresent())
+          && !(className.packageName().equals("java.lang")
+              && className.enclosingSimpleNames().isEmpty())) {
+        Optional<ClassName> importCandidate = Optional.of(className);
+        while (importCandidate.isPresent()
+            && importedClassIndex.containsKey(importCandidate.get().simpleName())) {
+          importCandidate = importCandidate.get().enclosingClassName();
+        }
+        if (importCandidate.isPresent()) {
+          appendable.append("import ").append(className.canonicalName()).append(";\n");
+          importedClassIndex.put(className.simpleName(), className);
+        }
+      }
+    }
+
+    appendable.append('\n');
+
+    CompilationUnitContext context =
+        new CompilationUnitContext(ImmutableSet.copyOf(importedClassIndex.values()));
+
+    // write types
+    for (TypeWriter typeWriter : typeWriters) {
+      typeWriter.write(appendable, context).append('\n');
+    }
+    return appendable;
+  }
+
+  public void file(Filer filer, Iterable<? extends Element> originatingElements)
+      throws IOException {
+    JavaFileObject sourceFile = filer.createSourceFile(
+        Iterables.getOnlyElement(typeWriters).name.canonicalName(),
+        Iterables.toArray(originatingElements, Element.class));
+    Closer closer = Closer.create();
+    try {
+      write(closer.register(sourceFile.openWriter()));
+    } catch (Exception e) {
+      try {
+        sourceFile.delete();
+      } catch (Exception e2) {
+        // couldn't delete the file
+      }
+      throw closer.rethrow(e);
+    } finally {
+      closer.close();
+    }
+  }
+
+  @Override
+  public String toString() {
+    try {
+      return write(new StringBuilder()).toString();
+    } catch (IOException e) {
+      throw new AssertionError();
+    }
+  }
+
+  final class CompilationUnitContext {
+    private final ImmutableSortedSet<ClassName> importedClasses;
+
+    CompilationUnitContext(ImmutableSet<ClassName> importedClasses) {
+      this.importedClasses =
+          ImmutableSortedSet.copyOf(Ordering.natural().reverse(), importedClasses);
+    }
+
+    String sourceReferenceForClassName(ClassName className) {
+      if (isImported(className)) {
+        return className.simpleName();
+      }
+      Optional<ClassName> enclosingClassName = className.enclosingClassName();
+      while (enclosingClassName.isPresent()) {
+        if (isImported(enclosingClassName.get())) {
+          return className.canonicalName()
+              .substring(enclosingClassName.get().canonicalName().length() + 1);
+        }
+        enclosingClassName = enclosingClassName.get().enclosingClassName();
+      }
+      return className.canonicalName();
+    }
+
+    private boolean isImported(ClassName className) {
+      return (packageName.equals(className.packageName())
+              && !className.enclosingClassName().isPresent()) // need to account for scope & hiding
+          || importedClasses.contains(className)
+          || (className.packageName().equals("java.lang")
+              && className.enclosingSimpleNames().isEmpty());
+    }
+
+    private static final String JAVA_IDENTIFIER_REGEX =
+        "\\p{javaJavaIdentifierStart}\\p{javaJavaIdentifierPart}*";
+
+    String compressTypesWithin(String snippet) {
+
+      // TODO(gak): deal with string literals
+      for (ClassName importedClass : importedClasses) {
+        snippet = snippet.replace(importedClass.canonicalName(), importedClass.simpleName());
+      }
+      Pattern samePackagePattern = Pattern.compile(
+          packageName.replace(".", "\\.") + "\\.(" + JAVA_IDENTIFIER_REGEX + ")([^\\.])");
+      Matcher matcher = samePackagePattern.matcher(snippet);
+      StringBuffer buffer = new StringBuffer();
+      while (matcher.find()) {
+        matcher.appendReplacement(buffer, "$1$2");
+      }
+      matcher.appendTail(buffer);
+      return buffer.toString();
+    }
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/MethodWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/MethodWriter.java
new file mode 100644
index 000000000..29d672768
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/MethodWriter.java
@@ -0,0 +1,94 @@
+package dagger.internal.codegen.writer;
+
+import com.google.common.base.Function;
+import com.google.common.base.Optional;
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.Iterables;
+import com.google.common.collect.Maps;
+import dagger.internal.codegen.writer.JavaWriter.CompilationUnitContext;
+import java.io.IOException;
+import java.util.Iterator;
+import java.util.Map;
+import java.util.Set;
+
+import static com.google.common.base.Preconditions.checkArgument;
+
+
+public class MethodWriter extends Modifiable implements HasClassReferences, Writable {
+  private final TypeName returnType;
+  private final String name;
+  private final Map<String, VariableWriter> parameterWriters;
+  private Optional<BlockWriter> body;
+
+  MethodWriter(TypeName returnType, String name) {
+    this.returnType = returnType;
+    this.name = name;
+    this.parameterWriters = Maps.newLinkedHashMap();
+    this.body = Optional.absent();
+  }
+
+  public VariableWriter addParameter(Class<?> type, String name) {
+    return addParameter(ClassName.fromClass(type), name);
+  }
+
+  public VariableWriter addParameter(TypeWriter type, String name) {
+    return addParameter(type.name, name);
+  }
+
+  public VariableWriter addParameter(TypeName type, String name) {
+    checkArgument(!parameterWriters.containsKey(name));
+    VariableWriter parameterWriter = new VariableWriter(type, name);
+    parameterWriters.put(name, parameterWriter);
+    return parameterWriter;
+  }
+
+  public BlockWriter body() {
+    if (body.isPresent()) {
+      return body.get();
+    } else {
+      BlockWriter blockWriter = new BlockWriter();
+      body = Optional.of(blockWriter);
+      return blockWriter;
+    }
+  }
+
+  @Override
+  public Appendable write(Appendable appendable, CompilationUnitContext context)
+      throws IOException {
+    writeAnnotations(appendable, context);
+    writeModifiers(appendable);
+    returnType.write(appendable, context);
+    appendable.append(' ').append(name).append('(');
+    Iterator<VariableWriter> parameterWritersIterator = parameterWriters.values().iterator();
+    if (parameterWritersIterator.hasNext()) {
+      parameterWritersIterator.next().write(appendable, context);
+    }
+    while (parameterWritersIterator.hasNext()) {
+      appendable.append(", ");
+      parameterWritersIterator.next().write(appendable, context);
+    }
+    appendable.append(")");
+    if (body.isPresent()) {
+      appendable.append(" {");
+      body.get().write(new IndentingAppendable(appendable), context);
+      appendable.append("}\n");
+    } else {
+      appendable.append(";\n");
+    }
+    return appendable;
+  }
+
+  @Override
+  public Set<ClassName> referencedClasses() {
+    return FluentIterable.from(
+        Iterables.concat(ImmutableList.of(returnType), parameterWriters.values(), body.asSet()))
+            .transformAndConcat(new Function<HasClassReferences, Set<ClassName>>() {
+              @Override
+              public Set<ClassName> apply(HasClassReferences input) {
+                return input.referencedClasses();
+              }
+            })
+            .toSet();
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/Modifiable.java b/compiler/src/main/java/dagger/internal/codegen/writer/Modifiable.java
new file mode 100644
index 000000000..86ec45eda
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/Modifiable.java
@@ -0,0 +1,46 @@
+package dagger.internal.codegen.writer;
+
+import com.google.common.collect.Lists;
+import dagger.internal.codegen.writer.JavaWriter.CompilationUnitContext;
+import java.io.IOException;
+import java.lang.annotation.Annotation;
+import java.util.EnumSet;
+import java.util.List;
+import java.util.Set;
+import javax.lang.model.element.Modifier;
+
+public abstract class Modifiable {
+  final Set<Modifier> modifiers;
+  final List<AnnotationWriter> annotations;
+
+  Modifiable() {
+    this.modifiers = EnumSet.noneOf(Modifier.class);
+    this.annotations = Lists.newArrayList();
+  }
+
+  public void addModifiers(Modifier first, Modifier... rest) {
+    this.modifiers.addAll(Lists.asList(first, rest));
+  }
+
+  public AnnotationWriter annotate(Class<? extends Annotation> annotation) {
+    AnnotationWriter annotationWriter = new AnnotationWriter(ClassName.fromClass(annotation));
+    this.annotations.add(annotationWriter);
+    return annotationWriter;
+  }
+
+
+  Appendable writeModifiers(Appendable appendable) throws IOException {
+    for (Modifier modifier : modifiers) {
+      appendable.append(modifier.toString()).append(' ');
+    }
+    return appendable;
+  }
+
+  Appendable writeAnnotations(Appendable appendable, CompilationUnitContext context)
+      throws IOException {
+    for (AnnotationWriter annotationWriter : annotations) {
+      annotationWriter.write(appendable, context).append('\n');
+    }
+    return appendable;
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/ParameterizedTypeName.java b/compiler/src/main/java/dagger/internal/codegen/writer/ParameterizedTypeName.java
new file mode 100644
index 000000000..6e620a7eb
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/ParameterizedTypeName.java
@@ -0,0 +1,67 @@
+package dagger.internal.codegen.writer;
+
+import com.google.common.base.Joiner;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
+import dagger.internal.codegen.writer.JavaWriter.CompilationUnitContext;
+import java.io.IOException;
+import java.util.Iterator;
+import java.util.Set;
+
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Verify.verify;
+
+public class ParameterizedTypeName implements TypeName {
+  private final ClassName type;
+  private final ImmutableList<? extends TypeName> parameters;
+
+  ParameterizedTypeName(ClassName type, Iterable<? extends TypeName> parameters) {
+    this.type = type;
+    this.parameters = ImmutableList.copyOf(parameters);
+  }
+
+  @Override
+  public Set<ClassName> referencedClasses() {
+    ImmutableSet.Builder<ClassName> builder = new ImmutableSet.Builder<ClassName>()
+        .add(type);
+    for (TypeName parameter : parameters) {
+      builder.addAll(parameter.referencedClasses());
+    }
+    return builder.build();
+  }
+
+  @Override
+  public Appendable write(Appendable appendable, CompilationUnitContext context)
+      throws IOException {
+    appendable.append(context.sourceReferenceForClassName(type));
+    Iterator<? extends TypeName> parameterIterator = parameters.iterator();
+    verify(parameterIterator.hasNext(), type.toString());
+    appendable.append('<');
+    parameterIterator.next().write(appendable, context);
+    while (parameterIterator.hasNext()) {
+      appendable.append(", ");
+      parameterIterator.next().write(appendable, context);
+    }
+    appendable.append('>');
+    return appendable;
+  }
+
+  @Override
+  public String toString() {
+    StringBuilder builder = new StringBuilder(type.toString()).append('<');
+    Joiner.on(", ").appendTo(builder, parameters);
+    return builder.append('>').toString();
+  }
+
+  public static ParameterizedTypeName create(ClassName className,
+      TypeName... parameters) {
+    return new ParameterizedTypeName(className, ImmutableList.copyOf(parameters));
+  }
+
+  public static ParameterizedTypeName create(Class<?> parameterizedClass,
+      TypeName... parameters) {
+    checkArgument(parameterizedClass.getTypeParameters().length == parameters.length);
+    return new ParameterizedTypeName(ClassName.fromClass(parameterizedClass),
+        ImmutableList.copyOf(parameters));
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/PrimitiveName.java b/compiler/src/main/java/dagger/internal/codegen/writer/PrimitiveName.java
new file mode 100644
index 000000000..d2d50b5aa
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/PrimitiveName.java
@@ -0,0 +1,51 @@
+package dagger.internal.codegen.writer;
+
+import com.google.common.base.Ascii;
+import com.google.common.collect.ImmutableSet;
+import dagger.internal.codegen.writer.JavaWriter.CompilationUnitContext;
+import java.io.IOException;
+import java.util.Set;
+import javax.lang.model.type.PrimitiveType;
+
+public enum PrimitiveName implements TypeName {
+  BOOLEAN, BYTE, SHORT, INT, LONG, CHAR, FLOAT, DOUBLE;
+
+  @Override
+  public Set<ClassName> referencedClasses() {
+    return ImmutableSet.of();
+  }
+
+  @Override
+  public String toString() {
+    return Ascii.toLowerCase(name());
+  }
+
+  @Override
+  public Appendable write(Appendable appendable, CompilationUnitContext context)
+      throws IOException {
+    return appendable.append(toString());
+  }
+
+  static PrimitiveName forTypeMirror(PrimitiveType mirror) {
+    switch (mirror.getKind()) {
+      case BOOLEAN:
+        return BOOLEAN;
+      case BYTE:
+        return BYTE;
+      case SHORT:
+        return SHORT;
+      case INT:
+        return INT;
+      case LONG:
+        return LONG;
+      case CHAR:
+        return CHAR;
+      case FLOAT:
+        return FLOAT;
+      case DOUBLE:
+        return DOUBLE;
+      default:
+        throw new AssertionError();
+    }
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/Snippet.java b/compiler/src/main/java/dagger/internal/codegen/writer/Snippet.java
new file mode 100644
index 000000000..9968a7383
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/Snippet.java
@@ -0,0 +1,86 @@
+package dagger.internal.codegen.writer;
+
+import com.google.common.base.Function;
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableSet;
+import dagger.internal.codegen.writer.JavaWriter.CompilationUnitContext;
+import java.io.IOException;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Set;
+
+public final class Snippet implements HasClassReferences, Writable {
+  private final String value;
+  private final ImmutableSet<TypeName> types;
+
+  Snippet(String value, ImmutableSet<TypeName> types) {
+    this.value = value;
+    this.types = types;
+  }
+
+  public String value() {
+    return value;
+  }
+
+  public ImmutableSet<TypeName> types() {
+    return types;
+  }
+
+  @Override
+  public String toString() {
+    return value;
+  }
+
+  @Override
+  public Set<ClassName> referencedClasses() {
+    return FluentIterable.from(types)
+        .transformAndConcat(new Function<TypeName, Set<ClassName>>() {
+          @Override
+          public Set<ClassName> apply(TypeName input) {
+            return input.referencedClasses();
+          }
+        })
+        .toSet();
+  }
+
+  @Override
+  public Appendable write(Appendable appendable, CompilationUnitContext context)
+      throws IOException {
+    return appendable.append(context.compressTypesWithin(value));
+  }
+
+  public static Snippet format(String format, Object... args) {
+    String value = String.format(format, args);
+    ImmutableSet.Builder<TypeName> types = ImmutableSet.builder();
+    for (Object arg : args) {
+      if (arg instanceof Snippet) {
+        types.addAll(((Snippet) arg).types);
+      }
+      if (arg instanceof TypeName) {
+        types.add((TypeName) arg);
+      }
+    }
+    return new Snippet(value, types.build());
+  }
+
+  public static Snippet create(String value, Iterable<TypeName> types) {
+    return new Snippet(value, ImmutableSet.copyOf(types));
+  }
+
+  public static Snippet makeParametersSnippet(List<Snippet> parameterSnippets) {
+    Iterator<Snippet> iterator = parameterSnippets.iterator();
+    StringBuilder stringBuilder = new StringBuilder();
+    ImmutableSet.Builder<TypeName> typesBuilder = ImmutableSet.builder();
+    if (iterator.hasNext()) {
+      Snippet firstSnippet = iterator.next();
+      stringBuilder.append(firstSnippet.value());
+      typesBuilder.addAll(firstSnippet.types());
+    }
+    while (iterator.hasNext()) {
+      Snippet nextSnippet = iterator.next();
+      stringBuilder.append(", ").append(nextSnippet.value());
+      typesBuilder.addAll(nextSnippet.types());
+    }
+    return Snippet.create(stringBuilder.toString(), typesBuilder.build());
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/StringLiteral.java b/compiler/src/main/java/dagger/internal/codegen/writer/StringLiteral.java
new file mode 100644
index 000000000..0ec21a09e
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/StringLiteral.java
@@ -0,0 +1,91 @@
+// Copyright 2014 Square, Inc.
+package dagger.internal.codegen.writer;
+
+import java.util.Formatter;
+
+/**
+ * Represents a string literal as found in Java source code.
+ */
+public final class StringLiteral {
+  /** Returns a new {@link StringLiteral} instance for the intended value of the literal. */
+  public static StringLiteral forValue(String value) {
+    return new StringLiteral(value, stringLiteral(value));
+  }
+
+  /** Returns the string literal representing {@code data}, including wrapping quotes. */
+  private static String stringLiteral(String value) {
+    StringBuilder result = new StringBuilder();
+    result.append('"');
+    for (int i = 0; i < value.length(); i++) {
+      char c = value.charAt(i);
+      switch (c) {
+        case '"':
+          result.append("\\\"");
+          break;
+        case '\\':
+          result.append("\\\\");
+          break;
+        case '\b':
+          result.append("\\b");
+          break;
+        case '\t':
+          result.append("\\t");
+          break;
+        case '\n':
+          result.append("\\n");
+          break;
+        case '\f':
+          result.append("\\f");
+          break;
+        case '\r':
+          result.append("\\r");
+          break;
+        default:
+          if (Character.isISOControl(c)) {
+            new Formatter(result).format("\\u%04x", (int) c);
+          } else {
+            result.append(c);
+          }
+      }
+    }
+    result.append('"');
+    return result.toString();
+  }
+
+  private final String value;
+  private final String literal;
+
+  private StringLiteral(String value, String literal) {
+    this.value = value;
+    this.literal = literal;
+  }
+
+  public String value() {
+    return value;
+  }
+
+  public String literal() {
+    return literal;
+  }
+
+  @Override
+  public String toString() {
+    return literal;
+  }
+
+  @Override
+  public boolean equals(Object obj) {
+    if (obj == this) {
+      return true;
+    } else if (obj instanceof StringLiteral) {
+      return this.value.equals(((StringLiteral) obj).value);
+    } else {
+      return false;
+    }
+  }
+
+  @Override
+  public int hashCode() {
+    return value.hashCode();
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/TypeName.java b/compiler/src/main/java/dagger/internal/codegen/writer/TypeName.java
new file mode 100644
index 000000000..aa6070c3e
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/TypeName.java
@@ -0,0 +1,4 @@
+package dagger.internal.codegen.writer;
+
+public interface TypeName extends HasClassReferences, Writable {
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/TypeReferences.java b/compiler/src/main/java/dagger/internal/codegen/writer/TypeReferences.java
new file mode 100644
index 000000000..4960e356b
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/TypeReferences.java
@@ -0,0 +1,53 @@
+package dagger.internal.codegen.writer;
+
+import com.google.common.base.Function;
+import com.google.common.collect.FluentIterable;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.ArrayType;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.PrimitiveType;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.type.WildcardType;
+import javax.lang.model.util.SimpleTypeVisitor6;
+
+public class TypeReferences {
+  static Function<TypeMirror, TypeName> FOR_TYPE_MIRROR =
+      new Function<TypeMirror, TypeName>() {
+        @Override public TypeName apply(TypeMirror input) {
+          return forTypeMirror(input);
+        }
+      };
+
+  public static TypeName forTypeMirror(TypeMirror mirror) {
+    return mirror.accept(new SimpleTypeVisitor6<TypeName, Void>() {
+      @Override
+      protected TypeName defaultAction(TypeMirror e, Void p) {
+        throw new IllegalArgumentException(e.toString());
+      }
+
+      @Override
+      public TypeName visitArray(ArrayType t, Void p) {
+        return super.visitArray(t, p);
+      }
+
+      @Override
+      public TypeName visitDeclared(DeclaredType t, Void p) {
+        return t.getTypeArguments().isEmpty()
+            ? ClassName.fromTypeElement((TypeElement) t.asElement())
+            : new ParameterizedTypeName(
+                ClassName.fromTypeElement((TypeElement) t.asElement()),
+                FluentIterable.from(t.getTypeArguments()).transform(FOR_TYPE_MIRROR));
+      }
+
+      @Override
+      public TypeName visitPrimitive(PrimitiveType t, Void p) {
+        return PrimitiveName.forTypeMirror(t);
+      }
+
+      @Override
+      public TypeName visitWildcard(WildcardType t, Void p) {
+        return WildcardName.forTypeMirror(t);
+      }
+    }, null);
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/TypeVariableName.java b/compiler/src/main/java/dagger/internal/codegen/writer/TypeVariableName.java
new file mode 100644
index 000000000..e47f42cc3
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/TypeVariableName.java
@@ -0,0 +1,67 @@
+package dagger.internal.codegen.writer;
+
+import com.google.common.base.Optional;
+import com.google.common.collect.ImmutableSet;
+import dagger.internal.codegen.writer.JavaWriter.CompilationUnitContext;
+import java.io.IOException;
+import java.util.Set;
+
+public class TypeVariableName implements TypeName {
+  private final String name;
+  private final Optional<TypeName> extendsBound;
+  private final Optional<TypeName> superBound;
+  TypeVariableName(String name, Optional<TypeName> extendsBound,
+      Optional<TypeName> superBound) {
+    this.name = name;
+    this.extendsBound = extendsBound;
+    this.superBound = superBound;
+  }
+
+  public String name() {
+    return name;
+  }
+
+  @Override
+  public Set<ClassName> referencedClasses() {
+    ImmutableSet.Builder<ClassName> builder = new ImmutableSet.Builder<ClassName>();
+    if (extendsBound.isPresent()) {
+      builder.addAll(extendsBound.get().referencedClasses());
+    }
+    if (superBound.isPresent()) {
+      builder.addAll(superBound.get().referencedClasses());
+    }
+    return builder.build();
+  }
+
+  @Override
+  public Appendable write(Appendable appendable, CompilationUnitContext context)
+      throws IOException {
+    appendable.append(name);
+    if (extendsBound.isPresent()) {
+      appendable.append(' ');
+      extendsBound.get().write(appendable, context);
+    }
+    if (superBound.isPresent()) {
+      appendable.append(' ');
+      superBound.get().write(appendable, context);
+    }
+    return appendable;
+  }
+
+  @Override
+  public String toString() {
+    StringBuilder builder = new StringBuilder(name);
+    if (extendsBound.isPresent()) {
+      builder.append(' ').append(extendsBound.get());
+    }
+    if (superBound.isPresent()) {
+      builder.append(' ').append(superBound.get());
+    }
+    return builder.toString();
+  }
+
+  static TypeVariableName named(String name) {
+    return new TypeVariableName(
+        name, Optional.<TypeName>absent(), Optional.<TypeName>absent());
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/TypeWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/TypeWriter.java
new file mode 100644
index 000000000..a49e765cc
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/TypeWriter.java
@@ -0,0 +1,22 @@
+package dagger.internal.codegen.writer;
+
+import com.google.common.base.Optional;
+import com.google.common.collect.Lists;
+import java.util.List;
+
+
+/**
+ * Only named types. Doesn't cover anonymous inner classes.
+ */
+public abstract class TypeWriter /* ha ha */ extends Modifiable
+    implements Writable, TypeName {
+  final ClassName name;
+  Optional<TypeName> supertype;
+  final List<TypeName> implementedTypes;
+
+  TypeWriter(ClassName name) {
+    this.name = name;
+    this.supertype = Optional.absent();
+    this.implementedTypes = Lists.newArrayList();
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/VariableWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/VariableWriter.java
new file mode 100644
index 000000000..5d2cf2a2f
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/VariableWriter.java
@@ -0,0 +1,37 @@
+package dagger.internal.codegen.writer;
+
+import dagger.internal.codegen.writer.JavaWriter.CompilationUnitContext;
+import java.io.IOException;
+import java.util.Set;
+
+
+public class VariableWriter extends Modifiable implements Writable, HasClassReferences {
+  private final TypeName type;
+  private final String name;
+
+  VariableWriter(TypeName type, String name) {
+    this.type = type;
+    this.name = name;
+  }
+
+  public TypeName type() {
+    return type;
+  }
+
+  public String name() {
+    return name;
+  }
+
+  @Override
+  public Appendable write(Appendable appendable, CompilationUnitContext context)
+      throws IOException {
+    writeModifiers(appendable);
+    type.write(appendable, context);
+    return appendable.append(' ').append(name);
+  }
+
+  @Override
+  public Set<ClassName> referencedClasses() {
+    return type.referencedClasses();
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/VoidName.java b/compiler/src/main/java/dagger/internal/codegen/writer/VoidName.java
new file mode 100644
index 000000000..c6f36098c
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/VoidName.java
@@ -0,0 +1,26 @@
+package dagger.internal.codegen.writer;
+
+import com.google.common.collect.ImmutableSet;
+import dagger.internal.codegen.writer.JavaWriter.CompilationUnitContext;
+import java.io.IOException;
+import java.util.Set;
+
+public enum VoidName implements TypeName {
+  VOID;
+
+  @Override
+  public Set<ClassName> referencedClasses() {
+    return ImmutableSet.of();
+  }
+
+  @Override
+  public String toString() {
+    return "void";
+  }
+
+  @Override
+  public Appendable write(Appendable appendable, CompilationUnitContext context)
+      throws IOException {
+    return appendable.append("void");
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/WildcardName.java b/compiler/src/main/java/dagger/internal/codegen/writer/WildcardName.java
new file mode 100644
index 000000000..f881235c5
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/WildcardName.java
@@ -0,0 +1,45 @@
+package dagger.internal.codegen.writer;
+
+import com.google.common.base.Optional;
+import com.google.common.collect.ImmutableSet;
+import dagger.internal.codegen.writer.JavaWriter.CompilationUnitContext;
+import java.io.IOException;
+import java.util.Set;
+import javax.lang.model.type.WildcardType;
+
+import static dagger.internal.codegen.writer.TypeReferences.FOR_TYPE_MIRROR;
+
+public class WildcardName implements TypeName {
+  private final Optional<TypeName> extendsBound;
+  private final Optional<TypeName> superBound;
+
+  WildcardName(Optional<TypeName> extendsBound,
+      Optional<TypeName> superBound) {
+    this.extendsBound = extendsBound;
+    this.superBound = superBound;
+  }
+
+  static WildcardName forTypeMirror(WildcardType mirror) {
+    return new WildcardName(
+        Optional.fromNullable(mirror.getExtendsBound()).transform(FOR_TYPE_MIRROR),
+        Optional.fromNullable(mirror.getSuperBound()).transform(FOR_TYPE_MIRROR));
+  }
+
+  @Override
+  public Set<ClassName> referencedClasses() {
+    ImmutableSet.Builder<ClassName> builder = new ImmutableSet.Builder<ClassName>();
+    if (extendsBound.isPresent()) {
+      builder.addAll(extendsBound.get().referencedClasses());
+    }
+    if (superBound.isPresent()) {
+      builder.addAll(superBound.get().referencedClasses());
+    }
+    return builder.build();
+  }
+
+  @Override
+  public Appendable write(Appendable appendable, CompilationUnitContext context)
+      throws IOException {
+    return null;
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/Writable.java b/compiler/src/main/java/dagger/internal/codegen/writer/Writable.java
new file mode 100644
index 000000000..7d3808c7b
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/Writable.java
@@ -0,0 +1,8 @@
+package dagger.internal.codegen.writer;
+
+import dagger.internal.codegen.writer.JavaWriter.CompilationUnitContext;
+import java.io.IOException;
+
+interface Writable {
+  Appendable write(Appendable appendable, CompilationUnitContext context) throws IOException;
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/Writables.java b/compiler/src/main/java/dagger/internal/codegen/writer/Writables.java
new file mode 100644
index 000000000..379540a91
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/Writables.java
@@ -0,0 +1,18 @@
+package dagger.internal.codegen.writer;
+
+import dagger.internal.codegen.writer.JavaWriter.CompilationUnitContext;
+import java.io.IOException;
+
+final class Writables {
+  static Writable toStringWritable(final Object object) {
+    return new Writable() {
+      @Override
+      public Appendable write(Appendable appendable, CompilationUnitContext ignored)
+          throws IOException {
+        return appendable.append(object.toString());
+      }
+    };
+  }
+
+  private Writables() {}
+}
diff --git a/compiler/src/test/java/dagger/internal/codegen/ClassNameTest.java b/compiler/src/test/java/dagger/internal/codegen/ClassNameTest.java
index eb50e9795..3a520ec73 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ClassNameTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ClassNameTest.java
@@ -18,12 +18,12 @@
 import com.google.common.collect.ImmutableList;
 import com.google.testing.compile.CompilationRule;
 import dagger.internal.codegen.ClassNameTest.OuterClass.InnerClass;
+import dagger.internal.codegen.writer.ClassName;
 import java.util.Map;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.util.Elements;
-import javax.lang.model.util.Types;
-import org.junit.Test;
 import org.junit.Rule;
+import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
@@ -79,7 +79,7 @@
   @Test public void classNameFromTypeElement() {
     Elements elements = compilationRule.getElements();
     TypeElement element = elements.getTypeElement(Object.class.getCanonicalName());
-    ASSERT.that(ClassName.fromTypeElement(element).fullyQualifiedName())
+    ASSERT.that(ClassName.fromTypeElement(element).canonicalName())
         .isEqualTo("java.lang.Object");
   }
 
@@ -88,7 +88,7 @@
     TypeElement element = elements.getTypeElement(ClassNameTest.class.getCanonicalName());
     ClassName className = ClassName.fromTypeElement(element);
     ClassName peerName = className.peerNamed("Foo");
-    ASSERT.that(peerName.fullyQualifiedName())
+    ASSERT.that(peerName.canonicalName())
         .isEqualTo("dagger.internal.codegen.Foo");
   }
 
@@ -97,7 +97,7 @@
     TypeElement element = elements.getTypeElement(OuterClass.class.getCanonicalName());
     ClassName className = ClassName.fromTypeElement(element);
     ClassName peerName = className.peerNamed("Foo");
-    ASSERT.that(peerName.fullyQualifiedName())
+    ASSERT.that(peerName.canonicalName())
         .isEqualTo("dagger.internal.codegen.ClassNameTest.Foo");
   }
 
@@ -106,7 +106,7 @@
     TypeElement element = elements.getTypeElement(InnerClass.class.getCanonicalName());
     ClassName className = ClassName.fromTypeElement(element);
     ClassName peerName = className.peerNamed("Foo");
-    ASSERT.that(peerName.fullyQualifiedName())
+    ASSERT.that(peerName.canonicalName())
         .isEqualTo("dagger.internal.codegen.ClassNameTest.OuterClass.Foo");
   }
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
index d67eda327..a8a67c51d 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
@@ -247,13 +247,14 @@
         "import dagger.MembersInjector;",
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
+        "import test.OuterType.A;",
         "import test.OuterType.B;",
         "",
         "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "final class OuterType$B$$MembersInjector implements MembersInjector<B> {",
-        "  private final Provider<OuterType.A> aProvider;",
-         "",
-        "  OuterType$B$$MembersInjector(Provider<OuterType.A> aProvider) {",
+        "public final class OuterType$B$$MembersInjector implements MembersInjector<B> {",
+        "  private final Provider<A> aProvider;",
+        "",
+        "  public OuterType$B$$MembersInjector(Provider<A> aProvider) {",
         "    assert aProvider != null;",
         "    this.aProvider = aProvider;",
         "  }",
@@ -274,22 +275,24 @@
         "import dagger.MembersInjector;",
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
+        "import test.OuterType.A;",
+        "import test.OuterType.B;",
         "import test.OuterType.SimpleComponent;",
         "",
         "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
         "public final class Dagger_OuterType$SimpleComponent implements SimpleComponent {",
-        "  private final Provider<OuterType.A> aProvider;",
-        "  private final MembersInjector<OuterType.B> bMembersInjector;",
+        "  private final Provider<A> aProvider;",
+        "  private final MembersInjector<B> bMembersInjector;",
         "",
         "  public Dagger_OuterType$SimpleComponent() {",
         "    this.aProvider = new OuterType$A$$Factory();",
         "    this.bMembersInjector = new OuterType$B$$MembersInjector(aProvider);",
         "  }",
         "",
-        "  @Override public OuterType.A a() {",
+        "  @Override public A a() {",
         "    return aProvider.get();",
         "  }",
-        "  @Override public void inject(OuterType.B b) {",
+        "  @Override public void inject(B b) {",
         "    bMembersInjector.injectMembers(b);",
         "  }",
         "}");
diff --git a/compiler/src/test/java/dagger/internal/codegen/InjectProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/InjectProcessorTest.java
index b6650cdae..cd995838d 100644
--- a/compiler/src/test/java/dagger/internal/codegen/InjectProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/InjectProcessorTest.java
@@ -284,19 +284,18 @@
     JavaFileObject expected = JavaFileObjects.forSourceLines("test.FieldInjection$$MembersInjector",
         "package test;",
         "",
-        "import dagger.Lazy;",
         "import dagger.MembersInjector;",
         "import dagger.internal.DoubleCheckLazy;",
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
         "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "final class FieldInjection$$MembersInjector ",
+        "public final class FieldInjection$$MembersInjector ",
         "    implements MembersInjector<FieldInjection> {",
         "",
         "  private final Provider<String> stringProvider;",
         "",
-        "  FieldInjection$$MembersInjector(Provider<String> stringProvider) {",
+        "  public FieldInjection$$MembersInjector(Provider<String> stringProvider) {",
         "    assert stringProvider != null;",
         "    this.stringProvider = stringProvider;",
         "  }",
@@ -333,19 +332,18 @@
         "test.MethodInjection$$MembersInjector",
         "package test;",
         "",
-        "import dagger.Lazy;",
         "import dagger.MembersInjector;",
         "import dagger.internal.DoubleCheckLazy;",
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
         "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "final class MethodInjection$$MembersInjector ",
+        "public final class MethodInjection$$MembersInjector ",
         "    implements MembersInjector<MethodInjection> {",
         "",
         "  private final Provider<String> stringProvider;",
         "",
-        "  MethodInjection$$MembersInjector(Provider<String> stringProvider) {",
+        "  public MethodInjection$$MembersInjector(Provider<String> stringProvider) {",
         "    assert stringProvider != null;",
         "    this.stringProvider = stringProvider;",
         "  }",
@@ -388,18 +386,18 @@
         "import javax.inject.Provider;",
         "",
         "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "final class MixedMemberInjection$$MembersInjector ",
+        "public final class MixedMemberInjection$$MembersInjector ",
         "    implements MembersInjector<MixedMemberInjection> {",
         "",
-        "  private final Provider<Object> objectAndOProvider;",
         "  private final Provider<String> stringAndSProvider;",
+        "  private final Provider<Object> objectAndOProvider;",
         "",
-        "  MixedMemberInjection$$MembersInjector(Provider<Object> objectAndOProvider,",
-        "      Provider<String> stringAndSProvider) {",
-        "    assert objectAndOProvider != null;",
-        "    this.objectAndOProvider = objectAndOProvider;",
+        "  public MixedMemberInjection$$MembersInjector(Provider<String> stringAndSProvider,",
+        "      Provider<Object> objectAndOProvider) {",
         "    assert stringAndSProvider != null;",
         "    this.stringAndSProvider = stringAndSProvider;",
+        "    assert objectAndOProvider != null;",
+        "    this.objectAndOProvider = objectAndOProvider;",
         "  }",
         "",
         "  @Override public void injectMembers(MixedMemberInjection instance) {",
@@ -504,12 +502,12 @@
         "import javax.inject.Provider;",
         "",
         "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "final class AllInjections$$MembersInjector ",
+        "public final class AllInjections$$MembersInjector ",
         "    implements MembersInjector<AllInjections> {",
         "",
         "  private final Provider<String> sProvider;",
         "",
-        "  AllInjections$$MembersInjector(Provider<String> sProvider) {",
+        "  public AllInjections$$MembersInjector(Provider<String> sProvider) {",
         "    assert sProvider != null;",
         "    this.sProvider = sProvider;",
         "  }",
@@ -593,13 +591,14 @@
         "import javax.inject.Provider;",
         "",
         "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "final class B$$MembersInjector ",
+        "public final class B$$MembersInjector ",
         "    implements MembersInjector<B> {",
         "",
         "  private final MembersInjector<A> supertypeInjector;",
         "  private final Provider<String> sProvider;",
         "",
-        "  B$$MembersInjector(MembersInjector<A> supertypeInjector, Provider<String> sProvider) {",
+        "  public B$$MembersInjector(MembersInjector<A> supertypeInjector,",
+        "      Provider<String> sProvider) {",
         "    assert supertypeInjector != null;",
         "    this.supertypeInjector = supertypeInjector;",
         "    assert sProvider != null;",
diff --git a/compiler/src/test/java/dagger/internal/codegen/SourceFileGeneratorTest.java b/compiler/src/test/java/dagger/internal/codegen/SourceFileGeneratorTest.java
deleted file mode 100644
index e76f8671c..000000000
--- a/compiler/src/test/java/dagger/internal/codegen/SourceFileGeneratorTest.java
+++ /dev/null
@@ -1,156 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen;
-
-import com.google.common.base.Optional;
-import com.google.common.collect.ImmutableSet;
-import com.squareup.javawriter.JavaWriter;
-import java.io.IOException;
-import java.io.Writer;
-import javax.annotation.processing.Filer;
-import javax.lang.model.element.Element;
-import javax.tools.JavaFileObject;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.Mock;
-import org.mockito.runners.MockitoJUnitRunner;
-
-import static org.junit.Assert.fail;
-import static org.mockito.Matchers.anyString;
-import static org.mockito.Mockito.doThrow;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-import static org.truth0.Truth.ASSERT;
-
-@RunWith(MockitoJUnitRunner.class)
-public class SourceFileGeneratorTest {
-  private static final ClassName FAKE_CLASS_NAME = ClassName.create("test", "FakeClass");
-
-  @Mock public Filer filer;
-  @Mock public JavaFileObject file;
-  @Mock public Writer writer;
-
-  private SourceFileGenerator<Void> generator;
-
-  @Before public void createGenerator() {
-    this.generator = new FailingSourceFileGenerator(filer);
-  }
-
-  @Test public void generate_failToCreateFile() throws Exception {
-    when(filer.createSourceFile(FAKE_CLASS_NAME.fullyQualifiedName()))
-      .thenThrow(new IOException("file creation"));
-    try {
-      generator.generate(null);
-      fail();
-    } catch (SourceFileGenerationException e) {
-      String message = e.getMessage();
-      ASSERT.that(message).contains(FAKE_CLASS_NAME.fullyQualifiedName());
-      ASSERT.that(message).contains("file creation");
-    }
-  }
-
-  @Test public void generate_failToOpenWriter() throws Exception {
-    when(filer.createSourceFile(FAKE_CLASS_NAME.fullyQualifiedName())).thenReturn(file);
-    when(file.openWriter()).thenThrow(new IOException("opening writer"));
-    try {
-      generator.generate(null);
-      fail();
-    } catch (SourceFileGenerationException e) {
-      String message = e.getMessage();
-      ASSERT.that(message).contains(FAKE_CLASS_NAME.fullyQualifiedName());
-      ASSERT.that(message).contains("opening writer");
-    }
-    verify(file).delete();
-  }
-
-  @Test public void generate_failToWrite() throws Exception {
-    when(filer.createSourceFile(FAKE_CLASS_NAME.fullyQualifiedName())).thenReturn(file);
-    when(file.openWriter()).thenReturn(writer);
-    doThrow(new IOException("writing")).when(writer).write(anyString());
-    try {
-      generator.generate(null);
-      fail();
-    } catch (SourceFileGenerationException e) {
-      String message = e.getMessage();
-      ASSERT.that(message).contains(FAKE_CLASS_NAME.fullyQualifiedName());
-      ASSERT.that(message).contains("writing");
-    }
-    verify(writer).close();
-    verify(file).delete();
-  }
-
-  @Test public void generate_failToWriteFailToClose() throws Exception {
-    when(filer.createSourceFile(FAKE_CLASS_NAME.fullyQualifiedName())).thenReturn(file);
-    when(file.openWriter()).thenReturn(writer);
-    doThrow(new IOException("writing")).when(writer).write(anyString());
-    doThrow(new IOException("closing writer")).when(writer).close();
-    try {
-      generator.generate(null);
-      fail();
-    } catch (SourceFileGenerationException e) {
-      String message = e.getMessage();
-      ASSERT.that(message).contains(FAKE_CLASS_NAME.fullyQualifiedName());
-      ASSERT.that(message).contains("writing");
-    }
-    verify(writer).close();
-    verify(file).delete();
-  }
-
-  @Test public void generate_failToClose() throws Exception {
-    when(filer.createSourceFile(FAKE_CLASS_NAME.fullyQualifiedName())).thenReturn(file);
-    when(file.openWriter()).thenReturn(writer);
-    doThrow(new IOException("closing writer")).when(writer).close();
-    try {
-      generator.generate(null);
-      fail();
-    } catch (SourceFileGenerationException e) {
-      String message = e.getMessage();
-      ASSERT.that(message).contains(FAKE_CLASS_NAME.fullyQualifiedName());
-      ASSERT.that(message).contains("closing writer");
-    }
-    verify(writer).close();
-    verify(file).delete();
-  }
-
-  private static final class FailingSourceFileGenerator extends SourceFileGenerator<Void> {
-    FailingSourceFileGenerator(Filer filer) {
-      super(filer);
-    }
-
-    @Override
-    ClassName nameGeneratedType(Void input) {
-      return FAKE_CLASS_NAME;
-    }
-
-    @Override
-    Iterable<? extends Element> getOriginatingElements(Void input) {
-      return ImmutableSet.of();
-    }
-
-    @Override
-    Optional<? extends Element> getElementForErrorReporting(Void input) {
-      return Optional.absent();
-    }
-
-    @Override
-    void write(ClassName generatedTypeName, JavaWriter writer, Void input) throws IOException {
-      writer.emitPackage(FAKE_CLASS_NAME.packageName())
-          .beginType("class", FAKE_CLASS_NAME.simpleName())
-          .endType();
-    }
-  }
-}
