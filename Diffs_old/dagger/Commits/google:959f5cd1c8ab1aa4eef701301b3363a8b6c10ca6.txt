diff --git a/compiler/src/it/functional-tests/src/main/java/test/GenericComponent.java b/compiler/src/it/functional-tests/src/main/java/test/GenericComponent.java
index ba441a21f..da5b9b530 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/GenericComponent.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/GenericComponent.java
@@ -27,7 +27,7 @@
   ComplexGenerics complexGenerics();
   GenericNoDeps<A> noDepsA();
   GenericNoDeps<B> noDepsB();
-  
+
   void injectA(GenericChild<A> childA);
   void injectB(GenericChild<B> childB);
 
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildComponent.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildComponent.java
new file mode 100644
index 000000000..1e9549231
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildComponent.java
@@ -0,0 +1,11 @@
+package test.subcomponent;
+
+import dagger.Subcomponent;
+import java.util.Set;
+
+@Subcomponent(modules = ChildModule.class)
+interface ChildComponent {
+  String string();
+
+  Set<Object> objectSet();
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildModule.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildModule.java
new file mode 100644
index 000000000..53cb00ccb
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildModule.java
@@ -0,0 +1,21 @@
+package test.subcomponent;
+
+import dagger.Module;
+import dagger.Provides;
+
+import static dagger.Provides.Type.SET;
+
+@Module
+final class ChildModule {
+  @Provides String stringRequiresSingleton(SingletonType singletonType) {
+    return singletonType.toString();
+  }
+
+  @Provides(type = SET) Object provideUnscopedObject() {
+    return new Object() {
+      @Override public String toString() {
+        return "unscoped in child";
+      }
+    };
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentComponent.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentComponent.java
new file mode 100644
index 000000000..b28debfee
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentComponent.java
@@ -0,0 +1,13 @@
+package test.subcomponent;
+
+import dagger.Component;
+import java.util.Set;
+import javax.inject.Singleton;
+
+@Component(modules = ParentModule.class)
+@Singleton
+interface ParentComponent {
+  ChildComponent newChildComponent();
+
+  Set<Object> objectSet();
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentModule.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentModule.java
new file mode 100644
index 000000000..0a753d290
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentModule.java
@@ -0,0 +1,26 @@
+package test.subcomponent;
+
+import dagger.Module;
+import dagger.Provides;
+import javax.inject.Singleton;
+
+import static dagger.Provides.Type.SET;
+
+@Module
+final class ParentModule {
+  @Provides(type = SET) Object provideUnscopedObject() {
+    return new Object() {
+      @Override public String toString() {
+        return "unscoped in parent";
+      }
+    };
+  }
+
+  @Provides(type = SET) @Singleton Object provideSingletonObject() {
+    return new Object() {
+      @Override public String toString() {
+        return "singleton";
+      }
+    };
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/SingletonType.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/SingletonType.java
new file mode 100644
index 000000000..7d0c98b6a
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/SingletonType.java
@@ -0,0 +1,9 @@
+package test.subcomponent;
+
+import javax.inject.Inject;
+import javax.inject.Singleton;
+
+@Singleton
+final class SingletonType {
+  @Inject SingletonType() {}
+}
diff --git a/compiler/src/it/functional-tests/src/test/java/test/subcomponent/SubcomponentScopeTest.java b/compiler/src/it/functional-tests/src/test/java/test/subcomponent/SubcomponentScopeTest.java
new file mode 100644
index 000000000..2d98d1f84
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/test/java/test/subcomponent/SubcomponentScopeTest.java
@@ -0,0 +1,33 @@
+package test.subcomponent;
+
+import java.util.Collections;
+import java.util.IdentityHashMap;
+import java.util.Set;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assertThat;
+
+@RunWith(JUnit4.class)
+public class SubcomponentScopeTest {
+  @Test
+  public void testSingletonPropagatesUpward() {
+    ParentComponent parentComponent = Dagger_ParentComponent.create();
+    assertThat(parentComponent.newChildComponent().string())
+        .isEqualTo(parentComponent.newChildComponent().string());
+  }
+
+  @Test
+  public void testMultibindingContributions() {
+    ParentComponent parentComponent = Dagger_ParentComponent.create();
+    Set<Object> parentObjectSet = parentComponent.objectSet();
+    assertThat(parentObjectSet).hasSize(2);
+    Set<Object> childObjectSet = parentComponent.newChildComponent().objectSet();
+    assertThat(childObjectSet).hasSize(3);
+    Set<Object> identitySet = Collections.newSetFromMap(new IdentityHashMap<Object, Boolean>());
+    identitySet.addAll(parentObjectSet);
+    identitySet.addAll(childObjectSet);
+    assertThat(identitySet).hasSize(4);
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
index c4591f1f1..49a5e470f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
@@ -17,27 +17,32 @@
 
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
+import com.google.common.base.Equivalence;
 import com.google.common.base.Optional;
+import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ImmutableSetMultimap;
+import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
 import com.google.common.collect.Queues;
+import dagger.Component;
 import dagger.Provides;
+import dagger.internal.codegen.ComponentDescriptor.ComponentMethodType;
 import dagger.producers.Produces;
+import dagger.producers.ProductionComponent;
 import java.util.Deque;
 import java.util.List;
 import java.util.Map;
+import java.util.Map.Entry;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.Modifier;
 import javax.lang.model.element.TypeElement;
-import javax.lang.model.element.VariableElement;
-import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.ElementFilter;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 
+import static com.google.auto.common.MoreElements.getAnnotationMirror;
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static com.google.common.base.Preconditions.checkState;
 import static dagger.internal.codegen.ComponentDescriptor.isComponentContributionMethod;
@@ -46,7 +51,6 @@
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentModules;
 import static dagger.internal.codegen.ConfigurationAnnotations.getTransitiveModules;
-import static javax.lang.model.type.TypeKind.VOID;
 import static javax.lang.model.util.ElementFilter.methodsIn;
 
 /**
@@ -60,6 +64,7 @@
   abstract ImmutableSet<DependencyRequest> entryPoints();
   abstract ImmutableMap<TypeElement, ImmutableSet<TypeElement>> transitiveModules();
   abstract ImmutableMap<BindingKey, ResolvedBindings> resolvedBindings();
+  abstract ImmutableMap<ExecutableElement, BindingGraph> subgraphs();
 
   @AutoValue
   abstract static class ResolvedBindings {
@@ -110,6 +115,11 @@ static ResolvedBindings create(
     }
 
     BindingGraph create(ComponentDescriptor componentDescriptor) {
+      return create(Optional.<RequestResolver>absent(), componentDescriptor);
+    }
+
+    private BindingGraph create(Optional<RequestResolver> parentResolver,
+        ComponentDescriptor componentDescriptor) {
       ImmutableSet.Builder<ProvisionBinding> explicitProvisionBindingsBuilder =
           ImmutableSet.builder();
       ImmutableSet.Builder<ProductionBinding> explicitProductionBindingsBuilder =
@@ -117,13 +127,18 @@ BindingGraph create(ComponentDescriptor componentDescriptor) {
       AnnotationMirror componentAnnotation = componentDescriptor.componentAnnotation();
 
       // binding for the component itself
+      TypeElement componentDefinitionType = componentDescriptor.componentDefinitionType();
       ProvisionBinding componentBinding =
-          provisionBindingFactory.forComponent(componentDescriptor.componentDefinitionType());
+          provisionBindingFactory.forComponent(componentDefinitionType);
       explicitProvisionBindingsBuilder.add(componentBinding);
 
       // Collect Component dependencies.
-      ImmutableSet<TypeElement> componentDependencyTypes =
-          MoreTypes.asTypeElements(getComponentDependencies(componentAnnotation));
+      Optional<AnnotationMirror> componentMirror =
+          getAnnotationMirror(componentDefinitionType, Component.class)
+              .or(getAnnotationMirror(componentDefinitionType, ProductionComponent.class));
+      ImmutableSet<TypeElement> componentDependencyTypes = componentMirror.isPresent()
+          ? MoreTypes.asTypeElements(getComponentDependencies(componentMirror.get()))
+          : ImmutableSet.<TypeElement>of();
       for (TypeElement componentDependency : componentDependencyTypes) {
         explicitProvisionBindingsBuilder.add(
             provisionBindingFactory.forComponent(componentDependency));
@@ -166,20 +181,34 @@ BindingGraph create(ComponentDescriptor componentDescriptor) {
       }
 
       RequestResolver requestResolver = new RequestResolver(
+          parentResolver,
+          componentDescriptor.wrappedScope(),
           explicitBindingsByKey(explicitProvisionBindingsBuilder.build()),
           explicitBindingsByKey(explicitProductionBindingsBuilder.build()));
-      ImmutableSet<DependencyRequest> componentMethodRequests = componentMethodRequests(
-          componentDescriptor.componentDefinitionType(), componentDescriptor.kind());
+      ImmutableSetMultimap<ComponentMethodType, ExecutableElement> componentMethods =
+          componentDescriptor.componentMethods();
+
+      ImmutableSet<DependencyRequest> componentMethodRequests =
+          componentMethodRequests(componentMethods);
       for (DependencyRequest componentMethodRequest :
           componentMethodRequests) {
         requestResolver.resolve(componentMethodRequest);
       }
 
+      ImmutableMap.Builder<ExecutableElement, BindingGraph> subgraphsBuilder =
+          ImmutableMap.builder();
+      for (Entry<ExecutableElement, ComponentDescriptor> subcomponentEntry :
+          componentDescriptor.subcomponents().entrySet()) {
+        subgraphsBuilder.put(subcomponentEntry.getKey(),
+            create(Optional.of(requestResolver), subcomponentEntry.getValue()));
+      }
+
       return new AutoValue_BindingGraph(
           componentDescriptor,
           componentMethodRequests,
           transitiveModules,
-          ImmutableMap.copyOf(requestResolver.resolvedBindings));
+          ImmutableMap.copyOf(requestResolver.resolvedBindings),
+          subgraphsBuilder.build());
     }
 
     private <B extends ContributionBinding> ImmutableSetMultimap<Key, B> explicitBindingsByKey(
@@ -192,47 +221,42 @@ BindingGraph create(ComponentDescriptor componentDescriptor) {
       return builder.build();
     }
 
-    private ImmutableSet<DependencyRequest> componentMethodRequests(TypeElement componentType,
-        ComponentDescriptor.Kind componentKind) {
+    private ImmutableSet<DependencyRequest> componentMethodRequests(
+        ImmutableSetMultimap<ComponentMethodType, ExecutableElement> componentMethods) {
       ImmutableSet.Builder<DependencyRequest> interfaceRequestsBuilder = ImmutableSet.builder();
-      for (ExecutableElement componentMethod : methodsIn(elements.getAllMembers(componentType))) {
-        if (componentMethod.getModifiers().contains(Modifier.ABSTRACT)) { // Elide Object.*;
-          if (isComponentContributionMethod(elements, componentMethod)) {
-            if (componentKind.equals(PRODUCTION_COMPONENT)
-                && isComponentProductionMethod(elements, componentMethod)) {
-              interfaceRequestsBuilder.add(
-                  dependencyRequestFactory.forComponentProductionMethod(componentMethod));
-            } else {
-              interfaceRequestsBuilder.add(
-                  dependencyRequestFactory.forComponentProvisionMethod(componentMethod));
-            }
-          } else if (isComponentMembersInjectionMethod(componentMethod)) {
-            interfaceRequestsBuilder.add(
-                dependencyRequestFactory.forComponentMembersInjectionMethod(componentMethod));
-          }
-        }
+      for (ExecutableElement provisionMethod : componentMethods.get(ComponentMethodType.PROVISON)) {
+        interfaceRequestsBuilder.add(
+            dependencyRequestFactory.forComponentProvisionMethod(provisionMethod));
+      }
+      for (ExecutableElement productionMethod :
+          componentMethods.get(ComponentMethodType.PRODUCTION)) {
+        interfaceRequestsBuilder.add(
+            dependencyRequestFactory.forComponentProductionMethod(productionMethod));
+      }
+      for (ExecutableElement membersInjectionMethod :
+          componentMethods.get(ComponentMethodType.MEMBERS_INJECTION)) {
+        interfaceRequestsBuilder.add(
+            dependencyRequestFactory.forComponentMembersInjectionMethod(membersInjectionMethod));
       }
       return interfaceRequestsBuilder.build();
     }
 
-    private boolean isComponentMembersInjectionMethod(ExecutableElement method) {
-      List<? extends VariableElement> parameters = method.getParameters();
-      TypeMirror returnType = method.getReturnType();
-      return parameters.size() == 1
-          && (returnType.getKind().equals(VOID)
-              || MoreTypes.equivalence().equivalent(returnType, parameters.get(0).asType()))
-          && !elements.getTypeElement(Object.class.getCanonicalName())
-              .equals(method.getEnclosingElement());
-    }
-
     private final class RequestResolver {
+      final Optional<RequestResolver> parentResolver;
+      final Optional<Equivalence.Wrapper<AnnotationMirror>> targetScope;
       final ImmutableSetMultimap<Key, ProvisionBinding> explicitProvisionBindings;
       final ImmutableSetMultimap<Key, ProductionBinding> explicitProductionBindings;
       final Map<BindingKey, ResolvedBindings> resolvedBindings;
       final Deque<BindingKey> cycleStack = Queues.newArrayDeque();
 
-      RequestResolver(ImmutableSetMultimap<Key, ProvisionBinding> explicitProvisionBindings,
+      RequestResolver(Optional<RequestResolver> parentResolver,
+          Optional<Equivalence.Wrapper<AnnotationMirror>> targetScope,
+          ImmutableSetMultimap<Key, ProvisionBinding> explicitProvisionBindings,
           ImmutableSetMultimap<Key, ProductionBinding> explicitProductionBindings) {
+        assert parentResolver != null;
+        this.parentResolver = parentResolver;
+        assert targetScope != null;
+        this.targetScope = targetScope;
         assert explicitProvisionBindings != null;
         this.explicitProvisionBindings = explicitProvisionBindings;
         assert explicitProductionBindings != null;
@@ -240,72 +264,125 @@ private boolean isComponentMembersInjectionMethod(ExecutableElement method) {
         this.resolvedBindings = Maps.newLinkedHashMap();
       }
 
-      ImmutableSet<? extends Binding> lookUpBindings(DependencyRequest request) {
+      /**
+       *  Looks up the bindings associated with a given dependency request and returns them.  In the
+       *  event that the binding is owned by a parent component it will trigger resolution in that
+       *  component's resolver but will return an {@link Optional#absent} value.
+       */
+      Optional<? extends ImmutableSet<? extends Binding>> lookUpBindings(
+          DependencyRequest request) {
         BindingKey bindingKey = BindingKey.forDependencyRequest(request);
         switch (bindingKey.kind()) {
           case CONTRIBUTION:
             // First, check for explicit keys (those from modules and components)
             ImmutableSet<ProvisionBinding> explicitProvisionBindingsForKey =
-                explicitProvisionBindings.get(bindingKey.key());
+                getExplicitProvisionBindings(bindingKey.key());
             ImmutableSet<ProductionBinding> explicitProductionBindingsForKey =
-                explicitProductionBindings.get(bindingKey.key());
+                getExplicitProductionBindings(bindingKey.key());
 
             // If the key is Map<K, V>, get its implicit binding keys, which are either
             // Map<K, Provider<V>> or Map<K, Producer<V>>, and grab their explicit bindings.
             Optional<Key> mapProviderKey = keyFactory.implicitMapProviderKeyFrom(bindingKey.key());
             ImmutableSet<ProvisionBinding> explicitMapProvisionBindings = ImmutableSet.of();
             if (mapProviderKey.isPresent()) {
-              explicitMapProvisionBindings = explicitProvisionBindings.get(mapProviderKey.get());
+              explicitMapProvisionBindings = getExplicitProvisionBindings(mapProviderKey.get());
             }
 
             Optional<Key> mapProducerKey = keyFactory.implicitMapProducerKeyFrom(bindingKey.key());
             ImmutableSet<ProductionBinding> explicitMapProductionBindings = ImmutableSet.of();
             if (mapProducerKey.isPresent()) {
-              explicitMapProductionBindings = explicitProductionBindings.get(mapProducerKey.get());
+              explicitMapProductionBindings = getExplicitProductionBindings(mapProducerKey.get());
             }
 
             if (!explicitProvisionBindingsForKey.isEmpty()
                 || !explicitProductionBindingsForKey.isEmpty()) {
               // we have some explicit binding for this key, so we collect all explicit implicit map
               // bindings that might conflict with this and let the validator sort it out
-              return ImmutableSet.<ContributionBinding>builder()
+              return Optional.of(ImmutableSet.<ContributionBinding>builder()
                   .addAll(explicitProvisionBindingsForKey)
                   .addAll(explicitMapProvisionBindings)
                   .addAll(explicitProductionBindingsForKey)
                   .addAll(explicitMapProductionBindings)
-                  .build();
+                  .build());
             } else {
               if (!explicitMapProductionBindings.isEmpty()) {
                 // if we have any explicit Map<K, Producer<V>> bindings, then this Map<K, V> binding
                 // must be considered an implicit ProductionBinding
                 DependencyRequest implicitRequest =
                     dependencyRequestFactory.forImplicitMapBinding(request, mapProducerKey.get());
-                return ImmutableSet.of(productionBindingFactory.forImplicitMapBinding(
-                    request, implicitRequest));
+                return Optional.of(ImmutableSet.of(productionBindingFactory.forImplicitMapBinding(
+                    request, implicitRequest)));
               } else if (!explicitMapProvisionBindings.isEmpty()) {
                 // if there are Map<K, Provider<V>> bindings, then it'll be an implicit
                 // ProvisionBinding
                 DependencyRequest implicitRequest =
                     dependencyRequestFactory.forImplicitMapBinding(request, mapProviderKey.get());
-                return ImmutableSet.of(provisionBindingFactory.forImplicitMapBinding(
-                    request, implicitRequest));
+                return Optional.of(ImmutableSet.of(provisionBindingFactory.forImplicitMapBinding(
+                    request, implicitRequest)));
               } else {
                 // no explicit binding, look it up.
                 Optional<ProvisionBinding> provisionBinding =
                     injectBindingRegistry.getOrFindProvisionBinding(bindingKey.key());
-                return ImmutableSet.copyOf(provisionBinding.asSet());
+                if (provisionBinding.isPresent()) {
+                  Optional<RequestResolver> owningResolver =
+                      getOwningResolver(provisionBinding.get());
+                  if (owningResolver.isPresent() && !owningResolver.get().equals(this)) {
+                    owningResolver.get().resolve(request);
+                    return Optional.absent();
+                  }
+                }
+                return Optional.of(ImmutableSet.copyOf(provisionBinding.asSet()));
               }
             }
           case MEMBERS_INJECTION:
             // no explicit deps for members injection, so just look it up
             MembersInjectionBinding membersInjectionBinding =
                 injectBindingRegistry.getOrFindMembersInjectionBinding(bindingKey.key());
-            return ImmutableSet.of(membersInjectionBinding);
+            return Optional.of(ImmutableSet.of(membersInjectionBinding));
           default:
             throw new AssertionError();
         }
       }
 
+      private Optional<RequestResolver> getOwningResolver(ProvisionBinding provisionBinding) {
+        Optional<Equivalence.Wrapper<AnnotationMirror>> bindingScope =
+            provisionBinding.wrappedScope();
+        for (RequestResolver requestResolver : getResolverLineage()) {
+          if (bindingScope.equals(requestResolver.targetScope)) {
+            return Optional.of(requestResolver);
+          }
+        }
+        return Optional.absent();
+      }
+
+      private ImmutableList<RequestResolver> getResolverLineage() {
+        List<RequestResolver> resolverList = Lists.newArrayList();
+        for (Optional<RequestResolver> currentResolver = Optional.of(this);
+            currentResolver.isPresent();
+            currentResolver = currentResolver.get().parentResolver) {
+          resolverList.add(currentResolver.get());
+        }
+        return ImmutableList.copyOf(Lists.reverse(resolverList));
+      }
+
+      private ImmutableSet<ProvisionBinding> getExplicitProvisionBindings(Key requestKey) {
+        ImmutableSet.Builder<ProvisionBinding> explicitBindingsForKey = ImmutableSet.builder();
+        for (RequestResolver resolver : getResolverLineage()) {
+          explicitBindingsForKey.addAll(
+              resolver.explicitProvisionBindings.get(requestKey));
+        }
+        return explicitBindingsForKey.build();
+      }
+
+      private ImmutableSet<ProductionBinding> getExplicitProductionBindings(Key requestKey) {
+        ImmutableSet.Builder<ProductionBinding> explicitBindingsForKey = ImmutableSet.builder();
+        for (RequestResolver resolver : getResolverLineage()) {
+          explicitBindingsForKey.addAll(
+              resolver.explicitProductionBindings.get(requestKey));
+        }
+        return explicitBindingsForKey.build();
+      }
+
       void resolve(DependencyRequest request) {
         BindingKey bindingKey = BindingKey.forDependencyRequest(request);
 
@@ -322,11 +399,13 @@ void resolve(DependencyRequest request) {
 
         cycleStack.push(bindingKey);
         try {
-          ImmutableSet<? extends Binding> bindings = lookUpBindings(request);
-          for (Binding binding : bindings) {
-            resolveDependencies(binding.implicitDependencies());
+          Optional<? extends ImmutableSet<? extends Binding>> bindings = lookUpBindings(request);
+          if (bindings.isPresent()) {
+            for (Binding binding : bindings.get()) {
+              resolveDependencies(binding.implicitDependencies());
+            }
+            resolvedBindings.put(bindingKey, ResolvedBindings.create(bindingKey, bindings.get()));
           }
-          resolvedBindings.put(bindingKey, ResolvedBindings.create(bindingKey, bindings));
         } finally {
           cycleStack.pop();
         }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
index 122a2d0e5..8ca6fe9f3 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
@@ -16,20 +16,29 @@
 package dagger.internal.codegen;
 
 import com.google.auto.common.AnnotationMirrors;
+import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Equivalence;
 import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.ImmutableSetMultimap;
+import com.google.common.collect.Lists;
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.Component;
+import dagger.Subcomponent;
 import dagger.producers.ProductionComponent;
 import java.lang.annotation.Annotation;
+import java.util.Iterator;
 import java.util.List;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.Modifier;
 import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.TypeKind;
+import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.ElementFilter;
 import javax.lang.model.util.Elements;
 
@@ -38,6 +47,7 @@
 import static dagger.internal.codegen.InjectionAnnotations.getScopeAnnotation;
 import static dagger.internal.codegen.Util.unwrapOptionalEquivalence;
 import static dagger.internal.codegen.Util.wrapOptionalInEquivalence;
+import static javax.lang.model.type.TypeKind.DECLARED;
 import static javax.lang.model.type.TypeKind.VOID;
 
 /**
@@ -101,6 +111,17 @@
    */
   abstract Optional<Equivalence.Wrapper<AnnotationMirror>> wrappedScope();
 
+  abstract ImmutableMap<ExecutableElement, ComponentDescriptor> subcomponents();
+
+  abstract ImmutableSetMultimap<ComponentMethodType, ExecutableElement> componentMethods();
+
+  enum ComponentMethodType {
+    PROVISON,
+    PRODUCTION,
+    MEMBERS_INJECTION,
+    SUBCOMPONENT,
+  }
+
   static final class Factory {
     private final Elements elements;
 
@@ -118,9 +139,13 @@ ComponentDescriptor forProductionComponent(TypeElement componentDefinitionType)
 
     private ComponentDescriptor create(TypeElement componentDefinitionType, Kind kind) {
       AnnotationMirror componentMirror =
-          getAnnotationMirror(componentDefinitionType, kind.annotationType()).get();
+          getAnnotationMirror(componentDefinitionType, kind.annotationType())
+              .or(getAnnotationMirror(componentDefinitionType, Subcomponent.class))
+              .get();
       ImmutableSet<TypeElement> componentDependencyTypes =
-          MoreTypes.asTypeElements(getComponentDependencies(componentMirror));
+          MoreElements.isAnnotationPresent(componentDefinitionType, Component.class)
+              ? MoreTypes.asTypeElements(getComponentDependencies(componentMirror))
+              : ImmutableSet.<TypeElement>of();
 
       ImmutableMap.Builder<ExecutableElement, TypeElement> dependencyMethodIndex =
           ImmutableMap.builder();
@@ -135,6 +160,25 @@ private ComponentDescriptor create(TypeElement componentDefinitionType, Kind kin
         }
       }
 
+      ImmutableSet<ExecutableElement> unimplementedMethods =
+          getUnimplementedMethods(elements, componentDefinitionType);
+
+      ImmutableSetMultimap.Builder<ComponentMethodType, ExecutableElement> componentMethodsBuilder =
+          ImmutableSetMultimap.builder();
+
+      ImmutableMap.Builder<ExecutableElement, ComponentDescriptor> subcomponentDescriptors =
+          ImmutableMap.builder();
+      for (ExecutableElement componentMethod : unimplementedMethods) {
+        ComponentMethodType componentMethodType =
+            getComponentMethodType(kind, componentMethod);
+        componentMethodsBuilder.put(componentMethodType, componentMethod);
+        if (componentMethodType.equals(ComponentMethodType.SUBCOMPONENT)) {
+          subcomponentDescriptors.put(componentMethod,
+              create(MoreElements.asType(MoreTypes.asElement(componentMethod.getReturnType())),
+                  Kind.COMPONENT));
+        }
+      }
+
       Optional<AnnotationMirror> scope = getScopeAnnotation(componentDefinitionType);
       return new AutoValue_ComponentDescriptor(
           kind,
@@ -142,10 +186,42 @@ private ComponentDescriptor create(TypeElement componentDefinitionType, Kind kin
           componentDefinitionType,
           componentDependencyTypes,
           dependencyMethodIndex.build(),
-          wrapOptionalInEquivalence(AnnotationMirrors.equivalence(), scope));
+          wrapOptionalInEquivalence(AnnotationMirrors.equivalence(), scope),
+          subcomponentDescriptors.build(),
+          componentMethodsBuilder.build());
     }
   }
 
+  private static ComponentMethodType getComponentMethodType(Kind componentKind,
+      ExecutableElement method) {
+    TypeMirror returnType = method.getReturnType();
+    if (returnType.getKind().equals(DECLARED) &&
+        getAnnotationMirror(MoreTypes.asElement(returnType), Subcomponent.class).isPresent()) {
+      return ComponentMethodType.SUBCOMPONENT;
+    }
+
+    if (method.getParameters().isEmpty()
+        && !method.getReturnType().getKind().equals(VOID)) {
+      switch (componentKind) {
+        case COMPONENT:
+          return ComponentMethodType.PROVISON;
+        case PRODUCTION_COMPONENT:
+          return ComponentMethodType.PRODUCTION;
+        default:
+          throw new AssertionError();
+      }
+    }
+
+    List<? extends VariableElement> parameters = method.getParameters();
+    if (parameters.size() == 1
+        && (returnType.getKind().equals(VOID)
+            || MoreTypes.equivalence().equivalent(returnType, parameters.get(0).asType()))) {
+      return ComponentMethodType.MEMBERS_INJECTION;
+    }
+
+    throw new IllegalArgumentException();
+  }
+
   static boolean isComponentContributionMethod(Elements elements, ExecutableElement method) {
     return method.getParameters().isEmpty()
         && !method.getReturnType().getKind().equals(VOID)
@@ -157,4 +233,57 @@ static boolean isComponentProductionMethod(Elements elements, ExecutableElement
     return isComponentContributionMethod(elements, method)
         && MoreTypes.isTypeOf(ListenableFuture.class, method.getReturnType());
   }
+
+  /*
+   * These two methods were borrowed from AutoValue and slightly modified.  TODO(gak): reconcile
+   * the two and put them in auto common
+   */
+  private static void findLocalAndInheritedMethods(Elements elements, TypeElement type,
+      List<ExecutableElement> methods) {
+    for (TypeMirror superInterface : type.getInterfaces()) {
+      findLocalAndInheritedMethods(
+          elements, MoreElements.asType(MoreTypes.asElement(superInterface)), methods);
+    }
+    if (type.getSuperclass().getKind() != TypeKind.NONE) {
+      // Visit the superclass after superinterfaces so we will always see the implementation of a
+      // method after any interfaces that declared it.
+      findLocalAndInheritedMethods(
+          elements, MoreElements.asType(MoreTypes.asElement(type.getSuperclass())), methods);
+    }
+    // Add each method of this class, and in so doing remove any inherited method it overrides.
+    // This algorithm is quadratic in the number of methods but it's hard to see how to improve
+    // that while still using Elements.overrides.
+    List<ExecutableElement> theseMethods = ElementFilter.methodsIn(type.getEnclosedElements());
+    for (ExecutableElement method : theseMethods) {
+      if (!method.getModifiers().contains(Modifier.PRIVATE)) {
+        boolean alreadySeen = false;
+        for (Iterator<ExecutableElement> methodIter = methods.iterator(); methodIter.hasNext();) {
+          ExecutableElement otherMethod = methodIter.next();
+          if (elements.overrides(method, otherMethod, type)) {
+            methodIter.remove();
+          } else if (method.getSimpleName().equals(otherMethod.getSimpleName())
+              && method.getParameters().equals(otherMethod.getParameters())) {
+            // If we inherit this method on more than one path, we don't want to add it twice.
+            alreadySeen = true;
+          }
+        }
+        if (!alreadySeen) {
+          methods.add(method);
+        }
+      }
+    }
+  }
+
+  private static ImmutableSet<ExecutableElement> getUnimplementedMethods(
+      Elements elements, TypeElement type) {
+    ImmutableSet.Builder<ExecutableElement> unimplementedMethods = ImmutableSet.builder();
+    List<ExecutableElement> methods = Lists.newArrayList();
+    findLocalAndInheritedMethods(elements, type, methods);
+    for (ExecutableElement method : methods) {
+      if (method.getModifiers().contains(Modifier.ABSTRACT)) {
+        unimplementedMethods.add(method);
+      }
+    }
+    return unimplementedMethods.build();
+  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
index 02431e5de..633c4b320 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
@@ -145,14 +145,24 @@ static ProxyClassAndField create(ClassWriter proxyWriter, FieldWriter proxyField
         ClassName.fromTypeElement(input.componentDescriptor().componentDefinitionType());
 
     JavaWriter writer = JavaWriter.inPackage(componentName.packageName());
+
     ClassWriter componentWriter = writer.addClass(componentName.simpleName());
     componentWriter.annotate(Generated.class).setValue(ComponentProcessor.class.getCanonicalName());
     componentWriter.addModifiers(PUBLIC, FINAL);
     componentWriter.addImplementedType(componentDefinitionTypeName);
 
+    Set<JavaWriter> javaWriters = Sets.newHashSet();
+    javaWriters.add(writer);
+    writeComponent(input, componentDefinitionTypeName, componentWriter, javaWriters);
+
+    return ImmutableSet.copyOf(javaWriters);
+  }
+
+  private ImmutableMap<BindingKey, Snippet> writeComponent(
+      BindingGraph input, ClassName componentDefinitionTypeName, ClassWriter componentWriter,
+      Set<JavaWriter> proxyWriters) {
     ClassWriter builderWriter = componentWriter.addNestedClass("Builder");
     builderWriter.addModifiers(PUBLIC, STATIC, FINAL);
-
     builderWriter.addConstructor().addModifiers(PRIVATE);
 
     MethodWriter builderFactoryMethod = componentWriter.addMethod(builderWriter, "builder");
@@ -222,15 +232,161 @@ static ProxyClassAndField create(ClassWriter proxyWriter, FieldWriter proxyField
       }
     }
 
-    ImmutableMap.Builder<BindingKey, Snippet> memberSelectSnippetsBuilder =
-        ImmutableMap.builder();
-    ImmutableMap.Builder<ContributionBinding, Snippet> multibindingContributionSnippetsBuilder =
-        ImmutableMap.builder();
+    if (!requiresBuilder) {
+      MethodWriter factoryMethod = componentWriter.addMethod(componentDefinitionTypeName, "create");
+      factoryMethod.addModifiers(PUBLIC, STATIC);
+      // TODO(gak): replace this with something that doesn't allocate a builder
+      factoryMethod.body().addSnippet("return builder().build();");
+    }
+
+    Map<BindingKey, Snippet> memberSelectSnippetsBuilder = Maps.newHashMap();
+    Map<ContributionBinding, Snippet> multibindingContributionSnippetsBuilder = Maps.newHashMap();
     ImmutableSet.Builder<BindingKey> enumBindingKeysBuilder = ImmutableSet.builder();
 
-    ImmutableSet.Builder<JavaWriter> proxyWriters = ImmutableSet.builder();
     Map<String, ProxyClassAndField> packageProxies = Maps.newHashMap();
 
+    writeFields(input,
+        componentWriter,
+        proxyWriters,
+        memberSelectSnippetsBuilder,
+        ImmutableMap.<ContributionBinding, Snippet>of(),
+        multibindingContributionSnippetsBuilder,
+        enumBindingKeysBuilder,
+        packageProxies);
+
+    buildMethod.body().addSnippet("return new %s(this);", componentWriter.name());
+
+    ImmutableMap<BindingKey, Snippet> memberSelectSnippets =
+        ImmutableMap.copyOf(memberSelectSnippetsBuilder);
+    ImmutableMap<ContributionBinding, Snippet> multibindingContributionSnippets =
+        ImmutableMap.copyOf(multibindingContributionSnippetsBuilder);
+    ImmutableSet<BindingKey> enumBindingKeys = enumBindingKeysBuilder.build();
+
+    initializeFrameworkTypes(input,
+        componentWriter,
+        constructorWriter,
+        componentContributionFields,
+        memberSelectSnippets,
+        ImmutableMap.<ContributionBinding, Snippet>of(),
+        multibindingContributionSnippets);
+
+    writeInterfaceMethods(input, componentWriter, memberSelectSnippets, enumBindingKeys);
+
+    for (Entry<ExecutableElement, BindingGraph> subgraphEntry : input.subgraphs().entrySet()) {
+      TypeName componentType =
+          TypeNames.forTypeMirror(subgraphEntry.getKey().getReturnType());
+
+      ClassWriter subcomponentWriter = componentWriter.addNestedClass(
+          subgraphEntry.getValue().componentDescriptor().componentDefinitionType().getSimpleName()
+              + "Impl");
+
+      subcomponentWriter.addModifiers(PRIVATE, FINAL);
+      subcomponentWriter.addImplementedType(componentType);
+
+      writeSubcomponent(subgraphEntry.getValue(),
+          subcomponentWriter,
+          proxyWriters,
+          ImmutableMap.copyOf(componentContributionFields),
+          ImmutableMap.copyOf(multibindingContributionSnippets),
+          memberSelectSnippets);
+
+      MethodWriter componentMethod = componentWriter.addMethod(componentType,
+          subgraphEntry.getKey().getSimpleName().toString());
+      componentMethod.addModifiers(PUBLIC);
+      componentMethod.annotate(Override.class);
+      // TODO(gak): need to pipe through the method params
+      componentMethod.body().addSnippet("return new %s();",
+          subcomponentWriter.name());
+    }
+
+    return memberSelectSnippets;
+  }
+
+  private ImmutableMap<BindingKey, Snippet> writeSubcomponent(
+      BindingGraph input, ClassWriter componentWriter,
+      Set<JavaWriter> proxyWriters,
+      ImmutableMap<TypeElement, FieldWriter> parentContributionFields,
+      ImmutableMap<ContributionBinding, Snippet> parentMultibindingContributionSnippets,
+      ImmutableMap<BindingKey, Snippet> parentMemberSelectSnippets) {
+    // the full set of types that calling code uses to construct a component instance
+    ImmutableMap<TypeElement, String> componentContributionNames =
+        ImmutableMap.copyOf(Maps.asMap(
+            Sets.union(
+                input.transitiveModules().keySet(),
+                input.componentDescriptor().dependencies()),
+            new Function<TypeElement, String>() {
+              @Override public String apply(TypeElement input) {
+                return CaseFormat.UPPER_CAMEL.to(LOWER_CAMEL, input.getSimpleName().toString());
+              }
+            }));
+
+    ConstructorWriter constructorWriter = componentWriter.addConstructor();
+    constructorWriter.addModifiers(PRIVATE);
+
+    Map<TypeElement, FieldWriter> componentContributionFields =
+        Maps.newHashMap(parentContributionFields);
+
+    for (Entry<TypeElement, String> entry : componentContributionNames.entrySet()) {
+      TypeElement contributionElement = entry.getKey();
+      String contributionName = entry.getValue();
+      FieldWriter contributionField =
+          componentWriter.addField(contributionElement, contributionName);
+      if (hasNoArgsConstructor(entry.getKey())) {
+        contributionField.setInitializer(Snippet.format("new %s()",
+            ClassName.fromTypeElement(entry.getKey())));
+      }
+      contributionField.addModifiers(PRIVATE, FINAL);
+      componentContributionFields.put(contributionElement, contributionField);
+    }
+
+    Map<BindingKey, Snippet> memberSelectSnippetsBuilder = Maps.newHashMap();
+
+    Map<ContributionBinding, Snippet> multibindingContributionSnippetsBuilder = Maps.newHashMap();
+    ImmutableSet.Builder<BindingKey> enumBindingKeysBuilder = ImmutableSet.builder();
+
+    Map<String, ProxyClassAndField> packageProxies = Maps.newHashMap();
+
+    writeFields(input,
+        componentWriter,
+        proxyWriters,
+        memberSelectSnippetsBuilder,
+        parentMultibindingContributionSnippets,
+        multibindingContributionSnippetsBuilder,
+        enumBindingKeysBuilder,
+        packageProxies);
+
+    for (Entry<BindingKey, Snippet> parentBindingEntry : parentMemberSelectSnippets.entrySet()) {
+      if (!memberSelectSnippetsBuilder.containsKey(parentBindingEntry.getKey())) {
+        memberSelectSnippetsBuilder.put(parentBindingEntry.getKey(), parentBindingEntry.getValue());
+      }
+    }
+
+    ImmutableMap<BindingKey, Snippet> memberSelectSnippets =
+        ImmutableMap.copyOf(memberSelectSnippetsBuilder);
+    ImmutableMap<ContributionBinding, Snippet> multibindingContributionSnippets =
+        ImmutableMap.copyOf(multibindingContributionSnippetsBuilder);
+    ImmutableSet<BindingKey> enumBindingKeys = enumBindingKeysBuilder.build();
+
+    initializeFrameworkTypes(input,
+        componentWriter,
+        constructorWriter,
+        componentContributionFields,
+        memberSelectSnippets,
+        parentMultibindingContributionSnippets,
+        multibindingContributionSnippets);
+
+    writeInterfaceMethods(input, componentWriter, memberSelectSnippets, enumBindingKeys);
+    return memberSelectSnippets;
+  }
+
+  private void writeFields(BindingGraph input,
+      ClassWriter componentWriter,
+      Set<JavaWriter> proxyWriters,
+      Map<BindingKey, Snippet> memberSelectSnippetsBuilder,
+      Map<ContributionBinding, Snippet> parentMultibindingContributionSnippetsBuilder,
+      Map<ContributionBinding, Snippet> multibindingContributionSnippetsBuilder,
+      ImmutableSet.Builder<BindingKey> enumBindingKeysBuilder,
+      Map<String, ProxyClassAndField> packageProxies) throws AssertionError {
     for (ResolvedBindings resolvedBindings : input.resolvedBindings().values()) {
       BindingKey bindingKey = resolvedBindings.bindingKey();
 
@@ -252,13 +408,13 @@ static ProxyClassAndField create(ClassWriter proxyWriter, FieldWriter proxyField
       }
 
       String bindingPackage = bindingPackageFor(resolvedBindings.bindings())
-          .or(componentName.packageName());
+          .or(componentWriter.name().packageName());
 
       final Optional<String> proxySelector;
       final TypeWriter classWithFields;
       final Set<Modifier> fieldModifiers;
 
-      if (bindingPackage.equals(componentName.packageName())) {
+      if (bindingPackage.equals(componentWriter.name().packageName())) {
         // no proxy
         proxySelector = Optional.absent();
         // component gets the fields
@@ -272,7 +428,7 @@ static ProxyClassAndField create(ClassWriter proxyWriter, FieldWriter proxyField
           JavaWriter proxyJavaWriter = JavaWriter.inPackage(bindingPackage);
           proxyWriters.add(proxyJavaWriter);
           ClassWriter proxyWriter =
-              proxyJavaWriter.addClass(componentName.simpleName() + "__PackageProxy");
+              proxyJavaWriter.addClass(componentWriter.name().simpleName() + "__PackageProxy");
           proxyWriter.annotate(Generated.class)
               .setValue(ComponentProcessor.class.getCanonicalName());
           proxyWriter.addModifiers(PUBLIC, FINAL);
@@ -297,22 +453,27 @@ static ProxyClassAndField create(ClassWriter proxyWriter, FieldWriter proxyField
         ImmutableSet<? extends ContributionBinding> contributionBindings =
             resolvedBindings.contributionBindings();
         if (ContributionBinding.bindingTypeFor(contributionBindings).isMultibinding()) {
+          // note that here we rely on the order of the resolved bindings being from parent to child
+          // otherwise, the nubmering wouldn't work
           int contributionNumber = 0;
           for (ContributionBinding contributionBinding : contributionBindings) {
             if (isSytheticProvisionBinding(contributionBinding)) {
               contributionNumber++;
-              FrameworkField contributionBindingField = frameworkFieldForSyntheticProvisionBinding(
-                  bindingKey, contributionNumber, contributionBinding);
-              FieldWriter contributionField = classWithFields.addField(
-                  contributionBindingField.frameworkType(), contributionBindingField.name());
-              contributionField.addModifiers(fieldModifiers);
-
-              ImmutableList<String> contirubtionSelectTokens = new ImmutableList.Builder<String>()
-                  .addAll(proxySelector.asSet())
-                  .add(contributionField.name())
-                  .build();
-              multibindingContributionSnippetsBuilder.put(contributionBinding,
-                  Snippet.memberSelectSnippet(contirubtionSelectTokens));
+              if (!parentMultibindingContributionSnippetsBuilder.containsKey(contributionBinding)) {
+                FrameworkField contributionBindingField =
+                    frameworkFieldForSyntheticProvisionBinding(
+                          bindingKey, contributionNumber, contributionBinding);
+                FieldWriter contributionField = classWithFields.addField(
+                    contributionBindingField.frameworkType(), contributionBindingField.name());
+                contributionField.addModifiers(fieldModifiers);
+
+                ImmutableList<String> contirubtionSelectTokens = new ImmutableList.Builder<String>()
+                    .addAll(proxySelector.asSet())
+                    .add(contributionField.name())
+                    .build();
+                multibindingContributionSnippetsBuilder.put(contributionBinding,
+                    Snippet.memberSelectSnippet(contirubtionSelectTokens));
+              }
             }
           }
         }
@@ -327,25 +488,79 @@ static ProxyClassAndField create(ClassWriter proxyWriter, FieldWriter proxyField
           .addAll(proxySelector.asSet())
           .add(frameworkField.name())
           .build();
-      memberSelectSnippetsBuilder.put(bindingKey,
-          Snippet.memberSelectSnippet(memberSelectTokens));
-
+      memberSelectSnippetsBuilder.put(bindingKey, Snippet.memberSelectSnippet(memberSelectTokens));
     }
+  }
 
-    buildMethod.body().addSnippet("return new %s(this);", componentWriter.name());
+  private void writeInterfaceMethods(BindingGraph input, ClassWriter componentWriter,
+      ImmutableMap<BindingKey, Snippet> memberSelectSnippets,
+      ImmutableSet<BindingKey> enumBindingKeys) throws AssertionError {
+    Set<MethodSignature> interfaceMethods = Sets.newHashSet();
 
-    if (!requiresBuilder) {
-      MethodWriter factoryMethod = componentWriter.addMethod(componentDefinitionTypeName, "create");
-      factoryMethod.addModifiers(PUBLIC, STATIC);
-      // TODO(gak): replace this with something that doesn't allocate a builder
-      factoryMethod.body().addSnippet("return builder().build();");
+    for (DependencyRequest interfaceRequest : input.entryPoints()) {
+      ExecutableElement requestElement =
+          MoreElements.asExecutable(interfaceRequest.requestElement());
+      MethodSignature signature = MethodSignature.fromExecutableElement(requestElement);
+      if (!interfaceMethods.contains(signature)) {
+        interfaceMethods.add(signature);
+        MethodWriter interfaceMethod = requestElement.getReturnType().getKind().equals(VOID)
+            ? componentWriter.addMethod(VoidName.VOID, requestElement.getSimpleName().toString())
+                : componentWriter.addMethod(requestElement.getReturnType(),
+                    requestElement.getSimpleName().toString());
+        interfaceMethod.annotate(Override.class);
+        interfaceMethod.addModifiers(PUBLIC);
+        BindingKey bindingKey = BindingKey.forDependencyRequest(interfaceRequest);
+        switch(interfaceRequest.kind()) {
+          case MEMBERS_INJECTOR:
+            Snippet membersInjectorName = memberSelectSnippets.get(bindingKey);
+            VariableElement parameter = Iterables.getOnlyElement(requestElement.getParameters());
+            Name parameterName = parameter.getSimpleName();
+            interfaceMethod.addParameter(
+                TypeNames.forTypeMirror(parameter.asType()), parameterName.toString());
+            interfaceMethod.body()
+                .addSnippet("%s.injectMembers(%s);", membersInjectorName, parameterName);
+            if (!requestElement.getReturnType().getKind().equals(VOID)) {
+              interfaceMethod.body().addSnippet("return %s;", parameterName);
+            }
+            break;
+          case INSTANCE:
+            if (enumBindingKeys.contains(bindingKey)
+                && !MoreTypes.asDeclared(bindingKey.key().type())
+                        .getTypeArguments().isEmpty()) {
+              // If using a parameterized enum type, then we need to store the factory
+              // in a temporary variable, in order to help javac be able to infer
+              // the generics of the Factory.create methods.
+              TypeName factoryType = ParameterizedTypeName.create(Provider.class,
+                  TypeNames.forTypeMirror(requestElement.getReturnType()));
+              interfaceMethod.body().addSnippet("%s factory = %s;", factoryType,
+                  memberSelectSnippets.get(bindingKey));
+              interfaceMethod.body().addSnippet("return factory.get();");
+              break;
+            }
+            // fall through in the else case.
+          case LAZY:
+          case PRODUCED:
+          case PRODUCER:
+          case PROVIDER:
+            interfaceMethod.body().addSnippet("return %s;",
+                frameworkTypeUsageStatement(memberSelectSnippets.get(bindingKey),
+                    interfaceRequest.kind()));
+            break;
+          default:
+            throw new AssertionError();
+        }
+      }
     }
+  }
 
-    ImmutableMap<BindingKey, Snippet> memberSelectSnippets = memberSelectSnippetsBuilder.build();
-    ImmutableMap<ContributionBinding, Snippet> multibindingContributionSnippets =
-        multibindingContributionSnippetsBuilder.build();
-    ImmutableSet<BindingKey> enumBindingKeys = enumBindingKeysBuilder.build();
-
+  private void initializeFrameworkTypes(BindingGraph input,
+      ClassWriter componentWriter,
+      ConstructorWriter constructorWriter,
+      Map<TypeElement, FieldWriter> componentContributionFields,
+      ImmutableMap<BindingKey, Snippet> memberSelectSnippets,
+      ImmutableMap<ContributionBinding, Snippet> parentMultibindingContributionSnippets,
+      ImmutableMap<ContributionBinding, Snippet> multibindingContributionSnippets)
+      throws AssertionError {
     List<List<BindingKey>> partitions = Lists.partition(
         input.resolvedBindings().keySet().asList(), 100);
     for (int i = 0; i < partitions.size(); i++) {
@@ -362,23 +577,32 @@ static ProxyClassAndField create(ClassWriter proxyWriter, FieldWriter proxyField
             @SuppressWarnings("unchecked")  // checked during validation
             ImmutableSet<ProvisionBinding> bindings =
                 (ImmutableSet<ProvisionBinding>) input.resolvedBindings()
-                .get(bindingKey)
-                .contributionBindings();
+                    .get(bindingKey)
+                    .contributionBindings();
 
             switch (ContributionBinding.bindingTypeFor(bindings)) {
               case SET:
+                ImmutableList.Builder<Snippet> parameterSnippets = ImmutableList.builder();
                 for (ProvisionBinding provisionBinding : bindings) {
-                  initializeMethod.body().addSnippet("this.%s = %s;",
-                      multibindingContributionSnippets.get(provisionBinding),
-                      initializeFactoryForBinding(provisionBinding,
-                          input.componentDescriptor().dependencyMethodIndex(),
-                          componentContributionFields,
-                          memberSelectSnippets));
+                  if (multibindingContributionSnippets.containsKey(provisionBinding)) {
+                    Snippet snippet = multibindingContributionSnippets.get(provisionBinding);
+                    initializeMethod.body().addSnippet("this.%s = %s;",
+                        snippet,
+                        initializeFactoryForBinding(provisionBinding,
+                            input.componentDescriptor().dependencyMethodIndex(),
+                            componentContributionFields,
+                            memberSelectSnippets));
+                    parameterSnippets.add(snippet);
+                  } else if (parentMultibindingContributionSnippets.containsKey(provisionBinding)) {
+                    parameterSnippets.add(
+                        parentMultibindingContributionSnippets.get(provisionBinding));
+                  } else {
+                    throw new IllegalStateException();
+                  }
                 }
                 Snippet initializeSetSnippet = Snippet.format("%s.create(%s)",
                     ClassName.fromClass(SetFactory.class),
-                    Snippet.makeParametersSnippet(Iterables.transform(bindings,
-                        Functions.forMap(multibindingContributionSnippets))));
+                    Snippet.makeParametersSnippet(parameterSnippets.build()));
                 initializeMethod.body().addSnippet("this.%s = %s;",
                     memberSelectSnippet, initializeSetSnippet);
                 break;
@@ -427,68 +651,6 @@ static ProxyClassAndField create(ClassWriter proxyWriter, FieldWriter proxyField
         }
       }
     }
-
-    Set<MethodSignature> interfaceMethods = Sets.newHashSet();
-
-    for (DependencyRequest interfaceRequest : input.entryPoints()) {
-      ExecutableElement requestElement =
-          MoreElements.asExecutable(interfaceRequest.requestElement());
-      MethodSignature signature = MethodSignature.fromExecutableElement(requestElement);
-      if (!interfaceMethods.contains(signature)) {
-        interfaceMethods.add(signature);
-        MethodWriter interfaceMethod = requestElement.getReturnType().getKind().equals(VOID)
-            ? componentWriter.addMethod(VoidName.VOID, requestElement.getSimpleName().toString())
-                : componentWriter.addMethod(requestElement.getReturnType(),
-                    requestElement.getSimpleName().toString());
-            interfaceMethod.annotate(Override.class);
-            interfaceMethod.addModifiers(PUBLIC);
-            BindingKey bindingKey = BindingKey.forDependencyRequest(interfaceRequest);
-            switch(interfaceRequest.kind()) {
-              case MEMBERS_INJECTOR:
-                Snippet membersInjectorName = memberSelectSnippets.get(bindingKey);
-                VariableElement parameter = Iterables.getOnlyElement(requestElement.getParameters());
-                Name parameterName = parameter.getSimpleName();
-                interfaceMethod.addParameter(
-                    TypeNames.forTypeMirror(parameter.asType()), parameterName.toString());
-                interfaceMethod.body()
-                    .addSnippet("%s.injectMembers(%s);", membersInjectorName, parameterName);
-                if (!requestElement.getReturnType().getKind().equals(VOID)) {
-                  interfaceMethod.body().addSnippet("return %s;", parameterName);
-                }
-                break;
-              case INSTANCE:
-                if (enumBindingKeys.contains(bindingKey)
-                    && !MoreTypes.asDeclared(bindingKey.key().type())
-                            .getTypeArguments().isEmpty()) {
-                  // If using a parameterized enum type, then we need to store the factory
-                  // in a temporary variable, in order to help javac be able to infer
-                  // the generics of the Factory.create methods.
-                  TypeName factoryType = ParameterizedTypeName.create(Provider.class,
-                      TypeNames.forTypeMirror(requestElement.getReturnType()));
-                  interfaceMethod.body().addSnippet("%s factory = %s;", factoryType,
-                      memberSelectSnippets.get(bindingKey));
-                  interfaceMethod.body().addSnippet("return factory.get();");
-                  break;
-                }
-                // fall through in the else case.
-              case LAZY:
-              case PRODUCED:
-              case PRODUCER:
-              case PROVIDER:
-                interfaceMethod.body().addSnippet("return %s;",
-                    frameworkTypeUsageStatement(memberSelectSnippets.get(bindingKey),
-                        interfaceRequest.kind()));
-                break;
-              default:
-                throw new AssertionError();
-            }
-      }
-    }
-
-    return new ImmutableSet.Builder<JavaWriter>()
-        .addAll(proxyWriters.build())
-        .add(writer)
-        .build();
   }
 
   private static FrameworkField frameworkFieldForSyntheticProvisionBinding(BindingKey bindingKey,
diff --git a/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java b/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
index 04f4cf90d..30080b211 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
@@ -29,6 +29,7 @@
 import dagger.Component;
 import dagger.MapKey;
 import dagger.Module;
+import dagger.Subcomponent;
 import dagger.producers.ProducerModule;
 import java.util.List;
 import java.util.Map;
@@ -37,9 +38,11 @@
 import javax.lang.model.element.AnnotationValue;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
+import javax.lang.model.util.SimpleTypeVisitor6;
 import javax.lang.model.util.Types;
 
 import static com.google.auto.common.AnnotationMirrors.getAnnotationValue;
@@ -132,6 +135,23 @@
     return ImmutableMap.copyOf(moduleElements);
   }
 
+  static boolean isSubcomponentType(TypeMirror type) {
+    return type.accept(new SubcomponentDetector(), null).isPresent();
+  }
+
+  private static final class SubcomponentDetector
+      extends SimpleTypeVisitor6<Optional<AnnotationMirror>, Void> {
+    @Override
+    protected Optional<AnnotationMirror> defaultAction(TypeMirror e, Void p) {
+      return Optional.absent();
+    }
+
+    @Override
+    public Optional<AnnotationMirror> visitDeclared(DeclaredType t, Void p) {
+      return MoreElements.getAnnotationMirror(t.asElement(), Subcomponent.class);
+    }
+  }
+
   /** Traverses includes from superclasses and adds them into the builder. */
   private static void addIncludesFromSuperclasses(Types types, TypeElement element,
       ImmutableSet.Builder<TypeElement> builder, TypeMirror objectType) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
index d87f673a6..2d3bbc903 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
@@ -25,6 +25,7 @@
 import com.google.common.collect.Sets;
 import dagger.Component;
 import dagger.Provides;
+import dagger.Subcomponent;
 import dagger.producers.ProductionComponent;
 import javax.inject.Inject;
 import javax.lang.model.element.AnnotationMirror;
diff --git a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
index ea3a14348..290a853f1 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
@@ -109,7 +109,7 @@
         .withErrorContaining(
             String.format(REFERENCED_MODULES_MUST_NOT_BE_ABSTRACT, "test.TestModule"));
   }
-  
+
   @Test public void doubleBindingFromResolvedModules() {
     JavaFileObject parent = JavaFileObjects.forSourceLines("test.ParentModule",
         "package test;",
@@ -624,9 +624,9 @@
         "  public static final class Builder {",
         "    private TestModule testModule;",
         "    private DepModule depModule;",
-        "    private AlwaysIncluded alwaysIncluded;", 
-        "    private ParentTestIncluded parentTestIncluded;", 
-        "    private RefByDep refByDep;", 
+        "    private AlwaysIncluded alwaysIncluded;",
+        "    private ParentTestIncluded parentTestIncluded;",
+        "    private RefByDep refByDep;",
         "    private ParentDepIncluded parentDepIncluded;",
         "",
         "    private Builder() {",
@@ -639,17 +639,17 @@
         "      if (depModule == null) {",
         "        this.depModule = new DepModule();",
         "      }",
-        "      if (alwaysIncluded == null) {", 
-        "        this.alwaysIncluded = new AlwaysIncluded();", 
-        "      }", 
-        "      if (parentTestIncluded == null) {", 
-        "        this.parentTestIncluded = new ParentTestIncluded();", 
-        "      }", 
-        "      if (refByDep == null) {", 
-        "        this.refByDep = new RefByDep();", 
-        "      }", 
-        "      if (parentDepIncluded == null) {", 
-        "        this.parentDepIncluded = new ParentDepIncluded();", 
+        "      if (alwaysIncluded == null) {",
+        "        this.alwaysIncluded = new AlwaysIncluded();",
+        "      }",
+        "      if (parentTestIncluded == null) {",
+        "        this.parentTestIncluded = new ParentTestIncluded();",
+        "      }",
+        "      if (refByDep == null) {",
+        "        this.refByDep = new RefByDep();",
+        "      }",
+        "      if (parentDepIncluded == null) {",
+        "        this.parentDepIncluded = new ParentDepIncluded();",
         "      }",
         "      return new Dagger_TestComponent(this);",
         "    }",
@@ -1688,7 +1688,7 @@
         .compilesWithoutError()
         .and().generatesSources(generatedComponent);
   }
-  
+
   @Test public void wildcardGenericsRequiresAtProvides() {
     JavaFileObject aFile = JavaFileObjects.forSourceLines("test.A",
         "package test;",
diff --git a/core/src/main/java/dagger/Subcomponent.java b/core/src/main/java/dagger/Subcomponent.java
new file mode 100644
index 000000000..c47b58982
--- /dev/null
+++ b/core/src/main/java/dagger/Subcomponent.java
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Target;
+
+import static java.lang.annotation.ElementType.TYPE;
+
+/**
+ * A component that inherits the bindings from a parent {@link Component}.
+ *
+ * <p>Subcomponent implementations only exist in the context of a parent and are associated with
+ * parents using factory methods on the component.  Simply add a method that returns the
+ * subcomponent on the parent.
+ *
+ * @author Gregory Kick
+ * @since 2.0
+ */
+// TODO(gak): add missing spec for @Scope, validation, etc.
+@Target(TYPE)
+@Documented
+public @interface Subcomponent {
+  /**
+   * A list of classes annotated with {@link Module} whose bindings are used to generate the
+   * component implementation.
+   *
+   * <p>At the moment, only modules without arguments are supported.
+   */
+  Class<?>[] modules() default {};
+}
