diff --git a/compiler/pom.xml b/compiler/pom.xml
index ce817e7c9..5ae96f62d 100644
--- a/compiler/pom.xml
+++ b/compiler/pom.xml
@@ -110,6 +110,7 @@
             <goals><goal>compile</goal></goals>
             <configuration>
               <annotationProcessors>
+                <annotationProcessor>com.google.auto.service.processor.AutoServiceProcessor</annotationProcessor>
                 <annotationProcessor>com.google.auto.value.processor.AutoValueProcessor</annotationProcessor>
               </annotationProcessors>
             </configuration>
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
new file mode 100644
index 000000000..39d2e3a98
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
@@ -0,0 +1,354 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import static dagger.internal.codegen.ComponentDescriptor.isComponentProvisionMethod;
+
+import com.google.auto.common.MoreTypes;
+import com.google.auto.value.AutoValue;
+import com.google.common.base.Function;
+import com.google.common.base.Optional;
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableListMultimap;
+import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.ImmutableSetMultimap;
+import com.google.common.collect.Maps;
+import com.google.common.collect.Queues;
+import dagger.Provides;
+import dagger.internal.codegen.BindingGraph.ResolvedBindings.State;
+import dagger.internal.codegen.ProvisionBinding.BindingType;
+import java.util.Deque;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.ElementFilter;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
+
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
+import static com.google.common.collect.Iterables.getOnlyElement;
+import static dagger.internal.codegen.ConfigurationAnnotations.getComponentModules;
+import static dagger.internal.codegen.ConfigurationAnnotations.getTransitiveModules;
+import static javax.lang.model.type.TypeKind.VOID;
+import static javax.lang.model.util.ElementFilter.methodsIn;
+
+/**
+ * The canonical representation of a full-resolved graph.
+ *
+ * @author Gregory Kick
+ */
+@AutoValue
+abstract class BindingGraph {
+  abstract ComponentDescriptor componentDescriptor();
+  abstract ImmutableSet<DependencyRequest> entryPoints();
+  abstract ImmutableMap<TypeElement, ImmutableSet<TypeElement>> transitiveModules();
+  abstract ImmutableMap<Key, ResolvedBindings> resolvedBindings();
+
+  @AutoValue
+  static abstract class ResolvedBindings {
+    enum State {
+      COMPLETE,
+      INCOMPLETE,
+      MULTIPLE_BINDING_TYPES,
+      DUPLICATE_BINDINGS,
+      CYCLE,
+      MALFORMED,
+      MISSING,
+    }
+
+    abstract State state();
+    abstract ImmutableSet<? extends Binding> bindings();
+  }
+
+  static final class Factory {
+    private final Elements elements;
+    private final Types types;
+    private final InjectBindingRegistry injectBindingRegistry;
+    private final Key.Factory keyFactory;
+    private final DependencyRequest.Factory dependencyRequestFactory;
+    private final ProvisionBinding.Factory provisionBindingFactory;
+
+    Factory(Elements elements,
+        Types types,
+        InjectBindingRegistry injectBindingRegistry,
+        dagger.internal.codegen.Key.Factory keyFactory,
+        dagger.internal.codegen.DependencyRequest.Factory dependencyRequestFactory,
+        dagger.internal.codegen.ProvisionBinding.Factory provisionBindingFactory) {
+      this.elements = elements;
+      this.types = types;
+      this.injectBindingRegistry = injectBindingRegistry;
+      this.keyFactory = keyFactory;
+      this.dependencyRequestFactory = dependencyRequestFactory;
+      this.provisionBindingFactory = provisionBindingFactory;
+    }
+
+    BindingGraph create(ComponentDescriptor componentDescriptor) {
+      ImmutableSet.Builder<ProvisionBinding> explicitBindingsBuilder = ImmutableSet.builder();
+
+      // binding for the component itself
+      ProvisionBinding componentBinding =
+          provisionBindingFactory.forComponent(componentDescriptor.componentDefinitionType());
+      explicitBindingsBuilder.add(componentBinding);
+
+      // Collect Component dependencies.
+      ImmutableSet<TypeElement> componentDependencyTypes = MoreTypes.asTypeElements(types,
+          ConfigurationAnnotations.getComponentDependencies(
+              elements, componentDescriptor.componentAnnotation()));
+      for (TypeElement componentDependency : componentDependencyTypes) {
+        explicitBindingsBuilder.add(provisionBindingFactory.forComponent(componentDependency));
+        List<ExecutableElement> dependencyMethods =
+            ElementFilter.methodsIn(elements.getAllMembers(componentDependency));
+        for (ExecutableElement method : dependencyMethods) {
+          if (isComponentProvisionMethod(elements, method)) {
+            // MembersInjection methods aren't "provided" explicitly, so ignore them.
+            explicitBindingsBuilder.add(provisionBindingFactory.forComponentMethod(method));
+          }
+        }
+      }
+
+      // Collect transitive modules provisions.
+      ImmutableSet<TypeElement> moduleTypes =
+          MoreTypes.asTypeElements(types,
+              getComponentModules(elements, componentDescriptor.componentAnnotation()));
+
+      ImmutableMap<TypeElement, ImmutableSet<TypeElement>> transitiveModules =
+          getTransitiveModules(elements, types, moduleTypes);
+      for (TypeElement module : transitiveModules.keySet()) {
+        // traverse the modules, collect the bindings
+        List<ExecutableElement> moduleMethods = methodsIn(elements.getAllMembers(module));
+        for (ExecutableElement moduleMethod : moduleMethods) {
+          if (isAnnotationPresent(moduleMethod, Provides.class)) {
+            try {
+              explicitBindingsBuilder.add(provisionBindingFactory.forProvidesMethod(moduleMethod));
+            } catch (IllegalArgumentException e) {
+              // just ignore it
+            }
+          }
+        }
+      }
+
+      RequestResolver requestResolver =
+          new RequestResolver(explicitBindingsByKey(explicitBindingsBuilder.build()));
+      ImmutableSet<DependencyRequest> componentMethodRequests =
+          componentMethodRequests(componentDescriptor.componentDefinitionType());
+      for (DependencyRequest componentMethodRequest :
+          componentMethodRequests) {
+        requestResolver.resolve(componentMethodRequest);
+      }
+
+      return new AutoValue_BindingGraph(
+          componentDescriptor,
+          componentMethodRequests,
+          transitiveModules,
+          ImmutableMap.copyOf(requestResolver.resolvedBindings));
+    }
+
+    private ImmutableSetMultimap<Key, ProvisionBinding> explicitBindingsByKey(
+        Iterable<ProvisionBinding> bindings) {
+      // Multimaps.index() doesn't do ImmutableSetMultimaps.
+      ImmutableSetMultimap.Builder<Key, ProvisionBinding> builder = ImmutableSetMultimap.builder();
+      for (ProvisionBinding binding : bindings) {
+        builder.put(binding.key(), binding);
+      }
+      return builder.build();
+    }
+
+    private ImmutableSet<DependencyRequest> componentMethodRequests(TypeElement componentType) {
+      ImmutableSet.Builder<DependencyRequest> interfaceRequestsBuilder = ImmutableSet.builder();
+      for (ExecutableElement componentMethod : methodsIn(elements.getAllMembers(componentType))) {
+        if (componentMethod.getModifiers().contains(Modifier.ABSTRACT)) { // Elide Object.*;
+          if (ComponentDescriptor.isComponentProvisionMethod(elements, componentMethod)) {
+            interfaceRequestsBuilder.add(
+                dependencyRequestFactory.forComponentProvisionMethod(componentMethod));
+          } else if (isComponentMembersInjectionMethod(componentMethod)) {
+            interfaceRequestsBuilder.add(
+                dependencyRequestFactory.forComponentMembersInjectionMethod(componentMethod));
+          }
+        }
+      }
+      return interfaceRequestsBuilder.build();
+    }
+
+    private boolean isComponentMembersInjectionMethod(ExecutableElement method) {
+      List<? extends VariableElement> parameters = method.getParameters();
+      TypeMirror returnType = method.getReturnType();
+      return parameters.size() == 1
+          && (returnType.getKind().equals(VOID)
+              || MoreTypes.equivalence().equivalent(returnType, parameters.get(0).asType()))
+          && !elements.getTypeElement(Object.class.getCanonicalName())
+              .equals(method.getEnclosingElement());
+    }
+
+    private final class RequestResolver {
+      final ImmutableSetMultimap<Key, ProvisionBinding> explicitBindings;
+      final Map<Key, ResolvedBindings> resolvedBindings;
+      final Deque<Key> cycleStack = Queues.newArrayDeque();
+
+      RequestResolver(ImmutableSetMultimap<Key, ProvisionBinding> explicitBindings) {
+        assert explicitBindings != null;
+        this.explicitBindings = explicitBindings;
+        this.resolvedBindings = Maps.newLinkedHashMap();
+      }
+
+      State resolve(DependencyRequest request) {
+        Key requestKey = request.key();
+
+        ResolvedBindings previouslyResolvedBinding = resolvedBindings.get(requestKey);
+        if (previouslyResolvedBinding != null) {
+          return previouslyResolvedBinding.state();
+        }
+
+        if (cycleStack.contains(requestKey)) {
+          // return malformed, but don't add a resolved binding.
+          // the original request will add it with all of the other resolved deps
+          return State.CYCLE;
+        }
+
+        cycleStack.push(requestKey);
+        try {
+          switch (request.kind()) {
+            case INSTANCE:
+            case LAZY:
+            case PROVIDER:
+              // First, check for explicit keys (those from modules and components)
+              ImmutableSet<ProvisionBinding> explicitBindingsForKey =
+                  explicitBindings.get(requestKey);
+              if (explicitBindingsForKey.isEmpty()) {
+                // If the key is Map<K, V>, get its implicit binding key which is
+                // Map<K, Provider<V>>
+                Optional<Key> mapProviderKey = keyFactory.implicitMapProviderKeyFrom(request.key());
+                if (mapProviderKey.isPresent()) {
+                  DependencyRequest implicitRequest =
+                      dependencyRequestFactory.forImplicitMapBinding(request, mapProviderKey.get());
+                  ProvisionBinding implicitBinding =
+                      provisionBindingFactory.forImplicitMapBinding(request, implicitRequest);
+                  State implicitState = resolve(implicitRequest);
+                  resolvedBindings.put(requestKey,
+                      new AutoValue_BindingGraph_ResolvedBindings(
+                          implicitState.equals(State.COMPLETE) ? State.COMPLETE : State.INCOMPLETE,
+                          ImmutableSet.of(implicitBinding)));
+                  return State.COMPLETE;
+                } else {
+                  // no explicit binding, look it up.
+                  Optional<ProvisionBinding> provisionBinding =
+                      injectBindingRegistry.getOrFindProvisionBinding(requestKey);
+                  if (provisionBinding.isPresent()) {
+                    // found a binding, resolve its deps and then mark it resolved
+                    State bindingState =
+                        resolveDependencies(provisionBinding.get().implicitDependencies());
+                    resolvedBindings.put(requestKey,
+                        new AutoValue_BindingGraph_ResolvedBindings(
+                            bindingState,
+                            ImmutableSet.copyOf(provisionBinding.asSet())));
+                    return bindingState;
+                  } else {
+                    // no explicit binding, no inject binding.  it's missing
+                    resolvedBindings.put(requestKey,
+                        new AutoValue_BindingGraph_ResolvedBindings(
+                            State.MISSING, ImmutableSet.<Binding>of()));
+                    return State.MISSING;
+                  }
+                }
+              } else {
+                // If this is an explicit Map<K, V> request then add in any map binding provision
+                // methods which are implied by and must collide with explicit Map<K, V> bindings.
+                Optional<Key> underlyingMapKey =
+                    keyFactory.implicitMapProviderKeyFrom(request.key());
+                if (underlyingMapKey.isPresent()) {
+                  explicitBindingsForKey = ImmutableSet.<ProvisionBinding>builder()
+                      .addAll(explicitBindingsForKey)
+                      .addAll(explicitBindings.get(underlyingMapKey.get()))
+                      .build();
+                }
+                ImmutableSet<DependencyRequest> allDeps =
+                    FluentIterable.from(explicitBindingsForKey)
+                        .transformAndConcat(
+                            new Function<ProvisionBinding, Set<DependencyRequest>>() {
+                              @Override
+                              public Set<DependencyRequest> apply(ProvisionBinding input) {
+                                return input.implicitDependencies();
+                              }
+                            })
+                        .toSet();
+                State bindingState = resolveDependencies(allDeps);
+                if (explicitBindingsForKey.size() > 1) {
+                  // Multiple Explicit bindings. Validate that they are multi-bindings.
+                  ImmutableListMultimap<BindingType, ProvisionBinding> bindingsByType =
+                      ProvisionBinding.bindingTypesFor(explicitBindingsForKey);
+                  if (bindingsByType.keySet().size() > 1) {
+                    resolvedBindings.put(requestKey,
+                        new AutoValue_BindingGraph_ResolvedBindings(
+                            State.MULTIPLE_BINDING_TYPES,
+                            explicitBindingsForKey));
+                    return State.MULTIPLE_BINDING_TYPES;
+                  } else if (getOnlyElement(bindingsByType.keySet()).equals(BindingType.UNIQUE)) {
+                    resolvedBindings.put(requestKey,
+                        new AutoValue_BindingGraph_ResolvedBindings(
+                            State.DUPLICATE_BINDINGS,
+                            explicitBindingsForKey));
+                    return State.DUPLICATE_BINDINGS;
+                  }
+                }
+                resolvedBindings.put(requestKey,
+                    new AutoValue_BindingGraph_ResolvedBindings(
+                        bindingState, explicitBindingsForKey));
+                return bindingState;
+              }
+            case MEMBERS_INJECTOR:
+              // no explicit deps for members injection, so just look it up
+              Optional<MembersInjectionBinding> membersInjectionBinding = Optional.fromNullable(
+                  injectBindingRegistry.getOrFindMembersInjectionBinding(requestKey));
+              if (membersInjectionBinding.isPresent()) {
+                // found a binding, resolve its deps and then mark it resolved
+                State bindingState =
+                    resolveDependencies(membersInjectionBinding.get().implicitDependencies());
+                resolvedBindings.put(requestKey,
+                    new AutoValue_BindingGraph_ResolvedBindings(
+                        bindingState,
+                        ImmutableSet.copyOf(membersInjectionBinding.asSet())));
+                return bindingState;
+              } else {
+                return State.MISSING;
+              }
+            default:
+              throw new AssertionError();
+          }
+        } finally {
+          cycleStack.pop();
+        }
+      }
+
+      private State resolveDependencies(Iterable<DependencyRequest> dependencies) {
+        State bindingState = State.COMPLETE;
+        for (DependencyRequest dependency : dependencies) {
+          State dependencyState = resolve(dependency);
+          if (dependencyState.equals(State.CYCLE)) {
+            bindingState = State.CYCLE;
+          } else if (!bindingState.equals(State.CYCLE) && !dependencyState.equals(State.COMPLETE)) {
+            bindingState = State.INCOMPLETE;
+          }
+        }
+        return bindingState;
+      }
+    }
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
new file mode 100644
index 000000000..ade56ca1e
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -0,0 +1,248 @@
+package dagger.internal.codegen;
+
+import com.google.auto.common.MoreElements;
+import com.google.common.base.Function;
+import com.google.common.base.Joiner;
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableListMultimap;
+import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Iterables;
+import com.google.common.collect.Lists;
+import com.google.common.collect.Ordering;
+import dagger.internal.codegen.BindingGraph.ResolvedBindings;
+import dagger.internal.codegen.BindingGraph.ResolvedBindings.State;
+import dagger.internal.codegen.ProvisionBinding.BindingType;
+import java.util.Deque;
+import java.util.Formatter;
+import java.util.LinkedList;
+import java.util.Set;
+import javax.lang.model.element.ElementKind;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.Name;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.SimpleTypeVisitor6;
+import javax.lang.model.util.Types;
+
+import static dagger.internal.codegen.ErrorMessages.INDENT;
+import static dagger.internal.codegen.ErrorMessages.REQUIRES_AT_INJECT_CONSTRUCTOR_OR_PROVIDER_FORMAT;
+import static dagger.internal.codegen.ErrorMessages.REQUIRES_PROVIDER_FORMAT;
+
+public class BindingGraphValidator implements Validator<BindingGraph> {
+  private final Types types;
+  private final InjectBindingRegistry injectBindingRegistry;
+
+  BindingGraphValidator(Types types, InjectBindingRegistry injectBindingRegistry) {
+    this.types = types;
+    this.injectBindingRegistry = injectBindingRegistry;
+  }
+
+  @Override
+  public ValidationReport<BindingGraph> validate(final BindingGraph subject) {
+    final ValidationReport.Builder<BindingGraph> reportBuilder =
+        ValidationReport.Builder.about(subject);
+    ImmutableMap<Key, ResolvedBindings> resolvedBindings = subject.resolvedBindings();
+
+    for (DependencyRequest entryPoint : subject.entryPoints()) {
+      ResolvedBindings resolvedBinding = resolvedBindings.get(entryPoint.key());
+      if (!resolvedBinding.state().equals(State.COMPLETE)) {
+        LinkedList<DependencyRequest> requestPath = Lists.newLinkedList();
+        requestPath.push(entryPoint);
+        traversalHelper(subject, requestPath, new Traverser() {
+          @Override
+          boolean visitResolvedBinding(
+              Deque<DependencyRequest> requestPath, ResolvedBindings binding) {
+            switch (binding.state()) {
+              case COMPLETE:
+              case INCOMPLETE:
+                return true;
+              case MISSING:
+                reportMissingBinding(requestPath, reportBuilder);
+                return false;
+              case DUPLICATE_BINDINGS:
+                reportDuplicateBindings(requestPath, binding, reportBuilder);
+                return false;
+              case MULTIPLE_BINDING_TYPES:
+                reportMultipleBindingTypes(requestPath, binding, reportBuilder);
+                return false;
+              case CYCLE:
+                reportCycle(requestPath, subject, reportBuilder);
+                return false;
+              case MALFORMED:
+                return false;
+              default:
+                throw new AssertionError();
+            }
+          }
+        });
+      }
+    }
+
+    return reportBuilder.build();
+  }
+
+  private void reportMissingBinding(
+      Deque<DependencyRequest> requestPath, ValidationReport.Builder<BindingGraph> reportBuilder) {
+    Key key = requestPath.peek().key();
+    TypeMirror type = key.type();
+    Name typeName = MoreElements.asType(types.asElement(type)).getQualifiedName();
+    boolean requiresProvidesMethod = type.accept(new SimpleTypeVisitor6<Boolean, Void>() {
+      @Override protected Boolean defaultAction(TypeMirror e, Void p) {
+        return true;
+      }
+
+      @Override public Boolean visitDeclared(DeclaredType type, Void ignored) {
+        // Note - this logic is also in InjectConstructorValidator but is woven into errors.
+        TypeElement typeElement = MoreElements.asType(type.asElement());
+        if (typeElement.getTypeParameters().isEmpty()
+            && typeElement.getKind().equals(ElementKind.CLASS)
+            && !typeElement.getModifiers().contains(Modifier.ABSTRACT)) {
+          return false;
+        }
+        return true;
+      }
+    }, null);
+    StringBuilder errorMessage = new StringBuilder();
+    if(requiresProvidesMethod) {
+      errorMessage.append(String.format(REQUIRES_PROVIDER_FORMAT, typeName));
+    } else {
+      errorMessage.append(
+          String.format(REQUIRES_AT_INJECT_CONSTRUCTOR_OR_PROVIDER_FORMAT, typeName));
+    }
+    if (key.isValidMembersInjectionKey()
+        && !injectBindingRegistry.getOrFindMembersInjectionBinding(key).injectionSites()
+            .isEmpty()) {
+      errorMessage.append(" ").append(ErrorMessages.MEMBERS_INJECTION_DOES_NOT_IMPLY_PROVISION);
+    }
+    ImmutableList<String> printableDependencyPath =
+        FluentIterable.from(requestPath)
+            .transform(DependencyRequestFormatter.instance())
+            .toList()
+            .reverse();
+    for(String dependency :
+        printableDependencyPath.subList(1, printableDependencyPath.size())) {
+      errorMessage.append("\n").append(dependency);
+    }
+    reportBuilder.addItem(errorMessage.toString(), requestPath.getLast().requestElement());
+  }
+
+  private static final int DUPLICATE_SIZE_LIMIT = 10;
+
+  @SuppressWarnings("resource") // Appendable is a StringBuilder.
+  private void reportDuplicateBindings(Deque<DependencyRequest> requestPath,
+      ResolvedBindings resolvedBinding, ValidationReport.Builder<BindingGraph> reportBuilder) {
+    StringBuilder builder = new StringBuilder();
+    new Formatter(builder).format(ErrorMessages.DUPLICATE_BINDINGS_FOR_KEY_FORMAT,
+        KeyFormatter.instance().format(requestPath.peek().key()));
+    for (Binding binding : Iterables.limit(resolvedBinding.bindings(), DUPLICATE_SIZE_LIMIT)) {
+      builder.append('\n').append(INDENT);
+      builder.append(ProvisionBindingFormatter.instance().format((ProvisionBinding) binding));
+    }
+    int numberOfOtherBindings = resolvedBinding.bindings().size() - DUPLICATE_SIZE_LIMIT;
+    if (numberOfOtherBindings > 0) {
+      builder.append('\n').append(INDENT)
+          .append("and ").append(numberOfOtherBindings).append(" other");
+    }
+    if (numberOfOtherBindings > 1) {
+      builder.append('s');
+    }
+    reportBuilder.addItem(builder.toString(), requestPath.getLast().requestElement());
+  }
+
+  @SuppressWarnings("resource") // Appendable is a StringBuilder.
+  private void reportMultipleBindingTypes(Deque<DependencyRequest> requestPath,
+      ResolvedBindings resolvedBinding, ValidationReport.Builder<BindingGraph> reportBuilder) {
+    StringBuilder builder = new StringBuilder();
+    new Formatter(builder).format(ErrorMessages.MULTIPLE_BINDING_TYPES_FOR_KEY_FORMAT,
+        KeyFormatter.instance().format(requestPath.peek().key()));
+    @SuppressWarnings("unchecked")
+    ImmutableListMultimap<BindingType, ProvisionBinding> bindingsByType =
+        ProvisionBinding.bindingTypesFor((Iterable<ProvisionBinding>) resolvedBinding.bindings());
+    for (BindingType type :
+        Ordering.natural().immutableSortedCopy(bindingsByType.keySet())) {
+      builder.append(INDENT);
+      builder.append(formatBindingType(type));
+      builder.append(" bindings:\n");
+      for (ProvisionBinding binding : bindingsByType.get(type)) {
+        builder.append(INDENT).append(INDENT);
+        builder.append(ProvisionBindingFormatter.instance().format(binding));
+        builder.append('\n');
+      }
+    }
+    reportBuilder.addItem(builder.toString(), requestPath.getLast().requestElement());
+  }
+
+  private String formatBindingType(BindingType type) {
+    switch(type) {
+      case MAP:
+        return "Map";
+      case SET:
+        return "Set";
+      case UNIQUE:
+        return "Unique";
+      default:
+        throw new IllegalStateException("Unknown binding type: " + type);
+    }
+  }
+
+  private void reportCycle(Deque<DependencyRequest> requestPath,
+      BindingGraph graph, final ValidationReport.Builder<BindingGraph> reportBuilder) {
+    final DependencyRequest startingRequest = requestPath.peek();
+    final Key cycleKey = startingRequest.key();
+    traversalHelper(graph, requestPath, new Traverser() {
+      @Override
+      boolean visitResolvedBinding(Deque<DependencyRequest> requestPath, ResolvedBindings binding) {
+        DependencyRequest request = requestPath.peek();
+        boolean endOfCycle = !startingRequest.equals(request) && cycleKey.equals(request.key());
+        if (endOfCycle) {
+          ImmutableList<String> printableDependencyPath = FluentIterable.from(requestPath)
+              .transform(DependencyRequestFormatter.instance()).toList().reverse();
+          DependencyRequest rootRequest = requestPath.getLast();
+          TypeElement componentType =
+              MoreElements.asType(rootRequest.requestElement().getEnclosingElement());
+          // TODO(user): Restructure to provide a hint for the start and end of the cycle.
+          reportBuilder.addItem(
+              String.format(ErrorMessages.CONTAINS_DEPENDENCY_CYCLE_FORMAT,
+                  componentType.getQualifiedName(),
+                  rootRequest.requestElement().getSimpleName(),
+                  Joiner.on("\n")
+                      .join(printableDependencyPath.subList(1, printableDependencyPath.size()))),
+                  rootRequest.requestElement());
+        }
+        return !endOfCycle;
+      }
+    });
+
+  }
+
+  private void traversalHelper(BindingGraph graph, Deque<DependencyRequest> requestPath,
+      Traverser traverser) {
+    ResolvedBindings resolvedBinding = graph.resolvedBindings().get(requestPath.peek().key());
+    ImmutableSet<DependencyRequest> allDeps =
+        FluentIterable.from(resolvedBinding.bindings())
+            .transformAndConcat(
+                new Function<Binding, Set<DependencyRequest>>() {
+                  @Override
+                  public Set<DependencyRequest> apply(Binding input) {
+                    return input.implicitDependencies();
+                  }
+                })
+            .toSet();
+    boolean descend = traverser.visitResolvedBinding(requestPath, resolvedBinding);
+    if (descend) {
+      for (DependencyRequest dependency : allDeps) {
+        requestPath.push(dependency);
+        traversalHelper(graph, requestPath, traverser);
+        requestPath.pop();
+      }
+    }
+  }
+
+  static abstract class Traverser {
+    abstract boolean visitResolvedBinding(
+        Deque<DependencyRequest> requestPath, ResolvedBindings binding);
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
index 303668368..8a6c71aa3 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
@@ -15,39 +15,21 @@
  */
 package dagger.internal.codegen;
 
-import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
-import com.google.common.base.Optional;
-import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ImmutableSetMultimap;
-import com.google.common.collect.Iterables;
-import com.google.common.collect.MultimapBuilder;
-import com.google.common.collect.Queues;
-import com.google.common.collect.SetMultimap;
-import com.google.common.collect.Sets;
 import dagger.Component;
-import dagger.MembersInjector;
-import dagger.Provides;
-import java.util.Deque;
 import java.util.List;
-import java.util.Map.Entry;
-import java.util.Set;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
-import javax.lang.model.element.VariableElement;
 import javax.lang.model.util.ElementFilter;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 
 import static com.google.auto.common.MoreElements.getAnnotationMirror;
-import static com.google.auto.common.MoreElements.isAnnotationPresent;
-import static com.google.common.base.Preconditions.checkState;
-import static dagger.internal.codegen.ConfigurationAnnotations.getTransitiveModules;
-import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.type.TypeKind.VOID;
 
 /**
@@ -60,6 +42,8 @@
 abstract class ComponentDescriptor {
   ComponentDescriptor() {}
 
+  abstract AnnotationMirror componentAnnotation();
+
   /**
    * The type (interface or abstract class) that defines the component. This is the element to which
    * the {@link Component} annotation was applied.
@@ -78,72 +62,22 @@
    */
   abstract ImmutableMap<ExecutableElement, TypeElement> dependencyMethodIndex();
 
-  /**
-   * The list of {@link DependencyRequest} instances whose sources are methods on the component
-   * definition type.  These are the user-requested dependencies.
-   */
-  abstract ImmutableList<DependencyRequest> interfaceRequests();
-
-  /**
-   * The total set of modules (those declared in {@link Component#modules} and their transitive
-   * dependencies) required to construct the object graph declared by the component.
-   */
-  abstract ImmutableSet<TypeElement> moduleDependencies();
-
-  /**
-   * Returns the mapping from {@link Key} to {@link ProvisionBinding} that
-   * (with {@link #resolvedMembersInjectionBindings}) represents the full adjacency matrix for the
-   * object graph.
-   */
-  abstract ImmutableSetMultimap<Key, ProvisionBinding> resolvedProvisionBindings();
-
-  /**
-   * Returns the mapping from {@link Key} to {@link MembersInjectionBinding} that
-   * (with {@link #resolvedProvisionBindings}) represents the full adjacency matrix for the object
-   * graph.
-   */
-  abstract ImmutableMap<Key, MembersInjectionBinding> resolvedMembersInjectionBindings();
-
-  /** The package in which each {@link Key} initialization must happen.  */
-  abstract ImmutableSetMultimap<String, Key> initializationByPackage();
-
-  /**
-   * The ordering of {@link Key keys} that will allow all of the {@link Factory} and
-   * {@link MembersInjector} implementations to initialize properly.
-   */
-  abstract ImmutableList<Key> initializationOrdering();
-
   static final class Factory {
     private final Elements elements;
     private final Types types;
-    private final InjectBindingRegistry injectBindingRegistry;
-    private final Key.Factory keyFactory;
     private final ProvisionBinding.Factory provisionBindingFactory;
-    private final DependencyRequest.Factory dependencyRequestFactory;
 
-    Factory(Elements elements, Types types,
-        InjectBindingRegistry injectBindingRegistry,
-        DependencyRequest.Factory dependencyRequestFactory,
-        Key.Factory keyFactory,
-        ProvisionBinding.Factory provisionBindingFactory) {
+    Factory(Elements elements, Types types, ProvisionBinding.Factory provisionBindingFactory) {
       this.elements = elements;
       this.types = types;
-      this.injectBindingRegistry = injectBindingRegistry;
-      this.dependencyRequestFactory = dependencyRequestFactory;
-      this.keyFactory = keyFactory;
       this.provisionBindingFactory = provisionBindingFactory;
     }
 
-    ComponentDescriptor create(TypeElement componentDefinitionType)
-        throws SourceFileGenerationException {
+    ComponentDescriptor create(TypeElement componentDefinitionType) {
       AnnotationMirror componentMirror =
           getAnnotationMirror(componentDefinitionType, Component.class).get();
-      ImmutableSet<TypeElement> moduleTypes = MoreTypes.asTypeElements(types,
-          ConfigurationAnnotations.getComponentModules(elements, componentMirror));
       ImmutableSet<TypeElement> componentDependencyTypes = MoreTypes.asTypeElements(types,
           ConfigurationAnnotations.getComponentDependencies(elements, componentMirror));
-      ImmutableSet<TypeElement> transitiveModules =
-          getTransitiveModules(elements, types, moduleTypes);
 
       ProvisionBinding componentBinding =
           provisionBindingFactory.forComponent(componentDefinitionType);
@@ -162,7 +96,7 @@ ComponentDescriptor create(TypeElement componentDefinitionType)
         List<ExecutableElement> dependencyMethods =
             ElementFilter.methodsIn(elements.getAllMembers(componentDependency));
         for (ExecutableElement dependencyMethod : dependencyMethods) {
-          if (isComponentProvisionMethod(dependencyMethod)) {
+          if (isComponentProvisionMethod(elements, dependencyMethod)) {
             ProvisionBinding componentMethodBinding =
                 provisionBindingFactory.forComponentMethod(dependencyMethod);
             explicitBindingIndexBuilder
@@ -172,175 +106,18 @@ ComponentDescriptor create(TypeElement componentDefinitionType)
         }
       }
 
-      for (TypeElement module : transitiveModules) {
-        // traverse the modules, collect the bindings
-        List<ExecutableElement> moduleMethods =
-            ElementFilter.methodsIn(elements.getAllMembers(module));
-        for (ExecutableElement moduleMethod : moduleMethods) {
-          if (isAnnotationPresent(moduleMethod, Provides.class)) {
-            ProvisionBinding providesMethodBinding =
-                provisionBindingFactory.forProvidesMethod(moduleMethod);
-            explicitBindingIndexBuilder
-                .put(providesMethodBinding.key(), providesMethodBinding);
-          }
-        }
-      }
-
-      ImmutableSetMultimap<Key, ProvisionBinding> explicitBindings =
-          explicitBindingIndexBuilder.build();
-
-      Set<MethodSignature> interfaceMethods = Sets.newHashSet();
-
-      ImmutableList.Builder<DependencyRequest> interfaceRequestsBuilder = ImmutableList.builder();
-
-      Deque<DependencyRequest> requestsToResolve = Queues.newArrayDeque();
-
-      for (ExecutableElement componentMethod
-          : ElementFilter.methodsIn(elements.getAllMembers(componentDefinitionType))) {
-        if (componentMethod.getModifiers().contains(ABSTRACT)) {
-          MethodSignature signature = MethodSignature.fromExecutableElement(componentMethod);
-          if (!interfaceMethods.contains(signature)) {
-            List<? extends VariableElement> parameters = componentMethod.getParameters();
-            switch (parameters.size()) {
-              case 0:
-                // provision method
-                DependencyRequest provisionRequest =
-                dependencyRequestFactory.forComponentProvisionMethod(componentMethod);
-                interfaceRequestsBuilder.add(provisionRequest);
-                requestsToResolve.addLast(provisionRequest);
-                break;
-              case 1:
-                // members injection method
-                DependencyRequest membersInjectionRequest =
-                dependencyRequestFactory.forComponentMembersInjectionMethod(componentMethod);
-                interfaceRequestsBuilder.add(membersInjectionRequest);
-                requestsToResolve.addLast(membersInjectionRequest);
-                break;
-              default:
-                throw new IllegalStateException();
-            }
-            interfaceMethods.add(signature);
-          }
-        }
-      }
-
-      ImmutableSetMultimap.Builder<Key, ProvisionBinding> resolvedProvisionBindings =
-          ImmutableSetMultimap.builder();
-      ImmutableMap.Builder<Key, MembersInjectionBinding> resolvedMembersInjectionBindings =
-          ImmutableMap.builder();
-      SetMultimap<Key, Binding> resolvedBindings =
-          MultimapBuilder.linkedHashKeys().linkedHashSetValues().build();
-
-      ImmutableList<DependencyRequest> interfaceRequests = interfaceRequestsBuilder.build();
-
-      for (DependencyRequest interfaceRequest : interfaceRequests) {
-        resolveRequest(interfaceRequest, explicitBindings, resolvedBindings,
-            resolvedProvisionBindings, resolvedMembersInjectionBindings);
-      }
-
-      ImmutableSetMultimap.Builder<String, Key> initializationByPackageBuilder =
-          ImmutableSetMultimap.builder();
-      for (Entry<Key, Binding> resolvedBindingEntry : resolvedBindings.entries()) {
-        initializationByPackageBuilder.put(
-            resolvedBindingEntry.getValue().bindingPackage().or(
-                  MoreElements.getPackage(componentDefinitionType).getQualifiedName().toString()),
-            resolvedBindingEntry.getKey());
-      }
-
       return new AutoValue_ComponentDescriptor(
+          componentMirror,
           componentDefinitionType,
           componentDependencyTypes,
-          dependencyMethodIndex.build(),
-          interfaceRequests,
-          transitiveModules,
-          resolvedProvisionBindings.build(),
-          resolvedMembersInjectionBindings.build(),
-          initializationByPackageBuilder.build(),
-          ImmutableList.copyOf(resolvedBindings.keySet()));
-    }
-
-    private void resolveRequest(DependencyRequest request,
-        ImmutableSetMultimap<Key, ProvisionBinding> explicitBindings,
-        SetMultimap<Key, Binding> resolvedBindings,
-        ImmutableSetMultimap.Builder<Key, ProvisionBinding> resolvedProvisionsBindingBuilder,
-        ImmutableMap.Builder<Key, MembersInjectionBinding> resolvedMembersInjectionBindingsBuilder)
-            throws SourceFileGenerationException {
-      Key requestKey = request.key();
-      if (resolvedBindings.containsKey(requestKey)) {
-        return;
-      }
-      switch (request.kind()) {
-        case INSTANCE:
-        case LAZY:
-        case PROVIDER:
-          // First, check for explicit keys (those from modules and components)
-          ImmutableSet<ProvisionBinding> explicitBindingsForKey =
-              explicitBindings.get(requestKey);
-          if (explicitBindingsForKey.isEmpty()) {
-            // If the key is Map<K, V>, get its implicit binding key which is Map<K, Provider<V>>
-            Optional<Key> key = keyFactory.implicitMapProviderKeyFrom(request.key());
-            if (key.isPresent()) {
-              DependencyRequest implicitRequest =
-                  dependencyRequestFactory.forImplicitMapBinding(request, key.get());
-              ProvisionBinding implicitBinding =
-                  provisionBindingFactory.forImplicitMapBinding(request, implicitRequest);
-              resolveRequest(Iterables.getOnlyElement(implicitBinding.dependencies()),
-                  explicitBindings, resolvedBindings, resolvedProvisionsBindingBuilder,
-                  resolvedMembersInjectionBindingsBuilder);
-              resolvedBindings.put(requestKey, implicitBinding);
-              resolvedProvisionsBindingBuilder.put(request.key(), implicitBinding);
-            } else {
-              // no explicit binding, look it up
-              Optional<ProvisionBinding> provisionBinding =
-                  injectBindingRegistry.getOrFindProvisionBinding(requestKey);
-              checkState(provisionBinding.isPresent(),
-                  "Can not find a provision binding for %s. this should not have passed validation",
-                  requestKey);
-              // found a binding, resolve its deps and then mark it resolved
-              for (DependencyRequest dependency : Iterables.concat(
-                  provisionBinding.get().dependencies(),
-                  provisionBinding.get().memberInjectionRequest().asSet())) {
-                resolveRequest(dependency, explicitBindings, resolvedBindings,
-                    resolvedProvisionsBindingBuilder, resolvedMembersInjectionBindingsBuilder);
-              }
-              resolvedBindings.put(requestKey, provisionBinding.get());
-              resolvedProvisionsBindingBuilder.put(requestKey, provisionBinding.get());
-            }
-          } else {
-            // we found explicit bindings. resolve the deps and them mark them resolved
-            for (Binding explicitBinding : explicitBindingsForKey) {
-              for (DependencyRequest dependency : explicitBinding.dependencies()) {
-                resolveRequest(dependency, explicitBindings, resolvedBindings,
-                    resolvedProvisionsBindingBuilder, resolvedMembersInjectionBindingsBuilder);
-              }
-            }
-            resolvedBindings.putAll(requestKey, explicitBindingsForKey);
-            resolvedProvisionsBindingBuilder.putAll(requestKey, explicitBindingsForKey);
-          }
-          break;
-        case MEMBERS_INJECTOR:
-         // no explicit deps for members injection, so just look it up
-          MembersInjectionBinding membersInjectionBinding =
-              injectBindingRegistry.getOrFindMembersInjectionBinding(requestKey);
-          //resolve its deps and then mark it resolved
-          for (DependencyRequest dependency : Iterables.concat(
-              membersInjectionBinding.dependencies(),
-              membersInjectionBinding.parentInjectorRequest().asSet())) {
-            resolveRequest(dependency, explicitBindings, resolvedBindings,
-                resolvedProvisionsBindingBuilder, resolvedMembersInjectionBindingsBuilder);
-          }
-          resolvedBindings.put(requestKey, membersInjectionBinding);
-          resolvedMembersInjectionBindingsBuilder.put(requestKey, membersInjectionBinding);
-          break;
-        default:
-          throw new AssertionError();
-      }
-
+          dependencyMethodIndex.build());
     }
+  }
 
-    private static boolean isComponentProvisionMethod(ExecutableElement method) {
-      return method.getParameters().isEmpty()
-          && !method.getReturnType().getKind().equals(VOID);
-    }
+  static boolean isComponentProvisionMethod(Elements elements, ExecutableElement method) {
+    return method.getParameters().isEmpty()
+        && !method.getReturnType().getKind().equals(VOID)
+        && !elements.getTypeElement(Object.class.getCanonicalName())
+            .equals(method.getEnclosingElement());
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
index 8628417f0..81de37ca9 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
@@ -15,6 +15,7 @@
  */
 package dagger.internal.codegen;
 
+import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.common.base.CaseFormat;
 import com.google.common.base.Function;
@@ -25,11 +26,9 @@
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.ImmutableSetMultimap;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
-import com.google.common.collect.Multimaps;
 import com.google.common.collect.Sets;
 import dagger.Component;
 import dagger.Factory;
@@ -40,6 +39,7 @@
 import dagger.internal.MembersInjectors;
 import dagger.internal.ScopedProvider;
 import dagger.internal.SetFactory;
+import dagger.internal.codegen.BindingGraph.ResolvedBindings;
 import dagger.internal.codegen.ProvisionBinding.BindingType;
 import dagger.internal.codegen.writer.ClassName;
 import dagger.internal.codegen.writer.ClassWriter;
@@ -52,6 +52,7 @@
 import dagger.internal.codegen.writer.StringLiteral;
 import dagger.internal.codegen.writer.TypeName;
 import dagger.internal.codegen.writer.TypeNames;
+import dagger.internal.codegen.writer.TypeWriter;
 import dagger.internal.codegen.writer.VoidName;
 import java.util.EnumSet;
 import java.util.Iterator;
@@ -73,19 +74,20 @@
 import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.ElementKindVisitor6;
 import javax.lang.model.util.SimpleAnnotationValueVisitor6;
 
 import static com.google.auto.common.MoreTypes.asDeclared;
 import static com.google.common.base.CaseFormat.LOWER_CAMEL;
 import static dagger.internal.codegen.ConfigurationAnnotations.getMapKeys;
 import static dagger.internal.codegen.DependencyRequest.Kind.MEMBERS_INJECTOR;
+import static dagger.internal.codegen.ProvisionBinding.FactoryCreationStrategy.ENUM_INSTANCE;
 import static dagger.internal.codegen.ProvisionBinding.Kind.COMPONENT;
 import static dagger.internal.codegen.ProvisionBinding.Kind.COMPONENT_PROVISION;
+import static dagger.internal.codegen.ProvisionBinding.Kind.INJECTION;
 import static dagger.internal.codegen.ProvisionBinding.Kind.PROVISION;
 import static dagger.internal.codegen.SourceFiles.factoryNameForProvisionBinding;
 import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
-import static dagger.internal.codegen.SourceFiles.generateMembersInjectorNamesForBindings;
-import static dagger.internal.codegen.SourceFiles.generateProviderNamesForBindings;
 import static dagger.internal.codegen.SourceFiles.membersInjectorNameForMembersInjectionBinding;
 import static javax.lang.model.element.ElementKind.CONSTRUCTOR;
 import static javax.lang.model.element.Modifier.FINAL;
@@ -102,33 +104,33 @@
  * @author Gregory Kick
  * @since 2.0
  */
-final class ComponentGenerator extends SourceFileGenerator<ComponentDescriptor> {
+final class ComponentGenerator extends SourceFileGenerator<BindingGraph> {
   ComponentGenerator(Filer filer) {
     super(filer);
   }
 
   @Override
-  ClassName nameGeneratedType(ComponentDescriptor input) {
+  ClassName nameGeneratedType(BindingGraph input) {
     ClassName componentDefinitionClassName =
-        ClassName.fromTypeElement(input.componentDefinitionType());
+        ClassName.fromTypeElement(input.componentDescriptor().componentDefinitionType());
     return componentDefinitionClassName.topLevelClassName().peerNamed(
         "Dagger_" + componentDefinitionClassName.classFileName());
   }
 
   @Override
-  Iterable<? extends Element> getOriginatingElements(ComponentDescriptor input) {
-    return ImmutableSet.of(input.componentDefinitionType());
+  Iterable<? extends Element> getOriginatingElements(BindingGraph input) {
+    return ImmutableSet.of(input.componentDescriptor().componentDefinitionType());
   }
 
   @Override
-  Optional<? extends Element> getElementForErrorReporting(ComponentDescriptor input) {
-    return Optional.of(input.componentDefinitionType());
+  Optional<? extends Element> getElementForErrorReporting(BindingGraph input) {
+    return Optional.of(input.componentDescriptor().componentDefinitionType());
   }
 
   @Override
-  ImmutableSet<JavaWriter> write(ClassName componentName, ComponentDescriptor input) {
+  ImmutableSet<JavaWriter> write(ClassName componentName, BindingGraph input) {
     ClassName componentDefinitionTypeName =
-        ClassName.fromTypeElement(input.componentDefinitionType());
+        ClassName.fromTypeElement(input.componentDescriptor().componentDefinitionType());
 
     JavaWriter writer = JavaWriter.inPackage(componentName.packageName());
     ClassWriter componentWriter = writer.addClass(componentName.simpleName());
@@ -145,20 +147,14 @@ ClassName nameGeneratedType(ComponentDescriptor input) {
     builderFactoryMethod.addModifiers(PUBLIC, STATIC);
     builderFactoryMethod.body().addSnippet("return new %s();", builderWriter.name());
 
-    ImmutableSetMultimap<Key, ProvisionBinding> resolvedProvisionBindings =
-        input.resolvedProvisionBindings();
-    ImmutableMap<Key, MembersInjectionBinding> resolvedMembersInjectionBindings =
-        input.resolvedMembersInjectionBindings();
-
-    ImmutableMap<Key, String> providerNames =
-        generateProviderNamesForBindings(resolvedProvisionBindings);
-    ImmutableMap<Key, String> membersInjectorNames =
-        generateMembersInjectorNamesForBindings(resolvedMembersInjectionBindings);
+    ImmutableMap<Key, String> framekworkTypeNames = generateFrameworkTypeNames(input);
 
     // the full set of types that calling code uses to construct a component instance
     ImmutableMap<TypeElement, String> componentContributionNames =
         ImmutableMap.copyOf(Maps.asMap(
-            Sets.union(input.moduleDependencies(), input.dependencies()),
+            Sets.union(
+                input.transitiveModules().keySet(),
+                input.componentDescriptor().dependencies()),
             Functions.compose(
                 CaseFormat.UPPER_CAMEL.converterTo(LOWER_CAMEL),
                 new Function<TypeElement, String>() {
@@ -167,8 +163,6 @@ ClassName nameGeneratedType(ComponentDescriptor input) {
                   }
                 })));
 
-    ImmutableSet.Builder<JavaWriter> packageProxies = ImmutableSet.builder();
-
     ConstructorWriter constructorWriter = componentWriter.addConstructor();
     constructorWriter.addModifiers(PRIVATE);
     constructorWriter.addParameter(builderWriter, "builder");
@@ -221,15 +215,50 @@ ClassName nameGeneratedType(ComponentDescriptor input) {
     ImmutableMap.Builder<Key, Snippet> memberSelectSnippetsBuilder =
         ImmutableMap.builder();
 
-    for (Entry<String, Set<Key>> packageEntry :
-        Multimaps.asMap(input.initializationByPackage()).entrySet()) {
-      String packageName = packageEntry.getKey();
+    ImmutableSet.Builder<JavaWriter> proxyWriters = ImmutableSet.builder();
+    Map<String, ClassWriter> packageProxies = Maps.newHashMap();
+
+    for (Entry<Key, ResolvedBindings> resolvedBindingsEntry : input.resolvedBindings().entrySet()) {
+      Key key = resolvedBindingsEntry.getKey();
+
+      ImmutableSet<? extends Binding> bindings = resolvedBindingsEntry.getValue().bindings();
+      if (bindings.size() == 1) {
+        Binding onlyBinding = bindings.iterator().next();
+        if (onlyBinding instanceof ProvisionBinding) {
+          ProvisionBinding provisionBinding = ((ProvisionBinding) onlyBinding);
+          if (provisionBinding.factoryCreationStrategy().equals(ENUM_INSTANCE)
+              && !provisionBinding.scope().isPresent()) {
+            // skip keys whose factories are enum instances and aren't scoped
+            memberSelectSnippetsBuilder.put(key, Snippet.format("%s.INSTANCE",
+                factoryNameForProvisionBinding(provisionBinding)));
+            continue;
+          }
+        }
+      }
+
+      ImmutableSet.Builder<String> bindingPackagesBuilder = ImmutableSet.builder();
+      for (Binding binding : bindings) {
+        bindingPackagesBuilder.addAll(binding.bindingPackage().asSet());
+      }
+      ImmutableSet<String> bindingPackages = bindingPackagesBuilder.build();
+
+      final String bindingPackage;
+      switch (bindingPackages.size()) {
+        case 0:
+          bindingPackage = componentName.packageName();
+          break;
+        case 1:
+          bindingPackage = bindingPackages.iterator().next();
+          break;
+        default:
+          throw new IllegalStateException();
+      }
 
       final Optional<String> proxySelector;
-      final ClassWriter classWithFields;
+      final TypeWriter classWithFields;
       final Set<Modifier> fieldModifiers;
 
-      if (packageName.equals(componentName.packageName())) {
+      if (bindingPackage.equals(componentName.packageName())) {
         // no proxy
         proxySelector = Optional.absent();
         // component gets the fields
@@ -237,15 +266,18 @@ ClassName nameGeneratedType(ComponentDescriptor input) {
         // private fields
         fieldModifiers = EnumSet.of(PRIVATE);
       } else {
-        // create the proxy
-        JavaWriter proxyWriter = JavaWriter.inPackage(packageName);
-        packageProxies.add(proxyWriter);
-        ClassWriter proxyClassWriter =
-            proxyWriter.addClass(componentName.simpleName() + "__PackageProxy");
+        // get or create the proxy
+        ClassWriter proxyClassWriter = packageProxies.get(bindingPackage);
+        if (proxyClassWriter == null) {
+          JavaWriter proxyWriter = JavaWriter.inPackage(bindingPackage);
+          proxyWriters.add(proxyWriter);
+          proxyClassWriter = proxyWriter.addClass(componentName.simpleName() + "__PackageProxy");
+          packageProxies.put(bindingPackage, proxyClassWriter);
+        }
         proxyClassWriter.addModifiers(PUBLIC, FINAL);
         // create the field for the proxy in the component
         FieldWriter proxyField =
-            componentWriter.addField(proxyClassWriter.name(), packageName.replace('.', '_')
+            componentWriter.addField(proxyClassWriter.name(), bindingPackage.replace('.', '_')
                 + "_Proxy");
         proxyField.addModifiers(PRIVATE, FINAL);
         proxyField.setInitializer("new %s()", proxyClassWriter.name());
@@ -257,33 +289,21 @@ ClassName nameGeneratedType(ComponentDescriptor input) {
         fieldModifiers = EnumSet.of(PUBLIC);
       }
 
-      for (Key key : packageEntry.getValue()) {
-        TypeName frameworkTypeName = ParameterizedTypeName.create(
-            ClassName.fromClass(key.kind().frameworkClass()),
-            TypeNames.forTypeMirror(key.type()));
+      TypeName frameworkTypeName = ParameterizedTypeName.create(
+          ClassName.fromClass(key.kind().frameworkClass()),
+          TypeNames.forTypeMirror(key.type()));
 
-        final String fieldName;
-        switch (key.kind()) {
-          case PROVIDER:
-            fieldName = providerNames.get(key);
-            break;
-          case MEMBERS_INJECTOR:
-            fieldName = membersInjectorNames.get(key);
-            break;
-          default:
-            throw new AssertionError();
-        }
+      String fieldName = framekworkTypeNames.get(key);
 
-        FieldWriter frameworkField = classWithFields.addField(frameworkTypeName, fieldName);
-        frameworkField.addModifiers(fieldModifiers);
+      FieldWriter frameworkField = classWithFields.addField(frameworkTypeName, fieldName);
+      frameworkField.addModifiers(fieldModifiers);
 
-        ImmutableList<String> memberSelectTokens = new ImmutableList.Builder<String>()
-            .addAll(proxySelector.asSet())
-            .add(frameworkField.name())
-            .build();
-        memberSelectSnippetsBuilder.put(key,
-            Snippet.memberSelectSnippet(memberSelectTokens));
-      }
+      ImmutableList<String> memberSelectTokens = new ImmutableList.Builder<String>()
+          .addAll(proxySelector.asSet())
+          .add(frameworkField.name())
+          .build();
+      memberSelectSnippetsBuilder.put(key,
+          Snippet.memberSelectSnippet(memberSelectTokens));
     }
 
     buildMethod.body().addSnippet("return new %s(this);", componentWriter.name());
@@ -297,10 +317,11 @@ ClassName nameGeneratedType(ComponentDescriptor input) {
 
     ImmutableMap<Key, Snippet> memberSelectSnippets = memberSelectSnippetsBuilder.build();
 
-    List<List<Key>> partitions = Lists.partition(input.initializationOrdering(), 100);
+    List<List<Key>> partitions = Lists.partition(input.resolvedBindings().keySet().asList(), 100);
     for (int i = 0; i < partitions.size(); i++) {
       MethodWriter initializeMethod =
           componentWriter.addMethod(VoidName.VOID, "initialize" + ((i == 0) ? "" : i));
+      initializeMethod.body();
       initializeMethod.addModifiers(PRIVATE);
       constructorWriter.body().addSnippet("%s();", initializeMethod.name());
 
@@ -308,14 +329,17 @@ ClassName nameGeneratedType(ComponentDescriptor input) {
         Snippet memberSelectSnippet = memberSelectSnippets.get(key);
         switch (key.kind()) {
           case PROVIDER:
-            Set<ProvisionBinding> bindings = resolvedProvisionBindings.get(key);
+            @SuppressWarnings("unchecked")
+            Set<ProvisionBinding> bindings =
+                (Set<ProvisionBinding>) input.resolvedBindings().get(key).bindings();
             BindingType bindingsType = ProvisionBinding.bindingTypeFor(bindings);
             switch (bindingsType) {
               case SET:
                 ImmutableList.Builder<Snippet> setFactoryParameters = ImmutableList.builder();
                 for (ProvisionBinding binding : bindings) {
                   setFactoryParameters.add(initializeFactoryForBinding(binding,
-                      input.dependencyMethodIndex(), componentContributionFields,
+                      input.componentDescriptor().dependencyMethodIndex(),
+                      componentContributionFields,
                       memberSelectSnippets));
                 }
                 Snippet initializeSetSnippet = Snippet.format("%s.create(%s)",
@@ -328,24 +352,30 @@ ClassName nameGeneratedType(ComponentDescriptor input) {
                 if (!bindings.isEmpty()) {
                   Snippet initializeMapSnippet =
                       initializeMapBinding(componentContributionFields,
-                          input.dependencyMethodIndex(), memberSelectSnippets, bindings);
+                          input.componentDescriptor().dependencyMethodIndex(),
+                          memberSelectSnippets, bindings);
                   initializeMethod.body().addSnippet("this.%s = %s;",
                       memberSelectSnippet, initializeMapSnippet);
                 }
                 break;
               case UNIQUE:
                 ProvisionBinding binding = Iterables.getOnlyElement(bindings);
-                initializeMethod.body().addSnippet("this.%s = %s;",
-                    memberSelectSnippet,
-                    initializeFactoryForBinding(binding, input.dependencyMethodIndex(),
-                        componentContributionFields, memberSelectSnippets));
+                if (!binding.factoryCreationStrategy().equals(ENUM_INSTANCE)
+                    || binding.scope().isPresent()) {
+                  initializeMethod.body().addSnippet("this.%s = %s;",
+                      memberSelectSnippet,
+                      initializeFactoryForBinding(binding,
+                          input.componentDescriptor().dependencyMethodIndex(),
+                          componentContributionFields, memberSelectSnippets));
+                }
                 break;
               default:
                 throw new IllegalStateException();
             }
             break;
           case MEMBERS_INJECTOR:
-            MembersInjectionBinding binding = resolvedMembersInjectionBindings.get(key);
+            MembersInjectionBinding binding = (MembersInjectionBinding) Iterables.getOnlyElement(
+                input.resolvedBindings().get(key).bindings());
             initializeMethod.body().addSnippet("this.%s = %s;",
                 memberSelectSnippet,
                 initializeMembersInjectorForBinding(binding, memberSelectSnippets));
@@ -356,39 +386,102 @@ ClassName nameGeneratedType(ComponentDescriptor input) {
       }
     }
 
-    for (DependencyRequest interfaceRequest : input.interfaceRequests()) {
-      ExecutableElement requestElement = (ExecutableElement) interfaceRequest.requestElement();
-      MethodWriter interfaceMethod = requestElement.getReturnType().getKind().equals(VOID)
-          ? componentWriter.addMethod(VoidName.VOID, requestElement.getSimpleName().toString())
-              : componentWriter.addMethod(requestElement.getReturnType(),
-                  requestElement.getSimpleName().toString());
-      interfaceMethod.annotate(Override.class);
-      interfaceMethod.addModifiers(PUBLIC);
-      Key key = interfaceRequest.key();
-      if (interfaceRequest.kind().equals(MEMBERS_INJECTOR)) {
-        Snippet membersInjectorName = memberSelectSnippets.get(key);
-        VariableElement parameter = Iterables.getOnlyElement(requestElement.getParameters());
-        Name parameterName = parameter.getSimpleName();
-        interfaceMethod.addParameter(
-            TypeNames.forTypeMirror(parameter.asType()), parameterName.toString());
-        interfaceMethod.body()
-        .addSnippet("%s.injectMembers(%s);", membersInjectorName, parameterName);
-        if (!requestElement.getReturnType().getKind().equals(VOID)) {
-          interfaceMethod.body().addSnippet("return %s;", parameterName);
-        }
-      } else {
-        interfaceMethod.body().addSnippet("return %s;",
-            frameworkTypeUsageStatement(memberSelectSnippets.get(key),
-                interfaceRequest.kind()));
+    Set<MethodSignature> interfaceMethods = Sets.newHashSet();
+
+    for (DependencyRequest interfaceRequest : input.entryPoints()) {
+      ExecutableElement requestElement =
+          MoreElements.asExecutable(interfaceRequest.requestElement());
+      MethodSignature signature = MethodSignature.fromExecutableElement(requestElement);
+      if (!interfaceMethods.contains(signature)) {
+        interfaceMethods.add(signature);
+        MethodWriter interfaceMethod = requestElement.getReturnType().getKind().equals(VOID)
+            ? componentWriter.addMethod(VoidName.VOID, requestElement.getSimpleName().toString())
+                : componentWriter.addMethod(requestElement.getReturnType(),
+                    requestElement.getSimpleName().toString());
+            interfaceMethod.annotate(Override.class);
+            interfaceMethod.addModifiers(PUBLIC);
+            Key key = interfaceRequest.key();
+            if (interfaceRequest.kind().equals(MEMBERS_INJECTOR)) {
+              Snippet membersInjectorName = memberSelectSnippets.get(key);
+              VariableElement parameter = Iterables.getOnlyElement(requestElement.getParameters());
+              Name parameterName = parameter.getSimpleName();
+              interfaceMethod.addParameter(
+                  TypeNames.forTypeMirror(parameter.asType()), parameterName.toString());
+              interfaceMethod.body()
+              .addSnippet("%s.injectMembers(%s);", membersInjectorName, parameterName);
+              if (!requestElement.getReturnType().getKind().equals(VOID)) {
+                interfaceMethod.body().addSnippet("return %s;", parameterName);
+              }
+            } else {
+              interfaceMethod.body().addSnippet("return %s;",
+                  frameworkTypeUsageStatement(memberSelectSnippets.get(key),
+                      interfaceRequest.kind()));
+            }
       }
     }
 
     return new ImmutableSet.Builder<JavaWriter>()
-        .addAll(packageProxies.build())
+        .addAll(proxyWriters.build())
         .add(writer)
         .build();
   }
 
+  private ImmutableMap<Key, String> generateFrameworkTypeNames(BindingGraph graph) {
+    ImmutableMap.Builder<Key, String> names = ImmutableMap.builder();
+    for (Entry<Key, ResolvedBindings> entry : graph.resolvedBindings().entrySet()) {
+      Key key = entry.getKey();
+      switch (key.kind()) {
+        case PROVIDER:
+          @SuppressWarnings("unchecked")
+          ImmutableSet<ProvisionBinding> bindingsForKey =
+              (ImmutableSet<ProvisionBinding>) entry.getValue().bindings();
+          BindingType bindingsType = ProvisionBinding.bindingTypeFor(bindingsForKey);
+          switch (bindingsType) {
+            case SET:
+              names.put(key,
+                  new KeyVariableNamer().apply(key) + "Provider");
+              break;
+            case MAP:
+              names.put(key,
+                  new KeyVariableNamer().apply(key) + "Provider");
+              break;
+            case UNIQUE:
+              ProvisionBinding binding = Iterables.getOnlyElement(bindingsForKey);
+              names.put(key,
+                  binding.bindingElement().accept(new ElementKindVisitor6<String, Void>() {
+                    @Override
+                    public String visitExecutableAsConstructor(ExecutableElement e, Void p) {
+                      return e.getEnclosingElement().accept(this, null);
+                    }
+
+                    @Override
+                    public String visitExecutableAsMethod(ExecutableElement e, Void p) {
+                      return e.getSimpleName().toString();
+                    }
+
+                    @Override
+                    public String visitType(TypeElement e, Void p) {
+                      return CaseFormat.UPPER_CAMEL.to(CaseFormat.LOWER_CAMEL,
+                          e.getSimpleName().toString());
+                    }
+                  }, null) + "Provider");
+              break;
+            default:
+              throw new AssertionError();
+          }
+          break;
+        case MEMBERS_INJECTOR:
+          names.put(key, CaseFormat.UPPER_CAMEL.to(CaseFormat.LOWER_CAMEL,
+              Iterables.getOnlyElement(entry.getValue().bindings())
+                  .bindingElement().getSimpleName().toString()) + "MembersInjector");
+          break;
+        default:
+          throw new AssertionError();
+      }
+    }
+    return names.build();
+  }
+
   private Snippet initializeFactoryForBinding(ProvisionBinding binding,
       ImmutableMap<ExecutableElement, TypeElement> dependencyMethodIndex,
       Map<TypeElement, FieldWriter> contributionFields,
@@ -409,28 +502,31 @@ private Snippet initializeFactoryForBinding(ProvisionBinding binding,
           contributionFields.get(dependencyMethodIndex.get(binding.bindingElement())).name(),
           binding.bindingElement().getSimpleName().toString());
     } else {
+      if (binding.bindingKind().equals(INJECTION) && binding.implicitDependencies().isEmpty()) {
+        return binding.scope().isPresent()
+            ? Snippet.format("%s.create(%s.INSTANCE)",
+                ClassName.fromClass(ScopedProvider.class),
+                factoryNameForProvisionBinding(binding))
+            : Snippet.format("%s.INSTANCE",
+                factoryNameForProvisionBinding(binding));
+      }
       List<Snippet> parameters = Lists.newArrayListWithCapacity(binding.dependencies().size() + 1);
       if (binding.bindingKind().equals(PROVISION)) {
         parameters.add(Snippet.format(contributionFields.get(binding.bindingTypeElement()).name()));
       }
       if (binding.memberInjectionRequest().isPresent()) {
-        Snippet snippet = memberSelectSnippets.get(
-            binding.memberInjectionRequest().get().key());
-        if (snippet != null) {
-          parameters.add(snippet);
-        } else {
-          throw new UnsupportedOperationException("Non-generated MembersInjector");
-        }
+        parameters.add(memberSelectSnippets.get(binding.memberInjectionRequest().get().key()));
       }
       parameters.addAll(getDependencyParameters(binding.dependencies(), memberSelectSnippets));
+
       return binding.scope().isPresent()
           ? Snippet.format("%s.create(new %s(%s))",
               ClassName.fromClass(ScopedProvider.class),
               factoryNameForProvisionBinding(binding),
-              Joiner.on(", ").join(parameters))
+              Snippet.makeParametersSnippet(parameters))
           : Snippet.format("new %s(%s)",
               factoryNameForProvisionBinding(binding),
-              Joiner.on(", ").join(parameters));
+              Snippet.makeParametersSnippet(parameters));
     }
   }
 
@@ -454,7 +550,7 @@ private static Snippet initializeMembersInjectorForBinding(
           memberSelectSnippets);
       return Snippet.format("new %s(%s)",
           membersInjectorNameForMembersInjectionBinding(binding),
-          Joiner.on(", ").join(parameters));
+          Snippet.makeParametersSnippet(parameters));
     }
   }
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java
index a0a956a4d..067194867 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java
@@ -34,21 +34,24 @@
 final class ComponentProcessingStep implements ProcessingStep {
   private final Messager messager;
   private final ComponentValidator componentValidator;
+  private final BindingGraphValidator bindingGraphValidator;
   private final ComponentDescriptor.Factory componentDescriptorFactory;
+  private final BindingGraph.Factory bindingGraphFactory;
   private final ComponentGenerator componentGenerator;
-  private final GraphValidator graphValidator;
 
   ComponentProcessingStep(
       Messager messager,
       ComponentValidator componentValidator,
-      GraphValidator graphValidator,
+      BindingGraphValidator bindingGraphValidator,
       Factory componentDescriptorFactory,
+      BindingGraph.Factory bindingGraphFactory,
       ComponentGenerator componentGenerator) {
     this.messager = messager;
     this.componentValidator = componentValidator;
+    this.bindingGraphValidator = bindingGraphValidator;
     this.componentDescriptorFactory = componentDescriptorFactory;
+    this.bindingGraphFactory = bindingGraphFactory;
     this.componentGenerator = componentGenerator;
-    this.graphValidator = graphValidator;
   }
 
   @Override
@@ -61,14 +64,19 @@ public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment
         ValidationReport<TypeElement> componentReport =
             componentValidator.validate(componentTypeElement);
         componentReport.printMessagesTo(messager);
-        ValidationReport<TypeElement> graphReport =
-            graphValidator.validate(componentTypeElement);
-        graphReport.printMessagesTo(messager);
-        if (componentReport.isClean() && graphReport.isClean()) {
-          try {
-            componentGenerator.generate(componentDescriptorFactory.create(componentTypeElement));
-          } catch (SourceFileGenerationException e) {
-            e.printMessageTo(messager);
+        if (componentReport.isClean()) {
+          ComponentDescriptor componentDescriptor =
+              componentDescriptorFactory.create(componentTypeElement);
+          BindingGraph bindingGraph = bindingGraphFactory.create(componentDescriptor);
+          ValidationReport<BindingGraph> graphReport =
+              bindingGraphValidator.validate(bindingGraph);
+          graphReport.printMessagesTo(messager);
+          if (graphReport.isClean()) {
+            try {
+              componentGenerator.generate(bindingGraph);
+            } catch (SourceFileGenerationException e) {
+              e.printMessageTo(messager);
+            }
           }
         }
       }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
index 644d79173..fb287dc75 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -15,6 +15,7 @@
  */
 package dagger.internal.codegen;
 
+import com.google.auto.service.AutoService;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import dagger.Component;
@@ -26,6 +27,7 @@
 import javax.annotation.processing.Filer;
 import javax.annotation.processing.Messager;
 import javax.annotation.processing.ProcessingEnvironment;
+import javax.annotation.processing.Processor;
 import javax.annotation.processing.RoundEnvironment;
 import javax.inject.Inject;
 import javax.lang.model.SourceVersion;
@@ -42,6 +44,7 @@
  * @author Gregory Kick
  * @since 2.0
  */
+@AutoService(Processor.class)
 public final class ComponentProcessor extends AbstractProcessor {
   private ImmutableList<ProcessingStep> processingSteps;
   private InjectBindingRegistry injectBindingRegistry;
@@ -98,12 +101,16 @@ public synchronized void init(ProcessingEnvironment processingEnv) {
         membersInjectionBindingFactory, membersInjectorGenerator);
 
     ComponentDescriptor.Factory componentDescriptorFactory =
-        new ComponentDescriptor.Factory(elements, types, injectBindingRegistry,
-            dependencyRequestFactory, keyFactory, provisionBindingFactory);
+        new ComponentDescriptor.Factory(elements, types, provisionBindingFactory);
+
+    BindingGraph.Factory bindingGraphFactory = new BindingGraph.Factory(
+        elements, types, injectBindingRegistry, keyFactory, dependencyRequestFactory,
+        provisionBindingFactory);
+
     MapKeyGenerator mapKeyGenerator = new MapKeyGenerator(filer);
 
-    GraphValidator graphValidator = new GraphValidator(elements, types, injectBindingRegistry,
-        dependencyRequestFactory, keyFactory, provisionBindingFactory);
+    BindingGraphValidator bindingGraphValidator = new BindingGraphValidator(types,
+        injectBindingRegistry);
 
     this.processingSteps = ImmutableList.<ProcessingStep>of(
         new MapKeyProcessingStep(
@@ -127,8 +134,9 @@ public synchronized void init(ProcessingEnvironment processingEnv) {
         new ComponentProcessingStep(
             messager,
             componentValidator,
-            graphValidator,
+            bindingGraphValidator,
             componentDescriptorFactory,
+            bindingGraphFactory,
             componentGenerator));
   }
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java b/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
index ae0cafeb8..75e401252 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
@@ -18,14 +18,15 @@
 import com.google.auto.common.MoreTypes;
 import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Maps;
 import com.google.common.collect.Queues;
-import com.google.common.collect.Sets;
 import dagger.Component;
 import dagger.MapKey;
 import dagger.Module;
+import java.util.Map;
 import java.util.Queue;
-import java.util.Set;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.TypeElement;
@@ -88,26 +89,26 @@
    * given seed modules.  If a module is malformed and a type listed in {@link Module#includes}
    * is not annotated with {@link Module}, it is ignored.
    */
-  static ImmutableSet<TypeElement> getTransitiveModules(Elements elements, Types types,
-      ImmutableSet<TypeElement> seedModules) {
+  static ImmutableMap<TypeElement, ImmutableSet<TypeElement>> getTransitiveModules(
+      Elements elements, Types types, ImmutableSet<TypeElement> seedModules) {
     Queue<TypeElement> moduleQueue = Queues.newArrayDeque(seedModules);
-    Set<TypeElement> moduleElements = Sets.newLinkedHashSet();
+    Map<TypeElement, ImmutableSet<TypeElement>> moduleElements = Maps.newLinkedHashMap();
     for (TypeElement moduleElement = moduleQueue.poll();
         moduleElement != null;
         moduleElement = moduleQueue.poll()) {
-      moduleElements.add(moduleElement);
       Optional<AnnotationMirror> moduleMirror = getAnnotationMirror(moduleElement, Module.class);
       if (moduleMirror.isPresent()) {
         ImmutableSet<TypeElement> moduleDependencies = MoreTypes.asTypeElements(types,
             ConfigurationAnnotations.getModuleIncludes(elements, moduleMirror.get()));
+        moduleElements.put(moduleElement, moduleDependencies);
         for (TypeElement dependencyType : moduleDependencies) {
-          if (!moduleElements.contains(dependencyType)) {
+          if (!moduleElements.containsKey(dependencyType)) {
             moduleQueue.add(dependencyType);
           }
         }
       }
     }
-    return ImmutableSet.copyOf(moduleElements);
+    return ImmutableMap.copyOf(moduleElements);
   }
 
   private ConfigurationAnnotations() {}
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyRequestFormatter.java b/compiler/src/main/java/dagger/internal/codegen/DependencyRequestFormatter.java
index 170ee831e..fa36084ee 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DependencyRequestFormatter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyRequestFormatter.java
@@ -46,7 +46,7 @@ static DependencyRequestFormatter instance() {
 
   // TODO(user): Sweep this class for TypeMirror.toString() usage and do some preventive format.
   // TODO(user): consider returning a small structure containing strings to be indented later.
-  @Override public String format(DependencyRequest request) {
+  @Override public String format(final DependencyRequest request) {
     Element requestElement = request.requestElement();
     Optional<AnnotationMirror> qualifier = InjectionAnnotations.getQualifier(requestElement);
     return requestElement.accept(new SimpleElementVisitor6<String, Optional<AnnotationMirror>>(){
@@ -112,6 +112,11 @@ static DependencyRequestFormatter instance() {
         return builder.toString();
       }
 
+      @Override
+      public String visitType(TypeElement e, Optional<AnnotationMirror> p) {
+        return INDENT + e.getQualifiedName();
+      }
+
       @Override protected String defaultAction(Element element, Optional<AnnotationMirror> ignore) {
         throw new IllegalStateException(
             "Invalid request " + element.getKind() +  " element " + element);
diff --git a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
index 4a9cb8868..d52a9c849 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
@@ -15,9 +15,7 @@
  */
 package dagger.internal.codegen;
 
-import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
-import com.google.common.base.Joiner;
 import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
@@ -28,18 +26,18 @@
 import dagger.internal.codegen.writer.ClassName;
 import dagger.internal.codegen.writer.ClassWriter;
 import dagger.internal.codegen.writer.ConstructorWriter;
+import dagger.internal.codegen.writer.EnumWriter;
 import dagger.internal.codegen.writer.FieldWriter;
 import dagger.internal.codegen.writer.JavaWriter;
 import dagger.internal.codegen.writer.MethodWriter;
 import dagger.internal.codegen.writer.ParameterizedTypeName;
 import dagger.internal.codegen.writer.Snippet;
-import dagger.internal.codegen.writer.StringLiteral;
 import dagger.internal.codegen.writer.TypeName;
 import dagger.internal.codegen.writer.TypeNames;
+import dagger.internal.codegen.writer.TypeWriter;
 import java.util.Collections;
 import java.util.List;
 import java.util.Map.Entry;
-import java.util.logging.Logger;
 import javax.annotation.Generated;
 import javax.annotation.processing.Filer;
 import javax.inject.Inject;
@@ -55,7 +53,6 @@
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.PUBLIC;
-import static javax.lang.model.element.Modifier.STATIC;
 
 /**
  * Generates {@link Factory} implementations from {@link ProvisionBinding} instances for
@@ -87,49 +84,55 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
   @Override
   ImmutableSet<JavaWriter> write(ClassName generatedTypeName, ProvisionBinding binding) {
     TypeMirror keyType = binding.provisionType().equals(Type.MAP)
-
         ? Util.getProvidedValueTypeOfMap(MoreTypes.asDeclared(binding.key().type()))
         : binding.key().type();
     TypeName providedTypeName = TypeNames.forTypeMirror(keyType);
     JavaWriter writer = JavaWriter.inPackage(generatedTypeName.packageName());
 
-    ClassWriter factoryWriter = writer.addClass(generatedTypeName.simpleName());
+    final TypeWriter factoryWriter;
+    final Optional<ConstructorWriter> constructorWriter;
+    switch (binding.factoryCreationStrategy()) {
+      case ENUM_INSTANCE:
+        EnumWriter enumWriter = writer.addEnum(generatedTypeName.simpleName());
+        enumWriter.addConstant("INSTANCE");
+        constructorWriter = Optional.absent();
+        factoryWriter = enumWriter;
+        break;
+      case CLASS_CONSTRUCTOR:
+        ClassWriter classWriter = writer.addClass(generatedTypeName.simpleName());
+        classWriter.addModifiers(FINAL);
+        constructorWriter = Optional.of(classWriter.addConstructor());
+        constructorWriter.get().addModifiers(PUBLIC);
+        factoryWriter = classWriter;
+        if (binding.bindingKind().equals(PROVISION)) {
+          factoryWriter.addField(binding.bindingTypeElement(), "module")
+              .addModifiers(PRIVATE, FINAL);
+          constructorWriter.get().addParameter(binding.bindingTypeElement(), "module");
+          constructorWriter.get().body()
+              .addSnippet("assert module != null;")
+              .addSnippet("this.module = module;");
+        }
+        break;
+      default:
+        throw new AssertionError();
+    }
+
     factoryWriter.annotate(Generated.class).setValue(ComponentProcessor.class.getName());
-    factoryWriter.addModifiers(PUBLIC, FINAL);
+    factoryWriter.addModifiers(PUBLIC);
     factoryWriter.addImplementedType(ParameterizedTypeName.create(
         ClassName.fromClass(Factory.class),
         providedTypeName));
 
-    // TODO(gak): stop doing this weird thing with the optional when javawriter lets me put fields
-    // in arbitrary places
-    Optional<FieldWriter> loggerField = Optional.absent();
-    if (binding.bindingKind().equals(PROVISION)) {
-      loggerField = Optional.of(factoryWriter.addField(Logger.class, "logger"));
-      loggerField.get().addModifiers(PRIVATE, STATIC, FINAL);
-      loggerField.get().setInitializer("%s.getLogger(%s.class.getCanonicalName())",
-          ClassName.fromClass(Logger.class), factoryWriter.name());
-    }
-
     MethodWriter getMethodWriter = factoryWriter.addMethod(keyType, "get");
     getMethodWriter.annotate(Override.class);
     getMethodWriter.addModifiers(PUBLIC);
 
-    ConstructorWriter constructorWriter = factoryWriter.addConstructor();
-    constructorWriter.addModifiers(PUBLIC);
-    if (binding.bindingKind().equals(PROVISION)) {
-      factoryWriter.addField(binding.bindingTypeElement(), "module").addModifiers(PRIVATE, FINAL);
-      constructorWriter.addParameter(binding.bindingTypeElement(), "module");
-      constructorWriter.body()
-          .addSnippet("assert module != null;")
-          .addSnippet("this.module = module;");
-    }
-
     if (binding.memberInjectionRequest().isPresent()) {
       ParameterizedTypeName membersInjectorType = ParameterizedTypeName.create(
           MembersInjector.class, providedTypeName);
       factoryWriter.addField(membersInjectorType, "membersInjector").addModifiers(PRIVATE, FINAL);
-      constructorWriter.addParameter(membersInjectorType, "membersInjector");
-      constructorWriter.body()
+      constructorWriter.get().addParameter(membersInjectorType, "membersInjector");
+      constructorWriter.get().body()
           .addSnippet("assert membersInjector != null;")
           .addSnippet("this.membersInjector = membersInjector;");
     }
@@ -156,8 +159,8 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
           throw new AssertionError();
       }
       field.addModifiers(PRIVATE, FINAL);
-      constructorWriter.addParameter(field.type(), field.name());
-      constructorWriter.body()
+      constructorWriter.get().addParameter(field.type(), field.name());
+      constructorWriter.get().body()
           .addSnippet("assert %s != null;", field.name())
           .addSnippet("this.%1$s = %1$s;", field.name());
     }
@@ -171,28 +174,15 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
     Snippet parametersSnippet = makeParametersSnippet(parameters);
 
     if (binding.bindingKind().equals(PROVISION)) {
-      TypeMirror providesMethodReturnType =
-          MoreElements.asExecutable(binding.bindingElement()).getReturnType();
-      getMethodWriter.body().addSnippet("%s result = module.%s(%s);",
-          TypeNames.forTypeMirror(providesMethodReturnType),
-          binding.bindingElement().getSimpleName(), parametersSnippet);
-      if (!providesMethodReturnType.getKind().isPrimitive()) {
-        getMethodWriter.body().addSnippet(Joiner.on('\n').join(
-            "if (result == null) {",
-            "  %s.warning(%s);",
-            "}"),
-            loggerField.get().name(),
-            StringLiteral.forValue(String.format(
-                "%s.%s provided null. "
-                    + "This is not allowed and will soon throw a NullPointerException.",
-                    binding.bindingTypeElement().getQualifiedName(),
-                    binding.bindingElement())));
-      }
       if (binding.provisionType().equals(SET)) {
-        getMethodWriter.body().addSnippet("return %s.singleton(result);",
-            ClassName.fromClass(Collections.class));
+        getMethodWriter.body().addSnippet("return %s.singleton(module.%s(%s));",
+            ClassName.fromClass(Collections.class),
+            binding.bindingElement().getSimpleName(),
+            parametersSnippet);
       } else {
-        getMethodWriter.body().addSnippet("return result;");
+        getMethodWriter.body().addSnippet("return module.%s(%s);",
+            binding.bindingElement().getSimpleName(),
+            parametersSnippet);
       }
     } else if (binding.memberInjectionRequest().isPresent()) {
       getMethodWriter.body().addSnippet("%1$s instance = new %1$s(%2$s);",
diff --git a/compiler/src/main/java/dagger/internal/codegen/GraphValidator.java b/compiler/src/main/java/dagger/internal/codegen/GraphValidator.java
deleted file mode 100644
index 7d9954371..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/GraphValidator.java
+++ /dev/null
@@ -1,424 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen;
-
-import com.google.auto.common.MoreElements;
-import com.google.auto.common.MoreTypes;
-import com.google.common.base.Joiner;
-import com.google.common.base.Optional;
-import com.google.common.collect.FluentIterable;
-import com.google.common.collect.ImmutableList;
-import com.google.common.collect.ImmutableListMultimap;
-import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.ImmutableSetMultimap;
-import com.google.common.collect.Iterables;
-import com.google.common.collect.ListMultimap;
-import com.google.common.collect.Ordering;
-import com.google.common.collect.Queues;
-import dagger.Component;
-import dagger.Provides;
-import dagger.internal.codegen.ProvisionBinding.BindingType;
-import dagger.internal.codegen.ValidationReport.Builder;
-import java.util.Deque;
-import java.util.Formatter;
-import java.util.LinkedHashSet;
-import java.util.List;
-import java.util.Set;
-import javax.lang.model.element.AnnotationMirror;
-import javax.lang.model.element.ElementKind;
-import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.Modifier;
-import javax.lang.model.element.Name;
-import javax.lang.model.element.TypeElement;
-import javax.lang.model.element.VariableElement;
-import javax.lang.model.type.DeclaredType;
-import javax.lang.model.type.TypeMirror;
-import javax.lang.model.util.ElementFilter;
-import javax.lang.model.util.Elements;
-import javax.lang.model.util.SimpleTypeVisitor6;
-import javax.lang.model.util.Types;
-
-import static com.google.auto.common.MoreElements.getAnnotationMirror;
-import static com.google.auto.common.MoreElements.isAnnotationPresent;
-import static com.google.common.collect.Iterables.getOnlyElement;
-import static dagger.internal.codegen.ConfigurationAnnotations.getComponentModules;
-import static dagger.internal.codegen.ConfigurationAnnotations.getTransitiveModules;
-import static dagger.internal.codegen.ErrorMessages.INDENT;
-import static dagger.internal.codegen.ErrorMessages.REQUIRES_AT_INJECT_CONSTRUCTOR_OR_PROVIDER_FORMAT;
-import static dagger.internal.codegen.ErrorMessages.REQUIRES_PROVIDER_FORMAT;
-import static javax.lang.model.type.TypeKind.VOID;
-import static javax.lang.model.util.ElementFilter.methodsIn;
-
-/**
- * Performs validation of object graphs rooted in the provision and injection methods of
- * a {link @Component} interface.
- *
- * @author Christian Gruber
- */
-public class GraphValidator implements Validator<TypeElement> {
-  private final Elements elements;
-  private final Types types;
-  private final InjectBindingRegistry bindingRegistry;
-  private final DependencyRequest.Factory dependencyRequestFactory;
-  private final Key.Factory keyFactory;
-  private final ProvisionBinding.Factory provisionBindingFactory;
-
-  GraphValidator(
-      Elements elements,
-      Types types,
-      InjectBindingRegistry bindingRegistry,
-      DependencyRequest.Factory dependencyRequestFactory,
-      Key.Factory keyFactory,
-      ProvisionBinding.Factory provisionBindingFactory) {
-    this.elements = elements;
-    this.types = types;
-    this.bindingRegistry = bindingRegistry;
-    this.dependencyRequestFactory = dependencyRequestFactory;
-    this.keyFactory = keyFactory;
-    this.provisionBindingFactory = provisionBindingFactory;
-  }
-
-  @Override
-  public ValidationReport<TypeElement> validate(TypeElement subject) {
-    ValidationReport.Builder<TypeElement> reportBuilder = ValidationReport.Builder.about(subject);
-    validateGraph(subject, reportBuilder);
-    return reportBuilder.build();
-  }
-
-  void validateGraph(TypeElement component,
-      ValidationReport.Builder<TypeElement> reportBuilder) {
-    AnnotationMirror componentMirror =
-        getAnnotationMirror(component, Component.class).get();
-    ImmutableSet.Builder<ProvisionBinding> explicitBindingsBuilder = ImmutableSet.builder();
-    ProvisionBinding componentBinding = provisionBindingFactory.forComponent(component);
-    explicitBindingsBuilder.add(componentBinding);
-
-    // Collect Component dependencies.
-    ImmutableSet<TypeElement> componentDependencyTypes = MoreTypes.asTypeElements(types,
-        ConfigurationAnnotations.getComponentDependencies(elements, componentMirror));
-    for (TypeElement componentDependency : componentDependencyTypes) {
-      explicitBindingsBuilder.add(provisionBindingFactory.forComponent(componentDependency));
-      List<ExecutableElement> dependencyMethods =
-          ElementFilter.methodsIn(elements.getAllMembers(componentDependency));
-      for (ExecutableElement method : dependencyMethods) {
-        if (isComponentProvisionMethod(method)) {
-          // MembersInjection methods aren't "provided" explicitly, so ignore them.
-          try {
-            explicitBindingsBuilder.add(provisionBindingFactory.forComponentMethod(method));
-          } catch (IllegalArgumentException e) {
-            // Should not ever get here due to previous component validation.
-            reportBuilder.addItem("Component provision methods cannot have parameters.", method);
-          }
-        }
-      }
-    }
-
-    // Collect transitive modules provisions.
-    ImmutableSet<TypeElement> moduleTypes =
-        MoreTypes.asTypeElements(types, getComponentModules(elements, componentMirror));
-
-    for (TypeElement module : getTransitiveModules(elements, types, moduleTypes)) {
-      // traverse the modules, collect the bindings
-      List<ExecutableElement> moduleMethods = methodsIn(elements.getAllMembers(module));
-      for (ExecutableElement moduleMethod : moduleMethods) {
-        if (isAnnotationPresent(moduleMethod, Provides.class)) {
-          try {
-            explicitBindingsBuilder.add(provisionBindingFactory.forProvidesMethod(moduleMethod));
-          } catch (IllegalArgumentException e) {
-            // Should not ever get here due to previous module validation.
-            reportBuilder.addItem(
-                String.format(ErrorMessages.MALFORMED_MODULE_METHOD_FORMAT,
-                    moduleMethod.getSimpleName(),
-                    MoreElements.asType(moduleMethod.getEnclosingElement()).getQualifiedName()),
-                component);
-          }
-        }
-      }
-    }
-
-    for (DependencyRequest componentMethodRequest : componentMethodRequests(component)) {
-      Deque<Key> cycleStack = Queues.newArrayDeque();
-      Deque<DependencyRequest> dependencyPath = Queues.newArrayDeque();
-      resolveRequest(
-          componentMethodRequest,
-          componentMethodRequest,
-          reportBuilder,
-          explicitBindingsByKey(explicitBindingsBuilder.build()),
-          new LinkedHashSet<Key>(),
-          cycleStack,
-          dependencyPath);
-    }
-  }
-
-  private ImmutableSetMultimap<Key, ProvisionBinding> explicitBindingsByKey(
-      Iterable<ProvisionBinding> bindings) {
-    // Multimaps.index() doesn't do ImmutableSetMultimaps.
-    ImmutableSetMultimap.Builder<Key, ProvisionBinding> builder = ImmutableSetMultimap.builder();
-    for (ProvisionBinding binding : bindings) {
-      builder.put(binding.key(), binding);
-    }
-    return builder.build();
-  }
-
-  private ImmutableList<DependencyRequest> componentMethodRequests(TypeElement componentType) {
-    ImmutableList.Builder<DependencyRequest> interfaceRequestsBuilder = ImmutableList.builder();
-    for (ExecutableElement componentMethod : methodsIn(elements.getAllMembers(componentType))) {
-      if (componentMethod.getModifiers().contains(Modifier.ABSTRACT)) { // Elide Object.*;
-        if (isComponentProvisionMethod(componentMethod)) {
-          interfaceRequestsBuilder.add(
-              dependencyRequestFactory.forComponentProvisionMethod(componentMethod));
-        } else if (isComponentMembersInjectionMethod(componentMethod)) {
-          interfaceRequestsBuilder.add(
-              dependencyRequestFactory.forComponentMembersInjectionMethod(componentMethod));
-        }
-      }
-    }
-    return interfaceRequestsBuilder.build();
-  }
-
-  private void resolveRequest(DependencyRequest request,
-      DependencyRequest rootRequest,
-      ValidationReport.Builder<TypeElement> reportBuilder,
-      ImmutableSetMultimap<Key, ProvisionBinding> explicitBindings,
-      Set<Key> resolvedBindings,
-      Deque<Key> cycleStack,
-      Deque<DependencyRequest> dependencyPath) {
-
-    Key requestKey = request.key();
-    if (cycleStack.contains(requestKey) && !isComponent(requestKey.type())) {
-      resolvedBindings.add(requestKey); // it's present, but bad, and we report that.
-      dependencyPath = Queues.newArrayDeque(dependencyPath); // copy
-      dependencyPath.push(request); // add current request.
-      dependencyPath.pollLast(); // strip off original request from the component method.
-      ImmutableList<String> printableDependencyPath = FluentIterable.from(dependencyPath)
-          .transform(DependencyRequestFormatter.instance()).toList().reverse();
-      TypeElement componentType =
-          MoreElements.asType(rootRequest.requestElement().getEnclosingElement());
-      // TODO(user): Restructure to provide a hint for the start and end of the cycle.
-      reportBuilder.addItem(
-          String.format(ErrorMessages.CONTAINS_DEPENDENCY_CYCLE_FORMAT,
-              componentType.getQualifiedName(),
-              rootRequest.requestElement().getSimpleName(),
-              Joiner.on("\n").join(printableDependencyPath)),
-          rootRequest.requestElement());
-
-      return;
-    }
-    if (resolvedBindings.contains(requestKey)) {
-      return;
-    }
-
-    dependencyPath.push(request);
-    cycleStack.push(requestKey);
-    try {
-      switch (request.kind()) {
-        case INSTANCE:
-        case LAZY:
-        case PROVIDER:
-          // First, check for explicit keys (those from modules and components)
-          ImmutableSet<ProvisionBinding> explicitBindingsForKey = explicitBindings.get(requestKey);
-          if (explicitBindingsForKey.isEmpty()) {
-            // If the key is Map<K, V>, get its implicit binding key which is Map<K, Provider<V>>
-            Optional<Key> key = keyFactory.implicitMapProviderKeyFrom(request.key());
-            if (key.isPresent()) {
-              DependencyRequest implicitRequest =
-                  dependencyRequestFactory.forImplicitMapBinding(request, key.get());
-              Binding implicitBinding =
-                  provisionBindingFactory.forImplicitMapBinding(request, implicitRequest);
-              resolveRequest(Iterables.getOnlyElement(implicitBinding.dependencies()),
-                  rootRequest, reportBuilder, explicitBindings, resolvedBindings, cycleStack,
-                  dependencyPath);
-              resolvedBindings.add(requestKey);
-            } else {
-              // no explicit binding, look it up or fail.
-              Optional<ProvisionBinding> provisionBinding =
-                  findProvidableType(requestKey, reportBuilder, rootRequest, dependencyPath);
-              if (provisionBinding.isPresent()) {
-                // found a binding, resolve its deps and then mark it resolved
-                for (DependencyRequest dependency : provisionBinding.get().implicitDependencies()) {
-                  resolveRequest(dependency, rootRequest, reportBuilder, explicitBindings,
-                      resolvedBindings, cycleStack, dependencyPath);
-                }
-                resolvedBindings.add(requestKey);
-              }
-            }
-          } else {
-            // If this is an explicit Map<K, V> request then add in any map binding provision
-            // methods which are implied by and must collide with explicit Map<K, V> bindings.
-            Optional<Key> underlyingMapKey = keyFactory.implicitMapProviderKeyFrom(request.key());
-            if (underlyingMapKey.isPresent()) {
-              explicitBindingsForKey = ImmutableSet.<ProvisionBinding>builder()
-                  .addAll(explicitBindingsForKey)
-                  .addAll(explicitBindings.get(underlyingMapKey.get()))
-                  .build();
-            }
-            if (explicitBindingsForKey.size() > 1) {
-              // Multiple Explicit bindings. Validate that they are multi-bindings.
-              ImmutableListMultimap<BindingType, ProvisionBinding> bindingsByType =
-                  ProvisionBinding.bindingTypesFor(explicitBindingsForKey);
-              if (bindingsByType.keySet().size() > 1) {
-                reportMultipleBindingTypes(rootRequest, requestKey, bindingsByType, reportBuilder);
-              } else if (getOnlyElement(bindingsByType.keySet()).equals(BindingType.UNIQUE)) {
-                reportDuplicateBindings(rootRequest, requestKey, bindingsByType, reportBuilder);
-              }
-            }
-            for (Binding explicitBinding : explicitBindingsForKey) {
-              for (DependencyRequest dependency : explicitBinding.dependencies()) {
-                resolveRequest(dependency, rootRequest, reportBuilder, explicitBindings,
-                    resolvedBindings, cycleStack, dependencyPath);
-              }
-            }
-            resolvedBindings.add(requestKey);
-          }
-          break;
-        case MEMBERS_INJECTOR:
-          // no explicit deps for members injection, so just look it up
-          Optional<MembersInjectionBinding> membersInjectionBinding =
-              Optional.fromNullable(bindingRegistry.getOrFindMembersInjectionBinding(requestKey));
-          if (membersInjectionBinding.isPresent()) {
-            // found a binding, resolve its deps and then mark it resolved
-            for (DependencyRequest dependency : membersInjectionBinding.get().dependencies()) {
-              resolveRequest(dependency, rootRequest, reportBuilder, explicitBindings,
-                  resolvedBindings, cycleStack, dependencyPath);
-            }
-            resolvedBindings.add(requestKey);
-          }
-          break;
-        default:
-          throw new AssertionError();
-      }
-    } finally {
-      dependencyPath.pop();
-      cycleStack.pop();
-    }
-  }
-
-  @SuppressWarnings("resource") // Appendable is a StringBuilder.
-  private void reportDuplicateBindings(DependencyRequest rootRequest, Key requestKey,
-      ListMultimap<BindingType, ProvisionBinding> bindingsByType,
-      ValidationReport.Builder<TypeElement> reportBuilder) {
-    StringBuilder builder = new StringBuilder();
-    new Formatter(builder).format(ErrorMessages.DUPLICATE_BINDINGS_FOR_KEY_FORMAT,
-        KeyFormatter.instance().format(requestKey));
-    for (ProvisionBinding binding : bindingsByType.values()) {
-      builder.append('\n').append(INDENT);
-      builder.append(ProvisionBindingFormatter.instance().format(binding));
-    }
-    reportBuilder.addItem(builder.toString(), rootRequest.requestElement());
-  }
-
-  @SuppressWarnings("resource") // Appendable is a StringBuilder.
-  private void reportMultipleBindingTypes(DependencyRequest rootRequest, Key requestKey,
-      ListMultimap<BindingType, ProvisionBinding> bindingsByType,
-      ValidationReport.Builder<TypeElement> reportBuilder) {
-    StringBuilder builder = new StringBuilder();
-    new Formatter(builder).format(ErrorMessages.MULTIPLE_BINDING_TYPES_FOR_KEY_FORMAT,
-        KeyFormatter.instance().format(requestKey));
-    for (BindingType type :
-        Ordering.natural().immutableSortedCopy(bindingsByType.keySet())) {
-      builder.append(INDENT);
-      builder.append(formatBindingType(type));
-      builder.append(" bindings:\n");
-      for (ProvisionBinding binding : bindingsByType.get(type)) {
-        builder.append(INDENT).append(INDENT);
-        builder.append(ProvisionBindingFormatter.instance().format(binding));
-        builder.append('\n');
-      }
-    }
-    reportBuilder.addItem(builder.toString(), rootRequest.requestElement());
-  }
-
-  private String formatBindingType(BindingType type) {
-    switch(type) {
-      case MAP:
-        return "Map";
-      case SET:
-        return "Set";
-      case UNIQUE:
-        return "Unique";
-      default:
-        throw new IllegalStateException("Unknown binding type: " + type);
-    }
-  }
-
-  // TODO(user) determine what bits of InjectBindingRegistry's findOrCreate logic to factor out.
-  private Optional<ProvisionBinding> findProvidableType(Key key, Builder<TypeElement> reportBuilder,
-      DependencyRequest rootRequest, Deque<DependencyRequest> dependencyPath) {
-    Optional<ProvisionBinding> binding = bindingRegistry.getOrFindProvisionBinding(key);
-    if (!binding.isPresent()) {
-      TypeMirror type = key.type();
-      Name typeName = MoreElements.asType(types.asElement(type)).getQualifiedName();
-      boolean requiresProvidesMethod = type.accept(new SimpleTypeVisitor6<Boolean, Void>() {
-        @Override protected Boolean defaultAction(TypeMirror e, Void p) {
-          return true;
-        }
-
-        @Override public Boolean visitDeclared(DeclaredType type, Void ignored) {
-          // Note - this logic is also in InjectConstructorValidator but is woven into errors.
-          TypeElement typeElement = MoreElements.asType(type.asElement());
-          if (typeElement.getTypeParameters().isEmpty()
-              && typeElement.getKind().equals(ElementKind.CLASS)
-              && !typeElement.getModifiers().contains(Modifier.ABSTRACT)) {
-            return false;
-          }
-          return true;
-        }
-      }, null);
-      StringBuilder errorMessage = new StringBuilder();
-      if(requiresProvidesMethod) {
-        errorMessage.append(String.format(REQUIRES_PROVIDER_FORMAT, typeName));
-      } else {
-        errorMessage.append(
-            String.format(REQUIRES_AT_INJECT_CONSTRUCTOR_OR_PROVIDER_FORMAT, typeName));
-      }
-      if (key.isValidMembersInjectionKey()
-          && !bindingRegistry.getOrFindMembersInjectionBinding(key).injectionSites().isEmpty()) {
-        errorMessage.append(" ").append(ErrorMessages.MEMBERS_INJECTION_DOES_NOT_IMPLY_PROVISION);
-      }
-      dependencyPath = Queues.newArrayDeque(dependencyPath); // copy
-      dependencyPath.pollLast();
-      ImmutableList<String> printableDependencyPath = FluentIterable.from(dependencyPath)
-          .transform(DependencyRequestFormatter.instance()).toList().reverse();
-      for(String dependency : printableDependencyPath) {
-        errorMessage.append("\n").append(dependency);
-      }
-      reportBuilder.addItem(errorMessage.toString(), rootRequest.requestElement());
-    }
-    return binding;
-  }
-
-  private boolean isComponent(TypeMirror type) {
-    // No need to fully validate. Components themselves will be validated by the ComponentValidator
-    return MoreElements.isAnnotationPresent(types.asElement(type), Component.class);
-  }
-
-  private boolean isComponentProvisionMethod(ExecutableElement method) {
-    return method.getParameters().isEmpty()
-        && !method.getReturnType().getKind().equals(VOID)
-        && !elements.getTypeElement(Object.class.getCanonicalName())
-            .equals(method.getEnclosingElement());
-  }
-
-  private boolean isComponentMembersInjectionMethod(ExecutableElement method) {
-    List<? extends VariableElement> parameters = method.getParameters();
-    TypeMirror returnType = method.getReturnType();
-    return parameters.size() == 1
-        && (returnType.getKind().equals(VOID)
-            || MoreTypes.equivalence().equivalent(returnType, parameters.get(0).asType()))
-        && !elements.getTypeElement(Object.class.getCanonicalName())
-            .equals(method.getEnclosingElement());
-  }
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/MapKeyGenerator.java b/compiler/src/main/java/dagger/internal/codegen/MapKeyGenerator.java
index 2fa5ff219..0715ca724 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MapKeyGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MapKeyGenerator.java
@@ -15,13 +15,14 @@
  */
 package dagger.internal.codegen;
 
+import dagger.internal.codegen.writer.TypeWriter;
+
 import com.google.auto.value.AutoAnnotation;
 import com.google.common.base.Joiner;
 import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableSet;
 import dagger.MapKey;
 import dagger.internal.codegen.writer.ClassName;
-import dagger.internal.codegen.writer.ClassWriter;
 import dagger.internal.codegen.writer.JavaWriter;
 import dagger.internal.codegen.writer.MethodWriter;
 import java.util.ArrayList;
@@ -33,7 +34,6 @@
 import javax.lang.model.element.Name;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.DeclaredType;
-
 import static javax.lang.model.element.Modifier.PUBLIC;
 import static javax.lang.model.element.Modifier.STATIC;
 
@@ -68,7 +68,7 @@ ClassName nameGeneratedType(Element e) {
   @Override
   ImmutableSet<JavaWriter> write(ClassName generatedTypeName, Element e) {
     JavaWriter writer = JavaWriter.inPackage(generatedTypeName.packageName());
-    ClassWriter mapKeyWriter = writer.addClass(generatedTypeName.simpleName());
+    TypeWriter mapKeyWriter = writer.addClass(generatedTypeName.simpleName());
     mapKeyWriter.annotate(Generated.class).setValue(ComponentProcessor.class.getName());
     mapKeyWriter.addModifiers(PUBLIC);
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
index 6eaa59687..d7c112a3c 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
@@ -47,6 +47,7 @@
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static dagger.internal.codegen.InjectionAnnotations.getScopeAnnotation;
+import static dagger.internal.codegen.ProvisionBinding.Kind.INJECTION;
 import static javax.lang.model.element.ElementKind.CONSTRUCTOR;
 import static javax.lang.model.element.ElementKind.FIELD;
 import static javax.lang.model.element.ElementKind.METHOD;
@@ -155,6 +156,17 @@ static BindingType bindingTypeFor(Iterable<ProvisionBinding> bindings) {
     }
   }
 
+  enum FactoryCreationStrategy {
+    ENUM_INSTANCE,
+    CLASS_CONSTRUCTOR,
+  }
+
+  FactoryCreationStrategy factoryCreationStrategy() {
+    return (bindingKind().equals(INJECTION) && implicitDependencies().isEmpty())
+        ? FactoryCreationStrategy.ENUM_INSTANCE
+        : FactoryCreationStrategy.CLASS_CONSTRUCTOR;
+  }
+
   static final class Factory {
     private final Elements elements;
     private final Types types;
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
index 21d4a3e06..6a0a04a86 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
@@ -1,40 +1,28 @@
 /*
  * Copyright (C) 2014 Google, Inc.
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
+ * in compliance with the License. You may obtain a copy of the License at
  *
  * http://www.apache.org/licenses/LICENSE-2.0
  *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
  */
 package dagger.internal.codegen;
 
-import com.google.auto.common.MoreTypes;
 import com.google.common.base.CaseFormat;
-import com.google.common.base.Function;
 import com.google.common.collect.ComparisonChain;
 import com.google.common.collect.FluentIterable;
-import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ImmutableSetMultimap;
-import com.google.common.collect.ImmutableSortedSet;
 import com.google.common.collect.Iterables;
-import com.google.common.collect.Maps;
 import com.google.common.collect.Ordering;
-import com.google.common.collect.SetMultimap;
-import dagger.Lazy;
-import dagger.MembersInjector;
 import dagger.internal.DoubleCheckLazy;
-import dagger.internal.codegen.ProvisionBinding.BindingType;
 import dagger.internal.codegen.writer.ClassName;
-import dagger.internal.codegen.writer.JavaWriter;
 import dagger.internal.codegen.writer.Snippet;
 import java.util.Collection;
 import java.util.Iterator;
@@ -43,7 +31,6 @@
 import javax.inject.Provider;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
-import javax.lang.model.util.ElementKindVisitor6;
 
 import static com.google.common.base.CaseFormat.UPPER_CAMEL;
 
@@ -54,77 +41,23 @@
  * @since 2.0
  */
 class SourceFiles {
-  /**
-   * Given a mapping from variable name to type, returns a list of tokens suitable for methods such
-   * as {@link JavaWriter#beginMethod(String, String, java.util.Set, String...)}.
-   */
-  // TODO(gak): push this change upstream to obviate the need for this utility
-  static ImmutableList<String> flattenVariableMap(Map<String, String> variableMap) {
-    ImmutableList.Builder<String> tokenList = ImmutableList.builder();
-    for (Entry<String, String> variableEntry : variableMap.entrySet()) {
-      tokenList.add(variableEntry.getValue(), variableEntry.getKey());
-    }
-    return tokenList.build();
-  }
-
-  /**
-   * Returns the sorted set of all classes required by the {@link MembersInjector} implementation
-   * being generated.
-   */
-  static ImmutableSortedSet<ClassName> collectImportsFromDependencies(ClassName topLevelClassName,
-      Iterable<? extends DependencyRequest> dependencies) {
-    ImmutableSortedSet.Builder<ClassName> builder = ImmutableSortedSet.<ClassName>naturalOrder();
-    ImmutableSet<String> packagesToSkip  =
-        ImmutableSet.of("java.lang", topLevelClassName.packageName());
-    for (DependencyRequest dependency : dependencies) {
-      ImmutableSet<TypeElement> referencedTypes =
-          MoreTypes.referencedTypes(dependency.key().type());
-      switch (dependency.kind()) {
-        case LAZY:
-          builder.add(ClassName.fromClass(Lazy.class), ClassName.fromClass(DoubleCheckLazy.class));
-          // fall through
-        case INSTANCE:
-        case PROVIDER:
-          builder.add(ClassName.fromClass(Provider.class));
-          break;
-        case MEMBERS_INJECTOR:
-          builder.add(ClassName.fromClass(MembersInjector.class));
-          break;
-        default:
-          throw new AssertionError();
-      }
-      for (TypeElement referencedType : referencedTypes) {
-        ClassName className = ClassName.fromTypeElement(referencedType);
-        // don't include classes in java.lang or the same package
-        if (!packagesToSkip.contains(className.packageName())
-            // or that are members of the same top-level class
-            && !className.topLevelClassName().equals(topLevelClassName)) {
-          builder.add(className);
-        }
-      }
-    }
-    return builder.build();
-  }
-
   /**
    * Sorts {@link DependencyRequest} instances in an order likely to reflect their logical
    * importance.
    */
-  static final Ordering<DependencyRequest> DEPENDENCY_ORDERING =
-      new Ordering<DependencyRequest>() {
-        @Override public int compare(DependencyRequest left, DependencyRequest right) {
-          return ComparisonChain.start()
-              // put fields before parameters
-              .compare(left.requestElement().getKind(), right.requestElement().getKind())
-              // order by dependency kind
-              .compare(left.kind(), right.kind())
-              // then sort by name
-              .compare(
-                  left.requestElement().getSimpleName().toString(),
-                  right.requestElement().getSimpleName().toString())
-              .result();
-        }
-      };
+  static final Ordering<DependencyRequest> DEPENDENCY_ORDERING = new Ordering<DependencyRequest>() {
+    @Override
+    public int compare(DependencyRequest left, DependencyRequest right) {
+      return ComparisonChain.start()
+      // put fields before parameters
+          .compare(left.requestElement().getKind(), right.requestElement().getKind())
+          // order by dependency kind
+          .compare(left.kind(), right.kind())
+          // then sort by name
+          .compare(left.requestElement().getSimpleName().toString(),
+              right.requestElement().getSimpleName().toString()).result();
+    }
+  };
 
   /**
    * This method generates names for the {@link Provider} references necessary for all of the
@@ -137,42 +70,38 @@
    * </ul>
    *
    * @return Returns the mapping from {@link Key} to provider name sorted by the name of the
-   * provider.
+   *         provider.
    */
   static ImmutableMap<Key, String> generateFrameworkReferenceNamesForDependencies(
       Iterable<? extends DependencyRequest> dependencies) {
     ImmutableSetMultimap.Builder<Key, DependencyRequest> dependenciesByKeyBuilder =
-        new ImmutableSetMultimap.Builder<Key, DependencyRequest>()
-            .orderValuesBy(DEPENDENCY_ORDERING);
+        new ImmutableSetMultimap.Builder<Key, DependencyRequest>().orderValuesBy(
+            DEPENDENCY_ORDERING);
     for (DependencyRequest dependency : dependencies) {
-      dependenciesByKeyBuilder.put(
-          dependency.key(), dependency);
+      dependenciesByKeyBuilder.put(dependency.key(), dependency);
     }
     ImmutableSetMultimap<Key, DependencyRequest> dependenciesByKey =
         dependenciesByKeyBuilder.build();
-    Map<Key, Collection<DependencyRequest>> dependenciesByKeyMap =
-        dependenciesByKey.asMap();
+    Map<Key, Collection<DependencyRequest>> dependenciesByKeyMap = dependenciesByKey.asMap();
     ImmutableMap.Builder<Key, String> providerNames = ImmutableMap.builder();
-    for (Entry<Key, Collection<DependencyRequest>> entry :
-      dependenciesByKeyMap.entrySet()) {
+    for (Entry<Key, Collection<DependencyRequest>> entry : dependenciesByKeyMap.entrySet()) {
       // collect together all of the names that we would want to call the provider
-      ImmutableSet<String> dependencyNames = FluentIterable.from(entry.getValue())
-          .transform(new DependencyVariableNamer())
-          .toSet();
+      ImmutableSet<String> dependencyNames =
+          FluentIterable.from(entry.getValue()).transform(new DependencyVariableNamer()).toSet();
 
       if (dependencyNames.size() == 1) {
-        // if there's only one name, great!  use it!
+        // if there's only one name, great! use it!
         String name = Iterables.getOnlyElement(dependencyNames);
         providerNames.put(entry.getKey(), name.endsWith("Provider") ? name : name + "Provider");
       } else {
         // in the event that a provider is being used for a bunch of deps with different names,
-        // add all the names together with "And"s in the middle.  E.g.: stringAndS
+        // add all the names together with "And"s in the middle. E.g.: stringAndS
         Iterator<String> namesIterator = dependencyNames.iterator();
         String first = namesIterator.next();
         StringBuilder compositeNameBuilder = new StringBuilder(first);
         while (namesIterator.hasNext()) {
-          compositeNameBuilder.append("And")
-              .append(CaseFormat.LOWER_CAMEL.to(UPPER_CAMEL, namesIterator.next()));
+          compositeNameBuilder.append("And").append(
+              CaseFormat.LOWER_CAMEL.to(UPPER_CAMEL, namesIterator.next()));
         }
         providerNames.put(entry.getKey(), compositeNameBuilder.append("Provider").toString());
       }
@@ -180,79 +109,12 @@
     return providerNames.build();
   }
 
-  // TODO(gak): this needs to suck less
-  static ImmutableMap<Key, String> generateProviderNamesForBindings(
-      SetMultimap<Key, ProvisionBinding> bindings) {
-    ImmutableMap.Builder<Key, String> providerNames = ImmutableMap.builder();
-    for (Entry<Key, Collection<ProvisionBinding>> entry : bindings.asMap().entrySet()) {
-      Collection<ProvisionBinding> bindingsForKey = entry.getValue();
-      BindingType bindingsType = ProvisionBinding.bindingTypeFor(bindingsForKey);
-      switch (bindingsType) {
-        case SET:
-          providerNames.put(entry.getKey(),
-              new KeyVariableNamer().apply(entry.getKey()) + "Provider");
-          break;
-        case MAP:
-          providerNames.put(entry.getKey(),
-              new KeyVariableNamer().apply(entry.getKey()) + "Provider");
-          break;
-        case UNIQUE:
-          Binding binding = Iterables.getOnlyElement(bindingsForKey);
-          providerNames.put(entry.getKey(),
-              binding.bindingElement().accept(new ElementKindVisitor6<String, Void>() {
-                @Override
-                public String visitExecutableAsConstructor(ExecutableElement e, Void p) {
-                  return e.getEnclosingElement().accept(this, null);
-                }
-
-                @Override
-                public String visitExecutableAsMethod(ExecutableElement e, Void p) {
-                  return e.getSimpleName().toString();
-                }
-
-                @Override
-                public String visitType(TypeElement e, Void p) {
-                  return CaseFormat.UPPER_CAMEL.to(CaseFormat.LOWER_CAMEL,
-                      e.getSimpleName().toString());
-                }
-              }, null) + "Provider");
-          break;
-        default:
-          throw new IllegalStateException();
-      }
-    }
-    Ordering<Entry<?, String>> entryValueOrdering =
-        Ordering.natural().onResultOf(new Function<Entry<?, String>, String>() {
-          @Override
-          public String apply(Entry<?, String> input) {
-            return input.getValue();
-          }
-        });
-    ImmutableMap.Builder<Key, String> sortedProviderNames = ImmutableMap.builder();
-    for (Entry<Key, String> providerNameEntry :
-      entryValueOrdering.sortedCopy(providerNames.build().entrySet())) {
-      sortedProviderNames.put(providerNameEntry);
-    }
-    return sortedProviderNames.build();
-  }
-
-  static ImmutableMap<Key, String> generateMembersInjectorNamesForBindings(
-      Map<Key, MembersInjectionBinding> bindings) {
-    return ImmutableMap.copyOf(Maps.transformValues(bindings,
-        new Function<MembersInjectionBinding, String>() {
-          @Override public String apply(MembersInjectionBinding input) {
-            return CaseFormat.UPPER_CAMEL.to(CaseFormat.LOWER_CAMEL,
-                input.bindingElement().getSimpleName().toString()) + "MembersInjector";
-          }
-        }));
-  }
-
   static Snippet frameworkTypeUsageStatement(Snippet frameworkTypeMemberSelect,
       DependencyRequest.Kind dependencyKind) {
     switch (dependencyKind) {
       case LAZY:
-        return Snippet.format("%s.create(%s)",
-            ClassName.fromClass(DoubleCheckLazy.class), frameworkTypeMemberSelect);
+        return Snippet.format("%s.create(%s)", ClassName.fromClass(DoubleCheckLazy.class),
+            frameworkTypeMemberSelect);
       case INSTANCE:
         return Snippet.format("%s.get()", frameworkTypeMemberSelect);
       case PROVIDER:
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/ClassWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/ClassWriter.java
index 107062f22..dd51c179c 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/ClassWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/ClassWriter.java
@@ -5,60 +5,27 @@
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Lists;
-import com.google.common.collect.Maps;
 import com.google.common.collect.Sets;
 import java.io.IOException;
 import java.util.Iterator;
 import java.util.List;
-import java.util.Map;
 import java.util.Set;
 import javax.lang.model.element.Modifier;
-import javax.lang.model.element.TypeElement;
 
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.PROTECTED;
 import static javax.lang.model.element.Modifier.PUBLIC;
 
 public final class ClassWriter extends TypeWriter {
-  private final Map<String, FieldWriter> fieldWriters;
   private final List<ConstructorWriter> constructorWriters;
   private final List<TypeVariableName> typeVariables;
 
   ClassWriter(ClassName className) {
     super(className);
-    this.fieldWriters = Maps.newLinkedHashMap();
     this.constructorWriters = Lists.newArrayList();
     this.typeVariables = Lists.newArrayList();
   }
 
-  public void addImplementedType(TypeName typeReference) {
-    implementedTypes.add(typeReference);
-  }
-
-  public void addImplementedType(TypeElement typeElement) {
-    implementedTypes.add(ClassName.fromTypeElement(typeElement));
-  }
-
-  public FieldWriter addField(Class<?> type, String name) {
-    return addField(ClassName.fromClass(type), name);
-  }
-
-  public FieldWriter addField(TypeElement type, String name) {
-    return addField(ClassName.fromTypeElement(type), name);
-  }
-
-  public FieldWriter addField(TypeName type, String name) {
-    String candidateName = name;
-    int differentiator = 1;
-    while (fieldWriters.containsKey(candidateName)) {
-      candidateName = name + differentiator;
-      differentiator++;
-    }
-    FieldWriter fieldWriter = new FieldWriter(type, candidateName);
-    fieldWriters.put(candidateName, fieldWriter);
-    return fieldWriter;
-  }
-
   public ConstructorWriter addConstructor() {
     ConstructorWriter constructorWriter = new ConstructorWriter(name.simpleName());
     constructorWriters.add(constructorWriter);
@@ -130,6 +97,7 @@ private boolean isDefaultConstructor(ConstructorWriter constructorWriter) {
 
   @Override
   public Set<ClassName> referencedClasses() {
+    @SuppressWarnings("unchecked")
     Iterable<? extends HasClassReferences> concat =
         Iterables.concat(nestedTypeWriters, fieldWriters.values(), constructorWriters,
             methodWriters, implementedTypes, supertype.asSet(), annotations);
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/EnumWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/EnumWriter.java
new file mode 100644
index 000000000..314380329
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/EnumWriter.java
@@ -0,0 +1,168 @@
+package dagger.internal.codegen.writer;
+
+import com.google.common.base.Function;
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.Iterables;
+import com.google.common.collect.Lists;
+import com.google.common.collect.Maps;
+import com.google.common.collect.Sets;
+import java.io.IOException;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import javax.lang.model.element.Modifier;
+
+import static com.google.common.base.Preconditions.checkState;
+import static javax.lang.model.element.Modifier.PRIVATE;
+import static javax.lang.model.element.Modifier.PROTECTED;
+import static javax.lang.model.element.Modifier.PUBLIC;
+
+public class EnumWriter extends TypeWriter {
+  private final Map<String, ConstantWriter> constantWriters = Maps.newLinkedHashMap();
+  private final List<ConstructorWriter> constructorWriters = Lists.newArrayList();
+
+  EnumWriter(ClassName name) {
+    super(name);
+  }
+
+  public ConstantWriter addConstant(String name) {
+    ConstantWriter constantWriter = new ConstantWriter(name);
+    constantWriters.put(name, constantWriter);
+    return constantWriter;
+  }
+
+  public ConstructorWriter addConstructor() {
+    ConstructorWriter constructorWriter = new ConstructorWriter(name.simpleName());
+    constructorWriters.add(constructorWriter);
+    return constructorWriter;
+  }
+
+  @Override
+  public Appendable write(Appendable appendable, Context context) throws IOException {
+    context = context.createSubcontext(FluentIterable.from(nestedTypeWriters)
+        .transform(new Function<TypeWriter, ClassName>() {
+          @Override public ClassName apply(TypeWriter input) {
+            return input.name;
+          }
+        })
+        .toSet());
+    writeAnnotations(appendable, context);
+    writeModifiers(appendable).append("enum ").append(name.simpleName());
+    Iterator<TypeName> implementedTypesIterator = implementedTypes.iterator();
+    if (implementedTypesIterator.hasNext()) {
+      appendable.append(" implements ");
+      implementedTypesIterator.next().write(appendable, context);
+      while (implementedTypesIterator.hasNext()) {
+        appendable.append(", ");
+        implementedTypesIterator.next().write(appendable, context);
+      }
+    }
+    appendable.append(" {");
+
+    checkState(!constantWriters.isEmpty(), "Cannot write an enum with no constants.");
+    appendable.append('\n');
+    ImmutableList<ConstantWriter> constantWriterList =
+        ImmutableList.copyOf(constantWriters.values());
+    for (ConstantWriter constantWriter :
+        constantWriterList.subList(0, constantWriterList.size() - 1)) {
+      constantWriter.write(appendable, context);
+      appendable.append(",\n");
+    }
+    constantWriterList.get(constantWriterList.size() - 1).write(appendable, context);
+    appendable.append(";\n");
+
+    if (!fieldWriters.isEmpty()) {
+      appendable.append('\n');
+    }
+    for (VariableWriter fieldWriter : fieldWriters.values()) {
+      fieldWriter.write(new IndentingAppendable(appendable), context).append("\n");
+    }
+    for (ConstructorWriter constructorWriter : constructorWriters) {
+      appendable.append('\n');
+      if (!isDefaultConstructor(constructorWriter)) {
+        constructorWriter.write(new IndentingAppendable(appendable), context);
+      }
+    }
+    for (MethodWriter methodWriter : methodWriters) {
+      appendable.append('\n');
+      methodWriter.write(new IndentingAppendable(appendable), context);
+    }
+    for (TypeWriter nestedTypeWriter : nestedTypeWriters) {
+      appendable.append('\n');
+      nestedTypeWriter.write(new IndentingAppendable(appendable), context);
+    }
+    appendable.append("}\n");
+    return appendable;
+  }
+
+  private static final Set<Modifier> VISIBILIY_MODIFIERS =
+      Sets.immutableEnumSet(PUBLIC, PROTECTED, PRIVATE);
+
+  private boolean isDefaultConstructor(ConstructorWriter constructorWriter) {
+    return Sets.intersection(VISIBILIY_MODIFIERS, modifiers)
+        .equals(Sets.intersection(VISIBILIY_MODIFIERS, constructorWriter.modifiers))
+        && constructorWriter.body().isEmpty();
+  }
+
+  @Override
+  public Set<ClassName> referencedClasses() {
+    @SuppressWarnings("unchecked")
+    Iterable<? extends HasClassReferences> concat =
+        Iterables.concat(nestedTypeWriters, constantWriters.values(), fieldWriters.values(),
+            constructorWriters,
+            methodWriters, implementedTypes, supertype.asSet(), annotations);
+    return FluentIterable.from(concat)
+        .transformAndConcat(new Function<HasClassReferences, Set<ClassName>>() {
+          @Override
+          public Set<ClassName> apply(HasClassReferences input) {
+            return input.referencedClasses();
+          }
+        })
+        .toSet();
+  }
+
+  public static final class ConstantWriter implements Writable, HasClassReferences {
+    private final String name;
+    private final List<Snippet> constructorSnippets;
+
+    private ConstantWriter(String name) {
+      this.name = name;
+      this.constructorSnippets = Lists.newArrayList();
+    }
+
+    ConstantWriter addArgument(Snippet snippet) {
+      constructorSnippets.add(snippet);
+      return this;
+    }
+
+    @Override
+    public Appendable write(Appendable appendable, Context context) throws IOException {
+      appendable.append(name);
+      Iterator<Snippet> snippetIterator = constructorSnippets.iterator();
+      if (snippetIterator.hasNext()) {
+        appendable.append('(');
+        snippetIterator.next().write(appendable, context);
+        while (snippetIterator.hasNext()) {
+          appendable.append(", ");
+          snippetIterator.next().write(appendable, context);
+        }
+        appendable.append(')');
+      }
+      return appendable;
+    }
+
+    @Override
+    public Set<ClassName> referencedClasses() {
+      return FluentIterable.from(constructorSnippets)
+          .transformAndConcat(new Function<Snippet, Set<ClassName>>() {
+            @Override
+            public Set<ClassName> apply(Snippet input) {
+              return input.referencedClasses();
+            }
+          })
+          .toSet();
+    }
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/JavaWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/JavaWriter.java
index 60ac493d1..4788a892e 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/JavaWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/JavaWriter.java
@@ -69,6 +69,13 @@ public ClassWriter addClass(String simpleName) {
     return classWriter;
   }
 
+  public EnumWriter addEnum(String simpleName) {
+    checkNotNull(simpleName);
+    EnumWriter writer = new EnumWriter(ClassName.create(simpleName, simpleName));
+    typeWriters.add(writer);
+    return writer;
+  }
+
   public InterfaceWriter addInterface(String simpleName) {
     InterfaceWriter writer = new InterfaceWriter(ClassName.create(packageName, simpleName));
     typeWriters.add(writer);
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/TypeWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/TypeWriter.java
index aa7ba02e5..40cd59e6e 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/TypeWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/TypeWriter.java
@@ -2,7 +2,10 @@
 
 import com.google.common.base.Optional;
 import com.google.common.collect.Lists;
+import com.google.common.collect.Maps;
 import java.util.List;
+import java.util.Map;
+import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.TypeMirror;
 
 /**
@@ -15,13 +18,15 @@
   final List<TypeName> implementedTypes;
   final List<MethodWriter> methodWriters;
   final List<TypeWriter> nestedTypeWriters;
+  final Map<String, FieldWriter> fieldWriters;
 
   TypeWriter(ClassName name) {
     this.name = name;
     this.supertype = Optional.absent();
     this.implementedTypes = Lists.newArrayList();
     this.methodWriters = Lists.newArrayList();
-    nestedTypeWriters = Lists.newArrayList();
+    this.nestedTypeWriters = Lists.newArrayList();
+    this.fieldWriters = Maps.newLinkedHashMap();
   }
 
   @Override
@@ -60,4 +65,32 @@ public ClassWriter addNestedClass(String name) {
     nestedTypeWriters.add(innerClassWriter);
     return innerClassWriter;
   }
+
+  public void addImplementedType(TypeName typeReference) {
+    implementedTypes.add(typeReference);
+  }
+
+  public void addImplementedType(TypeElement typeElement) {
+    implementedTypes.add(ClassName.fromTypeElement(typeElement));
+  }
+
+  public FieldWriter addField(Class<?> type, String name) {
+    return addField(ClassName.fromClass(type), name);
+  }
+
+  public FieldWriter addField(TypeElement type, String name) {
+    return addField(ClassName.fromTypeElement(type), name);
+  }
+
+  public FieldWriter addField(TypeName type, String name) {
+    String candidateName = name;
+    int differentiator = 1;
+    while (fieldWriters.containsKey(candidateName)) {
+      candidateName = name + differentiator;
+      differentiator++;
+    }
+    FieldWriter fieldWriter = new FieldWriter(type, candidateName);
+    fieldWriters.put(candidateName, fieldWriter);
+    return fieldWriter;
+  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/VariableWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/VariableWriter.java
index 44d1a11b7..00dc29434 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/VariableWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/VariableWriter.java
@@ -3,13 +3,15 @@
 import java.io.IOException;
 import java.util.Set;
 
+import static com.google.common.base.Preconditions.checkNotNull;
+
 public class VariableWriter extends Modifiable implements Writable, HasClassReferences {
   private final TypeName type;
   private final String name;
 
   VariableWriter(TypeName type, String name) {
-    this.type = type;
-    this.name = name;
+    this.type = checkNotNull(type);
+    this.name = checkNotNull(name);
   }
 
   public TypeName type() {
diff --git a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
index 91a4fe954..ce5631cbd 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
@@ -120,8 +120,6 @@
         "",
         "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
         "public final class Dagger_SimpleComponent implements SimpleComponent {",
-        "  private Provider<SomeInjectableType> someInjectableTypeProvider;",
-        "",
         "  private Dagger_SimpleComponent(Builder builder) {",
         "    assert builder != null;",
         "    initialize();",
@@ -136,22 +134,21 @@
         "  }",
         "",
         "  private void initialize() {",
-        "    this.someInjectableTypeProvider = new SomeInjectableType$$Factory();",
         "  }",
         "",
         "  @Override",
         "  public SomeInjectableType someInjectableType() {",
-        "    return someInjectableTypeProvider.get();",
+        "    return SomeInjectableType$$Factory.INSTANCE.get();",
         "  }",
         "",
         "  @Override",
         "  public Lazy<SomeInjectableType> lazySomeInjectableType() {",
-        "    return DoubleCheckLazy.create(someInjectableTypeProvider);",
+        "    return DoubleCheckLazy.create(SomeInjectableType$$Factory.INSTANCE);",
         "  }",
         "",
         "  @Override",
         "  public Provider<SomeInjectableType> someInjectableTypeProvider() {",
-        "    return someInjectableTypeProvider;",
+        "    return SomeInjectableType$$Factory.INSTANCE;",
         "  }",
         "",
         "  public static final class Builder {",
@@ -224,7 +221,7 @@
         "",
         "  private void initialize() {",
         "    this.someInjectableTypeProvider =",
-        "        ScopedProvider.create(new SomeInjectableType$$Factory());",
+        "        ScopedProvider.create(SomeInjectableType$$Factory.INSTANCE);",
         "  }",
         "",
         "  @Override",
@@ -284,7 +281,8 @@
         "import javax.annotation.Generated;",
         "import test.OuterType.A;",
         "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
-        "public final class OuterType$A$$Factory implements Factory<A> {",
+        "public enum OuterType$A$$Factory implements Factory<A> {",
+        "  INSTANCE;",
         "",
         "  @Override public A get() {",
         "    return new A();",
@@ -324,14 +322,12 @@
         "",
         "import dagger.MembersInjector;",
         "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
         "import test.OuterType.A;",
         "import test.OuterType.B;",
         "import test.OuterType.SimpleComponent;",
         "",
         "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
         "public final class Dagger_OuterType$SimpleComponent implements SimpleComponent {",
-        "  private Provider<A> aProvider;",
         "  private MembersInjector<B> bMembersInjector;",
         "",
         "  private Dagger_OuterType$SimpleComponent(Builder builder) {",
@@ -348,13 +344,13 @@
         "  }",
         "",
         "  private void initialize() {",
-        "    this.aProvider = new OuterType$A$$Factory();",
-        "    this.bMembersInjector = new OuterType$B$$MembersInjector(aProvider);",
+        "    this.bMembersInjector =",
+        "        new OuterType$B$$MembersInjector(OuterType$A$$Factory.INSTANCE);",
         "  }",
         "",
         "  @Override",
         "  public A a() {",
-        "    return aProvider.get();",
+        "    return OuterType$A$$Factory.INSTANCE.get();",
         "  }",
         "",
         "  @Override",
@@ -431,7 +427,6 @@
         "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
         "public final class Dagger_TestComponent implements TestComponent {",
         "  private final TestModule testModule;",
-        "  private Provider<C> cProvider;",
         "  private Provider<B> bProvider;",
         "  private Provider<A> aProvider;",
         "",
@@ -450,8 +445,7 @@
         "  }",
         "",
         "  private void initialize() {",
-        "    this.cProvider = new C$$Factory();",
-        "    this.bProvider = new TestModule$$BFactory(testModule, cProvider);",
+        "    this.bProvider = new TestModule$$BFactory(testModule, C$$Factory.INSTANCE);",
         "    this.aProvider = new A$$Factory(bProvider);",
         "  }",
         "",
@@ -741,11 +735,9 @@
         "",
         "import dagger.MembersInjector;",
         "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
         "",
         "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
         "public final class Dagger_SimpleComponent implements SimpleComponent {",
-        "  private Provider<SomeInjectableType> someInjectableTypeProvider;",
         "  private MembersInjector<SomeInjectedType> someInjectedTypeMembersInjector;",
         "",
         "  private Dagger_SimpleComponent(Builder builder) {",
@@ -762,9 +754,8 @@
         "  }",
         "",
         "  private void initialize() {",
-        "    this.someInjectableTypeProvider = new SomeInjectableType$$Factory();",
         "    this.someInjectedTypeMembersInjector =",
-        "        new SomeInjectedType$$MembersInjector(someInjectableTypeProvider);",
+        "        new SomeInjectedType$$MembersInjector(SomeInjectableType$$Factory.INSTANCE);",
         "  }",
         "",
         "  @Override",
@@ -904,7 +895,6 @@
         "",
         "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
         "public final class Dagger_SimpleComponent implements SimpleComponent {",
-        "  private Provider<SomeInjectableType> someInjectableTypeProvider;",
         "  private MembersInjector<SomeInjectedType> someInjectedTypeMembersInjector;",
         "  private Provider<SomeInjectedType> someInjectedTypeProvider;",
         "",
@@ -922,9 +912,8 @@
         "  }",
         "",
         "  private void initialize() {",
-        "    this.someInjectableTypeProvider = new SomeInjectableType$$Factory();",
         "    this.someInjectedTypeMembersInjector =",
-        "        new SomeInjectedType$$MembersInjector(someInjectableTypeProvider);",
+        "        new SomeInjectedType$$MembersInjector(SomeInjectableType$$Factory.INSTANCE);",
         "    this.someInjectedTypeProvider =",
         "        new SomeInjectedType$$Factory(someInjectedTypeMembersInjector);",
         "  }",
@@ -1245,7 +1234,6 @@
         "",
         "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
         "public final class Dagger_TestComponent implements TestComponent {",
-        "  private Provider<C> cProvider;",
         "  private Provider<B> bProvider;",
         "  private Provider<A> aProvider;",
         "  private Provider<X> xProvider;",
@@ -1264,10 +1252,9 @@
         "  }",
         "",
         "  private void initialize() {",
-        "    this.cProvider = new C$$Factory();",
-        "    this.bProvider = new B$$Factory(cProvider);",
+        "    this.bProvider = new B$$Factory(C$$Factory.INSTANCE);",
         "    this.aProvider = new A$$Factory(bProvider);",
-        "    this.xProvider = new X$$Factory(cProvider);",
+        "    this.xProvider = new X$$Factory(C$$Factory.INSTANCE);",
         "  }",
         "",
         "  @Override",
@@ -1277,7 +1264,7 @@
         "",
         "  @Override",
         "  public C c() {",
-        "    return cProvider.get();",
+        "    return C$$Factory.INSTANCE.get();",
         "  }",
         "",
         "  @Override",
@@ -1350,12 +1337,9 @@
         "package test;",
         "",
         "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
         "",
         "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
         "public final class Dagger_SimpleComponent implements SimpleComponent {",
-        "  private Provider<SomeInjectableType> someInjectableTypeProvider;",
-        "",
         "  private Dagger_SimpleComponent(Builder builder) {",
         "    assert builder != null;",
         "    initialize();",
@@ -1369,13 +1353,11 @@
         "    return builder().build();",
         "  }",
         "",
-        "  private void initialize() {",
-        "    this.someInjectableTypeProvider = new SomeInjectableType$$Factory();",
-        "  }",
+        "  private void initialize() {}",
         "",
         "  @Override",
         "  public SomeInjectableType someInjectableType() {",
-        "    return someInjectableTypeProvider.get();",
+        "    return SomeInjectableType$$Factory.INSTANCE.get();",
         "  }",
         "",
         "  public static final class Builder {",
@@ -1443,12 +1425,9 @@
         "package test;",
         "",
         "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
         "",
         "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
         "public final class Dagger_SimpleComponent implements SimpleComponent {",
-        "  private Provider<SomeInjectableType> someInjectableTypeProvider;",
-        "",
         "  private Dagger_SimpleComponent(Builder builder) {",
         "    assert builder != null;",
         "    initialize();",
@@ -1462,13 +1441,11 @@
         "    return builder().build();",
         "  }",
         "",
-        "  private void initialize() {",
-        "    this.someInjectableTypeProvider = new SomeInjectableType$$Factory();",
-        "  }",
+        "  private void initialize() {}",
         "",
         "  @Override",
         "  public SomeInjectableType someInjectableType() {",
-        "    return someInjectableTypeProvider.get();",
+        "    return SomeInjectableType$$Factory.INSTANCE.get();",
         "  }",
         "",
         "  public static final class Builder {",
diff --git a/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java b/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
index 71ddde94b..d89328cf0 100644
--- a/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
@@ -336,6 +336,116 @@
         .and().withErrorContaining(expectedMapError).in(component).onLine(44);
   }
 
+  @Test public void duplicateBindings_TruncateAfterLimit() {
+    JavaFileObject component = JavaFileObjects.forSourceLines("test.Outer",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import javax.inject.Inject;",
+        "",
+        "final class Outer {",
+        "  interface A {}",
+        "",
+        "  @Module",
+        "  static class Module1 {",
+        "    @Provides A provideA() { return new A() {}; }",
+        "  }",
+        "",
+        "  @Module",
+        "  static class Module2 {",
+        "    @Provides A provideA() { return new A() {}; }",
+        "  }",
+        "",
+        "  @Module",
+        "  static class Module3 {",
+        "    @Provides A provideA() { return new A() {}; }",
+        "  }",
+        "",
+        "  @Module",
+        "  static class Module4 {",
+        "    @Provides A provideA() { return new A() {}; }",
+        "  }",
+        "",
+        "  @Module",
+        "  static class Module5 {",
+        "    @Provides A provideA() { return new A() {}; }",
+        "  }",
+        "",
+        "  @Module",
+        "  static class Module6 {",
+        "    @Provides A provideA() { return new A() {}; }",
+        "  }",
+        "",
+        "  @Module",
+        "  static class Module7 {",
+        "    @Provides A provideA() { return new A() {}; }",
+        "  }",
+        "",
+        "  @Module",
+        "  static class Module8 {",
+        "    @Provides A provideA() { return new A() {}; }",
+        "  }",
+        "",
+        "  @Module",
+        "  static class Module9 {",
+        "    @Provides A provideA() { return new A() {}; }",
+        "  }",
+        "",
+        "  @Module",
+        "  static class Module10 {",
+        "    @Provides A provideA() { return new A() {}; }",
+        "  }",
+        "",
+        "  @Module",
+        "  static class Module11 {",
+        "    @Provides A provideA() { return new A() {}; }",
+        "  }",
+        "",
+        "  @Module",
+        "  static class Module12 {",
+        "    @Provides A provideA() { return new A() {}; }",
+        "  }",
+        "",
+        "  @Component(modules = {",
+        "    Module1.class,",
+        "    Module2.class,",
+        "    Module3.class,",
+        "    Module4.class,",
+        "    Module5.class,",
+        "    Module6.class,",
+        "    Module7.class,",
+        "    Module8.class,",
+        "    Module9.class,",
+        "    Module10.class,",
+        "    Module11.class,",
+        "    Module12.class",
+        "  })",
+        "  interface TestComponent {",
+        "    A getA();",
+        "  }",
+        "}");
+
+    String expectedError = "test.Outer.A is bound multiple times:\n"
+        + "      test.Outer.Module1.provideA()\n"
+        + "      test.Outer.Module2.provideA()\n"
+        + "      test.Outer.Module3.provideA()\n"
+        + "      test.Outer.Module4.provideA()\n"
+        + "      test.Outer.Module5.provideA()\n"
+        + "      test.Outer.Module6.provideA()\n"
+        + "      test.Outer.Module7.provideA()\n"
+        + "      test.Outer.Module8.provideA()\n"
+        + "      test.Outer.Module9.provideA()\n"
+        + "      test.Outer.Module10.provideA()\n"
+        + "      and 2 others";
+
+    assert_().about(javaSource()).that(component)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(expectedError).in(component).onLine(86);
+  }
+
   @Test public void longChainOfDependencies() {
     JavaFileObject component = JavaFileObjects.forSourceLines("test.TestClass",
         "package test;",
diff --git a/compiler/src/test/java/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java b/compiler/src/test/java/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java
index 29675bb16..8d6d1eb20 100644
--- a/compiler/src/test/java/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java
@@ -821,4 +821,35 @@ public void samePackageNameCollision() {
         .compilesWithoutError()
         .and().generatesSources(expected);
   }
+
+  @Test
+  public void noDeps() {
+    JavaFileObject simpleType = JavaFileObjects.forSourceLines("test.SimpleType",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class SimpleType {",
+        "  @Inject SimpleType() {}",
+        "}");
+    JavaFileObject factory = JavaFileObjects.forSourceLines("test.SimpleType$$Factory",
+        "package test;",
+        "",
+        "import dagger.Factory;",
+        "import javax.annotation.Generated;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public enum SimpleType$$Factory implements Factory<SimpleType> {",
+        "  INSTANCE;",
+        "",
+        "  @Override public SimpleType get() {",
+        "    return new SimpleType();",
+        "  }",
+        "}");
+    assert_().about(javaSource())
+        .that(simpleType)
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(factory);
+  }
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java b/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java
index e6c119e5b..2c80a64b3 100644
--- a/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java
@@ -139,7 +139,6 @@ public void parentClass_injectedMembersInSupertype() {
         "",
         "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
         "public final class Dagger_TestComponent implements TestComponent {",
-        "  private Provider<Dep> depProvider;",
         "  private MembersInjector<Parent> parentMembersInjector;",
         "  private MembersInjector<Child> childMembersInjector;",
         "  private Provider<Child> childProvider;",
@@ -158,8 +157,7 @@ public void parentClass_injectedMembersInSupertype() {
         "  }",
         "",
         "  private void initialize() {",
-        "    this.depProvider = new Dep$$Factory();",
-        "    this.parentMembersInjector = new Parent$$MembersInjector(depProvider);",
+        "    this.parentMembersInjector = new Parent$$MembersInjector(Dep$$Factory.INSTANCE);",
         "    this.childMembersInjector = MembersInjectors.delegatingTo(parentMembersInjector);",
         "    this.childProvider = new Child$$Factory(childMembersInjector);",
         "  }",
diff --git a/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java b/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
index cdf270a1d..35cfa5fa2 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
@@ -235,13 +235,10 @@
         "package test;",
         "",
         "import dagger.Factory;",
-        "import java.util.logging.Logger;",
         "import javax.annotation.Generated;",
         "",
         "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
         "public final class TestModule$$ProvideStringFactory implements Factory<String> {",
-        "  private static final Logger logger =",
-        "      Logger.getLogger(TestModule$$ProvideStringFactory.class.getCanonicalName());",
         "  private final TestModule module;",
         "",
         "  public TestModule$$ProvideStringFactory(TestModule module) {",
@@ -250,13 +247,7 @@
         "  }",
         "",
         "  @Override public String get() {",
-        "    String result =  module.provideString();",
-        "    if (result == null) {",
-        "      logger.warning("
-            + "\"test.TestModule.provideString() provided null. "
-            + "This is not allowed and will soon throw a NullPointerException.\");",
-        "    }",
-        "    return result;",
+        "    return module.provideString();",
         "  }",
         "}");
     assert_().about(javaSource()).that(moduleFile)
@@ -310,14 +301,11 @@
         "",
         "import dagger.Factory;",
         "import java.util.List;",
-        "import java.util.logging.Logger;",
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
         "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
         "public final class TestModule$$ProvideObjectsFactory implements Factory<List<Object>> {",
-        "  private static final Logger logger =",
-        "      Logger.getLogger(TestModule$$ProvideObjectsFactory.class.getCanonicalName());",
         "  private final TestModule module;",
         "  private final Provider<Object> aProvider;",
         "  private final Provider<Object> bProvider;",
@@ -333,13 +321,7 @@
         "  }",
         "",
         "  @Override public List<Object> get() {",
-        "    List<Object> result = module.provideObjects(aProvider.get(), bProvider.get());",
-        "    if (result == null) {",
-        "      logger.warning("
-            + "\"test.TestModule.provideObjects(java.lang.Object,java.lang.Object) provided null. "
-            + "This is not allowed and will soon throw a NullPointerException.\");",
-        "    }",
-        "    return result;",
+        "    return module.provideObjects(aProvider.get(), bProvider.get());",
         "  }",
         "}");
     assert_().about(javaSources()).that(ImmutableList.of(moduleFile, QUALIFIER_A, QUALIFIER_B))
@@ -370,13 +352,10 @@
         "import dagger.Factory;",
         "import java.util.Collections;",
         "import java.util.Set;",
-        "import java.util.logging.Logger;",
         "import javax.annotation.Generated;",
         "",
         "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
         "public final class TestModule$$ProvideStringFactory implements Factory<Set<String>> {",
-        "  private static final Logger logger =",
-        "      Logger.getLogger(TestModule$$ProvideStringFactory.class.getCanonicalName());",
         "  private final TestModule module;",
         "",
         "  public TestModule$$ProvideStringFactory(TestModule module) {",
@@ -385,13 +364,7 @@
         "  }",
         "",
         "  @Override public Set<String> get() {",
-        "    String result =  module.provideString();",
-        "    if (result == null) {",
-        "      logger.warning("
-            + "\"test.TestModule.provideString() provided null. "
-            + "This is not allowed and will soon throw a NullPointerException.\");",
-        "    }",
-        "    return Collections.singleton(result);",
+        "    return Collections.singleton(module.provideString());",
         "  }",
         "}");
     assert_().about(javaSource()).that(moduleFile)
@@ -421,13 +394,10 @@
         "",
         "import dagger.Factory;",
         "import java.util.Set;",
-        "import java.util.logging.Logger;",
         "import javax.annotation.Generated;",
         "",
         "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
         "public final class TestModule$$ProvideStringsFactory implements Factory<Set<String>> {",
-        "  private static final Logger logger =",
-        "      Logger.getLogger(TestModule$$ProvideStringsFactory.class.getCanonicalName());",
         "  private final TestModule module;",
         "",
         "  public TestModule$$ProvideStringsFactory(TestModule module) {",
@@ -436,13 +406,7 @@
         "  }",
         "",
         "  @Override public Set<String> get() {",
-        "    Set<String> result = module.provideStrings();",
-        "    if (result == null) {",
-        "      logger.warning("
-            + "\"test.TestModule.provideStrings() provided null. "
-            + "This is not allowed and will soon throw a NullPointerException.\");",
-        "    }",
-        "    return result;",
+        "    return module.provideStrings();",
         "  }",
         "}");
     assert_().about(javaSource()).that(moduleFile)
diff --git a/compiler/src/test/java/dagger/internal/codegen/PackageProxyTest.java b/compiler/src/test/java/dagger/internal/codegen/PackageProxyTest.java
index c404cce56..6f799ece3 100644
--- a/compiler/src/test/java/dagger/internal/codegen/PackageProxyTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/PackageProxyTest.java
@@ -13,13 +13,21 @@
 @RunWith(JUnit4.class)
 public class PackageProxyTest {
   @Test public void testPackageProxy() {
+    JavaFileObject noDepClassFile = JavaFileObjects.forSourceLines("foreign.NoDepClass",
+        "package foreign;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "public final class NoDepClass {",
+        "  @Inject NoDepClass() {}",
+        "}");
     JavaFileObject publicClassFile = JavaFileObjects.forSourceLines("foreign.PublicClass",
         "package foreign;",
         "",
         "import javax.inject.Inject;",
         "",
         "public final class PublicClass {",
-        "  @Inject PublicClass(NonPublicClass dep) {}",
+        "  @Inject PublicClass(NonPublicClass dep1, NoDepClass dep2) {}",
         "}");
     JavaFileObject nonPublicClassFile = JavaFileObjects.forSourceLines("foreign.NonPublicClass",
         "package foreign;",
@@ -27,7 +35,7 @@
         "import javax.inject.Inject;",
         "",
         "final class NonPublicClass {",
-        "  @Inject NonPublicClass() {}",
+        "  @Inject NonPublicClass(NoDepClass dep) {}",
         "}");
 
     JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
@@ -47,6 +55,7 @@
         "package test;",
         "",
         "import foreign.Dagger_TestComponent__PackageProxy;",
+        "import foreign.NoDepClass$$Factory;",
         "import foreign.NonPublicClass$$Factory;",
         "import foreign.PublicClass;",
         "import foreign.PublicClass$$Factory;",
@@ -73,9 +82,10 @@
         "  }",
         "",
         "  private void initialize() {",
-        "    this.foreign_Proxy.nonPublicClassProvider = new NonPublicClass$$Factory();",
-        "    this.publicClassProvider =",
-        "        new PublicClass$$Factory(foreign_Proxy.nonPublicClassProvider);",
+        "    this.foreign_Proxy.nonPublicClassProvider =",
+        "        new NonPublicClass$$Factory(NoDepClass$$Factory.INSTANCE);",
+        "    this.publicClassProvider = new PublicClass$$Factory(",
+        "        foreign_Proxy.nonPublicClassProvider, NoDepClass$$Factory.INSTANCE);",
         "  }",
         "",
         "  @Override",
@@ -93,7 +103,7 @@
         "  }",
         "}");
     assert_().about(javaSources())
-        .that(ImmutableList.of(publicClassFile, nonPublicClassFile, componentFile))
+        .that(ImmutableList.of(noDepClassFile, publicClassFile, nonPublicClassFile, componentFile))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and().generatesSources(generatedComponent);
diff --git a/compiler/src/test/java/dagger/tests/integration/codegen/dagger1/InjectAdapterGenerationTest.java b/compiler/src/test/java/dagger/tests/integration/codegen/dagger1/InjectAdapterGenerationTest.java
index 257f99d8e..703cf83d3 100644
--- a/compiler/src/test/java/dagger/tests/integration/codegen/dagger1/InjectAdapterGenerationTest.java
+++ b/compiler/src/test/java/dagger/tests/integration/codegen/dagger1/InjectAdapterGenerationTest.java
@@ -49,7 +49,7 @@
             "  private static final Class<?>[] INCLUDES = {};",
             "  public Basic$AModule$$ModuleAdapter() {",
             "    super(Basic.AModule.class, INJECTS, STATIC_INJECTIONS, false, INCLUDES,",
-            "      true, false);",
+            "      true, true);",
             "  }",
             "  @Override public Basic.AModule newModule() {",
             "    return new Basic.AModule();",
diff --git a/compiler/src/test/java/dagger/tests/integration/codegen/dagger1/ModuleAdapterGenerationTest.java b/compiler/src/test/java/dagger/tests/integration/codegen/dagger1/ModuleAdapterGenerationTest.java
index 17dfa7ce0..12ef23f0c 100644
--- a/compiler/src/test/java/dagger/tests/integration/codegen/dagger1/ModuleAdapterGenerationTest.java
+++ b/compiler/src/test/java/dagger/tests/integration/codegen/dagger1/ModuleAdapterGenerationTest.java
@@ -70,7 +70,7 @@
         "  private static final Class<?>[] STATIC_INJECTIONS = {};",
         "  private static final Class<?>[] INCLUDES = {};",
         "  public Field$AModule$$ModuleAdapter() {",
-        "    super(Field.AModule.class, INJECTS, STATIC_INJECTIONS, false, INCLUDES, true, false);",
+        "    super(Field.AModule.class, INJECTS, STATIC_INJECTIONS, false, INCLUDES, true, true);",
         "  }",
         "  @Override public Field.AModule newModule() {",
         "    return new Field.AModule();",
@@ -85,7 +85,7 @@
         "    public NameProvidesAdapter(Field.AModule module) {",
         "      super(\"java.lang.String\", NOT_SINGLETON, \"Field.AModule\", \"name\");",
         "      this.module = module;",
-        "      setLibrary(false);",
+        "      setLibrary(true);",
         "    }",
         "    @Override public String get() {",
         "      return module.name();", // corresponds to @Provides method
@@ -151,7 +151,7 @@
         "  private static final Class<?>[] STATIC_INJECTIONS = {};",
         "  private static final Class<?>[] INCLUDES = {};",
         "  public Field$AModule$$ModuleAdapter() {",
-        "    super(Field.AModule.class, INJECTS, STATIC_INJECTIONS, false, INCLUDES, true, false);",
+        "    super(Field.AModule.class, INJECTS, STATIC_INJECTIONS, false, INCLUDES, true, true);",
         "  }",
         "  @Override public Field.AModule newModule() {",
         "    return new Field.AModule();",
@@ -166,7 +166,7 @@
         "    public NameProvidesAdapter(Field.AModule module) {",
         "      super(\"java.lang.String\", NOT_SINGLETON, \"Field.AModule\", \"name\");",
         "      this.module = module;",
-        "      setLibrary(false);",
+        "      setLibrary(true);",
         "    }",
         "    @Override public String get() {",
         "      return module.name();", // corresponds to @Provides method
diff --git a/core/src/main/java/dagger/Component.java b/core/src/main/java/dagger/Component.java
index abfc34880..08880e845 100644
--- a/core/src/main/java/dagger/Component.java
+++ b/core/src/main/java/dagger/Component.java
@@ -27,8 +27,8 @@
  * Annotates an interface or abstract class for which a fully-formed, dependency-injected
  * implementation is to be generated from a set of {@linkplain #modules}. The generated class will
  * have the name of the type annotated with {@code @Component} prepended with
- * {@code DaggerComponent_}.  For example, {@code @Component interface MyComponent {...}} will
- * produce an implementation named {@code DaggerComponent_MyComponent}.
+ * {@code Dagger_}.  For example, {@code @Component interface MyComponent {...}} will
+ * produce an implementation named {@code Dagger_MyComponent}.
  *
  * <h2>Component methods</h2>
  *
diff --git a/core/src/main/java/dagger/Module.java b/core/src/main/java/dagger/Module.java
index 1e28f4fd6..33c10857b 100644
--- a/core/src/main/java/dagger/Module.java
+++ b/core/src/main/java/dagger/Module.java
@@ -89,7 +89,10 @@
    * included bindings are not necessary. If you provide bindings that are not
    * used by this module's graph, then you must declare {@code library = true}.
    *
-   * <p>This is intended to help you detect dead code.
+   * <p>This is intended to help you detect dead code.  As of 2.0 Dagger ignores
+   * this property and it is present for compatibility with Dagger 1.x during
+   * migrations.
    */
-  boolean library() default false;
+  // TODO(user): Deprecate this property.
+  boolean library() default true;
 }
diff --git a/core/src/main/java/dagger/ObjectGraph.java b/core/src/main/java/dagger/ObjectGraph.java
index f9c84ae7b..cd94d3069 100644
--- a/core/src/main/java/dagger/ObjectGraph.java
+++ b/core/src/main/java/dagger/ObjectGraph.java
@@ -304,11 +304,7 @@ private void linkInjectableTypes() {
      */
     private Binding<?> getInjectableTypeBinding(
         ClassLoader classLoader, String injectableKey, String key) {
-      Class<?> moduleClass = null;
-      for (DaggerObjectGraph graph = this; graph != null; graph = graph.base) {
-        moduleClass = graph.injectableTypes.get(injectableKey);
-        if (moduleClass != null) break;
-      }
+      Class<?> moduleClass = getModuleClassDeclaringInjects(injectableKey);
       if (moduleClass == null) {
         throw new IllegalArgumentException("No inject registered for " + injectableKey
             + ". You must explicitly add it to the 'injects' option in one of your modules.");
@@ -323,6 +319,15 @@ private void linkInjectableTypes() {
         return binding;
       }
     }
+
+    private Class<?> getModuleClassDeclaringInjects(String injectableKey) {
+      Class<?> moduleClass = null;
+      for (DaggerObjectGraph graph = this; graph != null; graph = graph.base) {
+        moduleClass = graph.injectableTypes.get(injectableKey);
+        if (moduleClass != null) break;
+      }
+      return moduleClass;
+    }
   }
 
   /**
diff --git a/core/src/test/java/dagger/SetBindingTest.java b/core/src/test/java/dagger/SetBindingTest.java
index 4474d217a..268c1162b 100644
--- a/core/src/test/java/dagger/SetBindingTest.java
+++ b/core/src/test/java/dagger/SetBindingTest.java
@@ -286,7 +286,7 @@ public String provideString() {
       }
     }
 
-    @Module
+    @Module(library = false)
     class SetModule2 {
       @Provides(type = SET)
       public String provideString() {
@@ -301,7 +301,7 @@ public String provideString() {
         new TestModule(), new SetModule1(), new SetModule2());
     try {
       graph.validate();
-      fail();
+      fail("Should have failed validation.");
     } catch (IllegalStateException expected) {}
   }
 
diff --git a/core/src/test/java/dagger/UnusedProviderTest.java b/core/src/test/java/dagger/UnusedProviderTest.java
index c6af6a3aa..377eec46b 100644
--- a/core/src/test/java/dagger/UnusedProviderTest.java
+++ b/core/src/test/java/dagger/UnusedProviderTest.java
@@ -47,7 +47,7 @@
     class BagOfMoney {
     }
 
-    @Module(injects = EntryPoint.class) class TestModule {
+    @Module(injects = EntryPoint.class, library = false) class TestModule {
       @Provides BagOfMoney providesMoney() {
         return new BagOfMoney();
       }
@@ -83,7 +83,7 @@
   }
 
   @Test public void unusedSetBinding() throws Exception {
-    @Module
+    @Module(library = false)
     class TestModule {
       @Provides(type = Provides.Type.SET) String provideA() {
         throw new AssertionError();
@@ -99,7 +99,7 @@
   }
 
   @Test public void unusedSetValuesBinding() throws Exception {
-    @Module
+    @Module(library = false)
     class TestModule {
       @Provides(type = Provides.Type.SET_VALUES) Set<String> provideA() {
         throw new AssertionError();
diff --git a/pom.xml b/pom.xml
index c77a0e5f1..b40512682 100644
--- a/pom.xml
+++ b/pom.xml
@@ -49,7 +49,7 @@
     <guava.version>18.0</guava.version>
 
     <!-- Test Dependencies -->
-    <compile-testing.version>0.6-SNAPSHOT</compile-testing.version>
+    <compile-testing.version>1.0-SNAPSHOT</compile-testing.version>
     <fest.version>1.4</fest.version>
     <junit.version>4.11</junit.version>
     <mockito.version>1.9.5</mockito.version>
