diff --git a/compiler/src/it/functional-tests/src/main/java/test/ChildDoubleModule.java b/compiler/src/it/functional-tests/src/main/java/test/ChildDoubleModule.java
new file mode 100644
index 000000000..ba46f2098
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/ChildDoubleModule.java
@@ -0,0 +1,19 @@
+package test;
+
+import com.google.common.collect.ImmutableList;
+import dagger.Module;
+import dagger.Provides;
+import java.util.List;
+
+@Module
+class ChildDoubleModule extends ParentModule<Double, String, List<Double>> {
+  
+  @Provides Double provideDouble() {
+    return 3d;
+  }
+  
+  @Provides List<Double> provideListOfDouble() {
+    return ImmutableList.of(4d);
+  }
+
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/ChildIntegerModule.java b/compiler/src/it/functional-tests/src/main/java/test/ChildIntegerModule.java
new file mode 100644
index 000000000..a724cdf82
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/ChildIntegerModule.java
@@ -0,0 +1,19 @@
+package test;
+
+import com.google.common.collect.ImmutableList;
+import dagger.Module;
+import dagger.Provides;
+import java.util.List;
+
+@Module
+class ChildIntegerModule extends ParentModule<Integer, String, List<Integer>> {
+  
+  @Provides Integer provideInteger() {
+    return 1;
+  }
+  
+  @Provides List<Integer> provideListOfInteger() {
+    return ImmutableList.of(2);
+  }
+
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/GenericComponent.java b/compiler/src/it/functional-tests/src/main/java/test/GenericComponent.java
index 37b8881c6..ba441a21f 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/GenericComponent.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/GenericComponent.java
@@ -19,7 +19,7 @@
 import test.sub.Exposed;
 import test.sub.PublicSubclass;
 
-@Component
+@Component(modules = {ChildDoubleModule.class, ChildIntegerModule.class})
 interface GenericComponent {
   ReferencesGeneric referencesGeneric();
   GenericDoubleReferences<A> doubleGenericA();
@@ -33,4 +33,7 @@
 
   Exposed exposed();
   PublicSubclass publicSubclass();
+  
+  Iterable<Integer> iterableInt();
+  Iterable<Double> iterableDouble();
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/ParentModule.java b/compiler/src/it/functional-tests/src/main/java/test/ParentModule.java
new file mode 100644
index 000000000..d9958ba3f
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/ParentModule.java
@@ -0,0 +1,12 @@
+package test;
+
+import com.google.common.collect.ImmutableList;
+import dagger.Module;
+import dagger.Provides;
+
+@Module
+abstract class ParentModule<A extends Number & Comparable<A>, B, C extends Iterable<A>> {
+  @Provides Iterable<A> provideIterableOfAWithC(A a, C c) {
+    return new ImmutableList.Builder<A>().add(a).addAll(c).build();
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/test/java/test/GenericTest.java b/compiler/src/it/functional-tests/src/test/java/test/GenericTest.java
index 844f3e4a8..88be63f0e 100644
--- a/compiler/src/it/functional-tests/src/test/java/test/GenericTest.java
+++ b/compiler/src/it/functional-tests/src/test/java/test/GenericTest.java
@@ -138,4 +138,11 @@
     
     assertThat(a).isNotSameAs(b);
   }
+  
+  @Test public void genericModules() {
+    GenericComponent component = Dagger_GenericComponent.create();
+    assertThat(component.iterableInt()).containsExactly(1, 2).inOrder();
+    assertThat(component.iterableDouble()).containsExactly(3d, 4d).inOrder();
+    
+  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
index d0c1888c0..bebdd2a6b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
@@ -132,17 +132,14 @@ BindingGraph create(ComponentDescriptor componentDescriptor) {
           MoreTypes.asTypeElements(types, getComponentModules(componentAnnotation));
 
       ImmutableMap<TypeElement, ImmutableSet<TypeElement>> transitiveModules =
-          getTransitiveModules(types, moduleTypes);
+          getTransitiveModules(types, elements, moduleTypes);
       for (TypeElement module : transitiveModules.keySet()) {
         // traverse the modules, collect the bindings
         List<ExecutableElement> moduleMethods = methodsIn(elements.getAllMembers(module));
         for (ExecutableElement moduleMethod : moduleMethods) {
           if (isAnnotationPresent(moduleMethod, Provides.class)) {
-            try {
-              explicitBindingsBuilder.add(provisionBindingFactory.forProvidesMethod(moduleMethod));
-            } catch (IllegalArgumentException e) {
-              // just ignore it
-            }
+            explicitBindingsBuilder.add(
+                provisionBindingFactory.forProvidesMethod(moduleMethod, module.asType()));
           }
         }
       }
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
index 2d639c9d3..362d3f7c5 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -66,17 +66,26 @@
   private final Types types;
   private final InjectBindingRegistry injectBindingRegistry;
   private final ScopeCycleValidation disableInterComponentScopeCycles;
+  private final ProvisionBindingFormatter provisionBindingFormatter;
+  private final MethodSignatureFormatter methodSignatureFormatter;
   private final DependencyRequestFormatter dependencyRequestFormatter;
+  private final KeyFormatter keyFormatter;
 
   BindingGraphValidator(
       Types types,
       InjectBindingRegistry injectBindingRegistry,
       ScopeCycleValidation disableInterComponentScopeCycles,
-      DependencyRequestFormatter dependencyRequestFormatter) {
+      ProvisionBindingFormatter provisionBindingFormatter,
+      MethodSignatureFormatter methodSignatureFormatter,
+      DependencyRequestFormatter dependencyRequestFormatter,
+      KeyFormatter keyFormatter) {
     this.types = types;
     this.injectBindingRegistry = injectBindingRegistry;
     this.disableInterComponentScopeCycles = disableInterComponentScopeCycles;
+    this.provisionBindingFormatter = provisionBindingFormatter;
+    this.methodSignatureFormatter = methodSignatureFormatter;
     this.dependencyRequestFormatter = dependencyRequestFormatter;
+    this.keyFormatter = keyFormatter;
   }
 
   @Override
@@ -343,7 +352,7 @@ void validateComponentScope(final BindingGraph subject,
                   ExecutableElement provisionMethod =
                       MoreElements.asExecutable(provisionBinding.bindingElement());
                   incompatiblyScopedMethodsBuilder.add(
-                      MethodSignatureFormatter.instance().format(provisionMethod));
+                      methodSignatureFormatter.format(provisionMethod));
                   break;
                 case INJECTION:
                   incompatiblyScopedMethodsBuilder.add(stripCommonTypePrefixes(
@@ -415,10 +424,10 @@ private void reportDuplicateBindings(Deque<DependencyRequest> requestPath,
       ResolvedBindings resolvedBinding, ValidationReport.Builder<BindingGraph> reportBuilder) {
     StringBuilder builder = new StringBuilder();
     new Formatter(builder).format(ErrorMessages.DUPLICATE_BINDINGS_FOR_KEY_FORMAT,
-        KeyFormatter.instance().format(requestPath.peek().key()));
+        keyFormatter.format(requestPath.peek().key()));
     for (Binding binding : Iterables.limit(resolvedBinding.bindings(), DUPLICATE_SIZE_LIMIT)) {
       builder.append('\n').append(INDENT);
-      builder.append(ProvisionBindingFormatter.instance().format((ProvisionBinding) binding));
+      builder.append(provisionBindingFormatter.format((ProvisionBinding) binding));
     }
     int numberOfOtherBindings = resolvedBinding.bindings().size() - DUPLICATE_SIZE_LIMIT;
     if (numberOfOtherBindings > 0) {
@@ -436,7 +445,7 @@ private void reportMultipleBindingTypes(Deque<DependencyRequest> requestPath,
       ResolvedBindings resolvedBinding, ValidationReport.Builder<BindingGraph> reportBuilder) {
     StringBuilder builder = new StringBuilder();
     new Formatter(builder).format(ErrorMessages.MULTIPLE_BINDING_TYPES_FOR_KEY_FORMAT,
-        KeyFormatter.instance().format(requestPath.peek().key()));
+        keyFormatter.format(requestPath.peek().key()));
     @SuppressWarnings("unchecked")
     ImmutableListMultimap<BindingType, ProvisionBinding> bindingsByType =
         ProvisionBinding.bindingTypesFor((Iterable<ProvisionBinding>) resolvedBinding.bindings());
@@ -447,7 +456,7 @@ private void reportMultipleBindingTypes(Deque<DependencyRequest> requestPath,
       builder.append(" bindings:\n");
       for (ProvisionBinding binding : bindingsByType.get(type)) {
         builder.append(INDENT).append(INDENT);
-        builder.append(ProvisionBindingFormatter.instance().format(binding));
+        builder.append(provisionBindingFormatter.format(binding));
         builder.append('\n');
       }
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
index 8e75f5393..02431e5de 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
@@ -605,7 +605,7 @@ private Snippet initializeFactoryForBinding(ProvisionBinding binding,
             Lists.newArrayListWithCapacity(binding.dependencies().size() + 1);
         if (binding.bindingKind().equals(PROVISION)) {
           parameters.add(
-              Snippet.format(contributionFields.get(binding.bindingTypeElement()).name()));
+              Snippet.format(contributionFields.get(binding.contributedBy().get()).name()));
         }
         if (binding.memberInjectionRequest().isPresent()) {
           parameters.add(memberSelectSnippets.get(
@@ -613,28 +613,14 @@ private Snippet initializeFactoryForBinding(ProvisionBinding binding,
         }
         parameters.addAll(getDependencyParameters(binding.dependencies(), memberSelectSnippets));
 
-        if (binding.bindingKind().equals(PROVISION)) {
-          // Factories from @Provides methods don't have .create() methods.
-          return binding.scope().isPresent()
-              ? Snippet.format("%s.create(new %s(%s))",
-                  ClassName.fromClass(ScopedProvider.class),
-                  factoryNameForProvisionBinding(binding),
-                  Snippet.makeParametersSnippet(parameters))
-              : Snippet.format("new %s(%s)",
-                  factoryNameForProvisionBinding(binding),
-                  Snippet.makeParametersSnippet(parameters));
-        } else {
-          // Factories from @Inject classes have .create() methods.
-          return binding.scope().isPresent()
-              ? Snippet.format("%s.create(%s.create(%s))",
-                  ClassName.fromClass(ScopedProvider.class),
-                  factoryNameForProvisionBinding(binding),
-                  Snippet.makeParametersSnippet(parameters))
-              : Snippet.format("%s.create(%s)",
-                  factoryNameForProvisionBinding(binding),
-                  Snippet.makeParametersSnippet(parameters));
-        }
-
+        return binding.scope().isPresent()
+            ? Snippet.format("%s.create(%s.create(%s))",
+                ClassName.fromClass(ScopedProvider.class),
+                factoryNameForProvisionBinding(binding),
+                Snippet.makeParametersSnippet(parameters))
+            : Snippet.format("%s.create(%s)",
+                factoryNameForProvisionBinding(binding),
+                Snippet.makeParametersSnippet(parameters));
       default:
         throw new AssertionError();
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
index dbbbe057b..fdf931e71 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -66,17 +66,22 @@ public SourceVersion getSupportedSourceVersion() {
     Elements elements = processingEnv.getElementUtils();
     Filer filer = processingEnv.getFiler();
     
+    MethodSignatureFormatter methodSignatureFormatter = new MethodSignatureFormatter(types);
+    ProvisionBindingFormatter provisionBindingFormatter =
+        new ProvisionBindingFormatter(methodSignatureFormatter);
     DependencyRequestFormatter dependencyRequestFormatter = new DependencyRequestFormatter(types);
+    KeyFormatter keyFormatter = new KeyFormatter();
 
     InjectConstructorValidator injectConstructorValidator = new InjectConstructorValidator();
     InjectFieldValidator injectFieldValidator = new InjectFieldValidator();
     InjectMethodValidator injectMethodValidator = new InjectMethodValidator();
-    ModuleValidator moduleValidator = new ModuleValidator(types, Module.class, Provides.class);
+    ModuleValidator moduleValidator = new ModuleValidator(types, elements, methodSignatureFormatter,
+        Module.class, Provides.class);
     ProvidesMethodValidator providesMethodValidator = new ProvidesMethodValidator(elements);
-    ComponentValidator componentValidator = new ComponentValidator();
+    ComponentValidator componentValidator = new ComponentValidator(moduleValidator);
     MapKeyValidator mapKeyValidator = new MapKeyValidator();
-    ModuleValidator producerModuleValidator = new ModuleValidator(
-        types, ProducerModule.class, Produces.class);
+    ModuleValidator producerModuleValidator = new ModuleValidator(types, elements,
+        methodSignatureFormatter, ProducerModule.class, Produces.class);
     ProducesMethodValidator producesMethodValidator = new ProducesMethodValidator(elements);
     ProductionComponentValidator productionComponentValidator = new ProductionComponentValidator();
 
@@ -115,7 +120,10 @@ public SourceVersion getSupportedSourceVersion() {
         types,
         injectBindingRegistry,
         disableInterComponentScopeValidation(processingEnv),
-        dependencyRequestFormatter);
+        provisionBindingFormatter,
+        methodSignatureFormatter,
+        dependencyRequestFormatter,
+        keyFormatter);
 
     return ImmutableList.<ProcessingStep>of(
         new MapKeyProcessingStep(
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
index 5e15022ed..ed99925e9 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
@@ -15,18 +15,13 @@
  */
 package dagger.internal.codegen;
 
-import com.google.auto.common.MoreElements;
 import com.google.common.collect.ImmutableList;
 import dagger.Component;
-import dagger.Module;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.TypeElement;
-import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeMirror;
-import javax.lang.model.util.SimpleTypeVisitor6;
 
 import static com.google.auto.common.MoreElements.getAnnotationMirror;
-import static com.google.common.base.Preconditions.checkState;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentModules;
 import static javax.lang.model.element.ElementKind.CLASS;
 import static javax.lang.model.element.ElementKind.INTERFACE;
@@ -38,6 +33,12 @@
  * @author Gregory Kick
  */
 final class ComponentValidator implements Validator<TypeElement> {
+  private final ModuleValidator moduleValidator;
+  
+  ComponentValidator(ModuleValidator moduleValidator) {
+    this.moduleValidator = moduleValidator;
+  }
+  
   @Override public ValidationReport<TypeElement> validate(final TypeElement subject) {
     final ValidationReport.Builder<TypeElement> builder = ValidationReport.Builder.about(subject);
 
@@ -48,29 +49,7 @@
 
     AnnotationMirror componentMirror = getAnnotationMirror(subject, Component.class).get();
     ImmutableList<TypeMirror> moduleTypes = getComponentModules(componentMirror);
-
-    // TODO(gak): make unused modules an error
-    for (TypeMirror moduleType : moduleTypes) {
-      moduleType.accept(new SimpleTypeVisitor6<Void, Void>() {
-        @Override
-        protected Void defaultAction(TypeMirror mirror, Void p) {
-          builder.addItem(mirror + " is not a valid module type.", subject);
-          return null;
-        }
-
-        @Override
-        public Void visitDeclared(DeclaredType t, Void p) {
-          checkState(t.getTypeArguments().isEmpty());
-          TypeElement moduleElement = MoreElements.asType(t.asElement());
-          if (!getAnnotationMirror(moduleElement, Module.class).isPresent()) {
-            builder.addItem(moduleElement.getQualifiedName()
-                + " is listed as a module, but is not annotated with @Module", subject);
-          }
-          return null;
-        }
-      }, null);
-    }
-
+    moduleValidator.validateReferencedModules(subject, builder, moduleTypes);
     return builder.build();
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java b/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
index f60e07f35..1174af617 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
@@ -16,6 +16,7 @@
 package dagger.internal.codegen;
 
 import com.google.auto.common.AnnotationMirrors;
+import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.common.base.Function;
 import com.google.common.base.Optional;
@@ -35,7 +36,9 @@
 import javax.lang.model.element.AnnotationValue;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 
 import static com.google.auto.common.AnnotationMirrors.getAnnotationValue;
@@ -98,7 +101,8 @@
    * is not annotated with {@link Module}, it is ignored.
    */
   static ImmutableMap<TypeElement, ImmutableSet<TypeElement>> getTransitiveModules(
-      Types types, ImmutableSet<TypeElement> seedModules) {
+      Types types, Elements elements, ImmutableSet<TypeElement> seedModules) {
+    TypeMirror objectType = elements.getTypeElement(Object.class.getCanonicalName()).asType();
     Queue<TypeElement> moduleQueue = Queues.newArrayDeque(seedModules);
     Map<TypeElement, ImmutableSet<TypeElement>> moduleElements = Maps.newLinkedHashMap();
     for (TypeElement moduleElement = moduleQueue.poll();
@@ -106,8 +110,14 @@
         moduleElement = moduleQueue.poll()) {
       Optional<AnnotationMirror> moduleMirror = getAnnotationMirror(moduleElement, Module.class);
       if (moduleMirror.isPresent()) {
-        ImmutableSet<TypeElement> moduleDependencies =
-            MoreTypes.asTypeElements(types, getModuleIncludes(moduleMirror.get()));
+        ImmutableSet.Builder<TypeElement> moduleDependenciesBuilder = ImmutableSet.builder();
+        moduleDependenciesBuilder.addAll(
+            MoreTypes.asTypeElements(types, getModuleIncludes(moduleMirror.get())));
+        // (note: we don't recurse on the parent class because we don't want the parent class as a
+        // root that the component depends on, and also because we want the dependencies rooted
+        // against this element, not the parent.)
+        addIncludesFromSuperclasses(types, moduleElement, moduleDependenciesBuilder, objectType);
+        ImmutableSet<TypeElement> moduleDependencies = moduleDependenciesBuilder.build();
         moduleElements.put(moduleElement, moduleDependencies);
         for (TypeElement dependencyType : moduleDependencies) {
           if (!moduleElements.containsKey(dependencyType)) {
@@ -118,6 +128,22 @@
     }
     return ImmutableMap.copyOf(moduleElements);
   }
+  
+  /** Traverses includes from superclasses and adds them into the builder. */
+  private static void addIncludesFromSuperclasses(Types types, TypeElement element,
+      ImmutableSet.Builder<TypeElement> builder, TypeMirror objectType) {
+    // Also add the superclass to the queue, in case any @Module definitions were on that.
+    TypeMirror superclass = element.getSuperclass();
+    while(!types.isSameType(objectType, superclass)
+        && superclass.getKind().equals(TypeKind.DECLARED)) {
+      element = MoreElements.asType(types.asElement(superclass));
+      Optional<AnnotationMirror> moduleMirror = getAnnotationMirror(element, Module.class);
+      if (moduleMirror.isPresent()) {
+        builder.addAll(MoreTypes.asTypeElements(types, getModuleIncludes(moduleMirror.get())));
+      }
+      superclass = element.getSuperclass();
+    }
+  }
 
   private ConfigurationAnnotations() {}
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
index e76a01709..046fcbd7f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
@@ -140,6 +140,24 @@
   static final String BINDING_METHOD_WITH_SAME_NAME =
       "Cannot have more than one @%s method with the same name in a single module";
 
+  static final String MODULES_WITH_TYPE_PARAMS_MUST_BE_ABSTRACT =
+      "Modules with type parameters must be abstract";
+
+  static final String REFERENCED_MODULES_MUST_NOT_BE_ABSTRACT =
+      "%s is listed as a module, but is abstract";
+
+  static final String REFERENCED_MODULE_NOT_ANNOTATED =
+      "%s is listed as a module, but is not annotated with @%s";
+
+  static final String REFERENCED_MODULE_MUST_NOT_HAVE_TYPE_PARAMS =
+      "%s is listed as a module, but has type parameters";
+
+  static final String PROVIDES_METHOD_OVERRIDES_ANOTHER =
+      "@%s methods may not override another method. Overrides: %s";
+
+  static final String METHOD_OVERRIDES_PROVIDES_METHOD =
+      "@%s methods may not be overridden in modules. Overrides: %s";
+
   /*mapKey errors*/
   static final String MAPKEY_WITHOUT_FIELDS =
       "Map key annotation does not have fields";
diff --git a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
index ae441f95c..cdd986e28 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
@@ -50,7 +50,6 @@
 
 import static com.google.common.base.Preconditions.checkState;
 import static dagger.Provides.Type.SET;
-import static dagger.internal.codegen.ProvisionBinding.Kind.INJECTION;
 import static dagger.internal.codegen.ProvisionBinding.Kind.PROVISION;
 import static dagger.internal.codegen.SourceFiles.factoryNameForProvisionBinding;
 import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
@@ -128,9 +127,9 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
         constructorWriter.get().addModifiers(PUBLIC);
         factoryWriter = classWriter;
         if (binding.bindingKind().equals(PROVISION)) {
-          factoryWriter.addField(binding.bindingTypeElement(), "module")
-              .addModifiers(PRIVATE, FINAL);
-          constructorWriter.get().addParameter(binding.bindingTypeElement(), "module");
+          TypeName enclosingType = TypeNames.forTypeMirror(binding.bindingTypeElement().asType());
+          factoryWriter.addField(enclosingType, "module").addModifiers(PRIVATE, FINAL);
+          constructorWriter.get().addParameter(enclosingType, "module");
           constructorWriter.get().body()
               .addSnippet("assert module != null;")
               .addSnippet("this.module = module;");
@@ -174,41 +173,45 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
           .addSnippet("this.%1$s = %1$s;", field.name());
     }
     
-    // If constructing a factory for @Inject bindings, we use a static create method
+    // If constructing a factory for @Inject or @Provides bindings, we use a static create method
     // so that generated components can avoid having to refer to the generic types
     // of the factory.  (Otherwise they may have visibility problems referring to the types.)
-    if (binding.bindingKind().equals(INJECTION)) {
-      // The return type is usually the same as the implementing type, except in the case
-      // of enums with type variables (where we cast).
-      TypeName returnType = ParameterizedTypeName.create(ClassName.fromClass(Factory.class),
-          TypeNames.forTypeMirror(keyType));
-      MethodWriter createMethodWriter = factoryWriter.addMethod(returnType, "create");
-      createMethodWriter.addTypeParameters(typeParameters);
-      createMethodWriter.addModifiers(Modifier.PUBLIC, Modifier.STATIC);
-      Map<String, TypeName> params = constructorWriter.isPresent()
-          ? constructorWriter.get().parameters() : ImmutableMap.<String, TypeName>of();
-      for (Map.Entry<String, TypeName> param : params.entrySet()) {
-        createMethodWriter.addParameter(param.getValue(), param.getKey());      
-      }
-      switch (binding.factoryCreationStrategy()) {
-        case ENUM_INSTANCE:
-          if (typeParameters.isEmpty()) {
-            createMethodWriter.body().addSnippet(" return INSTANCE;");
-          } else {
-            // We use an unsafe cast here because the types are different.
-            // It's safe because the type is never referenced anywhere.
-            createMethodWriter.annotate(SuppressWarnings.class).setValue("unchecked");
-            createMethodWriter.body().addSnippet(" return (Factory) INSTANCE;");
-          }
-          break;
-        case CLASS_CONSTRUCTOR:
-          createMethodWriter.body().addSnippet(" return new %s(%s);",
-              parameterizedFactoryNameForProvisionBinding(binding),
-              Joiner.on(", ").join(params.keySet()));
-          break;
-        default:
-          throw new AssertionError();
-      }
+    switch(binding.bindingKind()) {
+      case INJECTION:
+      case PROVISION:
+        // The return type is usually the same as the implementing type, except in the case
+        // of enums with type variables (where we cast).
+        TypeName returnType = ParameterizedTypeName.create(ClassName.fromClass(Factory.class),
+            TypeNames.forTypeMirror(keyType));
+        MethodWriter createMethodWriter = factoryWriter.addMethod(returnType, "create");
+        createMethodWriter.addTypeParameters(typeParameters);
+        createMethodWriter.addModifiers(Modifier.PUBLIC, Modifier.STATIC);
+        Map<String, TypeName> params = constructorWriter.isPresent()
+            ? constructorWriter.get().parameters() : ImmutableMap.<String, TypeName>of();
+        for (Map.Entry<String, TypeName> param : params.entrySet()) {
+          createMethodWriter.addParameter(param.getValue(), param.getKey());      
+        }
+        switch (binding.factoryCreationStrategy()) {
+          case ENUM_INSTANCE:
+            if (typeParameters.isEmpty()) {
+              createMethodWriter.body().addSnippet("return INSTANCE;");
+            } else {
+              // We use an unsafe cast here because the types are different.
+              // It's safe because the type is never referenced anywhere.
+              createMethodWriter.annotate(SuppressWarnings.class).setValue("unchecked");
+              createMethodWriter.body().addSnippet("return (Factory) INSTANCE;");
+            }
+            break;
+          case CLASS_CONSTRUCTOR:
+            createMethodWriter.body().addSnippet("return new %s(%s);",
+                parameterizedFactoryNameForProvisionBinding(binding),
+                Joiner.on(", ").join(params.keySet()));
+            break;
+          default:
+            throw new AssertionError();
+        }
+        break;
+      default: // do nothing.
     }
 
     List<Snippet> parameters = Lists.newArrayList();
diff --git a/compiler/src/main/java/dagger/internal/codegen/Key.java b/compiler/src/main/java/dagger/internal/codegen/Key.java
index 4f93eac26..e2f1cea98 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Key.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Key.java
@@ -37,6 +37,7 @@
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.ExecutableType;
 import javax.lang.model.type.PrimitiveType;
 import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
@@ -181,12 +182,12 @@ Key forComponentMethod(ExecutableElement componentMethod) {
           MoreTypes.equivalence().wrap(returnType));
     }
 
-    Key forProvidesMethod(ExecutableElement e) {
+    Key forProvidesMethod(ExecutableType executableType, ExecutableElement e) {
       checkNotNull(e);
       checkArgument(e.getKind().equals(METHOD));
       Provides providesAnnotation = e.getAnnotation(Provides.class);
       checkArgument(providesAnnotation != null);
-      TypeMirror returnType = normalize(e.getReturnType());
+      TypeMirror returnType = normalize(executableType.getReturnType());
       switch (providesAnnotation.type()) {
         case UNIQUE:
           return new AutoValue_Key(
diff --git a/compiler/src/main/java/dagger/internal/codegen/KeyFormatter.java b/compiler/src/main/java/dagger/internal/codegen/KeyFormatter.java
index 146d03c04..7e342876e 100644
--- a/compiler/src/main/java/dagger/internal/codegen/KeyFormatter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/KeyFormatter.java
@@ -22,11 +22,6 @@
  * @since 2.0
  */
 final class KeyFormatter extends Formatter<Key> {
-  private static final KeyFormatter INSTANCE = new KeyFormatter();
-
-  static KeyFormatter instance() {
-    return INSTANCE;
-  }
 
   @Override public String format(Key request) {
     StringBuilder builder = new StringBuilder();
diff --git a/compiler/src/main/java/dagger/internal/codegen/MethodSignatureFormatter.java b/compiler/src/main/java/dagger/internal/codegen/MethodSignatureFormatter.java
index b54205990..71ddfe6d6 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MethodSignatureFormatter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MethodSignatureFormatter.java
@@ -24,8 +24,12 @@
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.ExecutableType;
 import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Types;
 
+import static com.google.common.base.Preconditions.checkState;
 import static dagger.internal.codegen.ErrorMessages.stripCommonTypePrefixes;
 
 /**
@@ -35,15 +39,28 @@
  * @since 2.0
  */
 final class MethodSignatureFormatter extends Formatter<ExecutableElement> {
-  private static final MethodSignatureFormatter INSTANCE = new MethodSignatureFormatter();
+  private final Types types;
 
-  static MethodSignatureFormatter instance() {
-    return INSTANCE;
+  MethodSignatureFormatter(Types types) {
+    this.types = types;
   }
 
   @Override public String format(ExecutableElement method) {
+    return format(method, Optional.<DeclaredType>absent());
+  }
+
+  /**
+   * Formats an ExecutableElement as if it were contained within the container, if the container is
+   * present.
+   */
+  public String format(ExecutableElement method, Optional<DeclaredType> container) {
     StringBuilder builder = new StringBuilder();
     TypeElement type = MoreElements.asType(method.getEnclosingElement());
+    ExecutableType executableType = MoreTypes.asExecutable(method.asType());
+    if (container.isPresent()) {
+      executableType = MoreTypes.asExecutable(types.asMemberOf(container.get(), method));
+      type = MoreElements.asType(container.get().asElement());
+    }
 
     // TODO(user): AnnotationMirror formatter.
     List<? extends AnnotationMirror> annotations = method.getAnnotationMirrors();
@@ -57,29 +74,32 @@ static MethodSignatureFormatter instance() {
       }
       builder.append(' ');
     }
-    builder.append(nameOfType(method.getReturnType()));
+    builder.append(nameOfType(executableType.getReturnType()));
     builder.append(' ');
     builder.append(type.getQualifiedName());
     builder.append('.');
     builder.append(method.getSimpleName());
     builder.append('(');
+    checkState(method.getParameters().size() == executableType.getParameterTypes().size());
     Iterator<? extends VariableElement> parameters = method.getParameters().iterator();
+    Iterator<? extends TypeMirror> parameterTypes = executableType.getParameterTypes().iterator();
     for (int i = 0; parameters.hasNext(); i++) {
       if (i > 0) {
         builder.append(", ");
       }
-      appendParameter(builder, parameters.next());
+      appendParameter(builder, parameters.next(), parameterTypes.next());
     }
     builder.append(')');
     return builder.toString();
   }
 
-  private static void appendParameter(StringBuilder builder, VariableElement parameter) {
+  private static void appendParameter(StringBuilder builder, VariableElement parameter,
+      TypeMirror type) {
     Optional<AnnotationMirror> qualifier = InjectionAnnotations.getQualifier(parameter);
     if (qualifier.isPresent()) {
       builder.append(ErrorMessages.format(qualifier.get())).append(' ');
     }
-    builder.append(nameOfType(parameter.asType()));
+    builder.append(nameOfType(type));
   }
 
   private static String nameOfType(TypeMirror type) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/ModuleProcessingStep.java
index a7d06a6a6..423848868 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleProcessingStep.java
@@ -113,7 +113,8 @@ public void process(SetMultimap<Class<? extends Annotation>, Element> elementsBy
               .transform(new Function<ExecutableElement, ProvisionBinding>() {
                 @Override
                 public ProvisionBinding apply(ExecutableElement providesMethod) {
-                  return provisionBindingFactory.forProvidesMethod(providesMethod);
+                  return provisionBindingFactory.forProvidesMethod(providesMethod,
+                      providesMethod.getEnclosingElement().asType());
                 }
               })
               .toSet();
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java b/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java
index 9c360e8b0..f30ef9133 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java
@@ -15,24 +15,33 @@
  */
 package dagger.internal.codegen;
 
+import com.google.auto.common.MoreElements;
 import com.google.auto.common.Visibility;
 import com.google.common.base.Function;
 import com.google.common.base.Joiner;
 import com.google.common.base.Predicate;
+import com.google.common.collect.ArrayListMultimap;
 import com.google.common.collect.FluentIterable;
-import com.google.common.collect.ImmutableListMultimap;
+import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.ListMultimap;
+import com.google.common.collect.Sets;
 import dagger.Module;
 import dagger.producers.ProducerModule;
 import java.lang.annotation.Annotation;
 import java.util.Collection;
 import java.util.List;
 import java.util.Map.Entry;
+import java.util.Set;
+import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.ElementFilter;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.SimpleTypeVisitor6;
 import javax.lang.model.util.Types;
 
 import static com.google.auto.common.MoreElements.getAnnotationMirror;
@@ -42,6 +51,13 @@
 import static com.google.auto.common.Visibility.effectiveVisibilityOfElement;
 import static dagger.internal.codegen.ConfigurationAnnotations.getModuleIncludes;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_WITH_SAME_NAME;
+import static dagger.internal.codegen.ErrorMessages.METHOD_OVERRIDES_PROVIDES_METHOD;
+import static dagger.internal.codegen.ErrorMessages.MODULES_WITH_TYPE_PARAMS_MUST_BE_ABSTRACT;
+import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_OVERRIDES_ANOTHER;
+import static dagger.internal.codegen.ErrorMessages.REFERENCED_MODULES_MUST_NOT_BE_ABSTRACT;
+import static dagger.internal.codegen.ErrorMessages.REFERENCED_MODULE_MUST_NOT_HAVE_TYPE_PARAMS;
+import static dagger.internal.codegen.ErrorMessages.REFERENCED_MODULE_NOT_ANNOTATED;
+import static javax.lang.model.element.Modifier.ABSTRACT;
 
 /**
  * A {@link Validator} for {@link Module}s or {@link ProducerModule}s.
@@ -51,43 +67,167 @@
  */
 final class ModuleValidator implements Validator<TypeElement> {
   private final Types types;
+  private final Elements elements;
   private final Class<? extends Annotation> moduleClass;
   private final Class<? extends Annotation> methodClass;
+  private final MethodSignatureFormatter methodSignatureFormatter;
 
   ModuleValidator(
       Types types,
+      Elements elements,
+      MethodSignatureFormatter methodSignatureFormatter,
       Class<? extends Annotation> moduleClass,
       Class<? extends Annotation> methodClass) {
     this.types = types;
+    this.elements = elements;
     this.moduleClass = moduleClass;
     this.methodClass = methodClass;
+    this.methodSignatureFormatter = methodSignatureFormatter;
   }
 
   @Override
-  public ValidationReport<TypeElement> validate(TypeElement subject) {
-    ValidationReport.Builder<TypeElement> builder = ValidationReport.Builder.about(subject);
-
-    validateModuleVisibility(subject, builder);
+  public ValidationReport<TypeElement> validate(final TypeElement subject) {
+    final ValidationReport.Builder<TypeElement> builder = ValidationReport.Builder.about(subject);
 
     List<ExecutableElement> moduleMethods = ElementFilter.methodsIn(subject.getEnclosedElements());
-    ImmutableListMultimap.Builder<String, ExecutableElement> bindingMethodsByName =
-        ImmutableListMultimap.builder();
+    ListMultimap<String, ExecutableElement> allMethodsByName = ArrayListMultimap.create();
+    ListMultimap<String, ExecutableElement> bindingMethodsByName = ArrayListMultimap.create();
     for (ExecutableElement moduleMethod : moduleMethods) {
       if (isAnnotationPresent(moduleMethod, methodClass)) {
         bindingMethodsByName.put(moduleMethod.getSimpleName().toString(), moduleMethod);
       }
+      allMethodsByName.put(moduleMethod.getSimpleName().toString(), moduleMethod);
     }
+      
+    validateModuleVisibility(subject, builder);
+    validateMethodsWithSameName(builder, bindingMethodsByName);
+    validateProvidesOverrides(subject, builder, allMethodsByName, bindingMethodsByName);
+    validateModifiers(subject, builder);    
+    validateReferencedModules(subject, builder);
+    
+    // TODO(gak): port the dagger 1 module validation?
+    return builder.build();
+  }
+
+  private void validateModifiers(TypeElement subject,
+      ValidationReport.Builder<TypeElement> builder) {    
+    // This coupled with the check for abstract modules in ComponentValidator guarantees that
+    // only modules without type parameters are referenced from @Component(modules={...}). 
+    if (!subject.getTypeParameters().isEmpty() && !subject.getModifiers().contains(ABSTRACT)) {
+      builder.addItem(MODULES_WITH_TYPE_PARAMS_MUST_BE_ABSTRACT, subject);
+    }
+  }
+  
+  private void validateMethodsWithSameName(ValidationReport.Builder<TypeElement> builder,
+      ListMultimap<String, ExecutableElement> bindingMethodsByName) {
     for (Entry<String, Collection<ExecutableElement>> entry :
-        bindingMethodsByName.build().asMap().entrySet()) {
+        bindingMethodsByName.asMap().entrySet()) {
       if (entry.getValue().size() > 1) {
         for (ExecutableElement offendingMethod : entry.getValue()) {
           builder.addItem(String.format(BINDING_METHOD_WITH_SAME_NAME, methodClass.getSimpleName()),
               offendingMethod);
         }
       }
+    }    
+  }
+  
+  private void validateReferencedModules(final TypeElement subject,
+      final ValidationReport.Builder<TypeElement> builder) {
+    // Validate that all the modules we include are valid for inclusion.
+    AnnotationMirror mirror = getAnnotationMirror(subject, moduleClass).get();
+    ImmutableList<TypeMirror> includedTypes = getModuleIncludes(mirror);
+    validateReferencedModules(subject,  builder, includedTypes);
+  }
+  
+  /**
+   * Used by {@link ModuleValidator} & {@link ComponentValidator} to validate referenced modules.
+   */
+  void validateReferencedModules(final TypeElement subject,
+      final ValidationReport.Builder<TypeElement> builder,
+      ImmutableList<TypeMirror> includedTypes) {
+    for (TypeMirror includedType : includedTypes) {
+      includedType.accept(new SimpleTypeVisitor6<Void, Void>() {
+        @Override
+        protected Void defaultAction(TypeMirror mirror, Void p) {
+          builder.addItem(mirror + " is not a valid module type.", subject);
+          return null;
+        }
+
+        @Override
+        public Void visitDeclared(DeclaredType t, Void p) {
+          TypeElement element = MoreElements.asType(t.asElement()); 
+          if (!t.getTypeArguments().isEmpty()) {
+            builder.addItem(String.format(REFERENCED_MODULE_MUST_NOT_HAVE_TYPE_PARAMS,
+                element.getQualifiedName()), subject);
+          }
+          if (!getAnnotationMirror(element, moduleClass).isPresent()) {
+            builder.addItem(String.format(REFERENCED_MODULE_NOT_ANNOTATED,
+                element.getQualifiedName(), moduleClass.getSimpleName()), subject);
+          }
+          if (element.getModifiers().contains(ABSTRACT)) {
+            builder.addItem(String.format(REFERENCED_MODULES_MUST_NOT_BE_ABSTRACT,
+                element.getQualifiedName()), subject);
+          }
+          return null;
+        }
+      }, null);
+    }
+  }
+  
+  private void validateProvidesOverrides(TypeElement subject,
+      ValidationReport.Builder<TypeElement> builder,
+      ListMultimap<String, ExecutableElement> allMethodsByName,
+      ListMultimap<String, ExecutableElement> bindingMethodsByName) { 
+    // For every @Provides method, confirm it overrides nothing *and* nothing overrides it.
+    // Consider the following hierarchy:
+    // class Parent {
+    //    @Provides Foo a() {}
+    //    @Provides Foo b() {}
+    //    Foo c() {}
+    // }
+    // class Child extends Parent {
+    //    @Provides Foo a() {}
+    //    Foo b() {}
+    //    @Provides Foo c() {}
+    // }
+    // In each of those cases, we want to fail.  "a" is clear, "b" because Child is overriding
+    // a method marked @Provides in Parent, and "c" because Child is defining an @Provides
+    // method that overrides Parent.
+    TypeElement currentClass = subject;
+    TypeMirror objectType = elements.getTypeElement(Object.class.getCanonicalName()).asType();
+    // We keep track of methods that failed so we don't spam with multiple failures.
+    Set<ExecutableElement> failedMethods = Sets.newHashSet();
+    while (!types.isSameType(currentClass.getSuperclass(), objectType)) {
+      currentClass = MoreElements.asType(types.asElement(currentClass.getSuperclass()));
+      List<ExecutableElement> superclassMethods =
+          ElementFilter.methodsIn(currentClass.getEnclosedElements());
+      for (ExecutableElement superclassMethod : superclassMethods) {
+        String name = superclassMethod.getSimpleName().toString();
+        // For each method in the superclass, confirm our @Provides methods don't override it
+        for (ExecutableElement providesMethod : bindingMethodsByName.get(name)) {
+          if (!failedMethods.contains(providesMethod)
+              && elements.overrides(providesMethod, superclassMethod, subject)) {
+            failedMethods.add(providesMethod);
+            builder.addItem(String.format(PROVIDES_METHOD_OVERRIDES_ANOTHER,
+                methodClass.getSimpleName(), methodSignatureFormatter.format(superclassMethod)),
+                providesMethod);
+          }
+        }
+        // For each @Provides method in superclass, confirm our methods don't override it.
+        if (isAnnotationPresent(superclassMethod, methodClass)) {
+          for (ExecutableElement method : allMethodsByName.get(name)) {
+            if (!failedMethods.contains(method)
+                && elements.overrides(method, superclassMethod, subject)) {
+              failedMethods.add(method);
+              builder.addItem(String.format(METHOD_OVERRIDES_PROVIDES_METHOD,
+                  methodClass.getSimpleName(), methodSignatureFormatter.format(superclassMethod)),
+                  method);
+            }
+          }
+        }
+        allMethodsByName.put(superclassMethod.getSimpleName().toString(), superclassMethod);
+      }
     }
-    // TODO(gak): port the dagger 1 module validation?
-    return builder.build();
   }
 
   private void validateModuleVisibility(final TypeElement moduleElement,
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
index 6298db33d..fcd2e7ec7 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
@@ -33,6 +33,7 @@
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.ExecutableType;
+import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
@@ -106,6 +107,13 @@
 
   /** If this provision requires members injection, this will be the corresponding request. */
   abstract Optional<DependencyRequest> memberInjectionRequest();
+  
+  /**
+   * If this is a provision request from an {@code @Provides} method, this will be the element that
+   * contributed it. In the case of subclassed modules, this may differ than the binding's enclosed
+   * element, as this will return the subclass whereas the enclosed element will be the superclass.
+   */
+  abstract Optional<TypeElement> contributedBy();
 
   @Override
   BindingType bindingType() {
@@ -204,7 +212,8 @@ ProvisionBinding forInjectConstructor(ExecutableElement constructorElement,
           Kind.INJECTION,
           Provides.Type.UNIQUE,
           wrapOptionalInEquivalence(AnnotationMirrors.equivalence(), scope),
-          membersInjectionRequest);
+          membersInjectionRequest,
+          Optional.<TypeElement>absent());
     }
 
     private static final ImmutableSet<ElementKind> MEMBER_KINDS =
@@ -225,14 +234,21 @@ ProvisionBinding forInjectConstructor(ExecutableElement constructorElement,
       return Optional.absent();
     }
 
-    ProvisionBinding forProvidesMethod(ExecutableElement providesMethod) {
+    ProvisionBinding forProvidesMethod(ExecutableElement providesMethod, TypeMirror contributedBy) {
       checkNotNull(providesMethod);
       checkArgument(providesMethod.getKind().equals(METHOD));
+      checkArgument(contributedBy.getKind().equals(TypeKind.DECLARED));
       Provides providesAnnotation = providesMethod.getAnnotation(Provides.class);
       checkArgument(providesAnnotation != null);
-      Key key = keyFactory.forProvidesMethod(providesMethod);
+      DeclaredType declaredContainer = MoreTypes.asDeclared(contributedBy);
+      ExecutableType resolvedMethod =
+          MoreTypes.asExecutable(types.asMemberOf(declaredContainer, providesMethod));
+      Key key = keyFactory.forProvidesMethod(resolvedMethod, providesMethod);
       ImmutableSet<DependencyRequest> dependencies =
-          dependencyRequestFactory.forRequiredVariables(providesMethod.getParameters());
+          dependencyRequestFactory.forRequiredResolvedVariables(
+              declaredContainer,
+              providesMethod.getParameters(),
+              resolvedMethod.getParameterTypes());
       Optional<AnnotationMirror> scope = getScopeAnnotation(providesMethod);
       return new AutoValue_ProvisionBinding(
           false /* not resolved */,
@@ -243,7 +259,8 @@ ProvisionBinding forProvidesMethod(ExecutableElement providesMethod) {
           Kind.PROVISION,
           providesAnnotation.type(),
           wrapOptionalInEquivalence(AnnotationMirrors.equivalence(), scope),
-          Optional.<DependencyRequest>absent());
+          Optional.<DependencyRequest>absent(),
+          Optional.of(MoreTypes.asTypeElement(types, declaredContainer)));
     }
 
     ProvisionBinding forImplicitMapBinding(DependencyRequest explicitRequest,
@@ -261,7 +278,8 @@ ProvisionBinding forImplicitMapBinding(DependencyRequest explicitRequest,
           Kind.SYNTHETIC_PROVISON,
           Provides.Type.MAP,
           wrapOptionalInEquivalence(AnnotationMirrors.equivalence(), scope),
-          Optional.<DependencyRequest>absent());
+          Optional.<DependencyRequest>absent(),
+          Optional.<TypeElement>absent());
     }
 
     ProvisionBinding forComponent(TypeElement componentDefinitionType) {
@@ -277,7 +295,8 @@ ProvisionBinding forComponent(TypeElement componentDefinitionType) {
           Kind.COMPONENT,
           Provides.Type.UNIQUE,
           Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
-          Optional.<DependencyRequest>absent());
+          Optional.<DependencyRequest>absent(),
+          Optional.<TypeElement>absent());
     }
 
     ProvisionBinding forComponentMethod(ExecutableElement componentMethod) {
@@ -294,7 +313,8 @@ ProvisionBinding forComponentMethod(ExecutableElement componentMethod) {
           Kind.COMPONENT_PROVISION,
           Provides.Type.UNIQUE,
           wrapOptionalInEquivalence(AnnotationMirrors.equivalence(), scope),
-          Optional.<DependencyRequest>absent());
+          Optional.<DependencyRequest>absent(),
+          Optional.<TypeElement>absent());
     }
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvisionBindingFormatter.java b/compiler/src/main/java/dagger/internal/codegen/ProvisionBindingFormatter.java
index b058f81c0..92d031042 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvisionBindingFormatter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvisionBindingFormatter.java
@@ -15,7 +15,10 @@
  */
 package dagger.internal.codegen;
 
+import com.google.common.base.Optional;
+
 import static com.google.auto.common.MoreElements.asExecutable;
+import static com.google.auto.common.MoreTypes.asDeclared;
 
 /**
  * Formats a {@link ProvisionBinding} into a {@link String} suitable for use in error messages.
@@ -24,17 +27,19 @@
  * @since 2.0
  */
 final class ProvisionBindingFormatter extends Formatter<ProvisionBinding> {
-  private static final ProvisionBindingFormatter INSTANCE = new ProvisionBindingFormatter();
-
-  static ProvisionBindingFormatter instance() {
-    return INSTANCE;
+  private final MethodSignatureFormatter methodSignatureFormatter;
+  
+  ProvisionBindingFormatter(MethodSignatureFormatter methodSignatureFormatter) { 
+    this.methodSignatureFormatter = methodSignatureFormatter;
   }
 
   @Override public String format(ProvisionBinding binding) {
     switch (binding.bindingKind()) {
       case PROVISION:
+        return methodSignatureFormatter.format(asExecutable(binding.bindingElement()),
+            Optional.of(asDeclared(binding.contributedBy().get().asType())));
       case COMPONENT_PROVISION:
-        return MethodSignatureFormatter.instance().format(asExecutable(binding.bindingElement()));
+        return methodSignatureFormatter.format(asExecutable(binding.bindingElement()));
       default:
         throw new UnsupportedOperationException(
             "Not yet supporting " + binding.bindingKind() + " binding types.");
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
index 42a5adef1..dcfc93101 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
@@ -16,6 +16,7 @@
 import com.google.common.base.CaseFormat;
 import com.google.common.collect.ComparisonChain;
 import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ImmutableSetMultimap;
@@ -31,6 +32,7 @@
 import dagger.internal.codegen.writer.TypeNames;
 import java.util.Collection;
 import java.util.Iterator;
+import java.util.List;
 import java.util.Map;
 import java.util.Map.Entry;
 import javax.lang.model.element.ExecutableElement;
@@ -209,18 +211,31 @@ static ClassName factoryNameForProvisionBinding(ProvisionBinding binding) {
   static TypeName parameterizedFactoryNameForProvisionBinding(
       ProvisionBinding binding) {
     ClassName factoryName = factoryNameForProvisionBinding(binding);
-    // Only parameterize injection unique bindings.
-    // Other kinds generate unique factories that have no type parameters.
-    if (binding.bindingType() == BindingType.UNIQUE
-        && binding.bindingKind() == ProvisionBinding.Kind.INJECTION) {
-      TypeName bindingName = TypeNames.forTypeMirror(binding.key().type());
-      // If the binding is parameterized, parameterize the factory.
-      if (bindingName instanceof ParameterizedTypeName) {
-        return ParameterizedTypeName.create(factoryName,
-            ((ParameterizedTypeName) bindingName).parameters());
+    List<TypeName> parameters = ImmutableList.of();
+    if (binding.bindingType().equals(BindingType.UNIQUE)) {
+      switch(binding.bindingKind()) {
+        case INJECTION:
+          TypeName bindingName = TypeNames.forTypeMirror(binding.key().type());
+          // If the binding is parameterized, parameterize the factory.
+          if (bindingName instanceof ParameterizedTypeName) {
+            parameters = ((ParameterizedTypeName) bindingName).parameters();
+          }
+          break; 
+        case PROVISION:
+          // For provision bindings, we parameterize creation on the types of
+          // the module, not the types of the binding.
+          // Consider: Module<A, B, C> { @Provides List<B> provideB(B b) { .. }}
+          // The binding is just parameterized on <B>, but we need all of <A, B, C>.
+          if (!binding.bindingTypeElement().getTypeParameters().isEmpty()) {
+            parameters = ((ParameterizedTypeName) TypeNames.forTypeMirror(
+                binding.bindingTypeElement().asType())).parameters();
+          }
+          break;
+        default: // fall through.
       }
     }
-    return factoryName;
+    return parameters.isEmpty() ? factoryName
+        : ParameterizedTypeName.create(factoryName, parameters);
   }
 
   static ClassName factoryNameForProductionBinding(ProductionBinding binding) {
diff --git a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
index 8d41a1013..ea5fd26f5 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
@@ -26,6 +26,7 @@
 import static com.google.common.truth.Truth.assertAbout;
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+import static dagger.internal.codegen.ErrorMessages.REFERENCED_MODULES_MUST_NOT_BE_ABSTRACT;
 
 @RunWith(JUnit4.class)
 public class ComponentProcessorTest {
@@ -87,6 +88,81 @@
         .withErrorContaining("is not annotated with @Module");
   }
 
+  @Test public void cannotReferToAbstractModules() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "",
+        "@Module",
+        "abstract class TestModule {}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.BadComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component(modules = TestModule.class)",
+        "interface BadComponent {}");
+    assertAbout(javaSources()).that(ImmutableList.of(moduleFile, componentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            String.format(REFERENCED_MODULES_MUST_NOT_BE_ABSTRACT, "test.TestModule"));
+  }
+  
+  @Test public void doubleBindingFromResolvedModules() {
+    JavaFileObject parent = JavaFileObjects.forSourceLines("test.ParentModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import java.util.List;",
+        "",
+        "@Module",
+        "abstract class ParentModule<A> {",
+        "  @Provides List<A> provideListB(A a) { return null; }",
+        "}");
+    JavaFileObject child = JavaFileObjects.forSourceLines("test.ChildModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "class ChildNumberModule extends ParentModule<Integer> {",
+        "  @Provides Integer provideInteger() { return null; }",
+        "}");
+    JavaFileObject another = JavaFileObjects.forSourceLines("test.AnotherModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import java.util.List;",
+        "",
+        "@Module",
+        "class AnotherModule {",
+        "  @Provides List<Integer> provideListOfInteger() { return null; }",
+        "}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.BadComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import java.util.List;",
+        "",
+        "@Component(modules = {ChildNumberModule.class, AnotherModule.class})",
+        "interface BadComponent {",
+        "  List<Integer> listOfInteger();",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(parent, child, another, componentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile().withErrorContaining(
+            "java.util.List<java.lang.Integer> is bound multiple times")
+        .and().withErrorContaining(
+            "@Provides List<Integer> test.ChildNumberModule.provideListB(Integer)")
+        .and().withErrorContaining(
+            "@Provides List<Integer> test.AnotherModule.provideListOfInteger()");
+  }
+
   @Test public void simpleComponent() {
     JavaFileObject injectableTypeFile = JavaFileObjects.forSourceLines("test.SomeInjectableType",
         "package test;",
@@ -404,7 +480,7 @@
         "  }",
         "",
         "  private void initialize() {",
-        "    this.bProvider = new TestModule$$BFactory(testModule, C$$Factory.create());",
+        "    this.bProvider = TestModule$$BFactory.create(testModule, C$$Factory.create());",
         "    this.aProvider = A$$Factory.create(bProvider);",
         "  }",
         "",
@@ -443,22 +519,62 @@
   }
 
   @Test public void transitiveModuleDeps() {
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+    JavaFileObject always = JavaFileObjects.forSourceLines("test.AlwaysIncluded",
         "package test;",
         "",
         "import dagger.Module;",
         "",
-        "@Module(includes = DepModule.class)",
-        "final class TestModule {",
-        "}");
-    JavaFileObject depModuleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "@Module",
+        "final class AlwaysIncluded {}");
+    JavaFileObject testModule = JavaFileObjects.forSourceLines("test.TestModule",
         "package test;",
         "",
         "import dagger.Module;",
         "",
-        "@Module",
-        "final class DepModule {",
-        "}");
+        "@Module(includes = {DepModule.class, AlwaysIncluded.class})",
+        "final class TestModule extends ParentTestModule {}");
+    JavaFileObject parentTest = JavaFileObjects.forSourceLines("test.ParentTestModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "",
+        "@Module(includes = {ParentTestIncluded.class, AlwaysIncluded.class})",
+        "class ParentTestModule {}");
+    JavaFileObject parentTestIncluded = JavaFileObjects.forSourceLines("test.ParentTestIncluded",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "",
+        "@Module(includes = AlwaysIncluded.class)",
+        "final class ParentTestIncluded {}");
+    JavaFileObject depModule = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "",
+        "@Module(includes = {RefByDep.class, AlwaysIncluded.class})",
+        "final class DepModule extends ParentDepModule {}");
+    JavaFileObject refByDep = JavaFileObjects.forSourceLines("test.RefByDep",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "",
+        "@Module(includes = AlwaysIncluded.class)",
+        "final class RefByDep extends ParentDepModule {}");
+    JavaFileObject parentDep = JavaFileObjects.forSourceLines("test.ParentDepModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "",
+        "@Module(includes = {ParentDepIncluded.class, AlwaysIncluded.class})",
+        "class ParentDepModule {}");
+    JavaFileObject parentDepIncluded = JavaFileObjects.forSourceLines("test.ParentDepIncluded",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "",
+        "@Module(includes = AlwaysIncluded.class)",
+        "final class ParentDepIncluded {}");
 
     JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
         "package test;",
@@ -470,6 +586,8 @@
         "@Component(modules = TestModule.class)",
         "interface TestComponent {",
         "}");
+    // Generated code includes all includes, but excludes the parent modules.
+    // The "always" module should only be listed once.
     JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
         "test.Dagger_TestComponent",
         "package test;",
@@ -480,11 +598,19 @@
         "public final class Dagger_TestComponent implements TestComponent {",
         "  private final TestModule testModule;",
         "  private final DepModule depModule;",
+        "  private final AlwaysIncluded alwaysIncluded;",
+        "  private final ParentTestIncluded parentTestIncluded;",
+        "  private final RefByDep refByDep;",
+        "  private final ParentDepIncluded parentDepIncluded;",
         "",
         "  private Dagger_TestComponent(Builder builder) {",
         "    assert builder != null;",
         "    this.testModule = builder.testModule;",
         "    this.depModule = builder.depModule;",
+        "    this.alwaysIncluded = builder.alwaysIncluded;",
+        "    this.parentTestIncluded = builder.parentTestIncluded;",
+        "    this.refByDep = builder.refByDep;",
+        "    this.parentDepIncluded = builder.parentDepIncluded;",
         "  }",
         "",
         "  public static Builder builder() {",
@@ -498,6 +624,10 @@
         "  public static final class Builder {",
         "    private TestModule testModule;",
         "    private DepModule depModule;",
+        "    private AlwaysIncluded alwaysIncluded;", 
+        "    private ParentTestIncluded parentTestIncluded;", 
+        "    private RefByDep refByDep;", 
+        "    private ParentDepIncluded parentDepIncluded;",
         "",
         "    private Builder() {",
         "    }",
@@ -509,6 +639,18 @@
         "      if (depModule == null) {",
         "        this.depModule = new DepModule();",
         "      }",
+        "      if (alwaysIncluded == null) {", 
+        "        this.alwaysIncluded = new AlwaysIncluded();", 
+        "      }", 
+        "      if (parentTestIncluded == null) {", 
+        "        this.parentTestIncluded = new ParentTestIncluded();", 
+        "      }", 
+        "      if (refByDep == null) {", 
+        "        this.refByDep = new RefByDep();", 
+        "      }", 
+        "      if (parentDepIncluded == null) {", 
+        "        this.parentDepIncluded = new ParentDepIncluded();", 
+        "      }",
         "      return new Dagger_TestComponent(this);",
         "    }",
         "",
@@ -527,10 +669,50 @@
         "      this.depModule = depModule;",
         "      return this;",
         "    }",
+        "",
+        "    public Builder alwaysIncluded(AlwaysIncluded alwaysIncluded) {",
+        "      if (alwaysIncluded == null) {",
+        "        throw new NullPointerException(\"alwaysIncluded\");",
+        "      }",
+        "      this.alwaysIncluded = alwaysIncluded;",
+        "      return this;",
+        "    }",
+        "",
+        "    public Builder parentTestIncluded(ParentTestIncluded parentTestIncluded) {",
+        "      if (parentTestIncluded == null) {",
+        "        throw new NullPointerException(\"parentTestIncluded\");",
+        "      }",
+        "      this.parentTestIncluded = parentTestIncluded;",
+        "      return this;",
+        "    }",
+        "",
+        "    public Builder refByDep(RefByDep refByDep) {",
+        "      if (refByDep == null) {",
+        "        throw new NullPointerException(\"refByDep\");",
+        "      }",
+        "      this.refByDep = refByDep;",
+        "      return this;",
+        "    }",
+        "",
+        "    public Builder parentDepIncluded(ParentDepIncluded parentDepIncluded) {",
+        "      if (parentDepIncluded == null) {",
+        "        throw new NullPointerException(\"parentDepIncluded\");",
+        "      }",
+        "      this.parentDepIncluded = parentDepIncluded;",
+        "      return this;",
+        "    }",
         "  }",
         "}");
     assertAbout(javaSources())
-        .that(ImmutableList.of(moduleFile, depModuleFile, componentFile))
+        .that(ImmutableList.of(always,
+            testModule,
+            parentTest,
+            parentTestIncluded,
+            depModule,
+            refByDep,
+            parentDep,
+            parentDepIncluded,
+            componentFile))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and().generatesSources(generatedComponent);
@@ -609,8 +791,8 @@
         "",
         "  private void initialize() {",
         "    this.setOfStringContribution1Provider =",
-        "        new EmptySetModule$$EmptySetFactory(emptySetModule);",
-        "    this.setOfStringContribution2Provider = new SetModule$$StringFactory(setModule);",
+        "        EmptySetModule$$EmptySetFactory.create(emptySetModule);",
+        "    this.setOfStringContribution2Provider = SetModule$$StringFactory.create(setModule);",
         "    this.setOfStringProvider = SetFactory.create(",
         "        setOfStringContribution1Provider, setOfStringContribution2Provider);",
         "  }",
@@ -1166,8 +1348,8 @@
         "  }",
         "",
         "  private void initialize() {",
-        "    this.aProvider = new test.TestModule$$AFactory(testModule);",
-        "    this.aProvider1 = new TestModule$$AFactory(testModule1);",
+        "    this.aProvider = test.TestModule$$AFactory.create(testModule);",
+        "    this.aProvider1 = TestModule$$AFactory.create(testModule1);",
         "  }",
         "",
         "  @Override",
@@ -1646,6 +1828,7 @@
  
   @Test
   @Ignore // modify this test as necessary while debugging for your situation.
+  @SuppressWarnings("unused")
   public void genericTestToLetMeDebugInEclipse() {
     JavaFileObject aFile = JavaFileObjects.forSourceLines("test.A",
         "package test;",
diff --git a/compiler/src/test/java/dagger/internal/codegen/KeyTest.java b/compiler/src/test/java/dagger/internal/codegen/KeyTest.java
index 2e5f216a2..c6d283670 100644
--- a/compiler/src/test/java/dagger/internal/codegen/KeyTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/KeyTest.java
@@ -32,6 +32,7 @@
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.ExecutableType;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.ElementFilter;
 import javax.lang.model.util.Elements;
@@ -86,7 +87,8 @@
         elements.getTypeElement(ProvidesMethodModule.class.getCanonicalName());
     ExecutableElement providesMethod =
         Iterables.getOnlyElement(ElementFilter.methodsIn(moduleElement.getEnclosedElements()));
-    assertThat(keyFactory.forProvidesMethod(providesMethod))
+    assertThat(
+        keyFactory.forProvidesMethod((ExecutableType) providesMethod.asType(), providesMethod))
         .isEqualTo(new AutoValue_Key(
             Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
             MoreTypes.equivalence().wrap(stringType)));
@@ -107,7 +109,8 @@
         elements.getTypeElement(QualifiedProvidesMethodModule.class.getCanonicalName());
     ExecutableElement providesMethod =
         Iterables.getOnlyElement(ElementFilter.methodsIn(moduleElement.getEnclosedElements()));
-    Key key = keyFactory.forProvidesMethod(providesMethod);
+    Key key =
+        keyFactory.forProvidesMethod((ExecutableType) providesMethod.asType(), providesMethod);
     assertThat(MoreTypes.equivalence().wrap(key.qualifier().get().getAnnotationType()))
         .isEqualTo(MoreTypes.equivalence().wrap(qualifierElement.asType()));
     assertThat(key.wrappedType()).isEqualTo(MoreTypes.equivalence().wrap(stringType));
@@ -118,7 +121,8 @@
         elements.getTypeElement(QualifiedProvidesMethodModule.class.getCanonicalName());
     ExecutableElement providesMethod =
         Iterables.getOnlyElement(ElementFilter.methodsIn(moduleElement.getEnclosedElements()));
-    Key provisionKey = keyFactory.forProvidesMethod(providesMethod);
+    Key provisionKey =
+        keyFactory.forProvidesMethod((ExecutableType) providesMethod.asType(), providesMethod);
 
     TypeMirror type = elements.getTypeElement(String.class.getCanonicalName()).asType();
     TypeElement injectableElement =
@@ -159,7 +163,8 @@ String provideQualifiedString() {
         elements.getTypeElement(SetProvidesMethodsModule.class.getCanonicalName());
     for (ExecutableElement providesMethod
         : ElementFilter.methodsIn(moduleElement.getEnclosedElements())) {
-      assertThat(keyFactory.forProvidesMethod(providesMethod))
+      assertThat(
+          keyFactory.forProvidesMethod((ExecutableType) providesMethod.asType(), providesMethod))
           .isEqualTo(new AutoValue_Key(
               Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
               MoreTypes.equivalence().wrap(setOfStringsType)));
@@ -207,8 +212,9 @@ String provideQualifiedString() {
     assertThat(integerType.getKind().isPrimitive()).isFalse();
     assertThat(types.isSameType(intType, integerType)).named("type equality").isFalse();
 
-    Key intKey = keyFactory.forProvidesMethod(intMethod);
-    Key integerKey = keyFactory.forProvidesMethod(integerMethod);
+    Key intKey = keyFactory.forProvidesMethod((ExecutableType) intMethod.asType(), intMethod);
+    Key integerKey =
+        keyFactory.forProvidesMethod((ExecutableType) integerMethod.asType(), integerMethod);
     assertThat(intKey).isEqualTo(integerKey);
   }
 
diff --git a/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java
index 6ca89f8e4..4128b6828 100644
--- a/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java
@@ -142,9 +142,9 @@ public void mapBindingsWithEnumKey() {
         "",
         "  private void initialize() {",
         "    this.mapOfPathEnumAndProviderOfHandlerContribution1 =",
-        "        new MapModuleOne$$ProvideAdminHandlerFactory(mapModuleOne);",
+        "        MapModuleOne$$ProvideAdminHandlerFactory.create(mapModuleOne);",
         "    this.mapOfPathEnumAndProviderOfHandlerContribution2 =",
-        "        new MapModuleTwo$$ProvideLoginHandlerFactory(mapModuleTwo);",
+        "        MapModuleTwo$$ProvideLoginHandlerFactory.create(mapModuleTwo);",
         "    this.mapOfPathEnumAndProviderOfHandlerProvider =",
         "        MapProviderFactory.<PathEnum, Handler>builder(2)",
         "            .put(test.PathEnum.ADMIN,",
@@ -314,9 +314,9 @@ public void mapBindingsWithStringKey() {
         "",
         "  private void initialize() {",
         "    this.mapOfStringAndProviderOfHandlerContribution1 =",
-        "        new MapModuleOne$$ProvideAdminHandlerFactory(mapModuleOne);",
+        "        MapModuleOne$$ProvideAdminHandlerFactory.create(mapModuleOne);",
         "    this.mapOfStringAndProviderOfHandlerContribution2 =",
-        "        new MapModuleTwo$$ProvideLoginHandlerFactory(mapModuleTwo);",
+        "        MapModuleTwo$$ProvideLoginHandlerFactory.create(mapModuleTwo);",
         "    this.mapOfStringAndProviderOfHandlerProvider =",
         "        MapProviderFactory.<String, Handler>builder(2)",
         "            .put(\"Admin\", mapOfStringAndProviderOfHandlerContribution1)",
@@ -488,9 +488,9 @@ public void mapBindingsWithNonProviderValue() {
         "",
         "  private void initialize() {",
         "    this.mapOfPathEnumAndProviderOfHandlerContribution1 =",
-        "        new MapModuleOne$$ProvideAdminHandlerFactory(mapModuleOne);",
+        "        MapModuleOne$$ProvideAdminHandlerFactory.create(mapModuleOne);",
         "    this.mapOfPathEnumAndProviderOfHandlerContribution2 =",
-        "        new MapModuleTwo$$ProvideLoginHandlerFactory(mapModuleTwo);",
+        "        MapModuleTwo$$ProvideLoginHandlerFactory.create(mapModuleTwo);",
         "    this.mapOfPathEnumAndProviderOfHandlerProvider =",
         "        MapProviderFactory.<PathEnum, Handler>builder(2)",
         "            .put(test.PathEnum.ADMIN,",
@@ -612,7 +612,7 @@ public void injectMapWithoutMapBinding() {
         "  }",
         "",
         "  private void initialize() {",
-        "    this.provideAMapProvider = new MapModule$$ProvideAMapFactory(mapModule);",
+        "    this.provideAMapProvider = MapModule$$ProvideAMapFactory.create(mapModule);",
         "  }",
         "",
         "  @Override",
diff --git a/compiler/src/test/java/dagger/internal/codegen/MapKeyProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/MapKeyProcessorTest.java
index ed0d99322..1b9fd0f12 100644
--- a/compiler/src/test/java/dagger/internal/codegen/MapKeyProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/MapKeyProcessorTest.java
@@ -183,9 +183,9 @@ public void mapKeyComponentFileWithDisorderedKeyField() {
         "",
         "  private void initialize() {",
         "    this.mapOfPathKeyAndProviderOfHandlerContribution1 =",
-        "        new MapModuleOne$$ProvideAdminHandlerFactory(mapModuleOne);",
+        "        MapModuleOne$$ProvideAdminHandlerFactory.create(mapModuleOne);",
         "    this.mapOfPathKeyAndProviderOfHandlerContribution2 =",
-        "        new MapModuleTwo$$ProvideLoginHandlerFactory(mapModuleTwo);",
+        "        MapModuleTwo$$ProvideLoginHandlerFactory.create(mapModuleTwo);",
         "    this.mapOfPathKeyAndProviderOfHandlerProvider =",
         "        MapProviderFactory.<PathKey, Handler>builder(2)",
         "            .put(PathKeyCreator.create(PathEnum.ADMIN, \"AdminPath\"),",
@@ -361,9 +361,9 @@ public void mapKeyComponentFileWithDefaultField() {
         "",
         "  private void initialize() {",
         "    this.mapOfPathKeyAndProviderOfHandlerContribution1 =",
-        "        new MapModuleOne$$ProvideAdminHandlerFactory(mapModuleOne);",
+        "        MapModuleOne$$ProvideAdminHandlerFactory.create(mapModuleOne);",
         "    this.mapOfPathKeyAndProviderOfHandlerContribution2 =",
-        "        new MapModuleTwo$$ProvideLoginHandlerFactory(mapModuleTwo);",
+        "        MapModuleTwo$$ProvideLoginHandlerFactory.create(mapModuleTwo);",
         "    this.mapOfPathKeyAndProviderOfHandlerProvider =",
         "        MapProviderFactory.<PathKey, Handler>builder(2)",
         "            .put(PathKeyCreator.create(PathEnum.ADMIN, \"DefaultPath\"),",
diff --git a/compiler/src/test/java/dagger/internal/codegen/MethodSignatureFormatterTest.java b/compiler/src/test/java/dagger/internal/codegen/MethodSignatureFormatterTest.java
index 440c486fb..45791c75c 100644
--- a/compiler/src/test/java/dagger/internal/codegen/MethodSignatureFormatterTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/MethodSignatureFormatterTest.java
@@ -51,7 +51,7 @@
     Elements elements = compilationRule.getElements();
     TypeElement inner = elements.getTypeElement(InnerClass.class.getCanonicalName());
     ExecutableElement method = Iterables.getOnlyElement(methodsIn(inner.getEnclosedElements()));
-    String formatted = MethodSignatureFormatter.instance().format(method);
+    String formatted = new MethodSignatureFormatter(compilationRule.getTypes()).format(method);
     // This is gross, but it turns out that annotation order is not guaranteed when getting
     // all the AnnotationMirrors from an Element, so I have to test this chopped-up to make it
     // less brittle.
diff --git a/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java b/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
index a19b6e31e..5f1ca10fd 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
@@ -22,7 +22,7 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import static com.google.common.truth.Truth.assert_;
+import static com.google.common.truth.Truth.assertAbout;
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_ABSTRACT;
@@ -33,6 +33,7 @@
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_STATIC;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_TYPE_PARAMETER;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_WITH_SAME_NAME;
+import static dagger.internal.codegen.ErrorMessages.MODULES_WITH_TYPE_PARAMS_MUST_BE_ABSTRACT;
 import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_RETURN_TYPE;
 import static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_SET_VALUES_RETURN_SET;
 
@@ -60,7 +61,7 @@ private String formatModuleErrorMessage(String msg) {
         "    return \"\";",
         "  }",
         "}");
-    assert_().about(javaSource()).that(moduleFile)
+    assertAbout(javaSource()).that(moduleFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(formatModuleErrorMessage(BINDING_METHOD_NOT_IN_MODULE));
@@ -77,7 +78,7 @@ private String formatModuleErrorMessage(String msg) {
         "abstract class TestModule {",
         "  @Provides abstract String provideString();",
         "}");
-    assert_().about(javaSource()).that(moduleFile)
+    assertAbout(javaSource()).that(moduleFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(formatErrorMessage(BINDING_METHOD_ABSTRACT));
@@ -96,7 +97,7 @@ private String formatModuleErrorMessage(String msg) {
         "    return \"\";",
         "  }",
         "}");
-    assert_().about(javaSource()).that(moduleFile)
+    assertAbout(javaSource()).that(moduleFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(formatErrorMessage(BINDING_METHOD_PRIVATE));
@@ -115,7 +116,7 @@ private String formatModuleErrorMessage(String msg) {
         "    return \"\";",
         "  }",
         "}");
-    assert_().about(javaSource()).that(moduleFile)
+    assertAbout(javaSource()).that(moduleFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(formatErrorMessage(BINDING_METHOD_STATIC));
@@ -132,7 +133,7 @@ private String formatModuleErrorMessage(String msg) {
         "final class TestModule {",
         "  @Provides void provideNothing() {}",
         "}");
-    assert_().about(javaSource()).that(moduleFile)
+    assertAbout(javaSource()).that(moduleFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(formatErrorMessage(BINDING_METHOD_MUST_RETURN_A_VALUE));
@@ -151,7 +152,7 @@ private String formatModuleErrorMessage(String msg) {
         "    return \"\";",
         "  }",
         "}");
-    assert_().about(javaSource()).that(moduleFile)
+    assertAbout(javaSource()).that(moduleFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(formatErrorMessage(BINDING_METHOD_TYPE_PARAMETER));
@@ -174,7 +175,7 @@ private String formatModuleErrorMessage(String msg) {
         "    return null;",
         "  }",
         "}");
-    assert_().about(javaSource()).that(moduleFile)
+    assertAbout(javaSource()).that(moduleFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(PROVIDES_METHOD_RETURN_TYPE);
@@ -197,7 +198,7 @@ private String formatModuleErrorMessage(String msg) {
         "    return null;",
         "  }",
         "}");
-    assert_().about(javaSource()).that(moduleFile)
+    assertAbout(javaSource()).that(moduleFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(formatErrorMessage(BINDING_METHOD_SET_VALUES_RAW_SET));
@@ -220,12 +221,146 @@ private String formatModuleErrorMessage(String msg) {
         "    return null;",
         "  }",
         "}");
-    assert_().about(javaSource()).that(moduleFile)
+    assertAbout(javaSource()).that(moduleFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(PROVIDES_METHOD_SET_VALUES_RETURN_SET);
   }
 
+  @Test public void modulesWithTypeParamsMustBeAbstract() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "final class TestModule<A> {}");
+    assertAbout(javaSource()).that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(MODULES_WITH_TYPE_PARAMS_MUST_BE_ABSTRACT);
+  }
+
+  @Test public void provideOverriddenByNoProvide() {
+    JavaFileObject parent = JavaFileObjects.forSourceLines("test.Parent",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "class Parent {",
+        "  @Provides String foo() { return null; }",
+        "}");
+    JavaFileObject child = JavaFileObjects.forSourceLines("test.Child",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "",
+        "@Module",
+        "class Child extends Parent{",
+        "  String foo() { return null; }",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(parent, child))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(String.format(ErrorMessages.METHOD_OVERRIDES_PROVIDES_METHOD,
+            "Provides", "@Provides String test.Parent.foo()"));
+  }
+
+  @Test public void provideOverriddenByProvide() {
+    JavaFileObject parent = JavaFileObjects.forSourceLines("test.Parent",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "class Parent {",
+        "  @Provides String foo() { return null; }",
+        "}");
+    JavaFileObject child = JavaFileObjects.forSourceLines("test.Child",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "class Child extends Parent{",
+        "  @Provides String foo() { return null; }",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(parent, child))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(String.format(ErrorMessages.PROVIDES_METHOD_OVERRIDES_ANOTHER,
+            "Provides", "@Provides String test.Parent.foo()"));
+  }
+
+  @Test public void providesOverridesNonProvides() {
+    JavaFileObject parent = JavaFileObjects.forSourceLines("test.Parent",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "",
+        "@Module",
+        "class Parent {",
+        "  String foo() { return null; }",
+        "}");
+    JavaFileObject child = JavaFileObjects.forSourceLines("test.Child",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "class Child extends Parent{",
+        "  @Provides String foo() { return null; }",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(parent, child))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(String.format(ErrorMessages.PROVIDES_METHOD_OVERRIDES_ANOTHER,
+            "Provides", "String test.Parent.foo()"));
+  }
+
+  @Test public void validatesIncludedModules() {
+    JavaFileObject module = JavaFileObjects.forSourceLines("test.Parent",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "",
+        "@Module(includes = Void.class)",
+        "class TestModule {}");
+    assertAbout(javaSources()).that(ImmutableList.of(module))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(String.format(ErrorMessages.REFERENCED_MODULE_NOT_ANNOTATED,
+            "java.lang.Void", "Module"));
+  }
+
+  @Test public void referencedModulesMustNotBeAbstract() {
+    JavaFileObject module = JavaFileObjects.forSourceLines("test.Parent",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "",
+        "@Module(includes = AbstractModule.class)",
+        "class TestModule {}");
+    JavaFileObject abstractModule = JavaFileObjects.forSourceLines("test.AbstractModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "",
+        "@Module",
+        "abstract class AbstractModule {}");
+    assertAbout(javaSources()).that(ImmutableList.of(module, abstractModule))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(String.format(ErrorMessages.REFERENCED_MODULES_MUST_NOT_BE_ABSTRACT,
+            "test.AbstractModule"));
+  }
+
   @Test public void singleProvidesMethodNoArgs() {
     JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
         "package test;",
@@ -257,8 +392,12 @@ private String formatModuleErrorMessage(String msg) {
         "  @Override public String get() {",
         "    return module.provideString();",
         "  }",
+        "",
+        "  public static Factory<String> create(TestModule module) {",
+        "    return new TestModule$$ProvideStringFactory(module);",
+        "  }",
         "}");
-    assert_().about(javaSource()).that(moduleFile)
+    assertAbout(javaSource()).that(moduleFile)
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and().generatesSources(factoryFile);
@@ -348,8 +487,17 @@ private String formatModuleErrorMessage(String msg) {
         "  @Override public List<Object> get() {",
         "    return module.provideObjects(aProvider.get(), bProvider.get(), xMembersInjector);",
         "  }",
+        "",
+        "  public static Factory<List<Object>> create(",
+        "      TestModule module,",
+        "      Provider<Object> aProvider,",
+        "      Provider<Object> bProvider,",
+        "      MembersInjector<X> xMembersInjector) {",
+        "    return new TestModule$$ProvideObjectsFactory(",
+        "        module, aProvider, bProvider, xMembersInjector);",
+        "  }",
         "}");
-    assert_().about(javaSources()).that(
+    assertAbout(javaSources()).that(
             ImmutableList.of(classXFile, moduleFile, QUALIFIER_A, QUALIFIER_B))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
@@ -392,8 +540,12 @@ private String formatModuleErrorMessage(String msg) {
         "  @Override public Set<String> get() {",
         "    return Collections.singleton(module.provideString());",
         "  }",
+        "",
+        "  public static Factory<Set<String>> create(TestModule module) {",
+        "    return new TestModule$$ProvideStringFactory(module);",
+        "  }",
         "}");
-    assert_().about(javaSource()).that(moduleFile)
+    assertAbout(javaSource()).that(moduleFile)
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and().generatesSources(factoryFile);
@@ -434,8 +586,12 @@ private String formatModuleErrorMessage(String msg) {
         "  @Override public Set<String> get() {",
         "    return module.provideStrings();",
         "  }",
+        "",
+        "  public static Factory<Set<String>> create(TestModule module) {",
+        "    return new TestModule$$ProvideStringsFactory(module);",
+        "  }",
         "}");
-    assert_().about(javaSource()).that(moduleFile)
+    assertAbout(javaSource()).that(moduleFile)
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and().generatesSources(factoryFile);
@@ -458,7 +614,7 @@ private String formatModuleErrorMessage(String msg) {
         "    return \"\";",
         "  }",
         "}");
-    assert_().about(javaSource()).that(moduleFile)
+    assertAbout(javaSource()).that(moduleFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
     .withErrorContaining(formatErrorMessage(BINDING_METHOD_WITH_SAME_NAME)).in(moduleFile).onLine(8)
@@ -502,7 +658,7 @@ public void providedTypes() {
         "    return null;",
         "  }",
         "}");
-    assert_().about(javaSource()).that(moduleFile)
+    assertAbout(javaSource()).that(moduleFile)
         .processedWith(new ComponentProcessor())
         .compilesWithoutError();
   }
@@ -518,7 +674,7 @@ public void privateModule() {
         "  @Module private static final class PrivateModule {",
         "  }",
         "}");
-    assert_().about(javaSource())
+    assertAbout(javaSource())
         .that(moduleFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
@@ -539,7 +695,7 @@ public void enclosedInPrivateModule() {
         "    }",
         "  }",
         "}");
-    assert_().about(javaSource())
+    assertAbout(javaSource())
         .that(moduleFile)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
@@ -583,7 +739,7 @@ public void publicModuleNonPublicIncludes() {
         "@Module",
         "public final class OtherPublicModule {",
         "}");
-    assert_().about(javaSources())
+    assertAbout(javaSources())
         .that(ImmutableList.of(
             publicModuleFile, nonPublicModule1File, nonPublicModule2File, otherPublicModuleFile))
         .processedWith(new ComponentProcessor())
@@ -594,4 +750,145 @@ public void publicModuleNonPublicIncludes() {
             + "test.NonPublicModule1 and test.NonPublicModule2 public.")
         .in(publicModuleFile).onLine(8);
   }
+  
+  @Test
+  public void genericSubclassedModule() {
+    JavaFileObject parent = JavaFileObjects.forSourceLines("test.ParentModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import java.util.List;",
+        "import java.util.ArrayList;",
+        "",
+        "@Module",
+        "abstract class ParentModule<A extends CharSequence,",
+        "                            B,",
+        "                            C extends Number & Comparable<C>> {",
+        "  @Provides List<B> provideListB(B b) {",
+        "    List<B> list = new ArrayList<B>();",
+        "    list.add(b);",
+        "    return list;",
+        "  }",
+        "}");
+    JavaFileObject numberChild = JavaFileObjects.forSourceLines("test.ChildNumberModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "class ChildNumberModule extends ParentModule<String, Number, Double> {",
+        "  @Provides Number provideNumber() { return 1; }",
+        "}");
+    JavaFileObject integerChild = JavaFileObjects.forSourceLines("test.ChildIntegerModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "class ChildIntegerModule extends ParentModule<StringBuilder, Integer, Float> {",
+        "  @Provides Integer provideInteger() { return 2; }",
+        "}");
+    JavaFileObject component = JavaFileObjects.forSourceLines("test.C",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import java.util.List;",
+        "",
+        "@Component(modules={ChildNumberModule.class, ChildIntegerModule.class})",
+        "interface C {",
+        "  List<Number> numberList();",
+        "  List<Integer> integerList();",
+        "}");
+    JavaFileObject listBFactory = JavaFileObjects.forSourceLines(
+        "test.ParentModule$$ProvidesListBFactory",
+        "package test;", 
+        "", 
+        "import dagger.Factory;", 
+        "import java.util.List;", 
+        "import javax.annotation.Generated;", 
+        "import javax.inject.Provider;", 
+        "", 
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")", 
+        "public final class ParentModule$$ProvideListBFactory<A extends CharSequence,",
+        "    B, C extends Number & Comparable<C>> implements Factory<List<B>> {", 
+        "  private final ParentModule<A, B, C> module;", 
+        "  private final Provider<B> bProvider;", 
+        "", 
+        "  public ParentModule$$ProvideListBFactory(",
+        "        ParentModule<A, B, C> module, Provider<B> bProvider) {", 
+        "    assert module != null;", 
+        "    this.module = module;", 
+        "    assert bProvider != null;", 
+        "    this.bProvider = bProvider;", 
+        "  }", 
+        "", 
+        "  @Override", 
+        "  public List<B> get() {  ", 
+        "    return module.provideListB(bProvider.get());", 
+        "  }", 
+        "", 
+        "  public static <A extends CharSequence, B, C extends Number & Comparable<C>>",
+        "      Factory<List<B>> create(ParentModule<A, B, C> module, Provider<B> bProvider) {",
+        "    return new ParentModule$$ProvideListBFactory<A, B, C>(module, bProvider);", 
+        "  }", 
+        "}");
+    JavaFileObject numberFactory = JavaFileObjects.forSourceLines(
+        "test.ChildNumberModule$$ProvideNumberFactory",
+        "package test;",
+        "",
+        "import dagger.Factory;",
+        "import javax.annotation.Generated;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class ChildNumberModule$$ProvideNumberFactory implements Factory<Number> {",
+        "  private final ChildNumberModule module;",
+        "",
+        "  public ChildNumberModule$$ProvideNumberFactory(ChildNumberModule module) {",
+        "    assert module != null;",
+        "    this.module = module;",
+        "  }",
+        "",
+        "  @Override",
+        "  public Number get() {  ",
+        "    return module.provideNumber();",
+        "  }",
+        "",
+        "  public static Factory<Number> create(ChildNumberModule module) {",
+        "    return new ChildNumberModule$$ProvideNumberFactory(module);",
+        "  }",
+        "}");
+    JavaFileObject integerFactory = JavaFileObjects.forSourceLines(
+        "test.ChildIntegerModule$$ProvideIntegerFactory",
+        "package test;",
+        "",
+        "import dagger.Factory;",
+        "import javax.annotation.Generated;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class ChildIntegerModule$$ProvideIntegerFactory",
+        "    implements Factory<Integer> {",
+        "  private final ChildIntegerModule module;",
+        "",
+        "  public ChildIntegerModule$$ProvideIntegerFactory(ChildIntegerModule module) {",
+        "    assert module != null;",
+        "    this.module = module;",
+        "  }",
+        "",
+        "  @Override",
+        "  public Integer get() {  ",
+        "    return module.provideInteger();",
+        "  }",
+        "",
+        "  public static Factory<Integer> create(ChildIntegerModule module) {",
+        "    return new ChildIntegerModule$$ProvideIntegerFactory(module);",
+        "  }",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(parent, numberChild, integerChild, component))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(listBFactory, numberFactory, integerFactory);
+  }
 }
diff --git a/compiler/src/test/java/dagger/tests/integration/operation/PrimitiveInjectionTest.java b/compiler/src/test/java/dagger/tests/integration/operation/PrimitiveInjectionTest.java
index 427762409..9a561e9ad 100644
--- a/compiler/src/test/java/dagger/tests/integration/operation/PrimitiveInjectionTest.java
+++ b/compiler/src/test/java/dagger/tests/integration/operation/PrimitiveInjectionTest.java
@@ -95,7 +95,8 @@
       "  }",
       "",
       "  private void initialize() {",
-      "    this.primitiveIntProvider = new PrimitiveModule$$PrimitiveIntFactory(primitiveModule);",
+      "    this.primitiveIntProvider =",
+      "        PrimitiveModule$$PrimitiveIntFactory.create(primitiveModule);",
       "    this.primitiveInjectableProvider =",
       "        PrimitiveInjectable$$Factory.create(primitiveIntProvider);",
       "  }",
