diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/ThreadAccumulator.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/ThreadAccumulator.java
new file mode 100644
index 000000000..2eb4abda7
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/ThreadAccumulator.java
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package producerstest.monitoring;
+
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+import javax.inject.Inject;
+import javax.inject.Singleton;
+
+@Singleton
+final class ThreadAccumulator {
+  private final Map<String, Long> threadIds = new ConcurrentHashMap<>();
+
+  @Inject
+  ThreadAccumulator() {}
+
+  void markThread(String name) {
+    threadIds.put(name, Thread.currentThread().getId());
+  }
+
+  long threadId(String name) {
+    return threadIds.get(name);
+  }
+}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/ThreadModule.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/ThreadModule.java
new file mode 100644
index 000000000..431ffd93c
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/ThreadModule.java
@@ -0,0 +1,48 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package producerstest.monitoring;
+
+import dagger.producers.Producer;
+import dagger.producers.ProducerModule;
+import dagger.producers.Produces;
+import producerstest.monitoring.ThreadQualifiers.Deferred;
+import producerstest.monitoring.ThreadQualifiers.EntryPoint;
+import producerstest.monitoring.ThreadQualifiers.Required;
+
+@ProducerModule
+final class ThreadModule {
+  @Produces
+  @Deferred
+  Object deferred(ThreadAccumulator acc) {
+    acc.markThread("deferred");
+    return new Object();
+  }
+
+  @Produces
+  @Required
+  Object required(@Deferred Producer<Object> o, ThreadAccumulator acc) {
+    acc.markThread("required");
+    return o.get();
+  }
+
+  @Produces
+  @EntryPoint
+  ThreadAccumulator entryPoint(@Required Object o, ThreadAccumulator acc) {
+    acc.markThread("entryPoint");
+    return acc;
+  }
+}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/ThreadMonitoredComponent.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/ThreadMonitoredComponent.java
new file mode 100644
index 000000000..bc565feaa
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/ThreadMonitoredComponent.java
@@ -0,0 +1,30 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package producerstest.monitoring;
+
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.producers.ProductionComponent;
+import javax.inject.Singleton;
+import producerstest.ExecutorModule;
+import producerstest.monitoring.ThreadQualifiers.EntryPoint;
+
+@Singleton
+@ProductionComponent(modules = {ExecutorModule.class, MonitoringModule.class, ThreadModule.class})
+interface ThreadMonitoredComponent {
+  @EntryPoint
+  ListenableFuture<ThreadAccumulator> threadAccumulator();
+}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/ThreadQualifiers.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/ThreadQualifiers.java
new file mode 100644
index 000000000..bfd415094
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/ThreadQualifiers.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package producerstest.monitoring;
+
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import javax.inject.Qualifier;
+
+final class ThreadQualifiers {
+  private ThreadQualifiers() {}
+
+  @Qualifier
+  @Retention(RUNTIME)
+  @Documented
+  @interface EntryPoint {}
+
+  @Qualifier
+  @Retention(RUNTIME)
+  @Documented
+  @interface Required {}
+
+  @Qualifier
+  @Retention(RUNTIME)
+  @Documented
+  @interface Deferred {}
+}
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/monitoring/MonitoringTest.java b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/monitoring/MonitoringTest.java
index 57691f080..ee7414570 100644
--- a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/monitoring/MonitoringTest.java
+++ b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/monitoring/MonitoringTest.java
@@ -26,6 +26,7 @@
 
 import com.google.common.base.Throwables;
 import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
 import com.google.common.util.concurrent.ListenableFuture;
 import com.google.common.util.concurrent.SettableFuture;
 import dagger.producers.monitoring.ProducerMonitor;
@@ -34,6 +35,7 @@
 import java.util.LinkedHashMap;
 import java.util.Map;
 import java.util.concurrent.ExecutionException;
+import java.util.concurrent.Executors;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -41,6 +43,7 @@
 import org.mockito.InOrder;
 import org.mockito.Mock;
 import org.mockito.MockitoAnnotations;
+import producerstest.ExecutorModule;
 
 /** Tests for production components using monitoring. */
 @RunWith(JUnit4.class)
@@ -158,4 +161,88 @@ public ProducerMonitor producerMonitorFor(ProducerToken token) {
       return monitor;
     }
   }
+
+  @Test
+  public void monitoringWithThreads() throws Exception {
+    ThreadRecordingProductionComponentMonitor componentMonitor =
+        new ThreadRecordingProductionComponentMonitor();
+    when(componentMonitorFactory.create(any())).thenReturn(componentMonitor);
+
+    ThreadMonitoredComponent component =
+        DaggerThreadMonitoredComponent.builder()
+            .monitoringModule(new MonitoringModule(componentMonitorFactory))
+            .executorModule(new ExecutorModule(Executors.newFixedThreadPool(10)))
+            .build();
+    ThreadAccumulator threadAccumulator = component.threadAccumulator().get();
+
+    assertThat(componentMonitor.monitors).hasSize(3);
+    ImmutableList<Map.Entry<ProducerToken, ThreadRecordingProducerMonitor>> entries =
+        ImmutableList.copyOf(componentMonitor.monitors.entrySet());
+
+    assertThat(entries.get(0).getKey().toString()).contains("EntryPoint");
+    ThreadRecordingProducerMonitor entryPointMonitor = entries.get(0).getValue();
+    assertThat(entries.get(1).getKey().toString()).contains("Required");
+    ThreadRecordingProducerMonitor requiredMonitor = entries.get(1).getValue();
+    assertThat(entries.get(2).getKey().toString()).contains("Deferred");
+    ThreadRecordingProducerMonitor deferredMonitor = entries.get(2).getValue();
+
+    // The entry point producer was requested from the main thread, then ran in its own thread.
+    assertThat(entryPointMonitor.requestedThreadId).isEqualTo(Thread.currentThread().getId());
+    assertThat(entryPointMonitor.startingThreadId)
+        .isEqualTo(threadAccumulator.threadId("entryPoint"));
+    assertThat(entryPointMonitor.finishedThreadId)
+        .isEqualTo(threadAccumulator.threadId("entryPoint"));
+
+    // The deferred producer was requested by the required producer, then ran in its own thread.
+    assertThat(deferredMonitor.requestedThreadId).isEqualTo(threadAccumulator.threadId("required"));
+    assertThat(deferredMonitor.startingThreadId).isEqualTo(threadAccumulator.threadId("deferred"));
+    assertThat(deferredMonitor.finishedThreadId).isEqualTo(threadAccumulator.threadId("deferred"));
+
+    // The required producer was requested by the entry point producer, then ran in its own thread.
+    assertThat(requiredMonitor.requestedThreadId).isEqualTo(entryPointMonitor.requestedThreadId);
+    assertThat(requiredMonitor.startingThreadId).isEqualTo(threadAccumulator.threadId("required"));
+    assertThat(requiredMonitor.finishedThreadId).isEqualTo(threadAccumulator.threadId("required"));
+
+    // Each producer ran in a distinct thread.
+    ImmutableSet<Long> threadIds =
+        ImmutableSet.of(
+            Thread.currentThread().getId(),
+            threadAccumulator.threadId("required"),
+            threadAccumulator.threadId("deferred"),
+            threadAccumulator.threadId("entryPoint"));
+    assertThat(threadIds).hasSize(4);
+  }
+
+  private static final class ThreadRecordingProductionComponentMonitor
+      extends ProductionComponentMonitor {
+    final Map<ProducerToken, ThreadRecordingProducerMonitor> monitors = new LinkedHashMap<>();
+
+    @Override
+    public ProducerMonitor producerMonitorFor(ProducerToken token) {
+      ThreadRecordingProducerMonitor monitor = new ThreadRecordingProducerMonitor();
+      monitors.put(token, monitor);
+      return monitor;
+    }
+  }
+
+  private static final class ThreadRecordingProducerMonitor extends ProducerMonitor {
+    private long requestedThreadId;
+    private long startingThreadId;
+    private long finishedThreadId;
+
+    @Override
+    public void requested() {
+      requestedThreadId = Thread.currentThread().getId();
+    }
+
+    @Override
+    public void methodStarting() {
+      startingThreadId = Thread.currentThread().getId();
+    }
+
+    @Override
+    public void methodFinished() {
+      finishedThreadId = Thread.currentThread().getId();
+    }
+  }
 }
diff --git a/producers/src/main/java/dagger/producers/monitoring/ProducerMonitor.java b/producers/src/main/java/dagger/producers/monitoring/ProducerMonitor.java
index 040ea3ca6..6b29e1f56 100644
--- a/producers/src/main/java/dagger/producers/monitoring/ProducerMonitor.java
+++ b/producers/src/main/java/dagger/producers/monitoring/ProducerMonitor.java
@@ -80,6 +80,19 @@
    * <p>Note that if a method depends on {@code Producer<T>}, then this does not count as requesting
    * {@code T}; that is only triggered by calling {@link Producer#get()}.
    *
+   * <p>Depending on how this producer is requested, the following threading constraints are
+   * guaranteed:
+   *
+   * <ol>
+   *   <li>If the producer is requested directly by a method on a component, then {@code requested}
+   *       will be called on the same thread as the component method call.
+   *   <li>If the producer is requested by value from another producer (i.e., injected as {@code T}
+   *       or {@code Produced<T>}), then {@code requested} will be called from the same thread as
+   *       the other producer's {@code requested}.
+   *   <li>If the producer is requested by calling {@link Producer#get()}, then {@code requested}
+   *       will be called from the same thread as that {@code get()} call.
+   * </ol>
+   *
    * <p>When multiple monitors are installed, the order that each monitor will call this method is
    * unspecified, but will remain consistent throughout the course of the execution of a component.
    *
@@ -88,7 +101,8 @@
   public void requested() {}
 
   /**
-   * Called when the producer method is about to start executing.
+   * Called when the producer method is about to start executing. This will be called from the same
+   * thread as the producer method itself.
    *
    * <p>When multiple monitors are installed, calls to this method will be in the reverse order from
    * calls to {@link #requested()}.
@@ -99,7 +113,7 @@ public void methodStarting() {}
 
   /**
    * Called when the producer method has finished executing. This will be called from the same
-   * thread as {@link #methodStarting()}.
+   * thread as {@link #methodStarting()} and the producer method itself.
    *
    * <p>When multiple monitors are installed, calls to this method will be in the reverse order from
    * calls to {@link #requested()}.
