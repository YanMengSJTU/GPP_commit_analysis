diff --git a/compiler/src/it/functional-tests/src/main/java/test/BasicComponent.java b/compiler/src/it/functional-tests/src/main/java/test/BasicComponent.java
index cd9dbdbf1..2a0eab6ba 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/BasicComponent.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/BasicComponent.java
@@ -16,6 +16,7 @@
 package test;
 
 import dagger.Component;
+import javax.inject.Provider;
 
 @Component(modules = PrimitivesModule.class)
 interface BasicComponent {
@@ -37,6 +38,15 @@
   Float getBoxedFloat();
   Double getBoxedDouble();
 
+  Provider<Byte> getByteProvider();
+  Provider<Character> getCharProvider();
+  Provider<Short> getShortProvider();
+  Provider<Integer> getIntProvider();
+  Provider<Long> getLongProvider();
+  Provider<Boolean> getBooleanProvider();
+  Provider<Float> getFloatProvider();
+  Provider<Double> getDoubleProvider();
+
   byte[] getByteArray();
   char[] getCharArray();
   short[] getShortArray();
@@ -46,6 +56,15 @@
   float[] getFloatArray();
   double[] getDoubleArray();
 
+  Provider<byte[]> getByteArrayProvider();
+  Provider<char[]> getCharArrayProvider();
+  Provider<short[]> getShortArrayProvider();
+  Provider<int[]> getIntArrayProvider();
+  Provider<long[]> getLongArrayProvider();
+  Provider<boolean[]> getBooleanArrayProvider();
+  Provider<float[]> getFloatArrayProvider();
+  Provider<double[]> getDoubleArrayProvider();
+
   Object noOpMembersInjection(Object obviouslyDoesNotHaveMembersToInject);
 
   Thing thing();
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/RequiresSingleton.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/BoundAsSingleton.java
similarity index 69%
rename from compiler/src/it/functional-tests/src/main/java/test/subcomponent/RequiresSingleton.java
rename to compiler/src/it/functional-tests/src/main/java/test/subcomponent/BoundAsSingleton.java
index d7813f1cd..8ae147415 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/RequiresSingleton.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/BoundAsSingleton.java
@@ -15,16 +15,13 @@
  */
 package test.subcomponent;
 
-import javax.inject.Inject;
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import javax.inject.Qualifier;
 
-final class RequiresSingleton {
-  private final SingletonType singletonType;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
-  @Inject RequiresSingleton(SingletonType singletonType) {
-    this.singletonType = singletonType;
-  }
-
-  SingletonType singletonType() {
-    return singletonType;
-  }
-}
+@Documented
+@Retention(RUNTIME)
+@Qualifier
+@interface BoundAsSingleton {}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildComponent.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildComponent.java
index 96e4bcb1f..67d66cae9 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildComponent.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildComponent.java
@@ -23,7 +23,7 @@
 interface ChildComponent {
   Provider<UnscopedType> getUnscopedTypeProvider();
 
-  RequiresSingleton requiresSingleton();
+  RequiresSingletons requiresSingleton();
 
   Set<Object> objectSet();
 
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/GrandchildComponent.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/GrandchildComponent.java
index 388d66960..9ed4c714a 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/GrandchildComponent.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/GrandchildComponent.java
@@ -23,7 +23,7 @@
 interface GrandchildComponent {
   Provider<UnscopedType> getUnscopedTypeProvider();
 
-  RequiresSingleton requiresSingleton();
+  RequiresSingletons requiresSingleton();
 
   Set<Object> objectSet();
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentComponent.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentComponent.java
index ec9a79941..ed4e6f0e8 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentComponent.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentComponent.java
@@ -25,8 +25,6 @@
 interface ParentComponent {
   Provider<UnscopedType> getUnscopedTypeProvider();
 
-  SingletonType getSingletonType();
-
   Set<Object> objectSet();
 
   ChildComponent newChildComponent();
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentModule.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentModule.java
index 3ac07b086..dbe1a534a 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentModule.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentModule.java
@@ -38,4 +38,9 @@
       }
     };
   }
+
+  @Provides @Singleton @BoundAsSingleton UnscopedType provideUnscopedTypeBoundAsSingleton(
+      UnscopedType unscopedType) {
+    return unscopedType;
+  }
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/RequiresSingletons.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/RequiresSingletons.java
new file mode 100644
index 000000000..2d4053824
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/RequiresSingletons.java
@@ -0,0 +1,37 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.subcomponent;
+
+import javax.inject.Inject;
+
+final class RequiresSingletons {
+  private final SingletonType singletonType;
+  private final UnscopedType unscopedTypeBoundAsSingleton;
+
+  @Inject RequiresSingletons(SingletonType singletonType,
+      @BoundAsSingleton UnscopedType unscopedTypeBoundAsSingleton) {
+    this.singletonType = singletonType;
+    this.unscopedTypeBoundAsSingleton = unscopedTypeBoundAsSingleton;
+  }
+
+  SingletonType singletonType() {
+    return singletonType;
+  }
+
+  UnscopedType unscopedTypeBoundAsSingleton() {
+    return unscopedTypeBoundAsSingleton;
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/test/java/test/BasicTest.java b/compiler/src/it/functional-tests/src/test/java/test/BasicTest.java
index 45dd924ae..c3bfa98fa 100644
--- a/compiler/src/it/functional-tests/src/test/java/test/BasicTest.java
+++ b/compiler/src/it/functional-tests/src/test/java/test/BasicTest.java
@@ -63,6 +63,18 @@
     assertThat(basicComponent.getBoxedDouble()).isEqualTo(new Double(BOUND_DOUBLE));
   }
 
+  @Test public void boxedPrimitiveProviders() {
+    BasicComponent basicComponent = Dagger_BasicComponent.create();
+    assertThat(basicComponent.getByteProvider().get()).isEqualTo(new Byte(BOUND_BYTE));
+    assertThat(basicComponent.getCharProvider().get()).isEqualTo(new Character(BOUND_CHAR));
+    assertThat(basicComponent.getShortProvider().get()).isEqualTo(new Short(BOUND_SHORT));
+    assertThat(basicComponent.getIntProvider().get()).isEqualTo(new Integer(BOUND_INT));
+    assertThat(basicComponent.getLongProvider().get()).isEqualTo(new Long(BOUND_LONG));
+    assertThat(basicComponent.getBooleanProvider().get()).isEqualTo(new Boolean(BOUND_BOOLEAN));
+    assertThat(basicComponent.getFloatProvider().get()).isEqualTo(new Float(BOUND_FLOAT));
+    assertThat(basicComponent.getDoubleProvider().get()).isEqualTo(new Double(BOUND_DOUBLE));
+  }
+
   @Test public void primitiveArrays() {
     BasicComponent basicComponent = Dagger_BasicComponent.create();
     assertThat(basicComponent.getByteArray()).isSameAs(BOUND_BYTE_ARRAY);
@@ -75,6 +87,18 @@
     assertThat(basicComponent.getDoubleArray()).isSameAs(BOUND_DOUBLE_ARRAY);
   }
 
+  @Test public void primitiveArrayProviders() {
+    BasicComponent basicComponent = Dagger_BasicComponent.create();
+    assertThat(basicComponent.getByteArrayProvider().get()).isSameAs(BOUND_BYTE_ARRAY);
+    assertThat(basicComponent.getCharArrayProvider().get()).isSameAs(BOUND_CHAR_ARRAY);
+    assertThat(basicComponent.getShortArrayProvider().get()).isSameAs(BOUND_SHORT_ARRAY);
+    assertThat(basicComponent.getIntArrayProvider().get()).isSameAs(BOUND_INT_ARRAY);
+    assertThat(basicComponent.getLongArrayProvider().get()).isSameAs(BOUND_LONG_ARRAY);
+    assertThat(basicComponent.getBooleanArrayProvider().get()).isSameAs(BOUND_BOOLEAN_ARRAY);
+    assertThat(basicComponent.getFloatArrayProvider().get()).isSameAs(BOUND_FLOAT_ARRAY);
+    assertThat(basicComponent.getDoubleArrayProvider().get()).isSameAs(BOUND_DOUBLE_ARRAY);
+  }
+
   @Test public void noOpMembersInjection() {
     BasicComponent basicComponent = Dagger_BasicComponent.create();
     Object object = new Object();
diff --git a/compiler/src/it/functional-tests/src/test/java/test/subcomponent/SubcomponentScopeTest.java b/compiler/src/it/functional-tests/src/test/java/test/subcomponent/SubcomponentScopeTest.java
index 3f75547ce..4e897ff72 100644
--- a/compiler/src/it/functional-tests/src/test/java/test/subcomponent/SubcomponentScopeTest.java
+++ b/compiler/src/it/functional-tests/src/test/java/test/subcomponent/SubcomponentScopeTest.java
@@ -26,15 +26,26 @@
 @RunWith(JUnit4.class)
 public class SubcomponentScopeTest {
   @Test
-  public void singletonPropagatesUpward() {
+  public void scopePropagatesUpward_class() {
     ParentComponent parentComponent = Dagger_ParentComponent.create();
-    SingletonType singletonType = parentComponent.getSingletonType();
     assertThat(parentComponent.newChildComponent().requiresSingleton().singletonType())
-        .isSameAs(singletonType);
+        .isSameAs(parentComponent.newChildComponent().requiresSingleton().singletonType());
+    assertThat(parentComponent.newChildComponent().requiresSingleton().singletonType())
+        .isSameAs(parentComponent.newChildComponent()
+            .newGrandchildComponent().requiresSingleton().singletonType());
+  }
+
+  @Test
+  public void scopePropagatesUpward_provides() {
+    ParentComponent parentComponent = Dagger_ParentComponent.create();
+    assertThat(parentComponent.newChildComponent()
+        .requiresSingleton().unscopedTypeBoundAsSingleton())
+            .isSameAs(parentComponent.newChildComponent()
+                .requiresSingleton().unscopedTypeBoundAsSingleton());
     assertThat(parentComponent.newChildComponent()
-        .newGrandchildComponent()
-        .requiresSingleton().singletonType())
-            .isSameAs(singletonType);
+        .requiresSingleton().unscopedTypeBoundAsSingleton())
+            .isSameAs(parentComponent.newChildComponent().newGrandchildComponent()
+                .requiresSingleton().unscopedTypeBoundAsSingleton());
   }
 
   @Test
diff --git a/compiler/src/it/producers-functional-tests/pom.xml b/compiler/src/it/producers-functional-tests/pom.xml
index b8e8972e8..33c48efe5 100644
--- a/compiler/src/it/producers-functional-tests/pom.xml
+++ b/compiler/src/it/producers-functional-tests/pom.xml
@@ -66,8 +66,8 @@ limitations under the License.
         <artifactId>maven-compiler-plugin</artifactId>
         <version>3.1</version>
         <configuration>
-          <source>1.7</source>
-          <target>1.7</target>
+          <source>1.6</source>
+          <target>1.6</target>
           <annotationProcessors>
             <annotationProcessor>dagger.internal.codegen.ComponentProcessor</annotationProcessor>
           </annotationProcessors>
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
index 94f72ec1e..dde9f2823 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
@@ -26,6 +26,7 @@
 import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
 import com.google.common.collect.Queues;
+import com.google.common.collect.Sets;
 import dagger.Component;
 import dagger.Provides;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodType;
@@ -35,6 +36,7 @@
 import java.util.List;
 import java.util.Map;
 import java.util.Map.Entry;
+import java.util.Set;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
@@ -71,11 +73,35 @@
   @AutoValue
   abstract static class ResolvedBindings {
     abstract BindingKey bindingKey();
-    abstract ImmutableSet<? extends Binding> bindings();
+    abstract ImmutableSet<? extends Binding> ownedBindings();
+    abstract ImmutableSet<? extends Binding> inheritedBindings();
+
+    ImmutableSet<? extends Binding> bindings() {
+      return new ImmutableSet.Builder<Binding>()
+          .addAll(inheritedBindings())
+          .addAll(ownedBindings())
+          .build();
+    }
+
+    static ResolvedBindings create(
+        BindingKey bindingKey,
+        Set<? extends Binding> ownedBindings,
+        Set<? extends Binding> inheritedBindings) {
+      return new AutoValue_BindingGraph_ResolvedBindings(
+          bindingKey, ImmutableSet.copyOf(ownedBindings), ImmutableSet.copyOf(inheritedBindings));
+    }
 
     static ResolvedBindings create(
-        BindingKey bindingKey, ImmutableSet<? extends Binding> bindings) {
-      return new AutoValue_BindingGraph_ResolvedBindings(bindingKey, bindings);
+        BindingKey bindingKey,
+        Binding... ownedBindings) {
+      return new AutoValue_BindingGraph_ResolvedBindings(
+          bindingKey, ImmutableSet.copyOf(ownedBindings), ImmutableSet.<Binding>of());
+    }
+
+    @SuppressWarnings("unchecked")  // checked by validator
+    ImmutableSet<? extends ContributionBinding> ownedContributionBindings() {
+      checkState(bindingKey().kind().equals(BindingKey.Kind.CONTRIBUTION));
+      return (ImmutableSet<? extends ContributionBinding>) ownedBindings();
     }
 
     @SuppressWarnings("unchecked")  // checked by validator
@@ -270,8 +296,7 @@ private BindingGraph create(Optional<RequestResolver> parentResolver,
        *  event that the binding is owned by a parent component it will trigger resolution in that
        *  component's resolver but will return an {@link Optional#absent} value.
        */
-      Optional<? extends ImmutableSet<? extends Binding>> lookUpBindings(
-          DependencyRequest request) {
+      ResolvedBindings lookUpBindings(DependencyRequest request) {
         BindingKey bindingKey = BindingKey.forDependencyRequest(request);
         switch (bindingKey.kind()) {
           case CONTRIBUTION:
@@ -299,27 +324,39 @@ private BindingGraph create(Optional<RequestResolver> parentResolver,
                 || !explicitProductionBindingsForKey.isEmpty()) {
               // we have some explicit binding for this key, so we collect all explicit implicit map
               // bindings that might conflict with this and let the validator sort it out
-              return Optional.of(ImmutableSet.<ContributionBinding>builder()
-                  .addAll(explicitProvisionBindingsForKey)
-                  .addAll(explicitMapProvisionBindings)
-                  .addAll(explicitProductionBindingsForKey)
-                  .addAll(explicitMapProductionBindings)
-                  .build());
+              ImmutableSet.Builder<ContributionBinding> ownedBindings = ImmutableSet.builder();
+              ImmutableSet.Builder<ContributionBinding> inheritedBindings = ImmutableSet.builder();
+              for (ProvisionBinding provisionBinding :
+                  Sets.union(explicitProvisionBindingsForKey, explicitMapProvisionBindings)) {
+                Optional<RequestResolver> owningResolver = getOwningResolver(provisionBinding);
+                if (owningResolver.isPresent() && !owningResolver.get().equals(this)) {
+                  owningResolver.get().resolve(request);
+                  inheritedBindings.add(provisionBinding);
+                } else {
+                  ownedBindings.add(provisionBinding);
+                }
+              }
+              return ResolvedBindings.create(bindingKey,
+                  ownedBindings
+                      .addAll(explicitProductionBindingsForKey)
+                      .addAll(explicitMapProductionBindings)
+                      .build(),
+                  inheritedBindings.build());
             } else {
               if (!explicitMapProductionBindings.isEmpty()) {
                 // if we have any explicit Map<K, Producer<V>> bindings, then this Map<K, V> binding
                 // must be considered an implicit ProductionBinding
                 DependencyRequest implicitRequest =
                     dependencyRequestFactory.forImplicitMapBinding(request, mapProducerKey.get());
-                return Optional.of(ImmutableSet.of(productionBindingFactory.forImplicitMapBinding(
-                    request, implicitRequest)));
+                return ResolvedBindings.create(bindingKey,
+                    productionBindingFactory.forImplicitMapBinding(request, implicitRequest));
               } else if (!explicitMapProvisionBindings.isEmpty()) {
                 // if there are Map<K, Provider<V>> bindings, then it'll be an implicit
                 // ProvisionBinding
                 DependencyRequest implicitRequest =
                     dependencyRequestFactory.forImplicitMapBinding(request, mapProviderKey.get());
-                return Optional.of(ImmutableSet.of(provisionBindingFactory.forImplicitMapBinding(
-                    request, implicitRequest)));
+                return ResolvedBindings.create(bindingKey,
+                    provisionBindingFactory.forImplicitMapBinding(request, implicitRequest));
               } else {
                 // no explicit binding, look it up.
                 Optional<ProvisionBinding> provisionBinding =
@@ -329,15 +366,19 @@ private BindingGraph create(Optional<RequestResolver> parentResolver,
                       getOwningResolver(provisionBinding.get());
                   if (owningResolver.isPresent() && !owningResolver.get().equals(this)) {
                     owningResolver.get().resolve(request);
-                    return Optional.absent();
+                    return ResolvedBindings.create(
+                        bindingKey, ImmutableSet.<Binding>of(),
+                        provisionBinding.asSet());
                   }
                 }
-                return Optional.of(ImmutableSet.copyOf(provisionBinding.asSet()));
+                return ResolvedBindings.create(
+                    bindingKey, provisionBinding.asSet(), ImmutableSet.<Binding>of());
               }
             }
           case MEMBERS_INJECTION:
             // no explicit deps for members injection, so just look it up
-            return Optional.of(ImmutableSet.of(rollUpMembersInjectionBindings(bindingKey.key())));
+            return ResolvedBindings.create(
+                bindingKey, rollUpMembersInjectionBindings(bindingKey.key()));
           default:
             throw new AssertionError();
         }
@@ -430,15 +471,13 @@ void resolve(DependencyRequest request) {
 
         cycleStack.push(bindingKey);
         try {
-          Optional<? extends ImmutableSet<? extends Binding>> bindings = lookUpBindings(request);
-          if (bindings.isPresent()) {
-            for (Binding binding : bindings.get()) {
-              for (DependencyRequest dependency : binding.implicitDependencies()) {
-                resolve(dependency);
-              }
+          ResolvedBindings bindings = lookUpBindings(request);
+          for (Binding binding : bindings.ownedBindings()) {
+            for (DependencyRequest dependency : binding.implicitDependencies()) {
+              resolve(dependency);
             }
-            resolvedBindings.put(bindingKey, ResolvedBindings.create(bindingKey, bindings.get()));
           }
+          resolvedBindings.put(bindingKey, bindings);
         } finally {
           cycleStack.pop();
         }
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
index 213811749..f74085e8e 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -682,7 +682,7 @@ private void reportCycle(Deque<ResolvedRequest> path,
     DependencyRequest rootRequest = path.getLast().request();
     TypeElement componentType =
         MoreElements.asType(rootRequest.requestElement().getEnclosingElement());
-    // TODO(user): Restructure to provide a hint for the start and end of the cycle.
+    // TODO(cgruber): Restructure to provide a hint for the start and end of the cycle.
     reportBuilder.addItem(
         String.format(ErrorMessages.CONTAINS_DEPENDENCY_CYCLE_FORMAT,
             componentType.getQualifiedName(),
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
index 187b71e7d..f8ffb17dd 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
@@ -474,129 +474,155 @@ private void writeFields(BindingGraph input,
       Map<ContributionBinding, Snippet> parentMultibindingContributionSnippetsBuilder,
       Map<ContributionBinding, Snippet> multibindingContributionSnippetsBuilder,
       ImmutableSet.Builder<BindingKey> enumBindingKeysBuilder,
-      Map<String, ProxyClassAndField> packageProxies) throws AssertionError {
+      Map<String, ProxyClassAndField> packageProxies) {
     for (ResolvedBindings resolvedBindings : input.resolvedBindings().values()) {
-      BindingKey bindingKey = resolvedBindings.bindingKey();
-
-      if (resolvedBindings.bindings().size() == 1) {
-        if (bindingKey.kind().equals(BindingKey.Kind.CONTRIBUTION)) {
-          ContributionBinding contributionBinding =
-              Iterables.getOnlyElement(resolvedBindings.contributionBindings());
-          if (contributionBinding instanceof ProvisionBinding) {
-            ProvisionBinding provisionBinding = (ProvisionBinding) contributionBinding;
-            if (provisionBinding.factoryCreationStrategy().equals(ENUM_INSTANCE)
-                && !provisionBinding.scope().isPresent()) {
-              enumBindingKeysBuilder.add(bindingKey);
-              // skip keys whose factories are enum instances and aren't scoped
-              memberSelectSnippetsBuilder.put(bindingKey,
-                  MemberSelect.staticSelect(
-                      factoryNameForProvisionBinding(provisionBinding),
-                      Snippet.format("create()")));
-              continue;
-            }
-          }
-        } else if (bindingKey.kind().equals(BindingKey.Kind.MEMBERS_INJECTION)) {
-          MembersInjectionBinding membersInjectionBinding =
-              Iterables.getOnlyElement(resolvedBindings.membersInjectionBindings());
-          if (membersInjectionBinding.injectionStrategy().equals(NO_OP)) {
-            // TODO(gak): refactor to use enumBindingKeys throughout the generator
+      writeField(
+          componentWriter,
+          proxyWriters,
+          memberSelectSnippetsBuilder,
+          parentMultibindingContributionSnippetsBuilder,
+          multibindingContributionSnippetsBuilder,
+          enumBindingKeysBuilder,
+          packageProxies,
+          resolvedBindings);
+    }
+  }
+
+  private void writeField(
+      ClassWriter componentWriter,
+      Set<JavaWriter> proxyWriters,
+      Map<BindingKey, MemberSelect> memberSelectSnippetsBuilder,
+      Map<ContributionBinding, Snippet> parentMultibindingContributionSnippetsBuilder,
+      Map<ContributionBinding, Snippet> multibindingContributionSnippetsBuilder,
+      ImmutableSet.Builder<BindingKey> enumBindingKeysBuilder,
+      Map<String, ProxyClassAndField> packageProxies, ResolvedBindings resolvedBindings) {
+    BindingKey bindingKey = resolvedBindings.bindingKey();
+
+    if (bindingKey.kind().equals(BindingKey.Kind.CONTRIBUTION)
+        && resolvedBindings.ownedContributionBindings().isEmpty()
+        && !ContributionBinding.bindingTypeFor(resolvedBindings.contributionBindings())
+            .isMultibinding()) {
+      return;
+    }
+
+    if (resolvedBindings.bindings().size() == 1) {
+      if (bindingKey.kind().equals(BindingKey.Kind.CONTRIBUTION)) {
+        ContributionBinding contributionBinding =
+            Iterables.getOnlyElement(resolvedBindings.contributionBindings());
+        if (contributionBinding instanceof ProvisionBinding) {
+          ProvisionBinding provisionBinding = (ProvisionBinding) contributionBinding;
+          if (provisionBinding.factoryCreationStrategy().equals(ENUM_INSTANCE)
+              && !provisionBinding.scope().isPresent()) {
             enumBindingKeysBuilder.add(bindingKey);
-            // TODO(gak): suppress the warnings in a reasonable place
+            // skip keys whose factories are enum instances and aren't scoped
             memberSelectSnippetsBuilder.put(bindingKey,
-                MemberSelect.staticMethodInvocationWithCast(
-                    ClassName.fromClass(MembersInjectors.class),
-                    Snippet.format("noOp()"),
-                    ClassName.fromClass(MembersInjector.class)));
-            continue;
+                MemberSelect.staticSelect(
+                    factoryNameForProvisionBinding(provisionBinding),
+                    Snippet.format("create()")));
+            return;
           }
         }
+      } else if (bindingKey.kind().equals(BindingKey.Kind.MEMBERS_INJECTION)) {
+        MembersInjectionBinding membersInjectionBinding =
+            Iterables.getOnlyElement(resolvedBindings.membersInjectionBindings());
+        if (membersInjectionBinding.injectionStrategy().equals(NO_OP)) {
+          // TODO(gak): refactor to use enumBindingKeys throughout the generator
+          enumBindingKeysBuilder.add(bindingKey);
+          // TODO(gak): suppress the warnings in a reasonable place
+          memberSelectSnippetsBuilder.put(bindingKey,
+              MemberSelect.staticMethodInvocationWithCast(
+                  ClassName.fromClass(MembersInjectors.class),
+                  Snippet.format("noOp()"),
+                  ClassName.fromClass(MembersInjector.class)));
+          return;
+        }
       }
+    }
 
-      String bindingPackage = bindingPackageFor(resolvedBindings.bindings())
-          .or(componentWriter.name().packageName());
+    String bindingPackage = bindingPackageFor(resolvedBindings.bindings())
+        .or(componentWriter.name().packageName());
 
-      final Optional<String> proxySelector;
-      final TypeWriter classWithFields;
-      final Set<Modifier> fieldModifiers;
+    final Optional<String> proxySelector;
+    final TypeWriter classWithFields;
+    final Set<Modifier> fieldModifiers;
 
-      if (bindingPackage.equals(componentWriter.name().packageName())) {
-        // no proxy
-        proxySelector = Optional.absent();
-        // component gets the fields
-        classWithFields = componentWriter;
-        // private fields
-        fieldModifiers = EnumSet.of(PRIVATE);
-      } else {
-        // get or create the proxy
-        ProxyClassAndField proxyClassAndField = packageProxies.get(bindingPackage);
-        if (proxyClassAndField == null) {
-          JavaWriter proxyJavaWriter = JavaWriter.inPackage(bindingPackage);
-          proxyWriters.add(proxyJavaWriter);
-          ClassWriter proxyWriter =
-              proxyJavaWriter.addClass(componentWriter.name().simpleName() + "__PackageProxy");
-          proxyWriter.annotate(Generated.class)
-              .setValue(ComponentProcessor.class.getCanonicalName());
-          proxyWriter.addModifiers(PUBLIC, FINAL);
-          // create the field for the proxy in the component
-          FieldWriter proxyFieldWriter =
-              componentWriter.addField(proxyWriter.name(),
-                  bindingPackage.replace('.', '_') + "_Proxy");
-          proxyFieldWriter.addModifiers(PRIVATE, FINAL);
-          proxyFieldWriter.setInitializer("new %s()", proxyWriter.name());
-          proxyClassAndField = ProxyClassAndField.create(proxyWriter, proxyFieldWriter);
-          packageProxies.put(bindingPackage, proxyClassAndField);
-        }
-        // add the field for the member select
-        proxySelector = Optional.of(proxyClassAndField.proxyFieldWriter().name());
-        // proxy gets the fields
-        classWithFields = proxyClassAndField.proxyWriter();
-        // public fields in the proxy
-        fieldModifiers = EnumSet.of(PUBLIC);
+    if (bindingPackage.equals(componentWriter.name().packageName())) {
+      // no proxy
+      proxySelector = Optional.absent();
+      // component gets the fields
+      classWithFields = componentWriter;
+      // private fields
+      fieldModifiers = EnumSet.of(PRIVATE);
+    } else {
+      // get or create the proxy
+      ProxyClassAndField proxyClassAndField = packageProxies.get(bindingPackage);
+      if (proxyClassAndField == null) {
+        JavaWriter proxyJavaWriter = JavaWriter.inPackage(bindingPackage);
+        proxyWriters.add(proxyJavaWriter);
+        ClassWriter proxyWriter =
+            proxyJavaWriter.addClass(componentWriter.name().simpleName() + "__PackageProxy");
+        proxyWriter.annotate(Generated.class)
+            .setValue(ComponentProcessor.class.getCanonicalName());
+        proxyWriter.addModifiers(PUBLIC, FINAL);
+        // create the field for the proxy in the component
+        FieldWriter proxyFieldWriter =
+            componentWriter.addField(proxyWriter.name(),
+                bindingPackage.replace('.', '_') + "_Proxy");
+        proxyFieldWriter.addModifiers(PRIVATE, FINAL);
+        proxyFieldWriter.setInitializer("new %s()", proxyWriter.name());
+        proxyClassAndField = ProxyClassAndField.create(proxyWriter, proxyFieldWriter);
+        packageProxies.put(bindingPackage, proxyClassAndField);
       }
+      // add the field for the member select
+      proxySelector = Optional.of(proxyClassAndField.proxyFieldWriter().name());
+      // proxy gets the fields
+      classWithFields = proxyClassAndField.proxyWriter();
+      // public fields in the proxy
+      fieldModifiers = EnumSet.of(PUBLIC);
+    }
 
-      if (bindingKey.kind().equals(BindingKey.Kind.CONTRIBUTION)) {
-        ImmutableSet<? extends ContributionBinding> contributionBindings =
-            resolvedBindings.contributionBindings();
-        if (ContributionBinding.bindingTypeFor(contributionBindings).isMultibinding()) {
-          // note that here we rely on the order of the resolved bindings being from parent to child
-          // otherwise, the numbering wouldn't work
-          int contributionNumber = 0;
-          for (ContributionBinding contributionBinding : contributionBindings) {
-            if (!contributionBinding.isSyntheticBinding()) {
-              contributionNumber++;
-              if (!parentMultibindingContributionSnippetsBuilder.containsKey(contributionBinding)) {
-                FrameworkField contributionBindingField =
-                    frameworkFieldForSyntheticContributionBinding(
-                          bindingKey, contributionNumber, contributionBinding);
-                FieldWriter contributionField = classWithFields.addField(
-                    contributionBindingField.frameworkType(), contributionBindingField.name());
-                contributionField.addModifiers(fieldModifiers);
-
-                ImmutableList<String> contributionSelectTokens = new ImmutableList.Builder<String>()
-                    .addAll(proxySelector.asSet())
-                    .add(contributionField.name())
-                    .build();
-                multibindingContributionSnippetsBuilder.put(contributionBinding,
-                    Snippet.memberSelectSnippet(contributionSelectTokens));
-              }
+    if (bindingKey.kind().equals(BindingKey.Kind.CONTRIBUTION)) {
+      ImmutableSet<? extends ContributionBinding> contributionBindings =
+          resolvedBindings.contributionBindings();
+      if (ContributionBinding.bindingTypeFor(contributionBindings).isMultibinding()) {
+        // note that here we rely on the order of the resolved bindings being from parent to child
+        // otherwise, the numbering wouldn't work
+        int contributionNumber = 0;
+        for (ContributionBinding contributionBinding : contributionBindings) {
+          if (!contributionBinding.isSyntheticBinding()) {
+            contributionNumber++;
+            if (!parentMultibindingContributionSnippetsBuilder.containsKey(contributionBinding)) {
+              FrameworkField contributionBindingField =
+                  frameworkFieldForSyntheticContributionBinding(
+                        bindingKey, contributionNumber, contributionBinding);
+              FieldWriter contributionField = classWithFields.addField(
+                  contributionBindingField.frameworkType(), contributionBindingField.name());
+              contributionField.addModifiers(fieldModifiers);
+
+              ImmutableList<String> contributionSelectTokens = new ImmutableList.Builder<String>()
+                  .addAll(proxySelector.asSet())
+                  .add(contributionField.name())
+                  .build();
+              multibindingContributionSnippetsBuilder.put(contributionBinding,
+                  Snippet.memberSelectSnippet(contributionSelectTokens));
             }
           }
         }
       }
-
-      FrameworkField bindingField = frameworkFieldForResolvedBindings(resolvedBindings);
-      FieldWriter frameworkField =
-          classWithFields.addField(bindingField.frameworkType(), bindingField.name());
-      frameworkField.addModifiers(fieldModifiers);
-
-      ImmutableList<String> memberSelectTokens = new ImmutableList.Builder<String>()
-          .addAll(proxySelector.asSet())
-          .add(frameworkField.name())
-          .build();
-      memberSelectSnippetsBuilder.put(bindingKey, MemberSelect.instanceSelect(
-          componentWriter.name(),
-          Snippet.memberSelectSnippet(memberSelectTokens)));
     }
+
+    FrameworkField bindingField = frameworkFieldForResolvedBindings(resolvedBindings);
+    FieldWriter frameworkField =
+        classWithFields.addField(bindingField.frameworkType(), bindingField.name());
+    frameworkField.addModifiers(fieldModifiers);
+
+    ImmutableList<String> memberSelectTokens = new ImmutableList.Builder<String>()
+        .addAll(proxySelector.asSet())
+        .add(frameworkField.name())
+        .build();
+    memberSelectSnippetsBuilder.put(bindingKey, MemberSelect.instanceSelect(
+        componentWriter.name(),
+        Snippet.memberSelectSnippet(memberSelectTokens)));
   }
 
   private void writeInterfaceMethods(BindingGraph input, ClassWriter componentWriter,
@@ -686,10 +712,11 @@ private void initializeFrameworkTypes(BindingGraph input,
       for (BindingKey bindingKey : partitions.get(i)) {
         Snippet memberSelectSnippet =
             memberSelectSnippets.get(bindingKey).getSnippetFor(componentWriter.name());
+        ResolvedBindings resolvedBindings = input.resolvedBindings().get(bindingKey);
         switch (bindingKey.kind()) {
           case CONTRIBUTION:
             ImmutableSet<? extends ContributionBinding> bindings =
-                input.resolvedBindings().get(bindingKey).contributionBindings();
+                resolvedBindings.contributionBindings();
 
             switch (ContributionBinding.bindingTypeFor(bindings)) {
               case SET:
@@ -751,29 +778,31 @@ private void initializeFrameworkTypes(BindingGraph input,
                 }
                 break;
               case UNIQUE:
-                ContributionBinding binding = Iterables.getOnlyElement(bindings);
-                if (binding instanceof ProvisionBinding) {
-                  ProvisionBinding provisionBinding = (ProvisionBinding) binding;
-                  if (!provisionBinding.factoryCreationStrategy().equals(ENUM_INSTANCE)
-                      || provisionBinding.scope().isPresent()) {
+                if (!resolvedBindings.ownedContributionBindings().isEmpty()) {
+                  ContributionBinding binding = Iterables.getOnlyElement(bindings);
+                  if (binding instanceof ProvisionBinding) {
+                    ProvisionBinding provisionBinding = (ProvisionBinding) binding;
+                    if (!provisionBinding.factoryCreationStrategy().equals(ENUM_INSTANCE)
+                        || provisionBinding.scope().isPresent()) {
+                      initializeMethod.body().addSnippet("this.%s = %s;",
+                          memberSelectSnippet,
+                          initializeFactoryForProvisionBinding(provisionBinding,
+                              componentWriter.name(),
+                              input.componentDescriptor().dependencyMethodIndex(),
+                              componentContributionFields, memberSelectSnippets));
+                    }
+                  } else if (binding instanceof ProductionBinding) {
+                    ProductionBinding productionBinding = (ProductionBinding) binding;
                     initializeMethod.body().addSnippet("this.%s = %s;",
                         memberSelectSnippet,
-                        initializeFactoryForProvisionBinding(provisionBinding,
+                        initializeFactoryForProductionBinding(productionBinding,
+                            input,
                             componentWriter.name(),
                             input.componentDescriptor().dependencyMethodIndex(),
                             componentContributionFields, memberSelectSnippets));
+                  } else {
+                    throw new AssertionError();
                   }
-                } else if (binding instanceof ProductionBinding) {
-                  ProductionBinding productionBinding = (ProductionBinding) binding;
-                  initializeMethod.body().addSnippet("this.%s = %s;",
-                      memberSelectSnippet,
-                      initializeFactoryForProductionBinding(productionBinding,
-                          input,
-                          componentWriter.name(),
-                          input.componentDescriptor().dependencyMethodIndex(),
-                          componentContributionFields, memberSelectSnippets));
-                } else {
-                  throw new AssertionError();
                 }
                 break;
               default:
@@ -782,7 +811,7 @@ private void initializeFrameworkTypes(BindingGraph input,
             break;
           case MEMBERS_INJECTION:
             MembersInjectionBinding binding = Iterables.getOnlyElement(
-                input.resolvedBindings().get(bindingKey).membersInjectionBindings());
+                resolvedBindings.membersInjectionBindings());
             if (!binding.injectionStrategy().equals(MembersInjectionBinding.Strategy.NO_OP)) {
               initializeMethod.body().addSnippet("this.%s = %s;",
                   memberSelectSnippet,
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyRequestFormatter.java b/compiler/src/main/java/dagger/internal/codegen/DependencyRequestFormatter.java
index dd97665df..0e5f1f240 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DependencyRequestFormatter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyRequestFormatter.java
@@ -48,8 +48,8 @@
     this.types = types;
   }
 
-  // TODO(user): Sweep this class for TypeMirror.toString() usage and do some preventive format.
-  // TODO(user): consider returning a small structure containing strings to be indented later.
+  // TODO(cgruber): Sweep this class for TypeMirror.toString() usage and do some preventive format.
+  // TODO(cgruber): consider returning a small structure containing strings to be indented later.
   @Override public String format(final DependencyRequest request) {
     Element requestElement = request.requestElement();
     Optional<AnnotationMirror> qualifier = InjectionAnnotations.getQualifier(requestElement);
@@ -65,7 +65,7 @@
           appendEnclosingTypeAndMemberName(method, builder).append("()\n")
               .append(INDENT).append(INDENT).append("[component method with return type: ");
           if (qualifier.isPresent()) {
-            // TODO(user) use chenying's annotation mirror stringifier
+            // TODO(cgruber) use chenying's annotation mirror stringifier
             builder.append(qualifier.get()).append(' ');
           }
           builder.append(method.getReturnType()).append(']');
@@ -115,7 +115,7 @@
               .append(INDENT).append(INDENT).append("[injected field of type: ");
         }
         if (qualifier.isPresent()) {
-          // TODO(user) use chenying's annotation mirror stringifier
+          // TODO(cgruber) use chenying's annotation mirror stringifier
           builder.append(qualifier.get()).append(' ');
         }
         builder.append(resolvedVariableType)
diff --git a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
index c0af683f7..e5b657bee 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
@@ -240,7 +240,7 @@
    * (and possibly parameterized) type, and should NOT be used with
    * arbitrary text, especially prose error messages.
    *
-   * TODO(user): Tighten these to take type representations (mirrors
+   * TODO(cgruber): Tighten these to take type representations (mirrors
    *     and elements) to avoid accidental mis-use by running errors
    *     through this method.
    */
@@ -260,7 +260,7 @@ static String stripCommonTypePrefixes(String type) {
     return result.toString();
   }
 
-  //TODO(user): Extract Formatter and do something less stringy.
+  //TODO(cgruber): Extract Formatter and do something less stringy.
   static String format(AnnotationMirror annotation) {
     return stripCommonTypePrefixes(annotation.toString());
   }
diff --git a/compiler/src/main/java/dagger/internal/codegen/KeyFormatter.java b/compiler/src/main/java/dagger/internal/codegen/KeyFormatter.java
index 7e342876e..d2e62fcab 100644
--- a/compiler/src/main/java/dagger/internal/codegen/KeyFormatter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/KeyFormatter.java
@@ -26,10 +26,10 @@
   @Override public String format(Key request) {
     StringBuilder builder = new StringBuilder();
     if (request.qualifier().isPresent()) {
-      builder.append(request.qualifier()); // TODO(user): Use AnnotationMirrorFormatter.
+      builder.append(request.qualifier()); // TODO(cgruber): Use AnnotationMirrorFormatter.
       builder.append(' ');
     }
-    builder.append(request.type()); // TODO(user): Use TypeMirrorFormatter.
+    builder.append(request.type()); // TODO(cgruber): Use TypeMirrorFormatter.
     return builder.toString();
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/MethodSignatureFormatter.java b/compiler/src/main/java/dagger/internal/codegen/MethodSignatureFormatter.java
index 71ddfe6d6..9f8514df8 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MethodSignatureFormatter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MethodSignatureFormatter.java
@@ -62,7 +62,7 @@ public String format(ExecutableElement method, Optional<DeclaredType> container)
       type = MoreElements.asType(container.get().asElement());
     }
 
-    // TODO(user): AnnotationMirror formatter.
+    // TODO(cgruber): AnnotationMirror formatter.
     List<? extends AnnotationMirror> annotations = method.getAnnotationMirrors();
     if (!annotations.isEmpty()) {
       Iterator<? extends AnnotationMirror> annotationIterator = annotations.iterator();
diff --git a/compiler/src/main/java/dagger/internal/codegen/Util.java b/compiler/src/main/java/dagger/internal/codegen/Util.java
index 34df7eac9..2b633b33b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Util.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Util.java
@@ -50,7 +50,7 @@ public static TypeMirror getProvidedValueTypeOfMap(DeclaredType mapType) {
     return MoreTypes.asDeclared(mapType.getTypeArguments().get(1)).getTypeArguments().get(0);
   }
 
-  // TODO(user): Consider an object that holds and exposes the various parts of a Map type.
+  // TODO(cgruber): Consider an object that holds and exposes the various parts of a Map type.
   /**
    * returns the value type for a {@link Map} type like Map<K, V>}.
    */
diff --git a/compiler/src/test/java/dagger/internal/codegen/KeyTest.java b/compiler/src/test/java/dagger/internal/codegen/KeyTest.java
index 461c6c3c8..dde52f754 100644
--- a/compiler/src/test/java/dagger/internal/codegen/KeyTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/KeyTest.java
@@ -205,7 +205,7 @@ String provideQualifiedString() {
     ExecutableElement integerMethod = Iterables.getOnlyElement(
         ElementFilter.methodsIn(boxedPrimitiveHolder.getEnclosedElements()));
 
-    // TODO(user): Truth subject for TypeMirror and TypeElement
+    // TODO(cgruber): Truth subject for TypeMirror and TypeElement
     TypeMirror intType = intMethod.getReturnType();
     assertThat(intType.getKind().isPrimitive()).isTrue();
     TypeMirror integerType = integerMethod.getReturnType();
diff --git a/compiler/src/test/java/dagger/tests/integration/operation/PrimitiveInjectionTest.java b/compiler/src/test/java/dagger/tests/integration/operation/PrimitiveInjectionTest.java
index 9a561e9ad..6ed0b5e5b 100644
--- a/compiler/src/test/java/dagger/tests/integration/operation/PrimitiveInjectionTest.java
+++ b/compiler/src/test/java/dagger/tests/integration/operation/PrimitiveInjectionTest.java
@@ -30,7 +30,7 @@
 @RunWith(JUnit4.class)
 public final class PrimitiveInjectionTest {
 
-  // TODO(user): Use @test.ForTest to qualify primitives once qualifier equivalence is working.
+  // TODO(cgruber): Use @test.ForTest to qualify primitives once qualifier equivalence is working.
   /*
   JavaFileObject annotation = JavaFileObjects.forSourceLines("test.ForTest",
       "package test;",
@@ -40,7 +40,7 @@
       "}");
   */
 
-  // TODO(user): Expand test to support more primitive types when b/15512877 is fixed.
+  // TODO(cgruber): Expand test to support more primitive types when b/15512877 is fixed.
   JavaFileObject primitiveInjectable = JavaFileObjects.forSourceLines("test.PrimitiveInjectable",
       "package test;",
       "import javax.inject.Inject;",
diff --git a/core/src/main/java/dagger/Module.java b/core/src/main/java/dagger/Module.java
index 33c10857b..d566c5876 100644
--- a/core/src/main/java/dagger/Module.java
+++ b/core/src/main/java/dagger/Module.java
@@ -93,6 +93,6 @@
    * this property and it is present for compatibility with Dagger 1.x during
    * migrations.
    */
-  // TODO(user): Deprecate this property.
+  // TODO(cgruber): Deprecate this property.
   boolean library() default true;
 }
diff --git a/deploy_website.sh b/deploy_website.sh
old mode 100644
new mode 100755
diff --git a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/DemoApplication.java b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/DemoApplication.java
index 2b65da692..71a003089 100644
--- a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/DemoApplication.java
+++ b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/DemoApplication.java
@@ -17,12 +17,13 @@
 
 import android.app.Application;
 import android.location.LocationManager;
+import javax.inject.Singleton;
 import javax.inject.Inject;
 
 public class DemoApplication extends Application {
   private ApplicationComponent applicationComponent;
 
-  // TODO(user): Figure out a better example of something one might inject into the app.
+  // TODO(cgruber): Figure out a better example of something one might inject into the app.
   @Inject LocationManager locationManager; // to illustrate injecting somethign into the app.
 
   @Override public void onCreate() {
diff --git a/producers/src/main/java/dagger/producers/internal/SetProducer.java b/producers/src/main/java/dagger/producers/internal/SetProducer.java
index 234ff7ebd..399dbd031 100644
--- a/producers/src/main/java/dagger/producers/internal/SetProducer.java
+++ b/producers/src/main/java/dagger/producers/internal/SetProducer.java
@@ -62,7 +62,8 @@ private SetProducer(Set<Producer<Set<T>>> contributingProducers) {
    */
   @Override
   public ListenableFuture<Set<T>> compute() {
-    List<ListenableFuture<Set<T>>> futureSets = new ArrayList<>(contributingProducers.size());
+    List<ListenableFuture<Set<T>>> futureSets =
+        new ArrayList<ListenableFuture<Set<T>>>(contributingProducers.size());
     for (Producer<Set<T>> producer : contributingProducers) {
       ListenableFuture<Set<T>> futureSet = producer.get();
       if (futureSet == null) {
@@ -72,7 +73,7 @@ private SetProducer(Set<Producer<Set<T>>> contributingProducers) {
     }
     return Futures.transform(Futures.allAsList(futureSets), new Function<List<Set<T>>, Set<T>>() {
       @Override public Set<T> apply(List<Set<T>> sets) {
-        ImmutableSet.Builder<T> builder = new ImmutableSet.Builder<>();
+        ImmutableSet.Builder<T> builder = ImmutableSet.builder();
         for (Set<T> set : sets) {
           builder.addAll(set);
         }
