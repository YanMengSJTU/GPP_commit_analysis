diff --git a/compiler/src/main/java/dagger/internal/codegen/Binding.java b/compiler/src/main/java/dagger/internal/codegen/Binding.java
index 8ccd4ae13..29f17b3c5 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Binding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Binding.java
@@ -23,6 +23,7 @@
 import java.util.List;
 import java.util.Set;
 import javax.lang.model.element.Element;
+import javax.lang.model.element.ElementVisitor;
 import javax.lang.model.element.Name;
 import javax.lang.model.element.PackageElement;
 import javax.lang.model.element.TypeElement;
@@ -71,19 +72,22 @@
 
   /** The type enclosing the binding {@link #bindingElement()}. */
   TypeElement bindingTypeElement() {
-    return bindingElement().accept(new SimpleElementVisitor6<TypeElement, Void>() {
-      @Override
-      protected TypeElement defaultAction(Element e, Void p) {
-        return MoreElements.asType(bindingElement().getEnclosingElement());
-      }
-
-      @Override
-      public TypeElement visitType(TypeElement e, Void p) {
-        return e;
-      }
-    }, null);
+    return BINDING_TYPE_ELEMENT.visit(bindingElement());
   }
 
+  private static final ElementVisitor<TypeElement, Void> BINDING_TYPE_ELEMENT =
+      new SimpleElementVisitor6<TypeElement, Void>() {
+        @Override
+        protected TypeElement defaultAction(Element e, Void p) {
+          return visit(e.getEnclosingElement());
+        }
+
+        @Override
+        public TypeElement visitType(TypeElement e, Void p) {
+          return e;
+        }
+      };
+
   /**
    * The explicit set of {@link DependencyRequest dependencies} required to satisfy this binding.
    */
@@ -166,12 +170,12 @@ static boolean hasNonDefaultTypeParameters(TypeElement element, TypeMirror type,
     if (element.getTypeParameters().isEmpty()) {
       return false;
     }
-    
+
     List<TypeMirror> defaultTypes = Lists.newArrayList();
     for (TypeParameterElement parameter : element.getTypeParameters()) {
       defaultTypes.add(parameter.asType());
     }
-    
+
     List<TypeMirror> actualTypes =
         type.accept(
             new SimpleTypeVisitor6<List<TypeMirror>, Void>() {
@@ -186,7 +190,7 @@ static boolean hasNonDefaultTypeParameters(TypeElement element, TypeMirror type,
               }
             },
             null);
-    
+
     // The actual type parameter size can be different if the user is using a raw type.
     if (defaultTypes.size() != actualTypes.size()) {
       return true;
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java
index db30d57cd..b2f4dd119 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java
@@ -88,6 +88,8 @@
 import static com.google.common.base.Verify.verify;
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static dagger.internal.codegen.Binding.bindingPackageFor;
+import static dagger.internal.codegen.ComponentGenerator.MemberSelect.staticMethodInvocationWithCast;
+import static dagger.internal.codegen.ComponentGenerator.MemberSelect.staticSelect;
 import static dagger.internal.codegen.ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD;
 import static dagger.internal.codegen.MapKeys.getMapKeySnippet;
 import static dagger.internal.codegen.MembersInjectionBinding.Strategy.NO_OP;
@@ -376,56 +378,27 @@ private void writeField(
       ResolvedBindings resolvedBindings) {
     BindingKey bindingKey = resolvedBindings.bindingKey();
 
-    if (bindingKey.kind().equals(BindingKey.Kind.CONTRIBUTION)
-        && resolvedBindings.ownedContributionBindings().isEmpty()
-        && !ContributionBinding.bindingTypeFor(resolvedBindings.contributionBindings())
-            .isMultibinding()) {
+    // No field needed for unique contributions inherited from the parent.
+    if (resolvedBindings.isUniqueContribution() && resolvedBindings.ownedBindings().isEmpty()) {
       return;
     }
 
-    if (resolvedBindings.bindings().size() == 1) {
-      if (bindingKey.kind().equals(BindingKey.Kind.CONTRIBUTION)) {
-        ContributionBinding contributionBinding =
-            Iterables.getOnlyElement(resolvedBindings.contributionBindings());
-        if (!contributionBinding.bindingType().isMultibinding()
-            && (contributionBinding instanceof ProvisionBinding)) {
-          ProvisionBinding provisionBinding = (ProvisionBinding) contributionBinding;
-          if (provisionBinding.factoryCreationStrategy().equals(ENUM_INSTANCE)
-              && !provisionBinding.scope().isPresent()) {
-            enumBindingKeysBuilder.add(bindingKey);
-            // skip keys whose factories are enum instances and aren't scoped
-            memberSelectSnippetsBuilder.put(bindingKey,
-                MemberSelect.staticSelect(
-                    factoryNameForProvisionBinding(provisionBinding),
-                    Snippet.format("create()")));
-            return;
-          }
-        }
-      } else if (bindingKey.kind().equals(BindingKey.Kind.MEMBERS_INJECTION)) {
-        MembersInjectionBinding membersInjectionBinding =
-            Iterables.getOnlyElement(resolvedBindings.membersInjectionBindings());
-        if (membersInjectionBinding.injectionStrategy().equals(NO_OP)) {
-          // TODO(gak): refactor to use enumBindingKeys throughout the generator
-          enumBindingKeysBuilder.add(bindingKey);
-          // TODO(gak): suppress the warnings in a reasonable place
-          memberSelectSnippetsBuilder.put(bindingKey,
-              MemberSelect.staticMethodInvocationWithCast(
-                  ClassName.fromClass(MembersInjectors.class),
-                  Snippet.format("noOp()"),
-                  ClassName.fromClass(MembersInjector.class)));
-          return;
-        }
-      }
+    // No field needed for bindings with no dependencies or state.
+    Optional<MemberSelect> staticMemberSelect = staticMemberSelect(resolvedBindings);
+    if (staticMemberSelect.isPresent()) {
+      // TODO(gak): refactor to use enumBindingKeys throughout the generator
+      enumBindingKeysBuilder.add(bindingKey);
+      memberSelectSnippetsBuilder.put(bindingKey, staticMemberSelect.get());
+      return;
     }
 
-    String bindingPackage = bindingPackageFor(resolvedBindings.bindings())
-        .or(componentWriter.name().packageName());
+    String bindingPackage = bindingPackageFor(resolvedBindings.bindings()).or(name.packageName());
 
     final Optional<String> proxySelector;
     final TypeWriter classWithFields;
     final Set<Modifier> fieldModifiers;
 
-    if (bindingPackage.equals(componentWriter.name().packageName())) {
+    if (bindingPackage.equals(name.packageName())) {
       // no proxy
       proxySelector = Optional.absent();
       // component gets the fields
@@ -438,10 +411,8 @@ private void writeField(
       if (proxyClassAndField == null) {
         JavaWriter proxyJavaWriter = JavaWriter.inPackage(bindingPackage);
         javaWriters.add(proxyJavaWriter);
-        ClassWriter proxyWriter =
-            proxyJavaWriter.addClass(componentWriter.name().simpleName() + "_PackageProxy");
-        proxyWriter.annotate(Generated.class)
-            .setValue(ComponentProcessor.class.getCanonicalName());
+        ClassWriter proxyWriter = proxyJavaWriter.addClass(name.simpleName() + "_PackageProxy");
+        proxyWriter.annotate(Generated.class).setValue(ComponentProcessor.class.getCanonicalName());
         proxyWriter.addModifiers(PUBLIC, FINAL);
         // create the field for the proxy in the component
         FieldWriter proxyFieldWriter =
@@ -507,6 +478,51 @@ private void writeField(
         MemberSelect.instanceSelect(name, Snippet.memberSelectSnippet(memberSelectTokens)));
   }
 
+  /**
+   * If {@code resolvedBindings} is an unscoped provision binding with no factory arguments or a
+   * no-op members injection binding, then we do't need a field to hold its factory. In that case,
+   * this method returns the static member select snippet that returns the factory or no-op members
+   * injector.
+   */
+  private Optional<MemberSelect> staticMemberSelect(ResolvedBindings resolvedBindings) {
+    if (resolvedBindings.bindings().size() != 1) {
+      return Optional.absent();
+    }
+    switch (resolvedBindings.bindingKey().kind()) {
+      case CONTRIBUTION:
+        ContributionBinding contributionBinding =
+            getOnlyElement(resolvedBindings.contributionBindings());
+        if (contributionBinding.bindingType().isMultibinding()
+            || !(contributionBinding instanceof ProvisionBinding)) {
+          return Optional.absent();
+        }
+        ProvisionBinding provisionBinding = (ProvisionBinding) contributionBinding;
+        if (provisionBinding.factoryCreationStrategy().equals(ENUM_INSTANCE)
+            && !provisionBinding.scope().isPresent()) {
+          return Optional.of(
+              staticSelect(
+                  factoryNameForProvisionBinding(provisionBinding), Snippet.format("create()")));
+        }
+        break;
+
+      case MEMBERS_INJECTION:
+        if (getOnlyElement(resolvedBindings.membersInjectionBindings())
+            .injectionStrategy()
+            .equals(NO_OP)) {
+          return Optional.of(
+              staticMethodInvocationWithCast(
+                  ClassName.fromClass(MembersInjectors.class),
+                  Snippet.format("noOp()"),
+                  ClassName.fromClass(MembersInjector.class)));
+        }
+        break;
+
+      default:
+        throw new AssertionError();
+    }
+    return Optional.absent();
+  }
+
   protected void writeInterfaceMethods() {
     Set<MethodSignature> interfaceMethods = Sets.newHashSet();
 
@@ -716,7 +732,7 @@ protected void initializeFrameworkTypes(Optional<ClassName> builderName) {
       }
     }
   }
-  
+
   private void initializeDelegateFactories(Binding binding, MethodWriter initializeMethod) {
     for (Collection<DependencyRequest> requestsForKey :
         SourceFiles.indexDependenciesByUnresolvedKey(types, binding.dependencies())
@@ -747,10 +763,9 @@ public BindingKey apply(DependencyRequest request) {
       }
     }
   }
-  
-  private Snippet delegateFactoryVariableSnippet(BindingKey key){
-    return Snippet.format(
-        "%sDelegate", getMemberSelectSnippet(key).toString().replace('.', '_'));
+
+  private Snippet delegateFactoryVariableSnippet(BindingKey key) {
+    return Snippet.format("%sDelegate", getMemberSelectSnippet(key).toString().replace('.', '_'));
   }
 
   private Snippet initializeFactoryForContributionBinding(ContributionBinding binding) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
index 7097b9991..64f804da1 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
@@ -150,7 +150,7 @@ DependencyRequest forImplicitMapBinding(DependencyRequest delegatingRequest, Key
       checkNotNull(delegatingRequest);
       return new AutoValue_DependencyRequest(Kind.PROVIDER, delegateKey,
           delegatingRequest.requestElement(),
-          getEnclosingType(delegatingRequest.requestElement()),
+          delegatingRequest.enclosingType(),
           false /* doesn't allow null */);
     }
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java b/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
index 803ecc44b..28ce3c31a 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
@@ -90,4 +90,13 @@ boolean isMultibindings() {
         && !contributionBindings().isEmpty()
         && bindingTypeFor(contributionBindings()).isMultibinding();
   }
+
+  /**
+   * {@code true} if this is a unique contribution binding.
+   */
+  boolean isUniqueContribution() {
+    return bindingKey().kind().equals(BindingKey.Kind.CONTRIBUTION)
+        && !contributionBindings().isEmpty()
+        && !bindingTypeFor(contributionBindings()).isMultibinding();
+  }
 }
