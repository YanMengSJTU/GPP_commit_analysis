diff --git a/core/src/main/java/dagger/internal/SetFactory.java b/core/src/main/java/dagger/internal/SetFactory.java
index ecc43cb58..648679413 100644
--- a/core/src/main/java/dagger/internal/SetFactory.java
+++ b/core/src/main/java/dagger/internal/SetFactory.java
@@ -16,6 +16,8 @@
 package dagger.internal;
 
 import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
 import javax.inject.Provider;
@@ -33,31 +35,50 @@
  */
 public final class SetFactory<T> implements Factory<Set<T>> {
   /**
-   * Returns a new factory that creates {@link Set} instances that from the union of the given
-   * {@link Provider} instances.
+   * A message for NPEs that trigger on bad argument lists.
    */
-  public static <T> Factory<Set<T>> create(Provider<Set<T>> first,
-      @SuppressWarnings("unchecked") Provider<Set<T>>... rest) {
-    if (first == null) {
-      throw new NullPointerException();
-    }
-    if (rest == null) {
-      throw new NullPointerException();
-    }
-    Set<Provider<Set<T>>> contributingProviders = newLinkedHashSetWithExpectedSize(1 + rest.length);
-    contributingProviders.add(first);
-    for (Provider<Set<T>> provider : rest) {
-      if (provider == null) {
-        throw new NullPointerException();
-      }
-      contributingProviders.add(provider);
-    }
+  private static final String ARGUMENTS_MUST_BE_NON_NULL =
+      "SetFactory.create() requires its arguments to be non-null";
+
+  /**
+   * Returns the supplied factory.  If there's just one factory, there's no need to wrap it or its
+   * result.
+   */
+  public static <T> Factory<Set<T>> create(Factory<Set<T>> factory) {
+    assert factory != null : ARGUMENTS_MUST_BE_NON_NULL;
+    return factory;
+  }
+  
+  /**
+   * Returns a new factory that creates {@link Set} instances that form the union of the given
+   * {@link Provider} instances.  Callers must not modify the providers array after invoking this
+   * method; no copy is made.
+   */
+  public static <T> Factory<Set<T>> create(
+      @SuppressWarnings("unchecked") Provider<Set<T>>... providers) {
+    assert providers != null : ARGUMENTS_MUST_BE_NON_NULL;
+
+    List<Provider<Set<T>>> contributingProviders = Arrays.asList(providers);
+
+    assert !contributingProviders.contains(null)
+        : "Codegen error?  Null within provider list.";
+    assert !hasDuplicates(contributingProviders)
+        : "Codegen error?  Duplicates in the provider list";
+
     return new SetFactory<T>(contributingProviders);
   }
 
-  private final Set<Provider<Set<T>>> contributingProviders;
+  /**
+   * Returns true if at least one pair of items in (@code original) are equals.
+   */
+  private static boolean hasDuplicates(List<? extends Object> original) {
+    Set<Object> asSet = new HashSet<>(original);
+    return original.size() != asSet.size();
+  }
+
+  private final List<Provider<Set<T>>> contributingProviders;
 
-  private SetFactory(Set<Provider<Set<T>>> contributingProviders) {
+  private SetFactory(List<Provider<Set<T>>> contributingProviders) {
     this.contributingProviders = contributingProviders;
   }
 
@@ -70,21 +91,26 @@ private SetFactory(Set<Provider<Set<T>>> contributingProviders) {
    */
   @Override
   public Set<T> get() {
+    int size = 0;
+
+    // Profiling revealed that this method was a CPU-consuming hotspot in some applications, so
+    // these loops were changed to use c-style for.  Versus enhanced for-each loops, C-style for is 
+    // faster for ArrayLists, at least through Java 8.
+
     List<Set<T>> providedSets = new ArrayList<Set<T>>(contributingProviders.size());
-    for (Provider<Set<T>> provider : contributingProviders) {
+    for (int i = 0, c = contributingProviders.size(); i < c; i++) {
+      Provider<Set<T>> provider = contributingProviders.get(i);
       Set<T> providedSet = provider.get();
       if (providedSet == null) {
         throw new NullPointerException(provider + " returned null");
       }
       providedSets.add(providedSet);
-    }
-    int size = 0;
-    for (Set<T> providedSet : providedSets) {
       size += providedSet.size();
     }
+
     Set<T> result = newLinkedHashSetWithExpectedSize(size);
-    for (Set<T> s : providedSets) {
-      for (T element : s) {
+    for (int i = 0, c = providedSets.size(); i < c; i++) {
+      for (T element : providedSets.get(i)) {
         if (element == null) {
           throw new NullPointerException("a null element was provided");
         }
diff --git a/core/src/test/java/dagger/internal/SetFactoryTest.java b/core/src/test/java/dagger/internal/SetFactoryTest.java
index fcd6f6efb..04b982281 100644
--- a/core/src/test/java/dagger/internal/SetFactoryTest.java
+++ b/core/src/test/java/dagger/internal/SetFactoryTest.java
@@ -37,34 +37,39 @@
   @Rule public ExpectedException thrown = ExpectedException.none();
 
   @Test
-  public void nullFirstProvider() {
-    thrown.expect(NullPointerException.class);
-    SetFactory.create(null);
-  }
-
-  @Test
-  public void nullRest() {
+  public void providerReturnsNullSet() {
+    Factory<Set<Integer>> factory = SetFactory.create(new Provider<Set<Integer>>() {
+      @Override
+      public Set<Integer> get() {
+        return null;
+      }
+    }, incrementingIntegerProvider(0));
     thrown.expect(NullPointerException.class);
-    SetFactory.create(incrementingIntegerProvider(1),
-        (Provider<Set<Integer>>[]) null);
+    factory.get();
   }
 
   @Test
-  public void nullProviderInRest() {
+  public void providerReturnsNullSet_single() {
+    Factory<Set<Integer>> factory = SetFactory.create(new Provider<Set<Integer>>() {
+      @Override
+      public Set<Integer> get() {
+        return null;
+      }
+    });
     thrown.expect(NullPointerException.class);
-    SetFactory.create(
-        incrementingIntegerProvider(1),
-        incrementingIntegerProvider(2),
-        null,
-        incrementingIntegerProvider(3));
+    factory.get();
   }
 
   @Test
-  public void providerReturnsNullSet() {
+  public void providerReturnsSetWithNullElement() {
     Factory<Set<Integer>> factory = SetFactory.create(new Provider<Set<Integer>>() {
       @Override
       public Set<Integer> get() {
-        return null;
+        LinkedHashSet<Integer> result = new LinkedHashSet<Integer>();
+        result.add(1);
+        result.add(null);
+        result.add(3);
+        return result;
       }
     });
     thrown.expect(NullPointerException.class);
@@ -72,7 +77,7 @@ public void providerReturnsNullSet() {
   }
 
   @Test
-  public void providerReturnsSetWithNullElement() {
+  public void providerReturnsSetWithNullElement_single() {
     Factory<Set<Integer>> factory = SetFactory.create(new Provider<Set<Integer>>() {
       @Override
       public Set<Integer> get() {
@@ -82,7 +87,7 @@ public void providerReturnsSetWithNullElement() {
         result.add(3);
         return result;
       }
-    });
+    }, incrementingIntegerProvider(0));
     thrown.expect(NullPointerException.class);
     factory.get();
   }
