diff --git a/compiler/src/it/producers-functional-tests/src/main/java/test/ResponseModule.java b/compiler/src/it/producers-functional-tests/src/main/java/test/ResponseModule.java
new file mode 100644
index 000000000..4a83c6c83
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/test/ResponseModule.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import dagger.Module;
+import dagger.Provides;
+
+@Module
+final class ResponseModule {
+  @Provides
+  static int requestNumber() {
+    return 5;
+  }
+}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/test/ResponseProducerModule.java b/compiler/src/it/producers-functional-tests/src/main/java/test/ResponseProducerModule.java
index bda53eb56..f3ad22939 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/test/ResponseProducerModule.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/test/ResponseProducerModule.java
@@ -20,13 +20,15 @@
 import dagger.producers.ProducerModule;
 import dagger.producers.Produces;
 
-@ProducerModule
+@ProducerModule(includes = ResponseModule.class)
 final class ResponseProducerModule {
-  @Produces ListenableFuture<String> greeting() {
+  @Produces
+  static ListenableFuture<String> greeting() {
     return Futures.immediateFuture("Hello");
   }
 
-  @Produces Response response(String greeting, Request request) {
-    return new Response(greeting + ", " + request.name() + "!");
+  @Produces
+  static Response response(String greeting, Request request, int requestNumber) {
+    return new Response(String.format("%s, %s #%d!", greeting, request.name(), requestNumber));
   }
 }
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/test/SimpleTest.java b/compiler/src/it/producers-functional-tests/src/test/java/test/SimpleTest.java
index f2b910e3c..e6e73961c 100644
--- a/compiler/src/it/producers-functional-tests/src/test/java/test/SimpleTest.java
+++ b/compiler/src/it/producers-functional-tests/src/test/java/test/SimpleTest.java
@@ -30,6 +30,6 @@
         .executor(MoreExecutors.directExecutor())
         .build();
     assertThat(simpleComponent).isNotNull();
-    assertThat(simpleComponent.response().get().data()).isEqualTo("Hello, Request!");
+    assertThat(simpleComponent.response().get().data()).isEqualTo("Hello, Request #5!");
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
index afc0ab622..1e96a534a 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -24,6 +24,7 @@
 import dagger.Provides;
 import dagger.producers.ProducerModule;
 import dagger.producers.Produces;
+import java.lang.annotation.Annotation;
 import java.util.EnumSet;
 import java.util.Map;
 import java.util.Set;
@@ -93,8 +94,14 @@ public SourceVersion getSupportedSourceVersion() {
     InjectMethodValidator injectMethodValidator = new InjectMethodValidator(
         privateMemberValidationType(processingEnv).diagnosticKind().get(),
         staticMemberValidationType(processingEnv).diagnosticKind().get());
-    ModuleValidator moduleValidator = new ModuleValidator(types, elements, methodSignatureFormatter,
-        Module.class, Provides.class);
+    ModuleValidator moduleValidator =
+        new ModuleValidator(
+            types,
+            elements,
+            methodSignatureFormatter,
+            Module.class,
+            ImmutableList.<Class<? extends Annotation>>of(Module.class),
+            Provides.class);
     ProvidesMethodValidator providesMethodValidator = new ProvidesMethodValidator(elements);
     BuilderValidator componentBuilderValidator =
         new BuilderValidator(elements, types, ComponentDescriptor.Kind.COMPONENT);
@@ -105,8 +112,14 @@ public SourceVersion getSupportedSourceVersion() {
     ComponentValidator componentValidator = ComponentValidator.createForComponent(elements, types,
         moduleValidator, subcomponentValidator, subcomponentBuilderValidator);
     MapKeyValidator mapKeyValidator = new MapKeyValidator();
-    ModuleValidator producerModuleValidator = new ModuleValidator(types, elements,
-        methodSignatureFormatter, ProducerModule.class, Produces.class);
+    ModuleValidator producerModuleValidator =
+        new ModuleValidator(
+            types,
+            elements,
+            methodSignatureFormatter,
+            ProducerModule.class,
+            ImmutableList.of(Module.class, ProducerModule.class),
+            Produces.class);
     ProducesMethodValidator producesMethodValidator = new ProducesMethodValidator(elements);
     ProductionComponentValidator productionComponentValidator = new ProductionComponentValidator();
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
index c3126ead0..39e5e8ce9 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
@@ -155,7 +155,7 @@ static String duplicateMapKeysError(String key) {
       "%s is listed as a module, but is an abstract class or interface";
 
   static final String REFERENCED_MODULE_NOT_ANNOTATED =
-      "%s is listed as a module, but is not annotated with @%s";
+      "%s is listed as a module, but is not annotated with %s";
 
   static final String REFERENCED_MODULE_MUST_NOT_HAVE_TYPE_PARAMS =
       "%s is listed as a module, but has type parameters";
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java b/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java
index 516d0e0ae..8b0c9a217 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java
@@ -50,6 +50,7 @@
 import static com.google.auto.common.Visibility.PRIVATE;
 import static com.google.auto.common.Visibility.PUBLIC;
 import static com.google.auto.common.Visibility.effectiveVisibilityOfElement;
+import static com.google.common.collect.Iterables.any;
 import static dagger.internal.codegen.ConfigurationAnnotations.getModuleIncludes;
 import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_WITH_SAME_NAME;
 import static dagger.internal.codegen.ErrorMessages.METHOD_OVERRIDES_PROVIDES_METHOD;
@@ -70,6 +71,7 @@
   private final Types types;
   private final Elements elements;
   private final Class<? extends Annotation> moduleClass;
+  private final ImmutableList<Class<? extends Annotation>> includedModuleClasses;
   private final Class<? extends Annotation> methodClass;
   private final MethodSignatureFormatter methodSignatureFormatter;
 
@@ -78,10 +80,12 @@
       Elements elements,
       MethodSignatureFormatter methodSignatureFormatter,
       Class<? extends Annotation> moduleClass,
+      ImmutableList<Class<? extends Annotation>> includedModuleClasses,
       Class<? extends Annotation> methodClass) {
     this.types = types;
     this.elements = elements;
     this.moduleClass = moduleClass;
+    this.includedModuleClasses = includedModuleClasses;
     this.methodClass = methodClass;
     this.methodSignatureFormatter = methodSignatureFormatter;
   }
@@ -161,19 +165,39 @@ protected Void defaultAction(TypeMirror mirror, Void p) {
 
             @Override
             public Void visitDeclared(DeclaredType t, Void p) {
-              TypeElement element = MoreElements.asType(t.asElement());
+              final TypeElement element = MoreElements.asType(t.asElement());
               if (!t.getTypeArguments().isEmpty()) {
                 builder.addError(
                     String.format(
                         REFERENCED_MODULE_MUST_NOT_HAVE_TYPE_PARAMS, element.getQualifiedName()),
                     subject);
               }
-              if (!getAnnotationMirror(element, moduleClass).isPresent()) {
+              boolean isIncludedModule =
+                  any(
+                      includedModuleClasses,
+                      new Predicate<Class<? extends Annotation>>() {
+                        @Override
+                        public boolean apply(Class<? extends Annotation> otherClass) {
+                          return MoreElements.isAnnotationPresent(element, otherClass);
+                        }
+                      });
+              if (!isIncludedModule) {
                 builder.addError(
                     String.format(
                         REFERENCED_MODULE_NOT_ANNOTATED,
                         element.getQualifiedName(),
-                        moduleClass.getSimpleName()),
+                        (includedModuleClasses.size() > 1 ? "one of " : "")
+                            + Joiner.on(", ")
+                                .join(
+                                    FluentIterable.from(includedModuleClasses)
+                                        .transform(
+                                            new Function<Class<? extends Annotation>, String>() {
+                                              @Override
+                                              public String apply(
+                                                  Class<? extends Annotation> otherClass) {
+                                                return "@" + otherClass.getSimpleName();
+                                              }
+                                            }))),
                     subject);
               }
               if (element.getModifiers().contains(ABSTRACT)) {
diff --git a/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java b/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
index 1eeda25e3..72248e0c7 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
@@ -322,11 +322,13 @@ private String formatModuleErrorMessage(String msg) {
         "",
         "@Module(includes = Void.class)",
         "class TestModule {}");
-    assertAbout(javaSources()).that(ImmutableList.of(module))
+    assertAbout(javaSources())
+        .that(ImmutableList.of(module))
         .processedWith(new ComponentProcessor())
         .failsToCompile()
-        .withErrorContaining(String.format(ErrorMessages.REFERENCED_MODULE_NOT_ANNOTATED,
-            "java.lang.Void", "Module"));
+        .withErrorContaining(
+            String.format(
+                ErrorMessages.REFERENCED_MODULE_NOT_ANNOTATED, "java.lang.Void", "@Module"));
   }
 
   @Test public void referencedModulesMustNotBeAbstract() {
diff --git a/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java b/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
index 01e6aa325..fa466a630 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
@@ -378,6 +378,31 @@ public void enclosedInPrivateModule() {
         .in(moduleFile).onLine(7);
   }
 
+  @Test
+  public void includesNonModule() {
+    JavaFileObject xFile =
+        JavaFileObjects.forSourceLines("test.X", "package test;", "", "public final class X {}");
+    JavaFileObject moduleFile =
+        JavaFileObjects.forSourceLines(
+            "test.FooModule",
+            "package test;",
+            "",
+            "import dagger.producers.ProducerModule;",
+            "",
+            "@ProducerModule(includes = X.class)",
+            "public final class FooModule {",
+            "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(xFile, moduleFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            String.format(
+                ErrorMessages.REFERENCED_MODULE_NOT_ANNOTATED,
+                "X",
+                "one of @Module, @ProducerModule"));
+  }
+
   @Test
   public void publicModuleNonPublicIncludes() {
     JavaFileObject publicModuleFile = JavaFileObjects.forSourceLines("test.PublicModule",
