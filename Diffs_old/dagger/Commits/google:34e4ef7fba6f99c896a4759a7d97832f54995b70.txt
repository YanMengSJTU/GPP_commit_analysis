diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
index 65bd4dbab..54c7d0a68 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -659,26 +659,29 @@ private void implementInterfaceMethods() {
     for (ComponentMethodDescriptor componentMethod :
         graph.componentDescriptor().componentMethods()) {
       if (componentMethod.dependencyRequest().isPresent()) {
-        DependencyRequest interfaceRequest = componentMethod.dependencyRequest().get();
-        ExecutableElement requestElement =
-            MoreElements.asExecutable(interfaceRequest.requestElement());
-        ExecutableType requestType = MoreTypes.asExecutable(types.asMemberOf(
-            MoreTypes.asDeclared(componentDefinitionType().asType()), requestElement));
-        MethodSignature signature = MethodSignature.fromExecutableType(
-            requestElement.getSimpleName().toString(), requestType);
+        ExecutableElement methodElement =
+            MoreElements.asExecutable(componentMethod.methodElement());
+        ExecutableType requestType =
+            MoreTypes.asExecutable(
+                types.asMemberOf(
+                    MoreTypes.asDeclared(componentDefinitionType().asType()), methodElement));
+        MethodSignature signature =
+            MethodSignature.fromExecutableType(
+                methodElement.getSimpleName().toString(), requestType);
         if (!interfaceMethods.contains(signature)) {
           interfaceMethods.add(signature);
           MethodSpec.Builder interfaceMethod =
-              methodBuilder(requestElement.getSimpleName().toString())
+              methodBuilder(methodElement.getSimpleName().toString())
                   .addAnnotation(Override.class)
                   .addModifiers(PUBLIC)
                   .returns(TypeName.get(requestType.getReturnType()));
+          DependencyRequest interfaceRequest = componentMethod.dependencyRequest().get();
           BindingKey bindingKey = interfaceRequest.bindingKey();
           MemberSelect memberSelect = getMemberSelect(bindingKey);
           CodeBlock memberSelectCodeBlock = memberSelect.getExpressionFor(name);
           switch (interfaceRequest.kind()) {
             case MEMBERS_INJECTOR:
-              List<? extends VariableElement> parameters = requestElement.getParameters();
+              List<? extends VariableElement> parameters = methodElement.getParameters();
               if (parameters.isEmpty()) {
                 // we're returning the framework type
                 interfaceMethod.addStatement("return $L", memberSelectCodeBlock);
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
index 6e3f23741..df91437de 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -160,7 +160,7 @@
 
     /** The entry point. */
     Element entryPointElement() {
-      return path.getFirst().dependencyRequest().requestElement();
+      return path.getFirst().dependencyRequest().requestElement().get();
     }
 
     /** The current dependency request, which is a transitive dependency of the entry point. */
@@ -392,8 +392,7 @@ private void validateResolvedBindings(DependencyPath path) {
             throw new AssertionError(
                 "contribution binding keys should never have members injection bindings");
           }
-          validateNullability(
-              path.currentDependencyRequest(), resolvedBindings.contributionBindings());
+          validateNullability(path, resolvedBindings.contributionBindings());
           if (resolvedBindings.contributionBindings().size() > 1) {
             reportDuplicateBindings(path);
             return;
@@ -517,9 +516,12 @@ private ResolvedBindings inlineContributionsWithoutBindingElements(
           .build();
     }
 
-    /** Ensures that if the request isn't nullable, then each contribution is also not nullable. */
-    private void validateNullability(DependencyRequest request, Set<ContributionBinding> bindings) {
-      if (request.isNullable()) {
+    /**
+     * Ensures that if the current request isn't nullable, then each contribution is also not
+     * nullable.
+     */
+    private void validateNullability(DependencyPath path, Set<ContributionBinding> bindings) {
+      if (path.currentDependencyRequest().isNullable()) {
         return;
       }
 
@@ -528,16 +530,16 @@ private void validateNullability(DependencyRequest request, Set<ContributionBind
        * (Maybe this happens if the code was already compiled before this point?)
        * ... we manually print out the request in that case, otherwise the error
        * message is kind of useless. */
-      String typeName = TypeName.get(request.key().type()).toString();
+      String typeName = TypeName.get(path.currentDependencyRequest().key().type()).toString();
 
       for (ContributionBinding binding : bindings) {
         if (binding.nullableType().isPresent()) {
           reportBuilder.addItem(
               nullableToNonNullable(typeName, bindingDeclarationFormatter.format(binding))
                   + "\n at: "
-                  + dependencyRequestFormatter.format(request),
+                  + dependencyRequestFormatter.toDependencyTrace(path),
               compilerOptions.nullableValidationKind(),
-              request.requestElement());
+              path.entryPointElement());
         }
       }
     }
@@ -583,10 +585,9 @@ private void validateMapKeyAnnotationTypes(
       }
     }
 
-    /**
-     * Reports errors if a members injection binding is invalid.
-     */
-    private void validateMembersInjectionBinding(Binding binding, final DependencyPath path) {
+    /** Reports errors if a members injection binding is invalid. */
+    private void validateMembersInjectionBinding(
+        final MembersInjectionBinding binding, final DependencyPath path) {
       binding
           .key()
           .type()
@@ -595,8 +596,7 @@ private void validateMembersInjectionBinding(Binding binding, final DependencyPa
                 @Override
                 protected Void defaultAction(TypeMirror e, Void p) {
                   reportBuilder.addError(
-                      "Invalid members injection request.",
-                      path.currentDependencyRequest().requestElement());
+                      "Invalid members injection request.", binding.membersInjectedType());
                   return null;
                 }
 
@@ -1180,7 +1180,7 @@ private void reportCycle(DependencyPath path) {
       return FluentIterable.from(cycle)
           .skip(1)
           .transform(ResolvedRequest.DEPENDENCY_REQUEST)
-          .filter(not(DependencyRequest.IS_SYNTHETIC))
+          .filter(DependencyRequest.HAS_REQUEST_ELEMENT)
           .filter(
               new Predicate<DependencyRequest>() {
                 @Override
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
index 70886d0f4..be829f1db 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
@@ -152,7 +152,8 @@ BindingKey bindingKey() {
     }
   }
 
-  abstract Element requestElement();
+  /** The element that declares this dependency request. Absent for synthetic requests. */
+  abstract Optional<Element> requestElement();
 
   /** Returns true if this request allows null objects. */
   abstract boolean isNullable();
@@ -163,22 +164,17 @@ BindingKey bindingKey() {
    */
   abstract Optional<String> overriddenVariableName();
 
-  /** {@code true} if this is a synthetic request, which should not appear in dependency traces. */
-  abstract boolean isSynthetic();
-
-  /** A predicate that passes for synthetic requests. */
-  static final Predicate<DependencyRequest> IS_SYNTHETIC =
+  /** A predicate that passes for requests with elements. */
+  static final Predicate<DependencyRequest> HAS_REQUEST_ELEMENT =
       new Predicate<DependencyRequest>() {
         @Override
         public boolean apply(DependencyRequest request) {
-          return request.isSynthetic();
+          return request.requestElement().isPresent();
         }
       };
 
   private static DependencyRequest.Builder builder() {
-    return new AutoValue_DependencyRequest.Builder()
-        .isNullable(false)
-        .isSynthetic(false);
+    return new AutoValue_DependencyRequest.Builder().isNullable(false);
   }
 
   @CanIgnoreReturnValue
@@ -194,12 +190,6 @@ public boolean apply(DependencyRequest request) {
 
     abstract Builder overriddenVariableName(Optional<String> overriddenVariableName);
 
-    abstract Builder isSynthetic(boolean isSynthetic);
-
-    Builder isSynthetic() {
-      return isSynthetic(true);
-    }
-
     @CheckReturnValue
     abstract DependencyRequest build();
   }
@@ -230,30 +220,23 @@ Builder isSynthetic() {
     }
 
     /**
-     * Creates a implicit {@link DependencyRequest} for {@code mapOfFactoryKey}, which will be used
-     * to satisfy the {@code mapOfValueRequest}.
+     * Creates a implicit {@link DependencyRequest} for {@code mapOfFactoryKey}.
      *
-     * @param mapOfValueRequest a request for {@code Map<K, V>}
      * @param mapOfFactoryKey a key equivalent to {@code mapOfValueRequest}'s key, whose type is
      *     {@code Map<K, Provider<V>>} or {@code Map<K, Producer<V>>}
      */
-    DependencyRequest forImplicitMapBinding(
-        DependencyRequest mapOfValueRequest, Key mapOfFactoryKey) {
-      checkNotNull(mapOfValueRequest);
+    DependencyRequest forImplicitMapBinding(Key mapOfFactoryKey) {
       return DependencyRequest.builder()
           .kind(Kind.PROVIDER)
           .key(mapOfFactoryKey)
-          .requestElement(mapOfValueRequest.requestElement())
-          .isSynthetic()
           .build();
     }
 
     /**
-     * Creates a dependency request, with the same element as {@code request}, for one individual
-     * {@code multibindingContribution}.
+     * Creates a synthetic dependency request for one individual {@code multibindingContribution}.
      */
-    DependencyRequest forMultibindingContribution(
-        DependencyRequest request, ContributionBinding multibindingContribution) {
+    private DependencyRequest forMultibindingContribution(
+        ContributionBinding multibindingContribution) {
       checkArgument(
           multibindingContribution.key().multibindingContributionIdentifier().isPresent(),
           "multibindingContribution's key must have a multibinding contribution identifier: %s",
@@ -261,8 +244,6 @@ DependencyRequest forMultibindingContribution(
       return DependencyRequest.builder()
           .kind(multibindingContributionRequestKind(multibindingContribution))
           .key(multibindingContribution.key())
-          .requestElement(request.requestElement())
-          .isSynthetic()
           .build();
     }
 
@@ -284,14 +265,14 @@ private Kind multibindingContributionRequestKind(ContributionBinding multibindin
     }
 
     /**
-     * Creates dependency requests, with the same element as {@code request}, for each individual
-     * multibinding contribution in {@code multibindingContributions}.
+     * Creates synthetic dependency requests for each individual multibinding contribution in {@code
+     * multibindingContributions}.
      */
     ImmutableSet<DependencyRequest> forMultibindingContributions(
-        DependencyRequest request, Iterable<ContributionBinding> multibindingContributions) {
+        Iterable<ContributionBinding> multibindingContributions) {
       ImmutableSet.Builder<DependencyRequest> requests = ImmutableSet.builder();
       for (ContributionBinding multibindingContribution : multibindingContributions) {
-        requests.add(forMultibindingContribution(request, multibindingContribution));
+        requests.add(forMultibindingContribution(multibindingContribution));
       }
       return requests.build();
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyRequestFormatter.java b/compiler/src/main/java/dagger/internal/codegen/DependencyRequestFormatter.java
index 74d57469a..5d5c6a544 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DependencyRequestFormatter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyRequestFormatter.java
@@ -80,7 +80,7 @@ String toDependencyTrace(DependencyPath dependencyPath) {
         .join(
             dependencyPath
                 .dependencyRequests()
-                .filter(Predicates.not(DependencyRequest.IS_SYNTHETIC))
+                .filter(DependencyRequest.HAS_REQUEST_ELEMENT)
                 .transform(this)
                 .filter(Predicates.not(Predicates.equalTo("")))
                 .toList()
@@ -93,6 +93,7 @@ String toDependencyTrace(DependencyPath dependencyPath) {
   public String format(DependencyRequest request) {
     return request
         .requestElement()
+        .get()
         .accept(
             new ElementKindVisitor7<String, DependencyRequest>() {
 
@@ -117,8 +118,8 @@ public String visitExecutableAsMethod(
 
               /**
                * Returns the description for {@link javax.inject.Inject @Inject} constructor and
-               * method parameters and for {@link dagger.Provides @Provides} and
-               * {@link dagger.producers.Produces @Produces} method parameters.
+               * method parameters and for {@link dagger.Provides @Provides} and {@link
+               * dagger.producers.Produces @Produces} method parameters.
                */
               @Override
               public String visitVariableAsParameter(
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyVariableNamer.java b/compiler/src/main/java/dagger/internal/codegen/DependencyVariableNamer.java
index f68cedf55..b84d338db 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DependencyVariableNamer.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyVariableNamer.java
@@ -16,6 +16,8 @@
 
 package dagger.internal.codegen;
 
+import static com.google.common.base.Preconditions.checkArgument;
+
 import com.google.common.base.Ascii;
 import com.google.common.base.CaseFormat;
 import com.google.common.base.Function;
@@ -42,7 +44,8 @@ public String apply(DependencyRequest dependency) {
     if (dependency.overriddenVariableName().isPresent()) {
       return dependency.overriddenVariableName().get();
     }
-    String variableName = dependency.requestElement().getSimpleName().toString();
+    checkArgument(dependency.requestElement().isPresent());
+    String variableName = dependency.requestElement().get().getSimpleName().toString();
     if (Ascii.isUpperCase(variableName.charAt(0))) {
       variableName = toLowerCamel(variableName);
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/FrameworkDependency.java b/compiler/src/main/java/dagger/internal/codegen/FrameworkDependency.java
index 0d69b5d31..a5dfed2dd 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FrameworkDependency.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FrameworkDependency.java
@@ -19,17 +19,14 @@
 import static com.google.common.collect.Iterables.getOnlyElement;
 
 import com.google.auto.value.AutoValue;
-import com.google.common.base.Function;
-import com.google.common.base.Functions;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ImmutableSetMultimap;
-import com.google.common.collect.Maps;
 import java.util.Collection;
+import java.util.Iterator;
 import javax.inject.Provider;
-import javax.lang.model.element.Element;
 
 /**
  * The framework class and binding key for a resolved dependency of a binding. If a binding has
@@ -137,43 +134,14 @@
    */
   private static ImmutableList<Collection<DependencyRequest>> groupByUnresolvedKey(
       Binding binding) {
-    // If the binding has no unresolved version, just group the dependencies by binding key.
-    if (!binding.unresolved().isPresent()) {
-      return groupByKey(binding, Functions.<DependencyRequest>identity());
-    }
-
-    // Group the unresolved dependencies, replacing each one with its resolved version by looking it
-    // up by request element.
-    final ImmutableMap<Element, DependencyRequest> resolvedDependencies =
-        Maps.uniqueIndex(
-            binding.implicitDependencies(),
-            new Function<DependencyRequest, Element>() {
-              @Override
-              public Element apply(DependencyRequest dependencyRequest) {
-                return dependencyRequest.requestElement();
-              }
-            });
-    return groupByKey(
-        binding.unresolved().get(),
-        new Function<DependencyRequest, DependencyRequest>() {
-          @Override
-          public DependencyRequest apply(DependencyRequest unresolvedRequest) {
-            return resolvedDependencies.get(unresolvedRequest.requestElement());
-          }
-        });
-  }
-
-  /**
-   * Groups a binding's dependency requests by their binding key.
-   *
-   * @param transformer applied to each dependency before inserting into the group
-   */
-  private static ImmutableList<Collection<DependencyRequest>> groupByKey(
-      Binding binding, Function<DependencyRequest, DependencyRequest> transformer) {
     ImmutableSetMultimap.Builder<BindingKey, DependencyRequest> dependenciesByKeyBuilder =
         ImmutableSetMultimap.builder();
-    for (DependencyRequest dependency : binding.implicitDependencies()) {
-      dependenciesByKeyBuilder.put(dependency.bindingKey(), transformer.apply(dependency));
+    Iterator<DependencyRequest> dependencies = binding.implicitDependencies().iterator();
+    Binding unresolved = binding.unresolved().isPresent() ? binding.unresolved().get() : binding;
+    Iterator<DependencyRequest> unresolvedDependencies =
+        unresolved.implicitDependencies().iterator();
+    while (dependencies.hasNext()) {
+      dependenciesByKeyBuilder.put(unresolvedDependencies.next().bindingKey(), dependencies.next());
     }
     return ImmutableList.copyOf(
         dependenciesByKeyBuilder
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
index 936d88c91..4b6563406 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
@@ -357,7 +357,7 @@ private MethodSpec injectorMethodForSubclasses(
   private String staticInjectMethodDependencyParameterName(
       Set<String> parameterNames, DependencyRequest dependency, FieldSpec field) {
     StringBuilder parameterName =
-        new StringBuilder(dependency.requestElement().getSimpleName().toString());
+        new StringBuilder(dependency.requestElement().get().getSimpleName().toString());
     switch (dependency.kind()) {
       case LAZY:
       case INSTANCE:
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
index 1921b6baf..7605e4d49 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
@@ -254,7 +254,7 @@ private CodeBlock producerTokenConstruction(
 
   /** Returns a name of the variable representing this dependency's future. */
   private static String dependencyFutureName(DependencyRequest dependency) {
-    return dependency.requestElement().getSimpleName() + "Future";
+    return dependency.requestElement().get().getSimpleName() + "Future";
   }
 
   /** Represents the transformation of an input future by a producer method. */
@@ -354,7 +354,7 @@ TypeName applyArgType() {
 
     @Override
     String applyArgName() {
-      return asyncDependency.requestElement().getSimpleName().toString();
+      return asyncDependency.requestElement().get().getSimpleName().toString();
     }
 
     @Override
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
index 1a50fb091..06d916892 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
@@ -166,8 +166,7 @@ ProductionBinding syntheticMapOfValuesOrProducedBinding(
           "%s is not for a Map<K, V> or Map<K, Produced<V>>",
           requestForMapOfValuesOrProduced);
       DependencyRequest requestForMapOfProducers =
-          dependencyRequestFactory.forImplicitMapBinding(
-              requestForMapOfValuesOrProduced, mapOfProducersKey.get());
+          dependencyRequestFactory.forImplicitMapBinding(mapOfProducersKey.get());
       return ProductionBinding.builder()
           .contributionType(ContributionType.UNIQUE)
           .key(requestForMapOfValuesOrProduced.key())
@@ -188,8 +187,7 @@ ProductionBinding syntheticMultibinding(
           .contributionType(ContributionType.UNIQUE)
           .key(request.key())
           .dependencies(
-              dependencyRequestFactory.forMultibindingContributions(
-                  request, multibindingContributions))
+              dependencyRequestFactory.forMultibindingContributions(multibindingContributions))
           .bindingKind(Kind.forMultibindingRequest(request))
           .build();
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
index 13011fc29..be42fd0c5 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
@@ -206,8 +206,7 @@ ProvisionBinding syntheticMapOfValuesBinding(DependencyRequest requestForMapOfVa
           "%s is not a request for Map<K, V>",
           requestForMapOfValues);
       DependencyRequest requestForMapOfProviders =
-          dependencyRequestFactory.forImplicitMapBinding(
-              requestForMapOfValues, mapOfProvidersKey.get());
+          dependencyRequestFactory.forImplicitMapBinding(mapOfProvidersKey.get());
       return ProvisionBinding.builder()
           .contributionType(ContributionType.UNIQUE)
           .key(requestForMapOfValues.key())
@@ -228,8 +227,7 @@ ProvisionBinding syntheticMultibinding(
           .contributionType(ContributionType.UNIQUE)
           .key(request.key())
           .dependencies(
-              dependencyRequestFactory.forMultibindingContributions(
-                  request, multibindingContributions))
+              dependencyRequestFactory.forMultibindingContributions(multibindingContributions))
           .bindingKind(Kind.forMultibindingRequest(request))
           .build();
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
index ff362422c..c5a2e36c4 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
@@ -19,6 +19,8 @@
 import static dagger.internal.codegen.FrameworkDependency.frameworkDependenciesForBinding;
 import static dagger.internal.codegen.TypeNames.DOUBLE_CHECK;
 import static dagger.internal.codegen.TypeNames.PROVIDER_OF_LAZY;
+import static dagger.internal.codegen.Util.ELEMENT_KIND;
+import static dagger.internal.codegen.Util.ELEMENT_SIMPLE_NAME;
 
 import com.google.common.base.CaseFormat;
 import com.google.common.base.Joiner;
@@ -36,6 +38,7 @@
 import com.squareup.javapoet.TypeName;
 import com.squareup.javapoet.TypeVariableName;
 import java.util.Iterator;
+import javax.lang.model.element.ElementKind;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.TypeParameterElement;
 import javax.lang.model.type.TypeMirror;
@@ -54,19 +57,26 @@
    * Sorts {@link DependencyRequest} instances in an order likely to reflect their logical
    * importance.
    */
-  static final Ordering<DependencyRequest> DEPENDENCY_ORDERING = new Ordering<DependencyRequest>() {
-    @Override
-    public int compare(DependencyRequest left, DependencyRequest right) {
-      return ComparisonChain.start()
-      // put fields before parameters
-          .compare(left.requestElement().getKind(), right.requestElement().getKind())
-          // order by dependency kind
-          .compare(left.kind(), right.kind())
-          // then sort by name
-          .compare(left.requestElement().getSimpleName().toString(),
-              right.requestElement().getSimpleName().toString()).result();
-    }
-  };
+  static final Ordering<DependencyRequest> DEPENDENCY_ORDERING =
+      new Ordering<DependencyRequest>() {
+        @Override
+        public int compare(DependencyRequest left, DependencyRequest right) {
+          return ComparisonChain.start()
+              // put fields before parameters
+              .compare(
+                  left.requestElement().transform(ELEMENT_KIND),
+                  right.requestElement().transform(ELEMENT_KIND),
+                  Util.<ElementKind>optionalComparator())
+              // order by dependency kind
+              .compare(left.kind(), right.kind())
+              // then sort by name
+              .compare(
+                  left.requestElement().transform(ELEMENT_SIMPLE_NAME),
+                  right.requestElement().transform(ELEMENT_SIMPLE_NAME),
+                  Util.<String>optionalComparator())
+              .result();
+        }
+      };
 
   /**
    * Generates names and keys for the factory class fields needed to hold the framework classes for
diff --git a/compiler/src/main/java/dagger/internal/codegen/Util.java b/compiler/src/main/java/dagger/internal/codegen/Util.java
index 9b66577cd..234b1f528 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Util.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Util.java
@@ -27,6 +27,7 @@
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.common.base.Function;
+import com.google.common.base.Optional;
 import com.google.common.base.Predicate;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableSet;
@@ -34,8 +35,10 @@
 import dagger.Provides;
 import dagger.producers.Produces;
 import java.lang.annotation.Annotation;
+import java.util.Comparator;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
+import javax.lang.model.element.ElementKind;
 import javax.lang.model.element.ElementVisitor;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
@@ -211,5 +214,36 @@ public String apply(Element element) {
         }
       };
 
+  /** A function that returns the kind of an element. */
+  static final Function<Element, ElementKind> ELEMENT_KIND =
+      new Function<Element, ElementKind>() {
+        @Override
+        public ElementKind apply(Element element) {
+          return element.getKind();
+        }
+      };
+
+  @SuppressWarnings("rawtypes")
+  private static final Comparator OPTIONAL_COMPARATOR =
+      new Comparator<Optional<Comparable>>() {
+        @SuppressWarnings("unchecked") // Only used as a Comparator<Optional<SomeType>>.
+        @Override
+        public int compare(Optional<Comparable> o1, Optional<Comparable> o2) {
+          if (o1.isPresent() && o2.isPresent()) {
+            return o1.get().compareTo(o2.get());
+          }
+          return o1.isPresent() ? -1 : 1;
+        }
+      };
+
+  /**
+   * A {@link Comparator} that puts absent {@link Optional}s before present ones, and compares
+   * present {@link Optional}s by their values.
+   */
+  @SuppressWarnings("unchecked") // Fully covariant.
+  static <C extends Comparable<C>> Comparator<Optional<C>> optionalComparator() {
+    return OPTIONAL_COMPARATOR;
+  }
+
   private Util() {}
 }
