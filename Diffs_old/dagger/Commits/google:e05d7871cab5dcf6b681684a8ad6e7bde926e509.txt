diff --git a/compiler/src/it/functional-tests/src/main/java/test/builderbinds/Nullable.java b/compiler/src/it/functional-tests/src/main/java/test/builderbinds/Nullable.java
new file mode 100644
index 000000000..971eb0620
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/builderbinds/Nullable.java
@@ -0,0 +1,19 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package test.builderbinds;
+
+@interface Nullable {}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builderbinds/TestComponent.java b/compiler/src/it/functional-tests/src/main/java/test/builderbinds/TestComponent.java
new file mode 100644
index 000000000..7ecc83547
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/builderbinds/TestComponent.java
@@ -0,0 +1,53 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package test.builderbinds;
+
+import dagger.BindsInstance;
+import dagger.Component;
+import java.util.List;
+import javax.inject.Named;
+
+@Component
+interface TestComponent {
+  int count();
+
+  @Named("input")
+  String input();
+
+  @Nullable
+  @Named("nullable input")
+  String nullableInput();
+
+  List<String> listOfString();
+
+  @Component.Builder
+  interface Builder {
+    @BindsInstance
+    Builder count(int count);
+
+    @BindsInstance
+    Builder input(@Named("input") String input);
+
+    @BindsInstance
+    Builder nullableInput(@Nullable @Named("nullable input") String nullableInput);
+
+    @BindsInstance
+    Builder listOfString(List<String> listOfString);
+
+    TestComponent build();
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/test/java/test/builderbinds/BuilderBindsTest.java b/compiler/src/it/functional-tests/src/test/java/test/builderbinds/BuilderBindsTest.java
new file mode 100644
index 000000000..d71603e96
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/test/java/test/builderbinds/BuilderBindsTest.java
@@ -0,0 +1,109 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package test.builderbinds;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+
+import java.util.Arrays;
+import java.util.Collections;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public final class BuilderBindsTest {
+
+  @Test
+  public void builderBinds() {
+    TestComponent component =
+        DaggerTestComponent.builder()
+            .count(5)
+            .input("foo")
+            .nullableInput("bar")
+            .listOfString(Arrays.asList("x", "y", "z"))
+            .build();
+    assertThat(component.count()).isEqualTo(5);
+    assertThat(component.input()).isEqualTo("foo");
+    assertThat(component.nullableInput()).isEqualTo("bar");
+    assertThat(component.listOfString()).containsExactly("x", "y", "z").inOrder();
+  }
+
+  @Test
+  public void builderBindsNullableWithNull() {
+    TestComponent component =
+        DaggerTestComponent.builder()
+            .count(5)
+            .input("foo")
+            .nullableInput(null)
+            .listOfString(Collections.<String>emptyList())
+            .build();
+    assertThat(component.count()).isEqualTo(5);
+    assertThat(component.input()).isEqualTo("foo");
+    assertThat(component.nullableInput()).isNull();
+    assertThat(component.listOfString()).isEmpty();
+  }
+
+  @Test
+  public void builderBindsNonNullableWithNull() {
+    try {
+      DaggerTestComponent.builder().count(5).input(null);
+      fail("expected NullPointerException");
+    } catch (NullPointerException expected) {
+    }
+  }
+
+  @Test
+  public void builderBindsPrimitiveNotSet() {
+    try {
+      DaggerTestComponent.builder()
+          .input("foo")
+          .nullableInput("bar")
+          .listOfString(Collections.<String>emptyList())
+          .build();
+      fail("expected IllegalStateException");
+    } catch (IllegalStateException expected) {
+    }
+  }
+
+  @Test
+  public void builderBindsNonNullableNotSet() {
+    try {
+      DaggerTestComponent.builder()
+          .count(5)
+          .nullableInput("foo")
+          .listOfString(Collections.<String>emptyList())
+          .build();
+      fail("expected IllegalStateException");
+    } catch (IllegalStateException expected) {
+    }
+  }
+
+  @Test
+  public void builderBindsNullableNotSet() {
+    TestComponent component =
+        DaggerTestComponent.builder()
+            .count(5)
+            .input("foo")
+            .listOfString(Collections.<String>emptyList())
+            .build();
+    assertThat(component.count()).isEqualTo(5);
+    assertThat(component.input()).isEqualTo("foo");
+    assertThat(component.nullableInput()).isNull();
+    assertThat(component.listOfString()).isEmpty();
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindsInstanceProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/BindsInstanceProcessingStep.java
new file mode 100644
index 000000000..510f79385
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/BindsInstanceProcessingStep.java
@@ -0,0 +1,66 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static dagger.internal.codegen.ErrorMessages.BINDS_INSTANCE_NOT_IN_BUILDER;
+import static dagger.internal.codegen.Util.isAnyAnnotationPresent;
+import static dagger.internal.codegen.Util.toImmutableSet;
+
+import com.google.auto.common.BasicAnnotationProcessor.ProcessingStep;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.SetMultimap;
+import dagger.BindsInstance;
+import java.lang.annotation.Annotation;
+import java.util.Set;
+import java.util.stream.Stream;
+import javax.annotation.processing.Messager;
+import javax.lang.model.element.Element;
+import javax.tools.Diagnostic.Kind;
+
+/**
+ * Processing step that validates that the {@code BindsInstance} annotation is applied to the
+ * correct elements.
+ */
+final class BindsInstanceProcessingStep implements ProcessingStep {
+
+  private static final ImmutableSet<Class<? extends Annotation>> VALID_CONTAINING_ANNOTATIONS =
+      Stream.of(ComponentDescriptor.Kind.values())
+          .map(ComponentDescriptor.Kind::builderAnnotationType)
+          .collect(toImmutableSet());
+
+  private final Messager messager;
+
+  BindsInstanceProcessingStep(Messager messager) {
+    this.messager = messager;
+  }
+
+  @Override
+  public Set<? extends Class<? extends Annotation>> annotations() {
+    return ImmutableSet.of(BindsInstance.class);
+  }
+
+  @Override
+  public Set<Element> process(
+      SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
+    for (Element element : elementsByAnnotation.get(BindsInstance.class)) {
+      if (!isAnyAnnotationPresent(element.getEnclosingElement(), VALID_CONTAINING_ANNOTATIONS)) {
+        messager.printMessage(Kind.ERROR, BINDS_INSTANCE_NOT_IN_BUILDER, element);
+      }
+    }
+    return ImmutableSet.of();
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
index a27768703..5ef9b22db 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
@@ -46,6 +46,7 @@
 import com.google.common.collect.TreeTraverser;
 import com.google.common.util.concurrent.ListenableFuture;
 import com.squareup.javapoet.ClassName;
+import dagger.BindsInstance;
 import dagger.Component;
 import dagger.Lazy;
 import dagger.MembersInjector;
@@ -692,6 +693,13 @@ private ComponentMethodDescriptor getDescriptorForComponentMethod(
     private ComponentRequirement requirementForBuilderMethod(
         ExecutableElement method, ExecutableType resolvedType) {
       checkArgument(method.getParameters().size() == 1);
+      if (isAnnotationPresent(method, BindsInstance.class)) {
+        DependencyRequest request =
+            dependencyRequestFactory.forRequiredResolvedVariable(
+                getOnlyElement(method.getParameters()),
+                getOnlyElement(resolvedType.getParameterTypes()));
+        return ComponentRequirement.forBinding(request.key(), request.isNullable());
+      }
 
       TypeMirror type = getOnlyElement(resolvedType.getParameterTypes());
       return ConfigurationAnnotations.getModuleAnnotation(MoreTypes.asTypeElement(type)).isPresent()
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
index 656b67ebd..931664330 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -210,6 +210,7 @@ public SourceVersion getSupportedSourceVersion() {
         new MonitoringModuleProcessingStep(messager, monitoringModuleGenerator),
         new ProductionExecutorModuleProcessingStep(messager, productionExecutorModuleGenerator),
         new MultibindingAnnotationsProcessingStep(messager),
+        new BindsInstanceProcessingStep(messager),
         moduleProcessingStep(messager, moduleValidator, provisionBindingFactory, factoryGenerator),
         new ComponentProcessingStep(
             ComponentDescriptor.Kind.COMPONENT,
diff --git a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
index 3ec84c5c7..ae15635e3 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
@@ -322,6 +322,8 @@ static String nullableToNonNullable(String typeName, String bindingString) {
       "@%s.type cannot be used with multibinding annotations";
 
   /* BindsInstance messages. */
+  static final String BINDS_INSTANCE_NOT_IN_BUILDER =
+      "@BindsInstance must annotate a method in a component builder";
 
   static ComponentBuilderMessages builderMsgsFor(ComponentDescriptor.Kind kind) {
     switch(kind) {
diff --git a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
index 07374ede1..cacd83332 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
@@ -2673,6 +2673,47 @@ public void moduleInDependencies() {
         .hadErrorContaining("test.TestModule is a module, which cannot be a component dependency");
   }
 
+  @Test
+  public void bindsInstanceInModule() {
+    JavaFileObject testModule =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.BindsInstance;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "final class TestModule {",
+            "  @BindsInstance String s() { return null; }",
+            "}");
+    Compilation compilation = daggerCompiler().compile(testModule);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("@BindsInstance must annotate a method in a component builder");
+  }
+
+  @Test
+  public void bindsInstanceInComponent() {
+    JavaFileObject testComponent =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.BindsInstance;",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface TestComponent {",
+            "  @BindsInstance String s();",
+            "}");
+    Compilation compilation = daggerCompiler().compile(testComponent);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("@BindsInstance must annotate a method in a component builder");
+  }
+
   private static Compiler daggerCompiler(Processor... extraProcessors) {
     return javac().withProcessors(Lists.asList(new ComponentProcessor(), extraProcessors));
   }
diff --git a/compiler/src/test/java/dagger/internal/codegen/SubcomponentBuilderValidationTest.java b/compiler/src/test/java/dagger/internal/codegen/SubcomponentBuilderValidationTest.java
index 64a0b57a1..01389933f 100644
--- a/compiler/src/test/java/dagger/internal/codegen/SubcomponentBuilderValidationTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/SubcomponentBuilderValidationTest.java
@@ -20,6 +20,7 @@
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
 
+import com.google.common.base.Joiner;
 import com.google.common.collect.ImmutableList;
 import com.google.testing.compile.JavaFileObjects;
 import javax.tools.JavaFileObject;
@@ -683,6 +684,52 @@ public void testMultipleSettersPerTypeIncludingResolvedGenericsFails() {
         .onLine(14);
   }
 
+  @Test
+  public void testMultipleSettersPerBoundInstanceTypeFails() {
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.ParentComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface ParentComponent {",
+            "  ChildComponent.Builder childComponentBuilder();",
+            "}");
+    JavaFileObject childComponentFile =
+        JavaFileObjects.forSourceLines(
+            "test.ChildComponent",
+            "package test;",
+            "",
+            "import dagger.BindsInstance;",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent",
+            "interface ChildComponent {",
+            "  String s();",
+            "",
+            "  @Subcomponent.Builder",
+            "  interface Builder {",
+            "    ChildComponent build();",
+            "    @BindsInstance void set1(String s);",
+            "    @BindsInstance void set2(String s);",
+            "  }",
+            "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(componentFile, childComponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            Joiner.on("\n      ")
+                .join(
+                    "java.lang.String is bound multiple times:",
+                    "@BindsInstance void test.ChildComponent.Builder.set1(String)",
+                    "@BindsInstance void test.ChildComponent.Builder.set2(String)"))
+        .in(childComponentFile)
+        .onLine(8);
+  }
+
   @Test
   public void testExtraSettersFails() {
     JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.ParentComponent",
diff --git a/core/src/main/java/dagger/BindsInstance.java b/core/src/main/java/dagger/BindsInstance.java
new file mode 100644
index 000000000..cd87db8a8
--- /dev/null
+++ b/core/src/main/java/dagger/BindsInstance.java
@@ -0,0 +1,62 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger;
+
+import static java.lang.annotation.ElementType.METHOD;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+import dagger.internal.Beta;
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+
+/**
+ * Marks a method on a component builder or subcomponent builder that allows an instance to be bound
+ * to some type within the component.
+ *
+ * <p>For example:
+ *
+ * <pre>
+ *   {@literal @Component.Builder}
+ *   interface Builder {
+ *     {@literal @BindsInstance} Builder foo(Foo foo);
+ *     {@literal @BindsInstance} Builder bar({@literal @Blue} Bar bar);
+ *     ...
+ *   }
+ * </pre>
+ *
+ * <p>will allow clients of this builder to pass their own instances of {@code Foo} and {@code Bar},
+ * and those instances can be injected within the component as {@code Foo} or {@code @Blue Bar},
+ * respectively.
+ *
+ * <p>{@code @BindsInstance} methods may not be passed null arguments unless the parameter is
+ * annotated with {@code @Nullable}; in that case, both null and non-null arguments may be passed to
+ * the method.
+ *
+ * <p>{@code @BindsInstance} methods must be called before building the component, unless their
+ * parameter is marked {@code @Nullable}, in which case the component will act as though it was
+ * called with a null argument. Primitives, of course, may not be marked {@code @Nullable}.
+ *
+ * <p>Binding an instance is equivalent to passing an instance to a module constructor and providing
+ * that instance, but is often more efficient. When possible, binding object instances should be
+ * preferred to using module instances.
+ */
+@Documented
+@Retention(RUNTIME)
+@Target(METHOD)
+@Beta
+public @interface BindsInstance {}
