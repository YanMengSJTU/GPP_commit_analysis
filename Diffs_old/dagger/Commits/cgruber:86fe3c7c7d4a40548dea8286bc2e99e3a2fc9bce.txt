diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
index 869d3be59..7bf1587d7 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -198,12 +198,8 @@ protected AbstractComponentWriter(
         parent.optionalFactories);
   }
 
-  protected final TypeElement componentDefinitionType() {
-    return graph.componentDescriptor().componentDefinitionType();
-  }
-
   protected final ClassName componentDefinitionTypeName() {
-    return ClassName.get(componentDefinitionType());
+    return ClassName.get(graph.componentType());
   }
 
   /**
@@ -696,7 +692,7 @@ private void implementInterfaceMethods() {
         ExecutableType requestType =
             MoreTypes.asExecutable(
                 types.asMemberOf(
-                    MoreTypes.asDeclared(componentDefinitionType().asType()), methodElement));
+                    MoreTypes.asDeclared(graph.componentType().asType()), methodElement));
         MethodSignature signature =
             MethodSignature.fromExecutableType(
                 methodElement.getSimpleName().toString(), requestType);
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
index a1305bb9c..0ddaa5027 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
@@ -90,6 +90,15 @@
   abstract ImmutableMap<BindingKey, ResolvedBindings> resolvedBindings();
   abstract ImmutableSet<BindingGraph> subgraphs();
 
+  /**
+   * The type that defines the component for this graph.
+   *
+   * @see ComponentDescriptor#componentDefinitionType()
+   */
+  TypeElement componentType() {
+    return componentDescriptor().componentDefinitionType();
+  }
+
   /**
    * Returns the set of modules that are owned by this graph regardless of whether or not any of
    * their bindings are used in this graph. For graphs representing top-level {@link Component
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
index e263c06da..b6cbc70c2 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -230,8 +230,7 @@ int size() {
 
     Validation(BindingGraph subject, Optional<Validation> parent) {
       this.subject = subject;
-      this.reportBuilder =
-          ValidationReport.about(subject.componentDescriptor().componentDefinitionType());
+      this.reportBuilder = ValidationReport.about(subject.componentType());
       this.parent = parent;
       this.subgraphsByComponentDescriptor =
           Maps.uniqueIndex(subject.subgraphs(), BindingGraph::componentDescriptor);
@@ -293,7 +292,7 @@ private void validateSubcomponentFactoryMethod(
             String.format(
                 "%s requires modules which have no visible default constructors. "
                     + "Add the following modules as parameters to this method: %s",
-                subgraph.componentDescriptor().componentDefinitionType().getQualifiedName(),
+                subgraph.componentType().getQualifiedName(),
                 missingModules.stream().map(Object::toString).collect(joining(", "))),
             factoryMethod);
       }
@@ -301,8 +300,7 @@ private void validateSubcomponentFactoryMethod(
 
     private ImmutableSet<TypeElement> subgraphFactoryMethodParameters(
         ExecutableElement factoryMethod) {
-      DeclaredType componentType =
-          asDeclared(subject.componentDescriptor().componentDefinitionType().asType());
+      DeclaredType componentType = asDeclared(subject.componentType().asType());
       ExecutableType factoryMethodType =
           asExecutable(types.asMemberOf(componentType, factoryMethod));
       return asTypeElements(factoryMethodType.getParameterTypes());
@@ -362,8 +360,7 @@ private Validation validationForComponent(ComponentDescriptor component) {
         throw new IllegalArgumentException(
             String.format(
                 "unknown component %s within %s",
-                component.componentDefinitionType(),
-                subject.componentDescriptor().componentDefinitionType()));
+                component.componentDefinitionType(), subject.componentType()));
       }
     }
 
@@ -909,7 +906,7 @@ void validateComponentScope() {
 
       ImmutableSet<String> incompatiblyScopedMethods = incompatiblyScopedMethodsBuilder.build();
       if (!incompatiblyScopedMethods.isEmpty()) {
-        TypeElement componentType = subject.componentDescriptor().componentDefinitionType();
+        TypeElement componentType = subject.componentType();
         StringBuilder message = new StringBuilder(componentType.getQualifiedName());
         if (!componentScopes.isEmpty()) {
           message.append(" scoped with ");
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
index 980f8e36a..b9b646315 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
@@ -53,8 +53,7 @@
 
   @Override
   ClassName nameGeneratedType(BindingGraph input) {
-    ClassName componentDefinitionClassName =
-        ClassName.get(input.componentDescriptor().componentDefinitionType());
+    ClassName componentDefinitionClassName = ClassName.get(input.componentType());
     String componentName =
         "Dagger" + Joiner.on('_').join(componentDefinitionClassName.simpleNames());
     return componentDefinitionClassName.topLevelClassName().peerClass(componentName);
@@ -62,7 +61,7 @@ ClassName nameGeneratedType(BindingGraph input) {
 
   @Override
   Optional<? extends Element> getElementForErrorReporting(BindingGraph input) {
-    return Optional.of(input.componentDescriptor().componentDefinitionType());
+    return Optional.of(input.componentType());
   }
 
   @Override
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java
index 635dbeefc..bab73c9ea 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java
@@ -138,7 +138,7 @@ private UniqueSubcomponentNamesGenerator(BindingGraph graph) {
   @Override
   protected void decorateComponent() {
     component.addModifiers(PUBLIC, FINAL);
-    addSupertype(component, componentDefinitionType());
+    addSupertype(component, graph.componentType());
   }
 
   @Override
diff --git a/compiler/src/main/java/dagger/internal/codegen/MissingBindingSuggestions.java b/compiler/src/main/java/dagger/internal/codegen/MissingBindingSuggestions.java
index 8f86422b0..a5311b80b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MissingBindingSuggestions.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MissingBindingSuggestions.java
@@ -42,8 +42,9 @@
       if ((bindings == null) || bindings.bindings().isEmpty()) {
         graphsToTry.addAll(graph.subgraphs());
       } else {
-        resolutions.add("A binding with matching key exists in component: "
-            + graph.componentDescriptor().componentDefinitionType().getQualifiedName());
+        resolutions.add(
+            "A binding with matching key exists in component: "
+                + graph.componentType().getQualifiedName());
       }
     } while (!graphsToTry.isEmpty());
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/SubcomponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/SubcomponentWriter.java
index 9555ba055..050b6bc77 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SubcomponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SubcomponentWriter.java
@@ -101,11 +101,11 @@ private ExecutableType resolvedSubcomponentFactoryMethod() {
     checkState(
         subcomponentFactoryMethod.isPresent(),
         "%s does not have a factory method for %s",
-        parent.componentDefinitionType(),
-        componentDefinitionType());
+        parent.graph.componentType(),
+        graph.componentType());
     return MoreTypes.asExecutable(
         types.asMemberOf(
-            MoreTypes.asDeclared(parent.componentDefinitionType().asType()),
+            MoreTypes.asDeclared(parent.graph.componentType().asType()),
             subcomponentFactoryMethod.get().methodElement()));
   }
 
