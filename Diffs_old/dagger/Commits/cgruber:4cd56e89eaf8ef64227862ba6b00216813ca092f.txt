diff --git a/compiler/src/it/functional-tests/src/main/java/test/ComponentWithReusableBindings.java b/compiler/src/it/functional-tests/src/main/java/test/ComponentWithReusableBindings.java
new file mode 100644
index 000000000..059794257
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/ComponentWithReusableBindings.java
@@ -0,0 +1,75 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import dagger.Component;
+import dagger.Module;
+import dagger.Provides;
+import dagger.Reusable;
+import dagger.Subcomponent;
+import javax.inject.Qualifier;
+
+@Component(modules = ComponentWithReusableBindings.ReusableBindingsModule.class)
+interface ComponentWithReusableBindings {
+
+  @Qualifier
+  @interface InParent {}
+
+  @Qualifier
+  @interface InChildren {}
+
+  @InParent
+  Object reusableInParent();
+
+  ChildOne childOne();
+
+  ChildTwo childTwo();
+
+  @Subcomponent
+  interface ChildOne {
+    @InParent
+    Object reusableInParent();
+
+    @InChildren
+    Object reusableInChild();
+  }
+
+  @Subcomponent
+  interface ChildTwo {
+    @InParent
+    Object reusableInParent();
+
+    @InChildren
+    Object reusableInChild();
+  }
+
+  @Module
+  static class ReusableBindingsModule {
+    @Provides
+    @Reusable
+    @InParent
+    static Object inParent() {
+      return new Object();
+    }
+
+    @Provides
+    @Reusable
+    @InChildren
+    static Object inChildren() {
+      return new Object();
+    }
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/test/java/test/ReusableTest.java b/compiler/src/it/functional-tests/src/test/java/test/ReusableTest.java
new file mode 100644
index 000000000..acc212ddc
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/test/java/test/ReusableTest.java
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import test.ComponentWithReusableBindings.ChildOne;
+import test.ComponentWithReusableBindings.ChildTwo;
+
+import static com.google.common.truth.Truth.assertThat;
+
+@RunWith(JUnit4.class)
+public class ReusableTest {
+  @Test
+  public void testReusable() {
+    ComponentWithReusableBindings parent = DaggerComponentWithReusableBindings.create();
+    ChildOne childOne = parent.childOne();
+    ChildTwo childTwo = parent.childTwo();
+
+    Object reusableInParent = parent.reusableInParent();
+    assertThat(parent.reusableInParent()).isSameAs(reusableInParent);
+    assertThat(childOne.reusableInParent()).isSameAs(reusableInParent);
+    assertThat(childTwo.reusableInParent()).isSameAs(reusableInParent);
+
+    Object reusableFromChildOne = childOne.reusableInChild();
+    assertThat(childOne.reusableInChild()).isSameAs(reusableFromChildOne);
+
+    Object reusableFromChildTwo = childTwo.reusableInChild();
+    assertThat(childTwo.reusableInChild()).isSameAs(reusableFromChildTwo);
+
+    assertThat(reusableFromChildTwo).isNotSameAs(reusableFromChildOne);
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
index 6b944466b..da282f6bc 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -85,6 +85,7 @@
 import static dagger.internal.codegen.MemberSelect.noOpMembersInjector;
 import static dagger.internal.codegen.MemberSelect.staticMethod;
 import static dagger.internal.codegen.MembersInjectionBinding.Strategy.NO_OP;
+import static dagger.internal.codegen.Scope.reusableScope;
 import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
 import static dagger.internal.codegen.SourceFiles.generatedClassNameForBinding;
 import static dagger.internal.codegen.SourceFiles.membersInjectorNameForType;
@@ -105,6 +106,7 @@
 import static dagger.internal.codegen.TypeNames.SET_FACTORY;
 import static dagger.internal.codegen.TypeNames.SET_OF_PRODUCED_PRODUCER;
 import static dagger.internal.codegen.TypeNames.SET_PRODUCER;
+import static dagger.internal.codegen.TypeNames.SIMPLE_LAZILY_INITIALIZED_PROVIDER;
 import static dagger.internal.codegen.TypeNames.STRING;
 import static dagger.internal.codegen.TypeNames.UNSUPPORTED_OPERATION_EXCEPTION;
 import static dagger.internal.codegen.TypeNames.providerOf;
@@ -927,7 +929,7 @@ private CodeBlock initializeFactoryForContributionBinding(ContributionBinding bi
                   generatedClassNameForBinding(binding),
                   makeParametersCodeBlock(arguments));
           return binding.scope().isPresent()
-              ? CodeBlocks.format("$T.create($L)", SCOPED_PROVIDER, factoryCreate)
+              ? decorateForScope(factoryCreate, binding.scope().get())
               : factoryCreate;
         }
 
@@ -994,6 +996,15 @@ private CodeBlock initializeFactoryForContributionBinding(ContributionBinding bi
     }
   }
 
+  private CodeBlock decorateForScope(CodeBlock factoryCreate, Scope scope) {
+    return CodeBlocks.format(
+        "$T.create($L)",
+        scope.equals(reusableScope(elements))
+            ? SIMPLE_LAZILY_INITIALIZED_PROVIDER
+            : SCOPED_PROVIDER,
+        factoryCreate);
+  }
+
   private CodeBlock nullableAnnotation(Optional<DeclaredType> nullableType) {
     return nullableType.isPresent()
         ? CodeBlocks.format("@$T ", TypeName.get(nullableType.get()))
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
index 5b06e828a..d9cd68f1b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
@@ -32,6 +32,7 @@
 import com.google.common.collect.Sets;
 import com.google.common.collect.TreeTraverser;
 import dagger.Component;
+import dagger.Reusable;
 import dagger.Subcomponent;
 import dagger.internal.codegen.BindingType.HasBindingType;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
@@ -59,6 +60,7 @@
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Predicates.in;
 import static com.google.common.base.Verify.verify;
+import static dagger.internal.codegen.BindingKey.Kind.CONTRIBUTION;
 import static dagger.internal.codegen.ComponentDescriptor.isComponentContributionMethod;
 import static dagger.internal.codegen.ComponentDescriptor.isComponentProductionMethod;
 import static dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor.isOfKind;
@@ -68,6 +70,7 @@
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
 import static dagger.internal.codegen.ContributionBinding.Kind.IS_SYNTHETIC_MULTIBINDING_KIND;
 import static dagger.internal.codegen.Key.indexByKey;
+import static dagger.internal.codegen.Scope.reusableScope;
 import static javax.lang.model.element.Modifier.STATIC;
 
 /**
@@ -491,6 +494,18 @@ private boolean isResolvedInParent(DependencyRequest request, ContributionBindin
       }
 
       private Optional<Resolver> getOwningResolver(ContributionBinding binding) {
+        if (binding.scope().isPresent() && binding.scope().get().equals(reusableScope(elements))) {
+          for (Resolver requestResolver : getResolverLineage().reverse()) {
+            // If a @Reusable binding was resolved in an ancestor, use that component.
+            if (requestResolver.resolvedBindings.containsKey(
+                BindingKey.create(CONTRIBUTION, binding.key()))) {
+              return Optional.of(requestResolver);
+            }
+          }
+          // If a @Reusable binding was not resolved in any ancestor, resolve it here.
+          return Optional.absent();
+        }
+
         for (Resolver requestResolver : getResolverLineage().reverse()) {
           if (requestResolver.explicitBindingsSet.contains(binding)) {
             return Optional.of(requestResolver);
@@ -724,11 +739,12 @@ public Boolean call() {
         }
 
         /**
-         * Returns {@code true} if {@code binding} is unscoped and depends on multibindings with
-         * contributions declared within this component's modules, or if any of its unscoped
-         * dependencies depend on such local multibindings.
+         * Returns {@code true} if {@code binding} is unscoped (or has {@link Reusable @Reusable}
+         * scope) and depends on multibindings with contributions declared within this component's
+         * modules, or if any of its unscoped or {@link Reusable @Reusable} scoped dependencies
+         * depend on such local multibindings.
          *
-         * <p>We don't care about scoped dependencies because they will never depend on
+         * <p>We don't care about non-reusable scoped dependencies because they will never depend on
          * multibindings with contributions from subcomponents.
          */
         boolean dependsOnLocalMultibindings(final Binding binding) {
@@ -741,7 +757,8 @@ boolean dependsOnLocalMultibindings(final Binding binding) {
                 new Callable<Boolean>() {
                   @Override
                   public Boolean call() {
-                    if (!binding.scope().isPresent()
+                    if ((!binding.scope().isPresent()
+                            || binding.scope().get().equals(reusableScope(elements)))
                         // TODO(beder): Figure out what happens with production subcomponents.
                         && !binding.bindingType().equals(BindingType.PRODUCTION)) {
                       for (DependencyRequest dependency : binding.implicitDependencies()) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
index 2eb20921b..db0057ec9 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -101,6 +101,7 @@
 import static dagger.internal.codegen.ErrorMessages.inconsistentMapKeyAnnotationsError;
 import static dagger.internal.codegen.ErrorMessages.nullableToNonNullable;
 import static dagger.internal.codegen.ErrorMessages.stripCommonTypePrefixes;
+import static dagger.internal.codegen.Scope.reusableScope;
 import static dagger.internal.codegen.Util.componentCanMakeNewInstances;
 import static javax.tools.Diagnostic.Kind.ERROR;
 
@@ -796,10 +797,13 @@ void validateComponentScope() {
       ImmutableMap<BindingKey, ResolvedBindings> resolvedBindings = subject.resolvedBindings();
       ImmutableSet<Scope> componentScopes = subject.componentDescriptor().scopes();
       ImmutableSet.Builder<String> incompatiblyScopedMethodsBuilder = ImmutableSet.builder();
+      Scope reusableScope = reusableScope(elements);
       for (ResolvedBindings bindings : resolvedBindings.values()) {
         for (ContributionBinding contributionBinding : bindings.ownedContributionBindings()) {
           Optional<Scope> bindingScope = contributionBinding.scope();
-          if (bindingScope.isPresent() && !componentScopes.contains(bindingScope.get())) {
+          if (bindingScope.isPresent()
+              && !bindingScope.get().equals(reusableScope)
+              && !componentScopes.contains(bindingScope.get())) {
             // Scoped components cannot reference bindings to @Provides methods or @Inject
             // types decorated by a different scope annotation. Unscoped components cannot
             // reference to scoped @Provides methods or @Inject types decorated by any
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
index 0be4686a9..d47a3c68c 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentValidator.java
@@ -27,6 +27,7 @@
 import com.google.common.collect.Multimap;
 import com.google.common.collect.Sets;
 import dagger.Component;
+import dagger.Reusable;
 import dagger.producers.ProductionComponent;
 import java.lang.annotation.Annotation;
 import java.util.Collection;
@@ -50,6 +51,7 @@
 import static dagger.internal.codegen.ConfigurationAnnotations.enclosedBuilders;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentModules;
 import static dagger.internal.codegen.ConfigurationAnnotations.getTransitiveModules;
+import static dagger.internal.codegen.ErrorMessages.COMPONENT_ANNOTATED_REUSABLE;
 import static javax.lang.model.element.ElementKind.CLASS;
 import static javax.lang.model.element.ElementKind.INTERFACE;
 import static javax.lang.model.element.Modifier.ABSTRACT;
@@ -141,6 +143,11 @@ public ComponentValidationReport validate(final TypeElement subject,
           String.format(ErrorMessages.builderMsgsFor(componentKind).moreThanOne(), builders),
           subject);
     }
+    
+    Optional<AnnotationMirror> reusableAnnotation = getAnnotationMirror(subject, Reusable.class);
+    if (reusableAnnotation.isPresent()) {
+      builder.addError(COMPONENT_ANNOTATED_REUSABLE, subject, reusableAnnotation.get());
+    }
 
     DeclaredType subjectType = MoreTypes.asDeclared(subject.asType());
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
index abed9b7f2..ef091ee0f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
@@ -98,6 +98,7 @@
   static final String CANNOT_INJECT_WILDCARD_TYPE =
       "Dagger does not support injecting Provider<T>, Lazy<T> or Produced<T> when T is a wildcard "
           + "type such as <%s>.";
+  
   /*
    * Configuration errors
    *
@@ -115,6 +116,9 @@ static String inconsistentMapKeyAnnotationsError(String key) {
     return key + " uses more than one @MapKey annotation type";
   }
 
+  static final String COMPONENT_ANNOTATED_REUSABLE =
+      "@Reusable cannot be applied to components or subcomponents.";
+  
   static final String PROVIDES_METHOD_RETURN_TYPE =
       "@Provides methods must either return a primitive, an array, a type variable, or a declared"
           + " type.";
diff --git a/compiler/src/main/java/dagger/internal/codegen/Scope.java b/compiler/src/main/java/dagger/internal/codegen/Scope.java
index 962440fd8..d8590efd8 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Scope.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Scope.java
@@ -23,7 +23,9 @@
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
+import dagger.Reusable;
 import dagger.producers.ProductionScope;
+import java.lang.annotation.Annotation;
 import javax.inject.Singleton;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
@@ -71,21 +73,30 @@ private Scope(AnnotationMirror annotationMirror) {
   }
 
   /**
-   * Returns a representation for producer scope;
+   * Returns a representation for {@link ProductionScope @ProductionScope} scope.
    */
   static Scope productionScope(Elements elements) {
-    return new Scope(
-        SimpleAnnotationMirror.of(
-            elements.getTypeElement(ProductionScope.class.getCanonicalName())));
+    return scope(elements, ProductionScope.class);
   }
 
   /**
-   * Returns a representation for singleton scope.
+   * Returns a representation for {@link Singleton @Singleton} scope.
    */
   static Scope singletonScope(Elements elements) {
+    return scope(elements, Singleton.class);
+  }
+
+  /**
+   * Returns a representation for {@link Reusable @Reusable} scope.
+   */
+  static Scope reusableScope(Elements elements) {
+    return scope(elements, Reusable.class);
+  }
+
+  private static Scope scope(Elements elements, Class<? extends Annotation> scopeAnnotationClass) {
     return new Scope(
         SimpleAnnotationMirror.of(
-            elements.getTypeElement(Singleton.class.getCanonicalName())));
+            elements.getTypeElement(scopeAnnotationClass.getCanonicalName())));
   }
 
   /**
diff --git a/compiler/src/main/java/dagger/internal/codegen/TypeNames.java b/compiler/src/main/java/dagger/internal/codegen/TypeNames.java
index e005761d7..a4cc8c5d4 100644
--- a/compiler/src/main/java/dagger/internal/codegen/TypeNames.java
+++ b/compiler/src/main/java/dagger/internal/codegen/TypeNames.java
@@ -32,6 +32,7 @@
 import dagger.internal.MembersInjectors;
 import dagger.internal.ScopedProvider;
 import dagger.internal.SetFactory;
+import dagger.internal.SimpleLazilyInitializedProvider;
 import dagger.producers.Produced;
 import dagger.producers.Producer;
 import dagger.producers.internal.AbstractProducer;
@@ -78,6 +79,8 @@
   static final ClassName PRODUCERS = ClassName.get(Producers.class);
   static final ClassName PROVIDER = ClassName.get(Provider.class);
   static final ClassName SCOPED_PROVIDER = ClassName.get(ScopedProvider.class);
+  static final ClassName SIMPLE_LAZILY_INITIALIZED_PROVIDER =
+      ClassName.get(SimpleLazilyInitializedProvider.class);
   static final ClassName SET = ClassName.get(Set.class);
   static final ClassName SET_FACTORY = ClassName.get(SetFactory.class);
   static final ClassName SET_OF_PRODUCED_PRODUCER = ClassName.get(SetOfProducedProducer.class);
diff --git a/compiler/src/test/java/dagger/internal/codegen/GraphValidationScopingTest.java b/compiler/src/test/java/dagger/internal/codegen/GraphValidationScopingTest.java
index e207fe0ee..8196d1afe 100644
--- a/compiler/src/test/java/dagger/internal/codegen/GraphValidationScopingTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/GraphValidationScopingTest.java
@@ -21,7 +21,9 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
+import static com.google.common.truth.Truth.assertAbout;
 import static com.google.common.truth.Truth.assert_;
+import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
 import static java.util.Arrays.asList;
 
@@ -345,4 +347,48 @@
         .failsToCompile()
         .withErrorContaining(errorMessage);
   }
+  
+  @Test
+  public void reusableNotAllowedOnComponent() {
+    JavaFileObject someComponent =
+        JavaFileObjects.forSourceLines(
+            "test.SomeComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import dagger.Reusable;",
+            "",
+            "@Reusable",
+            "@Component",
+            "interface SomeComponent {}");
+    assertAbout(javaSource())
+        .that(someComponent)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("@Reusable cannot be applied to components or subcomponents.")
+        .in(someComponent)
+        .onLine(6);
+  }
+
+  @Test
+  public void reusableNotAllowedOnSubcomponent() {
+    JavaFileObject someSubcomponent =
+        JavaFileObjects.forSourceLines(
+            "test.SomeComponent",
+            "package test;",
+            "",
+            "import dagger.Reusable;",
+            "import dagger.Subcomponent;",
+            "",
+            "@Reusable",
+            "@Subcomponent",
+            "interface SomeSubcomponent {}");
+    assertAbout(javaSource())
+        .that(someSubcomponent)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("@Reusable cannot be applied to components or subcomponents.")
+        .in(someSubcomponent)
+        .onLine(6);
+  }
 }
diff --git a/core/src/main/java/dagger/Reusable.java b/core/src/main/java/dagger/Reusable.java
new file mode 100644
index 000000000..01175e0ee
--- /dev/null
+++ b/core/src/main/java/dagger/Reusable.java
@@ -0,0 +1,36 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import javax.inject.Scope;
+
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+/**
+ * A scope that indicates that the object returned by a binding may be (but might not be) reused.
+ *
+ * <p>{@code @Reusable} is useful when you want to limit the number of provisions of a type, but
+ * there is no specific lifetime over which there must be only one instance.
+ *
+ * @see <a href="http://google.github.io/dagger/users-guide.html#reusable-scope">Reusable Scope
+ * </a>
+ */
+@Documented
+@Retention(RUNTIME)
+@Scope
+public @interface Reusable {}
diff --git a/core/src/main/java/dagger/internal/SimpleLazilyInitializedProvider.java b/core/src/main/java/dagger/internal/SimpleLazilyInitializedProvider.java
new file mode 100644
index 000000000..a87d3136f
--- /dev/null
+++ b/core/src/main/java/dagger/internal/SimpleLazilyInitializedProvider.java
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal;
+
+import dagger.Lazy;
+import javax.inject.Provider;
+
+import static dagger.internal.Preconditions.checkNotNull;
+
+/**
+ * A {@link Provider} implementation that memoizes the result of a {@link Factory} instance using
+ * simple lazy initialization, not the double-checked lock pattern.
+ */
+public final class SimpleLazilyInitializedProvider<T> implements Provider<T>, Lazy<T> {
+  private static final Object UNINITIALIZED = new Object();
+
+  private final Factory<T> factory;
+  private volatile Object instance = UNINITIALIZED;
+
+  private SimpleLazilyInitializedProvider(Factory<T> factory) {
+    assert factory != null;
+    this.factory = factory;
+  }
+
+  @SuppressWarnings("unchecked") // cast only happens when result comes from the factory
+  @Override
+  public T get() {
+    if (instance == UNINITIALIZED) {
+      instance = factory.get();
+    }
+    return (T) instance;
+  }
+
+  /** Returns a new provider for the given factory. */
+  public static <T> Provider<T> create(Factory<T> factory) {
+    return new SimpleLazilyInitializedProvider<T>(checkNotNull(factory));
+  }
+}
diff --git a/core/src/test/java/dagger/internal/SimpleLazilyInitializedProviderTest.java b/core/src/test/java/dagger/internal/SimpleLazilyInitializedProviderTest.java
new file mode 100644
index 000000000..c1fd61c19
--- /dev/null
+++ b/core/src/test/java/dagger/internal/SimpleLazilyInitializedProviderTest.java
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal;
+
+import javax.inject.Provider;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assertThat;
+
+/**
+ * Tests {@link SimpleLazilyInitializedProvider}.
+ */
+@RunWith(JUnit4.class)
+public class SimpleLazilyInitializedProviderTest {
+  @Test(expected = NullPointerException.class)
+  public void create_nullPointerException() {
+    SimpleLazilyInitializedProvider.create(null);
+  }
+
+  @Test
+  public void get() {
+    Provider<Integer> provider =
+        SimpleLazilyInitializedProvider.create(
+            new Factory<Integer>() {
+              int i = 0;
+
+              @Override
+              public Integer get() {
+                return i++;
+              }
+            });
+    assertThat(provider.get()).isEqualTo(0);
+    assertThat(provider.get()).isEqualTo(0);
+    assertThat(provider.get()).isEqualTo(0);
+  }
+}
