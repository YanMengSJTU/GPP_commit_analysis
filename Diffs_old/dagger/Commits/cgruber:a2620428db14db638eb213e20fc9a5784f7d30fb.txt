diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
index 84f273f07..8c202d320 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -536,7 +536,7 @@ private FieldWriter addFrameworkField(boolean useRawType,
         ContributionBinding contributionBinding =
             getOnlyElement(resolvedBindings.contributionBindings());
         if (contributionBinding.contributionType().isMultibinding()
-            || !(contributionBinding.bindingType().equals(Binding.Type.PROVISION))) {
+            || !contributionBinding.bindingType().equals(BindingType.PROVISION)) {
           return Optional.absent();
         }
         if (contributionBinding.factoryCreationStrategy().equals(ENUM_INSTANCE)
@@ -751,7 +751,8 @@ private Snippet initializeSetMultibindings(ResolvedBindings resolvedBindings) {
     SetType setType = SetType.from(resolvedBindings.bindingKey().key().type());
     Class<?> factoryClass =
         Iterables.all(
-                resolvedBindings.contributionBindings(), Binding.isOfType(Binding.Type.PROVISION))
+                resolvedBindings.contributionBindings(),
+                BindingType.isOfType(BindingType.PROVISION))
             ? SetFactory.class
             : setType.elementsAreTypeOf(Produced.class)
                 ? SetOfProducedProducer.class
@@ -771,7 +772,7 @@ private Snippet initializeMapMultibindings(ResolvedBindings resolvedBindings) {
     ImmutableList.Builder<Snippet> initializationSnippets = ImmutableList.builder();
 
     if (Iterables.any(
-        resolvedBindings.contributionBindings(), Binding.isOfType(Binding.Type.PRODUCTION))) {
+        resolvedBindings.contributionBindings(), BindingType.isOfType(BindingType.PRODUCTION))) {
       // TODO(beder): Implement producer map bindings.
       throw new IllegalStateException("producer map bindings not implemented yet");
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/Binding.java b/compiler/src/main/java/dagger/internal/codegen/Binding.java
index 49e67a7b1..e53fc2de7 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Binding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Binding.java
@@ -17,17 +17,15 @@
 
 import com.google.auto.common.MoreElements;
 import com.google.common.base.Optional;
-import com.google.common.base.Predicate;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Lists;
-import dagger.MembersInjector;
-import dagger.producers.Producer;
+import dagger.internal.codegen.BindingType.HasBindingType;
+import dagger.internal.codegen.Key.HasKey;
+import dagger.internal.codegen.SourceElement.HasSourceElement;
 import java.util.List;
 import java.util.Set;
-import javax.inject.Provider;
 import javax.lang.model.element.Element;
-import javax.lang.model.element.ElementVisitor;
 import javax.lang.model.element.Name;
 import javax.lang.model.element.PackageElement;
 import javax.lang.model.element.TypeElement;
@@ -36,7 +34,6 @@
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.type.WildcardType;
-import javax.lang.model.util.SimpleElementVisitor6;
 import javax.lang.model.util.SimpleTypeVisitor6;
 import javax.lang.model.util.Types;
 
@@ -51,62 +48,7 @@
  * @author Gregory Kick
  * @since 2.0
  */
-abstract class Binding {
-  
-  /**
-   * A binding subtype.
-   */
-  enum Type {
-    /** A binding with this type is a {@link ProvisionBinding}. */
-    PROVISION(Provider.class),
-    /** A binding with this type is a {@link MembersInjectionBinding}. */
-    MEMBERS_INJECTION(MembersInjector.class),
-    /** A binding with this type is a {@link ProductionBinding}. */
-    PRODUCTION(Producer.class),
-    ;
-    
-    private final Class<?> frameworkClass;
-    
-    private Type(Class<?> frameworkClass) {
-      this.frameworkClass = frameworkClass;
-    }
-    
-    /**
-     * Returns the framework class associated with bindings of this type.
-     */
-    Class<?> frameworkClass() {
-      return frameworkClass;
-    }
-
-    BindingKey.Kind bindingKeyKind() {
-      switch (this) {
-        case MEMBERS_INJECTION:
-          return BindingKey.Kind.MEMBERS_INJECTION;
-        case PROVISION:
-        case PRODUCTION:
-          return BindingKey.Kind.CONTRIBUTION;
-        default:
-          throw new AssertionError();
-      }
-    }
-  }
-
-  /**
-   * The subtype of this binding.
-   */
-  abstract Binding.Type bindingType();
-
-  /**
-   * A predicate that passes for bindings of a given subtype.
-   */
-  static Predicate<Binding> isOfType(final Type type) {
-    return new Predicate<Binding>() {
-      @Override
-      public boolean apply(Binding binding) {
-        return binding.bindingType().equals(type);
-      }
-    };
-  }
+abstract class Binding implements HasBindingType, HasKey, HasSourceElement {
 
   /**
    * Returns the framework class associated with this binding.
@@ -116,29 +58,19 @@ public boolean apply(Binding binding) {
   }
 
   /** The {@link Key} that is provided by this binding. */
-  protected abstract Key key();
+  @Override
+  public abstract Key key();
 
   /** Returns the {@link Element} instance that is responsible for declaring the binding. */
-  abstract Element bindingElement();
+  Element bindingElement() {
+    return sourceElement().element();
+  }
 
   /** The type enclosing the binding {@link #bindingElement()}. */
   TypeElement bindingTypeElement() {
-    return BINDING_TYPE_ELEMENT.visit(bindingElement());
+    return sourceElement().enclosingTypeElement();
   }
 
-  private static final ElementVisitor<TypeElement, Void> BINDING_TYPE_ELEMENT =
-      new SimpleElementVisitor6<TypeElement, Void>() {
-        @Override
-        protected TypeElement defaultAction(Element e, Void p) {
-          return visit(e.getEnclosingElement());
-        }
-
-        @Override
-        public TypeElement visitType(TypeElement e, Void p) {
-          return e;
-        }
-      };
-
   /**
    * The explicit set of {@link DependencyRequest dependencies} required to satisfy this binding.
    */
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
index b65f9f153..915c30b85 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
@@ -33,7 +33,6 @@
 import com.google.common.collect.TreeTraverser;
 import dagger.Component;
 import dagger.Subcomponent;
-import dagger.internal.codegen.Binding.Type;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
 import dagger.producers.ProductionComponent;
 import java.util.ArrayDeque;
@@ -63,6 +62,7 @@
 import static dagger.internal.codegen.ComponentDescriptor.ComponentMethodKind.SUBCOMPONENT_BUILDER;
 import static dagger.internal.codegen.ComponentDescriptor.Kind.PRODUCTION_COMPONENT;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
+import static dagger.internal.codegen.Key.indexByKey;
 import static javax.lang.model.element.Modifier.STATIC;
 
 /**
@@ -234,9 +234,7 @@ private BindingGraph create(
 
       Resolver requestResolver =
           new Resolver(
-              parentResolver,
-              componentDescriptor,
-              explicitBindingsByKey(explicitBindingsBuilder.build()));
+              parentResolver, componentDescriptor, indexByKey(explicitBindingsBuilder.build()));
       for (ComponentMethodDescriptor componentMethod : componentDescriptor.componentMethods()) {
         Optional<DependencyRequest> componentMethodRequest = componentMethod.dependencyRequest();
         if (componentMethodRequest.isPresent()) {
@@ -268,16 +266,6 @@ private BindingGraph create(
           requestResolver.getOwnedModules());
     }
 
-    private <B extends ContributionBinding> ImmutableSetMultimap<Key, B> explicitBindingsByKey(
-        Iterable<? extends B> bindings) {
-      // Multimaps.index() doesn't do ImmutableSetMultimaps.
-      ImmutableSetMultimap.Builder<Key, B> builder = ImmutableSetMultimap.builder();
-      for (B binding : bindings) {
-        builder.put(binding.key(), binding);
-      }
-      return builder.build();
-    }
-
     private final class Resolver {
       final Optional<Resolver> parentResolver;
       final ComponentDescriptor componentDescriptor;
@@ -465,6 +453,10 @@ private boolean shouldOwnParentBinding(
         return ImmutableList.copyOf(Lists.reverse(resolverList));
       }
 
+      /**
+       * Returns the explicit {@link ContributionBinding}s that match the {@code requestKey} from
+       * this and all ancestor resolvers.
+       */
       private ImmutableSet<ContributionBinding> getExplicitBindings(Key requestKey) {
         ImmutableSet.Builder<ContributionBinding> explicitBindingsForKey = ImmutableSet.builder();
         for (Resolver resolver : getResolverLineage()) {
@@ -562,7 +554,7 @@ public Boolean call() {
 
                   for (Binding binding : previouslyResolvedBindings.bindings()) {
                     if (!binding.scope().isPresent()
-                        && !binding.bindingType().equals(Type.PRODUCTION)) {
+                        && !binding.bindingType().equals(BindingType.PRODUCTION)) {
                       for (DependencyRequest dependency : binding.implicitDependencies()) {
                         if (dependsOnLocalMultibindings(
                             getPreviouslyResolvedBindings(dependency.bindingKey()).get(),
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
index 153b175f1..d8b1d2358 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -33,7 +33,6 @@
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Maps;
 import com.google.common.collect.Multimap;
-import com.google.common.collect.Multimaps;
 import com.google.common.collect.Ordering;
 import com.google.common.collect.Sets;
 import dagger.Component;
@@ -41,7 +40,6 @@
 import dagger.MapKey;
 import dagger.internal.codegen.ComponentDescriptor.BuilderSpec;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
-import dagger.internal.codegen.ContributionBinding.ContributionType;
 import dagger.internal.codegen.writer.TypeNames;
 import java.util.ArrayDeque;
 import java.util.Arrays;
@@ -86,6 +84,7 @@
 import static dagger.internal.codegen.ContributionBinding.indexMapBindingsByAnnotationType;
 import static dagger.internal.codegen.ContributionBinding.indexMapBindingsByMapKey;
 import static dagger.internal.codegen.ContributionBinding.Kind.SYNTHETIC_MAP;
+import static dagger.internal.codegen.ContributionType.indexByContributionType;
 import static dagger.internal.codegen.ErrorMessages.DUPLICATE_SIZE_LIMIT;
 import static dagger.internal.codegen.ErrorMessages.INDENT;
 import static dagger.internal.codegen.ErrorMessages.MEMBERS_INJECTION_WITH_UNBOUNDED_TYPE;
@@ -107,7 +106,7 @@
   private final InjectBindingRegistry injectBindingRegistry;
   private final ValidationType scopeCycleValidationType;
   private final Diagnostic.Kind nullableValidationType;
-  private final ContributionBindingFormatter contributionBindingFormatter;
+  private final HasSourceElementFormatter hasSourceElementFormatter;
   private final MethodSignatureFormatter methodSignatureFormatter;
   private final DependencyRequestFormatter dependencyRequestFormatter;
   private final KeyFormatter keyFormatter;
@@ -118,7 +117,7 @@
       InjectBindingRegistry injectBindingRegistry,
       ValidationType scopeCycleValidationType,
       Diagnostic.Kind nullableValidationType,
-      ContributionBindingFormatter contributionBindingFormatter,
+      HasSourceElementFormatter hasSourceElementFormatter,
       MethodSignatureFormatter methodSignatureFormatter,
       DependencyRequestFormatter dependencyRequestFormatter,
       KeyFormatter keyFormatter,
@@ -127,7 +126,7 @@
     this.injectBindingRegistry = injectBindingRegistry;
     this.scopeCycleValidationType = scopeCycleValidationType;
     this.nullableValidationType = nullableValidationType;
-    this.contributionBindingFormatter = contributionBindingFormatter;
+    this.hasSourceElementFormatter = hasSourceElementFormatter;
     this.methodSignatureFormatter = methodSignatureFormatter;
     this.dependencyRequestFormatter = dependencyRequestFormatter;
     this.keyFormatter = keyFormatter;
@@ -286,14 +285,15 @@ private boolean validateResolvedBinding(
           ImmutableSet<ContributionBinding> contributionBindings =
               resolvedBinding.contributionBindings();
           if (Iterables.any(
-              contributionBindings, Binding.isOfType(Binding.Type.MEMBERS_INJECTION))) {
-            throw new IllegalArgumentException(
+              resolvedBinding.bindings(), BindingType.isOfType(BindingType.MEMBERS_INJECTION))) {
+            // TODO(dpb): How could this ever happen, even in an invalid graph?
+            throw new AssertionError(
                 "contribution binding keys should never have members injection bindings");
           }
           if (!validateNullability(path.peek().request(), contributionBindings)) {
             return false;
           }
-          if (Iterables.any(contributionBindings, Binding.isOfType(Binding.Type.PRODUCTION))
+          if (Iterables.any(contributionBindings, BindingType.isOfType(BindingType.PRODUCTION))
               && doesPathRequireProvisionOnly(path)) {
             reportProviderMayNotDependOnProducer(path);
             return false;
@@ -301,13 +301,13 @@ private boolean validateResolvedBinding(
           if (contributionBindings.size() <= 1) {
             return true;
           }
-          ImmutableListMultimap<ContributionType, ContributionBinding> contributionsByType =
-              contributionBindingsByType(resolvedBinding);
-          if (contributionsByType.keySet().size() > 1) {
+          ImmutableSet<ContributionType> contributionTypes =
+              contributionBindingsByType(resolvedBinding).keySet();
+          if (contributionTypes.size() > 1) {
             reportMultipleBindingTypes(path);
             return false;
           }
-          switch (getOnlyElement(contributionsByType.keySet())) {
+          switch (getOnlyElement(contributionTypes)) {
             case UNIQUE:
               reportDuplicateBindings(path);
               return false;
@@ -324,8 +324,9 @@ private boolean validateResolvedBinding(
           break;
         case MEMBERS_INJECTION:
           if (!Iterables.all(
-              resolvedBinding.bindings(), Binding.isOfType(Binding.Type.MEMBERS_INJECTION))) {
-            throw new IllegalArgumentException(
+              resolvedBinding.bindings(), BindingType.isOfType(BindingType.MEMBERS_INJECTION))) {
+            // TODO(dpb): How could this ever happen, even in an invalid graph?
+            throw new AssertionError(
                 "members injection binding keys should never have contribution bindings");
           }
           if (resolvedBinding.bindings().size() > 1) {
@@ -387,8 +388,7 @@ private boolean validateResolvedBinding(
 
     private ImmutableListMultimap<ContributionType, ContributionBinding> contributionBindingsByType(
         ResolvedBindings resolvedBinding) {
-      return Multimaps.index(
-          inlineSyntheticContributions(resolvedBinding), ContributionBinding.CONTRIBUTION_TYPE);
+      return indexByContributionType(inlineSyntheticContributions(resolvedBinding));
     }
 
     /** Ensures that if the request isn't nullable, then each contribution is also not nullable. */
@@ -409,7 +409,7 @@ private boolean validateNullability(
       for (ContributionBinding binding : bindings) {
         if (binding.nullableType().isPresent()) {
           reportBuilder.addItem(
-              nullableToNonNullable(typeName, contributionBindingFormatter.format(binding))
+              nullableToNonNullable(typeName, hasSourceElementFormatter.format(binding))
                   + "\n at: "
                   + dependencyRequestFormatter.format(request),
               nullableValidationType,
@@ -877,7 +877,8 @@ private void reportDuplicateBindings(Deque<ResolvedRequest> path) {
       StringBuilder builder = new StringBuilder();
       new Formatter(builder)
           .format(ErrorMessages.DUPLICATE_BINDINGS_FOR_KEY_FORMAT, formatRootRequestKey(path));
-      appendBindings(builder, inlineSyntheticContributions(resolvedBinding), 1);
+      hasSourceElementFormatter.formatIndentedList(
+          builder, inlineSyntheticContributions(resolvedBinding), 1, DUPLICATE_SIZE_LIMIT);
       reportBuilder.addError(builder.toString(), path.getLast().request().requestElement());
     }
 
@@ -892,15 +893,11 @@ private void reportMultipleBindingTypes(Deque<ResolvedRequest> path) {
       for (ContributionType type :
           Ordering.natural().immutableSortedCopy(bindingsByType.keySet())) {
         builder.append(INDENT);
-        builder.append(formatBindingType(type));
-        builder.append(" bindings:\n");
-        for (ContributionBinding binding : bindingsByType.get(type)) {
-          builder
-              .append(INDENT)
-              .append(INDENT)
-              .append(contributionBindingFormatter.format(binding))
-              .append('\n');
-        }
+        builder.append(formatContributionType(type));
+        builder.append(" bindings:");
+        hasSourceElementFormatter.formatIndentedList(
+            builder, bindingsByType.get(type), 2, DUPLICATE_SIZE_LIMIT);
+        builder.append('\n');
       }
       reportBuilder.addError(builder.toString(), path.getLast().request().requestElement());
     }
@@ -909,7 +906,7 @@ private void reportDuplicateMapKeys(
         Deque<ResolvedRequest> path, Collection<ContributionBinding> mapBindings) {
       StringBuilder builder = new StringBuilder();
       builder.append(duplicateMapKeysError(formatRootRequestKey(path)));
-      appendBindings(builder, mapBindings, 1);
+      hasSourceElementFormatter.formatIndentedList(builder, mapBindings, 1, DUPLICATE_SIZE_LIMIT);
       reportBuilder.addError(builder.toString(), path.getLast().request().requestElement());
     }
 
@@ -930,7 +927,7 @@ private void reportInconsistentMapKeyAnnotations(
             .append(annotationType)
             .append(':');
 
-        appendBindings(builder, bindings, 2);
+        hasSourceElementFormatter.formatIndentedList(builder, bindings, 2, DUPLICATE_SIZE_LIMIT);
       }
       reportBuilder.addError(builder.toString(), path.getLast().request().requestElement());
     }
@@ -1115,7 +1112,7 @@ private boolean doesPathRequireProvisionOnly(Deque<ResolvedRequest> path) {
     final DependencyRequest request = iterator.next().request();
     ResolvedRequest previousResolvedRequest = iterator.next();
     return FluentIterable.from(previousResolvedRequest.binding().bindings())
-        .filter(Binding.isOfType(Binding.Type.PROVISION))
+        .filter(BindingType.isOfType(BindingType.PROVISION))
         .filter(
             new Predicate<Binding>() {
               @Override
@@ -1126,7 +1123,7 @@ public boolean apply(Binding binding) {
         .toSet();
   }
 
-  private String formatBindingType(ContributionType type) {
+  private String formatContributionType(ContributionType type) {
     switch (type) {
       case MAP:
         return "Map";
@@ -1143,28 +1140,6 @@ private String formatRootRequestKey(Deque<ResolvedRequest> path) {
     return keyFormatter.format(path.peek().request().key());
   }
 
-  private void appendBindings(
-      StringBuilder builder, Collection<ContributionBinding> bindings, int indentLevel) {
-    for (ContributionBinding binding : Iterables.limit(bindings, DUPLICATE_SIZE_LIMIT)) {
-      builder.append('\n');
-      for (int i = 0; i < indentLevel; i++) {
-        builder.append(INDENT);
-      }
-      builder.append(contributionBindingFormatter.format(binding));
-    }
-    int numberOfOtherBindings = bindings.size() - DUPLICATE_SIZE_LIMIT;
-    if (numberOfOtherBindings > 0) {
-      builder.append('\n');
-      for (int i = 0; i < indentLevel; i++) {
-        builder.append(INDENT);
-      }
-      builder.append("and ").append(numberOfOtherBindings).append(" other");
-    }
-    if (numberOfOtherBindings > 1) {
-      builder.append('s');
-    }
-  }
-
   @AutoValue
   abstract static class ResolvedRequest {
     abstract DependencyRequest request();
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingType.java b/compiler/src/main/java/dagger/internal/codegen/BindingType.java
new file mode 100644
index 000000000..8d2a1d6c5
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingType.java
@@ -0,0 +1,69 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.common.base.Function;
+import com.google.common.base.Predicate;
+import com.google.common.base.Predicates;
+import dagger.MembersInjector;
+import dagger.producers.Producer;
+import javax.inject.Provider;
+
+/**
+ * Whether a binding or declaration is for provision, production, or a {@link MembersInjector}.
+ */
+enum BindingType {
+  /** A binding with this type is a {@link ProvisionBinding}. */
+  PROVISION(Provider.class),
+
+  /** A binding with this type is a {@link MembersInjectionBinding}. */
+  MEMBERS_INJECTION(MembersInjector.class),
+
+  /** A binding with this type is a {@link ProductionBinding}. */
+  PRODUCTION(Producer.class),
+  ;
+
+  /** An object that is associated with a {@link BindingType}. */
+  interface HasBindingType {
+    /** The binding type of this object. */
+    BindingType bindingType();
+  }
+
+  private final Class<?> frameworkClass;
+
+  private BindingType(Class<?> frameworkClass) {
+    this.frameworkClass = frameworkClass;
+  }
+
+  /** The framework class associated with bindings of this type. */
+  Class<?> frameworkClass() {
+    return frameworkClass;
+  }
+
+  /** A predicate that passes for {@link HasBindingType}s with a given type. */
+  static Predicate<HasBindingType> isOfType(BindingType type) {
+    return Predicates.compose(Predicates.equalTo(type), BINDING_TYPE);
+  }
+
+  /** A function that returns {@link HasBindingType#bindingType()}. */
+  static Function<HasBindingType, BindingType> BINDING_TYPE =
+      new Function<HasBindingType, BindingType>() {
+        @Override
+        public BindingType apply(HasBindingType hasBindingType) {
+          return hasBindingType.bindingType();
+        }
+      };
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
index 078736090..dfc77efe4 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -65,7 +65,7 @@ public SourceVersion getSupportedSourceVersion() {
   }
 
   @Override
-  protected Iterable<ProcessingStep> initSteps() {
+  protected Iterable<? extends ProcessingStep> initSteps() {
     Messager messager = processingEnv.getMessager();
     Types types = processingEnv.getTypeUtils();
     Elements elements = processingEnv.getElementUtils();
@@ -75,8 +75,8 @@ public SourceVersion getSupportedSourceVersion() {
         nullableValidationType(processingEnv).diagnosticKind().get();
 
     MethodSignatureFormatter methodSignatureFormatter = new MethodSignatureFormatter(types);
-    ContributionBindingFormatter contributionBindingFormatter =
-        new ContributionBindingFormatter(methodSignatureFormatter);
+    HasSourceElementFormatter hasSourceElementFormatter =
+        new HasSourceElementFormatter(methodSignatureFormatter);
     DependencyRequestFormatter dependencyRequestFormatter = new DependencyRequestFormatter(types);
     KeyFormatter keyFormatter = new KeyFormatter();
 
@@ -149,13 +149,13 @@ public SourceVersion getSupportedSourceVersion() {
             injectBindingRegistry,
             scopeValidationType(processingEnv),
             nullableDiagnosticType,
-            contributionBindingFormatter,
+            hasSourceElementFormatter,
             methodSignatureFormatter,
             dependencyRequestFormatter,
             keyFormatter,
             keyFactory);
 
-    return ImmutableList.<ProcessingStep>of(
+    return ImmutableList.of(
         new MapKeyProcessingStep(messager, types, mapKeyValidator, mapKeyGenerator),
         new InjectProcessingStep(
             messager,
diff --git a/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
index d6be50c37..dbe84067d 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
@@ -28,6 +28,7 @@
 import dagger.Component;
 import dagger.MapKey;
 import dagger.Provides;
+import dagger.internal.codegen.ContributionType.HasContributionType;
 import dagger.producers.Produces;
 import dagger.producers.ProductionComponent;
 import java.util.Set;
@@ -48,7 +49,7 @@
  * @author Jesse Beder
  * @since 2.0
  */
-abstract class ContributionBinding extends Binding {
+abstract class ContributionBinding extends Binding implements HasContributionType {
 
   @Override
   Set<DependencyRequest> implicitDependencies() {
@@ -60,41 +61,6 @@
       return Sets.union(membersInjectionRequest().asSet(), dependencies());
     }
   }
-
-  static enum ContributionType {
-    /** Represents map bindings. */
-    MAP,
-    /** Represents set bindings. */
-    SET,
-    /** Represents a valid non-collection binding. */
-    UNIQUE;
-
-    boolean isMultibinding() {
-      return !this.equals(UNIQUE);
-    }
-  }
-
-  ContributionType contributionType() {
-    switch (provisionType()) {
-      case SET:
-      case SET_VALUES:
-        return ContributionType.SET;
-      case MAP:
-        return ContributionType.MAP;
-      case UNIQUE:
-        return ContributionType.UNIQUE;
-      default:
-        throw new AssertionError("Unknown provision type: " + provisionType());
-    }
-  }
-  
-  static final Function<ContributionBinding, ContributionType> CONTRIBUTION_TYPE =
-      new Function<ContributionBinding, ContributionType>() {
-        @Override
-        public ContributionType apply(ContributionBinding binding) {
-          return binding.contributionType();
-        }
-      };
   
   /** Returns the type that specifies this' nullability, absent if not nullable. */
   abstract Optional<DeclaredType> nullableType();
@@ -105,7 +71,9 @@ public ContributionType apply(ContributionBinding binding) {
    * binding's enclosed element, as this will return the subclass whereas the enclosed element will
    * be the superclass.
    */
-  abstract Optional<TypeElement> contributedBy();
+  Optional<TypeElement> contributedBy() {
+    return sourceElement().contributedBy();
+  }
 
   /**
    * Returns whether this binding is synthetic, i.e., not explicitly tied to code, but generated
@@ -184,6 +152,11 @@ public boolean apply(ContributionBinding binding) {
   /** The provision type that was used to bind the key. */
   abstract Provides.Type provisionType();
 
+  @Override
+  public ContributionType contributionType() {
+    return ContributionType.forProvisionType(provisionType());
+  }
+
   /**
    * The strategy for getting an instance of a factory for a {@link ContributionBinding}.
    */
diff --git a/compiler/src/main/java/dagger/internal/codegen/ContributionBindingFormatter.java b/compiler/src/main/java/dagger/internal/codegen/ContributionBindingFormatter.java
deleted file mode 100644
index 0d267619b..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/ContributionBindingFormatter.java
+++ /dev/null
@@ -1,55 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen;
-
-import com.google.common.base.Optional;
-
-import static com.google.auto.common.MoreElements.asExecutable;
-import static com.google.auto.common.MoreTypes.asDeclared;
-
-/**
- * Formats a {@link ContributionBinding} into a {@link String} suitable for use in error messages.
- *
- * @author Christian Gruber
- * @since 2.0
- */
-final class ContributionBindingFormatter extends Formatter<ContributionBinding> {
-  private final MethodSignatureFormatter methodSignatureFormatter;
-  
-  ContributionBindingFormatter(MethodSignatureFormatter methodSignatureFormatter) { 
-    this.methodSignatureFormatter = methodSignatureFormatter;
-  }
-
-  @Override public String format(ContributionBinding binding) {
-    switch (binding.bindingKind()) {
-      case COMPONENT_PROVISION:
-      case COMPONENT_PRODUCTION:
-        return methodSignatureFormatter.format(asExecutable(binding.bindingElement()));
-
-      case PROVISION:
-      case SUBCOMPONENT_BUILDER:
-      case IMMEDIATE:
-      case FUTURE_PRODUCTION:
-        return methodSignatureFormatter.format(
-            asExecutable(binding.bindingElement()),
-            Optional.of(asDeclared(binding.contributedBy().get().asType())));
-
-      default:
-        throw new UnsupportedOperationException(
-            "Not yet supporting " + binding.bindingKind() + " binding types.");
-    }
-  }
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ContributionType.java b/compiler/src/main/java/dagger/internal/codegen/ContributionType.java
new file mode 100644
index 000000000..a1033932a
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/ContributionType.java
@@ -0,0 +1,78 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.common.base.Function;
+import com.google.common.collect.ImmutableListMultimap;
+import com.google.common.collect.Multimaps;
+
+/**
+ * Whether a binding or declaration is for a unique contribution or a map or set multibinding.
+ */
+enum ContributionType {
+  /** Represents map bindings. */
+  MAP,
+  /** Represents set bindings. */
+  SET,
+  /** Represents a valid non-collection binding. */
+  UNIQUE,
+  ;
+
+  /**
+   * An object that is associated with a {@link ContributionType}.
+   */
+  interface HasContributionType {
+
+    /** The contribution type of this object. */
+    ContributionType contributionType();
+  }
+
+  /**
+   * {@code true} if this is for a multibinding.
+   */
+  boolean isMultibinding() {
+    return !this.equals(UNIQUE);
+  }
+
+  /** The contribution type for a given provision type. */
+  static ContributionType forProvisionType(dagger.Provides.Type provisionType) {
+    switch (provisionType) {
+      case SET:
+      case SET_VALUES:
+        return SET;
+      case MAP:
+        return MAP;
+      case UNIQUE:
+        return UNIQUE;
+      default:
+        throw new AssertionError("Unknown provision type: " + provisionType);
+    }
+  }
+
+  /** Indexes objects by their contribution type. */
+  static <T extends HasContributionType>
+      ImmutableListMultimap<ContributionType, T> indexByContributionType(
+          Iterable<T> haveContributionTypes) {
+    return Multimaps.index(
+        haveContributionTypes,
+        new Function<HasContributionType, ContributionType>() {
+          @Override
+          public ContributionType apply(HasContributionType hasContributionType) {
+            return hasContributionType.contributionType();
+          }
+        });
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
index 0fbfa7dde..2a99d529a 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
@@ -22,7 +22,6 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Lists;
 import dagger.MembersInjector;
-import dagger.Provides.Type;
 import dagger.internal.Factory;
 import dagger.internal.codegen.writer.ClassName;
 import dagger.internal.codegen.writer.ClassWriter;
@@ -107,7 +106,7 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
     checkState(!binding.hasNonDefaultTypeParameters());
 
     TypeMirror keyType =
-        binding.provisionType().equals(Type.MAP)
+        binding.contributionType().equals(ContributionType.MAP)
             ? MapType.from(binding.key().type()).unwrappedValueType(Provider.class)
             : binding.key().type();
     TypeName providedTypeName = TypeNames.forTypeMirror(keyType);
diff --git a/compiler/src/main/java/dagger/internal/codegen/Formatter.java b/compiler/src/main/java/dagger/internal/codegen/Formatter.java
index 880b78705..93f88bee1 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Formatter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Formatter.java
@@ -16,6 +16,10 @@
 package dagger.internal.codegen;
 
 import com.google.common.base.Function;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.Iterables;
+
+import static dagger.internal.codegen.ErrorMessages.INDENT;
 
 /**
  * A formatter which transforms an instance of a particular type into a string
@@ -45,4 +49,48 @@
   @Override final public String apply(T object) {
     return format(object);
   }
+
+  /**
+   * Formats {@code items}, one per line.
+   */
+  public void formatIndentedList(
+      StringBuilder builder, Iterable<? extends T> items, int indentLevel) {
+    formatIndentedList(builder, indentLevel, items, ImmutableList.<T>of());
+  }
+
+  /**
+   * Formats {@code items}, one per line. Stops after {@code limit} items.
+   */
+  public void formatIndentedList(
+      StringBuilder builder, Iterable<? extends T> items, int indentLevel, int limit) {
+    formatIndentedList(
+        builder, indentLevel, Iterables.limit(items, limit), Iterables.skip(items, limit));
+  }
+
+  private void formatIndentedList(
+      StringBuilder builder,
+      int indentLevel,
+      Iterable<? extends T> firstItems,
+      Iterable<? extends T> restOfItems) {
+    for (T item : firstItems) {
+      builder.append('\n');
+      appendIndent(builder, indentLevel);
+      builder.append(format(item));
+    }
+    int numberOfOtherItems = Iterables.size(restOfItems);
+    if (numberOfOtherItems > 0) {
+      builder.append('\n');
+      appendIndent(builder, indentLevel);
+      builder.append("and ").append(numberOfOtherItems).append(" other");
+    }
+    if (numberOfOtherItems > 1) {
+      builder.append('s');
+    }
+  }
+
+  private void appendIndent(StringBuilder builder, int indentLevel) {
+    for (int i = 0; i < indentLevel; i++) {
+      builder.append(INDENT);
+    }
+  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java b/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java
index 13ed223bc..13950bc9b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java
@@ -15,17 +15,14 @@
  */
 package dagger.internal.codegen;
 
-import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
 import com.google.common.base.CaseFormat;
-import dagger.internal.codegen.ContributionBinding.ContributionType;
 import dagger.internal.codegen.writer.ClassName;
 import dagger.internal.codegen.writer.ParameterizedTypeName;
 import dagger.internal.codegen.writer.TypeNames;
 import javax.lang.model.element.ElementVisitor;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
-import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.ElementKindVisitor6;
 
 import static com.google.common.collect.Iterables.getOnlyElement;
@@ -49,9 +46,9 @@ static FrameworkField createWithTypeFromKey(Class<?> frameworkClass, Key key, St
   }
 
   private static FrameworkField createForMapBindingContribution(Key key, String name) {
-    TypeMirror mapValueType = MoreTypes.asDeclared(key.type()).getTypeArguments().get(1);
     return new AutoValue_FrameworkField(
-        (ParameterizedTypeName) TypeNames.forTypeMirror(mapValueType), name);
+        (ParameterizedTypeName) TypeNames.forTypeMirror(MapType.from(key.type()).valueType()),
+        name);
   }
 
   static FrameworkField createForSyntheticContributionBinding(
diff --git a/compiler/src/main/java/dagger/internal/codegen/HasSourceElementFormatter.java b/compiler/src/main/java/dagger/internal/codegen/HasSourceElementFormatter.java
new file mode 100644
index 000000000..d73930aee
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/HasSourceElementFormatter.java
@@ -0,0 +1,53 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.common.MoreElements;
+import com.google.auto.common.MoreTypes;
+import com.google.common.base.Optional;
+import dagger.internal.codegen.SourceElement.HasSourceElement;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeKind;
+
+import static com.google.common.base.Preconditions.checkArgument;
+
+/**
+ * Formats a {@link HasSourceElement} into a {@link String} suitable for use in error messages.
+ */
+final class HasSourceElementFormatter extends Formatter<HasSourceElement> {
+  private final MethodSignatureFormatter methodSignatureFormatter;
+
+  HasSourceElementFormatter(MethodSignatureFormatter methodSignatureFormatter) {
+    this.methodSignatureFormatter = methodSignatureFormatter;
+  }
+
+  @Override
+  public String format(HasSourceElement hasElement) {
+    SourceElement sourceElement = hasElement.sourceElement();
+    checkArgument(
+        sourceElement.element().asType().getKind().equals(TypeKind.EXECUTABLE),
+        "Not yet supporting nonexecutable elements: %s",
+        hasElement);
+
+    Optional<TypeElement> contributedBy = sourceElement.contributedBy();
+    return methodSignatureFormatter.format(
+        MoreElements.asExecutable(sourceElement.element()),
+        contributedBy.isPresent()
+            ? Optional.of(MoreTypes.asDeclared(contributedBy.get().asType()))
+            : Optional.<DeclaredType>absent());
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/Key.java b/compiler/src/main/java/dagger/internal/codegen/Key.java
index 0f3da6b6d..346169f27 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Key.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Key.java
@@ -21,9 +21,12 @@
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Equivalence;
 import com.google.common.base.Equivalence.Wrapper;
+import com.google.common.base.Function;
 import com.google.common.base.MoreObjects;
 import com.google.common.base.Optional;
+import com.google.common.collect.ImmutableSetMultimap;
 import com.google.common.collect.Iterables;
+import com.google.common.collect.Multimaps;
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.Provides;
 import dagger.producers.Produced;
@@ -63,6 +66,13 @@
  */
 @AutoValue
 abstract class Key {
+  
+  /** An object that is associated with a {@link Key}. */
+  interface HasKey {
+    /** The key associated with this object. */
+    Key key();
+  }
+
   /**
    * A {@link javax.inject.Qualifier} annotation that provides a unique namespace prefix
    * for the type of this key.
@@ -154,6 +164,21 @@ public String toString() {
         .toString();
   }
 
+  /**
+   * Indexes {@code haveKeys} by {@link HasKey#key()}.
+   */
+  static <T extends HasKey> ImmutableSetMultimap<Key, T> indexByKey(Iterable<T> haveKeys) {
+    return ImmutableSetMultimap.copyOf(
+        Multimaps.index(
+            haveKeys,
+            new Function<HasKey, Key>() {
+              @Override
+              public Key apply(HasKey hasKey) {
+                return hasKey.key();
+              }
+            }));
+  }
+
   /**
    * Wraps an {@link Optional} of a type in an {@code Optional} of a {@link Wrapper} for that type.
    */
@@ -282,10 +307,10 @@ private TypeMirror providesOrProducesKeyType(
         case SET:
           return types.getDeclaredType(getSetElement(), returnType);
         case MAP:
-          return mapOfFactoryType(
-              method,
-              returnType,
-              providesType.isPresent() ? getProviderElement() : getProducerElement());
+          return mapOfFrameworkType(
+              mapKeyType(method),
+              providesType.isPresent() ? getProviderElement() : getProducerElement(),
+              returnType);
         case SET_VALUES:
           // TODO(gak): do we want to allow people to use "covariant return" here?
           checkArgument(MoreTypes.isType(returnType) && MoreTypes.isTypeOf(Set.class, returnType));
@@ -295,11 +320,13 @@ private TypeMirror providesOrProducesKeyType(
       }
     }
 
-    private TypeMirror mapOfFactoryType(
-        ExecutableElement method, TypeMirror valueType, TypeElement factoryType) {
-      TypeMirror mapKeyType = mapKeyType(method);
-      TypeMirror mapValueFactoryType = types.getDeclaredType(factoryType, valueType);
-      return types.getDeclaredType(getMapElement(), mapKeyType, mapValueFactoryType);
+    /**
+     * Returns {@code Map<KeyType, FrameworkType<ValueType>>}.
+     */
+    private TypeMirror mapOfFrameworkType(
+        TypeMirror keyType, TypeElement frameworkType, TypeMirror valueType) {
+      return types.getDeclaredType(
+          getMapElement(), keyType, types.getDeclaredType(frameworkType, valueType));
     }
 
     private TypeMirror mapKeyType(ExecutableElement method) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/MapType.java b/compiler/src/main/java/dagger/internal/codegen/MapType.java
index cab30de04..5c0faf820 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MapType.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MapType.java
@@ -43,22 +43,37 @@ DeclaredType declaredMapType() {
     return wrappedDeclaredMapType().get();
   }
 
+  /**
+   * {@code true} if the map type is the raw {@link Map} type.
+   */
+  boolean isRawType() {
+    return declaredMapType().getTypeArguments().isEmpty();
+  }
+
   /**
    * The map key type.
+   * 
+   * @throws IllegalStateException if {@link #isRawType()} is true.
    */
   TypeMirror keyType() {
+    checkState(!isRawType());
     return declaredMapType().getTypeArguments().get(0);
   }
 
   /**
    * The map value type.
+   * 
+   * @throws IllegalStateException if {@link #isRawType()} is true.
    */
   TypeMirror valueType() {
+    checkState(!isRawType());
     return declaredMapType().getTypeArguments().get(1);
   }
 
   /**
    * {@code true} if {@link #valueType()} is a {@code clazz}.
+   * 
+   * @throws IllegalStateException if {@link #isRawType()} is true.
    */
   boolean valuesAreTypeOf(Class<?> clazz) {
     return MoreTypes.isType(valueType()) && MoreTypes.isTypeOf(clazz, valueType());
@@ -67,7 +82,8 @@ boolean valuesAreTypeOf(Class<?> clazz) {
   /**
    * {@code V} if {@link #valueType()} is a {@code WrappingClass<V>}.
    *
-   * @throws IllegalStateException if {@link #valueType()} is not a {@code WrappingClass<V>}
+   * @throws IllegalStateException if {@link #isRawType()} is true or {@link #valueType()} is not a
+   *     {@code WrappingClass<V>}
    * @throws IllegalArgumentException if {@code wrappingClass} does not have exactly one type
    *     parameter
    */
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
index 3346883b9..398f4bddc 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
@@ -61,7 +61,10 @@
  */
 @AutoValue
 abstract class MembersInjectionBinding extends Binding {
-  @Override abstract TypeElement bindingElement();
+  @Override
+  TypeElement bindingElement() {
+    return MoreElements.asType(super.bindingElement());
+  }
         
   /** The set of individual sites where {@link Inject} is applied. */
   abstract ImmutableSortedSet<InjectionSite> injectionSites();
@@ -82,8 +85,8 @@ Strategy injectionStrategy() {
   }
 
   @Override
-  protected Binding.Type bindingType() {
-    return Binding.Type.MEMBERS_INJECTION;
+  public BindingType bindingType() {
+    return BindingType.MEMBERS_INJECTION;
   }
 
   /**
@@ -218,12 +221,12 @@ public Key apply(DeclaredType superclass) {
       Key key = keyFactory.forMembersInjectedType(declaredType);
       TypeElement typeElement = MoreElements.asType(declaredType.asElement());
       return new AutoValue_MembersInjectionBinding(
+          SourceElement.forElement(typeElement),
           key,
           dependencies,
           dependencies,
           findBindingPackage(key),
           hasNonDefaultTypeParameters(typeElement, key.type(), types),
-          typeElement,
           injectionSites,
           parentKey);
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
index 133be5ba8..2e920d639 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
@@ -26,7 +26,6 @@
 import dagger.producers.Produces;
 import java.util.Set;
 import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.ExecutableType;
 import javax.lang.model.type.TypeKind;
@@ -48,10 +47,10 @@
 abstract class ProductionBinding extends ContributionBinding {
 
   @Override
-  Binding.Type bindingType() {
-    return Binding.Type.PRODUCTION;
+  public BindingType bindingType() {
+    return BindingType.PRODUCTION;
   }
-
+  
   @Override
   Provides.Type provisionType() {
     return Provides.Type.valueOf(productionType().name());
@@ -76,21 +75,6 @@
   /** If this production requires a monitor, this will be the corresponding request. */
   abstract Optional<DependencyRequest> monitorRequest();
 
-  @Override
-  ContributionType contributionType() {
-    switch (productionType()) {
-      case SET:
-      case SET_VALUES:
-        return ContributionType.SET;
-      case MAP:
-        return ContributionType.MAP;
-      case UNIQUE:
-        return ContributionType.UNIQUE;
-      default:
-        throw new AssertionError("Unknown production type: " + productionType());
-    }
-  }
-
   static final class Factory {
     private final Types types;
     private final Key.Factory keyFactory;
@@ -125,13 +109,12 @@ ProductionBinding forProducesMethod(
           ? Kind.FUTURE_PRODUCTION
           : Kind.IMMEDIATE;
       return new AutoValue_ProductionBinding(
+          SourceElement.forElement(producesMethod, MoreTypes.asTypeElement(declaredContainer)),
           key,
-          producesMethod,
           dependencies,
           findBindingPackage(key),
           false,
           ConfigurationAnnotations.getNullableType(producesMethod),
-          Optional.of(MoreTypes.asTypeElement(declaredContainer)),
           Optional.<DependencyRequest>absent(),
           kind,
           producesAnnotation.type(),
@@ -149,13 +132,12 @@ ProductionBinding implicitMapOfProducerBinding(DependencyRequest mapOfValueReque
           dependencyRequestFactory.forImplicitMapBinding(
               mapOfValueRequest, implicitMapOfProducerKey.get());
       return new AutoValue_ProductionBinding(
+          SourceElement.forElement(implicitMapOfProducerRequest.requestElement()),
           mapOfValueRequest.key(),
-          implicitMapOfProducerRequest.requestElement(),
           ImmutableSet.of(implicitMapOfProducerRequest),
           findBindingPackage(mapOfValueRequest.key()),
           false,
           Optional.<DeclaredType>absent(),
-          Optional.<TypeElement>absent(),
           Optional.<DependencyRequest>absent(),
           Kind.SYNTHETIC_MAP,
           Produces.Type.UNIQUE,
@@ -169,13 +151,12 @@ ProductionBinding forComponentMethod(ExecutableElement componentMethod) {
       checkArgument(componentMethod.getParameters().isEmpty());
       checkArgument(MoreTypes.isTypeOf(ListenableFuture.class, componentMethod.getReturnType()));
       return new AutoValue_ProductionBinding(
+          SourceElement.forElement(componentMethod),
           keyFactory.forProductionComponentMethod(componentMethod),
-          componentMethod,
           ImmutableSet.<DependencyRequest>of(),
           Optional.<String>absent(),
           false,
           Optional.<DeclaredType>absent(),
-          Optional.<TypeElement>absent(),
           Optional.<DependencyRequest>absent(),
           Kind.COMPONENT_PRODUCTION,
           Produces.Type.UNIQUE,
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
index 2582b31fd..2106c63e3 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
@@ -56,13 +56,13 @@
 abstract class ProvisionBinding extends ContributionBinding {
   
   @Override
-  Binding.Type bindingType() {
-    return Binding.Type.PROVISION;
+  public BindingType bindingType() {
+    return BindingType.PROVISION;
   }
   
   @Override
   abstract Scope scope();
-
+  
   static final class Factory {
     private final Elements elements;
     private final Types types;
@@ -124,13 +124,12 @@ ProvisionBinding forInjectConstructor(ExecutableElement constructorElement,
           MoreElements.asType(constructorElement.getEnclosingElement());
 
       return new AutoValue_ProvisionBinding(
+          SourceElement.forElement(constructorElement),
           key,
-          constructorElement,
           dependencies,
           findBindingPackage(key),
           hasNonDefaultTypeParameters(bindingTypeElement, key.type(), types),
           Optional.<DeclaredType>absent(),
-          Optional.<TypeElement>absent(),
           membersInjectionRequest,
           Kind.INJECTION,
           Provides.Type.UNIQUE,
@@ -172,13 +171,12 @@ ProvisionBinding forProvidesMethod(ExecutableElement providesMethod, TypeMirror
               resolvedMethod.getParameterTypes());
       Scope scope = Scope.scopeOf(providesMethod);
       return new AutoValue_ProvisionBinding(
+          SourceElement.forElement(providesMethod, MoreTypes.asTypeElement(declaredContainer)),
           key,
-          providesMethod,
           dependencies,
           findBindingPackage(key),
           false /* no non-default parameter types */,
           ConfigurationAnnotations.getNullableType(providesMethod),
-          Optional.of(MoreTypes.asTypeElement(declaredContainer)),
           Optional.<DependencyRequest>absent(),
           Kind.PROVISION,
           providesAnnotation.type(),
@@ -197,13 +195,12 @@ ProvisionBinding implicitMapOfProviderBinding(DependencyRequest mapOfValueReques
           dependencyRequestFactory.forImplicitMapBinding(
               mapOfValueRequest, implicitMapOfProviderKey.get());
       return new AutoValue_ProvisionBinding(
+          SourceElement.forElement(implicitMapOfProviderRequest.requestElement()),
           mapOfValueRequest.key(),
-          implicitMapOfProviderRequest.requestElement(),
           ImmutableSet.of(implicitMapOfProviderRequest),
           findBindingPackage(mapOfValueRequest.key()),
           false /* no non-default parameter types */,
           Optional.<DeclaredType>absent(),
-          Optional.<TypeElement>absent(),
           Optional.<DependencyRequest>absent(),
           Kind.SYNTHETIC_MAP,
           Provides.Type.UNIQUE,
@@ -213,13 +210,12 @@ ProvisionBinding implicitMapOfProviderBinding(DependencyRequest mapOfValueReques
     ProvisionBinding forComponent(TypeElement componentDefinitionType) {
       checkNotNull(componentDefinitionType);
       return new AutoValue_ProvisionBinding(
+          SourceElement.forElement(componentDefinitionType),
           keyFactory.forComponent(componentDefinitionType.asType()),
-          componentDefinitionType,
           ImmutableSet.<DependencyRequest>of(),
           Optional.<String>absent(),
           false /* no non-default parameter types */,
           Optional.<DeclaredType>absent(),
-          Optional.<TypeElement>absent(),
           Optional.<DependencyRequest>absent(),
           Kind.COMPONENT,
           Provides.Type.UNIQUE,
@@ -232,13 +228,12 @@ ProvisionBinding forComponentMethod(ExecutableElement componentMethod) {
       checkArgument(componentMethod.getParameters().isEmpty());
       Scope scope = Scope.scopeOf(componentMethod);
       return new AutoValue_ProvisionBinding(
+          SourceElement.forElement(componentMethod),
           keyFactory.forComponentMethod(componentMethod),
-          componentMethod,
           ImmutableSet.<DependencyRequest>of(),
           Optional.<String>absent(),
           false /* no non-default parameter types */,
           ConfigurationAnnotations.getNullableType(componentMethod),
-          Optional.<TypeElement>absent(),
           Optional.<DependencyRequest>absent(),
           Kind.COMPONENT_PROVISION,
           Provides.Type.UNIQUE,
@@ -252,13 +247,12 @@ ProvisionBinding forSubcomponentBuilderMethod(
       checkArgument(subcomponentBuilderMethod.getParameters().isEmpty());
       DeclaredType declaredContainer = asDeclared(contributedBy.asType());
       return new AutoValue_ProvisionBinding(
+          SourceElement.forElement(subcomponentBuilderMethod, contributedBy),
           keyFactory.forSubcomponentBuilderMethod(subcomponentBuilderMethod, declaredContainer),
-          subcomponentBuilderMethod,
           ImmutableSet.<DependencyRequest>of(),
           Optional.<String>absent(),
           false /* no non-default parameter types */,
           Optional.<DeclaredType>absent(),
-          Optional.of(contributedBy),
           Optional.<DependencyRequest>absent(),
           Kind.SUBCOMPONENT_BUILDER,
           Provides.Type.UNIQUE,
diff --git a/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java b/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
index f8b6aec87..7b7b6eeaa 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
@@ -24,12 +24,15 @@
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Multimap;
 import dagger.MembersInjector;
-import dagger.internal.codegen.ContributionBinding.ContributionType;
-import java.util.EnumSet;
-import java.util.Set;
+import dagger.internal.codegen.BindingType.HasBindingType;
+import dagger.internal.codegen.ContributionType.HasContributionType;
+import dagger.internal.codegen.Key.HasKey;
 
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkState;
+import static com.google.common.collect.Iterables.getOnlyElement;
+import static dagger.internal.codegen.ContributionType.indexByContributionType;
+import static dagger.internal.codegen.ErrorMessages.MULTIPLE_CONTRIBUTION_TYPES_FORMAT;
 
 /**
  * The collection of bindings that have been resolved for a binding key.
@@ -37,7 +40,7 @@
  * @author Gregory Kick
  */
 @AutoValue
-abstract class ResolvedBindings {
+abstract class ResolvedBindings implements HasBindingType, HasContributionType, HasKey {
   /**
    * The binding key for which the {@link #bindings()} have been resolved.
    */
@@ -66,6 +69,11 @@
    */
   abstract ImmutableMap<ComponentDescriptor, MembersInjectionBinding> allMembersInjectionBindings();
 
+  @Override
+  public Key key() {
+    return bindingKey().key();
+  }
+  
   /**
    * All bindings for {@link #bindingKey()}, regardless of in which component they were resolved.
    */
@@ -213,22 +221,31 @@ boolean isUniqueContribution() {
     return !contributionBindings().isEmpty() && !contributionType().isMultibinding();
   }
 
+  /**
+   * The binding type for all {@link #bindings()}.
+   *
+   * @throws IllegalStateException if {@link #bindings()} is empty or the binding types conflict
+   */
+  @Override
+  public BindingType bindingType() {
+    ImmutableSet<BindingType> bindingTypes =
+        FluentIterable.from(bindings()).transform(BindingType.BINDING_TYPE).toSet();
+    checkState(!bindingTypes.isEmpty(), "no bindings for %s", bindingKey());
+    checkState(bindingTypes.size() == 1, "conflicting binding types: %s", this);
+    return getOnlyElement(bindingTypes);
+  }
+
   /**
    * The contribution type for these bindings.
    *
    * @throws IllegalStateException if the bindings are not all of one contribution type
    */
-  ContributionType contributionType() {
-    checkState(!contributionBindings().isEmpty(), "no bindings for %s", bindingKey());
-    Set<ContributionType> types = EnumSet.noneOf(ContributionType.class);
-    for (ContributionBinding binding : contributionBindings()) {
-      types.add(binding.contributionType());
-    }
-    if (types.size() > 1) {
-      throw new IllegalStateException(
-          String.format(ErrorMessages.MULTIPLE_CONTRIBUTION_TYPES_FORMAT, types));
-    }
-    return Iterables.getOnlyElement(types);
+  @Override
+  public ContributionType contributionType() {
+    ImmutableSet<ContributionType> types = indexByContributionType(contributionBindings()).keySet();
+    checkState(!types.isEmpty(), "no bindings for %s", bindingKey());
+    checkState(types.size() == 1, MULTIPLE_CONTRIBUTION_TYPES_FORMAT, types);
+    return getOnlyElement(types);
   }
 
   /**
@@ -259,9 +276,9 @@ ContributionType contributionType() {
   Class<?> frameworkClass() {
     switch (bindingKey().kind()) {
       case CONTRIBUTION:
-        return Iterables.any(contributionBindings(), Binding.isOfType(Binding.Type.PRODUCTION))
-            ? Binding.Type.PRODUCTION.frameworkClass()
-            : Binding.Type.PROVISION.frameworkClass();
+        return Iterables.any(contributionBindings(), BindingType.isOfType(BindingType.PRODUCTION))
+            ? BindingType.PRODUCTION.frameworkClass()
+            : BindingType.PROVISION.frameworkClass();
       case MEMBERS_INJECTION:
         return MembersInjector.class;
       default:
diff --git a/compiler/src/main/java/dagger/internal/codegen/SetType.java b/compiler/src/main/java/dagger/internal/codegen/SetType.java
index 4103c71d0..23e95c7f7 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SetType.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SetType.java
@@ -43,6 +43,13 @@ DeclaredType declaredSetType() {
     return wrappedDeclaredSetType().get();
   }
 
+  /**
+   * {@code true} if the set type is the raw {@link Set} type.
+   */
+  boolean isRawType() {
+    return declaredSetType().getTypeArguments().isEmpty();
+  }
+
   /**
    * The element type.
    */
@@ -76,7 +83,7 @@ TypeMirror unwrappedElementType(Class<?> wrappingClass) {
   /**
    * {@code true} if {@code type} is a {@link Set} type.
    */
-  static boolean isSetType(TypeMirror type) {
+  static boolean isSet(TypeMirror type) {
     return MoreTypes.isType(type) && MoreTypes.isTypeOf(Set.class, type);
   }
 
@@ -86,7 +93,7 @@ static boolean isSetType(TypeMirror type) {
    * @throws IllegalArgumentException if {@code type} is not a {@link Set} type
    */
   static SetType from(TypeMirror type) {
-    checkArgument(isSetType(type), "%s must be a Set", type);
+    checkArgument(isSet(type), "%s must be a Set", type);
     return new AutoValue_SetType(MoreTypes.equivalence().wrap(MoreTypes.asDeclared(type)));
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceElement.java b/compiler/src/main/java/dagger/internal/codegen/SourceElement.java
new file mode 100644
index 000000000..29949629b
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceElement.java
@@ -0,0 +1,71 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.value.AutoValue;
+import com.google.common.base.Optional;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ElementVisitor;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.util.SimpleElementVisitor6;
+
+/**
+ * An {@link Element}, optionally contributed by a subtype of the type that encloses it.
+ */
+@AutoValue
+abstract class SourceElement {
+
+  /** An object that has a {@link SourceElement}. */
+  interface HasSourceElement {
+    /** The source element associated with this object. */
+    SourceElement sourceElement();
+  }
+
+  /** The {@link Element} instance.. */
+  abstract Element element();
+
+  /**
+   * The concrete class that contributed the {@link #element()}, if different from
+   * {@link #enclosingTypeElement()}.
+   */
+  abstract Optional<TypeElement> contributedBy();
+
+  /** The type enclosing the {@link #element()}. */
+  TypeElement enclosingTypeElement() {
+    return BINDING_TYPE_ELEMENT.visit(element());
+  }
+
+  private static final ElementVisitor<TypeElement, Void> BINDING_TYPE_ELEMENT =
+      new SimpleElementVisitor6<TypeElement, Void>() {
+        @Override
+        protected TypeElement defaultAction(Element e, Void p) {
+          return visit(e.getEnclosingElement());
+        }
+
+        @Override
+        public TypeElement visitType(TypeElement e, Void p) {
+          return e;
+        }
+      };
+
+  static SourceElement forElement(Element element) {
+    return new AutoValue_SourceElement(element, Optional.<TypeElement>absent());
+  }
+
+  static SourceElement forElement(Element element, TypeElement contributedBy) {
+    return new AutoValue_SourceElement(element, Optional.of(contributedBy));
+  }
+}
