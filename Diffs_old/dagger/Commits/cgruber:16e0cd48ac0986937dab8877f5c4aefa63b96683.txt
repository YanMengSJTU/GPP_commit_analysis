diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
new file mode 100644
index 000000000..8d9dd76ae
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
@@ -0,0 +1,359 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.auto.common.MoreTypes;
+import com.google.auto.value.AutoValue;
+import com.google.common.base.Function;
+import com.google.common.base.Optional;
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableListMultimap;
+import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.ImmutableSetMultimap;
+import com.google.common.collect.Maps;
+import com.google.common.collect.Queues;
+import dagger.Provides;
+import dagger.internal.codegen.BindingGraph.ResolvedBindings.State;
+import dagger.internal.codegen.ProvisionBinding.BindingType;
+import java.util.Deque;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.ElementFilter;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
+
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
+import static com.google.common.collect.Iterables.getOnlyElement;
+import static dagger.internal.codegen.ConfigurationAnnotations.getComponentModules;
+import static dagger.internal.codegen.ConfigurationAnnotations.getTransitiveModules;
+import static javax.lang.model.type.TypeKind.VOID;
+import static javax.lang.model.util.ElementFilter.methodsIn;
+
+/**
+ * The canonical representation of a full-resolved graph.
+ *
+ * @author Gregory Kick
+ */
+@AutoValue
+abstract class BindingGraph {
+  abstract ComponentDescriptor componentDescriptor();
+  abstract ImmutableSet<DependencyRequest> entryPoints();
+  abstract ImmutableMap<TypeElement, ImmutableSet<TypeElement>> transitiveModules();
+  abstract ImmutableMap<Key, ResolvedBindings> resolvedBindings();
+
+  @AutoValue
+  static abstract class ResolvedBindings {
+    enum State {
+      COMPLETE,
+      INCOMPLETE,
+      MULTIPLE_BINDING_TYPES,
+      DUPLICATE_BINDINGS,
+      CYCLE,
+      MALFORMED,
+      MISSING,
+    }
+
+    abstract State state();
+    abstract ImmutableSet<? extends Binding> bindings();
+  }
+
+  static final class Factory {
+    private final Elements elements;
+    private final Types types;
+    private final InjectBindingRegistry injectBindingRegistry;
+    private final Key.Factory keyFactory;
+    private final DependencyRequest.Factory dependencyRequestFactory;
+    private final ProvisionBinding.Factory provisionBindingFactory;
+
+    Factory(Elements elements,
+        Types types,
+        InjectBindingRegistry injectBindingRegistry,
+        dagger.internal.codegen.Key.Factory keyFactory,
+        dagger.internal.codegen.DependencyRequest.Factory dependencyRequestFactory,
+        dagger.internal.codegen.ProvisionBinding.Factory provisionBindingFactory) {
+      this.elements = elements;
+      this.types = types;
+      this.injectBindingRegistry = injectBindingRegistry;
+      this.keyFactory = keyFactory;
+      this.dependencyRequestFactory = dependencyRequestFactory;
+      this.provisionBindingFactory = provisionBindingFactory;
+    }
+
+    BindingGraph create(ComponentDescriptor componentDescriptor) {
+      ImmutableSet.Builder<ProvisionBinding> explicitBindingsBuilder = ImmutableSet.builder();
+
+      // binding for the component itself
+      ProvisionBinding componentBinding =
+          provisionBindingFactory.forComponent(componentDescriptor.componentDefinitionType());
+      explicitBindingsBuilder.add(componentBinding);
+
+      // Collect Component dependencies.
+      ImmutableSet<TypeElement> componentDependencyTypes = MoreTypes.asTypeElements(types,
+          ConfigurationAnnotations.getComponentDependencies(
+              elements, componentDescriptor.componentAnnotation()));
+      for (TypeElement componentDependency : componentDependencyTypes) {
+        explicitBindingsBuilder.add(provisionBindingFactory.forComponent(componentDependency));
+        List<ExecutableElement> dependencyMethods =
+            ElementFilter.methodsIn(elements.getAllMembers(componentDependency));
+        for (ExecutableElement method : dependencyMethods) {
+          if (isComponentProvisionMethod(method)) {
+            // MembersInjection methods aren't "provided" explicitly, so ignore them.
+            explicitBindingsBuilder.add(provisionBindingFactory.forComponentMethod(method));
+          }
+        }
+      }
+
+      // Collect transitive modules provisions.
+      ImmutableSet<TypeElement> moduleTypes =
+          MoreTypes.asTypeElements(types,
+              getComponentModules(elements, componentDescriptor.componentAnnotation()));
+
+      ImmutableMap<TypeElement, ImmutableSet<TypeElement>> transitiveModules =
+          getTransitiveModules(elements, types, moduleTypes);
+      for (TypeElement module : transitiveModules.keySet()) {
+        // traverse the modules, collect the bindings
+        List<ExecutableElement> moduleMethods = methodsIn(elements.getAllMembers(module));
+        for (ExecutableElement moduleMethod : moduleMethods) {
+          if (isAnnotationPresent(moduleMethod, Provides.class)) {
+            try {
+              explicitBindingsBuilder.add(provisionBindingFactory.forProvidesMethod(moduleMethod));
+            } catch (IllegalArgumentException e) {
+              // just ignore it
+            }
+          }
+        }
+      }
+
+      RequestResolver requestResolver =
+          new RequestResolver(explicitBindingsByKey(explicitBindingsBuilder.build()));
+      ImmutableSet<DependencyRequest> componentMethodRequests =
+          componentMethodRequests(componentDescriptor.componentDefinitionType());
+      for (DependencyRequest componentMethodRequest :
+          componentMethodRequests) {
+        requestResolver.resolve(componentMethodRequest);
+      }
+
+      return new AutoValue_BindingGraph(
+          componentDescriptor,
+          componentMethodRequests,
+          transitiveModules,
+          ImmutableMap.copyOf(requestResolver.resolvedBindings));
+    }
+
+    private ImmutableSetMultimap<Key, ProvisionBinding> explicitBindingsByKey(
+        Iterable<ProvisionBinding> bindings) {
+      // Multimaps.index() doesn't do ImmutableSetMultimaps.
+      ImmutableSetMultimap.Builder<Key, ProvisionBinding> builder = ImmutableSetMultimap.builder();
+      for (ProvisionBinding binding : bindings) {
+        builder.put(binding.key(), binding);
+      }
+      return builder.build();
+    }
+
+    private ImmutableSet<DependencyRequest> componentMethodRequests(TypeElement componentType) {
+      ImmutableSet.Builder<DependencyRequest> interfaceRequestsBuilder = ImmutableSet.builder();
+      for (ExecutableElement componentMethod : methodsIn(elements.getAllMembers(componentType))) {
+        if (componentMethod.getModifiers().contains(Modifier.ABSTRACT)) { // Elide Object.*;
+          if (isComponentProvisionMethod(componentMethod)) {
+            interfaceRequestsBuilder.add(
+                dependencyRequestFactory.forComponentProvisionMethod(componentMethod));
+          } else if (isComponentMembersInjectionMethod(componentMethod)) {
+            interfaceRequestsBuilder.add(
+                dependencyRequestFactory.forComponentMembersInjectionMethod(componentMethod));
+          }
+        }
+      }
+      return interfaceRequestsBuilder.build();
+    }
+
+    private boolean isComponentMembersInjectionMethod(ExecutableElement method) {
+      List<? extends VariableElement> parameters = method.getParameters();
+      TypeMirror returnType = method.getReturnType();
+      return parameters.size() == 1
+          && (returnType.getKind().equals(VOID)
+              || MoreTypes.equivalence().equivalent(returnType, parameters.get(0).asType()))
+          && !elements.getTypeElement(Object.class.getCanonicalName())
+              .equals(method.getEnclosingElement());
+    }
+
+    private final class RequestResolver {
+      final ImmutableSetMultimap<Key, ProvisionBinding> explicitBindings;
+      final Map<Key, ResolvedBindings> resolvedBindings;
+      final Deque<Key> cycleStack = Queues.newArrayDeque();
+
+      RequestResolver(ImmutableSetMultimap<Key, ProvisionBinding> explicitBindings) {
+        assert explicitBindings != null;
+        this.explicitBindings = explicitBindings;
+        this.resolvedBindings = Maps.newLinkedHashMap();
+      }
+
+      State resolve(DependencyRequest request) {
+        Key requestKey = request.key();
+
+        ResolvedBindings previouslyResolvedBinding = resolvedBindings.get(requestKey);
+        if (previouslyResolvedBinding != null) {
+          return previouslyResolvedBinding.state();
+        }
+
+        if (cycleStack.contains(requestKey)) {
+          // return malformed, but don't add a resolved binding.
+          // the original request will add it with all of the other resolved deps
+          return State.CYCLE;
+        }
+
+        cycleStack.push(requestKey);
+        try {
+          switch (request.kind()) {
+            case INSTANCE:
+            case LAZY:
+            case PROVIDER:
+              // First, check for explicit keys (those from modules and components)
+              ImmutableSet<ProvisionBinding> explicitBindingsForKey =
+                  explicitBindings.get(requestKey);
+              if (explicitBindingsForKey.isEmpty()) {
+                // If the key is Map<K, V>, get its implicit binding key which is
+                // Map<K, Provider<V>>
+                Optional<Key> mapProviderKey = keyFactory.implicitMapProviderKeyFrom(request.key());
+                if (mapProviderKey.isPresent()) {
+                  DependencyRequest implicitRequest =
+                      dependencyRequestFactory.forImplicitMapBinding(request, mapProviderKey.get());
+                  ProvisionBinding implicitBinding =
+                      provisionBindingFactory.forImplicitMapBinding(request, implicitRequest);
+                  State implicitState = resolve(implicitRequest);
+                  resolvedBindings.put(requestKey,
+                      new AutoValue_BindingGraph_ResolvedBindings(
+                          implicitState.equals(State.COMPLETE) ? State.COMPLETE : State.INCOMPLETE,
+                          ImmutableSet.of(implicitBinding)));
+                  return State.COMPLETE;
+                } else {
+                  // no explicit binding, look it up.
+                  Optional<ProvisionBinding> provisionBinding =
+                      injectBindingRegistry.getOrFindProvisionBinding(requestKey);
+                  if (provisionBinding.isPresent()) {
+                    // found a binding, resolve its deps and then mark it resolved
+                    State bindingState =
+                        resolveDependencies(provisionBinding.get().implicitDependencies());
+                    resolvedBindings.put(requestKey,
+                        new AutoValue_BindingGraph_ResolvedBindings(
+                            bindingState,
+                            ImmutableSet.copyOf(provisionBinding.asSet())));
+                    return bindingState;
+                  } else {
+                    // no explicit binding, no inject binding.  it's missing
+                    resolvedBindings.put(requestKey,
+                        new AutoValue_BindingGraph_ResolvedBindings(
+                            State.MISSING, ImmutableSet.<Binding>of()));
+                    return State.MISSING;
+                  }
+                }
+              } else {
+                // If this is an explicit Map<K, V> request then add in any map binding provision
+                // methods which are implied by and must collide with explicit Map<K, V> bindings.
+                Optional<Key> underlyingMapKey =
+                    keyFactory.implicitMapProviderKeyFrom(request.key());
+                if (underlyingMapKey.isPresent()) {
+                  explicitBindingsForKey = ImmutableSet.<ProvisionBinding>builder()
+                      .addAll(explicitBindingsForKey)
+                      .addAll(explicitBindings.get(underlyingMapKey.get()))
+                      .build();
+                }
+                ImmutableSet<DependencyRequest> allDeps =
+                    FluentIterable.from(explicitBindingsForKey)
+                        .transformAndConcat(
+                            new Function<ProvisionBinding, Set<DependencyRequest>>() {
+                              @Override
+                              public Set<DependencyRequest> apply(ProvisionBinding input) {
+                                return input.implicitDependencies();
+                              }
+                            })
+                        .toSet();
+                State bindingState = resolveDependencies(allDeps);
+                if (explicitBindingsForKey.size() > 1) {
+                  // Multiple Explicit bindings. Validate that they are multi-bindings.
+                  ImmutableListMultimap<BindingType, ProvisionBinding> bindingsByType =
+                      ProvisionBinding.bindingTypesFor(explicitBindingsForKey);
+                  if (bindingsByType.keySet().size() > 1) {
+                    resolvedBindings.put(requestKey,
+                        new AutoValue_BindingGraph_ResolvedBindings(
+                            State.MULTIPLE_BINDING_TYPES,
+                            explicitBindingsForKey));
+                    return State.MULTIPLE_BINDING_TYPES;
+                  } else if (getOnlyElement(bindingsByType.keySet()).equals(BindingType.UNIQUE)) {
+                    resolvedBindings.put(requestKey,
+                        new AutoValue_BindingGraph_ResolvedBindings(
+                            State.DUPLICATE_BINDINGS,
+                            explicitBindingsForKey));
+                    return State.DUPLICATE_BINDINGS;
+                  }
+                }
+                resolvedBindings.put(requestKey,
+                    new AutoValue_BindingGraph_ResolvedBindings(
+                        bindingState, explicitBindingsForKey));
+                return bindingState;
+              }
+            case MEMBERS_INJECTOR:
+              // no explicit deps for members injection, so just look it up
+              Optional<MembersInjectionBinding> membersInjectionBinding = Optional.fromNullable(
+                  injectBindingRegistry.getOrFindMembersInjectionBinding(requestKey));
+              if (membersInjectionBinding.isPresent()) {
+                // found a binding, resolve its deps and then mark it resolved
+                State bindingState =
+                    resolveDependencies(membersInjectionBinding.get().implicitDependencies());
+                resolvedBindings.put(requestKey,
+                    new AutoValue_BindingGraph_ResolvedBindings(
+                        bindingState,
+                        ImmutableSet.copyOf(membersInjectionBinding.asSet())));
+                return bindingState;
+              } else {
+                return State.MISSING;
+              }
+            default:
+              throw new AssertionError();
+          }
+        } finally {
+          cycleStack.pop();
+        }
+      }
+
+      private State resolveDependencies(Iterable<DependencyRequest> dependencies) {
+        State bindingState = State.COMPLETE;
+        for (DependencyRequest dependency : dependencies) {
+          State dependencyState = resolve(dependency);
+          if (dependencyState.equals(State.CYCLE)) {
+            bindingState = State.CYCLE;
+          } else if (!bindingState.equals(State.CYCLE) && !dependencyState.equals(State.COMPLETE)) {
+            bindingState = State.INCOMPLETE;
+          }
+        }
+        return bindingState;
+      }
+    }
+
+    private boolean isComponentProvisionMethod(ExecutableElement method) {
+      return method.getParameters().isEmpty()
+          && !method.getReturnType().getKind().equals(VOID)
+          && !elements.getTypeElement(Object.class.getCanonicalName())
+              .equals(method.getEnclosingElement());
+    }
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
new file mode 100644
index 000000000..1d8ede75a
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -0,0 +1,237 @@
+package dagger.internal.codegen;
+
+import com.google.auto.common.MoreElements;
+import com.google.common.base.Function;
+import com.google.common.base.Joiner;
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableListMultimap;
+import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Lists;
+import com.google.common.collect.Ordering;
+import dagger.internal.codegen.BindingGraph.ResolvedBindings;
+import dagger.internal.codegen.BindingGraph.ResolvedBindings.State;
+import dagger.internal.codegen.ProvisionBinding.BindingType;
+import java.util.Deque;
+import java.util.Formatter;
+import java.util.LinkedList;
+import java.util.Set;
+import javax.lang.model.element.ElementKind;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.element.Name;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.SimpleTypeVisitor6;
+import javax.lang.model.util.Types;
+
+import static dagger.internal.codegen.ErrorMessages.INDENT;
+import static dagger.internal.codegen.ErrorMessages.REQUIRES_AT_INJECT_CONSTRUCTOR_OR_PROVIDER_FORMAT;
+import static dagger.internal.codegen.ErrorMessages.REQUIRES_PROVIDER_FORMAT;
+
+public class BindingGraphValidator implements Validator<BindingGraph> {
+  private final Types types;
+  private final InjectBindingRegistry injectBindingRegistry;
+
+  BindingGraphValidator(Types types, InjectBindingRegistry injectBindingRegistry) {
+    this.types = types;
+    this.injectBindingRegistry = injectBindingRegistry;
+  }
+
+  @Override
+  public ValidationReport<BindingGraph> validate(final BindingGraph subject) {
+    final ValidationReport.Builder<BindingGraph> reportBuilder =
+        ValidationReport.Builder.about(subject);
+    ImmutableMap<Key, ResolvedBindings> resolvedBindings = subject.resolvedBindings();
+
+    for (DependencyRequest entryPoint : subject.entryPoints()) {
+      ResolvedBindings resolvedBinding = resolvedBindings.get(entryPoint.key());
+      if (!resolvedBinding.state().equals(State.COMPLETE)) {
+        LinkedList<DependencyRequest> requestPath = Lists.newLinkedList();
+        requestPath.push(entryPoint);
+        traversalHelper(subject, requestPath, new Traverser() {
+          @Override
+          boolean visitResolvedBinding(
+              Deque<DependencyRequest> requestPath, ResolvedBindings binding) {
+            switch (binding.state()) {
+              case COMPLETE:
+              case INCOMPLETE:
+                return true;
+              case MISSING:
+                reportMissingBinding(requestPath, reportBuilder);
+                return false;
+              case DUPLICATE_BINDINGS:
+                reportDuplicateBindings(requestPath, binding, reportBuilder);
+                return false;
+              case MULTIPLE_BINDING_TYPES:
+                reportMultipleBindingTypes(requestPath, binding, reportBuilder);
+                return false;
+              case CYCLE:
+                reportCycle(requestPath, subject, reportBuilder);
+                return false;
+              case MALFORMED:
+                return false;
+              default:
+                throw new AssertionError();
+            }
+          }
+        });
+      }
+    }
+
+    return reportBuilder.build();
+  }
+
+  private void reportMissingBinding(
+      Deque<DependencyRequest> requestPath, ValidationReport.Builder<BindingGraph> reportBuilder) {
+    Key key = requestPath.peek().key();
+    TypeMirror type = key.type();
+    Name typeName = MoreElements.asType(types.asElement(type)).getQualifiedName();
+    boolean requiresProvidesMethod = type.accept(new SimpleTypeVisitor6<Boolean, Void>() {
+      @Override protected Boolean defaultAction(TypeMirror e, Void p) {
+        return true;
+      }
+
+      @Override public Boolean visitDeclared(DeclaredType type, Void ignored) {
+        // Note - this logic is also in InjectConstructorValidator but is woven into errors.
+        TypeElement typeElement = MoreElements.asType(type.asElement());
+        if (typeElement.getTypeParameters().isEmpty()
+            && typeElement.getKind().equals(ElementKind.CLASS)
+            && !typeElement.getModifiers().contains(Modifier.ABSTRACT)) {
+          return false;
+        }
+        return true;
+      }
+    }, null);
+    StringBuilder errorMessage = new StringBuilder();
+    if(requiresProvidesMethod) {
+      errorMessage.append(String.format(REQUIRES_PROVIDER_FORMAT, typeName));
+    } else {
+      errorMessage.append(
+          String.format(REQUIRES_AT_INJECT_CONSTRUCTOR_OR_PROVIDER_FORMAT, typeName));
+    }
+    if (key.isValidMembersInjectionKey()
+        && !injectBindingRegistry.getOrFindMembersInjectionBinding(key).injectionSites()
+            .isEmpty()) {
+      errorMessage.append(" ").append(ErrorMessages.MEMBERS_INJECTION_DOES_NOT_IMPLY_PROVISION);
+    }
+    ImmutableList<String> printableDependencyPath =
+        FluentIterable.from(requestPath)
+            .transform(DependencyRequestFormatter.instance())
+            .toList()
+            .reverse();
+    for(String dependency :
+        printableDependencyPath.subList(1, printableDependencyPath.size())) {
+      errorMessage.append("\n").append(dependency);
+    }
+    reportBuilder.addItem(errorMessage.toString(), requestPath.getLast().requestElement());
+  }
+
+  @SuppressWarnings("resource") // Appendable is a StringBuilder.
+  private void reportDuplicateBindings(Deque<DependencyRequest> requestPath,
+      ResolvedBindings resolvedBinding, ValidationReport.Builder<BindingGraph> reportBuilder) {
+    StringBuilder builder = new StringBuilder();
+    new Formatter(builder).format(ErrorMessages.DUPLICATE_BINDINGS_FOR_KEY_FORMAT,
+        KeyFormatter.instance().format(requestPath.peek().key()));
+    for (Binding binding : resolvedBinding.bindings()) {
+      builder.append('\n').append(INDENT);
+      builder.append(ProvisionBindingFormatter.instance().format((ProvisionBinding) binding));
+    }
+    reportBuilder.addItem(builder.toString(), requestPath.getLast().requestElement());
+  }
+
+  @SuppressWarnings("resource") // Appendable is a StringBuilder.
+  private void reportMultipleBindingTypes(Deque<DependencyRequest> requestPath,
+      ResolvedBindings resolvedBinding, ValidationReport.Builder<BindingGraph> reportBuilder) {
+    StringBuilder builder = new StringBuilder();
+    new Formatter(builder).format(ErrorMessages.MULTIPLE_BINDING_TYPES_FOR_KEY_FORMAT,
+        KeyFormatter.instance().format(requestPath.peek().key()));
+    @SuppressWarnings("unchecked")
+    ImmutableListMultimap<BindingType, ProvisionBinding> bindingsByType =
+        ProvisionBinding.bindingTypesFor((Iterable<ProvisionBinding>) resolvedBinding.bindings());
+    for (BindingType type :
+        Ordering.natural().immutableSortedCopy(bindingsByType.keySet())) {
+      builder.append(INDENT);
+      builder.append(formatBindingType(type));
+      builder.append(" bindings:\n");
+      for (ProvisionBinding binding : bindingsByType.get(type)) {
+        builder.append(INDENT).append(INDENT);
+        builder.append(ProvisionBindingFormatter.instance().format(binding));
+        builder.append('\n');
+      }
+    }
+    reportBuilder.addItem(builder.toString(), requestPath.getLast().requestElement());
+  }
+
+  private String formatBindingType(BindingType type) {
+    switch(type) {
+      case MAP:
+        return "Map";
+      case SET:
+        return "Set";
+      case UNIQUE:
+        return "Unique";
+      default:
+        throw new IllegalStateException("Unknown binding type: " + type);
+    }
+  }
+
+  private void reportCycle(Deque<DependencyRequest> requestPath,
+      BindingGraph graph, final ValidationReport.Builder<BindingGraph> reportBuilder) {
+    final DependencyRequest startingRequest = requestPath.peek();
+    final Key cycleKey = startingRequest.key();
+    traversalHelper(graph, requestPath, new Traverser() {
+      @Override
+      boolean visitResolvedBinding(Deque<DependencyRequest> requestPath, ResolvedBindings binding) {
+        DependencyRequest request = requestPath.peek();
+        boolean endOfCycle = !startingRequest.equals(request) && cycleKey.equals(request.key());
+        if (endOfCycle) {
+          ImmutableList<String> printableDependencyPath = FluentIterable.from(requestPath)
+              .transform(DependencyRequestFormatter.instance()).toList().reverse();
+          DependencyRequest rootRequest = requestPath.getLast();
+          TypeElement componentType =
+              MoreElements.asType(rootRequest.requestElement().getEnclosingElement());
+          // TODO(user): Restructure to provide a hint for the start and end of the cycle.
+          reportBuilder.addItem(
+              String.format(ErrorMessages.CONTAINS_DEPENDENCY_CYCLE_FORMAT,
+                  componentType.getQualifiedName(),
+                  rootRequest.requestElement().getSimpleName(),
+                  Joiner.on("\n")
+                      .join(printableDependencyPath.subList(1, printableDependencyPath.size()))),
+                  rootRequest.requestElement());
+        }
+        return !endOfCycle;
+      }
+    });
+
+  }
+
+  private void traversalHelper(BindingGraph graph, Deque<DependencyRequest> requestPath,
+      Traverser traverser) {
+    ResolvedBindings resolvedBinding = graph.resolvedBindings().get(requestPath.peek().key());
+    ImmutableSet<DependencyRequest> allDeps =
+        FluentIterable.from(resolvedBinding.bindings())
+            .transformAndConcat(
+                new Function<Binding, Set<DependencyRequest>>() {
+                  @Override
+                  public Set<DependencyRequest> apply(Binding input) {
+                    return input.implicitDependencies();
+                  }
+                })
+            .toSet();
+    boolean descend = traverser.visitResolvedBinding(requestPath, resolvedBinding);
+    if (descend) {
+      for (DependencyRequest dependency : allDeps) {
+        requestPath.push(dependency);
+        traversalHelper(graph, requestPath, traverser);
+        requestPath.pop();
+      }
+    }
+  }
+
+  static abstract class Traverser {
+    abstract boolean visitResolvedBinding(
+        Deque<DependencyRequest> requestPath, ResolvedBindings binding);
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
index 303668368..2ea440c55 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
@@ -15,39 +15,21 @@
  */
 package dagger.internal.codegen;
 
-import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
-import com.google.common.base.Optional;
-import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ImmutableSetMultimap;
-import com.google.common.collect.Iterables;
-import com.google.common.collect.MultimapBuilder;
-import com.google.common.collect.Queues;
-import com.google.common.collect.SetMultimap;
-import com.google.common.collect.Sets;
 import dagger.Component;
-import dagger.MembersInjector;
-import dagger.Provides;
-import java.util.Deque;
 import java.util.List;
-import java.util.Map.Entry;
-import java.util.Set;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
-import javax.lang.model.element.VariableElement;
 import javax.lang.model.util.ElementFilter;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 
 import static com.google.auto.common.MoreElements.getAnnotationMirror;
-import static com.google.auto.common.MoreElements.isAnnotationPresent;
-import static com.google.common.base.Preconditions.checkState;
-import static dagger.internal.codegen.ConfigurationAnnotations.getTransitiveModules;
-import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.type.TypeKind.VOID;
 
 /**
@@ -60,6 +42,8 @@
 abstract class ComponentDescriptor {
   ComponentDescriptor() {}
 
+  abstract AnnotationMirror componentAnnotation();
+
   /**
    * The type (interface or abstract class) that defines the component. This is the element to which
    * the {@link Component} annotation was applied.
@@ -78,72 +62,22 @@
    */
   abstract ImmutableMap<ExecutableElement, TypeElement> dependencyMethodIndex();
 
-  /**
-   * The list of {@link DependencyRequest} instances whose sources are methods on the component
-   * definition type.  These are the user-requested dependencies.
-   */
-  abstract ImmutableList<DependencyRequest> interfaceRequests();
-
-  /**
-   * The total set of modules (those declared in {@link Component#modules} and their transitive
-   * dependencies) required to construct the object graph declared by the component.
-   */
-  abstract ImmutableSet<TypeElement> moduleDependencies();
-
-  /**
-   * Returns the mapping from {@link Key} to {@link ProvisionBinding} that
-   * (with {@link #resolvedMembersInjectionBindings}) represents the full adjacency matrix for the
-   * object graph.
-   */
-  abstract ImmutableSetMultimap<Key, ProvisionBinding> resolvedProvisionBindings();
-
-  /**
-   * Returns the mapping from {@link Key} to {@link MembersInjectionBinding} that
-   * (with {@link #resolvedProvisionBindings}) represents the full adjacency matrix for the object
-   * graph.
-   */
-  abstract ImmutableMap<Key, MembersInjectionBinding> resolvedMembersInjectionBindings();
-
-  /** The package in which each {@link Key} initialization must happen.  */
-  abstract ImmutableSetMultimap<String, Key> initializationByPackage();
-
-  /**
-   * The ordering of {@link Key keys} that will allow all of the {@link Factory} and
-   * {@link MembersInjector} implementations to initialize properly.
-   */
-  abstract ImmutableList<Key> initializationOrdering();
-
   static final class Factory {
     private final Elements elements;
     private final Types types;
-    private final InjectBindingRegistry injectBindingRegistry;
-    private final Key.Factory keyFactory;
     private final ProvisionBinding.Factory provisionBindingFactory;
-    private final DependencyRequest.Factory dependencyRequestFactory;
 
-    Factory(Elements elements, Types types,
-        InjectBindingRegistry injectBindingRegistry,
-        DependencyRequest.Factory dependencyRequestFactory,
-        Key.Factory keyFactory,
-        ProvisionBinding.Factory provisionBindingFactory) {
+    Factory(Elements elements, Types types, ProvisionBinding.Factory provisionBindingFactory) {
       this.elements = elements;
       this.types = types;
-      this.injectBindingRegistry = injectBindingRegistry;
-      this.dependencyRequestFactory = dependencyRequestFactory;
-      this.keyFactory = keyFactory;
       this.provisionBindingFactory = provisionBindingFactory;
     }
 
-    ComponentDescriptor create(TypeElement componentDefinitionType)
-        throws SourceFileGenerationException {
+    ComponentDescriptor create(TypeElement componentDefinitionType) {
       AnnotationMirror componentMirror =
           getAnnotationMirror(componentDefinitionType, Component.class).get();
-      ImmutableSet<TypeElement> moduleTypes = MoreTypes.asTypeElements(types,
-          ConfigurationAnnotations.getComponentModules(elements, componentMirror));
       ImmutableSet<TypeElement> componentDependencyTypes = MoreTypes.asTypeElements(types,
           ConfigurationAnnotations.getComponentDependencies(elements, componentMirror));
-      ImmutableSet<TypeElement> transitiveModules =
-          getTransitiveModules(elements, types, moduleTypes);
 
       ProvisionBinding componentBinding =
           provisionBindingFactory.forComponent(componentDefinitionType);
@@ -172,170 +106,11 @@ ComponentDescriptor create(TypeElement componentDefinitionType)
         }
       }
 
-      for (TypeElement module : transitiveModules) {
-        // traverse the modules, collect the bindings
-        List<ExecutableElement> moduleMethods =
-            ElementFilter.methodsIn(elements.getAllMembers(module));
-        for (ExecutableElement moduleMethod : moduleMethods) {
-          if (isAnnotationPresent(moduleMethod, Provides.class)) {
-            ProvisionBinding providesMethodBinding =
-                provisionBindingFactory.forProvidesMethod(moduleMethod);
-            explicitBindingIndexBuilder
-                .put(providesMethodBinding.key(), providesMethodBinding);
-          }
-        }
-      }
-
-      ImmutableSetMultimap<Key, ProvisionBinding> explicitBindings =
-          explicitBindingIndexBuilder.build();
-
-      Set<MethodSignature> interfaceMethods = Sets.newHashSet();
-
-      ImmutableList.Builder<DependencyRequest> interfaceRequestsBuilder = ImmutableList.builder();
-
-      Deque<DependencyRequest> requestsToResolve = Queues.newArrayDeque();
-
-      for (ExecutableElement componentMethod
-          : ElementFilter.methodsIn(elements.getAllMembers(componentDefinitionType))) {
-        if (componentMethod.getModifiers().contains(ABSTRACT)) {
-          MethodSignature signature = MethodSignature.fromExecutableElement(componentMethod);
-          if (!interfaceMethods.contains(signature)) {
-            List<? extends VariableElement> parameters = componentMethod.getParameters();
-            switch (parameters.size()) {
-              case 0:
-                // provision method
-                DependencyRequest provisionRequest =
-                dependencyRequestFactory.forComponentProvisionMethod(componentMethod);
-                interfaceRequestsBuilder.add(provisionRequest);
-                requestsToResolve.addLast(provisionRequest);
-                break;
-              case 1:
-                // members injection method
-                DependencyRequest membersInjectionRequest =
-                dependencyRequestFactory.forComponentMembersInjectionMethod(componentMethod);
-                interfaceRequestsBuilder.add(membersInjectionRequest);
-                requestsToResolve.addLast(membersInjectionRequest);
-                break;
-              default:
-                throw new IllegalStateException();
-            }
-            interfaceMethods.add(signature);
-          }
-        }
-      }
-
-      ImmutableSetMultimap.Builder<Key, ProvisionBinding> resolvedProvisionBindings =
-          ImmutableSetMultimap.builder();
-      ImmutableMap.Builder<Key, MembersInjectionBinding> resolvedMembersInjectionBindings =
-          ImmutableMap.builder();
-      SetMultimap<Key, Binding> resolvedBindings =
-          MultimapBuilder.linkedHashKeys().linkedHashSetValues().build();
-
-      ImmutableList<DependencyRequest> interfaceRequests = interfaceRequestsBuilder.build();
-
-      for (DependencyRequest interfaceRequest : interfaceRequests) {
-        resolveRequest(interfaceRequest, explicitBindings, resolvedBindings,
-            resolvedProvisionBindings, resolvedMembersInjectionBindings);
-      }
-
-      ImmutableSetMultimap.Builder<String, Key> initializationByPackageBuilder =
-          ImmutableSetMultimap.builder();
-      for (Entry<Key, Binding> resolvedBindingEntry : resolvedBindings.entries()) {
-        initializationByPackageBuilder.put(
-            resolvedBindingEntry.getValue().bindingPackage().or(
-                  MoreElements.getPackage(componentDefinitionType).getQualifiedName().toString()),
-            resolvedBindingEntry.getKey());
-      }
-
       return new AutoValue_ComponentDescriptor(
+          componentMirror,
           componentDefinitionType,
           componentDependencyTypes,
-          dependencyMethodIndex.build(),
-          interfaceRequests,
-          transitiveModules,
-          resolvedProvisionBindings.build(),
-          resolvedMembersInjectionBindings.build(),
-          initializationByPackageBuilder.build(),
-          ImmutableList.copyOf(resolvedBindings.keySet()));
-    }
-
-    private void resolveRequest(DependencyRequest request,
-        ImmutableSetMultimap<Key, ProvisionBinding> explicitBindings,
-        SetMultimap<Key, Binding> resolvedBindings,
-        ImmutableSetMultimap.Builder<Key, ProvisionBinding> resolvedProvisionsBindingBuilder,
-        ImmutableMap.Builder<Key, MembersInjectionBinding> resolvedMembersInjectionBindingsBuilder)
-            throws SourceFileGenerationException {
-      Key requestKey = request.key();
-      if (resolvedBindings.containsKey(requestKey)) {
-        return;
-      }
-      switch (request.kind()) {
-        case INSTANCE:
-        case LAZY:
-        case PROVIDER:
-          // First, check for explicit keys (those from modules and components)
-          ImmutableSet<ProvisionBinding> explicitBindingsForKey =
-              explicitBindings.get(requestKey);
-          if (explicitBindingsForKey.isEmpty()) {
-            // If the key is Map<K, V>, get its implicit binding key which is Map<K, Provider<V>>
-            Optional<Key> key = keyFactory.implicitMapProviderKeyFrom(request.key());
-            if (key.isPresent()) {
-              DependencyRequest implicitRequest =
-                  dependencyRequestFactory.forImplicitMapBinding(request, key.get());
-              ProvisionBinding implicitBinding =
-                  provisionBindingFactory.forImplicitMapBinding(request, implicitRequest);
-              resolveRequest(Iterables.getOnlyElement(implicitBinding.dependencies()),
-                  explicitBindings, resolvedBindings, resolvedProvisionsBindingBuilder,
-                  resolvedMembersInjectionBindingsBuilder);
-              resolvedBindings.put(requestKey, implicitBinding);
-              resolvedProvisionsBindingBuilder.put(request.key(), implicitBinding);
-            } else {
-              // no explicit binding, look it up
-              Optional<ProvisionBinding> provisionBinding =
-                  injectBindingRegistry.getOrFindProvisionBinding(requestKey);
-              checkState(provisionBinding.isPresent(),
-                  "Can not find a provision binding for %s. this should not have passed validation",
-                  requestKey);
-              // found a binding, resolve its deps and then mark it resolved
-              for (DependencyRequest dependency : Iterables.concat(
-                  provisionBinding.get().dependencies(),
-                  provisionBinding.get().memberInjectionRequest().asSet())) {
-                resolveRequest(dependency, explicitBindings, resolvedBindings,
-                    resolvedProvisionsBindingBuilder, resolvedMembersInjectionBindingsBuilder);
-              }
-              resolvedBindings.put(requestKey, provisionBinding.get());
-              resolvedProvisionsBindingBuilder.put(requestKey, provisionBinding.get());
-            }
-          } else {
-            // we found explicit bindings. resolve the deps and them mark them resolved
-            for (Binding explicitBinding : explicitBindingsForKey) {
-              for (DependencyRequest dependency : explicitBinding.dependencies()) {
-                resolveRequest(dependency, explicitBindings, resolvedBindings,
-                    resolvedProvisionsBindingBuilder, resolvedMembersInjectionBindingsBuilder);
-              }
-            }
-            resolvedBindings.putAll(requestKey, explicitBindingsForKey);
-            resolvedProvisionsBindingBuilder.putAll(requestKey, explicitBindingsForKey);
-          }
-          break;
-        case MEMBERS_INJECTOR:
-         // no explicit deps for members injection, so just look it up
-          MembersInjectionBinding membersInjectionBinding =
-              injectBindingRegistry.getOrFindMembersInjectionBinding(requestKey);
-          //resolve its deps and then mark it resolved
-          for (DependencyRequest dependency : Iterables.concat(
-              membersInjectionBinding.dependencies(),
-              membersInjectionBinding.parentInjectorRequest().asSet())) {
-            resolveRequest(dependency, explicitBindings, resolvedBindings,
-                resolvedProvisionsBindingBuilder, resolvedMembersInjectionBindingsBuilder);
-          }
-          resolvedBindings.put(requestKey, membersInjectionBinding);
-          resolvedMembersInjectionBindingsBuilder.put(requestKey, membersInjectionBinding);
-          break;
-        default:
-          throw new AssertionError();
-      }
-
+          dependencyMethodIndex.build());
     }
 
     private static boolean isComponentProvisionMethod(ExecutableElement method) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
index ac68c0afb..73a499e88 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
@@ -16,6 +16,7 @@
 package dagger.internal.codegen;
 
 import com.google.auto.common.MoreTypes;
+import com.google.auto.common.MoreElements;
 import com.google.common.base.CaseFormat;
 import com.google.common.base.Function;
 import com.google.common.base.Functions;
@@ -29,7 +30,6 @@
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
-import com.google.common.collect.Multimaps;
 import com.google.common.collect.Sets;
 import dagger.Component;
 import dagger.Factory;
@@ -40,6 +40,7 @@
 import dagger.internal.MembersInjectors;
 import dagger.internal.ScopedProvider;
 import dagger.internal.SetFactory;
+import dagger.internal.codegen.BindingGraph.ResolvedBindings;
 import dagger.internal.codegen.ProvisionBinding.BindingType;
 import dagger.internal.codegen.writer.ClassName;
 import dagger.internal.codegen.writer.ClassWriter;
@@ -54,6 +55,7 @@
 import dagger.internal.codegen.writer.TypeNames;
 import dagger.internal.codegen.writer.TypeWriter;
 import dagger.internal.codegen.writer.VoidName;
+import java.util.Collection;
 import java.util.EnumSet;
 import java.util.Iterator;
 import java.util.List;
@@ -74,6 +76,7 @@
 import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.ElementKindVisitor6;
 import javax.lang.model.util.SimpleAnnotationValueVisitor6;
 
 import static com.google.auto.common.MoreTypes.asDeclared;
@@ -86,8 +89,6 @@
 import static dagger.internal.codegen.ProvisionBinding.Kind.PROVISION;
 import static dagger.internal.codegen.SourceFiles.factoryNameForProvisionBinding;
 import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
-import static dagger.internal.codegen.SourceFiles.generateMembersInjectorNamesForBindings;
-import static dagger.internal.codegen.SourceFiles.generateProviderNamesForBindings;
 import static dagger.internal.codegen.SourceFiles.membersInjectorNameForMembersInjectionBinding;
 import static javax.lang.model.element.ElementKind.CONSTRUCTOR;
 import static javax.lang.model.element.Modifier.FINAL;
@@ -104,33 +105,33 @@
  * @author Gregory Kick
  * @since 2.0
  */
-final class ComponentGenerator extends SourceFileGenerator<ComponentDescriptor> {
+final class ComponentGenerator extends SourceFileGenerator<BindingGraph> {
   ComponentGenerator(Filer filer) {
     super(filer);
   }
 
   @Override
-  ClassName nameGeneratedType(ComponentDescriptor input) {
+  ClassName nameGeneratedType(BindingGraph input) {
     ClassName componentDefinitionClassName =
-        ClassName.fromTypeElement(input.componentDefinitionType());
+        ClassName.fromTypeElement(input.componentDescriptor().componentDefinitionType());
     return componentDefinitionClassName.topLevelClassName().peerNamed(
         "Dagger_" + componentDefinitionClassName.classFileName());
   }
 
   @Override
-  Iterable<? extends Element> getOriginatingElements(ComponentDescriptor input) {
-    return ImmutableSet.of(input.componentDefinitionType());
+  Iterable<? extends Element> getOriginatingElements(BindingGraph input) {
+    return ImmutableSet.of(input.componentDescriptor().componentDefinitionType());
   }
 
   @Override
-  Optional<? extends Element> getElementForErrorReporting(ComponentDescriptor input) {
-    return Optional.of(input.componentDefinitionType());
+  Optional<? extends Element> getElementForErrorReporting(BindingGraph input) {
+    return Optional.of(input.componentDescriptor().componentDefinitionType());
   }
 
   @Override
-  ImmutableSet<JavaWriter> write(ClassName componentName, ComponentDescriptor input) {
+  ImmutableSet<JavaWriter> write(ClassName componentName, BindingGraph input) {
     ClassName componentDefinitionTypeName =
-        ClassName.fromTypeElement(input.componentDefinitionType());
+        ClassName.fromTypeElement(input.componentDescriptor().componentDefinitionType());
 
     JavaWriter writer = JavaWriter.inPackage(componentName.packageName());
     ClassWriter componentWriter = writer.addClass(componentName.simpleName());
@@ -147,20 +148,14 @@ ClassName nameGeneratedType(ComponentDescriptor input) {
     builderFactoryMethod.addModifiers(PUBLIC, STATIC);
     builderFactoryMethod.body().addSnippet("return new %s();", builderWriter.name());
 
-    ImmutableSetMultimap<Key, ProvisionBinding> resolvedProvisionBindings =
-        input.resolvedProvisionBindings();
-    ImmutableMap<Key, MembersInjectionBinding> resolvedMembersInjectionBindings =
-        input.resolvedMembersInjectionBindings();
-
-    ImmutableMap<Key, String> providerNames =
-        generateProviderNamesForBindings(resolvedProvisionBindings);
-    ImmutableMap<Key, String> membersInjectorNames =
-        generateMembersInjectorNamesForBindings(resolvedMembersInjectionBindings);
+    ImmutableMap<Key, String> framekworkTypeNames = generateFrameworkTypeNames(input);
 
     // the full set of types that calling code uses to construct a component instance
     ImmutableMap<TypeElement, String> componentContributionNames =
         ImmutableMap.copyOf(Maps.asMap(
-            Sets.union(input.moduleDependencies(), input.dependencies()),
+            Sets.union(
+                input.transitiveModules().keySet(),
+                input.componentDescriptor().dependencies()),
             Functions.compose(
                 CaseFormat.UPPER_CAMEL.converterTo(LOWER_CAMEL),
                 new Function<TypeElement, String>() {
@@ -223,8 +218,11 @@ ClassName nameGeneratedType(ComponentDescriptor input) {
     ImmutableMap.Builder<Key, Snippet> memberSelectSnippetsBuilder =
         ImmutableMap.builder();
 
-    for (Entry<String, Set<Key>> packageEntry :
-        Multimaps.asMap(input.initializationByPackage()).entrySet()) {
+    ImmutableSetMultimap.Builder<String, Key> initializationByPackageBuilder =
+        indexInitializations(input, componentDefinitionTypeName);
+
+    for (Entry<String, Collection<Key>> packageEntry :
+        initializationByPackageBuilder.build().asMap().entrySet()) {
       String packageName = packageEntry.getKey();
 
       final Optional<String> proxySelector;
@@ -264,17 +262,7 @@ ClassName nameGeneratedType(ComponentDescriptor input) {
             ClassName.fromClass(key.kind().frameworkClass()),
             TypeNames.forTypeMirror(key.type()));
 
-        final String fieldName;
-        switch (key.kind()) {
-          case PROVIDER:
-            fieldName = providerNames.get(key);
-            break;
-          case MEMBERS_INJECTOR:
-            fieldName = membersInjectorNames.get(key);
-            break;
-          default:
-            throw new AssertionError();
-        }
+        String fieldName = framekworkTypeNames.get(key);
 
         FieldWriter frameworkField = classWithFields.addField(frameworkTypeName, fieldName);
         frameworkField.addModifiers(fieldModifiers);
@@ -299,7 +287,7 @@ ClassName nameGeneratedType(ComponentDescriptor input) {
 
     ImmutableMap<Key, Snippet> memberSelectSnippets = memberSelectSnippetsBuilder.build();
 
-    List<List<Key>> partitions = Lists.partition(input.initializationOrdering(), 100);
+    List<List<Key>> partitions = Lists.partition(input.resolvedBindings().keySet().asList(), 100);
     for (int i = 0; i < partitions.size(); i++) {
       MethodWriter initializeMethod =
           componentWriter.addMethod(VoidName.VOID, "initialize" + ((i == 0) ? "" : i));
@@ -310,14 +298,17 @@ ClassName nameGeneratedType(ComponentDescriptor input) {
         Snippet memberSelectSnippet = memberSelectSnippets.get(key);
         switch (key.kind()) {
           case PROVIDER:
-            Set<ProvisionBinding> bindings = resolvedProvisionBindings.get(key);
+            @SuppressWarnings("unchecked")
+            Set<ProvisionBinding> bindings =
+                (Set<ProvisionBinding>) input.resolvedBindings().get(key).bindings();
             BindingType bindingsType = ProvisionBinding.bindingTypeFor(bindings);
             switch (bindingsType) {
               case SET:
                 ImmutableList.Builder<Snippet> setFactoryParameters = ImmutableList.builder();
                 for (ProvisionBinding binding : bindings) {
                   setFactoryParameters.add(initializeFactoryForBinding(binding,
-                      input.dependencyMethodIndex(), componentContributionFields,
+                      input.componentDescriptor().dependencyMethodIndex(),
+                      componentContributionFields,
                       memberSelectSnippets));
                 }
                 Snippet initializeSetSnippet = Snippet.format("%s.create(%s)",
@@ -330,7 +321,8 @@ ClassName nameGeneratedType(ComponentDescriptor input) {
                 if (!bindings.isEmpty()) {
                   Snippet initializeMapSnippet =
                       initializeMapBinding(componentContributionFields,
-                          input.dependencyMethodIndex(), memberSelectSnippets, bindings);
+                          input.componentDescriptor().dependencyMethodIndex(),
+                          memberSelectSnippets, bindings);
                   initializeMethod.body().addSnippet("this.%s = %s;",
                       memberSelectSnippet, initializeMapSnippet);
                 }
@@ -339,7 +331,8 @@ ClassName nameGeneratedType(ComponentDescriptor input) {
                 ProvisionBinding binding = Iterables.getOnlyElement(bindings);
                 initializeMethod.body().addSnippet("this.%s = %s;",
                     memberSelectSnippet,
-                    initializeFactoryForBinding(binding, input.dependencyMethodIndex(),
+                    initializeFactoryForBinding(binding,
+                        input.componentDescriptor().dependencyMethodIndex(),
                         componentContributionFields, memberSelectSnippets));
                 break;
               default:
@@ -347,7 +340,8 @@ ClassName nameGeneratedType(ComponentDescriptor input) {
             }
             break;
           case MEMBERS_INJECTOR:
-            MembersInjectionBinding binding = resolvedMembersInjectionBindings.get(key);
+            MembersInjectionBinding binding = (MembersInjectionBinding) Iterables.getOnlyElement(
+                input.resolvedBindings().get(key).bindings());
             initializeMethod.body().addSnippet("this.%s = %s;",
                 memberSelectSnippet,
                 initializeMembersInjectorForBinding(binding, memberSelectSnippets));
@@ -358,30 +352,37 @@ ClassName nameGeneratedType(ComponentDescriptor input) {
       }
     }
 
-    for (DependencyRequest interfaceRequest : input.interfaceRequests()) {
-      ExecutableElement requestElement = (ExecutableElement) interfaceRequest.requestElement();
-      MethodWriter interfaceMethod = requestElement.getReturnType().getKind().equals(VOID)
-          ? componentWriter.addMethod(VoidName.VOID, requestElement.getSimpleName().toString())
-              : componentWriter.addMethod(requestElement.getReturnType(),
-                  requestElement.getSimpleName().toString());
-      interfaceMethod.annotate(Override.class);
-      interfaceMethod.addModifiers(PUBLIC);
-      Key key = interfaceRequest.key();
-      if (interfaceRequest.kind().equals(MEMBERS_INJECTOR)) {
-        Snippet membersInjectorName = memberSelectSnippets.get(key);
-        VariableElement parameter = Iterables.getOnlyElement(requestElement.getParameters());
-        Name parameterName = parameter.getSimpleName();
-        interfaceMethod.addParameter(
-            TypeNames.forTypeMirror(parameter.asType()), parameterName.toString());
-        interfaceMethod.body()
-        .addSnippet("%s.injectMembers(%s);", membersInjectorName, parameterName);
-        if (!requestElement.getReturnType().getKind().equals(VOID)) {
-          interfaceMethod.body().addSnippet("return %s;", parameterName);
-        }
-      } else {
-        interfaceMethod.body().addSnippet("return %s;",
-            frameworkTypeUsageStatement(memberSelectSnippets.get(key),
-                interfaceRequest.kind()));
+    Set<MethodSignature> interfaceMethods = Sets.newHashSet();
+
+    for (DependencyRequest interfaceRequest : input.entryPoints()) {
+      ExecutableElement requestElement =
+          MoreElements.asExecutable(interfaceRequest.requestElement());
+      MethodSignature signature = MethodSignature.fromExecutableElement(requestElement);
+      if (!interfaceMethods.contains(signature)) {
+        interfaceMethods.add(signature);
+        MethodWriter interfaceMethod = requestElement.getReturnType().getKind().equals(VOID)
+            ? componentWriter.addMethod(VoidName.VOID, requestElement.getSimpleName().toString())
+                : componentWriter.addMethod(requestElement.getReturnType(),
+                    requestElement.getSimpleName().toString());
+            interfaceMethod.annotate(Override.class);
+            interfaceMethod.addModifiers(PUBLIC);
+            Key key = interfaceRequest.key();
+            if (interfaceRequest.kind().equals(MEMBERS_INJECTOR)) {
+              Snippet membersInjectorName = memberSelectSnippets.get(key);
+              VariableElement parameter = Iterables.getOnlyElement(requestElement.getParameters());
+              Name parameterName = parameter.getSimpleName();
+              interfaceMethod.addParameter(
+                  TypeNames.forTypeMirror(parameter.asType()), parameterName.toString());
+              interfaceMethod.body()
+              .addSnippet("%s.injectMembers(%s);", membersInjectorName, parameterName);
+              if (!requestElement.getReturnType().getKind().equals(VOID)) {
+                interfaceMethod.body().addSnippet("return %s;", parameterName);
+              }
+            } else {
+              interfaceMethod.body().addSnippet("return %s;",
+                  frameworkTypeUsageStatement(memberSelectSnippets.get(key),
+                      interfaceRequest.kind()));
+            }
       }
     }
 
@@ -391,6 +392,88 @@ ClassName nameGeneratedType(ComponentDescriptor input) {
         .build();
   }
 
+  private ImmutableSetMultimap.Builder<String, Key> indexInitializations(BindingGraph input,
+      ClassName componentName) {
+    ImmutableSetMultimap.Builder<String, Key> initializationByPackageBuilder =
+        ImmutableSetMultimap.builder();
+    for (Entry<Key, ResolvedBindings> resolvedBindingEntry : input.resolvedBindings().entrySet()) {
+      ImmutableSet.Builder<String> bindingPackagesBuilder = ImmutableSet.builder();
+      for (Binding binding : resolvedBindingEntry.getValue().bindings()) {
+        bindingPackagesBuilder.addAll(binding.bindingPackage().asSet());
+      }
+      ImmutableSet<String> bindingPackages = bindingPackagesBuilder.build();
+      final String bindingPackage;
+      switch (bindingPackages.size()) {
+        case 0:
+          bindingPackage = componentName.packageName();
+          break;
+        case 1:
+          bindingPackage = bindingPackages.iterator().next();
+          break;
+        default:
+          throw new IllegalStateException();
+      }
+      initializationByPackageBuilder.put(bindingPackage, resolvedBindingEntry.getKey());
+    }
+    return initializationByPackageBuilder;
+  }
+
+  private ImmutableMap<Key, String> generateFrameworkTypeNames(BindingGraph graph) {
+    ImmutableMap.Builder<Key, String> names = ImmutableMap.builder();
+    for (Entry<Key, ResolvedBindings> entry : graph.resolvedBindings().entrySet()) {
+      Key key = entry.getKey();
+      switch (key.kind()) {
+        case PROVIDER:
+          @SuppressWarnings("unchecked")
+          ImmutableSet<ProvisionBinding> bindingsForKey =
+              (ImmutableSet<ProvisionBinding>) entry.getValue().bindings();
+          BindingType bindingsType = ProvisionBinding.bindingTypeFor(bindingsForKey);
+          switch (bindingsType) {
+            case SET:
+              names.put(key,
+                  new KeyVariableNamer().apply(key) + "Provider");
+              break;
+            case MAP:
+              names.put(key,
+                  new KeyVariableNamer().apply(key) + "Provider");
+              break;
+            case UNIQUE:
+              ProvisionBinding binding = Iterables.getOnlyElement(bindingsForKey);
+              names.put(key,
+                  binding.bindingElement().accept(new ElementKindVisitor6<String, Void>() {
+                    @Override
+                    public String visitExecutableAsConstructor(ExecutableElement e, Void p) {
+                      return e.getEnclosingElement().accept(this, null);
+                    }
+
+                    @Override
+                    public String visitExecutableAsMethod(ExecutableElement e, Void p) {
+                      return e.getSimpleName().toString();
+                    }
+
+                    @Override
+                    public String visitType(TypeElement e, Void p) {
+                      return CaseFormat.UPPER_CAMEL.to(CaseFormat.LOWER_CAMEL,
+                          e.getSimpleName().toString());
+                    }
+                  }, null) + "Provider");
+              break;
+            default:
+              throw new AssertionError();
+          }
+          break;
+        case MEMBERS_INJECTOR:
+          names.put(key, CaseFormat.UPPER_CAMEL.to(CaseFormat.LOWER_CAMEL,
+              Iterables.getOnlyElement(entry.getValue().bindings())
+                  .bindingElement().getSimpleName().toString()) + "MembersInjector");
+          break;
+        default:
+          throw new AssertionError();
+      }
+    }
+    return names.build();
+  }
+
   private Snippet initializeFactoryForBinding(ProvisionBinding binding,
       ImmutableMap<ExecutableElement, TypeElement> dependencyMethodIndex,
       Map<TypeElement, FieldWriter> contributionFields,
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java
index a0a956a4d..067194867 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java
@@ -34,21 +34,24 @@
 final class ComponentProcessingStep implements ProcessingStep {
   private final Messager messager;
   private final ComponentValidator componentValidator;
+  private final BindingGraphValidator bindingGraphValidator;
   private final ComponentDescriptor.Factory componentDescriptorFactory;
+  private final BindingGraph.Factory bindingGraphFactory;
   private final ComponentGenerator componentGenerator;
-  private final GraphValidator graphValidator;
 
   ComponentProcessingStep(
       Messager messager,
       ComponentValidator componentValidator,
-      GraphValidator graphValidator,
+      BindingGraphValidator bindingGraphValidator,
       Factory componentDescriptorFactory,
+      BindingGraph.Factory bindingGraphFactory,
       ComponentGenerator componentGenerator) {
     this.messager = messager;
     this.componentValidator = componentValidator;
+    this.bindingGraphValidator = bindingGraphValidator;
     this.componentDescriptorFactory = componentDescriptorFactory;
+    this.bindingGraphFactory = bindingGraphFactory;
     this.componentGenerator = componentGenerator;
-    this.graphValidator = graphValidator;
   }
 
   @Override
@@ -61,14 +64,19 @@ public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment
         ValidationReport<TypeElement> componentReport =
             componentValidator.validate(componentTypeElement);
         componentReport.printMessagesTo(messager);
-        ValidationReport<TypeElement> graphReport =
-            graphValidator.validate(componentTypeElement);
-        graphReport.printMessagesTo(messager);
-        if (componentReport.isClean() && graphReport.isClean()) {
-          try {
-            componentGenerator.generate(componentDescriptorFactory.create(componentTypeElement));
-          } catch (SourceFileGenerationException e) {
-            e.printMessageTo(messager);
+        if (componentReport.isClean()) {
+          ComponentDescriptor componentDescriptor =
+              componentDescriptorFactory.create(componentTypeElement);
+          BindingGraph bindingGraph = bindingGraphFactory.create(componentDescriptor);
+          ValidationReport<BindingGraph> graphReport =
+              bindingGraphValidator.validate(bindingGraph);
+          graphReport.printMessagesTo(messager);
+          if (graphReport.isClean()) {
+            try {
+              componentGenerator.generate(bindingGraph);
+            } catch (SourceFileGenerationException e) {
+              e.printMessageTo(messager);
+            }
           }
         }
       }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
index 644d79173..823a2666f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -98,12 +98,16 @@ public synchronized void init(ProcessingEnvironment processingEnv) {
         membersInjectionBindingFactory, membersInjectorGenerator);
 
     ComponentDescriptor.Factory componentDescriptorFactory =
-        new ComponentDescriptor.Factory(elements, types, injectBindingRegistry,
-            dependencyRequestFactory, keyFactory, provisionBindingFactory);
+        new ComponentDescriptor.Factory(elements, types, provisionBindingFactory);
+
+    BindingGraph.Factory bindingGraphFactory = new BindingGraph.Factory(
+        elements, types, injectBindingRegistry, keyFactory, dependencyRequestFactory,
+        provisionBindingFactory);
+
     MapKeyGenerator mapKeyGenerator = new MapKeyGenerator(filer);
 
-    GraphValidator graphValidator = new GraphValidator(elements, types, injectBindingRegistry,
-        dependencyRequestFactory, keyFactory, provisionBindingFactory);
+    BindingGraphValidator bindingGraphValidator = new BindingGraphValidator(types,
+        injectBindingRegistry);
 
     this.processingSteps = ImmutableList.<ProcessingStep>of(
         new MapKeyProcessingStep(
@@ -127,8 +131,9 @@ public synchronized void init(ProcessingEnvironment processingEnv) {
         new ComponentProcessingStep(
             messager,
             componentValidator,
-            graphValidator,
+            bindingGraphValidator,
             componentDescriptorFactory,
+            bindingGraphFactory,
             componentGenerator));
   }
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java b/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
index ae0cafeb8..75e401252 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ConfigurationAnnotations.java
@@ -18,14 +18,15 @@
 import com.google.auto.common.MoreTypes;
 import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Maps;
 import com.google.common.collect.Queues;
-import com.google.common.collect.Sets;
 import dagger.Component;
 import dagger.MapKey;
 import dagger.Module;
+import java.util.Map;
 import java.util.Queue;
-import java.util.Set;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.TypeElement;
@@ -88,26 +89,26 @@
    * given seed modules.  If a module is malformed and a type listed in {@link Module#includes}
    * is not annotated with {@link Module}, it is ignored.
    */
-  static ImmutableSet<TypeElement> getTransitiveModules(Elements elements, Types types,
-      ImmutableSet<TypeElement> seedModules) {
+  static ImmutableMap<TypeElement, ImmutableSet<TypeElement>> getTransitiveModules(
+      Elements elements, Types types, ImmutableSet<TypeElement> seedModules) {
     Queue<TypeElement> moduleQueue = Queues.newArrayDeque(seedModules);
-    Set<TypeElement> moduleElements = Sets.newLinkedHashSet();
+    Map<TypeElement, ImmutableSet<TypeElement>> moduleElements = Maps.newLinkedHashMap();
     for (TypeElement moduleElement = moduleQueue.poll();
         moduleElement != null;
         moduleElement = moduleQueue.poll()) {
-      moduleElements.add(moduleElement);
       Optional<AnnotationMirror> moduleMirror = getAnnotationMirror(moduleElement, Module.class);
       if (moduleMirror.isPresent()) {
         ImmutableSet<TypeElement> moduleDependencies = MoreTypes.asTypeElements(types,
             ConfigurationAnnotations.getModuleIncludes(elements, moduleMirror.get()));
+        moduleElements.put(moduleElement, moduleDependencies);
         for (TypeElement dependencyType : moduleDependencies) {
-          if (!moduleElements.contains(dependencyType)) {
+          if (!moduleElements.containsKey(dependencyType)) {
             moduleQueue.add(dependencyType);
           }
         }
       }
     }
-    return ImmutableSet.copyOf(moduleElements);
+    return ImmutableMap.copyOf(moduleElements);
   }
 
   private ConfigurationAnnotations() {}
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyRequestFormatter.java b/compiler/src/main/java/dagger/internal/codegen/DependencyRequestFormatter.java
index 170ee831e..fa36084ee 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DependencyRequestFormatter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyRequestFormatter.java
@@ -46,7 +46,7 @@ static DependencyRequestFormatter instance() {
 
   // TODO(user): Sweep this class for TypeMirror.toString() usage and do some preventive format.
   // TODO(user): consider returning a small structure containing strings to be indented later.
-  @Override public String format(DependencyRequest request) {
+  @Override public String format(final DependencyRequest request) {
     Element requestElement = request.requestElement();
     Optional<AnnotationMirror> qualifier = InjectionAnnotations.getQualifier(requestElement);
     return requestElement.accept(new SimpleElementVisitor6<String, Optional<AnnotationMirror>>(){
@@ -112,6 +112,11 @@ static DependencyRequestFormatter instance() {
         return builder.toString();
       }
 
+      @Override
+      public String visitType(TypeElement e, Optional<AnnotationMirror> p) {
+        return INDENT + e.getQualifiedName();
+      }
+
       @Override protected String defaultAction(Element element, Optional<AnnotationMirror> ignore) {
         throw new IllegalStateException(
             "Invalid request " + element.getKind() +  " element " + element);
diff --git a/compiler/src/main/java/dagger/internal/codegen/GraphValidator.java b/compiler/src/main/java/dagger/internal/codegen/GraphValidator.java
deleted file mode 100644
index 7d9954371..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/GraphValidator.java
+++ /dev/null
@@ -1,424 +0,0 @@
-/*
- * Copyright (C) 2014 Google, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package dagger.internal.codegen;
-
-import com.google.auto.common.MoreElements;
-import com.google.auto.common.MoreTypes;
-import com.google.common.base.Joiner;
-import com.google.common.base.Optional;
-import com.google.common.collect.FluentIterable;
-import com.google.common.collect.ImmutableList;
-import com.google.common.collect.ImmutableListMultimap;
-import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.ImmutableSetMultimap;
-import com.google.common.collect.Iterables;
-import com.google.common.collect.ListMultimap;
-import com.google.common.collect.Ordering;
-import com.google.common.collect.Queues;
-import dagger.Component;
-import dagger.Provides;
-import dagger.internal.codegen.ProvisionBinding.BindingType;
-import dagger.internal.codegen.ValidationReport.Builder;
-import java.util.Deque;
-import java.util.Formatter;
-import java.util.LinkedHashSet;
-import java.util.List;
-import java.util.Set;
-import javax.lang.model.element.AnnotationMirror;
-import javax.lang.model.element.ElementKind;
-import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.Modifier;
-import javax.lang.model.element.Name;
-import javax.lang.model.element.TypeElement;
-import javax.lang.model.element.VariableElement;
-import javax.lang.model.type.DeclaredType;
-import javax.lang.model.type.TypeMirror;
-import javax.lang.model.util.ElementFilter;
-import javax.lang.model.util.Elements;
-import javax.lang.model.util.SimpleTypeVisitor6;
-import javax.lang.model.util.Types;
-
-import static com.google.auto.common.MoreElements.getAnnotationMirror;
-import static com.google.auto.common.MoreElements.isAnnotationPresent;
-import static com.google.common.collect.Iterables.getOnlyElement;
-import static dagger.internal.codegen.ConfigurationAnnotations.getComponentModules;
-import static dagger.internal.codegen.ConfigurationAnnotations.getTransitiveModules;
-import static dagger.internal.codegen.ErrorMessages.INDENT;
-import static dagger.internal.codegen.ErrorMessages.REQUIRES_AT_INJECT_CONSTRUCTOR_OR_PROVIDER_FORMAT;
-import static dagger.internal.codegen.ErrorMessages.REQUIRES_PROVIDER_FORMAT;
-import static javax.lang.model.type.TypeKind.VOID;
-import static javax.lang.model.util.ElementFilter.methodsIn;
-
-/**
- * Performs validation of object graphs rooted in the provision and injection methods of
- * a {link @Component} interface.
- *
- * @author Christian Gruber
- */
-public class GraphValidator implements Validator<TypeElement> {
-  private final Elements elements;
-  private final Types types;
-  private final InjectBindingRegistry bindingRegistry;
-  private final DependencyRequest.Factory dependencyRequestFactory;
-  private final Key.Factory keyFactory;
-  private final ProvisionBinding.Factory provisionBindingFactory;
-
-  GraphValidator(
-      Elements elements,
-      Types types,
-      InjectBindingRegistry bindingRegistry,
-      DependencyRequest.Factory dependencyRequestFactory,
-      Key.Factory keyFactory,
-      ProvisionBinding.Factory provisionBindingFactory) {
-    this.elements = elements;
-    this.types = types;
-    this.bindingRegistry = bindingRegistry;
-    this.dependencyRequestFactory = dependencyRequestFactory;
-    this.keyFactory = keyFactory;
-    this.provisionBindingFactory = provisionBindingFactory;
-  }
-
-  @Override
-  public ValidationReport<TypeElement> validate(TypeElement subject) {
-    ValidationReport.Builder<TypeElement> reportBuilder = ValidationReport.Builder.about(subject);
-    validateGraph(subject, reportBuilder);
-    return reportBuilder.build();
-  }
-
-  void validateGraph(TypeElement component,
-      ValidationReport.Builder<TypeElement> reportBuilder) {
-    AnnotationMirror componentMirror =
-        getAnnotationMirror(component, Component.class).get();
-    ImmutableSet.Builder<ProvisionBinding> explicitBindingsBuilder = ImmutableSet.builder();
-    ProvisionBinding componentBinding = provisionBindingFactory.forComponent(component);
-    explicitBindingsBuilder.add(componentBinding);
-
-    // Collect Component dependencies.
-    ImmutableSet<TypeElement> componentDependencyTypes = MoreTypes.asTypeElements(types,
-        ConfigurationAnnotations.getComponentDependencies(elements, componentMirror));
-    for (TypeElement componentDependency : componentDependencyTypes) {
-      explicitBindingsBuilder.add(provisionBindingFactory.forComponent(componentDependency));
-      List<ExecutableElement> dependencyMethods =
-          ElementFilter.methodsIn(elements.getAllMembers(componentDependency));
-      for (ExecutableElement method : dependencyMethods) {
-        if (isComponentProvisionMethod(method)) {
-          // MembersInjection methods aren't "provided" explicitly, so ignore them.
-          try {
-            explicitBindingsBuilder.add(provisionBindingFactory.forComponentMethod(method));
-          } catch (IllegalArgumentException e) {
-            // Should not ever get here due to previous component validation.
-            reportBuilder.addItem("Component provision methods cannot have parameters.", method);
-          }
-        }
-      }
-    }
-
-    // Collect transitive modules provisions.
-    ImmutableSet<TypeElement> moduleTypes =
-        MoreTypes.asTypeElements(types, getComponentModules(elements, componentMirror));
-
-    for (TypeElement module : getTransitiveModules(elements, types, moduleTypes)) {
-      // traverse the modules, collect the bindings
-      List<ExecutableElement> moduleMethods = methodsIn(elements.getAllMembers(module));
-      for (ExecutableElement moduleMethod : moduleMethods) {
-        if (isAnnotationPresent(moduleMethod, Provides.class)) {
-          try {
-            explicitBindingsBuilder.add(provisionBindingFactory.forProvidesMethod(moduleMethod));
-          } catch (IllegalArgumentException e) {
-            // Should not ever get here due to previous module validation.
-            reportBuilder.addItem(
-                String.format(ErrorMessages.MALFORMED_MODULE_METHOD_FORMAT,
-                    moduleMethod.getSimpleName(),
-                    MoreElements.asType(moduleMethod.getEnclosingElement()).getQualifiedName()),
-                component);
-          }
-        }
-      }
-    }
-
-    for (DependencyRequest componentMethodRequest : componentMethodRequests(component)) {
-      Deque<Key> cycleStack = Queues.newArrayDeque();
-      Deque<DependencyRequest> dependencyPath = Queues.newArrayDeque();
-      resolveRequest(
-          componentMethodRequest,
-          componentMethodRequest,
-          reportBuilder,
-          explicitBindingsByKey(explicitBindingsBuilder.build()),
-          new LinkedHashSet<Key>(),
-          cycleStack,
-          dependencyPath);
-    }
-  }
-
-  private ImmutableSetMultimap<Key, ProvisionBinding> explicitBindingsByKey(
-      Iterable<ProvisionBinding> bindings) {
-    // Multimaps.index() doesn't do ImmutableSetMultimaps.
-    ImmutableSetMultimap.Builder<Key, ProvisionBinding> builder = ImmutableSetMultimap.builder();
-    for (ProvisionBinding binding : bindings) {
-      builder.put(binding.key(), binding);
-    }
-    return builder.build();
-  }
-
-  private ImmutableList<DependencyRequest> componentMethodRequests(TypeElement componentType) {
-    ImmutableList.Builder<DependencyRequest> interfaceRequestsBuilder = ImmutableList.builder();
-    for (ExecutableElement componentMethod : methodsIn(elements.getAllMembers(componentType))) {
-      if (componentMethod.getModifiers().contains(Modifier.ABSTRACT)) { // Elide Object.*;
-        if (isComponentProvisionMethod(componentMethod)) {
-          interfaceRequestsBuilder.add(
-              dependencyRequestFactory.forComponentProvisionMethod(componentMethod));
-        } else if (isComponentMembersInjectionMethod(componentMethod)) {
-          interfaceRequestsBuilder.add(
-              dependencyRequestFactory.forComponentMembersInjectionMethod(componentMethod));
-        }
-      }
-    }
-    return interfaceRequestsBuilder.build();
-  }
-
-  private void resolveRequest(DependencyRequest request,
-      DependencyRequest rootRequest,
-      ValidationReport.Builder<TypeElement> reportBuilder,
-      ImmutableSetMultimap<Key, ProvisionBinding> explicitBindings,
-      Set<Key> resolvedBindings,
-      Deque<Key> cycleStack,
-      Deque<DependencyRequest> dependencyPath) {
-
-    Key requestKey = request.key();
-    if (cycleStack.contains(requestKey) && !isComponent(requestKey.type())) {
-      resolvedBindings.add(requestKey); // it's present, but bad, and we report that.
-      dependencyPath = Queues.newArrayDeque(dependencyPath); // copy
-      dependencyPath.push(request); // add current request.
-      dependencyPath.pollLast(); // strip off original request from the component method.
-      ImmutableList<String> printableDependencyPath = FluentIterable.from(dependencyPath)
-          .transform(DependencyRequestFormatter.instance()).toList().reverse();
-      TypeElement componentType =
-          MoreElements.asType(rootRequest.requestElement().getEnclosingElement());
-      // TODO(user): Restructure to provide a hint for the start and end of the cycle.
-      reportBuilder.addItem(
-          String.format(ErrorMessages.CONTAINS_DEPENDENCY_CYCLE_FORMAT,
-              componentType.getQualifiedName(),
-              rootRequest.requestElement().getSimpleName(),
-              Joiner.on("\n").join(printableDependencyPath)),
-          rootRequest.requestElement());
-
-      return;
-    }
-    if (resolvedBindings.contains(requestKey)) {
-      return;
-    }
-
-    dependencyPath.push(request);
-    cycleStack.push(requestKey);
-    try {
-      switch (request.kind()) {
-        case INSTANCE:
-        case LAZY:
-        case PROVIDER:
-          // First, check for explicit keys (those from modules and components)
-          ImmutableSet<ProvisionBinding> explicitBindingsForKey = explicitBindings.get(requestKey);
-          if (explicitBindingsForKey.isEmpty()) {
-            // If the key is Map<K, V>, get its implicit binding key which is Map<K, Provider<V>>
-            Optional<Key> key = keyFactory.implicitMapProviderKeyFrom(request.key());
-            if (key.isPresent()) {
-              DependencyRequest implicitRequest =
-                  dependencyRequestFactory.forImplicitMapBinding(request, key.get());
-              Binding implicitBinding =
-                  provisionBindingFactory.forImplicitMapBinding(request, implicitRequest);
-              resolveRequest(Iterables.getOnlyElement(implicitBinding.dependencies()),
-                  rootRequest, reportBuilder, explicitBindings, resolvedBindings, cycleStack,
-                  dependencyPath);
-              resolvedBindings.add(requestKey);
-            } else {
-              // no explicit binding, look it up or fail.
-              Optional<ProvisionBinding> provisionBinding =
-                  findProvidableType(requestKey, reportBuilder, rootRequest, dependencyPath);
-              if (provisionBinding.isPresent()) {
-                // found a binding, resolve its deps and then mark it resolved
-                for (DependencyRequest dependency : provisionBinding.get().implicitDependencies()) {
-                  resolveRequest(dependency, rootRequest, reportBuilder, explicitBindings,
-                      resolvedBindings, cycleStack, dependencyPath);
-                }
-                resolvedBindings.add(requestKey);
-              }
-            }
-          } else {
-            // If this is an explicit Map<K, V> request then add in any map binding provision
-            // methods which are implied by and must collide with explicit Map<K, V> bindings.
-            Optional<Key> underlyingMapKey = keyFactory.implicitMapProviderKeyFrom(request.key());
-            if (underlyingMapKey.isPresent()) {
-              explicitBindingsForKey = ImmutableSet.<ProvisionBinding>builder()
-                  .addAll(explicitBindingsForKey)
-                  .addAll(explicitBindings.get(underlyingMapKey.get()))
-                  .build();
-            }
-            if (explicitBindingsForKey.size() > 1) {
-              // Multiple Explicit bindings. Validate that they are multi-bindings.
-              ImmutableListMultimap<BindingType, ProvisionBinding> bindingsByType =
-                  ProvisionBinding.bindingTypesFor(explicitBindingsForKey);
-              if (bindingsByType.keySet().size() > 1) {
-                reportMultipleBindingTypes(rootRequest, requestKey, bindingsByType, reportBuilder);
-              } else if (getOnlyElement(bindingsByType.keySet()).equals(BindingType.UNIQUE)) {
-                reportDuplicateBindings(rootRequest, requestKey, bindingsByType, reportBuilder);
-              }
-            }
-            for (Binding explicitBinding : explicitBindingsForKey) {
-              for (DependencyRequest dependency : explicitBinding.dependencies()) {
-                resolveRequest(dependency, rootRequest, reportBuilder, explicitBindings,
-                    resolvedBindings, cycleStack, dependencyPath);
-              }
-            }
-            resolvedBindings.add(requestKey);
-          }
-          break;
-        case MEMBERS_INJECTOR:
-          // no explicit deps for members injection, so just look it up
-          Optional<MembersInjectionBinding> membersInjectionBinding =
-              Optional.fromNullable(bindingRegistry.getOrFindMembersInjectionBinding(requestKey));
-          if (membersInjectionBinding.isPresent()) {
-            // found a binding, resolve its deps and then mark it resolved
-            for (DependencyRequest dependency : membersInjectionBinding.get().dependencies()) {
-              resolveRequest(dependency, rootRequest, reportBuilder, explicitBindings,
-                  resolvedBindings, cycleStack, dependencyPath);
-            }
-            resolvedBindings.add(requestKey);
-          }
-          break;
-        default:
-          throw new AssertionError();
-      }
-    } finally {
-      dependencyPath.pop();
-      cycleStack.pop();
-    }
-  }
-
-  @SuppressWarnings("resource") // Appendable is a StringBuilder.
-  private void reportDuplicateBindings(DependencyRequest rootRequest, Key requestKey,
-      ListMultimap<BindingType, ProvisionBinding> bindingsByType,
-      ValidationReport.Builder<TypeElement> reportBuilder) {
-    StringBuilder builder = new StringBuilder();
-    new Formatter(builder).format(ErrorMessages.DUPLICATE_BINDINGS_FOR_KEY_FORMAT,
-        KeyFormatter.instance().format(requestKey));
-    for (ProvisionBinding binding : bindingsByType.values()) {
-      builder.append('\n').append(INDENT);
-      builder.append(ProvisionBindingFormatter.instance().format(binding));
-    }
-    reportBuilder.addItem(builder.toString(), rootRequest.requestElement());
-  }
-
-  @SuppressWarnings("resource") // Appendable is a StringBuilder.
-  private void reportMultipleBindingTypes(DependencyRequest rootRequest, Key requestKey,
-      ListMultimap<BindingType, ProvisionBinding> bindingsByType,
-      ValidationReport.Builder<TypeElement> reportBuilder) {
-    StringBuilder builder = new StringBuilder();
-    new Formatter(builder).format(ErrorMessages.MULTIPLE_BINDING_TYPES_FOR_KEY_FORMAT,
-        KeyFormatter.instance().format(requestKey));
-    for (BindingType type :
-        Ordering.natural().immutableSortedCopy(bindingsByType.keySet())) {
-      builder.append(INDENT);
-      builder.append(formatBindingType(type));
-      builder.append(" bindings:\n");
-      for (ProvisionBinding binding : bindingsByType.get(type)) {
-        builder.append(INDENT).append(INDENT);
-        builder.append(ProvisionBindingFormatter.instance().format(binding));
-        builder.append('\n');
-      }
-    }
-    reportBuilder.addItem(builder.toString(), rootRequest.requestElement());
-  }
-
-  private String formatBindingType(BindingType type) {
-    switch(type) {
-      case MAP:
-        return "Map";
-      case SET:
-        return "Set";
-      case UNIQUE:
-        return "Unique";
-      default:
-        throw new IllegalStateException("Unknown binding type: " + type);
-    }
-  }
-
-  // TODO(user) determine what bits of InjectBindingRegistry's findOrCreate logic to factor out.
-  private Optional<ProvisionBinding> findProvidableType(Key key, Builder<TypeElement> reportBuilder,
-      DependencyRequest rootRequest, Deque<DependencyRequest> dependencyPath) {
-    Optional<ProvisionBinding> binding = bindingRegistry.getOrFindProvisionBinding(key);
-    if (!binding.isPresent()) {
-      TypeMirror type = key.type();
-      Name typeName = MoreElements.asType(types.asElement(type)).getQualifiedName();
-      boolean requiresProvidesMethod = type.accept(new SimpleTypeVisitor6<Boolean, Void>() {
-        @Override protected Boolean defaultAction(TypeMirror e, Void p) {
-          return true;
-        }
-
-        @Override public Boolean visitDeclared(DeclaredType type, Void ignored) {
-          // Note - this logic is also in InjectConstructorValidator but is woven into errors.
-          TypeElement typeElement = MoreElements.asType(type.asElement());
-          if (typeElement.getTypeParameters().isEmpty()
-              && typeElement.getKind().equals(ElementKind.CLASS)
-              && !typeElement.getModifiers().contains(Modifier.ABSTRACT)) {
-            return false;
-          }
-          return true;
-        }
-      }, null);
-      StringBuilder errorMessage = new StringBuilder();
-      if(requiresProvidesMethod) {
-        errorMessage.append(String.format(REQUIRES_PROVIDER_FORMAT, typeName));
-      } else {
-        errorMessage.append(
-            String.format(REQUIRES_AT_INJECT_CONSTRUCTOR_OR_PROVIDER_FORMAT, typeName));
-      }
-      if (key.isValidMembersInjectionKey()
-          && !bindingRegistry.getOrFindMembersInjectionBinding(key).injectionSites().isEmpty()) {
-        errorMessage.append(" ").append(ErrorMessages.MEMBERS_INJECTION_DOES_NOT_IMPLY_PROVISION);
-      }
-      dependencyPath = Queues.newArrayDeque(dependencyPath); // copy
-      dependencyPath.pollLast();
-      ImmutableList<String> printableDependencyPath = FluentIterable.from(dependencyPath)
-          .transform(DependencyRequestFormatter.instance()).toList().reverse();
-      for(String dependency : printableDependencyPath) {
-        errorMessage.append("\n").append(dependency);
-      }
-      reportBuilder.addItem(errorMessage.toString(), rootRequest.requestElement());
-    }
-    return binding;
-  }
-
-  private boolean isComponent(TypeMirror type) {
-    // No need to fully validate. Components themselves will be validated by the ComponentValidator
-    return MoreElements.isAnnotationPresent(types.asElement(type), Component.class);
-  }
-
-  private boolean isComponentProvisionMethod(ExecutableElement method) {
-    return method.getParameters().isEmpty()
-        && !method.getReturnType().getKind().equals(VOID)
-        && !elements.getTypeElement(Object.class.getCanonicalName())
-            .equals(method.getEnclosingElement());
-  }
-
-  private boolean isComponentMembersInjectionMethod(ExecutableElement method) {
-    List<? extends VariableElement> parameters = method.getParameters();
-    TypeMirror returnType = method.getReturnType();
-    return parameters.size() == 1
-        && (returnType.getKind().equals(VOID)
-            || MoreTypes.equivalence().equivalent(returnType, parameters.get(0).asType()))
-        && !elements.getTypeElement(Object.class.getCanonicalName())
-            .equals(method.getEnclosingElement());
-  }
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
index 21d4a3e06..6a0a04a86 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
@@ -1,40 +1,28 @@
 /*
  * Copyright (C) 2014 Google, Inc.
  *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
+ * in compliance with the License. You may obtain a copy of the License at
  *
  * http://www.apache.org/licenses/LICENSE-2.0
  *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
  */
 package dagger.internal.codegen;
 
-import com.google.auto.common.MoreTypes;
 import com.google.common.base.CaseFormat;
-import com.google.common.base.Function;
 import com.google.common.collect.ComparisonChain;
 import com.google.common.collect.FluentIterable;
-import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ImmutableSetMultimap;
-import com.google.common.collect.ImmutableSortedSet;
 import com.google.common.collect.Iterables;
-import com.google.common.collect.Maps;
 import com.google.common.collect.Ordering;
-import com.google.common.collect.SetMultimap;
-import dagger.Lazy;
-import dagger.MembersInjector;
 import dagger.internal.DoubleCheckLazy;
-import dagger.internal.codegen.ProvisionBinding.BindingType;
 import dagger.internal.codegen.writer.ClassName;
-import dagger.internal.codegen.writer.JavaWriter;
 import dagger.internal.codegen.writer.Snippet;
 import java.util.Collection;
 import java.util.Iterator;
@@ -43,7 +31,6 @@
 import javax.inject.Provider;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
-import javax.lang.model.util.ElementKindVisitor6;
 
 import static com.google.common.base.CaseFormat.UPPER_CAMEL;
 
@@ -54,77 +41,23 @@
  * @since 2.0
  */
 class SourceFiles {
-  /**
-   * Given a mapping from variable name to type, returns a list of tokens suitable for methods such
-   * as {@link JavaWriter#beginMethod(String, String, java.util.Set, String...)}.
-   */
-  // TODO(gak): push this change upstream to obviate the need for this utility
-  static ImmutableList<String> flattenVariableMap(Map<String, String> variableMap) {
-    ImmutableList.Builder<String> tokenList = ImmutableList.builder();
-    for (Entry<String, String> variableEntry : variableMap.entrySet()) {
-      tokenList.add(variableEntry.getValue(), variableEntry.getKey());
-    }
-    return tokenList.build();
-  }
-
-  /**
-   * Returns the sorted set of all classes required by the {@link MembersInjector} implementation
-   * being generated.
-   */
-  static ImmutableSortedSet<ClassName> collectImportsFromDependencies(ClassName topLevelClassName,
-      Iterable<? extends DependencyRequest> dependencies) {
-    ImmutableSortedSet.Builder<ClassName> builder = ImmutableSortedSet.<ClassName>naturalOrder();
-    ImmutableSet<String> packagesToSkip  =
-        ImmutableSet.of("java.lang", topLevelClassName.packageName());
-    for (DependencyRequest dependency : dependencies) {
-      ImmutableSet<TypeElement> referencedTypes =
-          MoreTypes.referencedTypes(dependency.key().type());
-      switch (dependency.kind()) {
-        case LAZY:
-          builder.add(ClassName.fromClass(Lazy.class), ClassName.fromClass(DoubleCheckLazy.class));
-          // fall through
-        case INSTANCE:
-        case PROVIDER:
-          builder.add(ClassName.fromClass(Provider.class));
-          break;
-        case MEMBERS_INJECTOR:
-          builder.add(ClassName.fromClass(MembersInjector.class));
-          break;
-        default:
-          throw new AssertionError();
-      }
-      for (TypeElement referencedType : referencedTypes) {
-        ClassName className = ClassName.fromTypeElement(referencedType);
-        // don't include classes in java.lang or the same package
-        if (!packagesToSkip.contains(className.packageName())
-            // or that are members of the same top-level class
-            && !className.topLevelClassName().equals(topLevelClassName)) {
-          builder.add(className);
-        }
-      }
-    }
-    return builder.build();
-  }
-
   /**
    * Sorts {@link DependencyRequest} instances in an order likely to reflect their logical
    * importance.
    */
-  static final Ordering<DependencyRequest> DEPENDENCY_ORDERING =
-      new Ordering<DependencyRequest>() {
-        @Override public int compare(DependencyRequest left, DependencyRequest right) {
-          return ComparisonChain.start()
-              // put fields before parameters
-              .compare(left.requestElement().getKind(), right.requestElement().getKind())
-              // order by dependency kind
-              .compare(left.kind(), right.kind())
-              // then sort by name
-              .compare(
-                  left.requestElement().getSimpleName().toString(),
-                  right.requestElement().getSimpleName().toString())
-              .result();
-        }
-      };
+  static final Ordering<DependencyRequest> DEPENDENCY_ORDERING = new Ordering<DependencyRequest>() {
+    @Override
+    public int compare(DependencyRequest left, DependencyRequest right) {
+      return ComparisonChain.start()
+      // put fields before parameters
+          .compare(left.requestElement().getKind(), right.requestElement().getKind())
+          // order by dependency kind
+          .compare(left.kind(), right.kind())
+          // then sort by name
+          .compare(left.requestElement().getSimpleName().toString(),
+              right.requestElement().getSimpleName().toString()).result();
+    }
+  };
 
   /**
    * This method generates names for the {@link Provider} references necessary for all of the
@@ -137,42 +70,38 @@
    * </ul>
    *
    * @return Returns the mapping from {@link Key} to provider name sorted by the name of the
-   * provider.
+   *         provider.
    */
   static ImmutableMap<Key, String> generateFrameworkReferenceNamesForDependencies(
       Iterable<? extends DependencyRequest> dependencies) {
     ImmutableSetMultimap.Builder<Key, DependencyRequest> dependenciesByKeyBuilder =
-        new ImmutableSetMultimap.Builder<Key, DependencyRequest>()
-            .orderValuesBy(DEPENDENCY_ORDERING);
+        new ImmutableSetMultimap.Builder<Key, DependencyRequest>().orderValuesBy(
+            DEPENDENCY_ORDERING);
     for (DependencyRequest dependency : dependencies) {
-      dependenciesByKeyBuilder.put(
-          dependency.key(), dependency);
+      dependenciesByKeyBuilder.put(dependency.key(), dependency);
     }
     ImmutableSetMultimap<Key, DependencyRequest> dependenciesByKey =
         dependenciesByKeyBuilder.build();
-    Map<Key, Collection<DependencyRequest>> dependenciesByKeyMap =
-        dependenciesByKey.asMap();
+    Map<Key, Collection<DependencyRequest>> dependenciesByKeyMap = dependenciesByKey.asMap();
     ImmutableMap.Builder<Key, String> providerNames = ImmutableMap.builder();
-    for (Entry<Key, Collection<DependencyRequest>> entry :
-      dependenciesByKeyMap.entrySet()) {
+    for (Entry<Key, Collection<DependencyRequest>> entry : dependenciesByKeyMap.entrySet()) {
       // collect together all of the names that we would want to call the provider
-      ImmutableSet<String> dependencyNames = FluentIterable.from(entry.getValue())
-          .transform(new DependencyVariableNamer())
-          .toSet();
+      ImmutableSet<String> dependencyNames =
+          FluentIterable.from(entry.getValue()).transform(new DependencyVariableNamer()).toSet();
 
       if (dependencyNames.size() == 1) {
-        // if there's only one name, great!  use it!
+        // if there's only one name, great! use it!
         String name = Iterables.getOnlyElement(dependencyNames);
         providerNames.put(entry.getKey(), name.endsWith("Provider") ? name : name + "Provider");
       } else {
         // in the event that a provider is being used for a bunch of deps with different names,
-        // add all the names together with "And"s in the middle.  E.g.: stringAndS
+        // add all the names together with "And"s in the middle. E.g.: stringAndS
         Iterator<String> namesIterator = dependencyNames.iterator();
         String first = namesIterator.next();
         StringBuilder compositeNameBuilder = new StringBuilder(first);
         while (namesIterator.hasNext()) {
-          compositeNameBuilder.append("And")
-              .append(CaseFormat.LOWER_CAMEL.to(UPPER_CAMEL, namesIterator.next()));
+          compositeNameBuilder.append("And").append(
+              CaseFormat.LOWER_CAMEL.to(UPPER_CAMEL, namesIterator.next()));
         }
         providerNames.put(entry.getKey(), compositeNameBuilder.append("Provider").toString());
       }
@@ -180,79 +109,12 @@
     return providerNames.build();
   }
 
-  // TODO(gak): this needs to suck less
-  static ImmutableMap<Key, String> generateProviderNamesForBindings(
-      SetMultimap<Key, ProvisionBinding> bindings) {
-    ImmutableMap.Builder<Key, String> providerNames = ImmutableMap.builder();
-    for (Entry<Key, Collection<ProvisionBinding>> entry : bindings.asMap().entrySet()) {
-      Collection<ProvisionBinding> bindingsForKey = entry.getValue();
-      BindingType bindingsType = ProvisionBinding.bindingTypeFor(bindingsForKey);
-      switch (bindingsType) {
-        case SET:
-          providerNames.put(entry.getKey(),
-              new KeyVariableNamer().apply(entry.getKey()) + "Provider");
-          break;
-        case MAP:
-          providerNames.put(entry.getKey(),
-              new KeyVariableNamer().apply(entry.getKey()) + "Provider");
-          break;
-        case UNIQUE:
-          Binding binding = Iterables.getOnlyElement(bindingsForKey);
-          providerNames.put(entry.getKey(),
-              binding.bindingElement().accept(new ElementKindVisitor6<String, Void>() {
-                @Override
-                public String visitExecutableAsConstructor(ExecutableElement e, Void p) {
-                  return e.getEnclosingElement().accept(this, null);
-                }
-
-                @Override
-                public String visitExecutableAsMethod(ExecutableElement e, Void p) {
-                  return e.getSimpleName().toString();
-                }
-
-                @Override
-                public String visitType(TypeElement e, Void p) {
-                  return CaseFormat.UPPER_CAMEL.to(CaseFormat.LOWER_CAMEL,
-                      e.getSimpleName().toString());
-                }
-              }, null) + "Provider");
-          break;
-        default:
-          throw new IllegalStateException();
-      }
-    }
-    Ordering<Entry<?, String>> entryValueOrdering =
-        Ordering.natural().onResultOf(new Function<Entry<?, String>, String>() {
-          @Override
-          public String apply(Entry<?, String> input) {
-            return input.getValue();
-          }
-        });
-    ImmutableMap.Builder<Key, String> sortedProviderNames = ImmutableMap.builder();
-    for (Entry<Key, String> providerNameEntry :
-      entryValueOrdering.sortedCopy(providerNames.build().entrySet())) {
-      sortedProviderNames.put(providerNameEntry);
-    }
-    return sortedProviderNames.build();
-  }
-
-  static ImmutableMap<Key, String> generateMembersInjectorNamesForBindings(
-      Map<Key, MembersInjectionBinding> bindings) {
-    return ImmutableMap.copyOf(Maps.transformValues(bindings,
-        new Function<MembersInjectionBinding, String>() {
-          @Override public String apply(MembersInjectionBinding input) {
-            return CaseFormat.UPPER_CAMEL.to(CaseFormat.LOWER_CAMEL,
-                input.bindingElement().getSimpleName().toString()) + "MembersInjector";
-          }
-        }));
-  }
-
   static Snippet frameworkTypeUsageStatement(Snippet frameworkTypeMemberSelect,
       DependencyRequest.Kind dependencyKind) {
     switch (dependencyKind) {
       case LAZY:
-        return Snippet.format("%s.create(%s)",
-            ClassName.fromClass(DoubleCheckLazy.class), frameworkTypeMemberSelect);
+        return Snippet.format("%s.create(%s)", ClassName.fromClass(DoubleCheckLazy.class),
+            frameworkTypeMemberSelect);
       case INSTANCE:
         return Snippet.format("%s.get()", frameworkTypeMemberSelect);
       case PROVIDER:
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/VariableWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/VariableWriter.java
index 44d1a11b7..00dc29434 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/VariableWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/VariableWriter.java
@@ -3,13 +3,15 @@
 import java.io.IOException;
 import java.util.Set;
 
+import static com.google.common.base.Preconditions.checkNotNull;
+
 public class VariableWriter extends Modifiable implements Writable, HasClassReferences {
   private final TypeName type;
   private final String name;
 
   VariableWriter(TypeName type, String name) {
-    this.type = type;
-    this.name = name;
+    this.type = checkNotNull(type);
+    this.name = checkNotNull(name);
   }
 
   public TypeName type() {
