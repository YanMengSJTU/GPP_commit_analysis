diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java b/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java
index 0813b2d77..3a6f970ba 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java
@@ -68,10 +68,12 @@ public synchronized void init(ProcessingEnvironment processingEnv) {
     Filer filer = processingEnv.getFiler();
     Elements elements = processingEnv.getElementUtils();
     Types types = processingEnv.getTypeUtils();
+    Key.Factory keyFactory = new Key.Factory(types, elements);
     DependencyRequest.Factory dependencyRequestFactory =
         new DependencyRequest.Factory(elements, types);
     ProviderTypeRepository providerTypeRepository = new ProviderTypeRepository(elements, types);
-    this.provisionBindingFactory = new ProvisionBinding.Factory(dependencyRequestFactory);
+    this.provisionBindingFactory =
+        new ProvisionBinding.Factory(keyFactory, dependencyRequestFactory);
     this.factoryWriter = new InjectConstructorFactoryGenerator(filer, providerTypeRepository);
     this.membersInjectionBindingFactory =
         new MembersInjectionBinding.Factory(dependencyRequestFactory);
diff --git a/compiler/src/main/java/dagger/internal/codegen/Key.java b/compiler/src/main/java/dagger/internal/codegen/Key.java
index 740ca59f3..2e2ff9aa1 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Key.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Key.java
@@ -20,6 +20,7 @@
 import static dagger.internal.codegen.InjectionAnnotations.getQualifier;
 import static javax.lang.model.element.ElementKind.CONSTRUCTOR;
 import static javax.lang.model.element.ElementKind.METHOD;
+import static javax.lang.model.type.TypeKind.DECLARED;
 
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Equivalence;
@@ -28,10 +29,17 @@
 
 import dagger.Provides;
 
+import java.util.Set;
+
 import javax.inject.Qualifier;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
 
 /**
  * Represents a unique combination of {@linkplain TypeMirror type} and
@@ -62,8 +70,6 @@ public String toString() {
         .toString();
   }
 
-  // TODO(gak): normalize boxed types
-
   static Key create(TypeMirror type) {
     return new AutoValue_Key(Optional.<AnnotationMirror>absent(), Mirrors.equivalence().wrap(type));
   }
@@ -72,27 +78,64 @@ static Key create(Optional<AnnotationMirror> qualifier, TypeMirror type) {
     return new AutoValue_Key(qualifier, Mirrors.equivalence().wrap(type));
   }
 
-  // TODO(gak): decide whether to address set bindings here or someplace else
-  static Key forProvidesMethod(ExecutableElement e) {
-    checkNotNull(e);
-    checkArgument(e.getKind().equals(METHOD));
-    checkArgument(e.getAnnotation(Provides.class) != null);
-    return new AutoValue_Key(getQualifier(e), Mirrors.equivalence().wrap(e.getReturnType()));
-  }
+  static final class Factory {
+    private final Types types;
+    private final Elements elements;
 
-  static Key forComponentMethod(ExecutableElement e) {
-    checkNotNull(e);
-    checkArgument(e.getKind().equals(METHOD));
-    checkArgument(e.getParameters().isEmpty());
-    return new AutoValue_Key(getQualifier(e), Mirrors.equivalence().wrap(e.getReturnType()));
-  }
+    Factory(Types types, Elements elements) {
+      this.types = checkNotNull(types);
+      this.elements = checkNotNull(elements);
+    }
 
-  static Key forInjectConstructor(ExecutableElement e) {
-    checkNotNull(e);
-    checkArgument(e.getKind().equals(CONSTRUCTOR));
-    checkArgument(!getQualifier(e).isPresent());
-    // Must use the enclosing element.  The return type is void for constructors(?!)
-    TypeMirror type = e.getEnclosingElement().asType();
-    return new AutoValue_Key(Optional.<AnnotationMirror>absent(), Mirrors.equivalence().wrap(type));
+    private TypeMirror normalize(TypeMirror type) {
+      TypeKind kind = type.getKind();
+      return kind.isPrimitive() ? types.getPrimitiveType(kind) : type;
+    }
+
+    private TypeElement getSetElement() {
+      return elements.getTypeElement(Set.class.getCanonicalName());
+    }
+
+    Key forProvidesMethod(ExecutableElement e) {
+      checkNotNull(e);
+      checkArgument(e.getKind().equals(METHOD));
+      Provides providesAnnotation = e.getAnnotation(Provides.class);
+      checkArgument(providesAnnotation != null);
+      TypeMirror returnType = normalize(e.getReturnType());
+      Optional<AnnotationMirror> qualifier = getQualifier(e);
+      switch (providesAnnotation.type()) {
+        case UNIQUE:
+          return new AutoValue_Key(qualifier, Mirrors.equivalence().wrap(returnType));
+        case SET:
+          TypeMirror setType = types.getDeclaredType(getSetElement(), returnType);
+          return new AutoValue_Key(qualifier, Mirrors.equivalence().wrap(setType));
+        case SET_VALUES:
+          // TODO(gak): do we want to allow people to use "covariant return" here?
+          checkArgument(returnType.getKind().equals(DECLARED));
+          checkArgument(((DeclaredType) returnType).asElement().equals(getSetElement()));
+          return new AutoValue_Key(qualifier, Mirrors.equivalence().wrap(returnType));
+        default:
+          throw new AssertionError();
+      }
+    }
+
+    Key forComponentMethod(ExecutableElement e) {
+      checkNotNull(e);
+      checkArgument(e.getKind().equals(METHOD));
+      checkArgument(e.getParameters().isEmpty());
+      return new AutoValue_Key(getQualifier(e),
+          Mirrors.equivalence().wrap(normalize(e.getReturnType())));
+    }
+
+    Key forInjectConstructor(ExecutableElement e) {
+      checkNotNull(e);
+      checkArgument(e.getKind().equals(CONSTRUCTOR));
+      checkArgument(!getQualifier(e).isPresent());
+      // Must use the enclosing element.  The return type is void for constructors(?!)
+      TypeMirror type = e.getEnclosingElement().asType();
+      return new AutoValue_Key(Optional.<AnnotationMirror>absent(),
+          Mirrors.equivalence().wrap(type));
+    }
   }
+
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
index ba2760043..329fcbd79 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
@@ -17,6 +17,7 @@
 
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
+import static dagger.Provides.Type.UNIQUE;
 import static dagger.internal.codegen.InjectionAnnotations.getScopeAnnotation;
 import static javax.lang.model.element.ElementKind.CONSTRUCTOR;
 import static javax.lang.model.element.ElementKind.FIELD;
@@ -54,10 +55,18 @@
   /** Returns {@code true} if this provision binding requires members to be injected implicitly. */
   abstract boolean requiresMemberInjection();
 
+  /**
+   * Returns {@code true} if this binding contributes to a single logical binding. I.e. multiple
+   * bindings are allowed for the same {@link Key}.
+   */
+  abstract boolean contributingBinding();
+
   static final class Factory {
+    private final Key.Factory keyFactory;
     private final DependencyRequest.Factory keyRequestFactory;
 
-    Factory(DependencyRequest.Factory keyRequestFactory) {
+    Factory(Key.Factory keyFactory, DependencyRequest.Factory keyRequestFactory) {
+      this.keyFactory = keyFactory;
       this.keyRequestFactory = keyRequestFactory;
     }
 
@@ -65,14 +74,15 @@ ProvisionBinding forInjectConstructor(ExecutableElement constructorElement) {
       checkNotNull(constructorElement);
       checkArgument(constructorElement.getKind().equals(CONSTRUCTOR));
       checkArgument(constructorElement.getAnnotation(Inject.class) != null);
-      Key key = Key.forInjectConstructor(constructorElement);
+      Key key = keyFactory.forInjectConstructor(constructorElement);
       checkArgument(!key.qualifier().isPresent());
       return new AutoValue_ProvisionBinding(constructorElement,
           keyRequestFactory.forVariables(constructorElement.getParameters()),
           key,
           getScopeAnnotation(constructorElement.getEnclosingElement()),
           requiresMemeberInjection(
-              ElementUtil.asTypeElement(constructorElement.getEnclosingElement())));
+              ElementUtil.asTypeElement(constructorElement.getEnclosingElement())),
+          false);
     }
 
     private static final ImmutableSet<ElementKind> MEMBER_KINDS =
@@ -90,13 +100,15 @@ private static boolean requiresMemeberInjection(TypeElement type) {
 
     ProvisionBinding forProvidesMethod(ExecutableElement providesMethod) {
       checkNotNull(providesMethod);
-      checkArgument(providesMethod.getKind().equals(CONSTRUCTOR));
-      checkArgument(providesMethod.getAnnotation(Provides.class) != null);
+      checkArgument(providesMethod.getKind().equals(METHOD));
+      Provides providesAnnotation = providesMethod.getAnnotation(Provides.class);
+      checkArgument(providesAnnotation != null);
       return new AutoValue_ProvisionBinding(providesMethod,
           keyRequestFactory.forVariables(providesMethod.getParameters()),
-          Key.forProvidesMethod(providesMethod),
+          keyFactory.forProvidesMethod(providesMethod),
           getScopeAnnotation(providesMethod),
-          false);
+          false,
+          !providesAnnotation.type().equals(UNIQUE));
     }
   }
 }
diff --git a/compiler/src/test/java/dagger/internal/codegen/KeyTest.java b/compiler/src/test/java/dagger/internal/codegen/KeyTest.java
index 040b6bf32..3b1d41ae6 100644
--- a/compiler/src/test/java/dagger/internal/codegen/KeyTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/KeyTest.java
@@ -15,6 +15,8 @@
  */
 package dagger.internal.codegen;
 
+import static dagger.Provides.Type.SET;
+import static dagger.Provides.Type.SET_VALUES;
 import static org.truth0.Truth.ASSERT;
 
 import com.google.common.collect.Iterables;
@@ -23,18 +25,23 @@
 import dagger.Module;
 import dagger.Provides;
 
-import org.junit.Rule;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
+import java.util.Set;
 
 import javax.inject.Inject;
 import javax.inject.Qualifier;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.ElementFilter;
 import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
+
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
 
 /**
  * Tests {@link Key}.
@@ -43,12 +50,19 @@
 public class KeyTest {
   @Rule public CompilationRule compilationRule = new CompilationRule();
 
+  private Key.Factory keyFactory;
+
+  @Before public void setUp() {
+    this.keyFactory = new Key.Factory(compilationRule.getTypes(), compilationRule.getElements());
+  }
+
   @Test public void forInjectConstructor() {
     TypeElement typeElement =
         compilationRule.getElements().getTypeElement(InjectedClass.class.getCanonicalName());
     ExecutableElement constructor =
         Iterables.getOnlyElement(ElementFilter.constructorsIn(typeElement.getEnclosedElements()));
-    ASSERT.that(Key.forInjectConstructor(constructor)).isEqualTo(Key.create(typeElement.asType()));
+    ASSERT.that(keyFactory.forInjectConstructor(constructor))
+        .isEqualTo(Key.create(typeElement.asType()));
   }
 
   static final class InjectedClass {
@@ -63,7 +77,7 @@
         elements.getTypeElement(ProvidesMethodModule.class.getCanonicalName());
     ExecutableElement providesMethod =
         Iterables.getOnlyElement(ElementFilter.methodsIn(moduleElement.getEnclosedElements()));
-    ASSERT.that(Key.forProvidesMethod(providesMethod)).isEqualTo(Key.create(stringType));
+    ASSERT.that(keyFactory.forProvidesMethod(providesMethod)).isEqualTo(Key.create(stringType));
   }
 
   @Module(library = true)
@@ -82,7 +96,7 @@
         elements.getTypeElement(QualifiedProvidesMethodModule.class.getCanonicalName());
     ExecutableElement providesMethod =
         Iterables.getOnlyElement(ElementFilter.methodsIn(moduleElement.getEnclosedElements()));
-    Key key = Key.forProvidesMethod(providesMethod);
+    Key key = keyFactory.forProvidesMethod(providesMethod);
     ASSERT.that(Mirrors.equivalence().wrap(key.qualifier().get().getAnnotationType()))
         .isEqualTo(Mirrors.equivalence().wrap(qualifierElement.asType()));
     ASSERT.that(key.wrappedType()).isEqualTo(Mirrors.equivalence().wrap(stringType));
@@ -97,4 +111,30 @@
 
   @Qualifier
   @interface TestQualifier {}
+
+  @Test public void forProvidesMethod_sets() {
+    Elements elements = compilationRule.getElements();
+    Types types = compilationRule.getTypes();
+    TypeElement setElement = elements.getTypeElement(Set.class.getCanonicalName());
+    TypeMirror stringType = elements.getTypeElement(String.class.getCanonicalName()).asType();
+    DeclaredType setOfStringsType = types.getDeclaredType(setElement, stringType);
+    TypeElement moduleElement =
+        elements.getTypeElement(SetProvidesMethodsModule.class.getCanonicalName());
+    for (ExecutableElement providesMethod
+        : ElementFilter.methodsIn(moduleElement.getEnclosedElements())) {
+      ASSERT.that(keyFactory.forProvidesMethod(providesMethod))
+          .isEqualTo(Key.create(setOfStringsType));
+    }
+  }
+
+  @Module(library = true)
+  static final class SetProvidesMethodsModule {
+    @Provides(type = SET) String provideString() {
+      return null;
+    }
+
+    @Provides(type = SET_VALUES) Set<String> provideStrings() {
+      return null;
+    }
+  }
 }
