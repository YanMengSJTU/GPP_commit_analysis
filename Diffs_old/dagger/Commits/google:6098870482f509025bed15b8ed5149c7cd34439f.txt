diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
index 98a8c8c1e..134f79e3d 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
@@ -20,7 +20,6 @@
 import com.google.common.base.Functions;
 import com.google.common.base.Joiner;
 import com.google.common.base.Optional;
-import com.google.common.collect.ImmutableBiMap;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
@@ -49,6 +48,7 @@
 import dagger.internal.codegen.writer.TypeNames;
 import dagger.internal.codegen.writer.VoidName;
 import java.util.List;
+import java.util.Map;
 import java.util.Map.Entry;
 import java.util.Set;
 import javax.annotation.Generated;
@@ -133,14 +133,16 @@ JavaWriter write(ClassName componentName, ComponentDescriptor input)  {
     ImmutableMap<Key, MembersInjectionBinding> resolvedMembersInjectionBindings =
         input.resolvedMembersInjectionBindings();
 
-    ImmutableBiMap<Key, String> providerNames =
+    ImmutableMap<Key, String> providerNames =
         generateProviderNamesForBindings(resolvedProvisionBindings);
-    ImmutableBiMap<Key, String> membersInjectorNames =
+    Map<Key, FieldWriter> providerFields = Maps.newHashMap();
+    ImmutableMap<Key, String> membersInjectorNames =
         generateMembersInjectorNamesForBindings(resolvedMembersInjectionBindings);
+    Map<Key, FieldWriter> membersInjectorFields = Maps.newHashMap();
 
     // the full set of types that calling code uses to construct a component instance
-    ImmutableBiMap<TypeElement, String> componentContributionNames =
-        ImmutableBiMap.copyOf(Maps.asMap(
+    ImmutableMap<TypeElement, String> componentContributionNames =
+        ImmutableMap.copyOf(Maps.asMap(
             Sets.union(input.moduleDependencies(), input.dependencies()),
             Functions.compose(
                 CaseFormat.UPPER_CAMEL.converterTo(LOWER_CAMEL),
@@ -160,42 +162,47 @@ JavaWriter write(ClassName componentName, ComponentDescriptor input)  {
 
     boolean requiresBuilder = false;
 
+    Map<TypeElement, FieldWriter> componentContributionFields = Maps.newHashMap();
+
     for (Entry<TypeElement, String> entry : componentContributionNames.entrySet()) {
-      TypeElement moduleElement = entry.getKey();
-      String moduleName = entry.getValue();
-      componentWriter.addField(moduleElement, moduleName)
-          .addModifiers(PRIVATE, FINAL);
-      builderWriter.addField(moduleElement, moduleName)
-          .addModifiers(PRIVATE);
+      TypeElement contributionElement = entry.getKey();
+      String contributionName = entry.getValue();
+      FieldWriter contributionField =
+          componentWriter.addField(contributionElement, contributionName);
+      contributionField.addModifiers(PRIVATE, FINAL);
+      componentContributionFields.put(contributionElement, contributionField);
+      FieldWriter builderField = builderWriter.addField(contributionElement, contributionName);
+      builderField.addModifiers(PRIVATE);
       constructorWriter.body()
-          .addSnippet("this.%1$s = builder.%1$s;", moduleName);
-      MethodWriter builderMethod = builderWriter.addMethod(builderWriter, moduleName);
+          .addSnippet("this.%1$s = builder.%1$s;", contributionField.name());
+      MethodWriter builderMethod = builderWriter.addMethod(builderWriter, contributionName);
       builderMethod.addModifiers(PUBLIC);
-      builderMethod.addParameter(moduleElement, moduleName);
+      builderMethod.addParameter(contributionElement, contributionName);
       builderMethod.body()
-          .addSnippet("if (%s == null) {", moduleName)
-          .addSnippet("  throw new NullPointerException(%s);", StringLiteral.forValue(moduleName))
+          .addSnippet("if (%s == null) {", contributionName)
+          .addSnippet("  throw new NullPointerException(%s);",
+              StringLiteral.forValue(contributionName))
           .addSnippet("}")
-          .addSnippet("this.%1$s = %1$s;", moduleName)
+          .addSnippet("this.%s = %s;", builderField.name(), contributionName)
           .addSnippet("return this;");
-      if (Util.getNoArgsConstructor(moduleElement) == null) {
+      if (Util.getNoArgsConstructor(contributionElement) == null) {
         requiresBuilder = true;
         buildMethod.body()
-            .addSnippet("if (%s == null) {", moduleName)
-            .addSnippet("  throw new IllegalStateException(\"%s must be set\");", moduleName)
+            .addSnippet("if (%s == null) {", builderField.name())
+            .addSnippet("  throw new IllegalStateException(\"%s must be set\");",
+                builderField.name())
             .addSnippet("}");
       } else {
         buildMethod.body()
-            .addSnippet("if (%s == null) {", moduleName)
+            .addSnippet("if (%s == null) {", builderField.name())
             .addSnippet("  this.%s = new %s();",
-                moduleName, ClassName.fromTypeElement(moduleElement))
+                builderField.name(), ClassName.fromTypeElement(contributionElement))
             .addSnippet("}");
       }
     }
 
     buildMethod.body().addSnippet("return new %s(this);", componentWriter.name());
 
-    // this will eventually need to be modules & components
     if (!requiresBuilder) {
       MethodWriter factoryMethod = componentWriter.addMethod(componentDefinitionTypeName, "create");
       factoryMethod.addModifiers(PUBLIC, STATIC);
@@ -212,16 +219,19 @@ JavaWriter write(ClassName componentName, ComponentDescriptor input)  {
       FieldWriter providerField =
           componentWriter.addField(providerTypeReferece, providerEntry.getValue());
       providerField.addModifiers(PRIVATE, FINAL);
+      providerFields.put(key, providerField);
     }
-    for (Entry<Key, String> providerEntry : membersInjectorNames.entrySet()) {
-      Key key = providerEntry.getKey();
+
+    for (Entry<Key, String> membersInjectorEntry : membersInjectorNames.entrySet()) {
+      Key key = membersInjectorEntry.getKey();
       // TODO(gak): provide more elaborate information about which requests relate
       TypeName membersInjectorTypeReferece = ParameterizedTypeName.create(
           ClassName.fromClass(MembersInjector.class),
           TypeNames.forTypeMirror(key.type()));
       FieldWriter membersInjectorField =
-          componentWriter.addField(membersInjectorTypeReferece, providerEntry.getValue());
+          componentWriter.addField(membersInjectorTypeReferece, membersInjectorEntry.getValue());
       membersInjectorField.addModifiers(PRIVATE, FINAL);
+      membersInjectorFields.put(key, membersInjectorField);
     }
 
     for (FrameworkKey frameworkKey : input.initializationOrdering()) {
@@ -232,24 +242,24 @@ JavaWriter write(ClassName componentName, ComponentDescriptor input)  {
           ImmutableList.Builder<Snippet> setFactoryParameters = ImmutableList.builder();
           for (ProvisionBinding binding : bindings) {
             setFactoryParameters.add(initializeFactoryForBinding(
-                binding, componentContributionNames, providerNames,membersInjectorNames));
+                binding, componentContributionFields, providerFields, membersInjectorFields));
           }
           constructorWriter.body().addSnippet("this.%s = %s.create(%n%s);",
-              providerNames.get(key),
+              providerFields.get(key).name(),
               ClassName.fromClass(SetFactory.class),
               Snippet.makeParametersSnippet(setFactoryParameters.build()));
         } else {
           ProvisionBinding binding = Iterables.getOnlyElement(bindings);
           constructorWriter.body().addSnippet("this.%s = %s;",
-              providerNames.get(key),
+              providerFields.get(key).name(),
               initializeFactoryForBinding(
-                  binding, componentContributionNames, providerNames, membersInjectorNames));
+                  binding, componentContributionFields, providerFields, membersInjectorFields));
         }
       } else if (frameworkKey.frameworkClass().equals(MembersInjector.class)) {
         constructorWriter.body().addSnippet("this.%s = %s;",
-            membersInjectorNames.get(key),
+            membersInjectorFields.get(key).name(),
             initializeMembersInjectorForBinding(resolvedMembersInjectionBindings.get(key),
-                providerNames, membersInjectorNames));
+                providerFields, membersInjectorFields));
       } else {
         throw new IllegalStateException(
             "unknown framework class: " + frameworkKey.frameworkClass());
@@ -265,7 +275,7 @@ JavaWriter write(ClassName componentName, ComponentDescriptor input)  {
       interfaceMethod.annotate(Override.class);
       interfaceMethod.addModifiers(PUBLIC);
       if (interfaceRequest.kind().equals(MEMBERS_INJECTOR)) {
-        String membersInjectorName = membersInjectorNames.get(interfaceRequest.key());
+        String membersInjectorName = membersInjectorFields.get(interfaceRequest.key()).name();
         VariableElement parameter = Iterables.getOnlyElement(requestElement.getParameters());
         Name parameterName = parameter.getSimpleName();
         interfaceMethod.addParameter(
@@ -276,12 +286,10 @@ JavaWriter write(ClassName componentName, ComponentDescriptor input)  {
           interfaceMethod.body().addSnippet("return %s;", parameterName);
         }
       } else {
-        // provision requests
-        String providerName = providerNames.get(interfaceRequest.key());
-
-        // look up the provider in the Key->name map and invoke.  Done.
+        // look up the provider in the Key->field map and invoke.  Done.
         interfaceMethod.body().addSnippet("return %s;",
-            frameworkTypeUsageStatement(providerName, interfaceRequest.kind()));
+            frameworkTypeUsageStatement(providerFields.get(interfaceRequest.key()).name(),
+                interfaceRequest.kind()));
       }
     }
 
@@ -289,9 +297,9 @@ JavaWriter write(ClassName componentName, ComponentDescriptor input)  {
   }
 
   private Snippet initializeFactoryForBinding(ProvisionBinding binding,
-      ImmutableBiMap<TypeElement, String> moduleNames,
-      ImmutableBiMap<Key, String> providerNames,
-      ImmutableBiMap<Key, String> membersInjectorNames) {
+      Map<TypeElement, FieldWriter> contributionFields,
+      Map<Key, FieldWriter> providerFields,
+      Map<Key, FieldWriter> membersInjectorFields) {
     if (binding.bindingKind().equals(COMPONENT)) {
       return Snippet.format("%s.<%s>create(this)",
           ClassName.fromClass(InstanceFactory.class),
@@ -305,54 +313,54 @@ private Snippet initializeFactoryForBinding(ProvisionBinding binding,
           "}"),
           ClassName.fromClass(Factory.class),
           TypeNames.forTypeMirror(binding.providedKey().type()),
-          moduleNames.get(binding.bindingTypeElement()),
+          contributionFields.get(binding.bindingTypeElement()).name(),
           binding.bindingElement().getSimpleName().toString());
     } else {
       List<String> parameters = Lists.newArrayListWithCapacity(binding.dependencies().size() + 1);
       if (binding.bindingKind().equals(PROVISION)) {
-        parameters.add(moduleNames.get(binding.bindingTypeElement()));
+        parameters.add(contributionFields.get(binding.bindingTypeElement()).name());
       }
       if (binding.requiresMemberInjection()) {
-        String membersInjectorName =
-            membersInjectorNames.get(keyFactory.forType(binding.providedKey().type()));
-        if (membersInjectorName != null) {
-          parameters.add(membersInjectorName);
+        FieldWriter membersInjectorField =
+            membersInjectorFields.get(keyFactory.forType(binding.providedKey().type()));
+        if (membersInjectorField != null) {
+          parameters.add(membersInjectorField.name());
         } else {
           throw new UnsupportedOperationException("Non-generated MembersInjector");
         }
       }
       parameters.addAll(
-          getDependencyParameters(binding.dependencies(), providerNames, membersInjectorNames));
+          getDependencyParameters(binding.dependencies(), providerFields, membersInjectorFields));
       return binding.scope().isPresent()
           ? Snippet.format("%s.create(new %s(%s))",
               ClassName.fromClass(ScopedProvider.class),
-              factoryNameForProvisionBinding(binding).toString(),
+              factoryNameForProvisionBinding(binding),
               Joiner.on(", ").join(parameters))
           : Snippet.format("new %s(%s)",
-              factoryNameForProvisionBinding(binding).toString(),
+              factoryNameForProvisionBinding(binding),
               Joiner.on(", ").join(parameters));
     }
   }
 
   private static Snippet initializeMembersInjectorForBinding(
       MembersInjectionBinding binding,
-      ImmutableBiMap<Key, String> providerNames,
-      ImmutableBiMap<Key, String> membersInjectorNames) {
+      Map<Key, FieldWriter> providerFields,
+      Map<Key, FieldWriter> membersInjectorFields) {
     List<String> parameters = getDependencyParameters(binding.dependencySet(),
-        providerNames, membersInjectorNames);
+        providerFields, membersInjectorFields);
     return Snippet.format("new %s(%s)",
        membersInjectorNameForMembersInjectionBinding(binding).toString(),
         Joiner.on(", ").join(parameters));
   }
 
   private static List<String> getDependencyParameters(Iterable<DependencyRequest> dependencies,
-      ImmutableBiMap<Key, String> providerNames,
-      ImmutableBiMap<Key, String> membersInjectorNames) {
+      Map<Key, FieldWriter> providerFields,
+      Map<Key, FieldWriter> membersInjectorFields) {
     ImmutableList.Builder<String> parameters = ImmutableList.builder();
     for (DependencyRequest dependency : dependencies) {
         parameters.add(dependency.kind().equals(MEMBERS_INJECTOR)
-            ? membersInjectorNames.get(dependency.key())
-            : providerNames.get(dependency.key()));
+            ? membersInjectorFields.get(dependency.key()).name()
+            : providerFields.get(dependency.key()).name());
     }
     return parameters.build();
   }
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
index 5152f027d..c72b24ce8 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
@@ -17,16 +17,12 @@
 
 import com.google.common.base.CaseFormat;
 import com.google.common.base.Function;
-import com.google.common.collect.BiMap;
 import com.google.common.collect.ComparisonChain;
 import com.google.common.collect.FluentIterable;
-import com.google.common.collect.HashBiMap;
-import com.google.common.collect.ImmutableBiMap;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ImmutableSetMultimap;
-import com.google.common.collect.ImmutableSortedMap;
 import com.google.common.collect.ImmutableSortedSet;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Maps;
@@ -182,9 +178,9 @@
   }
 
   // TODO(gak): this needs to suck less
-  static ImmutableBiMap<Key, String> generateProviderNamesForBindings(
+  static ImmutableMap<Key, String> generateProviderNamesForBindings(
       SetMultimap<Key, ProvisionBinding> bindings) {
-    BiMap<Key, String> providerNames = HashBiMap.create(bindings.size());
+    ImmutableMap.Builder<Key, String> providerNames = ImmutableMap.builder();
     for (Entry<Key, Collection<ProvisionBinding>> entry : bindings.asMap().entrySet()) {
       Collection<ProvisionBinding> bindingsForKey = entry.getValue();
       final String name;
@@ -213,13 +209,24 @@ public String visitType(TypeElement e, Void p) {
       }
       providerNames.put(entry.getKey(), name);
     }
-    // return the map so that it is sorted by name
-    return ImmutableBiMap.copyOf(ImmutableSortedMap.copyOf(providerNames.inverse())).inverse();
+    Ordering<Entry<?, String>> entryValueOrdering =
+        Ordering.natural().onResultOf(new Function<Entry<?, String>, String>() {
+          @Override
+          public String apply(Entry<?, String> input) {
+            return input.getValue();
+          }
+        });
+    ImmutableMap.Builder<Key, String> sortedProviderNames = ImmutableMap.builder();
+    for (Entry<Key, String> providerNameEntry :
+      entryValueOrdering.sortedCopy(providerNames.build().entrySet())) {
+      sortedProviderNames.put(providerNameEntry);
+    }
+    return sortedProviderNames.build();
   }
 
-  static ImmutableBiMap<Key, String> generateMembersInjectorNamesForBindings(
+  static ImmutableMap<Key, String> generateMembersInjectorNamesForBindings(
       Map<Key, MembersInjectionBinding> bindings) {
-    return ImmutableBiMap.copyOf(Maps.transformValues(bindings,
+    return ImmutableMap.copyOf(Maps.transformValues(bindings,
         new Function<MembersInjectionBinding, String>() {
           @Override public String apply(MembersInjectionBinding input) {
             return CaseFormat.UPPER_CAMEL.to(CaseFormat.LOWER_CAMEL,
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/ClassWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/ClassWriter.java
index 727d22f22..27cda36ed 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/ClassWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/ClassWriter.java
@@ -5,10 +5,12 @@
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Lists;
+import com.google.common.collect.Maps;
 import com.google.common.collect.Sets;
 import java.io.IOException;
 import java.util.Iterator;
 import java.util.List;
+import java.util.Map;
 import java.util.Set;
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.TypeElement;
@@ -19,14 +21,14 @@
 
 public final class ClassWriter extends TypeWriter {
   private final List<TypeWriter> nestedTypeWriters;
-  private final List<FieldWriter> fieldWriters;
+  private final Map<String, FieldWriter> fieldWriters;
   private final List<ConstructorWriter> constructorWriters;
   private final List<TypeVariableName> typeVariables;
 
   ClassWriter(ClassName className) {
     super(className);
     this.nestedTypeWriters = Lists.newArrayList();
-    this.fieldWriters = Lists.newArrayList();
+    this.fieldWriters = Maps.newLinkedHashMap();
     this.constructorWriters = Lists.newArrayList();
     this.typeVariables = Lists.newArrayList();
   }
@@ -40,20 +42,22 @@ public void addImplementedType(TypeElement typeElement) {
   }
 
   public FieldWriter addField(Class<?> type, String name) {
-    FieldWriter fieldWriter = new FieldWriter(ClassName.fromClass(type), name);
-    fieldWriters.add(fieldWriter);
-    return fieldWriter;
+    return addField(ClassName.fromClass(type), name);
   }
 
   public FieldWriter addField(TypeElement type, String name) {
-    FieldWriter fieldWriter = new FieldWriter(ClassName.fromTypeElement(type), name);
-    fieldWriters.add(fieldWriter);
-    return fieldWriter;
+    return addField(ClassName.fromTypeElement(type), name);
   }
 
   public FieldWriter addField(TypeName type, String name) {
-    FieldWriter fieldWriter = new FieldWriter(type, name);
-    fieldWriters.add(fieldWriter);
+    String candidateName = name;
+    int differentiator = 1;
+    while (fieldWriters.containsKey(candidateName)) {
+      candidateName = name + differentiator;
+      differentiator++;
+    }
+    FieldWriter fieldWriter = new FieldWriter(type, candidateName);
+    fieldWriters.put(candidateName, fieldWriter);
     return fieldWriter;
   }
 
@@ -102,7 +106,7 @@ public Appendable write(Appendable appendable, Context context) throws IOExcepti
     if (!fieldWriters.isEmpty()) {
       appendable.append('\n');
     }
-    for (VariableWriter fieldWriter : fieldWriters) {
+    for (VariableWriter fieldWriter : fieldWriters.values()) {
       fieldWriter.write(new IndentingAppendable(appendable), context).append("\n");
     }
     for (ConstructorWriter constructorWriter : constructorWriters) {
@@ -135,8 +139,8 @@ private boolean isDefaultConstructor(ConstructorWriter constructorWriter) {
   @Override
   public Set<ClassName> referencedClasses() {
     Iterable<? extends HasClassReferences> concat =
-        Iterables.concat(nestedTypeWriters, fieldWriters, constructorWriters, methodWriters,
-            implementedTypes, supertype.asSet(), annotations);
+        Iterables.concat(nestedTypeWriters, fieldWriters.values(), constructorWriters,
+            methodWriters, implementedTypes, supertype.asSet(), annotations);
     return FluentIterable.from(concat)
         .transformAndConcat(new Function<HasClassReferences, Set<ClassName>>() {
           @Override
diff --git a/compiler/src/main/java/dagger/internal/codegen/writer/JavaWriter.java b/compiler/src/main/java/dagger/internal/codegen/writer/JavaWriter.java
index debb8f526..f57e354b3 100644
--- a/compiler/src/main/java/dagger/internal/codegen/writer/JavaWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/writer/JavaWriter.java
@@ -11,6 +11,7 @@
 import com.google.common.collect.Lists;
 import com.google.common.collect.Ordering;
 import com.google.common.collect.Sets;
+import com.google.common.escape.Escapers;
 import com.google.common.io.Closer;
 import dagger.internal.codegen.writer.Writable.Context;
 import java.io.IOException;
@@ -249,7 +250,7 @@ public String compressTypesWithin(String snippet) {
       StringBuffer buffer = new StringBuffer();
       while (matcher.find()) {
         matcher.appendReplacement(buffer, collidesWithVisibleClass(matcher.group(1))
-            ? matcher.group()
+            ? Escapers.builder().addEscape('$', "\\$").build().escape(matcher.group())
             : "$1$2");
       }
       matcher.appendTail(buffer);
diff --git a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
index 90a680d92..dcd0de0b4 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
@@ -921,4 +921,128 @@
         .compilesWithoutError()
         .and().generatesSources(generatedComponent);
   }
+
+  @Test public void moduleNameCollision() {
+    JavaFileObject aFile = JavaFileObjects.forSourceLines("test.A",
+        "package test;",
+        "",
+        "public final class A {}");
+    JavaFileObject otherAFile = JavaFileObjects.forSourceLines("other.test.A",
+        "package other.test;",
+        "",
+        "public final class A {}");
+
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "public final class TestModule {",
+        "  @Provides A a() { return null; }",
+        "}");
+    JavaFileObject otherModuleFile = JavaFileObjects.forSourceLines("other.test.TestModule",
+        "package other.test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "public final class TestModule {",
+        "  @Provides A a() { return null; }",
+        "}");
+
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component(modules = {TestModule.class, other.test.TestModule.class})",
+        "interface TestComponent {",
+        "  A a();",
+        "  other.test.A otherA();",
+        "}");
+    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
+        "test.Dagger_TestComponent",
+        "package test;",
+        "",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "import other.test.A;",
+        "import other.test.TestModule;",
+        "import other.test.TestModule$$AFactory;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class Dagger_TestComponent implements TestComponent {",
+        "  private final test.TestModule testModule;",
+        "  private final TestModule testModule1;",
+        "  private final Provider<A> aProvider;",
+        "  private final Provider<test.A> aProvider1;",
+        "",
+        "  private Dagger_TestComponent(Builder builder) {",
+        "    assert builder != null;",
+        "    this.testModule = builder.testModule;",
+        "    this.testModule1 = builder.testModule1;",
+        "    this.aProvider1 = new test.TestModule$$AFactory(testModule);",
+        "    this.aProvider = new TestModule$$AFactory(testModule1);",
+        "  }",
+        "",
+        "  public static Builder builder() {",
+        "    return new Builder();",
+        "  }",
+        "",
+        "  public static TestComponent create() {",
+        "    return builder().build();",
+        "  }",
+        "",
+        "  @Override public test.A a() {",
+        "    return aProvider1.get();",
+        "  }",
+        "",
+        "  @Override public A otherA() {",
+        "    return aProvider.get();",
+        "  }",
+        "",
+        "  public static final class Builder {",
+        "    private test.TestModule testModule;",
+        "    private TestModule testModule1;",
+        "",
+        "    private Builder() {}",
+        "",
+        "    public TestComponent build() {",
+        "      if (testModule == null) {",
+        "        this.testModule = new test.TestModule();",
+        "      }",
+        "      if (testModule1 == null) {",
+        "        this.testModule1 = new TestModule();",
+        "      }",
+        "      return new Dagger_TestComponent(this);",
+        "    }",
+        "",
+        "    public Builder testModule(test.TestModule testModule) {",
+        "      if (testModule == null) {",
+        "        throw new NullPointerException(\"testModule\");",
+        "      }",
+        "      this.testModule = testModule;",
+        "      return this;",
+        "    }",
+        "",
+        "    public Builder testModule(TestModule testModule) {",
+        "      if (testModule == null) {",
+        "        throw new NullPointerException(\"testModule\");",
+        "      }",
+        "      this.testModule1 = testModule;",
+        "      return this;",
+        "    }",
+        "  }",
+        "}");
+    assert_().about(javaSources())
+        .that(ImmutableList.of(aFile, otherAFile, moduleFile, otherModuleFile, componentFile))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(generatedComponent);
+  }
 }
