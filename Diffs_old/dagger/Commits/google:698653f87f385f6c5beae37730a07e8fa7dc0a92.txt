diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
index 031841ba1..c4cd6c541 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -542,7 +542,7 @@ private boolean useRawType(Optional<String> bindingPackage) {
           switch (contributionBinding.bindingKind()) {
             case SYNTHETIC_MULTIBOUND_MAP:
               BindingType bindingType = contributionBinding.bindingType();
-              MapType mapType = MapType.from(contributionBinding.key().type());
+              MapType mapType = MapType.from(contributionBinding.key());
               return Optional.of(
                   emptyFrameworkMapFactory(
                       frameworkMapFactoryClassName(bindingType),
@@ -586,7 +586,7 @@ private boolean useRawType(Optional<String> bindingPackage) {
    * bindings.
    */
   private static MemberSelect emptySetFactoryStaticMemberSelect(BindingType bindingType, Key key) {
-    return emptySetProvider(setFactoryClassName(bindingType, key), SetType.from(key.type()));
+    return emptySetProvider(setFactoryClassName(bindingType, key), SetType.from(key));
   }
 
   /**
@@ -602,7 +602,7 @@ private static ClassName setFactoryClassName(BindingType bindingType, Key key) {
     if (bindingType.equals(BindingType.PROVISION)) {
       return SET_FACTORY;
     } else {
-      SetType setType = SetType.from(key.type());
+      SetType setType = SetType.from(key);
       return setType.elementsAreTypeOf(Produced.class) ? SET_OF_PRODUCED_PRODUCER : SET_PRODUCER;
     }
   }
@@ -618,7 +618,7 @@ private static ClassName setFactoryClassName(BindingType bindingType, Key key) {
   private static ClassName mapFactoryClassName(ContributionBinding binding) {
     switch (binding.bindingType()) {
       case PRODUCTION:
-        return MapType.from(binding.key().type()).valuesAreTypeOf(Produced.class)
+        return MapType.from(binding.key()).valuesAreTypeOf(Produced.class)
             ? MAP_OF_PRODUCED_PRODUCER : MAP_PRODUCER;
 
       case PROVISION:
@@ -1123,7 +1123,7 @@ private CodeBlock initializeFactoryForSetMultibinding(ContributionBinding bindin
         CodeBlock.builder().add("$T.", setFactoryClassName(binding.bindingType(), binding.key()));
     boolean useRawTypes = useRawType(binding);
     if (!useRawTypes) {
-      SetType setType = SetType.from(binding.key().type());
+      SetType setType = SetType.from(binding.key());
       builder.add(
           "<$T>",
           setType.elementsAreTypeOf(Produced.class)
diff --git a/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
index 27b6c7442..fe22d2b11 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
@@ -184,9 +184,9 @@ public Kind apply(ContributionBinding binding) {
      */
     static Kind forMultibindingRequest(DependencyRequest request) {
       Key key = request.key();
-      if (SetType.isSet(key.type())) {
+      if (SetType.isSet(key)) {
         return SYNTHETIC_MULTIBOUND_SET;
-      } else if (MapType.isMap(key.type())) {
+      } else if (MapType.isMap(key)) {
         return SYNTHETIC_MULTIBOUND_MAP;
       } else {
         throw new IllegalArgumentException(
@@ -244,9 +244,9 @@ FactoryCreationStrategy factoryCreationStrategy() {
   final TypeMirror factoryType() {
     switch (contributionType()) {
       case MAP:
-        return MapType.from(key().type()).unwrappedValueType(frameworkClass());
+        return MapType.from(key()).unwrappedValueType(frameworkClass());
       case SET:
-        return SetType.from(key().type()).elementType();
+        return SetType.from(key()).elementType();
       case SET_VALUES:
       case UNIQUE:
         return key().type();
diff --git a/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java b/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java
index 3d1951809..87d626b5d 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java
@@ -77,10 +77,10 @@ private static TypeMirror fieldValueType(ResolvedBindings resolvedBindings) {
     if (resolvedBindings.isMultibindingContribution()) {
       switch (resolvedBindings.contributionType()) {
         case MAP:
-          return MapType.from(resolvedBindings.key().type())
+          return MapType.from(resolvedBindings.key())
               .unwrappedValueType(resolvedBindings.frameworkClass());
         case SET:
-          return SetType.from((resolvedBindings.key().type())).elementType();
+          return SetType.from(resolvedBindings.key()).elementType();
         default:
           // do nothing
       }
diff --git a/compiler/src/main/java/dagger/internal/codegen/Key.java b/compiler/src/main/java/dagger/internal/codegen/Key.java
index 7e39125f1..29f804b3b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Key.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Key.java
@@ -484,8 +484,8 @@ Key forProductionImplementationExecutor() {
     private Optional<Key> maybeRewrapMapValue(
         Key possibleMapKey, Class<?> currentWrappingClass, Class<?> newWrappingClass) {
       checkArgument(!currentWrappingClass.equals(newWrappingClass));
-      if (MapType.isMap(possibleMapKey.type())) {
-        MapType mapType = MapType.from(possibleMapKey.type());
+      if (MapType.isMap(possibleMapKey)) {
+        MapType mapType = MapType.from(possibleMapKey);
         if (mapType.valuesAreTypeOf(currentWrappingClass)) {
           TypeElement wrappingElement = getClassElement(newWrappingClass);
           if (wrappingElement == null) {
@@ -509,8 +509,8 @@ Key forProductionImplementationExecutor() {
      * {@code Map<K, V>}.
      */
     private Optional<Key> maybeWrapMapValue(Key possibleMapKey, Class<?> wrappingClass) {
-      if (MapType.isMap(possibleMapKey.type())) {
-        MapType mapType = MapType.from(possibleMapKey.type());
+      if (MapType.isMap(possibleMapKey)) {
+        MapType mapType = MapType.from(possibleMapKey);
         if (!mapType.valuesAreTypeOf(wrappingClass)) {
           TypeElement wrappingElement = getClassElement(wrappingClass);
           if (wrappingElement == null) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/MapType.java b/compiler/src/main/java/dagger/internal/codegen/MapType.java
index 5c0faf820..aa481cf0b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MapType.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MapType.java
@@ -103,6 +103,13 @@ static boolean isMap(TypeMirror type) {
     return MoreTypes.isType(type) && MoreTypes.isTypeOf(Map.class, type);
   }
 
+  /**
+   * {@code true} if {@code key.type()} is a {@link Map} type.
+   */
+  static boolean isMap(Key key) {
+    return isMap(key.type());
+  }
+
   /**
    * Returns a {@link MapType} for {@code type}.
    *
@@ -112,4 +119,13 @@ static MapType from(TypeMirror type) {
     checkArgument(isMap(type), "%s is not a Map", type);
     return new AutoValue_MapType(MoreTypes.equivalence().wrap(MoreTypes.asDeclared(type)));
   }
+
+  /**
+   * Returns a {@link MapType} for {@code key}'s {@link Key#type() type}.
+   *
+   * @throws IllegalArgumentException if {@code key.type()} is not a {@link Map} type
+   */
+  static MapType from(Key key) {
+    return from(key.type());
+  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/SetType.java b/compiler/src/main/java/dagger/internal/codegen/SetType.java
index 23e95c7f7..9b55eed87 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SetType.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SetType.java
@@ -87,6 +87,13 @@ static boolean isSet(TypeMirror type) {
     return MoreTypes.isType(type) && MoreTypes.isTypeOf(Set.class, type);
   }
 
+  /**
+   * {@code true} if {@code key.type()} is a {@link Set} type.
+   */
+  static boolean isSet(Key key) {
+    return isSet(key.type());
+  }
+
   /**
    * Returns a {@link SetType} for {@code type}.
    *
@@ -96,4 +103,13 @@ static SetType from(TypeMirror type) {
     checkArgument(isSet(type), "%s must be a Set", type);
     return new AutoValue_SetType(MoreTypes.equivalence().wrap(MoreTypes.asDeclared(type)));
   }
+
+  /**
+   * Returns a {@link SetType} for {@code key}'s {@link Key#type() type}.
+   *
+   * @throws IllegalArgumentException if {@code key.type()} is not a {@link Set} type
+   */
+  static SetType from(Key key) {
+    return from (key.type());
+  }
 }
