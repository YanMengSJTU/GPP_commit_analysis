diff --git a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
index 79da42d4a..ee81a84a4 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
@@ -15,6 +15,8 @@
  */
 package dagger.internal.codegen;
 
+import com.google.auto.common.MoreElements;
+import com.google.common.base.Joiner;
 import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
@@ -30,11 +32,13 @@
 import dagger.internal.codegen.writer.MethodWriter;
 import dagger.internal.codegen.writer.ParameterizedTypeName;
 import dagger.internal.codegen.writer.Snippet;
+import dagger.internal.codegen.writer.StringLiteral;
 import dagger.internal.codegen.writer.TypeName;
 import dagger.internal.codegen.writer.TypeNames;
 import java.util.Collections;
 import java.util.List;
 import java.util.Map.Entry;
+import java.util.logging.Logger;
 import javax.annotation.Generated;
 import javax.annotation.processing.Filer;
 import javax.inject.Inject;
@@ -42,6 +46,7 @@
 import javax.lang.model.element.Element;
 import javax.lang.model.type.TypeMirror;
 
+import static dagger.Provides.Type.SET;
 import static dagger.internal.codegen.ProvisionBinding.Kind.PROVISION;
 import static dagger.internal.codegen.SourceFiles.factoryNameForProvisionBinding;
 import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
@@ -49,6 +54,7 @@
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.PUBLIC;
+import static javax.lang.model.element.Modifier.STATIC;
 
 /**
  * Generates {@link Factory} implementations from {@link ProvisionBinding} instances for
@@ -92,6 +98,16 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
         ClassName.fromClass(Factory.class),
         providedTypeName));
 
+    // TODO(gak): stop doing this weird thing with the optional when javawriter lets me put fields
+    // in arbitrary places
+    Optional<FieldWriter> loggerField = Optional.absent();
+    if (binding.bindingKind().equals(PROVISION)) {
+      loggerField = Optional.of(factoryWriter.addField(Logger.class, "logger"));
+      loggerField.get().addModifiers(PRIVATE, STATIC, FINAL);
+      loggerField.get().setInitializer("%s.getLogger(%s.class.getCanonicalName())",
+          ClassName.fromClass(Logger.class), factoryWriter.name());
+    }
+
     MethodWriter getMethodWriter = factoryWriter.addMethod(keyType, "get");
     getMethodWriter.annotate(Override.class);
     getMethodWriter.addModifiers(PUBLIC);
@@ -150,20 +166,28 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
     Snippet parametersSnippet = makeParametersSnippet(parameters);
 
     if (binding.bindingKind().equals(PROVISION)) {
-      switch (binding.provisionType()) {
-        case UNIQUE:
-        case MAP: 
-        case SET_VALUES:
-          getMethodWriter.body().addSnippet("return module.%s(%s);",
-              binding.bindingElement().getSimpleName(), parametersSnippet);
-          break;
-        case SET:
-          getMethodWriter.body().addSnippet("return %s.singleton(module.%s(%s));",
-              ClassName.fromClass(Collections.class),
-              binding.bindingElement().getSimpleName(), parametersSnippet);
-          break;
-        default:
-          throw new AssertionError();
+      TypeMirror providesMethodReturnType =
+          MoreElements.asExecutable(binding.bindingElement()).getReturnType();
+      getMethodWriter.body().addSnippet("%s result = module.%s(%s);",
+          TypeNames.forTypeMirror(providesMethodReturnType),
+          binding.bindingElement().getSimpleName(), parametersSnippet);
+      if (!providesMethodReturnType.getKind().isPrimitive()) {
+        getMethodWriter.body().addSnippet(Joiner.on('\n').join(
+            "if (result == null) {",
+            "  %s.warning(%s);",
+            "}"),
+            loggerField.get().name(),
+            StringLiteral.forValue(String.format(
+                "%s.%s provided null. "
+                    + "This is not allowed and will soon throw a NullPointerException.",
+                    binding.bindingTypeElement().getQualifiedName(),
+                    binding.bindingElement())));
+      }
+      if (binding.provisionType().equals(SET)) {
+        getMethodWriter.body().addSnippet("return %s.singleton(result);",
+            ClassName.fromClass(Collections.class));
+      } else {
+        getMethodWriter.body().addSnippet("return result;");
       }
     } else if (binding.memberInjectionRequest().isPresent()) {
       getMethodWriter.body().addSnippet("%1$s instance = new %1$s(%2$s);",
diff --git a/compiler/src/test/java/dagger/internal/codegen/ModuleProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ModuleProcessorTest.java
index 76eee3c6f..1c06564ee 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ModuleProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ModuleProcessorTest.java
@@ -235,10 +235,13 @@
         "package test;",
         "",
         "import dagger.Factory;",
+        "import java.util.logging.Logger;",
         "import javax.annotation.Generated;",
         "",
         "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
         "public final class TestModule$$ProvideStringFactory implements Factory<String> {",
+        "  private static final Logger logger =",
+        "      Logger.getLogger(TestModule$$ProvideStringFactory.class.getCanonicalName());",
         "  private final TestModule module;",
         "",
         "  public TestModule$$ProvideStringFactory(TestModule module) {",
@@ -247,7 +250,13 @@
         "  }",
         "",
         "  @Override public String get() {",
-        "    return module.provideString();",
+        "    String result =  module.provideString();",
+        "    if (result == null) {",
+        "      logger.warning("
+            + "\"test.TestModule.provideString() provided null. "
+            + "This is not allowed and will soon throw a NullPointerException.\");",
+        "    }",
+        "    return result;",
         "  }",
         "}");
     assert_().about(javaSource()).that(moduleFile)
@@ -301,11 +310,14 @@
         "",
         "import dagger.Factory;",
         "import java.util.List;",
+        "import java.util.logging.Logger;",
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
         "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
         "public final class TestModule$$ProvideObjectsFactory implements Factory<List<Object>> {",
+        "  private static final Logger logger =",
+        "      Logger.getLogger(TestModule$$ProvideObjectsFactory.class.getCanonicalName());",
         "  private final TestModule module;",
         "  private final Provider<Object> aProvider;",
         "  private final Provider<Object> bProvider;",
@@ -321,7 +333,13 @@
         "  }",
         "",
         "  @Override public List<Object> get() {",
-        "    return module.provideObjects(aProvider.get(), bProvider.get());",
+        "    List<Object> result = module.provideObjects(aProvider.get(), bProvider.get());",
+        "    if (result == null) {",
+        "      logger.warning("
+            + "\"test.TestModule.provideObjects(java.lang.Object,java.lang.Object) provided null. "
+            + "This is not allowed and will soon throw a NullPointerException.\");",
+        "    }",
+        "    return result;",
         "  }",
         "}");
     assert_().about(javaSources()).that(ImmutableList.of(moduleFile, QUALIFIER_A, QUALIFIER_B))
@@ -336,6 +354,7 @@
         "",
         "import static dagger.Provides.Type.SET;",
         "",
+        "import java.util.logging.Logger;",
         "import dagger.Module;",
         "import dagger.Provides;",
         "",
@@ -351,10 +370,13 @@
         "import dagger.Factory;",
         "import java.util.Collections;",
         "import java.util.Set;",
+        "import java.util.logging.Logger;",
         "import javax.annotation.Generated;",
         "",
         "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
         "public final class TestModule$$ProvideStringFactory implements Factory<Set<String>> {",
+        "  private static final Logger logger =",
+        "      Logger.getLogger(TestModule$$ProvideStringFactory.class.getCanonicalName());",
         "  private final TestModule module;",
         "",
         "  public TestModule$$ProvideStringFactory(TestModule module) {",
@@ -363,7 +385,13 @@
         "  }",
         "",
         "  @Override public Set<String> get() {",
-        "    return Collections.singleton(module.provideString());",
+        "    String result =  module.provideString();",
+        "    if (result == null) {",
+        "      logger.warning("
+            + "\"test.TestModule.provideString() provided null. "
+            + "This is not allowed and will soon throw a NullPointerException.\");",
+        "    }",
+        "    return Collections.singleton(result);",
         "  }",
         "}");
     assert_().about(javaSource()).that(moduleFile)
@@ -393,10 +421,13 @@
         "",
         "import dagger.Factory;",
         "import java.util.Set;",
+        "import java.util.logging.Logger;",
         "import javax.annotation.Generated;",
         "",
         "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
         "public final class TestModule$$ProvideStringsFactory implements Factory<Set<String>> {",
+        "  private static final Logger logger =",
+        "      Logger.getLogger(TestModule$$ProvideStringsFactory.class.getCanonicalName());",
         "  private final TestModule module;",
         "",
         "  public TestModule$$ProvideStringsFactory(TestModule module) {",
@@ -405,7 +436,13 @@
         "  }",
         "",
         "  @Override public Set<String> get() {",
-        "    return module.provideStrings();",
+        "    Set<String> result = module.provideStrings();",
+        "    if (result == null) {",
+        "      logger.warning("
+            + "\"test.TestModule.provideStrings() provided null. "
+            + "This is not allowed and will soon throw a NullPointerException.\");",
+        "    }",
+        "    return result;",
         "  }",
         "}");
     assert_().about(javaSource()).that(moduleFile)
diff --git a/core/src/main/java/dagger/internal/ScopedProvider.java b/core/src/main/java/dagger/internal/ScopedProvider.java
index be7a00148..90a679a90 100644
--- a/core/src/main/java/dagger/internal/ScopedProvider.java
+++ b/core/src/main/java/dagger/internal/ScopedProvider.java
@@ -25,30 +25,30 @@
  * @since 2.0
  */
 public final class ScopedProvider<T> implements Provider<T> {
+  private static final Object UNINITIALIZED = new Object();
+
   private final Factory<T> factory;
-  private volatile T instance = null;
+  private volatile Object instance = UNINITIALIZED;
 
   private ScopedProvider(Factory<T> factory) {
     assert factory != null;
     this.factory = factory;
   }
 
+  @SuppressWarnings("unchecked") // cast only happens when result comes from the factory
   @Override
   public T get() {
     // double-check idiom from EJ2: Item 71
-    T result = instance;
-    if (result == null) {
+    Object result = instance;
+    if (result == UNINITIALIZED) {
       synchronized (this) {
         result = instance;
-        if (result == null) {
+        if (result == UNINITIALIZED) {
           instance = result = factory.get();
-          if (result == null) {
-            throw new NullPointerException(factory + " returned null");
-          }
         }
       }
     }
-    return result;
+    return (T) result;
   }
 
   /** Returns a new scoped provider for the given factory. */
diff --git a/core/src/test/java/dagger/internal/ScopedProviderTest.java b/core/src/test/java/dagger/internal/ScopedProviderTest.java
index 7d2e4ba79..30cdd4121 100644
--- a/core/src/test/java/dagger/internal/ScopedProviderTest.java
+++ b/core/src/test/java/dagger/internal/ScopedProviderTest.java
@@ -17,6 +17,7 @@
 
 import dagger.Factory;
 import javax.inject.Provider;
+import org.junit.Ignore;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
@@ -36,7 +37,8 @@
     } catch (NullPointerException expected) { }
   }
 
-  @Test public void get_nullPointerException() {
+  // TODO(gak): reenable this test once we can ensure that factories are no longer providing null
+  @Ignore @Test public void get_nullPointerException() {
     Provider<Object> scopedProvider = ScopedProvider.create(new Factory<Object>() {
       @Override public Object get() {
         return null;
