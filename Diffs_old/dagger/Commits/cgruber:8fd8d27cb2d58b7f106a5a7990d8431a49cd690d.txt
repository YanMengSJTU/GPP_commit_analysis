diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
index a59c45a79..5bf939f7f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
@@ -142,8 +142,13 @@ ComponentDescriptor create(TypeElement componentDefinitionType) {
           ConfigurationAnnotations.getComponentModules(elements, componentMirror));
       ImmutableSet<TypeElement> transitiveModules = getTransitiveModules(moduleTypes);
 
+      ProvisionBinding componentBinding =
+          provisionBindingFactory.forComponent(componentDefinitionType);
+
       ImmutableSetMultimap.Builder<Key, ProvisionBinding> bindingIndexBuilder =
-          ImmutableSetMultimap.builder();
+          new ImmutableSetMultimap.Builder<Key, ProvisionBinding>()
+              .put(componentBinding.providedKey(), componentBinding);
+
 
       for (TypeElement module : transitiveModules) {
         // traverse the modules, collect the bindings
@@ -222,7 +227,7 @@ ComponentDescriptor create(TypeElement componentDefinitionType) {
                 // TODO(gak): support this
                 throw new UnsupportedOperationException(
                     "@Injected classes that weren't run with the compoenent processor are "
-                    + "(briefly) unsupported: " + key);
+                        + "(briefly) unsupported: " + key);
               }
             } else {
               resolvedProvisionBindings.putAll(key, explicitBindingsForKey);
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
index a0d4c9909..44b857116 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
@@ -21,6 +21,7 @@
 import static dagger.Provides.Type.SET;
 import static dagger.Provides.Type.SET_VALUES;
 import static dagger.internal.codegen.DependencyRequest.Kind.MEMBERS_INJECTOR;
+import static dagger.internal.codegen.ProvisionBinding.Kind.COMPONENT;
 import static dagger.internal.codegen.ProvisionBinding.Kind.PROVISION;
 import static dagger.internal.codegen.SourceFiles.collectImportsFromDependencies;
 import static dagger.internal.codegen.SourceFiles.factoryNameForProvisionBinding;
@@ -56,6 +57,8 @@
 
 import dagger.Component;
 import dagger.MembersInjector;
+import dagger.internal.InstanceFactory;
+import dagger.internal.ScopedProvider;
 import dagger.internal.SetFactory;
 
 import java.io.IOException;
@@ -164,6 +167,12 @@ private void writeImports(JavaWriter writer, ClassName factoryClassName,
             .add(ClassName.fromClass(Generated.class))
             .add(ClassName.fromClass(Provider.class));
     for (ProvisionBinding binding : bindings) {
+      if (binding.scope().isPresent()) {
+        importsBuilder.add(ClassName.fromClass(ScopedProvider.class));
+      }
+      if (binding.bindingKind().equals(COMPONENT)) {
+        importsBuilder.add(ClassName.fromClass(InstanceFactory.class));
+      }
       if (binding.provisionType().equals(SET) || binding.provisionType().equals(SET_VALUES)) {
         importsBuilder.add(ClassName.fromClass(SetFactory.class));
       }
@@ -274,15 +283,21 @@ private static String initializeFactoryForBinding(JavaWriter writer, ProvisionBi
       ImmutableBiMap<TypeElement, String> moduleNames,
       ImmutableBiMap<Key, String> providerNames,
       ImmutableBiMap<Key, String> membersInjectorNames) {
-    List<String> parameters = Lists.newArrayListWithCapacity(binding.dependencies().size() + 1);
-    if (binding.bindingKind().equals(PROVISION)) {
-      parameters.add(moduleNames.get(binding.bindingTypeElement()));
+    if (binding.bindingKind().equals(COMPONENT)) {
+      return String.format("InstanceFactory.<%s>create(this)",
+          writer.compressType(Util.typeToString(binding.providedKey().type())));
+    } else {
+      List<String> parameters = Lists.newArrayListWithCapacity(binding.dependencies().size() + 1);
+      if (binding.bindingKind().equals(PROVISION)) {
+        parameters.add(moduleNames.get(binding.bindingTypeElement()));
+      }
+      parameters.addAll(
+          getDependencyParameters(binding.dependencies(), providerNames, membersInjectorNames));
+      return String.format(
+          binding.scope().isPresent() ? "ScopedProvider.create(new %s(%s))" : "new %s(%s)",
+          writer.compressType(factoryNameForProvisionBinding(binding).toString()),
+          Joiner.on(", ").join(parameters));
     }
-    parameters.addAll(
-        getDependencyParameters(binding.dependencies(), providerNames, membersInjectorNames));
-    return String.format("new %s(%s)",
-        writer.compressType(factoryNameForProvisionBinding(binding).toString()),
-        Joiner.on(", ").join(parameters));
   }
 
   private static String initializeMembersInjectorForBinding(JavaWriter writer,
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
index ed2197c45..5be75d01b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
@@ -28,9 +28,11 @@
 import com.google.auto.common.MoreElements;
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Optional;
+import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Sets;
 
+import dagger.Component;
 import dagger.Provides;
 
 import java.util.Iterator;
@@ -56,6 +58,8 @@
     INJECTION,
     /** Represents a binding configured by {@link Provides}. */
     PROVISION,
+    /** Represents the implicit binding to the component. */
+    COMPONENT,
   }
 
   /**
@@ -150,5 +154,19 @@ ProvisionBinding forProvidesMethod(ExecutableElement providesMethod) {
           getScopeAnnotation(providesMethod),
           false);
     }
+
+    ProvisionBinding forComponent(TypeElement componentDefinitionType) {
+      checkNotNull(componentDefinitionType);
+      Component componentAnnotation = componentDefinitionType.getAnnotation(Component.class);
+      checkArgument(componentAnnotation != null);
+      return new AutoValue_ProvisionBinding(
+          componentDefinitionType,
+          ImmutableList.<DependencyRequest>of(),
+          Kind.COMPONENT,
+          Provides.Type.UNIQUE,
+          Key.create(componentDefinitionType.asType()),
+          Optional.<AnnotationMirror>absent(),
+          false);
+    }
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
index 7b9880f64..b5b7cf1f3 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
@@ -205,14 +205,19 @@
             new ElementKindVisitor6<String, Void>() {
               @Override
               public String visitExecutableAsConstructor(ExecutableElement e, Void p) {
-                return CaseFormat.UPPER_CAMEL.to(CaseFormat.LOWER_CAMEL,
-                    e.getEnclosingElement().getSimpleName().toString());
+                return e.getEnclosingElement().accept(this, null);
               }
 
               @Override
               public String visitExecutableAsMethod(ExecutableElement e, Void p) {
                 return e.getSimpleName().toString();
               }
+
+              @Override
+              public String visitType(TypeElement e, Void p) {
+                return CaseFormat.UPPER_CAMEL.to(CaseFormat.LOWER_CAMEL,
+                    e.getSimpleName().toString());
+              }
             }, null) + "Provider";
       }
       providerNames.put(entry.getKey(), name);
diff --git a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
index b77c8292d..e6640f1a1 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
@@ -146,6 +146,69 @@
         .and().generatesSources(generatedComponent);
   }
 
+  @Test public void componentWithScope() {
+    JavaFileObject injectableTypeFile = JavaFileObjects.forSourceLines("test.SomeInjectableType",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "import javax.inject.Singleton;",
+        "",
+        "@Singleton",
+        "final class SomeInjectableType {",
+        "  @Inject SomeInjectableType() {}",
+        "}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import dagger.Lazy;",
+        "import javax.inject.Provider;",
+        "import javax.inject.Singleton;",
+        "",
+        "@Singleton",
+        "@Component",
+        "interface SimpleComponent {",
+        "  SomeInjectableType someInjectableType();",
+        "  Lazy<SomeInjectableType> lazySomeInjectableType();",
+        "  Provider<SomeInjectableType> someInjectableTypeProvider();",
+        "}");
+    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
+        "test.Dagger_SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.Lazy;",
+        "import dagger.internal.DoubleCheckLazy;",
+        "import dagger.internal.ScopedProvider;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class Dagger_SimpleComponent implements SimpleComponent {",
+        "  private final Provider<SomeInjectableType> someInjectableTypeProvider;",
+        "",
+        "  public Dagger_SimpleComponent() {",
+        "    this.someInjectableTypeProvider =",
+        "        ScopedProvider.create(new SomeInjectableType$$Factory());",
+        "  }",
+        "",
+        "  @Override public SomeInjectableType someInjectableType() {",
+        "    return someInjectableTypeProvider.get();",
+        "  }",
+        "",
+        "  @Override public Lazy<SomeInjectableType> lazySomeInjectableType() {",
+        "    return DoubleCheckLazy.create(someInjectableTypeProvider);",
+        "  }",
+        "",
+        "  @Override public Provider<SomeInjectableType> someInjectableTypeProvider() {",
+        "    return someInjectableTypeProvider;",
+        "  }",
+        "}");
+    ASSERT.about(javaSources()).that(ImmutableList.of(injectableTypeFile, componentFile))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(generatedComponent);
+  }
+
   @Test public void componentWithModule() {
     JavaFileObject aFile = JavaFileObjects.forSourceLines("test.A",
         "package test;",
@@ -369,4 +432,54 @@
         .compilesWithoutError()
         .and().generatesSources(generatedComponent);
   }
+
+  @Test public void componentInjection() {
+    JavaFileObject injectableTypeFile = JavaFileObjects.forSourceLines("test.SomeInjectableType",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class SomeInjectableType {",
+        "  @Inject SomeInjectableType(SimpleComponent component) {}",
+        "}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import dagger.Lazy;",
+        "",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "interface SimpleComponent {",
+        "  SomeInjectableType someInjectableType();",
+        "}");
+    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
+        "test.Dagger_SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.internal.InstanceFactory;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+        "public final class Dagger_SimpleComponent implements SimpleComponent {",
+        "  private final Provider<SimpleComponent> simpleComponentProvider;",
+        "  private final Provider<SomeInjectableType> someInjectableTypeProvider;",
+        "",
+        "  public Dagger_SimpleComponent() {",
+        "    this.simpleComponentProvider = InstanceFactory.<SimpleComponent>create(this);",
+        "    this.someInjectableTypeProvider =",
+        "        new SomeInjectableType$$Factory(simpleComponentProvider);",
+        "  }",
+        "",
+        "  @Override public SomeInjectableType someInjectableType() {",
+        "    return someInjectableTypeProvider.get();",
+        "  }",
+        "}");
+    ASSERT.about(javaSources()).that(ImmutableList.of(injectableTypeFile, componentFile))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(generatedComponent);
+  }
 }
diff --git a/core/src/main/java/dagger/internal/InstanceFactory.java b/core/src/main/java/dagger/internal/InstanceFactory.java
new file mode 100644
index 000000000..7c4990b16
--- /dev/null
+++ b/core/src/main/java/dagger/internal/InstanceFactory.java
@@ -0,0 +1,50 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal;
+
+import dagger.Factory;
+
+/**
+ * A {@link Factory} implementation that returns a single instance for all invocations of
+ * {@link #get}.
+ *
+ * <p>Note that while this is a {@link Factory} implementation, and thus unscoped, each call to
+ * {@link #get} will always return the same instance.  As such, any scoping applied to this factory
+ * is redundant and unnecessary.  However, using this with the {@link ScopedProvider} is valid and
+ * may be desired for testing or contractual guarantees.
+ *
+ * @author Gregory Kick
+ * @since 2.0
+ */
+public final class InstanceFactory<T> implements Factory<T> {
+  public static <T> Factory<T> create(T instance) {
+    if (instance == null) {
+      throw new NullPointerException();
+    }
+    return new InstanceFactory<T>(instance);
+  }
+
+  private final T instance;
+
+  private InstanceFactory(T instance) {
+    this.instance = instance;
+  }
+
+  @Override
+  public T get() {
+    return instance;
+  }
+}
diff --git a/core/src/test/java/dagger/internal/InstanceFactoryTest.java b/core/src/test/java/dagger/internal/InstanceFactoryTest.java
new file mode 100644
index 000000000..0657c2f6e
--- /dev/null
+++ b/core/src/test/java/dagger/internal/InstanceFactoryTest.java
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal;
+
+import static org.truth0.Truth.ASSERT;
+
+import dagger.Factory;
+
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.ExpectedException;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public final class InstanceFactoryTest {
+  @Rule public final ExpectedException thrown = ExpectedException.none();
+
+  @Test public void instanceFactory() {
+    Object instance = new Object();
+    Factory<Object> factory = InstanceFactory.create(instance);
+    ASSERT.that(factory.get()).is(instance);
+    ASSERT.that(factory.get()).is(instance);
+    ASSERT.that(factory.get()).is(instance);
+  }
+
+  @Test public void create_throwsNullPointerException() {
+    thrown.expect(NullPointerException.class);
+    InstanceFactory.create(null);
+  }
+}
