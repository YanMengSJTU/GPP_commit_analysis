diff --git a/compiler/src/it/functional-tests/src/main/java/test/bind/SimpleBindingModule.java b/compiler/src/it/functional-tests/src/main/java/test/bind/SimpleBindingModule.java
index f884c8b8c..bd5dd6354 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/bind/SimpleBindingModule.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/bind/SimpleBindingModule.java
@@ -18,6 +18,15 @@
 import dagger.Binds;
 import dagger.Module;
 import dagger.Provides;
+import dagger.multibindings.ElementsIntoSet;
+import dagger.multibindings.IntoSet;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.Set;
+import java.util.TreeSet;
 import javax.inject.Singleton;
 import test.SomeQualifier;
 
@@ -41,4 +50,52 @@
   static Foo<Integer> provideFooOfIntegers() {
     return new Foo<Integer>() {};
   }
+
+  @Provides
+  static Foo<Double> provideFooOfDoubles() {
+    return new Foo<Double>() {};
+  }
+
+  @Binds
+  @IntoSet
+  abstract Foo<? extends Number> bindFooOfIntegersIntoSet(Foo<Integer> fooOfIntegers);
+
+  @Binds
+  @IntoSet
+  abstract Foo<? extends Number> bindFooExtendsNumberIntoSet(Foo<Double> fooOfDoubles);
+
+  @Binds
+  @ElementsIntoSet
+  abstract Set<Object> bindSetOfFooNumbersToObjects(Set<Foo<? extends Number>> setOfFooNumbers);
+
+  @Binds
+  @IntoSet
+  abstract Object bindFooOfStringsIntoSetOfObjects(FooOfStrings impl);
+
+  @Provides
+  static HashSet<String> provideStringHashSet() {
+    return new HashSet<>(Arrays.asList("hash-string1", "hash-string2"));
+  }
+
+  @Provides
+  static TreeSet<CharSequence> provideCharSequenceTreeSet() {
+    return new TreeSet<CharSequence>(Arrays.asList("tree-charSequence1", "tree-charSequence2"));
+  }
+
+  @Provides
+  static Collection<CharSequence> provideCharSequenceCollection() {
+    return Arrays.<CharSequence>asList("list-charSequence");
+  }
+
+  @Binds
+  @ElementsIntoSet
+  abstract Set<CharSequence> bindHashSetOfStrings(HashSet<String> set);
+
+  @Binds
+  @ElementsIntoSet
+  abstract Set<CharSequence> bindTreeSetOfCharSequences(TreeSet<CharSequence> set);
+
+  @Binds
+  @ElementsIntoSet
+  abstract Set<CharSequence> bindCollectionOfCharSequences(Collection<CharSequence> collection);
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/bind/TestComponent.java b/compiler/src/it/functional-tests/src/main/java/test/bind/TestComponent.java
index d92e6029f..0a2a18efb 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/bind/TestComponent.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/bind/TestComponent.java
@@ -16,6 +16,7 @@
 package test.bind;
 
 import dagger.Component;
+import java.util.Set;
 import javax.inject.Singleton;
 import test.SomeQualifier;
 
@@ -32,4 +33,10 @@
   Foo<String> qualifiedFooOfStrings();
 
   Foo<Integer> fooOfIntegers();
+
+  Set<Foo<? extends Number>> foosOfNumbers();
+
+  Set<Object> objects();
+
+  Set<CharSequence> charSequences();
 }
diff --git a/compiler/src/it/functional-tests/src/test/java/test/bind/BindTest.java b/compiler/src/it/functional-tests/src/test/java/test/bind/BindTest.java
index 04de60e00..d91daeb06 100644
--- a/compiler/src/it/functional-tests/src/test/java/test/bind/BindTest.java
+++ b/compiler/src/it/functional-tests/src/test/java/test/bind/BindTest.java
@@ -15,6 +15,7 @@
  */
 package test.bind;
 
+import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
@@ -23,9 +24,16 @@
 
 @RunWith(JUnit4.class)
 public class BindTest {
+
+  private TestComponent component;
+
+  @Before
+  public void setUp() {
+    component = DaggerTestComponent.create();
+  }
+
   @Test
   public void bindDelegates() {
-    TestComponent component = DaggerTestComponent.create();
     assertThat(component.object()).isInstanceOf(FooOfStrings.class);
     assertThat(component.fooOfStrings()).isInstanceOf(FooOfStrings.class);
     assertThat(component.fooOfObjects()).isInstanceOf(FooOfObjects.class);
@@ -34,8 +42,14 @@ public void bindDelegates() {
 
   @Test
   public void bindWithScope() {
-    TestComponent component = DaggerTestComponent.create();
     assertThat(component.qualifiedFooOfStrings())
         .isSameAs(component.qualifiedFooOfStrings());
   }
+
+  @Test
+  public void multibindings() {
+    assertThat(component.foosOfNumbers()).hasSize(2);
+    assertThat(component.objects()).hasSize(3);
+    assertThat(component.charSequences()).hasSize(5);
+  }
 }
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/bind/Foo.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/bind/Foo.java
new file mode 100644
index 000000000..5b0908832
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/bind/Foo.java
@@ -0,0 +1,21 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package producerstest.bind;
+
+/**
+ * This is the type that will be bound.  We throw in generics just to complicate the test.
+ */
+interface Foo<T> {}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/bind/FooOfStrings.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/bind/FooOfStrings.java
new file mode 100644
index 000000000..66f93406d
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/bind/FooOfStrings.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package producerstest.bind;
+
+/**
+ * This is not marked with {@link javax.inject.Inject @Inject} (like the {@link dagger.Provides
+ * @Provides} version in {@link test.bind.FooOfStrings}), to test that {@link dagger.Binds @Binds}
+ * properly translate to {@link dagger.internal.codegen.ProductionBinding}s when the right-hand-side
+ * of the method is also a production binding. We force this by adding a {@link
+ * dagger.producers.Produces @Produces} method to add it to the graph instead of relying on the
+ * {@link dagger.internal.codegen.ProvisionBinding} that would be created by default with an {@code
+ * @Inject} constructor.
+ */
+final class FooOfStrings implements Foo<String> {}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/bind/SimpleBindingModule.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/bind/SimpleBindingModule.java
new file mode 100644
index 000000000..fb851e21a
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/bind/SimpleBindingModule.java
@@ -0,0 +1,125 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package producerstest.bind;
+
+import com.google.common.util.concurrent.MoreExecutors;
+import dagger.Binds;
+import dagger.Module;
+import dagger.Provides;
+import dagger.multibindings.ElementsIntoSet;
+import dagger.multibindings.IntoSet;
+import dagger.producers.ProducerModule;
+import dagger.producers.Produces;
+import dagger.producers.Production;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.Set;
+import java.util.TreeSet;
+import java.util.concurrent.Executor;
+import javax.inject.Qualifier;
+import javax.inject.Singleton;
+
+@ProducerModule(includes = SimpleBindingModule.ExecutorModule.class)
+abstract class SimpleBindingModule {
+  @Binds
+  abstract Object bindObject(FooOfStrings impl);
+
+  @Binds
+  abstract Foo<String> bindFooOfStrings(FooOfStrings impl);
+
+  @Binds
+  abstract Foo<? extends Number> bindFooOfNumbers(Foo<Integer> fooOfIntegers);
+
+  @Binds
+  @Singleton
+  @SomeQualifier
+  abstract Foo<String> bindQualifiedFooOfStrings(FooOfStrings impl);
+
+  @Produces
+  static FooOfStrings produceFooOfStrings() {
+    return new FooOfStrings();
+  }
+
+  @Produces
+  static Foo<Integer> produceFooOfIntegers() {
+    return new Foo<Integer>() {};
+  }
+
+  @Produces
+  static Foo<Double> produceFooOfDoubles() {
+    return new Foo<Double>() {};
+  }
+
+  @Binds
+  @IntoSet
+  abstract Foo<? extends Number> bindFooOfIntegersIntoSet(Foo<Integer> fooOfIntegers);
+
+  @Binds
+  @IntoSet
+  abstract Foo<? extends Number> bindFooExtendsNumberIntoSet(Foo<Double> fooOfDoubles);
+
+  @Binds
+  @ElementsIntoSet
+  abstract Set<Object> bindSetOfFooNumbersToObjects(Set<Foo<? extends Number>> setOfFooNumbers);
+
+  @Binds
+  @IntoSet
+  abstract Object bindFooOfStringsIntoSetOfObjects(FooOfStrings impl);
+
+  @Produces
+  static HashSet<String> produceStringHashSet() {
+    return new HashSet<>(Arrays.asList("hash-string1", "hash-string2"));
+  }
+
+  @Produces
+  static TreeSet<CharSequence> produceCharSequenceTreeSet() {
+    return new TreeSet<CharSequence>(Arrays.asList("tree-charSequence1", "tree-charSequence2"));
+  }
+
+  @Produces
+  static Collection<CharSequence> produceCharSequenceCollection() {
+    return Arrays.<CharSequence>asList("list-charSequence");
+  }
+
+  @Binds
+  @ElementsIntoSet
+  abstract Set<CharSequence> bindHashSetOfStrings(HashSet<String> set);
+
+  @Binds
+  @ElementsIntoSet
+  abstract Set<CharSequence> bindTreeSetOfCharSequences(TreeSet<CharSequence> set);
+
+  @Binds
+  @ElementsIntoSet
+  abstract Set<CharSequence> bindCollectionOfCharSequences(Collection<CharSequence> collection);
+
+  @Qualifier
+  @Retention(RetentionPolicy.RUNTIME)
+  @interface SomeQualifier {}
+
+  @Module
+  static final class ExecutorModule {
+    @Provides @Production
+    static Executor provideExecutor() {
+      return MoreExecutors.directExecutor();
+    }
+  }
+}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/bind/SimpleBindsProductionComponent.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/bind/SimpleBindsProductionComponent.java
new file mode 100644
index 000000000..6c69b79f2
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/bind/SimpleBindsProductionComponent.java
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package producerstest.bind;
+
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.producers.ProductionComponent;
+import java.util.Set;
+import javax.inject.Singleton;
+import producerstest.bind.SimpleBindingModule.SomeQualifier;
+
+@Singleton
+@ProductionComponent(modules = SimpleBindingModule.class)
+public interface SimpleBindsProductionComponent {
+  ListenableFuture<Object> object();
+
+  ListenableFuture<Foo<String>> fooOfStrings();
+
+  @SomeQualifier
+  ListenableFuture<Foo<String>> qualifiedFooOfStrings();
+
+  ListenableFuture<Foo<Integer>> fooOfIntegers();
+
+  ListenableFuture<Set<Foo<? extends Number>>> foosOfNumbers();
+
+  ListenableFuture<Set<Object>> objects();
+
+  ListenableFuture<Set<CharSequence>> charSequences();
+}
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/bind/BindsProducersTest.java b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/bind/BindsProducersTest.java
new file mode 100644
index 000000000..88c675c97
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/bind/BindsProducersTest.java
@@ -0,0 +1,54 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package producerstest.bind;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assertThat;
+
+@RunWith(JUnit4.class)
+public class BindsProducersTest {
+
+  private SimpleBindsProductionComponent component;
+
+  @Before
+  public void setUp() {
+    component = DaggerSimpleBindsProductionComponent.create();
+  }
+
+  @Test
+  public void bindDelegates() throws Exception {
+    assertThat(component.object().get()).isInstanceOf(FooOfStrings.class);
+    assertThat(component.fooOfStrings().get()).isInstanceOf(FooOfStrings.class);
+    assertThat(component.fooOfIntegers().get()).isNotNull();
+  }
+
+  @Test
+  public void bindWithScope() throws Exception {
+    assertThat(component.qualifiedFooOfStrings().get())
+        .isSameAs(component.qualifiedFooOfStrings().get());
+  }
+
+  @Test
+  public void multibindings() throws Exception {
+    assertThat(component.foosOfNumbers().get()).hasSize(2);
+    assertThat(component.objects().get()).hasSize(3);
+    assertThat(component.charSequences().get()).hasSize(5);
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
index 15845651c..6d1437eda 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -1137,23 +1137,23 @@ private CodeBlock initializeFactoryForSetMultibinding(ContributionBinding bindin
       ContributionType contributionType =
           graph.resolvedBindings().get(frameworkDependency.bindingKey()).contributionType();
       String methodName;
+      String methodNameSuffix = frameworkDependency.frameworkClass().getSimpleName();
       switch (contributionType) {
         case SET:
           individualProviders++;
-          methodName = "add";
+          methodName = "add" + methodNameSuffix;
           break;
         case SET_VALUES:
           setProviders++;
-          methodName = "addSet";
+          methodName = "addCollection" + methodNameSuffix;
           break;
         default:
           throw new AssertionError(frameworkDependency + " is not a set multibinding");
       }
 
       builderMethodCalls.add(
-          ".$L$L($L)",
+          ".$L($L)",
           methodName,
-          frameworkDependency.frameworkClass().getSimpleName(),
           potentiallyCast(
               useRawTypes,
               frameworkDependency.frameworkClass(),
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
index b27fac745..e7140a247 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
@@ -36,6 +36,7 @@
 import dagger.Subcomponent;
 import dagger.internal.codegen.BindingType.HasBindingType;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
+import dagger.internal.codegen.Key.HasKey;
 import dagger.producers.ProductionComponent;
 import java.util.ArrayDeque;
 import java.util.Collection;
@@ -284,6 +285,7 @@ private BindingGraph create(
       final ImmutableSetMultimap<Key, ContributionBinding> explicitMultibindings;
       final ImmutableSetMultimap<Key, MultibindingDeclaration> multibindingDeclarations;
       final ImmutableSetMultimap<Key, DelegateDeclaration> delegateDeclarations;
+      final ImmutableSetMultimap<Key, DelegateDeclaration> delegateMultibindingDeclarations;
       final Map<BindingKey, ResolvedBindings> resolvedBindings;
       final Deque<BindingKey> cycleStack = new ArrayDeque<>();
       final Cache<BindingKey, Boolean> dependsOnLocalMultibindingsCache =
@@ -309,16 +311,10 @@ private BindingGraph create(
         assert delegateDeclarations != null;
         this.delegateDeclarations = delegateDeclarations;
         this.resolvedBindings = Maps.newLinkedHashMap();
-
-        ImmutableSetMultimap.Builder<Key, ContributionBinding> explicitMultibindingsBuilder =
-            ImmutableSetMultimap.builder();
-        for (ContributionBinding binding : explicitBindingsSet) {
-          if (binding.key().bindingMethodIdentifier().isPresent()) {
-            explicitMultibindingsBuilder.put(
-                binding.key().withoutBindingMethodIdentifier(), binding);
-          }
-        }
-        this.explicitMultibindings = explicitMultibindingsBuilder.build();
+        this.explicitMultibindings =
+            multibindingsKeyedWithoutBindingIdentifiers(explicitBindingsSet);
+        this.delegateMultibindingDeclarations =
+            multibindingsKeyedWithoutBindingIdentifiers(delegateDeclarations.values());
       }
 
       /**
@@ -354,19 +350,14 @@ ResolvedBindings lookUpBindings(DependencyRequest request) {
             ImmutableSet.Builder<DelegateDeclaration> delegateDeclarationsBuilder =
                 ImmutableSet.builder();
 
-            // Add explicit bindings and declarations (those from modules and components).
-            contributionBindings.addAll(getExplicitBindings(key));
-            multibindings.addAll(getExplicitMultibindings(key));
-            multibindingDeclarationsBuilder.addAll(getMultibindingDeclarations(key));
-            delegateDeclarationsBuilder.addAll(getDelegateDeclarations(key));
-
-            // If the key is Set<Produced<T>>, then add explicit bindings and declarations for
-            // Set<T>.
-            Optional<Key> implicitSetKey = keyFactory.implicitSetKeyFromProduced(key);
-            contributionBindings.addAll(getExplicitBindings(implicitSetKey));
-            multibindings.addAll(getExplicitMultibindings(implicitSetKey));
-            multibindingDeclarationsBuilder.addAll(getMultibindingDeclarations(implicitSetKey));
-            delegateDeclarationsBuilder.addAll(getDelegateDeclarations(implicitSetKey));
+            for (Key keyOrImplicitKey : explicitAndImplicitKeys(key)) {
+              contributionBindings.addAll(getExplicitBindings(keyOrImplicitKey));
+              multibindings.addAll(getExplicitMultibindings(keyOrImplicitKey));
+              multibindingDeclarationsBuilder.addAll(getMultibindingDeclarations(keyOrImplicitKey));
+              delegateDeclarationsBuilder.addAll(getDelegateDeclarations(keyOrImplicitKey));
+              multibindings.addAll(
+                  delegateBindings(getDelegateMultibindingDeclarations(keyOrImplicitKey)));
+            }
 
             ImmutableSet<MultibindingDeclaration> multibindingDeclarations =
                 multibindingDeclarationsBuilder.build();
@@ -378,27 +369,15 @@ ResolvedBindings lookUpBindings(DependencyRequest request) {
             // If the key is Map<K, V>, get its map-of-framework-type binding keys, which are either
             // Map<K, Provider<V>> or Map<K, Producer<V>>, and grab their explicit bindings and
             // declarations.
-            Optional<Key> implicitMapProviderKey = keyFactory.implicitMapProviderKeyFrom(key);
-            ImmutableSet<ContributionBinding> explicitProviderMapBindings =
-                getExplicitMultibindings(implicitMapProviderKey);
-            ImmutableSet<MultibindingDeclaration> explicitProviderMultibindingDeclarations =
-                getMultibindingDeclarations(implicitMapProviderKey);
-
-            Optional<Key> implicitMapProducerKey = keyFactory.implicitMapProducerKeyFrom(key);
-            ImmutableSet<ContributionBinding> explicitProducerMapBindings =
-                getExplicitMultibindings(implicitMapProducerKey);
-            ImmutableSet<MultibindingDeclaration> explicitProducerMultibindingDeclarations =
-                getMultibindingDeclarations(implicitMapProducerKey);
-
-            if (!explicitProducerMapBindings.isEmpty()
-                || !explicitProducerMultibindingDeclarations.isEmpty()) {
+            if (shouldCreateSyntheticMapOfValuesBinding(
+                keyFactory.implicitMapProducerKeyFrom(key))) {
               /* If the binding key is Map<K, V> or Map<K, Produced<V>> and there are some explicit
                * Map<K, Producer<V>> bindings or multibinding declarations, then add the synthetic
                * binding that depends on Map<K, Producer<V>>. */
               contributionBindings.add(
                   productionBindingFactory.syntheticMapOfValuesOrProducedBinding(request));
-            } else if (!explicitProviderMapBindings.isEmpty()
-                || !explicitProviderMultibindingDeclarations.isEmpty()) {
+            } else if (shouldCreateSyntheticMapOfValuesBinding(
+                keyFactory.implicitMapProviderKeyFrom(key))) {
               /* If the binding key is Map<K, V> and there are some explicit Map<K, Provider<V>>
                * bindings or multibinding declarations but no explicit Map<K, Producer<V>> bindings
                * or multibinding declarations, then add the synthetic binding that depends on
@@ -452,6 +431,22 @@ ResolvedBindings lookUpBindings(DependencyRequest request) {
         }
       }
 
+      private Iterable<Key> explicitAndImplicitKeys(Key key) {
+        return ImmutableSet.<Key>builder()
+            .add(key)
+            .addAll(keyFactory.implicitSetKeyFromProduced(key).asSet())
+            .build();
+      }
+
+      private boolean shouldCreateSyntheticMapOfValuesBinding(Optional<Key> key) {
+        if (!key.isPresent()) {
+          return false;
+        }
+        return !getExplicitMultibindings(key.get()).isEmpty()
+            || !getMultibindingDeclarations(key.get()).isEmpty()
+            || !getDelegateDeclarations(key.get()).isEmpty();
+      }
+
       private ImmutableSet<ContributionBinding> delegateBindings(
           ImmutableSet<DelegateDeclaration> delegateDeclarations) {
         ImmutableSet.Builder<ContributionBinding> builder = ImmutableSet.builder();
@@ -582,12 +577,6 @@ private boolean isResolvedInParent(DependencyRequest request, ContributionBindin
         return explicitBindingsForKey.build();
       }
 
-      private ImmutableSet<ContributionBinding> getExplicitBindings(Optional<Key> optionalKey) {
-        return optionalKey.isPresent()
-            ? getExplicitBindings(optionalKey.get())
-            : ImmutableSet.<ContributionBinding>of();
-      }
-
       /**
        * Returns the explicit multibindings whose key (minus its
        * {@link Key#bindingMethodIdentifier()}) matches the {@code requestKey} from this and all
@@ -602,13 +591,6 @@ private boolean isResolvedInParent(DependencyRequest request, ContributionBindin
         return explicitMultibindingsForKey.build();
       }
 
-      private ImmutableSet<ContributionBinding> getExplicitMultibindings(
-          Optional<Key> optionalKey) {
-        return optionalKey.isPresent()
-            ? getExplicitMultibindings(optionalKey.get())
-            : ImmutableSet.<ContributionBinding>of();
-      }
-
       /**
        * Returns the {@link MultibindingDeclaration}s that match the {@code key} from this and all
        * ancestor resolvers.
@@ -622,13 +604,6 @@ private boolean isResolvedInParent(DependencyRequest request, ContributionBindin
         return multibindingDeclarations.build();
       }
 
-      private ImmutableSet<MultibindingDeclaration> getMultibindingDeclarations(
-          Optional<Key> optionalKey) {
-        return optionalKey.isPresent()
-            ? getMultibindingDeclarations(optionalKey.get())
-            : ImmutableSet.<MultibindingDeclaration>of();
-      }
-
       private ImmutableSet<DelegateDeclaration> getDelegateDeclarations(Key key) {
         ImmutableSet.Builder<DelegateDeclaration> delegateDeclarations =
             ImmutableSet.builder();
@@ -638,11 +613,14 @@ private boolean isResolvedInParent(DependencyRequest request, ContributionBindin
         return delegateDeclarations.build();
       }
 
-      private ImmutableSet<DelegateDeclaration> getDelegateDeclarations(
-          Optional<Key> optionalKey) {
-        return optionalKey.isPresent()
-            ? getDelegateDeclarations(optionalKey.get())
-            : ImmutableSet.<DelegateDeclaration>of();
+      private ImmutableSet<DelegateDeclaration> getDelegateMultibindingDeclarations(Key key) {
+        ImmutableSet.Builder<DelegateDeclaration> delegateMultibindingDeclarations =
+            ImmutableSet.builder();
+        for (Resolver resolver : getResolverLineage()) {
+          delegateMultibindingDeclarations.addAll(
+              resolver.delegateMultibindingDeclarations.get(key));
+        }
+        return delegateMultibindingDeclarations.build();
       }
 
       private Optional<ResolvedBindings> getPreviouslyResolvedBindings(
@@ -835,5 +813,21 @@ private boolean isMultibindingsWithLocalContributions(ResolvedBindings resolvedB
         }
       }
     }
+
+    /**
+     * Selects each item in {@code haveKeys} that has a {@link Key#bindingMethodIdentifier()} and
+     * indexes them by its {@link HasKey#key()}, where each key has its {@link
+     * dagger.internal.codegen.Key.BindingMethodIdentifier} removed.
+     */
+    static <T extends HasKey> ImmutableSetMultimap<Key, T>
+        multibindingsKeyedWithoutBindingIdentifiers(Iterable<T> haveKeys) {
+      ImmutableSetMultimap.Builder<Key, T> builder = ImmutableSetMultimap.builder();
+      for (T hasKey : haveKeys) {
+        if (hasKey.key().bindingMethodIdentifier().isPresent()) {
+          builder.put(hasKey.key().withoutBindingMethodIdentifier(), hasKey);
+        }
+      }
+      return builder.build();
+    }
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingMethodValidator.java
index 3d4837705..0afbdd09e 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingMethodValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingMethodValidator.java
@@ -298,7 +298,7 @@ protected void checkSetValuesType(ValidationReport.Builder<ExecutableElement> bu
     checkSetValuesType(builder, builder.getSubject().getReturnType());
   }
 
-  /** Adds an error if {@code type} is not a a {@code Set<T>} for a reasonable {@code T}. */
+  /** Adds an error if {@code type} is not a {@code Set<T>} for a reasonable {@code T}. */
   protected final void checkSetValuesType(
       ValidationReport.Builder<ExecutableElement> builder, TypeMirror type) {
     if (!SetType.isSet(type)) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindsMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindsMethodValidator.java
index 369f424eb..dc8929ceb 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindsMethodValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindsMethodValidator.java
@@ -15,27 +15,41 @@
  */
 package dagger.internal.codegen;
 
+import com.google.auto.common.MoreElements;
+import com.google.auto.common.MoreTypes;
+import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import dagger.Binds;
 import dagger.Module;
+import dagger.multibindings.IntoMap;
 import dagger.producers.ProducerModule;
 import java.util.List;
+import java.util.Set;
+import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.util.ElementFilter;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static dagger.internal.codegen.BindingMethodValidator.Abstractness.MUST_BE_ABSTRACT;
 import static dagger.internal.codegen.BindingMethodValidator.ExceptionSuperclass.RUNTIME_EXCEPTION;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_NOT_MAP_HAS_MAP_KEY;
+import static dagger.internal.codegen.ErrorMessages.BINDS_ELEMENTS_INTO_SET_METHOD_RETURN_SET;
 import static dagger.internal.codegen.ErrorMessages.BINDS_METHOD_ONE_ASSIGNABLE_PARAMETER;
+import static dagger.internal.codegen.MapKeys.getMapKeys;
 
 /**
  * A validator for {@link Binds} methods.
  */
 final class BindsMethodValidator extends BindingMethodValidator {
   private final Types types;
+  private final Elements elements;
 
   BindsMethodValidator(Elements elements, Types types) {
     super(
@@ -45,7 +59,8 @@
         ImmutableSet.of(Module.class, ProducerModule.class),
         MUST_BE_ABSTRACT,
         RUNTIME_EXCEPTION);
-    this.types = checkNotNull(types);
+    this.types = types;
+    this.elements = elements;
   }
 
   @Override
@@ -54,31 +69,81 @@ protected void checkMethod(ValidationReport.Builder<ExecutableElement> builder)
     checkParameters(builder);
   }
 
-  @Override // TODO(dpb, ronshapiro): When @Binds methods support multibindings, stop overriding.
-  protected void checkReturnType(ValidationReport.Builder<ExecutableElement> builder) {
-    checkFrameworkType(builder);
-    checkKeyType(builder, builder.getSubject().getReturnType());
-  }
-
-  @Override // TODO(dpb, ronshapiro): When @Binds methods support multibindings, stop overriding.
+  @Override // TODO(dpb, ronshapiro): When @Binds methods support @IntoMap, stop overriding.
   protected void checkMapKeys(ValidationReport.Builder<ExecutableElement> builder) {
-    // no-op
+    if (!isAnnotationPresent(builder.getSubject(), IntoMap.class)) {
+      for (AnnotationMirror mapKey : getMapKeys(builder.getSubject())) {
+        builder.addError(BINDING_METHOD_NOT_MAP_HAS_MAP_KEY, builder.getSubject(), mapKey);
+      }
+    }
   }
 
-  @Override // TODO(dpb, ronshapiro): When @Binds methods support multibindings, stop overriding.
+  @Override
   protected void checkMultibindings(ValidationReport.Builder<ExecutableElement> builder) {
-    // no-op
+    super.checkMultibindings(builder);
+    if (isAnnotationPresent(builder.getSubject(), IntoMap.class)) {
+      builder.addError("@Binds @IntoMap is not yet supported");
+    }
   }
 
   private void checkParameters(ValidationReport.Builder<ExecutableElement> builder) {
     List<? extends VariableElement> parameters = builder.getSubject().getParameters();
     if (parameters.size() == 1) {
       VariableElement parameter = getOnlyElement(parameters);
-      if (!types.isAssignable(parameter.asType(), builder.getSubject().getReturnType())) {
-        builder.addError(formatErrorMessage(BINDS_METHOD_ONE_ASSIGNABLE_PARAMETER));
+      TypeMirror leftHandSide = builder.getSubject().getReturnType();
+      TypeMirror rightHandSide = parameter.asType();
+      switch (ContributionType.fromBindingMethod(builder.getSubject())) {
+        case SET_VALUES:
+          if (!SetType.isSet(leftHandSide)) {
+            builder.addError(BINDS_ELEMENTS_INTO_SET_METHOD_RETURN_SET);
+          } else {
+            validateTypesAreAssignable(
+                builder,
+                rightHandSide,
+                methodParameterType(MoreTypes.asDeclared(leftHandSide), "addAll"));
+          }
+          break;
+        case SET:
+          DeclaredType parameterizedSetType = types.getDeclaredType(setElement(), leftHandSide);
+          validateTypesAreAssignable(
+              builder,
+              rightHandSide,
+              methodParameterType(parameterizedSetType, "add"));
+          break;
+        case UNIQUE:
+          validateTypesAreAssignable(builder, rightHandSide, leftHandSide);
+          break;
+        default:
+          // @IntoMap not yet supported
       }
     } else {
-      builder.addError(formatErrorMessage(BINDS_METHOD_ONE_ASSIGNABLE_PARAMETER));
+      builder.addError(BINDS_METHOD_ONE_ASSIGNABLE_PARAMETER);
     }
   }
+
+  private TypeMirror methodParameterType(DeclaredType type, String methodName) {
+    ImmutableList.Builder<ExecutableElement> methodsForName = ImmutableList.builder();
+    for (ExecutableElement method :
+        ElementFilter.methodsIn(MoreElements.asType(type.asElement()).getEnclosedElements())) {
+      if (method.getSimpleName().contentEquals(methodName)) {
+        methodsForName.add(method);
+      }
+    }
+    ExecutableElement method = getOnlyElement(methodsForName.build());
+    return getOnlyElement(
+        MoreTypes.asExecutable(types.asMemberOf(type, method)).getParameterTypes());
+  }
+
+  private void validateTypesAreAssignable(
+      ValidationReport.Builder<ExecutableElement> builder,
+      TypeMirror rightHandSide,
+      TypeMirror leftHandSide) {
+    if (!types.isAssignable(rightHandSide, leftHandSide)) {
+      builder.addError(BINDS_METHOD_ONE_ASSIGNABLE_PARAMETER);
+    }
+  }
+
+  private TypeElement setElement() {
+    return elements.getTypeElement(Set.class.getName());
+  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/DelegateDeclaration.java b/compiler/src/main/java/dagger/internal/codegen/DelegateDeclaration.java
index a6872f5e8..7997581ef 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DelegateDeclaration.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DelegateDeclaration.java
@@ -18,17 +18,20 @@
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
+import com.google.common.base.Equivalence;
 import com.google.common.base.Optional;
 import com.google.common.collect.Iterables;
 import dagger.Binds;
 import dagger.internal.codegen.ContributionType.HasContributionType;
+import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.ExecutableType;
 import javax.lang.model.util.Types;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static dagger.internal.codegen.ContributionType.UNIQUE;
+import static dagger.internal.codegen.MapKeys.getMapKey;
+import static dagger.internal.codegen.MoreAnnotationMirrors.wrapOptionalInEquivalence;
 
 /**
  * The declaration for a delegate binding established by a {@link Binds} method.
@@ -37,11 +40,6 @@
 abstract class DelegateDeclaration extends BindingDeclaration implements HasContributionType {
   abstract DependencyRequest delegateRequest();
 
-  @Override
-  public ContributionType contributionType() {
-    return UNIQUE;
-  }
-
   static final class Factory {
     private final Types types;
     private final Key.Factory keyFactory;
@@ -65,6 +63,7 @@ DelegateDeclaration create(
               Iterables.getOnlyElement(bindsMethod.getParameters()),
               Iterables.getOnlyElement(resolvedMethod.getParameterTypes()));
       return new AutoValue_DelegateDeclaration(
+          ContributionType.fromBindingMethod(bindsMethod),
           keyFactory.forBindsMethod(bindsMethod, resolvedMethod),
           bindsMethod,
           Optional.of(contributingElement),
diff --git a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
index 8b07e58c9..76339ca17 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
@@ -143,6 +143,9 @@ static String inconsistentMapKeyAnnotationsError(String key) {
   static final String BINDING_METHOD_SET_VALUES_RAW_SET =
       "@%s methods of type set values cannot return a raw Set";
 
+  static final String BINDS_ELEMENTS_INTO_SET_METHOD_RAW_SET_PARAMETER =
+      "@Binds @ElementsIntoSet methods cannot take a raw Set parameter";
+
   static final String BINDING_METHOD_SET_VALUES_RETURN_SET =
       "@%s methods of type set values must return a Set";
 
@@ -171,12 +174,18 @@ static String inconsistentMapKeyAnnotationsError(String key) {
   static final String BINDING_METHOD_TYPE_PARAMETER =
       "@%s methods may not have type parameters.";
 
+  // TODO(ronshapiro): clarify this error message for @ElementsIntoSet cases, where the
+  // right-hand-side might not be assignable to the left-hand-side, but still compatible with
+  // Set.addAll(Collection<? extends E>)
   static final String BINDS_METHOD_ONE_ASSIGNABLE_PARAMETER =
       "@Binds methods must have only one parameter whose type is assignable to the return type";
 
   static final String BINDING_METHOD_NOT_IN_MODULE =
       "@%s methods can only be present within a @%s";
 
+  static final String BINDS_ELEMENTS_INTO_SET_METHOD_RETURN_SET =
+      "@Binds @ElementsIntoSet methods must return a Set and take a Set parameter";
+
   static final String BINDING_METHOD_NOT_MAP_HAS_MAP_KEY =
       "@%s methods of non map type cannot declare a map key";
 
@@ -291,8 +300,8 @@ static String nullableToNonNullable(String typeName, String bindingString) {
       "Cannot return null from a non-@Nullable @Provides method";
 
   /* Multibinding messages */
-  static final String MULTIBINDING_ANNOTATION_NOT_ON_PROVIDES_OR_PRODUCES =
-      "Multibinding annotations may only be on @Provides or @Produces methods";
+  static final String MULTIBINDING_ANNOTATION_NOT_ON_BINDING_METHOD =
+      "Multibinding annotations may only be on @Provides, @Produces, or @Binds methods";
 
   static final String MULTIPLE_MULTIBINDING_ANNOTATIONS_ON_METHOD =
       "Multiple multibinding annotations cannot be placed on the same %s method";
diff --git a/compiler/src/main/java/dagger/internal/codegen/Key.java b/compiler/src/main/java/dagger/internal/codegen/Key.java
index c67d374d8..8be35bdd5 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Key.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Key.java
@@ -322,7 +322,7 @@ private Key forProvidesOrProducesMethod(
         returnType = Iterables.getOnlyElement(MoreTypes.asDeclared(returnType).getTypeArguments());
       }
       TypeMirror keyType =
-          providesOrProducesKeyType(returnType, method, contributionType, frameworkType);
+          bindingMethodKeyType(returnType, method, contributionType, frameworkType);
       Key key = forMethod(method, keyType);
       return contributionType.equals(ContributionType.UNIQUE)
           ? key
@@ -356,10 +356,24 @@ Key forMultibindsMethod(
     /** Returns the key bound by a {@link Binds} method. */
     Key forBindsMethod(ExecutableElement method, ExecutableType methodType) {
       checkArgument(isAnnotationPresent(method, Binds.class));
-      return forMethod(method, normalize(types, methodType.getReturnType()));
+      ContributionType contributionType = ContributionType.fromBindingMethod(method);
+      TypeMirror returnType = normalize(types, methodType.getReturnType());
+      TypeMirror keyType =
+          bindingMethodKeyType(
+              // TODO(ronshapiro): Map<K, Framework<V>> can't be determined at this point. When
+              // @IntoMap support is added, consider replacing getProviderElement() with a
+              // placeholder type, which is then replaced when the DelegateDeclaration is translated
+              // into a Provision or ProductionBinding
+              returnType, method, contributionType, getProviderElement());
+      Key key = forMethod(method, keyType);
+      return contributionType.equals(ContributionType.UNIQUE)
+          ? key
+          : key.withBindingMethodIdentifier(
+              BindingMethodIdentifier.create(
+                  method, MoreElements.asType(method.getEnclosingElement())));
     }
 
-    private TypeMirror providesOrProducesKeyType(
+    private TypeMirror bindingMethodKeyType(
         TypeMirror returnType,
         ExecutableElement method,
         ContributionType contributionType,
diff --git a/compiler/src/main/java/dagger/internal/codegen/MultibindingAnnotationsProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/MultibindingAnnotationsProcessingStep.java
index 108557e91..6da60c38c 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MultibindingAnnotationsProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MultibindingAnnotationsProcessingStep.java
@@ -16,11 +16,9 @@
 package dagger.internal.codegen;
 
 import com.google.auto.common.BasicAnnotationProcessor.ProcessingStep;
-import com.google.common.base.Predicate;
-import com.google.common.base.Predicates;
-import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.SetMultimap;
+import dagger.Binds;
 import dagger.Provides;
 import dagger.multibindings.ElementsIntoSet;
 import dagger.multibindings.IntoMap;
@@ -35,8 +33,8 @@
 import javax.tools.Diagnostic.Kind;
 
 import static com.google.auto.common.MoreElements.getAnnotationMirror;
-import static dagger.internal.codegen.ErrorMessages.MULTIBINDING_ANNOTATION_NOT_ON_PROVIDES_OR_PRODUCES;
-import static dagger.internal.codegen.Util.hasAnnotationType;
+import static dagger.internal.codegen.ErrorMessages.MULTIBINDING_ANNOTATION_NOT_ON_BINDING_METHOD;
+import static dagger.internal.codegen.Util.isAnyAnnotationPresent;
 
 /**
  * Processing step which verifies that {@link IntoSet @IntoSet}, {@link ElementsIntoSet
@@ -44,6 +42,9 @@
  */
 final class MultibindingAnnotationsProcessingStep implements ProcessingStep {
 
+  private static final ImmutableSet<Class<? extends Annotation>> VALID_BINDING_ANNOTATIONS =
+      ImmutableSet.of(Provides.class, Produces.class, Binds.class);
+
   private final Messager messager;
 
   MultibindingAnnotationsProcessingStep(Messager messager) {
@@ -60,18 +61,12 @@
       SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
     for (Entry<Class<? extends Annotation>, Element> entry : elementsByAnnotation.entries()) {
       Element element = entry.getValue();
-      boolean onBindingMethod =
-          FluentIterable.from(element.getAnnotationMirrors()).anyMatch(providesOrProducesMethod());
-      if (!onBindingMethod) {
+      if (!isAnyAnnotationPresent(element, VALID_BINDING_ANNOTATIONS)) {
         AnnotationMirror annotation = getAnnotationMirror(entry.getValue(), entry.getKey()).get();
         messager.printMessage(
-            Kind.ERROR, MULTIBINDING_ANNOTATION_NOT_ON_PROVIDES_OR_PRODUCES, element, annotation);
+            Kind.ERROR, MULTIBINDING_ANNOTATION_NOT_ON_BINDING_METHOD, element, annotation);
       }
     }
     return ImmutableSet.of();
   }
-
-  private static Predicate<AnnotationMirror> providesOrProducesMethod() {
-    return Predicates.or(hasAnnotationType(Provides.class), hasAnnotationType(Produces.class));
-  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
index 38830b8a3..da904aa31 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
@@ -24,7 +24,6 @@
 import com.google.common.collect.Sets;
 import com.google.common.util.concurrent.ListenableFuture;
 import java.util.Set;
-
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
@@ -165,7 +164,7 @@ ProductionBinding syntheticMapOfValuesOrProducedBinding(
      * <p>Note that these could be set multibindings or map multibindings.
      */
     ProductionBinding syntheticMultibinding(
-        final DependencyRequest request, Iterable<ContributionBinding> multibindingContributions) {
+        DependencyRequest request, Iterable<ContributionBinding> multibindingContributions) {
       return new AutoValue_ProductionBinding(
           ContributionType.UNIQUE,
           request.requestElement(),
@@ -206,7 +205,7 @@ ProductionBinding forComponentMethod(ExecutableElement componentMethod) {
     ProductionBinding delegate(
         DelegateDeclaration delegateDeclaration, ProductionBinding delegateBinding) {
       return new AutoValue_ProductionBinding(
-          delegateBinding.contributionType(),
+          delegateDeclaration.contributionType(),
           delegateDeclaration.bindingElement(),
           delegateDeclaration.contributingModule(),
           delegateDeclaration.key(),
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
index 7a61391ce..c72ed21ab 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
@@ -217,7 +217,7 @@ ProvisionBinding syntheticMapOfValuesBinding(DependencyRequest requestForMapOfVa
      * <p>Note that these could be set multibindings or map multibindings.
      */
     ProvisionBinding syntheticMultibinding(
-        final DependencyRequest request, Iterable<ContributionBinding> multibindingContributions) {
+        DependencyRequest request, Iterable<ContributionBinding> multibindingContributions) {
       return new AutoValue_ProvisionBinding(
           ContributionType.UNIQUE,
           request.requestElement(),
@@ -294,7 +294,7 @@ ProvisionBinding forSubcomponentBuilderMethod(
     ProvisionBinding delegate(
         DelegateDeclaration delegateDeclaration, ProvisionBinding delegate) {
       return new AutoValue_ProvisionBinding(
-          delegate.contributionType(),
+          delegateDeclaration.contributionType(),
           delegateDeclaration.bindingElement(),
           delegateDeclaration.contributingModule(),
           delegateDeclaration.key(),
@@ -302,7 +302,6 @@ ProvisionBinding delegate(
           findBindingPackage(delegateDeclaration.key()),
           delegate.nullableType(),
           Optional.<DependencyRequest>absent(),
-          // TODO(ronshapiro): for @Binds @IntoMap, this should be delegateDeclaration.mapKey()
           Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
           Kind.SYNTHETIC_DELEGATE_BINDING,
           Optional.<ProvisionBinding>absent(),
diff --git a/compiler/src/test/java/dagger/internal/codegen/BindsMethodValidatorTest.java b/compiler/src/test/java/dagger/internal/codegen/BindsMethodValidatorTest.java
index 05071f493..57c702b7b 100644
--- a/compiler/src/test/java/dagger/internal/codegen/BindsMethodValidatorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/BindsMethodValidatorTest.java
@@ -99,6 +99,31 @@ public void noParameters() {
     assertThatMethod("@Binds abstract Object noParameters();").hasError("one parameter");
   }
 
+  @Test
+  public void intoMap() {
+    assertThatMethod("@Binds @IntoMap @IntKey(1) abstract Object bindObject(String string);")
+        .hasError("@Binds @IntoMap is not yet supported");
+  }
+
+  @Test
+  public void setElementsNotAssignable() {
+    assertThatMethod(
+            "@Binds @ElementsIntoSet abstract Set<String> bindSetOfIntegers(Set<Integer> ints);")
+        .hasError("assignable");
+  }
+
+  @Test
+  public void setElements_primitiveArgument() {
+    assertThatMethod("@Binds @ElementsIntoSet abstract Set<Number> bindInt(int integer);")
+        .hasError("assignable");
+  }
+
+  @Test
+  public void elementsIntoSet_withRawSets() {
+    assertThatMethod("@Binds @ElementsIntoSet abstract Set bindRawSet(HashSet hashSet);")
+        .hasError("cannot return a raw Set");
+  }
+
   private DaggerModuleMethodSubject assertThatMethod(String method) {
     return assertThatModuleMethod(method).withDeclaration(moduleDeclaration);
   }
diff --git a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
index f535d430e..9dfe0a6c6 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
@@ -1137,7 +1137,7 @@ public void subcomponentOmitsInheritedBindings() {
             "        SetModule_StringFactory.create(builder.setModule);",
             "    this.setOfStringProvider = ",
             "        SetFactory.<String>builder(1, 1)",
-            "            .addSetProvider(emptySetProvider)",
+            "            .addCollectionProvider(emptySetProvider)",
             "            .addProvider(stringProvider)",
             "            .build();",
             "  }",
diff --git a/compiler/src/test/java/dagger/internal/codegen/MultibindingTest.java b/compiler/src/test/java/dagger/internal/codegen/MultibindingTest.java
index 5b2728e88..90da7f518 100644
--- a/compiler/src/test/java/dagger/internal/codegen/MultibindingTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/MultibindingTest.java
@@ -142,17 +142,17 @@ public void appliedOnInvalidMethods_failsToCompile() {
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(
-            "Multibinding annotations may only be on @Provides or @Produces methods")
+            "Multibinding annotations may only be on @Provides, @Produces, or @Binds methods")
         .in(component)
         .onLine(12)
         .and()
         .withErrorContaining(
-            "Multibinding annotations may only be on @Provides or @Produces methods")
+            "Multibinding annotations may only be on @Provides, @Produces, or @Binds methods")
         .in(component)
         .onLine(13)
         .and()
         .withErrorContaining(
-            "Multibinding annotations may only be on @Provides or @Produces methods")
+            "Multibinding annotations may only be on @Provides, @Produces, or @Binds methods")
         .in(component)
         .onLine(14);
   }
diff --git a/core/src/main/java/dagger/internal/SetFactory.java b/core/src/main/java/dagger/internal/SetFactory.java
index d4e89f9a8..d2148ca18 100644
--- a/core/src/main/java/dagger/internal/SetFactory.java
+++ b/core/src/main/java/dagger/internal/SetFactory.java
@@ -16,6 +16,7 @@
 package dagger.internal;
 
 import java.util.ArrayList;
+import java.util.Collection;
 import java.util.List;
 import java.util.Set;
 import javax.inject.Provider;
@@ -51,54 +52,60 @@
 
   /**
    * Constructs a new {@link Builder} for a {@link SetFactory} with {@code individualProviderSize}
-   * individual {@code Provider<T>} and {@code setProviderSize} {@code Provider<Set<T>>} instances.
+   * individual {@code Provider<T>} and {@code collectionProviderSize} {@code
+   * Provider<Collection<T>>} instances.
    */
-  public static <T> Builder<T> builder(int individualProviderSize, int setProviderSize) {
-    return new Builder<T>(individualProviderSize, setProviderSize);
+  public static <T> Builder<T> builder(int individualProviderSize, int collectionProviderSize) {
+    return new Builder<T>(individualProviderSize, collectionProviderSize);
   }
 
   /**
-   * A builder to accumulate {@code Provider<T>} and {@code Provider<Set<T>>} instances. These are
-   * only intended to be single-use and from within generated code. Do <em>NOT</em> add providers
-   * after calling {@link #build()}.
+   * A builder to accumulate {@code Provider<T>} and {@code Provider<Collection<T>>} instances.
+   * These are only intended to be single-use and from within generated code. Do <em>NOT</em> add
+   * providers after calling {@link #build()}.
    */
   public static final class Builder<T> {
     private final List<Provider<T>> individualProviders;
-    private final List<Provider<Set<T>>> setProviders;
+    private final List<Provider<Collection<T>>> collectionProviders;
 
-    private Builder(int individualProviderSize, int setProviderSize) {
+    private Builder(int individualProviderSize, int collectionProviderSize) {
       individualProviders = presizedList(individualProviderSize);
-      setProviders = presizedList(setProviderSize);
+      collectionProviders = presizedList(collectionProviderSize);
     }
 
-    public Builder<T> addProvider(Provider<T> individualProvider) {
+    @SuppressWarnings("unchecked")
+    public Builder<T> addProvider(Provider<? extends T> individualProvider) {
       assert individualProvider != null : "Codegen error? Null provider";
-      individualProviders.add(individualProvider);
+      // TODO(ronshapiro): Store a List<? extends Provider<T>> and avoid the cast to Provider<T>
+      individualProviders.add((Provider<T>) individualProvider);
       return this;
     }
 
-    public Builder<T> addSetProvider(Provider<Set<T>> multipleProvider) {
-      assert multipleProvider != null : "Codegen error? Null provider";
-      setProviders.add(multipleProvider);
+    @SuppressWarnings("unchecked")
+    public Builder<T> addCollectionProvider(
+        Provider<? extends Collection<? extends T>> collectionProvider) {
+      assert collectionProvider != null : "Codegen error? Null provider";
+      collectionProviders.add((Provider<Collection<T>>) collectionProvider);
       return this;
     }
 
     public SetFactory<T> build() {
       assert !hasDuplicates(individualProviders)
           : "Codegen error?  Duplicates in the provider list";
-      assert !hasDuplicates(setProviders)
+      assert !hasDuplicates(collectionProviders)
           : "Codegen error?  Duplicates in the provider list";
 
-      return new SetFactory<T>(individualProviders, setProviders);
+      return new SetFactory<T>(individualProviders, collectionProviders);
     }
   }
 
   private final List<Provider<T>> individualProviders;
-  private final List<Provider<Set<T>>> setProviders;
+  private final List<Provider<Collection<T>>> collectionProviders;
 
-  private SetFactory(List<Provider<T>> individualProviders, List<Provider<Set<T>>> setProviders) {
+  private SetFactory(
+      List<Provider<T>> individualProviders, List<Provider<Collection<T>>> collectionProviders) {
     this.individualProviders = individualProviders;
-    this.setProviders = setProviders;
+    this.collectionProviders = collectionProviders;
   }
 
   /**
@@ -115,19 +122,20 @@ private SetFactory(List<Provider<T>> individualProviders, List<Provider<Set<T>>>
     // these loops were changed to use c-style for.  Versus enhanced for-each loops, C-style for is
     // faster for ArrayLists, at least through Java 8.
 
-    List<Set<T>> providedSets = new ArrayList<Set<T>>(setProviders.size());
-    for (int i = 0, c = setProviders.size(); i < c; i++) {
-      Set<T> providedSet = setProviders.get(i).get();
-      size += providedSet.size();
-      providedSets.add(providedSet);
+    List<Collection<T>> providedCollections =
+        new ArrayList<Collection<T>>(collectionProviders.size());
+    for (int i = 0, c = collectionProviders.size(); i < c; i++) {
+      Collection<T> providedCollection = collectionProviders.get(i).get();
+      size += providedCollection.size();
+      providedCollections.add(providedCollection);
     }
 
     Set<T> providedValues = newHashSetWithExpectedSize(size);
     for (int i = 0, c = individualProviders.size(); i < c; i++) {
       providedValues.add(checkNotNull(individualProviders.get(i).get()));
     }
-    for (int i = 0, c = providedSets.size(); i < c; i++) {
-      for (T element : providedSets.get(i)) {
+    for (int i = 0, c = providedCollections.size(); i < c; i++) {
+      for (T element : providedCollections.get(i)) {
         providedValues.add(checkNotNull(element));
       }
     }
diff --git a/core/src/test/java/dagger/internal/SetFactoryTest.java b/core/src/test/java/dagger/internal/SetFactoryTest.java
index b6d5d78ab..af7cb99bf 100644
--- a/core/src/test/java/dagger/internal/SetFactoryTest.java
+++ b/core/src/test/java/dagger/internal/SetFactoryTest.java
@@ -37,7 +37,7 @@
   @Test
   public void providerReturnsNull() {
     Factory<Set<Integer>> factory =
-        SetFactory.<Integer>builder(0, 1).addSetProvider(providerOf((Set<Integer>) null)).build();
+        SetFactory.<Integer>builder(0, 1).addCollectionProvider(providerOf((Set<Integer>) null)).build();
     thrown.expect(NullPointerException.class);
     factory.get();
   }
@@ -54,7 +54,7 @@ public void providerReturnsNullSet() {
   public void providerReturnsSetWithNullElement() {
     Set<Integer> set = new LinkedHashSet<Integer>(Arrays.asList(1, null, 3));
     Factory<Set<Integer>> factory =
-        SetFactory.<Integer>builder(0, 1).addSetProvider(providerOf(set)).build();
+        SetFactory.<Integer>builder(0, 1).addCollectionProvider(providerOf(set)).build();
     thrown.expect(NullPointerException.class);
     factory.get();
   }
@@ -65,8 +65,8 @@ public void invokesProvidersEveryTime() {
         SetFactory.<Integer>builder(2, 2)
             .addProvider(incrementingIntegerProvider(0))
             .addProvider(incrementingIntegerProvider(10))
-            .addSetProvider(incrementingIntegerSetProvider(20))
-            .addSetProvider(incrementingIntegerSetProvider(30))
+            .addCollectionProvider(incrementingIntegerSetProvider(20))
+            .addCollectionProvider(incrementingIntegerSetProvider(30))
             .build();
     assertThat(factory.get()).containsExactly(0, 10, 20, 21, 30, 31);
     assertThat(factory.get()).containsExactly(1, 11, 22, 23, 32, 33);
diff --git a/producers/src/main/java/dagger/producers/internal/SetOfProducedProducer.java b/producers/src/main/java/dagger/producers/internal/SetOfProducedProducer.java
index ef3d763fa..d0c445260 100644
--- a/producers/src/main/java/dagger/producers/internal/SetOfProducedProducer.java
+++ b/producers/src/main/java/dagger/producers/internal/SetOfProducedProducer.java
@@ -22,6 +22,7 @@
 import dagger.producers.Produced;
 import dagger.producers.Producer;
 import java.util.ArrayList;
+import java.util.Collection;
 import java.util.List;
 import java.util.Set;
 import java.util.concurrent.ExecutionException;
@@ -45,63 +46,67 @@
 
   /**
    * Constructs a new {@link Builder} for a {@link SetProducer} with {@code individualProducerSize}
-   * individual {@code Producer<T>} and {@code setProducerSize} {@code Producer<Set<T>>} instances.
+   * individual {@code Producer<T>} and {@code collectionProducerSize} {@code
+   * Producer<Collection<T>>} instances.
    */
-  public static <T> Builder<T> builder(int individualProducerSize, int setProducerSize) {
-    return new Builder<T>(individualProducerSize, setProducerSize);
+  public static <T> Builder<T> builder(int individualProducerSize, int collectionProducerSize) {
+    return new Builder<T>(individualProducerSize, collectionProducerSize);
   }
 
   /**
-   * A builder to accumulate {@code Producer<T>} and {@code Producer<Set<T>>} instances. These are
-   * only intended to be single-use and from within generated code. Do <em>NOT</em> add producers
-   * after calling {@link #build()}.
+   * A builder to accumulate {@code Producer<T>} and {@code Producer<Collection<T>>} instances.
+   * These are only intended to be single-use and from within generated code. Do <em>NOT</em> add
+   * producers after calling {@link #build()}.
    */
   public static final class Builder<T> {
     private final List<Producer<T>> individualProducers;
-    private final List<Producer<Set<T>>> setProducers;
+    private final List<Producer<Collection<T>>> collectionProducers;
 
-    private Builder(int individualProducerSize, int setProducerSize) {
+    private Builder(int individualProducerSize, int collectionProducerSize) {
       individualProducers = presizedList(individualProducerSize);
-      setProducers = presizedList(setProducerSize);
+      collectionProducers = presizedList(collectionProducerSize);
     }
 
-    public Builder<T> addProducer(Producer<T> individualProducer) {
+    @SuppressWarnings("unchecked")
+    public Builder<T> addProducer(Producer<? extends T> individualProducer) {
       assert individualProducer != null : "Codegen error? Null producer";
-      individualProducers.add(individualProducer);
+      individualProducers.add((Producer<T>) individualProducer);
       return this;
     }
 
-    public Builder<T> addSetProducer(Producer<Set<T>> multipleProducer) {
+    @SuppressWarnings("unchecked")
+    public Builder<T> addCollectionProducer(
+        Producer<? extends Collection<? extends T>> multipleProducer) {
       assert multipleProducer != null : "Codegen error? Null producer";
-      setProducers.add(multipleProducer);
+      collectionProducers.add((Producer<Collection<T>>) multipleProducer);
       return this;
     }
 
     public SetOfProducedProducer<T> build() {
       assert !hasDuplicates(individualProducers)
           : "Codegen error?  Duplicates in the producer list";
-      assert !hasDuplicates(setProducers)
+      assert !hasDuplicates(collectionProducers)
           : "Codegen error?  Duplicates in the producer list";
 
-      return new SetOfProducedProducer<T>(individualProducers, setProducers);
+      return new SetOfProducedProducer<T>(individualProducers, collectionProducers);
     }
   }
 
   private final List<Producer<T>> individualProducers;
-  private final List<Producer<Set<T>>> setProducers;
+  private final List<Producer<Collection<T>>> collectionProducers;
 
   private SetOfProducedProducer(
-      List<Producer<T>> individualProducers, List<Producer<Set<T>>> setProducers) {
+      List<Producer<T>> individualProducers, List<Producer<Collection<T>>> collectionProducers) {
     this.individualProducers = individualProducers;
-    this.setProducers = setProducers;
+    this.collectionProducers = collectionProducers;
   }
 
   /**
    * Returns a future {@link Set} of {@link Produced} values whose iteration order is that of the
    * elements given by each of the producers, which are invoked in the order given at creation.
    *
-   * <p>If any of the delegate sets, or any elements therein, are null, then that corresponding
-   * {@code Produced} element will fail with a NullPointerException.
+   * <p>If any of the delegate collections, or any elements therein, are null, then that
+   * corresponding {@code Produced} element will fail with a NullPointerException.
    *
    * <p>Canceling this future will attempt to cancel all of the component futures; but if any of the
    * delegate futures fail or are canceled, this future succeeds, with the appropriate failed
@@ -111,40 +116,41 @@ private SetOfProducedProducer(
    */
   @Override
   public ListenableFuture<Set<Produced<T>>> compute() {
-    List<ListenableFuture<Produced<Set<T>>>> futureProducedSets =
-        new ArrayList<ListenableFuture<Produced<Set<T>>>>(
-            individualProducers.size() + setProducers.size());
+    List<ListenableFuture<? extends Produced<? extends Collection<T>>>> futureProducedCollections =
+        new ArrayList<ListenableFuture<? extends Produced<? extends Collection<T>>>>(
+            individualProducers.size() + collectionProducers.size());
     for (Producer<T> producer : individualProducers) {
-      // TODO(ronshapiro): Don't require individual productions to be added to a set just to be
-      // materialized into futureProducedSets.
-      futureProducedSets.add(
+      // TODO(ronshapiro): Don't require individual productions to be added to a collection just to
+      // be materialized into futureProducedCollections.
+      futureProducedCollections.add(
           Producers.createFutureProduced(
               Producers.createFutureSingletonSet(checkNotNull(producer.get()))));
     }
-    for (Producer<Set<T>> producer : setProducers) {
-      futureProducedSets.add(Producers.createFutureProduced(checkNotNull(producer.get())));
+    for (Producer<Collection<T>> producer : collectionProducers) {
+      futureProducedCollections.add(Producers.createFutureProduced(checkNotNull(producer.get())));
     }
 
     return Futures.transform(
-        Futures.allAsList(futureProducedSets),
-        new Function<List<Produced<Set<T>>>, Set<Produced<T>>>() {
+        Futures.allAsList(futureProducedCollections),
+        new Function<List<Produced<? extends Collection<T>>>, Set<Produced<T>>>() {
           @Override
-          public Set<Produced<T>> apply(List<Produced<Set<T>>> producedSets) {
+          public Set<Produced<T>> apply(
+              List<Produced<? extends Collection<T>>> producedCollections) {
             ImmutableSet.Builder<Produced<T>> builder = ImmutableSet.builder();
-            for (Produced<Set<T>> producedSet : producedSets) {
+            for (Produced<? extends Collection<T>> producedCollection : producedCollections) {
               try {
-                Set<T> set = producedSet.get();
-                if (set == null) {
+                Collection<T> collection = producedCollection.get();
+                if (collection == null) {
                   // TODO(beder): This is a vague exception. Can we somehow point to the failing
                   // producer? See the similar comment in the component writer about null
                   // provisions.
                   builder.add(
                       Produced.<T>failed(
                           new NullPointerException(
-                              "Cannot contribute a null set into a producer set binding when it's"
-                                  + " injected as Set<Produced<T>>.")));
+                              "Cannot contribute a null collection into a producer set binding when"
+                                  + " it's injected as Set<Produced<T>>.")));
                 } else {
-                  for (T value : set) {
+                  for (T value : collection) {
                     if (value == null) {
                       builder.add(
                           Produced.<T>failed(
diff --git a/producers/src/main/java/dagger/producers/internal/SetProducer.java b/producers/src/main/java/dagger/producers/internal/SetProducer.java
index b2e8506f7..e3c0dde94 100644
--- a/producers/src/main/java/dagger/producers/internal/SetProducer.java
+++ b/producers/src/main/java/dagger/producers/internal/SetProducer.java
@@ -21,6 +21,7 @@
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.producers.Producer;
 import java.util.ArrayList;
+import java.util.Collection;
 import java.util.List;
 import java.util.Set;
 
@@ -52,63 +53,67 @@
 
   /**
    * Constructs a new {@link Builder} for a {@link SetProducer} with {@code individualProducerSize}
-   * individual {@code Producer<T>} and {@code setProducerSize} {@code Producer<Set<T>>} instances.
+   * individual {@code Producer<T>} and {@code collectionProducerSize} {@code
+   * Producer<Collection<T>>} instances.
    */
-  public static <T> Builder<T> builder(int individualProducerSize, int setProducerSize) {
-    return new Builder<T>(individualProducerSize, setProducerSize);
+  public static <T> Builder<T> builder(int individualProducerSize, int collectionProducerSize) {
+    return new Builder<T>(individualProducerSize, collectionProducerSize);
   }
 
   /**
-   * A builder to accumulate {@code Producer<T>} and {@code Producer<Set<T>>} instances. These are
-   * only intended to be single-use and from within generated code. Do <em>NOT</em> add producers
-   * after calling {@link #build()}.
+   * A builder to accumulate {@code Producer<T>} and {@code Producer<Collection<T>>} instances.
+   * These are only intended to be single-use and from within generated code. Do <em>NOT</em> add
+   * producers after calling {@link #build()}.
    */
   public static final class Builder<T> {
     private final List<Producer<T>> individualProducers;
-    private final List<Producer<Set<T>>> setProducers;
+    private final List<Producer<Collection<T>>> collectionProducers;
 
-    private Builder(int individualProducerSize, int setProducerSize) {
+    private Builder(int individualProducerSize, int collectionProducerSize) {
       individualProducers = presizedList(individualProducerSize);
-      setProducers = presizedList(setProducerSize);
+      collectionProducers = presizedList(collectionProducerSize);
     }
 
-    public Builder<T> addProducer(Producer<T> individualProducer) {
+    @SuppressWarnings("unchecked")
+    public Builder<T> addProducer(Producer<? extends T> individualProducer) {
       assert individualProducer != null : "Codegen error? Null producer";
-      individualProducers.add(individualProducer);
+      individualProducers.add((Producer<T>) individualProducer);
       return this;
     }
 
-    public Builder<T> addSetProducer(Producer<Set<T>> multipleProducer) {
+    @SuppressWarnings("unchecked")
+    public Builder<T> addCollectionProducer(
+        Producer<? extends Collection<? extends T>> multipleProducer) {
       assert multipleProducer != null : "Codegen error? Null producer";
-      setProducers.add(multipleProducer);
+      collectionProducers.add((Producer<Collection<T>>) multipleProducer);
       return this;
     }
 
     public SetProducer<T> build() {
       assert !hasDuplicates(individualProducers)
           : "Codegen error?  Duplicates in the producer list";
-      assert !hasDuplicates(setProducers)
+      assert !hasDuplicates(collectionProducers)
           : "Codegen error?  Duplicates in the producer list";
 
-      return new SetProducer<T>(individualProducers, setProducers);
+      return new SetProducer<T>(individualProducers, collectionProducers);
     }
   }
 
   private final List<Producer<T>> individualProducers;
-  private final List<Producer<Set<T>>> setProducers;
+  private final List<Producer<Collection<T>>> collectionProducers;
 
   private SetProducer(
-      List<Producer<T>> individualProducers, List<Producer<Set<T>>> setProducers) {
+      List<Producer<T>> individualProducers, List<Producer<Collection<T>>> collectionProducers) {
     this.individualProducers = individualProducers;
-    this.setProducers = setProducers;
+    this.collectionProducers = collectionProducers;
   }
 
   /**
    * Returns a future {@link Set} whose iteration order is that of the elements given by each of the
    * producers, which are invoked in the order given at creation.
    *
-   * <p>If any of the delegate sets, or any elements therein, are null, then this future will fail
-   * with a NullPointerException.
+   * <p>If any of the delegate collections, or any elements therein, are null, then this future will
+   * fail with a NullPointerException.
    *
    * <p>Canceling this future will attempt to cancel all of the component futures, and if any of the
    * delegate futures fails or is canceled, this one is, too.
@@ -123,30 +128,25 @@ private SetProducer(
       individualFutures.add(checkNotNull(producer.get()));
     }
 
-    List<ListenableFuture<Set<T>>> futureSets =
-        new ArrayList<ListenableFuture<Set<T>>>(setProducers.size() + 1);
-    futureSets.add(
-        Futures.transform(
-            Futures.allAsList(individualFutures),
-            // TODO(ronshapiro): make static instances of these transformation functions
-            new Function<List<T>, Set<T>>() {
-              @Override
-              public Set<T> apply(List<T> list) {
-                return ImmutableSet.copyOf(list);
-              }
-            }));
-
-    for (Producer<Set<T>> producer : setProducers) {
-      futureSets.add(checkNotNull(producer.get()));
+    // Presize the list of collections produced by the amount of collectionProducers, with one more
+    // for the consolidate individualFutures from Futures.allAsList.
+    List<ListenableFuture<? extends Collection<T>>> futureCollections =
+        new ArrayList<ListenableFuture<? extends Collection<T>>>(collectionProducers.size() + 1);
+    futureCollections.add(Futures.allAsList(individualFutures));
+    for (Producer<Collection<T>> producer : collectionProducers) {
+      futureCollections.add(checkNotNull(producer.get()));
     }
-    return Futures.transform(Futures.allAsList(futureSets), new Function<List<Set<T>>, Set<T>>() {
-      @Override public Set<T> apply(List<Set<T>> sets) {
-        ImmutableSet.Builder<T> builder = ImmutableSet.builder();
-        for (Set<T> set : sets) {
-          builder.addAll(set);
-        }
-        return builder.build();
-      }
-    });
+    return Futures.transform(
+        Futures.allAsList(futureCollections),
+        new Function<List<Collection<T>>, Set<T>>() {
+          @Override
+          public Set<T> apply(List<Collection<T>> sets) {
+            ImmutableSet.Builder<T> builder = ImmutableSet.builder();
+            for (Collection<T> set : sets) {
+              builder.addAll(set);
+            }
+            return builder.build();
+          }
+        });
   }
 }
diff --git a/producers/src/test/java/dagger/producers/internal/SetOfProducedProducerTest.java b/producers/src/test/java/dagger/producers/internal/SetOfProducedProducerTest.java
index 1f87a6f99..e92ef745e 100644
--- a/producers/src/test/java/dagger/producers/internal/SetOfProducedProducerTest.java
+++ b/producers/src/test/java/dagger/producers/internal/SetOfProducedProducerTest.java
@@ -40,7 +40,7 @@ public void success() throws Exception {
     Producer<Set<Produced<Integer>>> producer =
         SetOfProducedProducer.<Integer>builder(1, 1)
             .addProducer(Producers.immediateProducer(1))
-            .addSetProducer(Producers.<Set<Integer>>immediateProducer(ImmutableSet.of(5, 7)))
+            .addCollectionProducer(Producers.<Set<Integer>>immediateProducer(ImmutableSet.of(5, 7)))
             .build();
     assertThat(producer.get().get())
         .containsExactly(
@@ -54,7 +54,7 @@ public void failure() throws Exception {
     RuntimeException e = new RuntimeException("monkey");
     Producer<Set<Produced<Integer>>> producer =
         SetOfProducedProducer.<Integer>builder(1, 1)
-            .addSetProducer(Producers.<Set<Integer>>immediateProducer(ImmutableSet.of(1, 2)))
+            .addCollectionProducer(Producers.<Set<Integer>>immediateProducer(ImmutableSet.of(1, 2)))
             .addProducer(Producers.<Integer>immediateFailedProducer(e))
             .build();
     assertThat(producer.get().get())
@@ -79,7 +79,7 @@ public void delegateNpe() throws Exception {
   public void delegateSetNpe() throws Exception {
     Producer<Set<Produced<Integer>>> producer =
         SetOfProducedProducer.<Integer>builder(0, 1)
-            .addSetProducer(Producers.<Set<Integer>>immediateProducer(null))
+            .addCollectionProducer(Producers.<Set<Integer>>immediateProducer(null))
             .build();
     Results<Integer> results = Results.create(producer.get().get());
     assertThat(results.successes).isEmpty();
@@ -92,7 +92,7 @@ public void delegateSetNpe() throws Exception {
   public void delegateElementNpe() throws Exception {
     Producer<Set<Produced<Integer>>> producer =
         SetOfProducedProducer.<Integer>builder(0, 1)
-            .addSetProducer(
+            .addCollectionProducer(
                 Producers.<Set<Integer>>immediateProducer(Collections.<Integer>singleton(null)))
             .build();
     Results<Integer> results = Results.create(producer.get().get());
@@ -106,7 +106,7 @@ public void delegateElementNpe() throws Exception {
   public void oneOfDelegateElementNpe() throws Exception {
     Producer<Set<Produced<Integer>>> producer =
         SetOfProducedProducer.<Integer>builder(0, 1)
-            .addSetProducer(
+            .addCollectionProducer(
                 Producers.<Set<Integer>>immediateProducer(
                     Sets.newHashSet(Arrays.asList(5, 2, null))))
             .build();
diff --git a/producers/src/test/java/dagger/producers/internal/SetProducerTest.java b/producers/src/test/java/dagger/producers/internal/SetProducerTest.java
index da250945e..9ad22daf1 100644
--- a/producers/src/test/java/dagger/producers/internal/SetProducerTest.java
+++ b/producers/src/test/java/dagger/producers/internal/SetProducerTest.java
@@ -38,7 +38,7 @@ public void success() throws Exception {
     Producer<Set<Integer>> producer =
         SetProducer.<Integer>builder(1, 1)
             .addProducer(Producers.immediateProducer(1))
-            .addSetProducer(Producers.<Set<Integer>>immediateProducer(ImmutableSet.of(5, 7)))
+            .addCollectionProducer(Producers.<Set<Integer>>immediateProducer(ImmutableSet.of(5, 7)))
             .build();
     assertThat(producer.get().get()).containsExactly(1, 5, 7);
   }
@@ -62,7 +62,7 @@ public void delegateNpe() throws Exception {
   public void delegateSetNpe() throws Exception {
     Producer<Set<Integer>> producer =
         SetProducer.<Integer>builder(0, 1)
-            .addSetProducer(Producers.<Set<Integer>>immediateProducer(null))
+            .addCollectionProducer(Producers.<Set<Integer>>immediateProducer(null))
             .build();
     ListenableFuture<Set<Integer>> future = producer.get();
     try {
@@ -77,8 +77,8 @@ public void delegateSetNpe() throws Exception {
   public void delegateElementNpe() throws Exception {
     Producer<Set<Integer>> producer =
         SetProducer.<Integer>builder(0, 2)
-            .addSetProducer(Producers.<Set<Integer>>immediateProducer(ImmutableSet.of(1, 2)))
-            .addSetProducer(
+            .addCollectionProducer(Producers.<Set<Integer>>immediateProducer(ImmutableSet.of(1, 2)))
+            .addCollectionProducer(
                 Producers.<Set<Integer>>immediateProducer(Collections.<Integer>singleton(null)))
             .build();
     ListenableFuture<Set<Integer>> future = producer.get();
