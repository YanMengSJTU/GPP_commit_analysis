diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
index 70a3a648d..d0c1888c0 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
@@ -17,22 +17,16 @@
 
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
-import com.google.common.base.Function;
 import com.google.common.base.Optional;
-import com.google.common.collect.FluentIterable;
-import com.google.common.collect.ImmutableListMultimap;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.ImmutableSetMultimap;
 import com.google.common.collect.Maps;
 import com.google.common.collect.Queues;
 import dagger.Provides;
-import dagger.internal.codegen.BindingGraph.ResolvedBindings.State;
-import dagger.internal.codegen.ContributionBinding.BindingType;
 import java.util.Deque;
 import java.util.List;
 import java.util.Map;
-import java.util.Set;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.Modifier;
@@ -45,7 +39,6 @@
 
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static com.google.common.base.Preconditions.checkState;
-import static com.google.common.collect.Iterables.getOnlyElement;
 import static dagger.internal.codegen.ComponentDescriptor.isComponentProvisionMethod;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentModules;
@@ -67,88 +60,12 @@
 
   @AutoValue
   abstract static class ResolvedBindings {
-    enum State {
-      COMPLETE,
-      INCOMPLETE,
-      MULTIPLE_BINDING_TYPES,
-      DUPLICATE_BINDINGS,
-      CYCLE,
-      MALFORMED,
-      MISSING,
-    }
-
     abstract BindingKey bindingKey();
-    abstract State state();
     abstract ImmutableSet<? extends Binding> bindings();
 
     static ResolvedBindings create(
-        BindingKey bindingKey,
-        State state,
-        ImmutableSet<? extends Binding> bindings) {
-      Optional<State> overrideState = validate(bindingKey, bindings);
-      return new AutoValue_BindingGraph_ResolvedBindings(
-          bindingKey, overrideState.or(state), bindings);
-    }
-
-    /**
-     * Determines whether the given bindings are valid for a binding key.
-     *
-     * @return the appropriate error state if they are invalid; otherwise an absent optional.
-     */
-    private static Optional<State> validate(BindingKey bindingKey,
-        ImmutableSet<? extends Binding> bindings) {
-      if (bindings.isEmpty()) {
-        return Optional.of(State.MISSING);
-      }
-
-      // TODO(user): Perform this validation in the GraphValidator instead.
-      ImmutableSet.Builder<ContributionBinding> contributionBindingsBuilder =
-          ImmutableSet.builder();
-      ImmutableSet.Builder<MembersInjectionBinding> membersInjectionBindingsBuilder =
-          ImmutableSet.builder();
-      for (Binding binding : bindings) {
-        if (binding instanceof ContributionBinding) {
-          contributionBindingsBuilder.add((ContributionBinding) binding);
-        }
-        if (binding instanceof MembersInjectionBinding) {
-          membersInjectionBindingsBuilder.add((MembersInjectionBinding) binding);
-        }
-      }
-      ImmutableSet<ContributionBinding> contributionBindings =
-          contributionBindingsBuilder.build();
-      ImmutableSet<MembersInjectionBinding> membersInjectionBindings =
-          membersInjectionBindingsBuilder.build();
-
-      switch (bindingKey.kind()) {
-        case CONTRIBUTION:
-          if (!membersInjectionBindings.isEmpty()) {
-            throw new IllegalArgumentException(
-                "contribution binding keys should never have members injection bindings");
-          }
-          if (contributionBindings.size() <= 1) {
-            return Optional.absent();
-          }
-          ImmutableListMultimap<BindingType, ContributionBinding> bindingsByType =
-              ContributionBinding.bindingTypesFor(contributionBindings);
-          if (bindingsByType.keySet().size() > 1) {
-            return Optional.of(State.MULTIPLE_BINDING_TYPES);
-          } else if (getOnlyElement(bindingsByType.keySet()).equals(BindingType.UNIQUE)) {
-            return Optional.of(State.DUPLICATE_BINDINGS);
-          }
-          break;
-        case MEMBERS_INJECTION:
-          if (!contributionBindings.isEmpty()) {
-            throw new IllegalArgumentException(
-                "members injection binding keys should never have contribution bindings");
-          }
-          if (membersInjectionBindings.size() > 1) {
-            return Optional.of(State.DUPLICATE_BINDINGS);
-          }
-          break;
-        default:
-          throw new AssertionError();
-      }
-      return Optional.absent();
+        BindingKey bindingKey, ImmutableSet<? extends Binding> bindings) {
+      return new AutoValue_BindingGraph_ResolvedBindings(bindingKey, bindings);
     }
 
     @SuppressWarnings("unchecked")  // checked by validator
@@ -339,51 +256,36 @@ private boolean isComponentMembersInjectionMethod(ExecutableElement method) {
         }
       }
 
-      State resolve(DependencyRequest request) {
+      void resolve(DependencyRequest request) {
         BindingKey bindingKey = BindingKey.forDependencyRequest(request);
 
         ResolvedBindings previouslyResolvedBinding = resolvedBindings.get(bindingKey);
         if (previouslyResolvedBinding != null) {
-          return previouslyResolvedBinding.state();
+          return;
         }
 
         if (cycleStack.contains(bindingKey)) {
-          // return malformed, but don't add a resolved binding.
-          // the original request will add it with all of the other resolved deps
-          return State.CYCLE;
+          // We found a cycle. Don't add a resolved binding, since the original request will add it
+          // with all of the other resolved deps
+          return;
         }
 
         cycleStack.push(bindingKey);
         try {
           ImmutableSet<? extends Binding> bindings = lookUpBindings(request);
-          State dependenciesState = resolveDependencies(FluentIterable.from(bindings)
-              .transformAndConcat(
-                  new Function<Binding, Set<DependencyRequest>>() {
-                    @Override
-                    public Set<DependencyRequest> apply(Binding input) {
-                      return input.implicitDependencies();
-                    }
-                  }));
-          ResolvedBindings resolved =
-              ResolvedBindings.create(bindingKey, dependenciesState, bindings);
-          resolvedBindings.put(bindingKey, resolved);
-          return resolved.state();
+          for (Binding binding : bindings) {
+            resolveDependencies(binding.implicitDependencies());
+          }
+          resolvedBindings.put(bindingKey, ResolvedBindings.create(bindingKey, bindings));
         } finally {
           cycleStack.pop();
         }
       }
 
-      private State resolveDependencies(Iterable<DependencyRequest> dependencies) {
-        State bindingState = State.COMPLETE;
+      private void resolveDependencies(Iterable<DependencyRequest> dependencies) {
         for (DependencyRequest dependency : dependencies) {
-          State dependencyState = resolve(dependency);
-          if (dependencyState.equals(State.CYCLE)) {
-            bindingState = State.CYCLE;
-          } else if (!bindingState.equals(State.CYCLE) && !dependencyState.equals(State.COMPLETE)) {
-            bindingState = State.INCOMPLETE;
-          }
+          resolve(dependency);
         }
-        return bindingState;
       }
     }
   }
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
index b9016b071..2e859ab15 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -18,7 +18,6 @@
 import com.google.common.collect.Ordering;
 import dagger.Component;
 import dagger.internal.codegen.BindingGraph.ResolvedBindings;
-import dagger.internal.codegen.BindingGraph.ResolvedBindings.State;
 import dagger.internal.codegen.ContributionBinding.BindingType;
 import dagger.internal.codegen.ValidationReport.Builder;
 import java.util.ArrayDeque;
@@ -77,48 +76,98 @@
     for (DependencyRequest entryPoint : subject.entryPoints()) {
       ResolvedBindings resolvedBinding = resolvedBindings.get(
           BindingKey.forDependencyRequest(entryPoint));
-      if (!resolvedBinding.state().equals(State.COMPLETE)) {
-        LinkedList<DependencyRequest> requestPath = Lists.newLinkedList();
-        requestPath.push(entryPoint);
-        traversalHelper(subject, requestPath, new Traverser() {
-          final Set<ResolvedBindings> visitedBindings = new HashSet<>();
+      LinkedList<DependencyRequest> requestPath = Lists.newLinkedList();
+      requestPath.push(entryPoint);
+      traversalHelper(subject, requestPath, new Traverser() {
+        final Set<BindingKey> visitedBindings = new HashSet<>();
 
-          @Override
-          boolean visitResolvedBinding(
-              Deque<DependencyRequest> requestPath, ResolvedBindings binding) {
-            if (!visitedBindings.add(binding)) {
+        @Override
+        boolean visitResolvedBinding(
+            Deque<DependencyRequest> requestPath, ResolvedBindings binding) {
+          for (DependencyRequest request : Iterables.skip(requestPath, 1)) {
+            if (BindingKey.forDependencyRequest(request).equals(binding.bindingKey())) {
+              reportCycle(requestPath, subject, reportBuilder);
               return false;
             }
+          }
 
-            switch (binding.state()) {
-              case COMPLETE:
-              case INCOMPLETE:
-                return true;
-              case MISSING:
-                reportMissingBinding(requestPath, reportBuilder);
-                return false;
-              case DUPLICATE_BINDINGS:
-                reportDuplicateBindings(requestPath, binding, reportBuilder);
-                return false;
-              case MULTIPLE_BINDING_TYPES:
-                reportMultipleBindingTypes(requestPath, binding, reportBuilder);
-                return false;
-              case CYCLE:
-                reportCycle(requestPath, subject, reportBuilder);
-                return false;
-              case MALFORMED:
-                return false;
-              default:
-                throw new AssertionError();
-            }
+          if (!visitedBindings.add(binding.bindingKey())) {
+            return false;
           }
-        });
-      }
+
+          return validateResolvedBinding(requestPath, binding, reportBuilder);
+        }
+      });
     }
 
     return reportBuilder.build();
   }
 
+  /**
+   * Validates that the set of bindings resolved is consistent with the type of the binding, and
+   * returns true if the bindings are valid.
+   */
+  private boolean validateResolvedBinding(
+      Deque<DependencyRequest> requestPath,
+      ResolvedBindings resolvedBinding,
+      Builder<BindingGraph> reportBuilder) {
+    if (resolvedBinding.bindings().isEmpty()) {
+      reportMissingBinding(requestPath, reportBuilder);
+      return false;
+    }
+
+    ImmutableSet.Builder<ContributionBinding> contributionBindingsBuilder =
+        ImmutableSet.builder();
+    ImmutableSet.Builder<MembersInjectionBinding> membersInjectionBindingsBuilder =
+        ImmutableSet.builder();
+    for (Binding binding : resolvedBinding.bindings()) {
+      if (binding instanceof ContributionBinding) {
+        contributionBindingsBuilder.add((ContributionBinding) binding);
+      }
+      if (binding instanceof MembersInjectionBinding) {
+        membersInjectionBindingsBuilder.add((MembersInjectionBinding) binding);
+      }
+    }
+    ImmutableSet<ContributionBinding> contributionBindings =
+        contributionBindingsBuilder.build();
+    ImmutableSet<MembersInjectionBinding> membersInjectionBindings =
+        membersInjectionBindingsBuilder.build();
+
+    switch (resolvedBinding.bindingKey().kind()) {
+      case CONTRIBUTION:
+        if (!membersInjectionBindings.isEmpty()) {
+          throw new IllegalArgumentException(
+              "contribution binding keys should never have members injection bindings");
+        }
+        if (contributionBindings.size() <= 1) {
+          return true;
+        }
+        ImmutableListMultimap<BindingType, ContributionBinding> bindingsByType =
+            ContributionBinding.bindingTypesFor(contributionBindings);
+        if (bindingsByType.keySet().size() > 1) {
+          reportMultipleBindingTypes(requestPath, resolvedBinding, reportBuilder);
+          return false;
+        } else if (getOnlyElement(bindingsByType.keySet()).equals(BindingType.UNIQUE)) {
+          reportDuplicateBindings(requestPath, resolvedBinding, reportBuilder);
+          return false;
+        }
+        break;
+      case MEMBERS_INJECTION:
+        if (!contributionBindings.isEmpty()) {
+          throw new IllegalArgumentException(
+              "members injection binding keys should never have contribution bindings");
+        }
+        if (membersInjectionBindings.size() > 1) {
+          reportDuplicateBindings(requestPath, resolvedBinding, reportBuilder);
+          return false;
+        }
+        break;
+      default:
+        throw new AssertionError();
+    }
+    return true;
+  }
+
   /**
    * Validates that among the dependencies are at most one scoped dependency,
    * that there are no cycles within the scoping chain, and that singleton
@@ -421,32 +470,19 @@ private String formatBindingType(BindingType type) {
 
   private void reportCycle(Deque<DependencyRequest> requestPath,
       BindingGraph graph, final ValidationReport.Builder<BindingGraph> reportBuilder) {
-    final DependencyRequest startingRequest = requestPath.peek();
-    final Key cycleKey = startingRequest.key();
-    traversalHelper(graph, requestPath, new Traverser() {
-      @Override
-      boolean visitResolvedBinding(Deque<DependencyRequest> requestPath, ResolvedBindings binding) {
-        DependencyRequest request = requestPath.peek();
-        boolean endOfCycle = !startingRequest.equals(request) && cycleKey.equals(request.key());
-        if (endOfCycle) {
-          ImmutableList<String> printableDependencyPath = FluentIterable.from(requestPath)
-              .transform(DependencyRequestFormatter.instance()).toList().reverse();
-          DependencyRequest rootRequest = requestPath.getLast();
-          TypeElement componentType =
-              MoreElements.asType(rootRequest.requestElement().getEnclosingElement());
-          // TODO(user): Restructure to provide a hint for the start and end of the cycle.
-          reportBuilder.addItem(
-              String.format(ErrorMessages.CONTAINS_DEPENDENCY_CYCLE_FORMAT,
-                  componentType.getQualifiedName(),
-                  rootRequest.requestElement().getSimpleName(),
-                  Joiner.on("\n")
-                      .join(printableDependencyPath.subList(1, printableDependencyPath.size()))),
-                  rootRequest.requestElement());
-        }
-        return !endOfCycle;
-      }
-    });
-
+    ImmutableList<String> printableDependencyPath = FluentIterable.from(requestPath)
+        .transform(DependencyRequestFormatter.instance()).toList().reverse();
+    DependencyRequest rootRequest = requestPath.getLast();
+    TypeElement componentType =
+        MoreElements.asType(rootRequest.requestElement().getEnclosingElement());
+    // TODO(user): Restructure to provide a hint for the start and end of the cycle.
+    reportBuilder.addItem(
+        String.format(ErrorMessages.CONTAINS_DEPENDENCY_CYCLE_FORMAT,
+            componentType.getQualifiedName(),
+            rootRequest.requestElement().getSimpleName(),
+            Joiner.on("\n")
+            .join(printableDependencyPath.subList(1, printableDependencyPath.size()))),
+        rootRequest.requestElement());
   }
 
   private void traversalHelper(BindingGraph graph, Deque<DependencyRequest> requestPath,
diff --git a/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java b/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
index 9adbc879f..68b684588 100644
--- a/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
@@ -22,7 +22,7 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-import static com.google.common.truth.Truth.assert_;
+import static com.google.common.truth.Truth.assertAbout;
 import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
 import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
 
@@ -52,7 +52,7 @@
         "import javax.inject.Inject;",
         "",
         "interface Bar {}");
-    assert_().about(javaSources()).that(Arrays.asList(component, injectable, nonInjectable))
+    assertAbout(javaSources()).that(Arrays.asList(component, injectable, nonInjectable))
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining("test.Bar cannot be provided without an @Provides-annotated method.")
@@ -75,7 +75,7 @@
         "}");
     String expectedError =
         "test.TestClass.A cannot be provided without an @Provides-annotated method.";
-    assert_().about(javaSource()).that(component)
+    assertAbout(javaSource()).that(component)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(expectedError).in(component).onLine(10);
@@ -102,7 +102,7 @@
         "}");
     String expectedError = "test.TestClass.A cannot be provided without an "
         + "@Inject constructor or from an @Provides-annotated method.";
-    assert_().about(javaSource()).that(component)
+    assertAbout(javaSource()).that(component)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(expectedError).in(component).onLine(15);
@@ -134,7 +134,7 @@
     String expectedError = "test.TestClass.B cannot be provided without an "
         + "@Inject constructor or from an @Provides-annotated method. "
         + "This type supports members injection but cannot be implicitly provided.";
-    assert_().about(javaSource()).that(component)
+    assertAbout(javaSource()).that(component)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(expectedError).in(component).onLine(19);
@@ -176,12 +176,60 @@
         + "      test.Outer.A.<init>(test.Outer.C cParam)\n"
         + "          [parameter: test.Outer.C cParam]";
 
-    assert_().about(javaSource()).that(component)
+    assertAbout(javaSource()).that(component)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(expectedError).in(component).onLine(23);
   }
 
+  @Test public void cyclicDependencyNotIncludingEntryPoint() {
+    JavaFileObject component = JavaFileObjects.forSourceLines("test.Outer",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import javax.inject.Inject;",
+        "",
+        "final class Outer {",
+        "  static class A {",
+        "    @Inject A(C cParam) {}",
+        "  }",
+        "",
+        "  static class B {",
+        "    @Inject B(A aParam) {}",
+        "  }",
+        "",
+        "  static class C {",
+        "    @Inject C(B bParam) {}",
+        "  }",
+
+        "  static class D {",
+        "    @Inject D(C cParam) {}",
+        "  }",
+        "",
+        "  @Component()",
+        "  interface DComponent {",
+        "    D getD();",
+        "  }",
+        "}");
+
+    String expectedError = "test.Outer.DComponent.getD() contains a dependency cycle:\n"
+        + "      test.Outer.D.<init>(test.Outer.C cParam)\n"
+        + "          [parameter: test.Outer.C cParam]\n"
+        + "      test.Outer.C.<init>(test.Outer.B bParam)\n"
+        + "          [parameter: test.Outer.B bParam]\n"
+        + "      test.Outer.B.<init>(test.Outer.A aParam)\n"
+        + "          [parameter: test.Outer.A aParam]\n"
+        + "      test.Outer.A.<init>(test.Outer.C cParam)\n"
+        + "          [parameter: test.Outer.C cParam]";
+
+    assertAbout(javaSource()).that(component)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(expectedError).in(component).onLine(26);
+  }
+
   @Test public void duplicateExplicitBindings_ProvidesAndComponentProvision() {
     JavaFileObject component = JavaFileObjects.forSourceLines("test.Outer",
         "package test;",
@@ -221,7 +269,7 @@
         + "      test.Outer.A test.Outer.Parent.getA()\n"
         + "      @Provides test.Outer.A test.Outer.AModule.provideA(String)";
 
-    assert_().about(javaSource()).that(component)
+    assertAbout(javaSource()).that(component)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(expectedError).in(component).onLine(30);
@@ -260,7 +308,7 @@
         + "      @Provides test.Outer.A test.Outer.Module1.provideA1()\n"
         + "      @Provides test.Outer.A test.Outer.Module2.provideA2(String)";
 
-    assert_().about(javaSource()).that(component)
+    assertAbout(javaSource()).that(component)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(expectedError).in(component).onLine(24);
@@ -330,7 +378,7 @@
             + "      Unique bindings:\n"
             + "          @Provides Map<String,String> test.Outer.TestModule2.stringMap()";
 
-    assert_().about(javaSource()).that(component)
+    assertAbout(javaSource()).that(component)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(expectedSetError).in(component).onLine(43)
@@ -441,7 +489,7 @@
         + "      @Provides test.Outer.A test.Outer.Module10.provideA()\n"
         + "      and 2 others";
 
-    assert_().about(javaSource()).that(component)
+    assertAbout(javaSource()).that(component)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(expectedError).in(component).onLine(86);
@@ -501,7 +549,7 @@
         + "          [injected field of type: test.TestClass.B b]\n"
         + "      test.TestClass.B.<init>(test.TestClass.A a)\n"
         + "          [parameter: test.TestClass.A a]";
-    assert_().about(javaSource()).that(component)
+    assertAbout(javaSource()).that(component)
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(firstError).in(component).onLine(33)
