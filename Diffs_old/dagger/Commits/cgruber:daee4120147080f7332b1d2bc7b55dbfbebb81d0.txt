diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
index 581aab618..9edcd3295 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -28,7 +28,6 @@
 import com.google.common.collect.Maps;
 import com.google.common.collect.Sets;
 import com.google.common.util.concurrent.ListenableFuture;
-import dagger.MembersInjector;
 import dagger.internal.DelegateFactory;
 import dagger.internal.Factory;
 import dagger.internal.InstanceFactory;
@@ -39,7 +38,6 @@
 import dagger.internal.SetFactory;
 import dagger.internal.codegen.ComponentDescriptor.BuilderSpec;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
-import dagger.internal.codegen.ComponentGenerator.MemberSelect;
 import dagger.internal.codegen.writer.ClassName;
 import dagger.internal.codegen.writer.ClassWriter;
 import dagger.internal.codegen.writer.ConstructorWriter;
@@ -84,12 +82,15 @@
 import static dagger.internal.codegen.AbstractComponentWriter.InitializationState.DELEGATED;
 import static dagger.internal.codegen.AbstractComponentWriter.InitializationState.INITIALIZED;
 import static dagger.internal.codegen.AbstractComponentWriter.InitializationState.UNINITIALIZED;
-import static dagger.internal.codegen.ComponentGenerator.MemberSelect.staticMethodInvocationWithCast;
-import static dagger.internal.codegen.ComponentGenerator.MemberSelect.staticSelect;
 import static dagger.internal.codegen.ContributionBinding.FactoryCreationStrategy.ENUM_INSTANCE;
 import static dagger.internal.codegen.ContributionBinding.Kind.PROVISION;
 import static dagger.internal.codegen.ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD;
 import static dagger.internal.codegen.MapKeys.getMapKeySnippet;
+import static dagger.internal.codegen.MemberSelect.emptyMapProviderFactory;
+import static dagger.internal.codegen.MemberSelect.emptySetProvider;
+import static dagger.internal.codegen.MemberSelect.localField;
+import static dagger.internal.codegen.MemberSelect.noOpMembersInjector;
+import static dagger.internal.codegen.MemberSelect.staticMethod;
 import static dagger.internal.codegen.MembersInjectionBinding.Strategy.NO_OP;
 import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
 import static dagger.internal.codegen.SourceFiles.generatedClassNameForBinding;
@@ -97,7 +98,6 @@
 import static dagger.internal.codegen.SourceFiles.membersInjectorNameForType;
 import static dagger.internal.codegen.Util.componentCanMakeNewInstances;
 import static dagger.internal.codegen.writer.Snippet.makeParametersSnippet;
-import static dagger.internal.codegen.writer.Snippet.memberSelectSnippet;
 import static dagger.internal.codegen.writer.Snippet.nullCheck;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.element.Modifier.FINAL;
@@ -203,7 +203,7 @@ private Snippet getComponentContributionSnippet(TypeElement contributionType) {
               "this.%s = builder.%s;",
               componentField.name(),
               builderFields.get(contributionType).name());
-      fieldSelect = MemberSelect.instanceSelect(name, Snippet.format("%s", componentField.name()));
+      fieldSelect = localField(name, componentField.name());
       componentContributionFields.put(contributionType, fieldSelect);
     }
     return Optional.of(fieldSelect.getSnippetFor(name));
@@ -454,7 +454,7 @@ private void addFields() {
 
   private void addField(ResolvedBindings resolvedBindings) {
     BindingKey bindingKey = resolvedBindings.bindingKey();
-    
+
     // If the binding can be satisfied with a static method call without dependencies or state,
     // no field is necessary.
     Optional<MemberSelect> staticMemberSelect = staticMemberSelect(resolvedBindings);
@@ -462,7 +462,7 @@ private void addField(ResolvedBindings resolvedBindings) {
       memberSelectSnippets.put(bindingKey, staticMemberSelect.get());
       return;
     }
-    
+
     // No field needed if there are no owned bindings.
     if (resolvedBindings.ownedBindings().isEmpty()) {
       return;
@@ -483,11 +483,9 @@ private void addField(ResolvedBindings resolvedBindings) {
                   contributionNumber, contributionBinding);
           FieldWriter contributionField = addFrameworkField(useRawType, contributionBindingField);
 
-          ImmutableList<String> contributionSelectTokens =
-              ImmutableList.of(contributionField.name());
           multibindingContributionSnippets.put(
               contributionBinding,
-              MemberSelect.instanceSelect(name, memberSelectSnippet(contributionSelectTokens)));
+              localField(name, contributionField.name()));
         }
       }
     }
@@ -495,13 +493,9 @@ private void addField(ResolvedBindings resolvedBindings) {
     FrameworkField bindingField = FrameworkField.createForResolvedBindings(resolvedBindings);
     FieldWriter frameworkField = addFrameworkField(useRawType, bindingField);
 
-    ImmutableList<String> memberSelectTokens =
-        new ImmutableList.Builder<String>()
-            .add(frameworkField.name())
-            .build();
     memberSelectSnippets.put(
         bindingKey,
-        MemberSelect.instanceSelect(name, Snippet.memberSelectSnippet(memberSelectTokens)));
+        localField(name, frameworkField.name()));
   }
 
   private FieldWriter addFrameworkField(boolean useRawType,
@@ -532,7 +526,8 @@ private FieldWriter addFrameworkField(boolean useRawType,
             && resolvedBindings.contributionBindings().isEmpty()) {
           switch (resolvedBindings.contributionType()) {
             case MAP:
-              return Optional.of(emptyMapProviderFactoryStaticMemberSelect());
+              return Optional.of(emptyMapProviderFactory(
+                  MapType.from(resolvedBindings.key().type())));
 
             case SET:
               return Optional.of(emptySetFactoryStaticMemberSelect(resolvedBindings));
@@ -554,7 +549,7 @@ private FieldWriter addFrameworkField(boolean useRawType,
         if (contributionBinding.factoryCreationStrategy().equals(ENUM_INSTANCE)
             && !contributionBinding.scope().isPresent()) {
           return Optional.of(
-              staticSelect(
+              staticMethod(
                   generatedClassNameForBinding(contributionBinding), Snippet.format("create()")));
         }
         break;
@@ -564,11 +559,7 @@ private FieldWriter addFrameworkField(boolean useRawType,
             resolvedBindings.membersInjectionBinding();
         if (membersInjectionBinding.isPresent()
             && membersInjectionBinding.get().injectionStrategy().equals(NO_OP)) {
-          return Optional.of(
-              staticMethodInvocationWithCast(
-                  ClassName.fromClass(MembersInjectors.class),
-                  Snippet.format("noOp()"),
-                  ClassName.fromClass(MembersInjector.class)));
+          return Optional.of(noOpMembersInjector(membersInjectionBinding.get().key().type()));
         }
         break;
 
@@ -578,16 +569,6 @@ private FieldWriter addFrameworkField(boolean useRawType,
     return Optional.absent();
   }
 
-  /**
-   * A static member select for a call to {@link MapProviderFactory#empty()}.
-   */
-  private MemberSelect emptyMapProviderFactoryStaticMemberSelect() {
-    return staticMethodInvocationWithCast(
-        ClassName.fromClass(MapProviderFactory.class),
-        Snippet.format("empty()"),
-        ClassName.fromClass(MapProviderFactory.class));
-  }
-
   /**
    * A static member select for a call to {@code F.create()} where {@code F} is either
    * {@link SetFactory}, {@link SetProducer}, or {@link SetOfProducedProducer}, depending on the
@@ -595,8 +576,8 @@ private MemberSelect emptyMapProviderFactoryStaticMemberSelect() {
    */
   private MemberSelect emptySetFactoryStaticMemberSelect(ResolvedBindings setBindings) {
     ClassName setFactoryClassName = setFactoryClassName(setBindings);
-    return staticMethodInvocationWithCast(
-        setFactoryClassName, Snippet.format("create()"), setFactoryClassName);
+    return emptySetProvider(setFactoryClassName,
+        SetType.from(setBindings.bindingKey().key().type()));
   }
 
   /**
@@ -755,12 +736,12 @@ private void initializeFrameworkTypes() {
    */
   private Snippet initializeFrameworkType(BindingKey bindingKey) {
     ResolvedBindings resolvedBindings = graph.resolvedBindings().get(bindingKey);
-    
+
     // There's no field for inherited bindings.
     if (resolvedBindings.ownedBindings().isEmpty()) {
       return Snippet.format("");
     }
-    
+
     switch (bindingKey.kind()) {
       case CONTRIBUTION:
         switch (resolvedBindings.contributionType()) {
@@ -996,7 +977,7 @@ private Snippet initializeFactoryForContributionBinding(ContributionBinding bind
             /* 1 */ ClassName.fromClass(Factory.class),
             /* 2 */ bindingKeyTypeName,
             /* 3 */ binding.bindingElement().getSimpleName().toString());
-        
+
       case INJECTION:
       case PROVISION:
         {
@@ -1061,7 +1042,7 @@ private Snippet initializeFactoryForContributionBinding(ContributionBinding bind
               generatedClassNameForBinding(binding),
               Snippet.makeParametersSnippet(parameters));
         }
-        
+
       case SYNTHETIC_MAP:
         checkState(
             MapType.isMap(binding.key().type()),
@@ -1071,7 +1052,7 @@ private Snippet initializeFactoryForContributionBinding(ContributionBinding bind
             "%s.create(%s)",
             ClassName.fromClass(MapFactory.class),
             getMemberSelect(getOnlyElement(binding.dependencies()).bindingKey())
-                .getSnippetWithRawTypeCastFor(name));
+                .getSnippetFor(name));
 
       default:
         throw new AssertionError();
@@ -1114,7 +1095,7 @@ private Snippet initializeMembersInjectorForBinding(MembersInjectionBinding bind
                   .transform(DependencyRequest.BINDING_KEY_FUNCTION)
                   .toSet());
       ResolvedBindings resolvedBindings = graph.resolvedBindings().get(requestedKey);
-      Snippet frameworkSnippet = getMemberSelect(requestedKey).getSnippetWithRawTypeCastFor(name);
+      Snippet frameworkSnippet = getMemberSelect(requestedKey).getSnippetFor(name);
       if (resolvedBindings.frameworkClass().equals(Provider.class)
           && dependencyRequestMapper
               .getFrameworkClass(dependencyRequestsForUnresolvedKey)
diff --git a/compiler/src/main/java/dagger/internal/codegen/Accessibility.java b/compiler/src/main/java/dagger/internal/codegen/Accessibility.java
new file mode 100644
index 000000000..d8c5d2369
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/Accessibility.java
@@ -0,0 +1,212 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ElementKind;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.PackageElement;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.TypeParameterElement;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.ArrayType;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.NoType;
+import javax.lang.model.type.NullType;
+import javax.lang.model.type.PrimitiveType;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.type.TypeVariable;
+import javax.lang.model.type.WildcardType;
+import javax.lang.model.util.SimpleElementVisitor6;
+import javax.lang.model.util.SimpleTypeVisitor6;
+
+import static com.google.auto.common.MoreElements.getPackage;
+import static com.google.common.base.Preconditions.checkArgument;
+import static javax.lang.model.element.Modifier.PRIVATE;
+import static javax.lang.model.element.Modifier.PUBLIC;
+
+/**
+ * Utility methods for determining whether a {@linkplain TypeMirror type} or an {@linkplain Element
+ * element} is accessible given the rules outlined in
+ * <a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-6.html#jls-6.6">section 6.6 of the
+ * Java Language Specification</a>.
+ *
+ * <p>This class only provides an approximation for accessibility.  It does not always yield the
+ * same result as the compiler, but will always err on the side of declaring something inaccessible.
+ * This ensures that using this class will never result in generating code that will not compile.
+ *
+ * <p>Whenever compiler independence is not a requirement, the compiler-specific implementation of
+ * this functionality should be preferred.  For example,
+ * {@link com.sun.source.util.Trees#isAccessible(com.sun.source.tree.Scope, TypeElement)} would be
+ * preferable for {@code javac}.
+ */
+final class Accessibility {
+  /**
+   * Returns true if the given type can be referenced from code in the given package.
+   */
+  static boolean isTypeAccessibleFrom(TypeMirror type, String packageName) {
+    return type.accept(new TypeAccessiblityVisitor(packageName), null);
+  }
+
+  private static final class TypeAccessiblityVisitor extends SimpleTypeVisitor6<Boolean, Void> {
+    final String packageName;
+
+    TypeAccessiblityVisitor(String packageName) {
+      this.packageName = packageName;
+    }
+
+    boolean isAccessible(TypeMirror type) {
+      return type.accept(this, null);
+    }
+
+    @Override
+    public Boolean visitNoType(NoType type, Void p) {
+      return true;
+    }
+
+    @Override
+    public Boolean visitDeclared(DeclaredType type, Void p) {
+      if (!isAccessible(type.getEnclosingType())) {
+        // TODO(gak): investigate this check.  see comment in Binding
+        return false;
+      }
+      if (!isElementAccessibleFrom(type.asElement(), packageName)) {
+        return false;
+      }
+      for (TypeMirror typeArgument : type.getTypeArguments()) {
+        if (!isAccessible(typeArgument)) {
+          return false;
+        }
+      }
+      return true;
+    }
+
+    @Override
+    public Boolean visitArray(ArrayType type, Void p) {
+      return type.getComponentType().accept(this, null);
+    }
+
+    @Override
+    public Boolean visitPrimitive(PrimitiveType type, Void p) {
+      return true;
+    }
+
+    @Override
+    public Boolean visitNull(NullType type, Void p) {
+      return true;
+    }
+
+    @Override
+    public Boolean visitTypeVariable(TypeVariable type, Void p) {
+      // a _reference_ to a type variable is always accessible
+      return true;
+    }
+
+    @Override
+    public Boolean visitWildcard(WildcardType type, Void p) {
+      if (type.getExtendsBound() != null && !isAccessible(type.getExtendsBound())) {
+        return false;
+      }
+      if (type.getSuperBound() != null && !isAccessible(type.getSuperBound())) {
+        return false;
+      }
+      return true;
+    }
+
+    @Override
+    protected Boolean defaultAction(TypeMirror type, Void p) {
+      throw new IllegalArgumentException(String.format(
+          "%s of kind %s should not be checked for accessibility", type, type.getKind()));
+    }
+  }
+
+  /**
+   * Returns true if the given element can be referenced from code in the given package.
+   */
+  //TODO(gak): account for protected
+  static boolean isElementAccessibleFrom(Element element, final String packageName) {
+    return element.accept(new ElementAccessibilityVisitor(packageName), null);
+  }
+
+  private static final class ElementAccessibilityVisitor
+      extends SimpleElementVisitor6<Boolean, Void> {
+    final String packageName;
+
+    ElementAccessibilityVisitor(String packageName) {
+      this.packageName = packageName;
+    }
+
+    @Override
+    public Boolean visitPackage(PackageElement element, Void p) {
+      return true;
+    }
+
+    @Override
+    public Boolean visitType(TypeElement element, Void p) {
+      switch (element.getNestingKind()) {
+        case MEMBER:
+          return accessibleMember(element);
+        case TOP_LEVEL:
+          return accessibleModifiers(element);
+        case ANONYMOUS:
+        case LOCAL:
+          return false;
+        default:
+          throw new AssertionError();
+      }
+    }
+
+    boolean accessibleMember(Element element) {
+      if (!element.getEnclosingElement().accept(this, null)) {
+        return false;
+      }
+      return accessibleModifiers(element);
+    }
+
+    boolean accessibleModifiers(Element element) {
+      if (element.getModifiers().contains(PUBLIC)) {
+        return true;
+      } else if (element.getModifiers().contains(PRIVATE)) {
+        return false;
+      } else if (getPackage(element).getQualifiedName().contentEquals(packageName)) {
+        return true;
+      } else {
+        return false;
+      }
+    }
+
+    @Override
+    public Boolean visitTypeParameter(TypeParameterElement element, Void p) {
+      throw new IllegalArgumentException(
+          "It does not make sense to check the accessibility of a type parameter");
+    }
+
+    @Override
+    public Boolean visitExecutable(ExecutableElement element, Void p) {
+      return accessibleMember(element);
+    }
+
+    @Override
+    public Boolean visitVariable(VariableElement element, Void p) {
+      ElementKind kind = element.getKind();
+      checkArgument(kind.isField(), "checking a variable that isn't a field: %s", kind);
+      return accessibleMember(element);
+    }
+  }
+
+  private Accessibility() {}
+}
+
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
index ecb2cfd20..304df6c2b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
@@ -15,7 +15,6 @@
  */
 package dagger.internal.codegen;
 
-import com.google.auto.value.AutoValue;
 import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableSet;
 import dagger.Component;
@@ -23,8 +22,6 @@
 import dagger.internal.codegen.writer.ClassWriter;
 import dagger.internal.codegen.writer.FieldWriter;
 import dagger.internal.codegen.writer.JavaWriter;
-import dagger.internal.codegen.writer.Snippet;
-import dagger.internal.codegen.writer.TypeName;
 import javax.annotation.processing.Filer;
 import javax.lang.model.element.Element;
 import javax.lang.model.util.Elements;
@@ -74,50 +71,6 @@ ClassName nameGeneratedType(BindingGraph input) {
     return Optional.of(input.componentDescriptor().componentDefinitionType());
   }
 
-  @AutoValue static abstract class MemberSelect {
-    static MemberSelect instanceSelect(ClassName owningClass, Snippet snippet) {
-      return new AutoValue_ComponentGenerator_MemberSelect(
-          Optional.<TypeName> absent(), owningClass, false, snippet);
-    }
-
-    static MemberSelect staticSelect(ClassName owningClass, Snippet snippet) {
-      return new AutoValue_ComponentGenerator_MemberSelect(
-          Optional.<TypeName> absent(), owningClass, true, snippet);
-    }
-
-    static MemberSelect staticMethodInvocationWithCast(
-        ClassName owningClass, Snippet snippet, TypeName castType) {
-      return new AutoValue_ComponentGenerator_MemberSelect(
-          Optional.of(castType), owningClass, true, snippet);
-    }
-
-    /**
-     * This exists only to facilitate edge cases in which we need to select a member, but that
-     * member uses a type parameter that can't be inferred.
-     */
-    abstract Optional<TypeName> selectedCast();
-    abstract ClassName owningClass();
-    abstract boolean staticMember();
-    abstract Snippet snippet();
-
-    private Snippet qualifiedSelectSnippet() {
-      return Snippet.format(
-          "%s" + (staticMember() ? "" : ".this") + ".%s",
-          owningClass(), snippet());
-    }
-
-    Snippet getSnippetWithRawTypeCastFor(ClassName usingClass) {
-      Snippet snippet = getSnippetFor(usingClass);
-      return selectedCast().isPresent()
-          ? Snippet.format("(%s) %s", selectedCast().get(), snippet)
-          : snippet;
-    }
-
-    Snippet getSnippetFor(ClassName usingClass) {
-      return owningClass().equals(usingClass) ? snippet() : qualifiedSelectSnippet();
-    }
-  }
-
   @Override
   ImmutableSet<JavaWriter> write(ClassName componentName, BindingGraph input) {
     return new ComponentWriter(
diff --git a/compiler/src/main/java/dagger/internal/codegen/MemberSelect.java b/compiler/src/main/java/dagger/internal/codegen/MemberSelect.java
new file mode 100644
index 000000000..54fc45e87
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/MemberSelect.java
@@ -0,0 +1,196 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.common.base.Function;
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableList;
+import dagger.MembersInjector;
+import dagger.internal.MapProviderFactory;
+import dagger.internal.MembersInjectors;
+import dagger.internal.codegen.writer.ClassName;
+import dagger.internal.codegen.writer.Snippet;
+import dagger.internal.codegen.writer.TypeNames;
+import java.util.Set;
+import javax.inject.Provider;
+import javax.lang.model.type.TypeMirror;
+
+import static com.google.common.base.Preconditions.checkNotNull;
+import static dagger.internal.codegen.Accessibility.isTypeAccessibleFrom;
+
+/**
+ * Represents a {@link com.sun.source.tree.MemberSelectTree} as a {@link Snippet}.
+ */
+abstract class MemberSelect {
+  /**
+   * Returns a {@link MemberSelect} that accesses the field given by {@code fieldName} owned by
+   * {@code owningClass}.  In this context "local" refers to the fact that the field is owned by the
+   * type (or an enclosing type) from which the snippet will be used.  The returned
+   * {@link MemberSelect} will not be valid for accessing the field from a different class
+   * (regardless of accessibility).
+   */
+  static MemberSelect localField(ClassName owningClass, String fieldName) {
+    return new LocalField(owningClass, fieldName);
+  }
+
+  private static final class LocalField extends MemberSelect {
+    final String fieldName;
+
+    LocalField(ClassName owningClass, String fieldName) {
+      super(owningClass, false);
+      this.fieldName = checkNotNull(fieldName);
+    }
+
+    @Override
+    Snippet getSnippetFor(ClassName usingClass) {
+      return owningClass().equals(usingClass)
+          ? Snippet.format("%s", fieldName)
+          : Snippet.format("%s.this.%s", owningClass(), fieldName);
+    }
+  }
+
+  /**
+   * Returns a {@link MemberSelect} for the invocation of a static method (given by
+   * {@code methodInvocationSnippet}) on the {@code owningClass}.
+   */
+  static MemberSelect staticMethod(ClassName owningClass, Snippet methodInvocationSnippet) {
+    return new StaticMethod(owningClass, methodInvocationSnippet);
+  }
+
+  private static final class StaticMethod extends MemberSelect {
+    final Snippet methodSnippet;
+
+    StaticMethod(ClassName owningClass, Snippet methodSnippet) {
+      super(owningClass, true);
+      this.methodSnippet = checkNotNull(methodSnippet);
+    }
+
+    @Override
+    Snippet getSnippetFor(ClassName usingClass) {
+      return owningClass().equals(usingClass)
+          ? methodSnippet
+          : Snippet.format("%s.%s", owningClass(), methodSnippet);
+    }
+  }
+
+  /**
+   * Returns the {@link MemberSelect} for a no-op {@link MembersInjector} for the given type.
+   */
+  static MemberSelect noOpMembersInjector(TypeMirror type) {
+    return new ParameterizedStaticMethod(
+        ClassName.fromClass(MembersInjectors.class),
+        ImmutableList.of(type),
+        Snippet.format("noOp()"),
+        ClassName.fromClass(MembersInjector.class));
+  }
+
+  /**
+   * Returns the {@link MemberSelect} an empty implementation of {@link MapProviderFactory}.
+   */
+  static MemberSelect emptyMapProviderFactory(MapType mapType) {
+    return new ParameterizedStaticMethod(
+        ClassName.fromClass(MapProviderFactory.class),
+        ImmutableList.of(mapType.keyType(), mapType.unwrappedValueType(Provider.class)),
+        Snippet.format("empty()"),
+        ClassName.fromClass(MapProviderFactory.class));
+  }
+
+  /**
+   * Returns the {@link MemberSelect} for an empty set provider.  Since there are several different
+   * implementations for a multibound {@link Set}, the caller is responsible for passing the
+   * correct factory.
+   */
+  static MemberSelect emptySetProvider(ClassName setFactoryType, SetType setType) {
+    return new ParameterizedStaticMethod(
+        setFactoryType,
+        ImmutableList.of(setType.elementType()),
+        Snippet.format("create()"),
+        ClassName.fromClass(Set.class));
+  }
+
+  static final class ParameterizedStaticMethod extends MemberSelect {
+    final ImmutableList<TypeMirror> typeParameters;
+    final Snippet methodSnippet;
+    final ClassName rawReturnType;
+
+    ParameterizedStaticMethod(
+        ClassName owningClass,
+        ImmutableList<TypeMirror> typeParameters,
+        Snippet methodSnippet,
+        ClassName rawReturnType) {
+      super(owningClass, true);
+      this.typeParameters = typeParameters;
+      this.methodSnippet = methodSnippet;
+      this.rawReturnType = rawReturnType;
+    }
+
+    @Override
+    Snippet getSnippetFor(ClassName usingClass) {
+      boolean accessible = true;
+      for (TypeMirror typeParameter : typeParameters) {
+        accessible &= isTypeAccessibleFrom(typeParameter, usingClass.packageName());
+      }
+
+      if (accessible) {
+        Snippet typeParametersSnippet = Snippet.makeParametersSnippet(
+            FluentIterable.from(typeParameters)
+                .transform(new Function<TypeMirror, Snippet>() {
+                  @Override
+                  public Snippet apply(TypeMirror input) {
+                    return Snippet.format("%s", TypeNames.forTypeMirror(input));
+                  }
+                }));
+        return Snippet.format(
+            "%s.<%s>%s",
+            owningClass(),
+            typeParametersSnippet,
+            methodSnippet);
+      } else {
+        return Snippet.format(
+            "((%s) %s.%s)",
+            rawReturnType,
+            owningClass(),
+            methodSnippet);
+      }
+    }
+  }
+
+  private final ClassName owningClass;
+  private final boolean staticMember;
+
+  MemberSelect(ClassName owningClass, boolean staticMemeber) {
+    this.owningClass = owningClass;
+    this.staticMember = staticMemeber;
+  }
+
+  /** Returns the class that owns the member being selected. */
+  ClassName owningClass() {
+    return owningClass;
+  }
+
+  /**
+   * Returns true if the member being selected is static and does not require an instance of
+   * {@link #owningClass()}.
+   */
+  boolean staticMember() {
+    return staticMember;
+  }
+
+  /**
+   * Returns a {@link Snippet} suitable for accessing the member from the given {@code usingClass}.
+   */
+  abstract Snippet getSnippetFor(ClassName usingClass);
+}
\ No newline at end of file
diff --git a/compiler/src/main/java/dagger/internal/codegen/SubcomponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/SubcomponentWriter.java
index 507e4aaf1..36963a7e8 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SubcomponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SubcomponentWriter.java
@@ -20,7 +20,6 @@
 import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableList;
 import dagger.internal.codegen.ComponentDescriptor.BuilderSpec;
-import dagger.internal.codegen.ComponentGenerator.MemberSelect;
 import dagger.internal.codegen.writer.ClassName;
 import dagger.internal.codegen.writer.ClassWriter;
 import dagger.internal.codegen.writer.FieldWriter;
@@ -40,6 +39,7 @@
 import static com.google.common.base.Verify.verify;
 import static com.google.common.collect.Sets.difference;
 import static dagger.internal.codegen.AbstractComponentWriter.InitializationState.UNINITIALIZED;
+import static dagger.internal.codegen.MemberSelect.localField;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.PUBLIC;
@@ -183,8 +183,7 @@ private void writeSubcomponentWithoutBuilder(
             .addSnippet("  throw new NullPointerException();")
             .addSnippet("}");
         constructorWriter.body().addSnippet("this.%1$s = %1$s;", actualModuleName);
-        MemberSelect moduleSelect =
-            MemberSelect.instanceSelect(name, Snippet.format(actualModuleName));
+        MemberSelect moduleSelect = localField(name, actualModuleName);
         componentContributionFields.put(moduleTypeElement, moduleSelect);
         subcomponentConstructorParameters.add(Snippet.format("%s", moduleVariable.getSimpleName()));
       }
@@ -192,7 +191,7 @@ private void writeSubcomponentWithoutBuilder(
 
     Set<TypeElement> uninitializedModules =
         difference(graph.componentRequirements(), componentContributionFields.keySet());
-    
+
     for (TypeElement moduleType : uninitializedModules) {
       String preferredModuleName =
           CaseFormat.UPPER_CAMEL.to(LOWER_CAMEL, moduleType.getSimpleName().toString());
@@ -201,8 +200,7 @@ private void writeSubcomponentWithoutBuilder(
       String actualModuleName = contributionField.name();
       constructorWriter.body().addSnippet("this.%s = new %s();",
           actualModuleName, ClassName.fromTypeElement(moduleType));
-      MemberSelect moduleSelect =
-          MemberSelect.instanceSelect(name, Snippet.format(actualModuleName));
+      MemberSelect moduleSelect = localField(name, actualModuleName);
       componentContributionFields.put(moduleType, moduleSelect);
     }
 
diff --git a/compiler/src/test/java/dagger/internal/codegen/AccessibilityTest.java b/compiler/src/test/java/dagger/internal/codegen/AccessibilityTest.java
new file mode 100644
index 000000000..43d471879
--- /dev/null
+++ b/compiler/src/test/java/dagger/internal/codegen/AccessibilityTest.java
@@ -0,0 +1,134 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package dagger.internal.codegen;
+
+import com.google.testing.compile.CompilationRule;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.util.Elements;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assertThat;
+import static dagger.internal.codegen.Accessibility.isElementAccessibleFrom;
+
+@RunWith(JUnit4.class)
+@SuppressWarnings("unused") // contains a variety things used by the compilation rule for testing
+public class AccessibilityTest {
+  /* test data */
+  public AccessibilityTest() {}
+  protected AccessibilityTest(Object o) {}
+  AccessibilityTest(Object o1, Object o2) {}
+  private AccessibilityTest(Object o1, Object o2, Object o3) {}
+
+  public String publicField;
+  protected String protectedField;
+  String packagePrivateField;
+  private String privateField;
+
+  public void publicMethod() {}
+  protected void protectedMethod() {}
+  void packagePrivateMethod() {}
+  private void privateMethod() {}
+
+  public static final class PublicNestedClass {}
+  protected static final class ProtectedNestedClass {}
+  static final class PackagePrivateNestedClass {}
+  private static final class PrivateNestedClass {}
+
+  @Rule
+  public final CompilationRule compilationRule = new CompilationRule();
+
+  private TypeElement testElement;
+
+  @Before
+  public void setUp() {
+    Elements elements = compilationRule.getElements();
+    testElement = elements.getTypeElement(AccessibilityTest.class.getCanonicalName());
+  }
+
+  @Test
+  public void isElementAccessibleFrom_publicType() {
+    assertThat(isElementAccessibleFrom(testElement, "literally.anything")).isTrue();
+  }
+
+  @Test
+  public void isElementAccessibleFrom_publicMethod() {
+    Element member = getMemberNamed("publicMethod");
+    assertThat(isElementAccessibleFrom(member, "literally.anything")).isTrue();
+  }
+
+  @Test
+  public void isElementAccessibleFrom_protectedMethod() {
+    Element member = getMemberNamed("protectedMethod");
+    assertThat(isElementAccessibleFrom(member, "dagger.internal.codegen")).isTrue();
+    assertThat(isElementAccessibleFrom(member, "not.dagger.internal.codegen")).isFalse();
+  }
+
+  @Test
+  public void isElementAccessibleFrom_packagePrivateMethod() {
+    Element member = getMemberNamed("packagePrivateMethod");
+    assertThat(isElementAccessibleFrom(member, "dagger.internal.codegen")).isTrue();
+    assertThat(isElementAccessibleFrom(member, "not.dagger.internal.codegen")).isFalse();
+  }
+
+  @Test
+  public void isElementAccessibleFrom_privateMethod() {
+    Element member = getMemberNamed( "privateMethod");
+    assertThat(isElementAccessibleFrom(member, "dagger.internal.codegen")).isFalse();
+    assertThat(isElementAccessibleFrom(member, "not.dagger.internal.codegen")).isFalse();
+  }
+
+  @Test
+  public void isElementAccessibleFrom_publicField() {
+    Element member = getMemberNamed("publicField");
+    assertThat(isElementAccessibleFrom(member, "literally.anything")).isTrue();
+  }
+
+  @Test
+  public void isElementAccessibleFrom_protectedField() {
+    Element member = getMemberNamed("protectedField");
+    assertThat(isElementAccessibleFrom(member, "dagger.internal.codegen")).isTrue();
+    assertThat(isElementAccessibleFrom(member, "not.dagger.internal.codegen")).isFalse();
+  }
+
+  @Test
+  public void isElementAccessibleFrom_packagePrivateField() {
+    Element member = getMemberNamed("packagePrivateField");
+    assertThat(isElementAccessibleFrom(member, "dagger.internal.codegen")).isTrue();
+    assertThat(isElementAccessibleFrom(member, "not.dagger.internal.codegen")).isFalse();
+  }
+
+  @Test
+  public void isElementAccessibleFrom_privateField() {
+    Element member = getMemberNamed("privateField");
+    assertThat(isElementAccessibleFrom(member, "dagger.internal.codegen")).isFalse();
+    assertThat(isElementAccessibleFrom(member, "not.dagger.internal.codegen")).isFalse();
+  }
+
+  private Element getMemberNamed(String memberName) {
+    for (Element enclosedElement : testElement.getEnclosedElements()) {
+      if (enclosedElement.getSimpleName().contentEquals(memberName)) {
+        return enclosedElement;
+      }
+    }
+    throw new IllegalArgumentException();
+  }
+}
+
diff --git a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
index aefaf1275..3f400efbc 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
@@ -1371,7 +1371,6 @@ public void subcomponentOmitsInheritedBindings() {
         "test.DaggerSimpleComponent",
         "package test;",
         "",
-        "import dagger.MembersInjector;",
         "import dagger.internal.MembersInjectors;",
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
@@ -1396,7 +1395,7 @@ public void subcomponentOmitsInheritedBindings() {
         "  @SuppressWarnings(\"unchecked\")",
         "  private void initialize(final Builder builder) {",
         "    this.someInjectableTypeProvider =",
-        "        SomeInjectableType_Factory.create((MembersInjector) MembersInjectors.noOp());",
+        "        SomeInjectableType_Factory.create(MembersInjectors.<SomeInjectableType>noOp());",
         "  }",
         "",
         "  @Override",
diff --git a/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java b/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java
index 6d6d767f7..5c58ad5f7 100644
--- a/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java
@@ -67,7 +67,6 @@ public void parentClass_noInjectedMembers() {
         "test.DaggerTestComponent",
         "package test;",
         "",
-        "import dagger.MembersInjector;",
         "import dagger.internal.MembersInjectors;",
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
@@ -92,7 +91,7 @@ public void parentClass_noInjectedMembers() {
         "  @SuppressWarnings(\"unchecked\")",
         "  private void initialize(final Builder builder) {",
         "    this.childProvider =",
-        "        Child_Factory.create((MembersInjector) MembersInjectors.noOp());",
+        "        Child_Factory.create(MembersInjectors.<Child>noOp());",
         "  }",
         "",
         "  @Override",
