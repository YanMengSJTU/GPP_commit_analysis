diff --git a/java/dagger/internal/codegen/BindingGraph.java b/java/dagger/internal/codegen/BindingGraph.java
index 0113e4dcd..da8faeff0 100644
--- a/java/dagger/internal/codegen/BindingGraph.java
+++ b/java/dagger/internal/codegen/BindingGraph.java
@@ -30,6 +30,7 @@
 import static dagger.internal.codegen.Util.reentrantComputeIfAbsent;
 import static java.util.function.Predicate.isEqual;
 import static javax.lang.model.element.Modifier.ABSTRACT;
+import static javax.lang.model.util.ElementFilter.methodsIn;
 
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
@@ -75,7 +76,6 @@
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
-import javax.lang.model.util.ElementFilter;
 import javax.lang.model.util.Elements;
 
 /**
@@ -177,7 +177,6 @@ TypeElement componentType() {
     componentDescriptor()
         .dependencies()
         .stream()
-        .map(dep -> ComponentRequirement.forDependency(dep.asType()))
         .forEach(requirements::add);
     if (componentDescriptor().builderSpec().isPresent()) {
       componentDescriptor()
@@ -206,10 +205,7 @@ TypeElement componentType() {
                 .stream()
                 .filter(dep -> !dep.getModifiers().contains(ABSTRACT))
                 .map(module -> ComponentRequirement.forModule(module.asType())),
-            componentDescriptor()
-                .dependencies()
-                .stream()
-                .map(dep -> ComponentRequirement.forDependency(dep.asType())))
+            componentDescriptor().dependencies().stream())
         .collect(toImmutableSet());
   }
 
@@ -255,11 +251,10 @@ private BindingGraph create(
           provisionBindingFactory.forComponent(componentDescriptor.componentDefinitionType()));
 
       // Collect Component dependencies.
-      for (TypeElement componentDependency : componentDescriptor.dependencies()) {
-        explicitBindingsBuilder.add(
-            provisionBindingFactory.forComponentDependency(componentDependency));
+      for (ComponentRequirement dependency : componentDescriptor.dependencies()) {
+        explicitBindingsBuilder.add(provisionBindingFactory.forComponentDependency(dependency));
         List<ExecutableElement> dependencyMethods =
-            ElementFilter.methodsIn(elements.getAllMembers(componentDependency));
+            methodsIn(elements.getAllMembers(dependency.typeElement()));
         for (ExecutableElement method : dependencyMethods) {
           // MembersInjection methods aren't "provided" explicitly, so ignore them.
           if (isComponentContributionMethod(elements, method)) {
diff --git a/java/dagger/internal/codegen/BindingGraphValidator.java b/java/dagger/internal/codegen/BindingGraphValidator.java
index 20b2d6a1c..de2063f28 100644
--- a/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -292,7 +292,13 @@ private void validateComponentDependencyHierarchy(
     private void validateDependencyScopes(BindingGraph graph) {
       ComponentDescriptor descriptor = graph.componentDescriptor();
       ImmutableSet<Scope> scopes = descriptor.scopes();
-      ImmutableSet<TypeElement> scopedDependencies = scopedTypesIn(descriptor.dependencies());
+      ImmutableSet<TypeElement> scopedDependencies =
+          scopedTypesIn(
+              descriptor
+                  .dependencies()
+                  .stream()
+                  .map(ComponentRequirement::typeElement)
+                  .collect(toImmutableSet()));
       if (!scopes.isEmpty()) {
         Scope singletonScope = singletonScope(elements);
         // Dagger 1.x scope compatibility requires this be suppress-able.
diff --git a/java/dagger/internal/codegen/ComponentDescriptor.java b/java/dagger/internal/codegen/ComponentDescriptor.java
index 4643921c4..c81f3b1e7 100644
--- a/java/dagger/internal/codegen/ComponentDescriptor.java
+++ b/java/dagger/internal/codegen/ComponentDescriptor.java
@@ -32,6 +32,7 @@
 import static dagger.internal.codegen.Scopes.scopesOf;
 import static javax.lang.model.type.TypeKind.DECLARED;
 import static javax.lang.model.type.TypeKind.VOID;
+import static javax.lang.model.util.ElementFilter.methodsIn;
 
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
@@ -70,7 +71,6 @@
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.ExecutableType;
 import javax.lang.model.type.TypeMirror;
-import javax.lang.model.util.ElementFilter;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 
@@ -204,9 +204,10 @@ boolean isProducer() {
   abstract TypeElement componentDefinitionType();
 
   /**
-   * The set of component dependencies listed in {@link Component#dependencies}.
+   * The set of component dependencies listed in {@link Component#dependencies} or {@link
+   * ProductionComponent#dependencies()}.
    */
-  abstract ImmutableSet<TypeElement> dependencies();
+  abstract ImmutableSet<ComponentRequirement> dependencies();
 
   /**
    * The set of {@link ModuleDescriptor modules} declared directly in {@link Component#modules}.
@@ -249,11 +250,12 @@ private static void addTransitiveModules(
   }
 
   /**
-   * An index of the type to which this component holds a reference (the type listed in
-   * {@link Component#dependencies} or {@link ProductionComponent#dependencies} as opposed to the
-   * enclosing type) for each method from a component dependency that can be used for binding.
+   * This component's {@linkplain #dependencies() dependencies} keyed by each provision or
+   * production method implemented by that dependency. Note that the dependencies' types are not
+   * simply the enclosing type of the method; a method may be declared by a supertype of the actual
+   * dependency.
    */
-  abstract ImmutableMap<ExecutableElement, TypeElement> dependencyMethodIndex();
+  abstract ImmutableMap<ExecutableElement, ComponentRequirement> dependenciesByDependencyMethod();
 
   /**
    * The scopes of the component.
@@ -292,7 +294,7 @@ private static void addTransitiveModules(
    * builder method.
    */
   abstract ImmutableBiMap<ComponentMethodDescriptor, ComponentDescriptor>
-    subcomponentsByBuilderMethod();
+      subcomponentsByBuilderMethod();
 
   /**
    * All {@linkplain Subcomponent direct child} components that are declared by an entry point
@@ -478,20 +480,22 @@ private ComponentDescriptor create(
       DeclaredType declaredComponentType = MoreTypes.asDeclared(componentDefinitionType.asType());
       AnnotationMirror componentMirror =
           getAnnotationMirror(componentDefinitionType, kind.annotationType()).get();
-      ImmutableSet<TypeElement> componentDependencyTypes =
+      ImmutableSet<ComponentRequirement> componentDependencies =
           kind.isTopLevel()
-              ? MoreTypes.asTypeElements(getComponentDependencies(componentMirror))
-              : ImmutableSet.<TypeElement>of();
+              ? getComponentDependencies(componentMirror)
+                  .stream()
+                  .map(ComponentRequirement::forDependency)
+                  .collect(toImmutableSet())
+              : ImmutableSet.of();
 
-      ImmutableMap.Builder<ExecutableElement, TypeElement> dependencyMethodIndex =
+      ImmutableMap.Builder<ExecutableElement, ComponentRequirement> dependenciesByDependencyMethod =
           ImmutableMap.builder();
 
-      for (TypeElement componentDependency : componentDependencyTypes) {
-        List<ExecutableElement> dependencyMethods =
-            ElementFilter.methodsIn(elements.getAllMembers(componentDependency));
-        for (ExecutableElement dependencyMethod : dependencyMethods) {
+      for (ComponentRequirement componentDependency : componentDependencies) {
+        for (ExecutableElement dependencyMethod :
+            methodsIn(elements.getAllMembers(componentDependency.typeElement()))) {
           if (isComponentContributionMethod(elements, dependencyMethod)) {
-            dependencyMethodIndex.put(dependencyMethod, componentDependency);
+            dependenciesByDependencyMethod.put(dependencyMethod, componentDependency);
           }
         }
       }
@@ -576,10 +580,10 @@ private ComponentDescriptor create(
           kind,
           componentMirror,
           componentDefinitionType,
-          componentDependencyTypes,
+          componentDependencies,
           modules,
           transitiveModules,
-          dependencyMethodIndex.build(),
+          dependenciesByDependencyMethod.build(),
           scopes,
           subcomponentsFromModules.build(),
           subcomponentsByFactoryMethod.build(),
@@ -749,7 +753,8 @@ private ModuleDescriptor descriptorForProductionExecutorModule(
   static boolean isComponentContributionMethod(Elements elements, ExecutableElement method) {
     return method.getParameters().isEmpty()
         && !method.getReturnType().getKind().equals(VOID)
-        && !elements.getTypeElement(Object.class.getCanonicalName())
+        && !elements
+            .getTypeElement(Object.class.getCanonicalName())
             .equals(method.getEnclosingElement())
         && !NON_CONTRIBUTING_OBJECT_METHOD_NAMES.contains(method.getSimpleName().toString());
   }
diff --git a/java/dagger/internal/codegen/ComponentHjarProcessingStep.java b/java/dagger/internal/codegen/ComponentHjarProcessingStep.java
index 5a2371cab..3f726f86b 100644
--- a/java/dagger/internal/codegen/ComponentHjarProcessingStep.java
+++ b/java/dagger/internal/codegen/ComponentHjarProcessingStep.java
@@ -227,10 +227,7 @@ private MethodSpec privateConstructor() {
   private Stream<ComponentRequirement> componentRequirements(ComponentDescriptor component) {
     checkArgument(component.kind().isTopLevel());
     return Stream.concat(
-        component
-            .dependencies()
-            .stream()
-            .map(typeElement -> ComponentRequirement.forDependency(typeElement.asType())),
+        component.dependencies().stream(),
         component
             .transitiveModules()
             .stream()
diff --git a/java/dagger/internal/codegen/ComponentProvisionBindingExpression.java b/java/dagger/internal/codegen/ComponentProvisionBindingExpression.java
index de81d2b15..d95267bea 100644
--- a/java/dagger/internal/codegen/ComponentProvisionBindingExpression.java
+++ b/java/dagger/internal/codegen/ComponentProvisionBindingExpression.java
@@ -19,11 +19,9 @@
 import static com.google.common.base.Preconditions.checkNotNull;
 import static dagger.internal.codegen.ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD;
 
-import com.google.auto.common.MoreElements;
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
 import dagger.internal.Preconditions;
-import javax.lang.model.element.TypeElement;
 
 /** A binding expression for component provision methods. */
 final class ComponentProvisionBindingExpression extends SimpleInvocationBindingExpression {
@@ -58,12 +56,10 @@ Expression getInstanceDependencyExpression(ClassName requestingClass) {
   }
 
   private ComponentRequirement componentRequirement() {
-    TypeElement componentDependency =
-        bindingGraph
-            .componentDescriptor()
-            .dependencyMethodIndex()
-            .get(MoreElements.asExecutable(binding.bindingElement().get()));
-    return ComponentRequirement.forDependency(componentDependency.asType());
+    return bindingGraph
+        .componentDescriptor()
+        .dependenciesByDependencyMethod()
+        .get(binding.bindingElement().get());
   }
 
   static CodeBlock maybeCheckForNull(
diff --git a/java/dagger/internal/codegen/ProviderOrProducerFieldInitializer.java b/java/dagger/internal/codegen/ProviderOrProducerFieldInitializer.java
index f9c388360..30dc37dad 100644
--- a/java/dagger/internal/codegen/ProviderOrProducerFieldInitializer.java
+++ b/java/dagger/internal/codegen/ProviderOrProducerFieldInitializer.java
@@ -34,7 +34,6 @@
 import static dagger.internal.codegen.SourceFiles.generatedClassNameForBinding;
 import static dagger.internal.codegen.SourceFiles.mapFactoryClassName;
 import static dagger.internal.codegen.SourceFiles.setFactoryClassName;
-import static dagger.internal.codegen.SourceFiles.simpleVariableName;
 import static dagger.internal.codegen.TypeNames.DOUBLE_CHECK;
 import static dagger.internal.codegen.TypeNames.INSTANCE_FACTORY;
 import static dagger.internal.codegen.TypeNames.REFERENCE_RELEASING_PROVIDER;
@@ -74,7 +73,6 @@
 import java.util.Optional;
 import javax.inject.Provider;
 import javax.lang.model.element.AnnotationMirror;
-import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.TypeMirror;
 
 /**
@@ -153,8 +151,7 @@ private CodeBlock factoryForContributionBindingInitialization(ContributionBindin
 
       case COMPONENT_PROVISION:
         {
-          TypeElement dependencyType = dependencyTypeForBinding(binding);
-          String dependencyVariable = simpleVariableName(dependencyType);
+          ComponentRequirement dependency = dependencyForBinding(binding);
           String componentMethod = binding.bindingElement().get().getSimpleName().toString();
           // TODO(sameb): The Provider.get() throws a very vague NPE.  The stack trace doesn't
           // help to figure out what the method or return type is.  If we include a string
@@ -166,8 +163,8 @@ private CodeBlock factoryForContributionBindingInitialization(ContributionBindin
               ComponentProvisionBindingExpression.maybeCheckForNull(
                   (ProvisionBinding) binding,
                   compilerOptions,
-                  CodeBlock.of("$L.$L()", dependencyVariable, componentMethod));
-          ClassName dependencyClassName = ClassName.get(dependencyType);
+                  CodeBlock.of("$L.$L()", dependency.variableName(), componentMethod));
+          ClassName dependencyClassName = ClassName.get(dependency.typeElement());
           String factoryName =
               dependencyClassName.toString().replace('.', '_') + "_" + componentMethod;
           MethodSpec.Builder getMethod =
@@ -185,11 +182,11 @@ private CodeBlock factoryForContributionBindingInitialization(ContributionBindin
               TypeSpec.classBuilder(factoryName)
                   .addSuperinterface(providerOf(bindingKeyTypeName))
                   .addModifiers(PRIVATE, STATIC)
-                  .addField(dependencyClassName, dependencyVariable, PRIVATE, FINAL)
+                  .addField(dependencyClassName, dependency.variableName(), PRIVATE, FINAL)
                   .addMethod(
                       constructorBuilder()
-                          .addParameter(dependencyClassName, dependencyVariable)
-                          .addStatement("this.$1L = $1L", dependencyVariable)
+                          .addParameter(dependencyClassName, dependency.variableName())
+                          .addStatement("this.$1L = $1L", dependency.variableName())
                           .build())
                   .addMethod(getMethod.build())
                   .build());
@@ -198,8 +195,7 @@ private CodeBlock factoryForContributionBindingInitialization(ContributionBindin
               "new $L($L)",
               factoryName,
               componentRequirementFields.getExpressionDuringInitialization(
-                  ComponentRequirement.forDependency(dependencyType.asType()),
-                  generatedComponentModel.name()));
+                  dependency, generatedComponentModel.name()));
         }
 
       case SUBCOMPONENT_BUILDER:
@@ -264,17 +260,16 @@ private CodeBlock factoryForContributionBindingInitialization(ContributionBindin
 
       case COMPONENT_PRODUCTION:
         {
-          TypeElement dependencyType = dependencyTypeForBinding(binding);
+          ComponentRequirement dependency = dependencyForBinding(binding);
           FieldSpec dependencyField =
               FieldSpec.builder(
-                      ClassName.get(dependencyType),
-                      simpleVariableName(dependencyType),
+                      ClassName.get(dependency.typeElement()),
+                      dependency.variableName(),
                       PRIVATE,
                       FINAL)
                   .initializer(
                       componentRequirementFields.getExpressionDuringInitialization(
-                          ComponentRequirement.forDependency(dependencyType.asType()),
-                          generatedComponentModel.name()))
+                          dependency, generatedComponentModel.name()))
                   .build();
           // TODO(b/70395982): Explore using a private static type instead of an anonymous class.
           return CodeBlock.of(
@@ -355,8 +350,11 @@ private CodeBlock decorateForScope(CodeBlock factoryCreate, Optional<Scope> mayb
     }
   }
 
-  private TypeElement dependencyTypeForBinding(ContributionBinding binding) {
-    return graph.componentDescriptor().dependencyMethodIndex().get(binding.bindingElement().get());
+  private ComponentRequirement dependencyForBinding(ContributionBinding binding) {
+    return graph
+        .componentDescriptor()
+        .dependenciesByDependencyMethod()
+        .get(binding.bindingElement().get());
   }
 
   private CodeBlock factoryForSetMultibindingInitialization(ContributionBinding binding) {
diff --git a/java/dagger/internal/codegen/ProvisionBinding.java b/java/dagger/internal/codegen/ProvisionBinding.java
index ecbfa0b52..342040715 100644
--- a/java/dagger/internal/codegen/ProvisionBinding.java
+++ b/java/dagger/internal/codegen/ProvisionBinding.java
@@ -263,12 +263,12 @@ ProvisionBinding forComponent(TypeElement componentDefinitionType) {
           .build();
     }
 
-    ProvisionBinding forComponentDependency(TypeElement dependencyType) {
-      checkNotNull(dependencyType);
+    ProvisionBinding forComponentDependency(ComponentRequirement dependency) {
+      checkNotNull(dependency);
       return ProvisionBinding.builder()
           .contributionType(ContributionType.UNIQUE)
-          .bindingElement(dependencyType)
-          .key(keyFactory.forType(dependencyType.asType()))
+          .bindingElement(dependency.typeElement())
+          .key(keyFactory.forType(dependency.type()))
           .bindingKind(Kind.COMPONENT_DEPENDENCY)
           .build();
     }
