diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java b/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
index 071ce6982..d6ed27961 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectBindingRegistry.java
@@ -64,7 +64,7 @@
   final class BindingsCollection<B extends Binding> {
     private final Map<Key, B> bindingsByKey = Maps.newLinkedHashMap();
     private final Deque<B> bindingsRequiringGeneration = new ArrayDeque<>();
-    private final Set<B> materializedBindings = Sets.newLinkedHashSet();
+    private final Set<Key> materializedBindingKeys = Sets.newLinkedHashSet();
 
     void generateBindings(SourceFileGenerator<B> generator) throws SourceFileGenerationException {
       for (B binding = bindingsRequiringGeneration.poll();
@@ -72,8 +72,11 @@ void generateBindings(SourceFileGenerator<B> generator) throws SourceFileGenerat
           binding = bindingsRequiringGeneration.poll()) {
         checkState(!binding.hasNonDefaultTypeParameters());
         generator.generate(binding);
-        materializedBindings.add(binding);
+        materializedBindingKeys.add(binding.key());
       }
+      // Because Elements instantiated across processing rounds are not guaranteed to be equals() to
+      // the logically same element, clear the cache after generating 
+      bindingsByKey.clear();
     }
 
     /** Returns a previously cached binding. */
@@ -85,7 +88,7 @@ B getBinding(Key key) {
     B pretendBindingGenerated(B binding, ClassName factoryName) {
       tryToCacheBinding(binding);
       if (shouldGenerateBinding(binding, factoryName)) {
-        materializedBindings.add(binding);
+        materializedBindingKeys.add(binding.key());
       }
       return binding;
     }
@@ -116,7 +119,7 @@ void tryToGenerateBinding(B binding, ClassName factoryName, boolean explicit) {
     private boolean shouldGenerateBinding(B binding, ClassName factoryName) {
       return !binding.hasNonDefaultTypeParameters()
           && elements.getTypeElement(factoryName.canonicalName()) == null
-          && !materializedBindings.contains(binding)
+          && !materializedBindingKeys.contains(binding.key())
           && !bindingsRequiringGeneration.contains(binding);
 
     }
diff --git a/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java b/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java
index 25762ea94..7ea0cd1f4 100644
--- a/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java
@@ -15,8 +15,16 @@
  */
 package dagger.internal.codegen;
 
+import com.google.common.base.Joiner;
 import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
 import com.google.testing.compile.JavaFileObjects;
+import java.io.IOException;
+import java.io.Writer;
+import java.util.Set;
+import javax.annotation.processing.AbstractProcessor;
+import javax.annotation.processing.RoundEnvironment;
+import javax.lang.model.element.TypeElement;
 import javax.tools.JavaFileObject;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -659,4 +667,103 @@ public void parentClass_injectedMembersInSupertype() {
         .compilesWithoutError()
         .and().generatesSources(bMembersInjector);
   }
+
+  @Test
+  public void componentWithNestingAndGeneratedType() {
+    JavaFileObject nestedTypesFile =
+        JavaFileObjects.forSourceLines(
+            "test.OuterType",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Inject;",
+            "",
+            "final class OuterType {",
+            "  @Inject GeneratedType generated;",
+            "  static class A {",
+            "    @Inject A() {}",
+            "  }",
+            "  static class B {",
+            "    @Inject A a;",
+            "  }",
+            "  @Component interface SimpleComponent {",
+            "    A a();",
+            "    void inject(B b);",
+            "  }",
+            "}");
+    JavaFileObject bMembersInjector =
+        JavaFileObjects.forSourceLines(
+            "test.OuterType$B_MembersInjector",
+            "package test;",
+            "",
+            "import dagger.MembersInjector;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "import test.OuterType.A;",
+            "import test.OuterType.B;",
+            "",
+            "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
+            "public final class OuterType$B_MembersInjector implements MembersInjector<B> {",
+            "  private final Provider<A> aProvider;",
+            "",
+            "  public OuterType$B_MembersInjector(Provider<A> aProvider) {",
+            "    assert aProvider != null;",
+            "    this.aProvider = aProvider;",
+            "  }",
+            "",
+            "  @Override",
+            "  public void injectMembers(B instance) {",
+            "    if (instance == null) {",
+            "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
+            "    }",
+            "    instance.a = aProvider.get();",
+            "  }",
+            "",
+            "  public static MembersInjector<B> create(Provider<A> aProvider) {",
+            "    return new OuterType$B_MembersInjector(aProvider);",
+            "  }",
+            "}");
+    assertAbout(javaSource())
+        .that(nestedTypesFile)
+        .processedWith(
+            new ComponentProcessor(),
+            new AbstractProcessor() {
+              private boolean done;
+
+              @Override
+              public Set<String> getSupportedAnnotationTypes() {
+                return ImmutableSet.of("*");
+              }
+
+              @Override
+              public boolean process(
+                  Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
+                if (!done) {
+                  done = true;
+                  try (Writer writer =
+                          processingEnv
+                              .getFiler()
+                              .createSourceFile("test.GeneratedType")
+                              .openWriter()) {
+                    writer.write(
+                        Joiner.on('\n')
+                            .join(
+                                "package test;",
+                                "",
+                                "import javax.inject.Inject;",
+                                "",
+                                "class GeneratedType {",
+                                "  @Inject GeneratedType() {}",
+                                "}"));
+                  } catch (IOException e) {
+                    throw new RuntimeException(e);
+                  }
+                }
+                return false;
+              }
+            })
+        .compilesWithoutError()
+        .and()
+        .generatesSources(bMembersInjector);
+  }
 }
