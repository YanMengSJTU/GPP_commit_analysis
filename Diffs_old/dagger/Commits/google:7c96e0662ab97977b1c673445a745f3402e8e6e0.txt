diff --git a/java/dagger/internal/codegen/BUILD b/java/dagger/internal/codegen/BUILD
index 7161fbc79..7d1f41fe8 100644
--- a/java/dagger/internal/codegen/BUILD
+++ b/java/dagger/internal/codegen/BUILD
@@ -85,6 +85,7 @@ java_library(
         "DiagnosticFormatting.java",
         "Expression.java",
         "FeatureStatus.java",
+        "Formatter.java",
         "FrameworkTypes.java",
         "InjectionAnnotations.java",
         "Keys.java",
@@ -176,7 +177,6 @@ java_library(
         "ComponentValidator.java",
         "DependencyRequestFormatter.java",
         "ForReleasableReferencesValidator.java",
-        "Formatter.java",
         "InjectValidator.java",
         "MapKeyValidator.java",
         "MethodSignatureFormatter.java",
diff --git a/java/dagger/internal/codegen/BindingGraphValidator.java b/java/dagger/internal/codegen/BindingGraphValidator.java
index e11658151..047ee1795 100644
--- a/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -37,12 +37,12 @@
 import static dagger.internal.codegen.ErrorMessages.DEPENDS_ON_PRODUCTION_EXECUTOR_FORMAT;
 import static dagger.internal.codegen.ErrorMessages.DUPLICATE_BINDINGS_FOR_KEY_FORMAT;
 import static dagger.internal.codegen.ErrorMessages.DUPLICATE_SIZE_LIMIT;
-import static dagger.internal.codegen.ErrorMessages.INDENT;
 import static dagger.internal.codegen.ErrorMessages.MULTIPLE_CONTRIBUTION_TYPES_FOR_KEY_FORMAT;
 import static dagger.internal.codegen.ErrorMessages.abstractModuleHasInstanceBindingMethods;
 import static dagger.internal.codegen.ErrorMessages.referenceReleasingScopeMetadataMissingCanReleaseReferences;
 import static dagger.internal.codegen.ErrorMessages.referenceReleasingScopeNotAnnotatedWithMetadata;
 import static dagger.internal.codegen.ErrorMessages.referenceReleasingScopeNotInComponentHierarchy;
+import static dagger.internal.codegen.Formatter.INDENT;
 import static dagger.internal.codegen.Keys.isValidImplicitProvisionKey;
 import static dagger.internal.codegen.Keys.isValidMembersInjectionKey;
 import static dagger.internal.codegen.MoreAnnotationMirrors.getTypeValue;
@@ -526,7 +526,7 @@ private void checkScopedBindings(BindingGraph graph) {
       }
       for (ContributionBinding binding :
           incompatiblyScopedBindings.get(graph.componentDescriptor())) {
-        message.append(ErrorMessages.INDENT);
+        message.append(INDENT);
 
         switch (binding.kind()) {
           case DELEGATE:
diff --git a/java/dagger/internal/codegen/DaggerElements.java b/java/dagger/internal/codegen/DaggerElements.java
index 6aacc5437..314c26db7 100644
--- a/java/dagger/internal/codegen/DaggerElements.java
+++ b/java/dagger/internal/codegen/DaggerElements.java
@@ -16,11 +16,14 @@
 
 package dagger.internal.codegen;
 
+import static com.google.auto.common.MoreElements.asExecutable;
 import static com.google.auto.common.MoreElements.getLocalAndInheritedMethods;
 import static com.google.auto.common.MoreElements.hasModifiers;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.collect.Lists.asList;
 import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
+import static dagger.internal.codegen.Formatter.formatArgumentInList;
+import static java.util.stream.Collectors.joining;
 import static java.util.stream.Collectors.toSet;
 import static javax.lang.model.element.Modifier.ABSTRACT;
 
@@ -47,7 +50,9 @@
 import javax.lang.model.element.Name;
 import javax.lang.model.element.PackageElement;
 import javax.lang.model.element.TypeElement;
+import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.ElementKindVisitor8;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.SimpleElementVisitor8;
 import javax.lang.model.util.Types;
@@ -85,6 +90,69 @@ public TypeElement getTypeElement(CharSequence name) {
     return elements.getTypeElement(name);
   }
 
+  /**
+   * Returns a useful string form for an element.
+   *
+   * <p>Elements directly enclosed by a type are preceded by the enclosing type's qualified name.
+   *
+   * <p>Parameters are given with their enclosing executable, with other parameters elided.
+   */
+  static String elementToString(Element element) {
+    return element.accept(ELEMENT_TO_STRING, null);
+  }
+
+  private static final ElementVisitor<String, Void> ELEMENT_TO_STRING =
+      new ElementKindVisitor8<String, Void>() {
+        @Override
+        public String visitExecutable(ExecutableElement executableElement, Void aVoid) {
+          return enclosingTypeAndMemberName(executableElement)
+              .append(
+                  executableElement
+                      .getParameters()
+                      .stream()
+                      .map(parameter -> parameter.asType().toString())
+                      .collect(joining(", ", "(", ")")))
+              .toString();
+        }
+
+        @Override
+        public String visitVariableAsParameter(VariableElement parameter, Void aVoid) {
+          ExecutableElement methodOrConstructor = asExecutable(parameter.getEnclosingElement());
+          return enclosingTypeAndMemberName(methodOrConstructor)
+              .append('(')
+              .append(
+                  formatArgumentInList(
+                      methodOrConstructor.getParameters().indexOf(parameter),
+                      methodOrConstructor.getParameters().size(),
+                      parameter.getSimpleName()))
+              .append(')')
+              .toString();
+        }
+
+        @Override
+        public String visitVariableAsField(VariableElement field, Void aVoid) {
+          return enclosingTypeAndMemberName(field).toString();
+        }
+
+        @Override
+        public String visitType(TypeElement type, Void aVoid) {
+          return type.getQualifiedName().toString();
+        }
+
+        @Override
+        protected String defaultAction(Element element, Void aVoid) {
+          throw new UnsupportedOperationException(
+              "Can't determine string for " + element.getKind() + " element " + element);
+        }
+
+        private StringBuilder enclosingTypeAndMemberName(Element element) {
+          return new StringBuilder()
+              .append(element.getEnclosingElement().accept(this, null))
+              .append('.')
+              .append(element.getSimpleName());
+        }
+      };
+
   /** Returns the argument or the closest enclosing element that is a {@link TypeElement}. */
   static TypeElement closestEnclosingTypeElement(Element element) {
     return element.accept(CLOSEST_ENCLOSING_TYPE_ELEMENT, null);
diff --git a/java/dagger/internal/codegen/DependencyRequestFormatter.java b/java/dagger/internal/codegen/DependencyRequestFormatter.java
index 6443d7d2f..9fb3b885e 100644
--- a/java/dagger/internal/codegen/DependencyRequestFormatter.java
+++ b/java/dagger/internal/codegen/DependencyRequestFormatter.java
@@ -16,32 +16,27 @@
 
 package dagger.internal.codegen;
 
-import static com.google.auto.common.MoreElements.asExecutable;
+import static dagger.internal.codegen.DaggerElements.elementToString;
 import static dagger.internal.codegen.DaggerStreams.toImmutableList;
-import static dagger.internal.codegen.ErrorMessages.DOUBLE_INDENT;
-import static dagger.internal.codegen.ErrorMessages.INDENT;
 import static dagger.internal.codegen.RequestKinds.requestType;
 
-import com.google.auto.common.MoreElements;
 import com.google.common.base.Joiner;
 import com.google.common.collect.ImmutableSet;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import dagger.Provides;
 import dagger.internal.codegen.ComponentTreeTraverser.DependencyTrace;
 import dagger.model.DependencyRequest;
-import dagger.model.Key;
 import dagger.producers.Produces;
-import java.util.List;
 import java.util.Optional;
 import java.util.concurrent.atomic.AtomicReference;
 import javax.inject.Inject;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
+import javax.lang.model.element.ElementVisitor;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.TypeMirror;
-import javax.lang.model.util.ElementKindVisitor7;
+import javax.lang.model.util.ElementKindVisitor8;
 
 /**
  * Formats a {@link DependencyRequest} into a {@link String} suitable for an error message listing
@@ -95,109 +90,53 @@ String format(DependencyTrace dependencyTrace) {
                 .reverse());
   }
 
-  // TODO(cgruber): Sweep this class for TypeMirror.toString() usage and do some preventive format.
-  // TODO(cgruber): consider returning a small structure containing strings to be indented later.
   @Override
   public String format(DependencyRequest request) {
-    if (!request.requestElement().isPresent()) {
-      return "";
-    }
     return request
         .requestElement()
-        .get()
-        .accept(
-            new ElementKindVisitor7<String, DependencyRequest>() {
-
-              /** Returns the description for component methods. */
-              @Override
-              public String visitExecutableAsMethod(
-                  ExecutableElement method, DependencyRequest request) {
-                StringBuilder builder = new StringBuilder();
-                builder
-                    .append(INDENT)
-                    .append(formatKey(request.key()))
-                    .append(" is ")
-                    .append(componentMethodRequestVerb(request))
-                    .append(" at\n")
-                    .append(DOUBLE_INDENT);
-                appendEnclosingTypeAndMemberName(method, builder);
-                builder.append('(');
-                for (VariableElement parameter : method.getParameters()) {
-                  builder.append(parameter.getSimpleName());
-                }
-                builder.append(')');
-                return builder.toString();
-              }
-
-              /**
-               * Returns the description for {@link javax.inject.Inject @Inject} constructor and
-               * method parameters and for {@link dagger.Provides @Provides} and {@link
-               * dagger.producers.Produces @Produces} method parameters.
-               */
-              @Override
-              public String visitVariableAsParameter(
-                  VariableElement variable, DependencyRequest request) {
-                StringBuilder builder = new StringBuilder();
-                appendRequestedTypeIsInjectedAt(builder, request);
-
-                ExecutableElement methodOrConstructor =
-                    asExecutable(variable.getEnclosingElement());
-                appendEnclosingTypeAndMemberName(methodOrConstructor, builder).append('(');
-                List<? extends VariableElement> parameters = methodOrConstructor.getParameters();
-                int parameterIndex = parameters.indexOf(variable);
-                builder.append(
-                    formatArgumentInList(
-                        parameterIndex, parameters.size(), variable.getSimpleName()));
-                builder.append(')');
-                return builder.toString();
-              }
-
-              /** Returns the description for {@link javax.inject.Inject @Inject} fields. */
-              @Override
-              public String visitVariableAsField(
-                  VariableElement variable, DependencyRequest request) {
-                StringBuilder builder = new StringBuilder();
-                appendRequestedTypeIsInjectedAt(builder, request);
-                appendEnclosingTypeAndMemberName(variable, builder);
-                return builder.toString();
-              }
-
-              @Override
-              public String visitType(TypeElement e, DependencyRequest request) {
-                return ""; // types by themselves provide no useful information.
-              }
-
-              @Override
-              protected String defaultAction(Element element, DependencyRequest request) {
-                throw new IllegalStateException(
-                    "Invalid request " + element.getKind() + " element " + element);
-              }
-            },
-            request);
+        .map(element -> element.accept(formatVisitor, request))
+        .orElse("");
   }
 
-  @CanIgnoreReturnValue
-  private StringBuilder appendRequestedTypeIsInjectedAt(
-      StringBuilder builder, DependencyRequest request) {
-    TypeMirror requestedType = requestType(request.kind(), request.key().type(), types);
-    return builder
-        .append(INDENT)
-        .append(formatKey(request.key().qualifier(), requestedType))
-        .append(" is injected at\n")
-        .append(DOUBLE_INDENT);
-  }
-
-  private String formatKey(Key key) {
-    return formatKey(key.qualifier(), key.type());
-  }
-
-  private String formatKey(Optional<AnnotationMirror> qualifier, TypeMirror type) {
-    StringBuilder builder = new StringBuilder();
-    if (qualifier.isPresent()) {
-      builder.append(qualifier.get()).append(' ');
-    }
-    builder.append(type);
-    return builder.toString();
+  private final ElementVisitor<String, DependencyRequest> formatVisitor =
+      new ElementKindVisitor8<String, DependencyRequest>() {
+
+        @Override
+        public String visitExecutableAsMethod(ExecutableElement method, DependencyRequest request) {
+          return INDENT
+              + request.key()
+              + " is "
+              + componentMethodRequestVerb(request)
+              + " at\n"
+              + DOUBLE_INDENT
+              + elementToString(method);
+        }
+
+        @Override
+        public String visitVariable(VariableElement variable, DependencyRequest request) {
+          TypeMirror requestedType = requestType(request.kind(), request.key().type(), types);
+          return INDENT
+              + formatQualifier(request.key().qualifier())
+              + requestedType
+              + " is injected at\n"
+              + DOUBLE_INDENT
+              + elementToString(variable);
+        }
+
+        @Override
+        public String visitType(TypeElement e, DependencyRequest request) {
+          return ""; // types by themselves provide no useful information.
+        }
+
+        @Override
+        protected String defaultAction(Element element, DependencyRequest request) {
+          throw new IllegalStateException(
+              "Invalid request " + element.getKind() + " element " + element);
+        }
+      };
+
+  private String formatQualifier(Optional<AnnotationMirror> maybeQualifier) {
+    return maybeQualifier.map(qualifier -> qualifier + " ").orElse("");
   }
 
   /**
@@ -225,15 +164,6 @@ private String componentMethodRequestVerb(DependencyRequest request) {
     }
   }
 
-  @CanIgnoreReturnValue
-  private StringBuilder appendEnclosingTypeAndMemberName(Element member, StringBuilder builder) {
-    TypeElement type = MoreElements.asType(member.getEnclosingElement());
-    return builder
-        .append(type.getQualifiedName())
-        .append('.')
-        .append(member.getSimpleName());
-  }
-
   /**
    * Returns a string of the form "{@code @BindsOptionalOf SomeKey is declared at Module.method()}",
    * where {@code Module.method()} is the declaration. If there is more than one such declaration,
@@ -247,12 +177,11 @@ private String formatSyntheticOptionalBindingDependency(
     builder
         .append(INDENT)
         .append("@BindsOptionalOf ")
-        .append(formatKey(optionalBindingDeclaration.key()))
+        .append(optionalBindingDeclaration.key())
         .append(" is declared at\n")
-        .append(DOUBLE_INDENT);
+        .append(DOUBLE_INDENT)
+        .append(elementToString(optionalBindingDeclaration.bindingElement().get()));
 
-    appendEnclosingTypeAndMemberName(optionalBindingDeclaration.bindingElement().get(), builder);
-    builder.append("()");
     if (optionalBindingDeclarations.size() > 1) {
       builder.append(", among others");
     }
diff --git a/java/dagger/internal/codegen/ErrorMessages.java b/java/dagger/internal/codegen/ErrorMessages.java
index 9d408488a..23809da7b 100644
--- a/java/dagger/internal/codegen/ErrorMessages.java
+++ b/java/dagger/internal/codegen/ErrorMessages.java
@@ -42,11 +42,6 @@
  * The collection of error messages to be reported back to users.
  */
 final class ErrorMessages {
-  /*
-   * Common constants.
-   */
-  static final String INDENT = "    ";
-  static final String DOUBLE_INDENT = INDENT + INDENT;
   static final int DUPLICATE_SIZE_LIMIT = 10;
 
   /*
diff --git a/java/dagger/internal/codegen/Formatter.java b/java/dagger/internal/codegen/Formatter.java
index af8a183e3..176477e06 100644
--- a/java/dagger/internal/codegen/Formatter.java
+++ b/java/dagger/internal/codegen/Formatter.java
@@ -17,7 +17,6 @@
 package dagger.internal.codegen;
 
 import static com.google.common.base.Preconditions.checkElementIndex;
-import static dagger.internal.codegen.ErrorMessages.INDENT;
 
 import com.google.common.base.Function;
 import com.google.common.collect.Iterables;
@@ -30,6 +29,9 @@
  */
 abstract class Formatter<T> implements Function<T, String> {
 
+  static final String INDENT = "    ";
+  static final String DOUBLE_INDENT = INDENT + INDENT;
+
   /**
    * Performs the transformation of an object into a string representation.
    */
@@ -85,7 +87,7 @@ private void appendIndent(StringBuilder builder, int indentLevel) {
     }
   }
 
-  protected String formatArgumentInList(int index, int size, CharSequence name) {
+  static String formatArgumentInList(int index, int size, CharSequence name) {
     checkElementIndex(index, size);
     StringBuilder builder = new StringBuilder();
     if (index > 0) {
diff --git a/java/dagger/internal/codegen/MapMultibindingValidation.java b/java/dagger/internal/codegen/MapMultibindingValidation.java
index ff0df9f04..1f963717a 100644
--- a/java/dagger/internal/codegen/MapMultibindingValidation.java
+++ b/java/dagger/internal/codegen/MapMultibindingValidation.java
@@ -20,7 +20,7 @@
 import static dagger.internal.codegen.DaggerStreams.instancesOf;
 import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
 import static dagger.internal.codegen.ErrorMessages.DUPLICATE_SIZE_LIMIT;
-import static dagger.internal.codegen.ErrorMessages.INDENT;
+import static dagger.internal.codegen.Formatter.INDENT;
 import static dagger.model.BindingKind.MULTIBOUND_MAP;
 import static javax.tools.Diagnostic.Kind.ERROR;
 
diff --git a/java/dagger/internal/codegen/ValidationReport.java b/java/dagger/internal/codegen/ValidationReport.java
index 9fd2c734a..ef2142144 100644
--- a/java/dagger/internal/codegen/ValidationReport.java
+++ b/java/dagger/internal/codegen/ValidationReport.java
@@ -16,6 +16,7 @@
 
 package dagger.internal.codegen;
 
+import static dagger.internal.codegen.DaggerElements.elementToString;
 import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
 import static javax.tools.Diagnostic.Kind.ERROR;
 import static javax.tools.Diagnostic.Kind.NOTE;
@@ -31,8 +32,6 @@
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.AnnotationValue;
 import javax.lang.model.element.Element;
-import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.util.SimpleElementVisitor8;
 import javax.tools.Diagnostic;
 import javax.tools.Diagnostic.Kind;
 
@@ -113,7 +112,7 @@ void printMessagesTo(Messager messager) {
           messager.printMessage(item.kind(), item.message(), item.element());
         }
       } else {
-        String message = String.format("[%s] %s", elementString(item.element()), item.message());
+        String message = String.format("[%s] %s", elementToString(item.element()), item.message());
         messager.printMessage(item.kind(), message, subject());
       }
     }
@@ -122,22 +121,6 @@ void printMessagesTo(Messager messager) {
     }
   }
 
-  private static String elementString(Element element) {
-    return element.accept(
-        new SimpleElementVisitor8<String, Void>() {
-          @Override
-          protected String defaultAction(Element e, Void p) {
-            return e.toString();
-          }
-
-          @Override
-          public String visitExecutable(ExecutableElement e, Void p) {
-            return e.getEnclosingElement().accept(this, null) + '.' + e;
-          }
-        },
-        null);
-  }
-
   private static boolean isEnclosedIn(Element parent, Element child) {
     Element current = child;
     while (current != null) {
diff --git a/javatests/dagger/internal/codegen/GraphValidationTest.java b/javatests/dagger/internal/codegen/GraphValidationTest.java
index 93f1df27c..a838c12aa 100644
--- a/javatests/dagger/internal/codegen/GraphValidationTest.java
+++ b/javatests/dagger/internal/codegen/GraphValidationTest.java
@@ -208,7 +208,7 @@ public void membersInjectDependsOnUnboundedType() {
                     "      dagger.MembersInjector<java.util.ArrayList<?>> is injected at",
                     "          test.InjectsUnboundedType.listInjector",
                     "      test.InjectsUnboundedType is injected at",
-                    "          test.TestComponent.injectsUnboundedType(injects)"))
+                    "          test.TestComponent.injectsUnboundedType(test.InjectsUnboundedType)"))
         .in(component)
         .onLine(7);
   }
@@ -859,17 +859,18 @@ public void cycleFromMembersInjectionMethod_WithSameKeyAsMembersInjectionMethod(
     Compilation compilation = daggerCompiler().compile(a, b, component);
     assertThat(compilation).failed();
     assertThat(compilation)
-        .hadErrorContaining(Joiner.on('\n')
-            .join(
-                "Found a dependency cycle:",
-                "      test.B is injected at",
-                "          test.A.b",
-                "      test.A is injected at",
-                "          test.B.a",
-                "      test.B is injected at",
-                "          test.A.b",
-                "      test.A is injected at",
-                "          test.CycleComponent.inject(a)"))
+        .hadErrorContaining(
+            Joiner.on('\n')
+                .join(
+                    "Found a dependency cycle:",
+                    "      test.B is injected at",
+                    "          test.A.b",
+                    "      test.A is injected at",
+                    "          test.B.a",
+                    "      test.B is injected at",
+                    "          test.A.b",
+                    "      test.A is injected at",
+                    "          test.CycleComponent.inject(test.A)"))
         .inFile(component)
         .onLineContaining("void inject(A a);");
   }
@@ -1368,52 +1369,50 @@ public void duplicateExplicitBindings_UniqueBindingAndMultibindingDeclaration()
             "}");
     String errorText = "test.TestClass.A cannot be provided without an @Provides-annotated method.";
     String firstError =
-        Joiner.on("\n      ")
-            .join(
-                errorText,
-                "test.TestClass.A is injected at",
-                "    test.TestClass.B.<init>(a)",
-                "test.TestClass.B is injected at",
-                "    test.TestClass.C.b",
-                "test.TestClass.C is injected at",
-                "    test.TestClass.DImpl.<init>(c, …)",
-                "test.TestClass.DImpl is injected at",
-                "    test.TestClass.DModule.d(…, impl, …)",
-                "@javax.inject.Named(\"slim shady\") test.TestClass.D is provided at",
-                "    test.TestClass.AComponent.getFoo()");
+        error(
+            errorText,
+            "test.TestClass.A is injected at",
+            "    test.TestClass.B.<init>(a)",
+            "test.TestClass.B is injected at",
+            "    test.TestClass.C.b",
+            "test.TestClass.C is injected at",
+            "    test.TestClass.DImpl.<init>(c, …)",
+            "test.TestClass.DImpl is injected at",
+            "    test.TestClass.DModule.d(…, impl, …)",
+            "@javax.inject.Named(\"slim shady\") test.TestClass.D is provided at",
+            "    test.TestClass.AComponent.getFoo()");
     String otherErrorFormat =
-        Joiner.on("\n      ")
-            .join(
-                errorText,
-                "test.TestClass.A is injected at",
-                "    test.TestClass.B.<init>(a)",
-                "test.TestClass.B is injected at",
-                "    test.TestClass.C.b",
-                "test.TestClass.C is %s at",
-                "    test.TestClass.AComponent.%s");
-    assertAbout(javaSource())
-        .that(component)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(firstError)
-        .in(component)
-        .onLine(40)
-        .and()
-        .withErrorContaining(String.format(otherErrorFormat, "injected", "injectC(c)"))
-        .in(component)
-        .onLine(41)
-        .and()
-        .withErrorContaining(String.format(otherErrorFormat, "provided", "cProvider()"))
-        .in(component)
-        .onLine(42)
-        .and()
-        .withErrorContaining(String.format(otherErrorFormat, "provided", "lazyC()"))
-        .in(component)
-        .onLine(43)
-        .and()
-        .withErrorContaining(String.format(otherErrorFormat, "provided", "lazyCProvider()"))
-        .in(component)
-        .onLine(44);
+        error(
+            errorText,
+            "test.TestClass.A is injected at",
+            "    test.TestClass.B.<init>(a)",
+            "test.TestClass.B is injected at",
+            "    test.TestClass.C.b",
+            "test.TestClass.C is %s at",
+            "    test.TestClass.AComponent.%s");
+    Compilation compilation = daggerCompiler().compile(component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(firstError)
+        .inFile(component)
+        .onLineContaining("getFoo();");
+    assertThat(compilation)
+        .hadErrorContaining(
+            String.format(otherErrorFormat, "injected", "injectC(test.TestClass.C)"))
+        .inFile(component)
+        .onLineContaining("injectC(C c);");
+    assertThat(compilation)
+        .hadErrorContaining(String.format(otherErrorFormat, "provided", "cProvider()"))
+        .inFile(component)
+        .onLineContaining("cProvider();");
+    assertThat(compilation)
+        .hadErrorContaining(String.format(otherErrorFormat, "provided", "lazyC()"))
+        .inFile(component)
+        .onLineContaining("lazyC();");
+    assertThat(compilation)
+        .hadErrorContaining(String.format(otherErrorFormat, "provided", "lazyCProvider()"))
+        .inFile(component)
+        .onLineContaining("lazyCProvider();");
   }
 
   @Test
